/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_10F20();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int printf(const char *format, ...);
// int _isoc99_fscanf(_DWORD, const char *, ...); weak
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __off_t lseek(int fd, __off_t offset, int whence);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned int sleep(unsigned int seconds);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int pthread_cond_destroy(pthread_cond_t *cond);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int puts(const char *s);
// void *malloc(size_t size);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// char *strerror(int errnum);
// struct tm *localtime(const time_t *timer);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// void exit(int status);
// int feof(FILE *stream);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int *_errno_location(void);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// int pthread_cancel(pthread_t th);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// int pthread_join(pthread_t th, void **thread_return);
// int sprintf(char *s, const char *format, ...);
// int remove(const char *filename);
// int atoi(const char *nptr);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// double atof(const char *nptr);
// void pthread_testcancel(void);
// int fseek(FILE *stream, int off, int whence);
// int isatty(int fd);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// int close(int fd);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_weak_fn();
int *deregister_tm_clones();
int register_tm_clones(); // idb
int *_do_global_dtors_aux();
int frame_dummy(); // idb
uint8_t __cdecl get_bt8d_from_baud(const uint32_t baud);
void __cdecl get_plldata(uint32_t freq, uint32_t *vil_data);
int __cdecl makeup_work_pkg(uint8_t *str, uint8_t *work_str);
int __cdecl makeup_set_address_cmd(uint8_t *str, uint32_t str_len, uint8_t chip_addr);
int __cdecl makeup_set_config_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr, uint32_t regdata);
int __cdecl makeup_get_status_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr);
int __cdecl makeup_chain_inactive_cmd(uint8_t *str, uint32_t str_len);
int __cdecl bm174x_pack_ioctl_pkg(uint8_t *str, uint32_t str_len, uint32_t oper_type, void *param);
int __cdecl bm174x_ioctl(int fd, uint32_t oper_type, void *param);
void __cdecl bm174x_read_register(int fd, int mode, uint8_t chip_addr, uint8_t reg_addr);
void __cdecl bm174x_write_register(int fd, int mode, uint8_t chip_addr, uint8_t reg_addr, uint32_t reg_data);
void __cdecl bm174x_set_ticket_mask(int fd, uint32_t tm);
void __cdecl bm174x_set_frequency(int fd, uint32_t freq);
void __cdecl bm174x_set_io_drive_strength(int fd, uint32_t value);
void __cdecl bm174x_set_baud(int fd, int baudrate);
void __cdecl bm174x_chain_inactive(int fd);
void __cdecl bm174x_set_address(int fd, uint8_t address);
void __cdecl bm174x_set_core_timeout(int fd, uint32_t timeout);
void __cdecl bm174x_set_txn_data(int fd, uint32_t txn_data);
void __cdecl bm174x_set_nonce_shift(int fd, uint32_t nonce_shift, uint32_t *outer_shift);
void __cdecl bm174x_set_vmount(int fd, int vmount);
void __cdecl bm174x_set_pt_ctrl(int fd, int pt_num, int pt_en);
void __cdecl bm174x_set_pt_result(int fd, int ptr_grp_num, int ptr_rd);
void __cdecl bm174x_i2c_enable(int fd, uint8_t chip_addr);
void __cdecl bm174x_i2c_status(int fd, uint8_t chip_addr);
int __cdecl bm174x_i2c_recv(int fd, uint8_t chip_addr, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, int len);
void __cdecl bm174x_i2c_send(int fd, uint8_t chip_addr, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, uint8_t *reg_data, int len);
void __cdecl bm174x_send_work(int fd, uint8_t *buf);
void __cdecl bm174x_pm_handle(uint8_t *str, int len, uint8_t chainid);
void __cdecl bm174x_pt_handle(uint8_t *str, int len, uint8_t chainid);
void __cdecl bm174x_reg_handle(uint8_t *str, int len, uint8_t chainid);
int __cdecl bm174x_nonce_integrality(uint8_t chipid, uint8_t nonce_array_id, int chainid);
int __cdecl bm174x_nonce_handle(uint8_t *str, int len, uint32_t chainid, int addr_interval);
int __cdecl bm174x_init_asic(void *args);
void __cdecl delay(int seconds);
void __cdecl check_asic_num(runtime_base_t *runtime);
void __cdecl set_asic_address(runtime_base_t *runtime, unsigned __int8 chainid);
int __cdecl calc_asic_addr_interval(int actual_asic_number);
void __cdecl user_i2c_enable(runtime_base_t *runtime, unsigned __int8 chainid);
int __cdecl user_i2c_state(runtime_base_t *runtime, int chip_addr);
int __cdecl user_read_iic(runtime_base_t *runtime, int chip_addr, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, uint8_t *i2c_reg_data, int len);
void __cdecl user_send_work(runtime_base_t *runtime, uint8_t *header, int sno_valid, int test_patten);
void __cdecl online_mining(runtime_base_t *runtime);
int __cdecl pattern_test(runtime_base_t *runtime, int freq, int *nonce);
int __cdecl pattern_test_mode2(runtime_base_t *runtime, int freq, int *nonce);
int __cdecl user_asic_init(runtime_base_t *runtime);
int __cdecl user_check_communication(runtime_base_t *runtime);
void __cdecl env_init(runtime_base_t *runtime);
void __cdecl randomize(void *p, int l);
void __cdecl set_blocking_mode(int fd, int block);
uint8_t __cdecl hex2val(const unsigned __int8 *base, size_t off);
unsigned __int8 *__cdecl s_hexdump(const void *_a, uint32_t a_len);
void __cdecl hexdump(const unsigned __int8 *p, unsigned int len);
uint32_t __cdecl print_solver_line(uint8_t *soln, uint8_t *header, int fixed_nonce_bytes, unsigned __int8 *job_id);
void *__cdecl memrchr(const void *s, int c, size_t n);
int __cdecl read_last_line(unsigned __int8 *buf, size_t len, int block);
void __cdecl mining_parse_job(unsigned __int8 *str, uint8_t *target, int target_len, unsigned __int8 *job_id, int job_id_len, uint8_t *header, int header_len, int *fixed_nonce_bytes);
void *__cdecl mining_mode(void *args);
__int64 miner_now();
void __cdecl equihash_nonce_submit(uint8_t *nonce, uint8_t *verify, int fixed_nonce_bytes, unsigned __int8 *job_id);
void __cdecl equihash_miner_init(runtime_base_t *runtime);
void __cdecl equihash_miner_start(runtime_base_t *runtime);
void equihash_miner_join(); // idb
unsigned int __cdecl _bswap_32(unsigned int __bsx);
void __cdecl compressArray(const unsigned __int8 *in, const size_t in_len, unsigned __int8 *out, const size_t out_len, const size_t bit_len, const size_t byte_pad);
void __cdecl expandArray(const unsigned __int8 *in, const size_t in_len, unsigned __int8 *out, const size_t out_len, const size_t bit_len, const size_t byte_pad);
int __cdecl getIndices(const uint8_t *hash, size_t len, size_t lenIndices, size_t cBitLen, uint8_t *data, size_t maxLen);
int __cdecl isZero(const uint8_t *hash, size_t len);
void __cdecl generateHash(blake2b_state *S, const uint32_t g, uint8_t *hash, const size_t hashLen);
int __cdecl compareSR(const void *p1, const void *p2);
void __cdecl sort_pair(uint32_t *a, uint32_t len);
int __cdecl sortValidator(void *data, const unsigned __int8 *soln);
void __cdecl zcashPerson(uint8_t *person, const int n, const int k);
void __cdecl digestInit(blake2b_state *S, const int n, const int k);
uint32_t __cdecl target_zero_cal(uint8_t *target);
bool __cdecl equihash_target_match(unsigned __int8 *result_value, unsigned __int8 *target);
uint32_t __cdecl targetValidator(const uint8_t *work, const uint8_t *nonce, uint8_t *target);
int __cdecl equihash_nonce_verify(nonce_verify_info_t *verify_info, int *tm, uint32_t shift);
void __cdecl equihash_init_algo(void *args);
void pcba_app_manual_test(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len);
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len);
int bitmain_axi_init(); // idb
void bitmain_axi_close(); // idb
unsigned int __cdecl read_axi_fpga(unsigned int address);
void __cdecl write_axi_fpga(unsigned int address, unsigned int data);
void init_fpga(); // idb
void __cdecl get_return_nonce(unsigned int *buf);
void __cdecl set_BC_command_buffer(unsigned int *value);
unsigned int get_BC_write_command(); // idb
void __cdecl set_BC_write_command(unsigned int value);
unsigned __int8 __cdecl asic_baud_to_fpga_baud(unsigned __int8 asic_baud);
void __cdecl set_fpga_baud(unsigned __int8 asic_baud);
void __cdecl i2c_write(unsigned int config_data);
unsigned __int8 __cdecl i2c_read(unsigned int config_data);
int __cdecl ISL_page_enable(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t which_page);
int __cdecl ISL_on(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int __cdecl ISL_off(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int __cdecl ISL_set_on_off_config(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t config);
int __cdecl ISL_set_clear_faults(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int __cdecl ISL_set_write_protect(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t mode);
int __cdecl ISL_set_vout_command(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage);
int __cdecl ISL_set_apply_settings(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int __cdecl ISL_get_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t *voltage);
int __cdecl ISL_read_reg_default(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
uint16_t __cdecl ISL_set_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage);
int open_key(); // idb
void close_key(); // idb
ssize_t __cdecl read_key(unsigned __int8 value);
int open_lcd(); // idb
int close_lcd(); // idb
void __cdecl write_lcd(unsigned int line, unsigned __int8 *buf, unsigned int size);
void __cdecl write_lcd_no_memset(unsigned int line, unsigned __int8 *buf, unsigned int size);
int open_red_led(); // idb
void close_red_led(); // idb
void red_led_on(); // idb
void red_led_off(); // idb
int open_green_led(); // idb
void close_green_led(); // idb
void green_led_on(); // idb
void green_led_off(); // idb
void __cdecl write_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data);
unsigned __int8 __cdecl read_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain);
int __cdecl write_dc_dc(void *args, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t reg, uint8_t *data, int len);
int __cdecl read_dc_dc(void *args, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t reg, uint8_t *value, int len);
int __cdecl set_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 flash_addr_h, unsigned __int8 flash_addr_l);
int __cdecl send_data_to_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl read_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *flash_addr_h, unsigned __int8 *flash_addr_l);
int __cdecl read_PIC16F1704_flash_data(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl erase_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl write_data_into_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl jump_from_loader_to_app_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c);
int __cdecl reset_PIC16F1704_pic(unsigned int which_chain, unsigned __int8 which_i2c);
int __cdecl set_PIC16F1704_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage);
int __cdecl write_hash_ID_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 *buf);
int __cdecl read_hash_id_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl enable_PIC16F1704_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable);
int __cdecl heart_beat_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c);
void *__cdecl pic_heart_beat_func(void *arg);
int __cdecl get_PIC16F1704_software_version(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *version);
int __cdecl PIC16F1704_i2c_forward_send(uint32_t i2c, uint8_t chain, uint8_t dev_addr, int rw_flag, uint8_t reg_addr, int len, uint8_t *data);
void __cdecl set_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain, uint16_t vol);
void __cdecl get_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain);
int __cdecl get_PIC16F1704_voltage(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *voltage);
int __cdecl write_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl read_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl erase_PIC16F1704_app_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl PIC1704_update_pic_app_program(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl save_freq_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 freq);
int __cdecl get_PIC16F1704_freq(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 *freq);
void __cdecl set_temperature_offset_value(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *value);
int __cdecl write_PIC16F1705_iic_slave(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf, unsigned __int8 buf_len);
int __cdecl read_PIC16F1705_iic_slave(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf, unsigned __int8 buf_len, unsigned __int8 *read_back_buf);
int __cdecl write_data_to_PIC16F1704_flash(int which_chain, int which_i2c, unsigned __int8 *buf, int buf_len);
int __cdecl read_data_from_PIC16F1704_flash(int which_chain, int which_i2c, unsigned __int8 *buf, unsigned __int8 read_len);
unsigned int get_fan_speed(); // idb
void __cdecl set_fan_speed(unsigned int speed);
void __cdecl fan_control(unsigned __int8 level);
int __cdecl uart_init(int comport, int baud);
int __cdecl uart_exit(int fd);
unsigned int __cdecl check_how_many_uart_data_in_fpga(unsigned __int8 which_uart);
unsigned int __cdecl read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length);
unsigned int __cdecl uart_send(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length);
unsigned int __cdecl uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length);
unsigned int __cdecl clear_uart_send_fifo(unsigned __int8 which_chain);
unsigned int __cdecl clear_uart_rx_fifo(unsigned __int8 which_chain);
int __cdecl baud2bt8d(unsigned int baud);
int __cdecl cgpu_init(runtime_base_t *runtime);
void cgpu_exit(); // idb
int __cdecl v9_key_read(unsigned __int8 *command, int len);
void display_arguments(); // idb
void init_pcba_args(); // idb
int check_chain(); // idb
void *read_all_sensor(); // idb
void start_read_temp(); // idb
void stop_read_temp(); // idb
void show_result(); // idb
void V9_print_lcd(); // idb
void __cdecl V9_print_lcd_type(int type);
int __cdecl is_asic_pass(int index);
void __noreturn show_stats_func_z15_3chips();
int bm1744_hashboard_init(); // idb
void singleboard_pattern_test(); // idb
void *__cdecl check_nonce(void *args);
void *__cdecl check_nonce_loop(void *args);
int __cdecl vol_init(unsigned __int16 vol);
void __cdecl pcba_runtime_init(runtime_base_t *runtime);
void __cdecl pcba_runtime_exit(runtime_base_t *runtime);
void start_single_board_test(); // idb
int singleBoardTest_Z15_BM1746(); // idb
int __cdecl parse_config_ini_array(const unsigned __int8 *str, void **pointer);
int __cdecl app_config_handle(app_config_t *m_conf, unsigned __int8 *config_filename);
app_config_t *__cdecl app_config_init(unsigned __int8 *config_filename);
void __cdecl app_config_exit(app_config_t *conf);
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force);
void __cdecl applog(int prio, const unsigned __int8 *str, bool force);
void __cdecl simplelog(int prio, const unsigned __int8 *str, bool force);
void patten_info_init(); // idb
void patten_info_destory(); // idb
void __cdecl patten_load(unsigned __int8 *root_path);
int __cdecl is_patten_match(int asic_index, uint8_t *nonce, uint8_t *sol);
void display_single_board_test(); // idb
void clear_last_test_results(); // idb
uint16_t __cdecl rt_ringbuffer_get_size(rt_ringbuffer *rb);
RINGBUFFER_STATE __cdecl rt_ringbuffer_status(rt_ringbuffer *rb);
uint16_t __cdecl rt_ringbuffer_data_len(rt_ringbuffer *rb);
void __cdecl rt_ringbuffer_init(rt_ringbuffer *rb, uint8_t *pool, int16_t size, ringbuffer_type_t ringbuffer_type);
void __cdecl rt_ringbuffer_lock_destory(rt_ringbuffer *rb);
uint32_t __cdecl rt_ringbuffer_put(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length);
uint32_t __cdecl rt_ringbuffer_put_force(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length);
uint32_t __cdecl rt_ringbuffer_get(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length);
uint32_t __cdecl rt_ringbuffer_prefetch(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length);
void __cdecl get_current_time(unsigned __int8 *dtime);
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len);
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len);
int __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len);
unsigned __int8 __cdecl swap_bit(unsigned __int8 chr);
void __cdecl dump_str(void *fdp, const unsigned __int8 *func, unsigned __int8 *str, int len);
unsigned __int8 __cdecl bit_read(unsigned __int8 *y, int x);
void __cdecl swab256(void *dest_p, void *src_p);
uint64_t __cdecl load64(const void *src);
void __cdecl store32(void *dst, uint32_t w);
void __cdecl store64(void *dst, uint64_t w);
uint64_t __cdecl rotr64(const uint64_t w, const unsigned int c);
void __cdecl secure_zero_memory(void *v, size_t n);
int __cdecl blake2b_set_lastnode(blake2b_state *S);
int __cdecl blake2b_is_lastblock(const blake2b_state *S);
int __cdecl blake2b_set_lastblock(blake2b_state *S);
int __cdecl blake2b_increment_counter(blake2b_state *S, const uint64_t inc);
int __cdecl blake2b_init0(blake2b_state *S);
int __cdecl blake2b_init_param(blake2b_state *S, const blake2b_param *P);
int __cdecl blake2b_init(blake2b_state *S, const uint8_t outlen);
int __cdecl blake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen);
int __cdecl blake2b_compress(blake2b_state *S, const uint8_t *block);
int __cdecl blake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen);
int __cdecl blake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen);
int __cdecl blake2b(uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen);
unsigned __int16 __cdecl crc_itu_t_byte(unsigned __int16 crc, const unsigned __int8 data);
unsigned __int16 __cdecl CRC16_v1(const unsigned __int8 *buffer, int len);
unsigned __int8 __cdecl CRC5_v1(unsigned __int8 *ptr, unsigned __int8 len);
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __cdecl Sha256_Init(CSha256 *p);
void __cdecl Sha256_Transform(uint32_t *state, const uint32_t *data);
void __cdecl Sha256_WriteByteBlock(CSha256 *p);
void __cdecl Sha256_Update(CSha256 *p, const uint8_t *data, size_t size);
void __cdecl Sha256_Final(CSha256 *p, uint8_t *digest);
void __cdecl Sha256_Onestep(const uint8_t *data, size_t size, uint8_t *digest);
void __cdecl sha2_starts(sha2_context *ctx);
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
uint32_t __cdecl swab32(uint32_t v);
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length);
void __cdecl flip32(void *dest_p, const void *src_p);
void __cdecl push_nonce(nonce_rb_format *nonce_item);
void clear_register_value_buf(); // idb
void __cdecl pop_nonce(nonce_rb_format *nonce_tmp);
void __cdecl nonce_fifo_num(int *num);
int __cdecl add_reg_item(reg_list_item_t item);
int __cdecl read_reg_item(reg_list_item_t *item, int ms);
void *reg_list_aging(); // idb
void reg_list_init(); // idb
void reg_list_exit(); // idb
void *__cdecl nonce_scanhash(void *args);
void *__cdecl nonce_scanhash_loop(void *args);
void __cdecl add_point(int *point, int MAX_SIZE);
void *__cdecl handle_asic_response(void *args);
void __cdecl runtime_init(runtime_base_t *runtime);
void __cdecl runtime_exit(runtime_base_t *runtime);
void __cdecl work_list_init(int work_len);
void work_list_exit(); // idb
void __cdecl work_list_insert(uint8_t workid, uint8_t *work);
void __cdecl work_list_find(uint8_t workid, uint8_t *work);
int __fastcall divsi3_skip_div0_test(int result, unsigned int); // idb
int _aeabi_ldiv0();
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_255C0; // weak
_UNKNOWN loc_255C8; // weak
_UNKNOWN loc_255D0; // weak
_UNKNOWN loc_255D8; // weak
_UNKNOWN loc_255DC; // weak
_UNKNOWN loc_255E0; // weak
_UNKNOWN loc_255E4; // weak
_UNKNOWN locret_255E8; // weak
_UNKNOWN loc_255EC; // weak
_UNKNOWN loc_255F0; // weak
_UNKNOWN loc_255F4; // weak
_UNKNOWN loc_33C00; // weak
const unsigned __int8 _func___7412[23] =
{
  109u,
  97u,
  107u,
  101u,
  117u,
  112u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  95u,
  99u,
  109u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___7423[22] =
{
  109u,
  97u,
  107u,
  101u,
  117u,
  112u,
  95u,
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  95u,
  99u,
  109u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___7434[22] =
{
  109u,
  97u,
  107u,
  101u,
  117u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  99u,
  109u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___7441[26] =
{
  109u,
  97u,
  107u,
  101u,
  117u,
  112u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  105u,
  110u,
  97u,
  99u,
  116u,
  105u,
  118u,
  101u,
  95u,
  99u,
  109u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___7601[17] =
{
  98u,
  109u,
  49u,
  55u,
  52u,
  120u,
  95u,
  112u,
  109u,
  95u,
  104u,
  97u,
  110u,
  100u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___7611[17] =
{
  98u,
  109u,
  49u,
  55u,
  52u,
  120u,
  95u,
  112u,
  116u,
  95u,
  104u,
  97u,
  110u,
  100u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___7627[18] =
{
  98u,
  109u,
  49u,
  55u,
  52u,
  120u,
  95u,
  114u,
  101u,
  103u,
  95u,
  104u,
  97u,
  110u,
  100u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___7636[25] =
{
  98u,
  109u,
  49u,
  55u,
  52u,
  120u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  105u,
  110u,
  116u,
  101u,
  103u,
  114u,
  97u,
  108u,
  105u,
  116u,
  121u,
  0u
}; // idb
const unsigned __int8 _func___7272[25] =
{
  117u,
  115u,
  101u,
  114u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  99u,
  111u,
  109u,
  109u,
  117u,
  110u,
  105u,
  99u,
  97u,
  116u,
  105u,
  111u,
  110u,
  0u
}; // idb
_UNKNOWN unk_346C4; // weak
const unsigned __int8 _func___7604[15] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  108u,
  97u,
  115u,
  116u,
  95u,
  108u,
  105u,
  110u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7623[17] =
{
  109u,
  105u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  106u,
  111u,
  98u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7349[14] =
{
  99u,
  111u,
  109u,
  112u,
  114u,
  101u,
  115u,
  115u,
  65u,
  114u,
  114u,
  97u,
  121u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7371[12] = { 101u, 120u, 112u, 97u, 110u, 100u, 65u, 114u, 114u, 97u, 121u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___7397[11] = { 103u, 101u, 116u, 73u, 110u, 100u, 105u, 99u, 101u, 115u, 0u }; // idb
const uint8_t chCRCHTalbe[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // idb
const uint8_t chCRCLTalbe[256] =
{
  0u,
  192u,
  193u,
  1u,
  195u,
  3u,
  2u,
  194u,
  198u,
  6u,
  7u,
  199u,
  5u,
  197u,
  196u,
  4u,
  204u,
  12u,
  13u,
  205u,
  15u,
  207u,
  206u,
  14u,
  10u,
  202u,
  203u,
  11u,
  201u,
  9u,
  8u,
  200u,
  216u,
  24u,
  25u,
  217u,
  27u,
  219u,
  218u,
  26u,
  30u,
  222u,
  223u,
  31u,
  221u,
  29u,
  28u,
  220u,
  20u,
  212u,
  213u,
  21u,
  215u,
  23u,
  22u,
  214u,
  210u,
  18u,
  19u,
  211u,
  17u,
  209u,
  208u,
  16u,
  240u,
  48u,
  49u,
  241u,
  51u,
  243u,
  242u,
  50u,
  54u,
  246u,
  247u,
  55u,
  245u,
  53u,
  52u,
  244u,
  60u,
  252u,
  253u,
  61u,
  255u,
  63u,
  62u,
  254u,
  250u,
  58u,
  59u,
  251u,
  57u,
  249u,
  248u,
  56u,
  40u,
  232u,
  233u,
  41u,
  235u,
  43u,
  42u,
  234u,
  238u,
  46u,
  47u,
  239u,
  45u,
  237u,
  236u,
  44u,
  228u,
  36u,
  37u,
  229u,
  39u,
  231u,
  230u,
  38u,
  34u,
  226u,
  227u,
  35u,
  225u,
  33u,
  32u,
  224u,
  160u,
  96u,
  97u,
  161u,
  99u,
  163u,
  162u,
  98u,
  102u,
  166u,
  167u,
  103u,
  165u,
  101u,
  100u,
  164u,
  108u,
  172u,
  173u,
  109u,
  175u,
  111u,
  110u,
  174u,
  170u,
  106u,
  107u,
  171u,
  105u,
  169u,
  168u,
  104u,
  120u,
  184u,
  185u,
  121u,
  187u,
  123u,
  122u,
  186u,
  190u,
  126u,
  127u,
  191u,
  125u,
  189u,
  188u,
  124u,
  180u,
  116u,
  117u,
  181u,
  119u,
  183u,
  182u,
  118u,
  114u,
  178u,
  179u,
  115u,
  177u,
  113u,
  112u,
  176u,
  80u,
  144u,
  145u,
  81u,
  147u,
  83u,
  82u,
  146u,
  150u,
  86u,
  87u,
  151u,
  85u,
  149u,
  148u,
  84u,
  156u,
  92u,
  93u,
  157u,
  95u,
  159u,
  158u,
  94u,
  90u,
  154u,
  155u,
  91u,
  153u,
  89u,
  88u,
  152u,
  136u,
  72u,
  73u,
  137u,
  75u,
  139u,
  138u,
  74u,
  78u,
  142u,
  143u,
  79u,
  141u,
  77u,
  76u,
  140u,
  68u,
  132u,
  133u,
  69u,
  135u,
  71u,
  70u,
  134u,
  130u,
  66u,
  67u,
  131u,
  65u,
  129u,
  128u,
  64u
}; // idb
const unsigned __int8 _FUNCTION___7417[18] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  97u,
  120u,
  105u,
  95u,
  99u,
  108u,
  111u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7433[10] = { 105u, 110u, 105u, 116u, 95u, 102u, 112u, 103u, 97u, 0u }; // idb
const unsigned __int8 _FUNCTION___7452[21] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7466[23] =
{
  97u,
  115u,
  105u,
  99u,
  95u,
  98u,
  97u,
  117u,
  100u,
  95u,
  116u,
  111u,
  95u,
  102u,
  112u,
  103u,
  97u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___5997[9] = { 114u, 101u, 97u, 100u, 95u, 107u, 101u, 121u, 0u }; // idb
const unsigned __int8 _FUNCTION___6626[10] = { 119u, 114u, 105u, 116u, 101u, 95u, 108u, 99u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___6637[20] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  108u,
  99u,
  100u,
  95u,
  110u,
  111u,
  95u,
  109u,
  101u,
  109u,
  115u,
  101u,
  116u,
  0u
}; // idb
const uint8_t isl68127_i2c_dev_addr[4] = { 80u, 81u, 84u, 85u }; // idb
const unsigned __int8 _func___6668[12] = { 119u, 114u, 105u, 116u, 101u, 95u, 100u, 99u, 95u, 100u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___6683[12] = { 119u, 114u, 105u, 116u, 101u, 95u, 100u, 99u, 95u, 100u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___6709[11] = { 114u, 101u, 97u, 100u, 95u, 100u, 99u, 95u, 100u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___6733[29] =
{
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  95u,
  112u,
  111u,
  105u,
  110u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6759[24] =
{
  115u,
  101u,
  110u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  116u,
  111u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6780[30] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  95u,
  112u,
  111u,
  105u,
  110u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6801[27] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6825[23] =
{
  101u,
  114u,
  97u,
  115u,
  101u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6844[33] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  105u,
  110u,
  116u,
  111u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6863[35] =
{
  106u,
  117u,
  109u,
  112u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  108u,
  111u,
  97u,
  100u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  97u,
  112u,
  112u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6882[21] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6902[23] =
{
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6928[25] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  73u,
  68u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6948[24] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  105u,
  100u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6973[24] =
{
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  100u,
  99u,
  95u,
  100u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6992[22] =
{
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7019[32] =
{
  103u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7097[23] =
{
  103u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7125[36] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7145[35] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7164[27] =
{
  101u,
  114u,
  97u,
  115u,
  101u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  97u,
  112u,
  112u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7186[31] =
{
  80u,
  73u,
  67u,
  49u,
  55u,
  48u,
  52u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  97u,
  112u,
  112u,
  95u,
  112u,
  114u,
  111u,
  103u,
  114u,
  97u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7217[21] =
{
  115u,
  97u,
  118u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7237[20] =
{
  103u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7247[29] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7261[27] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  53u,
  95u,
  105u,
  105u,
  99u,
  95u,
  115u,
  108u,
  97u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7291[26] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  53u,
  95u,
  105u,
  105u,
  99u,
  95u,
  115u,
  108u,
  97u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7323[31] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  116u,
  111u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7356[32] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _func___6707[10] = { 117u, 97u, 114u, 116u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _func___6712[10] = { 117u, 97u, 114u, 116u, 95u, 101u, 120u, 105u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___6728[33] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  104u,
  111u,
  119u,
  95u,
  109u,
  97u,
  110u,
  121u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  105u,
  110u,
  95u,
  102u,
  112u,
  103u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6754[23] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  105u,
  110u,
  95u,
  102u,
  112u,
  103u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6793[10] = { 117u, 97u, 114u, 116u, 95u, 115u, 101u, 110u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___6827[21] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  105u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6852[19] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  114u,
  120u,
  95u,
  102u,
  105u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___6866[10] = { 98u, 97u, 117u, 100u, 50u, 98u, 116u, 56u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___8581[10] = { 99u, 103u, 112u, 117u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___8617[12] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 104u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___8689[22] =
{
  98u,
  109u,
  49u,
  55u,
  52u,
  52u,
  95u,
  104u,
  97u,
  115u,
  104u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___8701[25] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  112u,
  97u,
  116u,
  116u,
  101u,
  114u,
  110u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___8761[18] =
{
  112u,
  99u,
  98u,
  97u,
  95u,
  114u,
  117u,
  110u,
  116u,
  105u,
  109u,
  101u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___8766[18] =
{
  112u,
  99u,
  98u,
  97u,
  95u,
  114u,
  117u,
  110u,
  116u,
  105u,
  109u,
  101u,
  95u,
  101u,
  120u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___8774[27] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  66u,
  111u,
  97u,
  114u,
  100u,
  84u,
  101u,
  115u,
  116u,
  95u,
  90u,
  49u,
  53u,
  95u,
  66u,
  77u,
  49u,
  55u,
  52u,
  54u,
  0u
}; // idb
unsigned __int8 byte_36C3C[4] = { 0u, 0u, 0u, 0u }; // weak
const unsigned __int8 _func___6575[17] =
{
  112u,
  97u,
  116u,
  116u,
  101u,
  110u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const int hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // idb
const unsigned __int8 hex_6251[16] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u
}; // idb
const uint64_t blake2b_IV[8] =
{
  7640891576956012808uLL,
  13503953896175478587uLL,
  4354685564936845355uLL,
  11912009170470909681uLL,
  5840696475078001361uLL,
  11170449401992604703uLL,
  2270897969802886507uLL,
  6620516959819538809uLL
}; // idb
const unsigned __int16 crc_itu_t_table[256] =
{
  0u,
  4129u,
  8258u,
  12387u,
  16516u,
  20645u,
  24774u,
  28903u,
  33032u,
  37161u,
  41290u,
  45419u,
  49548u,
  53677u,
  57806u,
  61935u,
  4657u,
  528u,
  12915u,
  8786u,
  21173u,
  17044u,
  29431u,
  25302u,
  37689u,
  33560u,
  45947u,
  41818u,
  54205u,
  50076u,
  62463u,
  58334u,
  9314u,
  13379u,
  1056u,
  5121u,
  25830u,
  29895u,
  17572u,
  21637u,
  42346u,
  46411u,
  34088u,
  38153u,
  58862u,
  62927u,
  50604u,
  54669u,
  13907u,
  9842u,
  5649u,
  1584u,
  30423u,
  26358u,
  22165u,
  18100u,
  46939u,
  42874u,
  38681u,
  34616u,
  63455u,
  59390u,
  55197u,
  51132u,
  18628u,
  22757u,
  26758u,
  30887u,
  2112u,
  6241u,
  10242u,
  14371u,
  51660u,
  55789u,
  59790u,
  63919u,
  35144u,
  39273u,
  43274u,
  47403u,
  23285u,
  19156u,
  31415u,
  27286u,
  6769u,
  2640u,
  14899u,
  10770u,
  56317u,
  52188u,
  64447u,
  60318u,
  39801u,
  35672u,
  47931u,
  43802u,
  27814u,
  31879u,
  19684u,
  23749u,
  11298u,
  15363u,
  3168u,
  7233u,
  60846u,
  64911u,
  52716u,
  56781u,
  44330u,
  48395u,
  36200u,
  40265u,
  32407u,
  28342u,
  24277u,
  20212u,
  15891u,
  11826u,
  7761u,
  3696u,
  65439u,
  61374u,
  57309u,
  53244u,
  48923u,
  44858u,
  40793u,
  36728u,
  37256u,
  33193u,
  45514u,
  41451u,
  53516u,
  49453u,
  61774u,
  57711u,
  4224u,
  161u,
  12482u,
  8419u,
  20484u,
  16421u,
  28742u,
  24679u,
  33721u,
  37784u,
  41979u,
  46042u,
  49981u,
  54044u,
  58239u,
  62302u,
  689u,
  4752u,
  8947u,
  13010u,
  16949u,
  21012u,
  25207u,
  29270u,
  46570u,
  42443u,
  38312u,
  34185u,
  62830u,
  58703u,
  54572u,
  50445u,
  13538u,
  9411u,
  5280u,
  1153u,
  29798u,
  25671u,
  21540u,
  17413u,
  42971u,
  47098u,
  34713u,
  38840u,
  59231u,
  63358u,
  50973u,
  55100u,
  9939u,
  14066u,
  1681u,
  5808u,
  26199u,
  30326u,
  17941u,
  22068u,
  55628u,
  51565u,
  63758u,
  59695u,
  39368u,
  35305u,
  47498u,
  43435u,
  22596u,
  18533u,
  30726u,
  26663u,
  6336u,
  2273u,
  14466u,
  10403u,
  52093u,
  56156u,
  60223u,
  64286u,
  35833u,
  39896u,
  43963u,
  48026u,
  19061u,
  23124u,
  27191u,
  31254u,
  2801u,
  6864u,
  10931u,
  14994u,
  64814u,
  60687u,
  56684u,
  52557u,
  48554u,
  44427u,
  40424u,
  36297u,
  31782u,
  27655u,
  23652u,
  19525u,
  15522u,
  11395u,
  7392u,
  3265u,
  61215u,
  65342u,
  53085u,
  57212u,
  44955u,
  49082u,
  36825u,
  40952u,
  28183u,
  32310u,
  20053u,
  24180u,
  11923u,
  16050u,
  3793u,
  7920u
}; // idb
const uint32_t K[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
const unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___5961[11] = { 112u, 117u, 115u, 104u, 95u, 110u, 111u, 110u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___8704[21] =
{
  104u,
  97u,
  110u,
  100u,
  108u,
  101u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  115u,
  112u,
  111u,
  110u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___8737[13] = { 114u, 117u, 110u, 116u, 105u, 109u, 101u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _func___8743[13] = { 114u, 117u, 110u, 116u, 105u, 109u, 101u, 95u, 101u, 120u, 105u, 116u, 0u }; // idb
void *_frame_dummy_init_array_entry = (void *)0x1132D; // weak
bm174x_reg_value_t reg_value =
{
  390463488u,
  0u,
  2150105409u,
  2147483651u,
  10u,
  117455361u,
  16777216u,
  0u,
  4294967295u,
  34689297u,
  983040u,
  4294967295u,
  0u,
  0u,
  0u,
  0u,
  20u,
  0u,
  3u,
  0u,
  0u,
  288362800u,
  288362800u,
  196614000u,
  2000u
}; // idb
baud_BT8D_value baud_BT8D_values[5] =
{
  { 115200u, 26u, 216 },
  { 460800u, 6u, 56 },
  { 921600u, 2u, 24 },
  { 1500000u, 1u, 16 },
  { 3000000u, 0u, 8 }
}; // idb
freq_pll_str freq_pll[110] =
{
  { 16u, 0u, 0u, 1048917u },
  { 25u, 0u, 0u, 2359654u },
  { 50u, 0u, 0u, 1049153u },
  { 100u, 131136u, 1056u, 2097729u },
  { 125u, 163904u, 1056u, 2622017u },
  { 150u, 196672u, 1056u, 3146305u },
  { 175u, 229440u, 1056u, 3670593u },
  { 200u, 262208u, 1056u, 4194881u },
  { 225u, 294976u, 1056u, 4719169u },
  { 250u, 327744u, 1056u, 5243457u },
  { 275u, 360512u, 1056u, 5767745u },
  { 300u, 393280u, 1056u, 6292033u },
  { 325u, 426048u, 1056u, 6816321u },
  { 350u, 458816u, 1056u, 7340609u },
  { 375u, 491584u, 1056u, 7864897u },
  { 400u, 524352u, 1056u, 8389185u },
  { 404u, 397376u, 800u, 6357553u },
  { 406u, 266304u, 544u, 4260385u },
  { 408u, 401472u, 800u, 6423089u },
  { 412u, 270400u, 544u, 4325921u },
  { 416u, 409664u, 800u, 6554161u },
  { 418u, 274496u, 544u, 4391457u },
  { 420u, 413760u, 800u, 6619697u },
  { 425u, 278592u, 544u, 4456993u },
  { 429u, 421952u, 800u, 6750769u },
  { 431u, 282688u, 544u, 4522529u },
  { 433u, 426048u, 800u, 6816305u },
  { 437u, 286784u, 544u, 4588065u },
  { 441u, 434240u, 800u, 6947377u },
  { 443u, 290880u, 544u, 4653601u },
  { 445u, 438336u, 800u, 7012913u },
  { 450u, 294976u, 544u, 4719137u },
  { 454u, 446528u, 800u, 7143985u },
  { 456u, 299072u, 544u, 4784673u },
  { 458u, 450624u, 800u, 7209521u },
  { 462u, 303168u, 544u, 4850209u },
  { 466u, 458816u, 800u, 7340593u },
  { 468u, 307264u, 544u, 4915745u },
  { 470u, 462912u, 800u, 7406129u },
  { 475u, 311360u, 544u, 4981281u },
  { 479u, 471104u, 800u, 7537201u },
  { 481u, 315456u, 544u, 5046817u },
  { 483u, 475200u, 800u, 7602737u },
  { 487u, 319552u, 544u, 5112353u },
  { 491u, 483392u, 800u, 7733809u },
  { 493u, 323648u, 544u, 5177889u },
  { 495u, 487488u, 800u, 7799345u },
  { 500u, 327744u, 544u, 5243425u },
  { 504u, 495680u, 800u, 7930417u },
  { 506u, 331840u, 544u, 5308961u },
  { 508u, 499776u, 800u, 7995953u },
  { 512u, 335936u, 544u, 5374497u },
  { 516u, 507968u, 800u, 8127025u },
  { 518u, 340032u, 544u, 5440033u },
  { 520u, 512064u, 800u, 8192561u },
  { 525u, 344128u, 544u, 5505569u },
  { 529u, 520256u, 800u, 8323633u },
  { 531u, 348224u, 544u, 5571105u },
  { 533u, 524352u, 800u, 8389169u },
  { 537u, 352320u, 544u, 5636641u },
  { 543u, 356416u, 544u, 5702177u },
  { 550u, 360512u, 544u, 5767713u },
  { 556u, 364608u, 544u, 5833249u },
  { 562u, 368704u, 544u, 5898785u },
  { 568u, 372800u, 544u, 5964321u },
  { 575u, 376896u, 544u, 6029857u },
  { 581u, 380992u, 544u, 6095393u },
  { 587u, 385088u, 544u, 6160929u },
  { 593u, 389184u, 544u, 6226465u },
  { 600u, 393280u, 544u, 6292001u },
  { 606u, 397376u, 544u, 6357537u },
  { 612u, 401472u, 544u, 6423073u },
  { 618u, 405568u, 544u, 6488609u },
  { 625u, 409664u, 544u, 6554145u },
  { 631u, 413760u, 544u, 6619681u },
  { 637u, 417856u, 544u, 6685217u },
  { 643u, 421952u, 544u, 6750753u },
  { 650u, 426048u, 544u, 6816289u },
  { 656u, 430144u, 544u, 6881825u },
  { 662u, 434240u, 544u, 6947361u },
  { 668u, 438336u, 544u, 7012897u },
  { 675u, 442432u, 544u, 7078433u },
  { 681u, 446528u, 544u, 7143969u },
  { 687u, 450624u, 544u, 7209505u },
  { 693u, 454720u, 544u, 7275041u },
  { 700u, 458816u, 544u, 7340577u },
  { 706u, 462912u, 544u, 7406113u },
  { 712u, 467008u, 544u, 7471649u },
  { 718u, 471104u, 544u, 7537185u },
  { 725u, 475200u, 544u, 7602721u },
  { 731u, 479296u, 544u, 7668257u },
  { 737u, 483392u, 544u, 7733793u },
  { 743u, 487488u, 544u, 7799329u },
  { 750u, 491584u, 544u, 7864865u },
  { 756u, 495680u, 544u, 7930401u },
  { 762u, 499776u, 544u, 7995937u },
  { 768u, 503872u, 544u, 8061473u },
  { 775u, 507968u, 544u, 8127009u },
  { 781u, 512064u, 544u, 8192545u },
  { 787u, 516160u, 544u, 8258081u },
  { 793u, 520256u, 544u, 8323617u },
  { 800u, 524352u, 544u, 8389153u },
  { 805u, 0u, 0u, 10551633u },
  { 810u, 0u, 0u, 10617169u },
  { 815u, 0u, 0u, 10682705u },
  { 820u, 0u, 0u, 10748241u },
  { 825u, 270400u, 288u, 4325905u },
  { 850u, 0u, 0u, 4456737u },
  { 875u, 0u, 0u, 4587809u },
  { 900u, 0u, 0u, 4718881u }
}; // idb
unsigned __int8 nibble[16] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u
}; // idb
uint64_t status_period_7657 = 500000uLL; // idb
int compare_size = 3; // idb
unsigned __int8 lcd_output[4][16] =
{
  { 32u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
}; // idb
uint8_t isl_dev_addr[3] = { 80u, 84u, 88u }; // idb
unsigned __int8 gChain = 255u; // idb
int opt_log_level = 2; // idb
void *(*const volatile memset_v_5087)(void *, int, size_t) = &memset; // idb
uint32_t sha256_h0[8] =
{
  1779033703u,
  3144134277u,
  1013904242u,
  2773480762u,
  1359893119u,
  2600822924u,
  528734635u,
  1541459225u
}; // idb
uint32_t sha256_k[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
int _bss_start; // weak
int stdin; // weak
int stdout; // weak
char completed_9251; // weak
uint32_t total_error_7672; // idb
unsigned __int8 buf_7545[4096]; // idb
uint64_t total_7653; // idb
int golden_nonce_7652; // idb
uint64_t total_shares_7654; // idb
uint64_t t1_7656; // idb
uint64_t t0_7655; // idb
unsigned int *fpga_mem_addr; // idb
unsigned int *axi_fpga_addr; // idb
int red_led_fd; // idb
int green_led_fd; // idb
pthread_mutex_t i2c_mutex; // idb
pthread_mutex_t uart_send_mutex[1]; // idb
pthread_mutex_t uart_receive_mutex[1]; // idb
unsigned __int8 gI2c; // idb
int read_temp_test_result; // idb
int pattern_result; // idb
int pattern_level; // idb
uint8_t chip_temp[3]; // idb
uint8_t pcb_temp[3]; // idb
uint8_t chip_high; // idb
uint8_t pcb_high; // idb
int hardware_exception; // idb
bool use_syslog; // idb
bool opt_quiet; // idb
bool opt_debug; // idb
bool opt_log_output; // idb
pthread_mutex_t console_lock; // idb
pthread_mutex_t nonce_mutex; // idb
reg_list_t rs; // idb
uint8_t g_nonce_list[3][1][16][91]; // idb
nonce_rb_format g_nonce[3][1]; // idb
zcash_work_info g_work_info; // idb
pthread_t p_miner; // idb
app_config_t *app_conf; // idb
int fd_fpga_mem; // idb
int fd_fpga; // idb
cgpu_info cgpu; // idb
chain_info chain_info_0[1]; // idb
patten_info_t g_patten; // idb
nonce_buf nonce_fifo; // idb
work_list_info_t work_list_info; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00010F14) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (00010F20) --------------------------------------------------------
void sub_10F20()
{
  JUMPOUT(0);
}
// 10F2C: control flows out of bounds to 0

//----- (00011270) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    _libc_csu_fini,
    a1,
    va);
  abort();
}
// 1127A: positive sp value 4 has been found
// 1128C: variable 'v4' is possibly undefined

//----- (000112A0) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 110D8: using guessed type int _gmon_start__(void);

//----- (000112C4) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &_bss_start;
}
// 483E0: using guessed type int _bss_start;

//----- (000112E8) --------------------------------------------------------
int register_tm_clones()
{
  return 295904;
}

//----- (00011314) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !completed_9251 )
  {
    result = deregister_tm_clones();
    completed_9251 = 1;
  }
  return result;
}
// 483F0: using guessed type char completed_9251;

//----- (0001132C) --------------------------------------------------------
int frame_dummy()
{
  return register_tm_clones();
}

//----- (00011350) --------------------------------------------------------
uint8_t __cdecl get_bt8d_from_baud(const uint32_t baud)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  size_t max; // [sp+408h] [bp+408h]
  size_t index; // [sp+40Ch] [bp+40Ch]

  max = 5;
  for ( index = 0; ; ++index )
  {
    if ( index >= max )
    {
      if ( index != max )
        return -1;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "get bt8d value failed!!!,use default to continue\n");
        applog(3, tmp42, 0);
      }
      return get_bt8d_from_baud(0x1C200u);
    }
    if ( baud_BT8D_values[index].baud == baud )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x400u, "get bt8d %d\n", baud_BT8D_values[index].bt8d);
    applog(3, tmp42, 0);
  }
  return baud_BT8D_values[index].bt8d;
}

//----- (000114A0) --------------------------------------------------------
void __cdecl get_plldata(uint32_t freq, uint32_t *vil_data)
{
  uint32_t i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0x6D && freq_pll[i].freq != freq; ++i )
    ;
  if ( i == 110 )
    i = 4;
  *vil_data = freq_pll[i].vilpll;
}

//----- (00011504) --------------------------------------------------------
int __cdecl makeup_work_pkg(uint8_t *str, uint8_t *work_str)
{
  unsigned __int16 crc16; // [sp+Ah] [bp+Ah]

  work_str[2] = work_str[2] & 0x1F | 0x20;
  *work_str = 85;
  work_str[1] = -86;
  crc16 = CRC16_v1(work_str + 2, 142);
  *((_WORD *)work_str + 72) = HIBYTE(crc16) | (crc16 << 8);
  memcpy(str, work_str, 0x92u);
  return 146;
}

//----- (00011568) --------------------------------------------------------
int __cdecl makeup_set_address_cmd(uint8_t *str, uint32_t str_len, uint8_t chip_addr)
{
  unsigned __int8 v4; // r0
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  set_address_cmd_t set_address_cmd; // [sp+418h] [bp+410h] BYREF

  if ( str_len > 6 )
  {
    memset(&set_address_cmd, 0, sizeof(set_address_cmd));
    *(_BYTE *)&set_address_cmd = *(_BYTE *)&set_address_cmd & 0x1F | 0x40;
    *(_BYTE *)&set_address_cmd &= ~0x10u;
    *(_BYTE *)&set_address_cmd &= 0xF0u;
    set_address_cmd.length = 5;
    set_address_cmd.chip_addr = chip_addr;
    v4 = CRC5_v1((unsigned __int8 *)&set_address_cmd, 0x20u);
    *((_BYTE *)&set_address_cmd + 4) = *((_BYTE *)&set_address_cmd + 4) & 0xE0 | v4 & 0x1F;
    *str = 85;
    str[1] = -86;
    *(set_address_cmd_t *)(str + 2) = set_address_cmd;
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", (const char *)_func___7412, 7);
      applog(0, tmp42, 0);
    }
    return -1;
  }
}

//----- (00011684) --------------------------------------------------------
int __cdecl makeup_set_config_cmd(
        uint8_t *str,
        uint32_t str_len,
        uint8_t all,
        uint8_t chip_addr,
        uint8_t regaddr,
        uint32_t regdata)
{
  unsigned __int8 v7; // r0
  int v8; // r1
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  set_config_cmd_t set_config_cmd; // [sp+41Ch] [bp+414h] BYREF

  if ( str_len > 0xA )
  {
    memset(&set_config_cmd, 0, sizeof(set_config_cmd));
    *(_BYTE *)&set_config_cmd = *(_BYTE *)&set_config_cmd & 0x1F | 0x40;
    *(_BYTE *)&set_config_cmd = *(_BYTE *)&set_config_cmd & 0xEF | (16 * (all & 1));
    *(_BYTE *)&set_config_cmd = *(_BYTE *)&set_config_cmd & 0xF0 | 1;
    set_config_cmd.length = 9;
    set_config_cmd.chip_addr = chip_addr;
    set_config_cmd.regaddr = regaddr;
    *(_DWORD *)set_config_cmd.regdata = bswap32(regdata);
    v7 = CRC5_v1((unsigned __int8 *)&set_config_cmd, 0x40u);
    *((_BYTE *)&set_config_cmd + 8) = *((_BYTE *)&set_config_cmd + 8) & 0xE0 | v7 & 0x1F;
    *str = 85;
    str[1] = -86;
    v8 = *(_DWORD *)set_config_cmd.regdata;
    *(_DWORD *)(str + 2) = set_config_cmd;
    *(_DWORD *)(str + 6) = v8;
    str[10] = *((_BYTE *)&set_config_cmd + 8);
    return 11;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", (const char *)_func___7423, 11);
      applog(0, tmp42, 0);
    }
    return -1;
  }
}

//----- (000117D0) --------------------------------------------------------
int __cdecl makeup_get_status_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr)
{
  unsigned __int8 v6; // r0
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  get_status_cmd_t get_status_cmd; // [sp+418h] [bp+410h] BYREF

  if ( str_len > 6 )
  {
    memset(&get_status_cmd, 0, sizeof(get_status_cmd));
    *(_BYTE *)&get_status_cmd = *(_BYTE *)&get_status_cmd & 0x1F | 0x40;
    *(_BYTE *)&get_status_cmd = *(_BYTE *)&get_status_cmd & 0xEF | (16 * (all & 1));
    *(_BYTE *)&get_status_cmd = *(_BYTE *)&get_status_cmd & 0xF0 | 2;
    get_status_cmd.length = 5;
    get_status_cmd.chip_addr = chip_addr;
    get_status_cmd.regaddr = regaddr;
    v6 = CRC5_v1((unsigned __int8 *)&get_status_cmd, 0x20u);
    *((_BYTE *)&get_status_cmd + 4) = *((_BYTE *)&get_status_cmd + 4) & 0xE0 | v6 & 0x1F;
    *str = 85;
    str[1] = -86;
    *(get_status_cmd_t *)(str + 2) = get_status_cmd;
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", (const char *)_func___7434, 7);
      applog(0, tmp42, 0);
    }
    return -1;
  }
}

//----- (00011908) --------------------------------------------------------
int __cdecl makeup_chain_inactive_cmd(uint8_t *str, uint32_t str_len)
{
  unsigned __int8 v3; // r0
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF
  chain_inactive_cmd_t chain_inactive_cmd; // [sp+410h] [bp+408h] BYREF

  if ( str_len > 6 )
  {
    memset(&chain_inactive_cmd, 0, sizeof(chain_inactive_cmd));
    *(_BYTE *)&chain_inactive_cmd = *(_BYTE *)&chain_inactive_cmd & 0x1F | 0x40;
    *(_BYTE *)&chain_inactive_cmd |= 0x10u;
    *(_BYTE *)&chain_inactive_cmd = *(_BYTE *)&chain_inactive_cmd & 0xF0 | 3;
    chain_inactive_cmd.length = 5;
    v3 = CRC5_v1((unsigned __int8 *)&chain_inactive_cmd, 0x20u);
    *((_BYTE *)&chain_inactive_cmd + 4) = *((_BYTE *)&chain_inactive_cmd + 4) & 0xE0 | v3 & 0x1F;
    *str = 85;
    str[1] = -86;
    *(chain_inactive_cmd_t *)(str + 2) = chain_inactive_cmd;
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", (const char *)_func___7441, 7);
      applog(0, tmp42, 0);
    }
    return -1;
  }
}

//----- (00011A0C) --------------------------------------------------------
int __cdecl bm174x_pack_ioctl_pkg(uint8_t *str, uint32_t str_len, uint32_t oper_type, void *param)
{
  int status_cmd; // r3
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  uint8_t *work_str; // [sp+418h] [bp+410h]
  uint8_t *address; // [sp+41Ch] [bp+414h]
  base_type_t *item_0; // [sp+420h] [bp+418h]
  base_type_t *item; // [sp+424h] [bp+41Ch]

  switch ( oper_type )
  {
    case 0u:
      item = (base_type_t *)param;
      status_cmd = makeup_get_status_cmd(str, str_len, *((_BYTE *)param + 1), *(_BYTE *)param, *((_BYTE *)param + 2));
      break;
    case 1u:
      item_0 = (base_type_t *)param;
      status_cmd = makeup_set_config_cmd(
                     str,
                     str_len,
                     *((_BYTE *)param + 1),
                     *(_BYTE *)param,
                     *((_BYTE *)param + 2),
                     *((_DWORD *)param + 1));
      break;
    case 2u:
      work_str = (uint8_t *)param;
      status_cmd = makeup_work_pkg(str, (uint8_t *)param);
      break;
    case 3u:
      address = (uint8_t *)param;
      status_cmd = makeup_set_address_cmd(str, str_len, *(_BYTE *)param);
      break;
    case 4u:
      status_cmd = makeup_chain_inactive_cmd(str, str_len);
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf((char *)tmp42, 0x400u, "unknow ioctl type %d\n", oper_type);
        applog(0, tmp42, 0);
      }
      status_cmd = 0;
      break;
  }
  return status_cmd;
}

//----- (00011B68) --------------------------------------------------------
int __cdecl bm174x_ioctl(int fd, uint32_t oper_type, void *param)
{
  unsigned __int8 fda; // [sp+Ch] [bp+Ch]
  uint8_t str[300]; // [sp+10h] [bp+10h] BYREF
  int len; // [sp+13Ch] [bp+13Ch]

  fda = fd;
  memset(str, 0, sizeof(str));
  len = bm174x_pack_ioctl_pkg(str, 0x12Cu, oper_type, param);
  if ( len >= 0 )
    return uart_send(fda, str, len);
  else
    return len;
}

//----- (00011BDC) --------------------------------------------------------
void __cdecl bm174x_read_register(int fd, int mode, uint8_t chip_addr, uint8_t reg_addr)
{
  base_type_t item; // [sp+10h] [bp+10h] BYREF

  item.all = mode;
  item.chip_addr = chip_addr;
  item.addr = reg_addr;
  item.data = 0;
  bm174x_ioctl(fd, 0, &item);
}

//----- (00011C1C) --------------------------------------------------------
void __cdecl bm174x_write_register(int fd, int mode, uint8_t chip_addr, uint8_t reg_addr, uint32_t reg_data)
{
  base_type_t item; // [sp+10h] [bp+10h] BYREF

  item.all = mode;
  item.chip_addr = chip_addr;
  item.addr = reg_addr;
  item.data = reg_data;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00011C5C) --------------------------------------------------------
void __cdecl bm174x_set_ticket_mask(int fd, uint32_t tm)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  base_type_t item; // [sp+408h] [bp+408h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "Set ticket mask %u\n", tm);
    applog(2, tmp42, 0);
  }
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 20;
  item.data = tm;
  reg_value.ticket_mask = tm;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00011CFC) --------------------------------------------------------
void __cdecl bm174x_set_frequency(int fd, uint32_t freq)
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  base_type_t item; // [sp+40Ch] [bp+40Ch] BYREF
  uint32_t pll_value; // [sp+414h] [bp+414h] BYREF

  pll_value = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "Set frequency %u\n", freq);
    applog(2, tmp42, 0);
  }
  get_plldata(freq, &pll_value);
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 12;
  item.data = pll_value;
  reg_value.pll_parameter = pll_value;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00011DB0) --------------------------------------------------------
void __cdecl bm174x_set_io_drive_strength(int fd, uint32_t value)
{
  base_type_t item; // [sp+8h] [bp+8h] BYREF

  item.chip_addr = 0;
  item.all = 1;
  item.addr = 48;
  item.data = value;
  reg_value.io_drive_strength = value;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00011DEC) --------------------------------------------------------
void __cdecl bm174x_set_baud(int fd, int baudrate)
{
  base_type_t item; // [sp+Ch] [bp+Ch] BYREF
  bm174x_reg reg_misc; // [sp+14h] [bp+14h]

  reg_misc.chip_addr = (bm174x_chip_addr)reg_value.misc_control;
  *((_BYTE *)&reg_misc.chip_addr + 1) = *((_BYTE *)&reg_misc.chip_addr + 1) & 0xE0 | get_bt8d_from_baud(baudrate) & 0x1F;
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 28;
  item.data = reg_misc.core_timeout.core_timeout;
  reg_value.misc_control = reg_misc.core_timeout.core_timeout;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00011E4C) --------------------------------------------------------
void __cdecl bm174x_chain_inactive(int fd)
{
  bm174x_ioctl(fd, 4u, 0);
}

//----- (00011E68) --------------------------------------------------------
void __cdecl bm174x_set_address(int fd, uint8_t address)
{
  uint8_t addressa; // [sp+3h] [bp+3h] BYREF
  int fda; // [sp+4h] [bp+4h]

  fda = fd;
  addressa = address;
  bm174x_ioctl(fd, 3u, &addressa);
}

//----- (00011E88) --------------------------------------------------------
void __cdecl bm174x_set_core_timeout(int fd, uint32_t timeout)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  base_type_t item; // [sp+408h] [bp+408h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "Set core timeout %u\n", timeout);
    applog(2, tmp42, 0);
  }
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 40;
  item.data = timeout;
  reg_value.core_timeout = timeout;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00011F28) --------------------------------------------------------
void __cdecl bm174x_set_txn_data(int fd, uint32_t txn_data)
{
  base_type_t item; // [sp+8h] [bp+8h] BYREF

  item.chip_addr = 0;
  item.all = 1;
  item.addr = 88;
  item.data = txn_data;
  reg_value.txn_data = txn_data;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00011F64) --------------------------------------------------------
void __cdecl bm174x_set_nonce_shift(int fd, uint32_t nonce_shift, uint32_t *outer_shift)
{
  base_type_t item; // [sp+14h] [bp+14h] BYREF
  bm174x_reg nonce_shift_reg; // [sp+1Ch] [bp+1Ch]

  nonce_shift_reg.chip_addr = (bm174x_chip_addr)reg_value.nonce_shift;
  *(_BYTE *)&nonce_shift_reg.chip_addr = reg_value.nonce_shift & 0xE0 | nonce_shift & 0x1F;
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 80;
  item.data = nonce_shift_reg.core_timeout.core_timeout;
  bm174x_ioctl(fd, 1u, &item);
  *outer_shift = nonce_shift;
}

//----- (00011FBC) --------------------------------------------------------
void __cdecl bm174x_set_vmount(int fd, int vmount)
{
  base_type_t item; // [sp+Ch] [bp+Ch] BYREF
  bm174x_reg vmount_reg; // [sp+14h] [bp+14h]

  vmount_reg.chip_addr = (bm174x_chip_addr)reg_value.analog_mux_control;
  *(_BYTE *)&vmount_reg.chip_addr = reg_value.analog_mux_control & 0xF8 | vmount & 7;
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 64;
  item.data = vmount_reg.core_timeout.core_timeout;
  reg_value.analog_mux_control = vmount_reg.core_timeout.core_timeout;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00012018) --------------------------------------------------------
void __cdecl bm174x_set_pt_ctrl(int fd, int pt_num, int pt_en)
{
  base_type_t item; // [sp+14h] [bp+14h] BYREF
  bm174x_reg pt_ctrl_reg; // [sp+1Ch] [bp+1Ch]

  *((_BYTE *)&pt_ctrl_reg.chip_addr + 1) = BYTE1(reg_value.pt_ctrl);
  *(_BYTE *)&pt_ctrl_reg.chip_addr = reg_value.pt_ctrl & 0xFE | pt_en & 1;
  *((_WORD *)&pt_ctrl_reg.hash_rate + 1) = HIWORD(reg_value.pt_ctrl) & 0xF800 | pt_num & 0x7FF;
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 92;
  item.data = pt_ctrl_reg.core_timeout.core_timeout;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (0001207C) --------------------------------------------------------
void __cdecl bm174x_set_pt_result(int fd, int ptr_grp_num, int ptr_rd)
{
  base_type_t item; // [sp+14h] [bp+14h] BYREF
  bm174x_reg pt_result_reg; // [sp+1Ch] [bp+1Ch]

  *(_BYTE *)&pt_result_reg.chip_addr = *(_BYTE *)&pt_result_reg.chip_addr & 0xFE | ptr_rd & 1;
  *((_BYTE *)&pt_result_reg.chip_addr + 1) = *((_BYTE *)&pt_result_reg.chip_addr + 1) & 0xF0 | ptr_grp_num & 0xF;
  item.chip_addr = 0;
  item.all = 1;
  item.addr = 96;
  item.data = pt_result_reg.core_timeout.core_timeout;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (000120D4) --------------------------------------------------------
void __cdecl bm174x_i2c_enable(int fd, uint8_t chip_addr)
{
  base_type_t item; // [sp+Ch] [bp+Ch] BYREF
  bm174x_reg misc_reg; // [sp+14h] [bp+14h]

  misc_reg.core_timeout.core_timeout = reg_value.misc_control | 0x4060;
  item.chip_addr = chip_addr;
  item.all = 0;
  item.addr = 28;
  item.data = reg_value.misc_control | 0x4060;
  bm174x_ioctl(fd, 1u, &item);
}

//----- (00012124) --------------------------------------------------------
void __cdecl bm174x_i2c_status(int fd, uint8_t chip_addr)
{
  base_type_t item; // [sp+8h] [bp+8h] BYREF

  item.data = 0;
  *(_DWORD *)&item.chip_addr = chip_addr;
  item.addr = 32;
  bm174x_ioctl(fd, 0, &item);
}

//----- (00012158) --------------------------------------------------------
int __cdecl bm174x_i2c_recv(int fd, uint8_t chip_addr, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, int len)
{
  base_type_t item; // [sp+8h] [bp+8h] BYREF
  bm174x_reg i2c_reg; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  *(_BYTE *)&i2c_reg.chip_addr = reg_value.general_i2c_command;
  *((_BYTE *)&i2c_reg.pll_parameter + 3) = HIBYTE(reg_value.general_i2c_command) | 1;
  *((_BYTE *)&i2c_reg.hash_rate + 2) = 2 * (i2c_dev_addr & 0x7F);
  *((_BYTE *)&i2c_reg.chip_addr + 1) = i2c_reg_addr;
  item.chip_addr = chip_addr;
  item.all = 0;
  item.addr = 32;
  item.data = i2c_reg.core_timeout.core_timeout;
  bm174x_ioctl(fd, 1u, &item);
  usleep(0x30D40u);
  for ( i = 0; i < len; ++i )
  {
    item.all = 0;
    item.chip_addr = chip_addr;
    item.addr = 32;
    item.data = 0;
    bm174x_ioctl(fd, 0, &item);
    usleep((__useconds_t)&nonce_fifo.nonce_buffer[508].Nonce[1188]);
  }
  return 0;
}

//----- (00012214) --------------------------------------------------------
void __cdecl bm174x_i2c_send(
        int fd,
        uint8_t chip_addr,
        uint8_t i2c_dev_addr,
        uint8_t i2c_reg_addr,
        uint8_t *reg_data,
        int len)
{
  base_type_t item; // [sp+8h] [bp+8h] BYREF
  bm174x_reg i2c_reg; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i < len; ++i )
  {
    *(_BYTE *)&i2c_reg.chip_addr = reg_value.general_i2c_command;
    *((_BYTE *)&i2c_reg.pll_parameter + 3) = HIBYTE(reg_value.general_i2c_command) | 1;
    *((_BYTE *)&i2c_reg.hash_rate + 2) = (2 * (i2c_dev_addr & 0x7F)) | 1;
    *((_BYTE *)&i2c_reg.chip_addr + 1) = i2c_reg_addr;
    *(_BYTE *)&i2c_reg.chip_addr = reg_data[i];
    item.chip_addr = chip_addr;
    item.all = 0;
    item.addr = 32;
    item.data = i2c_reg.core_timeout.core_timeout;
    bm174x_ioctl(fd, 1u, &item);
  }
}

//----- (000122A4) --------------------------------------------------------
void __cdecl bm174x_send_work(int fd, uint8_t *buf)
{
  bm174x_ioctl(fd, 2u, buf);
}

//----- (000122C0) --------------------------------------------------------
void __cdecl bm174x_pm_handle(uint8_t *str, int len, uint8_t chainid)
{
  unsigned __int8 tmp42[1024]; // [sp+20h] [bp+10h] BYREF
  uint8_t crc5; // [sp+423h] [bp+413h]
  pmonitor_respond *pm; // [sp+424h] [bp+414h]

  pm = (pmonitor_respond *)str;
  crc5 = CRC5_v1(str + 2, 8 * (len - 3) + 3);
  if ( crc5 == (*((_BYTE *)pm + 8) & 0x1F) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "pmonitor[%02x] %02x %02x %02x %02x\n",
        pm->chip_addr,
        pm->pm_data[0],
        pm->pm_data[1],
        pm->pm_data[2],
        pm->pm_data[3]);
      applog(2, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf((char *)tmp42, 0x400u, "%s chain%d CRC error crc = %02x\n", (const char *)_func___7601, chainid, crc5);
    applog(0, tmp42, 0);
  }
}

//----- (00012408) --------------------------------------------------------
void __cdecl bm174x_pt_handle(uint8_t *str, int len, uint8_t chainid)
{
  unsigned __int16 v3; // r0
  unsigned __int8 tmp42[1024]; // [sp+20h] [bp+10h] BYREF
  FILE *fpt; // [sp+420h] [bp+410h]
  uint16_t crc16; // [sp+426h] [bp+416h]
  pattern_test_respond *pt; // [sp+428h] [bp+418h]
  int i; // [sp+42Ch] [bp+41Ch]

  pt = (pattern_test_respond *)str;
  v3 = CRC16_v1(str + 2, len - 4);
  crc16 = HIBYTE(v3) | (v3 << 8);
  if ( crc16 == pt->crc16 )
  {
    fpt = fopen("./pattern_result.txt", "a+");
    if ( fpt )
    {
      for ( i = 0; i <= 127; ++i )
        dump_str(fpt, 0, &pt->pt_result_data[8 * i], 8);
      fclose(fpt);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "open failed pattern_result.txt\n");
      applog(2, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "%s chainid=%d cal crc = %04x, chip crc = %04x\n",
      (const char *)_func___7611,
      chainid,
      crc16,
      pt->crc16);
    applog(2, tmp42, 0);
  }
}

//----- (000125A4) --------------------------------------------------------
void __cdecl bm174x_reg_handle(uint8_t *str, int len, uint8_t chainid)
{
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  reg_list_item_t new_item; // [sp+41Ch] [bp+414h]
  uint8_t crc5; // [sp+42Bh] [bp+423h]
  reg_respond *reg; // [sp+42Ch] [bp+424h]
  reg_list_item_t v8; // 0:r0.12

  reg = (reg_respond *)str;
  crc5 = CRC5_v1(str + 2, 8 * (len - 3) + 3);
  if ( crc5 == (*((_BYTE *)reg + 8) & 0x1F) )
  {
    new_item.age = 3;
    new_item.chainid = chainid;
    new_item.chip_addr = reg->chip_addr;
    new_item.reg_addr = reg->reg_addr;
    *(_QWORD *)&v8.chainid = __PAIR64__(_byteswap_ulong(*(_DWORD *)reg->reg_data), *(unsigned int *)&new_item.chainid);
    v8.age = 3;
    add_reg_item(v8);
  }
  else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf((char *)tmp42, 0x400u, "%s CRC error crc = %02x\n", (const char *)_func___7627, crc5);
    applog(0, tmp42, 0);
  }
}

//----- (000126C0) --------------------------------------------------------
int __cdecl bm174x_nonce_integrality(uint8_t chipid, uint8_t nonce_array_id, int chainid)
{
  uint8_t chainida; // [sp+10h] [bp+0h]
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+Ch] BYREF
  uint16_t crc16; // [sp+41Eh] [bp+40Eh] BYREF
  uint8_t *nonce_p; // [sp+420h] [bp+410h]
  int i; // [sp+424h] [bp+414h]

  chainida = chainid;
  for ( i = 0; i <= 15; ++i )
  {
    crc16 = CRC16_v1(g_nonce_list[nonce_array_id][chipid][i], 89);
    crc16 = HIBYTE(crc16) | (crc16 << 8);
    if ( memcmp(&crc16, &g_nonce_list[chipid][nonce_array_id][i][89], 2u) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s CRC error. cal-crc=%x, chip-crc=%02x%02x\n",
          (const char *)_func___7636,
          crc16,
          g_nonce_list[chipid][nonce_array_id][i][89],
          g_nonce_list[chipid][nonce_array_id][i][90]);
        applog(0, tmp42, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( (g_nonce_list[chipid][nonce_array_id][i][0] & 0xF) != i )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf((char *)tmp42, 0x400u, "nonce is not continous i=%d\n", i);
        applog(0, tmp42, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    if ( g_nonce_list[chipid][nonce_array_id][i][1] != g_nonce_list[chipid][nonce_array_id][i + 1][1] )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "chip_addr is different %02x != %02x\n",
          g_nonce_list[chipid][nonce_array_id][i][1],
          g_nonce_list[chipid][nonce_array_id][i + 1][1]);
        applog(0, tmp42, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    if ( g_nonce_list[chipid][nonce_array_id][i][2] != g_nonce_list[chipid][nonce_array_id][i + 1][2] )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "workID is different %02x != %02x\n",
          g_nonce_list[chipid][nonce_array_id][i][2],
          g_nonce_list[chipid][nonce_array_id][i + 1][2]);
        applog(0, tmp42, 0);
      }
      return -1;
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( i > 14 )
    {
      nonce_p = g_nonce[nonce_array_id][chipid].Nonce;
      for ( i = 0; i <= 14; ++i )
      {
        memcpy(nonce_p, &g_nonce_list[chipid][nonce_array_id][i][4], 0x55u);
        nonce_p += 85;
      }
      memcpy(nonce_p, &g_nonce_list[nonce_array_id][chipid][15][4], 0x45u);
      memcpy(
        g_nonce[nonce_array_id][chipid].chip_nonce,
        &g_nonce_list[nonce_array_id][chipid][15][85],
        sizeof(g_nonce[nonce_array_id][chipid].chip_nonce));
      g_nonce[chipid][nonce_array_id].chip_addr = g_nonce_list[chipid][nonce_array_id][15][1];
      g_nonce[chipid][nonce_array_id].work_id = g_nonce_list[chipid][nonce_array_id][15][2];
      g_nonce[chipid][nonce_array_id].nonce_id = g_nonce_list[chipid][nonce_array_id][15][3];
      g_nonce[chipid][nonce_array_id].diff0 = g_nonce_list[chipid][nonce_array_id][15][76];
      memcpy(
        g_nonce[chipid][nonce_array_id].sha256,
        &g_nonce_list[nonce_array_id][chipid][15][77],
        sizeof(g_nonce[chipid][nonce_array_id].sha256));
      g_nonce[chipid][nonce_array_id].chain_id = chainida;
      return 0;
    }
    if ( g_nonce_list[chipid][nonce_array_id][i][3] != g_nonce_list[chipid][nonce_array_id][i + 1][3] )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "nonceID is different %02x != %02x chipid=%d\n",
      g_nonce_list[chipid][nonce_array_id][i][3],
      g_nonce_list[chipid][nonce_array_id][i + 1][3],
      chipid);
    applog(0, tmp42, 0);
  }
  return -1;
}

//----- (00012F94) --------------------------------------------------------
int __cdecl bm174x_nonce_handle(uint8_t *str, int len, uint32_t chainid, int addr_interval)
{
  uint32_t v5; // r2
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  int ret; // [sp+414h] [bp+414h]
  uint8_t nonce_array_id; // [sp+41Bh] [bp+41Bh]
  uint8_t nonceid; // [sp+41Ch] [bp+41Ch]
  uint8_t chipid; // [sp+41Dh] [bp+41Dh]
  uint8_t chipaddr; // [sp+41Eh] [bp+41Eh]
  uint8_t index; // [sp+41Fh] [bp+41Fh]

  index = str[2] & 0xF;
  chipaddr = str[3];
  chipid = chipaddr / addr_interval;
  nonceid = str[5];
  nonce_array_id = 0;
  ret = 1;
  memcpy((char *)g_nonce_list[chipid] + 91 * index, str + 2, len - 2);
  if ( index != 15 )
    return 1;
  ret = bm174x_nonce_integrality(chipid, nonce_array_id, chainid);
  if ( ret >= 0 )
  {
    push_nonce(&g_nonce[nonce_array_id][chipid]);
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      v5 = total_error_7672++;
      snprintf((char *)tmp42, 0x400u, "receive a error nonce. total = %u\n", v5);
      applog(1, tmp42, 0);
    }
    return -1;
  }
}

//----- (00013104) --------------------------------------------------------
int __cdecl bm174x_init_asic(void *args)
{
  *((_DWORD *)args + 36) = 16;
  *((_DWORD *)args + 37) = 93;
  *((_DWORD *)args + 38) = 9;
  *((_DWORD *)args + 39) = 9;
  *((_DWORD *)args + 40) = 1030;
  *((_DWORD *)args + 41) = 1030;
  *((_DWORD *)args + 42) = 146;
  *((_DWORD *)args + 716) = bm174x_read_register;
  *((_DWORD *)args + 717) = bm174x_write_register;
  *((_DWORD *)args + 718) = bm174x_send_work;
  *((_DWORD *)args + 719) = bm174x_set_ticket_mask;
  *((_DWORD *)args + 720) = bm174x_set_core_timeout;
  *((_DWORD *)args + 721) = bm174x_set_pt_ctrl;
  *((_DWORD *)args + 722) = bm174x_set_pt_result;
  *((_DWORD *)args + 723) = bm174x_set_txn_data;
  *((_DWORD *)args + 724) = bm174x_set_baud;
  *((_DWORD *)args + 725) = bm174x_chain_inactive;
  *((_DWORD *)args + 726) = bm174x_set_address;
  *((_DWORD *)args + 727) = bm174x_set_frequency;
  *((_DWORD *)args + 728) = bm174x_set_nonce_shift;
  *((_DWORD *)args + 729) = bm174x_set_vmount;
  *((_DWORD *)args + 732) = bm174x_i2c_enable;
  *((_DWORD *)args + 733) = bm174x_i2c_status;
  *((_DWORD *)args + 731) = bm174x_i2c_recv;
  *((_DWORD *)args + 730) = bm174x_i2c_send;
  *((_DWORD *)args + 739) = bm174x_reg_handle;
  *((_DWORD *)args + 740) = bm174x_nonce_handle;
  *((_DWORD *)args + 738) = bm174x_pt_handle;
  *((_DWORD *)args + 737) = bm174x_pm_handle;
  return 0;
}

//----- (00013290) --------------------------------------------------------
void __cdecl delay(int seconds)
{
  int v1; // r3
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+40Ch] [bp+40Ch]

  i = 0;
  while ( 1 )
  {
    v1 = i++;
    if ( v1 >= seconds )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "remain %d seconds......\n", seconds - i);
      applog(2, tmp42, 0);
    }
    sleep(1u);
  }
}

//----- (0001331C) --------------------------------------------------------
void __cdecl check_asic_num(runtime_base_t *runtime)
{
  reg_list_item_t item_r; // [sp+8h] [bp+8h] BYREF
  int asicid; // [sp+14h] [bp+14h]

  runtime->read_register(runtime->chain_status[runtime->chain_id].fd, 1, 0, 0);
  item_r.chainid = runtime->chain_id;
  item_r.chip_addr = 0;
  item_r.reg_addr = 0;
  item_r.reg_data = 0;
  item_r.age = 0;
  runtime->chain_status[runtime->chain_id].real_asic_num = 0;
  for ( asicid = 0; app_conf->asic_num > asicid; ++asicid )
  {
    if ( read_reg_item(&item_r, 500) > 0 )
      ++runtime->chain_status[runtime->chain_id].real_asic_num;
  }
}

//----- (000133F0) --------------------------------------------------------
void __cdecl set_asic_address(runtime_base_t *runtime, unsigned __int8 chainid)
{
  int i; // [sp+Ch] [bp+Ch]

  runtime->chain_inactive(runtime->chain_status[chainid].fd);
  for ( i = 0; runtime->chain_status[chainid].design_asic_num > i; ++i )
    runtime->set_address(runtime->chain_status[chainid].fd, runtime->addr_interval * i);
}

//----- (00013470) --------------------------------------------------------
int __cdecl calc_asic_addr_interval(int actual_asic_number)
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+40Ch] [bp+40Ch]

  i = 0;
  if ( actual_asic_number == 1 )
  {
    i = 1;
    return 256 / i;
  }
  if ( actual_asic_number == 2 )
  {
    i = 2;
    return 256 / i;
  }
  if ( actual_asic_number > 2 && actual_asic_number <= 4 )
  {
    i = 4;
    return 256 / i;
  }
  if ( actual_asic_number > 4 && actual_asic_number <= 8 )
  {
    i = 8;
    return 256 / i;
  }
  if ( actual_asic_number > 8 && actual_asic_number <= 16 )
  {
    i = 16;
    return 256 / i;
  }
  if ( actual_asic_number > 16 && actual_asic_number <= 32 )
  {
    i = 32;
    return 256 / i;
  }
  if ( actual_asic_number > 32 && actual_asic_number <= 64 )
  {
    i = 64;
    return 256 / i;
  }
  if ( actual_asic_number > 64 && actual_asic_number <= 128 )
  {
    i = 128;
    return 256 / i;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf((char *)tmp42, 0x400u, "actual_asic_number = %d, but it is error\n", actual_asic_number);
    applog(4, tmp42, 0);
  }
  return -1;
}

//----- (000135B0) --------------------------------------------------------
void __cdecl user_i2c_enable(runtime_base_t *runtime, unsigned __int8 chainid)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; runtime->chain_status[runtime->chain_id].design_asic_num > i; ++i )
    runtime->i2c_enable(runtime->chain_status[chainid].fd, runtime->addr_interval * i);
}

//----- (00013618) --------------------------------------------------------
int __cdecl user_i2c_state(runtime_base_t *runtime, int chip_addr)
{
  int v2; // r3
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  reg_list_item_t item; // [sp+40Ch] [bp+40Ch] BYREF
  int chainid; // [sp+418h] [bp+418h]
  int check_loop; // [sp+41Ch] [bp+41Ch]

  chainid = runtime->chain_id;
  check_loop = 3;
  do
  {
    runtime->i2c_status(runtime->chain_status[chainid].fd, chip_addr);
    memset(&item, 0, sizeof(item));
    item.chainid = runtime->chain_id;
    item.chip_addr = chip_addr;
    item.reg_addr = 32;
    if ( read_reg_item(&item, 1000) >= 0 )
    {
      if ( (item.reg_data & 0x80000000) == 0 )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        snprintf((char *)tmp42, 0x400u, "chipaddr %02x - i2c is busy\n", chip_addr);
        applog(1, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      snprintf((char *)tmp42, 0x400u, "chipaddr %02x - i2c no-response\n", chip_addr);
      applog(1, tmp42, 0);
    }
    v2 = check_loop--;
  }
  while ( v2 > 0 );
  if ( check_loop > 0 )
    return 0;
  else
    return -1;
}

//----- (00013778) --------------------------------------------------------
int __cdecl user_read_iic(
        runtime_base_t *runtime,
        int chip_addr,
        uint8_t i2c_dev_addr,
        uint8_t i2c_reg_addr,
        uint8_t *i2c_reg_data,
        int len)
{
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  reg_list_item_t itemreg; // [sp+41Ch] [bp+414h] BYREF
  int fd; // [sp+428h] [bp+420h]
  int chainid; // [sp+42Ch] [bp+424h]
  int i; // [sp+430h] [bp+428h]
  int ret; // [sp+434h] [bp+42Ch]

  ret = 1;
  chainid = runtime->chain_id;
  fd = runtime->chain_status[chainid].fd;
  if ( user_i2c_state(runtime, chip_addr) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "i2c state check failed\n");
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( runtime->i2c_recv(fd, chip_addr, i2c_dev_addr, i2c_reg_addr, len) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        snprintf((char *)tmp42, 0x400u, "Read i2c failed chipaddr=%02x, i2c-regaddr=%02x\n", chip_addr, i2c_reg_addr);
        applog(1, tmp42, 0);
      }
      return 1;
    }
    else
    {
      itemreg.chainid = chainid;
      itemreg.chip_addr = chip_addr;
      itemreg.reg_addr = 32;
      itemreg.reg_data = 0;
      itemreg.age = 0;
      for ( i = 0; i < len; ++i )
      {
        if ( read_reg_item(&itemreg, 500) <= 0 || (itemreg.reg_data & 0xC0000000) != 0 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 0 )
          {
            snprintf(
              (char *)tmp42,
              0x400u,
              "Read i2c failed chipaddr=%02x, i2c-regaddr=%02x i2c-regdata=%08x\n",
              chip_addr,
              i2c_reg_addr,
              itemreg.reg_data);
            applog(1, tmp42, 0);
          }
          ret = 1;
        }
        else
        {
          i2c_reg_data[i] = itemreg.reg_data;
          ret = 0;
        }
      }
    }
    return ret;
  }
}

//----- (000139B4) --------------------------------------------------------
void __cdecl user_send_work(runtime_base_t *runtime, uint8_t *header, int sno_valid, int test_patten)
{
  uint8_t total_work; // r3
  char test_pattena; // [sp+0h] [bp+0h]
  char sno_valida; // [sp+4h] [bp+4h]
  work_input work; // [sp+10h] [bp+10h] BYREF
  int chainid; // [sp+A4h] [bp+A4h]

  sno_valida = sno_valid;
  test_pattena = test_patten;
  chainid = runtime->chain_id;
  memset(&work, 0, sizeof(work));
  *((_BYTE *)&work + 2) = *((_BYTE *)&work + 2) & 0xEF | (16 * (sno_valida & 1));
  *((_BYTE *)&work + 2) = *((_BYTE *)&work + 2) & 0xFE | test_pattena & 1;
  total_work = runtime->total_work;
  runtime->total_work = total_work + 1;
  work.workid = total_work;
  memcpy(work.work, header, sizeof(work.work));
  work_list_insert(work.workid, work.work);
  runtime->send_work(runtime->chain_status[chainid].fd, (uint8_t *)&work);
}

//----- (00013A5C) --------------------------------------------------------
void __cdecl online_mining(runtime_base_t *runtime)
{
  int chainid; // [sp+Ch] [bp+Ch]

  chainid = runtime->chain_id;
  runtime->set_ticket_mask(runtime->chain_status[chainid].fd, app_conf->ticket_mask);
  usleep(0x186A0u);
  runtime->set_core_timeout(runtime->chain_status[chainid].fd, app_conf->core_timeout);
  usleep(0x186A0u);
  runtime->set_frequency(runtime->chain_status[chainid].fd, app_conf->bringup_freq);
  usleep(0x186A0u);
  runtime->set_nonce_shift(runtime->chain_status[chainid].fd, 0, &runtime->nonce_shift);
  usleep(0x186A0u);
  equihash_miner_start(runtime);
  equihash_miner_join();
}

//----- (00013B48) --------------------------------------------------------
int __cdecl pattern_test(runtime_base_t *runtime, int freq, int *nonce)
{
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 golden[20]; // [sp+414h] [bp+414h] BYREF
  unsigned __int8 result[20]; // [sp+428h] [bp+428h] BYREF
  bm174x_reg pt_result_reg; // [sp+43Ch] [bp+43Ch]
  uint8_t header_bin[140]; // [sp+440h] [bp+440h] BYREF
  reg_list_item_t item; // [sp+4CCh] [bp+4CCh] BYREF
  unsigned __int8 *header; // [sp+4D8h] [bp+4D8h]
  int read_timeout_limit; // [sp+4DCh] [bp+4DCh]
  int chainid; // [sp+4E0h] [bp+4E0h]
  int read_timeout_counter; // [sp+4E4h] [bp+4E4h]
  FILE *fpr; // [sp+4E8h] [bp+4E8h]
  FILE *fpg; // [sp+4ECh] [bp+4ECh]
  int match_num; // [sp+4F0h] [bp+4F0h]
  int i; // [sp+4F4h] [bp+4F4h]

  chainid = runtime->chain_id;
  read_timeout_limit = 15;
  match_num = 0;
  fpg = 0;
  fpr = 0;
  remove("./pattern_result.txt");
  runtime->set_pt_ctrl(runtime->chain_status[chainid].fd, 0, 0);
  usleep(0x186A0u);
  runtime->set_ticket_mask(runtime->chain_status[chainid].fd, 5);
  usleep(0x186A0u);
  runtime->set_core_timeout(runtime->chain_status[chainid].fd, 45000);
  usleep(0x186A0u);
  runtime->set_txn_data(runtime->chain_status[chainid].fd, 0);
  usleep(0x186A0u);
  runtime->set_frequency(runtime->chain_status[chainid].fd, freq);
  usleep(0x186A0u);
  runtime->set_pt_ctrl(runtime->chain_status[chainid].fd, 2047, 1);
  usleep(0x186A0u);
  header = "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d"
           "3d3ff1502b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771e"
           "ccb5c5e3d6beb470359446494d25e15f87df87c3119ebd9ca813a400000000";
  memset(header_bin, 0, sizeof(header_bin));
  hex2bin(
    header_bin,
    "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d3d3ff15"
    "02b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771eccb5c5e3d6beb4"
    "70359446494d25e15f87df87c3119ebd9ca813a400000000",
    0x8Cu);
  user_send_work(runtime, header_bin, 0, 0);
  sleep(3u);
  item.age = 3;
  item.chainid = 0;
  item.chip_addr = 0;
  item.reg_addr = 96;
  read_timeout_counter = 0;
  while ( read_timeout_counter < read_timeout_limit )
  {
    runtime->read_register(runtime->chain_status[chainid].fd, 1, 0, 96);
    if ( read_reg_item(&item, 500) <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        strcpy((char *)tmp42, "REG_PT_RESULT read timeout\n");
        applog(0, tmp42, 0);
      }
      ++read_timeout_counter;
    }
    else
    {
      pt_result_reg.chip_addr = (bm174x_chip_addr)item.reg_data;
      if ( (HIWORD(item.reg_data) & 0xFFF) == 2048 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy((char *)tmp42, "pattern test finished\n");
          applog(2, tmp42, 0);
        }
        break;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "REG_PT_RESULT cur num = %d < 0x800, check again\n",
          *((_WORD *)&pt_result_reg.hash_rate + 1) & 0xFFF);
        applog(4, tmp42, 0);
      }
      ++read_timeout_counter;
    }
    sleep(1u);
  }
  if ( read_timeout_counter < read_timeout_limit )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      strcpy((char *)tmp42, "pattern test finished, read out nonce\n");
      applog(0, tmp42, 0);
    }
    for ( i = 0; i <= 15; ++i )
    {
      runtime->set_pt_result(runtime->chain_status[chainid].fd, i, 1);
      usleep(0x30D40u);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "Compare golden nonce and current nonce\n");
      applog(2, tmp42, 0);
    }
    fpr = fopen("./pattern_result.txt", "r");
    if ( fpr )
    {
      fpg = fopen("./pattern_golden.txt", "r");
      if ( fpg )
      {
LABEL_52:
        while ( !feof(fpr) )
        {
          memset(result, 0, sizeof(result));
          fgets((char *)result, 1024, fpr);
          fseek(fpg, 0, 0);
          while ( !feof(fpg) )
          {
            memset(golden, 0, sizeof(golden));
            fgets((char *)golden, 1024, fpg);
            if ( !strncmp((const char *)golden, (const char *)result, 0x10u) && golden[0] )
            {
              ++match_num;
              goto LABEL_52;
            }
          }
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        strcpy((char *)tmp42, "open failed pattern_golden.txt\n");
        applog(0, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      strcpy((char *)tmp42, "open failed pattern_result.txt\n");
      applog(0, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "patten test timeout\n");
    applog(2, tmp42, 0);
  }
  if ( fpg )
    fclose(fpg);
  if ( fpr )
    fclose(fpr);
  *nonce = match_num;
  return 0;
}

//----- (00014200) --------------------------------------------------------
int __cdecl pattern_test_mode2(runtime_base_t *runtime, int freq, int *nonce)
{
  int v3; // r3
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  int counter_limit; // [sp+414h] [bp+414h]
  int patten_check_interval; // [sp+418h] [bp+418h]
  int is_match; // [sp+41Ch] [bp+41Ch]
  int one_patten_bin_len; // [sp+420h] [bp+420h]
  int chainid; // [sp+424h] [bp+424h]
  int counter; // [sp+428h] [bp+428h]
  int which_patten; // [sp+42Ch] [bp+42Ch]
  int which_core; // [sp+430h] [bp+430h]
  int which_asic; // [sp+434h] [bp+434h]

  chainid = runtime->chain_id;
  clear_last_test_results();
  runtime->set_ticket_mask(runtime->chain_status[chainid].fd, app_conf->ticket_mask);
  usleep(0x186A0u);
  runtime->set_core_timeout(runtime->chain_status[chainid].fd, app_conf->core_timeout);
  usleep(0x186A0u);
  runtime->set_frequency(runtime->chain_status[chainid].fd, freq);
  usleep(0x186A0u);
  runtime->set_nonce_shift(runtime->chain_status[chainid].fd, 0, &runtime->nonce_shift);
  one_patten_bin_len = g_patten.sol_bin_len + g_patten.work_bin_len + g_patten.nonce_bin_len;
  g_patten.start = 1;
  sleep(1u);
  for ( which_asic = 0; g_patten.asic_num > which_asic; ++which_asic )
  {
    for ( which_core = 0; g_patten.core_num > which_core; ++which_core )
    {
      for ( which_patten = 0; g_patten.patten_num > which_patten; ++which_patten )
      {
        pthread_mutex_lock(&g_patten.patten_mutex);
        g_patten.cur_work = &g_patten.patten_start[one_patten_bin_len * which_core * g_patten.patten_num
                                                 + one_patten_bin_len
                                                 * g_patten.patten_num
                                                 * which_asic
                                                 * g_patten.core_num
                                                 + one_patten_bin_len * which_patten];
        g_patten.cur_asic = which_asic;
        g_patten.cur_core = which_core;
        g_patten.cur_patten = which_patten;
        pthread_mutex_unlock(&g_patten.patten_mutex);
        --g_patten.cur_work[g_patten.work_bin_len - 1];
        user_send_work(runtime, g_patten.cur_work, 1, 0);
        is_match = 0;
        patten_check_interval = 50;
        counter_limit = app_conf->slt_work_interval_ms / 50;
        counter = 0;
        do
        {
          usleep(1000 * patten_check_interval);
          pthread_mutex_lock(&g_patten.patten_mutex);
          is_match = g_patten.is_nonce_match[g_patten.cur_patten
                                           + g_patten.patten_num
                                           * (g_patten.core_num * g_patten.cur_asic + g_patten.cur_core)];
          pthread_mutex_unlock(&g_patten.patten_mutex);
          if ( is_match == 1 )
            break;
          v3 = counter++;
        }
        while ( v3 < counter_limit );
        if ( is_match != 1 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf((char *)tmp42, 0x400u, "pattern id %d receive failed\n", which_patten);
            applog(2, tmp42, 0);
          }
          dump_str((void *)_bss_start, 0, g_patten.cur_work, g_patten.work_bin_len);
        }
      }
    }
  }
  g_patten.start = 0;
  *nonce = g_patten.recv_nonces;
  return 0;
}
// 483E0: using guessed type int _bss_start;

//----- (0001460C) --------------------------------------------------------
int __cdecl user_asic_init(runtime_base_t *runtime)
{
  int v2; // r0
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  int chainid; // [sp+408h] [bp+408h]
  int check_times; // [sp+40Ch] [bp+40Ch]

  chainid = runtime->chain_id;
  for ( check_times = 3; check_times > 0; --check_times )
  {
    check_asic_num(runtime);
    if ( runtime->chain_status[chainid].real_asic_num > 0 )
      break;
    sleep(1u);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "check again check_times = %d\n", check_times);
      applog(2, tmp42, 0);
    }
  }
  if ( check_times > 0 )
  {
    runtime->start_recv = 0;
    if ( runtime->baudrate != 115200 )
    {
      sleep(1u);
      runtime->set_baud(runtime->chain_status[chainid].fd, runtime->baudrate);
      sleep(1u);
      uart_exit(runtime->chain_status[chainid].fd);
      sleep(1u);
      v2 = uart_init(runtime->chain_status[chainid].comport, runtime->baudrate);
      runtime->chain_status[chainid].fd = v2;
      sleep(1u);
    }
    runtime->start_recv = 1;
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      strcpy((char *)tmp42, "check asic failed\n");
      applog(0, tmp42, 0);
    }
    return -1;
  }
}

//----- (000147E4) --------------------------------------------------------
int __cdecl user_check_communication(runtime_base_t *runtime)
{
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  reg_list_item_t item; // [sp+414h] [bp+40Ch] BYREF
  uint8_t regaddr; // [sp+422h] [bp+41Ah]
  uint8_t chipaddr; // [sp+423h] [bp+41Bh]
  int count_max; // [sp+424h] [bp+41Ch]
  int chainid; // [sp+428h] [bp+420h]
  int count; // [sp+42Ch] [bp+424h]

  chainid = runtime->chain_id;
  count = 0;
  count_max = 3;
  chipaddr = 0;
  regaddr = 0;
  item.chainid = chainid;
  item.chip_addr = 0;
  item.reg_addr = 0;
  item.reg_data = 0;
  item.age = 0;
  while ( 1 )
  {
    runtime->read_register(runtime->chain_status[chainid].fd, 1, 0, 0);
    if ( read_reg_item(&item, 500) >= 0 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s  failed %d\n", (const char *)_func___7272, count);
      applog(2, tmp42, 0);
    }
    sleep(1u);
    if ( ++count >= count_max )
      return -1;
  }
  return count;
}

//----- (00014900) --------------------------------------------------------
void __cdecl env_init(runtime_base_t *runtime)
{
  int chainid; // [sp+8h] [bp+8h]
  int sensorid; // [sp+Ch] [bp+Ch]

  strcpy((char *)runtime->asic_name, (const char *)app_conf->name);
  runtime->addr_interval = calc_asic_addr_interval(app_conf->asic_num);
  runtime->sensor_num = app_conf->sensor_num;
  for ( sensorid = 0; app_conf->sensor_num > sensorid; ++sensorid )
    runtime->sensor_pos[sensorid] = app_conf->sensor_pos[sensorid];
  runtime->chain_num = app_conf->comport_num;
  for ( chainid = 0; runtime->chain_num > chainid; ++chainid )
  {
    runtime->chain_status[chainid].comport = app_conf->comport[chainid];
    runtime->chain_status[chainid].design_asic_num = app_conf->asic_num;
  }
  runtime->baudrate = app_conf->baudrate;
  runtime->nonce_shift = 20;
  bm174x_init_asic(runtime);
  equihash_init_algo(runtime);
  equihash_miner_init(runtime);
}

//----- (00014A30) --------------------------------------------------------
void __cdecl randomize(void *p, int l)
{
  int *v2; // r0
  char *v3; // r0
  int *v4; // r0
  char *v5; // r0
  int *v6; // r0
  char *v7; // r0
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  int ret; // [sp+414h] [bp+40Ch]
  int fd; // [sp+418h] [bp+410h]
  const unsigned __int8 *fname; // [sp+41Ch] [bp+414h]

  fname = "/dev/urandom";
  fd = open("/dev/urandom", 0);
  if ( fd == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      v2 = _errno_location();
      v3 = strerror(*v2);
      snprintf((char *)tmp42, 0x400u, "open %s: %s\n", (const char *)fname, v3);
      applog(0, tmp42, 0);
    }
    exit(1);
  }
  ret = read(fd, p, l);
  if ( ret == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      snprintf((char *)tmp42, 0x400u, "read %s: %s\n", (const char *)fname, v5);
      applog(0, tmp42, 0);
    }
    exit(1);
  }
  if ( ret != l )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: short read %d bytes out of %d\n", (const char *)fname, ret, l);
      applog(0, tmp42, 0);
    }
    exit(1);
  }
  if ( close(fd) == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      v6 = _errno_location();
      v7 = strerror(*v6);
      snprintf((char *)tmp42, 0x400u, "close %s: %s\n", (const char *)fname, v7);
      applog(0, tmp42, 0);
    }
    exit(1);
  }
}

//----- (00014C44) --------------------------------------------------------
void __cdecl set_blocking_mode(int fd, int block)
{
  int *v2; // r0
  char *v3; // r0
  unsigned int v4; // r3
  int *v5; // r0
  char *v6; // r0
  int fda; // [sp+4h] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  int f; // [sp+40Ch] [bp+40Ch]

  fda = fd;
  f = fcntl(fd, 3);
  if ( f == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      v2 = _errno_location();
      v3 = strerror(*v2);
      snprintf((char *)tmp42, 0x400u, "fcntl F_GETFL: %s\n", v3);
      applog(0, tmp42, 0);
    }
    exit(1);
  }
  if ( block )
    v4 = f & 0xFFFFF7FF;
  else
    v4 = f | 0x800;
  if ( fcntl(fda, 4, v4) == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      v5 = _errno_location();
      v6 = strerror(*v5);
      snprintf((char *)tmp42, 0x400u, "fcntl F_SETFL: %s\n", v6);
      applog(0, tmp42, 0);
    }
    exit(1);
  }
}

//----- (00014D68) --------------------------------------------------------
uint8_t __cdecl hex2val(const unsigned __int8 *base, size_t off)
{
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 c; // [sp+417h] [bp+40Fh]

  c = base[off];
  if ( c > 0x2Fu && c <= 0x39u )
    return c - 48;
  if ( c > 0x60u && c <= 0x66u )
    return c - 87;
  if ( c > 0x40u && c <= 0x46u )
    return c - 55;
  if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf((char *)tmp42, 0x400u, "Invalid hex char at offset %zd: ...%c...\n", off, c);
    applog(0, tmp42, 0);
  }
  return 0;
}

//----- (00014E38) --------------------------------------------------------
unsigned __int8 *__cdecl s_hexdump(const void *_a, uint32_t a_len)
{
  uint32_t i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < a_len && i + 2 < 0x1000; ++i )
    sprintf((char *)&buf_7545[2 * i], "%02x", *((unsigned __int8 *)_a + i));
  buf_7545[2 * i] = 0;
  return buf_7545;
}

//----- (00014EA8) --------------------------------------------------------
void __cdecl hexdump(const unsigned __int8 *p, unsigned int len)
{
  unsigned __int8 v2; // r1
  unsigned int lena; // [sp+0h] [bp+0h] BYREF
  const unsigned __int8 *pa; // [sp+4h] [bp+4h]
  int pos; // [sp+Ch] [bp+Ch]
  unsigned __int8 v; // [sp+13h] [bp+13h]
  unsigned __int8 (*p_line)[]; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  unsigned int wordlen; // [sp+1Ch] [bp+1Ch]
  unsigned int addr; // [sp+20h] [bp+20h]
  unsigned int i; // [sp+24h] [bp+24h]

  pa = p;
  lena = len;
  wordlen = 4;
  v8 = 79;
  p_line = (unsigned __int8 (*)[])&lena;
  for ( addr = 0; addr < lena; addr += 16 )
  {
    for ( i = 0; i < 0x50; ++i )
    {
      if ( 2 * (wordlen + 26) == i || 2 * wordlen + 69 == i )
      {
        *((_BYTE *)p_line + i) = 124;
      }
      else if ( 2 * (wordlen + 35) == i )
      {
        *((_BYTE *)p_line + i) = 0;
      }
      else
      {
        *((_BYTE *)p_line + i) = 32;
      }
    }
    for ( i = 0; 2 * wordlen > i; ++i )
    {
      v = addr >> (4 * (2 * wordlen - i - 1));
      *((_BYTE *)p_line + i) = nibble[(addr >> (4 * (2 * wordlen - i - 1))) & 0xF];
    }
    for ( i = 0; i <= 0xF; ++i )
    {
      pos = (i >> 3) + 2 * wordlen + 3;
      if ( addr + i >= lena )
        break;
      v = pa[i + addr];
      *((_BYTE *)p_line + 3 * i + pos) = nibble[v >> 4];
      *((_BYTE *)p_line + 3 * i + pos + 1) = nibble[v & 0xF];
      if ( v <= 0x1Fu || v > 0x7Eu )
        v2 = 46;
      else
        v2 = v;
      *((_BYTE *)p_line + 2 * wordlen + i + 53) = v2;
    }
    fprintf((FILE *)_bss_start, "%s\n", (const char *)p_line);
  }
}
// 483E0: using guessed type int _bss_start;

//----- (00015078) --------------------------------------------------------
uint32_t __cdecl print_solver_line(uint8_t *soln, uint8_t *header, int fixed_nonce_bytes, unsigned __int8 *job_id)
{
  unsigned __int8 *v4; // r0
  unsigned __int8 *v5; // r0
  unsigned __int8 *job_ida; // [sp+8h] [bp+0h]
  int fixed_nonce_bytesa; // [sp+Ch] [bp+4h]
  uint8_t *headera; // [sp+10h] [bp+8h]
  uint8_t *solna; // [sp+14h] [bp+Ch]
  uint8_t buffer[1487]; // [sp+1Ch] [bp+14h] BYREF
  uint8_t *p; // [sp+5ECh] [bp+5E4h]

  solna = soln;
  headera = header;
  fixed_nonce_bytesa = fixed_nonce_bytes;
  job_ida = job_id;
  p = buffer;
  memcpy(buffer, header, 0x8Cu);
  memcpy(&buffer[140], &unk_346C4, 3u);
  p = &buffer[143];
  memcpy(&buffer[143], solna, 0x540u);
  printf("sol: %s ", (const char *)job_ida);
  p = headera + 100;
  printf("%02x%02x%02x%02x ", headera[100], headera[101], headera[102], headera[103]);
  v4 = s_hexdump(&headera[fixed_nonce_bytesa + 108], 32 - fixed_nonce_bytesa);
  printf("%s ", (const char *)v4);
  v5 = s_hexdump(&buffer[143], 0x540u);
  printf("%s%s\n", "fd4005", (const char *)v5);
  fflush((FILE *)stdout);
  return 1;
}
// 483EC: using guessed type int stdout;

//----- (000151A8) --------------------------------------------------------
void *__cdecl memrchr(const void *s, int c, size_t n)
{
  const unsigned __int8 *end; // [sp+14h] [bp+14h]

  end = (const unsigned __int8 *)s + n;
  while ( --end >= s )
  {
    if ( *end == c )
      return (void *)end;
  }
  return 0;
}

//----- (000151F0) --------------------------------------------------------
int __cdecl read_last_line(unsigned __int8 *buf, size_t len, int block)
{
  int *v4; // r0
  char *v5; // r0
  int *v6; // r0
  char *v7; // r0
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 *start; // [sp+414h] [bp+414h]
  ssize_t n; // [sp+418h] [bp+418h]
  size_t pos; // [sp+41Ch] [bp+41Ch]

  pos = 0;
  set_blocking_mode(0, block);
  do
  {
    while ( 1 )
    {
      do
        n = read(0, &buf[pos], len - pos);
      while ( n == -1 && *_errno_location() == 4 );
      if ( n != -1 || *_errno_location() != 11 && *_errno_location() != 11 )
        break;
      if ( !pos )
        return 0;
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        v4 = _errno_location();
        v5 = strerror(*v4);
        snprintf((char *)tmp42, 0x400u, "strange: a partial line was read %s\n", v5);
        applog(1, tmp42, 0);
      }
      set_blocking_mode(0, 1);
    }
    if ( n == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        v6 = _errno_location();
        v7 = strerror(*v6);
        snprintf((char *)tmp42, 0x400u, "read stdin: %s\n", v7);
        applog(0, tmp42, 0);
      }
    }
    else if ( !n && (use_syslog || opt_log_output || opt_log_level >= 0) )
    {
      snprintf((char *)tmp42, 0x400u, "%s EOF on stdin\n", (const char *)_func___7604);
      applog(0, tmp42, 0);
    }
    pos += n;
  }
  while ( buf[pos - 1] != 10 );
  start = (unsigned __int8 *)memrchr(buf, 10, pos - 1);
  if ( start )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s strange: more than 1 line was read\n", (const char *)_func___7604);
      applog(1, tmp42, 0);
    }
    pos -= start + 1 - buf;
    memmove(buf, start + 1, pos);
  }
  buf[pos - 1] = 0;
  return 1;
}

//----- (00015498) --------------------------------------------------------
void __cdecl mining_parse_job(
        unsigned __int8 *str,
        uint8_t *target,
        int target_len,
        unsigned __int8 *job_id,
        int job_id_len,
        uint8_t *header,
        int header_len,
        int *fixed_nonce_bytes)
{
  char v8; // r5
  char v9; // r5
  char v10; // r5
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+10h] BYREF
  uint32_t i; // [sp+410h] [bp+410h]
  uint32_t str_i; // [sp+414h] [bp+414h]

  str_i = 0;
  i = 0;
  while ( i < target_len )
  {
    v8 = 16 * hex2val(str, str_i);
    target[i++] = hex2val(str, str_i + 1) + v8;
    str_i += 2;
  }
  if ( str[str_i] != 32 )
    _assert_fail("str[str_i] == ' '", "bm174x/equihash-miner.c", 0x152u, (const char *)_PRETTY_FUNCTION___7623);
  ++str_i;
  for ( i = 0; i < job_id_len && str[str_i] != 32; job_id[i++] = str[str_i++] )
    ;
  if ( str[str_i] != 32 )
    _assert_fail("str[str_i] == ' '", "bm174x/equihash-miner.c", 0x158u, (const char *)_PRETTY_FUNCTION___7623);
  if ( i >= job_id_len )
    _assert_fail("i < job_id_len", "bm174x/equihash-miner.c", 0x159u, (const char *)_PRETTY_FUNCTION___7623);
  job_id[i] = 0;
  ++str_i;
  i = 0;
  while ( i < header_len && str[str_i] != 32 )
  {
    v9 = 16 * hex2val(str, str_i);
    header[i++] = hex2val(str, str_i + 1) + v9;
    str_i += 2;
  }
  if ( str[str_i] != 32 )
    _assert_fail("str[str_i] == ' '", "bm174x/equihash-miner.c", 0x160u, (const char *)_PRETTY_FUNCTION___7623);
  ++str_i;
  *fixed_nonce_bytes = 0;
  while ( i < header_len && str[str_i] )
  {
    v10 = 16 * hex2val(str, str_i);
    header[i++] = hex2val(str, str_i + 1) + v10;
    str_i += 2;
    ++*fixed_nonce_bytes;
  }
  if ( str[str_i] )
    _assert_fail("!str[str_i]", "bm174x/equihash-miner.c", 0x16Bu, (const char *)_PRETTY_FUNCTION___7623);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf((char *)tmp42, 0x400u, "Randomizing %d bytes in nonce\n", header_len - i - 12);
    applog(4, tmp42, 0);
  }
  randomize(&header[i], header_len - i - 12);
  memset(&header[header_len - 12], 0, 0xCu);
}

//----- (00015828) --------------------------------------------------------
void *__cdecl __noreturn mining_mode(void *args)
{
  unsigned __int8 line[4096]; // [sp+418h] [bp+408h] BYREF
  uint64_t i; // [sp+1418h] [bp+1408h]
  runtime_base_t *runtime; // [sp+1424h] [bp+1414h]

  runtime = (runtime_base_t *)args;
  i = 0LL;
  puts("SILENTARMY mining mode ready");
  fflush((FILE *)stdout);
  while ( 1 )
  {
    do
      usleep(0x186A0u);
    while ( !read_last_line(line, 0x1000u, i == 0) );
    pthread_mutex_lock(&g_work_info.work_info_mutex);
    mining_parse_job(
      line,
      g_work_info.target,
      32,
      g_work_info.job_id,
      256,
      g_work_info.header,
      140,
      &g_work_info.fixed_nonce_bytes);
    user_send_work(runtime, g_work_info.header, 0, 0);
    pthread_mutex_unlock(&g_work_info.work_info_mutex);
  }
}
// 483EC: using guessed type int stdout;

//----- (0001591C) --------------------------------------------------------
__int64 miner_now()
{
  timeval tv; // [sp+0h] [bp+0h] BYREF

  gettimeofday(&tv, 0);
  return tv.tv_usec + 1000000LL * tv.tv_sec;
}

//----- (00015994) --------------------------------------------------------
void __cdecl equihash_nonce_submit(uint8_t *nonce, uint8_t *verify, int fixed_nonce_bytes, unsigned __int8 *job_id)
{
  int v4; // r2
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF

  ++total_7653;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v4 = golden_nonce_7652++;
    snprintf((char *)tmp42, 0x400u, "Golden Nonce Found! %d\n", v4);
    applog(3, tmp42, 0);
  }
  print_solver_line(nonce, verify, fixed_nonce_bytes, job_id);
  ++total_shares_7654;
  t1_7656 = miner_now();
  if ( status_period_7657 + t0_7655 < t1_7656 )
  {
    t0_7655 = t1_7656;
    printf("status: %lld %lld\n", total_7653, total_shares_7654);
    fflush((FILE *)stdout);
  }
}
// 483EC: using guessed type int stdout;

//----- (00015B0C) --------------------------------------------------------
void __cdecl equihash_miner_init(runtime_base_t *runtime)
{
  runtime->nonce_submit = (void (*)(uint8_t *, uint8_t *, int, unsigned __int8 *))equihash_nonce_submit;
}

//----- (00015B30) --------------------------------------------------------
void __cdecl equihash_miner_start(runtime_base_t *runtime)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF

  if ( pthread_create(&p_miner, 0, (void *(*)(void *))mining_mode, runtime) )
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      strcpy((char *)tmp42, "create mining mode thread failed\n");
      applog(0, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    strcpy((char *)tmp42, "create mining mode thread successed\n");
    applog(0, tmp42, 0);
  }
}

//----- (00015C18) --------------------------------------------------------
void equihash_miner_join()
{
  pthread_join(p_miner, 0);
}

//----- (00015C34) --------------------------------------------------------
unsigned int __cdecl _bswap_32(unsigned int __bsx)
{
  return bswap32(__bsx);
}

//----- (00015C4C) --------------------------------------------------------
void __cdecl compressArray(
        const unsigned __int8 *in,
        const size_t in_len,
        unsigned __int8 *out,
        const size_t out_len,
        const size_t bit_len,
        const size_t byte_pad)
{
  size_t in_width; // [sp+18h] [bp+18h]
  size_t x; // [sp+1Ch] [bp+1Ch]
  size_t i; // [sp+20h] [bp+20h]
  size_t j; // [sp+24h] [bp+24h]
  uint32_t acc_value; // [sp+28h] [bp+28h]
  size_t acc_bits; // [sp+2Ch] [bp+2Ch]

  if ( bit_len <= 7 )
    _assert_fail("bit_len >= 8", "bm174x/equihash-verify.c", 0x14u, (const char *)_PRETTY_FUNCTION___7349);
  if ( bit_len + 7 > 0x20 )
    _assert_fail(
      "8 * sizeof(uint32_t) >= 7 + bit_len",
      "bm174x/equihash-verify.c",
      0x15u,
      (const char *)_PRETTY_FUNCTION___7349);
  in_width = byte_pad + ((bit_len + 7) >> 3);
  if ( in_len * bit_len / (8 * in_width) != out_len )
    _assert_fail(
      "out_len == bit_len * in_len / (8 * in_width)",
      "bm174x/equihash-verify.c",
      0x18u,
      (const char *)_PRETTY_FUNCTION___7349);
  acc_bits = 0;
  acc_value = 0;
  j = 0;
  for ( i = 0; i < out_len; ++i )
  {
    if ( acc_bits <= 7 )
    {
      acc_value <<= bit_len;
      for ( x = byte_pad; x < in_width; ++x )
        acc_value |= (((unsigned int)((1 << bit_len) - 1) >> (8 * (in_width - x - 1))) & in[x + j]) << (8 * (in_width - x - 1));
      j += in_width;
      acc_bits += bit_len;
    }
    acc_bits -= 8;
    out[i] = acc_value >> acc_bits;
  }
}

//----- (00015DAC) --------------------------------------------------------
void __cdecl expandArray(
        const unsigned __int8 *in,
        const size_t in_len,
        unsigned __int8 *out,
        const size_t out_len,
        const size_t bit_len,
        const size_t byte_pad)
{
  size_t out_width; // [sp+14h] [bp+14h]
  size_t x_0; // [sp+18h] [bp+18h]
  size_t x; // [sp+1Ch] [bp+1Ch]
  size_t i; // [sp+20h] [bp+20h]
  size_t j; // [sp+24h] [bp+24h]
  unsigned int acc_value; // [sp+28h] [bp+28h]
  size_t acc_bits; // [sp+2Ch] [bp+2Ch]

  if ( bit_len <= 7 )
    _assert_fail("bit_len >= 8", "bm174x/equihash-verify.c", 0x3Eu, (const char *)_PRETTY_FUNCTION___7371);
  if ( bit_len + 7 > 0x20 )
    _assert_fail(
      "8 * sizeof(uint32_t) >= 7 + bit_len",
      "bm174x/equihash-verify.c",
      0x3Fu,
      (const char *)_PRETTY_FUNCTION___7371);
  out_width = byte_pad + ((bit_len + 7) >> 3);
  if ( 8 * in_len * out_width / bit_len != out_len )
    _assert_fail(
      "out_len == 8 * out_width * in_len / bit_len",
      "bm174x/equihash-verify.c",
      0x42u,
      (const char *)_PRETTY_FUNCTION___7371);
  acc_bits = 0;
  acc_value = 0;
  j = 0;
  for ( i = 0; i < in_len; ++i )
  {
    acc_value = (acc_value << 8) | in[i];
    acc_bits += 8;
    if ( acc_bits >= bit_len )
    {
      acc_bits -= bit_len;
      for ( x = 0; x < byte_pad; ++x )
        out[x + j] = 0;
      for ( x_0 = byte_pad; x_0 < out_width; ++x_0 )
        out[x_0 + j] = ((unsigned int)((1 << bit_len) - 1) >> (8 * (out_width - x_0 - 1))) & (acc_value >> (acc_bits + 8 * (out_width - x_0 - 1)));
      j += out_width;
    }
  }
}

//----- (00015F24) --------------------------------------------------------
int __cdecl getIndices(
        const uint8_t *hash,
        size_t len,
        size_t lenIndices,
        size_t cBitLen,
        uint8_t *data,
        size_t maxLen)
{
  if ( cBitLen + 8 > 0x27 )
    _assert_fail(
      "((cBitLen + 1) + 7) / 8 <= sizeof(uint32_t)",
      "bm174x/equihash-verify.c",
      0x6Cu,
      (const char *)_PRETTY_FUNCTION___7397);
  if ( (lenIndices * (cBitLen + 1)) >> 5 > maxLen )
    return -1;
  if ( data )
    compressArray(
      &hash[len],
      lenIndices,
      data,
      (lenIndices * (cBitLen + 1)) >> 5,
      cBitLen + 1,
      4 - ((cBitLen + 8) >> 3));
  return (lenIndices * (cBitLen + 1)) >> 5;
}

//----- (00015FAC) --------------------------------------------------------
int __cdecl isZero(const uint8_t *hash, size_t len)
{
  size_t i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < len; ++i )
  {
    if ( hash[i] )
      return 0;
  }
  return 1;
}

//----- (00015FE8) --------------------------------------------------------
void __cdecl generateHash(blake2b_state *S, const uint32_t g, uint8_t *hash, const size_t hashLen)
{
  uint8_t hashLena; // [sp+0h] [bp+0h]
  blake2b_state digest; // [sp+10h] [bp+10h] BYREF
  uint32_t le_g[2]; // [sp+17Ch] [bp+17Ch] BYREF

  hashLena = hashLen;
  le_g[0] = g;
  memcpy(&digest, S, sizeof(digest));
  blake2b_update(&digest, (const uint8_t *)le_g, 4uLL);
  blake2b_final(&digest, hash, hashLena);
}
// 15FE8: using guessed type uint32_t le_g[2];

//----- (00016054) --------------------------------------------------------
int __cdecl compareSR(const void *p1, const void *p2)
{
  return memcmp(p1, p2, compare_size);
}

//----- (0001607C) --------------------------------------------------------
void __cdecl sort_pair(uint32_t *a, uint32_t len)
{
  uint32_t tmp; // [sp+8h] [bp+8h]
  uint32_t *b; // [sp+Ch] [bp+Ch]
  uint32_t i; // [sp+10h] [bp+10h]
  uint32_t need_sorting; // [sp+14h] [bp+14h]

  b = &a[len];
  need_sorting = 0;
  for ( i = 0; i < len; ++i )
  {
    if ( need_sorting || a[i] > b[i] )
    {
      need_sorting = 1;
      tmp = a[i];
      a[i] = b[i];
      b[i] = tmp;
    }
    else if ( a[i] < b[i] )
    {
      return;
    }
  }
}

//----- (00016120) --------------------------------------------------------
int __cdecl sortValidator(void *data, const unsigned __int8 *soln)
{
  int v2; // r3
  unsigned int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  uint8_t tmpHash[50]; // [sp+14h] [bp+Ch] BYREF
  int i_4; // [sp+48h] [bp+40h] BYREF
  uint8_t hash_0[30]; // [sp+4Ch] [bp+44h] BYREF
  uint8_t hash[30]; // [sp+6Ch] [bp+64h] BYREF
  uint8_t tmp_data[1344]; // [sp+8Ch] [bp+84h] BYREF
  uint32_t real_indices[512]; // [sp+5CCh] [bp+5C4h] BYREF
  uint8_t tmp_hash[30]; // [sp+DCCh] [bp+DC4h] BYREF
  uint8_t vHash[30]; // [sp+DECh] [bp+DE4h] BYREF
  uint32_t indices[512]; // [sp+E0Ch] [bp+E04h] BYREF
  uint8_t *__tmp_0; // [sp+160Ch] [bp+1604h]
  uint8_t *__tmp; // [sp+1610h] [bp+1608h]
  int i_0; // [sp+1614h] [bp+160Ch]
  unsigned __int8 *hex_buff; // [sp+1618h] [bp+1610h]
  int solnr; // [sp+161Ch] [bp+1614h]
  int equihashSolutionSize; // [sp+1620h] [bp+1618h]
  int hashOutput; // [sp+1624h] [bp+161Ch]
  int indicesPerHashOutput; // [sp+1628h] [bp+1620h]
  uint32_t hashLength; // [sp+162Ch] [bp+1624h]
  int collisionByteLength; // [sp+1630h] [bp+1628h]
  int collisionBitLength; // [sp+1634h] [bp+162Ch]
  blake2b_state *digest; // [sp+1638h] [bp+1630h]
  int k; // [sp+163Ch] [bp+1634h]
  int n; // [sp+1640h] [bp+1638h]
  const validData *v; // [sp+1644h] [bp+163Ch]
  uint32_t index_0; // [sp+1648h] [bp+1640h]
  uint32_t j_3; // [sp+164Ch] [bp+1644h]
  int i_5; // [sp+1650h] [bp+1648h]
  int j_2; // [sp+1654h] [bp+164Ch]
  int i_3; // [sp+1658h] [bp+1650h]
  uint32_t level; // [sp+165Ch] [bp+1654h]
  int i_2; // [sp+1660h] [bp+1658h]
  uint32_t index; // [sp+1664h] [bp+165Ch]
  size_t j_1; // [sp+1668h] [bp+1660h]
  int i_1; // [sp+166Ch] [bp+1664h]
  uint32_t m; // [sp+1670h] [bp+1668h]
  int j_0; // [sp+1674h] [bp+166Ch]
  int j; // [sp+1678h] [bp+1670h]
  int i; // [sp+167Ch] [bp+1674h]
  uint32_t xc_size; // [sp+1680h] [bp+1678h]
  uint8_t *xc; // [sp+1684h] [bp+167Ch]
  uint8_t *x; // [sp+1688h] [bp+1680h]
  int err_type; // [sp+168Ch] [bp+1684h]
  uint32_t x_size; // [sp+1690h] [bp+1688h]
  uint32_t indicesLen; // [sp+1694h] [bp+168Ch]

  v = (const validData *)data;
  n = *(_DWORD *)data;
  k = *((_DWORD *)data + 1);
  digest = (blake2b_state *)*((_DWORD *)data + 2);
  collisionBitLength = n / (k + 1);
  v2 = collisionBitLength + 7;
  if ( collisionBitLength + 7 < 0 )
    v2 = collisionBitLength + 14;
  collisionByteLength = v2 >> 3;
  hashLength = (v2 >> 3) * (k + 1);
  indicesPerHashOutput = 512 / n;
  hashOutput = n * (512 / n) / 8;
  equihashSolutionSize = ((n / (k + 1) + 1) << k) / 8;
  solnr = 512;
  indicesLen = 4;
  x_size = 512;
  err_type = 0;
  compare_size = 3;
  expandArray(soln, equihashSolutionSize, (unsigned __int8 *)indices, 0x800u, collisionBitLength + 1, 1u);
  memset(vHash, 0, sizeof(vHash));
  x = (uint8_t *)malloc(0x4400u);
  xc = (uint8_t *)malloc(0x4400u);
  hex_buff = 0;
  xc_size = 0;
  memset(tmp_hash, 0, sizeof(tmp_hash));
  for ( i = 0; i < solnr; ++i )
  {
    for ( j = i + 1; j < solnr; ++j )
    {
      if ( indices[i] == indices[j] )
      {
        err_type = 1;
        goto failed;
      }
    }
  }
  for ( j_0 = 0; j_0 < solnr; ++j_0 )
  {
    i_0 = _bswap_32(indices[j_0]);
    generateHash(digest, i_0 / indicesPerHashOutput, tmpHash, hashOutput);
    expandArray(&tmpHash[n * (i_0 % indicesPerHashOutput) / 8], n / 8, hash, hashLength, collisionBitLength, 0);
    for ( m = 0; m < hashLength; ++m )
      vHash[m] ^= hash[m];
    memcpy(&x[j_0 * (indicesLen + hashLength)], hash, hashLength);
    memcpy(&x[hashLength + j_0 * (indicesLen + hashLength)], &indices[j_0], indicesLen);
  }
  if ( isZero(vHash, 0x1Eu) )
  {
    memset(vHash, 0, sizeof(vHash));
    for ( i_1 = 0; i_1 <= 8; ++i_1 )
    {
      qsort(x, x_size, hashLength + indicesLen, (__compar_fn_t)compareSR);
      xc_size = 0;
      for ( j_1 = 0; j_1 < x_size; j_1 += 2 )
      {
        for ( index = 0; index < hashLength; ++index )
          tmp_hash[index] = x[index + (j_1 + 1) * (indicesLen + hashLength)] ^ x[index + j_1 * (indicesLen + hashLength)];
        memcpy(&xc[(j_1 >> 1) * (hashLength + 2 * indicesLen)], tmp_hash, hashLength);
        memcpy(
          &xc[hashLength + (j_1 >> 1) * (hashLength + 2 * indicesLen)],
          &x[hashLength + j_1 * (indicesLen + hashLength)],
          indicesLen);
        memcpy(
          &xc[indicesLen + (j_1 >> 1) * (hashLength + 2 * indicesLen) + hashLength],
          &x[hashLength + (j_1 + 1) * (indicesLen + hashLength)],
          indicesLen);
        ++xc_size;
      }
      indicesLen *= 2;
      __tmp = x;
      x = xc;
      xc = __tmp;
      x_size = xc_size;
      compare_size += 3;
    }
    for ( i_2 = 0; i_2 < 512; ++i_2 )
    {
      v3 = _bswap_32(*(_DWORD *)&x[4 * i_2 + hashLength]);
      real_indices[i_2] = v3;
    }
    for ( level = 0; level <= 8; ++level )
    {
      for ( i_3 = 0; i_3 < 512; i_3 += 2 << level )
        sort_pair(&real_indices[i_3], 1 << level);
    }
    indicesLen = 4;
    x_size = 512;
    for ( j_2 = 0; j_2 < solnr; ++j_2 )
    {
      i_4 = real_indices[j_2];
      generateHash(digest, i_4 / indicesPerHashOutput, tmpHash, hashOutput);
      expandArray(&tmpHash[n * (i_4 % indicesPerHashOutput) / 8], n / 8, hash_0, hashLength, collisionBitLength, 0);
      i_4 = _bswap_32(real_indices[j_2]);
      memcpy(&x[j_2 * (indicesLen + hashLength)], hash_0, hashLength);
      memcpy(&x[hashLength + j_2 * (indicesLen + hashLength)], &i_4, indicesLen);
      hex_buff = bin2hex(&x[j_2 * (indicesLen + hashLength)], 0x22u);
      free(hex_buff);
    }
    for ( i_5 = 0; i_5 <= 8; ++i_5 )
    {
      xc_size = 0;
      for ( j_3 = 0; j_3 < x_size; j_3 += 2 )
      {
        for ( index_0 = 0; index_0 < hashLength; ++index_0 )
          tmp_hash[index_0] = x[index_0 + (j_3 + 1) * (indicesLen + hashLength)] ^ x[index_0
                                                                                   + j_3 * (indicesLen + hashLength)];
        memcpy(&xc[(j_3 >> 1) * (hashLength + 2 * indicesLen)], tmp_hash, hashLength);
        memcpy(
          &xc[hashLength + (j_3 >> 1) * (hashLength + 2 * indicesLen)],
          &x[hashLength + j_3 * (indicesLen + hashLength)],
          indicesLen);
        memcpy(
          &xc[indicesLen + (j_3 >> 1) * (hashLength + 2 * indicesLen) + hashLength],
          &x[hashLength + (j_3 + 1) * (indicesLen + hashLength)],
          indicesLen);
        ++xc_size;
      }
      indicesLen *= 2;
      __tmp_0 = x;
      x = xc;
      xc = __tmp_0;
      x_size = xc_size;
      compare_size += 3;
    }
    getIndices(x, hashLength, 0x800u, 0x14u, tmp_data, 0x540u);
    hex_buff = bin2hex(tmp_data, 0x540u);
    free(hex_buff);
    hex_buff = bin2hex(x, indicesLen + hashLength);
    free(hex_buff);
    v4 = *((_DWORD *)x + 1);
    v5 = *((_DWORD *)x + 2);
    v6 = *((_DWORD *)x + 3);
    *(_DWORD *)vHash = *(_DWORD *)x;
    *(_DWORD *)&vHash[4] = v4;
    *(_DWORD *)&vHash[8] = v5;
    *(_DWORD *)&vHash[12] = v6;
    v7 = *((_DWORD *)x + 5);
    v8 = *((_DWORD *)x + 6);
    *(_DWORD *)&vHash[16] = *((_DWORD *)x + 4);
    *(_DWORD *)&vHash[20] = v7;
    *(_DWORD *)&vHash[24] = v8;
    *(_WORD *)&vHash[28] = *((_WORD *)x + 14);
    if ( !isZero(vHash, 0x1Eu) )
      err_type = 3;
  }
  else
  {
    err_type = 2;
  }
failed:
  free(x);
  free(xc);
  return err_type;
}

//----- (000170F4) --------------------------------------------------------
void __cdecl zcashPerson(uint8_t *person, const int n, const int k)
{
  memcpy(person, "ZcashPoW", 8u);
  *((_DWORD *)person + 2) = n;
  *((_DWORD *)person + 3) = k;
}

//----- (00017128) --------------------------------------------------------
void __cdecl digestInit(blake2b_state *S, const int n, const int k)
{
  blake2b_param P[1]; // [sp+10h] [bp+10h] BYREF

  memset(P, 0, sizeof(P));
  P[0].fanout = 1;
  P[0].depth = 1;
  P[0].digest_length = n * (512 / n) / 8;
  zcashPerson(P[0].personal, n, k);
  blake2b_init_param(S, P);
}

//----- (00017194) --------------------------------------------------------
uint32_t __cdecl target_zero_cal(uint8_t *target)
{
  uint8_t tmphash[32]; // [sp+8h] [bp+8h] BYREF
  int j; // [sp+28h] [bp+28h]
  int i_0; // [sp+2Ch] [bp+2Ch]
  int i; // [sp+30h] [bp+30h]
  uint32_t zero_num; // [sp+34h] [bp+34h]

  zero_num = 0;
  memset(tmphash, 0, sizeof(tmphash));
  for ( i = 0; i <= 31; ++i )
    tmphash[i] = target[31 - i];
  for ( i_0 = 0; i_0 <= 31; ++i_0 )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( bit_read(&tmphash[i_0], j) )
        return zero_num;
      ++zero_num;
    }
  }
  return zero_num;
}

//----- (00017228) --------------------------------------------------------
bool __cdecl equihash_target_match(unsigned __int8 *result_value, unsigned __int8 *target)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 31; i >= 0; --i )
  {
    if ( result_value[i] < (unsigned int)target[i] )
      return 1;
    if ( result_value[i] > (unsigned int)target[i] )
      return 0;
  }
  return 1;
}

//----- (00017288) --------------------------------------------------------
uint32_t __cdecl targetValidator(const uint8_t *work, const uint8_t *nonce, uint8_t *target)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  uint8_t output[32]; // [sp+14h] [bp+14h] BYREF
  uint8_t tmphash[32]; // [sp+34h] [bp+34h] BYREF
  uint8_t input[1487]; // [sp+54h] [bp+54h] BYREF
  uint8_t str[3]; // [sp+624h] [bp+624h]

  *(_WORD *)str = 16637;
  str[2] = 5;
  memset(input, 0, sizeof(input));
  memset(tmphash, 0, sizeof(tmphash));
  memset(output, 0, sizeof(output));
  memcpy(input, work, 0x8Cu);
  *(_WORD *)&input[140] = 16637;
  input[142] = 5;
  memcpy(&input[143], nonce, 0x540u);
  Sha256_Onestep(input, 0x5CFu, tmphash);
  Sha256_Onestep(tmphash, 0x20u, output);
  v3 = *(_DWORD *)&output[4];
  v4 = *(_DWORD *)&output[8];
  v5 = *(_DWORD *)&output[12];
  *(_DWORD *)target = *(_DWORD *)output;
  *((_DWORD *)target + 1) = v3;
  *((_DWORD *)target + 2) = v4;
  *((_DWORD *)target + 3) = v5;
  v6 = *(_DWORD *)&output[20];
  v7 = *(_DWORD *)&output[24];
  v8 = *(_DWORD *)&output[28];
  *((_DWORD *)target + 4) = *(_DWORD *)&output[16];
  *((_DWORD *)target + 5) = v6;
  *((_DWORD *)target + 6) = v7;
  *((_DWORD *)target + 7) = v8;
  return target_zero_cal(output);
}

//----- (0001737C) --------------------------------------------------------
int __cdecl equihash_nonce_verify(nonce_verify_info_t *verify_info, int *tm, uint32_t shift)
{
  validData valData; // [sp+14h] [bp+14h] BYREF
  blake2b_state digest[1]; // [sp+20h] [bp+20h] BYREF
  int valid; // [sp+18Ch] [bp+18Ch]

  memcpy(&verify_info->work[verify_info->work_len - shift - 4], verify_info->nonce, verify_info->nonce_len);
  valData.n = 200;
  valData.k = 9;
  valData.digest = digest;
  digestInit(digest, 200, 9);
  blake2b_update(digest, verify_info->work, verify_info->work_len);
  valid = sortValidator(&valData, verify_info->sol);
  *tm = targetValidator(verify_info->work, verify_info->sol, verify_info->target);
  return valid;
}

//----- (00017464) --------------------------------------------------------
void __cdecl equihash_init_algo(void *args)
{
  *((_DWORD *)args + 423) = 140;
  *((_DWORD *)args + 424) = 4;
  *((_DWORD *)args + 425) = 1344;
  *((_DWORD *)args + 426) = 32;
  *((_DWORD *)args + 735) = equihash_target_match;
  *((_DWORD *)args + 734) = equihash_nonce_verify;
}

//----- (000174BC) --------------------------------------------------------
void pcba_app_manual_test()
{
  ;
}

//----- (000174CC) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 command[64]; // [sp+400h] [bp+400h] BYREF
  runtime_base_t *runtime; // [sp+440h] [bp+440h]
  int ret; // [sp+444h] [bp+444h]

  memset(command, 0, sizeof(command));
  app_conf = app_config_init("/mnt/card/Config.ini");
  runtime = (runtime_base_t *)calloc(0xB94u, 1u);
  env_init(runtime);
  if ( !app_conf )
    return -1;
  if ( cgpu_init(runtime) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "cgpu init failed\n");
      applog(2, tmp42, 0);
    }
    return -1;
  }
  display_arguments();
  fan_control(2u);
  while ( 1 )
  {
    memset(command, 0, sizeof(command));
    if ( strcmp((const char *)app_conf->pcba_repeat_ctrl, "keyboard") )
      break;
    ret = _isoc99_fscanf(stdin, "%s", command);
LABEL_18:
    if ( ret > 0 && command[0] == 48 )
      singleBoardTest_Z15_BM1746();
    usleep(0x186A0u);
  }
  if ( !strcmp((const char *)app_conf->pcba_repeat_ctrl, "button") )
  {
    ret = v9_key_read(command, 64);
    goto LABEL_18;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "please assign ctrl type: keyboard or button\n");
    applog(2, tmp42, 0);
  }
  free(runtime);
  app_config_exit(app_conf);
  cgpu_exit();
  return 0;
}
// 10F7C: using guessed type int _isoc99_fscanf(_DWORD, const char *, ...);
// 483E8: using guessed type int stdin;

//----- (000176B4) --------------------------------------------------------
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  unsigned __int8 crcout[5]; // [sp+Ch] [bp+Ch]
  int crcin; // [sp+14h] [bp+14h]
  char crcin_4; // [sp+18h] [bp+18h]
  bool din; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 crc; // [sp+1Ch] [bp+1Ch]
  unsigned __int8 k; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 j; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  crcin = 16843009;
  crcin_4 = 1;
  j = 0x80;
  k = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    din = (j & *ptr) != 0;
    crcout[0] = din ^ crcin_4;
    crcout[1] = crcin;
    crcout[2] = din ^ crcin_4 ^ BYTE1(crcin);
    *(_WORD *)&crcout[3] = HIWORD(crcin);
    j >>= 1;
    if ( ++k == 8 )
    {
      j = 0x80;
      k = 0;
      ++ptr;
    }
    crcin = *(_DWORD *)crcout;
    crcin_4 = crcout[4];
  }
  crc = 0;
  if ( crcin_4 )
    crc = 16;
  if ( HIBYTE(crcin) )
    crc |= 8u;
  if ( BYTE2(crcin) )
    crc |= 4u;
  if ( BYTE1(crcin) )
    crc |= 2u;
  if ( (_BYTE)crcin )
    crc |= 1u;
  return crc;
}

//----- (000177D4) --------------------------------------------------------
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len)
{
  const uint8_t *v2; // r3
  uint16_t wIndex; // [sp+Ch] [bp+Ch]
  uint8_t chCRCLo; // [sp+Eh] [bp+Eh]
  uint8_t chCRCHi; // [sp+Fh] [bp+Fh]

  chCRCHi = -1;
  chCRCLo = -1;
  while ( w_len-- )
  {
    v2 = p_data++;
    wIndex = (unsigned __int8)(chCRCLo ^ *v2);
    chCRCLo = chCRCHi ^ chCRCHTalbe[chCRCLo ^ *v2];
    chCRCHi = chCRCLTalbe[wIndex];
  }
  return chCRCLo | (chCRCHi << 8);
}

//----- (00017844) --------------------------------------------------------
int bitmain_axi_init()
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+0h] BYREF
  unsigned int data; // [sp+408h] [bp+400h]
  int ret; // [sp+40Ch] [bp+404h]

  ret = 0;
  fd_fpga = open("/dev/axi_fpga_dev", 2);
  if ( fd_fpga >= 0 )
  {
    axi_fpga_addr = (unsigned int *)mmap(0, 0x1200u, 3, 1, fd_fpga, 0);
    if ( axi_fpga_addr )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "mmap axi_fpga_addr = 0x%p\n", axi_fpga_addr);
        applog(2, tmp42, 0);
      }
      data = (unsigned __int16)*axi_fpga_addr;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "axi_fpga_addr data = 0x%x\n", data);
        applog(2, tmp42, 0);
      }
      fd_fpga_mem = open("/dev/fpga_mem", 2);
      if ( fd_fpga_mem >= 0 )
      {
        fpga_mem_addr = (unsigned int *)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
        if ( fpga_mem_addr )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf((char *)tmp42, 0x400u, "mmap fpga_mem_addr = 0x%p\n", fpga_mem_addr);
            applog(2, tmp42, 0);
          }
          return ret;
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf((char *)tmp42, 0x400u, "mmap fpga_mem_addr failed. fpga_mem_addr = 0x%p\n", fpga_mem_addr);
            applog(2, tmp42, 0);
          }
          return -1;
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "/dev/fpga_mem open failed. fd_fpga_mem = %d\n", fd_fpga_mem);
          applog(2, tmp42, 0);
        }
        return -1;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "mmap axi_fpga_addr failed. axi_fpga_addr = 0x%p\n", axi_fpga_addr);
        applog(2, tmp42, 0);
      }
      return -1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "/dev/axi_fpga_dev open failed. fd = %d\n", fd_fpga);
      applog(2, tmp42, 0);
    }
    return -1;
  }
}

//----- (00017B84) --------------------------------------------------------
void bitmain_axi_close()
{
  unsigned __int8 tmp42[1024]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+404h] [bp+404h]

  ret = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___7417);
    applog(2, tmp42, 0);
  }
  ret = munmap(axi_fpga_addr, 0x1200u);
  if ( ret < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(2, tmp42, 0);
  }
  ret = munmap(fpga_mem_addr, 0x1000000u);
  if ( ret < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(2, tmp42, 0);
  }
  close(fd_fpga);
  close(fd_fpga_mem);
}

//----- (00017CDC) --------------------------------------------------------
unsigned int __cdecl read_axi_fpga(unsigned int address)
{
  return axi_fpga_addr[address];
}

//----- (00017D0C) --------------------------------------------------------
void __cdecl write_axi_fpga(unsigned int address, unsigned int data)
{
  axi_fpga_addr[address] = data;
}

//----- (00017D38) --------------------------------------------------------
void init_fpga()
{
  unsigned __int8 tmp42[1024]; // [sp+4h] [bp+4h] BYREF
  unsigned int data; // [sp+404h] [bp+404h]

  data = -2147450880;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___7433);
    applog(2, tmp42, 0);
  }
  write_axi_fpga(0x20u, data);
  while ( (read_axi_fpga(0x20u) & 0x80000000) != 0 )
    usleep(0x2710u);
  usleep(0x186A0u);
}

//----- (00017DD0) --------------------------------------------------------
void __cdecl get_return_nonce(unsigned int *buf)
{
  *buf = read_axi_fpga(4u);
  buf[1] = read_axi_fpga(5u);
}

//----- (00017DFC) --------------------------------------------------------
void __cdecl set_BC_command_buffer(unsigned int *value)
{
  write_axi_fpga(0x31u, *value);
  write_axi_fpga(0x32u, value[1]);
  write_axi_fpga(0x33u, value[2]);
}

//----- (00017E34) --------------------------------------------------------
unsigned int get_BC_write_command()
{
  return read_axi_fpga(0x30u);
}

//----- (00017E54) --------------------------------------------------------
void __cdecl set_BC_write_command(unsigned int value)
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 i; // [sp+40Fh] [bp+40Fh]

  i = 0;
  if ( (value & 0x80000000) != 0 )
  {
    while ( (get_BC_write_command() & 0x80000000) != 0 )
    {
      usleep(0x3E8u);
      if ( ++i > 0x64u )
      {
        i = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "%s: timeout\n\n", (const char *)_FUNCTION___7452);
          applog(2, tmp42, 0);
        }
        break;
      }
    }
  }
  write_axi_fpga(0x30u, value);
}

//----- (00017F08) --------------------------------------------------------
unsigned __int8 __cdecl asic_baud_to_fpga_baud(unsigned __int8 asic_baud)
{
  unsigned __int8 v1; // r3
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF

  switch ( asic_baud )
  {
    case 0u:
      v1 = 1;
      break;
    case 1u:
      v1 = 3;
      break;
    case 2u:
      v1 = 5;
      break;
    case 6u:
      v1 = 13;
      break;
    case 0x1Au:
      v1 = 53;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: Don't support ASIC baud = %d, error!!!\n",
          (const char *)_FUNCTION___7466,
          asic_baud);
        applog(2, tmp42, 0);
      }
      v1 = 53;
      break;
  }
  return v1;
}

//----- (0001800C) --------------------------------------------------------
void __cdecl set_fpga_baud(unsigned __int8 asic_baud)
{
  unsigned __int8 fpga_baud; // [sp+Fh] [bp+Fh]

  fpga_baud = asic_baud_to_fpga_baud(asic_baud);
  write_axi_fpga(0xFu, fpga_baud);
}

//----- (00018034) --------------------------------------------------------
void __cdecl i2c_write(unsigned int config_data)
{
  unsigned int send_counter; // [sp+40Ch] [bp+40Ch]

  send_counter = 0;
  while ( (read_axi_fpga(0xCu) & 0x80000000) == 0 )
    usleep(0x1388u);
  write_axi_fpga(0xCu, config_data);
}
// 18056: conditional instruction was optimized away because %send_counter.4==0

//----- (000180D0) --------------------------------------------------------
unsigned __int8 __cdecl i2c_read(unsigned int config_data)
{
  unsigned int ret_data; // [sp+408h] [bp+408h]
  unsigned int send_counter; // [sp+40Ch] [bp+40Ch]

  send_counter = 0;
  ret_data = 255;
  i2c_write(config_data | 0x2000000);
  do
  {
    usleep(0x1388u);
    ret_data = read_axi_fpga(0xCu);
  }
  while ( (ret_data & 0x80000000) == 0 );
  return ret_data;
}
// 18116: conditional instruction was optimized away because %send_counter.4==0

//----- (00018180) --------------------------------------------------------
int __cdecl ISL_page_enable(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t which_page)
{
  uint8_t which_pagea; // [sp+Ch] [bp+4h] BYREF
  uint8_t i2c_dev_addra; // [sp+Dh] [bp+5h]
  uint8_t which_i2ca; // [sp+Eh] [bp+6h]
  uint8_t which_chaina[5]; // [sp+Fh] [bp+7h] BYREF

  which_chaina[0] = which_chain;
  which_i2ca = which_i2c;
  i2c_dev_addra = i2c_dev_addr;
  which_pagea = which_page;
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0, &which_pagea, 1);
  return 0;
}
// 18180: using guessed type uint8_t which_chain[5];

//----- (000181BC) --------------------------------------------------------
int __cdecl ISL_on(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr)
{
  uint8_t which_chaina[8]; // [sp+Fh] [bp+7h] BYREF
  uint8_t oper; // [sp+17h] [bp+Fh] BYREF

  which_chaina[0] = which_chain;
  oper = 0x80;
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 1u, &oper, 1);
  return 0;
}
// 181BC: using guessed type uint8_t which_chain[8];

//----- (000181F4) --------------------------------------------------------
int __cdecl ISL_off(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr)
{
  uint8_t which_chaina[8]; // [sp+Fh] [bp+7h] BYREF
  uint8_t oper; // [sp+17h] [bp+Fh] BYREF

  which_chaina[0] = which_chain;
  oper = 64;
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 1u, &oper, 1);
  return 0;
}
// 181F4: using guessed type uint8_t which_chain[8];

//----- (0001822C) --------------------------------------------------------
int __cdecl ISL_set_on_off_config(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t config)
{
  uint8_t configa; // [sp+Ch] [bp+4h] BYREF
  uint8_t i2c_dev_addra; // [sp+Dh] [bp+5h]
  uint8_t which_i2ca; // [sp+Eh] [bp+6h]
  uint8_t which_chaina[5]; // [sp+Fh] [bp+7h] BYREF

  which_chaina[0] = which_chain;
  which_i2ca = which_i2c;
  i2c_dev_addra = i2c_dev_addr;
  configa = config;
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 2u, &configa, 1);
  return 0;
}
// 1822C: using guessed type uint8_t which_chain[5];

//----- (00018268) --------------------------------------------------------
int __cdecl ISL_set_clear_faults(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr)
{
  uint8_t which_chaina[8]; // [sp+Fh] [bp+7h] BYREF
  uint8_t clear; // [sp+17h] [bp+Fh] BYREF

  which_chaina[0] = which_chain;
  clear = 1;
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 3u, &clear, 1);
  return 0;
}
// 18268: using guessed type uint8_t which_chain[8];

//----- (000182A0) --------------------------------------------------------
int __cdecl ISL_set_write_protect(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t mode)
{
  uint8_t modea; // [sp+Ch] [bp+4h] BYREF
  uint8_t i2c_dev_addra; // [sp+Dh] [bp+5h]
  uint8_t which_i2ca; // [sp+Eh] [bp+6h]
  uint8_t which_chaina[5]; // [sp+Fh] [bp+7h] BYREF

  which_chaina[0] = which_chain;
  which_i2ca = which_i2c;
  i2c_dev_addra = i2c_dev_addr;
  modea = mode;
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0x10u, &modea, 1);
  return 0;
}
// 182A0: using guessed type uint8_t which_chain[5];

//----- (000182DC) --------------------------------------------------------
int __cdecl ISL_set_vout_command(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage)
{
  uint8_t which_chaina[5]; // [sp+Fh] [bp+7h] BYREF
  uint8_t cmd[2]; // [sp+14h] [bp+Ch] BYREF

  which_chaina[0] = which_chain;
  *(_WORD *)cmd = voltage;
  printf("uint16 = 0x%04x[%u], cmd0=%02x cmd1=%02x\n", voltage, voltage, (unsigned __int8)voltage, HIBYTE(voltage));
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0x21u, cmd, 2);
  return 0;
}
// 182DC: using guessed type uint8_t which_chain[5];

//----- (00018344) --------------------------------------------------------
int __cdecl ISL_set_apply_settings(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr)
{
  uint8_t which_chaina[8]; // [sp+Fh] [bp+7h] BYREF
  uint8_t apply; // [sp+17h] [bp+Fh] BYREF

  which_chaina[0] = which_chain;
  apply = 1;
  write_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0xE7u, &apply, 1);
  return 0;
}
// 18344: using guessed type uint8_t which_chain[8];

//----- (0001837C) --------------------------------------------------------
int __cdecl ISL_get_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t *voltage)
{
  uint8_t which_chaina[5]; // [sp+Fh] [bp+7h] BYREF
  uint8_t vol[2]; // [sp+14h] [bp+Ch] BYREF

  which_chaina[0] = which_chain;
  memset(vol, 0, sizeof(vol));
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0x21u, vol, 2);
  *voltage = (vol[1] << 8) | vol[0];
  return 0;
}
// 1837C: using guessed type uint8_t which_chain[5];

//----- (000183D4) --------------------------------------------------------
int __cdecl ISL_read_reg_default(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr)
{
  uint8_t which_chaina[5]; // [sp+Fh] [bp+7h] BYREF
  uint8_t value[2]; // [sp+14h] [bp+Ch] BYREF

  which_chaina[0] = which_chain;
  value[0] = 0;
  value[1] = 0;
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0, value, 1);
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 1u, value, 1);
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 2u, value, 1);
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 3u, value, 1);
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0x10u, value, 1);
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0x21u, value, 2);
  read_dc_dc(which_chaina, which_i2c, i2c_dev_addr, 0x22u, value, 1);
  return 0;
}

//----- (00018494) --------------------------------------------------------
uint16_t __cdecl ISL_set_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage)
{
  uint16_t r_voltage; // [sp+Ch] [bp+Ch] BYREF
  uint8_t retry_limits; // [sp+Eh] [bp+Eh]
  uint8_t retry; // [sp+Fh] [bp+Fh]

  puts("begin to read voltage");
  ISL_page_enable(which_chain, which_i2c, i2c_dev_addr, 0);
  usleep(0x186A0u);
  usleep(0x186A0u);
  ISL_set_vout_command(which_chain, which_i2c, i2c_dev_addr, voltage);
  usleep(0x186A0u);
  usleep(0x186A0u);
  puts("end to read voltage");
  retry = 0;
  retry_limits = 5;
  r_voltage = 0;
  do
  {
    usleep(0x186A0u);
    ISL_get_voltage(which_chain, which_i2c, i2c_dev_addr, &r_voltage);
    ++retry;
  }
  while ( retry <= (unsigned int)retry_limits && !r_voltage );
  printf("--- ISL_get_voltage, Voltage: 0.%03d V\n\n", r_voltage);
  return r_voltage;
}

//----- (00018568) --------------------------------------------------------
int open_key()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  cgpu.key_fd = open("/sys/class/gpio/gpio943/value", 2048);
  if ( cgpu.key_fd < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open key failed!!!\n");
    applog(2, tmp42, 0);
  }
  return cgpu.key_fd;
}

//----- (000185FC) --------------------------------------------------------
void close_key()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  close(cgpu.key_fd);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "key closed!!!\n");
    applog(2, tmp42, 0);
  }
}

//----- (0001866C) --------------------------------------------------------
ssize_t __cdecl read_key(unsigned __int8 value)
{
  unsigned __int8 valuea[5]; // [sp+7h] [bp+7h] BYREF
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  ssize_t ret_len; // [sp+40Ch] [bp+40Ch]

  valuea[0] = value;
  ret_len = 0;
  lseek(cgpu.key_fd, 0, 0);
  ret_len = read(cgpu.key_fd, valuea, 1u);
  if ( ret_len == 1 )
    return 1;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s: can't read out key value\n", (const char *)_FUNCTION___5997);
    applog(2, tmp42, 0);
  }
  return -1;
}
// 1866C: using guessed type unsigned __int8 value[5];

//----- (0001871C) --------------------------------------------------------
int open_lcd()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  cgpu.lcd_fd = open("/dev/bitmain-lcd", 2178);
  if ( cgpu.lcd_fd <= 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open lcd failed!!!\n");
    applog(2, tmp42, 0);
  }
  return cgpu.lcd_fd;
}

//----- (000187B0) --------------------------------------------------------
int close_lcd()
{
  unsigned __int8 tmp42[1024]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+404h] [bp+404h]

  ret = close(cgpu.lcd_fd);
  if ( ret )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "lcd close failed!!!\n");
      applog(2, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "lcd closed!!!\n");
    applog(2, tmp42, 0);
  }
  return ret;
}

//----- (0001888C) --------------------------------------------------------
void __cdecl write_lcd(unsigned int line, unsigned __int8 *buf, unsigned int size)
{
  unsigned int v3; // r3
  size_t sizea; // [sp+4h] [bp+4h]
  unsigned int linea; // [sp+Ch] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  unsigned int Copied; // [sp+414h] [bp+414h]

  linea = line;
  sizea = size;
  Copied = 0;
  if ( buf && cgpu.lcd_fd > 0 )
  {
    if ( line <= 3 && size <= 0x40 )
    {
      lseek(cgpu.lcd_fd, 0, 0);
      memset(lcd_output, 32, sizeof(lcd_output));
      while ( sizea )
      {
        if ( sizea <= 0x10 )
        {
          memcpy(lcd_output[linea], &buf[Copied], sizea);
          break;
        }
        v3 = linea++;
        memcpy(lcd_output[v3], &buf[Copied], sizeof(unsigned __int8[16]));
        sizea -= 16;
        Copied += 16;
      }
      write(cgpu.lcd_fd, lcd_output, 0x40u);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: write_lcd's arg is overflow\n", (const char *)_FUNCTION___6626);
      applog(2, tmp42, 0);
    }
  }
}

//----- (00018A04) --------------------------------------------------------
void __cdecl write_lcd_no_memset(unsigned int line, unsigned __int8 *buf, unsigned int size)
{
  unsigned int v3; // r3
  size_t sizea; // [sp+4h] [bp+4h]
  unsigned int linea; // [sp+Ch] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  unsigned int Copied; // [sp+414h] [bp+414h]

  linea = line;
  sizea = size;
  Copied = 0;
  if ( buf && cgpu.lcd_fd > 0 )
  {
    if ( line <= 3 && size <= 0x40 )
    {
      while ( sizea )
      {
        if ( sizea <= 0x10 )
        {
          memcpy(lcd_output[linea], &buf[Copied], sizea);
          break;
        }
        v3 = linea++;
        memcpy(lcd_output[v3], &buf[Copied], sizeof(unsigned __int8[16]));
        sizea -= 16;
        Copied += 16;
      }
      write(cgpu.lcd_fd, lcd_output, 0x40u);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: write_lcd's arg is overflow\n", (const char *)_FUNCTION___6637);
      applog(2, tmp42, 0);
    }
  }
}

//----- (00018B54) --------------------------------------------------------
int open_red_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  red_led_fd = open("/sys/class/gpio/gpio941/value", 2049);
  if ( red_led_fd < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open red led failed!!!\n");
    applog(2, tmp42, 0);
  }
  return red_led_fd;
}

//----- (00018BEC) --------------------------------------------------------
void close_red_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  close(red_led_fd);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "red led closed!!!\n");
    applog(2, tmp42, 0);
  }
}

//----- (00018C64) --------------------------------------------------------
void red_led_on()
{
  write(red_led_fd, "1", 1u);
}

//----- (00018C88) --------------------------------------------------------
void red_led_off()
{
  write(red_led_fd, "0", 1u);
}

//----- (00018CAC) --------------------------------------------------------
int open_green_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  green_led_fd = open("/sys/class/gpio/gpio942/value", 2049);
  if ( green_led_fd < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open green led failed!!!\n");
    applog(2, tmp42, 0);
  }
  return green_led_fd;
}

//----- (00018D44) --------------------------------------------------------
void close_green_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  close(green_led_fd);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "green led closed!!!\n");
    applog(2, tmp42, 0);
  }
}

//----- (00018DB8) --------------------------------------------------------
void green_led_on()
{
  write(green_led_fd, "1", 1u);
}

//----- (00018DDC) --------------------------------------------------------
void green_led_off()
{
  write(green_led_fd, "0", 1u);
}

//----- (00018E00) --------------------------------------------------------
void __cdecl write_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data)
{
  i2c_write(data | (which_i2c << 26) | 0xA00000 | (which_chain << 16));
}

//----- (00018E38) --------------------------------------------------------
unsigned __int8 __cdecl read_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain)
{
  return i2c_read((which_chain << 16) | (which_i2c << 26) | 0xA00000);
}

//----- (00018E6C) --------------------------------------------------------
int __cdecl write_dc_dc(void *args, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t reg, uint8_t *data, int len)
{
  int v6; // r4
  uint8_t send_data[16]; // [sp+10h] [bp+8h] BYREF
  uint8_t read_back_data[16]; // [sp+20h] [bp+18h] BYREF
  uint8_t crc_data[2]; // [sp+30h] [bp+28h]
  uint8_t length; // [sp+32h] [bp+2Ah]
  uint8_t which_chain; // [sp+33h] [bp+2Bh]
  int j; // [sp+34h] [bp+2Ch]
  int i_0; // [sp+38h] [bp+30h]
  uint8_t i; // [sp+3Dh] [bp+35h]
  uint16_t crc; // [sp+3Eh] [bp+36h]
  _BYTE v21[4]; // [sp+40h] [bp+38h] BYREF

  which_chain = *(_BYTE *)args;
  *(_WORD *)crc_data = 255;
  *(_DWORD *)read_back_data = 255;
  memset(&read_back_data[4], 0, 12);
  crc = 0;
  memset(&send_data[6], 0, 10);
  length = len + 6;
  printf("%s dev addr = %02x\n", (const char *)_func___6668, i2c_dev_addr);
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = len + 6;
  send_data[3] = 50;
  send_data[4] = 2 * i2c_dev_addr;
  send_data[5] = reg;
  for ( i_0 = 0; i_0 < len; ++i_0 )
    v21[i_0 - 42] = data[i_0];
  for ( j = 2; len + 6 > j; ++j )
    crc += send_data[j];
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = crc;
  v21[len - 42] = HIBYTE(crc);
  v21[len - 41] = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < length + 2; ++i )
    write_pic(which_i2c, which_chain, v21[i - 48]);
  usleep(0x186A0u);
  memset(read_back_data, 0, sizeof(read_back_data));
  for ( i = 0; i <= 4u; ++i )
  {
    v6 = i;
    read_back_data[v6] = read_pic(which_i2c, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] == 50 && read_back_data[2] == 1 )
    return 0;
  printf(
    "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n\n",
    (const char *)_FUNCTION___6683,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3]);
  return -1;
}

//----- (0001907C) --------------------------------------------------------
int __cdecl read_dc_dc(void *args, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t reg, uint8_t *value, int len)
{
  int v6; // r4
  uint8_t send_data[9]; // [sp+14h] [bp+Ch] BYREF
  uint8_t read_back_data[16]; // [sp+20h] [bp+18h] BYREF
  uint8_t crc_data[2]; // [sp+30h] [bp+28h]
  uint8_t length; // [sp+32h] [bp+2Ah]
  uint8_t which_chain; // [sp+33h] [bp+2Bh]
  int i_1; // [sp+34h] [bp+2Ch]
  int i_0; // [sp+38h] [bp+30h]
  uint8_t i; // [sp+3Dh] [bp+35h]
  uint16_t crc; // [sp+3Eh] [bp+36h]
  _BYTE v19[4]; // [sp+40h] [bp+38h] BYREF

  which_chain = *(_BYTE *)args;
  length = 7;
  *(_WORD *)crc_data = 255;
  *(_DWORD *)read_back_data = 255;
  memset(&read_back_data[4], 0, 12);
  crc = 0;
  *(_DWORD *)send_data = 839363157;
  send_data[8] = 0;
  *(_DWORD *)&send_data[4] = (unsigned __int8)(2 * i2c_dev_addr) | 1;
  send_data[5] = reg;
  send_data[6] = len;
  for ( i_0 = 2; length > i_0; ++i_0 )
    crc += send_data[i_0];
  crc_data[0] = HIBYTE(crc);
  send_data[7] = HIBYTE(crc);
  crc_data[1] = crc;
  send_data[8] = crc;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < length + 2; ++i )
    write_pic(which_i2c, which_chain, v19[i - 44]);
  usleep(0x186A0u);
  memset(read_back_data, 0, sizeof(read_back_data));
  for ( i = 0; i < len + 5; ++i )
  {
    v6 = i;
    read_back_data[v6] = read_pic(which_i2c, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&nonce_fifo.nonce_buffer[508].Nonce[1188]);
  if ( read_back_data[1] == 50 && read_back_data[2] == 1 )
  {
    for ( i_1 = 0; i_1 < len; ++i_1 )
      value[i_1] = v19[i_1 - 29];
    return 0;
  }
  else
  {
    printf(
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n",
      (const char *)_FUNCTION___6709,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3]);
    return -1;
  }
}

//----- (00019268) --------------------------------------------------------
int __cdecl set_PIC16F1704_flash_pointer(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 flash_addr_h,
        unsigned __int8 flash_addr_l)
{
  __int16 v4; // r2
  int v5; // r4
  unsigned __int8 which_i2ca; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[8]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v18[4]; // [sp+428h] [bp+420h] BYREF

  which_i2ca = which_i2c;
  length = 6;
  *(_WORD *)read_back_data = 255;
  *(_DWORD *)send_data = 17214037;
  v4 = flash_addr_h + 6;
  crc = flash_addr_l + v4 + 1;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = flash_addr_l + v4 + 1;
  send_data[4] = flash_addr_h;
  send_data[5] = flash_addr_l;
  send_data[6] = HIBYTE(crc);
  send_data[7] = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(which_i2ca, which_chain, v18[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v5 = i;
    read_back_data[v5] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[0] == 1 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6733);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6733,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001949C) --------------------------------------------------------
int __cdecl send_data_to_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 send_data[22]; // [sp+41Ch] [bp+414h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+434h] [bp+42Ch]
  unsigned __int8 crc_data[2]; // [sp+438h] [bp+430h]
  unsigned __int8 length; // [sp+43Ch] [bp+434h]
  unsigned __int8 i; // [sp+43Dh] [bp+435h]
  unsigned __int16 crc; // [sp+43Eh] [bp+436h]
  _BYTE v15[4]; // [sp+440h] [bp+438h] BYREF

  which_i2ca = which_i2c;
  length = 20;
  *(_WORD *)crc_data = 255;
  *(_WORD *)read_back_data = 255;
  memset(send_data, 0, sizeof(send_data));
  crc = 22;
  for ( i = 0; i <= 0xFu; ++i )
    crc += buf[i];
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = crc;
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = length;
  send_data[3] = 2;
  for ( i = 0; i <= 0xFu; ++i )
    v15[i - 32] = buf[i];
  send_data[20] = crc_data[0];
  send_data[21] = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x15u; ++i )
    write_pic(which_i2ca, which_chain, v15[i - 36]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[0] == 2 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6759);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6759,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (00019718) --------------------------------------------------------
int __cdecl read_PIC16F1704_flash_pointer(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *flash_addr_h,
        unsigned __int8 *flash_addr_l)
{
  int v4; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 send_data[6]; // [sp+428h] [bp+410h]
  unsigned __int8 read_back_data[6]; // [sp+430h] [bp+418h]
  unsigned __int8 crc_data[2]; // [sp+438h] [bp+420h]
  unsigned __int16 crc; // [sp+43Ch] [bp+424h]
  unsigned __int8 length; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE v18[4]; // [sp+440h] [bp+428h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&read_back_data[4] = 0;
  *(_DWORD *)send_data = 134523477;
  crc = 12;
  crc_data[1] = 12;
  send_data[4] = 0;
  send_data[5] = 12;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v18[i - 24]);
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v4 = i;
    read_back_data[v4] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] == 8 && read_back_data[0] == 6 )
  {
    crc = read_back_data[3] + read_back_data[2] + read_back_data[1] + read_back_data[0];
    if ( HIBYTE(crc) == read_back_data[4] && (unsigned __int8)crc == read_back_data[5] )
    {
      *flash_addr_h = read_back_data[2];
      *flash_addr_l = read_back_data[3];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "--- %s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x\n\n",
          (const char *)_FUNCTION___6780,
          *flash_addr_h,
          *flash_addr_l);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3]"
          " = 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
          "\n",
          (const char *)_FUNCTION___6780,
          read_back_data[0],
          read_back_data[1],
          read_back_data[2],
          read_back_data[3],
          read_back_data[4],
          read_back_data[5]);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] ="
        " 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
        "\n",
        (const char *)_FUNCTION___6780,
        read_back_data[0],
        read_back_data[1],
        read_back_data[2],
        read_back_data[3],
        read_back_data[4],
        read_back_data[5]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (00019A3C) --------------------------------------------------------
int __cdecl read_PIC16F1704_flash_data(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+94h] [bp+44h]
  unsigned __int8 tmp42[1024]; // [sp+9Ch] [bp+4Ch] BYREF
  unsigned __int8 send_data[6]; // [sp+49Ch] [bp+44Ch]
  unsigned __int8 read_back_data[20]; // [sp+4A4h] [bp+454h] BYREF
  unsigned __int8 crc_data[2]; // [sp+4B8h] [bp+468h]
  unsigned __int16 crc; // [sp+4BCh] [bp+46Ch]
  unsigned __int8 length; // [sp+4BEh] [bp+46Eh]
  unsigned __int8 i; // [sp+4BFh] [bp+46Fh]
  _BYTE v16[4]; // [sp+4C0h] [bp+470h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  memset(&read_back_data[4], 0, 16);
  *(_DWORD *)send_data = 50637397;
  crc = 7;
  crc_data[1] = 7;
  send_data[4] = 0;
  send_data[5] = 7;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v16[i - 36]);
  usleep((__useconds_t)&buf_7545[4072]);
  for ( i = 0; i <= 0x13u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t"
      "\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread"
      "_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x, \t\tread_bac"
      "k_data[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x, \t\tread_back_"
      "data[16] = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
      (const char *)_FUNCTION___6801,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5],
      read_back_data[6],
      read_back_data[7],
      read_back_data[8],
      read_back_data[9],
      read_back_data[10],
      read_back_data[11],
      read_back_data[12],
      read_back_data[13],
      read_back_data[14],
      read_back_data[15],
      read_back_data[16],
      read_back_data[17],
      read_back_data[18],
      read_back_data[19]);
    applog(2, tmp42, 0);
  }
  usleep(0x186A0u);
  if ( read_back_data[1] == 3 && read_back_data[0] == 20 )
  {
    crc = read_back_data[17]
        + read_back_data[16]
        + read_back_data[15]
        + read_back_data[14]
        + read_back_data[13]
        + read_back_data[12]
        + read_back_data[11]
        + read_back_data[10]
        + read_back_data[9]
        + read_back_data[8]
        + read_back_data[7]
        + read_back_data[6]
        + read_back_data[5]
        + read_back_data[4]
        + read_back_data[3]
        + read_back_data[2]
        + read_back_data[1]
        + read_back_data[0];
    if ( HIBYTE(crc) == read_back_data[18] && (unsigned __int8)crc == read_back_data[19] )
    {
      for ( i = 0; i <= 0xFu; ++i )
        buf[i] = v16[i - 26];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6801);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___6801, crc);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", (const char *)_FUNCTION___6801);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (00019ECC) --------------------------------------------------------
int __cdecl erase_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  int v2; // r4
  unsigned __int8 which_i2ca; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[6]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_WORD *)read_back_data = 255;
  *(_DWORD *)send_data = 67414613;
  crc = 8;
  crc_data[1] = 8;
  send_data[4] = 0;
  send_data[5] = 8;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    read_back_data[v2] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[0] == 4 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6825);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6825,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001A0D4) --------------------------------------------------------
int __cdecl write_data_into_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  int v2; // r4
  unsigned __int8 which_i2ca; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[6]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_WORD *)read_back_data = 255;
  *(_DWORD *)send_data = 84191829;
  crc = 9;
  crc_data[1] = 9;
  send_data[4] = 0;
  send_data[5] = 9;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v14[i - 20]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    read_back_data[v2] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[0] == 5 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6844);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6844,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001A2DC) --------------------------------------------------------
int __cdecl jump_from_loader_to_app_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[6]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  length = 4;
  crc_data[0] = 0;
  *(_WORD *)read_back_data = 255;
  *(_DWORD *)send_data = 100969045;
  crc = 10;
  crc_data[1] = 10;
  send_data[4] = 0;
  send_data[5] = 10;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2c, which_chaina, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    read_back_data[v2] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&buf_7545[4072]);
  if ( read_back_data[0] == 6 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6863);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6863,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001A4E4) --------------------------------------------------------
int __cdecl reset_PIC16F1704_pic(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[6]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  length = 4;
  crc_data[0] = 0;
  *(_WORD *)read_back_data = 255;
  *(_DWORD *)send_data = 117746261;
  crc = 11;
  crc_data[1] = 11;
  send_data[4] = 0;
  send_data[5] = 11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2c, which_chaina, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    read_back_data[v2] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&nonce_fifo.nonce_buffer[508].Nonce[1188]);
  if ( read_back_data[0] == 7 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6882);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6882,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001A6EC) --------------------------------------------------------
int __cdecl set_PIC16F1704_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[7]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v15[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  length = 5;
  *(_WORD *)read_back_data = 255;
  *(_WORD *)send_data = -21931;
  send_data[3] = 16;
  crc = voltage + 21;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = voltage + 21;
  send_data[2] = 5;
  send_data[4] = voltage;
  send_data[5] = HIBYTE(crc);
  send_data[6] = voltage + 21;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(which_i2c, which_chaina, v15[i - 20]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[0] == 16 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6902);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6902,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001A914) --------------------------------------------------------
int __cdecl write_hash_ID_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 send_data[18]; // [sp+418h] [bp+410h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+42Ch] [bp+424h]
  unsigned __int8 crc_data[2]; // [sp+430h] [bp+428h]
  unsigned __int8 length; // [sp+434h] [bp+42Ch]
  unsigned __int8 i; // [sp+435h] [bp+42Dh]
  unsigned __int16 crc; // [sp+436h] [bp+42Eh]
  _BYTE v15[4]; // [sp+438h] [bp+430h] BYREF

  which_chaina = which_chain;
  length = 16;
  *(_WORD *)crc_data = 255;
  *(_WORD *)read_back_data = 255;
  memset(send_data, 0, sizeof(send_data));
  crc = 34;
  for ( i = 0; i <= 0xBu; ++i )
    crc += buf[i];
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = crc;
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = length;
  send_data[3] = 18;
  for ( i = 0; i <= 0xBu; ++i )
    v15[i - 28] = buf[i];
  send_data[16] = crc_data[0];
  send_data[17] = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x11u; ++i )
    write_pic(which_i2c, which_chaina, v15[i - 32]);
  usleep((__useconds_t)&nonce_fifo.nonce_buffer[66].Nonce[982]);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[0] == 18 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6928);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6928,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001AB9C) --------------------------------------------------------
int __cdecl read_hash_id_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+74h] [bp+34h]
  unsigned __int8 tmp42[1024]; // [sp+78h] [bp+38h] BYREF
  unsigned __int8 send_data[6]; // [sp+478h] [bp+438h]
  unsigned __int8 read_back_data[16]; // [sp+480h] [bp+440h] BYREF
  unsigned __int8 crc_data[2]; // [sp+490h] [bp+450h]
  unsigned __int16 crc; // [sp+494h] [bp+454h]
  unsigned __int8 length; // [sp+496h] [bp+456h]
  unsigned __int8 i; // [sp+497h] [bp+457h]
  _BYTE v16[4]; // [sp+498h] [bp+458h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  memset(&read_back_data[4], 0, 12);
  *(_DWORD *)send_data = 319072853;
  crc = 23;
  crc_data[1] = 23;
  send_data[4] = 0;
  send_data[5] = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v16[i - 32]);
  usleep(0x30D40u);
  for ( i = 0; i <= 0xFu; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\t"
      "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_ba"
      "ck_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_da"
      "ta[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
      (const char *)_FUNCTION___6948,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5],
      read_back_data[6],
      read_back_data[7],
      read_back_data[8],
      read_back_data[9],
      read_back_data[10],
      read_back_data[11],
      read_back_data[12],
      read_back_data[13],
      read_back_data[14],
      read_back_data[15]);
    applog(2, tmp42, 0);
  }
  if ( read_back_data[1] == 19 && read_back_data[0] == 16 )
  {
    crc = read_back_data[13]
        + read_back_data[12]
        + read_back_data[11]
        + read_back_data[10]
        + read_back_data[9]
        + read_back_data[8]
        + read_back_data[7]
        + read_back_data[6]
        + read_back_data[5]
        + read_back_data[4]
        + read_back_data[3]
        + read_back_data[2]
        + read_back_data[1]
        + read_back_data[0];
    if ( HIBYTE(crc) == read_back_data[14] && (unsigned __int8)crc == read_back_data[15] )
    {
      for ( i = 0; i <= 0xBu; ++i )
        buf[i] = v16[i - 22];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6948);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___6948, crc);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", (const char *)_FUNCTION___6948);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001AFCC) --------------------------------------------------------
int __cdecl enable_PIC16F1704_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[7]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v15[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  length = 5;
  *(_WORD *)read_back_data = 255;
  *(_WORD *)send_data = -21931;
  send_data[3] = 21;
  crc = enable + 26;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = enable + 26;
  send_data[2] = 5;
  send_data[4] = enable;
  send_data[5] = HIBYTE(crc);
  send_data[6] = enable + 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(which_i2c, which_chaina, v15[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[0] == 21 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6973);
      applog(2, tmp42, 0);
    }
    usleep((__useconds_t)&nonce_fifo.nonce_buffer[140].Nonce[564]);
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___6973,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001B1F4) --------------------------------------------------------
int __cdecl heart_beat_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4
  unsigned __int8 which_chaina; // [sp+4h] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 send_data[6]; // [sp+408h] [bp+408h]
  unsigned __int8 read_back_data[6]; // [sp+410h] [bp+410h]
  unsigned __int8 crc_data[2]; // [sp+418h] [bp+418h]
  unsigned __int16 crc; // [sp+41Ch] [bp+41Ch]
  unsigned __int8 length; // [sp+41Eh] [bp+41Eh]
  unsigned __int8 i; // [sp+41Fh] [bp+41Fh]
  _BYTE v14[4]; // [sp+420h] [bp+420h] BYREF

  which_chaina = which_chain;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&read_back_data[4] = 0;
  *(_DWORD *)send_data = 369404501;
  crc = 26;
  crc_data[1] = 26;
  send_data[4] = 0;
  send_data[5] = 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2c, which_chaina, v14[i - 24]);
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v2 = i;
    read_back_data[v2] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] == 22 && read_back_data[2] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___6992);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", (const char *)_FUNCTION___6992);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001B3E8) --------------------------------------------------------
void *__cdecl __noreturn pic_heart_beat_func(void *arg)
{
  unsigned __int8 which_i2c; // [sp+Ah] [bp+Ah]
  unsigned __int8 which_chain; // [sp+Bh] [bp+Bh]

  which_chain = *(_BYTE *)arg;
  which_i2c = *((_BYTE *)arg + 1);
  while ( 1 )
  {
    heart_beat_PIC16F1704(which_chain, which_i2c);
    sleep(0xAu);
  }
}

//----- (0001B414) --------------------------------------------------------
int __cdecl get_PIC16F1704_software_version(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *version)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 send_data[6]; // [sp+428h] [bp+410h]
  unsigned __int8 read_back_data[5]; // [sp+430h] [bp+418h]
  unsigned __int8 crc_data[2]; // [sp+438h] [bp+420h]
  unsigned __int16 crc; // [sp+43Ch] [bp+424h]
  unsigned __int8 length; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  __int128 savedregs; // [sp+440h] [bp+428h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  read_back_data[4] = 0;
  *(_DWORD *)send_data = 386181717;
  crc = 27;
  crc_data[1] = 27;
  send_data[4] = 0;
  send_data[5] = 27;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, *((_BYTE *)&savedregs + i - 24));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x\n",
      (const char *)_FUNCTION___7019,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4]);
    applog(2, tmp42, 0);
  }
  if ( read_back_data[1] == 23 && read_back_data[0] == 5 )
  {
    crc = read_back_data[2] + read_back_data[1] + read_back_data[0];
    if ( HIBYTE(crc) == read_back_data[3] && (unsigned __int8)crc == read_back_data[4] )
    {
      *version = read_back_data[2];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok, version = 0x%02x\n\n", (const char *)_FUNCTION___7019, *version);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___7019, crc);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", (const char *)_FUNCTION___7019);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001B748) --------------------------------------------------------
int __cdecl PIC16F1704_i2c_forward_send(
        uint32_t i2c,
        uint8_t chain,
        uint8_t dev_addr,
        int rw_flag,
        uint8_t reg_addr,
        int len,
        uint8_t *data)
{
  unsigned __int8 i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  uint8_t recv_data[12]; // [sp+418h] [bp+410h] BYREF
  uint8_t send_data[32]; // [sp+424h] [bp+41Ch] BYREF
  int i_1; // [sp+444h] [bp+43Ch]
  int i_0; // [sp+448h] [bp+440h]
  int i; // [sp+44Ch] [bp+444h]
  int body_len; // [sp+450h] [bp+448h]
  uint16_t crc; // [sp+456h] [bp+44Eh]
  _BYTE v21[4]; // [sp+458h] [bp+450h] BYREF

  i2ca = i2c;
  memset(send_data, 0, sizeof(send_data));
  memset(recv_data, 0, sizeof(recv_data));
  crc = 0;
  body_len = 0;
  i = 0;
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = 0;
  send_data[3] = 38;
  send_data[4] = rw_flag | (2 * dev_addr);
  send_data[5] = reg_addr;
  if ( rw_flag )
  {
    body_len = 5;
    send_data[6] = len;
  }
  else
  {
    body_len = len + 4;
    memcpy(&send_data[6], data, len);
  }
  send_data[2] = body_len + 2;
  for ( i_0 = 0; i_0 < body_len; ++i_0 )
    crc += (unsigned __int8)v21[i_0 - 50];
  v21[body_len - 50] = HIBYTE(crc);
  v21[body_len - 49] = crc;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; body_len + 4 > i; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "write pic i2c[%d] %02x\n", i, send_data[i]);
      applog(2, tmp42, 0);
    }
    write_pic(i2ca, chain, send_data[i]);
  }
  usleep(0x30D40u);
  if ( rw_flag != 1 )
    goto LABEL_40;
  for ( i = 0; len + 5 > i; ++i )
  {
    recv_data[i] = read_pic(i2ca, chain);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "read pic i2c[%d] %02x\n", i, recv_data[i]);
      applog(2, tmp42, 0);
    }
  }
  for ( i_1 = 0; len + 3 > i_1; ++i_1 )
    crc += recv_data[i_1];
  if ( crc == *(unsigned __int16 *)&recv_data[len + 3] )
  {
    if ( recv_data[0] != body_len + 2 || recv_data[1] != 38 || recv_data[2] != 1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "pic read failed %d %d %d\n", *data, data[1], data[2]);
        applog(2, tmp42, 0);
      }
      goto LABEL_30;
    }
    memcpy(data, &recv_data[3], len);
LABEL_40:
    pthread_mutex_unlock(&i2c_mutex);
    return 0;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "crc failed 0x%x\n", crc);
    applog(2, tmp42, 0);
  }
LABEL_30:
  pthread_mutex_unlock(&i2c_mutex);
  return -1;
}

//----- (0001BB64) --------------------------------------------------------
void __cdecl set_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain, uint16_t vol)
{
  uint16_t vola; // [sp+10h] [bp+0h] BYREF
  uint8_t chaina; // [sp+13h] [bp+3h]
  uint32_t i2ca; // [sp+14h] [bp+4h]
  size_t i; // [sp+1Ch] [bp+Ch]

  i2ca = i2c;
  chaina = chain;
  vola = vol;
  for ( i = 0; i <= 3; ++i )
  {
    PIC16F1704_i2c_forward_send(i2ca, chaina, isl68127_i2c_dev_addr[i], 0, 0, 1, 0);
    PIC16F1704_i2c_forward_send(i2ca, chaina, isl68127_i2c_dev_addr[i], 0, 0x21u, 2, (uint8_t *)&vola);
  }
}

//----- (0001BBDC) --------------------------------------------------------
void __cdecl get_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain)
{
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+Ch] BYREF
  uint8_t read_vol[12]; // [sp+41Ch] [bp+40Ch] BYREF
  size_t i; // [sp+42Ch] [bp+41Ch]

  for ( i = 0; i <= 3; ++i )
  {
    memset(read_vol, 0, sizeof(read_vol));
    if ( PIC16F1704_i2c_forward_send(i2c, chain, isl68127_i2c_dev_addr[i], 1, 0x21u, 2, read_vol) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "read %02x vol failed, 0x%02x%02x\n",
          isl68127_i2c_dev_addr[i],
          read_vol[0],
          read_vol[1]);
        applog(2, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "read %02x vol success, 0x%02x%02x\n",
        isl68127_i2c_dev_addr[i],
        read_vol[0],
        read_vol[1]);
      applog(2, tmp42, 0);
    }
  }
}

//----- (0001BD34) --------------------------------------------------------
int __cdecl get_PIC16F1704_voltage(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *voltage)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 send_data[6]; // [sp+428h] [bp+410h]
  unsigned __int8 read_back_data[5]; // [sp+430h] [bp+418h]
  unsigned __int8 crc_data[2]; // [sp+438h] [bp+420h]
  unsigned __int16 crc; // [sp+43Ch] [bp+424h]
  unsigned __int8 length; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  __int128 savedregs; // [sp+440h] [bp+428h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  read_back_data[4] = 0;
  *(_DWORD *)send_data = 402958933;
  crc = 28;
  crc_data[1] = 28;
  send_data[4] = 0;
  send_data[5] = 28;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, *((_BYTE *)&savedregs + i - 24));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x\n",
      (const char *)_FUNCTION___7097,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4]);
    applog(2, tmp42, 0);
  }
  if ( read_back_data[1] == 24 && read_back_data[0] == 5 )
  {
    crc = read_back_data[2] + read_back_data[1] + read_back_data[0];
    if ( HIBYTE(crc) == read_back_data[3] && (unsigned __int8)crc == read_back_data[4] )
    {
      *voltage = read_back_data[2];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok, voltage = 0x%02x\n\n", (const char *)_FUNCTION___7097, *voltage);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___7097, crc);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", (const char *)_FUNCTION___7097);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001C05C) --------------------------------------------------------
int __cdecl write_temperature_offset_PIC16F1704(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 send_data[14]; // [sp+41Ch] [bp+414h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+42Ch] [bp+424h]
  unsigned __int8 crc_data[2]; // [sp+430h] [bp+428h]
  unsigned __int8 length; // [sp+434h] [bp+42Ch]
  unsigned __int8 i; // [sp+435h] [bp+42Dh]
  unsigned __int16 crc; // [sp+436h] [bp+42Eh]
  _BYTE v15[4]; // [sp+438h] [bp+430h] BYREF

  which_i2ca = which_i2c;
  length = 12;
  *(_WORD *)crc_data = 255;
  *(_WORD *)read_back_data = 255;
  memset(send_data, 0, sizeof(send_data));
  crc = 46;
  for ( i = 0; i <= 7u; ++i )
    crc += buf[i];
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = crc;
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = length;
  send_data[3] = 34;
  for ( i = 0; i <= 7u; ++i )
    v15[i - 24] = buf[i];
  send_data[12] = crc_data[0];
  send_data[13] = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0xDu; ++i )
    write_pic(which_i2ca, which_chain, v15[i - 28]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[0] == 34 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___7125);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___7125,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001C2E0) --------------------------------------------------------
int __cdecl read_temperature_offset_PIC16F1704(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+54h] [bp+24h]
  unsigned __int8 tmp42[1024]; // [sp+5Ch] [bp+2Ch] BYREF
  unsigned __int8 send_data[6]; // [sp+45Ch] [bp+42Ch]
  unsigned __int8 read_back_data[12]; // [sp+464h] [bp+434h]
  unsigned __int8 crc_data[2]; // [sp+470h] [bp+440h]
  unsigned __int16 crc; // [sp+474h] [bp+444h]
  unsigned __int8 length; // [sp+476h] [bp+446h]
  unsigned __int8 i; // [sp+477h] [bp+447h]
  _BYTE v16[4]; // [sp+478h] [bp+448h] BYREF

  which_i2ca = which_i2c;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  *(_DWORD *)&read_back_data[4] = 0;
  *(_DWORD *)&read_back_data[8] = 0;
  *(_DWORD *)send_data = 587508309;
  crc = 39;
  crc_data[1] = 39;
  send_data[4] = 0;
  send_data[5] = 39;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v16[i - 28]);
  usleep(0x30D40u);
  for ( i = 0; i <= 0xBu; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t"
      "\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread"
      "_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
      (const char *)_FUNCTION___7145,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5],
      read_back_data[6],
      read_back_data[7],
      read_back_data[8],
      read_back_data[9],
      read_back_data[10],
      read_back_data[11]);
    applog(2, tmp42, 0);
  }
  if ( read_back_data[1] == 35 && read_back_data[0] == 12 )
  {
    crc = read_back_data[9]
        + read_back_data[8]
        + read_back_data[7]
        + read_back_data[6]
        + read_back_data[5]
        + read_back_data[4]
        + read_back_data[3]
        + read_back_data[2]
        + read_back_data[1]
        + read_back_data[0];
    if ( HIBYTE(crc) == read_back_data[10] && (unsigned __int8)crc == read_back_data[11] )
    {
      for ( i = 0; i <= 7u; ++i )
        buf[i] = v16[i - 18];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___7145);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___7145, crc);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", (const char *)_FUNCTION___7145);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001C6C4) --------------------------------------------------------
int __cdecl erase_PIC16F1704_app_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF
  unsigned int pic_flash_length; // [sp+410h] [bp+408h]
  unsigned __int8 end_addr_l; // [sp+414h] [bp+40Ch]
  unsigned __int8 end_addr_h; // [sp+415h] [bp+40Dh]
  unsigned __int8 start_addr_l; // [sp+416h] [bp+40Eh]
  unsigned __int8 start_addr_h; // [sp+417h] [bp+40Fh]
  unsigned int erase_loop; // [sp+418h] [bp+410h]
  unsigned int i; // [sp+41Ch] [bp+414h]

  i = 0;
  start_addr_h = 6;
  start_addr_l = 0;
  end_addr_h = 15;
  end_addr_l = 127;
  set_PIC16F1704_flash_pointer(which_i2c, which_chain, 6u, 0);
  pic_flash_length = 2432;
  erase_loop = 76;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s: erase_loop = %d\n", (const char *)_FUNCTION___7164, erase_loop);
    applog(2, tmp42, 0);
  }
  for ( i = 0; i < erase_loop; ++i )
    erase_PIC16F1704_flash(which_i2c, which_chain);
  return 1;
}

//----- (0001C7CC) --------------------------------------------------------
int __cdecl PIC1704_update_pic_app_program(unsigned int which_i2c, unsigned __int8 which_chain)
{
  unsigned __int8 *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[16]; // [sp+408h] [bp+408h] BYREF
  unsigned __int8 data_read[5]; // [sp+418h] [bp+418h] BYREF
  unsigned __int8 program_data[5000]; // [sp+420h] [bp+420h] BYREF
  FILE *pic_program_file; // [sp+17A8h] [bp+17A8h]
  int ret; // [sp+17ACh] [bp+17ACh]
  unsigned int pic_flash_length; // [sp+17B0h] [bp+17B0h]
  unsigned __int8 end_addr_l; // [sp+17B4h] [bp+17B4h]
  unsigned __int8 end_addr_h; // [sp+17B5h] [bp+17B5h]
  unsigned __int8 start_addr_l; // [sp+17B6h] [bp+17B6h]
  unsigned __int8 start_addr_h; // [sp+17B7h] [bp+17B7h]
  unsigned int data_int; // [sp+17B8h] [bp+17B8h]
  unsigned int i; // [sp+17BCh] [bp+17BCh]

  memset(program_data, 0, sizeof(program_data));
  i = 0;
  memset(data_read, 0, sizeof(data_read));
  memset(buf, 0, sizeof(buf));
  data_int = 0;
  start_addr_h = 6;
  start_addr_l = 0;
  end_addr_h = 15;
  end_addr_l = 127;
  pic_flash_length = 0;
  ret = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "--- update pic program\n");
    applog(2, tmp42, 0);
  }
  pic_program_file = fopen("/mnt/card/pic16f1704_app.txt", "r");
  if ( pic_program_file )
  {
    fseek(pic_program_file, 0, 0);
    memset(program_data, 0, sizeof(program_data));
    pic_flash_length = (end_addr_h << 8) + end_addr_l - (start_addr_l + (start_addr_h << 8)) + 1;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "pic_flash_length = %d\n", pic_flash_length);
      applog(2, tmp42, 0);
    }
    for ( i = 0; i < pic_flash_length; ++i )
    {
      fgets((char *)data_read, 1023, pic_program_file);
      data_int = strtoul((const char *)data_read, 0, 16);
      program_data[2 * i] = BYTE1(data_int);
      program_data[2 * i + 1] = data_int;
    }
    fclose(pic_program_file);
    ret = reset_PIC16F1704_pic(which_i2c, which_chain);
    if ( ret )
    {
      ret = erase_PIC16F1704_app_flash(which_i2c, which_chain);
      if ( ret )
      {
        ret = set_PIC16F1704_flash_pointer(which_i2c, which_chain, 6u, 0);
        if ( ret )
        {
          for ( i = 0; 4 * (pic_flash_length >> 5) > i; ++i )
          {
            v3 = &program_data[16 * i];
            v4 = *(_DWORD *)v3;
            v5 = *((_DWORD *)v3 + 1);
            v6 = *((_DWORD *)v3 + 2);
            v7 = *((_DWORD *)v3 + 3);
            *(_DWORD *)buf = v4;
            *(_DWORD *)&buf[4] = v5;
            *(_DWORD *)&buf[8] = v6;
            *(_DWORD *)&buf[12] = v7;
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf((char *)tmp42, 0x400u, "send pic program time: %d\n", i);
              applog(2, tmp42, 0);
            }
            send_data_to_PIC16F1704(which_i2c, which_chain, buf);
            write_data_into_PIC16F1704_flash(which_i2c, which_chain);
          }
          ret = reset_PIC16F1704_pic(which_i2c, which_chain);
          if ( ret )
          {
            return 1;
          }
          else
          {
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf((char *)tmp42, 0x400u, "!!! %s: reset pic error!\n\n", (const char *)_FUNCTION___7186);
              applog(2, tmp42, 0);
            }
            return 0;
          }
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf((char *)tmp42, 0x400u, "!!! %s: set flash pointer error!\n\n", (const char *)_FUNCTION___7186);
            applog(2, tmp42, 0);
          }
          return 0;
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "!!! %s: erase flash error!\n\n", (const char *)_FUNCTION___7186);
          applog(2, tmp42, 0);
        }
        return 0;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "!!! %s: reset pic error!\n\n", (const char *)_FUNCTION___7186);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: open pic16f1704_app.txt failed\n", (const char *)_FUNCTION___7186);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001CDF4) --------------------------------------------------------
int __cdecl save_freq_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 freq)
{
  __int16 v3; // r2
  int v4; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 send_data[8]; // [sp+414h] [bp+40Ch]
  unsigned __int8 read_back_data[2]; // [sp+41Ch] [bp+414h]
  unsigned __int8 crc_data[2]; // [sp+420h] [bp+418h]
  unsigned __int16 crc; // [sp+424h] [bp+41Ch]
  unsigned __int8 length; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v17[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  length = 6;
  *(_WORD *)read_back_data = 255;
  *(_DWORD *)send_data = 604416597;
  v3 = HIBYTE(freq) + 6;
  crc = (unsigned __int8)freq + v3 + 36;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = freq + v3 + 36;
  send_data[4] = HIBYTE(freq);
  send_data[5] = freq;
  send_data[6] = HIBYTE(crc);
  send_data[7] = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(which_i2c, which_chaina, v17[i - 20]);
  usleep((__useconds_t)&buf_7545[4072]);
  for ( i = 0; i <= 1u; ++i )
  {
    v4 = i;
    read_back_data[v4] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[0] == 36 && read_back_data[1] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___7217);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        (const char *)_FUNCTION___7217,
        read_back_data[0],
        read_back_data[1]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001D038) --------------------------------------------------------
int __cdecl get_PIC16F1704_freq(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 *freq)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 send_data[6]; // [sp+428h] [bp+410h]
  unsigned __int8 read_back_data[6]; // [sp+430h] [bp+418h]
  unsigned __int8 crc_data[2]; // [sp+438h] [bp+420h]
  unsigned __int16 crc; // [sp+43Ch] [bp+424h]
  unsigned __int8 length; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE v16[4]; // [sp+440h] [bp+428h] BYREF

  which_chaina = which_chain;
  length = 4;
  crc_data[0] = 0;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&read_back_data[4] = 0;
  *(_DWORD *)send_data = 621062741;
  crc = 41;
  crc_data[1] = 41;
  send_data[4] = 0;
  send_data[5] = 41;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2c, which_chaina, v16[i - 24]);
  usleep((__useconds_t)&buf_7545[4072]);
  for ( i = 0; i <= 5u; ++i )
  {
    v3 = i;
    read_back_data[v3] = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
      (const char *)_FUNCTION___7237,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5]);
    applog(2, tmp42, 0);
  }
  if ( read_back_data[1] == 37 && read_back_data[0] == 6 )
  {
    crc = read_back_data[3] + read_back_data[2] + read_back_data[1] + read_back_data[0];
    if ( HIBYTE(crc) == read_back_data[4] && (unsigned __int8)crc == read_back_data[5] )
    {
      *freq = _byteswap_ushort(*(unsigned __int16 *)&read_back_data[2]);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok, freq = %d\n\n", (const char *)_FUNCTION___7237, *freq);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___7237, crc);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", (const char *)_FUNCTION___7237);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001D38C) --------------------------------------------------------
void __cdecl set_temperature_offset_value(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *value)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+10h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___7247);
    applog(2, tmp42, 0);
  }
  write_temperature_offset_PIC16F1704(which_i2c, which_chain, value);
  usleep(0x186A0u);
}

//----- (0001D424) --------------------------------------------------------
int __cdecl write_PIC16F1705_iic_slave(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf,
        unsigned __int8 buf_len)
{
  int v4; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+2Ch] [bp+14h] BYREF
  unsigned __int8 send_data[100]; // [sp+42Ch] [bp+414h] BYREF
  unsigned __int8 read_back_data[5]; // [sp+490h] [bp+478h]
  unsigned __int8 crc_data[2]; // [sp+498h] [bp+480h]
  unsigned __int8 length; // [sp+49Ch] [bp+484h]
  unsigned __int8 i; // [sp+49Dh] [bp+485h]
  unsigned __int16 crc; // [sp+49Eh] [bp+486h]
  __int128 savedregs; // [sp+4A0h] [bp+488h] BYREF

  which_i2ca = which_i2c;
  length = buf_len + 4;
  *(_WORD *)crc_data = 255;
  *(_DWORD *)read_back_data = 255;
  read_back_data[4] = 0;
  crc = 0;
  memset(send_data, 0, sizeof(send_data));
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___7261);
    applog(2, tmp42, 0);
  }
  crc = length + 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    crc += buf[i];
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = crc;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      (const char *)_FUNCTION___7261,
      crc_data[0],
      crc_data[1]);
    applog(2, tmp42, 0);
  }
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = length;
  send_data[3] = 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    *((_BYTE *)&savedregs + i - 112) = buf[i];
  *((_BYTE *)&savedregs + buf_len - 112) = crc_data[0];
  *((_BYTE *)&savedregs + buf_len - 111) = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < length + 2; ++i )
    write_pic(which_i2ca, which_chain, *((_BYTE *)&savedregs + i - 116));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v4 = i;
    read_back_data[v4] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[1] == 38 && read_back_data[2] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___7261);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_dat"
        "a[3] = 0x%02x, read_back_data[4] = 0x%02x\n"
        "\n",
        (const char *)_FUNCTION___7261,
        read_back_data[0],
        read_back_data[1],
        read_back_data[2],
        read_back_data[3],
        read_back_data[4]);
      applog(2, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001D7B8) --------------------------------------------------------
int __cdecl read_PIC16F1705_iic_slave(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf,
        unsigned __int8 buf_len,
        unsigned __int8 *read_back_buf)
{
  int v5; // r4
  unsigned __int8 which_i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 send_data[100]; // [sp+418h] [bp+410h] BYREF
  unsigned __int8 read_back_data[100]; // [sp+47Ch] [bp+474h] BYREF
  unsigned __int8 crc_data[2]; // [sp+4E0h] [bp+4D8h]
  unsigned __int8 length; // [sp+4E4h] [bp+4DCh]
  unsigned __int8 i; // [sp+4E5h] [bp+4DDh]
  unsigned __int16 crc; // [sp+4E6h] [bp+4DEh]
  _BYTE v19[4]; // [sp+4E8h] [bp+4E0h] BYREF

  which_i2ca = which_i2c;
  length = buf_len + 4;
  *(_WORD *)crc_data = 255;
  memset(read_back_data, 0, sizeof(read_back_data));
  read_back_data[0] = -1;
  crc = 0;
  memset(send_data, 0, sizeof(send_data));
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___7291);
    applog(2, tmp42, 0);
  }
  crc = length + 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    crc += buf[i];
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = crc;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      (const char *)_FUNCTION___7291,
      crc_data[0],
      crc_data[1]);
    applog(2, tmp42, 0);
  }
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = length;
  send_data[3] = 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    v19[i - 204] = buf[i];
  v19[buf_len - 204] = crc_data[0];
  v19[buf_len - 203] = crc_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < length + 2; ++i )
    write_pic(which_i2ca, which_chain, v19[i - 208]);
  usleep(0x30D40u);
  for ( i = 0; i < buf[2] + 3; ++i )
  {
    v5 = i;
    read_back_data[v5] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( read_back_data[1] == 38 && read_back_data[2] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", (const char *)_FUNCTION___7291);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    for ( i = 0; i < buf[2] + 3; ++i )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "--- %s failed! read_back_data[%d] = 0x%02x\n\n",
          (const char *)_FUNCTION___7291,
          i,
          (unsigned __int8)v19[i - 108]);
        applog(2, tmp42, 0);
      }
    }
    return 0;
  }
}

//----- (0001DB70) --------------------------------------------------------
int __cdecl write_data_to_PIC16F1704_flash(int which_chain, int which_i2c, unsigned __int8 *buf, int buf_len)
{
  int v4; // r4
  unsigned __int8 which_i2ca; // [sp+18h] [bp+8h]
  unsigned __int8 which_chaina; // [sp+1Ch] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 send_data[12]; // [sp+420h] [bp+410h] BYREF
  unsigned __int8 read_back_data[5]; // [sp+42Ch] [bp+41Ch]
  unsigned __int8 crc_data[2]; // [sp+434h] [bp+424h]
  int send_len; // [sp+438h] [bp+428h]
  unsigned __int8 length; // [sp+43Ch] [bp+42Ch]
  unsigned __int8 i; // [sp+43Dh] [bp+42Dh]
  unsigned __int16 crc; // [sp+43Eh] [bp+42Eh]
  _BYTE v19[4]; // [sp+440h] [bp+430h] BYREF

  which_chaina = which_chain;
  which_i2ca = which_i2c;
  length = 6;
  *(_WORD *)crc_data = 255;
  *(_DWORD *)read_back_data = 255;
  read_back_data[4] = 0;
  crc = 0;
  memset(send_data, 0, sizeof(send_data));
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf((char *)tmp42, 0x400u, "\n--- %s\n", (const char *)_FUNCTION___7323);
    applog(4, tmp42, 0);
  }
  crc = buf_len + buf_len + length + 51;
  for ( i = 0; i < buf_len; ++i )
    crc += buf[i];
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = crc;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      (const char *)_FUNCTION___7323,
      crc_data[0],
      crc_data[1]);
    applog(2, tmp42, 0);
  }
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = length + buf_len;
  strcpy((char *)&send_data[3], "3");
  send_data[5] = buf_len;
  memcpy(&send_data[6], buf, buf_len);
  v19[buf_len - 26] = crc_data[0];
  v19[buf_len - 25] = crc_data[1];
  for ( i = 0; i < buf_len + 8; ++i )
    printf("%02x ", (unsigned __int8)v19[i - 32]);
  putchar(10);
  send_len = buf_len + length + 2;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < send_len; ++i )
    write_pic(which_i2ca, which_chaina, v19[i - 32]);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v4 = i;
    read_back_data[v4] = read_pic(which_i2ca, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
    printf("%02x ", (unsigned __int8)v19[i - 20]);
  putchar(10);
  if ( read_back_data[0] == 5 && read_back_data[1] == 51 && read_back_data[2] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "\n--- %s ok\n\n", (const char *)_FUNCTION___7323);
      applog(2, tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        (const char *)_FUNCTION___7323,
        read_back_data[0],
        read_back_data[1],
        read_back_data[2]);
      applog(0, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001DF88) --------------------------------------------------------
int __cdecl read_data_from_PIC16F1704_flash(
        int which_chain,
        int which_i2c,
        unsigned __int8 *buf,
        unsigned __int8 read_len)
{
  int v4; // r4
  unsigned __int8 which_i2ca; // [sp+18h] [bp+8h]
  unsigned __int8 which_chaina; // [sp+1Ch] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 send_data[8]; // [sp+420h] [bp+410h] BYREF
  unsigned __int8 read_back_data[40]; // [sp+428h] [bp+418h] BYREF
  unsigned __int8 crc_data[2]; // [sp+450h] [bp+440h]
  unsigned __int8 length; // [sp+454h] [bp+444h]
  unsigned __int8 i; // [sp+455h] [bp+445h]
  unsigned __int16 crc; // [sp+456h] [bp+446h]
  _BYTE v18[4]; // [sp+458h] [bp+448h] BYREF

  which_chaina = which_chain;
  which_i2ca = which_i2c;
  length = 6;
  *(_WORD *)crc_data = 255;
  memset(read_back_data, 0, sizeof(read_back_data));
  read_back_data[0] = -1;
  crc = 0;
  memset(send_data, 0, sizeof(send_data));
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "\n--- %s\n", (const char *)_FUNCTION___7356);
    applog(2, tmp42, 0);
  }
  crc = read_len + length + 52;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = read_len + length + 52;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      (const char *)_FUNCTION___7356,
      crc_data[0],
      crc_data[1]);
    applog(2, tmp42, 0);
  }
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = length;
  strcpy((char *)&send_data[3], "4");
  send_data[5] = read_len;
  send_data[6] = crc_data[0];
  send_data[7] = crc_data[1];
  for ( i = 0; i <= 7u; ++i )
    printf("%02x ", (unsigned __int8)v18[i - 56]);
  putchar(10);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(which_i2ca, which_chaina, v18[i - 56]);
  usleep(0x30D40u);
  for ( i = 0; i < read_len + 5; ++i )
  {
    v4 = i;
    read_back_data[v4] = read_pic(which_i2ca, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  for ( i = 0; i < read_len + 5; ++i )
    printf("%02x ", (unsigned __int8)v18[i - 48]);
  putchar(10);
  if ( read_back_data[1] == 52 && read_back_data[0] == read_len + 5 && read_back_data[2] == 1 )
  {
    crc = 0;
    for ( i = 0; i < read_len + 3; ++i )
      crc += (unsigned __int8)v18[i - 48];
    if ( HIBYTE(crc) == (unsigned __int8)v18[read_len - 45]
      && (unsigned __int8)crc == (unsigned __int8)v18[read_len - 44] )
    {
      memcpy(buf, &read_back_data[3], read_len);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "\n--- %s ok\n\n", (const char *)_FUNCTION___7356);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf((char *)tmp42, 0x400u, "\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___7356, crc);
        applog(0, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        (const char *)_FUNCTION___7356,
        read_back_data[0],
        read_back_data[1],
        read_back_data[2]);
      applog(0, tmp42, 0);
    }
    return 0;
  }
}

//----- (0001E400) --------------------------------------------------------
unsigned int get_fan_speed()
{
  return read_axi_fpga(1u);
}

//----- (0001E410) --------------------------------------------------------
void __cdecl set_fan_speed(unsigned int speed)
{
  write_axi_fpga(0x21u, speed);
}

//----- (0001E428) --------------------------------------------------------
void __cdecl fan_control(unsigned __int8 level)
{
  switch ( level )
  {
    case 0u:
      set_fan_speed(0x64u);
      break;
    case 1u:
      set_fan_speed(0xA005Au);
      break;
    case 2u:
      set_fan_speed(0x140050u);
      break;
    case 3u:
      set_fan_speed(0x1E0046u);
      break;
    case 4u:
      set_fan_speed(0x28003Cu);
      break;
    case 5u:
      set_fan_speed(0x320032u);
      break;
    case 6u:
      set_fan_speed(0x3C0028u);
      break;
    case 7u:
      set_fan_speed(0x46001Eu);
      break;
    case 8u:
      set_fan_speed(0x500014u);
      break;
    case 9u:
      set_fan_speed(0x5A000Au);
      break;
    default:
      set_fan_speed(0x640000u);
      break;
  }
}

//----- (0001E4EC) --------------------------------------------------------
int __cdecl uart_init(int comport, int baud)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s chain=%d baudrate=%d\n", (const char *)_func___6707, comport, baud);
    applog(2, tmp42, 0);
  }
  return gChain;
}

//----- (0001E570) --------------------------------------------------------
int __cdecl uart_exit(int fd)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s fd=%d\n", (const char *)_func___6712, fd);
    applog(2, tmp42, 0);
  }
  return 0;
}

//----- (0001E5E4) --------------------------------------------------------
unsigned int __cdecl check_how_many_uart_data_in_fpga(unsigned __int8 which_uart)
{
  unsigned int v1; // r3
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF

  switch ( which_uart )
  {
    case 0u:
      v1 = (read_axi_fpga(0x440u) >> 16) & 0x3FF;
      break;
    case 1u:
      v1 = read_axi_fpga(0x440u) & 0x3FF;
      break;
    case 2u:
      v1 = (read_axi_fpga(0x441u) >> 16) & 0x3FF;
      break;
    case 3u:
      v1 = read_axi_fpga(0x441u) & 0x3FF;
      break;
    case 4u:
      v1 = (read_axi_fpga(0x442u) >> 16) & 0x3FF;
      break;
    case 5u:
      v1 = read_axi_fpga(0x442u) & 0x3FF;
      break;
    case 6u:
      v1 = (read_axi_fpga(0x443u) >> 16) & 0x3FF;
      break;
    case 7u:
      v1 = read_axi_fpga(0x443u) & 0x3FF;
      break;
    case 8u:
      v1 = (read_axi_fpga(0x444u) >> 16) & 0x3FF;
      break;
    case 9u:
      v1 = read_axi_fpga(0x444u) & 0x3FF;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: The uart%d is not supported!!!\n",
          (const char *)_FUNCTION___6728,
          which_uart);
        applog(2, tmp42, 0);
      }
      v1 = 0;
      break;
  }
  return v1;
}

//----- (0001E738) --------------------------------------------------------
unsigned int __cdecl read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
{
  unsigned int v3; // r3
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  unsigned int ret_data; // [sp+41Ch] [bp+414h]
  unsigned int read_loop; // [sp+420h] [bp+418h]
  unsigned int data; // [sp+424h] [bp+41Ch]
  unsigned int ret_length; // [sp+428h] [bp+420h]
  unsigned int i; // [sp+42Ch] [bp+424h]
  unsigned int chain_read_data_addr; // [sp+430h] [bp+428h]
  unsigned int chain_read_enable_addr; // [sp+434h] [bp+42Ch]

  chain_read_enable_addr = 0;
  chain_read_data_addr = 0;
  data = 0;
  read_loop = 0;
  i = 0;
  ret_data = 0;
  ret_length = 0;
  switch ( which_uart )
  {
    case 0u:
      chain_read_enable_addr = 1100;
      chain_read_data_addr = 1101;
      goto LABEL_17;
    case 1u:
      chain_read_enable_addr = 1102;
      chain_read_data_addr = 1103;
      goto LABEL_17;
    case 2u:
      chain_read_enable_addr = 1104;
      chain_read_data_addr = 1105;
      goto LABEL_17;
    case 3u:
      chain_read_enable_addr = 1106;
      chain_read_data_addr = 1107;
      goto LABEL_17;
    case 4u:
      chain_read_enable_addr = 1108;
      chain_read_data_addr = 1109;
      goto LABEL_17;
    case 5u:
      chain_read_enable_addr = 1110;
      chain_read_data_addr = 1111;
      goto LABEL_17;
    case 6u:
      chain_read_enable_addr = 1112;
      chain_read_data_addr = 1113;
      goto LABEL_17;
    case 7u:
      chain_read_enable_addr = 1114;
      chain_read_data_addr = 1115;
      goto LABEL_17;
    case 8u:
      chain_read_enable_addr = 1116;
      chain_read_data_addr = 1117;
      goto LABEL_17;
    case 9u:
      chain_read_enable_addr = 1118;
      chain_read_data_addr = 1119;
LABEL_17:
      data = length & 0x3FF | 0x80000000;
      write_axi_fpga(chain_read_enable_addr, data);
      read_loop = length >> 2;
      for ( i = 0; i < read_loop; ++i )
      {
        ret_data = read_axi_fpga(chain_read_data_addr);
        buf[4 * i] = HIBYTE(ret_data);
        buf[4 * i + 1] = BYTE2(ret_data);
        buf[4 * i + 2] = BYTE1(ret_data);
        buf[4 * i + 3] = ret_data;
      }
      ret_length = 4 * read_loop;
      read_loop = length & 3;
      if ( (length & 3) != 0 )
      {
        ret_data = read_axi_fpga(chain_read_data_addr);
        switch ( read_loop )
        {
          case 2u:
            buf[4 * i] = HIBYTE(ret_data);
            buf[4 * i + 1] = BYTE2(ret_data);
            ret_length += 2;
            break;
          case 3u:
            buf[4 * i] = HIBYTE(ret_data);
            buf[4 * i + 1] = BYTE2(ret_data);
            buf[4 * i + 2] = BYTE1(ret_data);
            ret_length += 3;
            break;
          case 1u:
            buf[4 * i] = HIBYTE(ret_data);
            ++ret_length;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(
                (char *)tmp42,
                0x400u,
                "%s: the uart%d left data is 4*N length, error!!!\n",
                (const char *)_FUNCTION___6754,
                which_uart);
              applog(2, tmp42, 0);
            }
            break;
        }
      }
      v3 = ret_length;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: The uart%d is not supported!!!\n",
          (const char *)_FUNCTION___6754,
          which_uart);
        applog(2, tmp42, 0);
      }
      v3 = 0;
      break;
  }
  return v3;
}

//----- (0001EAE0) --------------------------------------------------------
unsigned int __cdecl uart_send(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
{
  unsigned int axi_fpga; // r0
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 send_buf[512]; // [sp+418h] [bp+410h] BYREF
  unsigned int max_fpga_can_send_uart_data_len; // [sp+618h] [bp+610h]
  unsigned int send_data_len; // [sp+61Ch] [bp+614h]
  int send_loop; // [sp+620h] [bp+618h]
  unsigned int bit_shift_num; // [sp+624h] [bp+61Ch]
  unsigned int chain_send_buffer_addr; // [sp+628h] [bp+620h]
  unsigned int chain_send_ready_addr; // [sp+62Ch] [bp+624h]
  unsigned int chain_send_fifo_status_addr; // [sp+630h] [bp+628h]
  unsigned int send_data; // [sp+634h] [bp+62Ch]
  int i; // [sp+638h] [bp+630h]
  int send_counter; // [sp+63Ch] [bp+634h]

  send_counter = 0;
  send_loop = 0;
  i = 0;
  memset(send_buf, 0, sizeof(send_buf));
  send_data_len = length;
  send_data = 0;
  chain_send_fifo_status_addr = 0;
  chain_send_ready_addr = 0;
  chain_send_buffer_addr = 0;
  max_fpga_can_send_uart_data_len = 0;
  bit_shift_num = 0;
  pthread_mutex_lock(&uart_send_mutex[which_uart]);
  switch ( which_uart )
  {
    case 0u:
      bit_shift_num = 24;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1028;
      chain_send_buffer_addr = 1029;
      goto LABEL_17;
    case 1u:
      bit_shift_num = 16;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1030;
      chain_send_buffer_addr = 1031;
      goto LABEL_17;
    case 2u:
      bit_shift_num = 8;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1032;
      chain_send_buffer_addr = 1033;
      goto LABEL_17;
    case 3u:
      bit_shift_num = 0;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1034;
      chain_send_buffer_addr = 1035;
      goto LABEL_17;
    case 4u:
      bit_shift_num = 24;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1036;
      chain_send_buffer_addr = 1037;
      goto LABEL_17;
    case 5u:
      bit_shift_num = 16;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1038;
      chain_send_buffer_addr = 1039;
      goto LABEL_17;
    case 6u:
      bit_shift_num = 8;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1040;
      chain_send_buffer_addr = 1041;
      goto LABEL_17;
    case 7u:
      bit_shift_num = 0;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1042;
      chain_send_buffer_addr = 1043;
      goto LABEL_17;
    case 8u:
      bit_shift_num = 24;
      chain_send_fifo_status_addr = 1026;
      chain_send_ready_addr = 1044;
      chain_send_buffer_addr = 1045;
      goto LABEL_17;
    case 9u:
      bit_shift_num = 16;
      chain_send_fifo_status_addr = 1026;
      chain_send_ready_addr = 1046;
      chain_send_buffer_addr = 1047;
LABEL_17:
      send_counter = 0;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: The uart%d is not supported!!!\n",
          (const char *)_FUNCTION___6793,
          which_uart);
        applog(2, tmp42, 0);
      }
      return 0;
  }
  while ( 1 )
  {
    axi_fpga = read_axi_fpga(chain_send_fifo_status_addr);
    max_fpga_can_send_uart_data_len = (unsigned __int8)(axi_fpga >> bit_shift_num);
    if ( max_fpga_can_send_uart_data_len >= length )
      break;
    usleep(0xBB8u);
    if ( ++send_counter > 20 )
    {
      pthread_mutex_unlock(&uart_send_mutex[which_uart]);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: uart%d always dose not has enough send fifo space, break\n",
          (const char *)_FUNCTION___6793,
          which_uart);
        applog(2, tmp42, 0);
      }
      return 0;
    }
  }
  send_counter = 0;
  while ( 1 )
  {
    if ( (read_axi_fpga(chain_send_ready_addr) & 0x80000000) == 0 )
    {
      memcpy(send_buf, buf, length);
      send_loop = send_data_len >> 2;
      for ( i = 0; i < send_loop; ++i )
      {
        send_data = (send_buf[4 * i + 2] << 8) | (send_buf[4 * i] << 24) | (send_buf[4 * i + 1] << 16) | send_buf[4 * i + 3];
        write_axi_fpga(chain_send_buffer_addr, send_data);
      }
      send_loop = send_data_len & 3;
      if ( (send_data_len & 3) != 0 )
      {
        switch ( send_loop )
        {
          case 2:
            send_data = (send_buf[4 * i + 1] << 16) | (send_buf[4 * i] << 24);
            break;
          case 3:
            send_data = (send_buf[4 * i + 2] << 8) | (send_buf[4 * i] << 24) | (send_buf[4 * i + 1] << 16);
            break;
          case 1:
            send_data = send_buf[4 * i] << 24;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(
                (char *)tmp42,
                0x400u,
                "%s: the uart%d send left data is 4*N length, error!!!\n",
                (const char *)_FUNCTION___6793,
                which_uart);
              applog(2, tmp42, 0);
            }
            break;
        }
        write_axi_fpga(chain_send_buffer_addr, send_data);
      }
      write_axi_fpga(chain_send_ready_addr, send_data_len | 0x80000000);
      pthread_mutex_unlock(&uart_send_mutex[which_uart]);
      return send_data_len;
    }
    if ( send_counter > 20 )
      break;
    ++send_counter;
    usleep(0xBB8u);
  }
  pthread_mutex_unlock(&uart_send_mutex[which_uart]);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s: uart%d always busy, break\n", (const char *)_FUNCTION___6793, which_uart);
    applog(2, tmp42, 0);
  }
  return 0;
}

//----- (0001F080) --------------------------------------------------------
unsigned int __cdecl uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length)
{
  unsigned int nbytes; // [sp+10h] [bp+10h]
  unsigned int len; // [sp+14h] [bp+14h]

  pthread_mutex_lock(&uart_receive_mutex[which_uart]);
  nbytes = check_how_many_uart_data_in_fpga(which_uart);
  if ( nbytes < buf_length )
  {
    if ( nbytes )
      len = read_uart_data_in_fpga(which_uart, buf, nbytes);
    else
      len = 0;
  }
  else
  {
    len = read_uart_data_in_fpga(which_uart, buf, buf_length);
  }
  pthread_mutex_unlock(&uart_receive_mutex[which_uart]);
  return len;
}

//----- (0001F110) --------------------------------------------------------
unsigned int __cdecl clear_uart_send_fifo(unsigned __int8 which_chain)
{
  unsigned int axi_fpga; // r0
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF
  unsigned int max_fpga_can_send_uart_data_len; // [sp+410h] [bp+408h]
  unsigned int chain_send_buffer_addr; // [sp+414h] [bp+40Ch]
  unsigned int send_counter; // [sp+418h] [bp+410h]
  unsigned int bit_shift_num; // [sp+41Ch] [bp+414h]
  unsigned int chain_send_ready_addr; // [sp+420h] [bp+418h]
  unsigned int chain_send_fifo_status_addr; // [sp+424h] [bp+41Ch]

  chain_send_fifo_status_addr = 0;
  chain_send_ready_addr = 0;
  max_fpga_can_send_uart_data_len = 0;
  bit_shift_num = 0;
  send_counter = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___6827);
    applog(2, tmp42, 0);
  }
  pthread_mutex_lock(&uart_send_mutex[which_chain]);
  switch ( which_chain )
  {
    case 0u:
      bit_shift_num = 24;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1028;
      chain_send_buffer_addr = 1029;
      goto LABEL_21;
    case 1u:
      bit_shift_num = 16;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1030;
      chain_send_buffer_addr = 1031;
      goto LABEL_21;
    case 2u:
      bit_shift_num = 8;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1032;
      chain_send_buffer_addr = 1033;
      goto LABEL_21;
    case 3u:
      bit_shift_num = 0;
      chain_send_fifo_status_addr = 1024;
      chain_send_ready_addr = 1034;
      chain_send_buffer_addr = 1035;
      goto LABEL_21;
    case 4u:
      bit_shift_num = 24;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1036;
      chain_send_buffer_addr = 1037;
      goto LABEL_21;
    case 5u:
      bit_shift_num = 16;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1038;
      chain_send_buffer_addr = 1039;
      goto LABEL_21;
    case 6u:
      bit_shift_num = 8;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1040;
      chain_send_buffer_addr = 1041;
      goto LABEL_21;
    case 7u:
      bit_shift_num = 0;
      chain_send_fifo_status_addr = 1025;
      chain_send_ready_addr = 1042;
      chain_send_buffer_addr = 1043;
      goto LABEL_21;
    case 8u:
      bit_shift_num = 24;
      chain_send_fifo_status_addr = 1026;
      chain_send_ready_addr = 1044;
      chain_send_buffer_addr = 1045;
      goto LABEL_21;
    case 9u:
      bit_shift_num = 16;
      chain_send_fifo_status_addr = 1026;
      chain_send_ready_addr = 1046;
      chain_send_buffer_addr = 1047;
LABEL_21:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "chain_send_ready_addr: 0x%08x, chain_send_buffer_addr: 0x%08x",
          chain_send_ready_addr,
          chain_send_buffer_addr);
        applog(4, tmp42, 0);
      }
      send_counter = 0;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: The uart%d is not supported!!!\n",
          (const char *)_FUNCTION___6827,
          which_chain);
        applog(2, tmp42, 0);
      }
      pthread_mutex_unlock(&uart_send_mutex[which_chain]);
      return 1;
  }
  do
  {
    axi_fpga = read_axi_fpga(chain_send_fifo_status_addr);
    max_fpga_can_send_uart_data_len = (unsigned __int8)(axi_fpga >> bit_shift_num);
    if ( max_fpga_can_send_uart_data_len == 255 )
    {
      pthread_mutex_unlock(&uart_send_mutex[which_chain]);
      return 0;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "%s: waiting fpga uart%d clear send fifo space ...\n",
        (const char *)_FUNCTION___6827,
        which_chain);
      applog(2, tmp42, 0);
    }
    usleep(0xBB8u);
    ++send_counter;
  }
  while ( send_counter <= 0x14 );
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "%s: uart%d always dose not has enough send fifo space, break\n",
      (const char *)_FUNCTION___6827,
      which_chain);
    applog(2, tmp42, 0);
  }
  pthread_mutex_unlock(&uart_send_mutex[which_chain]);
  return max_fpga_can_send_uart_data_len;
}

//----- (0001F540) --------------------------------------------------------
unsigned int __cdecl clear_uart_rx_fifo(unsigned __int8 which_chain)
{
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 *buf; // [sp+41Ch] [bp+40Ch]
  unsigned int nbytes; // [sp+420h] [bp+410h]
  unsigned int len; // [sp+424h] [bp+414h]

  len = 0;
  nbytes = 0;
  buf = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___6852);
    applog(2, tmp42, 0);
  }
  pthread_mutex_lock(&uart_receive_mutex[which_chain]);
  nbytes = check_how_many_uart_data_in_fpga(which_chain);
  if ( nbytes )
  {
    buf = (unsigned __int8 *)malloc(nbytes);
    if ( buf )
    {
      len = read_uart_data_in_fpga(which_chain, buf, nbytes);
      if ( len != nbytes && (use_syslog || opt_log_output || opt_log_level > 1) )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
          (const char *)_FUNCTION___6852,
          which_chain,
          nbytes,
          len);
        applog(2, tmp42, 0);
      }
      free(buf);
      buf = 0;
      usleep(0x2710u);
      pthread_mutex_unlock(&uart_receive_mutex[which_chain]);
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "%s: uart%d malloc buffer error\n", (const char *)_FUNCTION___6852, which_chain);
        applog(2, tmp42, 0);
      }
      buf = 0;
      usleep((__useconds_t)&nonce_fifo.nonce_buffer[140].Nonce[564]);
      pthread_mutex_unlock(&uart_receive_mutex[which_chain]);
      return 1;
    }
  }
  else
  {
    pthread_mutex_unlock(&uart_receive_mutex[which_chain]);
    return 0;
  }
}

//----- (0001F7A4) --------------------------------------------------------
int __cdecl baud2bt8d(unsigned int baud)
{
  if ( baud == 921600 )
    return 2;
  if ( baud <= 0xE1000 )
  {
    if ( baud == 115200 )
    {
      return 26;
    }
    else
    {
      if ( baud != 460800 )
        goto LABEL_13;
      return 6;
    }
  }
  if ( baud == 1500000 )
    return 1;
  if ( baud == 3000000 )
    return 0;
LABEL_13:
  printf("%s: the baud is not recommand value, so use 115200 baud\n", (const char *)_FUNCTION___6866);
  return -1;
}

//----- (0001F828) --------------------------------------------------------
int __cdecl cgpu_init(runtime_base_t *runtime)
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  int ret; // [sp+40Ch] [bp+40Ch]

  ret = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___8581);
    applog(2, tmp42, 0);
  }
  memset(&cgpu, 0, sizeof(cgpu));
  ret = open_lcd();
  if ( ret <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "!!! %s: open lcd driver error\n", (const char *)_FUNCTION___8581);
      applog(2, tmp42, 0);
    }
    goto LCD_ERR;
  }
  memset(lcd_output, 32, sizeof(lcd_output));
  write(cgpu.lcd_fd, lcd_output, 0x40u);
  ret = open_key();
  if ( ret <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "!!! %s: open start key error\n", (const char *)_FUNCTION___8581);
      applog(2, tmp42, 0);
    }
    goto START_KEY_ERR;
  }
  ret = open_red_led();
  if ( ret <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "!!! %s: open red led error\n", (const char *)_FUNCTION___8581);
      applog(2, tmp42, 0);
    }
    goto RED_LED_ERR;
  }
  ret = open_green_led();
  if ( ret <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "!!! %s: open green led error\n", (const char *)_FUNCTION___8581);
      applog(2, tmp42, 0);
    }
    goto GREEN_LED_ERR;
  }
  ret = bitmain_axi_init();
  if ( ret < 0 )
  {
    bitmain_axi_close();
GREEN_LED_ERR:
    close_green_led();
RED_LED_ERR:
    close_red_led();
START_KEY_ERR:
    close_key();
LCD_ERR:
    close_lcd();
    return -1;
  }
  cgpu.runtime = runtime;
  patten_info_init();
  patten_load("/mnt/card/");
  return 0;
}

//----- (0001FACC) --------------------------------------------------------
void cgpu_exit()
{
  bitmain_axi_close();
  close_green_led();
  close_red_led();
  close_key();
  close_lcd();
  patten_info_destory();
}

//----- (0001FAEC) --------------------------------------------------------
int __cdecl v9_key_read(unsigned __int8 *command, int len)
{
  lseek(cgpu.key_fd, 0, 0);
  return read(cgpu.key_fd, command, len);
}

//----- (0001FB28) --------------------------------------------------------
void display_arguments()
{
  size_t v0; // r0
  unsigned __int8 output[4][16]; // [sp+0h] [bp+0h] BYREF

  memset(output, 0, sizeof(output));
  lseek(cgpu.lcd_fd, 0, 0);
  memset(output, 32, sizeof(output));
  v0 = strlen((const char *)app_conf->name);
  memcpy(output, app_conf->name, v0);
  sprintf((char *)output[1], "IC:%2d", app_conf->asic_num);
  sprintf((char *)output[2], "FREQ: %d", app_conf->pcba_freq);
  sprintf((char *)output[3], "Voltage: %d", app_conf->pcba_voltage);
  write(cgpu.lcd_fd, output, 0x40u);
}

//----- (0001FBFC) --------------------------------------------------------
void init_pcba_args()
{
  runtime_base_t *runtime; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]
  int ia; // [sp+4h] [bp+4h]

  runtime = cgpu.runtime;
  for ( i = 0; i <= 0; ++i )
    runtime->chain_status[i].real_asic_num = 0;
  for ( ia = 0; ia <= 2; ++ia )
  {
    chip_temp[ia] = 0;
    pcb_temp[ia] = 0;
  }
  gChain = -1;
  pcb_high = 0;
  chip_high = 0;
}

//----- (0001FCA0) --------------------------------------------------------
int check_chain()
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+0h] BYREF
  int ret; // [sp+408h] [bp+400h]
  unsigned __int8 which_chain; // [sp+40Fh] [bp+407h]

  which_chain = -1;
  ret = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", (const char *)_FUNCTION___8617);
    applog(2, tmp42, 0);
  }
  cgpu.chain_num = 0;
  ret = read_axi_fpga(2u);
  if ( ret == 1 || ret == 2 || ret == 4 || ret == 8 )
  {
    for ( which_chain = 0; !which_chain; ++which_chain )
    {
      chain_info_0[0].which_chain = 0;
      chain_info_0[0].which_i2c = 0;
      if ( (ret & 1) != 0 )
      {
        cgpu.chain_exist[which_chain] = 1;
        ++cgpu.chain_num;
        gChain = which_chain;
        cgpu.runtime->chain_id = which_chain;
        gI2c = 0;
        chain_info_0[which_chain].which_chain = which_chain;
        chain_info_0[which_chain].which_i2c = gI2c;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "%s: gChain = %d, gI2c = %d\n", (const char *)_FUNCTION___8617, gChain, gI2c);
          applog(2, tmp42, 0);
        }
      }
      else
      {
        cgpu.chain_exist[which_chain] = 0;
      }
    }
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "%s: Test zhiju only support 1 plug, but now is 0x%08x\n",
        (const char *)_FUNCTION___8617,
        ret);
      applog(2, tmp42, 0);
    }
    return -1;
  }
}

//----- (0001FF08) --------------------------------------------------------
void *read_all_sensor()
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+4h] BYREF
  int chip_addr; // [sp+40Ch] [bp+404h]
  runtime_base_t *runtime; // [sp+410h] [bp+408h]
  int high_temp_alarm_counter; // [sp+414h] [bp+40Ch]
  int pcb_high_temp; // [sp+418h] [bp+410h]
  int chip_high_temp; // [sp+41Ch] [bp+414h]
  int which_asic; // [sp+420h] [bp+418h]
  int i; // [sp+424h] [bp+41Ch]

  runtime = cgpu.runtime;
  high_temp_alarm_counter = 0;
  while ( runtime->start_recv )
  {
    for ( i = 0; runtime->sensor_num > i; ++i )
    {
      which_asic = runtime->sensor_pos[i];
      chip_addr = which_asic * runtime->addr_interval;
      user_read_iic(runtime, chip_addr, 0x4Cu, 1u, &chip_temp[which_asic], 1);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "ASIC %d chip temp %d\n", which_asic, chip_temp[which_asic]);
        applog(2, tmp42, 0);
      }
      user_read_iic(runtime, chip_addr, 0x4Cu, 0, &pcb_temp[which_asic], 1);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "ASIC %d pcb temp %d\n", which_asic, pcb_temp[which_asic]);
        applog(2, tmp42, 0);
      }
    }
    pcb_high_temp = 0;
    chip_high_temp = 0;
    for ( which_asic = 0; which_asic <= 2; ++which_asic )
    {
      if ( chip_temp[which_asic] > chip_high_temp )
        chip_high_temp = chip_temp[which_asic];
      if ( pcb_temp[which_asic] > pcb_high_temp )
        pcb_high_temp = pcb_temp[which_asic];
    }
    chip_high = chip_high_temp;
    pcb_high = pcb_high_temp;
    if ( (unsigned __int8)chip_high_temp <= app_conf->pcba_tempture_high )
    {
      high_temp_alarm_counter = 0;
    }
    else
    {
      ++high_temp_alarm_counter;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "temperature alarm counter %d\n", high_temp_alarm_counter);
        applog(2, tmp42, 0);
      }
      if ( high_temp_alarm_counter > 1 )
        hardware_exception = 1;
    }
    sleep(2u);
  }
  return 0;
}

//----- (000201CC) --------------------------------------------------------
void start_read_temp()
{
  user_i2c_enable(cgpu.runtime, gChain);
  usleep(0xC350u);
  pthread_create(&cgpu.read_temp, 0, (void *(*)(void *))read_all_sensor, 0);
}

//----- (00020210) --------------------------------------------------------
void stop_read_temp()
{
  pthread_cancel(cgpu.read_temp);
  pthread_join(cgpu.read_temp, 0);
}

//----- (0002023C) --------------------------------------------------------
void show_result()
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+4h] BYREF
  int which_asic; // [sp+40Ch] [bp+404h]
  runtime_base_t *runtime; // [sp+410h] [bp+408h]
  int i; // [sp+414h] [bp+40Ch]

  runtime = cgpu.runtime;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "---------------------------------result-----------------------------------------------\n");
    applog(2, tmp42, 0);
  }
  read_temp_test_result = 1;
  for ( i = 0; runtime->sensor_num > i; ++i )
  {
    which_asic = runtime->sensor_pos[i];
    if ( chip_temp[which_asic] < app_conf->pcba_tempture_low || chip_temp[which_asic] > app_conf->pcba_tempture_high )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf((char *)tmp42, 0x400u, "Sensor %d CHIP temp wrong!\n", runtime->sensor_pos[0] + 1);
        applog(0, tmp42, 0);
      }
      read_temp_test_result = -1;
    }
    if ( pcb_temp[which_asic] < app_conf->pcba_tempture_low || pcb_temp[which_asic] > app_conf->pcba_tempture_high )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf((char *)tmp42, 0x400u, "Sensor %d PCB temp wrong!\n", runtime->sensor_pos[0] + 1);
        applog(0, tmp42, 0);
      }
      read_temp_test_result = -1;
    }
  }
  if ( read_temp_test_result <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "Sensor NG.\n");
      applog(2, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "Sensor OK.\n");
    applog(2, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "Expect pass rate: %d, real pattern rate: %.2f\n",
      app_conf->pcba_pattern_pass_rate,
      (float)(g_patten.total_rate * 100.0));
    applog(2, tmp42, 0);
  }
  if ( app_conf->pcba_enable_level != 1 )
  {
    pattern_level = 1;
    if ( (float)(g_patten.total_rate * 100.0) >= (float)app_conf->pcba_pattern_pass_rate )
    {
      pattern_result = 1;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
        goto LABEL_59;
      goto LABEL_64;
    }
    pattern_result = -1;
    if ( !use_syslog && !opt_log_output && opt_log_level <= 1 )
      goto LABEL_64;
    goto LABEL_63;
  }
  pattern_result = 1;
  if ( (float)(g_patten.total_rate * 100.0) < *app_conf->pcba_level_rate )
  {
    if ( (float)(g_patten.total_rate * 100.0) >= app_conf->pcba_level_rate[1] )
    {
      pattern_level = 2;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
        goto LABEL_59;
      goto LABEL_64;
    }
    if ( (float)(g_patten.total_rate * 100.0) >= app_conf->pcba_level_rate[2] )
    {
      pattern_level = 3;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
        goto LABEL_59;
      goto LABEL_64;
    }
    pattern_level = 4;
    pattern_result = -1;
    if ( !use_syslog && !opt_log_output && opt_log_level <= 1 )
      goto LABEL_64;
LABEL_63:
    strcpy((char *)tmp42, "Pattern NG.\n");
    applog(2, tmp42, 0);
    goto LABEL_64;
  }
  pattern_level = 1;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
LABEL_59:
    strcpy((char *)tmp42, "Pattern OK.\n");
    applog(2, tmp42, 0);
  }
LABEL_64:
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "--------------------------------------------------------------------------------------\n");
    applog(2, tmp42, 0);
  }
}

//----- (000208B8) --------------------------------------------------------
void V9_print_lcd()
{
  unsigned __int8 level_str[17]; // [sp+8h] [bp+0h] BYREF
  unsigned __int8 str[17]; // [sp+1Ch] [bp+14h] BYREF

  memset(str, 0, sizeof(str));
  show_result();
  sprintf(
    (char *)str,
    "Pattern %d %d %d   ",
    *g_patten.asic_recv_nonces,
    g_patten.asic_recv_nonces[1],
    g_patten.asic_recv_nonces[2]);
  write_lcd(0, str, 0x10u);
  if ( pattern_result <= 0 )
    write_lcd_no_memset(1u, "Pattern NG      ", 0x10u);
  else
    write_lcd_no_memset(1u, "Pattern OK      ", 0x10u);
  if ( read_temp_test_result <= 0 )
    write_lcd_no_memset(2u, "Sensor NG       ", 0x10u);
  else
    write_lcd_no_memset(2u, "Sensor OK       ", 0x10u);
  memset(level_str, 0, sizeof(level_str));
  sprintf((char *)level_str, "    Level %d     ", pattern_level);
  write_lcd_no_memset(3u, level_str, 0x10u);
}

//----- (000209B8) --------------------------------------------------------
void __cdecl V9_print_lcd_type(int type)
{
  if ( type == -1 )
  {
    write_lcd_no_memset(0, " hardware error ", 0x10u);
    write_lcd_no_memset(1u, "     check      ", 0x10u);
    write_lcd_no_memset(2u, " u2 u44 u16 u23 ", 0x10u);
    write_lcd_no_memset(3u, " u30            ", 0x10u);
  }
  else
  {
    V9_print_lcd();
  }
}

//----- (00020A18) --------------------------------------------------------
int __cdecl is_asic_pass(int index)
{
  return 1;
}

//----- (00020A30) --------------------------------------------------------
void __noreturn show_stats_func_z15_3chips()
{
  unsigned __int8 str[16]; // [sp+8h] [bp+0h] BYREF
  int len; // [sp+18h] [bp+10h]
  int time_counter; // [sp+1Ch] [bp+14h]

  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    sprintf((char *)lcd_output, "time %ds", time_counter);
    memset(str, 0, sizeof(str));
    sprintf(
      (char *)str,
      "nonce=%d %d %d",
      *g_patten.asic_recv_nonces,
      g_patten.asic_recv_nonces[1],
      g_patten.asic_recv_nonces[2]);
    len = strlen((const char *)str);
    memset(&str[len], 32, 16 - len);
    *(_QWORD *)&lcd_output[1][0] = *(_QWORD *)str;
    *(_QWORD *)&lcd_output[1][8] = *(_QWORD *)&str[8];
    sprintf((char *)lcd_output[2], "chip: %d'C      ", chip_high);
    sprintf((char *)lcd_output[3], "pcb : %d'C      ", pcb_high);
    ++time_counter;
    write(cgpu.lcd_fd, lcd_output, 0x40u);
    usleep((__useconds_t)&nonce_fifo.nonce_buffer[508].Nonce[1188]);
  }
}

//----- (00020B48) --------------------------------------------------------
int bm1744_hashboard_init()
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+4h] BYREF
  runtime_base_t *runtime; // [sp+40Ch] [bp+404h]

  runtime = cgpu.runtime;
  fan_control(5u);
  check_asic_num(runtime);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "%s: Check ASIC number: chain %d has %d asic\n",
      (const char *)_FUNCTION___8689,
      runtime->chain_id,
      runtime->chain_status[runtime->chain_id].real_asic_num);
    applog(2, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "%s: Expect ASIC number: %d\n",
      (const char *)_FUNCTION___8689,
      runtime->chain_status[runtime->chain_id].design_asic_num);
    applog(2, tmp42, 0);
  }
  if ( runtime->chain_status[runtime->chain_id].real_asic_num == runtime->chain_status[runtime->chain_id].design_asic_num )
  {
    if ( app_conf->pcba_only_find_asic )
    {
      write_lcd(0, "Find all ASIC!  ", 0x10u);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        strcpy((char *)tmp42, "Find all ASIC\n");
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      set_asic_address(runtime, gChain);
      user_i2c_enable(cgpu.runtime, gChain);
      runtime->set_core_timeout(runtime->chain_status[gChain].fd, app_conf->core_timeout);
      usleep(0x2710u);
      runtime->set_ticket_mask(runtime->chain_status[gChain].fd, app_conf->ticket_mask);
      usleep(0x2710u);
      runtime->set_frequency(runtime->chain_status[gChain].fd, app_conf->pcba_freq);
      usleep(0x2710u);
      runtime->set_nonce_shift(runtime->chain_status[gChain].fd, 0, &runtime->nonce_shift);
      usleep(0x2710u);
      puts("re read asic address:");
      runtime->read_register(runtime->chain_status[runtime->chain_id].fd, 1, 0, 0);
      return 0;
    }
  }
  else
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    write_lcd(0, "Not enough ASIC!", 0x10u);
    sprintf((char *)lcd_output[1], "%d ASIC", runtime->chain_status[runtime->chain_id].real_asic_num);
    write_lcd_no_memset(1u, lcd_output[1], 0x10u);
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      strcpy((char *)tmp42, "Not enough ASIC!\n");
      applog(0, tmp42, 0);
    }
    return -1;
  }
}

//----- (00020F00) --------------------------------------------------------
void singleboard_pattern_test()
{
  int v0; // r3
  int v1; // r3
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF
  int offset; // [sp+400h] [bp+400h]
  int is_match; // [sp+404h] [bp+404h]
  int counter_limit; // [sp+408h] [bp+408h]
  int patten_check_interval; // [sp+40Ch] [bp+40Ch]
  int one_patten_bin_len; // [sp+410h] [bp+410h]
  int counter; // [sp+414h] [bp+414h]
  int which_patten; // [sp+418h] [bp+418h]
  int which_core; // [sp+41Ch] [bp+41Ch]
  int which_asic; // [sp+420h] [bp+420h]
  int i; // [sp+424h] [bp+424h]

  one_patten_bin_len = g_patten.sol_bin_len + g_patten.work_bin_len + g_patten.nonce_bin_len;
  g_patten.start = 1;
  sleep(1u);
  fan_control(5u);
  for ( which_asic = 0; g_patten.asic_num > which_asic; ++which_asic )
  {
    for ( which_core = 0; g_patten.core_num > which_core; ++which_core )
    {
      for ( which_patten = 0; g_patten.patten_num > which_patten; ++which_patten )
      {
        if ( hardware_exception )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 0 )
          {
            snprintf((char *)tmp42, 0x400u, "%s hardware error\n", (const char *)_func___8701);
            applog(1, tmp42, 0);
          }
          which_patten = g_patten.patten_num;
          which_core = g_patten.core_num;
          which_asic = g_patten.asic_num;
        }
        else
        {
          pthread_mutex_lock(&g_patten.patten_mutex);
          g_patten.cur_work = &g_patten.patten_start[one_patten_bin_len * which_core * g_patten.patten_num
                                                   + one_patten_bin_len
                                                   * g_patten.patten_num
                                                   * which_asic
                                                   * g_patten.core_num
                                                   + one_patten_bin_len * which_patten];
          g_patten.cur_asic = which_asic;
          g_patten.cur_core = which_core;
          g_patten.cur_patten = which_patten;
          pthread_mutex_unlock(&g_patten.patten_mutex);
          user_send_work(cgpu.runtime, g_patten.cur_work, 1, 0);
          patten_check_interval = 50000;
          counter_limit = app_conf->send_pattern_timeout / 50000;
          counter = 0;
          is_match = 0;
          do
          {
            usleep(patten_check_interval);
            pthread_mutex_lock(&g_patten.patten_mutex);
            is_match = g_patten.is_nonce_match[g_patten.cur_patten
                                             + g_patten.patten_num
                                             * (g_patten.core_num * g_patten.cur_asic + g_patten.cur_core)];
            pthread_mutex_unlock(&g_patten.patten_mutex);
            if ( is_match == 1 )
              break;
            v0 = counter++;
          }
          while ( v0 < counter_limit );
          if ( is_match != 1 )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf((char *)tmp42, 0x400u, "pattern id %d receive failed\n", which_patten);
              applog(2, tmp42, 0);
            }
            dump_str((void *)_bss_start, 0, g_patten.cur_work, g_patten.work_bin_len);
          }
        }
      }
    }
  }
  g_patten.start = 0;
  sleep(1u);
  for ( which_asic = 0; g_patten.asic_num > which_asic; ++which_asic )
  {
    printf("ASIC %d result:\n", which_asic);
    offset = g_patten.patten_num * which_asic * g_patten.core_num;
    for ( i = 0; g_patten.patten_num * g_patten.core_num > i; ++i )
    {
      if ( g_patten.is_nonce_match[i + offset] )
        v1 = 79;
      else
        v1 = 88;
      printf("%c ", v1);
      if ( i % 10 == 9 )
        putchar(10);
    }
    putchar(10);
  }
}
// 483E0: using guessed type int _bss_start;

//----- (00021338) --------------------------------------------------------
void *__cdecl check_nonce(void *args)
{
  int nonceNum; // [sp+Ch] [bp+Ch] BYREF
  nonce_rb_format nonce_tmp; // [sp+10h] [bp+10h] BYREF
  int asic_index; // [sp+560h] [bp+560h]
  runtime_base_t *runtime; // [sp+564h] [bp+564h]

  runtime = (runtime_base_t *)args;
  nonceNum = 0;
  nonce_fifo_num(&nonceNum);
  while ( nonceNum )
  {
    --nonceNum;
    pop_nonce(&nonce_tmp);
    asic_index = nonce_tmp.chip_addr / runtime->addr_interval;
    is_patten_match(asic_index, nonce_tmp.chip_nonce, nonce_tmp.Nonce);
  }
  return 0;
}

//----- (000213C4) --------------------------------------------------------
void *__cdecl __noreturn check_nonce_loop(void *args)
{
  pthread_t send_id; // [sp+8h] [bp+8h] BYREF
  runtime_base_t *runtime; // [sp+Ch] [bp+Ch]

  runtime = (runtime_base_t *)args;
  while ( 1 )
  {
    if ( runtime->start_recv )
    {
      pthread_create(&send_id, 0, (void *(*)(void *))check_nonce, args);
      pthread_join(send_id, 0);
      usleep(0x1388u);
    }
    else
    {
      usleep(0x186A0u);
    }
  }
}

//----- (00021410) --------------------------------------------------------
int __cdecl vol_init(unsigned __int16 vol)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF
  unsigned __int16 read_back; // [sp+412h] [bp+40Ah]
  int which_asic; // [sp+414h] [bp+40Ch]

  if ( vol <= 0x384u && vol > 0x2EDu )
  {
    if ( vol == 800 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "setting voltage == configed voltage %d\n", vol);
        applog(2, tmp42, 0);
      }
      return 1;
    }
    else
    {
      for ( which_asic = 0; which_asic <= 2; ++which_asic )
      {
        read_back = ISL_set_voltage(gChain, 0, isl_dev_addr[which_asic], vol);
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "asic%d read back voltage = %d\n", which_asic, read_back);
          applog(2, tmp42, 0);
        }
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "illeagel setting voltage is %d\n", vol);
      applog(2, tmp42, 0);
    }
    return -1;
  }
}

//----- (00021590) --------------------------------------------------------
void __cdecl pcba_runtime_init(runtime_base_t *runtime)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  int bt8d; // [sp+408h] [bp+408h]
  int chainid; // [sp+40Ch] [bp+40Ch]

  chainid = runtime->chain_id;
  runtime->chain_status[chainid].design_asic_num = app_conf->asic_num;
  reg_list_init();
  work_list_init(runtime->nonce_verify_info.work_len);
  runtime->chain_status[chainid].fd = uart_init(runtime->chain_status[chainid].comport, 115200);
  sleep(1u);
  if ( runtime->baudrate != 115200 )
  {
    bt8d = baud2bt8d(runtime->baudrate);
    if ( bt8d <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        strcpy((char *)tmp42, "Don't support current baudrate, set to 115200\n");
        applog(2, tmp42, 0);
      }
    }
    else
    {
      runtime->set_baud(runtime->chain_status[chainid].fd, runtime->baudrate);
      usleep(0x30D40u);
      set_fpga_baud(bt8d);
      sleep(1u);
    }
  }
  pthread_create(&runtime->chain_status[chainid].p_dispatch, 0, (void *(*)(void *))handle_asic_response, runtime);
  sleep(1u);
  pthread_create(&runtime->p_scanhash, 0, (void *(*)(void *))check_nonce_loop, runtime);
  runtime->start_recv = 1;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s Done!\n", (const char *)_func___8761);
    applog(2, tmp42, 0);
  }
}

//----- (00021798) --------------------------------------------------------
void __cdecl pcba_runtime_exit(runtime_base_t *runtime)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF

  runtime->start_recv = 0;
  usleep((__useconds_t)&nonce_fifo.nonce_buffer[508].Nonce[1188]);
  pthread_cancel(runtime->p_scanhash);
  pthread_join(runtime->p_scanhash, 0);
  pthread_cancel(runtime->chain_status[runtime->chain_id].p_dispatch);
  pthread_join(runtime->chain_status[runtime->chain_id].p_dispatch, 0);
  uart_exit(runtime->chain_status[runtime->chain_id].fd);
  reg_list_exit();
  work_list_exit();
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s Done!\n", (const char *)_func___8766);
    applog(2, tmp42, 0);
  }
}

//----- (000218A0) --------------------------------------------------------
void start_single_board_test()
{
  pcba_runtime_init(cgpu.runtime);
  if ( !bm1744_hashboard_init() )
  {
    start_read_temp();
    singleboard_pattern_test();
    stop_read_temp();
  }
  pcba_runtime_exit(cgpu.runtime);
}

//----- (000218F0) --------------------------------------------------------
int singleBoardTest_Z15_BM1746()
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+0h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "Start %s[%d]\n", (const char *)_func___8774, 676);
    applog(2, tmp42, 0);
  }
  init_pcba_args();
  pthread_create(&cgpu.show_id, 0, (void *(*)(void *))show_stats_func_z15_3chips, 0);
  init_fpga();
  set_fpga_baud(0x1Au);
  check_chain();
  if ( gChain == 255 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "--- Chain Check Fail\n");
      applog(2, tmp42, 0);
    }
    return -1;
  }
  else
  {
    reset_PIC16F1704_pic(gChain, gI2c);
    jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
    pthread_create(&cgpu.pic_heart_beat_id, 0, (void *(*)(void *))pic_heart_beat_func, &chain_info_0[gChain]);
    write_axi_fpga(0xDu, 0xFFFFu);
    usleep((__useconds_t)&buf_7545[4072]);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 1u);
    usleep((__useconds_t)&buf_7545[4072]);
    write_axi_fpga(0xDu, 0);
    vol_init(app_conf->pcba_voltage);
    usleep((__useconds_t)&buf_7545[4072]);
    start_single_board_test();
    pthread_cancel(cgpu.show_id);
    pthread_join(cgpu.show_id, 0);
    V9_print_lcd_type(hardware_exception);
    write_axi_fpga(0xDu, 0xFFFFu);
    usleep((__useconds_t)&buf_7545[4072]);
    write_axi_fpga(0xDu, 0);
    usleep((__useconds_t)&buf_7545[4072]);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(cgpu.pic_heart_beat_id);
    pthread_join(cgpu.pic_heart_beat_id, 0);
    pthread_mutex_unlock(&i2c_mutex);
    clear_last_test_results();
    fan_control(2u);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "Test finished\n");
      applog(2, tmp42, 0);
    }
    return 1;
  }
}

//----- (00021BC8) --------------------------------------------------------
int __cdecl parse_config_ini_array(const unsigned __int8 *str, void **pointer)
{
  __int64 v2; // d0
  int v3; // r3
  _QWORD *v4; // r4
  int *v5; // r4
  unsigned __int8 item_str[32]; // [sp+8h] [bp+8h] BYREF
  int str_len; // [sp+28h] [bp+28h]
  int i_0; // [sp+2Ch] [bp+2Ch]
  int j; // [sp+30h] [bp+30h]
  int item_str_counter; // [sp+34h] [bp+34h]
  int i; // [sp+38h] [bp+38h]
  void *local_pointer; // [sp+3Ch] [bp+3Ch]
  int item_num; // [sp+40h] [bp+40h]
  int type; // [sp+44h] [bp+44h]
  _BYTE v18[4]; // [sp+48h] [bp+48h] BYREF

  str_len = strlen((const char *)str);
  type = 1;
  item_num = 0;
  local_pointer = 0;
  for ( i = 0; i < str_len; ++i )
  {
    if ( str[i] == 46 )
      type = 0;
    if ( str[i] == 44 )
      ++item_num;
  }
  ++item_num;
  if ( type )
  {
    local_pointer = malloc(4 * item_num);
    memset(local_pointer, 0, 4 * item_num);
  }
  else
  {
    local_pointer = malloc(8 * item_num);
    memset(local_pointer, 0, 8 * item_num);
  }
  item_str_counter = 0;
  memset(item_str, 0, sizeof(item_str));
  j = 0;
  for ( i_0 = 0; i_0 < str_len; ++i_0 )
  {
    if ( str[i_0] > 0x2Fu && str[i_0] <= 0x39u || str[i_0] == 46 )
    {
      v3 = item_str_counter++;
      v18[v3 - 64] = str[i_0];
    }
    if ( str[i_0] == 44 || str[i_0] == 93 )
    {
      item_str[item_str_counter] = 0;
      if ( type )
      {
        v5 = (int *)((char *)local_pointer + 4 * j);
        *v5 = atoi((const char *)item_str);
      }
      else
      {
        v4 = (char *)local_pointer + 8 * j;
        atof((const char *)item_str);
        *v4 = v2;
      }
      ++j;
      memset(item_str, 32, sizeof(item_str));
      item_str_counter = 0;
    }
  }
  *pointer = local_pointer;
  return item_num;
}
// 21CFC: variable 'v2' is possibly undefined

//----- (00021D50) --------------------------------------------------------
int __cdecl app_config_handle(app_config_t *m_conf, unsigned __int8 *config_filename)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 str[1024]; // [sp+408h] [bp+408h] BYREF
  int num; // [sp+808h] [bp+808h]
  int num_2; // [sp+80Ch] [bp+80Ch]
  int num_1; // [sp+810h] [bp+810h]
  int num_0; // [sp+814h] [bp+814h]
  FILE *fd; // [sp+818h] [bp+818h]
  unsigned __int8 *temp; // [sp+81Ch] [bp+81Ch]

  memset(str, 0, sizeof(str));
  temp = 0;
  fd = fopen((const char *)config_filename, "r");
  if ( !fd && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    snprintf((char *)tmp42, 0x400u, "open %s failed\n", (const char *)config_filename);
    applog(2, tmp42, 0);
  }
  while ( 1 )
  {
    do
    {
      if ( !fgets((char *)str, 1023, fd) )
      {
        fclose(fd);
        return 0;
      }
    }
    while ( str[0] == 35 || str[1] == 35 || !str[0] );
    temp = (unsigned __int8 *)strstr((const char *)str, "Name=");
    if ( temp )
    {
      temp += 5;
      _isoc99_sscanf(temp, "%s", m_conf->name);
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "AsicNum=");
    if ( temp )
    {
      temp += 8;
      _isoc99_sscanf(temp, "%d", &m_conf->asic_num);
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "CoreNum=");
    if ( temp )
    {
      temp += 8;
      _isoc99_sscanf(temp, "%d", &m_conf->core_num);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "WorkMode=");
    if ( temp )
    {
      temp += 9;
      _isoc99_sscanf(temp, "%d", &m_conf->work_mode);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "Comport=");
    if ( temp )
    {
      temp += 8;
      m_conf->comport_num = parse_config_ini_array(temp, (void **)&m_conf->comport);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SensorPos=");
    if ( temp )
    {
      temp += 10;
      m_conf->sensor_num = parse_config_ini_array(temp, (void **)&m_conf->sensor_pos);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "EnableCp210x=");
    if ( temp )
    {
      temp += 13;
      _isoc99_sscanf(temp, "%d", &m_conf->enable_cp210x);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "Baudrate=");
    if ( temp )
    {
      temp += 9;
      _isoc99_sscanf(temp, "%d", &m_conf->baudrate);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "TicketMask=");
    if ( temp )
    {
      temp += 11;
      _isoc99_sscanf(temp, "%d", &m_conf->ticket_mask);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "CoreTimeout=");
    if ( temp )
    {
      temp += 12;
      _isoc99_sscanf(temp, "%u", &m_conf->core_timeout);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "ChipAlarmTemp=");
    if ( temp )
    {
      temp += 14;
      _isoc99_sscanf(temp, "%d", &m_conf->chip_alarm_temp);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "BringupFreq=");
    if ( temp )
    {
      temp += 12;
      _isoc99_sscanf(temp, "%d", &m_conf->bringup_freq);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "BringupVoltage=");
    if ( temp )
    {
      temp += 15;
      _isoc99_sscanf(temp, "%d", &m_conf->bringup_voltage);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "BringupWorkIntervalS=");
    if ( temp )
    {
      temp += 21;
      _isoc99_sscanf(temp, "%d", &m_conf->bringup_work_interval_s);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "BringupAutoJHVolt=");
    if ( temp )
    {
      temp += 18;
      num = parse_config_ini_array(temp, (void **)&m_conf->bringup_autojh_volt);
      if ( num != 3 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "BringupAutoJHVolt number error %d\n", num);
          applog(2, tmp42, 0);
        }
        return -1;
      }
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "BringupAutoJHFreq=");
    if ( temp )
    {
      temp += 18;
      num_0 = parse_config_ini_array(temp, (void **)&m_conf->bringup_autojh_freq);
      if ( num_0 != 3 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "BringupAutoJHFreq number error %d\n", num_0);
          applog(2, tmp42, 0);
        }
        return -1;
      }
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PattenNum=");
    if ( temp )
    {
      temp += 10;
      _isoc99_sscanf(temp, "%d", &m_conf->pattern_num);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltTestMode=");
    if ( temp )
    {
      temp += 12;
      _isoc99_sscanf(temp, "%d", &m_conf->slt_test_mode);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltTunelPath=");
    if ( temp )
    {
      temp += 13;
      _isoc99_sscanf(temp, "%s", m_conf->slt_tunel_path);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltCP210xRuntime=");
    if ( temp )
    {
      temp += 17;
      _isoc99_sscanf(temp, "%s", m_conf->slt_cp210x_runtime);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltBinRate=");
    if ( temp )
    {
      temp += 11;
      num_1 = parse_config_ini_array(temp, (void **)&m_conf->slt_bin_rate);
      if ( num_1 != 3 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "SltBinRate number error %d\n", num_1);
          applog(2, tmp42, 0);
        }
        return -1;
      }
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltDelay=");
    if ( temp )
    {
      temp += 9;
      _isoc99_sscanf(temp, "%d", &m_conf->slt_delay);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltFreq=");
    if ( temp )
    {
      temp += 8;
      _isoc99_sscanf(temp, "%d", &m_conf->slt_freq);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltWorkIntervalMs=");
    if ( temp )
    {
      temp += 18;
      _isoc99_sscanf(temp, "%d", &m_conf->slt_work_interval_ms);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "SltEnableReadTemp=");
    if ( temp )
    {
      temp += 18;
      _isoc99_sscanf(temp, "%d", &m_conf->slt_enable_read_temp);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaRepeatCtrl=");
    if ( temp )
    {
      temp += 15;
      _isoc99_sscanf(temp, "%s", m_conf->pcba_repeat_ctrl);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaFreq=");
    if ( temp )
    {
      temp += 9;
      _isoc99_sscanf(temp, "%d", &m_conf->pcba_freq);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaVoltage=");
    if ( temp )
    {
      temp += 12;
      _isoc99_sscanf(temp, "%d", &m_conf->pcba_voltage);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaTemptureHigh=");
    if ( temp )
    {
      temp += 17;
      _isoc99_sscanf(temp, "%d", &m_conf->pcba_tempture_high);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaTemptureLow=");
    if ( temp )
    {
      temp += 16;
      _isoc99_sscanf(temp, "%d", &m_conf->pcba_tempture_low);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaOnlyFindASIC=");
    if ( temp )
    {
      temp += 17;
      _isoc99_sscanf(temp, "%d", &m_conf->pcba_only_find_asic);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaPatternPassRate=");
    if ( temp )
    {
      temp += 20;
      _isoc99_sscanf(temp, "%d", &m_conf->pcba_pattern_pass_rate);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaSendPtTimeout=");
    if ( temp )
    {
      temp += 18;
      _isoc99_sscanf(temp, "%d", &m_conf->send_pattern_timeout);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaEnableLevel=");
    if ( temp )
    {
      temp += 16;
      _isoc99_sscanf(temp, "%d", &m_conf->pcba_enable_level);
      goto LABEL_99;
    }
    temp = (unsigned __int8 *)strstr((const char *)str, "PcbaLevelRate=");
    if ( temp )
    {
      temp += 14;
      num_2 = parse_config_ini_array(temp, (void **)&m_conf->pcba_level_rate);
      if ( num_2 != 3 )
        break;
    }
LABEL_99:
    memset(str, 0, sizeof(str));
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "PcbaLevelRate number should be 3, but not %d\n", num_2);
    applog(2, tmp42, 0);
  }
  return -1;
}
// 1115C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (000228D0) --------------------------------------------------------
app_config_t *__cdecl app_config_init(unsigned __int8 *config_filename)
{
  FILE *v2; // r0
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 dbg_fname[32]; // [sp+40Ch] [bp+40Ch] BYREF
  app_config_t *app_conf; // [sp+42Ch] [bp+42Ch]

  app_conf = (app_config_t *)calloc(0x128u, 1u);
  if ( app_config_handle(app_conf, config_filename) < 0 )
    return 0;
  memset(dbg_fname, 0, sizeof(dbg_fname));
  sprintf((char *)dbg_fname, "%s.log", (const char *)app_conf->name);
  v2 = fopen((const char *)dbg_fname, "w+");
  app_conf->dbg_fp = v2;
  if ( app_conf->dbg_fp )
    return app_conf;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "open %s file error\n", (const char *)dbg_fname);
    applog(2, tmp42, 0);
  }
  return 0;
}

//----- (000229B0) --------------------------------------------------------
void __cdecl app_config_exit(app_config_t *conf)
{
  fclose(conf->dbg_fp);
  free(conf->comport);
  free(conf->sensor_pos);
  free(conf->bringup_autojh_freq);
  free(conf->bringup_autojh_volt);
  free(conf->slt_bin_rate);
  free(conf->pcba_level_rate);
  free(conf);
}

//----- (00022A10) --------------------------------------------------------
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force)
{
  if ( !opt_quiet || !prio )
  {
    if ( force )
    {
      pthread_mutex_trylock(&console_lock);
      pthread_mutex_unlock(&console_lock);
    }
    pthread_mutex_lock(&console_lock);
    if ( prio )
    {
      if ( prio == 1 )
        fprintf((FILE *)_bss_start, "\x1B[1;34m%s%s\x1B[0m", (const char *)datetime, (const char *)str);
      else
        fprintf((FILE *)_bss_start, "%s%s", (const char *)datetime, (const char *)str);
    }
    else
    {
      fprintf((FILE *)_bss_start, "\x1B[0;31m%s%s\x1B[0m", (const char *)datetime, (const char *)str);
    }
    fflush((FILE *)_bss_start);
    pthread_mutex_unlock(&console_lock);
  }
}
// 483E0: using guessed type int _bss_start;

//----- (00022AE0) --------------------------------------------------------
void __cdecl applog(int prio, const unsigned __int8 *str, bool force)
{
  int v3; // r0
  unsigned __int8 datetime[64]; // [sp+2Ch] [bp+14h] BYREF
  time_t tmp_time; // [sp+6Ch] [bp+54h] BYREF
  timeval tv; // [sp+70h] [bp+58h] BYREF
  tm *tm; // [sp+78h] [bp+60h]
  int ms; // [sp+7Ch] [bp+64h]

  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  tmp_time = tv.tv_sec;
  ms = tv.tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf(
    (char *)datetime,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
    tm->tm_year + 1900,
    tm->tm_mon + 1,
    tm->tm_mday,
    tm->tm_hour,
    tm->tm_min,
    tm->tm_sec,
    ms);
  if ( app_conf->dbg_fp )
  {
    v3 = fileno(app_conf->dbg_fp);
    if ( !isatty(v3) )
    {
      fprintf(app_conf->dbg_fp, "%s%s", (const char *)datetime, (const char *)str);
      fflush(app_conf->dbg_fp);
    }
  }
  if ( app_conf->work_mode != 1 )
    my_log_curses(prio, datetime, str, force);
}

//----- (00022BF0) --------------------------------------------------------
void __cdecl simplelog(int prio, const unsigned __int8 *str, bool force)
{
  int v3; // r0

  v3 = fileno((FILE *)_bss_start);
  if ( !isatty(v3) )
  {
    fprintf((FILE *)_bss_start, "%s\n", (const char *)str);
    fflush((FILE *)_bss_start);
  }
  my_log_curses(prio, byte_36C3C, str, force);
}
// 36C3C: using guessed type unsigned __int8 byte_36C3C[4];
// 483E0: using guessed type int _bss_start;

//----- (00022C60) --------------------------------------------------------
void patten_info_init()
{
  memset(&g_patten, 0, sizeof(g_patten));
  g_patten.asic_num = app_conf->asic_num;
  g_patten.core_num = app_conf->core_num;
  g_patten.patten_num = app_conf->pattern_num;
  strcpy((char *)g_patten.dir_root, "pattern");
  strcpy((char *)g_patten.dir_algo, "zec-z15");
  strcpy((char *)g_patten.dir_asic, "asic");
  strcpy((char *)g_patten.file_core, "core");
  g_patten.work_bin_len = 140;
  g_patten.nonce_bin_len = 4;
  g_patten.sol_bin_len = 1344;
  g_patten.total_pattens = g_patten.patten_num * g_patten.core_num * g_patten.asic_num;
  g_patten.patten_start = (unsigned __int8 *)malloc(1488 * g_patten.patten_num * g_patten.core_num * g_patten.asic_num);
  if ( !g_patten.patten_start )
  {
    printf("%s[%d] malloc failed\n", (const char *)_func___6575, 29);
    exit(1);
  }
  memset(g_patten.patten_start, 0, 1488 * g_patten.patten_num * g_patten.core_num * g_patten.asic_num);
  g_patten.is_nonce_match = (unsigned __int8 *)malloc(g_patten.patten_num * g_patten.core_num * g_patten.asic_num);
  if ( !g_patten.is_nonce_match )
  {
    printf("%s[%d] malloc failed\n", (const char *)_func___6575, 35);
    exit(1);
  }
  memset(g_patten.is_nonce_match, 0, g_patten.patten_num * g_patten.core_num * g_patten.asic_num);
  g_patten.asic_recv_nonces = (int *)malloc(4 * g_patten.asic_num);
  if ( !g_patten.asic_recv_nonces )
  {
    printf("%s[%d] malloc failed\n", (const char *)_func___6575, 41);
    exit(1);
  }
  memset(g_patten.asic_recv_nonces, 0, 4 * g_patten.asic_num);
  pthread_mutex_init(&g_patten.patten_mutex, 0);
}

//----- (00022F50) --------------------------------------------------------
void patten_info_destory()
{
  if ( g_patten.patten_start )
    free(g_patten.patten_start);
  if ( g_patten.is_nonce_match )
    free(g_patten.is_nonce_match);
  if ( g_patten.asic_recv_nonces )
    free(g_patten.asic_recv_nonces);
  pthread_mutex_destroy(&g_patten.patten_mutex);
}

//----- (00022FBC) --------------------------------------------------------
void __cdecl patten_load(unsigned __int8 *root_path)
{
  unsigned __int8 fname[128]; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 buff[4096]; // [sp+A4h] [bp+8Ch] BYREF
  unsigned __int8 *tmp; // [sp+10A4h] [bp+108Ch]
  uint8_t *cur_patten; // [sp+10A8h] [bp+1090h]
  FILE *fp_patten; // [sp+10ACh] [bp+1094h]
  int one_patten_bin_len; // [sp+10B0h] [bp+1098h]
  int which_patten; // [sp+10B4h] [bp+109Ch]
  int which_core; // [sp+10B8h] [bp+10A0h]
  int which_asic; // [sp+10BCh] [bp+10A4h]

  one_patten_bin_len = g_patten.sol_bin_len + g_patten.work_bin_len + g_patten.nonce_bin_len;
  for ( which_asic = 0; g_patten.asic_num > which_asic; ++which_asic )
  {
    for ( which_core = 0; g_patten.core_num > which_core; ++which_core )
    {
      memset(fname, 0, sizeof(fname));
      sprintf(
        (char *)fname,
        "%s/%s/%s/%s-0x%02x/%s-0x%02x.txt",
        (const char *)root_path,
        (const char *)g_patten.dir_root,
        (const char *)g_patten.dir_algo,
        (const char *)g_patten.dir_asic,
        which_asic,
        (const char *)g_patten.file_core,
        which_core);
      printf("fname %s\n", (const char *)fname);
      fp_patten = fopen((const char *)fname, "r");
      if ( !fp_patten )
      {
        printf("open %s failed\n", (const char *)fname);
        exit(1);
      }
      for ( which_patten = 0; g_patten.patten_num > which_patten; ++which_patten )
      {
        cur_patten = &g_patten.patten_start[one_patten_bin_len * which_core * g_patten.patten_num
                                          + one_patten_bin_len * g_patten.patten_num * which_asic * g_patten.core_num
                                          + one_patten_bin_len * which_patten];
        memset(buff, 0, sizeof(buff));
        fgets((char *)buff, 4096, fp_patten);
        tmp = (unsigned __int8 *)strstr((const char *)buff, "work");
        hex2bin(cur_patten, tmp + 5, g_patten.work_bin_len);
        tmp = (unsigned __int8 *)strstr((const char *)buff, "nonce");
        hex2bin(&cur_patten[g_patten.work_bin_len], tmp + 6, g_patten.nonce_bin_len);
        tmp = (unsigned __int8 *)strstr((const char *)buff, "sol");
        hex2bin(&cur_patten[g_patten.nonce_bin_len + g_patten.work_bin_len], tmp + 4, g_patten.sol_bin_len);
      }
      fclose(fp_patten);
    }
  }
  puts("Load Patten Done");
}

//----- (0002332C) --------------------------------------------------------
int __cdecl is_patten_match(int asic_index, uint8_t *nonce, uint8_t *sol)
{
  int sol_ret; // [sp+14h] [bp+14h]
  int nonce_ret; // [sp+18h] [bp+18h]
  int ret; // [sp+1Ch] [bp+1Ch]

  if ( g_patten.cur_asic == asic_index )
  {
    pthread_mutex_lock(&g_patten.patten_mutex);
    nonce_ret = memcmp(&g_patten.cur_work[g_patten.work_bin_len], nonce, g_patten.nonce_bin_len);
    sol_ret = memcmp(&g_patten.cur_work[g_patten.nonce_bin_len + g_patten.work_bin_len], sol, g_patten.sol_bin_len);
    if ( nonce_ret || sol_ret )
    {
      dump_str((void *)_bss_start, "Not Match Recv:", nonce, g_patten.nonce_bin_len);
      dump_str(
        (void *)_bss_start,
        "Not Match Expect:",
        &g_patten.cur_work[g_patten.work_bin_len],
        g_patten.nonce_bin_len);
      ret = -1;
    }
    else
    {
      g_patten.is_nonce_match[g_patten.cur_patten
                            + g_patten.patten_num * (g_patten.core_num * g_patten.cur_asic + g_patten.cur_core)] = 1;
      g_patten.total_rate = (float)++g_patten.recv_nonces / (float)g_patten.total_pattens;
      ++g_patten.asic_recv_nonces[g_patten.cur_asic];
      ret = 0;
    }
    pthread_mutex_unlock(&g_patten.patten_mutex);
    return ret;
  }
  else
  {
    printf("asic is not match %d vs %d\n", asic_index, g_patten.cur_asic);
    return -1;
  }
}
// 483E0: using guessed type int _bss_start;

//----- (00023510) --------------------------------------------------------
void display_single_board_test()
{
  puts("******************Display Results*******************");
}

//----- (00023524) --------------------------------------------------------
void clear_last_test_results()
{
  memset(g_patten.is_nonce_match, 0, g_patten.patten_num * g_patten.core_num * g_patten.asic_num);
  memset(g_patten.asic_recv_nonces, 0, 4 * g_patten.asic_num);
  g_patten.recv_nonces = 0;
  g_patten.total_rate = 0.0;
}

//----- (0002359C) --------------------------------------------------------
uint16_t __cdecl rt_ringbuffer_get_size(rt_ringbuffer *rb)
{
  return rb->buffer_size;
}

//----- (000235B4) --------------------------------------------------------
RINGBUFFER_STATE __cdecl rt_ringbuffer_status(rt_ringbuffer *rb)
{
  if ( *((_WORD *)rb + 2) >> 1 == *((_WORD *)rb + 3) >> 1 )
    return (*((_BYTE *)rb + 4) & 1) != (*((_BYTE *)rb + 6) & 1);
  else
    return 2;
}

//----- (00023604) --------------------------------------------------------
uint16_t __cdecl rt_ringbuffer_data_len(rt_ringbuffer *rb)
{
  RINGBUFFER_STATE v1; // r0

  v1 = rt_ringbuffer_status(rb);
  if ( v1 == RT_RINGBUFFER_EMPTY )
    return 0;
  if ( v1 == RT_RINGBUFFER_FULL )
    return rb->buffer_size;
  if ( *((_WORD *)rb + 3) >> 1 <= *((_WORD *)rb + 2) >> 1 )
    return (*((_WORD *)rb + 3) >> 1) - (*((_WORD *)rb + 2) >> 1) + rb->buffer_size;
  return (*((_WORD *)rb + 3) >> 1) - (*((_WORD *)rb + 2) >> 1);
}

//----- (00023688) --------------------------------------------------------
void __cdecl rt_ringbuffer_init(rt_ringbuffer *rb, uint8_t *pool, int16_t size, ringbuffer_type_t ringbuffer_type)
{
  *((_WORD *)rb + 2) &= 1u;
  *((_BYTE *)rb + 4) = *((_BYTE *)rb + 4) & 0xFE | ((*((_WORD *)rb + 2) & 2) != 0);
  *((_WORD *)rb + 3) &= 1u;
  *((_BYTE *)rb + 6) = *((_BYTE *)rb + 6) & 0xFE | ((*((_WORD *)rb + 3) & 2) != 0);
  rb->buffer_ptr = pool;
  rb->buffer_size = size & 0xFFFC;
  rb->ringbuffer_type = ringbuffer_type;
  pthread_mutex_init(&rb->ringbuf_lock, 0);
  if ( rb->ringbuffer_type == BLOCK_TYPE )
  {
    pthread_cond_init(&rb->notfull, 0);
    pthread_cond_init(&rb->notempty, 0);
  }
}

//----- (00023734) --------------------------------------------------------
void __cdecl rt_ringbuffer_lock_destory(rt_ringbuffer *rb)
{
  pthread_mutex_destroy(&rb->ringbuf_lock);
  if ( rb->ringbuffer_type == BLOCK_TYPE )
  {
    pthread_cond_destroy(&rb->notfull);
    pthread_cond_destroy(&rb->notempty);
  }
}

//----- (0002376C) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_put(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length)
{
  unsigned __int16 buffer_size; // r4
  unsigned __int16 v5; // r4
  uint16_t size; // [sp+16h] [bp+16h]

  pthread_mutex_lock(&rb->ringbuf_lock);
  buffer_size = rb->buffer_size;
  size = buffer_size - rt_ringbuffer_data_len(rb);
  if ( rb->ringbuffer_type == POLL_TYPE )
  {
    if ( !size )
    {
      pthread_mutex_unlock(&rb->ringbuf_lock);
      return 0;
    }
    if ( size < (unsigned int)length )
      length = size;
  }
  else if ( rb->ringbuffer_type == BLOCK_TYPE )
  {
    while ( size < (unsigned int)length )
    {
      pthread_cond_wait(&rb->notfull, &rb->ringbuf_lock);
      v5 = rb->buffer_size;
      size = v5 - rt_ringbuffer_data_len(rb);
    }
  }
  if ( rb->buffer_size - (*((_WORD *)rb + 3) >> 1) <= length )
  {
    memcpy(&rb->buffer_ptr[*((_WORD *)rb + 3) >> 1], ptr, rb->buffer_size - (*((_WORD *)rb + 3) >> 1));
    memcpy(
      rb->buffer_ptr,
      &ptr[rb->buffer_size - (*((_WORD *)rb + 3) >> 1)],
      length - (rb->buffer_size - (*((_WORD *)rb + 3) >> 1)));
    *((_BYTE *)rb + 6) = *((_BYTE *)rb + 6) & 0xFE | ((*((_BYTE *)rb + 6) & 1) == 0);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2 * ((length + (*((_WORD *)rb + 3) >> 1) - rb->buffer_size) & 0x7FFF));
  }
  else
  {
    memcpy(&rb->buffer_ptr[*((_WORD *)rb + 3) >> 1], ptr, length);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2 * ((length + (*((_WORD *)rb + 3) >> 1)) & 0x7FFF));
  }
  pthread_cond_signal(&rb->notempty);
  pthread_mutex_unlock(&rb->ringbuf_lock);
  return length;
}

//----- (0002392C) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_put_force(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length)
{
  unsigned __int16 buffer_size; // r4
  uint16_t space_length; // [sp+16h] [bp+16h]

  pthread_mutex_lock(&rb->ringbuf_lock);
  buffer_size = rb->buffer_size;
  space_length = buffer_size - rt_ringbuffer_data_len(rb);
  if ( length > (unsigned int)space_length )
    length = rb->buffer_size;
  if ( rb->buffer_size - (*((_WORD *)rb + 3) >> 1) <= length )
  {
    memcpy(&rb->buffer_ptr[*((_WORD *)rb + 3) >> 1], ptr, rb->buffer_size - (*((_WORD *)rb + 3) >> 1));
    memcpy(
      rb->buffer_ptr,
      &ptr[rb->buffer_size - (*((_WORD *)rb + 3) >> 1)],
      length - (rb->buffer_size - (*((_WORD *)rb + 3) >> 1)));
    *((_BYTE *)rb + 6) = *((_BYTE *)rb + 6) & 0xFE | ((*((_BYTE *)rb + 6) & 1) == 0);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2 * ((length + (*((_WORD *)rb + 3) >> 1) - rb->buffer_size) & 0x7FFF));
    if ( length > (unsigned int)space_length )
    {
      *((_BYTE *)rb + 4) = *((_BYTE *)rb + 4) & 0xFE | ((*((_BYTE *)rb + 4) & 1) == 0);
      *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2 * ((*((_WORD *)rb + 3) >> 1) & 0x7FFF));
    }
  }
  else
  {
    memcpy(&rb->buffer_ptr[*((_WORD *)rb + 3) >> 1], ptr, length);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2 * ((length + (*((_WORD *)rb + 3) >> 1)) & 0x7FFF));
    if ( length > (unsigned int)space_length )
      *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2 * ((*((_WORD *)rb + 3) >> 1) & 0x7FFF));
  }
  pthread_cond_signal(&rb->notempty);
  pthread_mutex_unlock(&rb->ringbuf_lock);
  return length;
}

//----- (00023AEC) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_get(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length)
{
  uint32_t size; // [sp+14h] [bp+14h]

  pthread_mutex_lock(&rb->ringbuf_lock);
  size = rt_ringbuffer_data_len(rb);
  if ( rb->ringbuffer_type == POLL_TYPE )
  {
    if ( !size )
    {
      pthread_mutex_unlock(&rb->ringbuf_lock);
      return 0;
    }
    if ( length > size )
      length = size;
  }
  else if ( rb->ringbuffer_type == BLOCK_TYPE )
  {
    while ( length > size )
    {
      pthread_cond_wait(&rb->notempty, &rb->ringbuf_lock);
      size = rt_ringbuffer_data_len(rb);
    }
  }
  if ( rb->buffer_size - (*((_WORD *)rb + 2) >> 1) <= length )
  {
    memcpy(ptr, &rb->buffer_ptr[*((_WORD *)rb + 2) >> 1], rb->buffer_size - (*((_WORD *)rb + 2) >> 1));
    memcpy(
      &ptr[rb->buffer_size - (*((_WORD *)rb + 2) >> 1)],
      rb->buffer_ptr,
      length - (rb->buffer_size - (*((_WORD *)rb + 2) >> 1)));
    *((_BYTE *)rb + 4) = *((_BYTE *)rb + 4) & 0xFE | ((*((_BYTE *)rb + 4) & 1) == 0);
    *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2 * ((length + (*((_WORD *)rb + 2) >> 1) - rb->buffer_size) & 0x7FFF));
    pthread_cond_signal(&rb->notfull);
    pthread_mutex_unlock(&rb->ringbuf_lock);
  }
  else
  {
    memcpy(ptr, &rb->buffer_ptr[*((_WORD *)rb + 2) >> 1], length);
    *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2 * ((length + (*((_WORD *)rb + 2) >> 1)) & 0x7FFF));
    pthread_mutex_unlock(&rb->ringbuf_lock);
    pthread_cond_signal(&rb->notfull);
  }
  return length;
}

//----- (00023CA0) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_prefetch(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length)
{
  uint32_t size; // [sp+14h] [bp+14h]

  size = rt_ringbuffer_data_len(rb);
  if ( !size )
    return 0;
  if ( length > size )
    length = size;
  if ( rb->buffer_size - (*((_WORD *)rb + 2) >> 1) <= length )
  {
    memcpy(ptr, &rb->buffer_ptr[*((_WORD *)rb + 2) >> 1], rb->buffer_size - (*((_WORD *)rb + 2) >> 1));
    memcpy(
      &ptr[rb->buffer_size - (*((_WORD *)rb + 2) >> 1)],
      rb->buffer_ptr,
      length - (rb->buffer_size - (*((_WORD *)rb + 2) >> 1)));
  }
  else
  {
    memcpy(ptr, &rb->buffer_ptr[*((_WORD *)rb + 2) >> 1], length);
  }
  return length;
}

//----- (00023D70) --------------------------------------------------------
void __cdecl get_current_time(unsigned __int8 *dtime)
{
  time_t tmp_time; // [sp+24h] [bp+Ch] BYREF
  timeval tv; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 datetime[64]; // [sp+30h] [bp+18h] BYREF
  tm *tm; // [sp+70h] [bp+58h]
  int ms; // [sp+74h] [bp+5Ch]

  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  tmp_time = tv.tv_sec;
  ms = tv.tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf(
    (char *)datetime,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
    tm->tm_year + 1900,
    tm->tm_mon + 1,
    tm->tm_mday,
    tm->tm_hour,
    tm->tm_min,
    tm->tm_sec,
    ms);
  strcpy((char *)dtime, (const char *)datetime);
}

//----- (00023E08) --------------------------------------------------------
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *v3; // r2
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i < (int)len; ++i )
  {
    *s = hex_6251[p[i] >> 4];
    v3 = s + 1;
    s += 2;
    *v3 = hex_6251[p[i] & 0xF];
  }
  *s = 0;
}

//----- (00023E7C) --------------------------------------------------------
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *s; // [sp+8h] [bp+8h]
  unsigned int slen; // [sp+Ch] [bp+Ch]

  slen = 2 * len + 1;
  if ( (slen & 3) != 0 )
    slen = (slen & 0xFFFFFFFC) + 4;
  s = (unsigned __int8 *)calloc(slen, 1u);
  if ( !s )
    fwrite("Failed to calloc", 1u, 0x10u, (FILE *)_bss_start);
  _bin2hex(s, p, len);
  return s;
}
// 483E0: using guessed type int _bss_start;

//----- (00023EE4) --------------------------------------------------------
int __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len)
{
  const unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r3
  int nibble2; // [sp+10h] [bp+10h]
  int nibble1; // [sp+14h] [bp+14h]
  int ret; // [sp+1Ch] [bp+1Ch]

  ret = 0;
  while ( *hexstr && len )
  {
    if ( !hexstr[1] )
      return 0;
    nibble1 = hex2bin_tbl[*hexstr];
    v4 = hexstr + 1;
    hexstr += 2;
    nibble2 = hex2bin_tbl[*v4];
    if ( nibble1 < 0 || nibble2 < 0 )
      return 0;
    v5 = p++;
    *v5 = nibble2 | (16 * nibble1);
    --len;
  }
  if ( !len && !*hexstr )
    return 1;
  return ret;
}

//----- (00023F98) --------------------------------------------------------
unsigned __int8 __cdecl swap_bit(unsigned __int8 chr)
{
  int i; // [sp+8h] [bp+8h]
  unsigned __int8 ret; // [sp+Fh] [bp+Fh]

  ret = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( (((int)chr >> i) & 1) != 0 )
      ret |= 1 << (7 - i);
  }
  return ret;
}

//----- (00023FF0) --------------------------------------------------------
void __cdecl dump_str(void *fdp, const unsigned __int8 *func, unsigned __int8 *str, int len)
{
  unsigned __int8 *hexbuff; // [sp+18h] [bp+10h]

  if ( fdp )
  {
    hexbuff = bin2hex(str, len);
    if ( func )
      fprintf((FILE *)fdp, "%s %s len=%d\n", (const char *)func, (const char *)hexbuff, len);
    else
      fprintf((FILE *)fdp, "%s\n", (const char *)hexbuff);
    fflush((FILE *)fdp);
    free(hexbuff);
  }
}

//----- (00024058) --------------------------------------------------------
unsigned __int8 __cdecl bit_read(unsigned __int8 *y, int x)
{
  int v2; // r3
  unsigned __int8 v3; // r3

  v2 = x & 7;
  if ( x <= 0 )
    v2 = -(-x & 7);
  switch ( v2 )
  {
    case 0:
      v3 = (y[x / 8] & 1) != 0;
      break;
    case 1:
      v3 = (y[x / 8] & 2) != 0;
      break;
    case 2:
      v3 = (y[x / 8] & 4) != 0;
      break;
    case 3:
      v3 = (y[x / 8] & 8) != 0;
      break;
    case 4:
      v3 = (y[x / 8] & 0x10) != 0;
      break;
    case 5:
      v3 = (y[x / 8] & 0x20) != 0;
      break;
    case 6:
      v3 = (y[x / 8] & 0x40) != 0;
      break;
    case 7:
      v3 = y[x / 8] >> 7;
      break;
    default:
      v3 = 0;
      break;
  }
  return v3;
}

//----- (000241D8) --------------------------------------------------------
void __cdecl swab256(void *dest_p, void *src_p)
{
  *(_DWORD *)dest_p = bswap32(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = bswap32(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = bswap32(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = bswap32(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = bswap32(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = bswap32(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = bswap32(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = bswap32(*(_DWORD *)src_p);
}

//----- (00024268) --------------------------------------------------------
uint64_t __cdecl load64(const void *src)
{
  unsigned __int64 w; // [sp+28h] [bp+28h]

  w = *(unsigned __int8 *)src | (*((unsigned __int8 *)src + 1) << 8) | (*((unsigned __int8 *)src + 2) << 16) | (unsigned __int64)(*((unsigned __int8 *)src + 3) << 24);
  HIDWORD(w) = (*((unsigned __int8 *)src + 7) << 24) | (*((unsigned __int8 *)src + 6) << 16) | (*((unsigned __int8 *)src
                                                                                                + 5) << 8) | *((unsigned __int8 *)src + 4);
  return w;
}

//----- (000243CC) --------------------------------------------------------
void __cdecl store32(void *dst, uint32_t w)
{
  *(_DWORD *)dst = w;
}

//----- (00024428) --------------------------------------------------------
void __cdecl store64(void *dst, uint64_t w)
{
  *(_QWORD *)dst = w;
}

//----- (00024550) --------------------------------------------------------
uint64_t __cdecl rotr64(const uint64_t w, const unsigned int c)
{
  return (w << (-(char)c & 0x3F)) | (w >> c);
}

//----- (000245C4) --------------------------------------------------------
void __cdecl secure_zero_memory(void *v, size_t n)
{
  memset_v_5087(v, 0, n);
}

//----- (000245E8) --------------------------------------------------------
int __cdecl blake2b_set_lastnode(blake2b_state *S)
{
  S->f[1] = -1LL;
  return 0;
}

//----- (0002460C) --------------------------------------------------------
int __cdecl blake2b_is_lastblock(const blake2b_state *S)
{
  return S->f[0] != 0;
}

//----- (00024630) --------------------------------------------------------
int __cdecl blake2b_set_lastblock(blake2b_state *S)
{
  if ( S->last_node )
    blake2b_set_lastnode(S);
  LODWORD(S->f[0]) = -1;
  HIDWORD(S->f[0]) = -1;
  return 0;
}

//----- (00024660) --------------------------------------------------------
int __cdecl blake2b_increment_counter(blake2b_state *S, const uint64_t inc)
{
  S->t[0] += inc;
  S->t[1] += S->t[0] < inc;
  return 0;
}

//----- (000246C0) --------------------------------------------------------
int __cdecl blake2b_init0(blake2b_state *S)
{
  int i; // [sp+Ch] [bp+Ch]

  memset(S, 0, sizeof(blake2b_state));
  for ( i = 0; i <= 7; ++i )
    S->h[i] = blake2b_IV[i];
  return 0;
}

//----- (00024710) --------------------------------------------------------
int __cdecl blake2b_init_param(blake2b_state *S, const blake2b_param *P)
{
  size_t i; // [sp+Ch] [bp+Ch]

  blake2b_init0(S);
  for ( i = 0; i <= 7; ++i )
    S->h[i] ^= load64((char *)P + 8 * i);
  return 0;
}

//----- (00024774) --------------------------------------------------------
int __cdecl blake2b_init(blake2b_state *S, const uint8_t outlen)
{
  blake2b_param P[1]; // [sp+8h] [bp+8h] BYREF

  if ( !outlen || outlen > 0x40u )
    return -1;
  P[0].digest_length = outlen;
  P[0].key_length = 0;
  P[0].fanout = 1;
  P[0].depth = 1;
  store32(&P[0].leaf_length, 0);
  store64(&P[0].node_offset, 0LL);
  P[0].node_depth = 0;
  P[0].inner_length = 0;
  memset(P[0].reserved, 0, sizeof(P[0].reserved));
  memset(P[0].salt, 0, sizeof(P[0].salt));
  memset(P[0].personal, 0, sizeof(P[0].personal));
  return blake2b_init_param(S, P);
}

//----- (00024814) --------------------------------------------------------
int __cdecl blake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen)
{
  uint8_t block[128]; // [sp+10h] [bp+10h] BYREF
  blake2b_param P[1]; // [sp+90h] [bp+90h] BYREF

  if ( !outlen || outlen > 0x40u )
    return -1;
  if ( !key || !keylen || keylen > 0x40u )
    return -1;
  P[0].digest_length = outlen;
  P[0].key_length = keylen;
  P[0].fanout = 1;
  P[0].depth = 1;
  store32(&P[0].leaf_length, 0);
  store64(&P[0].node_offset, 0LL);
  P[0].node_depth = 0;
  P[0].inner_length = 0;
  memset(P[0].reserved, 0, sizeof(P[0].reserved));
  memset(P[0].salt, 0, sizeof(P[0].salt));
  memset(P[0].personal, 0, sizeof(P[0].personal));
  if ( blake2b_init_param(S, P) < 0 )
    return -1;
  memset(block, 0, sizeof(block));
  memcpy(block, key, keylen);
  blake2b_update(S, block, 0x80uLL);
  secure_zero_memory(block, 0x80u);
  return 0;
}

//----- (00024928) --------------------------------------------------------
int __cdecl blake2b_compress(blake2b_state *S, const uint8_t *block)
{
  uint64_t v2; // r0
  uint64_t v[16]; // [sp+8h] [bp+8h] BYREF
  uint64_t m[16]; // [sp+88h] [bp+88h]
  int i; // [sp+10Ch] [bp+10Ch]
  int v9; // [sp+110h] [bp+110h] BYREF

  for ( i = 0; i <= 15; ++i )
  {
    v2 = load64(&block[8 * i]);
    *((_QWORD *)&v9 + i - 17) = v2;
  }
  for ( i = 0; i <= 7; ++i )
    v[i] = S->h[i];
  v[8] = 0x6A09E667F3BCC908LL;
  v[9] = loc_255C0;
  v[10] = loc_255C8;
  v[11] = loc_255D0;
  v[12] = S->t[0] ^ __PAIR64__(loc_255DC, loc_255D8);
  v[13] = S->t[1] ^ __PAIR64__(loc_255E4, loc_255E0);
  v[14] = S->f[0] ^ __PAIR64__(loc_255EC, locret_255E8);
  v[15] = S->f[1] ^ __PAIR64__(loc_255F4, loc_255F0);
  v[0] += m[0] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[1] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[2] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[3] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[4] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[5] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[6] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[7] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[8] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[9] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[10] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[11] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[12] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[13] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[14] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[15] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[14] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[10] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[4] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[8] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[9] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[15] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[13] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[6] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[1] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[12] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[0] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[2] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[11] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[7] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[5] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[3] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[11] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[8] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[12] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[0] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[5] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[2] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[15] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[13] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[10] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[14] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[3] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[6] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[7] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[1] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[9] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[4] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[7] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[9] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[3] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[1] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[13] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[12] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[11] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[14] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[2] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[6] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[5] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[10] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[4] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[0] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[15] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[8] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[9] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[0] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[5] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[7] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[2] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[4] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[10] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[15] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[14] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[1] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[11] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[12] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[6] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[8] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[3] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[13] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[2] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[12] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[6] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[10] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[0] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[11] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[8] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[3] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[4] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[13] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[7] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[5] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[15] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[14] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[1] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[9] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[12] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[5] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[1] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[15] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[14] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[13] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[4] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[10] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[0] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[7] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[6] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[3] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[9] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[2] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[8] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[11] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[13] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[11] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[7] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[14] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[12] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[1] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[3] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[9] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[5] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[0] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[15] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[4] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[8] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[6] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[2] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[10] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[6] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[15] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[14] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[9] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[11] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[3] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[0] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[8] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[12] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[2] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[13] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[7] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[1] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[4] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[10] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[5] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[10] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[2] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[8] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[4] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[7] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[6] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[1] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[5] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[15] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[11] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[9] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[14] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[3] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[12] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[13] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[0] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[0] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[1] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[2] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[3] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[4] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[5] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[6] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[7] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[8] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[9] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[10] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[11] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[12] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[13] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[14] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[15] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  v[0] += m[14] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x20u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x18u);
  v[0] += m[10] + v[4];
  v[12] = rotr64(v[0] ^ v[12], 0x10u);
  v[8] += v[12];
  v[4] = rotr64(v[8] ^ v[4], 0x3Fu);
  v[1] += m[4] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x20u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x18u);
  v[1] += m[8] + v[5];
  v[13] = rotr64(v[1] ^ v[13], 0x10u);
  v[9] += v[13];
  v[5] = rotr64(v[9] ^ v[5], 0x3Fu);
  v[2] += m[9] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x20u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x18u);
  v[2] += m[15] + v[6];
  v[14] = rotr64(v[2] ^ v[14], 0x10u);
  v[10] += v[14];
  v[6] = rotr64(v[10] ^ v[6], 0x3Fu);
  v[3] += m[13] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x20u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x18u);
  v[3] += m[6] + v[7];
  v[15] = rotr64(v[3] ^ v[15], 0x10u);
  v[11] += v[15];
  v[7] = rotr64(v[11] ^ v[7], 0x3Fu);
  v[0] += m[1] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x20u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x18u);
  v[0] += m[12] + v[5];
  v[15] = rotr64(v[0] ^ v[15], 0x10u);
  v[10] += v[15];
  v[5] = rotr64(v[10] ^ v[5], 0x3Fu);
  v[1] += m[0] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x20u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x18u);
  v[1] += m[2] + v[6];
  v[12] = rotr64(v[1] ^ v[12], 0x10u);
  v[11] += v[12];
  v[6] = rotr64(v[11] ^ v[6], 0x3Fu);
  v[2] += m[11] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x20u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x18u);
  v[2] += m[7] + v[7];
  v[13] = rotr64(v[2] ^ v[13], 0x10u);
  v[8] += v[13];
  v[7] = rotr64(v[8] ^ v[7], 0x3Fu);
  v[3] += m[5] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x20u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x18u);
  v[3] += m[3] + v[4];
  v[14] = rotr64(v[3] ^ v[14], 0x10u);
  v[9] += v[14];
  v[4] = rotr64(v[9] ^ v[4], 0x3Fu);
  for ( i = 0; i <= 7; ++i )
    S->h[i] ^= v[i + 8] ^ v[i];
  return 0;
}
// 257BA: fixed broken macro-insn

//----- (0002CDB4) --------------------------------------------------------
int __cdecl blake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen)
{
  size_t fill; // [sp+10h] [bp+10h]
  size_t left; // [sp+14h] [bp+14h]

  while ( inlen )
  {
    left = S->buflen;
    fill = 256 - left;
    if ( 256 - left >= inlen )
    {
      memcpy(&S->buf[left], in, inlen);
      S->buflen += inlen;
      in += inlen;
      inlen = 0LL;
    }
    else
    {
      memcpy(&S->buf[left], in, fill);
      S->buflen += fill;
      blake2b_increment_counter(S, 0x80uLL);
      blake2b_compress(S, S->buf);
      memcpy(S->buf, &S->buf[128], 0x80u);
      S->buflen -= 128;
      in += fill;
      inlen -= fill;
    }
  }
  return 0;
}

//----- (0002CEB4) --------------------------------------------------------
int __cdecl blake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen)
{
  uint8_t buffer[64]; // [sp+14h] [bp+14h] BYREF
  int i; // [sp+54h] [bp+54h]

  memset(buffer, 0, sizeof(buffer));
  if ( !out || !outlen || outlen > 0x40u )
    return -1;
  if ( blake2b_is_lastblock(S) )
    return -1;
  if ( S->buflen > 0x80 )
  {
    blake2b_increment_counter(S, 0x80uLL);
    blake2b_compress(S, S->buf);
    S->buflen -= 128;
    memcpy(S->buf, &S->buf[128], S->buflen);
  }
  blake2b_increment_counter(S, S->buflen);
  blake2b_set_lastblock(S);
  memset(&S->buf[S->buflen], 0, 256 - S->buflen);
  blake2b_compress(S, S->buf);
  for ( i = 0; i <= 7; ++i )
    store64(&buffer[8 * i], S->h[i]);
  memcpy(out, buffer, outlen);
  return 0;
}

//----- (0002CFD8) --------------------------------------------------------
int __cdecl blake2b(
        uint8_t *out,
        const void *in,
        const void *key,
        const uint8_t outlen,
        const uint64_t inlen,
        uint8_t keylen)
{
  blake2b_state S[1]; // [sp+10h] [bp+10h] BYREF

  if ( !in && inlen )
    return -1;
  if ( !out )
    return -1;
  if ( !key && keylen )
    return -1;
  if ( !outlen || outlen > 0x40u )
    return -1;
  if ( keylen <= 0x40u )
  {
    if ( keylen )
    {
      if ( blake2b_init_key(S, outlen, key, keylen) < 0 )
        return -1;
    }
    else if ( blake2b_init(S, outlen) < 0 )
    {
      return -1;
    }
    blake2b_update(S, (const uint8_t *)in, inlen);
    blake2b_final(S, out, outlen);
    return 0;
  }
  return -1;
}

//----- (0002D0D8) --------------------------------------------------------
unsigned __int16 __cdecl crc_itu_t_byte(unsigned __int16 crc, const unsigned __int8 data)
{
  return crc_itu_t_table[(unsigned __int8)(data ^ HIBYTE(crc))] ^ (crc << 8);
}

//----- (0002D11C) --------------------------------------------------------
unsigned __int16 __cdecl CRC16_v1(const unsigned __int8 *buffer, int len)
{
  const unsigned __int8 *v2; // r3
  __int16 crc; // [sp+Eh] [bp+Eh]

  for ( crc = -1; len--; crc = crc_itu_t_byte(crc, *v2) )
    v2 = buffer++;
  return crc;
}

//----- (0002D158) --------------------------------------------------------
unsigned __int8 __cdecl CRC5_v1(unsigned __int8 *ptr, unsigned __int8 len)
{
  unsigned __int8 crcout[5]; // [sp+Ch] [bp+Ch]
  int crcin; // [sp+14h] [bp+14h]
  char crcin_4; // [sp+18h] [bp+18h]
  bool din; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 crc; // [sp+1Ch] [bp+1Ch]
  unsigned __int8 k; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 j; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  crcin = 16843009;
  crcin_4 = 1;
  j = 0x80;
  k = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    din = (j & *ptr) != 0;
    crcout[0] = din ^ crcin_4;
    crcout[1] = crcin;
    crcout[2] = din ^ crcin_4 ^ BYTE1(crcin);
    *(_WORD *)&crcout[3] = HIWORD(crcin);
    j >>= 1;
    if ( ++k == 8 )
    {
      j = 0x80;
      k = 0;
      ++ptr;
    }
    crcin = *(_DWORD *)crcout;
    crcin_4 = crcout[4];
  }
  crc = 0;
  if ( crcin_4 )
    crc = 16;
  if ( HIBYTE(crcin) )
    crc |= 8u;
  if ( BYTE2(crcin) )
    crc |= 4u;
  if ( BYTE1(crcin) )
    crc |= 2u;
  if ( (_BYTE)crcin )
    crc |= 1u;
  return crc;
}

//----- (0002D278) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  uint32_t wv[8]; // [sp+14h] [bp+14h]
  uint32_t w[64]; // [sp+34h] [bp+34h]
  uint32_t t2; // [sp+134h] [bp+134h]
  uint32_t t1; // [sp+138h] [bp+138h]
  const unsigned __int8 *sub_block; // [sp+13Ch] [bp+13Ch]
  int j; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  for ( i = 0; i < (int)block_nb; ++i )
  {
    sub_block = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = sub_block[4 * j + 3] | (sub_block[4 * j + 2] << 8) | (sub_block[4 * j + 1] << 16) | (sub_block[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      wv[j] = ctx->h[j];
    for ( j = 0; j <= 63; ++j )
    {
      t1 = w[j]
         + wv[7]
         + (__ROR4__(wv[4], 25) ^ __ROR4__(wv[4], 6) ^ __ROR4__(wv[4], 11))
         + (wv[6] & ~wv[4] ^ wv[4] & wv[5])
         + sha256_k[j];
      t2 = (wv[2] & wv[1] ^ wv[0] & wv[1] ^ wv[2] & wv[0])
         + (__ROR4__(wv[0], 2) ^ __ROR4__(wv[0], 13) ^ __ROR4__(wv[0], 22));
      wv[7] = wv[6];
      wv[6] = wv[5];
      wv[5] = wv[4];
      wv[4] = wv[3] + t1;
      wv[3] = wv[2];
      wv[2] = wv[1];
      wv[1] = wv[0];
      wv[0] = t1 + t2;
    }
    for ( j = 0; j <= 7; ++j )
      ctx->h[j] += wv[j];
  }
}

//----- (0002D5D4) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  sha256_ctx ctx; // [sp+10h] [bp+10h] BYREF

  sha256_init(&ctx);
  sha256_update(&ctx, message, len);
  sha256_final(&ctx, digest);
}

//----- (0002D60C) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 7; ++i )
    ctx->h[i] = sha256_h0[i];
  ctx->len = 0;
  ctx->tot_len = 0;
}

//----- (0002D658) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v3; // r3
  const unsigned __int8 *shifted_message; // [sp+14h] [bp+14h]
  unsigned int block_nb; // [sp+18h] [bp+18h]
  unsigned int rem_len; // [sp+20h] [bp+20h]
  size_t rem_lena; // [sp+20h] [bp+20h]

  v3 = len;
  if ( len >= 64 - ctx->len )
    v3 = 64 - ctx->len;
  rem_len = v3;
  memcpy(&ctx->block[ctx->len], message, v3);
  if ( len + ctx->len > 0x3F )
  {
    block_nb = (len - rem_len) >> 6;
    shifted_message = &message[rem_len];
    sha256_transf(ctx, ctx->block, 1u);
    sha256_transf(ctx, &message[rem_len], block_nb);
    rem_lena = (len - rem_len) & 0x3F;
    memcpy(ctx->block, &shifted_message[64 * block_nb], rem_lena);
    ctx->len = rem_lena;
    ctx->tot_len += (block_nb + 1) << 6;
  }
  else
  {
    ctx->len += len;
  }
}

//----- (0002D710) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  unsigned int pm_len; // [sp+8h] [bp+8h]
  unsigned int len_b; // [sp+Ch] [bp+Ch]
  unsigned int block_nb; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( (ctx->len & 0x3F) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  block_nb = v2;
  len_b = 8 * (ctx->len + ctx->tot_len);
  pm_len = v2 << 6;
  memset(&ctx->block[ctx->len], 0, (v2 << 6) - ctx->len);
  ctx->block[ctx->len] = 0x80;
  ctx->block[pm_len - 1] = len_b;
  ctx->block[pm_len - 2] = BYTE1(len_b);
  ctx->block[pm_len - 3] = BYTE2(len_b);
  ctx->block[pm_len - 4] = HIBYTE(len_b);
  sha256_transf(ctx, ctx->block, block_nb);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = ctx->h[i];
    digest[4 * i + 2] = BYTE1(ctx->h[i]);
    digest[4 * i + 1] = BYTE2(ctx->h[i]);
    digest[4 * i] = HIBYTE(ctx->h[i]);
  }
}

//----- (0002D848) --------------------------------------------------------
void __cdecl Sha256_Init(CSha256 *p)
{
  p->state[0] = 1779033703;
  p->state[1] = -1150833019;
  p->state[2] = 1013904242;
  p->state[3] = -1521486534;
  p->state[4] = 1359893119;
  p->state[5] = -1694144372;
  p->state[6] = 528734635;
  p->state[7] = 1541459225;
  p->count = 0LL;
}

//----- (0002D8C8) --------------------------------------------------------
void __cdecl Sha256_Transform(uint32_t *state, const uint32_t *data)
{
  uint32_t v2; // r1
  unsigned int v3; // r2
  int v4; // r3
  unsigned int i; // [sp+68h] [bp+68h]
  unsigned int j; // [sp+6Ch] [bp+6Ch]
  int v8; // [sp+70h] [bp+70h] BYREF

  for ( j = 0; j <= 7; ++j )
    *(&v8 + j - 26) = state[j];
  for ( j = 0; j <= 0x3F; j += 16 )
  {
    for ( i = 0; i <= 0xF; ++i )
    {
      v2 = (__ROR4__(*(&v8 + ((4 - (_BYTE)i) & 7) - 26), 6) ^ __ROR4__(*(&v8 + ((4 - (_BYTE)i) & 7) - 26), 11) ^ __ROR4__(*(&v8 + ((4 - (_BYTE)i) & 7) - 26), 25))
         + ((*(&v8 + ((6 - (_BYTE)i) & 7) - 26) ^ *(&v8 + ((5 - (_BYTE)i) & 7) - 26)) & *(&v8 + ((4 - (_BYTE)i) & 7)
                                                                                              - 26) ^ *(&v8 + ((6 - (_BYTE)i) & 7) - 26))
         + K[i + j];
      if ( j )
      {
        v3 = i;
        *(&v8 + i - 18) = *(&v8 + (i & 0xF) - 18)
                        + (((unsigned int)*(&v8 + (((_BYTE)i - 15) & 0xF) - 18) >> 3) ^ __ROR4__(
                                                                                          *(&v8
                                                                                          + (((_BYTE)i - 15) & 0xF)
                                                                                          - 18),
                                                                                          7) ^ __ROR4__(
                                                                                                 *(&v8
                                                                                                 + (((_BYTE)i - 15) & 0xF)
                                                                                                 - 18),
                                                                                                 18))
                        + (__ROR4__(*(&v8 + (((_BYTE)i - 2) & 0xF) - 18), 17) ^ __ROR4__(
                                                                                  *(&v8 + (((_BYTE)i - 2) & 0xF) - 18),
                                                                                  19) ^ ((unsigned int)*(&v8 + (((_BYTE)i - 2) & 0xF) - 18) >> 10))
                        + *(&v8 + (((_BYTE)i - 7) & 0xF) - 18);
        v4 = *(&v8 + v3 - 18);
      }
      else
      {
        *(&v8 + i - 18) = data[i];
        v4 = *(&v8 + i - 18);
      }
      *(&v8 + ((7 - (_BYTE)i) & 7) - 26) += v2 + v4;
      *(&v8 + ((3 - (_BYTE)i) & 7) - 26) += *(&v8 + ((7 - (_BYTE)i) & 7) - 26);
      *(&v8 + ((7 - (_BYTE)i) & 7) - 26) += ((*(&v8 + ((1 - (_BYTE)i) & 7) - 26) | *(&v8 + (-i & 7) - 26)) & *(&v8 + ((2 - (_BYTE)i) & 7) - 26) | *(&v8 + (-i & 7) - 26) & *(&v8 + ((1 - (_BYTE)i) & 7) - 26))
                                          + (__ROR4__(*(&v8 + (-i & 7) - 26), 2) ^ __ROR4__(*(&v8 + (-i & 7) - 26), 13) ^ __ROR4__(*(&v8 + (-i & 7) - 26), 22));
    }
  }
  for ( j = 0; j <= 7; ++j )
    state[j] += *(&v8 + j - 26);
}
// 2D9D6: masking with 0xF was optimized away because %i.4 <= 0xF

//----- (0002DC98) --------------------------------------------------------
void __cdecl Sha256_WriteByteBlock(CSha256 *p)
{
  uint32_t data32[16]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int i; // [sp+4Ch] [bp+4Ch]
  __int64 savedregs; // [sp+50h] [bp+50h] BYREF

  for ( i = 0; i <= 0xF; ++i )
    *((_DWORD *)&savedregs + i - 17) = p->buffer[4 * i + 3]
                                     + (p->buffer[4 * i + 2] << 8)
                                     + (p->buffer[4 * i] << 24)
                                     + (p->buffer[4 * i + 1] << 16);
  Sha256_Transform(p->state, data32);
}

//----- (0002DD18) --------------------------------------------------------
void __cdecl Sha256_Update(CSha256 *p, const uint8_t *data, size_t size)
{
  uint32_t v3; // r3
  uint8_t *v4; // r2
  uint32_t curBufferPos; // [sp+14h] [bp+14h]

  curBufferPos = p->count & 0x3F;
  while ( size )
  {
    v3 = curBufferPos++;
    v4 = (uint8_t *)data++;
    p->buffer[v3] = *v4;
    ++p->count;
    --size;
    if ( curBufferPos == 64 )
    {
      curBufferPos = 0;
      Sha256_WriteByteBlock(p);
    }
  }
}

//----- (0002DD80) --------------------------------------------------------
void __cdecl Sha256_Final(CSha256 *p, uint8_t *digest)
{
  int v2; // r3
  int v3; // r3
  uint32_t v4; // r1
  uint8_t *v5; // r3
  unsigned int i; // [sp+8h] [bp+8h]
  unsigned int ia; // [sp+8h] [bp+8h]
  uint32_t curBufferPos; // [sp+Ch] [bp+Ch]
  int curBufferPosa; // [sp+Ch] [bp+Ch]
  uint64_t lenInBits; // [sp+10h] [bp+10h]

  lenInBits = 8 * p->count;
  v2 = p->count & 0x3F;
  curBufferPos = v2 + 1;
  p->buffer[v2] = 0x80;
  while ( curBufferPos != 56 )
  {
    curBufferPosa = curBufferPos & 0x3F;
    if ( !curBufferPosa )
      Sha256_WriteByteBlock(p);
    v3 = curBufferPosa;
    curBufferPos = curBufferPosa + 1;
    p->buffer[v3] = 0;
  }
  for ( i = 0; i <= 7; ++i )
  {
    v4 = curBufferPos++;
    p->buffer[v4] = HIBYTE(lenInBits);
    lenInBits <<= 8;
  }
  Sha256_WriteByteBlock(p);
  for ( ia = 0; ia <= 7; ++ia )
  {
    *digest = HIBYTE(p->state[ia]);
    digest[1] = BYTE2(p->state[ia]);
    digest[2] = BYTE1(p->state[ia]);
    v5 = digest + 3;
    digest += 4;
    *v5 = p->state[ia];
  }
  Sha256_Init(p);
}

//----- (0002DEA0) --------------------------------------------------------
void __cdecl Sha256_Onestep(const uint8_t *data, size_t size, uint8_t *digest)
{
  CSha256 p; // [sp+10h] [bp+10h] BYREF

  Sha256_Init(&p);
  Sha256_Update(&p, data, size);
  Sha256_Final(&p, digest);
}

//----- (0002DED8) --------------------------------------------------------
void __cdecl sha2_starts(sha2_context *ctx)
{
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[0] = 1779033703;
  ctx->state[1] = -1150833019;
  ctx->state[2] = 1013904242;
  ctx->state[3] = -1521486534;
  ctx->state[4] = 1359893119;
  ctx->state[5] = -1694144372;
  ctx->state[6] = 528734635;
  ctx->state[7] = 1541459225;
}

//----- (0002DF58) --------------------------------------------------------
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int W; // [sp+8h] [bp+8h]
  unsigned int W_4; // [sp+Ch] [bp+Ch]
  unsigned int W_8; // [sp+10h] [bp+10h]
  unsigned int W_12; // [sp+14h] [bp+14h]
  unsigned int W_16; // [sp+18h] [bp+18h]
  unsigned int W_20; // [sp+1Ch] [bp+1Ch]
  unsigned int W_24; // [sp+20h] [bp+20h]
  unsigned int W_28; // [sp+24h] [bp+24h]
  unsigned int W_32; // [sp+28h] [bp+28h]
  unsigned int W_36; // [sp+2Ch] [bp+2Ch]
  unsigned int W_40; // [sp+30h] [bp+30h]
  unsigned int W_44; // [sp+34h] [bp+34h]
  unsigned int W_48; // [sp+38h] [bp+38h]
  unsigned int W_52; // [sp+3Ch] [bp+3Ch]
  unsigned int W_56; // [sp+40h] [bp+40h]
  unsigned int W_60; // [sp+44h] [bp+44h]
  unsigned int W_64; // [sp+48h] [bp+48h]
  unsigned int W_68; // [sp+4Ch] [bp+4Ch]
  unsigned int W_72; // [sp+50h] [bp+50h]
  unsigned int W_76; // [sp+54h] [bp+54h]
  unsigned int W_80; // [sp+58h] [bp+58h]
  unsigned int W_84; // [sp+5Ch] [bp+5Ch]
  unsigned int W_88; // [sp+60h] [bp+60h]
  unsigned int W_92; // [sp+64h] [bp+64h]
  unsigned int W_96; // [sp+68h] [bp+68h]
  unsigned int W_100; // [sp+6Ch] [bp+6Ch]
  unsigned int W_104; // [sp+70h] [bp+70h]
  unsigned int W_108; // [sp+74h] [bp+74h]
  unsigned int W_112; // [sp+78h] [bp+78h]
  unsigned int W_116; // [sp+7Ch] [bp+7Ch]
  unsigned int W_120; // [sp+80h] [bp+80h]
  unsigned int W_124; // [sp+84h] [bp+84h]
  unsigned int W_128; // [sp+88h] [bp+88h]
  unsigned int W_132; // [sp+8Ch] [bp+8Ch]
  unsigned int W_136; // [sp+90h] [bp+90h]
  unsigned int W_140; // [sp+94h] [bp+94h]
  unsigned int W_144; // [sp+98h] [bp+98h]
  unsigned int W_148; // [sp+9Ch] [bp+9Ch]
  unsigned int W_152; // [sp+A0h] [bp+A0h]
  unsigned int W_156; // [sp+A4h] [bp+A4h]
  unsigned int W_160; // [sp+A8h] [bp+A8h]
  unsigned int W_164; // [sp+ACh] [bp+ACh]
  unsigned int W_168; // [sp+B0h] [bp+B0h]
  unsigned int W_172; // [sp+B4h] [bp+B4h]
  unsigned int W_176; // [sp+B8h] [bp+B8h]
  unsigned int W_180; // [sp+BCh] [bp+BCh]
  unsigned int W_184; // [sp+C0h] [bp+C0h]
  unsigned int W_188; // [sp+C4h] [bp+C4h]
  unsigned int W_192; // [sp+C8h] [bp+C8h]
  unsigned int W_196; // [sp+CCh] [bp+CCh]
  unsigned int W_200; // [sp+D0h] [bp+D0h]
  unsigned int W_204; // [sp+D4h] [bp+D4h]
  unsigned int W_208; // [sp+D8h] [bp+D8h]
  unsigned int W_212; // [sp+DCh] [bp+DCh]
  unsigned int W_216; // [sp+E0h] [bp+E0h]
  unsigned int W_220; // [sp+E4h] [bp+E4h]
  unsigned int W_224; // [sp+E8h] [bp+E8h]
  unsigned int W_228; // [sp+ECh] [bp+ECh]
  unsigned int W_232; // [sp+F0h] [bp+F0h]
  unsigned int W_236; // [sp+F4h] [bp+F4h]
  unsigned int W_240; // [sp+F8h] [bp+F8h]
  unsigned int W_244; // [sp+FCh] [bp+FCh]
  uint32_t temp1; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1a; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1b; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1c; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1d; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1e; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1f; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1g; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1h; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1i; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1j; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1k; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1l; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1m; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1n; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1o; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1p; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1q; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1r; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1s; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1t; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1u; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1v; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1w; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1x; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1y; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1z; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ba; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bb; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bc; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bd; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1be; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bf; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bg; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bh; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bi; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bj; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bk; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bl; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bm; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bn; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bo; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bp; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bq; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1br; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bs; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bt; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bu; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bv; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bw; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bx; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1by; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bz; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ca; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cb; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cc; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cd; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ce; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cf; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cg; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ch; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ci; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cj; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ck; // [sp+10Ch] [bp+10Ch]
  uint32_t H; // [sp+110h] [bp+110h]
  uint32_t Ha; // [sp+110h] [bp+110h]
  uint32_t Hb; // [sp+110h] [bp+110h]
  uint32_t Hc; // [sp+110h] [bp+110h]
  uint32_t Hd; // [sp+110h] [bp+110h]
  uint32_t He; // [sp+110h] [bp+110h]
  uint32_t Hf; // [sp+110h] [bp+110h]
  uint32_t Hg; // [sp+110h] [bp+110h]
  uint32_t Hh; // [sp+110h] [bp+110h]
  uint32_t Hi; // [sp+110h] [bp+110h]
  uint32_t Hj; // [sp+110h] [bp+110h]
  uint32_t Hk; // [sp+110h] [bp+110h]
  uint32_t Hl; // [sp+110h] [bp+110h]
  uint32_t Hm; // [sp+110h] [bp+110h]
  uint32_t Hn; // [sp+110h] [bp+110h]
  uint32_t Ho; // [sp+110h] [bp+110h]
  uint32_t G; // [sp+114h] [bp+114h]
  uint32_t Ga; // [sp+114h] [bp+114h]
  uint32_t Gb; // [sp+114h] [bp+114h]
  uint32_t Gc; // [sp+114h] [bp+114h]
  uint32_t Gd; // [sp+114h] [bp+114h]
  uint32_t Ge; // [sp+114h] [bp+114h]
  uint32_t Gf; // [sp+114h] [bp+114h]
  uint32_t Gg; // [sp+114h] [bp+114h]
  uint32_t Gh; // [sp+114h] [bp+114h]
  uint32_t Gi; // [sp+114h] [bp+114h]
  uint32_t Gj; // [sp+114h] [bp+114h]
  uint32_t Gk; // [sp+114h] [bp+114h]
  uint32_t Gl; // [sp+114h] [bp+114h]
  uint32_t Gm; // [sp+114h] [bp+114h]
  uint32_t Gn; // [sp+114h] [bp+114h]
  uint32_t Go; // [sp+114h] [bp+114h]
  uint32_t Gp; // [sp+114h] [bp+114h]
  uint32_t F; // [sp+118h] [bp+118h]
  uint32_t Fa; // [sp+118h] [bp+118h]
  uint32_t Fb; // [sp+118h] [bp+118h]
  uint32_t Fc; // [sp+118h] [bp+118h]
  uint32_t Fd; // [sp+118h] [bp+118h]
  uint32_t Fe; // [sp+118h] [bp+118h]
  uint32_t Ff; // [sp+118h] [bp+118h]
  uint32_t Fg; // [sp+118h] [bp+118h]
  uint32_t Fh; // [sp+118h] [bp+118h]
  uint32_t Fi; // [sp+118h] [bp+118h]
  uint32_t Fj; // [sp+118h] [bp+118h]
  uint32_t Fk; // [sp+118h] [bp+118h]
  uint32_t Fl; // [sp+118h] [bp+118h]
  uint32_t Fm; // [sp+118h] [bp+118h]
  uint32_t Fn; // [sp+118h] [bp+118h]
  uint32_t Fo; // [sp+118h] [bp+118h]
  uint32_t Fp; // [sp+118h] [bp+118h]
  uint32_t E; // [sp+11Ch] [bp+11Ch]
  uint32_t Ea; // [sp+11Ch] [bp+11Ch]
  uint32_t Eb; // [sp+11Ch] [bp+11Ch]
  uint32_t Ec; // [sp+11Ch] [bp+11Ch]
  uint32_t Ed; // [sp+11Ch] [bp+11Ch]
  uint32_t Ee; // [sp+11Ch] [bp+11Ch]
  uint32_t Ef; // [sp+11Ch] [bp+11Ch]
  uint32_t Eg; // [sp+11Ch] [bp+11Ch]
  uint32_t Eh; // [sp+11Ch] [bp+11Ch]
  uint32_t Ei; // [sp+11Ch] [bp+11Ch]
  uint32_t Ej; // [sp+11Ch] [bp+11Ch]
  uint32_t Ek; // [sp+11Ch] [bp+11Ch]
  uint32_t El; // [sp+11Ch] [bp+11Ch]
  uint32_t Em; // [sp+11Ch] [bp+11Ch]
  uint32_t En; // [sp+11Ch] [bp+11Ch]
  uint32_t Eo; // [sp+11Ch] [bp+11Ch]
  uint32_t D; // [sp+120h] [bp+120h]
  uint32_t Da; // [sp+120h] [bp+120h]
  uint32_t Db; // [sp+120h] [bp+120h]
  uint32_t Dc; // [sp+120h] [bp+120h]
  uint32_t Dd; // [sp+120h] [bp+120h]
  uint32_t De; // [sp+120h] [bp+120h]
  uint32_t Df; // [sp+120h] [bp+120h]
  uint32_t Dg; // [sp+120h] [bp+120h]
  uint32_t Dh; // [sp+120h] [bp+120h]
  uint32_t Di; // [sp+120h] [bp+120h]
  uint32_t Dj; // [sp+120h] [bp+120h]
  uint32_t Dk; // [sp+120h] [bp+120h]
  uint32_t Dl; // [sp+120h] [bp+120h]
  uint32_t Dm; // [sp+120h] [bp+120h]
  uint32_t Dn; // [sp+120h] [bp+120h]
  uint32_t Do; // [sp+120h] [bp+120h]
  uint32_t C; // [sp+124h] [bp+124h]
  uint32_t Ca; // [sp+124h] [bp+124h]
  uint32_t Cb; // [sp+124h] [bp+124h]
  uint32_t Cc; // [sp+124h] [bp+124h]
  uint32_t Cd; // [sp+124h] [bp+124h]
  uint32_t Ce; // [sp+124h] [bp+124h]
  uint32_t Cf; // [sp+124h] [bp+124h]
  uint32_t Cg; // [sp+124h] [bp+124h]
  uint32_t Ch; // [sp+124h] [bp+124h]
  uint32_t Ci; // [sp+124h] [bp+124h]
  uint32_t Cj; // [sp+124h] [bp+124h]
  uint32_t Ck; // [sp+124h] [bp+124h]
  uint32_t Cl; // [sp+124h] [bp+124h]
  uint32_t Cm; // [sp+124h] [bp+124h]
  uint32_t Cn; // [sp+124h] [bp+124h]
  uint32_t Co; // [sp+124h] [bp+124h]
  uint32_t Cp; // [sp+124h] [bp+124h]
  uint32_t B; // [sp+128h] [bp+128h]
  uint32_t Ba; // [sp+128h] [bp+128h]
  uint32_t Bb; // [sp+128h] [bp+128h]
  uint32_t Bc; // [sp+128h] [bp+128h]
  uint32_t Bd; // [sp+128h] [bp+128h]
  uint32_t Be; // [sp+128h] [bp+128h]
  uint32_t Bf; // [sp+128h] [bp+128h]
  uint32_t Bg; // [sp+128h] [bp+128h]
  uint32_t Bh; // [sp+128h] [bp+128h]
  uint32_t Bi; // [sp+128h] [bp+128h]
  uint32_t Bj; // [sp+128h] [bp+128h]
  uint32_t Bk; // [sp+128h] [bp+128h]
  uint32_t Bl; // [sp+128h] [bp+128h]
  uint32_t Bm; // [sp+128h] [bp+128h]
  uint32_t Bn; // [sp+128h] [bp+128h]
  uint32_t Bo; // [sp+128h] [bp+128h]
  uint32_t Bp; // [sp+128h] [bp+128h]
  uint32_t A; // [sp+12Ch] [bp+12Ch]
  uint32_t Aa; // [sp+12Ch] [bp+12Ch]
  uint32_t Ab; // [sp+12Ch] [bp+12Ch]
  uint32_t Ac; // [sp+12Ch] [bp+12Ch]
  uint32_t Ad; // [sp+12Ch] [bp+12Ch]
  uint32_t Ae; // [sp+12Ch] [bp+12Ch]
  uint32_t Af; // [sp+12Ch] [bp+12Ch]
  uint32_t Ag; // [sp+12Ch] [bp+12Ch]
  uint32_t Ah; // [sp+12Ch] [bp+12Ch]
  uint32_t Ai; // [sp+12Ch] [bp+12Ch]
  uint32_t Aj; // [sp+12Ch] [bp+12Ch]
  uint32_t Ak; // [sp+12Ch] [bp+12Ch]
  uint32_t Al; // [sp+12Ch] [bp+12Ch]
  uint32_t Am; // [sp+12Ch] [bp+12Ch]
  uint32_t An; // [sp+12Ch] [bp+12Ch]
  uint32_t Ao; // [sp+12Ch] [bp+12Ch]

  W = _byteswap_ulong(*(_DWORD *)data);
  W_4 = _byteswap_ulong(*((_DWORD *)data + 1));
  W_8 = _byteswap_ulong(*((_DWORD *)data + 2));
  W_12 = _byteswap_ulong(*((_DWORD *)data + 3));
  W_16 = _byteswap_ulong(*((_DWORD *)data + 4));
  W_20 = _byteswap_ulong(*((_DWORD *)data + 5));
  W_24 = _byteswap_ulong(*((_DWORD *)data + 6));
  W_28 = _byteswap_ulong(*((_DWORD *)data + 7));
  W_32 = _byteswap_ulong(*((_DWORD *)data + 8));
  W_36 = _byteswap_ulong(*((_DWORD *)data + 9));
  W_40 = _byteswap_ulong(*((_DWORD *)data + 10));
  W_44 = _byteswap_ulong(*((_DWORD *)data + 11));
  W_48 = _byteswap_ulong(*((_DWORD *)data + 12));
  W_52 = _byteswap_ulong(*((_DWORD *)data + 13));
  W_56 = _byteswap_ulong(*((_DWORD *)data + 14));
  W_60 = _byteswap_ulong(*((_DWORD *)data + 15));
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  E = ctx->state[4];
  F = ctx->state[5];
  G = ctx->state[6];
  temp1 = (__ROR4__(E, 6) ^ __ROR4__(E, 11) ^ __ROR4__(E, 25)) + ctx->state[7] + (G ^ (F ^ G) & E) + W + 1116352408;
  D = temp1 + ctx->state[3];
  H = (C & (A | B) | A & B) + (__ROR4__(A, 2) ^ __ROR4__(A, 13) ^ __ROR4__(A, 22)) + temp1;
  temp1a = (__ROR4__(D, 6) ^ __ROR4__(D, 11) ^ __ROR4__(D, 25)) + G + (F ^ (E ^ F) & D) + W_4 + 1899447441;
  Ca = temp1a + C;
  Ga = (B & (H | A) | H & A) + (__ROR4__(H, 2) ^ __ROR4__(H, 13) ^ __ROR4__(H, 22)) + temp1a;
  temp1b = (__ROR4__(Ca, 6) ^ __ROR4__(Ca, 11) ^ __ROR4__(Ca, 25)) + F + (E ^ (D ^ E) & Ca) + W_8 - 1245643825;
  Ba = temp1b + B;
  Fa = (A & (Ga | H) | Ga & H) + (__ROR4__(Ga, 2) ^ __ROR4__(Ga, 13) ^ __ROR4__(Ga, 22)) + temp1b;
  temp1c = (__ROR4__(Ba, 6) ^ __ROR4__(Ba, 11) ^ __ROR4__(Ba, 25)) + E + (D ^ (Ca ^ D) & Ba) + W_12 - 373957723;
  Aa = temp1c + A;
  Ea = (H & (Fa | Ga) | Fa & Ga) + (__ROR4__(Fa, 2) ^ __ROR4__(Fa, 13) ^ __ROR4__(Fa, 22)) + temp1c;
  temp1d = (__ROR4__(Aa, 6) ^ __ROR4__(Aa, 11) ^ __ROR4__(Aa, 25)) + D + (Ca ^ (Ba ^ Ca) & Aa) + W_16 + 961987163;
  Ha = temp1d + H;
  Da = (Ga & (Ea | Fa) | Ea & Fa) + (__ROR4__(Ea, 2) ^ __ROR4__(Ea, 13) ^ __ROR4__(Ea, 22)) + temp1d;
  temp1e = (__ROR4__(Ha, 6) ^ __ROR4__(Ha, 11) ^ __ROR4__(Ha, 25)) + Ca + (Ba ^ (Aa ^ Ba) & Ha) + W_20 + 1508970993;
  Gb = temp1e + Ga;
  Cb = (Fa & (Da | Ea) | Da & Ea) + (__ROR4__(Da, 2) ^ __ROR4__(Da, 13) ^ __ROR4__(Da, 22)) + temp1e;
  temp1f = (__ROR4__(Gb, 6) ^ __ROR4__(Gb, 11) ^ __ROR4__(Gb, 25)) + Ba + (Aa ^ (Ha ^ Aa) & Gb) + W_24 - 1841331548;
  Fb = temp1f + Fa;
  Bb = (Ea & (Cb | Da) | Cb & Da) + (__ROR4__(Cb, 2) ^ __ROR4__(Cb, 13) ^ __ROR4__(Cb, 22)) + temp1f;
  temp1g = (__ROR4__(Fb, 6) ^ __ROR4__(Fb, 11) ^ __ROR4__(Fb, 25)) + Aa + (Ha ^ (Gb ^ Ha) & Fb) + W_28 - 1424204075;
  Eb = temp1g + Ea;
  Ab = (Da & (Bb | Cb) | Bb & Cb) + (__ROR4__(Bb, 2) ^ __ROR4__(Bb, 13) ^ __ROR4__(Bb, 22)) + temp1g;
  temp1h = (__ROR4__(Eb, 6) ^ __ROR4__(Eb, 11) ^ __ROR4__(Eb, 25)) + Ha + (Gb ^ (Fb ^ Gb) & Eb) + W_32 - 670586216;
  Db = temp1h + Da;
  Hb = (Cb & (Ab | Bb) | Ab & Bb) + (__ROR4__(Ab, 2) ^ __ROR4__(Ab, 13) ^ __ROR4__(Ab, 22)) + temp1h;
  temp1i = (__ROR4__(Db, 6) ^ __ROR4__(Db, 11) ^ __ROR4__(Db, 25)) + Gb + (Fb ^ (Eb ^ Fb) & Db) + W_36 + 310598401;
  Cc = temp1i + Cb;
  Gc = (Bb & (Hb | Ab) | Hb & Ab) + (__ROR4__(Hb, 2) ^ __ROR4__(Hb, 13) ^ __ROR4__(Hb, 22)) + temp1i;
  temp1j = (__ROR4__(Cc, 6) ^ __ROR4__(Cc, 11) ^ __ROR4__(Cc, 25)) + Fb + (Eb ^ (Db ^ Eb) & Cc) + W_40 + 607225278;
  Bc = temp1j + Bb;
  Fc = (Ab & (Gc | Hb) | Gc & Hb) + (__ROR4__(Gc, 2) ^ __ROR4__(Gc, 13) ^ __ROR4__(Gc, 22)) + temp1j;
  temp1k = (__ROR4__(Bc, 6) ^ __ROR4__(Bc, 11) ^ __ROR4__(Bc, 25)) + Eb + (Db ^ (Cc ^ Db) & Bc) + W_44 + 1426881987;
  Ac = temp1k + Ab;
  Ec = (Hb & (Fc | Gc) | Fc & Gc) + (__ROR4__(Fc, 2) ^ __ROR4__(Fc, 13) ^ __ROR4__(Fc, 22)) + temp1k;
  temp1l = (__ROR4__(Ac, 6) ^ __ROR4__(Ac, 11) ^ __ROR4__(Ac, 25)) + Db + (Cc ^ (Bc ^ Cc) & Ac) + W_48 + 1925078388;
  Hc = temp1l + Hb;
  Dc = (Gc & (Ec | Fc) | Ec & Fc) + (__ROR4__(Ec, 2) ^ __ROR4__(Ec, 13) ^ __ROR4__(Ec, 22)) + temp1l;
  temp1m = (__ROR4__(Hc, 6) ^ __ROR4__(Hc, 11) ^ __ROR4__(Hc, 25)) + Cc + (Bc ^ (Ac ^ Bc) & Hc) + W_52 - 2132889090;
  Gd = temp1m + Gc;
  Cd = (Fc & (Dc | Ec) | Dc & Ec) + (__ROR4__(Dc, 2) ^ __ROR4__(Dc, 13) ^ __ROR4__(Dc, 22)) + temp1m;
  temp1n = (__ROR4__(Gd, 6) ^ __ROR4__(Gd, 11) ^ __ROR4__(Gd, 25)) + Bc + (Ac ^ (Hc ^ Ac) & Gd) + W_56 - 1680079193;
  Fd = temp1n + Fc;
  Bd = (Ec & (Cd | Dc) | Cd & Dc) + (__ROR4__(Cd, 2) ^ __ROR4__(Cd, 13) ^ __ROR4__(Cd, 22)) + temp1n;
  temp1o = (__ROR4__(Fd, 6) ^ __ROR4__(Fd, 11) ^ __ROR4__(Fd, 25)) + Ac + (Hc ^ (Gd ^ Hc) & Fd) + W_60 - 1046744716;
  Ed = temp1o + Ec;
  Ad = (Dc & (Bd | Cd) | Bd & Cd) + (__ROR4__(Bd, 2) ^ __ROR4__(Bd, 13) ^ __ROR4__(Bd, 22)) + temp1o;
  W_64 = (__ROR4__(W_56, 17) ^ __ROR4__(W_56, 19) ^ (W_56 >> 10))
       + W_36
       + ((W_4 >> 3) ^ __ROR4__(W_4, 7) ^ __ROR4__(W_4, 18))
       + W;
  temp1p = (__ROR4__(Ed, 6) ^ __ROR4__(Ed, 11) ^ __ROR4__(Ed, 25)) + Hc + (Gd ^ (Fd ^ Gd) & Ed) + W_64 - 459576895;
  Dd = temp1p + Dc;
  Hd = (Cd & (Ad | Bd) | Ad & Bd) + (__ROR4__(Ad, 2) ^ __ROR4__(Ad, 13) ^ __ROR4__(Ad, 22)) + temp1p;
  W_68 = (__ROR4__(W_60, 17) ^ __ROR4__(W_60, 19) ^ (W_60 >> 10))
       + W_40
       + ((W_8 >> 3) ^ __ROR4__(W_8, 7) ^ __ROR4__(W_8, 18))
       + W_4;
  temp1q = (__ROR4__(Dd, 6) ^ __ROR4__(Dd, 11) ^ __ROR4__(Dd, 25)) + Gd + (Fd ^ (Ed ^ Fd) & Dd) + W_68 - 272742522;
  Ce = temp1q + Cd;
  Ge = (Bd & (Hd | Ad) | Hd & Ad) + (__ROR4__(Hd, 2) ^ __ROR4__(Hd, 13) ^ __ROR4__(Hd, 22)) + temp1q;
  W_72 = (__ROR4__(W_64, 17) ^ __ROR4__(W_64, 19) ^ (W_64 >> 10))
       + W_44
       + ((W_12 >> 3) ^ __ROR4__(W_12, 7) ^ __ROR4__(W_12, 18))
       + W_8;
  temp1r = (__ROR4__(Ce, 6) ^ __ROR4__(Ce, 11) ^ __ROR4__(Ce, 25)) + Fd + (Ed ^ (Dd ^ Ed) & Ce) + W_72 + 264347078;
  Be = temp1r + Bd;
  Fe = (Ad & (Ge | Hd) | Ge & Hd) + (__ROR4__(Ge, 2) ^ __ROR4__(Ge, 13) ^ __ROR4__(Ge, 22)) + temp1r;
  W_76 = (__ROR4__(W_68, 17) ^ __ROR4__(W_68, 19) ^ (W_68 >> 10))
       + W_48
       + ((W_16 >> 3) ^ __ROR4__(W_16, 7) ^ __ROR4__(W_16, 18))
       + W_12;
  temp1s = (__ROR4__(Be, 6) ^ __ROR4__(Be, 11) ^ __ROR4__(Be, 25)) + Ed + (Dd ^ (Ce ^ Dd) & Be) + W_76 + 604807628;
  Ae = temp1s + Ad;
  Ee = (Hd & (Fe | Ge) | Fe & Ge) + (__ROR4__(Fe, 2) ^ __ROR4__(Fe, 13) ^ __ROR4__(Fe, 22)) + temp1s;
  W_80 = (__ROR4__(W_72, 17) ^ __ROR4__(W_72, 19) ^ (W_72 >> 10))
       + W_52
       + ((W_20 >> 3) ^ __ROR4__(W_20, 7) ^ __ROR4__(W_20, 18))
       + W_16;
  temp1t = (__ROR4__(Ae, 6) ^ __ROR4__(Ae, 11) ^ __ROR4__(Ae, 25)) + Dd + (Ce ^ (Be ^ Ce) & Ae) + W_80 + 770255983;
  He = temp1t + Hd;
  De = (Ge & (Ee | Fe) | Ee & Fe) + (__ROR4__(Ee, 2) ^ __ROR4__(Ee, 13) ^ __ROR4__(Ee, 22)) + temp1t;
  W_84 = (__ROR4__(W_76, 17) ^ __ROR4__(W_76, 19) ^ (W_76 >> 10))
       + W_56
       + ((W_24 >> 3) ^ __ROR4__(W_24, 7) ^ __ROR4__(W_24, 18))
       + W_20;
  temp1u = (__ROR4__(He, 6) ^ __ROR4__(He, 11) ^ __ROR4__(He, 25)) + Ce + (Be ^ (Ae ^ Be) & He) + W_84 + 1249150122;
  Gf = temp1u + Ge;
  Cf = (Fe & (De | Ee) | De & Ee) + (__ROR4__(De, 2) ^ __ROR4__(De, 13) ^ __ROR4__(De, 22)) + temp1u;
  W_88 = (__ROR4__(W_80, 17) ^ __ROR4__(W_80, 19) ^ (W_80 >> 10))
       + W_60
       + ((W_28 >> 3) ^ __ROR4__(W_28, 7) ^ __ROR4__(W_28, 18))
       + W_24;
  temp1v = (__ROR4__(Gf, 6) ^ __ROR4__(Gf, 11) ^ __ROR4__(Gf, 25)) + Be + (Ae ^ (He ^ Ae) & Gf) + W_88 + 1555081692;
  Ff = temp1v + Fe;
  Bf = (Ee & (Cf | De) | Cf & De) + (__ROR4__(Cf, 2) ^ __ROR4__(Cf, 13) ^ __ROR4__(Cf, 22)) + temp1v;
  W_92 = (__ROR4__(W_84, 17) ^ __ROR4__(W_84, 19) ^ (W_84 >> 10))
       + W_64
       + ((W_32 >> 3) ^ __ROR4__(W_32, 7) ^ __ROR4__(W_32, 18))
       + W_28;
  temp1w = (__ROR4__(Ff, 6) ^ __ROR4__(Ff, 11) ^ __ROR4__(Ff, 25)) + Ae + (He ^ (Gf ^ He) & Ff) + W_92 + 1996064986;
  Ef = temp1w + Ee;
  Af = (De & (Bf | Cf) | Bf & Cf) + (__ROR4__(Bf, 2) ^ __ROR4__(Bf, 13) ^ __ROR4__(Bf, 22)) + temp1w;
  W_96 = (__ROR4__(W_88, 17) ^ __ROR4__(W_88, 19) ^ (W_88 >> 10))
       + W_68
       + ((W_36 >> 3) ^ __ROR4__(W_36, 7) ^ __ROR4__(W_36, 18))
       + W_32;
  temp1x = (__ROR4__(Ef, 6) ^ __ROR4__(Ef, 11) ^ __ROR4__(Ef, 25)) + He + (Gf ^ (Ff ^ Gf) & Ef) + W_96 - 1740746414;
  Df = temp1x + De;
  Hf = (Cf & (Af | Bf) | Af & Bf) + (__ROR4__(Af, 2) ^ __ROR4__(Af, 13) ^ __ROR4__(Af, 22)) + temp1x;
  W_100 = (__ROR4__(W_92, 17) ^ __ROR4__(W_92, 19) ^ (W_92 >> 10))
        + W_72
        + ((W_40 >> 3) ^ __ROR4__(W_40, 7) ^ __ROR4__(W_40, 18))
        + W_36;
  temp1y = (__ROR4__(Df, 6) ^ __ROR4__(Df, 11) ^ __ROR4__(Df, 25)) + Gf + (Ff ^ (Ef ^ Ff) & Df) + W_100 - 1473132947;
  Cg = temp1y + Cf;
  Gg = (Bf & (Hf | Af) | Hf & Af) + (__ROR4__(Hf, 2) ^ __ROR4__(Hf, 13) ^ __ROR4__(Hf, 22)) + temp1y;
  W_104 = (__ROR4__(W_96, 17) ^ __ROR4__(W_96, 19) ^ (W_96 >> 10))
        + W_76
        + ((W_44 >> 3) ^ __ROR4__(W_44, 7) ^ __ROR4__(W_44, 18))
        + W_40;
  temp1z = (__ROR4__(Cg, 6) ^ __ROR4__(Cg, 11) ^ __ROR4__(Cg, 25)) + Ff + (Ef ^ (Df ^ Ef) & Cg) + W_104 - 1341970488;
  Bg = temp1z + Bf;
  Fg = (Af & (Gg | Hf) | Gg & Hf) + (__ROR4__(Gg, 2) ^ __ROR4__(Gg, 13) ^ __ROR4__(Gg, 22)) + temp1z;
  W_108 = (__ROR4__(W_100, 17) ^ __ROR4__(W_100, 19) ^ (W_100 >> 10))
        + W_80
        + ((W_48 >> 3) ^ __ROR4__(W_48, 7) ^ __ROR4__(W_48, 18))
        + W_44;
  temp1ba = (__ROR4__(Bg, 6) ^ __ROR4__(Bg, 11) ^ __ROR4__(Bg, 25)) + Ef + (Df ^ (Cg ^ Df) & Bg) + W_108 - 1084653625;
  Ag = temp1ba + Af;
  Eg = (Hf & (Fg | Gg) | Fg & Gg) + (__ROR4__(Fg, 2) ^ __ROR4__(Fg, 13) ^ __ROR4__(Fg, 22)) + temp1ba;
  W_112 = (__ROR4__(W_104, 17) ^ __ROR4__(W_104, 19) ^ (W_104 >> 10))
        + W_84
        + ((W_52 >> 3) ^ __ROR4__(W_52, 7) ^ __ROR4__(W_52, 18))
        + W_48;
  temp1bb = (__ROR4__(Ag, 6) ^ __ROR4__(Ag, 11) ^ __ROR4__(Ag, 25)) + Df + (Cg ^ (Bg ^ Cg) & Ag) + W_112 - 958395405;
  Hg = temp1bb + Hf;
  Dg = (Gg & (Eg | Fg) | Eg & Fg) + (__ROR4__(Eg, 2) ^ __ROR4__(Eg, 13) ^ __ROR4__(Eg, 22)) + temp1bb;
  W_116 = (__ROR4__(W_108, 17) ^ __ROR4__(W_108, 19) ^ (W_108 >> 10))
        + W_88
        + ((W_56 >> 3) ^ __ROR4__(W_56, 7) ^ __ROR4__(W_56, 18))
        + W_52;
  temp1bc = (__ROR4__(Hg, 6) ^ __ROR4__(Hg, 11) ^ __ROR4__(Hg, 25)) + Cg + (Bg ^ (Ag ^ Bg) & Hg) + W_116 - 710438585;
  Gh = temp1bc + Gg;
  Ch = (Fg & (Dg | Eg) | Dg & Eg) + (__ROR4__(Dg, 2) ^ __ROR4__(Dg, 13) ^ __ROR4__(Dg, 22)) + temp1bc;
  W_120 = (__ROR4__(W_112, 17) ^ __ROR4__(W_112, 19) ^ (W_112 >> 10))
        + W_92
        + ((W_60 >> 3) ^ __ROR4__(W_60, 7) ^ __ROR4__(W_60, 18))
        + W_56;
  temp1bd = (__ROR4__(Gh, 6) ^ __ROR4__(Gh, 11) ^ __ROR4__(Gh, 25)) + Bg + (Ag ^ (Hg ^ Ag) & Gh) + W_120 + 113926993;
  Fh = temp1bd + Fg;
  Bh = (Eg & (Ch | Dg) | Ch & Dg) + (__ROR4__(Ch, 2) ^ __ROR4__(Ch, 13) ^ __ROR4__(Ch, 22)) + temp1bd;
  W_124 = (__ROR4__(W_116, 17) ^ __ROR4__(W_116, 19) ^ (W_116 >> 10))
        + W_96
        + ((W_64 >> 3) ^ __ROR4__(W_64, 7) ^ __ROR4__(W_64, 18))
        + W_60;
  temp1be = (__ROR4__(Fh, 6) ^ __ROR4__(Fh, 11) ^ __ROR4__(Fh, 25)) + Ag + (Hg ^ (Gh ^ Hg) & Fh) + W_124 + 338241895;
  Eh = temp1be + Eg;
  Ah = (Dg & (Bh | Ch) | Bh & Ch) + (__ROR4__(Bh, 2) ^ __ROR4__(Bh, 13) ^ __ROR4__(Bh, 22)) + temp1be;
  W_128 = (__ROR4__(W_120, 17) ^ __ROR4__(W_120, 19) ^ (W_120 >> 10))
        + W_100
        + ((W_68 >> 3) ^ __ROR4__(W_68, 7) ^ __ROR4__(W_68, 18))
        + W_64;
  temp1bf = (__ROR4__(Eh, 6) ^ __ROR4__(Eh, 11) ^ __ROR4__(Eh, 25)) + Hg + (Gh ^ (Fh ^ Gh) & Eh) + W_128 + 666307205;
  Dh = temp1bf + Dg;
  Hh = (Ch & (Ah | Bh) | Ah & Bh) + (__ROR4__(Ah, 2) ^ __ROR4__(Ah, 13) ^ __ROR4__(Ah, 22)) + temp1bf;
  W_132 = (__ROR4__(W_124, 17) ^ __ROR4__(W_124, 19) ^ (W_124 >> 10))
        + W_104
        + ((W_72 >> 3) ^ __ROR4__(W_72, 7) ^ __ROR4__(W_72, 18))
        + W_68;
  temp1bg = (__ROR4__(Dh, 6) ^ __ROR4__(Dh, 11) ^ __ROR4__(Dh, 25)) + Gh + (Fh ^ (Eh ^ Fh) & Dh) + W_132 + 773529912;
  Ci = temp1bg + Ch;
  Gi = (Bh & (Hh | Ah) | Hh & Ah) + (__ROR4__(Hh, 2) ^ __ROR4__(Hh, 13) ^ __ROR4__(Hh, 22)) + temp1bg;
  W_136 = (__ROR4__(W_128, 17) ^ __ROR4__(W_128, 19) ^ (W_128 >> 10))
        + W_108
        + ((W_76 >> 3) ^ __ROR4__(W_76, 7) ^ __ROR4__(W_76, 18))
        + W_72;
  temp1bh = (__ROR4__(Ci, 6) ^ __ROR4__(Ci, 11) ^ __ROR4__(Ci, 25)) + Fh + (Eh ^ (Dh ^ Eh) & Ci) + W_136 + 1294757372;
  Bi = temp1bh + Bh;
  Fi = (Ah & (Gi | Hh) | Gi & Hh) + (__ROR4__(Gi, 2) ^ __ROR4__(Gi, 13) ^ __ROR4__(Gi, 22)) + temp1bh;
  W_140 = (__ROR4__(W_132, 17) ^ __ROR4__(W_132, 19) ^ (W_132 >> 10))
        + W_112
        + ((W_80 >> 3) ^ __ROR4__(W_80, 7) ^ __ROR4__(W_80, 18))
        + W_76;
  temp1bi = (__ROR4__(Bi, 6) ^ __ROR4__(Bi, 11) ^ __ROR4__(Bi, 25)) + Eh + (Dh ^ (Ci ^ Dh) & Bi) + W_140 + 1396182291;
  Ai = temp1bi + Ah;
  Ei = (Hh & (Fi | Gi) | Fi & Gi) + (__ROR4__(Fi, 2) ^ __ROR4__(Fi, 13) ^ __ROR4__(Fi, 22)) + temp1bi;
  W_144 = (__ROR4__(W_136, 17) ^ __ROR4__(W_136, 19) ^ (W_136 >> 10))
        + W_116
        + ((W_84 >> 3) ^ __ROR4__(W_84, 7) ^ __ROR4__(W_84, 18))
        + W_80;
  temp1bj = (__ROR4__(Ai, 6) ^ __ROR4__(Ai, 11) ^ __ROR4__(Ai, 25)) + Dh + (Ci ^ (Bi ^ Ci) & Ai) + W_144 + 1695183700;
  Hi = temp1bj + Hh;
  Di = (Gi & (Ei | Fi) | Ei & Fi) + (__ROR4__(Ei, 2) ^ __ROR4__(Ei, 13) ^ __ROR4__(Ei, 22)) + temp1bj;
  W_148 = (__ROR4__(W_140, 17) ^ __ROR4__(W_140, 19) ^ (W_140 >> 10))
        + W_120
        + ((W_88 >> 3) ^ __ROR4__(W_88, 7) ^ __ROR4__(W_88, 18))
        + W_84;
  temp1bk = (__ROR4__(Hi, 6) ^ __ROR4__(Hi, 11) ^ __ROR4__(Hi, 25)) + Ci + (Bi ^ (Ai ^ Bi) & Hi) + W_148 + 1986661051;
  Gj = temp1bk + Gi;
  Cj = (Fi & (Di | Ei) | Di & Ei) + (__ROR4__(Di, 2) ^ __ROR4__(Di, 13) ^ __ROR4__(Di, 22)) + temp1bk;
  W_152 = (__ROR4__(W_144, 17) ^ __ROR4__(W_144, 19) ^ (W_144 >> 10))
        + W_124
        + ((W_92 >> 3) ^ __ROR4__(W_92, 7) ^ __ROR4__(W_92, 18))
        + W_88;
  temp1bl = (__ROR4__(Gj, 6) ^ __ROR4__(Gj, 11) ^ __ROR4__(Gj, 25)) + Bi + (Ai ^ (Hi ^ Ai) & Gj) + W_152 - 2117940946;
  Fj = temp1bl + Fi;
  Bj = (Ei & (Cj | Di) | Cj & Di) + (__ROR4__(Cj, 2) ^ __ROR4__(Cj, 13) ^ __ROR4__(Cj, 22)) + temp1bl;
  W_156 = (__ROR4__(W_148, 17) ^ __ROR4__(W_148, 19) ^ (W_148 >> 10))
        + W_128
        + ((W_96 >> 3) ^ __ROR4__(W_96, 7) ^ __ROR4__(W_96, 18))
        + W_92;
  temp1bm = (__ROR4__(Fj, 6) ^ __ROR4__(Fj, 11) ^ __ROR4__(Fj, 25)) + Ai + (Hi ^ (Gj ^ Hi) & Fj) + W_156 - 1838011259;
  Ej = temp1bm + Ei;
  Aj = (Di & (Bj | Cj) | Bj & Cj) + (__ROR4__(Bj, 2) ^ __ROR4__(Bj, 13) ^ __ROR4__(Bj, 22)) + temp1bm;
  W_160 = (__ROR4__(W_152, 17) ^ __ROR4__(W_152, 19) ^ (W_152 >> 10))
        + W_132
        + ((W_100 >> 3) ^ __ROR4__(W_100, 7) ^ __ROR4__(W_100, 18))
        + W_96;
  temp1bn = (__ROR4__(Ej, 6) ^ __ROR4__(Ej, 11) ^ __ROR4__(Ej, 25)) + Hi + (Gj ^ (Fj ^ Gj) & Ej) + W_160 - 1564481375;
  Dj = temp1bn + Di;
  Hj = (Cj & (Aj | Bj) | Aj & Bj) + (__ROR4__(Aj, 2) ^ __ROR4__(Aj, 13) ^ __ROR4__(Aj, 22)) + temp1bn;
  W_164 = (__ROR4__(W_156, 17) ^ __ROR4__(W_156, 19) ^ (W_156 >> 10))
        + W_136
        + ((W_104 >> 3) ^ __ROR4__(W_104, 7) ^ __ROR4__(W_104, 18))
        + W_100;
  temp1bo = (__ROR4__(Dj, 6) ^ __ROR4__(Dj, 11) ^ __ROR4__(Dj, 25)) + Gj + (Fj ^ (Ej ^ Fj) & Dj) + W_164 - 1474664885;
  Ck = temp1bo + Cj;
  Gk = (Bj & (Hj | Aj) | Hj & Aj) + (__ROR4__(Hj, 2) ^ __ROR4__(Hj, 13) ^ __ROR4__(Hj, 22)) + temp1bo;
  W_168 = (__ROR4__(W_160, 17) ^ __ROR4__(W_160, 19) ^ (W_160 >> 10))
        + W_140
        + ((W_108 >> 3) ^ __ROR4__(W_108, 7) ^ __ROR4__(W_108, 18))
        + W_104;
  temp1bp = (__ROR4__(Ck, 6) ^ __ROR4__(Ck, 11) ^ __ROR4__(Ck, 25)) + Fj + (Ej ^ (Dj ^ Ej) & Ck) + W_168 - 1035236496;
  Bk = temp1bp + Bj;
  Fk = (Aj & (Gk | Hj) | Gk & Hj) + (__ROR4__(Gk, 2) ^ __ROR4__(Gk, 13) ^ __ROR4__(Gk, 22)) + temp1bp;
  W_172 = (__ROR4__(W_164, 17) ^ __ROR4__(W_164, 19) ^ (W_164 >> 10))
        + W_144
        + ((W_112 >> 3) ^ __ROR4__(W_112, 7) ^ __ROR4__(W_112, 18))
        + W_108;
  temp1bq = (__ROR4__(Bk, 6) ^ __ROR4__(Bk, 11) ^ __ROR4__(Bk, 25)) + Ej + (Dj ^ (Ck ^ Dj) & Bk) + W_172 - 949202525;
  Ak = temp1bq + Aj;
  Ek = (Hj & (Fk | Gk) | Fk & Gk) + (__ROR4__(Fk, 2) ^ __ROR4__(Fk, 13) ^ __ROR4__(Fk, 22)) + temp1bq;
  W_176 = (__ROR4__(W_168, 17) ^ __ROR4__(W_168, 19) ^ (W_168 >> 10))
        + W_148
        + ((W_116 >> 3) ^ __ROR4__(W_116, 7) ^ __ROR4__(W_116, 18))
        + W_112;
  temp1br = (__ROR4__(Ak, 6) ^ __ROR4__(Ak, 11) ^ __ROR4__(Ak, 25)) + Dj + (Ck ^ (Bk ^ Ck) & Ak) + W_176 - 778901479;
  Hk = temp1br + Hj;
  Dk = (Gk & (Ek | Fk) | Ek & Fk) + (__ROR4__(Ek, 2) ^ __ROR4__(Ek, 13) ^ __ROR4__(Ek, 22)) + temp1br;
  W_180 = (__ROR4__(W_172, 17) ^ __ROR4__(W_172, 19) ^ (W_172 >> 10))
        + W_152
        + ((W_120 >> 3) ^ __ROR4__(W_120, 7) ^ __ROR4__(W_120, 18))
        + W_116;
  temp1bs = (__ROR4__(Hk, 6) ^ __ROR4__(Hk, 11) ^ __ROR4__(Hk, 25)) + Ck + (Bk ^ (Ak ^ Bk) & Hk) + W_180 - 694614492;
  Gl = temp1bs + Gk;
  Cl = (Fk & (Dk | Ek) | Dk & Ek) + (__ROR4__(Dk, 2) ^ __ROR4__(Dk, 13) ^ __ROR4__(Dk, 22)) + temp1bs;
  W_184 = (__ROR4__(W_176, 17) ^ __ROR4__(W_176, 19) ^ (W_176 >> 10))
        + W_156
        + ((W_124 >> 3) ^ __ROR4__(W_124, 7) ^ __ROR4__(W_124, 18))
        + W_120;
  temp1bt = (__ROR4__(Gl, 6) ^ __ROR4__(Gl, 11) ^ __ROR4__(Gl, 25)) + Bk + (Ak ^ (Hk ^ Ak) & Gl) + W_184 - 200395387;
  Fl = temp1bt + Fk;
  Bl = (Ek & (Cl | Dk) | Cl & Dk) + (__ROR4__(Cl, 2) ^ __ROR4__(Cl, 13) ^ __ROR4__(Cl, 22)) + temp1bt;
  W_188 = (__ROR4__(W_180, 17) ^ __ROR4__(W_180, 19) ^ (W_180 >> 10))
        + W_160
        + ((W_128 >> 3) ^ __ROR4__(W_128, 7) ^ __ROR4__(W_128, 18))
        + W_124;
  temp1bu = (__ROR4__(Fl, 6) ^ __ROR4__(Fl, 11) ^ __ROR4__(Fl, 25)) + Ak + (Hk ^ (Gl ^ Hk) & Fl) + W_188 + 275423344;
  El = temp1bu + Ek;
  Al = (Dk & (Bl | Cl) | Bl & Cl) + (__ROR4__(Bl, 2) ^ __ROR4__(Bl, 13) ^ __ROR4__(Bl, 22)) + temp1bu;
  W_192 = (__ROR4__(W_184, 17) ^ __ROR4__(W_184, 19) ^ (W_184 >> 10))
        + W_164
        + ((W_132 >> 3) ^ __ROR4__(W_132, 7) ^ __ROR4__(W_132, 18))
        + W_128;
  temp1bv = (__ROR4__(El, 6) ^ __ROR4__(El, 11) ^ __ROR4__(El, 25)) + Hk + (Gl ^ (Fl ^ Gl) & El) + W_192 + 430227734;
  Dl = temp1bv + Dk;
  Hl = (Cl & (Al | Bl) | Al & Bl) + (__ROR4__(Al, 2) ^ __ROR4__(Al, 13) ^ __ROR4__(Al, 22)) + temp1bv;
  W_196 = (__ROR4__(W_188, 17) ^ __ROR4__(W_188, 19) ^ (W_188 >> 10))
        + W_168
        + ((W_136 >> 3) ^ __ROR4__(W_136, 7) ^ __ROR4__(W_136, 18))
        + W_132;
  temp1bw = (__ROR4__(Dl, 6) ^ __ROR4__(Dl, 11) ^ __ROR4__(Dl, 25)) + Gl + (Fl ^ (El ^ Fl) & Dl) + W_196 + 506948616;
  Cm = temp1bw + Cl;
  Gm = (Bl & (Hl | Al) | Hl & Al) + (__ROR4__(Hl, 2) ^ __ROR4__(Hl, 13) ^ __ROR4__(Hl, 22)) + temp1bw;
  W_200 = (__ROR4__(W_192, 17) ^ __ROR4__(W_192, 19) ^ (W_192 >> 10))
        + W_172
        + ((W_140 >> 3) ^ __ROR4__(W_140, 7) ^ __ROR4__(W_140, 18))
        + W_136;
  temp1bx = (__ROR4__(Cm, 6) ^ __ROR4__(Cm, 11) ^ __ROR4__(Cm, 25)) + Fl + (El ^ (Dl ^ El) & Cm) + W_200 + 659060556;
  Bm = temp1bx + Bl;
  Fm = (Al & (Gm | Hl) | Gm & Hl) + (__ROR4__(Gm, 2) ^ __ROR4__(Gm, 13) ^ __ROR4__(Gm, 22)) + temp1bx;
  W_204 = (__ROR4__(W_196, 17) ^ __ROR4__(W_196, 19) ^ (W_196 >> 10))
        + W_176
        + ((W_144 >> 3) ^ __ROR4__(W_144, 7) ^ __ROR4__(W_144, 18))
        + W_140;
  temp1by = (__ROR4__(Bm, 6) ^ __ROR4__(Bm, 11) ^ __ROR4__(Bm, 25)) + El + (Dl ^ (Cm ^ Dl) & Bm) + W_204 + 883997877;
  Am = temp1by + Al;
  Em = (Hl & (Fm | Gm) | Fm & Gm) + (__ROR4__(Fm, 2) ^ __ROR4__(Fm, 13) ^ __ROR4__(Fm, 22)) + temp1by;
  W_208 = (__ROR4__(W_200, 17) ^ __ROR4__(W_200, 19) ^ (W_200 >> 10))
        + W_180
        + ((W_148 >> 3) ^ __ROR4__(W_148, 7) ^ __ROR4__(W_148, 18))
        + W_144;
  temp1bz = (__ROR4__(Am, 6) ^ __ROR4__(Am, 11) ^ __ROR4__(Am, 25)) + Dl + (Cm ^ (Bm ^ Cm) & Am) + W_208 + 958139571;
  Hm = temp1bz + Hl;
  Dm = (Gm & (Em | Fm) | Em & Fm) + (__ROR4__(Em, 2) ^ __ROR4__(Em, 13) ^ __ROR4__(Em, 22)) + temp1bz;
  W_212 = (__ROR4__(W_204, 17) ^ __ROR4__(W_204, 19) ^ (W_204 >> 10))
        + W_184
        + ((W_152 >> 3) ^ __ROR4__(W_152, 7) ^ __ROR4__(W_152, 18))
        + W_148;
  temp1ca = (__ROR4__(Hm, 6) ^ __ROR4__(Hm, 11) ^ __ROR4__(Hm, 25)) + Cm + (Bm ^ (Am ^ Bm) & Hm) + W_212 + 1322822218;
  Gn = temp1ca + Gm;
  Cn = (Fm & (Dm | Em) | Dm & Em) + (__ROR4__(Dm, 2) ^ __ROR4__(Dm, 13) ^ __ROR4__(Dm, 22)) + temp1ca;
  W_216 = (__ROR4__(W_208, 17) ^ __ROR4__(W_208, 19) ^ (W_208 >> 10))
        + W_188
        + ((W_156 >> 3) ^ __ROR4__(W_156, 7) ^ __ROR4__(W_156, 18))
        + W_152;
  temp1cb = (__ROR4__(Gn, 6) ^ __ROR4__(Gn, 11) ^ __ROR4__(Gn, 25)) + Bm + (Am ^ (Hm ^ Am) & Gn) + W_216 + 1537002063;
  Fn = temp1cb + Fm;
  Bn = (Em & (Cn | Dm) | Cn & Dm) + (__ROR4__(Cn, 2) ^ __ROR4__(Cn, 13) ^ __ROR4__(Cn, 22)) + temp1cb;
  W_220 = (__ROR4__(W_212, 17) ^ __ROR4__(W_212, 19) ^ (W_212 >> 10))
        + W_192
        + ((W_160 >> 3) ^ __ROR4__(W_160, 7) ^ __ROR4__(W_160, 18))
        + W_156;
  temp1cc = (__ROR4__(Fn, 6) ^ __ROR4__(Fn, 11) ^ __ROR4__(Fn, 25)) + Am + (Hm ^ (Gn ^ Hm) & Fn) + W_220 + 1747873779;
  En = temp1cc + Em;
  An = (Dm & (Bn | Cn) | Bn & Cn) + (__ROR4__(Bn, 2) ^ __ROR4__(Bn, 13) ^ __ROR4__(Bn, 22)) + temp1cc;
  W_224 = (__ROR4__(W_216, 17) ^ __ROR4__(W_216, 19) ^ (W_216 >> 10))
        + W_196
        + ((W_164 >> 3) ^ __ROR4__(W_164, 7) ^ __ROR4__(W_164, 18))
        + W_160;
  temp1cd = (__ROR4__(En, 6) ^ __ROR4__(En, 11) ^ __ROR4__(En, 25)) + Hm + (Gn ^ (Fn ^ Gn) & En) + W_224 + 1955562222;
  Dn = temp1cd + Dm;
  Hn = (Cn & (An | Bn) | An & Bn) + (__ROR4__(An, 2) ^ __ROR4__(An, 13) ^ __ROR4__(An, 22)) + temp1cd;
  W_228 = (__ROR4__(W_220, 17) ^ __ROR4__(W_220, 19) ^ (W_220 >> 10))
        + W_200
        + ((W_168 >> 3) ^ __ROR4__(W_168, 7) ^ __ROR4__(W_168, 18))
        + W_164;
  temp1ce = (__ROR4__(Dn, 6) ^ __ROR4__(Dn, 11) ^ __ROR4__(Dn, 25)) + Gn + (Fn ^ (En ^ Fn) & Dn) + W_228 + 2024104815;
  Co = temp1ce + Cn;
  Go = (Bn & (Hn | An) | Hn & An) + (__ROR4__(Hn, 2) ^ __ROR4__(Hn, 13) ^ __ROR4__(Hn, 22)) + temp1ce;
  W_232 = (__ROR4__(W_224, 17) ^ __ROR4__(W_224, 19) ^ (W_224 >> 10))
        + W_204
        + ((W_172 >> 3) ^ __ROR4__(W_172, 7) ^ __ROR4__(W_172, 18))
        + W_168;
  temp1cf = (__ROR4__(Co, 6) ^ __ROR4__(Co, 11) ^ __ROR4__(Co, 25)) + Fn + (En ^ (Dn ^ En) & Co) + W_232 - 2067236844;
  Bo = temp1cf + Bn;
  Fo = (An & (Go | Hn) | Go & Hn) + (__ROR4__(Go, 2) ^ __ROR4__(Go, 13) ^ __ROR4__(Go, 22)) + temp1cf;
  W_236 = (__ROR4__(W_228, 17) ^ __ROR4__(W_228, 19) ^ (W_228 >> 10))
        + W_208
        + ((W_176 >> 3) ^ __ROR4__(W_176, 7) ^ __ROR4__(W_176, 18))
        + W_172;
  temp1cg = (__ROR4__(Bo, 6) ^ __ROR4__(Bo, 11) ^ __ROR4__(Bo, 25)) + En + (Dn ^ (Co ^ Dn) & Bo) + W_236 - 1933114872;
  Ao = temp1cg + An;
  Eo = (Hn & (Fo | Go) | Fo & Go) + (__ROR4__(Fo, 2) ^ __ROR4__(Fo, 13) ^ __ROR4__(Fo, 22)) + temp1cg;
  W_240 = (__ROR4__(W_232, 17) ^ __ROR4__(W_232, 19) ^ (W_232 >> 10))
        + W_212
        + ((W_180 >> 3) ^ __ROR4__(W_180, 7) ^ __ROR4__(W_180, 18))
        + W_176;
  temp1ch = (__ROR4__(Ao, 6) ^ __ROR4__(Ao, 11) ^ __ROR4__(Ao, 25)) + Dn + (Co ^ (Bo ^ Co) & Ao) + W_240 - 1866530822;
  Ho = temp1ch + Hn;
  Do = (Go & (Eo | Fo) | Eo & Fo) + (__ROR4__(Eo, 2) ^ __ROR4__(Eo, 13) ^ __ROR4__(Eo, 22)) + temp1ch;
  W_244 = (__ROR4__(W_236, 17) ^ __ROR4__(W_236, 19) ^ (W_236 >> 10))
        + W_216
        + ((W_184 >> 3) ^ __ROR4__(W_184, 7) ^ __ROR4__(W_184, 18))
        + W_180;
  temp1ci = (__ROR4__(Ho, 6) ^ __ROR4__(Ho, 11) ^ __ROR4__(Ho, 25)) + Co + (Bo ^ (Ao ^ Bo) & Ho) + W_244 - 1538233109;
  Gp = temp1ci + Go;
  Cp = (Fo & (Do | Eo) | Do & Eo) + (__ROR4__(Do, 2) ^ __ROR4__(Do, 13) ^ __ROR4__(Do, 22)) + temp1ci;
  temp1cj = (__ROR4__(Gp, 6) ^ __ROR4__(Gp, 11) ^ __ROR4__(Gp, 25))
          + Bo
          + (Ao ^ (Ho ^ Ao) & Gp)
          + (__ROR4__(W_240, 17) ^ __ROR4__(W_240, 19) ^ (W_240 >> 10))
          + W_220
          + ((W_188 >> 3) ^ __ROR4__(W_188, 7) ^ __ROR4__(W_188, 18))
          + W_184
          - 1090935817;
  Fp = temp1cj + Fo;
  Bp = (Eo & (Cp | Do) | Cp & Do) + (__ROR4__(Cp, 2) ^ __ROR4__(Cp, 13) ^ __ROR4__(Cp, 22)) + temp1cj;
  temp1ck = (__ROR4__(Fp, 6) ^ __ROR4__(Fp, 11) ^ __ROR4__(Fp, 25))
          + Ao
          + (Ho ^ (Gp ^ Ho) & Fp)
          + (__ROR4__(W_244, 17) ^ __ROR4__(W_244, 19) ^ (W_244 >> 10))
          + W_224
          + ((W_192 >> 3) ^ __ROR4__(W_192, 7) ^ __ROR4__(W_192, 18))
          + W_188
          - 965641998;
  ctx->state[0] += (Do & (Bp | Cp) | Bp & Cp) + (__ROR4__(Bp, 2) ^ __ROR4__(Bp, 13) ^ __ROR4__(Bp, 22)) + temp1ck;
  ctx->state[1] += Bp;
  ctx->state[2] += Cp;
  ctx->state[3] += Do;
  ctx->state[4] += temp1ck + Eo;
  ctx->state[5] += Fp;
  ctx->state[6] += Gp;
  ctx->state[7] += Ho;
}

//----- (00032060) --------------------------------------------------------
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  signed int ilena; // [sp+4h] [bp+4h]
  const unsigned __int8 *inputa; // [sp+8h] [bp+8h]
  signed int fill; // [sp+10h] [bp+10h]
  uint32_t left; // [sp+14h] [bp+14h]

  inputa = input;
  ilena = ilen;
  if ( ilen > 0 )
  {
    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    ctx->total[0] += ilen;
    ctx->total[0] = ctx->total[0];
    if ( ctx->total[0] < ilen )
      ++ctx->total[1];
    if ( left && ilen >= fill )
    {
      memcpy(&ctx->buffer[left], input, fill);
      sha2_process(ctx, ctx->buffer);
      inputa += fill;
      ilena -= fill;
      left = 0;
    }
    while ( ilena > 63 )
    {
      sha2_process(ctx, inputa);
      inputa += 64;
      ilena -= 64;
    }
    if ( ilena > 0 )
      memcpy(&ctx->buffer[left], inputa, ilena);
  }
}

//----- (00032130) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  uint32_t v2; // r3
  unsigned __int8 msglen[8]; // [sp+8h] [bp+8h] BYREF
  uint32_t padn; // [sp+10h] [bp+10h]
  uint32_t last; // [sp+14h] [bp+14h]
  __int64 low; // [sp+18h] [bp+18h] OVERLAPPED

  low = 8LL * *(_QWORD *)ctx->total;
  msglen[0] = HIBYTE(low);
  msglen[1] = BYTE6(low);
  msglen[2] = BYTE5(low);
  msglen[3] = BYTE4(low);
  msglen[4] = BYTE3(low);
  msglen[5] = BYTE2(low);
  msglen[6] = BYTE1(low);
  msglen[7] = low;
  last = ctx->total[0] & 0x3F;
  if ( last > 0x37 )
    v2 = 120 - last;
  else
    v2 = 56 - last;
  padn = v2;
  sha2_update(ctx, sha2_padding, v2);
  sha2_update(ctx, msglen, 8);
  *output = HIBYTE(ctx->state[0]);
  output[1] = BYTE2(ctx->state[0]);
  output[2] = BYTE1(ctx->state[0]);
  output[3] = ctx->state[0];
  output[4] = HIBYTE(ctx->state[1]);
  output[5] = BYTE2(ctx->state[1]);
  output[6] = BYTE1(ctx->state[1]);
  output[7] = ctx->state[1];
  output[8] = HIBYTE(ctx->state[2]);
  output[9] = BYTE2(ctx->state[2]);
  output[10] = BYTE1(ctx->state[2]);
  output[11] = ctx->state[2];
  output[12] = HIBYTE(ctx->state[3]);
  output[13] = BYTE2(ctx->state[3]);
  output[14] = BYTE1(ctx->state[3]);
  output[15] = ctx->state[3];
  output[16] = HIBYTE(ctx->state[4]);
  output[17] = BYTE2(ctx->state[4]);
  output[18] = BYTE1(ctx->state[4]);
  output[19] = ctx->state[4];
  output[20] = HIBYTE(ctx->state[5]);
  output[21] = BYTE2(ctx->state[5]);
  output[22] = BYTE1(ctx->state[5]);
  output[23] = ctx->state[5];
  output[24] = HIBYTE(ctx->state[6]);
  output[25] = BYTE2(ctx->state[6]);
  output[26] = BYTE1(ctx->state[6]);
  output[27] = ctx->state[6];
  output[28] = HIBYTE(ctx->state[7]);
  output[29] = BYTE2(ctx->state[7]);
  output[30] = BYTE1(ctx->state[7]);
  output[31] = ctx->state[7];
}
// 32130: variables would overlap: ^18.8 and stkvar "low" ^18.4(has user info),stkvar "high" ^1C.4(has user info)

//----- (00032384) --------------------------------------------------------
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  sha2_context ctx; // [sp+10h] [bp+10h] BYREF

  sha2_starts(&ctx);
  sha2_update(&ctx, input, ilen);
  sha2_finish(&ctx, output);
  memset(&ctx, 0, sizeof(ctx));
}

//----- (000323CC) --------------------------------------------------------
uint32_t __cdecl swab32(uint32_t v)
{
  return bswap32(v);
}

//----- (000323E4) --------------------------------------------------------
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; length >> 2 > i; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00032434) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (0003247C) --------------------------------------------------------
void __cdecl push_nonce(nonce_rb_format *nonce_item)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF

  pthread_mutex_lock(&nonce_mutex);
  memcpy(&nonce_fifo.nonce_buffer[nonce_fifo.p_wr], nonce_item, sizeof(nonce_fifo.nonce_buffer[nonce_fifo.p_wr]));
  if ( nonce_fifo.p_wr >= 0x1FE )
    nonce_fifo.p_wr = 0;
  else
    ++nonce_fifo.p_wr;
  if ( nonce_fifo.nonce_num > 0x1FE )
  {
    nonce_fifo.nonce_num = 511;
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: nonce fifo full!!!\n", (const char *)_FUNCTION___5961);
      applog(1, tmp42, 0);
    }
  }
  else
  {
    ++nonce_fifo.nonce_num;
  }
  pthread_mutex_unlock(&nonce_mutex);
}

//----- (00032598) --------------------------------------------------------
void clear_register_value_buf()
{
  pthread_mutex_lock(&nonce_mutex);
  nonce_fifo.p_wr = 0;
  nonce_fifo.p_rd = 0;
  nonce_fifo.nonce_num = 0;
  pthread_mutex_unlock(&nonce_mutex);
}

//----- (000325DC) --------------------------------------------------------
void __cdecl pop_nonce(nonce_rb_format *nonce_tmp)
{
  pthread_mutex_lock(&nonce_mutex);
  --nonce_fifo.nonce_num;
  memcpy(nonce_tmp, &nonce_fifo.nonce_buffer[nonce_fifo.p_rd], sizeof(nonce_rb_format));
  if ( nonce_fifo.p_rd >= 0x1FE )
    nonce_fifo.p_rd = 0;
  else
    ++nonce_fifo.p_rd;
  pthread_mutex_unlock(&nonce_mutex);
}

//----- (0003267C) --------------------------------------------------------
void __cdecl nonce_fifo_num(int *num)
{
  pthread_mutex_lock(&nonce_mutex);
  *num = nonce_fifo.nonce_num;
  pthread_mutex_unlock(&nonce_mutex);
}

//----- (000326B4) --------------------------------------------------------
int __cdecl add_reg_item(reg_list_item_t item)
{
  int i; // [sp+14h] [bp+14h]

  pthread_mutex_lock(&rs.reg_list_mutex);
  for ( i = 0; i <= 99; ++i )
  {
    if ( rs.reg_list_items[i].age < 0 )
    {
      rs.reg_list_items[i] = item;
      pthread_mutex_unlock(&rs.reg_list_mutex);
      return 1;
    }
  }
  pthread_mutex_unlock(&rs.reg_list_mutex);
  return -1;
}

//----- (00032738) --------------------------------------------------------
int __cdecl read_reg_item(reg_list_item_t *item, int ms)
{
  int v3; // r3
  int i; // [sp+10h] [bp+10h]
  int check_times; // [sp+14h] [bp+14h]

  check_times = ms % 50 + ms / 50;
  do
  {
    usleep(0xC350u);
    pthread_mutex_lock(&rs.reg_list_mutex);
    for ( i = 0; i <= 99; ++i )
    {
      if ( rs.reg_list_items[i].chainid == item->chainid
        && rs.reg_list_items[i].chip_addr == item->chip_addr
        && rs.reg_list_items[i].reg_addr == item->reg_addr
        && rs.reg_list_items[i].age >= 0 )
      {
        item->reg_data = rs.reg_list_items[i].reg_data;
        rs.reg_list_items[i].age = -1;
        pthread_mutex_unlock(&rs.reg_list_mutex);
        return 1;
      }
    }
    pthread_mutex_unlock(&rs.reg_list_mutex);
    v3 = check_times--;
  }
  while ( v3 > 0 );
  return -1;
}

//----- (00032868) --------------------------------------------------------
void *reg_list_aging()
{
  pthread_t v0; // r0
  int i; // [sp+4h] [bp+4h]

  v0 = pthread_self();
  pthread_detach(v0);
  while ( rs.alive == 1 )
  {
    sleep(1u);
    pthread_mutex_lock(&rs.reg_list_mutex);
    for ( i = 0; i <= 99; ++i )
    {
      if ( rs.reg_list_items[i].age >= 0 )
        --rs.reg_list_items[i].age;
    }
    pthread_mutex_unlock(&rs.reg_list_mutex);
  }
  return 0;
}

//----- (000328F4) --------------------------------------------------------
void reg_list_init()
{
  int id; // [sp+4h] [bp+4h]

  rs.alive = 1;
  pthread_mutex_init(&rs.reg_list_mutex, 0);
  rs.reg_list_items = (reg_list_item_t *)calloc(0xCu, 0x64u);
  for ( id = 0; id <= 99; ++id )
    rs.reg_list_items[id].age = -1;
  pthread_create(&rs.p_reg_list, 0, (void *(*)(void *))reg_list_aging, 0);
}

//----- (00032974) --------------------------------------------------------
void reg_list_exit()
{
  rs.alive = 0;
  usleep(0x16E360u);
  pthread_cancel(rs.p_reg_list);
  pthread_join(rs.p_reg_list, 0);
  free(rs.reg_list_items);
  pthread_mutex_destroy(&rs.reg_list_mutex);
}

//----- (000329D0) --------------------------------------------------------
void *__cdecl nonce_scanhash(void *args)
{
  uint8_t work[140]; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 tmp42[1024]; // [sp+ACh] [bp+94h] BYREF
  nonce_rb_format nonce_tmp; // [sp+4ACh] [bp+494h] BYREF
  int ticket_mask; // [sp+9FCh] [bp+9E4h] BYREF
  int nonceNum; // [sp+A00h] [bp+9E8h] BYREF
  int valid; // [sp+A04h] [bp+9ECh]
  int chainid; // [sp+A08h] [bp+9F0h]
  runtime_base_t *runtime; // [sp+A0Ch] [bp+9F4h]
  int asic; // [sp+A10h] [bp+9F8h]
  int asic_index; // [sp+A14h] [bp+9FCh]

  runtime = (runtime_base_t *)args;
  nonceNum = 0;
  nonce_fifo_num(&nonceNum);
  while ( nonceNum )
  {
    --nonceNum;
    pop_nonce(&nonce_tmp);
    chainid = nonce_tmp.chain_id;
    memset(work, 0, sizeof(work));
    work_list_find(nonce_tmp.work_id, work);
    memcpy(&runtime->nonce_verify_info, work, runtime->nonce_verify_info.work_len);
    memcpy(runtime->nonce_verify_info.nonce, nonce_tmp.chip_nonce, runtime->nonce_verify_info.nonce_len);
    memcpy(runtime->nonce_verify_info.sol, &nonce_tmp, runtime->nonce_verify_info.sol_len);
    memset(runtime->nonce_verify_info.target, 0, runtime->nonce_verify_info.target_len);
    ticket_mask = 0;
    valid = runtime->nonce_verify(&runtime->nonce_verify_info, &ticket_mask, runtime->nonce_shift);
    if ( runtime->new_block )
    {
      runtime->new_block = 0;
      memset(
        runtime->chain_status[chainid].one_work_nonce_each_asic,
        0,
        4 * runtime->chain_status[chainid].design_asic_num);
      memset(
        runtime->chain_status[chainid].one_work_invalid_nonce_each_asic,
        0,
        4 * runtime->chain_status[chainid].design_asic_num);
      memset(
        runtime->chain_status[chainid].one_work_invalid_nonce_each_asic_type,
        0,
        12 * runtime->chain_status[chainid].design_asic_num);
    }
    if ( valid )
    {
      ++runtime->invalid_nonce_total;
      for ( asic = 0; asic <= 2; ++asic )
      {
        if ( nonce_tmp.chip_addr / runtime->addr_interval == asic )
        {
          ++runtime->chain_status[chainid].nonce_invalid_num_each_asic[asic];
          ++runtime->chain_status[chainid].one_work_invalid_nonce_each_asic[asic];
          if ( valid == 1 )
          {
            ++runtime->chain_status[chainid].one_work_invalid_nonce_each_asic_type[asic][1];
          }
          else if ( valid == 2 )
          {
            ++runtime->chain_status[chainid].one_work_invalid_nonce_each_asic_type[asic][2];
          }
          if ( use_syslog || opt_log_output || opt_log_level >= 0 )
          {
            snprintf(
              (char *)tmp42,
              0x400u,
              "Fail:invalid nonce: chainid=%d chipaddr=%02x nonces=%d tm=%d errtype=%d\n",
              chainid,
              nonce_tmp.chip_addr,
              runtime->chain_status[chainid].one_work_invalid_nonce_each_asic[asic],
              ticket_mask,
              valid);
            applog(0, tmp42, 0);
          }
        }
      }
    }
    else
    {
      ++runtime->valid_nonce_total;
      for ( asic_index = 0; asic_index <= 2; ++asic_index )
      {
        if ( nonce_tmp.chip_addr / runtime->addr_interval == asic_index )
        {
          ++runtime->chain_status[chainid].one_work_nonce_each_asic[asic_index];
          ++runtime->chain_status[chainid].nonce_num_each_asic[asic_index];
          if ( g_patten.start )
            is_patten_match(asic_index, nonce_tmp.chip_nonce, nonce_tmp.Nonce);
          if ( use_syslog || opt_log_output || opt_log_level > 0 )
          {
            snprintf(
              (char *)tmp42,
              0x400u,
              "Success:valid nonce: chainid=%d chipaddr=%02x nonces=%d total=%d tm=%d err=%d\n",
              chainid,
              nonce_tmp.chip_addr,
              runtime->chain_status[chainid].one_work_nonce_each_asic[asic_index],
              runtime->submit_nonce,
              ticket_mask,
              valid);
            applog(1, tmp42, 0);
          }
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
          {
            snprintf(
              (char *)tmp42,
              0x400u,
              "SHA256:%02x%02x%02x%02x\n",
              nonce_tmp.sha256[0],
              nonce_tmp.sha256[1],
              nonce_tmp.sha256[2],
              nonce_tmp.sha256[3]);
            applog(4, tmp42, 0);
          }
        }
      }
      if ( app_conf->work_mode == 1
        && ((int (__fastcall *)(uint8_t *, zcash_work_info *))runtime->nonce_verify_target_match)(
             runtime->nonce_verify_info.target,
             &g_work_info) )
      {
        runtime->nonce_submit(
          (uint8_t *)&nonce_tmp,
          (uint8_t *)&runtime->nonce_verify_info,
          g_work_info.fixed_nonce_bytes,
          g_work_info.job_id);
      }
    }
  }
  return 0;
}

//----- (00033024) --------------------------------------------------------
void *__cdecl __noreturn nonce_scanhash_loop(void *args)
{
  pthread_t send_id; // [sp+8h] [bp+8h] BYREF
  runtime_base_t *runtime; // [sp+Ch] [bp+Ch]

  runtime = (runtime_base_t *)args;
  while ( 1 )
  {
    if ( runtime->start_recv )
    {
      pthread_create(&send_id, 0, (void *(*)(void *))nonce_scanhash, args);
      pthread_join(send_id, 0);
      usleep(0x3E8u);
    }
    else
    {
      pthread_testcancel();
      usleep(0x186A0u);
    }
  }
}

//----- (00033074) --------------------------------------------------------
void __cdecl add_point(int *point, int MAX_SIZE)
{
  if ( ++*point >= MAX_SIZE )
    *point = 0;
}

//----- (000330A4) --------------------------------------------------------
void *__cdecl __noreturn handle_asic_response(void *args)
{
  int v1; // r3
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  uint8_t header[3]; // [sp+408h] [bp+408h] BYREF
  int p_header; // [sp+40Ch] [bp+40Ch] BYREF
  int data_buf_wp; // [sp+410h] [bp+410h] BYREF
  int data_buf_rp; // [sp+414h] [bp+414h] BYREF
  int max; // [sp+418h] [bp+418h]
  uint8_t *tmp; // [sp+41Ch] [bp+41Ch]
  uint8_t *data_buf; // [sp+420h] [bp+420h]
  int data_buf_len; // [sp+424h] [bp+424h]
  uint8_t *receive_buf; // [sp+428h] [bp+428h]
  int resp_nonce_len; // [sp+42Ch] [bp+42Ch]
  int chainid; // [sp+430h] [bp+430h]
  runtime_base_t *runtime; // [sp+434h] [bp+434h]
  int i; // [sp+438h] [bp+438h]
  int len; // [sp+43Ch] [bp+43Ch]

  runtime = (runtime_base_t *)args;
  chainid = *((_DWORD *)args + 443);
  len = 0;
  resp_nonce_len = *((_DWORD *)args + 37) * *((_DWORD *)args + 36);
  receive_buf = (uint8_t *)calloc(1u, resp_nonce_len);
  data_buf_len = 50 * resp_nonce_len;
  data_buf = (uint8_t *)calloc(50 * resp_nonce_len, 1u);
  data_buf_rp = 0;
  data_buf_wp = 0;
  tmp = (uint8_t *)calloc(1u, runtime->asic_data_info.resp_frame_max_len);
  if ( !tmp )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s calloc tmp failed\n", (const char *)_func___8704);
      applog(2, tmp42, 0);
    }
    exit(1);
  }
  max = data_buf_len;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "Start A New Asic Response.Chain Id:[%d]\n", chainid);
    applog(2, tmp42, 0);
  }
  while ( 1 )
  {
    do
    {
LABEL_11:
      while ( !runtime->start_recv )
      {
        pthread_testcancel();
        usleep(0x186A0u);
      }
      usleep(0x1F4u);
      memset(receive_buf, 0, resp_nonce_len);
      len = uart_receive(runtime->chain_status[chainid].fd, receive_buf, resp_nonce_len);
      for ( i = 0; i < len; ++i )
      {
        data_buf[data_buf_wp] = receive_buf[i];
        add_point(&data_buf_wp, max);
      }
    }
    while ( data_buf_rp == data_buf_wp );
    if ( data_buf_wp <= data_buf_rp )
      v1 = data_buf_wp + data_buf_len - data_buf_rp;
    else
      v1 = data_buf_wp - data_buf_rp;
    len = v1;
    while ( len > 2 )
    {
      p_header = data_buf_rp;
      memset(header, 0, sizeof(header));
      for ( i = 0; i <= 2; ++i )
      {
        header[i] = data_buf[p_header];
        add_point(&p_header, max);
      }
      if ( header[0] == 170 && header[1] == 85 )
      {
        if ( (header[2] & 0xF0) == 224 )
        {
          if ( runtime->asic_data_info.resp_nonce_frame_len > len )
            goto LABEL_11;
          for ( i = 0; runtime->asic_data_info.resp_nonce_frame_len > i; ++i )
          {
            tmp[i] = data_buf[data_buf_rp];
            add_point(&data_buf_rp, max);
          }
          len -= runtime->asic_data_info.resp_nonce_frame_len;
          runtime->nonce_handle(tmp, runtime->asic_data_info.resp_nonce_frame_len, chainid, runtime->addr_interval);
        }
        else if ( header[2] == 204 )
        {
          if ( runtime->asic_data_info.resp_pm_len > len )
            goto LABEL_11;
          for ( i = 0; runtime->asic_data_info.resp_pm_len > i; ++i )
          {
            tmp[i] = data_buf[data_buf_rp];
            add_point(&data_buf_rp, max);
          }
          len -= runtime->asic_data_info.resp_pm_len;
          runtime->pm_handle(tmp, runtime->asic_data_info.resp_pm_len, chainid);
        }
        else if ( header[2] == 208 )
        {
          if ( runtime->asic_data_info.resp_pt_len > len )
            goto LABEL_11;
          for ( i = 0; runtime->asic_data_info.resp_pt_len > i; ++i )
          {
            tmp[i] = data_buf[data_buf_rp];
            add_point(&data_buf_rp, max);
          }
          len -= runtime->asic_data_info.resp_pt_len;
          runtime->pt_handle(tmp, runtime->asic_data_info.resp_pt_len, chainid);
        }
        else
        {
          if ( runtime->asic_data_info.resp_reg_len > len )
            goto LABEL_11;
          for ( i = 0; runtime->asic_data_info.resp_reg_len > i; ++i )
          {
            tmp[i] = data_buf[data_buf_rp];
            add_point(&data_buf_rp, max);
          }
          len -= runtime->asic_data_info.resp_reg_len;
          runtime->reg_handle(tmp, runtime->asic_data_info.resp_reg_len, chainid);
        }
      }
      else
      {
        add_point(&data_buf_rp, max);
        --len;
      }
    }
  }
}

//----- (000335C8) --------------------------------------------------------
void __cdecl runtime_init(runtime_base_t *runtime)
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  int chainid; // [sp+40Ch] [bp+40Ch]

  work_list_init(runtime->nonce_verify_info.work_len);
  reg_list_init();
  chainid = runtime->chain_id;
  sleep(1u);
  pthread_create(&runtime->chain_status[chainid].p_dispatch, 0, (void *(*)(void *))handle_asic_response, runtime);
  pthread_create(&runtime->p_scanhash, 0, (void *(*)(void *))nonce_scanhash_loop, runtime);
  runtime->start_recv = 1;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s Done!\n", (const char *)_func___8737);
    applog(2, tmp42, 0);
  }
}

//----- (000336A4) --------------------------------------------------------
void __cdecl runtime_exit(runtime_base_t *runtime)
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  int chainid; // [sp+40Ch] [bp+40Ch]

  runtime->start_recv = 0;
  chainid = runtime->chain_id;
  usleep((__useconds_t)&buf_7545[4072]);
  pthread_cancel(runtime->p_scanhash);
  pthread_join(runtime->p_scanhash, 0);
  pthread_cancel(runtime->chain_status[chainid].p_dispatch);
  pthread_join(runtime->chain_status[chainid].p_dispatch, 0);
  reg_list_exit();
  work_list_exit();
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s Done!\n", (const char *)_func___8743);
    applog(2, tmp42, 0);
  }
}

//----- (00033790) --------------------------------------------------------
void __cdecl work_list_init(int work_len)
{
  int i; // [sp+Ch] [bp+Ch]

  memset(&work_list_info, 0, sizeof(work_list_info));
  work_list_info.work_len = work_len;
  pthread_mutex_init(&work_list_info.work_list_mutex, 0);
  for ( i = 0; i <= 9; ++i )
    work_list_info.work_list[i].work = (uint8_t *)calloc(work_len, 1u);
}

//----- (000337F8) --------------------------------------------------------
void work_list_exit()
{
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 9; ++i )
    free(work_list_info.work_list[i].work);
  pthread_mutex_destroy(&work_list_info.work_list_mutex);
}

//----- (00033838) --------------------------------------------------------
void __cdecl work_list_insert(uint8_t workid, uint8_t *work)
{
  pthread_mutex_lock(&work_list_info.work_list_mutex);
  work_list_info.work_list[work_list_info.work_list_insert_index].workid = workid;
  memcpy(work_list_info.work_list[work_list_info.work_list_insert_index].work, work, work_list_info.work_len);
  if ( ++work_list_info.work_list_insert_index > 9 )
    work_list_info.work_list_insert_index = 0;
  pthread_mutex_unlock(&work_list_info.work_list_mutex);
}

//----- (000338D0) --------------------------------------------------------
void __cdecl work_list_find(uint8_t workid, uint8_t *work)
{
  int i; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&work_list_info.work_list_mutex);
  for ( i = 0; i <= 9; ++i )
  {
    if ( workid == work_list_info.work_list[i].workid )
    {
      memcpy(work, work_list_info.work_list[i].work, work_list_info.work_len);
      break;
    }
  }
  pthread_mutex_unlock(&work_list_info.work_list_mutex);
}

//----- (00033BBE) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_33C00 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 33BC2: variable 'v2' is possibly undefined

//----- (00033E68) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00033E74) --------------------------------------------------------
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp)
{
  int i; // r4
  void (__fastcall *v4)(); // r3

  init_proc();
  for ( i = 0; i != 1; ++i )
  {
    v4 = (void (__fastcall *)())*(&_frame_dummy_init_array_entry + i);
    v4();
  }
}
// 47788: using guessed type void *_frame_dummy_init_array_entry;

//----- (00033EB8) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=434 queued=291 decompiled=291 lumina nreq=0 worse=0 better=0
// ALL OK, 291 function(s) have been successfully decompiled
