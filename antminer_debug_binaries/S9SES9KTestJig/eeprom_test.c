/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <fcntl.h>
#include <pthread.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_107D0();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// char *strstr(const char *haystack, const char *needle);
// int strcmp(const char *s1, const char *s2);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// void free(void *ptr);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// void *memcpy(void *dest, const void *src, size_t n);
// int ftell(FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
// void perror(const char *s);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int puts(const char *s);
// void *malloc(size_t size);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// char *strncpy(char *dest, const char *src, size_t n);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// int sprintf(char *s, const char *format, ...);
// int atoi(const char *nptr);
// int fseek(FILE *stream, int off, int whence);
// void abort(void);
// int close(int fd);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_weak_fn();
char *deregister_tm_clones();
int register_tm_clones(); // idb
char *_do_global_dtors_aux();
int frame_dummy(); // idb
void print_usage(); // idb
int __cdecl dump_eeprom(uint8_t chain);
int __cdecl tarverse_eeprom(uint8_t chain);
int __cdecl init_eeprom_all(unsigned __int8 *path);
int __cdecl update_version_info(uint8_t chain, uint8_t pcb, uint8_t bom);
int __cdecl erase_eeprom(uint8_t chain);
int __cdecl write_eeprom(uint8_t chain, int addr, uint8_t *buf, int len);
int __cdecl read_eeprom(uint8_t chain, int addr, int len);
int __cdecl main(int argc, const char **argv, const char **envp);
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len);
int check_chain_num(); // idb
unsigned int get_iic_0(); // idb
unsigned __int8 __cdecl set_iic(unsigned int data);
uint8_t __cdecl znyq_set_iic(unsigned __int8 dev_addr, unsigned __int8 which_iic, bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 data);
uint8_t __cdecl write_eeprom_iic(uint8_t chain, uint8_t reg_addr, uint8_t data);
uint8_t __cdecl read_eeprom_iic(uint8_t chain, uint8_t reg_addr);
void __cdecl eeprom_write_one_byte(uint8_t address, uint8_t data, uint8_t chain);
uint8_t __cdecl eeprom_read_one_byte(uint8_t address, uint8_t chain);
void __cdecl eeprom_write_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint8_t length);
void __cdecl eeprom_read_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint8_t length);
bool __cdecl eeprom_update_crc(uint8_t chain);
bool __cdecl eeprom_check_crc(uint8_t chain);
bool __cdecl eeprom_set_magic(uint8_t chain, uint8_t magic_num);
bool __cdecl eeprom_get_magic(uint8_t chain, uint8_t *magic_num);
void __cdecl write_eeprom_store_into_at24c02(eeprom_store_t *eeprom, uint8_t chain);
eeprom_store_t *__cdecl read_eeprom_store_from_at24c02(eeprom_store_t *eeprom_store, uint8_t chain);
bool __cdecl eeprom_set_freq(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_get_freq(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_set_freq_one_chain(uint8_t chain, uint8_t *buf, uint8_t buf_len);
bool __cdecl eeprom_get_freq_one_chain(uint8_t chain, uint8_t *buf, uint8_t buf_len);
bool __cdecl eeprom_set_voltage(uint8_t chain, double voltage);
bool __cdecl eeprom_get_voltage(uint8_t chain, double *voltage);
bool __cdecl eeprom_set_hashrate(uint8_t chain, uint32_t hash);
bool __cdecl eeprom_get_hashrate(uint8_t chain, uint32_t *hash);
void __cdecl convert_freq_array(uint8_t *chain_freq, uint16_t (*array)[9]);
void __cdecl travel_eeprom_store(uint8_t chain);
bool __cdecl eeprom_store_init(unsigned __int8 *path, eeprom_store_t **eeprom);
bool __cdecl eeprom_init(unsigned __int8 *path);
void __cdecl eeprom_dump(uint8_t chain);
void __cdecl eeprom_dump_raw(uint8_t chain);
void __cdecl eeprom_dump(uint8_t chain);
void __cdecl eeprom_erase(uint8_t chain);
void eeprom_erase_all(); // idb
bool __cdecl eeprom_write(uint8_t chain, uint32_t addr, uint8_t *buf, uint32_t len);
bool __cdecl eeprom_read(uint8_t chain, uint32_t addr, uint8_t *buf, uint32_t len);
bool __cdecl eeprom_set_inbalance_info(uint8_t chain, uint8_t *buf, uint32_t len);
bool __cdecl eeprom_get_inbalance_info(uint8_t chain, uint8_t *buf, uint32_t *len);
bool __cdecl eeprom_set_pcb_version(uint8_t chain, uint8_t pcb_version);
bool __cdecl eeprom_set_bom_version(uint8_t chain, uint8_t bom_version);
bool __cdecl eeprom_get_pcb_version(uint8_t chain, uint8_t *pcb_version);
bool __cdecl eeprom_get_bom_version(uint8_t chain, uint8_t *bom_version);
bool __cdecl set_freq_array(int flag, uint16_t (*freq_data)[9], int freq);
bool __cdecl conf_process(int chain, uint16_t (*freq_data)[9], const unsigned __int8 *str);
void __cdecl travel_array(uint16_t (*array)[9]);
bool __cdecl scan_eeprom_config_file(const unsigned __int8 *conf_file_path, uint16_t (*freq_data)[12][9]);
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

const unsigned __int8 eeprom_conf_file[64] =
{
  47u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  47u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  46u,
  99u,
  111u,
  110u,
  102u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const uint16_t def_freq_data[12][9] =
{
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u },
  { 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u, 275u }
}; // idb
const uint8_t chCRCHTalbe[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // idb
const uint8_t chCRCLTalbe[256] =
{
  0u,
  192u,
  193u,
  1u,
  195u,
  3u,
  2u,
  194u,
  198u,
  6u,
  7u,
  199u,
  5u,
  197u,
  196u,
  4u,
  204u,
  12u,
  13u,
  205u,
  15u,
  207u,
  206u,
  14u,
  10u,
  202u,
  203u,
  11u,
  201u,
  9u,
  8u,
  200u,
  216u,
  24u,
  25u,
  217u,
  27u,
  219u,
  218u,
  26u,
  30u,
  222u,
  223u,
  31u,
  221u,
  29u,
  28u,
  220u,
  20u,
  212u,
  213u,
  21u,
  215u,
  23u,
  22u,
  214u,
  210u,
  18u,
  19u,
  211u,
  17u,
  209u,
  208u,
  16u,
  240u,
  48u,
  49u,
  241u,
  51u,
  243u,
  242u,
  50u,
  54u,
  246u,
  247u,
  55u,
  245u,
  53u,
  52u,
  244u,
  60u,
  252u,
  253u,
  61u,
  255u,
  63u,
  62u,
  254u,
  250u,
  58u,
  59u,
  251u,
  57u,
  249u,
  248u,
  56u,
  40u,
  232u,
  233u,
  41u,
  235u,
  43u,
  42u,
  234u,
  238u,
  46u,
  47u,
  239u,
  45u,
  237u,
  236u,
  44u,
  228u,
  36u,
  37u,
  229u,
  39u,
  231u,
  230u,
  38u,
  34u,
  226u,
  227u,
  35u,
  225u,
  33u,
  32u,
  224u,
  160u,
  96u,
  97u,
  161u,
  99u,
  163u,
  162u,
  98u,
  102u,
  166u,
  167u,
  103u,
  165u,
  101u,
  100u,
  164u,
  108u,
  172u,
  173u,
  109u,
  175u,
  111u,
  110u,
  174u,
  170u,
  106u,
  107u,
  171u,
  105u,
  169u,
  168u,
  104u,
  120u,
  184u,
  185u,
  121u,
  187u,
  123u,
  122u,
  186u,
  190u,
  126u,
  127u,
  191u,
  125u,
  189u,
  188u,
  124u,
  180u,
  116u,
  117u,
  181u,
  119u,
  183u,
  182u,
  118u,
  114u,
  178u,
  179u,
  115u,
  177u,
  113u,
  112u,
  176u,
  80u,
  144u,
  145u,
  81u,
  147u,
  83u,
  82u,
  146u,
  150u,
  86u,
  87u,
  151u,
  85u,
  149u,
  148u,
  84u,
  156u,
  92u,
  93u,
  157u,
  95u,
  159u,
  158u,
  94u,
  90u,
  154u,
  155u,
  91u,
  153u,
  89u,
  88u,
  152u,
  136u,
  72u,
  73u,
  137u,
  75u,
  139u,
  138u,
  74u,
  78u,
  142u,
  143u,
  79u,
  141u,
  77u,
  76u,
  140u,
  68u,
  132u,
  133u,
  69u,
  135u,
  71u,
  70u,
  134u,
  130u,
  66u,
  67u,
  131u,
  65u,
  129u,
  128u,
  64u
}; // idb
void *_frame_dummy_init_array_entry = (void *)0x10A25; // weak
char completed_9251; // weak
pthread_mutex_t iic_mutex; // idb
int chain_num; // idb
unsigned int *axi_fpga_addr; // idb
int chain_list[16]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (000107C4) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (000107D0) --------------------------------------------------------
void sub_107D0()
{
  JUMPOUT(0);
}
// 107DC: control flows out of bounds to 0

//----- (00010968) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    _libc_csu_fini,
    a1,
    va);
  abort();
}
// 10972: positive sp value 4 has been found
// 10984: variable 'v4' is possibly undefined

//----- (00010998) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 108BC: using guessed type int _gmon_start__(void);

//----- (000109BC) --------------------------------------------------------
char *deregister_tm_clones()
{
  return &completed_9251;
}
// 23D70: using guessed type char completed_9251;

//----- (000109E0) --------------------------------------------------------
int register_tm_clones()
{
  return 146800;
}

//----- (00010A0C) --------------------------------------------------------
char *_do_global_dtors_aux()
{
  char *result; // r0

  if ( !completed_9251 )
  {
    result = deregister_tm_clones();
    completed_9251 = 1;
  }
  return result;
}
// 23D70: using guessed type char completed_9251;

//----- (00010A24) --------------------------------------------------------
int frame_dummy()
{
  return register_tm_clones();
}

//----- (00010A48) --------------------------------------------------------
void print_usage()
{
  puts("eeprom_test help:");
  puts(" -d [chain]                         dump eeprom");
  puts(" -l [chain]                         traverse eeprom friendly");
  puts(" -i [config file path]              init all eeprom with config file");
  puts(" -e [chain]                         erase eeprom");
  puts(" -w [chain] [eeprom addr] [data0 ...]    write eeprom");
  puts(" -r [chain] [eeprom addr] [length]  read eeprom");
  puts(" -p [chain] [pcb_ver] [bom_ver]      update PCB & BOM version");
}

//----- (00010AB0) --------------------------------------------------------
int __cdecl dump_eeprom(uint8_t chain)
{
  if ( chain_list[chain] )
  {
    eeprom_dump_raw(chain);
    return 0;
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return -1;
  }
}

//----- (00010AF4) --------------------------------------------------------
int __cdecl tarverse_eeprom(uint8_t chain)
{
  int v1; // r3

  if ( chain_list[chain] )
  {
    eeprom_dump(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return -1;
  }
  return v1;
}
// 10B2E: variable 'v1' is possibly undefined

//----- (00010B38) --------------------------------------------------------
int __cdecl init_eeprom_all(unsigned __int8 *path)
{
  if ( !eeprom_init(path) )
    return -1;
  else
    return 0;
}

//----- (00010B68) --------------------------------------------------------
int __cdecl update_version_info(uint8_t chain, uint8_t pcb, uint8_t bom)
{
  _BOOL4 v4; // r4

  if ( chain_list[chain] )
  {
    v4 = eeprom_set_pcb_version(chain, pcb);
    return eeprom_set_bom_version(chain, bom) && v4;
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return -1;
  }
}

//----- (00010BD8) --------------------------------------------------------
int __cdecl erase_eeprom(uint8_t chain)
{
  if ( chain_list[chain] )
  {
    eeprom_erase_all();
    return 0;
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return -1;
  }
}

//----- (00010C1C) --------------------------------------------------------
int __cdecl write_eeprom(uint8_t chain, int addr, uint8_t *buf, int len)
{
  bool ret; // [sp+13h] [bp+13h]
  int i; // [sp+14h] [bp+14h]

  if ( chain_list[chain] )
  {
    ret = eeprom_write(chain, addr, buf, len);
    usleep(0x2710u);
    if ( eeprom_write(chain, addr, buf, len) && ret )
    {
      for ( i = 0; i < len; ++i )
        printf("[chain%d] [0x%02x] : 0x%02x\n", chain, addr + i, buf[i]);
      return 0;
    }
    else
    {
      puts("write error!");
      return -1;
    }
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return -1;
  }
}

//----- (00010CE4) --------------------------------------------------------
int __cdecl read_eeprom(uint8_t chain, int addr, int len)
{
  _BOOL4 v4; // r4
  uint8_t buf[256]; // [sp+10h] [bp+10h] BYREF
  bool ret; // [sp+113h] [bp+113h]
  int i; // [sp+114h] [bp+114h]

  if ( chain_list[chain] )
  {
    ret = eeprom_read(chain, addr, buf, len);
    usleep(0x2710u);
    v4 = ret;
    ret = eeprom_read(chain, addr, buf, len) && v4;
    if ( !ret )
    {
      puts("write error!");
      return -1;
    }
    else
    {
      for ( i = 0; i < len; ++i )
        printf("[chain%d] [0x%02x] : 0x%02x\n", chain, addr + i, buf[i]);
      return 0;
    }
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return -1;
  }
}

//----- (00010DF8) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  uint8_t v4; // r0
  uint8_t buf[256]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 path[256]; // [sp+110h] [bp+108h] BYREF
  int fd; // [sp+210h] [bp+208h]
  int i; // [sp+214h] [bp+20Ch]
  uint8_t bom; // [sp+21Ah] [bp+212h]
  uint8_t pcb; // [sp+21Bh] [bp+213h]
  int len; // [sp+21Ch] [bp+214h]
  int addr; // [sp+220h] [bp+218h]
  uint8_t chain; // [sp+227h] [bp+21Fh]
  int option; // [sp+228h] [bp+220h]
  int ret; // [sp+22Ch] [bp+224h]

  ret = 0;
  option = 0;
  if ( !argv[1] || !strcmp(argv[1], "--help") || !strcmp(argv[1], "-h") )
  {
    print_usage();
    return ret;
  }
  fd = open("/dev/axi_fpga_dev", 2);
  if ( fd >= 0 )
  {
    axi_fpga_addr = (unsigned int *)mmap(0, 0x160u, 3, 1, fd, 0);
    if ( axi_fpga_addr )
    {
      chain_num = check_chain_num();
      if ( !strcmp(argv[1], "-d") )
      {
        if ( argc == 3 )
        {
          chain = atoi(argv[2]);
          option = 1;
        }
      }
      else if ( !strcmp(argv[1], "-l") )
      {
        if ( argc == 3 )
        {
          chain = atoi(argv[2]);
          option = 2;
        }
      }
      else if ( !strcmp(argv[1], "-i") )
      {
        if ( argc == 3 )
        {
          strcpy((char *)path, argv[2]);
          option = 3;
        }
      }
      else if ( !strcmp(argv[1], "-e") )
      {
        if ( argc == 3 )
        {
          chain = atoi(argv[2]);
          option = 4;
        }
      }
      else if ( !strcmp(argv[1], "-w") )
      {
        if ( argc > 3 )
        {
          chain = atoi(argv[2]);
          addr = atoi(argv[3]);
          len = argc - 4;
          for ( i = 0; i < len; ++i )
          {
            v4 = atoi(argv[i + 4]);
            buf[i] = v4;
          }
          option = 5;
        }
      }
      else if ( !strcmp(argv[1], "-r") )
      {
        if ( argc == 5 )
        {
          chain = atoi(argv[2]);
          addr = atoi(argv[3]);
          len = atoi(argv[4]);
          option = 6;
        }
      }
      else if ( !strcmp(argv[1], "-p") && argc == 5 )
      {
        chain = atoi(argv[2]);
        pcb = atoi(argv[3]);
        bom = atoi(argv[4]);
        option = 7;
      }
      switch ( option )
      {
        case 1:
          ret = dump_eeprom(chain);
          break;
        case 2:
          ret = tarverse_eeprom(chain);
          break;
        case 3:
          ret = init_eeprom_all(path);
          break;
        case 4:
          ret = erase_eeprom(chain);
          break;
        case 5:
          ret = write_eeprom(chain, addr, buf, len);
          break;
        case 6:
          ret = read_eeprom(chain, addr, len);
          break;
        case 7:
          ret = update_version_info(chain, pcb, bom);
          break;
        default:
          print_usage();
          ret = 0;
          break;
      }
      pthread_mutex_destroy(&iic_mutex);
      munmap(axi_fpga_addr, 0x160u);
      close(fd);
      return ret;
    }
    printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%lsx\n", (const wchar_t *)axi_fpga_addr);
    return -1;
  }
  else
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", fd);
    perror("open");
    return -1;
  }
}

//----- (00011298) --------------------------------------------------------
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len)
{
  const uint8_t *v2; // r3
  uint16_t wIndex; // [sp+Ch] [bp+Ch]
  uint8_t chCRCLo; // [sp+Eh] [bp+Eh]
  uint8_t chCRCHi; // [sp+Fh] [bp+Fh]

  chCRCHi = -1;
  chCRCLo = -1;
  while ( w_len-- )
  {
    v2 = p_data++;
    wIndex = (unsigned __int8)(chCRCLo ^ *v2);
    chCRCLo = chCRCHi ^ chCRCHTalbe[chCRCLo ^ *v2];
    chCRCHi = chCRCLTalbe[wIndex];
  }
  return chCRCLo | (chCRCHi << 8);
}

//----- (00011308) --------------------------------------------------------
int check_chain_num()
{
  int ret; // [sp+4h] [bp+4h]
  int chain_num; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  chain_num = 0;
  ret = axi_fpga_addr[2];
  if ( ret < 0 )
    return 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( ((ret >> i) & 1) != 0 )
    {
      chain_list[i] = 1;
      printf("chain[%d] ", i);
      ++chain_num;
    }
    else
    {
      chain_list[i] = 0;
    }
  }
  printf("found, %d chain total\n", chain_num);
  return chain_num;
}

//----- (000113A4) --------------------------------------------------------
unsigned int get_iic_0()
{
  return axi_fpga_addr[12];
}

//----- (000113D0) --------------------------------------------------------
unsigned __int8 __cdecl set_iic(unsigned int data)
{
  int v2; // r3
  signed int ret; // [sp+10h] [bp+10h]
  int wait_counter; // [sp+14h] [bp+14h]

  wait_counter = 0;
  axi_fpga_addr[12] = data & 0x3FFFFFFF;
  while ( 1 )
  {
    ret = get_iic_0();
    if ( ret < 0 )
      return ret;
    v2 = wait_counter++;
    if ( v2 > 100 )
      break;
    usleep(0x1388u);
  }
  printf("could not get iic, ret = 0x%08x\n", ret);
  return 0;
}

//----- (0001143C) --------------------------------------------------------
uint8_t __cdecl znyq_set_iic(
        unsigned __int8 dev_addr,
        unsigned __int8 which_iic,
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 data)
{
  uint32_t value; // [sp+Ch] [bp+Ch]

  value = 0;
  if ( read )
    value = 0x2000000;
  if ( reg_addr_valid )
    value |= (reg_addr << 8) | 0x1000000;
  return set_iic(data | value | ((which_iic & 3) << 26) | (((dev_addr >> 3) & 0xF) << 20) | ((dev_addr & 7) << 16));
}

//----- (000114D8) --------------------------------------------------------
uint8_t __cdecl write_eeprom_iic(uint8_t chain, uint8_t reg_addr, uint8_t data)
{
  return znyq_set_iic(chain & 7 | 0x50, 0, 0, 1, reg_addr, data);
}

//----- (00011528) --------------------------------------------------------
uint8_t __cdecl read_eeprom_iic(uint8_t chain, uint8_t reg_addr)
{
  return znyq_set_iic(chain & 7 | 0x50, 0, 1, 1, reg_addr, 0);
}

//----- (00011578) --------------------------------------------------------
void __cdecl eeprom_write_one_byte(uint8_t address, uint8_t data, uint8_t chain)
{
  write_eeprom_iic(chain, address, data);
}

//----- (000115A0) --------------------------------------------------------
uint8_t __cdecl eeprom_read_one_byte(uint8_t address, uint8_t chain)
{
  return read_eeprom_iic(chain, address);
}

//----- (000115D0) --------------------------------------------------------
void __cdecl eeprom_write_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint8_t length)
{
  uint8_t i; // [sp+Fh] [bp+Fh]

  if ( length + address <= 256 )
  {
    for ( i = 0; i < (unsigned int)length; ++i )
      eeprom_write_one_byte(i + address, buf[i], chain);
  }
}

//----- (00011630) --------------------------------------------------------
void __cdecl eeprom_read_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint8_t length)
{
  uint8_t i; // [sp+Fh] [bp+Fh]

  if ( length + address <= 256 )
  {
    for ( i = 0; i < (unsigned int)length; ++i )
      buf[i] = eeprom_read_one_byte(i + address, chain);
  }
}

//----- (00011694) --------------------------------------------------------
bool __cdecl eeprom_update_crc(uint8_t chain)
{
  uint16_t crc; // [sp+Ah] [bp+Ah] BYREF
  uint8_t *buf; // [sp+Ch] [bp+Ch]

  buf = (uint8_t *)malloc(0xFEu);
  if ( buf )
  {
    pthread_mutex_lock(&iic_mutex);
    eeprom_read_bytes(0, buf, chain, 0xFEu);
    crc = CRC16(buf, 0xFEu);
    eeprom_write_bytes(0xFEu, (uint8_t *)&crc, chain, 2u);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    if ( buf )
      free(buf);
    return 1;
  }
  else
  {
    perror("error: allocate memory failed\n");
    return 0;
  }
}

//----- (0001171C) --------------------------------------------------------
bool __cdecl eeprom_check_crc(uint8_t chain)
{
  uint16_t _crc_; // [sp+8h] [bp+8h] BYREF
  uint16_t crc; // [sp+Ah] [bp+Ah]
  uint8_t *buf; // [sp+Ch] [bp+Ch]

  buf = (uint8_t *)malloc(0xFEu);
  if ( buf )
  {
    pthread_mutex_lock(&iic_mutex);
    eeprom_read_bytes(0, buf, chain, 0xFEu);
    crc = CRC16(buf, 0xFEu);
    eeprom_read_bytes(0xFEu, (uint8_t *)&_crc_, chain, 2u);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    if ( buf )
      free(buf);
    return crc == _crc_;
  }
  else
  {
    perror("error: allocate memory failed\n");
    return 0;
  }
}

//----- (000117B0) --------------------------------------------------------
bool __cdecl eeprom_set_magic(uint8_t chain, uint8_t magic_num)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    eeprom_write_one_byte(0, magic_num, chain);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011824) --------------------------------------------------------
bool __cdecl eeprom_get_magic(uint8_t chain, uint8_t *magic_num)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    eeprom_read_one_byte(0, chain);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011898) --------------------------------------------------------
void __cdecl write_eeprom_store_into_at24c02(eeprom_store_t *eeprom, uint8_t chain)
{
  pthread_mutex_lock(&iic_mutex);
  usleep(0x2710u);
  eeprom_write_one_byte(0, eeprom->magic_num, chain);
  eeprom_write_one_byte(1u, eeprom->chain_volt, chain);
  eeprom_write_bytes(2u, eeprom->chain_freq_data, chain, 0x6Cu);
  eeprom_write_bytes(0x6Eu, eeprom->hash_rate, chain, 4u);
  pthread_mutex_unlock(&iic_mutex);
}

//----- (00011908) --------------------------------------------------------
eeprom_store_t *__cdecl read_eeprom_store_from_at24c02(eeprom_store_t *eeprom_store, uint8_t chain)
{
  pthread_mutex_lock(&iic_mutex);
  usleep(0x2710u);
  eeprom_store->magic_num = eeprom_read_one_byte(0, chain);
  eeprom_store->chain_volt = eeprom_read_one_byte(1u, chain);
  eeprom_read_bytes(2u, eeprom_store->chain_freq_data, chain, 0x6Cu);
  eeprom_read_bytes(0x6Eu, eeprom_store->hash_rate, chain, 4u);
  pthread_mutex_unlock(&iic_mutex);
  return eeprom_store;
}

//----- (00011984) --------------------------------------------------------
bool __cdecl eeprom_set_freq(uint8_t chain, uint32_t *buf)
{
  uint8_t *receive_buf; // [sp+Ch] [bp+Ch]
  uint8_t *send_buf; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]
  bool ret; // [sp+1Bh] [bp+1Bh]
  int try_time; // [sp+1Ch] [bp+1Ch]

  try_time = 0;
  if ( chain_list[chain] )
  {
    send_buf = (uint8_t *)malloc(0x6Cu);
    if ( send_buf && (receive_buf = (uint8_t *)malloc(0x6Cu)) != 0 )
    {
      for ( i = 0; i <= 107; ++i )
        send_buf[i] = buf[i] + 56;
      while ( 1 )
      {
        pthread_mutex_lock(&iic_mutex);
        eeprom_write_bytes(2u, send_buf, chain, 0x6Cu);
        usleep(0x2710u);
        eeprom_read_bytes(2u, receive_buf, chain, 0x6Cu);
        pthread_mutex_unlock(&iic_mutex);
        if ( !memcmp(buf, receive_buf, 0x6Cu) )
        {
          ret = 1;
          goto LABEL_14;
        }
        if ( try_time == 2 )
          break;
        ++try_time;
      }
      ret = 0;
LABEL_14:
      free(receive_buf);
      free(send_buf);
      return eeprom_update_crc(chain) && ret;
    }
    else
    {
      perror("fetal error: allocate memory failed!\n");
      return 0;
    }
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}
// 11A8A: conditional instruction was optimized away because %receive_buf.4!=0
// 11A96: conditional instruction was optimized away because %send_buf.4!=0

//----- (00011AC0) --------------------------------------------------------
bool __cdecl eeprom_get_freq(uint8_t chain, uint32_t *buf)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    for ( i = 0; i <= 107; ++i )
      buf[i] = eeprom_read_one_byte(i + 2, chain) + 200;
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011B58) --------------------------------------------------------
bool __cdecl eeprom_set_freq_one_chain(uint8_t chain, uint8_t *buf, uint8_t buf_len)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    eeprom_write_one_byte(0, 0x7Du, chain);
    eeprom_write_bytes(2u, buf, chain, buf_len);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011BD8) --------------------------------------------------------
bool __cdecl eeprom_get_freq_one_chain(uint8_t chain, uint8_t *buf, uint8_t buf_len)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    eeprom_read_bytes(2u, buf, chain, buf_len);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011C4C) --------------------------------------------------------
bool __cdecl eeprom_set_voltage(uint8_t chain, double voltage)
{
  double v2; // d0

  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    eeprom_write_one_byte(1u, (unsigned int)(v2 * 100.0 / 5.0 - 200.0), chain);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}
// 11C88: variable 'v2' is possibly undefined

//----- (00011CF8) --------------------------------------------------------
bool __cdecl eeprom_get_voltage(uint8_t chain, double *voltage)
{
  uint32_t vol; // [sp+Ch] [bp+Ch]

  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    vol = eeprom_read_one_byte(1u, chain);
    pthread_mutex_unlock(&iic_mutex);
    *voltage = (double)(vol + 200) * 5.0 / 100.0;
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011D98) --------------------------------------------------------
bool __cdecl eeprom_set_hashrate(uint8_t chain, uint32_t hash)
{
  uint8_t hash_rate[4]; // [sp+8h] [bp+8h] BYREF
  int i; // [sp+Ch] [bp+Ch]

  if ( chain_list[chain] )
  {
    *(_DWORD *)hash_rate = hash;
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    for ( i = 0; (unsigned int)i <= 3; ++i )
      eeprom_write_one_byte(i + 110, hash_rate[i], chain);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011E48) --------------------------------------------------------
bool __cdecl eeprom_get_hashrate(uint8_t chain, uint32_t *hash)
{
  uint8_t hash_rate[4]; // [sp+8h] [bp+8h] BYREF
  int i; // [sp+Ch] [bp+Ch]

  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    usleep(0x2710u);
    for ( i = 0; (unsigned int)i <= 3; ++i )
      hash_rate[i] = eeprom_read_one_byte(i + 110, chain);
    pthread_mutex_unlock(&iic_mutex);
    *hash = hash_rate[0] + (hash_rate[1] << 8) + (hash_rate[2] << 16) + (hash_rate[3] << 24);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00011EFC) --------------------------------------------------------
void __cdecl convert_freq_array(uint8_t *chain_freq, uint16_t (*array)[9])
{
  int i; // [sp+8h] [bp+8h]
  int j; // [sp+Ch] [bp+Ch]

  for ( j = 0; j <= 11; ++j )
  {
    for ( i = 0; i <= 8; ++i )
      chain_freq[i + 108 * j / 12] = (*array)[9 * j + i] + 56;
  }
}

//----- (00011F78) --------------------------------------------------------
void __cdecl travel_eeprom_store(uint8_t chain)
{
  eeprom_store_t *eeprom; // [sp+Ch] [bp+Ch]
  eeprom_store_t *eeproma; // [sp+Ch] [bp+Ch]
  int k; // [sp+10h] [bp+10h]
  int l; // [sp+14h] [bp+14h]

  if ( chain_list[chain] )
  {
    eeprom = (eeprom_store_t *)malloc(0x72u);
    if ( eeprom )
    {
      memset(eeprom, 0, sizeof(eeprom_store_t));
      eeproma = read_eeprom_store_from_at24c02(eeprom, chain);
      printf("chain[%d] data in eeprom is:\n", chain);
      printf("magic number: 0x%02x\n", eeproma->magic_num);
      puts("freq data per ASIC:");
      for ( l = 0; l <= 11; ++l )
      {
        for ( k = 0; k <= 8; ++k )
          printf("IC[%03d]:%d ", 108 * l / 12 + k, eeproma->chain_freq_data[k + 108 * l / 12] + 200);
        putchar(10);
      }
      printf("voltage: %.02f V\n", (float)((float)(5 * (unsigned int)eeproma->chain_volt + 1000) / 100.0));
      printf(
        "hash rate: %05d GH/s\n",
        (eeproma->hash_rate[3] << 24)
      + eeproma->hash_rate[0]
      + (eeproma->hash_rate[1] << 8)
      + (eeproma->hash_rate[2] << 16));
      if ( eeproma )
        free(eeproma);
    }
    else
    {
      puts("fetal error: failed to allocate memory for eeprom!");
    }
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
  }
}

//----- (00012114) --------------------------------------------------------
bool __cdecl eeprom_store_init(unsigned __int8 *path, eeprom_store_t **eeprom)
{
  uint16_t freq[16][12][9]; // [sp+8h] [bp+8h] BYREF
  int i; // [sp+DA8h] [bp+DA8h]
  bool ret; // [sp+DAFh] [bp+DAFh]

  if ( path )
    ret = scan_eeprom_config_file(path, freq);
  else
    ret = scan_eeprom_config_file(eeprom_conf_file, freq);
  if ( !ret )
    return 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( chain_list[i] )
    {
      memset(eeprom[i], 0, sizeof(eeprom_store_t));
      convert_freq_array(eeprom[i]->chain_freq_data, freq[i]);
      eeprom[i]->magic_num = 125;
      eeprom[i]->chain_volt = -91;
      eeprom[i]->hash_rate[0] = 68;
      eeprom[i]->hash_rate[1] = 72;
      eeprom[i]->hash_rate[2] = 0;
      eeprom[i]->hash_rate[3] = 0;
    }
  }
  return ret;
}

//----- (0001225C) --------------------------------------------------------
bool __cdecl eeprom_init(unsigned __int8 *path)
{
  eeprom_store_t *eeprom[16]; // [sp+Ch] [bp+Ch] BYREF
  bool ret; // [sp+4Fh] [bp+4Fh]
  int i_2; // [sp+50h] [bp+50h]
  int i_1; // [sp+54h] [bp+54h]
  int i_0; // [sp+58h] [bp+58h]
  int i; // [sp+5Ch] [bp+5Ch]
  __int64 savedregs; // [sp+60h] [bp+60h] BYREF

  for ( i = 0; i <= 15; ++i )
  {
    *((_DWORD *)&savedregs + i - 21) = malloc(0x72u);
    if ( !*((_DWORD *)&savedregs + i - 21) )
    {
      perror("failed to allocate memory for eeprom");
      *((_DWORD *)&savedregs + i - 21) = 0;
      return 0;
    }
  }
  ret = eeprom_store_init(path, eeprom);
  if ( !ret )
  {
    puts("failed to initialize eeprom");
  }
  else
  {
    for ( i_0 = 0; i_0 <= 15; ++i_0 )
    {
      if ( chain_list[i_0] )
        write_eeprom_store_into_at24c02(*((eeprom_store_t **)&savedregs + i_0 - 21), i_0);
    }
    for ( i_1 = 0; i_1 <= 15; ++i_1 )
    {
      ret = eeprom_update_crc(i_1);
      if ( !ret )
        break;
    }
  }
  for ( i_2 = 0; i_2 <= 15; ++i_2 )
  {
    if ( *((_DWORD *)&savedregs + i_2 - 21) )
    {
      free(*((void **)&savedregs + i_2 - 21));
      *((_DWORD *)&savedregs + i_2 - 21) = 0;
    }
  }
  return 1;
}

//----- (000123B4) --------------------------------------------------------
void __cdecl eeprom_dump(uint8_t chain)
{
  uint8_t *temp; // [sp+Ch] [bp+Ch]
  int i_0; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  temp = (uint8_t *)malloc(0x100u);
  if ( temp )
  {
    pthread_mutex_lock(&iic_mutex);
    for ( i = 0; i <= 255; ++i )
      temp[i] = eeprom_read_one_byte(i, chain);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    printf("eeprom data in chain[%d]:\n", chain);
    puts("offset: 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0d");
    for ( i_0 = 0; i_0 <= 255; ++i_0 )
    {
      if ( (i_0 & 0xF) == 0 )
        printf("%06x: ", i_0);
      printf("%02x ", temp[i_0]);
      if ( (((_BYTE)i_0 + 1) & 0xF) == 0 )
        putchar(10);
    }
    free(temp);
    putchar(10);
  }
  else
  {
    perror("allocat memory failed");
  }
}
// 1249A: conditional instruction was optimized away because %temp.4!=0

//----- (000124B0) --------------------------------------------------------
void __cdecl eeprom_dump_raw(uint8_t chain)
{
  if ( chain_list[chain] )
    eeprom_dump(chain);
}

//----- (000124DC) --------------------------------------------------------
void __cdecl eeprom_dump(uint8_t chain)
{
  uint8_t bom; // [sp+Eh] [bp+Eh] BYREF
  uint8_t pcb; // [sp+Fh] [bp+Fh] BYREF
  uint8_t buf[6]; // [sp+10h] [bp+10h] BYREF
  uint32_t len; // [sp+18h] [bp+18h] BYREF
  int i; // [sp+1Ch] [bp+1Ch]

  if ( chain_list[chain] )
  {
    travel_eeprom_store(chain);
    eeprom_get_inbalance_info(chain, buf, &len);
    printf("inbalance ASIC info: ");
    if ( len <= 6 )
    {
      for ( i = 0; i < len; ++i )
        printf("IC[%03d] ", buf[i]);
    }
    putchar(10);
    eeprom_get_pcb_version(chain, &pcb);
    eeprom_get_bom_version(chain, &bom);
    printf("PCB_Ver:0x%02x  BOM_Ver:0x%02x\n", pcb, bom);
  }
}

//----- (0001258C) --------------------------------------------------------
void __cdecl eeprom_erase(uint8_t chain)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    for ( i = 0; i <= 255; ++i )
      eeprom_write_one_byte(i, 0, chain);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
  }
}

//----- (00012600) --------------------------------------------------------
void eeprom_erase_all()
{
  int j; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]

  pthread_mutex_lock(&iic_mutex);
  for ( i = 0; i <= 15; ++i )
  {
    if ( chain_list[i] )
    {
      for ( j = 0; j <= 255; ++j )
        eeprom_write_one_byte(j, 0, i);
    }
  }
  usleep(0x2710u);
  pthread_mutex_unlock(&iic_mutex);
}

//----- (00012674) --------------------------------------------------------
bool __cdecl eeprom_write(uint8_t chain, uint32_t addr, uint8_t *buf, uint32_t len)
{
  uint8_t lena; // [sp+0h] [bp+0h]
  uint8_t addra; // [sp+8h] [bp+8h]

  addra = addr;
  lena = len;
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    eeprom_write_bytes(addra, buf, chain, lena);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (000126EC) --------------------------------------------------------
bool __cdecl eeprom_read(uint8_t chain, uint32_t addr, uint8_t *buf, uint32_t len)
{
  uint8_t lena; // [sp+0h] [bp+0h]
  uint8_t addra; // [sp+8h] [bp+8h]

  addra = addr;
  lena = len;
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    eeprom_read_bytes(addra, buf, chain, lena);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist!\n", chain);
    return 0;
  }
}

//----- (00012764) --------------------------------------------------------
bool __cdecl eeprom_set_inbalance_info(uint8_t chain, uint8_t *buf, uint32_t len)
{
  uint8_t lena; // [sp+4h] [bp+4h]

  lena = len;
  if ( len <= 6 )
  {
    pthread_mutex_lock(&iic_mutex);
    if ( chain_list[chain] )
    {
      eeprom_write_one_byte(0x72u, lena, chain);
      eeprom_write_bytes(0x73u, buf, chain, lena);
    }
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("error: inbalance data are more than %d\n", 6);
    return 0;
  }
}

//----- (000127EC) --------------------------------------------------------
bool __cdecl eeprom_get_inbalance_info(uint8_t chain, uint8_t *buf, uint32_t *len)
{
  uint8_t one_byte; // r0

  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    one_byte = eeprom_read_one_byte(0x72u, chain);
    *len = one_byte;
    eeprom_write_bytes(0x73u, buf, chain, one_byte);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist\n", chain);
    return 0;
  }
}

//----- (00012874) --------------------------------------------------------
bool __cdecl eeprom_set_pcb_version(uint8_t chain, uint8_t pcb_version)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    eeprom_write_one_byte(0xFCu, pcb_version, chain);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist\n", chain);
    return 0;
  }
}

//----- (000128E8) --------------------------------------------------------
bool __cdecl eeprom_set_bom_version(uint8_t chain, uint8_t bom_version)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    eeprom_write_one_byte(0xFDu, bom_version, chain);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_update_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist\n", chain);
    return 0;
  }
}

//----- (0001295C) --------------------------------------------------------
bool __cdecl eeprom_get_pcb_version(uint8_t chain, uint8_t *pcb_version)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    *pcb_version = eeprom_read_one_byte(0xFCu, chain);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist\n", chain);
    return 0;
  }
}

//----- (000129D4) --------------------------------------------------------
bool __cdecl eeprom_get_bom_version(uint8_t chain, uint8_t *bom_version)
{
  if ( chain_list[chain] )
  {
    pthread_mutex_lock(&iic_mutex);
    *bom_version = eeprom_read_one_byte(0xFDu, chain);
    usleep(0x2710u);
    pthread_mutex_unlock(&iic_mutex);
    return eeprom_check_crc(chain);
  }
  else
  {
    printf("chain[%d] does not exist\n", chain);
    return 0;
  }
}

//----- (00012A50) --------------------------------------------------------
bool __cdecl set_freq_array(int flag, uint16_t (*freq_data)[9], int freq)
{
  int j_0; // [sp+14h] [bp+14h]
  int i; // [sp+18h] [bp+18h]
  int j; // [sp+1Ch] [bp+1Ch]

  if ( flag < 0 || flag > 12 )
    return 0;
  if ( flag )
  {
    for ( j_0 = 0; j_0 <= 8; ++j_0 )
      (*freq_data)[9 * flag - 9 + j_0] = freq;
  }
  else
  {
    for ( j = 0; j <= 11; ++j )
    {
      for ( i = 0; i <= 8; ++i )
        (*freq_data)[9 * j + i] = freq;
    }
  }
  return 1;
}

//----- (00012AF4) --------------------------------------------------------
bool __cdecl conf_process(int chain, uint16_t (*freq_data)[9], const unsigned __int8 *str)
{
  int v4; // r4
  int v5; // r0
  unsigned __int8 chain_stamp[16]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 temp_index[16]; // [sp+24h] [bp+24h] BYREF
  unsigned __int8 temp_freq[16]; // [sp+34h] [bp+34h] BYREF
  int stamp_flag[110]; // [sp+54h] [bp+54h]
  int line_flag[110]; // [sp+20Ch] [bp+20Ch]
  int str_len; // [sp+3C4h] [bp+3C4h]
  int i_1; // [sp+3C8h] [bp+3C8h]
  int i_0; // [sp+3CCh] [bp+3CCh]
  int i; // [sp+3D0h] [bp+3D0h]
  int stamp_num; // [sp+3D4h] [bp+3D4h]
  int line_num; // [sp+3D8h] [bp+3D8h]
  bool ret; // [sp+3DFh] [bp+3DFh]

  line_num = 0;
  stamp_num = 0;
  str_len = strlen((const char *)str) + 1;
  sprintf((char *)chain_stamp, "chain %d", chain + 1);
  if ( strstr((const char *)str, (const char *)chain_stamp) )
  {
    printf("now set: %s freq array ...\n", (const char *)chain_stamp);
    for ( i = 0; i < str_len; ++i )
    {
      if ( str[i] == 10 || !str[i] )
        line_flag[line_num++] = i;
    }
    for ( i_0 = 0; i_0 < str_len; ++i_0 )
    {
      if ( str[i_0] == 58 )
        stamp_flag[stamp_num++] = i_0;
    }
    for ( i_1 = 0; i_1 < stamp_num; ++i_1 )
    {
      memset(temp_freq, 0, sizeof(temp_freq));
      strncpy((char *)temp_freq, (const char *)&str[stamp_flag[i_1] + 1], line_flag[i_1 + 1] - stamp_flag[i_1] - 1);
      temp_freq[line_flag[i_1 + 1] - stamp_flag[i_1]] = 0;
      memset(temp_index, 0, sizeof(temp_index));
      strncpy((char *)temp_index, (const char *)&str[line_flag[i_1] + 1], stamp_flag[i_1] - line_flag[i_1] - 1);
      temp_index[line_flag[i_1 + 1] - stamp_flag[i_1]] = 0;
      v4 = atoi((const char *)temp_index);
      v5 = atoi((const char *)temp_freq);
      ret = set_freq_array(v4, freq_data, v5);
    }
    return ret;
  }
  else
  {
    puts("conf file format is incorrect, please check!");
    return 0;
  }
}

//----- (00012D54) --------------------------------------------------------
void __cdecl travel_array(uint16_t (*array)[9])
{
  int i; // [sp+8h] [bp+8h]
  int j; // [sp+Ch] [bp+Ch]

  for ( j = 0; j <= 11; ++j )
  {
    for ( i = 0; i <= 8; ++i )
      printf("IC[%03d]:%d ", 108 * j / 12 + i, (*array)[9 * j + i]);
    putchar(10);
  }
}

//----- (00012DD0) --------------------------------------------------------
bool __cdecl scan_eeprom_config_file(const unsigned __int8 *conf_file_path, uint16_t (*freq_data)[12][9])
{
  int chain_msg_len[17]; // [sp+44Ch] [bp+44Ch] BYREF
  unsigned __int8 *file_buf; // [sp+490h] [bp+490h]
  int file_length; // [sp+494h] [bp+494h]
  FILE *fp; // [sp+498h] [bp+498h]
  int i_4; // [sp+49Ch] [bp+49Ch]
  int i_3; // [sp+4A0h] [bp+4A0h]
  int i_2; // [sp+4A4h] [bp+4A4h]
  int j; // [sp+4A8h] [bp+4A8h]
  int i_1; // [sp+4ACh] [bp+4ACh]
  int i_0; // [sp+4B0h] [bp+4B0h]
  int i; // [sp+4B4h] [bp+4B4h]
  int freq_set_num; // [sp+4B8h] [bp+4B8h]
  bool ret; // [sp+4BFh] [bp+4BFh]
  __int64 savedregs; // [sp+4C0h] [bp+4C0h] BYREF

  fp = fopen((const char *)conf_file_path, "r");
  if ( fp )
  {
    fseek(fp, 0, 2);
    file_length = ftell(fp);
    fseek(fp, 0, 0);
    file_buf = (unsigned __int8 *)malloc(file_length);
    if ( file_buf )
    {
      memset(file_buf, 0, file_length);
      for ( i_0 = 0; i_0 <= 15; ++i_0 )
      {
        *((_DWORD *)&savedregs + i_0 - 45) = malloc(0x400u);
        if ( !*((_DWORD *)&savedregs + i_0 - 45) )
        {
          perror("failed to allocate memory for chain_msg_ptr!\n");
          return 0;
        }
        memset(*((void **)&savedregs + i_0 - 45), 0, 0x400u);
      }
      fread(file_buf, file_length, 1u, fp);
      i_1 = 0;
      j = 1;
      while ( i_1 < file_length )
      {
        if ( file_buf[i_1] == 10 && file_buf[i_1 + 1] == 10 )
        {
          chain_msg_len[j++] = i_1;
          freq_set_num = j;
          if ( j > 16 )
            break;
        }
        ++i_1;
      }
      chain_msg_len[0] = 0;
      *((_DWORD *)&savedregs + freq_set_num - 29) = strlen((const char *)file_buf);
      for ( i_2 = 0; i_2 < freq_set_num; ++i_2 )
      {
        strncpy(
          *((char **)&savedregs + i_2 - 45),
          (const char *)&file_buf[*((_DWORD *)&savedregs + i_2 - 29)],
          *((_DWORD *)&savedregs + i_2 - 28) - *((_DWORD *)&savedregs + i_2 - 29));
        if ( strstr(*((const char **)&savedregs + i_2 - 45), "\n\n") )
          strncpy(
            *((char **)&savedregs + i_2 - 45),
            (const char *)(*((_DWORD *)&savedregs + i_2 - 45) + 2),
            *((_DWORD *)&savedregs + i_2 - 28) - *((_DWORD *)&savedregs + i_2 - 29));
      }
      for ( i_3 = 0; i_3 <= 15; ++i_3 )
      {
        if ( chain_list[i_3] )
        {
          ret = conf_process(
                  i_3,
                  (uint16_t (*)[9])(*freq_data)[12 * i_3],
                  *((const unsigned __int8 **)&savedregs + i_3 - 45));
          if ( !ret )
            return 0;
          travel_array((uint16_t (*)[9])(*freq_data)[12 * i_3]);
        }
      }
      if ( file_buf )
      {
        free(file_buf);
        file_buf = 0;
      }
      for ( i_4 = 0; i_4 <= 15; ++i_4 )
      {
        if ( *((_DWORD *)&savedregs + i_4 - 45) )
        {
          free(*((void **)&savedregs + i_4 - 45));
          *((_DWORD *)&savedregs + i_4 - 45) = 0;
        }
      }
      fclose(fp);
      return ret;
    }
    else
    {
      perror("failed to allocate memory for file_buf!\n");
      return 0;
    }
  }
  else
  {
    printf("%s : dose not exist, will use default freq configure\n", (const char *)conf_file_path);
    for ( i = 0; i <= 15; ++i )
    {
      if ( chain_list[i] )
      {
        printf("now set: chain %d freq array ...\n", i);
        memcpy((*freq_data)[12 * i], def_freq_data, sizeof(uint16_t[12][9]));
        travel_array((uint16_t (*)[9])(*freq_data)[12 * i]);
      }
    }
    return 1;
  }
}

//----- (000131E8) --------------------------------------------------------
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp)
{
  int i; // r4
  void (__fastcall *v4)(); // r3

  init_proc();
  for ( i = 0; i != 1; ++i )
  {
    v4 = (void (__fastcall *)())*(&_frame_dummy_init_array_entry + i);
    v4();
  }
}
// 23BC8: using guessed type void *_frame_dummy_init_array_entry;

//----- (0001322C) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=130 queued=65 decompiled=65 lumina nreq=0 worse=0 better=0
// ALL OK, 65 function(s) have been successfully decompiled
