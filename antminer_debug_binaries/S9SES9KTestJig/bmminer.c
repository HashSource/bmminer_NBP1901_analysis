/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_9FBC();
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int open(const char *file, int oflag, ...);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// int fileno(FILE *stream);
// int mkdir(const char *path, __mode_t mode);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// void abort(void);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// struct tm *localtime(const time_t *timer);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int memcmp(const void *s1, const void *s2, size_t n);
// int sysconf(int name);
// void syslog(int pri, const char *fmt, ...);
// int getchar(void);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int _isinf(double value);
int sub_A0D8(void); // weak
// int sched_yield(void);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// in_addr_t inet_addr(const char *cp);
// char *strncpy(char *dest, const char *src, size_t n);
// int fclose(FILE *stream);
// char *fgets(char *s, int n, FILE *stream);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *getenv(const char *name);
// double strtod(const char *nptr, char **endptr);
// int system(const char *command);
// char *strchr(const char *s, int c);
// int putchar(int c);
// int strcasecmp(const char *s1, const char *s2);
// char *dirname(char *path);
// int setlogmask(int mask);
// int listen(int fd, int n);
// int toupper(int c);
// void *calloc(size_t nmemb, size_t size);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// FILE *fopen(const char *filename, const char *modes);
// void *memset(void *s, int c, size_t n);
// int sem_destroy(sem_t *sem);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// void freeaddrinfo(struct addrinfo *ai);
// void perror(const char *s);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// double floor(double x);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// double exp(double x);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// uint32_t ntohl(uint32_t netlong);
// int usleep(__useconds_t useconds);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// void free(void *ptr);
// int access(const char *name, int type);
// void openlog(const char *ident, int option, int facility);
// int inet_pton(int af, const char *cp, void *buf);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int sem_trywait(sem_t *sem);
// int fseek(FILE *stream, int off, int whence);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int round(void); weak
// int socket(int domain, int type, int protocol);
// int execl(const char *path, const char *arg, ...);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fflush(FILE *stream);
// int isatty(int fd);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int sscanf(const char *s, const char *format, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int execv(const char *path, char *const argv[]);
// int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// struct lconv *localeconv(void);
// int fgetc(FILE *stream);
// int strtol(const char *nptr, char **endptr, int base);
// char *strcpy(char *dest, const char *src);
// int sem_post(sem_t *sem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// char *strncat(char *dest, const char *src, size_t n);
// int atol(const char *nptr);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int printf(const char *format, ...);
// int raise(int sig);
// int atoi(const char *nptr);
// void errx(int status, const char *format, ...);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int shutdown(int fd, int how);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// FILE *fdopen(int fd, const char *modes);
// double atof(const char *nptr);
// char *strstr(const char *haystack, const char *needle);
// int nice(int inc);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int _isnan(double value);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// time_t time(time_t *timer);
// double log10(double x);
// const unsigned __int16 **_ctype_b_loc(void);
// int fprintf(FILE *stream, const char *format, ...);
// char *strdup(const char *s);
// void *malloc(size_t size);
// int sigaction_0(int sig, const struct sigaction *act, struct sigaction *oact);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// unsigned int sleep(unsigned int seconds);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// char *strcat(char *dest, const char *src);
// void *memmove(void *dest, const void *src, size_t n);
// void pthread_testcancel(void);
// int dup2(int fd, int fd2);
// int puts(const char *s);
// int prctl(int option, ...);
// int fcntl(int fd, int cmd, ...);
// __pid_t fork(void);
// uint32_t htonl(uint32_t hostlong);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int munmap(void *addr, size_t len);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// size_t strcspn(const char *s, const char *reject);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int strncmp(const char *s1, const char *s2, size_t n);
// int kill(__pid_t pid, int sig);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_detach(pthread_t th);
// void *realloc(void *ptr, size_t size);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_setcancelstate(int state, int *oldstate);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int sysinfo_0(struct sysinfo *info);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int pipe(int pipedes[2]);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// char *strpbrk(const char *s, const char *accept);
// int sem_wait(sem_t *sem);
// int tolower(int c);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int pthread_setcanceltype(int type, int *oldtype);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int *_errno_location(void);
// pthread_t pthread_self(void);
// int pthread_cancel(pthread_t th);
// int sprintf(char *s, const char *format, ...);
// int pthread_join(pthread_t th, void **thread_return);
// int fputs(const char *s, FILE *stream);
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...);
int call_gmon_start();
void *deregister_tm_clones();
__int64 register_tm_clones();
void *_do_global_dtors_aux();
__int64 frame_dummy();
void __cdecl json_decref(json_t_0 *json);
bool sock_blocks();
void __cdecl mutex_lock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl io_reinit(io_data *io_data);
io_data *__cdecl io_new(size_t initial, bool socket_buf);
bool __cdecl io_add(io_data *io_data, unsigned __int8 *buf);
bool __cdecl io_put(io_data *io_data, unsigned __int8 *buf);
void __cdecl io_close(io_data *io_data);
void io_free(); // idb
unsigned __int8 *__cdecl escape_string(unsigned __int8 *str, bool isjson);
api_data *__cdecl api_add_extra(api_data *root, api_data *extra);
api_data *__cdecl api_add_data_full(api_data *root, unsigned __int8 *name, api_data_type type, void *data, bool copy_data);
api_data *__cdecl api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_uint8(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_int16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data);
api_data *__cdecl api_add_uint16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data);
api_data *__cdecl api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data);
api_data *__cdecl api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__cdecl api_add_uint32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__cdecl api_add_hex32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__cdecl api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data);
api_data *__cdecl api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data);
api_data *__cdecl api_add_double(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data);
api_data *__cdecl api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data);
api_data *__cdecl api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data);
api_data *__cdecl api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
api_data *__cdecl api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_freq(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_volts(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
api_data *__cdecl api_add_hs(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_avg(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
void __cdecl add_item_buf(K_ITEM *item, const unsigned __int8 *str);
api_data *__cdecl print_data(io_data *io_data, api_data *root, bool isjson, bool precom);
int numascs(); // idb
int __cdecl ascdevice(int ascid);
void __cdecl message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson);
void __cdecl lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
const unsigned __int8 *__cdecl status2str(alive status);
void __cdecl ascstatus(io_data *io_data, int asc, bool isjson, bool precom);
void __cdecl devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void getAVGhashrate();
void __cdecl lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl copyadvanceafter(unsigned __int8 ch, unsigned __int8 **param, unsigned __int8 **buf);
bool __cdecl pooldetails(unsigned __int8 *param, unsigned __int8 **url, unsigned __int8 **user, unsigned __int8 **pass);
void __cdecl addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group);
void __cdecl notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
int __cdecl itemstats(io_data *io_data, int i, unsigned __int8 *id, cgminer_stats *stats, cgminer_pool_stats *pool_stats, api_data *extra, cgpu_info *cgpu, bool isjson);
void __cdecl minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascdev(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascenable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascdisable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascidentify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascset(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl lcddata(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin);
void __cdecl tail_join(io_data *io_data, bool isjson);
void __cdecl send_result(io_data *io_data, int c, bool isjson);
void __cdecl tidyup(void *arg);
void setup_groups(); // idb
void setup_ipaccess(); // idb
void *__cdecl quit_thread(void *userdata);
void *__cdecl restart_thread(void *userdata);
bool __cdecl check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group);
void mcast(); // idb
void *__cdecl mcast_thread(void *userdata);
void mcast_init(); // idb
void reCalculateAVG(); // idb
void __cdecl api(int api_thr_id);
void __cdecl json_decref_0(json_t_0 *json);
void __cdecl _list_del(list_head *prev, list_head *next);
void __cdecl list_del(list_head *entry);
unsigned int __cdecl swab32(unsigned int v);
void __cdecl swap256(void *dest_p, const void *src_p);
void __cdecl swab256(void *dest_p, const void *src_p);
void __cdecl flip32(void *dest_p, const void *src_p);
void __cdecl flip64(void *dest_p, const void *src_p);
void __cdecl flip80(void *dest_p, const void *src_p);
void __cdecl endian_flip32(void *dest_p, const void *src_p);
void __cdecl mutex_lock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl wr_trylock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_dwlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl time_before(tm *tm1, tm *tm2);
bool should_run(); // idb
void __cdecl get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv);
void __cdecl get_timestamp(unsigned __int8 *f, size_t fsiz, timeval *tv);
void applog_and_exit(const unsigned __int8 *fmt, ...);
thr_info *__cdecl _get_thread(int thr_id);
thr_info *__cdecl get_thread(int thr_id);
cgpu_info *__cdecl get_thr_cgpu(int thr_id);
cgpu_info *__cdecl get_devices(int id);
void __cdecl sharelog(const unsigned __int8 *disposition, const work *work);
void adjust_quota_gcd(); // idb
pool *add_pool(); // idb
bool __cdecl pool_tset(pool *pool, bool *var);
bool __cdecl pool_tclear(pool *pool, bool *var);
pool *current_pool(); // idb
unsigned __int8 *__cdecl set_int_range(const unsigned __int8 *arg, int *i, int min, int max);
unsigned __int8 *__cdecl set_int_0_to_9999(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_65535(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_10(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_100(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_7680(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_200(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_32_to_63(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_22_to_75(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_42_to_85(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_22_to_55(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_42_to_65(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_10(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_4(const unsigned __int8 *arg, int *i);
void __cdecl get_intrange(unsigned __int8 *arg, int *val1, int *val2);
unsigned __int8 *__cdecl set_balance(pool_strategy *strategy);
unsigned __int8 *__cdecl set_loadbalance(pool_strategy *strategy);
unsigned __int8 *__cdecl set_rotate(const unsigned __int8 *arg, unsigned __int8 *i);
unsigned __int8 *__cdecl set_rr(pool_strategy *strategy);
bool __cdecl detect_stratum(pool *pool, unsigned __int8 *url);
pool *add_url(); // idb
unsigned __int8 *__cdecl setup_url(pool *pool, unsigned __int8 *arg);
unsigned __int8 *__cdecl set_url(unsigned __int8 *arg);
unsigned __int8 *__cdecl set_quota(unsigned __int8 *arg);
unsigned __int8 *__cdecl set_user(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_pass(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_userpass(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_extranonce_subscribe(unsigned __int8 *arg);
unsigned __int8 *__cdecl enable_debug(bool *flag);
unsigned __int8 *__cdecl set_schedtime(const unsigned __int8 *arg, schedtime *st);
unsigned __int8 *__cdecl set_sched_start(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_sched_stop(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_sharelog(unsigned __int8 *arg);
unsigned __int8 *__cdecl set_temp_cutoff(unsigned __int8 *arg);
void load_temp_cutoffs(); // idb
unsigned __int8 *__cdecl set_logfile_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logfile_openflag(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logwork_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logwork_asicnum(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_float_125_to_500(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_float_100_to_250(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_null(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_version_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl parse_config(json_t_0 *config, bool fileconf);
unsigned __int8 *__cdecl load_config(const unsigned __int8 *arg, void *unused);
unsigned __int8 *__cdecl set_default_config(const unsigned __int8 *arg);
void load_default_config(); // idb
unsigned __int8 *__cdecl opt_verusage_and_exit(const unsigned __int8 *extra);
void __cdecl calc_midstate(work *work);
int total_work_inc(); // idb
work *make_work(); // idb
void __cdecl clean_work(work *work);
void __cdecl free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl dev_from_id(int thr_id);
void __cdecl decay_time(double *f, double fadd, double fsecs, double interval);
unsigned int _total_staged();
int total_staged(); // idb
void __cdecl suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits);
double __cdecl cgpu_runtime(cgpu_info *cgpu);
double tsince_restart(); // idb
double tsince_update(); // idb
void __cdecl get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
int shared_strategy();
void __cdecl enable_pool(pool *pool);
void __cdecl reject_pool(pool *pool);
void __cdecl share_result(json_t_0 *val, json_t_0 *res, json_t_0 *err, const work *work, unsigned __int8 *hashshow, bool resubmit, unsigned __int8 *worktime);
void __cdecl show_hash(work *work, unsigned __int8 *hashshow);
bool __cdecl pool_unusable(pool *pool);
pool *__cdecl select_balanced(pool *cp);
pool *select_pool(); // idb
double __cdecl le256todouble(const void *target);
double __cdecl diff_from_target(void *target);
void __cdecl calc_diff(work *work, double known);
void __cdecl get_benchmark_work(work *work);
void __cdecl benchfile_dspwork(work *work, unsigned int nonce);
bool __cdecl benchfile_get_work(work *work);
void __cdecl get_benchfile_work(work *work);
void __cdecl kill_timeout(thr_info *thr);
void kill_mining(); // idb
void _kill_work(); // idb
void __noreturn kill_work();
void app_restart(); // idb
void __cdecl sighandler(int sig);
void __cdecl modify_ntime(unsigned __int8 *ntime, int noffset);
void __cdecl roll_work(work *work);
work *__cdecl make_clone(work *work);
void *__cdecl submit_work_thread(void *userdata);
unsigned __int8 *__cdecl offset_ntime(const unsigned __int8 *ntime, int noffset);
void __cdecl copy_work(work *work, const work *base_work, int noffset);
void __cdecl set_work_ntime(work *work, int ntime);
work *__cdecl copy_work_noffset(work *base_work, int noffset);
void __cdecl pool_died(pool *pool);
bool __cdecl stale_work(work *work, bool share);
uint64_t __cdecl share_diff(const work *work);
uint64_t __cdecl share_ndiff(const work *work);
void __cdecl regen_hash(work *work);
pool *__cdecl priority_pool(int choice);
void __cdecl switch_pools(pool *selected);
void __cdecl discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void wake_gws(); // idb
void discard_stale(); // idb
int __cdecl restart_wait(thr_info *thr, unsigned int mstime);
void *__cdecl restart_thread_0(void *arg);
void restart_threads(); // idb
void signal_work_update(); // idb
void __cdecl set_curblock(const unsigned __int8 *hexstr, const unsigned __int8 *bedata);
int __cdecl block_sort(block *blocka, block *blockb);
void __cdecl set_blockdiff(const work *work);
bool __cdecl block_exists(const unsigned __int8 *hexstr, const unsigned __int8 *bedata, const work *work);
bool __cdecl test_work_current(work *work);
int __cdecl tv_sort(work *worka, work *workb);
bool __cdecl work_rollable(work *work);
bool __cdecl hash_push(work *work);
void __cdecl stage_work(work *work);
void __cdecl remove_pool(pool *pool);
void json_escape_free(); // idb
unsigned __int8 *__cdecl json_escape(unsigned __int8 *str);
void __cdecl write_config(FILE *fcfg);
void zero_bestshare(); // idb
void zero_stats(); // idb
void set_highprio(); // idb
void set_lowprio(); // idb
void __cdecl default_save_file(unsigned __int8 *filename);
void *__cdecl api_thread(void *userdata);
void __cdecl thread_reportin(thr_info *thr);
void __cdecl thread_reportout(thr_info *thr);
void __cdecl hashmeter(int thr_id, uint64_t hashes_done);
void __cdecl stratum_share_result(json_t_0 *val, json_t_0 *res_val, json_t_0 *err_val, stratum_share *sshare);
bool __cdecl parse_stratum_response(pool *pool, unsigned __int8 *s);
void __cdecl clear_stratum_shares(pool *pool);
void __cdecl clear_pool_work(pool *pool);
int cp_prio(); // idb
bool __cdecl cnx_needed(pool *pool);
void __cdecl stratum_resumed(pool *pool);
bool __cdecl supports_resume(pool *pool);
void *__cdecl stratum_rthread(void *userdata);
void *__cdecl stratum_sthread(void *userdata);
void __cdecl init_stratum_threads(pool *pool);
bool __cdecl stratum_works(pool *pool);
bool __cdecl setup_gbt_solo(CURL *curl, pool *pool);
void __cdecl pool_start_lp(pool *pool);
bool __cdecl pool_active(pool *pool, bool pinging);
void __cdecl pool_resus(pool *pool);
work *__cdecl hash_pop(bool blocking);
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len);
void __cdecl set_target(unsigned __int8 *dest_target, double diff);
void __cdecl get_work_by_nonce2(thr_info *thr, work **work, pool *pool, pool *real_pool, uint64_t nonce2, unsigned int ntime, unsigned int version);
void __cdecl gen_stratum_work(pool *pool, work *work);
int __cdecl share_work_tdiff(cgpu_info *cgpu);
void __cdecl set_benchmark_work(cgpu_info *cgpu, work *work);
work *__cdecl get_work(thr_info *thr, const int thr_id);
void __cdecl submit_work_async(work *work);
void __cdecl inc_hw_errors(thr_info *thr);
void __cdecl inc_hw_errors_with_diff(thr_info *thr, int diff);
void __cdecl inc_dev_status(int max_fan, int max_temp);
void __cdecl rebuild_nonce(work *work, unsigned int nonce);
bool __cdecl test_nonce(work *work, unsigned int nonce);
bool __cdecl test_nonce_diff(work *work, unsigned int nonce, double diff);
void __cdecl update_work_stats(thr_info *thr, work *work);
void __cdecl inc_work_stats(thr_info *thr, pool *pool, int diff1);
bool __cdecl submit_tested_work(thr_info *thr, work *work);
bool __cdecl new_nonce(thr_info *thr, unsigned int nonce);
bool __cdecl Hex2Bin(unsigned __int8 *hex, unsigned __int8 *pBytes);
int __cdecl getChipIndex(unsigned __int8 *nonce4);
void __cdecl cg_savelogwork(work *work, unsigned __int8 *nonce_bin);
void __cdecl cg_savelogwork_uint32(work *work, unsigned int nonce);
bool __cdecl savelog_nonce(work *work, unsigned int nonce);
bool __cdecl submit_nonce(thr_info *thr, work *work, unsigned int nonce);
bool __cdecl submit_nonce_1(thr_info *thr, work *work, unsigned int nonce, int *nofull);
void __cdecl submit_nonce_2(work *work);
bool __cdecl submit_nonce_direct(thr_info *thr, work *work, unsigned int nonce);
bool __cdecl submit_noffset_nonce(thr_info *thr, work *work_in, unsigned int nonce, int noffset);
bool __cdecl abandon_work(work *work, timeval *wdiff, uint64_t hashes);
void __cdecl mt_disable(thr_info *mythr, const int thr_id, device_drv *drv);
void __cdecl hash_sole_work(thr_info *mythr);
void __cdecl fill_queue(thr_info *mythr, cgpu_info *cgpu, device_drv *drv, const int thr_id);
void __cdecl _add_queued(cgpu_info *cgpu, work *work);
work *__cdecl _get_queued(cgpu_info *cgpu);
work *__cdecl get_queued(cgpu_info *cgpu);
void __cdecl add_queued(cgpu_info *cgpu, work *work);
work *__cdecl get_queue_work(thr_info *thr, cgpu_info *cgpu, int thr_id);
work *__cdecl _find_work_bymidstate(work *que, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
work *__cdecl find_queued_work_bymidstate(cgpu_info *cgpu, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
work *__cdecl clone_queued_work_bymidstate(cgpu_info *cgpu, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
work *__cdecl _find_work_byid(work *que, unsigned int id);
work *__cdecl find_queued_work_byid(cgpu_info *cgpu, unsigned int id);
work *__cdecl clone_queued_work_byid(cgpu_info *cgpu, unsigned int id);
void __cdecl _work_completed(cgpu_info *cgpu, work *work);
int __cdecl age_queued_work(cgpu_info *cgpu, double secs);
void __cdecl work_completed(cgpu_info *cgpu, work *work);
work *__cdecl take_queued_work_bymidstate(cgpu_info *cgpu, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
void __cdecl flush_queue(cgpu_info *cgpu);
void __cdecl hash_queued_work(thr_info *mythr);
void __cdecl hash_driver_work(thr_info *mythr);
void *__cdecl miner_thread(void *userdata);
void __cdecl wait_lpcurrent(pool *pool);
void *__cdecl longpoll_thread(void *userdata);
void __cdecl reinit_device(cgpu_info *cgpu);
void __cdecl reap_curl(pool *pool);
void __cdecl prune_stratum_shares(pool *pool);
void *__cdecl watchpool_thread(void *userdata);
void *__cdecl watchdog_thread(void *userdata);
void __cdecl log_print_status(cgpu_info *cgpu);
void print_summary(); // idb
void __cdecl clean_up(bool restarting);
void *__cdecl killall_thread(void *arg);
void __cdecl _quit(int status, bool clean);
void __cdecl quit(int status);
void *__cdecl test_pool_thread(void *arg);
bool __cdecl add_pool_details(pool *pool, bool live, unsigned __int8 *url, unsigned __int8 *user, unsigned __int8 *pass);
void fork_monitor(); // idb
void __cdecl noop_reinit_device(cgpu_info *cgpu);
void __cdecl blank_get_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
void __cdecl noop_get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
bool __cdecl noop_get_stats(cgpu_info *cgpu);
bool __cdecl noop_thread_prepare(thr_info *thr);
uint64_t __cdecl noop_can_limit_work(thr_info *thr);
bool __cdecl noop_thread_init(thr_info *thr);
bool __cdecl noop_prepare_work(thr_info *thr, work *work);
void __cdecl noop_hw_error(thr_info *thr);
void __cdecl noop_thread_shutdown(thr_info *thr);
void __cdecl noop_thread_enable(thr_info *thr);
void __cdecl noop_detect(bool hotplug);
api_data *__cdecl noop_get_api_stats(cgpu_info *cgpu);
void __cdecl noop_hash_work(thr_info *thr);
void __cdecl generic_zero_stats(cgpu_info *cgpu);
void __cdecl fill_device_drv(device_drv *drv);
void __cdecl null_device_drv(device_drv *drv);
void __cdecl enable_device(cgpu_info *cgpu);
void adjust_mostdevs(); // idb
bool __cdecl add_cgpu(cgpu_info *cgpu);
device_drv *__cdecl copy_drv(device_drv *drv);
void probe_pools(); // idb
void setStartTimePoint(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
unsigned __int16 __cdecl crc16(const unsigned __int8 *buffer, int len);
unsigned int __cdecl swab32_0(unsigned int v);
void __cdecl flip32_0(void *dest_p, const void *src_p);
void __cdecl mutex_lock_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl hexdump(const unsigned __int8 *p, unsigned int len);
unsigned int get_iic(); // idb
unsigned __int8 __cdecl set_iic(unsigned int data);
unsigned __int8 __cdecl T9_plus_write_pic_iic(bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 data);
unsigned __int8 __cdecl s11_write_vol_iic(bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned __int8 data);
int __cdecl dsPIC33EP16GS202_jump_to_app_from_loader(unsigned __int8 which_iic);
int __cdecl dsPIC33EP16GS202_reset_pic(unsigned __int8 which_iic);
int __cdecl dsPIC33EP16GS202_pic_heart_beat(unsigned __int8 which_iic);
int __cdecl dsPIC33EP16GS202_enable_pic_dc_dc(unsigned __int8 which_iic, unsigned __int8 enable);
int __cdecl dsPIC33EP16GS202_enable_pic_dc_dc_75j(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned __int8 enable);
int __cdecl dsPIC33EP16GS202_enable_pic_fix_voltage(unsigned __int8 which_iic, unsigned __int8 enable);
bool __cdecl isDisabledCore(int chainIndex, int chipIndex, int coreIndex);
int hasDisabledCore();
bool __cdecl chainHasDisabledCore(int chainIndex);
char __cdecl getMeddleOffsetForTestPatten(int chainIndex);
bool isFixedFreqMode(); // idb
bool isC5_Board(); // idb
uint16_t __cdecl CRC16(const unsigned __int8 *p_data, uint16_t w_len);
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len);
void __noreturn get_hash_rate();
void __cdecl read_fpga_id(unsigned __int8 *pFpgaID);
unsigned __int8 __cdecl getPICvoltageFromValue(int vol_value);
int __cdecl getVolValueFromPICvoltage(unsigned __int8 vol_pic);
void __cdecl getPICChainIndexOffset(int chainIndex, int *pChain, int *pOffset);
int __cdecl getChainAsicFreqIndex(int chainIndex, int asicIndex);
int get_pic_iic();
unsigned __int8 __cdecl set_pic_iic(unsigned int data);
unsigned __int8 __cdecl write_pic_iic(bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 chain, unsigned __int8 data);
void __cdecl send_pic_command(unsigned __int8 chain);
void __cdecl set_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 addr_H, unsigned __int8 addr_L);
void __cdecl send_data_to_pic_iic(unsigned __int8 chain, unsigned __int8 command, unsigned __int8 *buf, unsigned __int8 length);
void __cdecl get_data_from_pic_iic(unsigned __int8 chain, unsigned __int8 command, unsigned __int8 *buf, unsigned __int8 length);
void __cdecl send_data_to_pic_flash(unsigned __int8 chain, unsigned __int8 *buf);
void __cdecl get_data_from_pic_flash(unsigned __int8 chain, unsigned __int8 *buf);
unsigned __int8 __cdecl erase_pic_flash(unsigned __int8 chain);
unsigned __int8 __cdecl erase_pic_flash_all(unsigned __int8 chain);
void __cdecl set_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value);
void __cdecl get_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value);
unsigned __int8 __cdecl write_data_into_pic_flash(unsigned __int8 chain);
unsigned __int8 __cdecl jump_to_app_from_loader(unsigned __int8 chain);
unsigned __int8 __cdecl reset_iic_pic(unsigned __int8 chain);
void __cdecl get_pic_software_version(unsigned __int8 chain, unsigned __int8 *version);
void __cdecl update_pic_program(unsigned __int8 chain);
void __cdecl jump_to_app_CheckAndRestorePIC(int chainIndex);
void __cdecl get_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 *addr_H, unsigned __int8 *addr_L);
unsigned __int8 __cdecl write_EEPROM_iic(bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 data);
void __cdecl AT24C02_write_one_byte(unsigned __int8 address, unsigned __int8 data, unsigned __int8 which_iic);
unsigned __int8 __cdecl AT24C02_read_one_byte(unsigned __int8 address, unsigned __int8 which_iic);
void __cdecl AT24C02_write_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 length);
void __cdecl AT24C02_read_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 length);
unsigned __int8 __cdecl read_disabled_cores(unsigned __int8 chain, unsigned __int8 *buf);
unsigned __int8 __cdecl read_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf);
unsigned __int8 __cdecl save_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf);
void __cdecl AT24C02_save_voltage(unsigned __int8 which_iic, unsigned __int8 voltage);
unsigned __int8 __cdecl AT24C02_read_voltage(unsigned __int8 which_iic);
unsigned __int8 __cdecl AT24C02_read_freq_one_chip(unsigned __int8 which_iic);
int __cdecl set_Voltage_S9_plus_plus_BM1387_54(unsigned __int8 which_iic, unsigned __int8 pic_voltage);
int __cdecl set_voltage_s11_into_PIC(unsigned __int8 which_chain, unsigned int pic_voltage);
int __cdecl set_voltage_s11_into_PIC_without_disable(unsigned __int8 which_chain, unsigned int pic_voltage);
int __cdecl set_Voltage_S9_plus_plus_BM1387_54_without_disable(unsigned __int8 which_iic, unsigned __int8 pic_voltage);
void __cdecl set_voltage_T9_18_into_PIC(unsigned __int8 chain, unsigned __int8 voltage);
void __cdecl set_voltage_T9_18_into_PIC_without_disable(unsigned __int8 chain, unsigned __int8 voltage);
unsigned __int8 __cdecl getHighestVoltagePIC(int chainIndex);
void __cdecl set_pic_voltage_T9_18(unsigned __int8 chain);
void __cdecl set_pic_voltage(unsigned __int8 chain, unsigned __int8 voltage);
unsigned __int8 __cdecl get_pic_voltage(unsigned __int8 chain);
void __cdecl set_voltage_setting_time(unsigned __int8 chain, unsigned __int8 *time);
void __cdecl set_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id);
void __cdecl get_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id);
void __cdecl write_host_MAC_and_time(unsigned __int8 chain, unsigned __int8 *buf);
void __cdecl enable_pic_dc_dc(unsigned __int8 chain);
void enable_pic_dc_dc_all(); // idb
void __cdecl enable_pic_dac(unsigned __int8 chain);
void __cdecl disable_pic_dac(unsigned __int8 chain);
void __cdecl pic_heart_beat_each_chain(unsigned __int8 chain);
unsigned int get_nonce2_and_job_id_store_address();
void __cdecl set_nonce2_and_job_id_store_address(unsigned int value);
int get_job_start_address(); // idb
void __cdecl set_job_start_address(unsigned int value);
void __cdecl set_bmc_counter(unsigned int value);
unsigned int read_bmc_counter(); // idb
int get_QN_write_data_command(); // idb
void __cdecl set_QN_write_data_command(unsigned int value);
void __cdecl set_reset_hashboard(int chainIndex, int resetBit);
void reset_down_hash_board(); // idb
void reset_up_hash_board(); // idb
void reset_hash_board(); // idb
void __cdecl set_reset_allhashboard(int resetBit);
int bitmain_axi_init(); // idb
int bitmain_axi_Reinit(); // idb
int bitmain_axi_close(); // idb
int get_fan_control(); // idb
void __cdecl set_fan_control(unsigned int value);
int get_hash_on_plug(); // idb
unsigned int get_crc_count(); // idb
int get_hardware_version(); // idb
void __cdecl set_Hardware_version(unsigned int value);
int __cdecl get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed);
unsigned int get_temperature_0_3();
unsigned int get_temperature_4_7();
unsigned int get_temperature_8_11();
unsigned int get_temperature_12_15();
int get_time_out_control(); // idb
void __cdecl set_time_out_control(unsigned int value);
int get_bt8d_control(); // idb
void __cdecl set_bt8d_control(unsigned int value);
int __cdecl get_BC_command_buffer(unsigned int *buf);
void __cdecl set_BC_command_buffer(unsigned int *value);
void __cdecl set_BC_command_buffer_t(unsigned int *value);
unsigned int get_nonce_number_in_fifo();
int __cdecl get_return_nonce(unsigned int *buf);
int get_BC_write_command(); // idb
void __cdecl set_BC_write_command(unsigned int value);
int get_ticket_mask(); // idb
void __cdecl set_ticket_mask(unsigned int value);
int get_job_id(); // idb
void __cdecl set_job_id(unsigned int value);
int get_job_length(); // idb
void __cdecl set_job_length(unsigned int value);
int get_block_header_version(); // idb
void __cdecl set_block_header_version(unsigned int value);
int get_time_stamp(); // idb
void __cdecl set_time_stamp(unsigned int value);
int get_target_bits(); // idb
void __cdecl set_target_bits(unsigned int value);
int __cdecl get_pre_header_hash(unsigned int *buf);
void __cdecl set_pre_header_hash(unsigned int *value);
int get_coinbase_length_and_nonce2_length(); // idb
void __cdecl set_coinbase_length_and_nonce2_length(unsigned int value);
int __cdecl get_work_nonce2(unsigned int *buf);
void __cdecl set_work_nonce2(unsigned int *value);
int get_merkle_bin_number(); // idb
void __cdecl set_merkle_bin_number(unsigned int value);
int get_nonce_fifo_interrupt(); // idb
void __cdecl set_nonce_fifo_interrupt(unsigned int value);
int get_dhash_acc_control(); // idb
void __cdecl set_dhash_acc_control(unsigned int value);
void __cdecl set_TW_write_command(unsigned int *value);
void __cdecl set_TW_write_command_vil(unsigned int *value);
unsigned int get_buffer_space();
int get_hash_counting_number(); // idb
void __cdecl set_hash_counting_number(unsigned int value);
void check_chain(); // idb
void check_fan(); // idb
void check_fan_beforeInit(); // idb
void __cdecl set_PWM(unsigned __int8 pwm_percent);
int isTempTooLow();
void CheckChainTempTooLowFlag(); // idb
void setChainTempTooLowFlag(); // idb
void set_PWM_according_to_temperature(); // idb
void set_PWM_to_target_temperature(); // idb
bool is_temp_adjusted_to_target(); // idb
void wait_for_target_temp(); // idb
void __cdecl get_plldata(int type, int freq, unsigned int *reg_data, uint16_t *reg_data2, unsigned int *vil_data);
void __cdecl set_frequency_with_addr_plldatai(int pllindex, unsigned __int8 mode, unsigned __int8 addr, unsigned __int8 chain);
int __cdecl get_pll_index(int freq);
int __cdecl get_index_from_high_pll(int freq);
int __cdecl get_freqvalue_by_index(int index);
int GetTotalRate(); // idb
int __cdecl GetRealBoardRate(int chainIndex);
int __cdecl GetBoardRate(int chainIndex);
bool isChainEnough(); // idb
int __cdecl ConvirtTotalRate(int totalRate);
int DownOneChipFreqOneStep();
void ProcessFixFreq(); // idb
void ProcessFixFreqForChips(); // idb
void __cdecl set_divider(unsigned int div, unsigned int chain, unsigned int mode, unsigned __int8 addr);
int __cdecl set_frequency_with_addr(unsigned int frequency, unsigned __int8 mode, unsigned __int8 addr, unsigned __int8 chain);
void __cdecl set_frequency_B1393(unsigned int freq);
void __cdecl update_frequency_B1393(unsigned int freq, unsigned int chain, unsigned int mode, unsigned __int8 addr);
void __cdecl set_frequency_new_B1393(unsigned __int16 frequency);
void clear_nonce_fifo(); // idb
void clear_register_value_buf(); // idb
void __cdecl read_asic_register(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 chip_addr, unsigned __int8 reg_addr);
void __cdecl read_temp(unsigned __int8 device, unsigned int reg, unsigned __int8 data, unsigned __int8 write, unsigned __int8 chip_addr, int chain);
void __cdecl suffix_string_soc(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display);
void showAllBadRTInfo(); // idb
bool __cdecl check_asic_reg(unsigned int reg);
void __cdecl reset_one_hashboard(int chainIndex);
bool __cdecl check_asic_reg_oneChain(int chainIndex, unsigned int reg);
unsigned int __cdecl check_asic_reg_with_addr_test(unsigned int reg, unsigned __int8 chip_addr, unsigned int chain, int check_num);
unsigned int __cdecl check_asic_reg_with_addr(unsigned int reg, unsigned __int8 chip_addr, unsigned int chain, int check_num);
unsigned int __cdecl wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update);
unsigned int __cdecl check_reg_temp(unsigned __int8 device, unsigned int reg, unsigned __int8 data, unsigned __int8 write, unsigned __int8 chip_addr, int chain);
int8_t __cdecl calc_offset(int remote, int local);
int16_t __cdecl get_remote(int16_t remote);
int16_t __cdecl get_local(int16_t local);
int8_t __cdecl do_calibration_sensor_offset(unsigned __int8 device, unsigned __int8 chip_addr, int chain, int temp_chip_index);
void __cdecl set_misc_control(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 addr, int i2c);
void __cdecl set_general_i2c(unsigned __int8 chain, unsigned __int8 chip_addr, int bottom_or_mid, unsigned __int8 reg, unsigned __int8 device, unsigned __int8 data, unsigned __int8 write);
void __cdecl set_baud_with_addr(unsigned __int8 bauddiv, int mode, unsigned __int8 chip_addr, int chain, int iic, int open_core, int bottom_or_mid);
int8_t __cdecl calibration_sensor_offset(unsigned __int8 device, int chain);
int __cdecl fakeMiddleTempFromPCB(int local_temp);
void __noreturn read_temp_func();
void __noreturn scanfreq_read_temp_func();
void __cdecl chain_inactive(unsigned __int8 chain);
void __cdecl set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address);
int __cdecl calculate_asic_number(unsigned int actual_asic_number);
int __cdecl calculate_core_number(unsigned int actual_core_number);
void __cdecl software_set_address_onChain(int chainIndex);
void __cdecl set_core_number_BM1390(unsigned __int8 which_chain, unsigned __int8 chip_addr);
void __cdecl software_set_address(int addrInterval);
void __cdecl set_asic_ticket_mask(unsigned int ticket_mask);
void __cdecl set_sno(unsigned int sno);
void __cdecl set_hcnt(unsigned int hcnt);
void __cdecl set_baud(unsigned __int8 bauddiv, int no_use);
void init_uart_baud(); // idb
void __cdecl set_led(bool stop);
void __noreturn pic_heart_beat_func();
int __cdecl get_asic_nonce_num(int chain, int asic, int timeslice);
void __cdecl get_lastn_nonce_num(unsigned __int8 *dest, int n);
void __noreturn check_system_work();
void __cdecl enable_core_clock_BM1393(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 chain);
void __cdecl open_core_BM1393_pre_open(unsigned __int8 num, unsigned __int8 set);
void __cdecl open_core_bm1393(bool nullwork_enable);
void __noreturn get_nonce_and_register();
void set_nonce2_jobid_phy_addr(); // idb
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length);
void __cdecl set_core_cmd_BM1393(core_cmd *core);
void read_clock_delay_control(); // idb
void read_clock_delay_control_all_chip(); // idb
void read_clock_delay_control_all_chip_one_core(); // idb
void set_clock_delay_control(); // idb
void __cdecl set_core_clock_sel(unsigned __int8 chain, unsigned __int8 sel_index);
void __cdecl rewrite_clock_delay_control(unsigned __int8 chain, unsigned __int8 chip_addr, unsigned __int8 core_id, unsigned __int8 core_data);
unsigned __int8 __cdecl c2hex(unsigned __int8 value);
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __cdecl s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen);
int __cdecl get_work_of_core(int which_asic, int which_core, FILE *stream, int count);
int scanfreq_get_works(); // idb
void __cdecl scanfreq_set_voltage(int voltage);
void __cdecl scanfreq_set_voltage_75j(int voltage);
void __cdecl scanfreq_set_voltage_without_disable(int voltage);
void __cdecl scanfreq_set_voltage_without_disable_75j(int voltage);
int __cdecl decrease_voltage_75j(unsigned __int8 which_chain, int opencore_vol, int target_vol, int step);
void scanfreq_init_pic(); // idb
void scanfreq_check_asic_num(); // idb
void check_domain_volt(); // idb
int __cdecl get_index_from_high_pll_yf(int freq);
int __cdecl get_index_from_pll_B1393(int pll);
void __cdecl get_plldata_from_index(int index, unsigned __int8 *vil_pll);
int __cdecl get_pllparam_divider(float freq, unsigned int *pll_param, unsigned __int8 *divider, float *pll_freq);
void __cdecl set_config_BM1393(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 mode, unsigned __int8 reg, unsigned int reg_data);
void __cdecl change_high_pll_test(unsigned __int8 chain, float freq, int index);
void __cdecl change_high_pll_by_pll_no(unsigned __int8 chain, float freq, int pll_no);
void __cdecl set_freq_by_chip(unsigned __int8 chain, unsigned __int8 chip_addr, float freq);
void __cdecl set_freq_yf(float freq);
void __cdecl set_freq_switch_two_pll(float freq, float nextfreq);
void __cdecl set_core_clock_delay_control_one_chain(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 data, int chain);
void __cdecl enable_core_clock_BM1390(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 chain);
void __cdecl open_core_BM1393_pre_open_yf(unsigned __int8 num, int chain);
void __cdecl open_core_BM1393_S11_single_board(unsigned __int8 chain);
void scanfreq_read_temp(); // idb
void __cdecl increase_freq_slowly(float init_freq, float final_freq, float freq_step);
void __cdecl increase_freq_slowly_chain(int chainid, float init_freq, float final_freq, float freq_step);
int __cdecl scanfreq_init(int max_freq);
int scanfreq_is_all_finished();
void __cdecl scanfreq_get_next_freq_chain(int chain);
int scanfreq_get_next_freq(); // idb
int scanfreq_get_max_freq_index(); // idb
int scanfreq_init_freq_level(); // idb
void __cdecl clear_nonce_return_back_flag(int chain);
void scanfreq_reset_result(); // idb
void *__cdecl scanfreq_send_work(void *arg);
int __cdecl check_hw(SCAN_FREQ_WORK *work, unsigned int nonce, bool print);
void __cdecl Nonce_Match(int chain, unsigned int buf, unsigned int which_pattern);
void *__cdecl scanfreq_receive_nonce_register(void *arg);
bool __cdecl isDisabledChipCore(int chainIndex, int chipIndex, int coreIndex);
void __cdecl UpdateAsicCoreEnabledFlag(int chainIndex);
int __cdecl getChainAsicTempBadCoreNum(int chainIndex, int asicIndex);
void scanfreq_read_core_hash_clock_counter(); // idb
void scanfreq_read_hash_clock_counter_all_chip_one_core(); // idb
void scanfreq_print_core_hash_clock_counter(); // idb
void scanfreq_print_core_hash_clock_counter_error(); // idb
void scanfreq_print_core_clock_delay_control_error(); // idb
void scanfreq_find_all_error_clock_delay_control_asic(); // idb
void scanfreq_rewrite_error_clock_delay_control_asic(); // idb
void __cdecl scanfreq_print_bad_chip(int chain);
void scanfreq_print_nonce_zero_core_chip(); // idb
int scanfreq_print_nonce_info(); // idb
void scanfreq_check_result(); // idb
void scanfreq_finish(); // idb
int scanfreq_needed();
int scanfreq_prepare(); // idb
void bitmain_scan_freq(); // idb
int __cdecl bitmain_soc_init(init_config config);
void bitmain_core_reInit(); // idb
int __cdecl parse_job_to_soc(unsigned __int8 **buf, pool *pool, unsigned int id);
void __cdecl show_status(int if_quit);
void __cdecl show_pool_status(pool *pool, uint64_t nonce2);
int __cdecl send_job(unsigned __int8 *buf, pool *pool);
void re_send_last_job(); // idb
void __cdecl copy_pool_stratum(pool *pool_stratum, pool *pool);
bool __cdecl bitmain_soc_prepare(thr_info *thr);
void __cdecl bitmain_soc_reinit_device(cgpu_info *bitmain);
void __cdecl bitmain_soc_detect(bool hotplug);
void __cdecl btm_save_core_nonce(int asic, int core, int chain);
void btm_clear_core_nonce(); // idb
void __cdecl btm_init_core_nonce_file(unsigned int num);
void btm_init_open_again_file(); // idb
void __cdecl btm_enable_one_corebyasic(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 chain, unsigned __int8 chip_addr);
void __cdecl btm_reopen_core_again(int asic, int core, int chain);
FILE *__cdecl btm_open_core_nonce_file(unsigned int num);
void btm_show_core_nonce(); // idb
void btm_check_open_again(); // idb
void __noreturn btm_show_core_nonce_func();
uint64_t __cdecl hashtest_submit(thr_info *thr, work *work, unsigned int nonce, unsigned __int8 *midstate, pool *pool, uint64_t nonce2, unsigned int chain_id);
void *__cdecl bitmain_scanhash(void *arg);
int64_t __cdecl bitmain_soc_scanhash(thr_info *thr);
void __cdecl bitmain_soc_update(cgpu_info *bitmain_soc);
void __cdecl get_bitmain_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *bitmain_soc);
void __cdecl remove_dot_char(unsigned __int8 *number);
void __cdecl add_dot_number(unsigned __int8 *number);
api_data *__cdecl bitmain_api_stats(cgpu_info *cgpu);
void __cdecl bitmain_soc_shutdown(thr_info *thr);
void __cdecl mutex_init_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_destroy(pthread_mutex_t *lock);
void __cdecl rwlock_init_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_destroy(pthread_rwlock_t *lock);
void __cdecl cglock_init_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_destroy(cglock_t *lock);
void __cdecl k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__cdecl k_new_store(K_LIST *list);
K_LIST *__cdecl k_new_list(const unsigned __int8 *name, size_t siz, int allocate, int limit, bool do_tail, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__cdecl k_unlink_head(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__cdecl k_unlink_head_zero(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__cdecl k_unlink_tail(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_add_head(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_add_tail(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_insert_before(K_LIST *list, K_ITEM *item, K_ITEM *before, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_insert_after(K_LIST *list, K_ITEM *item, K_ITEM *after, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_unlink_item(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_list_transfer_to_head(K_LIST *from, K_LIST *to, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_list_transfer_to_tail(K_LIST *from, K_LIST *to, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__cdecl k_free_list(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__cdecl k_free_store(K_LIST *store, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_lock_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl mutex_trylock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force);
void __cdecl applog(int prio, const unsigned __int8 *str, bool force);
void __cdecl simplelog(int prio, const unsigned __int8 *str, bool force);
void __cdecl mutex_lock_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl dupalloc(cgpu_info *cgpu, int timelimit);
void __cdecl dupcounters(cgpu_info *cgpu, uint64_t *checked, uint64_t *dups);
bool __cdecl isdupnonce(cgpu_info *cgpu, work *work, unsigned int nonce);
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __cdecl sha2_starts(sha2_context *ctx);
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
void __cdecl json_decref_1(json_t_0 *json);
void __cdecl _list_add(list_head *new, list_head *prev, list_head *next);
void __cdecl list_add_tail(list_head *new, list_head *head);
void __cdecl _list_del_0(list_head *prev, list_head *next);
void __cdecl list_del_0(list_head *entry);
int __cdecl list_empty(list_head *head);
int sock_blocks_0();
bool sock_timeout(); // idb
bool interrupted(); // idb
void __cdecl align_len(size_t *len);
unsigned int __cdecl swab32_1(unsigned int v);
void __cdecl swab256_0(void *dest_p, const void *src_p);
void __cdecl mutex_lock_4(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_4(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_4(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_3(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_3(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_3(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_3(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_3(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int no_yield(); // idb
void __cdecl keep_sockalive(int fd);
void *__cdecl cgmalloc(unsigned int size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__cdecl cgcalloc(int memb, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__cdecl cgrealloc(void *ptr, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
const unsigned __int8 *__cdecl proxytype(proxytypes_t proxytype);
unsigned __int8 *__cdecl get_proxy(unsigned __int8 *url, pool *pool);
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len);
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len);
bool __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len);
bool __cdecl valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl valid_ascii(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl b58tobin(unsigned __int8 *b58bin, const unsigned __int8 *b58);
void __cdecl address_to_pubkeyhash(unsigned __int8 *pkh, const unsigned __int8 *addr);
int __cdecl ser_number(unsigned __int8 *s, int32_t val);
unsigned __int8 *__cdecl ser_string(unsigned __int8 *s, int *slen);
bool __cdecl fulltest(const unsigned __int8 *hash, const unsigned __int8 *target);
thread_q *tq_new(); // idb
void __cdecl tq_free(thread_q *tq);
void __cdecl tq_freezethaw(thread_q *tq, bool frozen);
void __cdecl tq_freeze(thread_q *tq);
void __cdecl tq_thaw(thread_q *tq);
bool __cdecl tq_push(thread_q *tq, void *data);
void *__cdecl tq_pop(thread_q *tq, const timespec *abstime);
int __cdecl thr_info_create(thr_info *thr, pthread_attr_t *attr, void *(*start)(void *), void *arg);
void __cdecl thr_info_cancel(thr_info *thr);
void __cdecl subtime(timeval *a, timeval *b);
void __cdecl addtime(timeval *a, timeval *b);
bool __cdecl time_more(timeval *a, timeval *b);
bool __cdecl time_less(timeval *a, timeval *b);
void __cdecl copy_time(timeval *dest, const timeval *src);
void __cdecl timespec_to_val(timeval *val, const timespec *spec);
void __cdecl timeval_to_spec(timespec *spec, const timeval *val);
void __cdecl us_to_timeval(timeval *val, int64_t us);
void __cdecl us_to_timespec(timespec *spec, int64_t us);
void __cdecl ms_to_timespec(timespec *spec, int64_t ms);
void __cdecl ms_to_timeval(timeval *val, int64_t ms);
void __cdecl spec_nscheck(timespec *ts);
void __cdecl timeraddspec(timespec *a, const timespec *b);
int __cdecl timespec_to_ms(timespec *ts);
void __cdecl timersubspec(timespec *a, const timespec *b);
unsigned __int8 *__cdecl Strcasestr(unsigned __int8 *haystack, const unsigned __int8 *needle);
unsigned __int8 *__cdecl Strsep(unsigned __int8 **stringp, const unsigned __int8 *delim);
void __cdecl cgtime(timeval *tv);
int __cdecl cgtimer_to_ms(cgtimer_t *cgt);
void __cdecl cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res);
void __cdecl cgtimer_time(cgtimer_t *ts_start);
void __cdecl nanosleep_abstime(timespec *ts_end);
void __cdecl cgsleep_ms_r(cgtimer_t *ts_start, int ms);
void __cdecl cgsleep_us_r(cgtimer_t *ts_start, int64_t us);
void __cdecl cgsleep_ms(int ms);
void __cdecl cgsleep_us(int64_t us);
double __cdecl us_tdiff(timeval *end, timeval *start);
int __cdecl ms_tdiff(timeval *end, timeval *start);
double __cdecl tdiff(timeval *end, timeval *start);
bool __cdecl extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port);
send_ret __cdecl _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
bool __cdecl stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
bool __cdecl socket_full(pool *pool, int wait);
bool __cdecl sock_full(pool *pool);
void __cdecl clear_sockbuf(pool *pool);
void __cdecl clear_sock(pool *pool);
void __cdecl recalloc(void **ptr, size_t old, size_t news, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl recalloc_sock(pool *pool, size_t len);
unsigned __int8 *__cdecl recv_line(pool *pool);
unsigned __int8 *__cdecl _json_array_string(json_t_0 *val, unsigned int entry);
unsigned __int8 *__cdecl json_array_string(json_t_0 *val, unsigned int entry);
bool __cdecl parse_notify(pool *pool, json_t_0 *val);
bool __cdecl parse_version(pool *pool, json_t_0 *val);
bool __cdecl parse_diff(pool *pool, json_t_0 *val);
bool __cdecl parse_extranonce(pool *pool, json_t_0 *val);
void __cdecl _suspend_stratum(pool *pool);
bool __cdecl parse_reconnect(pool *pool, json_t_0 *val);
bool __cdecl send_version(pool *pool, json_t_0 *val);
bool __cdecl send_pong(pool *pool, json_t_0 *val);
bool __cdecl show_message(pool *pool, json_t_0 *val);
bool __cdecl parse_method(pool *pool, unsigned __int8 *s);
bool __cdecl subscribe_extranonce(pool *pool);
bool __cdecl auth_stratum(pool *pool);
int __cdecl recv_byte(int sockd);
bool __cdecl http_negotiate(pool *pool, int sockd, bool http0);
bool __cdecl socks5_negotiate(pool *pool, int sockd);
bool __cdecl socks4_negotiate(pool *pool, int sockd, bool socks4a);
void __cdecl noblock_socket(int fd);
void __cdecl block_socket(int fd);
bool sock_connecting(); // idb
bool __cdecl setup_stratum_socket(pool *pool);
unsigned __int8 *__cdecl get_sessionid(json_t_0 *val);
void __cdecl suspend_stratum(pool *pool);
bool __cdecl initiate_stratum(pool *pool);
bool __cdecl restart_stratum(pool *pool);
void __cdecl dev_error(cgpu_info *dev, dev_reason reason);
void *__cdecl realloc_strcat(unsigned __int8 *ptr, unsigned __int8 *s);
void *__cdecl str_text(unsigned __int8 *ptr);
void __cdecl RenameThread(const unsigned __int8 *name);
void __cdecl cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl cgsem_mswait(cgsem_t *cgsem, int ms, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_reset(cgsem_t *cgsem);
void __cdecl cgsem_destroy(cgsem_t *cgsem);
void *__cdecl completion_thread(void *arg);
bool __cdecl cg_completion_timeout(void *fn, void *fnarg, int timeout);
void __cdecl cg_memcpy(void *dest, const void *src, unsigned int n, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl cg_timeval_subtract(timeval *result, timeval *x, timeval *y);
void __cdecl rev(unsigned __int8 *s, size_t l);
int __cdecl check_asicnum(int asic_num, unsigned __int8 nonce);
void __cdecl cg_logwork(work *work, unsigned __int8 *nonce_bin, bool ok);
void __cdecl cg_logwork_uint32(work *work, unsigned int nonce, bool ok);
unsigned __int8 *__cdecl arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg);
unsigned __int8 *__cdecl opt_set_bool(bool *b);
unsigned __int8 *__cdecl opt_set_false(bool *b);
unsigned __int8 *__cdecl opt_set_invbool(bool *b);
unsigned __int8 *__cdecl opt_set_bool_arg(const unsigned __int8 *arg, bool *b);
unsigned __int8 *__cdecl opt_set_invbool_arg(const unsigned __int8 *arg, bool *b);
unsigned __int8 *__cdecl opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p);
unsigned __int8 *__cdecl opt_set_intval(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl opt_set_floatval(const unsigned __int8 *arg, float *f);
unsigned __int8 *__cdecl opt_set_uintval(const unsigned __int8 *arg, unsigned int *ui);
unsigned __int8 *__cdecl opt_set_longval(const unsigned __int8 *arg, int *l);
unsigned __int8 *__cdecl opt_set_ulongval(const unsigned __int8 *arg, unsigned int *ul);
unsigned __int8 *__cdecl opt_inc_intval(int *i);
unsigned __int8 *__cdecl opt_version_and_exit(const unsigned __int8 *version);
unsigned __int8 *__cdecl opt_usage_and_exit(const unsigned __int8 *extra);
void __cdecl opt_show_bool(unsigned __int8 *buf, const bool *b);
void __cdecl opt_show_invbool(unsigned __int8 *buf, const bool *b);
void __cdecl opt_show_charp(unsigned __int8 *buf, unsigned __int8 *const *p);
void __cdecl opt_show_intval(unsigned __int8 *buf, const int *i);
void __cdecl opt_show_floatval(unsigned __int8 *buf, const float *f);
void __cdecl opt_show_uintval(unsigned __int8 *buf, const unsigned int *ui);
void __cdecl opt_show_longval(unsigned __int8 *buf, const int *l);
void __cdecl opt_show_ulongval(unsigned __int8 *buf, const unsigned int *ul);
const unsigned __int8 *__cdecl first_name(const unsigned __int8 *names, unsigned int *len);
const unsigned __int8 *__cdecl next_name(const unsigned __int8 *names, unsigned int *len);
const unsigned __int8 *__cdecl first_opt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl first_lopt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl first_sopt(unsigned int *i);
const unsigned __int8 *__cdecl next_sopt(const unsigned __int8 *p, unsigned int *i);
void __cdecl check_opt(const opt_table *entry);
void __cdecl add_opt(const opt_table *entry);
void __cdecl opt_register(const unsigned __int8 *names, opt_type type, unsigned __int8 *(*cb)(void *), unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *), void (*show)(unsigned __int8 *, const void *), const void *arg, const unsigned __int8 *desc);
void __cdecl opt_register_table(const opt_table *entry, const unsigned __int8 *desc);
bool __cdecl opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...));
void opt_free_table(); // idb
void opt_log_stderr(const unsigned __int8 *fmt, ...);
void opt_log_stderr_exit(const unsigned __int8 *fmt, ...);
unsigned __int8 *__cdecl opt_invalid_argument(const unsigned __int8 *arg);
int __cdecl parse_err(void (*errlog)(const unsigned __int8 *, ...), const unsigned __int8 *argv0, const unsigned __int8 *arg, unsigned int len, const unsigned __int8 *problem);
void __cdecl consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum);
int __cdecl parse_one(int *argc, unsigned __int8 **argv, unsigned int *offset, void (*errlog)(const unsigned __int8 *, ...));
unsigned int __cdecl write_short_options(unsigned __int8 *str);
unsigned __int8 *__cdecl opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra);
int __cdecl dump_to_strbuffer(const unsigned __int8 *buffer, size_t size, void *data);
int __cdecl dump_to_file(const unsigned __int8 *buffer, size_t size, void *data);
int __cdecl dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data);
int __cdecl dump_string(const unsigned __int8 *str, size_t len, json_dump_callback_t dump, void *data, size_t flags);
int __cdecl compare_keys(const void *key1, const void *key2);
int __cdecl do_dump(const json_t_0 *json, size_t flags, int depth, json_dump_callback_t dump, void *data);
unsigned __int8 *__cdecl json_dumps(const json_t_0 *json, size_t flags);
int __cdecl json_dumpf(const json_t_0 *json, FILE *output, size_t flags);
int __cdecl json_dump_file(const json_t_0 *json, const unsigned __int8 *path, size_t flags);
int __cdecl json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags);
void __cdecl jsonp_error_init(json_error_t *error, const unsigned __int8 *source);
void __cdecl jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source);
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...);
void __cdecl jsonp_error_vset(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, va_list ap);
void __cdecl json_decref_2(json_t_0 *json);
uint32_t __cdecl hashlittle(const void *key, size_t length, uint32_t initval);
void __cdecl list_init(list_t *list);
void __cdecl list_insert(list_t *list, list_t *node);
void __cdecl list_remove(list_t *list);
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket);
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list);
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const unsigned __int8 *key, size_t hash);
int __cdecl hashtable_do_del(hashtable_t *hashtable, const unsigned __int8 *key, size_t hash);
void __cdecl hashtable_do_clear(hashtable_t *hashtable);
int __cdecl hashtable_do_rehash(hashtable_t *hashtable);
int __cdecl hashtable_init(hashtable_t *hashtable);
void __cdecl hashtable_close(hashtable_t *hashtable);
int __cdecl hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, json_t_0 *value);
void *__cdecl hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key);
int __cdecl hashtable_del(hashtable_t *hashtable, const unsigned __int8 *key);
void __cdecl hashtable_clear(hashtable_t *hashtable);
void *__cdecl hashtable_iter(hashtable_t *hashtable);
void *__cdecl hashtable_iter_at(hashtable_t *hashtable, const unsigned __int8 *key);
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter);
void *__cdecl hashtable_iter_key(void *iter);
void *__cdecl hashtable_iter_value(void *iter);
void __cdecl hashtable_iter_set(void *iter, json_t_0 *value);
uint32_t __cdecl buf_to_uint32(unsigned __int8 *data);
int __cdecl seed_from_timestamp_and_pid(uint32_t *seed);
uint32_t generate_seed(); // idb
void __cdecl json_object_seed(size_t seed);
json_t_0 *__cdecl json_incref(json_t_0 *json);
void __cdecl json_decref_3(json_t_0 *json);
int __cdecl json_object_set_nocheck(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value);
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value);
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *msg, ...);
void __cdecl stream_init(stream_t *stream, get_func get, void *data);
int __cdecl stream_get(stream_t *stream, json_error_t *error);
void __cdecl stream_unget(stream_t *stream, int c);
int __cdecl lex_get(lex_t *lex, json_error_t *error);
void __cdecl lex_save(lex_t *lex, int c);
int __cdecl lex_get_save(lex_t *lex, json_error_t *error);
void __cdecl lex_unget(lex_t *lex, int c);
void __cdecl lex_unget_unsave(lex_t *lex, int c);
void __cdecl lex_save_cached(lex_t *lex);
void __cdecl lex_free_string(lex_t *lex);
int32_t __cdecl decode_unicode_escape(const unsigned __int8 *str);
void __cdecl lex_scan_string(lex_t *lex, json_error_t *error);
int __cdecl lex_scan_number(lex_t *lex, int c, json_error_t *error);
int __cdecl lex_scan(lex_t *lex, json_error_t *error);
unsigned __int8 *__cdecl lex_steal_string(lex_t *lex, size_t *out_len);
int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data);
void __cdecl lex_close(lex_t *lex);
json_t_0 *__cdecl parse_object(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_array(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_value(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_json(lex_t *lex, size_t flags, json_error_t *error);
int __cdecl string_get(void *data);
json_t_0 *__cdecl json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error);
int __cdecl buffer_get(void *data);
json_t_0 *__cdecl json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error);
json_t_0 *__cdecl json_loadf(FILE *input, size_t flags, json_error_t *error);
json_t_0 *__cdecl json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error);
int __cdecl callback_get(void *data);
json_t_0 *__cdecl json_load_callback(json_load_callback_t callback, void *arg, size_t flags, json_error_t *error);
void *__cdecl jsonp_malloc(size_t size);
void __cdecl jsonp_free(void *ptr);
unsigned __int8 *__cdecl jsonp_strdup(const unsigned __int8 *str);
unsigned __int8 *__cdecl jsonp_strndup(const unsigned __int8 *str, size_t len);
void __cdecl json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
void __cdecl json_get_alloc_funcs(json_malloc_t *malloc_fn, json_free_t *free_fn);
json_t_0 *__cdecl json_incref_0(json_t_0 *json);
void __cdecl json_decref_4(json_t_0 *json);
void __cdecl scanner_init(scanner_t *s, json_error_t *error, size_t flags, const unsigned __int8 *fmt);
void __cdecl next_token(scanner_t *s);
void __cdecl prev_token(scanner_t *s);
void set_error(scanner_t *s, const unsigned __int8 *source, const unsigned __int8 *fmt, ...);
unsigned __int8 *__cdecl read_string(scanner_t *s, va_list *ap, const unsigned __int8 *purpose, size_t *out_len, int *ours);
json_t_0 *__cdecl pack_object(scanner_t *s, va_list *ap);
json_t_0 *__cdecl pack_array(scanner_t *s, va_list *ap);
json_t_0 *__cdecl pack_string(scanner_t *s, va_list *ap);
json_t_0 *__cdecl pack(scanner_t *s, va_list *ap);
int __cdecl unpack_object(scanner_t *s, json_t_0 *root, va_list *ap);
int __cdecl unpack_array(scanner_t *s, json_t_0 *root, va_list *ap);
int __cdecl unpack(scanner_t *s, json_t_0 *root, va_list *ap);
json_t_0 *__cdecl json_vpack_ex(json_error_t *error, size_t flags, const unsigned __int8 *fmt, va_list ap);
json_t_0 *json_pack_ex(json_error_t *error, size_t flags, const unsigned __int8 *fmt, ...);
json_t_0 *json_pack(const unsigned __int8 *fmt, ...);
int __cdecl json_vunpack_ex(json_t_0 *root, json_error_t *error, size_t flags, const unsigned __int8 *fmt, va_list ap);
int json_unpack_ex(json_t_0 *root, json_error_t *error, size_t flags, const unsigned __int8 *fmt, ...);
int json_unpack(json_t_0 *root, const unsigned __int8 *fmt, ...);
int __cdecl strbuffer_init(strbuffer_t *strbuff);
void __cdecl strbuffer_close(strbuffer_t *strbuff);
void __cdecl strbuffer_clear(strbuffer_t *strbuff);
const unsigned __int8 *__cdecl strbuffer_value(const strbuffer_t *strbuff);
unsigned __int8 *__cdecl strbuffer_steal_value(strbuffer_t *strbuff);
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte);
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size);
unsigned __int8 __cdecl strbuffer_pop(strbuffer_t *strbuff);
void __cdecl to_locale(strbuffer_t *strbuffer);
void __cdecl from_locale(unsigned __int8 *buffer);
int __cdecl jsonp_strtod(strbuffer_t *strbuffer, double *out);
int __cdecl jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value, int precision);
int __cdecl utf8_encode(int32_t codepoint, unsigned __int8 *buffer, size_t *size);
size_t __cdecl utf8_check_first(unsigned __int8 byte);
size_t __cdecl utf8_check_full(const unsigned __int8 *buffer, size_t size, int32_t *codepoint);
const unsigned __int8 *__cdecl utf8_iterate(const unsigned __int8 *buffer, size_t bufsize, int32_t *codepoint);
int __cdecl utf8_check_string(const unsigned __int8 *string, size_t length);
json_t_0 *__cdecl json_incref_1(json_t_0 *json);
void __cdecl json_decref_5(json_t_0 *json);
int __cdecl json_object_set_nocheck_0(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value);
int __cdecl json_array_append_0(json_t_0 *array, json_t_0 *value);
void __cdecl json_init(json_t_0 *json, json_type type);
json_object_t *json_object();
void __cdecl json_delete_object(json_object_t *object);
size_t __cdecl json_object_size(const json_t_0 *json);
json_t_0 *__cdecl json_object_get(const json_t_0 *json, const unsigned __int8 *key);
int __cdecl json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value);
int __cdecl json_object_set_new(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value);
int __cdecl json_object_del(json_t_0 *json, const unsigned __int8 *key);
int __cdecl json_object_clear(json_t_0 *json);
int __cdecl json_object_update(json_t_0 *object, json_t_0 *other);
int __cdecl json_object_update_existing(json_t_0 *object, json_t_0 *other);
int __cdecl json_object_update_missing(json_t_0 *object, json_t_0 *other);
void *__cdecl json_object_iter(json_t_0 *json);
void *__cdecl json_object_iter_at(json_t_0 *json, const unsigned __int8 *key);
void *__cdecl json_object_iter_next(json_t_0 *json, void *iter);
const unsigned __int8 *__cdecl json_object_iter_key(void *iter);
json_t_0 *__cdecl json_object_iter_value(void *iter);
int __cdecl json_object_iter_set_new(json_t_0 *json, void *iter, json_t_0 *value);
void *__cdecl json_object_key_to_iter(const unsigned __int8 *key);
int __cdecl json_object_equal(json_t_0 *object1, json_t_0 *object2);
json_t_0 *__cdecl json_object_copy(json_t_0 *object);
json_t_0 *__cdecl json_object_deep_copy(const json_t_0 *object);
json_array_t *json_array();
void __cdecl json_delete_array(json_array_t *array);
size_t __cdecl json_array_size(const json_t_0 *json);
json_t_0 *__cdecl json_array_get(const json_t_0 *json, size_t index);
int __cdecl json_array_set_new(json_t_0 *json, size_t index, json_t_0 *value);
void __cdecl array_move(json_array_t *array, size_t dest, size_t src, size_t count);
void __cdecl array_copy(json_t_0 **dest, size_t dpos, json_t_0 **src, size_t spos, size_t count);
json_t_0 **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy);
int __cdecl json_array_append_new(json_t_0 *json, json_t_0 *value);
int __cdecl json_array_insert_new(json_t_0 *json, size_t index, json_t_0 *value);
int __cdecl json_array_remove(json_t_0 *json, size_t index);
int __cdecl json_array_clear(json_t_0 *json);
int __cdecl json_array_extend(json_t_0 *json, json_t_0 *other_json);
int __cdecl json_array_equal(json_t_0 *array1, json_t_0 *array2);
json_t_0 *__cdecl json_array_copy(json_t_0 *array);
json_t_0 *__cdecl json_array_deep_copy(const json_t_0 *array);
json_t_0 *__cdecl string_create(const unsigned __int8 *value, size_t len, int own);
json_t_0 *__cdecl json_string_nocheck(const unsigned __int8 *value);
json_t_0 *__cdecl json_stringn_nocheck(const unsigned __int8 *value, size_t len);
json_t_0 *__cdecl jsonp_stringn_nocheck_own(const unsigned __int8 *value, size_t len);
json_t_0 *__cdecl json_string(const unsigned __int8 *value);
json_t_0 *__cdecl json_stringn(const unsigned __int8 *value, size_t len);
const unsigned __int8 *__cdecl json_string_value(const json_t_0 *json);
size_t __cdecl json_string_length(const json_t_0 *json);
int __cdecl json_string_set_nocheck(json_t_0 *json, const unsigned __int8 *value);
int __cdecl json_string_setn_nocheck(json_t_0 *json, const unsigned __int8 *value, size_t len);
int __cdecl json_string_set(json_t_0 *json, const unsigned __int8 *value);
int __cdecl json_string_setn(json_t_0 *json, const unsigned __int8 *value, size_t len);
void __cdecl json_delete_string(json_string_t *string);
int __cdecl json_string_equal(json_t_0 *string1, json_t_0 *string2);
json_t_0 *__cdecl json_string_copy(const json_t_0 *string);
json_t_0 *__cdecl json_integer(json_int_t value);
json_int_t __cdecl json_integer_value(const json_t_0 *json);
int __cdecl json_integer_set(json_t_0 *json, json_int_t value);
void __cdecl json_delete_integer(json_integer_t *integer);
int __cdecl json_integer_equal(json_t_0 *integer1, json_t_0 *integer2);
json_t_0 *__cdecl json_integer_copy(const json_t_0 *integer);
json_t_0 *__cdecl json_real(double value);
double __cdecl json_real_value(const json_t_0 *json);
int __cdecl json_real_set(json_t_0 *json, double value);
void __cdecl json_delete_real(json_real_t *real);
int __cdecl json_real_equal(json_t_0 *real1, json_t_0 *real2);
json_t_0 *__cdecl json_real_copy(const json_t_0 *real);
double __cdecl json_number_value(const json_t_0 *json);
json_t_0 *json_true(); // idb
json_t_0 *json_false(); // idb
json_t_0 *json_null(); // idb
void __cdecl json_delete(json_t_0 *json);
int __cdecl json_equal(json_t_0 *json1, json_t_0 *json2);
json_t_0 *__cdecl json_copy(json_t_0 *json);
json_t_0 *__cdecl json_deep_copy(const json_t_0 *json);
void *__cdecl rpl_memchr(const void *s, int c_in, size_t n);
size_t __cdecl critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period);
void *__cdecl two_way_short_needle(const unsigned __int8 *haystack, size_t haystack_len, const unsigned __int8 *needle, size_t needle_len);
void *__cdecl two_way_long_needle(const unsigned __int8 *haystack, size_t haystack_len, const unsigned __int8 *needle, size_t needle_len);
void *__cdecl memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len);
int __fastcall divsi3_skip_div0_test(int result, unsigned int); // idb
int _aeabi_ldiv0();
__int64 __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3);
unsigned __int64 __fastcall _gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3);
__int64 init();
int _libc_csu_fini(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_6BA00; // weak
_UNKNOWN unk_6C900; // weak
const unsigned __int8 SEPARATOR = 124u; // idb
const unsigned __int8 ISJSON = 123u; // idb
const unsigned __int8 _func___11165[4] = { 97u, 112u, 105u, 0u }; // idb
const unsigned __int8 _func___11127[11] = { 109u, 99u, 97u, 115u, 116u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _func___11104[6] = { 109u, 99u, 97u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___11049[14] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 111u, 110u, 110u, 101u, 99u, 116u, 0u }; // idb
const unsigned __int8 _func___11036[15] =
{
  114u,
  101u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___11031[12] = { 113u, 117u, 105u, 116u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___10996[15] =
{
  115u,
  101u,
  116u,
  117u,
  112u,
  95u,
  105u,
  112u,
  97u,
  99u,
  99u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___10958[13] = { 115u, 101u, 116u, 117u, 112u, 95u, 103u, 114u, 111u, 117u, 112u, 115u, 0u }; // idb
const unsigned __int8 _func___10942[7] = { 116u, 105u, 100u, 121u, 117u, 112u, 0u }; // idb
const unsigned __int8 _func___10858[8] = { 108u, 99u, 100u, 100u, 97u, 116u, 97u, 0u }; // idb
const unsigned __int8 _func___10785[10] = { 97u, 115u, 99u, 101u, 110u, 97u, 98u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___10706[9] = { 109u, 105u, 110u, 101u, 99u, 111u, 105u, 110u, 0u }; // idb
const unsigned __int8 _func___10483[12] = { 112u, 111u, 111u, 108u, 100u, 101u, 116u, 97u, 105u, 108u, 115u, 0u }; // idb
const unsigned __int8 _func___10466[11] = { 115u, 119u, 105u, 116u, 99u, 104u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___10433[8] = { 115u, 117u, 109u, 109u, 97u, 114u, 121u, 0u }; // idb
const unsigned __int8 _func___10245[10] = { 97u, 115u, 99u, 100u, 101u, 118u, 105u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___10236[8] = { 110u, 117u, 109u, 97u, 115u, 99u, 115u, 0u }; // idb
const unsigned __int8 _func___10197[11] = { 112u, 114u, 105u, 110u, 116u, 95u, 100u, 97u, 116u, 97u, 0u }; // idb
const unsigned __int8 _func___10183[13] = { 97u, 100u, 100u, 95u, 105u, 116u, 101u, 109u, 95u, 98u, 117u, 102u, 0u }; // idb
const unsigned __int8 _func___9981[18] =
{
  97u,
  112u,
  105u,
  95u,
  97u,
  100u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  102u,
  117u,
  108u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___9957[14] =
{
  101u,
  115u,
  99u,
  97u,
  112u,
  101u,
  95u,
  115u,
  116u,
  114u,
  105u,
  110u,
  103u,
  0u
}; // idb
const unsigned __int8 _func___9927[7] = { 105u, 111u, 95u, 97u, 100u, 100u, 0u }; // idb
const unsigned __int8 _func___9918[8] = { 95u, 105u, 111u, 95u, 110u, 101u, 119u, 0u }; // idb
const unsigned __int8 bench_hidiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    50u,
    98u,
    49u,
    53u,
    49u,
    52u,
    101u,
    55u,
    98u,
    54u,
    53u,
    54u,
    53u,
    57u,
    52u,
    49u,
    101u,
    53u,
    56u,
    50u,
    52u,
    102u,
    48u,
    56u,
    52u,
    50u,
    57u,
    50u,
    49u,
    54u,
    52u,
    101u,
    99u,
    53u,
    102u,
    57u,
    55u,
    101u,
    55u,
    101u,
    97u,
    50u,
    48u,
    99u,
    52u,
    57u,
    52u,
    98u,
    100u,
    57u,
    54u,
    101u,
    53u,
    50u,
    52u,
    100u,
    52u,
    55u,
    56u,
    57u,
    55u,
    55u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    50u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    98u,
    49u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    101u,
    52u,
    101u,
    51u,
    98u,
    101u,
    99u,
    99u,
    48u,
    49u,
    48u,
    54u,
    52u,
    100u,
    56u,
    48u,
    56u,
    50u,
    54u,
    57u,
    98u,
    51u,
    51u,
    48u,
    102u,
    52u,
    48u,
    102u,
    52u,
    100u,
    101u,
    56u,
    50u,
    100u,
    99u,
    57u,
    50u,
    101u,
    56u,
    57u,
    52u,
    100u,
    54u,
    51u,
    53u,
    48u,
    50u,
    53u,
    100u,
    97u,
    97u,
    51u,
    101u,
    50u,
    101u,
    50u,
    99u,
    52u,
    49u,
    48u,
    98u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    57u,
    101u,
    98u,
    98u,
    99u,
    101u,
    50u,
    102u,
    53u,
    102u,
    48u,
    100u,
    54u,
    99u,
    99u,
    48u,
    97u,
    99u,
    97u,
    50u,
    56u,
    52u,
    101u,
    99u,
    98u,
    49u,
    48u,
    53u,
    57u,
    99u,
    56u,
    53u,
    54u,
    101u,
    102u,
    50u,
    102u,
    55u,
    102u,
    52u,
    50u,
    101u,
    55u,
    101u,
    100u,
    100u,
    52u,
    48u,
    51u,
    100u,
    50u,
    52u,
    54u,
    55u,
    53u,
    52u,
    101u,
    101u,
    52u,
    99u,
    57u,
    48u,
    53u,
    97u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    102u,
    100u,
    97u,
    48u,
    51u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    55u,
    56u,
    100u,
    97u,
    102u,
    49u,
    98u,
    53u,
    101u,
    98u,
    51u,
    51u,
    57u,
    55u,
    97u,
    102u,
    49u,
    99u,
    48u,
    48u,
    100u,
    98u,
    100u,
    57u,
    98u,
    48u,
    54u,
    54u,
    53u,
    57u,
    99u,
    100u,
    99u,
    48u,
    52u,
    49u,
    56u,
    51u,
    99u,
    56u,
    98u,
    97u,
    97u,
    102u,
    53u,
    98u,
    101u,
    49u,
    100u,
    98u,
    102u,
    51u,
    50u,
    102u,
    55u,
    57u,
    101u,
    48u,
    48u,
    52u,
    53u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    48u,
    52u,
    54u,
    53u,
    48u,
    97u,
    56u,
    101u,
    55u,
    52u,
    56u,
    100u,
    50u,
    101u,
    54u,
    102u,
    100u,
    101u,
    56u,
    54u,
    97u,
    56u,
    97u,
    57u,
    50u,
    48u,
    98u,
    50u,
    56u,
    53u,
    102u,
    51u,
    101u,
    50u,
    50u,
    51u,
    57u,
    56u,
    102u,
    53u,
    56u,
    51u,
    55u,
    48u,
    48u,
    50u,
    51u,
    54u,
    57u,
    53u,
    56u,
    51u,
    50u,
    51u,
    101u,
    102u,
    57u,
    101u,
    97u,
    56u,
    51u,
    50u,
    49u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    52u,
    53u,
    55u,
    48u,
    101u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    49u,
    100u,
    54u,
    53u,
    52u,
    97u,
    101u,
    50u,
    98u,
    48u,
    54u,
    102u,
    50u,
    49u,
    57u,
    99u,
    99u,
    102u,
    52u,
    54u,
    48u,
    49u,
    57u,
    51u,
    51u,
    102u,
    97u,
    98u,
    52u,
    48u,
    56u,
    100u,
    101u,
    49u,
    99u,
    51u,
    98u,
    55u,
    99u,
    56u,
    99u,
    57u,
    99u,
    56u,
    53u,
    101u,
    48u,
    51u,
    50u,
    51u,
    49u,
    100u,
    52u,
    97u,
    97u,
    102u,
    53u,
    97u,
    50u,
    54u,
    99u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    52u,
    98u,
    51u,
    57u,
    49u,
    51u,
    52u,
    99u,
    50u,
    57u,
    51u,
    48u,
    100u,
    50u,
    102u,
    50u,
    101u,
    55u,
    51u,
    51u,
    57u,
    102u,
    57u,
    100u,
    53u,
    48u,
    50u,
    99u,
    55u,
    55u,
    54u,
    99u,
    52u,
    52u,
    100u,
    54u,
    101u,
    101u,
    53u,
    57u,
    57u,
    102u,
    55u,
    101u,
    102u,
    101u,
    98u,
    101u,
    99u,
    54u,
    99u,
    57u,
    98u,
    98u,
    100u,
    48u,
    52u,
    55u,
    56u,
    55u,
    97u,
    97u,
    101u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    50u,
    55u,
    49u,
    48u,
    102u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    57u,
    52u,
    101u,
    54u,
    48u,
    99u,
    49u,
    49u,
    56u,
    48u,
    48u,
    50u,
    50u,
    102u,
    51u,
    51u,
    55u,
    50u,
    51u,
    50u,
    97u,
    98u,
    51u,
    100u,
    50u,
    57u,
    56u,
    102u,
    56u,
    51u,
    56u,
    51u,
    48u,
    52u,
    98u,
    54u,
    48u,
    48u,
    56u,
    97u,
    98u,
    50u,
    51u,
    55u,
    99u,
    102u,
    55u,
    101u,
    49u,
    55u,
    49u,
    55u,
    102u,
    49u,
    57u,
    51u,
    51u,
    52u,
    48u,
    55u,
    101u,
    53u,
    57u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    53u,
    98u,
    56u,
    50u,
    49u,
    102u,
    98u,
    48u,
    98u,
    50u,
    54u,
    100u,
    54u,
    51u,
    98u,
    48u,
    48u,
    99u,
    99u,
    50u,
    54u,
    101u,
    55u,
    97u,
    99u,
    52u,
    100u,
    54u,
    99u,
    102u,
    100u,
    49u,
    100u,
    51u,
    102u,
    99u,
    49u,
    48u,
    57u,
    98u,
    48u,
    100u,
    98u,
    49u,
    56u,
    56u,
    101u,
    55u,
    101u,
    55u,
    57u,
    50u,
    101u,
    51u,
    100u,
    49u,
    56u,
    51u,
    52u,
    50u,
    57u,
    49u,
    57u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    100u,
    52u,
    56u,
    48u,
    53u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    57u,
    48u,
    101u,
    97u,
    99u,
    54u,
    49u,
    54u,
    52u,
    50u,
    57u,
    52u,
    57u,
    99u,
    48u,
    48u,
    100u,
    49u,
    55u,
    102u,
    55u,
    99u,
    100u,
    53u,
    57u,
    56u,
    48u,
    97u,
    98u,
    101u,
    100u,
    98u,
    56u,
    54u,
    52u,
    55u,
    102u,
    99u,
    53u,
    100u,
    102u,
    57u,
    57u,
    53u,
    53u,
    100u,
    99u,
    102u,
    101u,
    52u,
    100u,
    53u,
    54u,
    97u,
    53u,
    48u,
    97u,
    48u,
    99u,
    53u,
    54u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    101u,
    57u,
    100u,
    57u,
    52u,
    98u,
    102u,
    53u,
    97u,
    48u,
    97u,
    98u,
    55u,
    98u,
    50u,
    48u,
    50u,
    100u,
    51u,
    57u,
    101u,
    49u,
    50u,
    48u,
    48u,
    97u,
    102u,
    57u,
    54u,
    48u,
    55u,
    52u,
    101u,
    52u,
    102u,
    54u,
    52u,
    49u,
    102u,
    52u,
    101u,
    53u,
    53u,
    101u,
    51u,
    101u,
    57u,
    101u,
    51u,
    97u,
    101u,
    101u,
    55u,
    50u,
    97u,
    97u,
    48u,
    48u,
    97u,
    55u,
    48u,
    101u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    48u,
    102u,
    55u,
    48u,
    49u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    52u,
    55u,
    55u,
    99u,
    97u,
    56u,
    53u,
    51u,
    54u,
    55u,
    48u,
    50u,
    101u,
    97u,
    99u,
    98u,
    100u,
    54u,
    53u,
    97u,
    54u,
    97u,
    49u,
    54u,
    50u,
    99u,
    102u,
    101u,
    57u,
    48u,
    100u,
    54u,
    50u,
    48u,
    49u,
    54u,
    97u,
    49u,
    52u,
    102u,
    102u,
    101u,
    53u,
    56u,
    100u,
    53u,
    50u,
    98u,
    55u,
    100u,
    100u,
    52u,
    99u,
    51u,
    54u,
    50u,
    56u,
    97u,
    50u,
    55u,
    101u,
    53u,
    98u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    98u,
    98u,
    98u,
    50u,
    53u,
    48u,
    102u,
    50u,
    100u,
    99u,
    50u,
    51u,
    55u,
    49u,
    55u,
    101u,
    56u,
    49u,
    57u,
    50u,
    99u,
    48u,
    98u,
    56u,
    98u,
    101u,
    99u,
    54u,
    97u,
    49u,
    55u,
    53u,
    99u,
    100u,
    48u,
    53u,
    57u,
    101u,
    52u,
    48u,
    56u,
    57u,
    100u,
    51u,
    50u,
    53u,
    48u,
    48u,
    54u,
    101u,
    97u,
    101u,
    101u,
    51u,
    52u,
    52u,
    54u,
    50u,
    53u,
    52u,
    99u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    57u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    54u,
    57u,
    56u,
    48u,
    99u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    56u,
    100u,
    98u,
    53u,
    57u,
    57u,
    100u,
    54u,
    98u,
    55u,
    97u,
    53u,
    53u,
    102u,
    100u,
    54u,
    49u,
    100u,
    52u,
    50u,
    52u,
    52u,
    97u,
    51u,
    100u,
    102u,
    97u,
    52u,
    54u,
    53u,
    48u,
    53u,
    53u,
    101u,
    97u,
    100u,
    54u,
    98u,
    53u,
    99u,
    48u,
    97u,
    51u,
    55u,
    99u,
    55u,
    97u,
    51u,
    100u,
    52u,
    53u,
    53u,
    53u,
    98u,
    53u,
    56u,
    101u,
    57u,
    57u,
    48u,
    54u,
    53u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    50u,
    101u,
    49u,
    55u,
    98u,
    97u,
    98u,
    100u,
    52u,
    48u,
    56u,
    57u,
    98u,
    50u,
    48u,
    52u,
    55u,
    57u,
    55u,
    99u,
    101u,
    98u,
    100u,
    97u,
    55u,
    100u,
    99u,
    54u,
    101u,
    50u,
    55u,
    55u,
    57u,
    53u,
    48u,
    101u,
    97u,
    98u,
    49u,
    98u,
    50u,
    57u,
    48u,
    56u,
    57u,
    57u,
    49u,
    97u,
    101u,
    49u,
    100u,
    55u,
    50u,
    51u,
    51u,
    53u,
    102u,
    56u,
    50u,
    100u,
    50u,
    48u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    102u,
    50u,
    100u,
    48u,
    57u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    99u,
    55u,
    100u,
    54u,
    48u,
    49u,
    99u,
    101u,
    51u,
    98u,
    48u,
    49u,
    101u,
    53u,
    54u,
    57u,
    97u,
    52u,
    57u,
    53u,
    48u,
    56u,
    100u,
    53u,
    52u,
    49u,
    98u,
    98u,
    99u,
    98u,
    97u,
    57u,
    98u,
    51u,
    99u,
    56u,
    51u,
    57u,
    52u,
    98u,
    49u,
    56u,
    51u,
    52u,
    53u,
    50u,
    51u,
    101u,
    102u,
    49u,
    101u,
    53u,
    99u,
    98u,
    50u,
    99u,
    54u,
    48u,
    98u,
    100u,
    51u,
    52u,
    97u,
    51u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    56u,
    56u,
    98u,
    54u,
    102u,
    48u,
    50u,
    50u,
    49u,
    52u,
    52u,
    100u,
    98u,
    49u,
    51u,
    52u,
    97u,
    102u,
    49u,
    98u,
    99u,
    56u,
    101u,
    54u,
    49u,
    98u,
    51u,
    56u,
    53u,
    99u,
    97u,
    51u,
    55u,
    99u,
    97u,
    101u,
    48u,
    51u,
    56u,
    99u,
    49u,
    100u,
    49u,
    54u,
    53u,
    97u,
    101u,
    57u,
    56u,
    99u,
    52u,
    57u,
    54u,
    98u,
    51u,
    98u,
    52u,
    49u,
    101u,
    56u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    97u,
    56u,
    101u,
    97u,
    48u,
    101u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    49u,
    48u,
    55u,
    54u,
    49u,
    101u,
    57u,
    55u,
    101u,
    54u,
    55u,
    98u,
    52u,
    57u,
    52u,
    102u,
    100u,
    53u,
    52u,
    55u,
    99u,
    102u,
    101u,
    57u,
    102u,
    102u,
    98u,
    98u,
    51u,
    54u,
    56u,
    57u,
    51u,
    100u,
    97u,
    55u,
    97u,
    101u,
    99u,
    55u,
    53u,
    99u,
    54u,
    98u,
    53u,
    49u,
    98u,
    56u,
    100u,
    53u,
    102u,
    51u,
    56u,
    102u,
    56u,
    55u,
    98u,
    53u,
    100u,
    54u,
    51u,
    99u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    49u,
    102u,
    48u,
    99u,
    102u,
    100u,
    102u,
    53u,
    97u,
    100u,
    56u,
    50u,
    52u,
    56u,
    102u,
    99u,
    52u,
    53u,
    50u,
    48u,
    102u,
    51u,
    98u,
    98u,
    48u,
    98u,
    50u,
    48u,
    52u,
    48u,
    50u,
    50u,
    54u,
    52u,
    51u,
    48u,
    51u,
    52u,
    56u,
    99u,
    100u,
    100u,
    101u,
    102u,
    102u,
    53u,
    99u,
    97u,
    57u,
    49u,
    56u,
    49u,
    98u,
    101u,
    101u,
    98u,
    55u,
    56u,
    56u,
    55u,
    48u,
    100u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    48u,
    100u,
    54u,
    48u,
    48u,
    102u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    49u,
    97u,
    56u,
    100u,
    51u,
    53u,
    52u,
    97u,
    55u,
    101u,
    56u,
    98u,
    49u,
    51u,
    101u,
    99u,
    52u,
    55u,
    102u,
    52u,
    99u,
    51u,
    100u,
    57u,
    48u,
    55u,
    100u,
    48u,
    48u,
    57u,
    52u,
    53u,
    97u,
    54u,
    49u,
    101u,
    56u,
    54u,
    48u,
    53u,
    57u,
    102u,
    52u,
    57u,
    52u,
    51u,
    101u,
    52u,
    50u,
    99u,
    49u,
    101u,
    53u,
    50u,
    51u,
    57u,
    56u,
    101u,
    98u,
    97u,
    53u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    50u,
    97u,
    49u,
    54u,
    100u,
    51u,
    56u,
    99u,
    99u,
    48u,
    101u,
    49u,
    51u,
    101u,
    52u,
    98u,
    49u,
    54u,
    100u,
    57u,
    49u,
    55u,
    98u,
    102u,
    102u,
    52u,
    99u,
    51u,
    52u,
    55u,
    50u,
    55u,
    100u,
    101u,
    98u,
    51u,
    98u,
    53u,
    99u,
    53u,
    48u,
    101u,
    52u,
    50u,
    52u,
    102u,
    98u,
    56u,
    52u,
    53u,
    51u,
    102u,
    102u,
    57u,
    98u,
    50u,
    97u,
    100u,
    99u,
    98u,
    52u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    50u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    102u,
    49u,
    48u,
    48u,
    50u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    99u,
    54u,
    55u,
    100u,
    51u,
    56u,
    102u,
    51u,
    49u,
    102u,
    53u,
    56u,
    57u,
    98u,
    49u,
    56u,
    98u,
    57u,
    100u,
    56u,
    101u,
    53u,
    51u,
    49u,
    98u,
    57u,
    57u,
    52u,
    99u,
    101u,
    53u,
    55u,
    51u,
    51u,
    99u,
    48u,
    50u,
    49u,
    97u,
    48u,
    51u,
    100u,
    56u,
    56u,
    100u,
    51u,
    56u,
    54u,
    49u,
    49u,
    101u,
    101u,
    54u,
    98u,
    52u,
    99u,
    50u,
    55u,
    49u,
    48u,
    97u,
    53u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    56u,
    54u,
    48u,
    52u,
    55u,
    49u,
    50u,
    55u,
    55u,
    98u,
    52u,
    97u,
    57u,
    51u,
    102u,
    101u,
    97u,
    50u,
    97u,
    56u,
    98u,
    54u,
    100u,
    56u,
    99u,
    50u,
    56u,
    49u,
    102u,
    97u,
    98u,
    55u,
    98u,
    100u,
    101u,
    51u,
    98u,
    55u,
    56u,
    102u,
    50u,
    97u,
    99u,
    100u,
    49u,
    98u,
    102u,
    100u,
    99u,
    56u,
    57u,
    100u,
    52u,
    54u,
    52u,
    101u,
    100u,
    51u,
    98u,
    98u,
    51u,
    99u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    53u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    100u,
    51u,
    48u,
    48u,
    52u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    51u,
    55u,
    54u,
    56u,
    54u,
    99u,
    54u,
    49u,
    49u,
    97u,
    97u,
    101u,
    52u,
    51u,
    57u,
    55u,
    99u,
    55u,
    99u,
    48u,
    52u,
    98u,
    50u,
    99u,
    49u,
    57u,
    48u,
    55u,
    48u,
    56u,
    52u,
    53u,
    51u,
    100u,
    48u,
    48u,
    101u,
    56u,
    99u,
    57u,
    53u,
    54u,
    51u,
    53u,
    50u,
    53u,
    54u,
    49u,
    48u,
    99u,
    51u,
    49u,
    98u,
    97u,
    52u,
    54u,
    101u,
    56u,
    48u,
    100u,
    98u,
    99u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    51u,
    55u,
    48u,
    50u,
    51u,
    48u,
    54u,
    48u,
    55u,
    57u,
    57u,
    56u,
    102u,
    98u,
    98u,
    100u,
    49u,
    48u,
    50u,
    55u,
    53u,
    99u,
    53u,
    56u,
    57u,
    48u,
    56u,
    56u,
    53u,
    102u,
    99u,
    100u,
    56u,
    49u,
    98u,
    54u,
    56u,
    48u,
    49u,
    56u,
    98u,
    97u,
    50u,
    51u,
    55u,
    51u,
    97u,
    98u,
    102u,
    48u,
    102u,
    57u,
    51u,
    97u,
    48u,
    54u,
    100u,
    48u,
    50u,
    97u,
    98u,
    50u,
    56u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    51u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    51u,
    55u,
    55u,
    53u,
    48u,
    98u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    102u,
    100u,
    100u,
    97u,
    57u,
    53u,
    50u,
    100u,
    97u,
    54u,
    97u,
    98u,
    100u,
    55u,
    48u,
    48u,
    50u,
    50u,
    97u,
    54u,
    101u,
    53u,
    102u,
    50u,
    98u,
    57u,
    100u,
    99u,
    53u,
    101u,
    49u,
    98u,
    54u,
    54u,
    48u,
    49u,
    49u,
    49u,
    50u,
    56u,
    99u,
    51u,
    102u,
    97u,
    50u,
    52u,
    57u,
    102u,
    48u,
    98u,
    55u,
    52u,
    51u,
    57u,
    102u,
    48u,
    48u,
    100u,
    53u,
    57u,
    52u,
    51u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    97u,
    50u,
    99u,
    57u,
    49u,
    102u,
    99u,
    52u,
    49u,
    50u,
    53u,
    52u,
    53u,
    51u,
    57u,
    97u,
    53u,
    98u,
    50u,
    97u,
    50u,
    55u,
    98u,
    101u,
    50u,
    56u,
    100u,
    101u,
    50u,
    97u,
    54u,
    49u,
    56u,
    55u,
    101u,
    50u,
    97u,
    102u,
    51u,
    102u,
    49u,
    50u,
    57u,
    100u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    52u,
    53u,
    102u,
    102u,
    99u,
    53u,
    49u,
    50u,
    100u,
    53u,
    99u,
    97u,
    51u,
    98u,
    99u,
    52u,
    100u,
    50u,
    48u,
    54u,
    51u,
    100u,
    100u,
    51u,
    97u,
    102u,
    49u,
    54u,
    54u,
    57u,
    99u,
    50u,
    57u,
    54u,
    97u,
    101u,
    49u,
    50u,
    54u,
    97u,
    53u,
    97u,
    50u,
    101u,
    102u,
    56u,
    57u,
    54u,
    100u,
    49u,
    101u,
    49u,
    57u,
    48u,
    99u,
    101u,
    100u,
    102u,
    54u,
    55u,
    98u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    53u,
    53u,
    98u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    48u,
    57u,
    52u,
    100u,
    54u,
    99u,
    98u,
    101u,
    55u,
    54u,
    53u,
    51u,
    56u,
    97u,
    56u,
    56u,
    54u,
    49u,
    50u,
    54u,
    50u,
    52u,
    102u,
    99u,
    53u,
    101u,
    54u,
    53u,
    53u,
    99u,
    99u,
    52u,
    48u,
    53u,
    99u,
    98u,
    56u,
    49u,
    57u,
    56u,
    100u,
    99u,
    97u,
    100u,
    53u,
    49u,
    54u,
    98u,
    56u,
    56u,
    100u,
    98u,
    97u,
    99u,
    53u,
    98u,
    102u,
    56u,
    98u,
    57u,
    48u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    99u,
    53u,
    52u,
    56u,
    56u,
    49u,
    53u,
    49u,
    50u,
    55u,
    99u,
    49u,
    50u,
    53u,
    49u,
    52u,
    55u,
    97u,
    102u,
    57u,
    49u,
    99u,
    51u,
    53u,
    54u,
    99u,
    50u,
    57u,
    51u,
    102u,
    48u,
    100u,
    101u,
    102u,
    98u,
    100u,
    50u,
    55u,
    55u,
    49u,
    102u,
    56u,
    100u,
    99u,
    51u,
    98u,
    49u,
    49u,
    52u,
    50u,
    98u,
    51u,
    54u,
    55u,
    53u,
    50u,
    56u,
    54u,
    53u,
    54u,
    100u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    54u,
    55u,
    55u,
    48u,
    97u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    98u,
    100u,
    98u,
    98u,
    51u,
    98u,
    49u,
    98u,
    101u,
    55u,
    50u,
    49u,
    54u,
    56u,
    55u,
    50u,
    101u,
    97u,
    55u,
    56u,
    55u,
    54u,
    50u,
    55u,
    98u,
    48u,
    51u,
    99u,
    51u,
    56u,
    57u,
    97u,
    53u,
    50u,
    55u,
    52u,
    53u,
    49u,
    102u,
    54u,
    100u,
    100u,
    56u,
    51u,
    50u,
    100u,
    56u,
    53u,
    52u,
    48u,
    56u,
    55u,
    52u,
    51u,
    48u,
    54u,
    102u,
    57u,
    99u,
    48u,
    55u,
    99u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    101u,
    102u,
    55u,
    53u,
    56u,
    55u,
    55u,
    48u,
    98u,
    98u,
    57u,
    48u,
    99u,
    53u,
    98u,
    49u,
    51u,
    55u,
    54u,
    57u,
    99u,
    53u,
    98u,
    54u,
    49u,
    97u,
    102u,
    102u,
    98u,
    51u,
    50u,
    50u,
    98u,
    50u,
    52u,
    99u,
    55u,
    52u,
    55u,
    53u,
    55u,
    51u,
    98u,
    51u,
    56u,
    101u,
    98u,
    101u,
    50u,
    101u,
    101u,
    56u,
    49u,
    55u,
    52u,
    56u,
    100u,
    48u,
    98u,
    53u,
    53u,
    55u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    48u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    57u,
    102u,
    48u,
    48u,
    49u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    97u,
    99u,
    56u,
    101u,
    101u,
    97u,
    54u,
    51u,
    50u,
    56u,
    53u,
    51u,
    53u,
    51u,
    57u,
    52u,
    52u,
    101u,
    52u,
    48u,
    101u,
    101u,
    99u,
    53u,
    52u,
    100u,
    50u,
    100u,
    100u,
    54u,
    99u,
    100u,
    48u,
    57u,
    57u,
    52u,
    98u,
    52u,
    52u,
    55u,
    52u,
    50u,
    57u,
    98u,
    98u,
    48u,
    101u,
    100u,
    48u,
    53u,
    57u,
    56u,
    100u,
    51u,
    56u,
    102u,
    52u,
    50u,
    100u,
    97u,
    48u,
    101u,
    50u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
const unsigned __int8 bench_lodiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    49u,
    102u,
    53u,
    48u,
    50u,
    99u,
    98u,
    51u,
    101u,
    57u,
    102u,
    100u,
    98u,
    48u,
    53u,
    51u,
    50u,
    51u,
    48u,
    101u,
    99u,
    49u,
    50u,
    97u,
    52u,
    57u,
    53u,
    52u,
    99u,
    49u,
    48u,
    50u,
    49u,
    97u,
    54u,
    98u,
    51u,
    53u,
    56u,
    54u,
    50u,
    98u,
    53u,
    101u,
    50u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    52u,
    100u,
    49u,
    98u,
    56u,
    51u,
    97u,
    101u,
    52u,
    52u,
    48u,
    53u,
    55u,
    48u,
    50u,
    53u,
    101u,
    56u,
    99u,
    53u,
    98u,
    53u,
    55u,
    53u,
    54u,
    98u,
    52u,
    52u,
    102u,
    48u,
    52u,
    100u,
    102u,
    53u,
    102u,
    102u,
    102u,
    101u,
    52u,
    97u,
    55u,
    97u,
    51u,
    48u,
    101u,
    53u,
    99u,
    49u,
    50u,
    100u,
    49u,
    50u,
    97u,
    57u,
    55u,
    97u,
    55u,
    97u,
    52u,
    99u,
    50u,
    101u,
    97u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    54u,
    100u,
    54u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    48u,
    56u,
    102u,
    55u,
    101u,
    49u,
    52u,
    99u,
    53u,
    48u,
    100u,
    97u,
    100u,
    55u,
    55u,
    100u,
    99u,
    50u,
    51u,
    56u,
    98u,
    52u,
    100u,
    98u,
    50u,
    57u,
    48u,
    49u,
    97u,
    48u,
    53u,
    55u,
    56u,
    101u,
    54u,
    53u,
    55u,
    98u,
    49u,
    57u,
    53u,
    52u,
    55u,
    55u,
    57u,
    97u,
    98u,
    57u,
    99u,
    100u,
    56u,
    50u,
    97u,
    55u,
    51u,
    56u,
    50u,
    57u,
    101u,
    100u,
    102u,
    55u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    49u,
    97u,
    49u,
    55u,
    52u,
    50u,
    53u,
    52u,
    97u,
    54u,
    53u,
    57u,
    51u,
    102u,
    102u,
    98u,
    97u,
    57u,
    56u,
    55u,
    102u,
    54u,
    56u,
    102u,
    101u,
    50u,
    54u,
    101u,
    55u,
    49u,
    54u,
    101u,
    51u,
    99u,
    49u,
    50u,
    57u,
    97u,
    55u,
    102u,
    51u,
    51u,
    97u,
    57u,
    99u,
    52u,
    51u,
    97u,
    101u,
    55u,
    101u,
    99u,
    102u,
    57u,
    48u,
    99u,
    56u,
    99u,
    100u,
    48u,
    100u,
    50u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    101u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    102u,
    56u,
    49u,
    48u,
    48u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    55u,
    48u,
    48u,
    97u,
    101u,
    101u,
    100u,
    97u,
    100u,
    97u,
    50u,
    98u,
    51u,
    56u,
    55u,
    55u,
    57u,
    48u,
    48u,
    98u,
    53u,
    56u,
    97u,
    49u,
    56u,
    51u,
    99u,
    52u,
    50u,
    99u,
    52u,
    48u,
    57u,
    52u,
    57u,
    57u,
    53u,
    54u,
    98u,
    98u,
    56u,
    98u,
    52u,
    97u,
    56u,
    100u,
    50u,
    49u,
    52u,
    56u,
    49u,
    102u,
    56u,
    57u,
    51u,
    54u,
    98u,
    53u,
    55u,
    50u,
    57u,
    50u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    51u,
    56u,
    99u,
    102u,
    52u,
    98u,
    54u,
    49u,
    100u,
    102u,
    102u,
    55u,
    52u,
    101u,
    51u,
    99u,
    50u,
    54u,
    98u,
    50u,
    100u,
    56u,
    48u,
    48u,
    52u,
    53u,
    48u,
    54u,
    52u,
    101u,
    56u,
    97u,
    98u,
    52u,
    56u,
    48u,
    50u,
    53u,
    50u,
    49u,
    98u,
    97u,
    98u,
    50u,
    99u,
    100u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    49u,
    101u,
    101u,
    102u,
    54u,
    52u,
    97u,
    55u,
    101u,
    102u,
    52u,
    101u,
    52u,
    55u,
    99u,
    100u,
    97u,
    49u,
    54u,
    101u,
    57u,
    54u,
    54u,
    55u,
    51u,
    49u,
    57u,
    55u,
    100u,
    51u,
    54u,
    99u,
    55u,
    50u,
    51u,
    53u,
    97u,
    52u,
    97u,
    97u,
    100u,
    100u,
    50u,
    51u,
    99u,
    50u,
    49u,
    97u,
    51u,
    56u,
    99u,
    101u,
    53u,
    51u,
    56u,
    50u,
    55u,
    100u,
    49u,
    102u,
    56u,
    98u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    57u,
    54u,
    98u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    51u,
    48u,
    99u,
    102u,
    55u,
    97u,
    54u,
    98u,
    56u,
    97u,
    56u,
    53u,
    101u,
    98u,
    49u,
    99u,
    99u,
    48u,
    49u,
    55u,
    98u,
    49u,
    48u,
    57u,
    100u,
    50u,
    51u,
    99u,
    51u,
    57u,
    50u,
    52u,
    54u,
    52u,
    102u,
    57u,
    57u,
    97u,
    97u,
    56u,
    99u,
    48u,
    50u,
    48u,
    101u,
    97u,
    49u,
    48u,
    55u,
    99u,
    53u,
    50u,
    53u,
    98u,
    54u,
    55u,
    49u,
    97u,
    100u,
    100u,
    101u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    101u,
    50u,
    99u,
    54u,
    98u,
    57u,
    50u,
    54u,
    52u,
    54u,
    56u,
    53u,
    54u,
    53u,
    101u,
    53u,
    50u,
    52u,
    97u,
    98u,
    55u,
    99u,
    50u,
    102u,
    49u,
    49u,
    49u,
    48u,
    51u,
    53u,
    100u,
    99u,
    100u,
    101u,
    55u,
    99u,
    54u,
    48u,
    57u,
    53u,
    53u,
    56u,
    52u,
    50u,
    49u,
    49u,
    49u,
    57u,
    51u,
    48u,
    53u,
    56u,
    57u,
    101u,
    99u,
    99u,
    98u,
    52u,
    49u,
    48u,
    102u,
    56u,
    51u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    102u,
    52u,
    50u,
    57u,
    48u,
    48u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    100u,
    98u,
    98u,
    51u,
    55u,
    52u,
    97u,
    57u,
    55u,
    102u,
    49u,
    53u,
    99u,
    53u,
    57u,
    53u,
    56u,
    55u,
    50u,
    53u,
    54u,
    54u,
    54u,
    50u,
    102u,
    51u,
    54u,
    57u,
    48u,
    52u,
    100u,
    48u,
    55u,
    53u,
    100u,
    48u,
    101u,
    54u,
    49u,
    102u,
    55u,
    52u,
    57u,
    54u,
    49u,
    56u,
    49u,
    56u,
    50u,
    55u,
    49u,
    49u,
    50u,
    56u,
    56u,
    97u,
    99u,
    54u,
    49u,
    55u,
    99u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    48u,
    55u,
    51u,
    51u,
    56u,
    53u,
    101u,
    48u,
    53u,
    99u,
    50u,
    57u,
    102u,
    48u,
    52u,
    51u,
    53u,
    97u,
    54u,
    48u,
    48u,
    49u,
    99u,
    56u,
    101u,
    99u,
    97u,
    57u,
    99u,
    56u,
    100u,
    53u,
    54u,
    48u,
    50u,
    56u,
    57u,
    48u,
    97u,
    101u,
    102u,
    102u,
    57u,
    100u,
    52u,
    100u,
    49u,
    48u,
    51u,
    100u,
    51u,
    51u,
    56u,
    51u,
    99u,
    102u,
    56u,
    48u,
    100u,
    97u,
    101u,
    53u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    50u,
    49u,
    100u,
    48u,
    48u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    55u,
    100u,
    97u,
    51u,
    98u,
    57u,
    55u,
    101u,
    56u,
    50u,
    99u,
    48u,
    99u,
    51u,
    49u,
    50u,
    53u,
    97u,
    53u,
    56u,
    100u,
    97u,
    100u,
    56u,
    97u,
    48u,
    100u,
    49u,
    100u,
    48u,
    51u,
    54u,
    57u,
    50u,
    52u,
    52u,
    55u,
    51u,
    49u,
    102u,
    51u,
    98u,
    48u,
    57u,
    54u,
    101u,
    57u,
    55u,
    50u,
    52u,
    56u,
    52u,
    50u,
    57u,
    56u,
    100u,
    49u,
    53u,
    98u,
    56u,
    52u,
    51u,
    100u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    98u,
    53u,
    98u,
    52u,
    100u,
    49u,
    57u,
    99u,
    50u,
    48u,
    97u,
    55u,
    102u,
    99u,
    50u,
    98u,
    49u,
    55u,
    52u,
    102u,
    102u,
    54u,
    55u,
    51u,
    99u,
    48u,
    48u,
    54u,
    101u,
    100u,
    100u,
    50u,
    50u,
    52u,
    55u,
    99u,
    52u,
    98u,
    50u,
    51u,
    51u,
    54u,
    53u,
    55u,
    49u,
    56u,
    54u,
    52u,
    100u,
    102u,
    57u,
    51u,
    101u,
    98u,
    55u,
    101u,
    99u,
    48u,
    99u,
    56u,
    99u,
    50u,
    55u,
    54u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    48u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    54u,
    51u,
    99u,
    48u,
    48u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    53u,
    49u,
    52u,
    98u,
    100u,
    53u,
    56u,
    54u,
    53u,
    49u,
    49u,
    101u,
    53u,
    51u,
    49u,
    101u,
    50u,
    98u,
    54u,
    50u,
    55u,
    55u,
    97u,
    54u,
    100u,
    49u,
    49u,
    50u,
    98u,
    49u,
    55u,
    49u,
    102u,
    57u,
    101u,
    48u,
    48u,
    56u,
    100u,
    53u,
    54u,
    101u,
    102u,
    52u,
    97u,
    57u,
    55u,
    49u,
    101u,
    54u,
    49u,
    57u,
    97u,
    99u,
    102u,
    50u,
    50u,
    101u,
    55u,
    53u,
    48u,
    55u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    101u,
    51u,
    48u,
    51u,
    48u,
    54u,
    50u,
    57u,
    102u,
    102u,
    52u,
    50u,
    53u,
    56u,
    48u,
    53u,
    54u,
    100u,
    99u,
    57u,
    101u,
    102u,
    97u,
    102u,
    57u,
    50u,
    50u,
    98u,
    100u,
    49u,
    55u,
    51u,
    97u,
    54u,
    53u,
    102u,
    54u,
    53u,
    101u,
    101u,
    55u,
    57u,
    57u,
    98u,
    48u,
    99u,
    55u,
    54u,
    53u,
    48u,
    57u,
    55u,
    100u,
    51u,
    100u,
    101u,
    101u,
    100u,
    100u,
    101u,
    102u,
    49u,
    48u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    56u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    52u,
    51u,
    48u,
    48u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    98u,
    55u,
    55u,
    97u,
    57u,
    99u,
    51u,
    54u,
    100u,
    56u,
    57u,
    52u,
    100u,
    50u,
    100u,
    98u,
    99u,
    51u,
    49u,
    52u,
    51u,
    55u,
    101u,
    53u,
    99u,
    50u,
    97u,
    49u,
    53u,
    54u,
    52u,
    101u,
    57u,
    50u,
    55u,
    57u,
    51u,
    55u,
    56u,
    52u,
    56u,
    101u,
    97u,
    50u,
    101u,
    98u,
    50u,
    48u,
    98u,
    51u,
    56u,
    54u,
    51u,
    56u,
    97u,
    102u,
    99u,
    54u,
    52u,
    98u,
    57u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    49u,
    51u,
    99u,
    50u,
    50u,
    98u,
    98u,
    57u,
    57u,
    101u,
    57u,
    100u,
    97u,
    97u,
    57u,
    57u,
    51u,
    54u,
    98u,
    48u,
    100u,
    102u,
    53u,
    100u,
    99u,
    101u,
    54u,
    52u,
    100u,
    55u,
    55u,
    51u,
    55u,
    101u,
    51u,
    55u,
    48u,
    54u,
    98u,
    101u,
    57u,
    57u,
    101u,
    53u,
    48u,
    57u,
    56u,
    100u,
    49u,
    49u,
    50u,
    48u,
    48u,
    50u,
    52u,
    57u,
    50u,
    99u,
    102u,
    56u,
    49u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    54u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    52u,
    52u,
    49u,
    48u,
    48u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    100u,
    56u,
    57u,
    54u,
    50u,
    54u,
    55u,
    102u,
    100u,
    97u,
    53u,
    100u,
    100u,
    97u,
    48u,
    102u,
    56u,
    53u,
    51u,
    48u,
    56u,
    101u,
    55u,
    55u,
    102u,
    55u,
    53u,
    52u,
    99u,
    56u,
    98u,
    57u,
    52u,
    98u,
    55u,
    98u,
    56u,
    56u,
    101u,
    51u,
    99u,
    98u,
    51u,
    49u,
    53u,
    52u,
    55u,
    53u,
    99u,
    100u,
    57u,
    101u,
    102u,
    100u,
    49u,
    54u,
    52u,
    48u,
    49u,
    101u,
    51u,
    99u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    102u,
    53u,
    99u,
    102u,
    102u,
    100u,
    55u,
    101u,
    53u,
    97u,
    55u,
    48u,
    56u,
    55u,
    102u,
    49u,
    98u,
    52u,
    56u,
    52u,
    98u,
    53u,
    50u,
    54u,
    99u,
    55u,
    51u,
    53u,
    48u,
    99u,
    56u,
    54u,
    100u,
    56u,
    51u,
    56u,
    57u,
    50u,
    56u,
    51u,
    53u,
    48u,
    57u,
    99u,
    97u,
    56u,
    55u,
    56u,
    53u,
    48u,
    50u,
    102u,
    55u,
    57u,
    50u,
    49u,
    49u,
    53u,
    101u,
    56u,
    100u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    97u,
    100u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    57u,
    57u,
    100u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    51u,
    51u,
    57u,
    51u,
    53u,
    52u,
    53u,
    54u,
    56u,
    102u,
    53u,
    48u,
    54u,
    97u,
    99u,
    51u,
    99u,
    100u,
    54u,
    57u,
    98u,
    98u,
    52u,
    50u,
    55u,
    98u,
    49u,
    97u,
    102u,
    56u,
    51u,
    97u,
    48u,
    52u,
    55u,
    51u,
    98u,
    56u,
    55u,
    99u,
    49u,
    54u,
    98u,
    102u,
    51u,
    98u,
    53u,
    54u,
    50u,
    97u,
    57u,
    51u,
    100u,
    48u,
    97u,
    50u,
    102u,
    102u,
    99u,
    53u,
    51u,
    101u,
    53u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    50u,
    53u,
    97u,
    54u,
    50u,
    52u,
    101u,
    53u,
    99u,
    56u,
    52u,
    102u,
    57u,
    54u,
    100u,
    50u,
    99u,
    51u,
    52u,
    100u,
    99u,
    101u,
    51u,
    98u,
    54u,
    97u,
    55u,
    51u,
    54u,
    97u,
    100u,
    100u,
    98u,
    56u,
    57u,
    49u,
    55u,
    50u,
    52u,
    98u,
    52u,
    56u,
    97u,
    51u,
    54u,
    51u,
    50u,
    48u,
    99u,
    55u,
    52u,
    57u,
    52u,
    52u,
    51u,
    53u,
    102u,
    57u,
    99u,
    57u,
    49u,
    53u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    54u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    102u,
    98u,
    48u,
    48u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    56u,
    51u,
    54u,
    50u,
    48u,
    48u,
    57u,
    99u,
    48u,
    55u,
    99u,
    102u,
    52u,
    56u,
    50u,
    52u,
    57u,
    102u,
    52u,
    56u,
    49u,
    98u,
    101u,
    54u,
    98u,
    55u,
    57u,
    101u,
    54u,
    55u,
    50u,
    52u,
    55u,
    99u,
    97u,
    98u,
    49u,
    100u,
    50u,
    48u,
    48u,
    53u,
    48u,
    99u,
    102u,
    49u,
    49u,
    99u,
    50u,
    55u,
    54u,
    48u,
    56u,
    53u,
    98u,
    57u,
    48u,
    55u,
    51u,
    50u,
    49u,
    49u,
    48u,
    99u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    54u,
    57u,
    102u,
    49u,
    100u,
    54u,
    53u,
    48u,
    55u,
    102u,
    52u,
    98u,
    55u,
    98u,
    53u,
    48u,
    57u,
    56u,
    48u,
    57u,
    51u,
    48u,
    102u,
    55u,
    100u,
    56u,
    48u,
    56u,
    57u,
    56u,
    51u,
    52u,
    102u,
    98u,
    101u,
    54u,
    53u,
    102u,
    48u,
    57u,
    56u,
    48u,
    98u,
    56u,
    53u,
    57u,
    50u,
    100u,
    53u,
    51u,
    99u,
    100u,
    100u,
    97u,
    48u,
    56u,
    101u,
    53u,
    48u,
    100u,
    50u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    55u,
    100u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    101u,
    101u,
    98u,
    48u,
    48u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    101u,
    52u,
    102u,
    54u,
    53u,
    52u,
    100u,
    50u,
    54u,
    97u,
    98u,
    56u,
    99u,
    57u,
    49u,
    54u,
    52u,
    102u,
    102u,
    51u,
    49u,
    49u,
    54u,
    53u,
    55u,
    97u,
    57u,
    102u,
    57u,
    99u,
    52u,
    99u,
    100u,
    99u,
    48u,
    101u,
    56u,
    97u,
    48u,
    57u,
    51u,
    51u,
    52u,
    57u,
    50u,
    53u,
    102u,
    55u,
    99u,
    48u,
    50u,
    49u,
    51u,
    56u,
    56u,
    49u,
    57u,
    100u,
    55u,
    101u,
    54u,
    49u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    57u,
    50u,
    51u,
    98u,
    54u,
    51u,
    102u,
    53u,
    51u,
    99u,
    55u,
    50u,
    99u,
    48u,
    52u,
    101u,
    98u,
    101u,
    54u,
    99u,
    49u,
    99u,
    57u,
    49u,
    52u,
    48u,
    98u,
    54u,
    51u,
    55u,
    55u,
    49u,
    51u,
    50u,
    98u,
    54u,
    101u,
    53u,
    48u,
    56u,
    54u,
    53u,
    56u,
    49u,
    52u,
    102u,
    101u,
    53u,
    54u,
    50u,
    50u,
    57u,
    49u,
    98u,
    100u,
    48u,
    50u,
    51u,
    100u,
    51u,
    52u,
    56u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    53u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    53u,
    50u,
    101u,
    48u,
    48u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    100u,
    98u,
    57u,
    49u,
    97u,
    50u,
    53u,
    52u,
    48u,
    49u,
    97u,
    56u,
    57u,
    100u,
    97u,
    102u,
    57u,
    102u,
    102u,
    55u,
    100u,
    55u,
    57u,
    53u,
    52u,
    98u,
    97u,
    98u,
    55u,
    50u,
    50u,
    98u,
    56u,
    57u,
    52u,
    98u,
    97u,
    52u,
    56u,
    48u,
    102u,
    101u,
    102u,
    97u,
    102u,
    49u,
    102u,
    48u,
    97u,
    57u,
    53u,
    97u,
    97u,
    102u,
    53u,
    102u,
    54u,
    48u,
    48u,
    53u,
    54u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    101u,
    57u,
    56u,
    49u,
    55u,
    49u,
    54u,
    48u,
    101u,
    51u,
    53u,
    100u,
    52u,
    52u,
    49u,
    48u,
    54u,
    48u,
    49u,
    99u,
    56u,
    100u,
    99u,
    55u,
    52u,
    49u,
    99u,
    49u,
    97u,
    56u,
    49u,
    48u,
    99u,
    52u,
    56u,
    53u,
    102u,
    51u,
    98u,
    52u,
    48u,
    97u,
    48u,
    56u,
    53u,
    57u,
    98u,
    101u,
    53u,
    102u,
    53u,
    56u,
    102u,
    48u,
    98u,
    102u,
    54u,
    101u,
    102u,
    49u,
    54u,
    57u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    51u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    101u,
    49u,
    102u,
    48u,
    48u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    101u,
    50u,
    49u,
    53u,
    55u,
    56u,
    53u,
    49u,
    55u,
    56u,
    102u,
    102u,
    54u,
    51u,
    53u,
    48u,
    48u,
    54u,
    52u,
    48u,
    54u,
    48u,
    101u,
    98u,
    98u,
    98u,
    50u,
    49u,
    57u,
    97u,
    55u,
    49u,
    55u,
    49u,
    54u,
    97u,
    49u,
    48u,
    101u,
    56u,
    56u,
    53u,
    50u,
    56u,
    102u,
    99u,
    52u,
    98u,
    98u,
    49u,
    99u,
    98u,
    53u,
    99u,
    56u,
    102u,
    100u,
    100u,
    48u,
    99u,
    102u,
    54u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    53u,
    49u,
    52u,
    99u,
    102u,
    55u,
    51u,
    56u,
    52u,
    53u,
    53u,
    97u,
    53u,
    52u,
    102u,
    48u,
    48u,
    52u,
    101u,
    99u,
    56u,
    54u,
    101u,
    100u,
    97u,
    102u,
    99u,
    102u,
    100u,
    57u,
    102u,
    100u,
    50u,
    48u,
    50u,
    50u,
    48u,
    49u,
    55u,
    98u,
    98u,
    51u,
    49u,
    99u,
    50u,
    52u,
    53u,
    51u,
    52u,
    48u,
    51u,
    53u,
    51u,
    57u,
    49u,
    49u,
    55u,
    52u,
    52u,
    102u,
    98u,
    55u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    49u,
    102u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    54u,
    53u,
    102u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    97u,
    102u,
    97u,
    97u,
    56u,
    54u,
    100u,
    101u,
    102u,
    101u,
    56u,
    53u,
    48u,
    98u,
    48u,
    53u,
    55u,
    97u,
    101u,
    55u,
    52u,
    102u,
    55u,
    50u,
    49u,
    56u,
    97u,
    55u,
    57u,
    98u,
    48u,
    101u,
    100u,
    101u,
    48u,
    56u,
    54u,
    97u,
    49u,
    57u,
    54u,
    102u,
    49u,
    56u,
    102u,
    48u,
    101u,
    55u,
    99u,
    53u,
    56u,
    53u,
    101u,
    98u,
    56u,
    56u,
    100u,
    49u,
    49u,
    51u,
    57u,
    97u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    100u,
    98u,
    100u,
    53u,
    51u,
    102u,
    99u,
    99u,
    54u,
    52u,
    56u,
    53u,
    48u,
    98u,
    53u,
    51u,
    51u,
    52u,
    54u,
    55u,
    56u,
    49u,
    57u,
    57u,
    100u,
    55u,
    54u,
    57u,
    53u,
    49u,
    52u,
    56u,
    49u,
    56u,
    102u,
    98u,
    99u,
    99u,
    55u,
    57u,
    56u,
    54u,
    49u,
    102u,
    99u,
    55u,
    55u,
    101u,
    53u,
    55u,
    50u,
    98u,
    98u,
    52u,
    55u,
    53u,
    51u,
    98u,
    55u,
    102u,
    101u,
    50u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    100u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    51u,
    56u,
    57u,
    48u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    54u,
    53u,
    51u,
    100u,
    102u,
    53u,
    57u,
    53u,
    54u,
    101u,
    99u,
    101u,
    53u,
    49u,
    56u,
    97u,
    55u,
    56u,
    97u,
    53u,
    100u,
    49u,
    49u,
    50u,
    57u,
    55u,
    52u,
    51u,
    49u,
    97u,
    102u,
    57u,
    52u,
    99u,
    101u,
    56u,
    98u,
    97u,
    57u,
    49u,
    100u,
    56u,
    48u,
    99u,
    102u,
    98u,
    50u,
    97u,
    97u,
    56u,
    99u,
    53u,
    98u,
    51u,
    48u,
    57u,
    53u,
    102u,
    97u,
    50u,
    53u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    54u,
    102u,
    99u,
    52u,
    97u,
    97u,
    53u,
    100u,
    97u,
    56u,
    51u,
    57u,
    98u,
    97u,
    50u,
    54u,
    55u,
    99u,
    51u,
    54u,
    97u,
    97u,
    49u,
    97u,
    53u,
    98u,
    50u,
    57u,
    100u,
    56u,
    49u,
    51u,
    55u,
    52u,
    55u,
    98u,
    50u,
    50u,
    55u,
    51u,
    100u,
    99u,
    48u,
    51u,
    97u,
    97u,
    57u,
    101u,
    52u,
    48u,
    52u,
    99u,
    52u,
    100u,
    97u,
    48u,
    50u,
    51u,
    56u,
    101u,
    50u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    99u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    101u,
    55u,
    48u,
    48u,
    48u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    50u,
    51u,
    56u,
    48u,
    54u,
    97u,
    53u,
    51u,
    51u,
    98u,
    100u,
    57u,
    53u,
    54u,
    55u,
    56u,
    55u,
    101u,
    101u,
    102u,
    53u,
    50u,
    100u,
    100u,
    56u,
    101u,
    100u,
    101u,
    101u,
    52u,
    53u,
    54u,
    99u,
    54u,
    48u,
    100u,
    54u,
    99u,
    101u,
    99u,
    98u,
    98u,
    54u,
    49u,
    55u,
    53u,
    52u,
    53u,
    56u,
    101u,
    101u,
    53u,
    51u,
    102u,
    99u,
    56u,
    99u,
    54u,
    99u,
    56u,
    49u,
    51u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
char byte_71100 = '\0'; // weak
char a0[2] = "0"; // weak
const unsigned __int8 _func___14954[5] = { 109u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _func___14924[9] = { 99u, 111u, 112u, 121u, 95u, 100u, 114u, 118u, 0u }; // idb
const unsigned __int8 _func___14887[9] = { 97u, 100u, 100u, 95u, 99u, 103u, 112u, 117u, 0u }; // idb
const unsigned __int8 _func___14851[14] = { 101u, 110u, 97u, 98u, 108u, 101u, 95u, 100u, 101u, 118u, 105u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___14757[17] =
{
  97u,
  100u,
  100u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  100u,
  101u,
  116u,
  97u,
  105u,
  108u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___14747[17] =
{
  116u,
  101u,
  115u,
  116u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___14623[16] =
{
  119u,
  97u,
  116u,
  99u,
  104u,
  100u,
  111u,
  103u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___14590[21] =
{
  112u,
  114u,
  117u,
  110u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  104u,
  97u,
  114u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___14578[10] = { 114u, 101u, 97u, 112u, 95u, 99u, 117u, 114u, 108u, 0u }; // idb
const unsigned __int8 _func___14560[15] =
{
  119u,
  97u,
  105u,
  116u,
  95u,
  108u,
  112u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___14552[13] = { 109u, 105u, 110u, 101u, 114u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___14539[17] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  100u,
  114u,
  105u,
  118u,
  101u,
  114u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___14509[12] = { 102u, 108u, 117u, 115u, 104u, 95u, 113u, 117u, 101u, 117u, 101u, 0u }; // idb
const unsigned __int8 _func___14504[28] =
{
  116u,
  97u,
  107u,
  101u,
  95u,
  113u,
  117u,
  101u,
  117u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  109u,
  105u,
  100u,
  115u,
  116u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___14494[15] =
{
  119u,
  111u,
  114u,
  107u,
  95u,
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___14486[16] =
{
  97u,
  103u,
  101u,
  95u,
  113u,
  117u,
  101u,
  117u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___14471[23] =
{
  99u,
  108u,
  111u,
  110u,
  101u,
  95u,
  113u,
  117u,
  101u,
  117u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  105u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___14464[22] =
{
  102u,
  105u,
  110u,
  100u,
  95u,
  113u,
  117u,
  101u,
  117u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  105u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___14448[29] =
{
  99u,
  108u,
  111u,
  110u,
  101u,
  95u,
  113u,
  117u,
  101u,
  117u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  109u,
  105u,
  100u,
  115u,
  116u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___14437[28] =
{
  102u,
  105u,
  110u,
  100u,
  95u,
  113u,
  117u,
  101u,
  117u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  109u,
  105u,
  100u,
  115u,
  116u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___14407[11] = { 97u, 100u, 100u, 95u, 113u, 117u, 101u, 117u, 101u, 100u, 0u }; // idb
const unsigned __int8 _func___14402[11] = { 103u, 101u, 116u, 95u, 113u, 117u, 101u, 117u, 101u, 100u, 0u }; // idb
const unsigned __int8 _func___14397[13] = { 95u, 95u, 103u, 101u, 116u, 95u, 113u, 117u, 101u, 117u, 101u, 100u, 0u }; // idb
const unsigned __int8 _func___14354[11] = { 102u, 105u, 108u, 108u, 95u, 113u, 117u, 101u, 117u, 101u, 0u }; // idb
const unsigned __int8 _func___14343[15] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  115u,
  111u,
  108u,
  101u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___14311[11] = { 109u, 116u, 95u, 100u, 105u, 115u, 97u, 98u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___14296[21] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  110u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14211[19] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  116u,
  101u,
  115u,
  116u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___14204[15] =
{
  105u,
  110u,
  99u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  115u,
  116u,
  97u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___14198[18] =
{
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  115u,
  116u,
  97u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___14174[15] =
{
  105u,
  110u,
  99u,
  95u,
  100u,
  101u,
  118u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___14169[24] =
{
  105u,
  110u,
  99u,
  95u,
  104u,
  119u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  115u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  100u,
  105u,
  102u,
  102u,
  0u
}; // idb
const unsigned __int8 _func___14163[14] =
{
  105u,
  110u,
  99u,
  95u,
  104u,
  119u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___14150[18] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  97u,
  115u,
  121u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _func___14138[9] = { 103u, 101u, 116u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___14129[19] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  101u,
  110u,
  99u,
  104u,
  109u,
  97u,
  114u,
  107u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___14112[17] =
{
  103u,
  101u,
  110u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___14101[19] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _func___14088[11] = { 115u, 101u, 116u, 95u, 116u, 97u, 114u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _func___14056[9] = { 104u, 97u, 115u, 104u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___14035[12] = { 112u, 111u, 111u, 108u, 95u, 97u, 99u, 116u, 105u, 118u, 101u, 0u }; // idb
const unsigned __int8 _func___13928[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___13904[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  114u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___13876[16] =
{
  115u,
  117u,
  112u,
  112u,
  111u,
  114u,
  116u,
  115u,
  95u,
  114u,
  101u,
  115u,
  117u,
  109u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___13856[8] = { 99u, 112u, 95u, 112u, 114u, 105u, 111u, 0u }; // idb
const unsigned __int8 _func___13845[16] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___13832[21] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  104u,
  97u,
  114u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___13796[23] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  114u,
  101u,
  115u,
  112u,
  111u,
  110u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___13749[10] = { 104u, 97u, 115u, 104u, 109u, 101u, 116u, 101u, 114u, 0u }; // idb
const unsigned __int8 _func___13703[11] = { 122u, 101u, 114u, 111u, 95u, 115u, 116u, 97u, 116u, 115u, 0u }; // idb
const unsigned __int8 _func___13656[12] = { 106u, 115u, 111u, 110u, 95u, 101u, 115u, 99u, 97u, 112u, 101u, 0u }; // idb
const unsigned __int8 _func___13570[10] = { 104u, 97u, 115u, 104u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _func___13549[18] =
{
  116u,
  101u,
  115u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___13454[13] = { 98u, 108u, 111u, 99u, 107u, 95u, 101u, 120u, 105u, 115u, 116u, 115u, 0u }; // idb
const unsigned __int8 _func___13426[13] = { 115u, 101u, 116u, 95u, 99u, 117u, 114u, 98u, 108u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___13417[19] =
{
  115u,
  105u,
  103u,
  110u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___13402[15] =
{
  114u,
  101u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___13395[13] = { 114u, 101u, 115u, 116u, 97u, 114u, 116u, 95u, 119u, 97u, 105u, 116u, 0u }; // idb
const unsigned __int8 _func___13379[14] = { 100u, 105u, 115u, 99u, 97u, 114u, 100u, 95u, 115u, 116u, 97u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___13372[9] = { 119u, 97u, 107u, 101u, 95u, 103u, 119u, 115u, 0u }; // idb
const unsigned __int8 _func___13339[13] = { 115u, 119u, 105u, 116u, 99u, 104u, 95u, 112u, 111u, 111u, 108u, 115u, 0u }; // idb
const unsigned __int8 _func___13304[11] = { 115u, 104u, 97u, 114u, 101u, 95u, 100u, 105u, 102u, 102u, 0u }; // idb
const unsigned __int8 _func___13293[11] = { 115u, 116u, 97u, 108u, 101u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___13252[11] = { 95u, 99u, 111u, 112u, 121u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___13117[19] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  101u,
  110u,
  99u,
  104u,
  109u,
  97u,
  114u,
  107u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___13016[13] = { 115u, 104u, 97u, 114u, 101u, 95u, 114u, 101u, 115u, 117u, 108u, 116u, 0u }; // idb
const unsigned __int8 _func___12993[13] = { 103u, 101u, 116u, 95u, 115u, 116u, 97u, 116u, 108u, 105u, 110u, 101u, 0u }; // idb
const unsigned __int8 _func___12940[13] = { 116u, 111u, 116u, 97u, 108u, 95u, 115u, 116u, 97u, 103u, 101u, 100u, 0u }; // idb
const unsigned __int8 _func___12900[10] = { 109u, 97u, 107u, 101u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___12895[15] =
{
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  105u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _func___12890[14] = { 99u, 97u, 108u, 99u, 95u, 109u, 105u, 100u, 115u, 116u, 97u, 116u, 101u, 0u }; // idb
const unsigned __int8 _func___12856[20] =
{
  108u,
  111u,
  97u,
  100u,
  95u,
  100u,
  101u,
  102u,
  97u,
  117u,
  108u,
  116u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  0u
}; // idb
const unsigned __int8 _func___12847[12] = { 108u, 111u, 97u, 100u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___12822[13] = { 112u, 97u, 114u, 115u, 101u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _func___12351[18] =
{
  108u,
  111u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  99u,
  117u,
  116u,
  111u,
  102u,
  102u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___12279[10] = { 115u, 101u, 116u, 117u, 112u, 95u, 117u, 114u, 108u, 0u }; // idb
const unsigned __int8 _func___12180[13] = { 99u, 117u, 114u, 114u, 101u, 110u, 116u, 95u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___12175[12] = { 112u, 111u, 111u, 108u, 95u, 116u, 99u, 108u, 101u, 97u, 114u, 0u }; // idb
const unsigned __int8 _func___12169[10] = { 112u, 111u, 111u, 108u, 95u, 116u, 115u, 101u, 116u, 0u }; // idb
const unsigned __int8 _func___12161[9] = { 97u, 100u, 100u, 95u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___12129[9] = { 115u, 104u, 97u, 114u, 101u, 108u, 111u, 103u, 0u }; // idb
const unsigned __int8 _func___12113[12] = { 103u, 101u, 116u, 95u, 100u, 101u, 118u, 105u, 99u, 101u, 115u, 0u }; // idb
const unsigned __int8 _func___12104[11] = { 103u, 101u, 116u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 chCRCHTalbe[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // idb
const unsigned __int8 chCRCLTalbe[256] =
{
  0u,
  192u,
  193u,
  1u,
  195u,
  3u,
  2u,
  194u,
  198u,
  6u,
  7u,
  199u,
  5u,
  197u,
  196u,
  4u,
  204u,
  12u,
  13u,
  205u,
  15u,
  207u,
  206u,
  14u,
  10u,
  202u,
  203u,
  11u,
  201u,
  9u,
  8u,
  200u,
  216u,
  24u,
  25u,
  217u,
  27u,
  219u,
  218u,
  26u,
  30u,
  222u,
  223u,
  31u,
  221u,
  29u,
  28u,
  220u,
  20u,
  212u,
  213u,
  21u,
  215u,
  23u,
  22u,
  214u,
  210u,
  18u,
  19u,
  211u,
  17u,
  209u,
  208u,
  16u,
  240u,
  48u,
  49u,
  241u,
  51u,
  243u,
  242u,
  50u,
  54u,
  246u,
  247u,
  55u,
  245u,
  53u,
  52u,
  244u,
  60u,
  252u,
  253u,
  61u,
  255u,
  63u,
  62u,
  254u,
  250u,
  58u,
  59u,
  251u,
  57u,
  249u,
  248u,
  56u,
  40u,
  232u,
  233u,
  41u,
  235u,
  43u,
  42u,
  234u,
  238u,
  46u,
  47u,
  239u,
  45u,
  237u,
  236u,
  44u,
  228u,
  36u,
  37u,
  229u,
  39u,
  231u,
  230u,
  38u,
  34u,
  226u,
  227u,
  35u,
  225u,
  33u,
  32u,
  224u,
  160u,
  96u,
  97u,
  161u,
  99u,
  163u,
  162u,
  98u,
  102u,
  166u,
  167u,
  103u,
  165u,
  101u,
  100u,
  164u,
  108u,
  172u,
  173u,
  109u,
  175u,
  111u,
  110u,
  174u,
  170u,
  106u,
  107u,
  171u,
  105u,
  169u,
  168u,
  104u,
  120u,
  184u,
  185u,
  121u,
  187u,
  123u,
  122u,
  186u,
  190u,
  126u,
  127u,
  191u,
  125u,
  189u,
  188u,
  124u,
  180u,
  116u,
  117u,
  181u,
  119u,
  183u,
  182u,
  118u,
  114u,
  178u,
  179u,
  115u,
  177u,
  113u,
  112u,
  176u,
  80u,
  144u,
  145u,
  81u,
  147u,
  83u,
  82u,
  146u,
  150u,
  86u,
  87u,
  151u,
  85u,
  149u,
  148u,
  84u,
  156u,
  92u,
  93u,
  157u,
  95u,
  159u,
  158u,
  94u,
  90u,
  154u,
  155u,
  91u,
  153u,
  89u,
  88u,
  152u,
  136u,
  72u,
  73u,
  137u,
  75u,
  139u,
  138u,
  74u,
  78u,
  142u,
  143u,
  79u,
  141u,
  77u,
  76u,
  140u,
  68u,
  132u,
  133u,
  69u,
  135u,
  71u,
  70u,
  134u,
  130u,
  66u,
  67u,
  131u,
  65u,
  129u,
  128u,
  64u
}; // idb
const unsigned __int8 _func___15463[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___15414[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15427[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15372[16] =
{
  104u,
  97u,
  115u,
  104u,
  116u,
  101u,
  115u,
  116u,
  95u,
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___15381[16] =
{
  104u,
  97u,
  115u,
  104u,
  116u,
  101u,
  115u,
  116u,
  95u,
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___15299[22] =
{
  98u,
  116u,
  109u,
  95u,
  114u,
  101u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  97u,
  103u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _func___15271[20] =
{
  98u,
  116u,
  109u,
  95u,
  115u,
  97u,
  118u,
  101u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___15261[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  100u,
  101u,
  116u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___15250[20] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___15238[18] =
{
  99u,
  111u,
  112u,
  121u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15196[9] = { 115u, 101u, 110u, 100u, 95u, 106u, 111u, 98u, 0u }; // idb
const unsigned __int8 _FUNCTION___15174[17] =
{
  115u,
  104u,
  111u,
  119u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15157[12] = { 115u, 104u, 111u, 119u, 95u, 115u, 116u, 97u, 116u, 117u, 115u, 0u }; // idb
const unsigned __int8 _FUNCTION___15070[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15043[18] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14670[12] = { 78u, 111u, 110u, 99u, 101u, 95u, 77u, 97u, 116u, 99u, 104u, 0u }; // idb
const unsigned __int8 _FUNCTION___14651[9] = { 99u, 104u, 101u, 99u, 107u, 95u, 104u, 119u, 0u }; // idb
const unsigned __int8 _FUNCTION___14489[14] =
{
  115u,
  99u,
  97u,
  110u,
  102u,
  114u,
  101u,
  113u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14429[34] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  51u,
  95u,
  83u,
  49u,
  49u,
  95u,
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14387[29] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  51u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  121u,
  102u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14210[23] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  108u,
  108u,
  100u,
  97u,
  116u,
  97u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  105u,
  110u,
  100u,
  101u,
  120u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14178[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  95u,
  118u,
  111u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13989[19] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  99u,
  108u,
  111u,
  99u,
  107u,
  95u,
  115u,
  101u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13977[24] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  108u,
  111u,
  99u,
  107u,
  95u,
  100u,
  101u,
  108u,
  97u,
  121u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13902[23] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  97u,
  110u,
  100u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13826[26] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  51u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13773[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  115u,
  121u,
  115u,
  116u,
  101u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13704[9] = { 115u, 101u, 116u, 95u, 98u, 97u, 117u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___13668[21] =
{
  115u,
  101u,
  116u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13648[21] =
{
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13625[29] =
{
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  95u,
  111u,
  110u,
  67u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13604[12] = { 115u, 101u, 116u, 95u, 97u, 100u, 100u, 114u, 101u, 115u, 115u, 0u }; // idb
const unsigned __int8 _FUNCTION___13590[15] =
{
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  105u,
  110u,
  97u,
  99u,
  116u,
  105u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13451[19] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13420[17] =
{
  115u,
  101u,
  116u,
  95u,
  109u,
  105u,
  115u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___13403[29] =
{
  100u,
  111u,
  95u,
  99u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13332[25] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13296[30] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13259[24] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  111u,
  110u,
  101u,
  67u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13127[19] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13073[24] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  117u,
  101u,
  110u,
  99u,
  121u,
  95u,
  110u,
  101u,
  119u,
  95u,
  66u,
  49u,
  51u,
  57u,
  51u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13040[20] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  117u,
  101u,
  110u,
  99u,
  121u,
  95u,
  66u,
  49u,
  51u,
  57u,
  51u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12823[33] =
{
  115u,
  101u,
  116u,
  95u,
  80u,
  87u,
  77u,
  95u,
  97u,
  99u,
  99u,
  111u,
  114u,
  100u,
  105u,
  110u,
  103u,
  95u,
  116u,
  111u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12746[12] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 104u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___12740[25] =
{
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12735[25] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12707[22] =
{
  115u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12701[22] =
{
  103u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12695[25] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12690[25] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12684[22] =
{
  115u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12679[22] =
{
  103u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12673[16] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12667[16] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12661[38] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12656[38] =
{
  103u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12650[20] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  114u,
  101u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12644[20] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  114u,
  101u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12638[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12633[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12627[15] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12622[15] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12617[25] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12612[25] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12606[15] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12601[15] =
{
  103u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12595[11] = { 115u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___12590[11] = { 103u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___12584[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12579[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12564[21] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12541[22] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12535[22] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12529[17] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  116u,
  56u,
  100u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12524[17] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  116u,
  56u,
  100u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12518[21] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12513[21] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12491[14] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  115u,
  112u,
  101u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12481[21] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  114u,
  100u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12472[17] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  111u,
  110u,
  95u,
  112u,
  108u,
  117u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12466[16] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12461[16] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12421[17] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12417[20] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  117u,
  112u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12413[22] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  100u,
  111u,
  119u,
  110u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12401[26] =
{
  115u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12396[26] =
{
  103u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12384[22] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12379[22] =
{
  103u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12373[36] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  97u,
  110u,
  100u,
  95u,
  106u,
  111u,
  98u,
  95u,
  105u,
  100u,
  95u,
  115u,
  116u,
  111u,
  114u,
  101u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12275[51] =
{
  115u,
  101u,
  116u,
  95u,
  86u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  83u,
  57u,
  95u,
  112u,
  108u,
  117u,
  115u,
  95u,
  112u,
  108u,
  117u,
  115u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  55u,
  95u,
  53u,
  52u,
  95u,
  119u,
  105u,
  116u,
  104u,
  111u,
  117u,
  116u,
  95u,
  100u,
  105u,
  115u,
  97u,
  98u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12257[41] =
{
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  115u,
  49u,
  49u,
  95u,
  105u,
  110u,
  116u,
  111u,
  95u,
  80u,
  73u,
  67u,
  95u,
  119u,
  105u,
  116u,
  104u,
  111u,
  117u,
  116u,
  95u,
  100u,
  105u,
  115u,
  97u,
  98u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12238[25] =
{
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  115u,
  49u,
  49u,
  95u,
  105u,
  110u,
  116u,
  111u,
  95u,
  80u,
  73u,
  67u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12218[35] =
{
  115u,
  101u,
  116u,
  95u,
  86u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  83u,
  57u,
  95u,
  112u,
  108u,
  117u,
  115u,
  95u,
  112u,
  108u,
  117u,
  115u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  55u,
  95u,
  53u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12116[19] =
{
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  112u,
  114u,
  111u,
  103u,
  114u,
  97u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11999[12] = { 115u, 101u, 116u, 95u, 112u, 105u, 99u, 95u, 105u, 105u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___11992[12] = { 103u, 101u, 116u, 95u, 112u, 105u, 99u, 95u, 105u, 105u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___11848[40] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  102u,
  105u,
  120u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11832[38] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  100u,
  99u,
  95u,
  100u,
  99u,
  95u,
  55u,
  53u,
  106u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11815[34] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  100u,
  99u,
  95u,
  100u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11798[32] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  112u,
  105u,
  99u,
  95u,
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11784[27] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11769[41] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  106u,
  117u,
  109u,
  112u,
  95u,
  116u,
  111u,
  95u,
  97u,
  112u,
  112u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  108u,
  111u,
  97u,
  100u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _func___9200[14] =
{
  95u,
  107u,
  95u,
  102u,
  114u,
  101u,
  101u,
  95u,
  115u,
  116u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___9186[13] = { 95u, 107u, 95u, 102u, 114u, 101u, 101u, 95u, 108u, 105u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___9176[25] =
{
  95u,
  107u,
  95u,
  108u,
  105u,
  115u,
  116u,
  95u,
  116u,
  114u,
  97u,
  110u,
  115u,
  102u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  116u,
  97u,
  105u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___9166[25] =
{
  95u,
  107u,
  95u,
  108u,
  105u,
  115u,
  116u,
  95u,
  116u,
  114u,
  97u,
  110u,
  115u,
  102u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  104u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___9157[15] =
{
  95u,
  107u,
  95u,
  117u,
  110u,
  108u,
  105u,
  110u,
  107u,
  95u,
  105u,
  116u,
  101u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___9147[16] =
{
  95u,
  107u,
  95u,
  105u,
  110u,
  115u,
  101u,
  114u,
  116u,
  95u,
  97u,
  102u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _func___9136[17] =
{
  95u,
  107u,
  95u,
  105u,
  110u,
  115u,
  101u,
  114u,
  116u,
  95u,
  98u,
  101u,
  102u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___9125[12] = { 95u, 107u, 95u, 97u, 100u, 100u, 95u, 116u, 97u, 105u, 108u, 0u }; // idb
const unsigned __int8 _func___9116[12] = { 95u, 107u, 95u, 97u, 100u, 100u, 95u, 104u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___9107[15] =
{
  95u,
  107u,
  95u,
  117u,
  110u,
  108u,
  105u,
  110u,
  107u,
  95u,
  116u,
  97u,
  105u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___9081[12] = { 95u, 107u, 95u, 110u, 101u, 119u, 95u, 108u, 105u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___9068[12] = { 107u, 95u, 110u, 101u, 119u, 95u, 115u, 116u, 111u, 114u, 101u, 0u }; // idb
const unsigned __int8 _func___9052[14] = { 107u, 95u, 97u, 108u, 108u, 111u, 99u, 95u, 105u, 116u, 101u, 109u, 115u, 0u }; // idb
unsigned __int8 byte_7A680[4] = { 0u, 0u, 0u, 0u }; // weak
const unsigned __int8 _func___9625[14] =
{
  109u,
  121u,
  95u,
  108u,
  111u,
  103u,
  95u,
  99u,
  117u,
  114u,
  115u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___9075[11] = { 105u, 115u, 100u, 117u, 112u, 110u, 111u, 110u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___9059[9] = { 100u, 117u, 112u, 97u, 108u, 108u, 111u, 99u, 0u }; // idb
const unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const int hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // idb
const int b58tobin_tbl[123] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  -1,
  17,
  18,
  19,
  20,
  21,
  -1,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  -1,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57
}; // idb
const unsigned __int8 _func___10913[22] =
{
  99u,
  103u,
  95u,
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___10904[18] =
{
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___10843[9] = { 115u, 116u, 114u, 95u, 116u, 101u, 120u, 116u, 0u }; // idb
const unsigned __int8 _func___10835[15] =
{
  114u,
  101u,
  97u,
  108u,
  108u,
  111u,
  99u,
  95u,
  115u,
  116u,
  114u,
  99u,
  97u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___10800[17] =
{
  105u,
  110u,
  105u,
  116u,
  105u,
  97u,
  116u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___10775[16] =
{
  115u,
  117u,
  115u,
  112u,
  101u,
  110u,
  100u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___10723[21] =
{
  115u,
  101u,
  116u,
  117u,
  112u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  111u,
  99u,
  107u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___10698[17] =
{
  115u,
  111u,
  99u,
  107u,
  115u,
  52u,
  95u,
  110u,
  101u,
  103u,
  111u,
  116u,
  105u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___10670[17] =
{
  115u,
  111u,
  99u,
  107u,
  115u,
  53u,
  95u,
  110u,
  101u,
  103u,
  111u,
  116u,
  105u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___10556[16] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  114u,
  101u,
  99u,
  111u,
  110u,
  110u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___10531[17] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  101u,
  120u,
  116u,
  114u,
  97u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___10519[11] = { 112u, 97u, 114u, 115u, 101u, 95u, 100u, 105u, 102u, 102u, 0u }; // idb
const unsigned __int8 _func___10481[13] = { 112u, 97u, 114u, 115u, 101u, 95u, 110u, 111u, 116u, 105u, 102u, 121u, 0u }; // idb
const unsigned __int8 _func___10425[14] = { 114u, 101u, 99u, 97u, 108u, 108u, 111u, 99u, 95u, 115u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___10408[11] = { 99u, 108u, 101u, 97u, 114u, 95u, 115u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___10376[13] = { 115u, 116u, 114u, 97u, 116u, 117u, 109u, 95u, 115u, 101u, 110u, 100u, 0u }; // idb
const unsigned __int8 _func___10207[10] = { 99u, 111u, 112u, 121u, 95u, 116u, 105u, 109u, 101u, 0u }; // idb
const unsigned __int8 _func___10183_0[16] =
{
  116u,
  104u,
  114u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  99u,
  114u,
  101u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___10173[7] = { 116u, 113u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___10165[8] = { 116u, 113u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _func___10152[14] =
{
  116u,
  113u,
  95u,
  102u,
  114u,
  101u,
  101u,
  122u,
  101u,
  116u,
  104u,
  97u,
  119u,
  0u
}; // idb
const unsigned __int8 _func___10139[7] = { 116u, 113u, 95u, 110u, 101u, 119u, 0u }; // idb
const unsigned __int8 _func___10110[11] = { 115u, 101u, 114u, 95u, 115u, 116u, 114u, 105u, 110u, 103u, 0u }; // idb
const unsigned __int8 _func___10097[22] =
{
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  95u,
  116u,
  111u,
  95u,
  112u,
  117u,
  98u,
  107u,
  101u,
  121u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _func___10023[8] = { 98u, 105u, 110u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 hex_10013[16] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u
}; // idb
const unsigned __int8 _func___10003[10] = { 103u, 101u, 116u, 95u, 112u, 114u, 111u, 120u, 121u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___5165[10] = { 112u, 97u, 114u, 115u, 101u, 95u, 111u, 110u, 101u, 0u }; // idb
_UNKNOWN unk_7C728; // weak
const unsigned __int8 whitespace[33] =
{
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  0u
}; // idb
unsigned __int8 byte_7C7B0[4] = { 10u, 0u, 0u, 0u }; // weak
unsigned __int8 byte_7C7B4[4] = { 32u, 0u, 0u, 0u }; // weak
unsigned __int8 byte_7C7B8[4] = { 34u, 0u, 0u, 0u }; // weak
_UNKNOWN unk_7C7BC; // weak
_UNKNOWN unk_7C7C0; // weak
_UNKNOWN unk_7C7C4; // weak
_UNKNOWN unk_7C7C8; // weak
_UNKNOWN unk_7C7CC; // weak
_UNKNOWN unk_7C7D0; // weak
_UNKNOWN unk_7C7D4; // weak
_UNKNOWN unk_7C7D8; // weak
const unsigned __int8 _PRETTY_FUNCTION___6031[8] = { 100u, 111u, 95u, 100u, 117u, 109u, 112u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___6087[16] =
{
  108u,
  101u,
  120u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___6061[16] =
{
  108u,
  101u,
  120u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  115u,
  116u,
  114u,
  105u,
  110u,
  103u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___6038[22] =
{
  100u,
  101u,
  99u,
  111u,
  100u,
  101u,
  95u,
  117u,
  110u,
  105u,
  99u,
  111u,
  100u,
  101u,
  95u,
  101u,
  115u,
  99u,
  97u,
  112u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___6023[17] =
{
  108u,
  101u,
  120u,
  95u,
  117u,
  110u,
  103u,
  101u,
  116u,
  95u,
  117u,
  110u,
  115u,
  97u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___6000[13] = { 115u, 116u, 114u, 101u, 97u, 109u, 95u, 117u, 110u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___5992[11] = { 115u, 116u, 114u, 101u, 97u, 109u, 95u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 *const type_names[8] =
{
  &aObject,
  &aArray,
  &aString_0,
  &aInteger,
  &aReal,
  &aTrue_3,
  &aFalse_3,
  &aNull_3
}; // idb
const unsigned __int8 unpack_value_starters[12] = { 123u, 91u, 115u, 105u, 73u, 98u, 102u, 70u, 79u, 111u, 110u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___6782[13] = { 106u, 115u, 111u, 110u, 112u, 95u, 115u, 116u, 114u, 116u, 111u, 100u, 0u }; // idb
const unsigned __int8 *UNAVAILABLE = &aApiWillNotBeAv; // idb
const unsigned __int8 *MUNAVAILABLE = &aApiMulticastLi; // idb
const unsigned __int8 *BLANK = &unk_6C900; // idb
const unsigned __int8 *COMMA = &asc_6C904; // idb
const unsigned __int8 *APIVERSION = &unk_6C908; // idb
const unsigned __int8 *DEAD = &aDead; // idb
const unsigned __int8 *SICK = &aSick; // idb
const unsigned __int8 *NOSTART = &aNostart; // idb
const unsigned __int8 *INIT = &aInitialising; // idb
const unsigned __int8 *DISABLED = &aDisabled; // idb
const unsigned __int8 *ALIVE = &aAlive; // idb
const unsigned __int8 *REJECTING = &aRejecting; // idb
const unsigned __int8 *UNKNOWN = &aUnknown; // idb
const unsigned __int8 *NONE = &aNone; // idb
const unsigned __int8 *YES = &aY; // idb
const unsigned __int8 *NO = &aN; // idb
const unsigned __int8 *NULLSTR = &aNull; // idb
const unsigned __int8 *TRUESTR = &aTrue; // idb
const unsigned __int8 *FALSESTR = &aFalse; // idb
const unsigned __int8 *SHA256STR = &aSha256; // idb
const unsigned __int8 *DEVICECODE = &unk_6C900; // idb
const unsigned __int8 *OSINFO = &aLinux; // idb
const unsigned __int8 *JSON_COMMAND = &aCommand; // idb
const unsigned __int8 *JSON_PARAMETER = &aParameter; // idb
CODES codes[84] =
{
  { SEVERITY_SUCC, 7, PARAM_PMAX, &aDPoolS },
  { SEVERITY_ERR, 8, PARAM_NONE, &aNoPools },
  { SEVERITY_SUCC, 9, PARAM_DMAX, &aDAscS },
  { SEVERITY_ERR, 10, PARAM_NONE, &aNoAscs },
  { SEVERITY_SUCC, 11, PARAM_NONE, &aSummary_1 },
  { SEVERITY_SUCC, 16, PARAM_NONE, &aNonceNum },
  { SEVERITY_ERR, 14, PARAM_NONE, &aInvalidCommand },
  { SEVERITY_ERR, 15, PARAM_NONE, &aMissingDeviceI },
  { SEVERITY_SUCC, 59, PARAM_NONE, &aPgaCount_0 },
  { SEVERITY_SUCC, 104, PARAM_NONE, &aAscCount_0 },
  { SEVERITY_SUCC, 22, PARAM_NONE, &aCgminerVersion },
  { SEVERITY_ERR, 23, PARAM_NONE, &aInvalidJson },
  { SEVERITY_ERR, 24, PARAM_CMD, &aMissingJsonS },
  { SEVERITY_ERR, 25, PARAM_NONE, &aMissingPoolIdP },
  { SEVERITY_ERR, 26, PARAM_POOLMAX, &aInvalidPoolIdD },
  { SEVERITY_SUCC, 27, PARAM_POOL, &aSwitchingToPoo_1 },
  { SEVERITY_SUCC, 33, PARAM_NONE, &aCgminerConfig },
  { SEVERITY_ERR, 42, PARAM_NONE, &aMissingSaveFil },
  { SEVERITY_ERR, 43, PARAM_STR, &aCanTOpenOrCrea },
  { SEVERITY_SUCC, 44, PARAM_STR, &aConfigurationS },
  { SEVERITY_ERR, 45, PARAM_STR, &aAccessDeniedTo },
  { SEVERITY_SUCC, 46, PARAM_NONE, &aPrivilegedAcce },
  { SEVERITY_SUCC, 47, PARAM_POOL, &aEnablingPoolDS },
  { SEVERITY_SUCC, 73, PARAM_NONE, &aChangedPoolPri },
  { SEVERITY_ERR, 74, PARAM_PID, &aDuplicatePoolS },
  { SEVERITY_SUCC, 48, PARAM_POOL, &aDisablingPoolD },
  { SEVERITY_INFO, 49, PARAM_POOL, &aPoolDSAlreadyE },
  { SEVERITY_INFO, 50, PARAM_POOL, &aPoolDSAlreadyD },
  { SEVERITY_ERR, 51, PARAM_POOL, &aCannotDisableL },
  { SEVERITY_ERR, 52, PARAM_NONE, &aMissingAddpool },
  { SEVERITY_ERR, 53, PARAM_STR, &aInvalidAddpool },
  { SEVERITY_ERR, 54, PARAM_NONE, &aReachedMaximum },
  { SEVERITY_SUCC, 55, PARAM_POOL, &aAddedPoolDS },
  { SEVERITY_ERR, 66, PARAM_POOL, &aCannotRemoveLa },
  { SEVERITY_ERR, 67, PARAM_POOL, &aCannotRemoveAc },
  { SEVERITY_SUCC, 68, PARAM_BOTH, &aRemovedPoolDS },
  { SEVERITY_SUCC, 60, PARAM_NONE, &aNotify_1 },
  { SEVERITY_SUCC, 69, PARAM_NONE, &aDeviceDetails },
  { SEVERITY_SUCC, 70, PARAM_NONE, &aCgminerStats },
  { SEVERITY_ERR, 71, PARAM_NONE, &aMissingCheckCm },
  { SEVERITY_SUCC, 72, PARAM_NONE, &aCheckCommand },
  { SEVERITY_ERR, 75, PARAM_NONE, &aMissingParamet },
  { SEVERITY_ERR, 76, PARAM_NONE, &aInvalidParamet_0 },
  { SEVERITY_SUCC, 77, PARAM_BOOL, &aFailoverOnlySe },
  { SEVERITY_SUCC, 78, PARAM_NONE, &aCgminerCoin },
  { SEVERITY_SUCC, 79, PARAM_NONE, &aDebugSettings },
  { SEVERITY_SUCC, 82, PARAM_SET, &aSetConfigSToD },
  { SEVERITY_ERR, 83, PARAM_STR, &aUnknownConfigS },
  { SEVERITY_ERR, 126, PARAM_STR, &aDeprecatedConf },
  { SEVERITY_ERR, 84, PARAM_BOTH, &aInvalidNumberD },
  { SEVERITY_ERR, 121, PARAM_BOTH, &aInvalidNegativ_0 },
  { SEVERITY_SUCC, 122, PARAM_SET, &aSetPoolSToQuot },
  { SEVERITY_ERR, 85, PARAM_NONE, &aMissingConfigP },
  { SEVERITY_ERR, 86, PARAM_STR, &aMissingConfigV },
  { SEVERITY_SUCC, 87, PARAM_NONE, &aUsbStatistics },
  { SEVERITY_INFO, 88, PARAM_NONE, &aNoUsbStatistic },
  { SEVERITY_ERR, 94, PARAM_NONE, &aMissingZeroPar },
  { SEVERITY_ERR, 95, PARAM_STR, &aInvalidZeroPar },
  { SEVERITY_SUCC, 96, PARAM_STR, &aZeroedSStatsWi },
  { SEVERITY_SUCC, 97, PARAM_STR, &aZeroedSStatsWi_0 },
  { SEVERITY_ERR, 99, PARAM_STR, &aInvalidValueFo },
  { SEVERITY_SUCC, 100, PARAM_INT, &aHotplugCheckSe },
  { SEVERITY_SUCC, 101, PARAM_NONE, &aHotplugDisable },
  { SEVERITY_WARN, 102, PARAM_NONE, &aHotplugIsNotAv },
  { SEVERITY_ERR, 103, PARAM_NONE, &aMissingHotplug },
  { SEVERITY_ERR, 105, PARAM_NONE, &aNoAscs },
  { SEVERITY_SUCC, 106, PARAM_ASC, &aAscD },
  { SEVERITY_ERR, 107, PARAM_ASCMAX, &aInvalidAscIdDR },
  { SEVERITY_INFO, 108, PARAM_ASC, &aAscDAlreadyEna },
  { SEVERITY_INFO, 109, PARAM_ASC, &aAscDAlreadyDis },
  { SEVERITY_INFO, 110, PARAM_ASC, &aAscDSentEnable },
  { SEVERITY_INFO, 111, PARAM_ASC, &aAscDSetDisable },
  { SEVERITY_ERR, 112, PARAM_ASC, &aAscDIsNotFlagg },
  { SEVERITY_SUCC, 113, PARAM_ASC, &aIdentifyComman },
  { SEVERITY_WARN, 114, PARAM_ASC, &aAscDDoesNotSup },
  { SEVERITY_ERR, 116, PARAM_NONE, &aMissingOptionA },
  { SEVERITY_WARN, 117, PARAM_ASC, &aAscDDoesNotSup_0 },
  { SEVERITY_INFO, 118, PARAM_BOTH, &aAscDSetHelpS },
  { SEVERITY_SUCC, 119, PARAM_BOTH, &aAscDSetOk },
  { SEVERITY_ERR, 120, PARAM_BOTH, &aAscDSetFailedS },
  { SEVERITY_SUCC, 125, PARAM_NONE, &aLcd_1 },
  { SEVERITY_SUCC, 123, PARAM_NONE, &aLockStatsCreat },
  { SEVERITY_WARN, 124, PARAM_NONE, &aLockStatsNotEn },
  { SEVERITY_FAIL, 0, PARAM_PGA, NULL }
}; // idb
const unsigned __int8 *localaddr = &a127001; // idb
CMDS cmds[40] =
{
  {
    &aVersion_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xCCD5,
    false,
    true
  },
  {
    &aConfig_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xCDCD,
    false,
    true
  },
  {
    &aDevs_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xD385,
    false,
    true
  },
  {
    &aEdevs,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xD451,
    false,
    true
  },
  {
    &aPools_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xD51D,
    false,
    true
  },
  {
    &aSummary_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xDF6D,
    false,
    true
  },
  {
    &aNoncenum_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xE56D,
    false,
    true
  },
  {
    &aPgacount,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xE62D,
    false,
    true
  },
  {
    &aSwitchpool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xE6B9,
    true,
    false
  },
  {
    &aAddpool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xE90D,
    true,
    false
  },
  {
    &aPoolpriority,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xEAC5,
    true,
    false
  },
  {
    &aPoolquota,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xED6D,
    true,
    false
  },
  {
    &aEnablepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xE9E5,
    true,
    false
  },
  {
    &aDisablepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xEE79,
    true,
    false
  },
  {
    &aRemovepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xEF75,
    true,
    false
  },
  {
    &aSave,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xF661,
    true,
    false
  },
  {
    &aQuit_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xF0B1,
    true,
    false
  },
  {
    &aPrivileged,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xF159,
    true,
    false
  },
  {
    &aNotify_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xF411,
    false,
    true
  },
  {
    &aDevdetails_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xF4BD,
    false,
    true
  },
  {
    &aRestart_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xF105,
    true,
    false
  },
  {
    &aStats_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xF949,
    false,
    true
  },
  {
    &aEstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xFAB1,
    false,
    true
  },
  {
    &aCheck_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x11001,
    false,
    false
  },
  {
    &aFailoverOnly,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xFBA1,
    true,
    false
  },
  {
    &aCoin_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xFBC9,
    false,
    true
  },
  {
    &aDebug_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xFD01,
    true,
    false
  },
  {
    &aSetconfig,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x10069,
    true,
    false
  },
  {
    &aUsbstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x100DD,
    false,
    true
  },
  {
    &aZero,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x10111,
    true,
    false
  },
  {
    &aHotplug_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1029D,
    true,
    false
  },
  {
    &aAsc_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x102C5,
    false,
    false
  },
  {
    &aAscenable,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1038D,
    true,
    false
  },
  {
    &aAscdisable,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x10605,
    true,
    false
  },
  {
    &aAscidentify,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x107B1,
    true,
    false
  },
  {
    &aAscset,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x10921,
    true,
    false
  },
  {
    &aAsccount,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1088D,
    false,
    true
  },
  {
    &aLcd_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xDD41,
    false,
    true
  },
  {
    &aLockstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0xCCAD,
    true,
    true
  },
  { NULL, NULL, false, false }
}; // idb
unsigned __int8 *curly = &unk_6E668; // idb
strategies strategies_0[5] =
{
  { &aFailover },
  { &aRoundRobin },
  { &aRotate },
  { &aLoadBalance },
  { &aBalance }
}; // idb
benchfile_layout benchfile_data[5] =
{
  { 1, &aVersion_2 },
  { 64, &aMerkleroot },
  { 64, &aPrevhash },
  { 8, &aDifficultybits },
  { 10, &aNoncetime }
}; // idb
int opt_log_interval = 5; // idb
int max_queue = 1; // idb
int opt_scantime = -1; // idb
int opt_expiry = 120; // idb
int opt_pool_fallback = 120; // idb
unsigned int global_quota_gcd = 1u; // idb
bool opt_restart = true; // idb
bool opt_submit_stale = true; // idb
unsigned __int8 *opt_api_description = &aBmminer100; // idb
int opt_api_port = 4028; // idb
unsigned __int8 *opt_api_host = &a0000; // idb
unsigned __int8 *opt_api_mcast_addr = &a2240075; // idb
unsigned __int8 *opt_api_mcast_code = &aFtw; // idb
unsigned __int8 *opt_api_mcast_des = &byte_71100; // idb
int opt_api_mcast_port = 4028; // idb
unsigned __int8 best_share[8] = { 48u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // idb
double current_diff = 1.84467441e19; // idb
int opt_multi_version = 1; // idb
unsigned __int8 *getwork_req = &aMethodGetworkP; // idb
opt_table opt_config_table[72] =
{
  {
    &aVersionFile,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17AC5,
    NULL,
    { &opt_hidden },
    &aSetMinerVersio
  },
  {
    &aLogfileOpenfla,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17979,
    NULL,
    { &opt_hidden },
    &aSetLogFileOpen
  },
  {
    &aLogwork,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1799D,
    NULL,
    { &opt_hidden },
    &aSetLogWorkFile
  },
  {
    &aLogworkAsicnum,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x179C1,
    NULL,
    { &opt_hidden },
    &aSetLogWorkAsic
  },
  {
    &aLogworkDiff,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_logwork_diff },
    &aAllowLogWorkDi
  },
  {
    &aLogfile,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17955,
    NULL,
    { &opt_hidden },
    &aSetLogFileDefa
  },
  {
    &aApiAllow,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_api_allow },
    &aAllowApiAccess
  },
  {
    &aApiDescription,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_api_description },
    &aDescriptionPla
  },
  {
    &aApiGroups,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_api_groups },
    &aApiOneLetterGr
  },
  {
    &aApiListen,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_api_listen },
    &aEnableApiDefau
  },
  {
    &aApiMcast,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_api_mcast },
    &aEnableApiMulti
  },
  {
    &aApiMcastAddr,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_api_mcast_addr },
    &aApiMulticastLi_0
  },
  {
    &aApiMcastCode,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_api_mcast_code },
    &aCodeExpectedIn
  },
  {
    &aApiMcastDes,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_api_mcast_des },
    &aDescriptionApp
  },
  {
    &aApiMcastPort,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A69,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_api_mcast_port },
    &aApiMulticastLi_1
  },
  {
    &aApiNetwork,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_api_network },
    &aAllowApiIfEnab
  },
  {
    &aApiPort,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A69,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_api_port },
    &aPortNumberOfMi
  },
  {
    &aApiHost,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_api_host },
    &aSpecifyApiList
  },
  {
    &aBalance_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x16C95,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo
  },
  {
    &aBenchfile_0,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_benchfile },
    &aRunCgminerInBe
  },
  {
    &aBenchfileDispl,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_benchfile_display },
    &aDisplayEachBen
  },
  {
    &aBenchmark_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_benchmark },
    &aRunCgminerInBe_0
  },
  {
    &aBitmainFanCtrl,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_bitmain_fan_ctrl },
    &aEnableBitmainM
  },
  {
    &aBitmainFanPwm,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16AB1,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_bitmain_fan_pwm },
    &aSetBitmainFanP
  },
  {
    &aBitmainFreq,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A45,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_bitmain_soc_freq },
    &aSetFrequency
  },
  {
    &aBitmainVoltage,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A45,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_bitmain_soc_voltage },
    &aSetVoltage
  },
  {
    &aFixedFreq,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_fixed_freq },
    &aSetBitmainMine
  },
  {
    &aNoPreHeat,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62EA1,
    NULL,
    NULL,
    { &opt_pre_heat },
    &aSetBitmainMine_0
  },
  {
    &aDebugD,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x173A9,
    NULL,
    NULL,
    { &opt_debug },
    &aEnableDebugOut
  },
  {
    &aDisableRejecti,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_disable_pool },
    &aAutomaticallyD
  },
  {
    &aExpiryE,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A45,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_expiry },
    &aUpperBoundOnHo
  },
  {
    &aExtranonceSubs_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x172CD,
    NULL,
    NULL,
    { NULL },
    &aEnableExtranon_0
  },
  {
    &aFailoverOnly_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_fail_only },
    &aDonTLeakWorkTo
  },
  {
    &aFixProtocol,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_fix_protocol },
    &aDoNotRedirectT
  },
  {
    &aFallbackTime,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62FBD,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_pool_fallback },
    &aSetTimeInSecon
  },
  {
    &aHotplug_1,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A45,
    NULL,
    { &hotplug_time },
    &opt_hidden
  },
  {
    &aLoadBalance_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x16CB1,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_0
  },
  {
    &aLogL,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A45,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_log_interval },
    &aIntervalInSeco
  },
  {
    &aLowmem,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_lowmem },
    &aMinimiseCachin
  },
  {
    &aMonitorM,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_stderr_cmd },
    &aUseCustomPipeC
  },
  {
    &aNetDelay,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_delaynet },
    &aImposeSmallDel
  },
  {
    &aNoPoolDisable,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62EBD,
    NULL,
    NULL,
    { &opt_disable_pool },
    &opt_hidden
  },
  {
    &aNoSubmitStale,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62EBD,
    NULL,
    NULL,
    { &opt_submit_stale },
    &aDonTSubmitShar
  },
  {
    &aPassP,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17145,
    NULL,
    { &opt_set_null },
    &aPasswordForBit
  },
  {
    &aPerDeviceStats,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &want_per_device_stats },
    &aForceVerboseMo
  },
  {
    &aPools_2,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62E85,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aProtocolDumpP,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_protocol },
    &aVerboseDumpOfP
  },
  {
    &aQueueQ,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A45,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_queue },
    &aMaximumNumberO
  },
  {
    &aQuietQ,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_quiet },
    &aDisableLogging
  },
  {
    &aQuotaU,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16F81,
    NULL,
    { &opt_set_null },
    &aQuotaUrlCombin
  },
  {
    &aRealQuiet,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_realquiet },
    &aDisableAllOutp
  },
  {
    &aRetries,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17AAD,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRetryPause,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17AAD,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRotate_0,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16CCD,
    NULL,
    { &opt_set_null },
    &aChangeMultipoo_1
  },
  {
    &aRoundRobin_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x16D05,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_2
  },
  {
    &aScanTimeS,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16A45,
    (void (*)(unsigned __int8 *, const void *))0x632ED,
    { &opt_scantime },
    &aUpperBoundOnTi
  },
  {
    &aSchedStart,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17441,
    NULL,
    { &opt_set_sched_start },
    &aSetATimeOfDayI
  },
  {
    &aSchedStop,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17465,
    NULL,
    { &opt_set_sched_stop },
    &aSetATimeOfDayI_0
  },
  {
    &aSharelog,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17489,
    NULL,
    { &opt_set_sharelog },
    &aAppendShareLog
  },
  {
    &aShares,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62FBD,
    NULL,
    { &opt_shares },
    &aQuitAfterMinin
  },
  {
    &aSocksProxy,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62F9D,
    NULL,
    { &opt_socks_proxy },
    &aSetSocks4Proxy
  },
  {
    &aSuggestDiff,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62FBD,
    NULL,
    { &opt_suggest_diff },
    &aSuggestMinerDi
  },
  {
    &aMultiVersion,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x62FBD,
    NULL,
    { &opt_multi_version },
    &aMultiVersionMi
  },
  {
    &aSyslog_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &use_syslog },
    &aUseSystemLogFo
  },
  {
    &aTextOnlyT,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62EBD,
    NULL,
    NULL,
    { &use_curses },
    &opt_hidden
  },
  {
    &aUrlO,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x16EB1,
    NULL,
    { &opt_set_null },
    &aUrlForBitcoinJ
  },
  {
    &aUserU,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x170BD,
    NULL,
    { &opt_set_null },
    &aUsernameForBit
  },
  {
    &aUserpassO,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x171CD,
    NULL,
    { &opt_set_null },
    &aUsernamePasswo
  },
  {
    &aVerbose_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_log_output },
    &aLogVerboseOutp
  },
  {
    &aWidescreen,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_widescreen },
    &aUseExtraWideDi
  },
  {
    &aWorktime_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x62E85,
    NULL,
    NULL,
    { &opt_worktime },
    &aDisplayExtraWo
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
opt_table opt_cmdline_table[5] =
{
  {
    &aConfigC,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17E7D,
    NULL,
    { &opt_set_null },
    &aLoadAJsonForma
  },
  {
    &aDefaultConfig,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x17F8D,
    NULL,
    { &opt_set_null },
    &aSpecifyTheFile
  },
  {
    &aHelpH,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x18039,
    NULL,
    NULL,
    { NULL },
    &aPrintThisMessa
  },
  {
    &aVersionV,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x631B9,
    NULL,
    NULL,
    { &packagename },
    &aDisplayVersion
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
unsigned __int8 *workpadding = &a00000080000000; // idb
double total_secs = 1.0; // idb
double new_total_secs = 1.0; // idb
double last_total_secs = 1.0; // idb
unsigned int crc16_table[256] =
{
  0u,
  4129u,
  8258u,
  12387u,
  16516u,
  20645u,
  24774u,
  28903u,
  33032u,
  37161u,
  41290u,
  45419u,
  49548u,
  53677u,
  57806u,
  61935u,
  4657u,
  528u,
  12915u,
  8786u,
  21173u,
  17044u,
  29431u,
  25302u,
  37689u,
  33560u,
  45947u,
  41818u,
  54205u,
  50076u,
  62463u,
  58334u,
  9314u,
  13379u,
  1056u,
  5121u,
  25830u,
  29895u,
  17572u,
  21637u,
  42346u,
  46411u,
  34088u,
  38153u,
  58862u,
  62927u,
  50604u,
  54669u,
  13907u,
  9842u,
  5649u,
  1584u,
  30423u,
  26358u,
  22165u,
  18100u,
  46939u,
  42874u,
  38681u,
  34616u,
  63455u,
  59390u,
  55197u,
  51132u,
  18628u,
  22757u,
  26758u,
  30887u,
  2112u,
  6241u,
  10242u,
  14371u,
  51660u,
  55789u,
  59790u,
  63919u,
  35144u,
  39273u,
  43274u,
  47403u,
  23285u,
  19156u,
  31415u,
  27286u,
  6769u,
  2640u,
  14899u,
  10770u,
  56317u,
  52188u,
  64447u,
  60318u,
  39801u,
  35672u,
  47931u,
  43802u,
  27814u,
  31879u,
  19684u,
  23749u,
  11298u,
  15363u,
  3168u,
  7233u,
  60846u,
  64911u,
  52716u,
  56781u,
  44330u,
  48395u,
  36200u,
  40265u,
  32407u,
  28342u,
  24277u,
  20212u,
  15891u,
  11826u,
  7761u,
  3696u,
  65439u,
  61374u,
  57309u,
  53244u,
  48923u,
  44858u,
  40793u,
  36728u,
  37256u,
  33193u,
  45514u,
  41451u,
  53516u,
  49453u,
  61774u,
  57711u,
  4224u,
  161u,
  12482u,
  8419u,
  20484u,
  16421u,
  28742u,
  24679u,
  33721u,
  37784u,
  41979u,
  46042u,
  49981u,
  54044u,
  58239u,
  62302u,
  689u,
  4752u,
  8947u,
  13010u,
  16949u,
  21012u,
  25207u,
  29270u,
  46570u,
  42443u,
  38312u,
  34185u,
  62830u,
  58703u,
  54572u,
  50445u,
  13538u,
  9411u,
  5280u,
  1153u,
  29798u,
  25671u,
  21540u,
  17413u,
  42971u,
  47098u,
  34713u,
  38840u,
  59231u,
  63358u,
  50973u,
  55100u,
  9939u,
  14066u,
  1681u,
  5808u,
  26199u,
  30326u,
  17941u,
  22068u,
  55628u,
  51565u,
  63758u,
  59695u,
  39368u,
  35305u,
  47498u,
  43435u,
  22596u,
  18533u,
  30726u,
  26663u,
  6336u,
  2273u,
  14466u,
  10403u,
  52093u,
  56156u,
  60223u,
  64286u,
  35833u,
  39896u,
  43963u,
  48026u,
  19061u,
  23124u,
  27191u,
  31254u,
  2801u,
  6864u,
  10931u,
  14994u,
  64814u,
  60687u,
  56684u,
  52557u,
  48554u,
  44427u,
  40424u,
  36297u,
  31782u,
  27655u,
  23652u,
  19525u,
  15522u,
  11395u,
  7392u,
  3265u,
  61215u,
  65342u,
  53085u,
  57212u,
  44955u,
  49082u,
  36825u,
  40952u,
  28183u,
  32310u,
  20053u,
  24180u,
  11923u,
  16050u,
  3793u,
  7920u
}; // idb
device_drv bitmain_soc_drv =
{
  DRIVER_bitmain_soc,
  &aBitmainSoc,
  &aBtmSoc,
  (void (*)(bool))0x4F865,
  (void (*)(cgpu_info *))0x4F839,
  (void (*)(unsigned __int8 *, size_t, cgpu_info *))0x5151D,
  NULL,
  (api_data *(*)(cgpu_info *))0x51639,
  NULL,
  NULL,
  NULL,
  (bool (*)(thr_info *))0x4F665,
  NULL,
  NULL,
  NULL,
  (void (*)(thr_info *))0x29061,
  NULL,
  (int64_t (*)(thr_info *))0x5122D,
  NULL,
  (void (*)(cgpu_info *))0x51281,
  (void (*)(cgpu_info *))0x51281,
  NULL,
  (void (*)(thr_info *))0x52961,
  NULL,
  NULL,
  false,
  0.0,
  0.0
}; // idb
freq_pll freq_pll_1393_0[179] =
{
  { 19, 131136u, 1056u, 2097779u },
  { 22, 131136u, 1056u, 2097763u },
  { 26, 131136u, 1056u, 2097747u },
  { 28, 131136u, 1056u, 2097778u },
  { 33, 131136u, 1056u, 2097731u },
  { 40, 131136u, 1056u, 2097746u },
  { 50, 131136u, 1056u, 2097730u },
  { 57, 131136u, 1056u, 2097777u },
  { 66, 131136u, 1056u, 2097761u },
  { 80, 131136u, 1056u, 2097745u },
  { 100, 131136u, 1056u, 2097729u },
  { 125, 163904u, 1056u, 2622017u },
  { 150, 196672u, 1056u, 7864660u },
  { 175, 229440u, 1056u, 3670593u },
  { 200, 262208u, 1056u, 4194881u },
  { 225, 294976u, 1056u, 4719169u },
  { 250, 327744u, 1056u, 5243457u },
  { 275, 360512u, 1056u, 5767745u },
  { 300, 393280u, 1056u, 7864658u },
  { 303, 393280u, 1056u, 6357569u },
  { 306, 393280u, 1056u, 6423105u },
  { 309, 393280u, 1056u, 6488641u },
  { 312, 393280u, 1056u, 6554177u },
  { 315, 393280u, 1056u, 6619713u },
  { 318, 393280u, 1056u, 6685249u },
  { 321, 393280u, 1056u, 6750785u },
  { 325, 426048u, 1056u, 6816321u },
  { 328, 393280u, 1056u, 6881857u },
  { 331, 393280u, 1056u, 6947393u },
  { 334, 393280u, 1056u, 7012929u },
  { 337, 458816u, 1056u, 7078465u },
  { 340, 393280u, 1056u, 7144001u },
  { 343, 393280u, 1056u, 7209537u },
  { 346, 393280u, 1056u, 7275073u },
  { 350, 426048u, 1056u, 5505330u },
  { 353, 393280u, 1056u, 7406145u },
  { 356, 393280u, 1056u, 7471681u },
  { 359, 393280u, 1056u, 7537217u },
  { 362, 393280u, 1056u, 7602753u },
  { 365, 393280u, 1056u, 7668289u },
  { 368, 393280u, 1056u, 7733825u },
  { 371, 393280u, 1056u, 7799361u },
  { 375, 426048u, 1056u, 7864897u },
  { 378, 393280u, 1056u, 7930433u },
  { 381, 393280u, 1056u, 7995969u },
  { 384, 393280u, 1056u, 8061505u },
  { 387, 458816u, 1056u, 8127041u },
  { 390, 393280u, 1056u, 8192577u },
  { 393, 393280u, 1056u, 8258113u },
  { 396, 393280u, 1056u, 8323649u },
  { 400, 524352u, 1056u, 8389185u },
  { 404, 397376u, 800u, 6357553u },
  { 406, 266304u, 544u, 4260385u },
  { 408, 401472u, 800u, 6423089u },
  { 412, 270400u, 544u, 4325921u },
  { 416, 409664u, 800u, 6554161u },
  { 418, 274496u, 544u, 4391457u },
  { 420, 413760u, 800u, 6619697u },
  { 425, 278592u, 544u, 4456993u },
  { 429, 421952u, 800u, 6750769u },
  { 431, 282688u, 544u, 4522529u },
  { 433, 426048u, 800u, 6816305u },
  { 437, 286784u, 544u, 4588065u },
  { 441, 434240u, 800u, 6947377u },
  { 443, 290880u, 544u, 4653601u },
  { 445, 438336u, 800u, 7012913u },
  { 450, 294976u, 544u, 4719137u },
  { 454, 446528u, 800u, 7143985u },
  { 456, 299072u, 544u, 4784673u },
  { 458, 450624u, 800u, 7209521u },
  { 462, 303168u, 544u, 4850209u },
  { 466, 458816u, 800u, 7340593u },
  { 468, 307264u, 544u, 4915745u },
  { 470, 462912u, 800u, 7406129u },
  { 475, 311360u, 544u, 4981281u },
  { 479, 471104u, 800u, 7537201u },
  { 481, 315456u, 544u, 5046817u },
  { 483, 475200u, 800u, 7602737u },
  { 487, 319552u, 544u, 5112353u },
  { 491, 483392u, 800u, 7733809u },
  { 493, 323648u, 544u, 5177889u },
  { 495, 487488u, 800u, 7799345u },
  { 500, 327744u, 544u, 5243425u },
  { 504, 495680u, 800u, 7930417u },
  { 506, 331840u, 544u, 5308961u },
  { 508, 499776u, 800u, 7995953u },
  { 512, 335936u, 544u, 5374497u },
  { 516, 507968u, 800u, 8127025u },
  { 518, 340032u, 544u, 5440033u },
  { 520, 512064u, 800u, 8192561u },
  { 525, 344128u, 544u, 5505569u },
  { 529, 520256u, 800u, 8323633u },
  { 531, 348224u, 544u, 5571105u },
  { 533, 524352u, 800u, 8389169u },
  { 537, 352320u, 544u, 5636641u },
  { 543, 356416u, 544u, 5702177u },
  { 550, 360512u, 544u, 5767713u },
  { 556, 364608u, 544u, 5833249u },
  { 562, 368704u, 544u, 5898785u },
  { 568, 372800u, 544u, 5964321u },
  { 575, 376896u, 544u, 6029857u },
  { 581, 380992u, 544u, 6095393u },
  { 587, 385088u, 544u, 6160929u },
  { 593, 389184u, 544u, 6226465u },
  { 600, 393280u, 544u, 6291777u },
  { 606, 397376u, 544u, 6357537u },
  { 612, 401472u, 544u, 6423073u },
  { 618, 405568u, 544u, 6488609u },
  { 625, 409664u, 544u, 6554145u },
  { 631, 413760u, 544u, 6619681u },
  { 637, 417856u, 544u, 6685217u },
  { 643, 421952u, 544u, 6750753u },
  { 650, 426048u, 544u, 6816289u },
  { 656, 430144u, 544u, 6881825u },
  { 662, 434240u, 544u, 6947361u },
  { 668, 438336u, 544u, 7012897u },
  { 675, 442432u, 544u, 7078433u },
  { 681, 446528u, 544u, 7143969u },
  { 687, 450624u, 544u, 7209505u },
  { 693, 454720u, 544u, 7275041u },
  { 700, 458816u, 544u, 7340577u },
  { 706, 462912u, 544u, 7406113u },
  { 712, 467008u, 544u, 7471649u },
  { 718, 471104u, 544u, 7537185u },
  { 725, 475200u, 544u, 7602721u },
  { 731, 479296u, 544u, 7668257u },
  { 737, 483392u, 544u, 7733793u },
  { 743, 487488u, 544u, 7799329u },
  { 750, 491584u, 544u, 7864865u },
  { 756, 495680u, 544u, 7930401u },
  { 762, 499776u, 544u, 7995937u },
  { 768, 503872u, 544u, 8061473u },
  { 775, 507968u, 544u, 8127009u },
  { 781, 512064u, 544u, 8192545u },
  { 787, 516160u, 544u, 8258081u },
  { 793, 520256u, 544u, 8323617u },
  { 800, 524352u, 544u, 8389153u },
  { 825, 270400u, 288u, 4325905u },
  { 850, 278592u, 288u, 4456977u },
  { 875, 286784u, 288u, 4588049u },
  { 900, 294976u, 288u, 7078193u },
  { 925, 303168u, 288u, 4850193u },
  { 950, 311360u, 288u, 4981265u },
  { 975, 319552u, 288u, 5112337u },
  { 1000, 327744u, 288u, 5243409u },
  { 1025, 335936u, 288u, 5374481u },
  { 1050, 344128u, 288u, 5505553u },
  { 1075, 352320u, 288u, 5636625u },
  { 1100, 360512u, 288u, 5767697u },
  { 1125, 368704u, 288u, 5898769u },
  { 1150, 376896u, 288u, 6029841u },
  { 1175, 385088u, 288u, 6160913u },
  { 1200, 385088u, 288u, 6291985u },
  { 1300, 385088u, 288u, 6816273u },
  { 1400, 385088u, 288u, 7340561u },
  { 1500, 385088u, 288u, 7864849u },
  { 1600, 385088u, 288u, 8389137u },
  { 1700, 385088u, 288u, 8913425u },
  { 1800, 385088u, 288u, 9437713u },
  { 1900, 385088u, 288u, 9962001u },
  { 2000, 385088u, 288u, 5243153u },
  { 2100, 393248u, 288u, 5505297u },
  { 2200, 393248u, 288u, 5767441u },
  { 2300, 393248u, 288u, 6029585u },
  { 2400, 393248u, 288u, 6291729u },
  { 2500, 409632u, 288u, 6553873u },
  { 2550, 409632u, 288u, 13369873u },
  { 2600, 426016u, 288u, 6816017u },
  { 2625, 426016u, 288u, 13763089u },
  { 2700, 442400u, 288u, 7078161u },
  { 2750, 442400u, 288u, 14418449u },
  { 2800, 458784u, 288u, 7340305u },
  { 2850, 458784u, 288u, 14942737u },
  { 2875, 458784u, 288u, 15073809u },
  { 2900, 458784u, 288u, 7602449u },
  { 3000, 458784u, 288u, 7864593u },
  { 3100, 458784u, 288u, 8126737u },
  { 3200, 458784u, 288u, 8388881u },
  { 3300, 458784u, 288u, 8651025u }
}; // idb
high_pll_out freq_high_pll_1393_0[33] =
{
  { 100u, 15u, 1500u },
  { 125u, 12u, 1500u },
  { 150u, 10u, 1500u },
  { 175u, 12u, 2100u },
  { 200u, 15u, 3000u },
  { 225u, 12u, 2700u },
  { 250u, 12u, 3000u },
  { 275u, 10u, 2750u },
  { 300u, 10u, 3000u },
  { 325u, 8u, 2600u },
  { 350u, 8u, 2800u },
  { 375u, 8u, 3000u },
  { 400u, 7u, 2800u },
  { 425u, 6u, 2550u },
  { 450u, 6u, 2700u },
  { 475u, 6u, 2850u },
  { 500u, 6u, 3000u },
  { 525u, 5u, 2625u },
  { 550u, 5u, 2750u },
  { 575u, 5u, 2870u },
  { 600u, 5u, 3000u },
  { 625u, 4u, 2500u },
  { 650u, 4u, 2600u },
  { 675u, 4u, 2700u },
  { 700u, 4u, 2800u },
  { 725u, 4u, 2900u },
  { 750u, 4u, 3000u },
  { 775u, 4u, 3100u },
  { 800u, 4u, 3200u },
  { 825u, 4u, 3300u },
  { 850u, 3u, 2550u },
  { 875u, 3u, 2625u },
  { 900u, 3u, 2700u }
}; // idb
int g_opencore_vol = 2009; // idb
int g_target_vol = 1812; // idb
unsigned __int8 nibble[16] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u
}; // idb
int ticket_mask = 63; // idb
unsigned int given_id = 2u; // idb
int opt_bitmain_soc_freq = 600; // idb
unsigned int gBM1393_PLL0_DIVIDER_reg = 50595335u; // idb
unsigned __int8 chain_voltage_pic[16] = { 255u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // idb
unsigned __int8 disabledcore_pos_buf[16][16] =
{
  { 255u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
}; // idb
unsigned int gBM1393_MISC_CONTROL_reg = 14849u; // idb
unsigned __int8 g_Clock_delay_control = 2u; // idb
unsigned int PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608u; // idb
unsigned __int8 last_job_buffer[8192] =
{
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
high_pll_out freq_high_pll_1385[38] =
{
  { 10u, 15u, 150u },
  { 20u, 15u, 300u },
  { 25u, 14u, 350u },
  { 50u, 12u, 600u },
  { 75u, 12u, 900u },
  { 100u, 15u, 1500u },
  { 125u, 12u, 1500u },
  { 150u, 10u, 1500u },
  { 175u, 12u, 2100u },
  { 200u, 15u, 3000u },
  { 225u, 12u, 2700u },
  { 250u, 12u, 3000u },
  { 275u, 10u, 2750u },
  { 300u, 10u, 3000u },
  { 325u, 8u, 2600u },
  { 350u, 8u, 2800u },
  { 375u, 8u, 3000u },
  { 400u, 7u, 2800u },
  { 425u, 6u, 2550u },
  { 450u, 6u, 2700u },
  { 475u, 6u, 2850u },
  { 500u, 6u, 3000u },
  { 525u, 5u, 2625u },
  { 550u, 5u, 2750u },
  { 575u, 5u, 2870u },
  { 600u, 5u, 3000u },
  { 625u, 4u, 2500u },
  { 650u, 4u, 2600u },
  { 675u, 4u, 2700u },
  { 700u, 4u, 2800u },
  { 725u, 4u, 2900u },
  { 750u, 4u, 3000u },
  { 775u, 4u, 3100u },
  { 800u, 4u, 3200u },
  { 825u, 4u, 3300u },
  { 850u, 3u, 2550u },
  { 875u, 3u, 2625u },
  { 900u, 3u, 2700u }
}; // idb
unsigned int first_time = 1u; // idb
bool blink_13721 = true; // idb
int opt_log_level = 5; // idb
unsigned int sha256_h0[8] =
{
  1779033703u,
  3144134277u,
  1013904242u,
  2773480762u,
  1359893119u,
  2600822924u,
  528734635u,
  1541459225u
}; // idb
unsigned int sha256_k[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
int (*selective_yield)(void) = (int (*)(void))0x59DA1; // idb
unsigned __int8 bit_swap_table[256] =
{
  0u,
  128u,
  64u,
  192u,
  32u,
  160u,
  96u,
  224u,
  16u,
  144u,
  80u,
  208u,
  48u,
  176u,
  112u,
  240u,
  8u,
  136u,
  72u,
  200u,
  40u,
  168u,
  104u,
  232u,
  24u,
  152u,
  88u,
  216u,
  56u,
  184u,
  120u,
  248u,
  4u,
  132u,
  68u,
  196u,
  36u,
  164u,
  100u,
  228u,
  20u,
  148u,
  84u,
  212u,
  52u,
  180u,
  116u,
  244u,
  12u,
  140u,
  76u,
  204u,
  44u,
  172u,
  108u,
  236u,
  28u,
  156u,
  92u,
  220u,
  60u,
  188u,
  124u,
  252u,
  2u,
  130u,
  66u,
  194u,
  34u,
  162u,
  98u,
  226u,
  18u,
  146u,
  82u,
  210u,
  50u,
  178u,
  114u,
  242u,
  10u,
  138u,
  74u,
  202u,
  42u,
  170u,
  106u,
  234u,
  26u,
  154u,
  90u,
  218u,
  58u,
  186u,
  122u,
  250u,
  6u,
  134u,
  70u,
  198u,
  38u,
  166u,
  102u,
  230u,
  22u,
  150u,
  86u,
  214u,
  54u,
  182u,
  118u,
  246u,
  14u,
  142u,
  78u,
  206u,
  46u,
  174u,
  110u,
  238u,
  30u,
  158u,
  94u,
  222u,
  62u,
  190u,
  126u,
  254u,
  1u,
  129u,
  65u,
  193u,
  33u,
  161u,
  97u,
  225u,
  17u,
  145u,
  81u,
  209u,
  49u,
  177u,
  113u,
  241u,
  9u,
  137u,
  73u,
  201u,
  41u,
  169u,
  105u,
  233u,
  25u,
  153u,
  89u,
  217u,
  57u,
  185u,
  121u,
  249u,
  5u,
  133u,
  69u,
  197u,
  37u,
  165u,
  101u,
  229u,
  21u,
  149u,
  85u,
  213u,
  53u,
  181u,
  117u,
  245u,
  13u,
  141u,
  77u,
  205u,
  45u,
  173u,
  109u,
  237u,
  29u,
  157u,
  93u,
  221u,
  61u,
  189u,
  125u,
  253u,
  3u,
  131u,
  67u,
  195u,
  35u,
  163u,
  99u,
  227u,
  19u,
  147u,
  83u,
  211u,
  51u,
  179u,
  115u,
  243u,
  11u,
  139u,
  75u,
  203u,
  43u,
  171u,
  107u,
  235u,
  27u,
  155u,
  91u,
  219u,
  59u,
  187u,
  123u,
  251u,
  7u,
  135u,
  71u,
  199u,
  39u,
  167u,
  103u,
  231u,
  23u,
  151u,
  87u,
  215u,
  55u,
  183u,
  119u,
  247u,
  15u,
  143u,
  79u,
  207u,
  47u,
  175u,
  111u,
  239u,
  31u,
  159u,
  95u,
  223u,
  63u,
  191u,
  127u,
  255u
}; // idb
$262D70590CF6D71EA9430194459E5D8E proxynames[7] =
{
  { &aHttp_0, 0 },
  { &aHttp0, 1 },
  { &aSocks4, 2 },
  { &aSocks5, 3 },
  { &aSocks4a, 4 },
  { &aSocks5h, 5 },
  { NULL, 0 }
}; // idb
unsigned __int8 *blank_merkle = &a00000000000000; // idb
json_malloc_t do_malloc = &malloc; // idb
json_free_t do_free = &free; // idb
json_t_0 the_null_7359 = { JSON_NULL, 4294967295u }; // idb
json_t_0 the_false_7355 = { JSON_FALSE, 4294967295u }; // idb
json_t_0 the_true_7351 = { JSON_TRUE, 4294967295u }; // idb
_UNKNOWN _TMC_END__; // weak
int stdin; // weak
int stdout; // weak
int stderr; // weak
char completed_8605; // weak
int my_thr_id; // idb
bool bye; // idb
pthread_mutex_t quit_restart_lock; // idb
bool do_a_quit; // idb
bool do_a_restart; // idb
time_t when; // idb
IPACCESS *ipaccess; // idb
int ips; // idb
io_list *io_head; // idb
K_LIST *strbufs; // idb
FILE *g_logwork_file; // idb
FILE *g_logwork_files[65]; // idb
FILE *g_logwork_diffs[65]; // idb
int g_logwork_asicnum; // idb
unsigned __int8 *opt_version_path; // idb
unsigned __int8 *opt_logfile_path; // idb
unsigned __int8 *opt_logfile_openflag; // idb
unsigned __int8 *opt_logwork_path; // idb
unsigned __int8 *opt_logwork_asicnum; // idb
bool opt_logwork_diff; // idb
unsigned __int8 *opt_api_allow; // idb
double g_local_mhashes_dones[12]; // idb
int g_local_mhashes_index; // idb
double g_displayed_rolling; // idb
unsigned __int8 g_miner_version[256]; // idb
unsigned __int8 g_miner_compiletime[256]; // idb
unsigned __int8 g_miner_type[256]; // idb
unsigned __int8 displayed_hash_rate[16]; // idb
unsigned int local_work_last; // idb
int local_work_lasttime; // idb
pool_strategy pool_strategy_0; // idb
uint64_t best_diff; // idb
unsigned __int8 *opt_socks_proxy; // idb
work *staged_work; // idb
unsigned __int8 *cnfbuf; // idb
FILE *fd_log; // idb
unsigned __int8 packagename[256]; // idb
unsigned __int8 *opt_benchfile; // idb
bool opt_benchfile_display; // idb
FILE *benchfile_in; // idb
int benchfile_line; // idb
int benchfile_work; // idb
bool opt_benchmark; // idb
bool work_filled; // idb
bool work_emptied; // idb
bool opt_display_devs; // idb
int most_devices; // idb
bool alt_status; // idb
bool switch_status; // idb
int opt_shares; // idb
bool opt_fix_protocol; // idb
bool no_work; // idb
unsigned __int8 *opt_set_null; // idb
int gwsched_thr_id; // idb
int watchpool_thr_id; // idb
int watchdog_thr_id; // idb
int api_thr_id; // idb
int total_control_threads; // idb
int new_devices; // idb
int new_threads; // idb
pthread_mutex_t *stgd_lock; // idb
pthread_rwlock_t blk_lock; // idb
pthread_mutex_t sshare_lock; // idb
pthread_mutex_t lp_lock; // idb
pthread_cond_t lp_cond; // idb
timeval total_tv_start; // idb
timeval total_tv_end; // idb
timeval restart_tv_start; // idb
timeval update_tv_start; // idb
int staged_rollable; // idb
unsigned int work_block; // idb
pool *currentpool; // idb
int total_urls; // idb
int total_users; // idb
int total_passes; // idb
int total_userpasses; // idb
int total_extranonce; // idb
const bool curses_active; // idb
unsigned __int8 prev_block[12]; // idb
unsigned __int8 current_block[32]; // idb
unsigned __int8 datestamp[40]; // idb
unsigned __int8 blocktime[32]; // idb
unsigned __int8 block_diff[8]; // idb
block *blocks; // idb
stratum_share *stratum_shares; // idb
unsigned __int8 *default_config; // idb
bool config_loaded; // idb
int include_count; // idb
unsigned __int8 *opt_stderr_cmd; // idb
int forkpid; // idb
unsigned int total_work; // idb
unsigned __int8 exit_buf[512]; // idb
pthread_mutex_t sharelog_lock; // idb
FILE *sharelog_file; // idb
unsigned __int8 *temp_cutoff_str; // idb
int fileconf_load; // idb
unsigned __int8 statusline[256]; // idb
int devcursor; // idb
int logstart; // idb
int logcursor; // idb
unsigned __int8 bench_hidiff_bins[16][160]; // idb
unsigned __int8 bench_lodiff_bins[16][160]; // idb
unsigned __int8 bench_target[32]; // idb
unsigned __int8 **initial_args; // idb
JE *jedata; // idb
timeval tv_hashmeter; // idb
time_t hashdisplay_t; // idb
timeval rotate_tv; // idb
bool pools_active; // idb
int cgminer_id_count; // idb
int rotating_pool_13068; // idb
_cgpu_devid_counter *devids_14862; // idb
unsigned __int8 err_buf_12816[200]; // idb
int check_core_register; // idb
bool isUseDefaultFreq; // idb
bool doTestPatten; // idb
bool startCheckNetworkJob; // idb
int last_testpatten_highest_pcb_temp; // idb
bool is218_Temp; // idb
bool chip_hasNoMiddle; // idb
unsigned int *axi_fpga_addr; // idb
unsigned int *fpga_mem_addr; // idb
unsigned int *nonce2_jobid_address; // idb
unsigned int *job_start_address_1; // idb
unsigned int *job_start_address_2; // idb
thr_info *read_temp_id; // idb
thr_info *pic_heart_beat; // idb
bool gBegin_get_nonce; // idb
timeval tv_send_job; // idb
timeval tv_send; // idb
pthread_mutex_t reg_mutex; // idb
pthread_mutex_t nonce_mutex; // idb
pthread_mutex_t iic_mutex; // idb
pthread_mutex_t fpga_mutex; // idb
pthread_mutex_t opencore_readtemp_mutex; // idb
uint64_t h; // idb
unsigned int c_coinbase_padding; // idb
unsigned int c_merkles_num; // idb
unsigned int l_coinbase_padding; // idb
unsigned int l_merkles_num; // idb
int last_temperature; // idb
int temp_highest; // idb
int target_temp; // idb
bool opt_bitmain_fan_ctrl; // idb
int opt_bitmain_fan_pwm; // idb
int FatalErrorValue; // idb
bool opt_fixed_freq; // idb
bool status_error; // idb
bool once_error; // idb
unsigned __int8 freq_one_board[16]; // idb
unsigned __int8 freq_one_board_backup[16]; // idb
double chain_asic_RT[16][108]; // idb
uint64_t rate[16]; // idb
uint64_t nonce_num[16][128][60]; // idb
int nonce_times; // idb
int rate_error[16]; // idb
int lowest_testOK_temp[16]; // idb
int chain_temp_toolow[16]; // idb
unsigned __int8 last_freq[16][256]; // idb
unsigned __int8 badcore_num_buf[16][64]; // idb
int chain_badcore_num[16][256]; // idb
unsigned __int8 show_last_freq[16][256]; // idb
unsigned __int8 chip_last_freq[16][256]; // idb
int x_time[16][256]; // idb
int temp_offside[16]; // idb
bool isChainAllCoresOpened[16]; // idb
pthread_mutex_t reinit_mutex; // idb
uint64_t h_each_chain[16]; // idb
double each_chain_h_avg[16]; // idb
double geach_chain_h_all; // idb
SCAN_FREQ_INFO scanfreq_info; // idb
bool gUsePllList; // idb
FILE *fd_core; // idb
FILE *fd_open; // idb
unsigned int time_num; // idb
init_config config_parameter; // idb
bool global_stop; // idb
int8_t middle_Offset[128]; // idb
int last_record_freq[16][256]; // idb
unsigned int last_nonce3_15410; // idb
unsigned int last_workid_15411; // idb
uint64_t pool_diff_15363; // idb
uint64_t pool_diff_bit_15365; // idb
uint64_t net_diff_15364; // idb
uint64_t net_diff_bit_15366; // idb
int time_15332; // idb
unsigned int loop_15312; // idb
uint64_t pool_send_nu_15141; // idb
int counter_14531[16]; // idb
int current_pll_14334[16]; // idb
int print_num_12771; // idb
bool opt_debug; // idb
bool opt_log_output; // idb
FILE *g_log_file; // idb
bool g_logfile_enable; // idb
unsigned __int8 g_logfile_path[256]; // idb
unsigned __int8 g_logfile_openflag[32]; // idb
bool g_logfile_no_datetime; // idb
bool successful_connect; // idb
volatile uint32_t hashtable_seed; // idb
device_drv modminer_drv; // idb
APIGROUPS apigroups[26]; // idb
device_drv bitforce_drv; // idb
device_drv bitmain_drv; // idb
double total_mhashes_done; // idb
bool use_syslog; // idb
pthread_mutex_t stats_lock; // idb
unsigned int total_ro; // idb
timeval block_timeval; // idb
int swork_id; // idb
thr_info *control_thr; // idb
int64_t total_diff1; // idb
sigaction termhandler; // idb
bool sched_paused; // idb
int total_pools; // idb
pthread_cond_t gws_cond; // idb
bool opt_disable_pool; // idb
pthread_rwlock_t netacc_lock; // idb
double rolling15; // idb
bool opt_protocol; // idb
double new_total_mhashes_done; // idb
pthread_mutex_t hash_lock; // idb
int64_t total_accepted; // idb
double total_diff_stale; // idb
pool **pools; // idb
unsigned int total_go; // idb
list_head scan_devices; // idb
unsigned int local_work; // idb
unsigned __int8 nonce_num60_string[4096]; // idb
int opt_rotate_period; // idb
thr_info **mining_thr; // idb
unsigned __int8 nonce_num30_string[4096]; // idb
int enabled_pools; // idb
double total_diff_accepted; // idb
schedtime schedstop; // idb
thread_q *getq; // idb
bool opt_api_mcast; // idb
bool opt_fail_only; // idb
cgpu_info **devices; // idb
pthread_mutex_t restart_lock; // idb
bool opt_lowmem; // idb
int64_t total_getworks; // idb
pthread_rwlock_t mining_thr_lock; // idb
double total_diff_rejected; // idb
int64_t total_rejected; // idb
pthread_rwlock_t devices_lock; // idb
int total_devices; // idb
pthread_mutex_t console_lock; // idb
bool opt_api_network; // idb
int64_t total_discarded; // idb
bool hotplug_mode; // idb
bool opt_api_listen; // idb
unsigned __int8 nonce_num10_string[4096]; // idb
bool want_per_device_stats; // idb
bool opt_worktime; // idb
pthread_mutex_t update_job_lock; // idb
schedtime schedstart; // idb
int hw_errors; // idb
int g_max_fan; // idb
bool opt_work_update; // idb
int zombie_devs; // idb
unsigned __int8 *cgminer_path; // idb
unsigned int found_blocks; // idb
bool opt_compact; // idb
bool use_curses; // idb
unsigned __int8 *opt_api_groups; // idb
time_t last_getwork; // idb
sigaction inthandler; // idb
cglock_t ch_lock; // idb
cglock_t control_lock; // idb
unsigned __int64 global_hashrate; // idb
time_t total_tv_start_sys; // idb
pthread_cond_t restart_cond; // idb
double total_rolling; // idb
bool opt_realquiet; // idb
time_t total_tv_end_sys; // idb
unsigned int new_blocks; // idb
int g_max_temp; // idb
int opt_suggest_diff; // idb
unsigned __int8 current_hash[68]; // idb
int mining_threads; // idb
unsigned __int8 *opt_kernel_path; // idb
bool opt_quiet; // idb
sigaction abrthandler; // idb
bool have_longpoll; // idb
int64_t total_stale; // idb
double rolling5; // idb
double rolling1; // idb
bool opt_delaynet; // idb
int fpga_version; // idb
thr_info *read_hash_rate; // idb
unsigned __int8 core_hash_clock_delay_control[16][256][256]; // idb
unsigned __int8 DEVICEADDR[16]; // idb
unsigned __int8 clock_delay_control_error_core[16][256][256]; // idb
int fpga_major_version; // idb
int clock_delay_control_error_asic_num[16]; // idb
int asic_core_nonce_num_chain[16][108][208]; // idb
unsigned __int8 clock_delay_control_error_core_num[16][256]; // idb
volatile nonce_buf nonce_read_out; // idb
unsigned __int8 displayed_rate[16][32]; // idb
int fd_fpga_mem; // idb
int fd; // idb
int pcb_version; // idb
unsigned __int8 clock_delay_control_error_asic[16][256]; // idb
thr_info *check_system_work_id; // idb
pthread_t send_id; // idb
int core_hash_clock_control[16][256][256]; // idb
all_parameters *dev; // idb
pthread_t receive_id; // idb
unsigned __int8 FPGA_ID_str[32]; // idb
volatile reg_buf reg_value_buf; // idb
int core_hash_clock_counter[16][256][256]; // idb
thr_info *read_nonce_reg_id; // idb
unsigned int opt_num_long; // idb
unsigned int opt_num_short; // idb
unsigned int opt_count; // idb
unsigned int opt_num_short_arg; // idb
opt_table *opt_table_0; // idb
const unsigned __int8 *opt_argv0; // idb
const unsigned __int8 opt_hidden[1]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00009FB0) --------------------------------------------------------
int init_proc()
{
  return call_gmon_start();
}

//----- (00009FBC) --------------------------------------------------------
void sub_9FBC()
{
  JUMPOUT(0);
}
// 9FC8: control flows out of bounds to 0

//----- (0000A7A0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)&va,
    (void (*)(void))init,
    (void (*)(void))_libc_csu_fini,
    a1,
    &va);
  abort();
}
// A7AC: positive sp value 4 has been found
// A7C2: variable 'v4' is possibly undefined
// 6C728: using guessed type int init();
// 6C76C: using guessed type int _libc_csu_fini();

//----- (0000A7D8) --------------------------------------------------------
int call_gmon_start()
{
  int result; // r0

  if ( &__gmon_start__ )
    return sub_A0D8();
  return result;
}
// A0D8: using guessed type int sub_A0D8(void);

//----- (0000A7F0) --------------------------------------------------------
void *deregister_tm_clones()
{
  return &_TMC_END__;
}

//----- (0000A814) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &_TMC_END__;
  HIDWORD(result) = 0;
  return result;
}

//----- (0000A840) --------------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // r0

  if ( !completed_8605 )
  {
    result = deregister_tm_clones();
    completed_8605 = 1;
  }
  return result;
}
// 8A8BC: using guessed type char completed_8605;

//----- (0000A858) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (0000A878) --------------------------------------------------------
void __cdecl json_decref(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0000A8B0) --------------------------------------------------------
bool sock_blocks()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (0000A8DC) --------------------------------------------------------
void __cdecl mutex_lock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000A95C) --------------------------------------------------------
void __cdecl mutex_unlock_noyield(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000A9DC) --------------------------------------------------------
void __cdecl mutex_unlock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield(lock, file, func, line);
  selective_yield();
}

//----- (0000AA0C) --------------------------------------------------------
void __cdecl wr_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000AA8C) --------------------------------------------------------
void __cdecl rd_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000AB0C) --------------------------------------------------------
void __cdecl rw_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000AB8C) --------------------------------------------------------
void __cdecl wr_unlock_noyield(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock(lock, file, func, line);
}

//----- (0000ABB0) --------------------------------------------------------
void __cdecl rd_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock(lock, file, func, line);
  selective_yield();
}

//----- (0000ABE0) --------------------------------------------------------
void __cdecl mutex_init(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000AC60) --------------------------------------------------------
void __cdecl cg_rlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock(&lock->mutex, file, func, line);
  rd_lock(&lock->rwlock, file, func, line);
  mutex_unlock_noyield(&lock->mutex, file, func, line);
}

//----- (0000ACA4) --------------------------------------------------------
void __cdecl cg_wlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock(&lock->mutex, file, func, line);
  wr_lock(&lock->rwlock, file, func, line);
}

//----- (0000ACD8) --------------------------------------------------------
void __cdecl cg_runlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock(&lock->rwlock, file, func, line);
}

//----- (0000AD00) --------------------------------------------------------
void __cdecl cg_wunlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield(&lock->rwlock, file, func, line);
  mutex_unlock(&lock->mutex, file, func, line);
}

//----- (0000AD34) --------------------------------------------------------
void __cdecl io_reinit(io_data *io_data)
{
  io_data->cur = io_data->ptr;
  *io_data->ptr = 0;
  io_data->close = 0;
}

//----- (0000AD5C) --------------------------------------------------------
io_data *__cdecl io_new(size_t initial, bool socket_buf)
{
  io_list *io_list; // [sp+8h] [bp+8h]
  io_data *io_data; // [sp+Ch] [bp+Ch]

  io_data = (io_data *)cgmalloc(0x10u, "api-btm.c", _func___9918, 723);
  io_data->ptr = (unsigned __int8 *)cgmalloc(initial, "api-btm.c", _func___9918, 724);
  io_data->siz = initial;
  io_data->sock = socket_buf;
  io_reinit(io_data);
  io_list = (io_list *)cgmalloc(0xCu, "api-btm.c", _func___9918, 729);
  io_list->io_data = io_data;
  if ( io_head )
  {
    io_list->next = io_head;
    io_list->prev = io_head->prev;
    io_list->next->prev = io_list;
    io_list->prev->next = io_list;
  }
  else
  {
    io_list->prev = io_list;
    io_list->next = io_list;
    io_head = io_list;
  }
  return io_data;
}

//----- (0000AE3C) --------------------------------------------------------
bool __cdecl io_add(io_data *io_data, unsigned __int8 *buf)
{
  unsigned int tot; // [sp+10h] [bp+8h]
  size_t dif; // [sp+14h] [bp+Ch]
  size_t len; // [sp+18h] [bp+10h]
  unsigned int newa; // [sp+1Ch] [bp+14h]

  len = strlen((const char *)buf);
  dif = io_data->cur - io_data->ptr;
  tot = len + dif + 12;
  if ( io_data->siz < tot )
  {
    newa = io_data->siz + 0x20000;
    if ( newa < tot )
      newa = ((unsigned int)(float)((float)tot / 65536.0) + 2) << 16;
    io_data->ptr = (unsigned __int8 *)cgrealloc(io_data->ptr, newa, "api-btm.c", _func___9927, 766);
    io_data->cur = &io_data->ptr[dif];
    io_data->siz = newa;
  }
  memcpy(io_data->cur, buf, len + 1);
  io_data->cur += len;
  return 1;
}

//----- (0000AF08) --------------------------------------------------------
bool __cdecl io_put(io_data *io_data, unsigned __int8 *buf)
{
  io_reinit(io_data);
  return io_add(io_data, buf);
}

//----- (0000AF2C) --------------------------------------------------------
void __cdecl io_close(io_data *io_data)
{
  io_data->close = 1;
}

//----- (0000AF44) --------------------------------------------------------
void io_free()
{
  io_list *io_next; // [sp+0h] [bp+0h]
  io_list *io_list; // [sp+4h] [bp+4h]

  if ( io_head )
  {
    io_list = io_head;
    do
    {
      io_next = io_list->next;
      free(io_list->io_data->ptr);
      free(io_list->io_data);
      free(io_list);
      io_list = io_next;
    }
    while ( io_next != io_head );
    io_head = 0;
  }
}

//----- (0000AFB0) --------------------------------------------------------
unsigned __int8 *__cdecl escape_string(unsigned __int8 *str, bool isjson)
{
  int v2; // r3
  size_t v4; // r0
  int v5; // r3
  unsigned __int8 *stra; // [sp+4h] [bp+4h]
  unsigned __int8 *buf; // [sp+Ch] [bp+Ch]
  int count; // [sp+10h] [bp+10h]
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]
  unsigned __int8 *ptra; // [sp+14h] [bp+14h]
  unsigned __int8 *ptrb; // [sp+14h] [bp+14h]

  stra = str;
  count = 0;
  for ( ptr = str; *ptr; ++ptr )
  {
    v2 = *ptr;
    if ( v2 == 61 )
      goto LABEL_9;
    if ( *ptr > 0x3Du )
    {
      if ( v2 == 92 )
      {
        ++count;
        continue;
      }
      if ( v2 != 124 )
        continue;
LABEL_9:
      if ( !isjson )
        ++count;
      continue;
    }
    if ( v2 != 34 )
    {
      if ( v2 != 44 )
        continue;
      goto LABEL_9;
    }
    if ( isjson )
      ++count;
  }
  if ( count )
  {
    v4 = strlen((const char *)str);
    buf = (unsigned __int8 *)cgmalloc(v4 + count + 1, "api-btm.c", _func___9957, 842);
    ptra = buf;
    while ( 1 )
    {
      if ( !*stra )
      {
        *ptra = 0;
        return buf;
      }
      v5 = *stra;
      if ( v5 == 61 )
        goto LABEL_26;
      if ( *stra > 0x3Du )
      {
        if ( v5 == 92 )
        {
          *ptra = 92;
          ptrb = ptra + 1;
          *ptrb = *stra;
          ptra = ptrb + 1;
          ++stra;
        }
        else
        {
          if ( v5 != 124 )
            goto LABEL_33;
LABEL_26:
          if ( !isjson )
            *ptra++ = 92;
          *ptra++ = *stra++;
        }
      }
      else if ( v5 == 34 )
      {
        if ( isjson )
          *ptra++ = 92;
        *ptra++ = *stra++;
      }
      else
      {
        if ( v5 == 44 )
          goto LABEL_26;
LABEL_33:
        *ptra++ = *stra++;
      }
    }
  }
  return str;
}

//----- (0000B124) --------------------------------------------------------
api_data *__cdecl api_add_extra(api_data *root, api_data *extra)
{
  api_data *roota; // [sp+4h] [bp+4h]
  api_data *tmp; // [sp+Ch] [bp+Ch]

  roota = root;
  if ( !root )
    return extra;
  if ( extra )
  {
    tmp = extra->prev;
    extra->prev = root->prev;
    root->prev->next = extra;
    tmp->next = root;
    root->prev = tmp;
  }
  return roota;
}

//----- (0000B170) --------------------------------------------------------
api_data *__cdecl api_add_data_full(
        api_data *root,
        unsigned __int8 *name,
        api_data_type type,
        void *data,
        bool copy_data)
{
  size_t v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+14h] BYREF
  api_data *api_data; // [sp+814h] [bp+814h]

  api_data = (api_data *)cgmalloc(0x18u, "api-btm.c", _func___9981, 908);
  api_data->name = (unsigned __int8 *)strdup((const char *)name);
  api_data->type = type;
  if ( root )
  {
    api_data->prev = root->prev;
    root->prev = api_data;
    api_data->next = root;
    api_data->prev->next = api_data;
  }
  else
  {
    root = api_data;
    api_data->prev = api_data;
    root->next = root;
  }
  api_data->data_was_malloc = copy_data;
  if ( !data )
  {
    type = API_CONST;
    api_data->type = API_CONST;
    data = (void *)NULLSTR;
    copy_data = 0;
    api_data->data_was_malloc = 0;
  }
  if ( !copy_data )
  {
    api_data->data = data;
  }
  else
  {
    switch ( type )
    {
      case API_ESCAPE:
      case API_STRING:
      case API_CONST:
        v5 = strlen((const char *)data);
        api_data->data = cgmalloc(v5 + 1, "api-btm.c", _func___9981, 945);
        strcpy((char *)api_data->data, (const char *)data);
        break;
      case API_UINT8:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 950);
        *(_BYTE *)api_data->data = *(_BYTE *)data;
        break;
      case API_INT16:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 955);
        *(_WORD *)api_data->data = *(_WORD *)data;
        break;
      case API_UINT16:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 960);
        *(_WORD *)api_data->data = *(_WORD *)data;
        break;
      case API_INT:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 964);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 968);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT32:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 972);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_HEX32:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 976);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT64:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___9981, 980);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_INT64:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___9981, 984);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_DOUBLE:
      case API_ELAPSED:
      case API_MHS:
      case API_MHTOTAL:
      case API_UTILITY:
      case API_FREQ:
      case API_HS:
      case API_DIFF:
      case API_PERCENT:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___9981, 996);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_BOOL:
        api_data->data = cgmalloc(1u, "api-btm.c", _func___9981, 1000);
        *(_BYTE *)api_data->data = *(_BYTE *)data;
        break;
      case API_TIMEVAL:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___9981, 1004);
        memcpy(api_data->data, data, 8u);
        break;
      case API_TIME:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 1008);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_TEMP:
      case API_VOLTS:
      case API_AVG:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___9981, 1014);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: unknown1 data type %d ignored", type);
          applog(3, tmp42, 0);
        }
        api_data->type = API_STRING;
        api_data->data_was_malloc = 0;
        api_data->data = (void *)UNKNOWN;
        break;
    }
  }
  return root;
}

//----- (0000B698) --------------------------------------------------------
api_data *__cdecl api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ESCAPE, data, copy_data);
}

//----- (0000B6C4) --------------------------------------------------------
api_data *__cdecl api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_STRING, data, copy_data);
}

//----- (0000B6F0) --------------------------------------------------------
api_data *__cdecl api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_CONST, (void *)data, copy_data);
}

//----- (0000B71C) --------------------------------------------------------
api_data *__cdecl api_add_uint8(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT8, data, copy_data);
}

//----- (0000B748) --------------------------------------------------------
api_data *__cdecl api_add_int16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT16, data, copy_data);
}

//----- (0000B774) --------------------------------------------------------
api_data *__cdecl api_add_uint16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT16, data, copy_data);
}

//----- (0000B7A0) --------------------------------------------------------
api_data *__cdecl api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT, data, copy_data);
}

//----- (0000B7CC) --------------------------------------------------------
api_data *__cdecl api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT, data, copy_data);
}

//----- (0000B7F8) --------------------------------------------------------
api_data *__cdecl api_add_uint32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT32, data, copy_data);
}

//----- (0000B824) --------------------------------------------------------
api_data *__cdecl api_add_hex32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_HEX32, data, copy_data);
}

//----- (0000B850) --------------------------------------------------------
api_data *__cdecl api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT64, data, copy_data);
}

//----- (0000B87C) --------------------------------------------------------
api_data *__cdecl api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT64, data, copy_data);
}

//----- (0000B8A8) --------------------------------------------------------
api_data *__cdecl api_add_double(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_DOUBLE, data, copy_data);
}

//----- (0000B8D4) --------------------------------------------------------
api_data *__cdecl api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ELAPSED, data, copy_data);
}

//----- (0000B900) --------------------------------------------------------
api_data *__cdecl api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data)
{
  return api_add_data_full(root, name, API_BOOL, data, copy_data);
}

//----- (0000B92C) --------------------------------------------------------
api_data *__cdecl api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIMEVAL, data, copy_data);
}

//----- (0000B958) --------------------------------------------------------
api_data *__cdecl api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIME, data, copy_data);
}

//----- (0000B984) --------------------------------------------------------
api_data *__cdecl api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHS, data, copy_data);
}

//----- (0000B9B0) --------------------------------------------------------
api_data *__cdecl api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHTOTAL, data, copy_data);
}

//----- (0000B9DC) --------------------------------------------------------
api_data *__cdecl api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TEMP, data, copy_data);
}

//----- (0000BA08) --------------------------------------------------------
api_data *__cdecl api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UTILITY, data, copy_data);
}

//----- (0000BA34) --------------------------------------------------------
api_data *__cdecl api_add_freq(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_FREQ, data, copy_data);
}

//----- (0000BA60) --------------------------------------------------------
api_data *__cdecl api_add_volts(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_VOLTS, data, copy_data);
}

//----- (0000BA8C) --------------------------------------------------------
api_data *__cdecl api_add_hs(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_HS, data, copy_data);
}

//----- (0000BAB8) --------------------------------------------------------
api_data *__cdecl api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_DIFF, data, copy_data);
}

//----- (0000BAE4) --------------------------------------------------------
api_data *__cdecl api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_PERCENT, data, copy_data);
}

//----- (0000BB10) --------------------------------------------------------
api_data *__cdecl api_add_avg(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_AVG, data, copy_data);
}

//----- (0000BB3C) --------------------------------------------------------
void __cdecl add_item_buf(K_ITEM *item, const unsigned __int8 *str)
{
  void **data; // r4
  size_t old_siz; // [sp+1Ch] [bp+14h]
  size_t siz; // [sp+20h] [bp+18h]
  unsigned __int8 *buf; // [sp+24h] [bp+1Ch]

  buf = *(unsigned __int8 **)item->data;
  siz = strlen((const char *)str);
  old_siz = *((_DWORD *)item->data + 1);
  if ( *((_DWORD *)item->data + 2) < old_siz + siz + 1 )
  {
    data = (void **)item->data;
    buf = (unsigned __int8 *)cgrealloc(
                               *data,
                               (size_t)data[2] + siz - (((_WORD)siz + 1) & 0xFFF) + 4097,
                               "api-btm.c",
                               _func___10183,
                               1176);
    *data = buf;
    *((_DWORD *)item->data + 2) += siz - (((_WORD)siz + 1) & 0xFFF) + 4097;
  }
  memcpy(&buf[old_siz], str, siz + 1);
  *((_DWORD *)item->data + 1) += siz;
}

//----- (0000BBFC) --------------------------------------------------------
api_data *__cdecl print_data(io_data *io_data, api_data *root, bool isjson, bool precom)
{
  const unsigned __int8 *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 buf[64]; // [sp+81Ch] [bp+814h] BYREF
  api_data *tmp; // [sp+85Ch] [bp+854h]
  unsigned __int8 *escape; // [sp+860h] [bp+858h]
  unsigned __int8 *original; // [sp+864h] [bp+85Ch]
  K_ITEM *item; // [sp+868h] [bp+860h]
  bool first; // [sp+86Eh] [bp+866h]
  bool done; // [sp+86Fh] [bp+867h]

  first = 1;
  cg_wlock(strbufs->lock, "api-btm.c", _func___10197, 1192);
  item = k_unlink_head(strbufs, "api-btm.c", _func___10197, 1193);
  cg_wunlock(strbufs->lock, "api-btm.c", _func___10197, 1194);
  *((_DWORD *)item->data + 1) = 0;
  if ( precom )
    add_item_buf(item, COMMA);
  if ( isjson )
    add_item_buf(item, "{");
  while ( root )
  {
    if ( !first )
      add_item_buf(item, COMMA);
    else
      first = 0;
    if ( isjson )
      add_item_buf(item, "\"");
    add_item_buf(item, root->name);
    if ( isjson )
      add_item_buf(item, "\"");
    if ( isjson )
      add_item_buf(item, ":");
    else
      add_item_buf(item, "=");
    first = 0;
    done = 0;
    switch ( root->type )
    {
      case API_ESCAPE:
        original = (unsigned __int8 *)root->data;
        escape = escape_string((unsigned __int8 *)root->data, isjson);
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, escape);
        if ( isjson )
          add_item_buf(item, "\"");
        if ( escape != original )
          free(escape);
        done = 1;
        break;
      case API_STRING:
      case API_CONST:
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, (const unsigned __int8 *)root->data);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
      case API_UINT8:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int8 *)root->data);
        break;
      case API_INT16:
        snprintf((char *)buf, 0x40u, "%d", *(__int16 *)root->data);
        break;
      case API_UINT16:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int16 *)root->data);
        break;
      case API_INT:
        snprintf((char *)buf, 0x40u, "%d", *(_DWORD *)root->data);
        break;
      case API_UINT:
      case API_UINT32:
        snprintf((char *)buf, 0x40u, "%u", *(_DWORD *)root->data);
        break;
      case API_HEX32:
        if ( isjson )
          add_item_buf(item, "\"");
        snprintf((char *)buf, 0x40u, "0x%08x", *(_DWORD *)root->data);
        add_item_buf(item, buf);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
      case API_UINT64:
        snprintf((char *)buf, 0x40u, "%llu", *(_QWORD *)root->data);
        break;
      case API_INT64:
        snprintf((char *)buf, 0x40u, "%lld", *(_QWORD *)root->data);
        break;
      case API_DOUBLE:
        snprintf((char *)buf, 0x40u, "%f", *(double *)root->data);
        break;
      case API_ELAPSED:
        snprintf((char *)buf, 0x40u, "%.0f", *(double *)root->data);
        break;
      case API_BOOL:
        if ( *(_BYTE *)root->data )
          v4 = TRUESTR;
        else
          v4 = FALSESTR;
        snprintf((char *)buf, 0x40u, "%s", (const char *)v4);
        break;
      case API_TIMEVAL:
        snprintf((char *)buf, 0x40u, "%ld.%06ld", *(_DWORD *)root->data, *((_DWORD *)root->data + 1));
        break;
      case API_TIME:
        snprintf((char *)buf, 0x40u, "%lu", *(_DWORD *)root->data);
        break;
      case API_MHS:
      case API_UTILITY:
      case API_FREQ:
        snprintf((char *)buf, 0x40u, "%.2f", *(double *)root->data);
        break;
      case API_MHTOTAL:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data);
        break;
      case API_TEMP:
        snprintf((char *)buf, 0x40u, "%.2f", *(float *)root->data);
        break;
      case API_VOLTS:
      case API_AVG:
        snprintf((char *)buf, 0x40u, "%.3f", *(float *)root->data);
        break;
      case API_HS:
        snprintf((char *)buf, 0x40u, "%.15f", *(double *)root->data);
        break;
      case API_DIFF:
        snprintf((char *)buf, 0x40u, "%.8f", *(double *)root->data);
        break;
      case API_PERCENT:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data * 100.0);
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: unknown2 data type %d ignored", root->type);
          applog(3, tmp42, 0);
        }
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, UNKNOWN);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
    }
    if ( !done )
      add_item_buf(item, buf);
    free(root->name);
    if ( root->data_was_malloc )
      free(root->data);
    if ( root->next == root )
    {
      free(root);
      root = 0;
    }
    else
    {
      tmp = root;
      root = root->next;
      root->prev = tmp->prev;
      root->prev->next = root;
      free(tmp);
    }
  }
  if ( isjson )
    add_item_buf(item, "}");
  else
    add_item_buf(item, "|");
  io_add(io_data, *(unsigned __int8 **)item->data);
  cg_wlock(strbufs->lock, "api-btm.c", _func___10197, 1364);
  k_add_head(strbufs, item, "api-btm.c", _func___10197, 1365);
  cg_wunlock(strbufs->lock, "api-btm.c", _func___10197, 1366);
  return 0;
}

//----- (0000C448) --------------------------------------------------------
int numascs()
{
  int i; // [sp+0h] [bp+0h]
  int count; // [sp+4h] [bp+4h]

  count = 0;
  rd_lock(&devices_lock, "api-btm.c", _func___10236, 1380);
  for ( i = 0; i < total_devices; ++i )
  {
    if ( devices[i]->drv->drv_id == DRIVER_bitmain )
      ++count;
    if ( devices[i]->drv->drv_id == DRIVER_bitmain_soc )
      ++count;
  }
  rd_unlock(&devices_lock, "api-btm.c", _func___10236, 1385);
  return count;
}

//----- (0000C4FC) --------------------------------------------------------
int __cdecl ascdevice(int ascid)
{
  int i; // [sp+8h] [bp+8h]
  int count; // [sp+Ch] [bp+Ch]

  count = 0;
  rd_lock(&devices_lock, "api-btm.c", _func___10245, 1394);
  for ( i = 0; ; ++i )
  {
    if ( i >= total_devices )
    {
      rd_unlock(&devices_lock, "api-btm.c", _func___10245, 1402);
      return -1;
    }
    if ( devices[i]->drv->drv_id == DRIVER_bitmain )
      ++count;
    if ( devices[i]->drv->drv_id == DRIVER_bitmain_soc )
      ++count;
    if ( ascid + 1 == count )
      break;
  }
  rd_unlock(&devices_lock, "api-btm.c", _func___10245, 1407);
  return i;
}

//----- (0000C5E4) --------------------------------------------------------
void __cdecl message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson)
{
  code_severity v5; // r3
  const unsigned __int8 *v6; // r2
  api_data *v7; // r0
  int messageida; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  int id; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 severity[2]; // [sp+18h] [bp+18h] BYREF
  unsigned __int8 buf[8192]; // [sp+1Ch] [bp+1Ch] BYREF
  int asc; // [sp+201Ch] [bp+201Ch]
  api_data *root; // [sp+2020h] [bp+2020h]
  int i; // [sp+2024h] [bp+2024h]

  io_dataa = io_data;
  messageida = messageid;
  root = 0;
  if ( isjson )
    io_add(io_dataa, "{\"STATUS\":[");
  for ( i = 0; ; ++i )
  {
    if ( codes[i].severity == SEVERITY_FAIL )
    {
      v7 = api_add_string(root, "STATUS", "F", 0);
      root = api_add_time(v7, "When", &when, 0);
      id = -1;
      root = api_add_int(root, "Code", &id, 0);
      sprintf((char *)buf, "%d", messageida);
      root = api_add_escape(root, "Msg", buf, 0);
      root = api_add_escape(root, "Description", opt_api_description, 0);
      root = print_data(io_dataa, root, isjson, 0);
      if ( isjson )
        io_add(io_dataa, "]");
      return;
    }
    if ( codes[i].code == messageida )
      break;
  }
  v5 = codes[i].severity;
  switch ( v5 )
  {
    case SEVERITY_INFO:
      severity[0] = 73;
      break;
    case SEVERITY_SUCC:
      severity[0] = 83;
      break;
    case SEVERITY_WARN:
      severity[0] = 87;
      break;
    default:
      severity[0] = 69;
      break;
  }
  severity[1] = 0;
  switch ( codes[i].params )
  {
    case PARAM_PGA:
    case PARAM_ASC:
    case PARAM_PID:
    case PARAM_INT:
      sprintf((char *)buf, (const char *)codes[i].description, paramid);
      break;
    case PARAM_ASCMAX:
      asc = numascs();
      sprintf((char *)buf, (const char *)codes[i].description, paramid, asc - 1);
      break;
    case PARAM_PMAX:
      sprintf((char *)buf, (const char *)codes[i].description, total_pools);
      break;
    case PARAM_POOLMAX:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, total_pools - 1);
      break;
    case PARAM_DMAX:
      asc = numascs();
      sprintf((char *)buf, (const char *)codes[i].description, asc);
      break;
    case PARAM_CMD:
      sprintf((char *)buf, (const char *)codes[i].description, JSON_COMMAND);
      break;
    case PARAM_POOL:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, pools[paramid]->rpc_url);
      break;
    case PARAM_STR:
      sprintf((char *)buf, (const char *)codes[i].description, param2);
      break;
    case PARAM_BOTH:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, param2);
      break;
    case PARAM_BOOL:
      if ( paramid )
        v6 = TRUESTR;
      else
        v6 = FALSESTR;
      sprintf((char *)buf, (const char *)codes[i].description, v6);
      break;
    case PARAM_SET:
      sprintf((char *)buf, (const char *)codes[i].description, param2, paramid);
      break;
    default:
      strcpy((char *)buf, (const char *)codes[i].description);
      break;
  }
  root = api_add_string(root, "STATUS", severity, 0);
  root = api_add_time(root, "When", &when, 0);
  root = api_add_int(root, "Code", &messageida, 0);
  root = api_add_escape(root, "Msg", buf, 0);
  root = api_add_escape(root, "Description", opt_api_description, 0);
  root = print_data(io_dataa, root, isjson, 0);
  if ( isjson )
    io_add(io_dataa, "]");
}

//----- (0000CCAC) --------------------------------------------------------
void __cdecl lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 124, 0, 0, isjson);
}

//----- (0000CCD4) --------------------------------------------------------
void __cdecl apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  bool io_open; // [sp+1Bh] [bp+13h]

  message(io_data, 22, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"VERSION\":[";
  else
    v5 = "VERSION,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_string(0, "CGMiner", "2.0.0", 0);
  v7 = api_add_const(v6, "API", APIVERSION, 0);
  v8 = api_add_string(v7, "Miner", g_miner_version, 0);
  v9 = api_add_string(v8, "CompileTime", g_miner_compiletime, 0);
  v10 = api_add_string(v9, "Type", g_miner_type, 0);
  print_data(io_data, v10, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0000CDCC) --------------------------------------------------------
void __cdecl minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int pgacount; // [sp+18h] [bp+10h] BYREF
  int asccount; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  pgacount = 0;
  asccount = numascs();
  message(io_data, 33, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"CONFIG\":[";
  else
    v5 = "CONFIG,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "ASC Count", &asccount, 0);
  root = api_add_int(root, "PGA Count", &pgacount, 0);
  root = api_add_int(root, "Pool Count", &total_pools, 0);
  root = api_add_const(root, "Strategy", strategies_0[pool_strategy_0].s, 0);
  root = api_add_int(root, "Log Interval", &opt_log_interval, 0);
  root = api_add_const(root, "Device Code", DEVICECODE, 0);
  root = api_add_const(root, "OS", OSINFO, 0);
  root = api_add_const(root, "Hotplug", NONE, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0000CF34) --------------------------------------------------------
const unsigned __int8 *__cdecl status2str(alive status)
{
  const unsigned __int8 *v1; // r3

  switch ( status )
  {
    case LIFE_WELL:
      v1 = ALIVE;
      break;
    case LIFE_SICK:
      v1 = SICK;
      break;
    case LIFE_DEAD:
      v1 = DEAD;
      break;
    case LIFE_NOSTART:
      v1 = NOSTART;
      break;
    case LIFE_INIT:
      v1 = INIT;
      break;
    default:
      v1 = UNKNOWN;
      break;
  }
  return v1;
}

//----- (0000CFB0) --------------------------------------------------------
void __cdecl ascstatus(io_data *io_data, int asc, bool isjson, bool precom)
{
  double v4; // d0
  float v5; // s15
  int v6; // r3
  double v7; // d7
  double v8; // d7
  int asca; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  double rejp; // [sp+10h] [bp+10h] BYREF
  double hwp; // [sp+18h] [bp+18h] BYREF
  int last_share_pool; // [sp+20h] [bp+20h] BYREF
  unsigned __int8 mhsname[27]; // [sp+24h] [bp+24h] BYREF
  double mhs; // [sp+40h] [bp+40h] BYREF
  double dev_runtime; // [sp+48h] [bp+48h] BYREF
  float temp; // [sp+54h] [bp+54h] BYREF
  unsigned __int8 *status; // [sp+58h] [bp+58h]
  cgpu_info *cgpu; // [sp+5Ch] [bp+5Ch]
  int dev; // [sp+60h] [bp+60h]
  int numasc; // [sp+64h] [bp+64h]
  api_data *root; // [sp+68h] [bp+68h]
  unsigned __int8 *enabled; // [sp+6Ch] [bp+6Ch]

  io_dataa = io_data;
  asca = asc;
  root = 0;
  numasc = numascs();
  if ( numasc > 0 && asca >= 0 && asca < numasc )
  {
    dev = ascdevice(asca);
    if ( dev >= 0 )
    {
      cgpu = get_devices(dev);
      v5 = cgpu->temp;
      temp = v5;
      cgpu_runtime(cgpu);
      dev_runtime = v4;
      cgpu->utility = (double)cgpu->accepted / v4 * 60.0;
      if ( cgpu->deven == DEV_DISABLED )
        enabled = (unsigned __int8 *)NO;
      else
        enabled = (unsigned __int8 *)YES;
      status = (unsigned __int8 *)status2str(cgpu->status);
      root = api_add_int(root, "ASC", &asca, 0);
      root = api_add_string(root, "Name", cgpu->drv->name, 0);
      root = api_add_int(root, "ID", &cgpu->device_id, 0);
      root = api_add_string(root, "Enabled", enabled, 0);
      root = api_add_string(root, "Status", status, 0);
      root = api_add_temp(root, "Temperature", &temp, 0);
      mhs = cgpu->total_mhashes / dev_runtime;
      root = api_add_mhs(root, "MHS av", &mhs, 0);
      sprintf((char *)mhsname, "MHS %ds", opt_log_interval);
      root = api_add_mhs(root, mhsname, &cgpu->rolling, 0);
      root = api_add_int(root, "Accepted", &cgpu->accepted, 0);
      root = api_add_int(root, "Rejected", &cgpu->rejected, 0);
      root = api_add_int(root, "Hardware Errors", &cgpu->hw_errors, 0);
      root = api_add_utility(root, "Utility", &cgpu->utility, 0);
      if ( cgpu->last_share_pool_time <= 0 )
        v6 = -1;
      else
        v6 = cgpu->last_share_pool;
      last_share_pool = v6;
      root = api_add_int(root, "Last Share Pool", &last_share_pool, 0);
      root = api_add_time(root, "Last Share Time", &cgpu->last_share_pool_time, 0);
      root = api_add_mhtotal(root, "Total MH", &cgpu->total_mhashes, 0);
      root = api_add_int64(root, "Diff1 Work", &cgpu->diff1, 0);
      root = api_add_diff(root, "Difficulty Accepted", &cgpu->diff_accepted, 0);
      root = api_add_diff(root, "Difficulty Rejected", &cgpu->diff_rejected, 0);
      root = api_add_diff(root, "Last Share Difficulty", &cgpu->last_share_diff, 0);
      root = api_add_time(root, "Last Valid Work", &cgpu->last_device_valid_work, 0);
      if ( cgpu->hw_errors + cgpu->diff1 )
        v7 = (double)cgpu->hw_errors / (double)(cgpu->hw_errors + cgpu->diff1);
      else
        v7 = 0.0;
      hwp = v7;
      root = api_add_percent(root, "Device Hardware%", &hwp, 0);
      if ( cgpu->diff1 )
        v8 = cgpu->diff_rejected / (double)cgpu->diff1;
      else
        v8 = 0.0;
      rejp = v8;
      root = api_add_percent(root, "Device Rejected%", &rejp, 0);
      root = api_add_elapsed(root, "Device Elapsed", &dev_runtime, 0);
      print_data(io_dataa, root, isjson, precom);
    }
  }
}
// D018: variable 'v4' is possibly undefined

//----- (0000D384) --------------------------------------------------------
void __cdecl devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int numasc; // [sp+20h] [bp+18h]
  int i; // [sp+24h] [bp+1Ch]
  int devcount; // [sp+28h] [bp+20h]
  bool io_open; // [sp+2Fh] [bp+27h]

  io_open = 0;
  devcount = 0;
  numasc = numascs();
  if ( numasc )
  {
    message(io_data, 9, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVS\":[");
    if ( numasc > 0 )
    {
      for ( i = 0; i < numasc; ++i )
      {
        v5 = isjson && devcount > 0;
        ascstatus(io_data, i, isjson, v5);
        ++devcount;
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}
// D3AE: conditional instruction was optimized away because %numpga.4==0

//----- (0000D450) --------------------------------------------------------
void __cdecl edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int numasc; // [sp+20h] [bp+18h]
  int i; // [sp+24h] [bp+1Ch]
  int devcount; // [sp+28h] [bp+20h]
  bool io_open; // [sp+2Fh] [bp+27h]

  io_open = 0;
  devcount = 0;
  numasc = numascs();
  if ( numasc )
  {
    message(io_data, 9, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVS\":[");
    if ( numasc > 0 )
    {
      for ( i = 0; i < numasc; ++i )
      {
        v5 = isjson && devcount > 0;
        ascstatus(io_data, i, isjson, v5);
        ++devcount;
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}
// D47A: conditional instruction was optimized away because %numpga.4==0

//----- (0000D51C) --------------------------------------------------------
void __cdecl poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool_enable enabled; // r3
  const unsigned __int8 *v6; // r0
  double v7; // d7
  double v8; // d7
  bool v9; // r3
  double stalep; // [sp+18h] [bp+10h] BYREF
  double rejp; // [sp+20h] [bp+18h] BYREF
  unsigned __int8 lasttime[256]; // [sp+28h] [bp+20h] BYREF
  int i; // [sp+128h] [bp+120h] BYREF
  pool *pool; // [sp+12Ch] [bp+124h]
  int second; // [sp+130h] [bp+128h]
  int minute; // [sp+134h] [bp+12Ch]
  int hour; // [sp+138h] [bp+130h]
  int timediff; // [sp+13Ch] [bp+134h]
  unsigned __int8 *lp; // [sp+140h] [bp+138h]
  unsigned __int8 *status; // [sp+144h] [bp+13Ch]
  bool io_open; // [sp+14Bh] [bp+143h]
  api_data *root; // [sp+14Ch] [bp+144h]

  root = 0;
  io_open = 0;
  hour = 0;
  minute = 0;
  second = 0;
  memset(lasttime, 0, sizeof(lasttime));
  timediff = 0;
  if ( total_pools )
  {
    message(io_data, 7, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"POOLS\":[");
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( !pool->removed )
      {
        enabled = pool->enabled;
        if ( enabled == POOL_ENABLED )
        {
          if ( pool->idle )
            status = (unsigned __int8 *)DEAD;
          else
            status = (unsigned __int8 *)ALIVE;
        }
        else if ( enabled )
        {
          if ( enabled == POOL_REJECTING )
            status = (unsigned __int8 *)REJECTING;
          else
            status = (unsigned __int8 *)UNKNOWN;
        }
        else
        {
          status = (unsigned __int8 *)DISABLED;
        }
        if ( pool->hdr_path )
          lp = (unsigned __int8 *)YES;
        else
          lp = (unsigned __int8 *)NO;
        if ( pool->last_share_time > 0 )
        {
          timediff = time(0) - pool->last_share_time;
          if ( timediff < 0 )
            timediff = 0;
          hour = timediff / 3600;
          minute = timediff % 3600 / 60;
          second = timediff % 3600 % 60;
          sprintf((char *)lasttime, "%d:%02d:%02d", timediff / 3600, minute, second);
        }
        else
        {
          strcpy((char *)lasttime, "0");
        }
        root = api_add_int(root, "POOL", &i, 0);
        root = api_add_escape(root, "URL", pool->rpc_url, 0);
        root = api_add_string(root, "Status", status, 0);
        root = api_add_int(root, "Priority", &pool->prio, 0);
        root = api_add_int(root, "Quota", &pool->quota, 0);
        root = api_add_string(root, "Long Poll", lp, 0);
        root = api_add_uint(root, "Getworks", &pool->getwork_requested, 0);
        root = api_add_int64(root, "Accepted", &pool->accepted, 0);
        root = api_add_int64(root, "Rejected", &pool->rejected, 0);
        root = api_add_uint(root, "Discarded", &pool->discarded_work, 0);
        root = api_add_uint(root, "Stale", &pool->stale_shares, 0);
        root = api_add_uint(root, "Get Failures", &pool->getfail_occasions, 0);
        root = api_add_uint(root, "Remote Failures", &pool->remotefail_occasions, 0);
        root = api_add_escape(root, "User", pool->rpc_user, 0);
        root = api_add_string(root, "Last Share Time", lasttime, 0);
        root = api_add_string(root, "Diff", pool->diff, 0);
        root = api_add_int64(root, "Diff1 Shares", &pool->diff1, 0);
        if ( pool->rpc_proxy )
        {
          v6 = proxytype(pool->rpc_proxytype);
          root = api_add_const(root, "Proxy Type", v6, 0);
          root = api_add_escape(root, "Proxy", pool->rpc_proxy, 0);
        }
        else
        {
          root = api_add_const(root, "Proxy Type", BLANK, 0);
          root = api_add_const(root, "Proxy", BLANK, 0);
        }
        root = api_add_diff(root, "Difficulty Accepted", &pool->diff_accepted, 0);
        root = api_add_diff(root, "Difficulty Rejected", &pool->diff_rejected, 0);
        root = api_add_diff(root, "Difficulty Stale", &pool->diff_stale, 0);
        root = api_add_diff(root, "Last Share Difficulty", &pool->last_share_diff, 0);
        root = api_add_bool(root, "Has Stratum", &pool->has_stratum, 0);
        root = api_add_bool(root, "Stratum Active", &pool->stratum_active, 0);
        if ( pool->stratum_active )
          root = api_add_escape(root, "Stratum URL", pool->stratum_url, 0);
        else
          root = api_add_const(root, "Stratum URL", BLANK, 0);
        root = api_add_bool(root, "Has GBT", &pool->has_gbt, 0);
        root = api_add_uint64(root, "Best Share", &pool->best_diff, 1);
        if ( pool->diff_accepted + pool->diff_rejected + pool->diff_stale == 0.0 )
          v7 = 0.0;
        else
          v7 = pool->diff_rejected / (pool->diff_accepted + pool->diff_rejected + pool->diff_stale);
        rejp = v7;
        root = api_add_percent(root, "Pool Rejected%", &rejp, 0);
        if ( pool->diff_accepted + pool->diff_rejected + pool->diff_stale == 0.0 )
          v8 = 0.0;
        else
          v8 = pool->diff_stale / (pool->diff_accepted + pool->diff_rejected + pool->diff_stale);
        stalep = v8;
        root = api_add_percent(root, "Pool Stale%", &stalep, 0);
        v9 = isjson && i > 0;
        root = print_data(io_data, root, isjson, v9);
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (0000DCE0) --------------------------------------------------------
void getAVGhashrate()
{
  ;
}

//----- (0000DD40) --------------------------------------------------------
void __cdecl lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  double v5; // d0
  unsigned __int8 szuser[32]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 szpool[32]; // [sp+38h] [bp+30h] BYREF
  unsigned __int8 szindex[32]; // [sp+58h] [bp+50h] BYREF
  double ghs; // [sp+78h] [bp+70h] BYREF
  pool *pool; // [sp+84h] [bp+7Ch]
  bool io_open; // [sp+8Bh] [bp+83h]
  api_data *root; // [sp+8Ch] [bp+84h]

  root = 0;
  io_open = 0;
  memset(szindex, 0, sizeof(szindex));
  memset(szpool, 0, sizeof(szpool));
  memset(szuser, 0, sizeof(szuser));
  pool = current_pool();
  message(io_data, 7, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"POOLS\":[");
  getAVGhashrate();
  ghs = v5;
  strcpy((char *)szindex, "0");
  root = api_add_string(root, "LCD", szindex, 0);
  root = api_add_string(root, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHSavg", &ghs, 0);
  if ( pool )
  {
    root = api_add_string(root, "pool", pool->rpc_url, 0);
    root = api_add_string(root, "user", pool->rpc_user, 0);
  }
  else
  {
    strcpy((char *)szpool, "no");
    strcpy((char *)szuser, "no");
    root = api_add_string(root, "pool", szpool, 0);
    root = api_add_string(root, "user", szuser, 0);
  }
  root = print_data(io_data, root, isjson, isjson);
  if ( isjson && io_open )
    io_close(io_data);
}
// DE2E: variable 'v5' is possibly undefined

//----- (0000DF6C) --------------------------------------------------------
void __cdecl summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  double v5; // d0
  char *v6; // r3
  double v7; // d7
  double v8; // d7
  api_data *v9; // r0
  double v10; // d7
  double v11; // d7
  double v12; // d7
  double v13; // d7
  double stalep; // [sp+18h] [bp+10h] BYREF
  double prejp; // [sp+20h] [bp+18h] BYREF
  double rejp; // [sp+28h] [bp+20h] BYREF
  double hwp; // [sp+30h] [bp+28h] BYREF
  double work_utility; // [sp+38h] [bp+30h] BYREF
  double ghs; // [sp+40h] [bp+38h] BYREF
  double utility; // [sp+48h] [bp+40h] BYREF
  bool io_open; // [sp+53h] [bp+4Bh]
  api_data *root; // [sp+54h] [bp+4Ch]

  root = 0;
  message(io_data, 11, 0, 0, isjson);
  if ( isjson )
    v6 = ",\"SUMMARY\":[";
  else
    v6 = "SUMMARY,";
  io_open = io_add(io_data, (unsigned __int8 *)v6);
  mutex_lock(&hash_lock, "api-btm.c", _func___10433, 2779);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  if ( total_secs == 0.0 )
    v7 = 1.0;
  else
    v7 = total_secs;
  utility = (double)total_accepted / v7 * 60.0;
  getAVGhashrate();
  ghs = v5;
  if ( total_secs == 0.0 )
    v8 = 1.0;
  else
    v8 = total_secs;
  work_utility = (double)total_diff1 / v8 * 60.0;
  v9 = api_add_elapsed(root, "Elapsed", &total_secs, 1);
  root = api_add_string(v9, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHS av", &ghs, 0);
  root = api_add_uint(root, "Found Blocks", &found_blocks, 1);
  root = api_add_int64(root, "Getworks", &total_getworks, 1);
  root = api_add_int64(root, "Accepted", &total_accepted, 1);
  root = api_add_int64(root, "Rejected", &total_rejected, 1);
  root = api_add_int(root, "Hardware Errors", &hw_errors, 1);
  root = api_add_utility(root, "Utility", &utility, 0);
  root = api_add_int64(root, "Discarded", &total_discarded, 1);
  root = api_add_int64(root, "Stale", &total_stale, 1);
  root = api_add_uint(root, "Get Failures", &total_go, 1);
  root = api_add_uint(root, "Local Work", &local_work, 1);
  root = api_add_uint(root, "Remote Failures", &total_ro, 1);
  root = api_add_uint(root, "Network Blocks", &new_blocks, 1);
  root = api_add_mhtotal(root, "Total MH", &total_mhashes_done, 1);
  root = api_add_utility(root, "Work Utility", &work_utility, 0);
  root = api_add_diff(root, "Difficulty Accepted", &total_diff_accepted, 1);
  root = api_add_diff(root, "Difficulty Rejected", &total_diff_rejected, 1);
  root = api_add_diff(root, "Difficulty Stale", &total_diff_stale, 1);
  root = api_add_uint64(root, "Best Share", &best_diff, 1);
  if ( hw_errors + total_diff1 )
    v10 = (double)hw_errors / (double)(hw_errors + total_diff1);
  else
    v10 = 0.0;
  hwp = v10;
  root = api_add_percent(root, "Device Hardware%", &hwp, 0);
  if ( total_diff1 )
    v11 = total_diff_rejected / (double)total_diff1;
  else
    v11 = 0.0;
  rejp = v11;
  root = api_add_percent(root, "Device Rejected%", &rejp, 0);
  if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
    v12 = 0.0;
  else
    v12 = total_diff_rejected / (total_diff_accepted + total_diff_rejected + total_diff_stale);
  prejp = v12;
  root = api_add_percent(root, "Pool Rejected%", &prejp, 0);
  if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
    v13 = 0.0;
  else
    v13 = total_diff_stale / (total_diff_accepted + total_diff_rejected + total_diff_stale);
  stalep = v13;
  root = api_add_percent(root, "Pool Stale%", &stalep, 0);
  root = api_add_time(root, "Last getwork", &last_getwork, 0);
  mutex_unlock(&hash_lock, "api-btm.c", _func___10433, 2824);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}
// E070: variable 'v5' is possibly undefined

//----- (0000E56C) --------------------------------------------------------
void __cdecl noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  bool io_open; // [sp+1Bh] [bp+13h]

  message(io_data, 16, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"NONCENUM\":[";
  else
    v5 = "NONCENUM,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_string(0, "10min nonce", nonce_num10_string, 0);
  v7 = api_add_string(v6, "30min nonce", nonce_num30_string, 0);
  v8 = api_add_string(v7, "60min nonce", nonce_num60_string, 0);
  print_data(io_data, v8, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0000E62C) --------------------------------------------------------
void __cdecl pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int count; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  count = 0;
  message(io_data, 59, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"PGAS\":[";
  else
    v5 = "PGAS,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "Count", &count, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0000E6B8) --------------------------------------------------------
void __cdecl switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool *pool; // [sp+18h] [bp+10h]
  int id; // [sp+1Ch] [bp+14h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      cg_rlock(&control_lock, "api-btm.c", _func___10466, 2887);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        pool->enabled = POOL_ENABLED;
        cg_runlock(&control_lock, "api-btm.c", _func___10466, 2897);
        switch_pools(pool);
        message(io_data, 27, id, 0, isjson);
      }
      else
      {
        cg_runlock(&control_lock, "api-btm.c", _func___10466, 2890);
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (0000E7D0) --------------------------------------------------------
void __cdecl copyadvanceafter(unsigned __int8 ch, unsigned __int8 **param, unsigned __int8 **buf)
{
  unsigned __int8 *v3; // r2
  unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r3

  while ( **param && ch != **param )
  {
    if ( **param == 92 && (*param)[1] )
      ++*param;
    v3 = *buf;
    v4 = *param;
    *v3 = **param;
    *buf = v3 + 1;
    *param = v4 + 1;
  }
  if ( **param )
    ++*param;
  v5 = *buf;
  *v5 = 0;
  *buf = v5 + 1;
}

//----- (0000E85C) --------------------------------------------------------
bool __cdecl pooldetails(unsigned __int8 *param, unsigned __int8 **url, unsigned __int8 **user, unsigned __int8 **pass)
{
  size_t v4; // r0
  unsigned __int8 *parama; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 *buf; // [sp+10h] [bp+10h] BYREF
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]

  parama = param;
  v4 = strlen((const char *)param);
  buf = (unsigned __int8 *)cgmalloc(v4 + 1, "api-btm.c", _func___10483, 2925);
  ptr = buf;
  *url = buf;
  copyadvanceafter(0x2Cu, &parama, &buf);
  if ( *parama && (*user = buf, copyadvanceafter(0x2Cu, &parama, &buf), *parama) )
  {
    *pass = buf;
    copyadvanceafter(0x2Cu, &parama, &buf);
    return 1;
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (0000E90C) --------------------------------------------------------
void __cdecl addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *pass; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 *user; // [sp+20h] [bp+18h] BYREF
  unsigned __int8 *url; // [sp+24h] [bp+1Ch] BYREF
  pool *pool; // [sp+28h] [bp+20h]
  unsigned __int8 *ptr; // [sp+2Ch] [bp+24h]

  if ( param && *param )
  {
    if ( !pooldetails(param, &url, &user, &pass) )
    {
      ptr = escape_string(param, isjson);
      message(io_data, 53, 0, ptr, isjson);
      if ( ptr != param )
        free(ptr);
      ptr = 0;
    }
    else
    {
      pool = add_pool();
      detect_stratum(pool, url);
      add_pool_details(pool, 1, url, user, pass);
      ptr = escape_string(url, isjson);
      message(io_data, 55, pool->pool_no, ptr, isjson);
      if ( ptr != url )
        free(ptr);
    }
  }
  else
  {
    message(io_data, 52, 0, 0, isjson);
  }
}

//----- (0000E9E4) --------------------------------------------------------
void __cdecl enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int prio; // r4
  pool *pool; // [sp+18h] [bp+10h]
  int id; // [sp+1Ch] [bp+14h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        if ( pool->enabled == POOL_ENABLED )
        {
          message(io_data, 49, id, 0, isjson);
        }
        else
        {
          pool->enabled = POOL_ENABLED;
          prio = pool->prio;
          if ( prio < current_pool()->prio )
            switch_pools(pool);
          message(io_data, 47, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (0000EAC4) --------------------------------------------------------
void __cdecl poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char v5; // [sp+8h] [bp+0h] BYREF
  unsigned int v6; // [sp+Ch] [bp+4h]
  bool isjsona; // [sp+13h] [bp+Bh]
  unsigned __int8 *parama; // [sp+14h] [bp+Ch]
  int ca; // [sp+18h] [bp+10h]
  io_data *io_dataa; // [sp+1Ch] [bp+14h]
  unsigned __int8 *ptr; // [sp+24h] [bp+1Ch]
  int (*p_new_prio)[]; // [sp+28h] [bp+20h]
  int v13; // [sp+2Ch] [bp+24h]
  bool (*p_pools_changed)[]; // [sp+30h] [bp+28h]
  int v15; // [sp+34h] [bp+2Ch]
  int prio; // [sp+38h] [bp+30h]
  int pr; // [sp+3Ch] [bp+34h]
  int i; // [sp+40h] [bp+38h]
  unsigned __int8 *next; // [sp+44h] [bp+3Ch]

  io_dataa = io_data;
  ca = c;
  parama = param;
  isjsona = isjson;
  prio = 0;
  if ( total_pools )
  {
    if ( parama && *parama )
    {
      v15 = total_pools - 1;
      v6 = (unsigned int)total_pools >> 29;
      p_pools_changed = (bool (*)[])&v5;
      v13 = total_pools - 1;
      p_new_prio = (int (*)[])&v5;
      for ( i = 0; i < total_pools; ++i )
        *((_BYTE *)p_pools_changed + i) = 0;
      next = parama;
      while ( next && *next )
      {
        ptr = next;
        next = (unsigned __int8 *)strchr((const char *)next, 44);
        if ( next )
          *next++ = 0;
        i = atoi((const char *)ptr);
        if ( i < 0 || i >= total_pools )
        {
          message(io_dataa, 26, i, 0, isjsona);
          return;
        }
        if ( *((_BYTE *)p_pools_changed + i) )
        {
          message(io_dataa, 74, i, 0, isjsona);
          return;
        }
        *((_BYTE *)p_pools_changed + i) = 1;
        *((_DWORD *)p_new_prio + i) = prio++;
      }
      for ( i = 0; i < total_pools; ++i )
      {
        if ( *((_BYTE *)p_pools_changed + i) )
          pools[i]->prio = *((_DWORD *)p_new_prio + i);
      }
      for ( pr = 0; pr < total_pools; ++pr )
      {
        for ( i = 0; i < total_pools; ++i )
        {
          if ( *((_BYTE *)p_pools_changed + i) != 1 && pools[i]->prio == pr )
          {
            pools[i]->prio = prio++;
            *((_BYTE *)p_pools_changed + i) = 1;
            break;
          }
        }
      }
      if ( current_pool()->prio )
        switch_pools(0);
      message(io_dataa, 73, 0, 0, isjsona);
    }
    else
    {
      message(io_dataa, 25, 0, 0, isjsona);
    }
  }
  else
  {
    message(io_dataa, 8, 0, 0, isjsona);
  }
}

//----- (0000ED6C) --------------------------------------------------------
void __cdecl poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int quota; // [sp+18h] [bp+10h]
  pool *pool; // [sp+1Ch] [bp+14h]
  int id; // [sp+20h] [bp+18h]
  unsigned __int8 *comma; // [sp+24h] [bp+1Ch]
  unsigned __int8 *commaa; // [sp+24h] [bp+1Ch]

  if ( total_pools )
  {
    if ( param && *param )
    {
      comma = (unsigned __int8 *)strchr((const char *)param, 44);
      if ( comma )
      {
        *comma = 0;
        commaa = comma + 1;
        id = atoi((const char *)param);
        if ( id >= 0 && id < total_pools )
        {
          pool = pools[id];
          quota = atoi((const char *)commaa);
          if ( quota >= 0 )
          {
            pool->quota = quota;
            adjust_quota_gcd();
            message(io_data, 122, quota, pool->rpc_url, isjson);
          }
          else
          {
            message(io_data, 121, quota, pool->rpc_url, isjson);
          }
        }
        else
        {
          message(io_data, 26, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 86, 0, param, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (0000EE78) --------------------------------------------------------
void __cdecl disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool *pool; // [sp+18h] [bp+10h]
  int id; // [sp+1Ch] [bp+14h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        if ( pool->enabled )
        {
          if ( enabled_pools > 1 )
          {
            pool->enabled = POOL_DISABLED;
            if ( current_pool() == pool )
              switch_pools(0);
            message(io_data, 48, id, 0, isjson);
          }
          else
          {
            message(io_data, 51, id, 0, isjson);
          }
        }
        else
        {
          message(io_data, 50, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (0000EF74) --------------------------------------------------------
void __cdecl removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *rpc_url; // [sp+18h] [bp+10h]
  pool *pool; // [sp+1Ch] [bp+14h]
  int id; // [sp+20h] [bp+18h]
  bool dofree; // [sp+27h] [bp+1Fh]

  dofree = 0;
  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        if ( total_pools > 1 )
        {
          pool = pools[id];
          if ( current_pool() == pool )
            switch_pools(0);
          if ( current_pool() == pool )
          {
            message(io_data, 67, id, 0, isjson);
          }
          else
          {
            pool->enabled = POOL_DISABLED;
            rpc_url = escape_string(pool->rpc_url, isjson);
            if ( pool->rpc_url != rpc_url )
              dofree = 1;
            remove_pool(pool);
            message(io_data, 68, id, rpc_url, isjson);
            if ( dofree )
              free(rpc_url);
          }
        }
        else
        {
          message(io_data, 66, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (0000F0B0) --------------------------------------------------------
void __cdecl doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"BYE\"");
  else
    io_put(io_data, "BYE");
  bye = 1;
  do_a_quit = 1;
}

//----- (0000F104) --------------------------------------------------------
void __cdecl dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"RESTART\"");
  else
    io_put(io_data, "RESTART");
  bye = 1;
  do_a_restart = 1;
}

//----- (0000F158) --------------------------------------------------------
void __cdecl privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 46, 0, 0, isjson);
}

//----- (0000F180) --------------------------------------------------------
void __cdecl notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int devicea; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  api_data *root; // [sp+10h] [bp+10h]
  unsigned __int8 *reason; // [sp+14h] [bp+14h]

  io_dataa = io_data;
  devicea = device;
  root = 0;
  if ( cgpu->device_last_not_well )
  {
    switch ( cgpu->device_not_well_reason )
    {
      case REASON_THREAD_FAIL_INIT:
        reason = "Thread failed to init";
        break;
      case REASON_THREAD_ZERO_HASH:
        reason = "Thread got zero hashes";
        break;
      case REASON_THREAD_FAIL_QUEUE:
        reason = "Thread failed to queue work";
        break;
      case REASON_DEV_SICK_IDLE_60:
        reason = "Device idle for 60s";
        break;
      case REASON_DEV_DEAD_IDLE_600:
        reason = "Device dead - idle for 600s";
        break;
      case REASON_DEV_NOSTART:
        reason = "Device failed to start";
        break;
      case REASON_DEV_OVER_HEAT:
        reason = "Device over heated";
        break;
      case REASON_DEV_THERMAL_CUTOFF:
        reason = "Device reached thermal cutoff";
        break;
      case REASON_DEV_COMMS_ERROR:
        reason = "Device comms error";
        break;
      default:
        reason = "Unknown reason - code bug";
        break;
    }
  }
  else
  {
    reason = "None";
  }
  root = api_add_int(root, "NOTIFY", &devicea, 0);
  root = api_add_string(root, "Name", cgpu->drv->name, 0);
  root = api_add_int(root, "ID", &cgpu->device_id, 0);
  root = api_add_time(root, "Last Well", &cgpu->device_last_well, 0);
  root = api_add_time(root, "Last Not Well", &cgpu->device_last_not_well, 0);
  root = api_add_string(root, "Reason Not Well", reason, 0);
  root = api_add_int(root, "*Thread Fail Init", &cgpu->thread_fail_init_count, 0);
  root = api_add_int(root, "*Thread Zero Hash", &cgpu->thread_zero_hash_count, 0);
  root = api_add_int(root, "*Thread Fail Queue", &cgpu->thread_fail_queue_count, 0);
  root = api_add_int(root, "*Dev Sick Idle 60s", &cgpu->dev_sick_idle_60_count, 0);
  root = api_add_int(root, "*Dev Dead Idle 600s", &cgpu->dev_dead_idle_600_count, 0);
  root = api_add_int(root, "*Dev Nostart", &cgpu->dev_nostart_count, 0);
  root = api_add_int(root, "*Dev Over Heat", &cgpu->dev_over_heat_count, 0);
  root = api_add_int(root, "*Dev Thermal Cutoff", &cgpu->dev_thermal_cutoff_count, 0);
  root = api_add_int(root, "*Dev Comms Error", &cgpu->dev_comms_error_count, 0);
  root = api_add_int(root, "*Dev Throttle", &cgpu->dev_throttle_count, 0);
  v5 = isjson && devicea > 0;
  print_data(io_dataa, root, isjson, v5);
}

//----- (0000F410) --------------------------------------------------------
void __cdecl notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  cgpu_info *cgpu; // [sp+1Ch] [bp+14h]
  int i; // [sp+20h] [bp+18h]
  bool io_open; // [sp+27h] [bp+1Fh]

  io_open = 0;
  if ( total_devices )
  {
    message(io_data, 60, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"NOTIFY\":[");
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = get_devices(i);
      notifystatus(io_data, i, cgpu, isjson, group);
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}

//----- (0000F4BC) --------------------------------------------------------
void __cdecl devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  const unsigned __int8 *kname; // r3
  unsigned __int8 *name; // r3
  unsigned __int8 *device_path; // r3
  bool v8; // r3
  int i; // [sp+18h] [bp+10h] BYREF
  cgpu_info *cgpu; // [sp+1Ch] [bp+14h]
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  io_open = 0;
  if ( total_devices )
  {
    message(io_data, 69, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVDETAILS\":[");
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = get_devices(i);
      root = api_add_int(root, "DEVDETAILS", &i, 0);
      root = api_add_string(root, "Name", cgpu->drv->name, 0);
      root = api_add_int(root, "ID", &cgpu->device_id, 0);
      root = api_add_string(root, "Driver", cgpu->drv->dname, 0);
      kname = cgpu->kname;
      if ( !kname )
        kname = BLANK;
      root = api_add_const(root, "Kernel", kname, 0);
      name = cgpu->name;
      if ( !name )
        name = (unsigned __int8 *)BLANK;
      root = api_add_const(root, "Model", name, 0);
      device_path = cgpu->device_path;
      if ( !device_path )
        device_path = (unsigned __int8 *)BLANK;
      root = api_add_const(root, "Device Path", device_path, 0);
      v8 = isjson && i > 0;
      root = print_data(io_data, root, isjson, v8);
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}

//----- (0000F660) --------------------------------------------------------
void __cdecl dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *parama; // [sp+Ch] [bp+4h]
  unsigned __int8 filename[4096]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 *ptr; // [sp+1018h] [bp+1010h]
  FILE *fcfg; // [sp+101Ch] [bp+1014h]

  parama = param;
  if ( !param || !*param )
  {
    default_save_file(filename);
    parama = filename;
  }
  fcfg = fopen((const char *)parama, "w");
  if ( fcfg )
  {
    write_config(fcfg);
    fclose(fcfg);
    ptr = escape_string(parama, isjson);
    message(io_data, 44, 0, ptr, isjson);
    if ( ptr != parama )
      free(ptr);
  }
  else
  {
    ptr = escape_string(parama, isjson);
    message(io_data, 43, 0, ptr, isjson);
    if ( ptr != parama )
      free(ptr);
    ptr = 0;
  }
}

//----- (0000F808) --------------------------------------------------------
int __cdecl itemstats(
        io_data *io_data,
        int i,
        unsigned __int8 *id,
        cgminer_stats *stats,
        cgminer_pool_stats *pool_stats,
        api_data *extra,
        cgpu_info *cgpu,
        bool isjson)
{
  double v8; // d0
  bool v9; // r3
  int ia; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  double ghs; // [sp+10h] [bp+10h] BYREF
  api_data *root; // [sp+1Ch] [bp+1Ch]

  io_dataa = io_data;
  ia = i;
  root = 0;
  getAVGhashrate();
  ghs = v8;
  root = api_add_int(0, "STATS", &ia, 0);
  root = api_add_string(root, "ID", id, 0);
  root = api_add_elapsed(root, "Elapsed", &total_secs, 0);
  root = api_add_uint32(root, "Calls", &stats->getwork_calls, 0);
  root = api_add_timeval(root, "Wait", &stats->getwork_wait, 0);
  root = api_add_timeval(root, "Max", &stats->getwork_wait_max, 0);
  root = api_add_timeval(root, "Min", &stats->getwork_wait_min, 0);
  root = api_add_string(root, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHS av", &ghs, 0);
  if ( extra )
    root = api_add_extra(root, extra);
  v9 = isjson && ia > 0;
  print_data(io_dataa, root, isjson, v9);
  return ia + 1;
}
// F822: variable 'v8' is possibly undefined

//----- (0000F948) --------------------------------------------------------
void __cdecl minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  api_data *v5; // r0
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  unsigned __int8 id[20]; // [sp+24h] [bp+14h] BYREF
  cgpu_info *cgpu; // [sp+38h] [bp+28h]
  api_data *root; // [sp+3Ch] [bp+2Ch]
  int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]
  api_data *extra; // [sp+48h] [bp+38h]
  bool io_open; // [sp+4Fh] [bp+3Fh]

  root = 0;
  io_open = 0;
  message(io_data, 70, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"STATS\":[");
  v5 = api_add_string(root, "BMMiner", "2.0.0", 0);
  v6 = api_add_string(v5, "Miner", g_miner_version, 0);
  v7 = api_add_string(v6, "CompileTime", g_miner_compiletime, 0);
  v8 = api_add_string(v7, "Type", g_miner_type, 0);
  root = print_data(io_data, v8, isjson, 0);
  i = 0;
  for ( j = 0; j < total_devices; ++j )
  {
    cgpu = get_devices(j);
    if ( cgpu && cgpu->drv )
    {
      if ( cgpu->drv->get_api_stats )
        extra = cgpu->drv->get_api_stats(cgpu);
      else
        extra = 0;
      sprintf((char *)id, "%s%d", (const char *)cgpu->drv->name, cgpu->device_id);
      i = itemstats(io_data, i, id, &cgpu->cgminer_stats, 0, extra, cgpu, isjson);
    }
  }
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0000FAB0) --------------------------------------------------------
void __cdecl minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 id[20]; // [sp+20h] [bp+10h] BYREF
  cgpu_info *cgpu; // [sp+34h] [bp+24h]
  int j; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]
  api_data *extra; // [sp+40h] [bp+30h]
  bool io_open; // [sp+47h] [bp+37h]

  io_open = 0;
  message(io_data, 70, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"STATS\":[");
  i = 0;
  for ( j = 0; j < total_devices; ++j )
  {
    cgpu = get_devices(j);
    if ( cgpu && cgpu->drv )
    {
      if ( cgpu->drv->get_api_stats )
        extra = cgpu->drv->get_api_stats(cgpu);
      else
        extra = 0;
      sprintf((char *)id, "%s%d", (const char *)cgpu->drv->name, cgpu->device_id);
      i = itemstats(io_data, i, id, &cgpu->cgminer_stats, 0, extra, cgpu, isjson);
    }
  }
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0000FBA0) --------------------------------------------------------
void __cdecl failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 126, 0, param, isjson);
}

//----- (0000FBC8) --------------------------------------------------------
void __cdecl minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  bool io_open; // [sp+1Bh] [bp+13h]
  api_data *root; // [sp+1Ch] [bp+14h]
  api_data *roota; // [sp+1Ch] [bp+14h]

  message(io_data, 78, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"COIN\":[";
  else
    v5 = "COIN,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_const(0, "Hash Method", SHA256STR, 0);
  cg_rlock(&ch_lock, "api-btm.c", _func___10706, 3661);
  v6 = api_add_timeval(root, "Current Block Time", &block_timeval, 1);
  roota = api_add_string(v6, "Current Block Hash", current_hash, 1);
  cg_runlock(&ch_lock, "api-btm.c", _func___10706, 3664);
  v7 = api_add_bool(roota, "LP", &have_longpoll, 0);
  v8 = api_add_diff(v7, "Network Difficulty", &current_diff, 1);
  print_data(io_data, v8, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0000FD00) --------------------------------------------------------
void __cdecl debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  const unsigned __int8 *parama; // [sp+Ch] [bp+4h]
  bool io_open; // [sp+1Bh] [bp+13h]

  parama = param;
  if ( param )
    *param = tolower(*param);
  else
    parama = BLANK;
  switch ( *parama )
  {
    case 'd':
      opt_debug = !opt_debug;
      opt_log_output = opt_debug;
      if ( opt_debug )
        opt_quiet = 0;
      break;
    case 'n':
      opt_log_output = 0;
      opt_debug = 0;
      opt_quiet = 0;
      opt_protocol = 0;
      want_per_device_stats = 0;
      opt_worktime = 0;
      break;
    case 'p':
      want_per_device_stats = !want_per_device_stats;
      opt_log_output = want_per_device_stats;
      break;
    case 'q':
      opt_quiet = !opt_quiet;
      break;
    case 'r':
      opt_protocol = !opt_protocol;
      if ( opt_protocol )
        opt_quiet = 0;
      break;
    case 's':
      opt_realquiet = 1;
      break;
    case 'v':
      opt_log_output = !opt_log_output;
      if ( opt_log_output )
        opt_quiet = 0;
      break;
    case 'w':
      opt_worktime = !opt_worktime;
      break;
    default:
      break;
  }
  message(io_data, 79, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"DEBUG\":[";
  else
    v5 = "DEBUG,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_bool(0, "Silent", &opt_realquiet, 0);
  v7 = api_add_bool(v6, "Quiet", &opt_quiet, 0);
  v8 = api_add_bool(v7, "Verbose", &opt_log_output, 0);
  v9 = api_add_bool(v8, "Debug", &opt_debug, 0);
  v10 = api_add_bool(v9, "RPCProto", &opt_protocol, 0);
  v11 = api_add_bool(v10, "PerDevice", &want_per_device_stats, 0);
  v12 = api_add_bool(v11, "WorkTime", &opt_worktime, 0);
  print_data(io_data, v12, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00010068) --------------------------------------------------------
void __cdecl setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( !strcasecmp((const char *)param, "queue")
    || !strcasecmp((const char *)param, "scantime")
    || !strcasecmp((const char *)param, "expiry") )
  {
    message(io_data, 126, 0, param, isjson);
  }
  message(io_data, 83, 0, param, isjson);
}

//----- (000100DC) --------------------------------------------------------
void __cdecl usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 88, 0, 0, isjson);
}

//----- (00010110) --------------------------------------------------------
void __cdecl dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  char *v6; // r3
  bool dosum; // [sp+19h] [bp+11h]
  bool bs; // [sp+1Ah] [bp+12h]
  bool all; // [sp+1Bh] [bp+13h]
  unsigned __int8 *sum; // [sp+1Ch] [bp+14h]

  if ( param && *param )
  {
    sum = (unsigned __int8 *)strchr((const char *)param, 44);
    if ( sum )
      *sum++ = 0;
    if ( sum && *sum )
    {
      all = 0;
      bs = 0;
      if ( !strcasecmp((const char *)param, "all") )
      {
        all = 1;
      }
      else if ( !strcasecmp((const char *)param, "bestshare") )
      {
        bs = 1;
      }
      if ( !all && !bs )
      {
        message(io_data, 95, 0, param, isjson);
      }
      else
      {
        *sum = tolower(*sum);
        if ( *sum == 116 || *sum == 102 )
        {
          dosum = *sum == 116;
          if ( *sum == 116 )
            print_summary();
          if ( all )
            zero_stats();
          if ( bs )
            zero_bestshare();
          if ( dosum )
          {
            if ( all )
              v5 = "All";
            else
              v5 = "BestShare";
            message(io_data, 96, 0, (unsigned __int8 *)v5, isjson);
          }
          else
          {
            if ( all )
              v6 = "All";
            else
              v6 = "BestShare";
            message(io_data, 97, 0, (unsigned __int8 *)v6, isjson);
          }
        }
        else
        {
          message(io_data, 76, 0, 0, isjson);
        }
      }
    }
    else
    {
      message(io_data, 75, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 94, 0, 0, isjson);
  }
}

//----- (0001029C) --------------------------------------------------------
void __cdecl dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 102, 0, 0, isjson);
}

//----- (000102C4) --------------------------------------------------------
void __cdecl ascdev(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int id; // [sp+1Ch] [bp+14h]
  int numasc; // [sp+20h] [bp+18h]
  bool io_open; // [sp+27h] [bp+1Fh]

  io_open = 0;
  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc )
      {
        message(io_data, 106, id, 0, isjson);
        if ( isjson )
          io_open = io_add(io_data, ",\"ASC\":[");
        ascstatus(io_data, id, isjson, 0);
        if ( isjson && io_open )
          io_close(io_data);
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (0001038C) --------------------------------------------------------
void __cdecl ascenable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  int asc; // [sp+824h] [bp+814h]
  thr_info *thr; // [sp+828h] [bp+818h]
  cgpu_info *cgpu; // [sp+82Ch] [bp+81Ch]
  int dev; // [sp+830h] [bp+820h]
  int id; // [sp+834h] [bp+824h]
  int numasc; // [sp+838h] [bp+828h]
  int i; // [sp+83Ch] [bp+82Ch]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: request to ascenable ascid %d device %d %s%u",
            id,
            dev,
            (const char *)cgpu->drv->name,
            cgpu->device_id);
          applog(7, tmp42, 0);
        }
        if ( cgpu->deven == DEV_DISABLED )
        {
          for ( i = 0; i < mining_threads; ++i )
          {
            thr = get_thread(i);
            asc = thr->cgpu->cgminer_id;
            if ( asc == dev )
            {
              cgpu->deven = DEV_ENABLED;
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "API: Pushing sem post to thread %d", thr->id);
                applog(7, tmp42, 0);
              }
              cgsem_post(&thr->sem, "api-btm.c", _func___10785, 4059);
            }
          }
          message(io_data, 110, id, 0, isjson);
        }
        else
        {
          message(io_data, 108, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (00010604) --------------------------------------------------------
void __cdecl ascdisable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  cgpu_info *cgpu; // [sp+820h] [bp+810h]
  int dev; // [sp+824h] [bp+814h]
  int id; // [sp+828h] [bp+818h]
  int numasc; // [sp+82Ch] [bp+81Ch]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: request to ascdisable ascid %d device %d %s%u",
            id,
            dev,
            (const char *)cgpu->drv->name,
            cgpu->device_id);
          applog(7, tmp42, 0);
        }
        if ( cgpu->deven == DEV_DISABLED )
        {
          message(io_data, 109, id, 0, isjson);
        }
        else
        {
          cgpu->deven = DEV_DISABLED;
          message(io_data, 111, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (000107B0) --------------------------------------------------------
void __cdecl ascidentify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  device_drv *drv; // [sp+1Ch] [bp+14h]
  cgpu_info *cgpu; // [sp+20h] [bp+18h]
  int dev; // [sp+24h] [bp+1Ch]
  int id; // [sp+28h] [bp+20h]
  int numasc; // [sp+2Ch] [bp+24h]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        drv = cgpu->drv;
        if ( drv->identify_device )
        {
          drv->identify_device(cgpu);
          message(io_data, 113, id, 0, isjson);
        }
        else
        {
          message(io_data, 114, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (0001088C) --------------------------------------------------------
void __cdecl asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int count; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  count = numascs();
  message(io_data, 104, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"ASCS\":[";
  else
    v5 = "ASCS,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "Count", &count, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00010920) --------------------------------------------------------
void __cdecl ascset(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 buf[8192]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 *ret; // [sp+2018h] [bp+2010h]
  device_drv *drv; // [sp+201Ch] [bp+2014h]
  cgpu_info *cgpu; // [sp+2020h] [bp+2018h]
  int dev; // [sp+2024h] [bp+201Ch]
  int id; // [sp+2028h] [bp+2020h]
  int numasc; // [sp+202Ch] [bp+2024h]
  unsigned __int8 *set; // [sp+2030h] [bp+2028h]
  unsigned __int8 *opt; // [sp+2034h] [bp+202Ch]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      opt = (unsigned __int8 *)strchr((const char *)param, 44);
      if ( opt )
        *opt++ = 0;
      if ( opt && *opt )
      {
        id = atoi((const char *)param);
        if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
        {
          cgpu = get_devices(dev);
          drv = cgpu->drv;
          set = (unsigned __int8 *)strchr((const char *)opt, 44);
          if ( set )
            *set++ = 0;
          if ( drv->set_device )
          {
            ret = drv->set_device(cgpu, opt, set, buf);
            if ( ret )
            {
              if ( !strcasecmp((const char *)opt, "help") )
                message(io_data, 118, id, ret, isjson);
              else
                message(io_data, 120, id, ret, isjson);
            }
            else
            {
              message(io_data, 119, id, 0, isjson);
            }
          }
          else
          {
            message(io_data, 117, id, 0, isjson);
          }
        }
        else
        {
          message(io_data, 107, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 116, 0, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (00010CB0) --------------------------------------------------------
void __cdecl lcddata(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  double v5; // d0
  char *v6; // r3
  float v7; // s15
  time_t last_device_valid_work; // [sp+1Ch] [bp+14h] BYREF
  time_t last_share_time; // [sp+20h] [bp+18h] BYREF
  float temp; // [sp+24h] [bp+1Ch] BYREF
  double last_share_diff; // [sp+28h] [bp+20h] BYREF
  double ghs; // [sp+30h] [bp+28h] BYREF
  cgpu_info *cgpu; // [sp+3Ch] [bp+34h]
  bool io_open; // [sp+43h] [bp+3Bh]
  pool *pool; // [sp+44h] [bp+3Ch]
  api_data *root; // [sp+48h] [bp+40h]
  int i; // [sp+4Ch] [bp+44h]
  unsigned __int8 *rpc_user; // [sp+50h] [bp+48h]
  unsigned __int8 *rpc_url; // [sp+54h] [bp+4Ch]

  root = 0;
  ghs = 0.0;
  last_share_diff = 0.0;
  temp = 0.0;
  last_share_time = 0;
  last_device_valid_work = 0;
  pool = 0;
  rpc_url = "none";
  rpc_user = (unsigned __int8 *)&unk_6C900;
  message(io_data, 125, 0, 0, isjson);
  if ( isjson )
    v6 = ",\"LCD\":[";
  else
    v6 = "LCD,";
  io_open = io_add(io_data, (unsigned __int8 *)v6);
  mutex_lock(&hash_lock, "api-btm.c", _func___10858, 4265);
  root = api_add_elapsed(root, "Elapsed", &total_secs, 1);
  getAVGhashrate();
  ghs = v5;
  root = api_add_mhs(root, "GHS av", &ghs, 1);
  ghs = rolling5 / 1000.0;
  root = api_add_mhs(root, "GHS 5m", &ghs, 1);
  ghs = total_rolling / 1000.0;
  root = api_add_mhs(root, "GHS 5s", &ghs, 1);
  mutex_unlock(&hash_lock, "api-btm.c", _func___10858, 4277);
  temp = 0.0;
  last_device_valid_work = 0;
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu = get_devices(i);
    if ( !last_device_valid_work || cgpu->last_device_valid_work > last_device_valid_work )
      last_device_valid_work = cgpu->last_device_valid_work;
    if ( temp < cgpu->temp )
    {
      v7 = cgpu->temp;
      temp = v7;
    }
  }
  last_share_time = 0;
  last_share_diff = 0.0;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    if ( !pool->removed && (!last_share_time || pool->last_share_time > last_share_time) )
    {
      last_share_time = pool->last_share_time;
      last_share_diff = pool->last_share_diff;
    }
  }
  pool = current_pool();
  if ( pool )
  {
    rpc_url = pool->rpc_url;
    rpc_user = pool->rpc_user;
  }
  root = api_add_temp(root, "Temperature", &temp, 0);
  root = api_add_diff(root, "Last Share Difficulty", &last_share_diff, 0);
  root = api_add_time(root, "Last Share Time", &last_share_time, 0);
  root = api_add_uint64(root, "Best Share", &best_diff, 1);
  root = api_add_time(root, "Last Valid Work", &last_device_valid_work, 0);
  root = api_add_uint(root, "Found Blocks", &found_blocks, 1);
  root = api_add_escape(root, "Current Pool", rpc_url, 1);
  root = api_add_escape(root, "User", rpc_user, 1);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}
// 10D78: variable 'v5' is possibly undefined

//----- (00011000) --------------------------------------------------------
void __cdecl checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int v5; // r4
  int v6; // r4
  int v7; // r0
  char *v8; // r3
  const unsigned __int8 *v9; // r3
  const unsigned __int8 *v10; // r3
  unsigned __int8 cmdbuf[100]; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+83h] [bp+7Bh]
  api_data *root; // [sp+84h] [bp+7Ch]
  int i; // [sp+88h] [bp+80h]
  bool access; // [sp+8Eh] [bp+86h]
  bool found; // [sp+8Fh] [bp+87h]

  root = 0;
  if ( param && *param )
  {
    found = 0;
    access = 0;
    for ( i = 0; cmds[i].name; ++i )
    {
      if ( !strcmp((const char *)cmds[i].name, (const char *)param) )
      {
        found = 1;
        sprintf((char *)cmdbuf, "|%s|", (const char *)param);
        v5 = toupper(group);
        if ( v5 == toupper(87)
          || (v6 = toupper(group),
              v7 = toupper(65),
              strstr((const char *)apigroups[v6 - v7].commands, (const char *)cmdbuf)) )
        {
          access = 1;
        }
        break;
      }
    }
    message(io_data, 72, 0, 0, isjson);
    if ( isjson )
      v8 = ",\"CHECK\":[";
    else
      v8 = "CHECK,";
    io_open = io_add(io_data, (unsigned __int8 *)v8);
    if ( found )
      v9 = YES;
    else
      v9 = NO;
    root = api_add_const(root, "Exists", v9, 0);
    if ( access )
      v10 = YES;
    else
      v10 = NO;
    root = api_add_const(root, "Access", v10, 0);
    root = print_data(io_data, root, isjson, 0);
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 71, 0, 0, isjson);
  }
}

//----- (000111CC) --------------------------------------------------------
void __cdecl head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin)
{
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]

  if ( *firstjoin )
  {
    if ( isjson )
      io_add(io_data, "{");
    *firstjoin = 0;
  }
  else if ( isjson )
  {
    io_add(io_data, ",");
  }
  ptr = escape_string(cmdptr, isjson);
  if ( isjson )
  {
    io_add(io_data, "\"");
    io_add(io_data, ptr);
    io_add(io_data, "\":[");
  }
  else
  {
    io_add(io_data, "CMD=");
    io_add(io_data, ptr);
    io_add(io_data, "|");
  }
  if ( ptr != cmdptr )
    free(ptr);
}

//----- (00011288) --------------------------------------------------------
void __cdecl tail_join(io_data *io_data, bool isjson)
{
  if ( io_data->close )
  {
    io_add(io_data, "]");
    io_data->close = 0;
  }
  if ( isjson )
  {
    io_add(io_data, ",\"id\":1}");
    io_add(io_data, "]");
  }
}

//----- (000112DC) --------------------------------------------------------
void __cdecl send_result(io_data *io_data, int c, bool isjson)
{
  const char *v3; // r3
  int v4; // r4
  int v5; // r5
  int *v6; // r0
  char *v7; // r0
  fd_set wd; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+9Ch] [bp+94h] BYREF
  timeval timeout; // [sp+89Ch] [bp+894h] BYREF
  int n; // [sp+8A4h] [bp+89Ch]
  int res; // [sp+8A8h] [bp+8A0h]
  fd_set *__arr; // [sp+8ACh] [bp+8A4h]
  int len; // [sp+8B0h] [bp+8A8h]
  unsigned int __i; // [sp+8B4h] [bp+8ACh]
  unsigned __int8 *buf; // [sp+8B8h] [bp+8B0h]
  int tosend; // [sp+8BCh] [bp+8B4h]
  int sendc; // [sp+8C0h] [bp+8B8h]
  int count; // [sp+8C4h] [bp+8BCh]

  buf = io_data->ptr;
  strcpy((char *)buf, (const char *)io_data->ptr);
  if ( io_data->close )
    strcat((char *)buf, "]");
  if ( isjson )
    strcat((char *)buf, ",\"id\":1}");
  len = strlen((const char *)buf);
  tosend = len + 1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( len > 10 )
      v3 = "...";
    else
      v3 = (const char *)BLANK;
    snprintf((char *)tmp42, 0x800u, "API: send reply: (%d) '%.10s%s'", tosend, (const char *)buf, v3);
    applog(7, tmp42, 0);
  }
  sendc = 0;
  count = 0;
  while ( count <= 4 && tosend > 0 )
  {
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    __arr = &wd;
    for ( __i = 0; __i <= 0x1F; ++__i )
      __arr->fds_bits[__i] = 0;
    wd.fds_bits[c / 32] |= 1 << (c % 32);
    res = select(c + 1, 0, &wd, 0, &timeout);
    if ( res <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API: send select failed (%d)", res);
        applog(4, tmp42, 0);
      }
      return;
    }
    n = send(c, buf, tosend, 0);
    ++sendc;
    if ( n >= 0 )
    {
      if ( sendc > 1 )
      {
        if ( n == tosend )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "API: sent all of remaining %d (sendc=%d)", tosend, sendc);
            applog(7, tmp42, 0);
          }
        }
        else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent %d of remaining %d (sendc=%d)", n, tosend, sendc);
          applog(7, tmp42, 0);
        }
      }
      else if ( n == tosend )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent all of %d first go", tosend);
          applog(7, tmp42, 0);
        }
      }
      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "API: sent %d of %d first go", n, tosend);
        applog(7, tmp42, 0);
      }
      tosend -= n;
      buf += n;
      if ( !n )
        ++count;
    }
    else
    {
      ++count;
      if ( !sock_blocks() )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          v4 = len + 1;
          v5 = len + 1 - tosend;
          v6 = _errno_location();
          v7 = strerror(*v6);
          snprintf((char *)tmp42, 0x800u, "API: send (%d:%d) failed: %s", v4, v5, v7);
          applog(4, tmp42, 0);
        }
        return;
      }
    }
  }
}

//----- (000117D8) --------------------------------------------------------
void __cdecl tidyup(void *arg)
{
  mutex_lock(&quit_restart_lock, "api-btm.c", _func___10942, 4555);
  bye = 1;
  if ( *(_DWORD *)arg != -1 )
  {
    shutdown(*(_DWORD *)arg, 2);
    close(*(_DWORD *)arg);
    *(_DWORD *)arg = -1;
  }
  if ( ipaccess )
  {
    free(ipaccess);
    ipaccess = 0;
  }
  io_free();
  mutex_unlock(&quit_restart_lock, "api-btm.c", _func___10942, 4576);
}

//----- (00011890) --------------------------------------------------------
void setup_groups()
{
  unsigned __int8 *v0; // r3
  size_t v1; // r0
  int v2; // r4
  int v3; // r4
  int v4; // r4
  int v5; // r0
  int v6; // r4
  int v7; // r0
  int v8; // r4
  int v9; // r4
  int v10; // r4
  size_t v11; // r0
  int v12; // r0
  int v13; // r4
  int v14; // r4
  size_t v15; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  unsigned __int8 cmdbuf[100]; // [sp+808h] [bp+800h] BYREF
  unsigned __int8 commands[8192]; // [sp+86Ch] [bp+864h] BYREF
  unsigned __int8 group; // [sp+286Fh] [bp+2867h]
  unsigned __int8 *buf; // [sp+2870h] [bp+2868h]
  unsigned __int8 *api_groups; // [sp+2874h] [bp+286Ch]
  int i; // [sp+2878h] [bp+2870h]
  bool did; // [sp+287Eh] [bp+2876h]
  bool addstar; // [sp+287Fh] [bp+2877h]
  unsigned __int8 *cmd; // [sp+2880h] [bp+2878h]
  unsigned __int8 *colon; // [sp+2884h] [bp+287Ch]
  unsigned __int8 *next; // [sp+2888h] [bp+2880h]
  unsigned __int8 *ptr; // [sp+288Ch] [bp+2884h]

  if ( opt_api_groups )
    v0 = opt_api_groups;
  else
    v0 = (unsigned __int8 *)BLANK;
  api_groups = v0;
  v1 = strlen((const char *)v0);
  buf = (unsigned __int8 *)cgmalloc(v1 + 1, "api-btm.c", _func___10958, 4593);
  strcpy((char *)buf, (const char *)api_groups);
  next = buf;
  while ( next && *next )
  {
    ptr = next;
    next = (unsigned __int8 *)strchr((const char *)next, 44);
    if ( next )
      *next++ = 0;
    if ( ptr[1] != 58 )
    {
      colon = (unsigned __int8 *)strchr((const char *)ptr, 58);
      if ( colon )
        *colon = 0;
      snprintf((char *)tmp42, 0x800u, "API invalid group name '%s'", (const char *)ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    group = toupper(*ptr);
    v2 = toupper(group);
    if ( v2 < toupper(65) || (v3 = toupper(group), v3 > toupper(90)) )
    {
      snprintf((char *)tmp42, 0x800u, "API invalid group name '%c'", *ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    v4 = group;
    if ( v4 == toupper(87) )
    {
      v5 = toupper(87);
      snprintf((char *)tmp42, 0x800u, "API group name can't be '%c'", v5);
      applog(3, tmp42, 1);
      quit(1);
    }
    v6 = group;
    if ( v6 == toupper(82) )
    {
      v7 = toupper(82);
      snprintf((char *)tmp42, 0x800u, "API group name can't be '%c'", v7);
      applog(3, tmp42, 1);
      quit(1);
    }
    v8 = toupper(group);
    if ( apigroups[v8 - toupper(65)].commands )
    {
      snprintf((char *)tmp42, 0x800u, "API duplicate group name '%c'", *ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    ptr += 2;
    strcpy((char *)commands, "|");
    cmd = &commands[1];
    addstar = 0;
    while ( ptr && *ptr )
    {
      colon = (unsigned __int8 *)strchr((const char *)ptr, 58);
      if ( colon )
        *colon++ = 0;
      if ( !strcmp((const char *)ptr, "*") )
      {
        addstar = 1;
      }
      else
      {
        did = 0;
        for ( i = 0; cmds[i].name; ++i )
        {
          if ( !strcasecmp((const char *)ptr, (const char *)cmds[i].name) )
          {
            did = 1;
            break;
          }
        }
        if ( !did )
        {
          snprintf((char *)tmp42, 0x800u, "API unknown command '%s' in group '%c'", (const char *)ptr, group);
          applog(3, tmp42, 1);
          quit(1);
        }
        sprintf((char *)cmdbuf, "|%s|", (const char *)cmds[i].name);
        if ( !strstr((const char *)commands, (const char *)cmdbuf) )
        {
          strcpy((char *)cmd, (const char *)cmds[i].name);
          cmd += strlen((const char *)cmds[i].name);
          *cmd++ = SEPARATOR;
          *cmd = 0;
        }
      }
      ptr = colon;
    }
    if ( addstar )
    {
      for ( i = 0; cmds[i].name; ++i )
      {
        if ( !cmds[i].iswritemode )
        {
          sprintf((char *)cmdbuf, "|%s|", (const char *)cmds[i].name);
          if ( !strstr((const char *)commands, (const char *)cmdbuf) )
          {
            strcpy((char *)cmd, (const char *)cmds[i].name);
            cmd += strlen((const char *)cmds[i].name);
            *cmd++ = SEPARATOR;
            *cmd = 0;
          }
        }
      }
    }
    v9 = toupper(group);
    v10 = v9 - toupper(65);
    v11 = strlen((const char *)commands);
    apigroups[v10].commands = (unsigned __int8 *)cgmalloc(v11 + 1, "api-btm.c", _func___10958, 4695);
    ptr = apigroups[v10].commands;
    strcpy((char *)ptr, (const char *)commands);
  }
  strcpy((char *)commands, "|");
  cmd = &commands[1];
  for ( i = 0; cmds[i].name; ++i )
  {
    if ( !cmds[i].iswritemode )
    {
      strcpy((char *)cmd, (const char *)cmds[i].name);
      cmd += strlen((const char *)cmds[i].name);
      *cmd++ = SEPARATOR;
      *cmd = 0;
    }
  }
  v12 = toupper(82);
  v13 = toupper(v12);
  v14 = v13 - toupper(65);
  v15 = strlen((const char *)commands);
  apigroups[v14].commands = (unsigned __int8 *)cgmalloc(v15 + 1, "api-btm.c", _func___10958, 4715);
  ptr = apigroups[v14].commands;
  strcpy((char *)ptr, (const char *)commands);
  free(buf);
}

//----- (000122D0) --------------------------------------------------------
void setup_ipaccess()
{
  size_t v0; // r0
  int v2; // r4
  int v3; // r4
  int v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  unsigned __int8 original[64]; // [sp+80Ch] [bp+804h] BYREF
  unsigned __int8 tmp[64]; // [sp+84Ch] [bp+844h] BYREF
  unsigned __int8 *dot; // [sp+88Ch] [bp+884h]
  unsigned __int8 *slash; // [sp+890h] [bp+888h]
  unsigned __int8 *buf; // [sp+894h] [bp+88Ch]
  unsigned __int8 group; // [sp+89Ah] [bp+892h]
  bool ipv6; // [sp+89Bh] [bp+893h]
  int shift; // [sp+89Ch] [bp+894h]
  int i; // [sp+8A0h] [bp+898h]
  int mask; // [sp+8A4h] [bp+89Ch]
  int ipcount; // [sp+8A8h] [bp+8A0h]
  unsigned __int8 *end; // [sp+8ACh] [bp+8A4h]
  unsigned __int8 *comma; // [sp+8B0h] [bp+8A8h]
  unsigned __int8 *ptr; // [sp+8B4h] [bp+8ACh]

  ipv6 = 0;
  v0 = strlen((const char *)opt_api_allow);
  buf = (unsigned __int8 *)cgmalloc(v0 + 1, "api-btm.c", _func___10996, 4742);
  strcpy((char *)buf, (const char *)opt_api_allow);
  ipcount = 1;
  ptr = buf;
  while ( *ptr )
  {
    if ( *ptr++ == 44 )
      ++ipcount;
  }
  ipaccess = (IPACCESS *)cgcalloc(ipcount, 0x24u, "api-btm.c", _func___10996, 4753);
  ips = 0;
  ptr = buf;
  while ( ptr && *ptr )
  {
    while ( *ptr == 32 || *ptr == 9 )
      ++ptr;
    if ( *ptr == 44 )
    {
      ++ptr;
    }
    else
    {
      comma = (unsigned __int8 *)strchr((const char *)ptr, 44);
      if ( comma )
        *comma++ = 0;
      strncpy((char *)original, (const char *)ptr, 0x40u);
      original[63] = 0;
      group = toupper(82);
      if ( ((*_ctype_b_loc())[*ptr] & 0x400) != 0 && ptr[1] == 58 )
      {
        v2 = toupper(*ptr);
        if ( v2 == toupper(87) || (v3 = toupper(*ptr), apigroups[v3 - toupper(65)].commands) )
          group = toupper(*ptr);
        ptr += 2;
      }
      ipaccess[ips].group = group;
      if ( !strcmp((const char *)ptr, "0/0") )
      {
        for ( i = 0; i <= 15; ++i )
        {
          ipaccess[ips].ip.__u6_addr8[i] = 0;
          ipaccess[ips].mask.__u6_addr8[i] = 0;
        }
LABEL_74:
        ++ips;
        goto popipo;
      }
      end = (unsigned __int8 *)strchr((const char *)ptr, 47);
      if ( !end )
      {
        for ( i = 0; i <= 15; ++i )
          ipaccess[ips].mask.__u6_addr8[i] = -1;
        end = &ptr[strlen((const char *)ptr)];
      }
      slash = end--;
      if ( *ptr == 91 && *end == 93 )
      {
        *ptr++ = 0;
        *end-- = 0;
        ipv6 = 1;
      }
      else
      {
        ipv6 = 0;
      }
      if ( *slash )
      {
        *slash++ = 0;
        mask = atoi((const char *)slash);
        if ( mask <= 0 || (!ipv6 ? (v4 = 96) : (v4 = 0), mask += v4, mask > 128) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "API: ignored address with invalid mask (%d) '%s'",
              mask,
              (const char *)original);
            applog(3, tmp42, 0);
          }
          goto popipo;
        }
        for ( i = 0; i <= 15; ++i )
          ipaccess[ips].mask.__u6_addr8[i] = 0;
        i = 0;
        shift = 7;
        while ( mask-- > 0 )
        {
          ipaccess[ips].mask.__u6_addr8[i] |= 1 << shift;
          if ( shift-- == 0 )
          {
            ++i;
            shift = 7;
          }
        }
      }
      for ( i = 0; i <= 15; ++i )
        ipaccess[ips].ip.__u6_addr8[i] = 0;
      if ( ipv6 )
      {
        if ( inet_pton(10, (const char *)ptr, &ipaccess[ips]) == 1 )
          goto LABEL_71;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: ignored invalid IPv6 address '%s'", (const char *)original);
          applog(3, tmp42, 0);
        }
      }
      else
      {
        dot = (unsigned __int8 *)strchr((const char *)ptr, 46);
        if ( dot )
        {
          dot = (unsigned __int8 *)strchr((const char *)dot + 1, 46);
          if ( dot )
          {
            dot = (unsigned __int8 *)strchr((const char *)dot + 1, 46);
            if ( dot )
              snprintf((char *)tmp, 0x40u, "::ffff:%s", (const char *)ptr);
            else
              snprintf((char *)tmp, 0x40u, "::ffff:%s.0", (const char *)ptr);
          }
          else
          {
            snprintf((char *)tmp, 0x40u, "::ffff:%s.0.0", (const char *)ptr);
          }
        }
        else
        {
          snprintf((char *)tmp, 0x40u, "::ffff:%s.0.0.0", (const char *)ptr);
        }
        if ( inet_pton(10, (const char *)tmp, &ipaccess[ips]) == 1 )
        {
LABEL_71:
          for ( i = 0; i <= 15; ++i )
            ipaccess[ips].ip.__u6_addr8[i] &= ipaccess[ips].mask.__u6_addr8[i];
          goto LABEL_74;
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: ignored invalid IPv4 address '%s' (as %s)",
            (const char *)original,
            (const char *)tmp);
          applog(3, tmp42, 0);
        }
      }
popipo:
      ptr = comma;
    }
  }
  free(buf);
}

//----- (00012ACC) --------------------------------------------------------
void *__cdecl __noreturn quit_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  mutex_lock(&quit_restart_lock, "api-btm.c", _func___11031, 4911);
  mutex_unlock(&quit_restart_lock, "api-btm.c", _func___11031, 4912);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "API: killing cgminer");
    applog(7, tmp42, 0);
  }
  kill_work();
}

//----- (00012BA0) --------------------------------------------------------
void *__cdecl restart_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  mutex_lock(&quit_restart_lock, "api-btm.c", _func___11036, 4925);
  mutex_unlock(&quit_restart_lock, "api-btm.c", _func___11036, 4926);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "API: restarting cgminer");
    applog(7, tmp42, 0);
  }
  app_restart();
  return 0;
}

//----- (00012C70) --------------------------------------------------------
bool __cdecl check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group)
{
  unsigned int v3; // r4
  bool v5; // r3
  in6_addr client_ip; // [sp+24h] [bp+14h] BYREF
  unsigned __int8 tmp[30]; // [sp+34h] [bp+24h] BYREF
  const in6_addr *__a; // [sp+54h] [bp+44h]
  bool match; // [sp+5Bh] [bp+4Bh]
  int j; // [sp+5Ch] [bp+4Ch]
  int i; // [sp+60h] [bp+50h]
  bool addrok; // [sp+67h] [bp+57h]

  addrok = 0;
  *connectaddr = (unsigned __int8 *)cgmalloc(0x2Eu, "api-btm.c", _func___11049, 4944);
  getnameinfo((const struct sockaddr *)cli, 0x80u, (char *)*connectaddr, 0x2Eu, 0, 0, 1u);
  if ( cli->ss_family == 2 )
  {
    sprintf((char *)tmp, "::ffff:%s", (const char *)*connectaddr);
    inet_pton(10, (const char *)tmp, &client_ip);
  }
  else
  {
    inet_pton(10, (const char *)*connectaddr, &client_ip);
  }
  *group = toupper(82);
  if ( opt_api_allow )
  {
    for ( i = 0; i < ips; ++i )
    {
      match = 1;
      for ( j = 0; j <= 15; ++j )
      {
        if ( (unsigned __int8)(ipaccess[i].mask.__u6_addr8[j] & client_ip.__u6_addr8[j]) != ipaccess[i].ip.__u6_addr8[j] )
        {
          match = 0;
          break;
        }
      }
      if ( match )
      {
        addrok = 1;
        *group = ipaccess[i].group;
        return addrok;
      }
    }
  }
  else if ( opt_api_network )
  {
    return 1;
  }
  else
  {
    v5 = 1;
    if ( strcmp((const char *)*connectaddr, (const char *)localaddr) )
    {
      __a = &client_ip;
      if ( client_ip.__u6_addr32[0] )
        return 0;
      if ( __a->__u6_addr32[1] )
        return 0;
      if ( __a->__u6_addr32[2] )
        return 0;
      v3 = __a->__u6_addr32[3];
      if ( v3 != htonl(1u) )
        return 0;
    }
    return v5;
  }
  return addrok;
}
// 12E56: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (00012E68) --------------------------------------------------------
void mcast()
{
  int *v0; // r0
  char *v1; // r0
  int *v2; // r0
  int ai_family; // r3
  int *v4; // r0
  char *v5; // r0
  unsigned int v6; // r1
  __int64 v7; // r2
  int *v8; // r0
  char *v9; // r0
  size_t v10; // r0
  int *v11; // r0
  char *v12; // r0
  const char *v13; // r3
  size_t v14; // r0
  int *v15; // r0
  char *v16; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+4h] BYREF
  ipv6_mreq grp_0; // [sp+814h] [bp+804h] BYREF
  ip_mreq grp; // [sp+828h] [bp+818h] BYREF
  int optval; // [sp+830h] [bp+820h] BYREF
  unsigned __int8 replybuf[1024]; // [sp+834h] [bp+824h] BYREF
  unsigned __int8 buf[1024]; // [sp+C34h] [bp+C24h] BYREF
  unsigned __int8 expect[9]; // [sp+1034h] [bp+1024h] BYREF
  addrinfo *res; // [sp+1040h] [bp+1030h] BYREF
  addrinfo hints; // [sp+1044h] [bp+1034h] BYREF
  unsigned __int8 came_from_port[10]; // [sp+1064h] [bp+1054h] BYREF
  unsigned __int8 port_s[10]; // [sp+1070h] [bp+1060h] BYREF
  unsigned __int8 group; // [sp+107Bh] [bp+106Bh] BYREF
  unsigned __int8 *connectaddr; // [sp+107Ch] [bp+106Ch] BYREF
  socklen_t came_from_siz; // [sp+1080h] [bp+1070h] BYREF
  sockaddr_storage came_from; // [sp+1084h] [bp+1074h] BYREF
  int reply_port; // [sp+1104h] [bp+10F4h]
  bool addrok; // [sp+110Bh] [bp+10FBh]
  unsigned __int8 *expect_code; // [sp+110Ch] [bp+10FCh]
  size_t expect_code_len; // [sp+1110h] [bp+1100h]
  time_t bindstart; // [sp+1114h] [bp+1104h]
  addrinfo *client; // [sp+1118h] [bp+1108h]
  addrinfo *host; // [sp+111Ch] [bp+110Ch]
  int count; // [sp+1120h] [bp+1110h]
  int bound; // [sp+1124h] [bp+1114h]
  ssize_t rep; // [sp+1128h] [bp+1118h]
  int reply_sock; // [sp+112Ch] [bp+111Ch]
  int mcast_sock; // [sp+1130h] [bp+1120h]
  unsigned __int8 *binderror; // [sp+1134h] [bp+1124h]

  mcast_sock = -1;
  reply_sock = -1;
  strcpy((char *)expect, "cgminer-");
  sprintf((char *)port_s, "%d", opt_api_mcast_port);
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  if ( getaddrinfo((const char *)opt_api_mcast_addr, (const char *)port_s, &hints, &res) )
  {
    strcpy((char *)tmp42, "Invalid API Multicast Address");
    applog(3, tmp42, 1);
    quit(1);
  }
  for ( host = res; host; host = host->ai_next )
  {
    mcast_sock = socket(res->ai_family, 2, 0);
    if ( mcast_sock > 0 )
      break;
  }
  if ( mcast_sock == -1 )
  {
    freeaddrinfo(res);
    strcpy((char *)tmp42, "API mcast could not open socket");
    applog(3, tmp42, 1);
    quit(1);
  }
  optval = 1;
  if ( setsockopt(mcast_sock, 1, 2, &optval, 4u) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v0 = _errno_location();
      v1 = strerror(*v0);
      snprintf((char *)tmp42, 0x800u, "API mcast setsockopt SO_REUSEADDR failed (%s)%s", v1, (const char *)MUNAVAILABLE);
      applog(3, tmp42, 0);
    }
    goto die;
  }
  bound = 0;
  bindstart = time(0);
  while ( !bound )
  {
    if ( bind(mcast_sock, host->ai_addr, host->ai_addrlen) >= 0 )
    {
      bound = 1;
    }
    else
    {
      v2 = _errno_location();
      binderror = (unsigned __int8 *)strerror(*v2);
      if ( time(0) - bindstart > 61 )
        break;
      cgsleep_ms(30000);
    }
  }
  if ( !bound )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "API mcast bind to port %d failed (%s)%s",
        opt_api_mcast_port,
        (const char *)binderror,
        (const char *)MUNAVAILABLE);
      applog(3, tmp42, 0);
    }
    goto die;
  }
  ai_family = host->ai_family;
  if ( ai_family != 2 )
  {
    if ( ai_family == 10 )
    {
      v6 = *(_DWORD *)&host->ai_addr->sa_data[10];
      v7 = *(_QWORD *)&host->ai_addr[1].sa_family;
      grp_0.ipv6mr_multiaddr.__u6_addr32[0] = *(_DWORD *)&host->ai_addr->sa_data[6];
      grp_0.ipv6mr_multiaddr.__u6_addr32[1] = v6;
      *(_QWORD *)&grp_0.ipv6mr_multiaddr.__u6_addr32[2] = v7;
      grp_0.ipv6mr_interface = 0;
      if ( setsockopt(mcast_sock, 41, 20, &grp_0, 0x14u) < 0 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          v8 = _errno_location();
          v9 = strerror(*v8);
          snprintf((char *)tmp42, 0x800u, "API mcast join failed (%s)%s", v9, (const char *)MUNAVAILABLE);
          applog(3, tmp42, 0);
        }
        goto die;
      }
    }
LABEL_38:
    freeaddrinfo(res);
    v10 = strlen((const char *)opt_api_mcast_code);
    expect_code_len = v10 + 9;
    expect_code = (unsigned __int8 *)cgmalloc(v10 + 10, "api-btm.c", _func___11104, 5104);
    snprintf((char *)expect_code, expect_code_len + 1, "%s%s-", (const char *)expect, (const char *)opt_api_mcast_code);
    count = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        cgsleep_ms(1000);
        ++count;
        came_from_siz = 128;
        rep = recvfrom(mcast_sock, buf, 0x3FFu, 0, (struct sockaddr *)&came_from, &came_from_siz);
        if ( rep >= 0 )
          break;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          v11 = _errno_location();
          v12 = strerror(*v11);
          snprintf((char *)tmp42, 0x800u, "API mcast failed count=%d (%s) (%d)", count, v12, mcast_sock);
          applog(7, tmp42, 0);
        }
      }
      addrok = check_connect(&came_from, &connectaddr, &group);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        if ( addrok )
          v13 = "Accepted";
        else
          v13 = "Ignored";
        snprintf((char *)tmp42, 0x800u, "API mcast from %s - %s", (const char *)connectaddr, v13);
        applog(7, tmp42, 0);
      }
      if ( addrok )
      {
        buf[rep] = 0;
        if ( rep > 0 && buf[rep - 1] == 10 )
          buf[--rep] = 0;
        getnameinfo((const struct sockaddr *)&came_from, came_from_siz, 0, 0, (char *)came_from_port, 0xAu, 1u);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API mcast request rep=%d (%s) from [%s]:%s",
            rep,
            (const char *)buf,
            (const char *)connectaddr,
            (const char *)came_from_port);
          applog(7, tmp42, 0);
        }
        if ( rep > expect_code_len && !memcmp(buf, expect_code, expect_code_len) )
        {
          reply_port = atoi((const char *)&buf[expect_code_len]);
          if ( reply_port > 0 && reply_port <= 0xFFFF )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "API mcast request OK port %s=%d",
                (const char *)&buf[expect_code_len],
                reply_port);
              applog(7, tmp42, 0);
            }
            if ( getaddrinfo((const char *)connectaddr, (const char *)&buf[expect_code_len], &hints, &res) )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf((char *)tmp42, 0x800u, "Invalid client address %s", (const char *)connectaddr);
                applog(3, tmp42, 0);
              }
            }
            else
            {
              for ( client = res; client; client = client->ai_next )
              {
                reply_sock = socket(res->ai_family, 2, 0);
                if ( mcast_sock > 0 )
                  break;
              }
              if ( reply_sock == -1 )
              {
                freeaddrinfo(res);
                if ( use_syslog || opt_log_output || opt_log_level > 2 )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "API mcast could not open socket to client %s",
                    (const char *)connectaddr);
                  applog(3, tmp42, 0);
                }
              }
              else
              {
                snprintf((char *)replybuf, 0x400u, "cgm-FTW-%d-%s", opt_api_port, (const char *)opt_api_mcast_des);
                v14 = strlen((const char *)replybuf);
                rep = sendto(reply_sock, replybuf, v14 + 1, 0, client->ai_addr, client->ai_addrlen);
                freeaddrinfo(res);
                if ( rep >= 0 )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "API mcast send reply (%s) succeeded (%d) (%d)",
                      (const char *)replybuf,
                      rep,
                      reply_sock);
                    applog(7, tmp42, 0);
                  }
                }
                else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  v15 = _errno_location();
                  v16 = strerror(*v15);
                  snprintf((char *)tmp42, 0x800u, "API mcast send reply failed (%s) (%d)", v16, reply_sock);
                  applog(7, tmp42, 0);
                }
                close(reply_sock);
              }
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "API mcast request ignored - invalid port (%s)",
              (const char *)&buf[expect_code_len]);
            applog(7, tmp42, 0);
          }
        }
        else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "API mcast request was no good");
          applog(7, tmp42, 0);
        }
      }
    }
  }
  memset(&grp, 0, sizeof(grp));
  grp.imr_multiaddr.s_addr = *(_DWORD *)&host->ai_addr->sa_data[2];
  grp.imr_interface.s_addr = 0;
  if ( setsockopt(mcast_sock, 0, 35, &grp, 8u) >= 0 )
    goto LABEL_38;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v4 = _errno_location();
    v5 = strerror(*v4);
    snprintf((char *)tmp42, 0x800u, "API mcast join failed (%s)%s", v5, (const char *)MUNAVAILABLE);
    applog(3, tmp42, 0);
  }
die:
  close(mcast_sock);
}

//----- (00013C0C) --------------------------------------------------------
void *__cdecl mcast_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  RenameThread("APIMcast");
  mcast();
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (00013C50) --------------------------------------------------------
void mcast_init()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  thr_info *thr; // [sp+80Ch] [bp+804h]

  thr = (thr_info *)cgcalloc(1, 0x40u, "api-btm.c", _func___11127, 5221);
  if ( thr_info_create(thr, 0, (void *(*)(void *))mcast_thread, thr) )
  {
    strcpy((char *)tmp42, "API mcast thread create failed");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00013CD4) --------------------------------------------------------
void reCalculateAVG()
{
  new_total_mhashes_done = total_mhashes_done;
  if ( total_secs <= 0.0 )
    new_total_secs = total_secs;
  else
    new_total_secs = total_secs - 1.0;
}

//----- (00013D48) --------------------------------------------------------
void __cdecl api(int api_thr_id)
{
  double v1; // d0
  int v2; // r0
  int *v3; // r0
  char *v4; // r0
  int *v5; // r0
  char *v6; // r0
  int *v7; // r0
  int *v8; // r0
  char *v9; // r0
  int *v10; // r0
  char *v11; // r0
  const char *v12; // r3
  int *v13; // r0
  char *v14; // r0
  int v15; // r0
  size_t v16; // r0
  int v17; // r4
  int v18; // r4
  int v19; // r0
  const char *v20; // r3
  __pthread_unwind_buf_t __cancel_buf; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+130h] [bp+120h] BYREF
  int optval; // [sp+930h] [bp+920h] BYREF
  addrinfo *res; // [sp+934h] [bp+924h] BYREF
  addrinfo hints; // [sp+938h] [bp+928h] BYREF
  bool firstjoin; // [sp+95Bh] [bp+94Bh] BYREF
  json_error_t json_err; // [sp+95Ch] [bp+94Ch] BYREF
  unsigned __int8 group; // [sp+A5Bh] [bp+A4Bh] BYREF
  unsigned __int8 cmdbuf[100]; // [sp+A5Ch] [bp+A4Ch] BYREF
  socklen_t clisiz; // [sp+AC0h] [bp+AB0h] BYREF
  sockaddr_storage cli; // [sp+AC4h] [bp+AB4h] BYREF
  unsigned __int8 port_s[10]; // [sp+B44h] [bp+B34h] BYREF
  unsigned __int8 *connectaddr; // [sp+B50h] [bp+B40h] BYREF
  unsigned __int8 param_buf[8192]; // [sp+B54h] [bp+B44h] BYREF
  unsigned __int8 buf[8192]; // [sp+2B54h] [bp+2B44h] BYREF
  thr_info bye_thr; // [sp+4B54h] [bp+4B44h] BYREF
  json_t_0 *json_val; // [sp+4B94h] [bp+4B84h]
  int n; // [sp+4B98h] [bp+4B88h]
  bool addrok; // [sp+4B9Fh] [bp+4B8Fh]
  int c; // [sp+4BA0h] [bp+4B90h]
  time_t bindstart; // [sp+4BA4h] [bp+4B94h]
  void *__cancel_arg; // [sp+4BACh] [bp+4B9Ch]
  void (*__cancel_routine)(void *); // [sp+4BB0h] [bp+4BA0h]
  io_data *io_data; // [sp+4BB4h] [bp+4BA4h]
  int *apisock; // [sp+4BB8h] [bp+4BA8h]
  __int16 port; // [sp+4BBEh] [bp+4BAEh]
  unsigned __int8 *cmdsbuf; // [sp+4BC0h] [bp+4BB0h]
  unsigned __int8 *cmdptr; // [sp+4BC4h] [bp+4BB4h]
  addrinfo *host; // [sp+4BC8h] [bp+4BB8h]
  int i; // [sp+4BCCh] [bp+4BBCh]
  bool isjoin; // [sp+4BD1h] [bp+4BC1h]
  bool did; // [sp+4BD2h] [bp+4BC2h]
  bool isjson; // [sp+4BD3h] [bp+4BC3h]
  json_t_0 *json_config; // [sp+4BD4h] [bp+4BC4h]
  unsigned __int8 *param; // [sp+4BD8h] [bp+4BC8h]
  unsigned __int8 *cmd; // [sp+4BDCh] [bp+4BCCh]
  unsigned __int8 *binderror; // [sp+4BE0h] [bp+4BD0h]
  int bound; // [sp+4BE4h] [bp+4BD4h]

  port = opt_api_port;
  cmd = 0;
  apisock = (int *)cgmalloc(4u, "api-btm.c", _func___11165, 5265);
  *apisock = -1;
  json_config = 0;
  isjoin = 0;
  if ( !opt_api_listen )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "API not running%s", (const char *)UNAVAILABLE);
      applog(7, tmp42, 0);
    }
    free(apisock);
    return;
  }
  io_data = io_new(0x10000u, 1);
  mutex_init(&quit_restart_lock, "api-btm.c", _func___11165, 5279);
  __cancel_routine = (void (*)(void *))tidyup;
  __cancel_arg = apisock;
  if ( _sigsetjmp((struct __jmp_buf_tag *)&__cancel_buf, 0) )
  {
    __cancel_routine(__cancel_arg);
    _pthread_unwind_next(&__cancel_buf);
  }
  _pthread_register_cancel(&__cancel_buf);
  my_thr_id = api_thr_id;
  setup_groups();
  if ( opt_api_allow )
  {
    setup_ipaccess();
    if ( !ips )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API not running (no valid IPs specified)%s", (const char *)UNAVAILABLE);
        applog(4, tmp42, 0);
      }
LABEL_54:
      free(apisock);
      return;
    }
  }
  cgsleep_ms(1000 * opt_log_interval);
  sprintf((char *)port_s, "%d", port);
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = 1;
  hints.ai_family = 0;
  if ( getaddrinfo((const char *)opt_api_host, (const char *)port_s, &hints, &res) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "API failed to resolve %s", (const char *)opt_api_host);
      applog(3, tmp42, 0);
    }
    goto LABEL_54;
  }
  for ( host = res; host; host = host->ai_next )
  {
    v2 = socket(res->ai_family, 1, 0);
    *apisock = v2;
    if ( *apisock > 0 )
      break;
  }
  if ( *apisock == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v3 = _errno_location();
      v4 = strerror(*v3);
      snprintf((char *)tmp42, 0x800u, "API initialisation failed (%s)%s", v4, (const char *)UNAVAILABLE);
      applog(3, tmp42, 0);
    }
    freeaddrinfo(res);
    free(apisock);
    return;
  }
  optval = 1;
  if ( setsockopt(*apisock, 1, 2, &optval, 4u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v5 = _errno_location();
    v6 = strerror(*v5);
    snprintf((char *)tmp42, 0x800u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v6);
    applog(7, tmp42, 0);
  }
  bound = 0;
  bindstart = time(0);
  while ( !bound )
  {
    if ( bind(*apisock, host->ai_addr, host->ai_addrlen) >= 0 )
    {
      bound = 1;
    }
    else
    {
      v7 = _errno_location();
      binderror = (unsigned __int8 *)strerror(*v7);
      if ( time(0) - bindstart > 61 )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API bind to port %d failed - trying again in 30sec", port);
        applog(4, tmp42, 0);
      }
      cgsleep_ms(30000);
    }
  }
  freeaddrinfo(res);
  if ( !bound )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "API bind to port %d failed (%s)%s",
        port,
        (const char *)binderror,
        (const char *)UNAVAILABLE);
      applog(3, tmp42, 0);
    }
    goto LABEL_54;
  }
  if ( listen(*apisock, 100) >= 0 )
  {
    if ( opt_api_allow )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API running in IP access mode on port %d (%d)", port, *apisock);
        applog(4, tmp42, 0);
      }
    }
    else if ( opt_api_network )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API running in UNRESTRICTED read access mode on port %d (%d)", port, *apisock);
        applog(4, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "API running in local read access mode on port %d (%d)", port, *apisock);
      applog(4, tmp42, 0);
    }
    if ( opt_api_mcast )
      mcast_init();
    strbufs = k_new_list("StrBufs", 0xCu, 2, 0, 0, "api-btm.c", _func___11165, 5391);
    while ( !bye )
    {
      clisiz = 128;
      c = accept(*apisock, (struct sockaddr *)&cli, &clisiz);
      if ( c < 0 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          v10 = _errno_location();
          v11 = strerror(*v10);
          snprintf((char *)tmp42, 0x800u, "API failed (%s)%s (%d)", v11, (const char *)UNAVAILABLE, *apisock);
          applog(3, tmp42, 0);
        }
        break;
      }
      addrok = check_connect(&cli, &connectaddr, &group);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        if ( addrok )
          v12 = "Accepted";
        else
          v12 = "Ignored";
        snprintf((char *)tmp42, 0x800u, "API: connection from %s - %s", (const char *)connectaddr, v12);
        applog(7, tmp42, 0);
      }
      if ( addrok )
      {
        n = recv(c, buf, 0x1FFFu, 0);
        if ( n >= 0 )
          buf[n] = 0;
        else
          buf[0] = 0;
        if ( opt_debug )
        {
          if ( n >= 0 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42, 0x800u, "API: recv command: (%d) '%s'", n, (const char *)buf);
              applog(7, tmp42, 0);
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            v13 = _errno_location();
            v14 = strerror(*v13);
            snprintf((char *)tmp42, 0x800u, "API: recv failed: %s", v14);
            applog(7, tmp42, 0);
          }
        }
        if ( n >= 0 )
        {
          when = time(0);
          io_reinit(io_data);
          did = 0;
          if ( buf[0] == ISJSON )
          {
            isjson = 1;
            param = 0;
            json_config = json_loadb(buf, n, 0, &json_err);
            if ( json_config && json_config->type == JSON_OBJECT )
            {
              json_val = json_object_get(json_config, JSON_COMMAND);
              if ( json_val )
              {
                if ( json_val->type == JSON_STRING )
                {
                  cmd = (unsigned __int8 *)json_string_value(json_val);
                  json_val = json_object_get(json_config, JSON_PARAMETER);
                  if ( json_val && json_val->type == JSON_STRING )
                  {
                    param = (unsigned __int8 *)json_string_value(json_val);
                  }
                  else if ( json_val && json_val->type == JSON_INTEGER )
                  {
                    v15 = json_integer_value(json_val);
                    sprintf((char *)param_buf, "%d", v15);
                    param = param_buf;
                  }
                  else if ( json_val && json_val->type == JSON_REAL )
                  {
                    json_real_value(json_val);
                    sprintf((char *)param_buf, "%f", v1);
                    param = param_buf;
                  }
                }
                else
                {
                  message(io_data, 14, 0, 0, isjson);
                  send_result(io_data, c, isjson);
                  did = 1;
                }
              }
              else
              {
                message(io_data, 24, 0, 0, isjson);
                send_result(io_data, c, isjson);
                did = 1;
              }
            }
            else
            {
              message(io_data, 23, 0, 0, isjson);
              send_result(io_data, c, isjson);
              did = 1;
            }
          }
          else
          {
            isjson = 0;
            param = (unsigned __int8 *)strchr((const char *)buf, SEPARATOR);
            if ( param )
              *param++ = 0;
            cmd = buf;
          }
          if ( !did )
          {
            cmdsbuf = 0;
            if ( strchr((const char *)cmd, 43) )
            {
              isjoin = 1;
              firstjoin = 1;
              v16 = strlen((const char *)cmd);
              cmdsbuf = (unsigned __int8 *)cgmalloc(v16 + 3, "api-btm.c", _func___11165, 5500);
              strcpy((char *)cmdsbuf, "|");
              param = 0;
            }
            else
            {
              isjoin = 0;
              firstjoin = 0;
            }
            cmdptr = cmd;
            do
            {
              did = 0;
              if ( !isjoin )
                goto LABEL_137;
              cmd = (unsigned __int8 *)strchr((const char *)cmdptr, 43);
              if ( cmd )
                *cmd++ = 0;
              if ( *cmdptr )
              {
LABEL_137:
                for ( i = 0; cmds[i].name; ++i )
                {
                  if ( !strcmp((const char *)cmdptr, (const char *)cmds[i].name) )
                  {
                    sprintf((char *)cmdbuf, "|%s|", (const char *)cmdptr);
                    if ( !isjoin )
                      goto LABEL_144;
                    if ( strstr((const char *)cmdsbuf, (const char *)cmdbuf) )
                    {
                      did = 1;
                      break;
                    }
                    strcat((char *)cmdsbuf, (const char *)cmdptr);
                    strcat((char *)cmdsbuf, "|");
                    head_join(io_data, cmdptr, isjson, &firstjoin);
                    if ( !cmds[i].joinable )
                    {
                      message(io_data, 45, 0, cmds[i].name, isjson);
                      did = 1;
                      tail_join(io_data, isjson);
                    }
                    else
                    {
LABEL_144:
                      v17 = toupper(group);
                      if ( v17 == toupper(87)
                        || (v18 = toupper(group),
                            v19 = toupper(65),
                            strstr((const char *)apigroups[v18 - v19].commands, (const char *)cmdbuf)) )
                      {
                        cmds[i].func(io_data, c, param, isjson, group);
                      }
                      else
                      {
                        message(io_data, 45, 0, cmds[i].name, isjson);
                        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                        {
                          snprintf(
                            (char *)tmp42,
                            0x800u,
                            "API: access denied to '%s' for '%s' command",
                            (const char *)connectaddr,
                            (const char *)cmds[i].name);
                          applog(7, tmp42, 0);
                        }
                      }
                      did = 1;
                      if ( !isjoin )
                        send_result(io_data, c, isjson);
                      else
                        tail_join(io_data, isjson);
                    }
                    break;
                  }
                }
                if ( !did )
                {
                  if ( isjoin )
                    head_join(io_data, cmdptr, isjson, &firstjoin);
                  message(io_data, 14, 0, 0, isjson);
                  if ( isjoin )
                    tail_join(io_data, isjson);
                  else
                    send_result(io_data, c, isjson);
                }
              }
              if ( isjoin )
                cmdptr = cmd;
            }
            while ( isjoin && cmdptr );
          }
          if ( isjoin )
            send_result(io_data, c, isjson);
          if ( isjson && json_config && json_config->type == JSON_OBJECT )
            json_decref(json_config);
        }
      }
      close(c);
    }
    _pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
    free(apisock);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      if ( do_a_quit )
      {
        v20 = "QUIT";
      }
      else if ( do_a_restart )
      {
        v20 = "RESTART";
      }
      else if ( bye )
      {
        v20 = "BYE";
      }
      else
      {
        v20 = "UNKNOWN!";
      }
      snprintf((char *)tmp42, 0x800u, "API: terminating due to: %s", v20);
      applog(7, tmp42, 0);
    }
    mutex_lock(&quit_restart_lock, "api-btm.c", _func___11165, 5599);
    if ( do_a_restart )
    {
      if ( thr_info_create(&bye_thr, 0, (void *(*)(void *))restart_thread, &bye_thr) )
      {
        mutex_unlock(&quit_restart_lock, "api-btm.c", _func___11165, 5605);
        strcpy((char *)tmp42, "API failed to initiate a restart - aborting");
        applog(3, tmp42, 1);
        quit(1);
      }
    }
    else
    {
      if ( !do_a_quit )
      {
LABEL_195:
        mutex_unlock(&quit_restart_lock, "api-btm.c", _func___11165, 5620);
        return;
      }
      if ( thr_info_create(&bye_thr, 0, (void *(*)(void *))quit_thread, &bye_thr) )
      {
        mutex_unlock(&quit_restart_lock, "api-btm.c", _func___11165, 5614);
        strcpy((char *)tmp42, "API failed to initiate a clean quit - aborting");
        applog(3, tmp42, 1);
        quit(1);
      }
    }
    pthread_detach(bye_thr.pth);
    goto LABEL_195;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v8 = _errno_location();
    v9 = strerror(*v8);
    snprintf((char *)tmp42, 0x800u, "API3 initialisation failed (%s)%s", v9, (const char *)UNAVAILABLE);
    applog(3, tmp42, 0);
  }
  close(*apisock);
  free(apisock);
}
// 14D2C: variable 'v1' is possibly undefined

//----- (00015680) --------------------------------------------------------
void __cdecl json_decref_0(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (000156B8) --------------------------------------------------------
void __cdecl _list_del(list_head *prev, list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

//----- (000156D8) --------------------------------------------------------
void __cdecl list_del(list_head *entry)
{
  _list_del(entry->prev, entry->next);
  entry->next = 0;
  entry->prev = 0;
}

//----- (00015704) --------------------------------------------------------
unsigned int __cdecl swab32(unsigned int v)
{
  return bswap32(v);
}

//----- (0001571C) --------------------------------------------------------
void __cdecl swap256(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = *((_DWORD *)src_p + 7);
  *((_DWORD *)dest_p + 1) = *((_DWORD *)src_p + 6);
  *((_DWORD *)dest_p + 2) = *((_DWORD *)src_p + 5);
  *((_DWORD *)dest_p + 3) = *((_DWORD *)src_p + 4);
  *((_DWORD *)dest_p + 4) = *((_DWORD *)src_p + 3);
  *((_DWORD *)dest_p + 5) = *((_DWORD *)src_p + 2);
  *((_DWORD *)dest_p + 6) = *((_DWORD *)src_p + 1);
  *((_DWORD *)dest_p + 7) = *(_DWORD *)src_p;
}

//----- (00015788) --------------------------------------------------------
void __cdecl swab256(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = swab32(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = swab32(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = swab32(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = swab32(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = swab32(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = swab32(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = swab32(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = swab32(*(_DWORD *)src_p);
}

//----- (0001584C) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00015894) --------------------------------------------------------
void __cdecl flip64(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 15; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (000158DC) --------------------------------------------------------
void __cdecl flip80(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 19; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00015924) --------------------------------------------------------
void __cdecl endian_flip32(void *dest_p, const void *src_p)
{
  ;
}

//----- (00015938) --------------------------------------------------------
void __cdecl mutex_lock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000159B8) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00015A38) --------------------------------------------------------
void __cdecl mutex_unlock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_0(lock, file, func, line);
  selective_yield();
}

//----- (00015A68) --------------------------------------------------------
void __cdecl wr_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00015AE8) --------------------------------------------------------
int __cdecl wr_trylock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_rwlock_trywrlock(lock);
}

//----- (00015B0C) --------------------------------------------------------
void __cdecl rd_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00015B8C) --------------------------------------------------------
void __cdecl rw_unlock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00015C0C) --------------------------------------------------------
void __cdecl wr_unlock_noyield_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_0(lock, file, func, line);
}

//----- (00015C30) --------------------------------------------------------
void __cdecl rd_unlock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_0(lock, file, func, line);
  selective_yield();
}

//----- (00015C60) --------------------------------------------------------
void __cdecl wr_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_0(lock, file, func, line);
  selective_yield();
}

//----- (00015C90) --------------------------------------------------------
void __cdecl mutex_init_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00015D10) --------------------------------------------------------
void __cdecl rwlock_init(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00015D90) --------------------------------------------------------
void __cdecl cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init_0(&lock->mutex, file, func, line);
  rwlock_init(&lock->rwlock, file, func, line);
}

//----- (00015DC4) --------------------------------------------------------
void __cdecl cg_rlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_0(&lock->mutex, file, func, line);
  rd_lock_0(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_0(&lock->mutex, file, func, line);
}

//----- (00015E08) --------------------------------------------------------
void __cdecl cg_wlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_0(&lock->mutex, file, func, line);
  wr_lock_0(&lock->rwlock, file, func, line);
}

//----- (00015E3C) --------------------------------------------------------
void __cdecl cg_dwlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_0(&lock->rwlock, file, func, line);
  rd_lock_0(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_0(&lock->mutex, file, func, line);
}

//----- (00015E80) --------------------------------------------------------
void __cdecl cg_runlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock_0(&lock->rwlock, file, func, line);
}

//----- (00015EA8) --------------------------------------------------------
void __cdecl cg_wunlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_0(&lock->rwlock, file, func, line);
  mutex_unlock_0(&lock->mutex, file, func, line);
}

//----- (00015EDC) --------------------------------------------------------
bool __cdecl time_before(tm *tm1, tm *tm2)
{
  return tm1->tm_hour < tm2->tm_hour || tm1->tm_hour == tm2->tm_hour && tm1->tm_min < tm2->tm_min;
}

//----- (00015F20) --------------------------------------------------------
bool should_run()
{
  time_t tmp_time; // [sp+0h] [bp+0h] BYREF
  timeval tv; // [sp+4h] [bp+4h] BYREF
  tm *tm; // [sp+Ch] [bp+Ch]

  if ( !schedstart.enable && !schedstop.enable )
    return 1;
  cgtime(&tv);
  tmp_time = tv.tv_sec;
  tm = localtime(&tmp_time);
  if ( !schedstart.enable )
    return time_before(tm, &schedstop.tm);
  if ( !schedstop.enable )
  {
    if ( time_before(tm, &schedstart.tm) )
    {
      return 0;
    }
    else
    {
      schedstart.enable = 0;
      return 1;
    }
  }
  else if ( time_before(&schedstart.tm, &schedstop.tm) )
  {
    return time_before(tm, &schedstop.tm) && !time_before(tm, &schedstart.tm);
  }
  else
  {
    return !time_before(tm, &schedstart.tm) || time_before(tm, &schedstop.tm);
  }
}

//----- (00016038) --------------------------------------------------------
void __cdecl get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv)
{
  time_t tmp_time; // [sp+2Ch] [bp+14h] BYREF
  tm *tm; // [sp+30h] [bp+18h]
  int ms; // [sp+34h] [bp+1Ch]

  tmp_time = tv->tv_sec;
  ms = tv->tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf(
    (char *)f,
    fsiz,
    "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
    tm->tm_year + 1900,
    tm->tm_mon + 1,
    tm->tm_mday,
    tm->tm_hour,
    tm->tm_min,
    tm->tm_sec,
    ms);
}

//----- (000160B4) --------------------------------------------------------
void __cdecl get_timestamp(unsigned __int8 *f, size_t fsiz, timeval *tv)
{
  time_t tmp_time; // [sp+24h] [bp+14h] BYREF
  tm *tm; // [sp+28h] [bp+18h]
  int ms; // [sp+2Ch] [bp+1Ch]

  tmp_time = tv->tv_sec;
  ms = tv->tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf((char *)f, fsiz, "[%02d:%02d:%02d.%03d]", tm->tm_hour, tm->tm_min, tm->tm_sec, ms);
}

//----- (00016118) --------------------------------------------------------
void __noreturn applog_and_exit(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+14h] BYREF

  va_start(varg_r1, fmt);
  vsnprintf((char *)exit_buf, 0x200u, (const char *)fmt, varg_r1);
  applog(3, exit_buf, 1);
  exit(1);
}

//----- (00016150) --------------------------------------------------------
thr_info *__cdecl _get_thread(int thr_id)
{
  return mining_thr[thr_id];
}

//----- (00016178) --------------------------------------------------------
thr_info *__cdecl get_thread(int thr_id)
{
  thr_info *thr; // [sp+Ch] [bp+Ch]

  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___12104, 581);
  thr = _get_thread(thr_id);
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___12104, 583);
  return thr;
}

//----- (000161D4) --------------------------------------------------------
cgpu_info *__cdecl get_thr_cgpu(int thr_id)
{
  return get_thread(thr_id)->cgpu;
}

//----- (000161F4) --------------------------------------------------------
cgpu_info *__cdecl get_devices(int id)
{
  cgpu_info *cgpu; // [sp+Ch] [bp+Ch]

  rd_lock_0(&devices_lock, "cgminer.c", _func___12113, 601);
  cgpu = devices[id];
  rd_unlock_0(&devices_lock, "cgminer.c", _func___12113, 603);
  return cgpu;
}

//----- (0001625C) --------------------------------------------------------
void __cdecl sharelog(const unsigned __int8 *disposition, const work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+2Ch] [bp+Ch] BYREF
  unsigned __int8 s[1024]; // [sp+82Ch] [bp+80Ch] BYREF
  size_t ret; // [sp+C2Ch] [bp+C0Ch]
  int rv; // [sp+C30h] [bp+C10h]
  unsigned __int8 *data; // [sp+C34h] [bp+C14h]
  unsigned __int8 *hash; // [sp+C38h] [bp+C18h]
  unsigned __int8 *target; // [sp+C3Ch] [bp+C1Ch]
  unsigned int t; // [sp+C40h] [bp+C20h]
  pool *pool; // [sp+C44h] [bp+C24h]
  cgpu_info *cgpu; // [sp+C48h] [bp+C28h]
  int thr_id; // [sp+C4Ch] [bp+C2Ch]

  if ( !sharelog_file )
    return;
  thr_id = work->thr_id;
  cgpu = get_thr_cgpu(thr_id);
  pool = work->pool;
  t = work->tv_work_found.tv_sec;
  target = bin2hex(work->target, 0x20u);
  hash = bin2hex(work->hash, 0x20u);
  data = bin2hex(work->data, 0x80u);
  rv = snprintf(
         (char *)s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         t,
         (const char *)disposition,
         (const char *)target,
         (const char *)pool->rpc_url,
         (const char *)cgpu->drv->name,
         cgpu->device_id,
         thr_id,
         (const char *)hash,
         (const char *)data);
  free(target);
  free(hash);
  free(data);
  if ( rv > 1023 )
  {
    s[1023] = 0;
LABEL_9:
    mutex_lock_0(&sharelog_lock, "cgminer.c", _func___12129, 649);
    ret = fwrite(s, rv, 1u, sharelog_file);
    fflush(sharelog_file);
    mutex_unlock_0(&sharelog_lock, "cgminer.c", _func___12129, 652);
    if ( ret != 1 && (use_syslog || opt_log_output || opt_log_level > 2) )
    {
      strcpy((char *)tmp42, "sharelog fwrite error");
      applog(3, tmp42, 0);
    }
    return;
  }
  if ( rv >= 0 )
    goto LABEL_9;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "sharelog printf error");
    applog(3, tmp42, 0);
  }
}

//----- (000164A0) --------------------------------------------------------
void adjust_quota_gcd()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  unsigned int quota; // [sp+804h] [bp+804h]
  pool *pool; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]
  unsigned int lowest_quota; // [sp+810h] [bp+810h]
  unsigned int gcd; // [sp+814h] [bp+814h]

  lowest_quota = -1;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    quota = pool->quota;
    if ( quota && quota < lowest_quota )
      lowest_quota = quota;
  }
  if ( lowest_quota == -1 )
  {
    gcd = 1;
  }
  else
  {
    gcd = lowest_quota;
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      quota = pool->quota;
      if ( quota )
      {
        while ( quota % gcd )
          --gcd;
      }
    }
  }
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->quota_used *= global_quota_gcd;
    pool->quota_used /= gcd;
    pool->quota_gcd = pool->quota / gcd;
  }
  global_quota_gcd = gcd;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Global quota greatest common denominator set to %lu", gcd);
    applog(7, tmp42, 0);
  }
}

//----- (000166A8) --------------------------------------------------------
pool *add_pool()
{
  int v0; // r3
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  pool *pool; // [sp+80Ch] [bp+804h]

  pool = (pool *)cgcalloc(1856, 1u, "cgminer.c", _func___12161, 734);
  pool->support_vil = 0;
  if ( !pool )
  {
    strcpy((char *)tmp42, "Failed to malloc pool in add_pool");
    applog(3, tmp42, 1);
    quit(1);
  }
  pool->prio = total_pools;
  pool->pool_no = pool->prio;
  pools = (pool **)cgrealloc(pools, 4 * (total_pools + 2), "cgminer.c", _func___12161, 746);
  v0 = total_pools;
  pools[total_pools] = pool;
  total_pools = v0 + 1;
  mutex_init_0(&pool->pool_lock, "cgminer.c", _func___12161, 749);
  if ( pthread_cond_init(&pool->cr_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init in add_pool");
    applog(3, tmp42, 1);
    quit(1);
  }
  cglock_init(&pool->data_lock, "cgminer.c", _func___12161, 756);
  mutex_init_0(&pool->stratum_lock, "cgminer.c", _func___12161, 757);
  cglock_init(&pool->gbt_lock, "cgminer.c", _func___12161, 758);
  pool->curlring.next = &pool->curlring;
  pool->curlring.prev = &pool->curlring;
  pool->tv_idle.tv_sec = -1;
  pool->rpc_req = getwork_req;
  pool->rpc_proxy = 0;
  pool->quota = 1;
  adjust_quota_gcd();
  pool->extranonce_subscribe = 0;
  return pool;
}

//----- (000168D8) --------------------------------------------------------
bool __cdecl pool_tset(pool *pool, bool *var)
{
  bool ret; // [sp+Fh] [bp+Fh]

  mutex_lock_0(&pool->pool_lock, "cgminer.c", _func___12169, 780);
  ret = *var;
  *var = 1;
  mutex_unlock_0(&pool->pool_lock, "cgminer.c", _func___12169, 785);
  return ret;
}

//----- (00016938) --------------------------------------------------------
bool __cdecl pool_tclear(pool *pool, bool *var)
{
  bool ret; // [sp+Fh] [bp+Fh]

  mutex_lock_0(&pool->pool_lock, "cgminer.c", _func___12175, 795);
  ret = *var;
  *var = 0;
  mutex_unlock_0(&pool->pool_lock, "cgminer.c", _func___12175, 800);
  return ret;
}

//----- (00016998) --------------------------------------------------------
pool *current_pool()
{
  pool *pool; // [sp+4h] [bp+4h]

  cg_rlock_0(&control_lock, "cgminer.c", _func___12180, 810);
  pool = currentpool;
  cg_runlock_0(&control_lock, "cgminer.c", _func___12180, 814);
  return pool;
}

//----- (000169F8) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_range(const unsigned __int8 *arg, int *i, int min, int max)
{
  unsigned __int8 *err; // [sp+14h] [bp+14h]

  err = opt_set_intval(arg, i);
  if ( err )
    return err;
  if ( *i >= min && *i <= max )
    return 0;
  return "Value out of range";
}

//----- (00016A44) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_9999(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 9999);
}

//----- (00016A68) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_65535(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 0xFFFF);
}

//----- (00016A8C) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 10);
}

//----- (00016AB0) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_100(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 100);
}

//----- (00016AD4) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 255);
}

//----- (00016AF8) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 255);
}

//----- (00016B1C) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_7680(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 7680);
}

//----- (00016B40) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_200(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 200);
}

//----- (00016B64) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_32_to_63(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 32, 63);
}

//----- (00016B88) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_22_to_75(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 75);
}

//----- (00016BAC) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_42_to_85(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 85);
}

//----- (00016BD0) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_22_to_55(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 55);
}

//----- (00016BF4) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_42_to_65(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 62);
}

//----- (00016C18) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 10);
}

//----- (00016C3C) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_4(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 4);
}

//----- (00016C60) --------------------------------------------------------
void __cdecl get_intrange(unsigned __int8 *arg, int *val1, int *val2)
{
  if ( sscanf((const char *)arg, "%d-%d", val1, val2) == 1 )
    *val2 = *val1;
}

//----- (00016C94) --------------------------------------------------------
unsigned __int8 *__cdecl set_balance(pool_strategy *strategy)
{
  *strategy = POOL_BALANCE;
  return 0;
}

//----- (00016CB0) --------------------------------------------------------
unsigned __int8 *__cdecl set_loadbalance(pool_strategy *strategy)
{
  *strategy = POOL_LOADBALANCE;
  return 0;
}

//----- (00016CCC) --------------------------------------------------------
unsigned __int8 *__cdecl set_rotate(const unsigned __int8 *arg, unsigned __int8 *i)
{
  pool_strategy_0 = POOL_ROTATE;
  return set_int_range(arg, &opt_rotate_period, 0, 9999);
}

//----- (00016D04) --------------------------------------------------------
unsigned __int8 *__cdecl set_rr(pool_strategy *strategy)
{
  *strategy = POOL_ROUNDROBIN;
  return 0;
}

//----- (00016D20) --------------------------------------------------------
bool __cdecl detect_stratum(pool *pool, unsigned __int8 *url)
{
  if ( !extract_sockaddr(url, &pool->sockaddr_url, &pool->stratum_port) )
    return 0;
  if ( strncasecmp((const char *)url, "stratum+tcp://", 0xEu) )
    return 0;
  pool->rpc_url = (unsigned __int8 *)strdup((const char *)url);
  pool->has_stratum = 1;
  pool->stratum_url = pool->sockaddr_url;
  return 1;
}

//----- (00016D9C) --------------------------------------------------------
pool *add_url()
{
  if ( ++total_urls > total_pools )
    add_pool();
  return pools[total_urls - 1];
}

//----- (00016DF4) --------------------------------------------------------
unsigned __int8 *__cdecl setup_url(pool *pool, unsigned __int8 *arg)
{
  unsigned __int8 *arga; // [sp+0h] [bp+0h]
  unsigned __int8 *httpinput; // [sp+Ch] [bp+Ch]

  arga = get_proxy(arg, pool);
  if ( !detect_stratum(pool, arga) )
  {
    opt_set_charp(arga, &pool->rpc_url);
    if ( strncmp((const char *)arga, "http://", 7u) )
    {
      if ( strncmp((const char *)arga, "https://", 8u) )
      {
        httpinput = (unsigned __int8 *)cgmalloc(0x100u, "cgminer.c", _func___12279, 1014);
        strcpy((char *)httpinput, "stratum+tcp://");
        strncat((char *)httpinput, (const char *)arga, 0xF2u);
        detect_stratum(pool, httpinput);
      }
    }
  }
  return pool->rpc_url;
}

//----- (00016EB0) --------------------------------------------------------
unsigned __int8 *__cdecl set_url(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  pool *pool; // [sp+80Ch] [bp+80Ch]

  pool = add_url();
  setup_url(pool, arg);
  if ( strstr((const char *)pool->rpc_url, ".nicehash.com") || strstr((const char *)pool->rpc_url, "#xnsub") )
  {
    pool->extranonce_subscribe = 1;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d extranonce subscribing enabled.", pool->pool_no);
      applog(7, tmp42, 0);
    }
  }
  return 0;
}

//----- (00016F80) --------------------------------------------------------
unsigned __int8 *__cdecl set_quota(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  pool *pool; // [sp+810h] [bp+808h]
  unsigned __int8 *url; // [sp+814h] [bp+80Ch]
  int quota; // [sp+818h] [bp+810h]
  int qlen; // [sp+81Ch] [bp+814h]
  int len; // [sp+820h] [bp+818h]
  unsigned __int8 *semicolon; // [sp+824h] [bp+81Ch]

  semicolon = (unsigned __int8 *)strchr((const char *)arg, 59);
  if ( !semicolon )
    return "No semicolon separated quota;URL pair found";
  len = strlen((const char *)arg);
  *semicolon = 0;
  qlen = strlen((const char *)arg);
  if ( !qlen )
    return "No parameter for quota found";
  len += ~qlen;
  if ( len <= 0 )
    return "No parameter for URL found";
  quota = atoi((const char *)arg);
  if ( quota < 0 )
    return "Invalid negative parameter for quota set";
  url = &arg[qlen + 1];
  pool = add_url();
  setup_url(pool, url);
  pool->quota = quota;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Setting pool %d to quota %d", pool->pool_no, pool->quota);
    applog(6, tmp42, 0);
  }
  adjust_quota_gcd();
  return 0;
}

//----- (000170BC) --------------------------------------------------------
unsigned __int8 *__cdecl set_user(const unsigned __int8 *arg)
{
  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_users > total_pools )
    add_pool();
  opt_set_charp(arg, &pools[total_users - 1]->rpc_user);
  return 0;
}

//----- (00017144) --------------------------------------------------------
unsigned __int8 *__cdecl set_pass(const unsigned __int8 *arg)
{
  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_passes > total_pools )
    add_pool();
  opt_set_charp(arg, &pools[total_passes - 1]->rpc_pass);
  return 0;
}

//----- (000171CC) --------------------------------------------------------
unsigned __int8 *__cdecl set_userpass(const unsigned __int8 *arg)
{
  char *updup; // [sp+8h] [bp+8h]
  pool *pool; // [sp+Ch] [bp+Ch]

  if ( total_users || total_passes )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_userpasses > total_pools )
    add_pool();
  pool = pools[total_userpasses - 1];
  updup = strdup((const char *)arg);
  opt_set_charp(arg, &pool->rpc_userpass);
  pool->rpc_user = (unsigned __int8 *)strtok(updup, ":");
  if ( !pool->rpc_user )
    return "Failed to find : delimited user info";
  pool->rpc_pass = (unsigned __int8 *)strtok(0, ":");
  if ( !pool->rpc_pass )
    pool->rpc_pass = (unsigned __int8 *)strdup(&byte_71100);
  return 0;
}
// 71100: using guessed type char byte_71100;

//----- (000172CC) --------------------------------------------------------
unsigned __int8 *__cdecl set_extranonce_subscribe(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  pool *pool; // [sp+80Ch] [bp+80Ch]

  if ( ++total_extranonce > total_pools )
    add_pool();
  pool = pools[total_extranonce - 1];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Enable extranonce subscribe on %d", pool->pool_no);
    applog(7, tmp42, 0);
  }
  opt_set_bool(&pool->extranonce_subscribe);
  return 0;
}

//----- (000173A8) --------------------------------------------------------
unsigned __int8 *__cdecl enable_debug(bool *flag)
{
  *flag = 0;
  opt_log_output = 0;
  return 0;
}

//----- (000173D0) --------------------------------------------------------
unsigned __int8 *__cdecl set_schedtime(const unsigned __int8 *arg, schedtime *st)
{
  if ( sscanf((const char *)arg, "%d:%d", &st->tm.tm_hour, &st->tm.tm_min) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( st->tm.tm_hour > 23 || st->tm.tm_min > 59 || st->tm.tm_hour < 0 || st->tm.tm_min < 0 )
    return "Invalid time set.";
  st->enable = 1;
  return 0;
}

//----- (00017440) --------------------------------------------------------
unsigned __int8 *__cdecl set_sched_start(const unsigned __int8 *arg)
{
  return set_schedtime(arg, &schedstart);
}

//----- (00017464) --------------------------------------------------------
unsigned __int8 *__cdecl set_sched_stop(const unsigned __int8 *arg)
{
  return set_schedtime(arg, &schedstop);
}

//----- (00017488) --------------------------------------------------------
unsigned __int8 *__cdecl set_sharelog(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *r; // [sp+808h] [bp+808h] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  r = (unsigned __int8 *)&byte_71100;
  i = strtol((const char *)arg, (char **)&r, 10);
  if ( *r || i < 0 )
  {
    if ( !strcmp((const char *)arg, "-") )
    {
      sharelog_file = (FILE *)stdout;
      if ( !stdout && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        strcpy((char *)tmp42, "Standard output missing for share log");
        applog(3, tmp42, 0);
      }
    }
    else
    {
      sharelog_file = fopen((const char *)arg, "a");
      if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        snprintf((char *)tmp42, 0x800u, "Failed to open %s for share log", (const char *)arg);
        applog(3, tmp42, 0);
      }
    }
  }
  else
  {
    sharelog_file = fdopen(i, "a");
    if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
    {
      snprintf((char *)tmp42, 0x800u, "Failed to open fd %u for share log", i);
      applog(3, tmp42, 0);
    }
  }
  return 0;
}
// 71100: using guessed type char byte_71100;
// 8A8B4: using guessed type int stdout;

//----- (00017668) --------------------------------------------------------
unsigned __int8 *__cdecl set_temp_cutoff(unsigned __int8 *arg)
{
  int val; // [sp+Ch] [bp+Ch]

  if ( !arg || !*arg )
    return "Invalid parameters for set temp cutoff";
  val = atoi((const char *)arg);
  if ( val < 0 || val > 200 )
    return "Invalid value passed to set temp cutoff";
  temp_cutoff_str = arg;
  return 0;
}

//----- (000176C0) --------------------------------------------------------
void load_temp_cutoffs()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 *nextptr; // [sp+800h] [bp+800h]
  int device; // [sp+804h] [bp+804h]
  int val; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]

  val = 0;
  device = 0;
  if ( temp_cutoff_str )
  {
    device = 0;
    for ( nextptr = (unsigned __int8 *)strtok((char *)temp_cutoff_str, ",");
          nextptr;
          nextptr = (unsigned __int8 *)strtok(0, ",") )
    {
      if ( device >= total_devices )
      {
        strcpy((char *)tmp42, "Too many values passed to set temp cutoff");
        applog(3, tmp42, 1);
        quit(1);
      }
      val = atoi((const char *)nextptr);
      if ( val < 0 || val > 200 )
      {
        strcpy((char *)tmp42, "Invalid value passed to set temp cutoff");
        applog(3, tmp42, 1);
        quit(1);
      }
      rd_lock_0(&devices_lock, "cgminer.c", _func___12351, 1308);
      devices[device]->cutofftemp = val;
      rd_unlock_0(&devices_lock, "cgminer.c", _func___12351, 1310);
      ++device;
    }
    if ( device <= 1 )
    {
      rd_lock_0(&devices_lock, "cgminer.c", _func___12351, 1331);
      for ( i = device; i < total_devices; ++i )
        devices[i]->cutofftemp = val;
      rd_unlock_0(&devices_lock, "cgminer.c", _func___12351, 1337);
    }
  }
  else
  {
    rd_lock_0(&devices_lock, "cgminer.c", _func___12351, 1315);
    for ( i = device; i < total_devices; ++i )
    {
      if ( !devices[i]->cutofftemp )
        devices[i]->cutofftemp = 95;
    }
    rd_unlock_0(&devices_lock, "cgminer.c", _func___12351, 1324);
  }
}

//----- (00017954) --------------------------------------------------------
unsigned __int8 *__cdecl set_logfile_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_path);
  return 0;
}

//----- (00017978) --------------------------------------------------------
unsigned __int8 *__cdecl set_logfile_openflag(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_openflag);
  return 0;
}

//----- (0001799C) --------------------------------------------------------
unsigned __int8 *__cdecl set_logwork_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_path);
  return 0;
}

//----- (000179C0) --------------------------------------------------------
unsigned __int8 *__cdecl set_logwork_asicnum(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_asicnum);
  return 0;
}

//----- (000179E4) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_125_to_500(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 125.0 && *i <= 500.0 )
    return 0;
  return "Value out of range";
}

//----- (00017A48) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_100_to_250(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 100.0 && *i <= 250.0 )
    return 0;
  return "Value out of range";
}

//----- (00017AAC) --------------------------------------------------------
unsigned __int8 *__cdecl set_null(const unsigned __int8 *arg)
{
  return 0;
}

//----- (00017AC4) --------------------------------------------------------
unsigned __int8 *__cdecl set_version_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_version_path);
  return 0;
}

//----- (00017AE8) --------------------------------------------------------
unsigned __int8 *__cdecl parse_config(json_t_0 *config, bool fileconf)
{
  size_t v2; // r0
  const unsigned __int8 *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  json_t_0 *arr_val; // [sp+810h] [bp+808h]
  const unsigned __int8 *str; // [sp+814h] [bp+80Ch]
  json_t_0 *val; // [sp+818h] [bp+810h]
  unsigned __int8 *name; // [sp+81Ch] [bp+814h]
  size_t index; // [sp+820h] [bp+818h]
  unsigned __int8 *err; // [sp+824h] [bp+81Ch]
  unsigned __int8 *p; // [sp+828h] [bp+820h]
  opt_table *opt; // [sp+82Ch] [bp+824h]

  if ( fileconf && !fileconf_load )
    fileconf_load = 1;
  for ( opt = opt_config_table; opt->type != OPT_END; ++opt )
  {
    if ( (opt->type & 8) != 0 )
      _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x766u, (const char *)_PRETTY_FUNCTION___12822);
    if ( opt->names )
    {
      name = (unsigned __int8 *)strdup((const char *)opt->names);
      for ( p = (unsigned __int8 *)strtok((char *)name, "|"); p; p = (unsigned __int8 *)strtok(0, "|") )
      {
        err = 0;
        if ( p[1] == 45 )
        {
          val = json_object_get(config, p + 2);
          if ( val )
          {
            if ( (opt->type & 6) != 0 && val->type == JSON_STRING )
            {
              str = json_string_value(val);
              err = opt->cb_arg(str, opt->u.tlen);
              if ( opt->type == OPT_PROCESSARG )
                opt_set_charp(str, (unsigned __int8 **)opt->u.carg);
            }
            else if ( (opt->type & 6) != 0 && val->type == JSON_ARRAY )
            {
              for ( index = 0; ; ++index )
              {
                v2 = json_array_size(val);
                if ( v2 <= index )
                  break;
                arr_val = json_array_get(val, index);
                if ( !arr_val )
                  break;
                if ( arr_val->type == JSON_STRING )
                {
                  str = json_string_value(arr_val);
                  err = opt->cb_arg(str, opt->u.tlen);
                  if ( opt->type == OPT_PROCESSARG )
                    opt_set_charp(str, (unsigned __int8 **)opt->u.carg);
                }
                else if ( arr_val->type == JSON_OBJECT )
                {
                  err = parse_config(arr_val, 0);
                }
                if ( err )
                  break;
              }
            }
            else
            {
              err = (opt->type & 1) != 0 && val->type == JSON_TRUE ? opt->cb(opt->u.tlen) : "Invalid value";
            }
            if ( err )
            {
              if ( !fileconf )
              {
                snprintf((char *)err_buf_12816, 0xC8u, "Parsing JSON option %s: %s", (const char *)p, (const char *)err);
                return err_buf_12816;
              }
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf((char *)tmp42, 0x800u, "Invalid config option %s: %s", (const char *)p, (const char *)err);
                applog(3, tmp42, 0);
              }
              fileconf_load = -1;
            }
          }
        }
      }
      free(name);
    }
  }
  val = json_object_get(config, "include");
  if ( !val || val->type != JSON_STRING )
    return 0;
  v4 = json_string_value(val);
  return load_config(v4, 0);
}
// 17BD2: conditional instruction was optimized away because %val.4!=0
// 17C34: conditional instruction was optimized away because %val.4!=0
// 17CA0: conditional instruction was optimized away because %arr_val.4!=0
// 17D10: conditional instruction was optimized away because %val.4!=0

//----- (00017E7C) --------------------------------------------------------
unsigned __int8 *__cdecl load_config(const unsigned __int8 *arg, void *unused)
{
  size_t v3; // r4
  json_error_t err; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 *json_error; // [sp+10Ch] [bp+104h]
  size_t siz; // [sp+110h] [bp+108h]
  json_t_0 *config; // [sp+114h] [bp+10Ch]

  if ( !cnfbuf )
    cnfbuf = (unsigned __int8 *)strdup((const char *)arg);
  if ( ++include_count > 10 )
    return "Too many levels of JSON includes (limit 10) or a loop";
  config = json_load_file(arg, 0, &err);
  if ( config && config->type == JSON_OBJECT )
  {
    config_loaded = 1;
    return parse_config(config, 1);
  }
  else
  {
    v3 = strlen((const char *)arg);
    siz = v3 + strlen((const char *)err.text) + 35;
    json_error = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___12847, 2048);
    snprintf((char *)json_error, siz, "JSON decode of file '%s' failed\n %s", (const char *)arg, (const char *)err.text);
    return json_error;
  }
}

//----- (00017F8C) --------------------------------------------------------
unsigned __int8 *__cdecl set_default_config(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &default_config);
  return 0;
}

//----- (00017FB0) --------------------------------------------------------
void load_default_config()
{
  cnfbuf = (unsigned __int8 *)cgmalloc(0x1000u, "cgminer.c", _func___12856, 2073);
  default_save_file(cnfbuf);
  if ( access((const char *)cnfbuf, 4) )
  {
    free(cnfbuf);
    cnfbuf = 0;
  }
  else
  {
    load_config(cnfbuf, 0);
  }
}

//----- (00018038) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_verusage_and_exit(const unsigned __int8 *extra)
{
  unsigned __int8 *v1; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", (const char *)packagename);
  v1 = opt_usage(opt_argv0, extra);
  printf("%s", (const char *)v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 8A8B4: using guessed type int stdout;

//----- (0001808C) --------------------------------------------------------
void __cdecl calc_midstate(work *work)
{
  sha256_ctx ctx; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 data[64]; // [sp+BCh] [bp+B4h] BYREF
  unsigned int *data32; // [sp+FCh] [bp+F4h]

  data32 = (unsigned int *)data;
  flip64(data, work);
  sha256_init(&ctx);
  sha256_update(&ctx, data, 0x40u);
  cg_memcpy(work->midstate, ctx.h, 0x20u, "cgminer.c", _func___12890, 2180);
  endian_flip32(work->midstate, work->midstate);
}

//----- (00018110) --------------------------------------------------------
int total_work_inc()
{
  int ret; // [sp+4h] [bp+4h]

  cg_wlock_0(&control_lock, "cgminer.c", _func___12895, 2189);
  ret = total_work++;
  cg_wunlock_0(&control_lock, "cgminer.c", _func___12895, 2191);
  return ret;
}

//----- (0001817C) --------------------------------------------------------
work *make_work()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  work *work; // [sp+80Ch] [bp+804h]

  work = (work *)cgcalloc(1, 0x1C0u, "cgminer.c", _func___12900, 2198);
  if ( !work )
  {
    strcpy((char *)tmp42, "Failed to calloc work in make_work");
    applog(3, tmp42, 1);
    quit(1);
  }
  work->id = total_work_inc();
  return work;
}

//----- (00018208) --------------------------------------------------------
void __cdecl clean_work(work *work)
{
  free(work->job_id);
  free(work->ntime);
  free(work->coinbase);
  free(work->nonce1);
  memset(work, 0, sizeof(work));
}

//----- (00018254) --------------------------------------------------------
void __cdecl free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  work *work; // [sp+81Ch] [bp+814h]

  work = *workptr;
  if ( work )
  {
    clean_work(work);
    free(work);
    *workptr = 0;
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Free work called with NULL work from %s %s:%d",
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (00018310) --------------------------------------------------------
int __cdecl dev_from_id(int thr_id)
{
  return get_thr_cgpu(thr_id)->device_id;
}

//----- (00018330) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl decay_time(double *f, double fadd, double fsecs, double interval)
{
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double fprop; // [sp+28h] [bp+28h]

  if ( v5 > 0.0 )
  {
    exp(*(double *)&f);
    fprop = 1.0 - 1.0 / (v5 / v6);
    *f = *f + v4 / v5 * fprop;
    *f = *f / (fprop + 1.0);
  }
}
// 18330: variables would overlap: r0.4 and r0.8

//----- (000183D4) --------------------------------------------------------
unsigned int _total_staged()
{
  if ( staged_work )
    return staged_work->hh.tbl->num_items;
  else
    return 0;
}

//----- (00018404) --------------------------------------------------------
int total_staged()
{
  int ret; // [sp+4h] [bp+4h]

  mutex_lock_0(stgd_lock, "cgminer.c", _func___12940, 2847);
  ret = _total_staged();
  mutex_unlock_0(stgd_lock, "cgminer.c", _func___12940, 2849);
  return ret;
}

//----- (00018464) --------------------------------------------------------
void __cdecl suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits)
{
  double v4; // r0
  double v5; // r0
  double v6; // d7
  unsigned __int8 suffix[2]; // [sp+28h] [bp+10h] BYREF
  int ndigits; // [sp+2Ch] [bp+14h]
  uint64_t exa; // [sp+30h] [bp+18h]
  uint64_t peta; // [sp+38h] [bp+20h]
  uint64_t tera; // [sp+40h] [bp+28h]
  uint64_t giga; // [sp+48h] [bp+30h]
  uint64_t mega; // [sp+50h] [bp+38h]
  uint64_t kilo; // [sp+58h] [bp+40h]
  double dkilo; // [sp+60h] [bp+48h]
  bool decimal; // [sp+6Fh] [bp+57h]
  double dval; // [sp+70h] [bp+58h]

  dkilo = 1000.0;
  kilo = 1000LL;
  mega = (unsigned int)&nonce_num[6][85][45];
  giga = 1000000000LL;
  tera = 1000000000000LL;
  peta = 1000000000000000LL;
  exa = 1000000000000000000LL;
  *(_WORD *)suffix = 0;
  decimal = 1;
  if ( val < 0xDE0B6B3A7640000LL )
  {
    if ( val < peta )
    {
      if ( val < tera )
      {
        if ( val < giga )
        {
          if ( val < mega )
          {
            v4 = (double)val;
            if ( val >= kilo )
            {
              dval = (double)val / dkilo;
              strcpy((char *)suffix, "K");
            }
            else
            {
              dval = (double)val;
              decimal = 0;
            }
          }
          else
          {
            v4 = (double)(val / kilo);
            dval = v4 / dkilo;
            strcpy((char *)suffix, "M");
          }
        }
        else
        {
          v4 = (double)(val / mega);
          dval = v4 / dkilo;
          strcpy((char *)suffix, "G");
        }
      }
      else
      {
        v4 = (double)(val / giga);
        dval = v4 / dkilo;
        strcpy((char *)suffix, "T");
      }
    }
    else
    {
      v4 = (double)(val / tera);
      dval = v4 / dkilo;
      strcpy((char *)suffix, "P");
    }
  }
  else
  {
    v4 = (double)(val / peta);
    dval = v4 / dkilo;
    strcpy((char *)suffix, "E");
  }
  if ( sigdigits )
  {
    if ( dval <= 0.0 )
    {
      v6 = 0.0;
    }
    else
    {
      v5 = log10(v4);
      floor(v5);
      v6 = dval;
    }
    ndigits = (int)((double)(sigdigits - 1) - v6);
    snprintf((char *)buf, bufsiz, "%*.*f%s", sigdigits + 1, ndigits, dval, (const char *)suffix);
  }
  else if ( decimal )
  {
    snprintf((char *)buf, bufsiz, "%.3g%s", dval, (const char *)suffix);
  }
  else
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)dval, (const char *)suffix);
  }
}

//----- (00018758) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl cgpu_runtime(cgpu_info *cgpu)
{
  double result; // r0
  cgpu_info *cgpua; // [sp+4h] [bp+4h]
  timeval now; // [sp+8h] [bp+8h] BYREF
  double dev_runtime; // [sp+10h] [bp+10h]

  cgpua = cgpu;
  if ( cgpu->dev_start_tv.tv_sec )
  {
    cgtime(&now);
    *(double *)&cgpu = tdiff(&now, &cgpua->dev_start_tv);
  }
  else
  {
    dev_runtime = total_secs;
  }
  LODWORD(result) = cgpu;
  return result;
}
// 18758: variables would overlap: r0.4 and r0.8
// 18758: bad return variable

//----- (000187D4) --------------------------------------------------------
double tsince_restart()
{
  timeval now; // [sp+0h] [bp+0h] BYREF

  cgtime(&now);
  return tdiff(&now, &restart_tv_start);
}

//----- (00018804) --------------------------------------------------------
double tsince_update()
{
  timeval now; // [sp+0h] [bp+0h] BYREF

  cgtime(&now);
  return tdiff(&now, &update_tv_start);
}

//----- (00018834) --------------------------------------------------------
void __cdecl get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  double v3; // d0
  unsigned __int8 tmp13[64]; // [sp+38h] [bp+10h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+78h] [bp+50h] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+878h] [bp+850h] BYREF
  unsigned __int8 displayed_hashes[16]; // [sp+888h] [bp+860h] BYREF
  size_t len13; // [sp+898h] [bp+870h]
  size_t buflen; // [sp+89Ch] [bp+874h]
  uint64_t dr64; // [sp+8A0h] [bp+878h]
  uint64_t dh64; // [sp+8A8h] [bp+880h]
  double wu; // [sp+8B0h] [bp+888h]
  double dev_runtime; // [sp+8B8h] [bp+890h]

  cgpu_runtime(cgpu);
  dev_runtime = v3;
  wu = (double)cgpu->diff1 / v3 * 60.0;
  dh64 = (unsigned __int64)(cgpu->total_mhashes / v3 * 1000000.0);
  dr64 = (unsigned __int64)(cgpu->rolling * 1000000.0);
  suffix_string(dh64, displayed_hashes, 0x10u, 4);
  suffix_string(dr64, displayed_rolling, 0x10u, 4);
  snprintf((char *)buf, bufsiz, "%s%d ", (const char *)cgpu->drv->name, cgpu->device_id);
  cgpu->drv->get_statline_before(buf, bufsiz, cgpu);
  buflen = strlen((const char *)buf);
  snprintf(
    (char *)tmp13,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    opt_log_interval,
    (const char *)displayed_rolling,
    (const char *)displayed_hashes,
    cgpu->diff_accepted,
    cgpu->diff_rejected,
    cgpu->hw_errors,
    wu);
  len13 = strlen((const char *)tmp13);
  if ( buflen + len13 >= bufsiz )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "tailsprintf buffer overflow in %s %s line %d",
      "cgminer.c",
      (const char *)_func___12993,
      3041);
    applog(3, tmp42, 1);
    quit(1);
  }
  strcat((char *)buf, (const char *)tmp13);
  cgpu->drv->get_statline(buf, bufsiz, cgpu);
}
// 18858: variable 'v3' is possibly undefined

//----- (00018A68) --------------------------------------------------------
int shared_strategy()
{
  return pool_strategy_0 == POOL_LOADBALANCE || pool_strategy_0 == POOL_BALANCE;
}

//----- (00018A9C) --------------------------------------------------------
void __cdecl enable_pool(pool *pool)
{
  if ( pool->enabled != POOL_ENABLED )
  {
    ++enabled_pools;
    pool->enabled = POOL_ENABLED;
  }
}

//----- (00018AD4) --------------------------------------------------------
void __cdecl reject_pool(pool *pool)
{
  if ( pool->enabled == POOL_ENABLED )
    --enabled_pools;
  pool->enabled = POOL_REJECTING;
}

//----- (00018B0C) --------------------------------------------------------
void __cdecl share_result(
        json_t_0 *val,
        json_t_0 *res,
        json_t_0 *err,
        const work *work,
        unsigned __int8 *hashshow,
        bool resubmit,
        unsigned __int8 *worktime)
{
  const char *v7; // r3
  const char *v8; // r3
  const char *v9; // r3
  unsigned __int8 reason[32]; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 disposition[36]; // [sp+48h] [bp+30h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+6Ch] [bp+54h] BYREF
  unsigned __int8 where[20]; // [sp+86Ch] [bp+854h] BYREF
  double utility; // [sp+880h] [bp+868h]
  const unsigned __int8 *s; // [sp+88Ch] [bp+874h]
  unsigned __int8 *reason_str; // [sp+890h] [bp+878h]
  json_t_0 *reason_val; // [sp+894h] [bp+87Ch]
  const unsigned __int8 *reasontmp; // [sp+898h] [bp+880h]
  cgpu_info *cgpu; // [sp+89Ch] [bp+884h]
  pool *pool; // [sp+8A0h] [bp+888h]
  size_t reasonLen; // [sp+8A4h] [bp+88Ch]

  pool = work->pool;
  cgpu = get_thr_cgpu(work->thr_id);
  if ( res && res->type == JSON_TRUE || work->gbt && res && res->type == JSON_NULL )
  {
    mutex_lock_0(&stats_lock, "cgminer.c", _func___13016, 3451);
    ++cgpu->accepted;
    ++total_accepted;
    ++pool->accepted;
    cgpu->diff_accepted = cgpu->diff_accepted + work->work_difficulty;
    total_diff_accepted = work->work_difficulty + total_diff_accepted;
    pool->diff_accepted = pool->diff_accepted + work->work_difficulty;
    mutex_unlock_0(&stats_lock, "cgminer.c", _func___13016, 3461);
    pool->seq_rejects = 0;
    cgpu->last_share_pool = pool->pool_no;
    cgpu->last_share_pool_time = time(0);
    cgpu->last_share_diff = work->work_difficulty;
    pool->last_share_time = cgpu->last_share_pool_time;
    pool->last_share_diff = work->work_difficulty;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "PROOF OF WORK RESULT: true (yay!!!)");
      applog(7, tmp42, 0);
    }
    if ( !opt_quiet && !opt_realquiet )
    {
      if ( total_pools <= 1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          if ( resubmit )
            v8 = "(resubmit)";
          else
            v8 = &byte_71100;
          snprintf(
            (char *)tmp42,
            0x800u,
            "Accepted %s %s %d %s%s",
            (const char *)hashshow,
            (const char *)cgpu->drv->name,
            cgpu->device_id,
            v8,
            (const char *)worktime);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( resubmit )
          v7 = "(resubmit)";
        else
          v7 = &byte_71100;
        snprintf(
          (char *)tmp42,
          0x800u,
          "Accepted %s %s %d pool %d %s%s",
          (const char *)hashshow,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          work->pool->pool_no,
          v7,
          (const char *)worktime);
        applog(5, tmp42, 0);
      }
    }
    sharelog("accept", work);
    if ( opt_shares && (double)opt_shares <= total_diff_accepted )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Successfully mined %d accepted shares as requested and exiting.", opt_shares);
        applog(4, tmp42, 0);
      }
      kill_work();
    }
    if ( pool->enabled == POOL_REJECTING )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Rejecting pool %d now accepting shares, re-enabling!", pool->pool_no);
        applog(4, tmp42, 0);
      }
      enable_pool(pool);
      switch_pools(0);
    }
    if ( work->block )
      restart_threads();
  }
  else
  {
    mutex_lock_0(&stats_lock, "cgminer.c", _func___13016, 3514);
    ++cgpu->rejected;
    ++total_rejected;
    ++pool->rejected;
    cgpu->diff_rejected = cgpu->diff_rejected + work->work_difficulty;
    total_diff_rejected = work->work_difficulty + total_diff_rejected;
    pool->diff_rejected = pool->diff_rejected + work->work_difficulty;
    ++pool->seq_rejects;
    mutex_unlock_0(&stats_lock, "cgminer.c", _func___13016, 3522);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "PROOF OF WORK RESULT: false (booooo)");
      applog(7, tmp42, 0);
    }
    if ( !opt_quiet && !opt_realquiet )
    {
      strcpy((char *)disposition, "reject");
      memset(&disposition[7], 0, 0x1Du);
      reason[0] = 0;
      if ( total_pools <= 1 )
        where[0] = 0;
      else
        snprintf((char *)where, 0x14u, "pool %d", work->pool->pool_no);
      if ( !work->gbt )
        res = json_object_get(val, "reject-reason");
      if ( res )
      {
        reasontmp = json_string_value(res);
        reasonLen = strlen((const char *)reasontmp);
        if ( reasonLen > 0x1C )
          reasonLen = 28;
        qmemcpy(reason, " (", 2);
        cg_memcpy(&reason[2], reasontmp, reasonLen, "cgminer.c", _func___13016, 3562);
        reason[reasonLen + 2] = 41;
        reason[reasonLen + 3] = 0;
        cg_memcpy(&disposition[7], reasontmp, reasonLen, "cgminer.c", _func___13016, 3567);
        disposition[6] = 58;
        disposition[reasonLen + 7] = 0;
      }
      else if ( work->stratum && err )
      {
        if ( err->type == JSON_ARRAY )
        {
          reason_val = json_array_get(err, 1u);
          if ( reason_val && reason_val->type == JSON_STRING )
          {
            reason_str = (unsigned __int8 *)json_string_value(reason_val);
            snprintf((char *)reason, 0x1Fu, " (%s)", (const char *)reason_str);
          }
        }
        else if ( err->type == JSON_STRING )
        {
          s = json_string_value(err);
          snprintf((char *)reason, 0x1Fu, " (%s)", (const char *)s);
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( resubmit )
          v9 = "(resubmit)";
        else
          v9 = &byte_71100;
        snprintf(
          (char *)tmp42,
          0x800u,
          "Rejected %s %s %d %s%s %s%s",
          (const char *)hashshow,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          (const char *)where,
          (const char *)reason,
          v9,
          (const char *)worktime);
        applog(5, tmp42, 0);
      }
      sharelog(disposition, work);
    }
    if ( pool->seq_rejects > 10 && !work->stale && opt_disable_pool && enabled_pools > 1 )
    {
      utility = (double)total_accepted / total_secs * 60.0;
      if ( (double)pool->seq_rejects > utility * 3.0 && enabled_pools > 1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Pool %d rejected %d sequential shares, disabling!",
            pool->pool_no,
            pool->seq_rejects);
          applog(4, tmp42, 0);
        }
        reject_pool(pool);
        if ( current_pool() == pool )
          switch_pools(0);
        pool->seq_rejects = 0;
      }
    }
  }
}
// 1929A: conditional instruction was optimized away because %err.4!=0
// 192FA: conditional instruction was optimized away because %err.4!=0
// 71100: using guessed type char byte_71100;

//----- (00019508) --------------------------------------------------------
void __cdecl show_hash(work *work, unsigned __int8 *hashshow)
{
  double work_difficulty; // d0
  const char *v3; // r3
  unsigned __int8 diffdisp[16]; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 rhash[32]; // [sp+30h] [bp+18h] BYREF
  uint64_t uintdiff; // [sp+50h] [bp+38h]
  unsigned int h32; // [sp+5Ch] [bp+44h]
  unsigned int *hash32; // [sp+60h] [bp+48h]
  int ofs; // [sp+64h] [bp+4Ch]

  swab256(rhash, work->hash);
  for ( ofs = 0; ofs <= 28 && !rhash[ofs]; ++ofs )
    ;
  hash32 = (unsigned int *)&rhash[ofs];
  h32 = (*(_DWORD *)&rhash[ofs] << 24) | HIBYTE(*(_DWORD *)&rhash[ofs]) | ((*(_DWORD *)&rhash[ofs] & 0xFF0000u) >> 8) | ((*(_DWORD *)&rhash[ofs] & 0xFF00) << 8);
  work_difficulty = work->work_difficulty;
  round();
  uintdiff = (unsigned __int64)work_difficulty;
  suffix_string(work->share_diff, diffdisp, 0x10u, 0);
  if ( work->block )
    v3 = " BLOCK!";
  else
    v3 = &byte_71100;
  snprintf((char *)hashshow, 0x40u, "%08lx Diff %s/%llu%s", h32, (const char *)diffdisp, uintdiff, v3);
}
// A2F8: using guessed type int round(void);
// 71100: using guessed type char byte_71100;

//----- (000195F0) --------------------------------------------------------
bool __cdecl pool_unusable(pool *pool)
{
  if ( pool->idle )
    return 1;
  if ( pool->enabled == POOL_ENABLED )
    return pool->has_stratum && (!pool->stratum_active || !pool->stratum_notify);
  return 1;
}

//----- (00019650) --------------------------------------------------------
pool *__cdecl select_balanced(pool *cp)
{
  pool *pool; // [sp+8h] [bp+8h]
  pool *ret; // [sp+Ch] [bp+Ch]
  int lowest; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  lowest = cp->shares;
  ret = cp;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    if ( !pool_unusable(pool) && pool->shares < lowest )
    {
      lowest = pool->shares;
      ret = pool;
    }
  }
  ++ret->shares;
  return ret;
}

//----- (000196D8) --------------------------------------------------------
pool *select_pool()
{
  int quota_used; // r3
  bool v1; // r2
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  pool *tp_0; // [sp+804h] [bp+804h]
  pool *tp; // [sp+808h] [bp+808h]
  pool *cp; // [sp+80Ch] [bp+80Ch]
  int i; // [sp+810h] [bp+810h]
  int tested; // [sp+814h] [bp+814h]
  bool avail; // [sp+81Bh] [bp+81Bh]
  pool *pool; // [sp+81Ch] [bp+81Ch]

  avail = 0;
  cp = current_pool();
  if ( pool_strategy_0 == POOL_BALANCE )
  {
    pool = select_balanced(cp);
  }
  else if ( pool_strategy_0 == POOL_LOADBALANCE )
  {
    pool = 0;
    for ( i = 0; i < total_pools; ++i )
    {
      tp = pools[i];
      if ( tp->quota_used < tp->quota_gcd )
      {
        avail = 1;
        break;
      }
    }
    if ( !avail )
    {
      for ( i = 0; i < total_pools; ++i )
        pools[i]->quota_used = 0;
      if ( ++rotating_pool_13068 >= total_pools )
        rotating_pool_13068 = 0;
    }
    tested = 0;
    while ( !pool )
    {
      if ( tested++ >= total_pools )
        break;
      pool = pools[rotating_pool_13068];
      quota_used = pool->quota_used;
      v1 = quota_used < pool->quota_gcd;
      pool->quota_used = quota_used + 1;
      if ( v1 && !pool_unusable(pool) )
        break;
      pool = 0;
      if ( ++rotating_pool_13068 >= total_pools )
        rotating_pool_13068 = 0;
    }
    if ( !pool )
    {
      for ( i = 0; i < total_pools; ++i )
      {
        tp_0 = priority_pool(i);
        if ( !pool_unusable(tp_0) )
        {
          pool = tp_0;
          break;
        }
      }
    }
    if ( !pool )
      pool = cp;
  }
  else
  {
    pool = cp;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Selecting pool %d for work", pool->pool_no);
    applog(7, tmp42, 0);
  }
  return pool;
}

//----- (000199A0) --------------------------------------------------------
double __cdecl le256todouble(const void *target)
{
  return (double)*(unsigned __int64 *)target;
}

//----- (00019A74) --------------------------------------------------------
double __cdecl diff_from_target(void *target)
{
  return le256todouble(target);
}

//----- (00019ACC) --------------------------------------------------------
void __cdecl calc_diff(work *work, double known)
{
  double v2; // d0
  double difficulty; // [sp+20h] [bp+18h]
  cgminer_pool_stats *pool_stats; // [sp+2Ch] [bp+24h]

  pool_stats = &work->pool->cgminer_pool_stats;
  if ( v2 == 0.0 )
  {
    diff_from_target(work->target);
    work->work_difficulty = v2;
  }
  else
  {
    work->work_difficulty = v2;
  }
  difficulty = work->work_difficulty;
  pool_stats->last_diff = difficulty;
  round();
  suffix_string((unsigned __int64)difficulty, work->pool->diff, 8u, 0);
  if ( pool_stats->min_diff == difficulty )
  {
    ++pool_stats->min_diff_count;
  }
  else if ( pool_stats->min_diff > difficulty || pool_stats->min_diff == 0.0 )
  {
    pool_stats->min_diff = difficulty;
    pool_stats->min_diff_count = 1;
  }
  if ( pool_stats->max_diff == difficulty )
  {
    ++pool_stats->max_diff_count;
  }
  else if ( pool_stats->max_diff < difficulty )
  {
    pool_stats->max_diff = difficulty;
    pool_stats->max_diff_count = 1;
  }
}
// 19AF0: variable 'v2' is possibly undefined
// A2F8: using guessed type int round(void);

//----- (00019BFC) --------------------------------------------------------
void __cdecl get_benchmark_work(work *work)
{
  work->work_difficulty = 32.0;
  cg_memcpy(work->target, bench_target, 0x20u, "cgminer.c", _func___13117, 4172);
  work->drv_rolllimit = 0;
  work->mandatory = 1;
  work->pool = *pools;
  cgtime(&work->tv_getwork);
  copy_time(&work->tv_getwork_reply, &work->tv_getwork);
  work->getwork_mode = 66;
}

//----- (00019C98) --------------------------------------------------------
void __cdecl benchfile_dspwork(work *work, unsigned int nonce)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf[1024]; // [sp+810h] [bp+808h] BYREF
  int i; // [sp+C10h] [bp+C08h]
  unsigned int dn; // [sp+C14h] [bp+C0Ch]

  dn = 0;
  for ( i = 0; i <= 3; ++i )
  {
    dn = (dn << 8) + (unsigned __int8)nonce;
    nonce >>= 8;
  }
  _bin2hex(buf, work->data, 0x80u);
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", dn, dn, (const char *)buf);
    applog(3, tmp42, 0);
  }
}

//----- (00019D64) --------------------------------------------------------
bool __cdecl benchfile_get_work(work *work)
{
  unsigned __int8 *v1; // r0
  unsigned __int8 **v2; // r2
  unsigned __int8 *v3; // r3
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 *commas[5]; // [sp+818h] [bp+808h] BYREF
  unsigned __int8 item[1024]; // [sp+82Ch] [bp+81Ch] BYREF
  unsigned __int8 buf[1024]; // [sp+C2Ch] [bp+C1Ch] BYREF
  int nonce_time; // [sp+102Ch] [bp+101Ch]
  int len; // [sp+1030h] [bp+1020h]
  int j; // [sp+1034h] [bp+1024h]
  int i; // [sp+1038h] [bp+1028h]
  bool got; // [sp+103Fh] [bp+102Fh]

  got = 0;
  if ( !benchfile_in )
  {
    if ( !opt_benchfile )
    {
      strcpy((char *)tmp42, "BENCHFILE Invalid benchfile NULL");
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_in = fopen((const char *)opt_benchfile, "r");
    if ( !benchfile_in )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to open benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_line = 0;
    if ( !fgets((char *)buf, 1024, benchfile_in) )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to read benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    got = 1;
    benchfile_work = 0;
  }
  if ( got || fgets((char *)buf, 1024, benchfile_in) )
  {
    do
    {
      ++benchfile_line;
      if ( buf[0] && buf[0] != 35 && buf[0] != 47 )
      {
        commas[0] = buf;
        for ( i = 1; i <= 4; ++i )
        {
          v1 = (unsigned __int8 *)strchr((const char *)commas[i - 1], 44);
          commas[i] = v1;
          if ( !commas[i] )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
              benchfile_line,
              i,
              5);
            applog(3, tmp42, 1);
            quit(1);
          }
          len = commas[i] - commas[i - 1];
          if ( benchfile_data[i - 1].length && benchfile_data[i - 1].length != len )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
              benchfile_line,
              i,
              (const char *)benchfile_data[i - 1].name,
              len,
              benchfile_data[i - 1].length);
            applog(3, tmp42, 1);
            quit(1);
          }
          v2 = &commas[i];
          v3 = *v2;
          *v3 = 0;
          *v2 = v3 + 1;
        }
        len = strlen((const char *)commas[4]);
        if ( benchfile_data[4].length > len )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
            benchfile_line,
            5,
            (const char *)benchfile_data[4].name,
            len,
            benchfile_data[4].length);
          applog(3, tmp42, 1);
          quit(1);
        }
        sprintf((char *)item, "0000000%c", *commas[0]);
        j = strlen((const char *)item);
        for ( i = benchfile_data[2].length - 8; i >= 0; i -= 8 )
        {
          sprintf((char *)&item[j], "%.8s", (const char *)&commas[2][i]);
          j += 8;
        }
        for ( i = benchfile_data[1].length - 8; i >= 0; i -= 8 )
        {
          sprintf((char *)&item[j], "%.8s", (const char *)&commas[1][i]);
          j += 8;
        }
        nonce_time = atol((const char *)commas[4]);
        sprintf((char *)&item[j], "%08lx", nonce_time);
        j += 8;
        strcpy((char *)&item[j], (const char *)commas[3]);
        j += benchfile_data[3].length;
        memset(work, 0, sizeof(work));
        hex2bin(work->data, item, j >> 1);
        calc_midstate(work);
        ++benchfile_work;
        return 1;
      }
    }
    while ( fgets((char *)buf, 1024, benchfile_in) );
    if ( !benchfile_work )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE No work in benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  else if ( !benchfile_work )
  {
    snprintf((char *)tmp42, 0x800u, "BENCHFILE No work in benchfile '%s'", (const char *)opt_benchfile);
    applog(3, tmp42, 1);
    quit(1);
  }
  fclose(benchfile_in);
  benchfile_in = 0;
  return benchfile_get_work(work);
}

//----- (0001A4F8) --------------------------------------------------------
void __cdecl get_benchfile_work(work *work)
{
  double v1; // r2

  benchfile_get_work(work);
  work->mandatory = 1;
  work->pool = *pools;
  cgtime(&work->tv_getwork);
  copy_time(&work->tv_getwork_reply, &work->tv_getwork);
  HIDWORD(v1) = work;
  LODWORD(v1) = 66;
  work->getwork_mode = 66;
  calc_diff(work, v1);
}

//----- (0001A568) --------------------------------------------------------
void __cdecl kill_timeout(thr_info *thr)
{
  cg_completion_timeout(thr_info_cancel, thr, 1000);
}

//----- (0001A58C) --------------------------------------------------------
void kill_mining()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  thr_info *thr; // [sp+804h] [bp+804h]
  pthread_t *pth; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Killing off mining threads");
    applog(7, tmp42, 1);
  }
  for ( i = 0; i < mining_threads; ++i )
  {
    pth = 0;
    thr = get_thread(i);
    if ( thr && thr->pth )
      pth = &thr->pth;
    thr_info_cancel(thr);
    if ( pth )
    {
      if ( *pth )
        pthread_join(*pth, 0);
    }
  }
}

//----- (0001A67C) --------------------------------------------------------
void _kill_work()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  cgpu_info *cgpu; // [sp+804h] [bp+804h]
  thr_info *thr; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]

  if ( successful_connect )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Received kill message");
      applog(6, tmp42, 1);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off watchpool thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[watchpool_thr_id];
    kill_timeout(thr);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off watchdog thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[watchdog_thr_id];
    kill_timeout(thr);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Shutting down mining threads");
      applog(7, tmp42, 1);
    }
    for ( i = 0; i < mining_threads; ++i )
    {
      thr = get_thread(i);
      if ( thr )
      {
        cgpu = thr->cgpu;
        if ( cgpu )
          cgpu->shutdown = 1;
      }
    }
    sleep(1u);
    cg_completion_timeout(kill_mining, 0, 3000);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off API thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[api_thr_id];
    kill_timeout(thr);
  }
}

//----- (0001A958) --------------------------------------------------------
void __noreturn kill_work()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF

  cg_completion_timeout(_kill_work, 0, 5000);
  strcpy((char *)tmp42, "Shutdown signal received.");
  applog(3, tmp42, 1);
  quit(0);
}

//----- (0001A9A8) --------------------------------------------------------
void app_restart()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Attempting to restart %s", (const char *)packagename);
    applog(4, tmp42, 0);
  }
  cg_completion_timeout(_kill_work, 0, 5000);
  clean_up(1);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  execv((const char *)*initial_args, (char *const *)initial_args);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Failed to restart application");
    applog(4, tmp42, 0);
  }
}

//----- (0001AABC) --------------------------------------------------------
void __cdecl __noreturn sighandler(int sig)
{
  sigaction_0(15, &termhandler, 0);
  sigaction_0(2, &inthandler, 0);
  sigaction_0(6, &abrthandler, 0);
  kill_work();
}

//----- (0001AB00) --------------------------------------------------------
void __cdecl modify_ntime(unsigned __int8 *ntime, int noffset)
{
  unsigned __int8 bin[4]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int h32; // [sp+10h] [bp+10h]
  unsigned int *be32; // [sp+14h] [bp+14h]

  be32 = (unsigned int *)bin;
  hex2bin(bin, ntime, 4u);
  h32 = (HIBYTE(*be32) | ((*be32 & 0xFF0000) >> 8) | ((*be32 & 0xFF00) << 8) | (*be32 << 24)) + noffset;
  *be32 = HIBYTE(h32) | ((h32 & 0xFF0000) >> 8) | ((h32 & 0xFF00) << 8) | (h32 << 24);
  _bin2hex(ntime, bin, 4u);
}

//----- (0001AB70) --------------------------------------------------------
void __cdecl roll_work(work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned int ntime; // [sp+808h] [bp+808h]
  unsigned int *work_ntime; // [sp+80Ch] [bp+80Ch]

  work_ntime = (unsigned int *)&work->data[68];
  ntime = ((*work_ntime << 24) | HIBYTE(*work_ntime) | ((*work_ntime & 0xFF0000) >> 8) | ((*work_ntime & 0xFF00) << 8))
        + 1;
  *(_DWORD *)&work->data[68] = HIBYTE(ntime) | ((ntime & 0xFF0000) >> 8) | ((ntime & 0xFF00) << 8) | (ntime << 24);
  ++local_work;
  ++work->rolls;
  work->nonce = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Successfully rolled work");
    applog(7, tmp42, 0);
  }
  if ( work->ntime )
    modify_ntime(work->ntime, 1);
  work->id = total_work_inc();
}

//----- (0001AC98) --------------------------------------------------------
work *__cdecl make_clone(work *work)
{
  work *work_clone; // [sp+Ch] [bp+Ch]

  work_clone = copy_work_noffset(work, 0);
  work_clone->clone = 1;
  cgtime(&work_clone->tv_cloned);
  work_clone->longpoll = 0;
  work_clone->mandatory = 0;
  --work_clone->tv_staged.tv_sec;
  return work_clone;
}

//----- (0001ACE8) --------------------------------------------------------
void *__cdecl submit_work_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0001AD08) --------------------------------------------------------
unsigned __int8 *__cdecl offset_ntime(const unsigned __int8 *ntime, int noffset)
{
  unsigned __int8 bin[4]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int h32; // [sp+10h] [bp+10h]
  unsigned int *be32; // [sp+14h] [bp+14h]

  be32 = (unsigned int *)bin;
  hex2bin(bin, ntime, 4u);
  h32 = (HIBYTE(*be32) | ((*be32 & 0xFF0000) >> 8) | ((*be32 & 0xFF00) << 8) | (*be32 << 24)) + noffset;
  *be32 = HIBYTE(h32) | ((h32 & 0xFF0000) >> 8) | ((h32 & 0xFF00) << 8) | (h32 << 24);
  return bin2hex(bin, 4u);
}

//----- (0001AD7C) --------------------------------------------------------
void __cdecl copy_work(work *work, const work *base_work, int noffset)
{
  unsigned int ntime_0; // [sp+1Ch] [bp+14h]
  unsigned int ntime; // [sp+24h] [bp+1Ch]
  unsigned int id; // [sp+2Ch] [bp+24h]

  id = work->id;
  clean_work(work);
  cg_memcpy(work, base_work, 0x1C0u, "cgminer.c", _func___13252, 4858);
  work->id = id;
  if ( base_work->job_id )
    work->job_id = (unsigned __int8 *)strdup((const char *)base_work->job_id);
  if ( base_work->nonce1 )
    work->nonce1 = (unsigned __int8 *)strdup((const char *)base_work->nonce1);
  if ( base_work->ntime )
  {
    if ( noffset )
    {
      ntime = ((*(_DWORD *)&work->data[68] << 24) | HIBYTE(*(_DWORD *)&work->data[68]) | ((*(_DWORD *)&work->data[68] & 0xFF0000u) >> 8) | ((*(_DWORD *)&work->data[68] & 0xFF00) << 8))
            + noffset;
      *(_DWORD *)&work->data[68] = HIBYTE(ntime) | ((ntime & 0xFF0000) >> 8) | ((ntime & 0xFF00) << 8) | (ntime << 24);
      work->ntime = offset_ntime(base_work->ntime, noffset);
    }
    else
    {
      work->ntime = (unsigned __int8 *)strdup((const char *)base_work->ntime);
    }
  }
  else if ( noffset )
  {
    ntime_0 = ((*(_DWORD *)&work->data[68] << 24) | HIBYTE(*(_DWORD *)&work->data[68]) | ((*(_DWORD *)&work->data[68] & 0xFF0000u) >> 8) | ((*(_DWORD *)&work->data[68] & 0xFF00) << 8))
            + noffset;
    *(_DWORD *)&work->data[68] = HIBYTE(ntime_0) | ((ntime_0 & 0xFF0000) >> 8) | ((ntime_0 & 0xFF00) << 8) | (ntime_0 << 24);
  }
  if ( base_work->coinbase )
    work->coinbase = (unsigned __int8 *)strdup((const char *)base_work->coinbase);
  work->version = base_work->version;
}

//----- (0001AF08) --------------------------------------------------------
void __cdecl set_work_ntime(work *work, int ntime)
{
  const unsigned __int8 *work_ntime; // [sp+Ch] [bp+Ch]

  work_ntime = &work->data[68];
  *(_DWORD *)&work->data[68] = HIBYTE(ntime) | ((ntime & 0xFF0000u) >> 8) | ((ntime & 0xFF00) << 8) | (ntime << 24);
  if ( work->ntime )
  {
    free(work->ntime);
    work->ntime = bin2hex(work_ntime, 4u);
  }
}

//----- (0001AF64) --------------------------------------------------------
work *__cdecl copy_work_noffset(work *base_work, int noffset)
{
  work *work; // [sp+Ch] [bp+Ch]

  work = make_work();
  copy_work(work, base_work, noffset);
  return work;
}

//----- (0001AF8C) --------------------------------------------------------
void __cdecl pool_died(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  if ( !pool_tset(pool, &pool->idle) )
  {
    cgtime(&pool->tv_idle);
    if ( current_pool() == pool )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d %s not responding!", pool->pool_no, (const char *)pool->rpc_url);
        applog(4, tmp42, 0);
      }
      switch_pools(0);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s failed to return work", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
}

//----- (0001B0A0) --------------------------------------------------------
bool __cdecl stale_work(work *work, bool share)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  timeval now; // [sp+808h] [bp+808h] BYREF
  int getwork_delay; // [sp+810h] [bp+810h]
  pool *pool; // [sp+814h] [bp+814h]
  bool same_job; // [sp+81Bh] [bp+81Bh]
  time_t work_expiry; // [sp+81Ch] [bp+81Ch]

  if ( opt_benchmark || opt_benchfile )
    return 0;
  if ( work->work_block != work_block )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to block mismatch");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  if ( work->rolltime <= opt_scantime )
    work_expiry = opt_expiry;
  else
    work_expiry = work->rolltime;
  pool = work->pool;
  if ( share || !pool->has_stratum )
    goto LABEL_33;
  if ( !pool->stratum_active || !pool->stratum_notify )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to stratum inactive");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  same_job = 1;
  cg_rlock_0(&pool->data_lock, "cgminer.c", _func___13293, 4996);
  if ( strcmp((const char *)work->job_id, (const char *)pool->swork.job_id) )
    same_job = 0;
  cg_runlock_0(&pool->data_lock, "cgminer.c", _func___13293, 5003);
  if ( !same_job )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to stratum job_id mismatch");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  else
  {
LABEL_33:
    getwork_delay = (int)(pool->cgminer_pool_stats.getwork_wait_rolling * 5.0 + 1.0);
    work_expiry -= getwork_delay;
    if ( work_expiry <= 4 )
      work_expiry = 5;
    cgtime(&now);
    if ( now.tv_sec - work->tv_staged.tv_sec < work_expiry )
    {
      if ( !opt_fail_only
        || share
        || current_pool() == pool
        || work->mandatory
        || pool_strategy_0 == POOL_LOADBALANCE
        || pool_strategy_0 == POOL_BALANCE )
      {
        return 0;
      }
      else
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Work stale due to fail only pool mismatch");
          applog(7, tmp42, 0);
        }
        return 1;
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Work stale due to expiry");
        applog(7, tmp42, 0);
      }
      return 1;
    }
  }
}

//----- (0001B4B4) --------------------------------------------------------
uint64_t __cdecl share_diff(const work *work)
{
  double v1; // d0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  uint64_t ret; // [sp+810h] [bp+808h]
  double d64; // [sp+818h] [bp+810h]
  double s64; // [sp+820h] [bp+818h]
  bool new_best; // [sp+82Fh] [bp+827h]

  new_best = 0;
  d64 = 2.69595353e67;
  le256todouble(work->hash);
  s64 = v1;
  if ( v1 == 0.0 )
    s64 = 0.0;
  round();
  ret = (unsigned __int64)(d64 / s64);
  cg_wlock_0(&control_lock, "cgminer.c", _func___13304, 5057);
  if ( best_diff < ret )
  {
    new_best = 1;
    best_diff = ret;
    suffix_string(ret, best_share, 8u, 0);
  }
  if ( work->pool->best_diff < ret )
    work->pool->best_diff = ret;
  cg_wunlock_0(&control_lock, "cgminer.c", _func___13304, 5071);
  if ( new_best && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "New best share: %s", (const char *)best_share);
    applog(6, tmp42, 0);
  }
  return ret;
}
// 1B4EA: variable 'v1' is possibly undefined
// A2F8: using guessed type int round(void);

//----- (0001B68C) --------------------------------------------------------
uint64_t __cdecl share_ndiff(const work *work)
{
  double v1; // d0
  uint64_t ret; // [sp+18h] [bp+18h]

  ret = 0LL;
  if ( work )
  {
    le256todouble(work->hash);
    if ( v1 == 0.0 )
      return 0LL;
    else
      return (unsigned __int64)(2.69595353e67 / v1);
  }
  return ret;
}
// 1B6D0: variable 'v1' is possibly undefined

//----- (0001B70C) --------------------------------------------------------
void __cdecl regen_hash(work *work)
{
  unsigned __int8 hash1[32]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 swap[80]; // [sp+28h] [bp+28h] BYREF
  unsigned int *swap32; // [sp+78h] [bp+78h]
  unsigned int *data32; // [sp+7Ch] [bp+7Ch]

  data32 = (unsigned int *)work;
  swap32 = (unsigned int *)swap;
  flip80(swap, work);
  sha256(swap, 0x50u, hash1);
  sha256(hash1, 0x20u, work->hash);
}

//----- (0001B754) --------------------------------------------------------
pool *__cdecl priority_pool(int choice)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  pool *pool; // [sp+80Ch] [bp+80Ch]
  int i; // [sp+810h] [bp+810h]
  pool *ret; // [sp+814h] [bp+814h]

  ret = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    if ( pool->prio == choice )
    {
      ret = pool;
      break;
    }
  }
  if ( ret )
    return ret;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "WTF No pool %d found!", choice);
    applog(3, tmp42, 0);
  }
  return pools[choice];
}

//----- (0001B83C) --------------------------------------------------------
void __cdecl switch_pools(pool *selected)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  pool *pool; // [sp+814h] [bp+80Ch]
  pool *last_pool; // [sp+818h] [bp+810h]
  int next_pool; // [sp+81Ch] [bp+814h]
  int pool_no; // [sp+820h] [bp+818h]
  int i; // [sp+824h] [bp+81Ch]

  cg_wlock_0(&control_lock, "cgminer.c", _func___13339, 5150);
  last_pool = currentpool;
  pool_no = currentpool->pool_no;
  if ( selected && selected->prio )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( pool->prio < selected->prio )
        ++pool->prio;
    }
    selected->prio = 0;
  }
  if ( (unsigned int)pool_strategy_0 <= POOL_BALANCE )
  {
    if ( ((1 << pool_strategy_0) & 0x19) != 0 )
    {
      for ( i = 0; i < total_pools; ++i )
      {
        pool = priority_pool(i);
        if ( !pool_unusable(pool) )
        {
          pool_no = pool->pool_no;
          break;
        }
      }
    }
    else if ( ((1 << pool_strategy_0) & 6) != 0 )
    {
      if ( selected && !selected->idle )
      {
        pool_no = selected->pool_no;
      }
      else
      {
        next_pool = pool_no;
        for ( i = 1; i < total_pools; ++i )
        {
          if ( ++next_pool >= total_pools )
            next_pool = 0;
          pool = pools[next_pool];
          if ( !pool_unusable(pool) )
          {
            pool_no = next_pool;
            break;
          }
        }
      }
    }
  }
  currentpool = pools[pool_no];
  pool = currentpool;
  cg_wunlock_0(&control_lock, "cgminer.c", _func___13339, 5231);
  if ( pool != last_pool && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Switching to pool %d %s", pool->pool_no, (const char *)pool->rpc_url);
      applog(4, tmp42, 0);
    }
    clear_pool_work(last_pool);
  }
  mutex_lock_0(&lp_lock, "cgminer.c", _func___13339, 5239);
  pthread_cond_broadcast(&lp_cond);
  mutex_unlock_0(&lp_lock, "cgminer.c", _func___13339, 5241);
}

//----- (0001BB4C) --------------------------------------------------------
void __cdecl discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  work *work; // [sp+81Ch] [bp+814h]

  work = *workptr;
  if ( work )
  {
    if ( !work->clone && !work->rolls && !work->mined )
    {
      if ( work->pool )
      {
        ++work->pool->discarded_work;
        --work->pool->quota_used;
        --work->pool->works;
      }
      ++total_discarded;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Discarded work");
        applog(7, tmp42, 0);
      }
    }
    else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Discarded cloned or rolled work");
      applog(7, tmp42, 0);
    }
    free_work(workptr, file, func, line);
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Discard work called with NULL work from %s %s:%d",
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (0001BD54) --------------------------------------------------------
void wake_gws()
{
  mutex_lock_0(stgd_lock, "cgminer.c", _func___13372, 5275);
  pthread_cond_signal(&gws_cond);
  mutex_unlock_0(stgd_lock, "cgminer.c", _func___13372, 5277);
}

//----- (0001BDB0) --------------------------------------------------------
void discard_stale()
{
  work *next; // r3
  UT_hash_bucket_0 *v1; // r3
  work *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  work *work; // [sp+804h] [bp+804h] BYREF
  unsigned int _hd_bkt; // [sp+808h] [bp+808h]
  UT_hash_handle *_hd_hh_del; // [sp+80Ch] [bp+80Ch]
  int stale; // [sp+810h] [bp+810h]
  work *tmp; // [sp+814h] [bp+814h]

  stale = 0;
  mutex_lock_0(stgd_lock, "cgminer.c", _func___13379, 5285);
  work = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( stale_work(work, 0) )
    {
      if ( work->hh.prev || work->hh.next )
      {
        _hd_hh_del = &work->hh;
        if ( (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) == work )
          staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
        if ( work->hh.prev )
          *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
        else
          staged_work = (work *)work->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v1 = &staged_work->hh.tbl->buckets[_hd_bkt];
        --v1->count;
        if ( staged_work->hh.tbl->buckets[_hd_bkt].hh_head == _hd_hh_del )
          staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --staged_work->hh.tbl->num_items;
      }
      else
      {
        free(staged_work->hh.tbl->buckets);
        free(staged_work->hh.tbl);
        staged_work = 0;
      }
      discard_work(&work, "cgminer.c", _func___13379, 5292);
      ++stale;
    }
    work = tmp;
    if ( tmp )
      v2 = (work *)tmp->hh.next;
    else
      v2 = 0;
    tmp = v2;
  }
  pthread_cond_signal(&gws_cond);
  mutex_unlock_0(stgd_lock, "cgminer.c", _func___13379, 5298);
  if ( stale && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Discarded %d stales that didn't match current hash", stale);
    applog(7, tmp42, 0);
  }
}

//----- (0001C118) --------------------------------------------------------
int __cdecl restart_wait(thr_info *thr, unsigned int mstime)
{
  timespec abstime; // [sp+Ch] [bp+Ch] BYREF
  timeval now; // [sp+14h] [bp+14h] BYREF
  timeval then; // [sp+1Ch] [bp+1Ch]
  timeval tdiff; // [sp+24h] [bp+24h]
  int rc; // [sp+2Ch] [bp+2Ch]

  tdiff.tv_sec = mstime / 0x3E8;
  tdiff.tv_usec = 1000 * mstime - 1000000 * (mstime / 0x3E8);
  cgtime(&now);
  then.tv_sec = now.tv_sec + tdiff.tv_sec;
  then.tv_usec = now.tv_usec + tdiff.tv_usec;
  if ( now.tv_usec + tdiff.tv_usec > 999999 )
  {
    ++then.tv_sec;
    then.tv_usec -= 1000000;
  }
  abstime.tv_sec = then.tv_sec;
  abstime.tv_nsec = 1000 * then.tv_usec;
  mutex_lock_0(&restart_lock, "cgminer.c", _func___13395, 5328);
  if ( thr->work_restart )
    rc = 0;
  else
    rc = pthread_cond_timedwait(&restart_cond, &restart_lock, &abstime);
  mutex_unlock_0(&restart_lock, "cgminer.c", _func___13395, 5338);
  return rc;
}

//----- (0001C214) --------------------------------------------------------
void *__cdecl restart_thread_0(void *arg)
{
  pthread_t v1; // r0
  cgpu_info *cgpu; // [sp+Ch] [bp+Ch]
  int mt; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  v1 = pthread_self();
  pthread_detach(v1);
  discard_stale();
  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___13402, 5351);
  mt = mining_threads;
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___13402, 5353);
  for ( i = 0; i < mt; ++i )
  {
    cgpu = mining_thr[i]->cgpu;
    if ( cgpu && cgpu->deven == DEV_ENABLED )
    {
      mining_thr[i]->work_restart = 1;
      flush_queue(cgpu);
      cgpu->drv->flush_work(cgpu);
    }
  }
  mutex_lock_0(&restart_lock, "cgminer.c", _func___13402, 5374);
  pthread_cond_broadcast(&restart_cond);
  mutex_unlock_0(&restart_lock, "cgminer.c", _func___13402, 5376);
  return 0;
}

//----- (0001C338) --------------------------------------------------------
void restart_threads()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  pthread_t rthread; // [sp+804h] [bp+804h] BYREF

  cgtime(&restart_tv_start);
  if ( pthread_create(&rthread, 0, (void *(*)(void *))restart_thread_0, 0) )
  {
    strcpy((char *)tmp42, "Failed to create restart thread");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001C3A0) --------------------------------------------------------
void signal_work_update()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+804h] [bp+804h]

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    strcpy((char *)tmp42, "Work update message received");
    applog(6, tmp42, 0);
  }
  cgtime(&update_tv_start);
  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___13417, 5409);
  for ( i = 0; i < mining_threads; ++i )
    mining_thr[i]->work_update = 1;
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___13417, 5416);
}

//----- (0001C490) --------------------------------------------------------
void __cdecl set_curblock(const unsigned __int8 *hexstr, const unsigned __int8 *bedata)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int ofs; // [sp+814h] [bp+80Ch]

  cg_wlock_0(&ch_lock, "cgminer.c", _func___13426, 5423);
  cgtime(&block_timeval);
  strcpy((char *)current_hash, (const char *)hexstr);
  cg_memcpy(current_block, bedata, 0x20u, "cgminer.c", _func___13426, 5426);
  get_timestamp(blocktime, 0x20u, &block_timeval);
  cg_wunlock_0(&ch_lock, "cgminer.c", _func___13426, 5428);
  for ( ofs = 0; ofs <= 56 && current_hash[ofs] == (unsigned __int8)a0[0]; ++ofs )
    ;
  strncpy((char *)prev_block, (const char *)&current_hash[ofs], 8u);
  prev_block[8] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "New block: %s... diff %s", (const char *)current_hash, (const char *)block_diff);
    applog(6, tmp42, 0);
  }
}

//----- (0001C60C) --------------------------------------------------------
int __cdecl block_sort(block *blocka, block *blockb)
{
  return blocka->block_no - blockb->block_no;
}

//----- (0001C62C) --------------------------------------------------------
void __cdecl set_blockdiff(const work *work)
{
  unsigned __int64 v1; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  double ddiff; // [sp+810h] [bp+808h]
  double numerator; // [sp+818h] [bp+810h]
  unsigned int diff32; // [sp+824h] [bp+81Ch]
  unsigned __int8 pow; // [sp+82Bh] [bp+823h]
  int powdiff; // [sp+82Ch] [bp+824h]

  pow = work->data[72];
  powdiff = 8 * (29 - pow);
  if ( powdiff <= 7 )
    powdiff = 8;
  diff32 = (HIBYTE(*(_DWORD *)&work->data[72]) | ((*(_DWORD *)&work->data[72] & 0xFF0000u) >> 8) | ((*(_DWORD *)&work->data[72] & 0xFF00) << 8)) & 0xFFFFFF;
  LODWORD(v1) = 0xFFFF << powdiff;
  HIDWORD(v1) = (0xFFFF << (powdiff - 32)) | (0xFFFFu >> (32 - powdiff));
  numerator = (double)v1;
  ddiff = (double)v1 / (double)diff32;
  if ( current_diff != ddiff )
  {
    suffix_string((unsigned __int64)ddiff, block_diff, 8u, 0);
    current_diff = ddiff;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Network diff set to %s", (const char *)block_diff);
      applog(5, tmp42, 0);
    }
  }
}

//----- (0001C79C) --------------------------------------------------------
bool __cdecl block_exists(const unsigned __int8 *hexstr, const unsigned __int8 *bedata, const work *work)
{
  size_t v3; // r0
  unsigned int v4; // r1
  UT_hash_handle *v5; // r3
  UT_hash_handle *v6; // r3
  UT_hash_handle *v7; // r3
  UT_hash_handle *v8; // r3
  UT_hash_handle *v9; // r3
  char *v10; // r3
  char *v11; // r3
  UT_hash_bucket_0 *v12; // r3
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v14; // r3
  unsigned int v15; // r3
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  UT_hash_bucket_0 *_he_newbkt; // [sp+81Ch] [bp+814h]
  unsigned int _he_bkt; // [sp+820h] [bp+818h]
  UT_hash_handle *_he_hh_nxt; // [sp+824h] [bp+81Ch]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+828h] [bp+820h]
  unsigned int _ha_bkt; // [sp+82Ch] [bp+824h]
  unsigned int _hd_bkt; // [sp+830h] [bp+828h]
  UT_hash_handle *_hd_hh_del; // [sp+834h] [bp+82Ch]
  block *oldblock; // [sp+838h] [bp+830h]
  unsigned int _hf_bkt; // [sp+83Ch] [bp+834h]
  UT_hash_handle *_he_thh; // [sp+840h] [bp+838h]
  unsigned int _he_bkt_i; // [sp+844h] [bp+83Ch]
  const unsigned __int8 *_hj_key_0; // [sp+848h] [bp+840h]
  unsigned int _hj_k_0; // [sp+84Ch] [bp+844h]
  unsigned int _hj_j_0; // [sp+850h] [bp+848h]
  unsigned int _hj_i_0; // [sp+854h] [bp+84Ch]
  unsigned int _ha_hashv; // [sp+858h] [bp+850h]
  UT_hash_handle *_hs_tail; // [sp+85Ch] [bp+854h]
  UT_hash_handle *_hs_list; // [sp+860h] [bp+858h]
  UT_hash_handle *_hs_e; // [sp+864h] [bp+85Ch]
  UT_hash_handle *_hs_q; // [sp+868h] [bp+860h]
  UT_hash_handle *_hs_p; // [sp+86Ch] [bp+864h]
  unsigned int _hs_qsize; // [sp+870h] [bp+868h]
  unsigned int _hs_psize; // [sp+874h] [bp+86Ch]
  unsigned int _hs_insize; // [sp+878h] [bp+870h]
  unsigned int _hs_nmerges; // [sp+87Ch] [bp+874h]
  unsigned int _hs_looping; // [sp+880h] [bp+878h]
  unsigned int _hs_i; // [sp+884h] [bp+87Ch]
  const unsigned __int8 *_hj_key; // [sp+888h] [bp+880h]
  unsigned int _hj_k; // [sp+88Ch] [bp+884h]
  unsigned int _hj_j; // [sp+890h] [bp+888h]
  unsigned int _hj_i; // [sp+894h] [bp+88Ch]
  unsigned int _hf_hashv; // [sp+898h] [bp+890h]
  bool ret; // [sp+89Fh] [bp+897h]
  block *s; // [sp+8A0h] [bp+898h]
  int deleted_block; // [sp+8A4h] [bp+89Ch]

  deleted_block = 0;
  ret = 1;
  wr_lock_0(&blk_lock, "cgminer.c", _func___13454, 5478);
  _hj_key = hexstr;
  _hf_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)hexstr); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_i += *_hj_key + (_hj_key[1] << 8) + (_hj_key[2] << 16) + (_hj_key[3] << 24);
    _hj_j += _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16) + (_hj_key[7] << 24);
    _hf_hashv += _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16) + (_hj_key[11] << 24);
    _hj_i = (_hf_hashv >> 13) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 8) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 13) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_i = (_hf_hashv >> 12) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 16) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 5) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_i = (_hf_hashv >> 3) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 10) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 15) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_key += 12;
  }
  _hf_hashv += strlen((const char *)hexstr);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      goto LABEL_9;
    case 8u:
      goto LABEL_8;
    case 9u:
      goto LABEL_7;
    case 0xAu:
      goto LABEL_6;
    case 0xBu:
      _hf_hashv += _hj_key[10] << 24;
LABEL_6:
      _hf_hashv += _hj_key[9] << 16;
LABEL_7:
      _hf_hashv += _hj_key[8] << 8;
LABEL_8:
      _hj_j += _hj_key[7] << 24;
LABEL_9:
      _hj_j += _hj_key[6] << 16;
LABEL_10:
      _hj_j += _hj_key[5] << 8;
LABEL_11:
      _hj_j += _hj_key[4];
LABEL_12:
      _hj_i += _hj_key[3] << 24;
LABEL_13:
      _hj_i += _hj_key[2] << 16;
LABEL_14:
      _hj_i += _hj_key[1] << 8;
LABEL_15:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_i = (_hf_hashv >> 13) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 8) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 13) ^ (_hf_hashv - _hj_i - _hj_j);
  _hj_i = (_hf_hashv >> 12) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 16) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 5) ^ (_hf_hashv - _hj_i - _hj_j);
  _hj_i = (_hf_hashv >> 3) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 10) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 15) ^ (_hf_hashv - _hj_i - _hj_j);
  s = 0;
  if ( blocks )
  {
    _hf_bkt = _hf_hashv & (blocks->hh.tbl->num_buckets - 1);
    if ( blocks->hh.tbl->buckets[_hf_bkt].hh_head )
      s = (block *)((char *)blocks->hh.tbl->buckets[_hf_bkt].hh_head - blocks->hh.tbl->hho);
    else
      s = 0;
    while ( s )
    {
      if ( s->hh.hashv == _hf_hashv && s->hh.keylen == strlen((const char *)hexstr) )
      {
        v3 = strlen((const char *)hexstr);
        if ( !memcmp(s->hh.key, hexstr, v3) )
          break;
      }
      if ( s->hh.hh_next )
        s = (block *)((char *)s->hh.hh_next - blocks->hh.tbl->hho);
      else
        s = 0;
    }
  }
  if ( !s )
  {
    s = (block *)cgcalloc(104, 1u, "cgminer.c", _func___13454, 5482);
    if ( !s )
    {
      strcpy((char *)tmp42, "block_exists OOM");
      applog(3, tmp42, 1);
      quit(1);
    }
    strcpy((char *)s, (const char *)hexstr);
    v4 = new_blocks;
    s->block_no = new_blocks;
    new_blocks = v4 + 1;
    ret = 0;
    if ( blocks && blocks->hh.tbl->num_items > 3 )
    {
      if ( blocks )
      {
        _hs_insize = 1;
        _hs_looping = 1;
        _hs_list = &blocks->hh;
        while ( _hs_looping )
        {
          _hs_p = _hs_list;
          _hs_list = 0;
          _hs_tail = 0;
          _hs_nmerges = 0;
          while ( _hs_p )
          {
            ++_hs_nmerges;
            _hs_q = _hs_p;
            _hs_psize = 0;
            for ( _hs_i = 0; _hs_i < _hs_insize; ++_hs_i )
            {
              ++_hs_psize;
              v5 = _hs_q->next ? (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho) : 0;
              _hs_q = v5;
              if ( !v5 )
                break;
            }
            _hs_qsize = _hs_insize;
            while ( _hs_psize || _hs_qsize && _hs_q )
            {
              if ( _hs_psize )
              {
                if ( _hs_qsize && _hs_q )
                {
                  if ( block_sort(
                         (block *)((char *)_hs_p - blocks->hh.tbl->hho),
                         (block *)((char *)_hs_q - blocks->hh.tbl->hho)) > 0 )
                  {
                    _hs_e = _hs_q;
                    if ( _hs_q->next )
                      v9 = (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho);
                    else
                      v9 = 0;
                    _hs_q = v9;
                    --_hs_qsize;
                  }
                  else
                  {
                    _hs_e = _hs_p;
                    if ( _hs_p )
                    {
                      if ( _hs_p->next )
                        v8 = (UT_hash_handle *)((char *)_hs_p->next + blocks->hh.tbl->hho);
                      else
                        v8 = 0;
                      _hs_p = v8;
                    }
                    --_hs_psize;
                  }
                }
                else
                {
                  _hs_e = _hs_p;
                  if ( _hs_p )
                  {
                    if ( _hs_p->next )
                      v7 = (UT_hash_handle *)((char *)_hs_p->next + blocks->hh.tbl->hho);
                    else
                      v7 = 0;
                    _hs_p = v7;
                  }
                  --_hs_psize;
                }
              }
              else
              {
                _hs_e = _hs_q;
                if ( _hs_q->next )
                  v6 = (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho);
                else
                  v6 = 0;
                _hs_q = v6;
                --_hs_qsize;
              }
              if ( _hs_tail )
              {
                if ( _hs_e )
                  v10 = (char *)_hs_e - blocks->hh.tbl->hho;
                else
                  v10 = 0;
                _hs_tail->next = v10;
              }
              else
              {
                _hs_list = _hs_e;
              }
              if ( _hs_e )
              {
                if ( _hs_tail )
                  v11 = (char *)_hs_tail - blocks->hh.tbl->hho;
                else
                  v11 = 0;
                _hs_e->prev = v11;
              }
              _hs_tail = _hs_e;
            }
            _hs_p = _hs_q;
          }
          if ( _hs_tail )
            _hs_tail->next = 0;
          if ( _hs_nmerges <= 1 )
          {
            _hs_looping = 0;
            blocks->hh.tbl->tail = _hs_tail;
            blocks = (block *)((char *)_hs_list - blocks->hh.tbl->hho);
          }
          _hs_insize *= 2;
        }
      }
      oldblock = blocks;
      deleted_block = blocks->block_no;
      if ( blocks->hh.prev || oldblock->hh.next )
      {
        _hd_hh_del = &oldblock->hh;
        if ( (block *)((char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho) == oldblock )
          blocks->hh.tbl->tail = (UT_hash_handle *)((char *)oldblock->hh.prev + blocks->hh.tbl->hho);
        if ( oldblock->hh.prev )
          *(_DWORD *)((char *)oldblock->hh.prev + blocks->hh.tbl->hho + 8) = oldblock->hh.next;
        else
          blocks = (block *)oldblock->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + blocks->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (blocks->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v12 = &blocks->hh.tbl->buckets[_hd_bkt];
        --v12->count;
        if ( blocks->hh.tbl->buckets[_hd_bkt].hh_head == _hd_hh_del )
          blocks->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --blocks->hh.tbl->num_items;
      }
      else
      {
        free(blocks->hh.tbl->buckets);
        free(blocks->hh.tbl);
        blocks = 0;
      }
      free(oldblock);
    }
    _hj_key_0 = (const unsigned __int8 *)s;
    _ha_hashv = -17973521;
    _hj_j_0 = -1640531527;
    _hj_i_0 = -1640531527;
    for ( _hj_k_0 = strlen((const char *)s); _hj_k_0 > 0xB; _hj_k_0 -= 12 )
    {
      _hj_i_0 += *_hj_key_0 + (_hj_key_0[1] << 8) + (_hj_key_0[2] << 16) + (_hj_key_0[3] << 24);
      _hj_j_0 += _hj_key_0[4] + (_hj_key_0[5] << 8) + (_hj_key_0[6] << 16) + (_hj_key_0[7] << 24);
      _ha_hashv += _hj_key_0[8] + (_hj_key_0[9] << 8) + (_hj_key_0[10] << 16) + (_hj_key_0[11] << 24);
      _hj_i_0 = (_ha_hashv >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 8) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 13) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_i_0 = (_ha_hashv >> 12) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 16) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 5) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_i_0 = (_ha_hashv >> 3) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_key_0 += 12;
    }
    _ha_hashv += strlen((const char *)s);
    switch ( _hj_k_0 )
    {
      case 1u:
        goto LABEL_122;
      case 2u:
        goto LABEL_121;
      case 3u:
        goto LABEL_120;
      case 4u:
        goto LABEL_119;
      case 5u:
        goto LABEL_118;
      case 6u:
        goto LABEL_117;
      case 7u:
        goto LABEL_116;
      case 8u:
        goto LABEL_115;
      case 9u:
        goto LABEL_114;
      case 0xAu:
        goto LABEL_113;
      case 0xBu:
        _ha_hashv += _hj_key_0[10] << 24;
LABEL_113:
        _ha_hashv += _hj_key_0[9] << 16;
LABEL_114:
        _ha_hashv += _hj_key_0[8] << 8;
LABEL_115:
        _hj_j_0 += _hj_key_0[7] << 24;
LABEL_116:
        _hj_j_0 += _hj_key_0[6] << 16;
LABEL_117:
        _hj_j_0 += _hj_key_0[5] << 8;
LABEL_118:
        _hj_j_0 += _hj_key_0[4];
LABEL_119:
        _hj_i_0 += _hj_key_0[3] << 24;
LABEL_120:
        _hj_i_0 += _hj_key_0[2] << 16;
LABEL_121:
        _hj_i_0 += _hj_key_0[1] << 8;
LABEL_122:
        _hj_i_0 += *_hj_key_0;
        break;
      default:
        break;
    }
    _hj_i_0 = (_ha_hashv >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 8) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 13) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    _hj_i_0 = (_ha_hashv >> 12) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 16) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 5) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    _hj_i_0 = (_ha_hashv >> 3) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    s->hh.hashv = _ha_hashv;
    s->hh.key = s;
    s->hh.keylen = strlen((const char *)s);
    if ( blocks )
    {
      s->hh.tbl = blocks->hh.tbl;
      s->hh.next = 0;
      s->hh.prev = (char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho;
      blocks->hh.tbl->tail->next = s;
      blocks->hh.tbl->tail = &s->hh;
    }
    else
    {
      s->hh.next = 0;
      s->hh.prev = 0;
      blocks = s;
      s->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !blocks->hh.tbl )
        exit(-1);
      memset(blocks->hh.tbl, 0, sizeof(UT_hash_table));
      blocks->hh.tbl->tail = &blocks->hh;
      blocks->hh.tbl->num_buckets = 32;
      blocks->hh.tbl->log2_num_buckets = 5;
      blocks->hh.tbl->hho = 68;
      tbl = blocks->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !blocks->hh.tbl->buckets )
        exit(-1);
      memset(blocks->hh.tbl->buckets, 0, 0x180u);
      blocks->hh.tbl->signature = -1609490463;
    }
    ++blocks->hh.tbl->num_items;
    _ha_bkt = _ha_hashv & (blocks->hh.tbl->num_buckets - 1);
    v14 = &blocks->hh.tbl->buckets[_ha_bkt];
    ++v14->count;
    s->hh.hh_next = blocks->hh.tbl->buckets[_ha_bkt].hh_head;
    s->hh.hh_prev = 0;
    if ( blocks->hh.tbl->buckets[_ha_bkt].hh_head )
      blocks->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &s->hh;
    blocks->hh.tbl->buckets[_ha_bkt].hh_head = &s->hh;
    if ( blocks->hh.tbl->buckets[_ha_bkt].count >= 10 * (blocks->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && s->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * s->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * s->hh.tbl->num_buckets);
      s->hh.tbl->ideal_chain_maxlen = (s->hh.tbl->num_items >> (s->hh.tbl->log2_num_buckets + 1))
                                    + (((2 * s->hh.tbl->num_buckets - 1) & s->hh.tbl->num_items) != 0);
      s->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; s->hh.tbl->num_buckets > _he_bkt_i; ++_he_bkt_i )
      {
        for ( _he_thh = s->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_bkt = (2 * s->hh.tbl->num_buckets - 1) & _he_thh->hashv;
          _he_newbkt = &_he_new_buckets[_he_bkt];
          if ( ++_he_newbkt->count > s->hh.tbl->ideal_chain_maxlen )
          {
            ++s->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / s->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(s->hh.tbl->buckets);
      s->hh.tbl->num_buckets *= 2;
      ++s->hh.tbl->log2_num_buckets;
      s->hh.tbl->buckets = _he_new_buckets;
      if ( s->hh.tbl->nonideal_items <= s->hh.tbl->num_items >> 1 )
        v15 = 0;
      else
        v15 = s->hh.tbl->ineff_expands + 1;
      s->hh.tbl->ineff_expands = v15;
      if ( s->hh.tbl->ineff_expands > 1 )
        s->hh.tbl->noexpand = 1;
    }
    set_blockdiff(work);
    if ( deleted_block && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", deleted_block);
      applog(7, tmp42, 0);
    }
  }
  wr_unlock(&blk_lock, "cgminer.c", _func___13454, 5516);
  if ( !ret )
    set_curblock(hexstr, bedata);
  if ( deleted_block && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", deleted_block);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (0001DF54) --------------------------------------------------------
bool __cdecl test_work_current(work *work)
{
  const char *v2; // r3
  pool *v3; // r4
  const char *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned int height; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 hexstr[68]; // [sp+814h] [bp+80Ch] BYREF
  unsigned __int8 bedata[32]; // [sp+858h] [bp+850h] BYREF
  unsigned __int8 cb_height_sz; // [sp+87Bh] [bp+873h]
  unsigned __int8 *bin_height; // [sp+87Ch] [bp+874h]
  pool *pool; // [sp+880h] [bp+878h]
  bool ret; // [sp+887h] [bp+87Fh]

  pool = work->pool;
  ret = 1;
  bin_height = pool->coinbase + 43;
  cb_height_sz = *(bin_height - 1);
  height = 0;
  if ( !work->mandatory )
  {
    swap256(bedata, &work->data[4]);
    _bin2hex(hexstr, bedata, 0x20u);
    if ( cb_height_sz <= 4u )
    {
      cg_memcpy(&height, bin_height, cb_height_sz, "cgminer.c", _func___13549, 5552);
      --height;
    }
    cg_wlock_0(&pool->data_lock, "cgminer.c", _func___13549, 5557);
    if ( pool->swork.clean )
    {
      pool->swork.clean = 0;
      work->longpoll = 1;
    }
    cg_wunlock_0(&pool->data_lock, "cgminer.c", _func___13549, 5565);
    if ( !block_exists(hexstr, bedata, work) )
    {
      cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", _func___13549, 5573);
      if ( new_blocks == 1 )
      {
        ret = 0;
out:
        work->longpoll = 0;
        return ret;
      }
      work->work_block = ++work_block;
      if ( work->longpoll )
      {
        if ( work->stratum )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Stratum from pool %d detected new block at height %d",
              pool->pool_no,
              height);
            applog(5, tmp42, 0);
          }
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          if ( work->gbt )
            v2 = "GBT ";
          else
            v2 = &byte_71100;
          snprintf((char *)tmp42, 0x800u, "%sLONGPOLL from pool %d detected new block", v2, work->pool->pool_no);
          applog(5, tmp42, 0);
        }
      }
      else if ( have_longpoll && !pool->gbt_solo )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy((char *)tmp42, "New block detected on network before pool notification");
          applog(5, tmp42, 0);
        }
      }
      else if ( !pool->gbt_solo && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        strcpy((char *)tmp42, "New block detected on network");
        applog(5, tmp42, 0);
      }
    }
    else
    {
      if ( memcmp(pool->prev_block, bedata, 0x20u) )
      {
        if ( !memcmp(bedata, current_block, 0x20u) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "Pool %d now up to date at height %d", pool->pool_no, height);
            applog(6, tmp42, 0);
          }
          cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", _func___13549, 5623);
        }
        else
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "Stale data from pool %d at height %d", pool->pool_no, height);
            applog(7, tmp42, 0);
          }
          ret = 0;
        }
      }
      if ( !work->longpoll )
        goto out;
      work->work_block = ++work_block;
      if ( !shared_strategy() )
      {
        v3 = work->pool;
        if ( v3 != current_pool() )
          goto out;
      }
      if ( work->stratum )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Stratum from pool %d requested work restart", pool->pool_no);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( work->gbt )
          v4 = "GBT ";
        else
          v4 = &byte_71100;
        snprintf((char *)tmp42, 0x800u, "%sLONGPOLL from pool %d requested work restart", v4, work->pool->pool_no);
        applog(5, tmp42, 0);
      }
    }
    restart_threads();
    goto out;
  }
  return ret;
}
// 71100: using guessed type char byte_71100;

//----- (0001E558) --------------------------------------------------------
int __cdecl tv_sort(work *worka, work *workb)
{
  return worka->tv_staged.tv_sec - workb->tv_staged.tv_sec;
}

//----- (0001E57C) --------------------------------------------------------
bool __cdecl work_rollable(work *work)
{
  return !work->clone && work->rolltime;
}
// 1E5AA: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (0001E5B8) --------------------------------------------------------
bool __cdecl hash_push(work *work)
{
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v2; // r3
  unsigned int v3; // r3
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  char *v9; // r3
  char *v10; // r3
  UT_hash_bucket_0 *_he_newbkt; // [sp+8h] [bp+8h]
  UT_hash_handle *_he_hh_nxt; // [sp+10h] [bp+10h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+14h] [bp+14h]
  unsigned int _ha_bkt; // [sp+18h] [bp+18h]
  UT_hash_handle *_hs_tail; // [sp+1Ch] [bp+1Ch]
  UT_hash_handle *_hs_list; // [sp+20h] [bp+20h]
  UT_hash_handle *_hs_e; // [sp+24h] [bp+24h]
  UT_hash_handle *_hs_q; // [sp+28h] [bp+28h]
  UT_hash_handle *_hs_p; // [sp+2Ch] [bp+2Ch]
  unsigned int _hs_qsize; // [sp+30h] [bp+30h]
  unsigned int _hs_psize; // [sp+34h] [bp+34h]
  unsigned int _hs_insize; // [sp+38h] [bp+38h]
  unsigned int _hs_nmerges; // [sp+3Ch] [bp+3Ch]
  unsigned int _hs_looping; // [sp+40h] [bp+40h]
  unsigned int _hs_i; // [sp+44h] [bp+44h]
  UT_hash_handle *_he_thh; // [sp+48h] [bp+48h]
  unsigned int _he_bkt_i; // [sp+4Ch] [bp+4Ch]
  unsigned int _hj_j; // [sp+58h] [bp+58h]
  unsigned int _hj_ja; // [sp+58h] [bp+58h]
  int _hj_i; // [sp+5Ch] [bp+5Ch]
  int _hj_ia; // [sp+5Ch] [bp+5Ch]
  int _hj_ib; // [sp+5Ch] [bp+5Ch]
  unsigned int _ha_hashva; // [sp+60h] [bp+60h]
  unsigned int _ha_hashvb; // [sp+60h] [bp+60h]
  unsigned int _ha_hashv; // [sp+60h] [bp+60h]
  bool rc; // [sp+67h] [bp+67h]

  rc = 1;
  mutex_lock_0(stgd_lock, "cgminer.c", _func___13570, 5679);
  if ( work_rollable(work) )
    ++staged_rollable;
  if ( !getq->frozen )
  {
    _hj_i = ((HIBYTE(work->id) << 24) + (BYTE2(work->id) << 16) + (BYTE1(work->id) << 8) + LOBYTE(work->id) + 17973517) ^ 0x7F76D;
    _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
    _ha_hashva = (_hj_j >> 13) ^ (-17973517 - _hj_i - _hj_j);
    _hj_ia = (_ha_hashva >> 12) ^ (_hj_i - _hj_j - _ha_hashva);
    _hj_ja = (_hj_ia << 16) ^ (_hj_j - _ha_hashva - _hj_ia);
    _ha_hashvb = (_hj_ja >> 5) ^ (_ha_hashva - _hj_ia - _hj_ja);
    _hj_ib = (_ha_hashvb >> 3) ^ (_hj_ia - _hj_ja - _ha_hashvb);
    _ha_hashv = (((_hj_ib << 10) ^ (_hj_ja - _ha_hashvb - _hj_ib)) >> 15) ^ (_ha_hashvb
                                                                           - _hj_ib
                                                                           - ((_hj_ib << 10) ^ (_hj_ja
                                                                                              - _ha_hashvb
                                                                                              - _hj_ib)));
    work->hh.hashv = _ha_hashv;
    work->hh.key = &work->id;
    work->hh.keylen = 4;
    if ( staged_work )
    {
      work->hh.tbl = staged_work->hh.tbl;
      work->hh.next = 0;
      work->hh.prev = (char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho;
      staged_work->hh.tbl->tail->next = work;
      staged_work->hh.tbl->tail = &work->hh;
    }
    else
    {
      work->hh.next = 0;
      work->hh.prev = 0;
      staged_work = work;
      work->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !staged_work->hh.tbl )
        exit(-1);
      memset(staged_work->hh.tbl, 0, sizeof(UT_hash_table));
      staged_work->hh.tbl->tail = &staged_work->hh;
      staged_work->hh.tbl->num_buckets = 32;
      staged_work->hh.tbl->log2_num_buckets = 5;
      staged_work->hh.tbl->hho = 344;
      tbl = staged_work->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !staged_work->hh.tbl->buckets )
        exit(-1);
      memset(staged_work->hh.tbl->buckets, 0, 0x180u);
      staged_work->hh.tbl->signature = -1609490463;
    }
    ++staged_work->hh.tbl->num_items;
    _ha_bkt = _ha_hashv & (staged_work->hh.tbl->num_buckets - 1);
    v2 = &staged_work->hh.tbl->buckets[_ha_bkt];
    ++v2->count;
    work->hh.hh_next = staged_work->hh.tbl->buckets[_ha_bkt].hh_head;
    work->hh.hh_prev = 0;
    if ( staged_work->hh.tbl->buckets[_ha_bkt].hh_head )
      staged_work->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &work->hh;
    staged_work->hh.tbl->buckets[_ha_bkt].hh_head = &work->hh;
    if ( staged_work->hh.tbl->buckets[_ha_bkt].count >= 10 * (staged_work->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && work->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * work->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * work->hh.tbl->num_buckets);
      work->hh.tbl->ideal_chain_maxlen = (work->hh.tbl->num_items >> (work->hh.tbl->log2_num_buckets + 1))
                                       + (((2 * work->hh.tbl->num_buckets - 1) & work->hh.tbl->num_items) != 0);
      work->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; work->hh.tbl->num_buckets > _he_bkt_i; ++_he_bkt_i )
      {
        for ( _he_thh = work->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_newbkt = &_he_new_buckets[(2 * work->hh.tbl->num_buckets - 1) & _he_thh->hashv];
          if ( ++_he_newbkt->count > work->hh.tbl->ideal_chain_maxlen )
          {
            ++work->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / work->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(work->hh.tbl->buckets);
      work->hh.tbl->num_buckets *= 2;
      ++work->hh.tbl->log2_num_buckets;
      work->hh.tbl->buckets = _he_new_buckets;
      if ( work->hh.tbl->nonideal_items <= work->hh.tbl->num_items >> 1 )
        v3 = 0;
      else
        v3 = work->hh.tbl->ineff_expands + 1;
      work->hh.tbl->ineff_expands = v3;
      if ( work->hh.tbl->ineff_expands > 1 )
        work->hh.tbl->noexpand = 1;
    }
    if ( staged_work )
    {
      _hs_insize = 1;
      _hs_looping = 1;
      _hs_list = &staged_work->hh;
      while ( _hs_looping )
      {
        _hs_p = _hs_list;
        _hs_list = 0;
        _hs_tail = 0;
        _hs_nmerges = 0;
        while ( _hs_p )
        {
          ++_hs_nmerges;
          _hs_q = _hs_p;
          _hs_psize = 0;
          for ( _hs_i = 0; _hs_i < _hs_insize; ++_hs_i )
          {
            ++_hs_psize;
            v4 = _hs_q->next ? (int)_hs_q->next + staged_work->hh.tbl->hho : 0;
            _hs_q = (UT_hash_handle *)v4;
            if ( !v4 )
              break;
          }
          _hs_qsize = _hs_insize;
          while ( _hs_psize || _hs_qsize && _hs_q )
          {
            if ( _hs_psize )
            {
              if ( _hs_qsize && _hs_q )
              {
                if ( tv_sort(
                       (work *)((char *)_hs_p - staged_work->hh.tbl->hho),
                       (work *)((char *)_hs_q - staged_work->hh.tbl->hho)) > 0 )
                {
                  _hs_e = _hs_q;
                  if ( _hs_q->next )
                    v8 = (int)_hs_q->next + staged_work->hh.tbl->hho;
                  else
                    v8 = 0;
                  _hs_q = (UT_hash_handle *)v8;
                  --_hs_qsize;
                }
                else
                {
                  _hs_e = _hs_p;
                  if ( _hs_p )
                  {
                    if ( _hs_p->next )
                      v7 = (int)_hs_p->next + staged_work->hh.tbl->hho;
                    else
                      v7 = 0;
                    _hs_p = (UT_hash_handle *)v7;
                  }
                  --_hs_psize;
                }
              }
              else
              {
                _hs_e = _hs_p;
                if ( _hs_p )
                {
                  if ( _hs_p->next )
                    v6 = (int)_hs_p->next + staged_work->hh.tbl->hho;
                  else
                    v6 = 0;
                  _hs_p = (UT_hash_handle *)v6;
                }
                --_hs_psize;
              }
            }
            else
            {
              _hs_e = _hs_q;
              if ( _hs_q->next )
                v5 = (int)_hs_q->next + staged_work->hh.tbl->hho;
              else
                v5 = 0;
              _hs_q = (UT_hash_handle *)v5;
              --_hs_qsize;
            }
            if ( _hs_tail )
            {
              if ( _hs_e )
                v9 = (char *)_hs_e - staged_work->hh.tbl->hho;
              else
                v9 = 0;
              _hs_tail->next = v9;
            }
            else
            {
              _hs_list = _hs_e;
            }
            if ( _hs_e )
            {
              if ( _hs_tail )
                v10 = (char *)_hs_tail - staged_work->hh.tbl->hho;
              else
                v10 = 0;
              _hs_e->prev = v10;
            }
            _hs_tail = _hs_e;
          }
          _hs_p = _hs_q;
        }
        if ( _hs_tail )
          _hs_tail->next = 0;
        if ( _hs_nmerges <= 1 )
        {
          _hs_looping = 0;
          staged_work->hh.tbl->tail = _hs_tail;
          staged_work = (work *)((char *)_hs_list - staged_work->hh.tbl->hho);
        }
        _hs_insize *= 2;
      }
    }
  }
  else
  {
    rc = 0;
  }
  pthread_cond_broadcast(&getq->cond);
  mutex_unlock_0(stgd_lock, "cgminer.c", _func___13570, 5697);
  return rc;
}
// 1E7C6: conditional instruction was optimized away because %_hj_k.4==4

//----- (0001F128) --------------------------------------------------------
void __cdecl stage_work(work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Pushing work from pool %d to hash queue", work->pool->pool_no);
    applog(7, tmp42, 0);
  }
  work->work_block = work_block;
  test_work_current(work);
  ++work->pool->works;
  hash_push(work);
}

//----- (0001F1D8) --------------------------------------------------------
void __cdecl remove_pool(pool *pool)
{
  pool *other; // [sp+Ch] [bp+Ch]
  int last_pool; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  last_pool = total_pools - 1;
  for ( i = 0; i < total_pools; ++i )
  {
    other = pools[i];
    if ( other->prio > pool->prio )
      --other->prio;
  }
  if ( pool->pool_no < last_pool )
  {
    pools[last_pool]->pool_no = pool->pool_no;
    pools[pool->pool_no] = pools[last_pool];
  }
  pool->pool_no = total_pools;
  pool->removed = 1;
  --total_pools;
}

//----- (0001F2B4) --------------------------------------------------------
void json_escape_free()
{
  JE *jenext; // [sp+0h] [bp+0h]
  JE *jeptr; // [sp+4h] [bp+4h]

  jeptr = jedata;
  jedata = 0;
  while ( jeptr )
  {
    jenext = jeptr->next;
    free(jeptr->buf);
    free(jeptr);
    jeptr = jenext;
  }
}

//----- (0001F2FC) --------------------------------------------------------
unsigned __int8 *__cdecl json_escape(unsigned __int8 *str)
{
  size_t v1; // r0
  JE *v2; // r0
  unsigned __int8 *stra; // [sp+4h] [bp+4h]
  unsigned __int8 *buf; // [sp+10h] [bp+10h]
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]

  stra = str;
  v1 = strlen((const char *)str);
  buf = (unsigned __int8 *)cgmalloc(2 * v1 + 1, "cgminer.c", _func___13656, 5823);
  ptr = buf;
  v2 = (JE *)cgmalloc(8u, "cgminer.c", _func___13656, 5824);
  v2->buf = buf;
  v2->next = jedata;
  jedata = v2;
  while ( *stra )
  {
    if ( *stra == 92 || *stra == 34 )
      *ptr++ = 92;
    *ptr++ = *stra++;
  }
  *ptr = 0;
  return buf;
}

//----- (0001F3B8) --------------------------------------------------------
void __cdecl write_config(FILE *fcfg)
{
  const char *v1; // r4
  unsigned __int8 *v2; // r0
  const char *v3; // r6
  const char *v4; // r8
  const char *v5; // r5
  int quota; // r9
  unsigned __int8 *v7; // r0
  const char *v8; // r4
  unsigned __int8 *v9; // r0
  const char *v10; // r6
  const char *v11; // r8
  const char *v12; // r5
  unsigned __int8 *v13; // r0
  unsigned __int8 *v14; // r0
  unsigned __int8 *v15; // r0
  unsigned __int8 *v16; // r0
  unsigned __int8 *carg; // [sp+18h] [bp+8h]
  char *name; // [sp+1Ch] [bp+Ch]
  pool *pool; // [sp+20h] [bp+10h]
  unsigned __int8 *p; // [sp+24h] [bp+14h]
  int i; // [sp+28h] [bp+18h]
  opt_table *opt; // [sp+2Ch] [bp+1Ch]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, fcfg);
  for ( i = 0; i < total_pools; ++i )
  {
    pool = priority_pool(i);
    if ( pool->quota == 1 )
    {
      if ( i <= 0 )
        v8 = &byte_71100;
      else
        v8 = ",";
      if ( pool->rpc_proxy )
      {
        v9 = (unsigned __int8 *)proxytype(pool->rpc_proxytype);
        v10 = (const char *)json_escape(v9);
      }
      else
      {
        v10 = &byte_71100;
      }
      if ( pool->rpc_proxy )
        v11 = (const char *)json_escape(pool->rpc_proxy);
      else
        v11 = &byte_71100;
      if ( pool->rpc_proxy )
        v12 = "|";
      else
        v12 = &byte_71100;
      v13 = json_escape(pool->rpc_url);
      fprintf(fcfg, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v8, v10, v11, v12, (const char *)v13);
    }
    else
    {
      if ( i <= 0 )
        v1 = &byte_71100;
      else
        v1 = ",";
      if ( pool->rpc_proxy )
      {
        v2 = (unsigned __int8 *)proxytype(pool->rpc_proxytype);
        v3 = (const char *)json_escape(v2);
      }
      else
      {
        v3 = &byte_71100;
      }
      if ( pool->rpc_proxy )
        v4 = (const char *)json_escape(pool->rpc_proxy);
      else
        v4 = &byte_71100;
      if ( pool->rpc_proxy )
        v5 = "|";
      else
        v5 = &byte_71100;
      quota = pool->quota;
      v7 = json_escape(pool->rpc_url);
      fprintf(fcfg, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v1, v3, v4, v5, quota, (const char *)v7);
    }
    if ( pool->extranonce_subscribe )
      fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 0x21u, fcfg);
    v14 = json_escape(pool->rpc_user);
    fprintf(fcfg, "\n\t\t\"user\" : \"%s\",", (const char *)v14);
    v15 = json_escape(pool->rpc_pass);
    fprintf(fcfg, "\n\t\t\"pass\" : \"%s\"\n\t}", (const char *)v15);
  }
  fwrite("\n]\n", 1u, 3u, fcfg);
  for ( opt = opt_config_table; opt->type != OPT_END; ++opt )
  {
    name = strdup((const char *)opt->names);
    for ( p = (unsigned __int8 *)strtok(name, "|"); p; p = (unsigned __int8 *)strtok(0, "|") )
    {
      if ( p[1] == 45 && opt->desc != opt_hidden )
      {
        if ( (opt->type & 1) != 0
          && ((unsigned __int8 *(__cdecl *)(bool *))opt->cb == opt_set_bool
           || (unsigned __int8 *(__cdecl *)(bool *))opt->cb == opt_set_invbool)
          && *(_BYTE *)opt->u.carg == (opt->cb == (unsigned __int8 *(*)(void *))opt_set_bool) )
        {
          fprintf(fcfg, ",\n\"%s\" : true", (const char *)p + 2);
        }
        else if ( (opt->type & 2) != 0
               && ((unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == opt_set_intval
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_9999
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_65535
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_10
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_10
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_100
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_255
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_255
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_7680
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_200
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_4
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_32_to_63
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_22_to_75
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_42_to_85
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_22_to_55
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_42_to_65) )
        {
          fprintf(fcfg, ",\n\"%s\" : \"%d\"", (const char *)p + 2, *(_DWORD *)opt->u.carg);
        }
        else if ( (opt->type & 2) != 0
               && ((unsigned __int8 *(__cdecl *)(const unsigned __int8 *, float *))opt->cb_arg == set_float_125_to_500
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, float *))opt->cb_arg == set_float_100_to_250) )
        {
          fprintf(fcfg, ",\n\"%s\" : \"%.1f\"", (const char *)p + 2, *(float *)opt->u.carg);
        }
        else if ( (opt->type & 6) != 0 && opt->u.carg != &opt_set_null )
        {
          carg = *(unsigned __int8 **)opt->u.carg;
          if ( carg )
          {
            v16 = json_escape(carg);
            fprintf(fcfg, ",\n\"%s\" : \"%s\"", (const char *)p + 2, (const char *)v16);
          }
        }
      }
    }
    free(name);
  }
  if ( pool_strategy_0 == POOL_BALANCE )
    fwrite(",\n\"balance\" : true", 1u, 0x12u, fcfg);
  if ( pool_strategy_0 == POOL_LOADBALANCE )
    fwrite(",\n\"load-balance\" : true", 1u, 0x17u, fcfg);
  if ( pool_strategy_0 == POOL_ROUNDROBIN )
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, fcfg);
  if ( pool_strategy_0 == POOL_ROTATE )
    fprintf(fcfg, ",\n\"rotate\" : \"%d\"", opt_rotate_period);
  fwrite("\n}\n", 1u, 3u, fcfg);
  json_escape_free();
}
// 71100: using guessed type char byte_71100;

//----- (0001F918) --------------------------------------------------------
void zero_bestshare()
{
  int i; // [sp+Ch] [bp+4h]

  best_diff = 0LL;
  memset(best_share, 0, sizeof(best_share));
  suffix_string(0LL, best_share, 8u, 0);
  for ( i = 0; i < total_pools; ++i )
    pools[i]->best_diff = 0LL;
}

//----- (0001F9B0) --------------------------------------------------------
void zero_stats()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  sysinfo sInfo; // [sp+80Ch] [bp+804h] BYREF
  cgpu_info *cgpu; // [sp+84Ch] [bp+844h]
  pool *pool; // [sp+850h] [bp+848h]
  int i; // [sp+854h] [bp+84Ch]

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v0 = *_errno_location();
      v1 = _errno_location();
      v2 = strerror(*v1);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v2);
      applog(6, tmp42, 0);
    }
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
  }
  cgtime(&total_tv_start);
  copy_time(&tv_hashmeter, &total_tv_start);
  total_rolling = 0.0;
  rolling1 = 0.0;
  rolling5 = 0.0;
  rolling15 = 0.0;
  total_mhashes_done = 0.0;
  new_total_mhashes_done = 0.0;
  for ( i = 0; i <= 11; ++i )
    g_local_mhashes_dones[i] = 0.0;
  g_local_mhashes_index = 0;
  g_max_fan = 0;
  g_max_temp = 0;
  total_getworks = 0LL;
  total_accepted = 0LL;
  total_rejected = 0LL;
  hw_errors = 0;
  total_stale = 0LL;
  total_discarded = 0LL;
  local_work = 0;
  total_go = 0;
  total_ro = 0;
  total_secs = 1.0;
  new_total_secs = 1.0;
  last_total_secs = 1.0;
  total_diff1 = 0LL;
  found_blocks = 0;
  total_diff_accepted = 0.0;
  total_diff_rejected = 0.0;
  total_diff_stale = 0.0;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->getwork_requested = 0;
    pool->accepted = 0LL;
    pool->rejected = 0LL;
    pool->stale_shares = 0;
    pool->discarded_work = 0;
    pool->getfail_occasions = 0;
    pool->remotefail_occasions = 0;
    pool->last_share_time = 0;
    pool->diff1 = 0LL;
    pool->diff_accepted = 0.0;
    pool->diff_rejected = 0.0;
    pool->diff_stale = 0.0;
    pool->last_share_diff = 0.0;
  }
  zero_bestshare();
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu = get_devices(i);
    copy_time(&cgpu->dev_start_tv, &total_tv_start);
    mutex_lock_0(&hash_lock, "cgminer.c", _func___13703, 6077);
    cgpu->total_mhashes = 0.0;
    cgpu->accepted = 0;
    cgpu->rejected = 0;
    cgpu->hw_errors = 0;
    cgpu->utility = 0.0;
    cgpu->last_share_pool_time = 0;
    cgpu->diff1 = 0LL;
    cgpu->diff_accepted = 0.0;
    cgpu->diff_rejected = 0.0;
    cgpu->last_share_diff = 0.0;
    mutex_unlock_0(&hash_lock, "cgminer.c", _func___13703, 6090);
    cgpu->drv->zero_stats(cgpu);
  }
}

//----- (0001FE88) --------------------------------------------------------
void set_highprio()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+804h] [bp+804h]

  ret = nice(-10);
  if ( !ret && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Unable to set thread to high priority");
    applog(7, tmp42, 0);
  }
}

//----- (0001FF14) --------------------------------------------------------
void set_lowprio()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+804h] [bp+804h]

  ret = nice(10);
  if ( !ret && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    strcpy((char *)tmp42, "Unable to set thread to low priority");
    applog(6, tmp42, 0);
  }
}

//----- (0001FF90) --------------------------------------------------------
void __cdecl default_save_file(unsigned __int8 *filename)
{
  char *v1; // r0

  if ( default_config && *default_config )
  {
    strcpy((char *)filename, (const char *)default_config);
  }
  else
  {
    if ( getenv("HOME") && *getenv("HOME") )
    {
      v1 = getenv("HOME");
      strcpy((char *)filename, v1);
      strcat((char *)filename, "/");
    }
    else
    {
      *filename = 0;
    }
    strcat((char *)filename, ".bmminer/");
    mkdir((const char *)filename, 0x1FFu);
    strcat((char *)filename, "bmminer.conf");
  }
}

//----- (00020078) --------------------------------------------------------
void *__cdecl api_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  RenameThread("API");
  set_lowprio();
  api(api_thr_id);
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (000200CC) --------------------------------------------------------
void __cdecl thread_reportin(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 0;
  cgtime(&thr->last);
  thr->cgpu->status = LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00020108) --------------------------------------------------------
void __cdecl thread_reportout(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 1;
  cgtime(&thr->last);
  thr->cgpu->status = LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00020144) --------------------------------------------------------
void __cdecl hashmeter(int thr_id, uint64_t hashes_done)
{
  double v2; // d0
  int v3; // r4
  int *v4; // r0
  char *v5; // r0
  double v6; // r2
  double v7; // r2
  double v8; // r2
  double v9; // r2
  double v10; // r2
  double v11; // r2
  double fsecs; // [sp+0h] [bp-18h]
  double fsecsa; // [sp+0h] [bp-18h]
  double fsecsb; // [sp+0h] [bp-18h]
  double fsecsc; // [sp+0h] [bp-18h]
  double fsecsd; // [sp+0h] [bp-18h]
  double fsecse; // [sp+0h] [bp-18h]
  double fsecsf; // [sp+0h] [bp-18h]
  double fsecsg; // [sp+0h] [bp-18h]
  double fsecsh; // [sp+0h] [bp-18h]
  double fsecsi; // [sp+0h] [bp-18h]
  double interval; // [sp+8h] [bp-10h]
  double intervala; // [sp+8h] [bp-10h]
  double intervalb; // [sp+8h] [bp-10h]
  double intervalc; // [sp+8h] [bp-10h]
  double intervald; // [sp+8h] [bp-10h]
  double intervale; // [sp+8h] [bp-10h]
  double intervalf; // [sp+8h] [bp-10h]
  double intervalg; // [sp+8h] [bp-10h]
  double intervalh; // [sp+8h] [bp-10h]
  double intervali; // [sp+8h] [bp-10h]
  int thr_idb; // [sp+24h] [bp+Ch]
  unsigned __int8 logline[256]; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+128h] [bp+110h] BYREF
  unsigned __int8 displayed_r15[16]; // [sp+928h] [bp+910h] BYREF
  unsigned __int8 displayed_r5[16]; // [sp+938h] [bp+920h] BYREF
  unsigned __int8 displayed_r1[16]; // [sp+948h] [bp+930h] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+958h] [bp+940h] BYREF
  unsigned __int8 displayed_hashes[16]; // [sp+968h] [bp+950h] BYREF
  sysinfo sInfo; // [sp+978h] [bp+960h] BYREF
  uint64_t d64; // [sp+9B8h] [bp+9A0h]
  double device_tdiff_0; // [sp+9C0h] [bp+9A8h] BYREF
  cgpu_info *cgpu_0; // [sp+9C8h] [bp+9B0h]
  thr_info *thr_0; // [sp+9CCh] [bp+9B4h]
  double thr_mhs; // [sp+9D0h] [bp+9B8h]
  double device_tdiff; // [sp+9D8h] [bp+9C0h] BYREF
  cgpu_info *cgpu; // [sp+9E0h] [bp+9C8h]
  thr_info *thr; // [sp+9E4h] [bp+9CCh]
  int diff_t; // [sp+9E8h] [bp+9D0h]
  time_t now_t; // [sp+9ECh] [bp+9D4h]
  double tv_tdiff; // [sp+9F0h] [bp+9D8h] BYREF
  int i; // [sp+9F8h] [bp+9E0h]
  int local_mhashes_done_count; // [sp+9FCh] [bp+9E4h]
  uint64_t local_mhashes_done_avg; // [sp+A00h] [bp+9E8h]
  uint64_t local_mhashes_done; // [sp+A08h] [bp+9F0h] BYREF
  bool showlog; // [sp+A17h] [bp+9FFh]

  showlog = 0;
  local_mhashes_done = 0LL;
  local_mhashes_done_avg = 0LL;
  local_mhashes_done_count = 0;
  i = 0;
  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v3 = *_errno_location();
      v4 = _errno_location();
      v5 = strerror(*v4);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v3, v5);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
  }
  cgtime(&total_tv_end);
  tdiff(&total_tv_end, &tv_hashmeter);
  tv_tdiff = v2;
  now_t = total_tv_end.tv_sec;
  diff_t = total_tv_end.tv_sec - hashdisplay_t;
  if ( total_tv_end.tv_sec - hashdisplay_t < opt_log_interval )
  {
    if ( thr_id < 0 )
      return;
  }
  else
  {
    alt_status = switch_status != alt_status;
    hashdisplay_t = now_t;
    showlog = 1;
  }
  copy_time(&tv_hashmeter, &total_tv_end);
  if ( thr_id < 0 )
  {
    mutex_lock_0(&hash_lock, "cgminer.c", _func___13749, 6993);
    for ( thr_idb = 0; thr_idb < mining_threads; ++thr_idb )
    {
      thr_0 = get_thread(thr_idb);
      cgpu_0 = thr_0->cgpu;
      tdiff(&total_tv_end, &cgpu_0->last_message_tv);
      device_tdiff_0 = v2;
      copy_time(&cgpu_0->last_message_tv, &total_tv_end);
      LODWORD(v7) = &cgpu_0->rolling;
      HIDWORD(v7) = &opt_log_interval;
      decay_time(&cgpu_0->rolling, v7, fsecs, interval);
      HIDWORD(v8) = &cgpu_0->rolling1;
      LODWORD(v8) = &device_tdiff_0;
      decay_time(&cgpu_0->rolling1, v8, fsecsd, intervald);
      HIDWORD(v9) = &device_tdiff_0;
      decay_time(&cgpu_0->rolling5, v9, fsecse, intervale);
      HIDWORD(v10) = &cgpu_0->rolling15;
      v2 = 0.0;
      decay_time(&cgpu_0->rolling15, v10, fsecsf, intervalf);
    }
    mutex_unlock_0(&hash_lock, "cgminer.c", _func___13749, 7008);
  }
  else
  {
    thr = get_thread(thr_id);
    cgpu = thr->cgpu;
    copy_time(&thr->last, &total_tv_end);
    cgpu->device_last_well = now_t;
    tdiff(&total_tv_end, &cgpu->last_message_tv);
    device_tdiff = v2;
    copy_time(&cgpu->last_message_tv, &total_tv_end);
    thr_mhs = (double)hashes_done / device_tdiff / 1000000.0;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "[thread %d: %llu hashes, %.1f mhash/sec]", thr_id, hashes_done, thr_mhs);
      applog(7, tmp42, 0);
    }
    hashes_done /= (unsigned int)&nonce_num[6][85][45];
    mutex_lock_0(&hash_lock, "cgminer.c", _func___13749, 6964);
    cgpu->total_mhashes = cgpu->total_mhashes + (double)hashes_done;
    HIDWORD(v6) = &opt_log_interval;
    decay_time(&cgpu->rolling, v6, fsecs, interval);
    decay_time(&cgpu->rolling1, (double)hashes_done, fsecsa, intervala);
    decay_time(
      &cgpu->rolling5,
      COERCE_DOUBLE(__PAIR64__(&device_tdiff, COERCE_UNSIGNED_INT64((double)hashes_done))),
      fsecsb,
      intervalb);
    decay_time(&cgpu->rolling15, (double)hashes_done, fsecsc, intervalc);
    mutex_unlock_0(&hash_lock, "cgminer.c", _func___13749, 6971);
    if ( want_per_device_stats && showlog )
    {
      get_statline(logline, 0x100u, cgpu);
      if ( !curses_active )
      {
        printf("%s          \r", (const char *)logline);
        fflush((FILE *)stdout);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "%s", (const char *)logline);
        applog(6, tmp42, 0);
      }
    }
  }
  mutex_lock_0(&hash_lock, "cgminer.c", _func___13749, 7011);
  total_mhashes_done = (double)hashes_done + total_mhashes_done;
  if ( showlog )
  {
    if ( ++g_local_mhashes_index > 11 )
      g_local_mhashes_index = 0;
    for ( i = 0; i <= 11; ++i )
    {
      if ( g_local_mhashes_dones[i] >= 0.0 )
      {
        local_mhashes_done_avg = (unsigned __int64)((double)local_mhashes_done_avg + g_local_mhashes_dones[i]);
        ++local_mhashes_done_count;
      }
    }
    if ( local_mhashes_done_count <= 0 )
      local_mhashes_done = hashes_done;
    else
      local_mhashes_done = local_mhashes_done_avg / local_mhashes_done_count;
    LODWORD(v11) = &local_mhashes_done;
    HIDWORD(v11) = &opt_log_interval;
    decay_time(&total_rolling, v11, fsecs, interval);
    decay_time(
      &rolling1,
      COERCE_DOUBLE(__PAIR64__(&tv_tdiff, COERCE_UNSIGNED_INT64((double)hashes_done))),
      fsecsg,
      intervalg);
    decay_time(&rolling5, (double)hashes_done, fsecsh, intervalh);
    decay_time(&rolling15, (double)hashes_done, fsecsi, intervali);
    global_hashrate = (unsigned __int64)(total_rolling * 1000000.0);
    g_local_mhashes_dones[g_local_mhashes_index] = 0.0;
  }
  g_local_mhashes_dones[g_local_mhashes_index] = g_local_mhashes_dones[g_local_mhashes_index] + (double)hashes_done;
  total_secs = (double)total_tv_end_sys - (double)total_tv_start_sys;
  if ( (double)total_tv_end_sys - (double)total_tv_start_sys - last_total_secs <= 86400.0 )
  {
    last_total_secs = total_secs;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "cgminer time error total_secs = %d last_total_secs = %d",
        HIDWORD(last_total_secs),
        LODWORD(total_secs));
      applog(3, tmp42, 0);
    }
    mutex_unlock_0(&hash_lock, "cgminer.c", _func___13749, 7059);
    zero_stats();
    mutex_lock_0(&hash_lock, "cgminer.c", _func___13749, 7061);
  }
  if ( showlog )
  {
    d64 = (unsigned __int64)(total_mhashes_done / total_secs * 1000000.0);
    suffix_string(d64, displayed_hashes, 0x10u, 4);
    d64 = (unsigned __int64)(total_rolling * 1000000.0);
    g_displayed_rolling = (double)((int)total_rolling / 10) / 100.0;
    suffix_string(d64, displayed_rolling, 0x10u, 4);
    d64 = (unsigned __int64)(rolling1 * 1000000.0);
    suffix_string(d64, displayed_r1, 0x10u, 4);
    d64 = (unsigned __int64)(rolling5 * 1000000.0);
    suffix_string(d64, displayed_r5, 0x10u, 4);
    d64 = (unsigned __int64)(rolling15 * 1000000.0);
    suffix_string(d64, displayed_r15, 0x10u, 4);
    snprintf(
      (char *)statusline,
      0x100u,
      "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
      opt_log_interval,
      (const char *)displayed_rolling,
      (const char *)displayed_r1,
      (const char *)displayed_r5,
      (const char *)displayed_r15,
      (const char *)displayed_hashes);
  }
  mutex_unlock_0(&hash_lock, "cgminer.c", _func___13749, 7102);
  if ( showlog )
  {
    if ( !curses_active )
    {
      printf("%s          \r", (const char *)statusline);
      fflush((FILE *)stdout);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "%s", (const char *)statusline);
      applog(6, tmp42, 0);
    }
  }
}
// 2024E: variable 'v2' is possibly undefined
// 2049C: variable 'v6' is possibly undefined
// 2049C: variable 'fsecs' is possibly undefined
// 2049C: variable 'interval' is possibly undefined
// 204C8: variable 'fsecsa' is possibly undefined
// 204C8: variable 'intervala' is possibly undefined
// 204F4: variable 'fsecsb' is possibly undefined
// 204F4: variable 'intervalb' is possibly undefined
// 20520: variable 'fsecsc' is possibly undefined
// 20520: variable 'intervalc' is possibly undefined
// 206DE: variable 'fsecsd' is possibly undefined
// 206DE: variable 'intervald' is possibly undefined
// 206FA: variable 'v9' is possibly undefined
// 206FA: variable 'fsecse' is possibly undefined
// 206FA: variable 'intervale' is possibly undefined
// 20716: variable 'v10' is possibly undefined
// 20716: variable 'fsecsf' is possibly undefined
// 20716: variable 'intervalf' is possibly undefined
// 20904: variable 'fsecsg' is possibly undefined
// 20904: variable 'intervalg' is possibly undefined
// 2092E: variable 'fsecsh' is possibly undefined
// 2092E: variable 'intervalh' is possibly undefined
// 20958: variable 'fsecsi' is possibly undefined
// 20958: variable 'intervali' is possibly undefined
// 8A8B4: using guessed type int stdout;

//----- (00020DD0) --------------------------------------------------------
void __cdecl stratum_share_result(json_t_0 *val, json_t_0 *res_val, json_t_0 *err_val, stratum_share *sshare)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  unsigned __int8 hashshow[64]; // [sp+824h] [bp+814h] BYREF
  int srdiff; // [sp+864h] [bp+854h]
  time_t now_t; // [sp+868h] [bp+858h]
  work *work; // [sp+86Ch] [bp+85Ch]

  work = sshare->work;
  now_t = time(0);
  srdiff = now_t - sshare->sshare_sent;
  if ( (opt_debug || srdiff > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stratum share result lag time %d seconds", work->pool->pool_no, srdiff);
    applog(6, tmp42, 0);
  }
  show_hash(work, hashshow);
  share_result(val, res_val, err_val, work, hashshow, 0, (unsigned __int8 *)&byte_71100);
}
// 71100: using guessed type char byte_71100;

//----- (00020ECC) --------------------------------------------------------
bool __cdecl parse_stratum_response(pool *pool, unsigned __int8 *s)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  int id; // [sp+810h] [bp+808h] BYREF
  json_error_t err; // [sp+814h] [bp+80Ch] BYREF
  double pool_diff; // [sp+910h] [bp+908h]
  unsigned int _hd_bkt; // [sp+91Ch] [bp+914h]
  UT_hash_handle *_hd_hh_del; // [sp+920h] [bp+918h]
  unsigned int _hf_bkt; // [sp+924h] [bp+91Ch]
  json_t_0 *id_val; // [sp+928h] [bp+920h]
  json_t_0 *err_val; // [sp+92Ch] [bp+924h]
  json_t_0 *res_val; // [sp+930h] [bp+928h]
  json_t_0 *val; // [sp+934h] [bp+92Ch]
  const unsigned __int8 *_hj_key; // [sp+938h] [bp+930h]
  unsigned int _hj_k; // [sp+93Ch] [bp+934h]
  unsigned int _hj_j; // [sp+940h] [bp+938h]
  unsigned int _hj_i; // [sp+944h] [bp+93Ch]
  unsigned int _hf_hashv; // [sp+948h] [bp+940h]
  unsigned __int8 *ss; // [sp+94Ch] [bp+944h]
  bool ret; // [sp+953h] [bp+94Bh]
  stratum_share *sshare; // [sp+954h] [bp+94Ch]

  val = 0;
  ret = 0;
  val = json_loads(s, 0, &err);
  if ( val )
  {
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    id_val = json_object_get(val, "id");
    if ( id_val && id_val->type == JSON_NULL || !id_val )
    {
      if ( err_val )
        ss = json_dumps(err_val, 3u);
      else
        ss = (unsigned __int8 *)strdup("(unknown reason)");
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "JSON-RPC non method decode failed: %s", (const char *)ss);
        applog(6, tmp42, 0);
      }
      free(ss);
    }
    else
    {
      id = json_integer_value(id_val);
      mutex_lock_0(&sshare_lock, "cgminer.c", _func___13796, 7185);
      _hj_key = (const unsigned __int8 *)&id;
      _hj_k = 4;
      _hj_i = (HIBYTE(id) << 24) - 1640531527;
      _hj_i += BYTE2(id) << 16;
      _hj_i += BYTE1(id) << 8;
      _hj_i += (unsigned __int8)id;
      _hj_i += 1640531527;
      _hj_i += 17973517;
      _hj_i ^= 0x7F76Du;
      _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
      _hf_hashv = -17973517 - _hj_i - _hj_j;
      _hf_hashv ^= _hj_j >> 13;
      _hj_i -= _hj_j;
      _hj_i -= _hf_hashv;
      _hj_i ^= _hf_hashv >> 12;
      _hj_j -= _hf_hashv;
      _hj_j -= _hj_i;
      _hj_j ^= _hj_i << 16;
      _hf_hashv -= _hj_i;
      _hf_hashv -= _hj_j;
      _hf_hashv ^= _hj_j >> 5;
      _hj_i -= _hj_j;
      _hj_i -= _hf_hashv;
      _hj_i ^= _hf_hashv >> 3;
      _hj_j -= _hf_hashv;
      _hj_j -= _hj_i;
      _hj_j ^= _hj_i << 10;
      _hf_hashv -= _hj_i;
      _hf_hashv -= _hj_j;
      _hf_hashv ^= _hj_j >> 15;
      sshare = 0;
      if ( stratum_shares )
      {
        _hf_bkt = _hf_hashv & (stratum_shares->hh.tbl->num_buckets - 1);
        if ( stratum_shares->hh.tbl->buckets[_hf_bkt].hh_head )
          sshare = (stratum_share *)((char *)stratum_shares->hh.tbl->buckets[_hf_bkt].hh_head
                                   - stratum_shares->hh.tbl->hho);
        else
          sshare = 0;
        while ( sshare && (sshare->hh.hashv != _hf_hashv || sshare->hh.keylen != 4 || memcmp(sshare->hh.key, &id, 4u)) )
        {
          if ( sshare->hh.hh_next )
            sshare = (stratum_share *)((char *)sshare->hh.hh_next - stratum_shares->hh.tbl->hho);
          else
            sshare = 0;
        }
      }
      if ( sshare )
      {
        if ( sshare->hh.prev || sshare->hh.next )
        {
          _hd_hh_del = &sshare->hh;
          if ( (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) == sshare )
            stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
          if ( sshare->hh.prev )
            *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
          else
            stratum_shares = (stratum_share *)sshare->hh.next;
          if ( _hd_hh_del->next )
            *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
          _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
          --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
          if ( stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head == _hd_hh_del )
            stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
          if ( _hd_hh_del->hh_prev )
            _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
          if ( _hd_hh_del->hh_next )
            _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
          --stratum_shares->hh.tbl->num_items;
        }
        else
        {
          free(stratum_shares->hh.tbl->buckets);
          free(stratum_shares->hh.tbl);
          stratum_shares = 0;
        }
        --pool->sshares;
      }
      mutex_unlock_0(&sshare_lock, "cgminer.c", _func___13796, 7193);
      if ( sshare )
      {
        stratum_share_result(val, res_val, err_val, sshare);
        free_work(&sshare->work, "cgminer.c", _func___13796, 7238);
        free(sshare);
        ret = 1;
      }
      else if ( res_val )
      {
        cg_rlock_0(&pool->data_lock, "cgminer.c", _func___13796, 7205);
        pool_diff = pool->sdiff;
        cg_runlock_0(&pool->data_lock, "cgminer.c", _func___13796, 7207);
        if ( res_val && res_val->type == JSON_TRUE )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "Accepted untracked stratum share from pool %d", pool->pool_no);
            applog(5, tmp42, 0);
          }
          mutex_lock_0(&stats_lock, "cgminer.c", _func___13796, 7215);
          ++total_accepted;
          ++pool->accepted;
          total_diff_accepted = total_diff_accepted + pool_diff;
          pool->diff_accepted = pool->diff_accepted + pool_diff;
          mutex_unlock_0(&stats_lock, "cgminer.c", _func___13796, 7220);
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "Rejected untracked stratum share from pool %d", pool->pool_no);
            applog(5, tmp42, 0);
          }
          mutex_lock_0(&stats_lock, "cgminer.c", _func___13796, 7226);
          ++total_rejected;
          ++pool->rejected;
          total_diff_rejected = total_diff_rejected + pool_diff;
          pool->diff_rejected = pool->diff_rejected + pool_diff;
          mutex_unlock_0(&stats_lock, "cgminer.c", _func___13796, 7231);
        }
      }
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
    applog(6, tmp42, 0);
  }
  if ( val )
    json_decref_0(val);
  return ret;
}
// 212F2: conditional instruction was optimized away because %_hj_k.4==4

//----- (00021B9C) --------------------------------------------------------
void __cdecl clear_stratum_shares(pool *pool)
{
  stratum_share *next; // r3
  stratum_share *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned int _hd_bkt; // [sp+814h] [bp+80Ch]
  UT_hash_handle *_hd_hh_del; // [sp+818h] [bp+810h]
  int cleared; // [sp+81Ch] [bp+814h]
  double diff_cleared; // [sp+820h] [bp+818h]
  stratum_share *tmpshare; // [sp+828h] [bp+820h]
  stratum_share *sshare; // [sp+82Ch] [bp+824h]

  diff_cleared = 0.0;
  cleared = 0;
  mutex_lock_0(&sshare_lock, "cgminer.c", _func___13832, 7260);
  sshare = stratum_shares;
  if ( stratum_shares )
    next = (stratum_share *)stratum_shares->hh.next;
  else
    next = 0;
  tmpshare = next;
  while ( sshare )
  {
    if ( sshare->work->pool == pool )
    {
      if ( sshare->hh.prev || sshare->hh.next )
      {
        _hd_hh_del = &sshare->hh;
        if ( (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) == sshare )
          stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
        if ( sshare->hh.prev )
          *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
        else
          stratum_shares = (stratum_share *)sshare->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
        if ( stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head == _hd_hh_del )
          stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --stratum_shares->hh.tbl->num_items;
      }
      else
      {
        free(stratum_shares->hh.tbl->buckets);
        free(stratum_shares->hh.tbl);
        stratum_shares = 0;
      }
      diff_cleared = diff_cleared + sshare->work->work_difficulty;
      free_work(&sshare->work, "cgminer.c", _func___13832, 7268);
      --pool->sshares;
      free(sshare);
      ++cleared;
    }
    sshare = tmpshare;
    if ( tmpshare )
      v2 = (stratum_share *)tmpshare->hh.next;
    else
      v2 = 0;
    tmpshare = v2;
  }
  mutex_unlock_0(&sshare_lock, "cgminer.c", _func___13832, 7274);
  if ( cleared )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", cleared, pool->pool_no);
      applog(4, tmp42, 0);
    }
    pool->stale_shares += cleared;
    total_stale += cleared;
    pool->diff_stale = pool->diff_stale + diff_cleared;
    total_diff_stale = total_diff_stale + diff_cleared;
  }
}

//----- (00021F84) --------------------------------------------------------
void __cdecl clear_pool_work(pool *pool)
{
  work *next; // r3
  UT_hash_bucket_0 *v2; // r3
  work *v3; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  work *work; // [sp+814h] [bp+80Ch] BYREF
  unsigned int _hd_bkt; // [sp+818h] [bp+810h]
  UT_hash_handle *_hd_hh_del; // [sp+81Ch] [bp+814h]
  int cleared; // [sp+820h] [bp+818h]
  work *tmp; // [sp+824h] [bp+81Ch]

  cleared = 0;
  mutex_lock_0(stgd_lock, "cgminer.c", _func___13845, 7291);
  work = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( work->pool == pool )
    {
      if ( work->hh.prev || work->hh.next )
      {
        _hd_hh_del = &work->hh;
        if ( (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) == work )
          staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
        if ( work->hh.prev )
          *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
        else
          staged_work = (work *)work->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v2 = &staged_work->hh.tbl->buckets[_hd_bkt];
        --v2->count;
        if ( staged_work->hh.tbl->buckets[_hd_bkt].hh_head == _hd_hh_del )
          staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --staged_work->hh.tbl->num_items;
      }
      else
      {
        free(staged_work->hh.tbl->buckets);
        free(staged_work->hh.tbl);
        staged_work = 0;
      }
      free_work(&work, "cgminer.c", _func___13845, 7297);
      ++cleared;
    }
    work = tmp;
    if ( tmp )
      v3 = (work *)tmp->hh.next;
    else
      v3 = 0;
    tmp = v3;
  }
  mutex_unlock_0(stgd_lock, "cgminer.c", _func___13845, 7301);
  if ( cleared && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Cleared %d work items due to stratum disconnect on pool %d",
      cleared,
      pool->pool_no);
    applog(6, tmp42, 0);
  }
}

//----- (000222DC) --------------------------------------------------------
int cp_prio()
{
  int prio; // [sp+4h] [bp+4h]

  cg_rlock_0(&control_lock, "cgminer.c", _func___13856, 7311);
  prio = currentpool->prio;
  cg_runlock_0(&control_lock, "cgminer.c", _func___13856, 7313);
  return prio;
}

//----- (0002233C) --------------------------------------------------------
bool __cdecl cnx_needed(pool *pool)
{
  bool v1; // r3
  int prio; // r4

  if ( pool->enabled != POOL_ENABLED )
    return 0;
  if ( pool_strategy_0 == POOL_BALANCE )
    return 1;
  if ( pool_strategy_0 == POOL_LOADBALANCE )
    return 1;
  if ( pool->has_stratum && pool->idle )
    return 1;
  if ( current_pool() == pool )
    return 1;
  if ( pool->sshares )
    return 1;
  v1 = pool_strategy_0 == POOL_FAILOVER && (prio = pool->prio, prio < cp_prio()) || no_work;
  return v1;
}

//----- (000223EC) --------------------------------------------------------
void __cdecl stratum_resumed(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( pool_tclear(pool, &pool->idle) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d resumed", pool->pool_no);
      applog(6, tmp42, 0);
    }
    pool_resus(pool);
  }
}

//----- (00022478) --------------------------------------------------------
bool __cdecl supports_resume(pool *pool)
{
  bool ret; // [sp+Fh] [bp+Fh]

  cg_rlock_0(&pool->data_lock, "cgminer.c", _func___13876, 7376);
  ret = pool->sessionid != 0;
  cg_runlock_0(&pool->data_lock, "cgminer.c", _func___13876, 7378);
  return ret;
}

//----- (000224D8) --------------------------------------------------------
void *__cdecl stratum_rthread(void *userdata)
{
  pthread_t v1; // r0
  fd_set rd; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+90h] [bp+88h] BYREF
  work *work; // [sp+890h] [bp+888h] BYREF
  timeval timeout; // [sp+894h] [bp+88Ch] BYREF
  unsigned __int8 threadname[16]; // [sp+89Ch] [bp+894h] BYREF
  int sel_ret; // [sp+8ACh] [bp+8A4h]
  fd_set *__arr; // [sp+8B0h] [bp+8A8h]
  pool *pool; // [sp+8B4h] [bp+8ACh]
  unsigned int __i; // [sp+8B8h] [bp+8B0h]
  unsigned __int8 *s; // [sp+8BCh] [bp+8B4h]

  pool = (pool *)userdata;
  v1 = pthread_self();
  pthread_detach(v1);
  snprintf((char *)threadname, 0x10u, "%d/RStratum", pool->pool_no);
  RenameThread(threadname);
  while ( !pool->removed )
  {
    if ( !sock_full(pool) && !cnx_needed(pool) )
    {
      suspend_stratum(pool);
      clear_stratum_shares(pool);
      clear_pool_work(pool);
      wait_lpcurrent(pool);
      while ( !restart_stratum(pool) )
      {
        pool_died(pool);
        if ( pool->removed )
          return 0;
        cgsleep_ms(5000);
      }
    }
    __arr = &rd;
    for ( __i = 0; __i <= 0x1F; ++__i )
      __arr->fds_bits[__i] = 0;
    rd.fds_bits[pool->sock / 32] |= 1 << (pool->sock % 32);
    timeout.tv_sec = 90;
    timeout.tv_usec = 0;
    if ( !sock_full(pool) && (sel_ret = select(pool->sock + 1, &rd, 0, 0, &timeout), sel_ret <= 0) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum select failed on pool %d with value %d", pool->pool_no, sel_ret);
        applog(7, tmp42, 0);
      }
      s = 0;
    }
    else
    {
      s = recv_line(pool);
    }
    if ( s )
    {
      stratum_resumed(pool);
      if ( !parse_method(pool, s) && !parse_stratum_response(pool, s) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Unknown stratum msg: %s", (const char *)s);
          applog(6, tmp42, 0);
        }
      }
      else if ( pool->swork.clean )
      {
        work = make_work();
        pool->swork.clean = 0;
        gen_stratum_work(pool, work);
        work->longpoll = 1;
        test_work_current(work);
        free_work(&work, "cgminer.c", _func___13904, 7490);
      }
      free(s);
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d interrupted", pool->pool_no);
        applog(5, tmp42, 0);
      }
      ++pool->getfail_occasions;
      ++total_go;
      if ( !supports_resume(pool) || opt_lowmem )
        clear_stratum_shares(pool);
      clear_pool_work(pool);
      if ( current_pool() == pool )
        restart_threads();
      while ( !restart_stratum(pool) )
      {
        pool_died(pool);
        if ( pool->removed )
          return 0;
        cgsleep_ms(5000);
      }
    }
  }
  suspend_stratum(pool);
  return 0;
}

//----- (000228F0) --------------------------------------------------------
void *__cdecl stratum_sthread(void *userdata)
{
  pthread_t v1; // r0
  int v2; // r3
  unsigned __int8 *rpc_user; // r4
  unsigned __int8 *job_id; // r6
  unsigned __int8 *ntime; // r5
  unsigned int v6; // r0
  size_t v7; // r0
  stratum_share *v8; // r4
  UT_hash_table *tbl; // r4
  unsigned int v10; // r3
  bool v11; // r3
  unsigned __int8 s[1024]; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+420h] [bp+408h] BYREF
  work *work; // [sp+C20h] [bp+C08h] BYREF
  unsigned __int8 nonce2[8]; // [sp+C24h] [bp+C0Ch] BYREF
  unsigned int nonce; // [sp+C2Ch] [bp+C14h] BYREF
  unsigned __int8 nonce2hex[20]; // [sp+C30h] [bp+C18h] BYREF
  unsigned __int8 noncehex[12]; // [sp+C44h] [bp+C2Ch] BYREF
  unsigned __int8 threadname[16]; // [sp+C50h] [bp+C38h] BYREF
  int ssdiff; // [sp+C60h] [bp+C48h]
  bool sessionid_match; // [sp+C67h] [bp+C4Fh]
  UT_hash_bucket_0 *_he_newbkt; // [sp+C68h] [bp+C50h]
  unsigned int _he_bkt; // [sp+C6Ch] [bp+C54h]
  UT_hash_handle *_he_hh_nxt; // [sp+C70h] [bp+C58h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+C74h] [bp+C5Ch]
  unsigned int _ha_bkt; // [sp+C78h] [bp+C60h]
  unsigned int *hash32; // [sp+C7Ch] [bp+C64h]
  stratum_share *sshare; // [sp+C80h] [bp+C68h]
  uint64_t *nonce2_64; // [sp+C84h] [bp+C6Ch]
  pool *pool; // [sp+C88h] [bp+C70h]
  UT_hash_handle *_he_thh; // [sp+C8Ch] [bp+C74h]
  unsigned int _he_bkt_i; // [sp+C90h] [bp+C78h]
  const unsigned __int8 *_hj_key; // [sp+C94h] [bp+C7Ch]
  unsigned int _hj_k; // [sp+C98h] [bp+C80h]
  unsigned int _hj_j; // [sp+C9Ch] [bp+C84h]
  unsigned int _hj_i; // [sp+CA0h] [bp+C88h]
  unsigned int _ha_hashv; // [sp+CA4h] [bp+C8Ch]
  bool submitted; // [sp+CABh] [bp+C93h]
  unsigned int last_nonce; // [sp+CACh] [bp+C94h]
  uint64_t last_nonce2; // [sp+CB0h] [bp+C98h]

  pool = (pool *)userdata;
  last_nonce2 = 0LL;
  last_nonce = 0;
  v1 = pthread_self();
  pthread_detach(v1);
  snprintf((char *)threadname, 0x10u, "%d/SStratum", pool->pool_no);
  RenameThread(threadname);
  pool->stratum_q = tq_new();
  if ( !pool->stratum_q )
  {
    strcpy((char *)tmp42, "Failed to create stratum_q in stratum_sthread");
    applog(3, tmp42, 1);
    quit(1);
  }
  while ( !pool->removed )
  {
    work = (work *)tq_pop(pool->stratum_q, 0);
    if ( !work )
    {
      strcpy((char *)tmp42, "Stratum q returned empty work");
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( work->nonce2_len <= 8 )
    {
      nonce = *(_DWORD *)&work->data[76];
      nonce2_64 = (uint64_t *)nonce2;
      *(_QWORD *)nonce2 = work->nonce2;
      if ( nonce == last_nonce && *nonce2_64 == last_nonce2 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Filtering duplicate share to pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        free_work(&work, "cgminer.c", _func___13928, 7557);
      }
      else
      {
        last_nonce = nonce;
        last_nonce2 = *nonce2_64;
        _bin2hex(noncehex, (const unsigned __int8 *)&nonce, 4u);
        _bin2hex(nonce2hex, nonce2, work->nonce2_len);
        sshare = (stratum_share *)cgcalloc(52, 1u, "cgminer.c", _func___13928, 7566);
        hash32 = (unsigned int *)work->hash;
        submitted = 0;
        sshare->sshare_time = time(0);
        sshare->work = work;
        memset(s, 0, sizeof(s));
        mutex_lock_0(&sshare_lock, "cgminer.c", _func___13928, 7575);
        v2 = swork_id;
        sshare->id = swork_id;
        swork_id = v2 + 1;
        mutex_unlock_0(&sshare_lock, "cgminer.c", _func___13928, 7578);
        if ( pool->support_vil )
        {
          rpc_user = pool->rpc_user;
          job_id = work->job_id;
          ntime = work->ntime;
          v6 = swab32(work->version);
          snprintf(
            (char *)s,
            0x400u,
            "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
            (const char *)rpc_user,
            (const char *)job_id,
            (const char *)nonce2hex,
            (const char *)ntime,
            (const char *)noncehex,
            v6,
            sshare->id);
        }
        else
        {
          snprintf(
            (char *)s,
            0x400u,
            "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
            (const char *)pool->rpc_user,
            (const char *)work->job_id,
            (const char *)nonce2hex,
            (const char *)work->ntime,
            (const char *)noncehex,
            sshare->id);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Submitting share %08lx to pool %d", hash32[6], pool->pool_no);
          applog(6, tmp42, 0);
        }
        while ( time(0) < sshare->sshare_time + 120 )
        {
          v7 = strlen((const char *)s);
          if ( stratum_send(pool, s, v7) )
          {
            mutex_lock_0(&sshare_lock, "cgminer.c", _func___13928, 7614);
            _hj_key = (const unsigned __int8 *)&sshare->id;
            _hj_j = -1640531527;
            _hj_i = -1640531527;
            _hj_k = 4;
            _ha_hashv = -17973517;
            _hj_i = (HIBYTE(sshare->id) << 24) - 1640531527;
            _hj_i += BYTE2(sshare->id) << 16;
            _hj_i += BYTE1(sshare->id) << 8;
            _hj_i += LOBYTE(sshare->id);
            _hj_i += 1640531527;
            _hj_i += 17973517;
            _hj_i ^= 0x7F76Du;
            _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
            _ha_hashv = -17973517 - _hj_i - _hj_j;
            _ha_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _ha_hashv;
            _hj_i ^= _ha_hashv >> 12;
            _hj_j -= _ha_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _ha_hashv -= _hj_i;
            _ha_hashv -= _hj_j;
            _ha_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _ha_hashv;
            _hj_i ^= _ha_hashv >> 3;
            _hj_j -= _ha_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _ha_hashv -= _hj_i;
            _ha_hashv -= _hj_j;
            _ha_hashv ^= _hj_j >> 15;
            sshare->hh.hashv = _ha_hashv;
            sshare->hh.key = &sshare->id;
            sshare->hh.keylen = 4;
            if ( stratum_shares )
            {
              sshare->hh.tbl = stratum_shares->hh.tbl;
              sshare->hh.next = 0;
              sshare->hh.prev = (char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho;
              stratum_shares->hh.tbl->tail->next = sshare;
              stratum_shares->hh.tbl->tail = &sshare->hh;
            }
            else
            {
              sshare->hh.next = 0;
              sshare->hh.prev = 0;
              stratum_shares = sshare;
              v8 = sshare;
              v8->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
              if ( !stratum_shares->hh.tbl )
                exit(-1);
              memset(stratum_shares->hh.tbl, 0, sizeof(UT_hash_table));
              stratum_shares->hh.tbl->tail = &stratum_shares->hh;
              stratum_shares->hh.tbl->num_buckets = 32;
              stratum_shares->hh.tbl->log2_num_buckets = 5;
              stratum_shares->hh.tbl->hho = 0;
              tbl = stratum_shares->hh.tbl;
              tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
              if ( !stratum_shares->hh.tbl->buckets )
                exit(-1);
              memset(stratum_shares->hh.tbl->buckets, 0, 0x180u);
              stratum_shares->hh.tbl->signature = -1609490463;
            }
            ++stratum_shares->hh.tbl->num_items;
            _ha_bkt = _ha_hashv & (stratum_shares->hh.tbl->num_buckets - 1);
            ++stratum_shares->hh.tbl->buckets[_ha_bkt].count;
            sshare->hh.hh_next = stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head;
            sshare->hh.hh_prev = 0;
            if ( stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head )
              stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &sshare->hh;
            stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head = &sshare->hh;
            if ( stratum_shares->hh.tbl->buckets[_ha_bkt].count >= 10
                                                                 * (stratum_shares->hh.tbl->buckets[_ha_bkt].expand_mult
                                                                  + 1)
              && sshare->hh.tbl->noexpand != 1 )
            {
              _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * sshare->hh.tbl->num_buckets);
              if ( !_he_new_buckets )
                exit(-1);
              memset(_he_new_buckets, 0, 24 * sshare->hh.tbl->num_buckets);
              sshare->hh.tbl->ideal_chain_maxlen = (sshare->hh.tbl->num_items >> (sshare->hh.tbl->log2_num_buckets + 1))
                                                 + (((2 * sshare->hh.tbl->num_buckets - 1) & sshare->hh.tbl->num_items) != 0);
              sshare->hh.tbl->nonideal_items = 0;
              for ( _he_bkt_i = 0; sshare->hh.tbl->num_buckets > _he_bkt_i; ++_he_bkt_i )
              {
                for ( _he_thh = sshare->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
                {
                  _he_hh_nxt = _he_thh->hh_next;
                  _he_bkt = (2 * sshare->hh.tbl->num_buckets - 1) & _he_thh->hashv;
                  _he_newbkt = &_he_new_buckets[_he_bkt];
                  if ( ++_he_newbkt->count > sshare->hh.tbl->ideal_chain_maxlen )
                  {
                    ++sshare->hh.tbl->nonideal_items;
                    _he_newbkt->expand_mult = _he_newbkt->count / sshare->hh.tbl->ideal_chain_maxlen;
                  }
                  _he_thh->hh_prev = 0;
                  _he_thh->hh_next = _he_newbkt->hh_head;
                  if ( _he_newbkt->hh_head )
                    _he_newbkt->hh_head->hh_prev = _he_thh;
                  _he_newbkt->hh_head = _he_thh;
                }
              }
              free(sshare->hh.tbl->buckets);
              sshare->hh.tbl->num_buckets *= 2;
              ++sshare->hh.tbl->log2_num_buckets;
              sshare->hh.tbl->buckets = _he_new_buckets;
              if ( sshare->hh.tbl->nonideal_items <= sshare->hh.tbl->num_items >> 1 )
                v10 = 0;
              else
                v10 = sshare->hh.tbl->ineff_expands + 1;
              sshare->hh.tbl->ineff_expands = v10;
              if ( sshare->hh.tbl->ineff_expands > 1 )
                sshare->hh.tbl->noexpand = 1;
            }
            ++pool->sshares;
            mutex_unlock_0(&sshare_lock, "cgminer.c", _func___13928, 7617);
            if ( pool_tclear(pool, &pool->submit_fail) && (use_syslog || opt_log_output || opt_log_level > 3) )
            {
              snprintf((char *)tmp42, 0x800u, "Pool %d communication resumed, submitting work", pool->pool_no);
              applog(4, tmp42, 0);
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "Successfully submitted, adding to stratum_shares db");
              applog(7, tmp42, 0);
            }
            submitted = 1;
            break;
          }
          if ( !pool_tset(pool, &pool->submit_fail) && cnx_needed(pool) )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf((char *)tmp42, 0x800u, "Pool %d stratum share submission failure", pool->pool_no);
              applog(4, tmp42, 0);
            }
            ++total_ro;
            ++pool->remotefail_occasions;
          }
          if ( opt_lowmem )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "Lowmem option prevents resubmitting stratum share");
              applog(7, tmp42, 0);
            }
            break;
          }
          cg_rlock_0(&pool->data_lock, "cgminer.c", _func___13928, 7639);
          v11 = pool->nonce1 && !strcmp((const char *)work->nonce1, (const char *)pool->nonce1);
          sessionid_match = v11;
          cg_runlock_0(&pool->data_lock, "cgminer.c", _func___13928, 7641);
          if ( !sessionid_match )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "No matching session id for resubmitting stratum share");
              applog(7, tmp42, 0);
            }
            break;
          }
          sleep(2u);
        }
        if ( !submitted )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Failed to submit stratum share, discarding");
            applog(7, tmp42, 0);
          }
          free_work(&work, "cgminer.c", _func___13928, 7656);
          free(sshare);
          ++pool->stale_shares;
          ++total_stale;
        }
        else
        {
          sshare->sshare_sent = time(0);
          ssdiff = sshare->sshare_sent - sshare->sshare_time;
          if ( (opt_debug || ssdiff > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Pool %d stratum share submission lag time %d seconds",
              pool->pool_no,
              ssdiff);
            applog(6, tmp42, 0);
          }
        }
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d asking for inappropriately long nonce2 length %d",
          pool->pool_no,
          work->nonce2_len);
        applog(3, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "Not attempting to submit shares");
        applog(3, tmp42, 0);
      }
      free_work(&work, "cgminer.c", _func___13928, 7545);
    }
  }
  tq_freeze(pool->stratum_q);
  return 0;
}
// 23064: conditional instruction was optimized away because %_hj_k.4==4

//----- (00023CD8) --------------------------------------------------------
void __cdecl init_stratum_threads(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  have_longpoll = 1;
  if ( pthread_create(&pool->stratum_sthread, 0, (void *(*)(void *))stratum_sthread, pool) )
  {
    strcpy((char *)tmp42, "Failed to create stratum sthread");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_create(&pool->stratum_rthread, 0, (void *(*)(void *))stratum_rthread, pool) )
  {
    strcpy((char *)tmp42, "Failed to create stratum rthread");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00023DA0) --------------------------------------------------------
bool __cdecl stratum_works(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %d stratum %s", pool->pool_no, (const char *)pool->stratum_url);
    applog(6, tmp42, 0);
  }
  return extract_sockaddr(pool->stratum_url, &pool->sockaddr_url, &pool->stratum_port) && initiate_stratum(pool);
}

//----- (00023E64) --------------------------------------------------------
bool __cdecl setup_gbt_solo(CURL *curl, pool *pool)
{
  return 0;
}

//----- (00023E7C) --------------------------------------------------------
void __cdecl pool_start_lp(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( !pool->lp_started )
  {
    pool->lp_started = 1;
    if ( pthread_create(&pool->longpoll_thread, 0, (void *(*)(void *))longpoll_thread, pool) )
    {
      strcpy((char *)tmp42, "Failed to create pool longpoll thread");
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (00023F08) --------------------------------------------------------
bool __cdecl pool_active(pool *pool, bool pinging)
{
  bool v2; // r3
  unsigned __int8 *v4; // r3
  size_t v5; // r4
  const char *v6; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  work *work; // [sp+814h] [bp+80Ch] BYREF
  timeval tv_getwork_reply; // [sp+818h] [bp+810h] BYREF
  timeval tv_getwork; // [sp+820h] [bp+818h] BYREF
  size_t siz; // [sp+828h] [bp+820h]
  unsigned __int8 *copy_start; // [sp+82Ch] [bp+824h]
  unsigned __int8 *hdr_path; // [sp+830h] [bp+828h]
  bool rc; // [sp+837h] [bp+82Fh]
  CURL *curl; // [sp+844h] [bp+83Ch]
  bool ret_0; // [sp+84Ah] [bp+842h]
  json_t_0 *val; // [sp+850h] [bp+848h]
  bool need_slash; // [sp+857h] [bp+84Fh]
  bool ret; // [sp+867h] [bp+85Fh]

  val = 0;
  ret = 0;
  if ( pool->has_gbt )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Retrieving block template from pool %s", (const char *)pool->rpc_url);
      applog(7, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %s", (const char *)pool->rpc_url);
    applog(6, tmp42, 0);
  }
  while ( 1 )
  {
    if ( pool->has_stratum )
    {
      if ( pool_tset(pool, &pool->stratum_init) )
        return pool->stratum_active;
      v2 = initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool);
      ret_0 = v2;
      if ( v2 )
        init_stratum_threads(pool);
      else
        pool_tclear(pool, &pool->stratum_init);
      return ret_0;
    }
    curl = curly;
    if ( !curly )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "CURL initialisation failed");
        applog(3, tmp42, 0);
      }
      return 0;
    }
    if ( !pool->probed )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Probing for GBT support");
        applog(7, tmp42, 0);
      }
      val = 0;
      pool->probed = 0;
      if ( pool->has_gbt )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "GBT coinbase + append support found, switching to GBT protocol");
          applog(7, tmp42, 0);
        }
      }
      else if ( pool->gbt_solo )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "GBT coinbase without append found, switching to GBT solo protocol");
          applog(7, tmp42, 0);
        }
      }
      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "No GBT coinbase + append support found, pool unusable if it has no stratum");
        applog(7, tmp42, 0);
      }
    }
    cgtime(&tv_getwork);
    val = 0;
    cgtime(&tv_getwork_reply);
    if ( !pool->stratum_url || opt_fix_protocol || !stratum_works(pool) )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Switching pool %d %s to %s",
        pool->pool_no,
        (const char *)pool->rpc_url,
        (const char *)pool->stratum_url);
      applog(5, tmp42, 0);
    }
    if ( !pool->rpc_url )
      pool->rpc_url = (unsigned __int8 *)strdup((const char *)pool->stratum_url);
    pool->has_stratum = 1;
  }
  if ( !pool->has_stratum && !pool->gbt_solo && !pool->has_gbt )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "No Stratum, GBT or Solo support in pool %d %s unable to use",
        pool->pool_no,
        (const char *)pool->rpc_url);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  else
  {
    if ( val )
    {
      work = make_work();
      rc = 0;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Successfully retrieved but FAILED to decipher work from pool %u %s",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(7, tmp42, 0);
      }
      free_work(&work, "cgminer.c", _func___14035, 7977);
      if ( !pool->lp_url )
      {
        if ( pool->hdr_path )
        {
          need_slash = 0;
          hdr_path = pool->hdr_path;
          if ( strstr((const char *)hdr_path, "://") )
          {
            pool->lp_url = hdr_path;
            hdr_path = 0;
          }
          else
          {
            if ( *hdr_path == 47 )
              v4 = hdr_path + 1;
            else
              v4 = hdr_path;
            copy_start = v4;
            if ( pool->rpc_url[strlen((const char *)pool->rpc_url) - 1] != 47 )
              need_slash = 1;
            v5 = strlen((const char *)pool->rpc_url);
            siz = v5 + strlen((const char *)copy_start) + 2;
            pool->lp_url = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___14035, 8010);
            if ( need_slash )
              v6 = "/";
            else
              v6 = &byte_71100;
            snprintf((char *)pool->lp_url, siz, "%s%s%s", (const char *)pool->rpc_url, v6, (const char *)copy_start);
          }
        }
        else
        {
          pool->lp_url = 0;
        }
        pool_start_lp(pool);
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "FAILED to retrieve work from pool %u %s",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(7, tmp42, 0);
      }
      if ( !pinging && !pool->idle && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %u slow/down or URL or credentials invalid", pool->pool_no);
        applog(4, tmp42, 0);
      }
    }
    if ( val )
      json_decref_0(val);
    return ret;
  }
}
// 71100: using guessed type char byte_71100;

//----- (00024A80) --------------------------------------------------------
void __cdecl pool_resus(pool *pool)
{
  int prio; // r4
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  pool->seq_getfails = 0;
  if ( pool_strategy_0 || (prio = pool->prio, prio >= cp_prio()) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s alive", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d %s alive, testing stability", pool->pool_no, (const char *)pool->rpc_url);
    applog(4, tmp42, 0);
  }
}

//----- (00024B7C) --------------------------------------------------------
work *__cdecl hash_pop(bool blocking)
{
  int num_items; // r3
  work *next; // r3
  work *v3; // r3
  UT_hash_bucket_0 *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  timeval now; // [sp+808h] [bp+808h] BYREF
  timespec then; // [sp+810h] [bp+810h] BYREF
  unsigned int _hd_bkt; // [sp+818h] [bp+818h]
  UT_hash_handle *_hd_hh_del; // [sp+81Ch] [bp+81Ch]
  int hc; // [sp+820h] [bp+820h]
  work *tmp; // [sp+828h] [bp+828h]
  work *work; // [sp+82Ch] [bp+82Ch]

  work = 0;
  mutex_lock_0(stgd_lock, "cgminer.c", _func___14056, 8063);
  if ( !staged_work || !staged_work->hh.tbl->num_items )
  {
    work_emptied = 1;
    if ( !blocking )
      goto out_unlock;
    do
    {
      cgtime(&now);
      then.tv_sec = now.tv_sec + 10;
      then.tv_nsec = 1000 * now.tv_usec;
      pthread_cond_signal(&gws_cond);
      if ( pthread_cond_timedwait(&getq->cond, stgd_lock, &then) )
      {
        if ( !no_work )
        {
          no_work = 1;
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy((char *)tmp42, "Waiting for work to be available from pools.");
            applog(4, tmp42, 0);
          }
        }
      }
    }
    while ( !staged_work || !staged_work->hh.tbl->num_items );
  }
  if ( no_work )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Work available from pools, resuming.");
      applog(4, tmp42, 0);
    }
    no_work = 0;
  }
  if ( staged_work )
    num_items = staged_work->hh.tbl->num_items;
  else
    num_items = 0;
  hc = num_items;
  if ( num_items <= staged_rollable )
  {
    work = staged_work;
  }
  else
  {
    work = staged_work;
    if ( staged_work )
      next = (work *)staged_work->hh.next;
    else
      next = 0;
    tmp = next;
    while ( work && work_rollable(work) )
    {
      work = tmp;
      if ( tmp )
        v3 = (work *)tmp->hh.next;
      else
        v3 = 0;
      tmp = v3;
    }
  }
  if ( work->hh.prev || work->hh.next )
  {
    _hd_hh_del = &work->hh;
    if ( (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) == work )
      staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
    if ( work->hh.prev )
      *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
    else
      staged_work = (work *)work->hh.next;
    if ( _hd_hh_del->next )
      *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
    _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
    v4 = &staged_work->hh.tbl->buckets[_hd_bkt];
    --v4->count;
    if ( staged_work->hh.tbl->buckets[_hd_bkt].hh_head == _hd_hh_del )
      staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
    if ( _hd_hh_del->hh_prev )
      _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
    if ( _hd_hh_del->hh_next )
      _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
    --staged_work->hh.tbl->num_items;
  }
  else
  {
    free(staged_work->hh.tbl->buckets);
    free(staged_work->hh.tbl);
    staged_work = 0;
  }
  if ( work_rollable(work) )
    --staged_rollable;
  pthread_cond_signal(&gws_cond);
  pthread_cond_signal(&getq->cond);
  last_getwork = time(0);
out_unlock:
  mutex_unlock_0(stgd_lock, "cgminer.c", _func___14056, 8135);
  return work;
}

//----- (000250A4) --------------------------------------------------------
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len)
{
  unsigned __int8 hash1[32]; // [sp+10h] [bp+10h] BYREF

  sha256(data, len, hash1);
  sha256(hash1, 0x20u, hash);
}

//----- (000250D8) --------------------------------------------------------
void __cdecl set_target(unsigned __int8 *dest_target, double diff)
{
  double v2; // d0
  double diffa; // [sp+8h] [bp+0h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 target[32]; // [sp+818h] [bp+810h] BYREF
  unsigned __int8 *htarget; // [sp+838h] [bp+830h]
  uint64_t *data64; // [sp+83Ch] [bp+834h]
  uint64_t h64; // [sp+840h] [bp+838h]
  double dcut64; // [sp+848h] [bp+840h]
  double d64; // [sp+850h] [bp+848h]

  diffa = v2;
  if ( v2 == 0.0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "Diff zero passed to set_target");
      applog(3, tmp42, 0);
    }
    diffa = 1.0;
  }
  dcut64 = 2.69595353e67 / diffa / 6.27710174e57;
  *(_QWORD *)&target[24] = (unsigned __int64)dcut64;
  dcut64 = (double)(unsigned __int64)dcut64 * 6.27710174e57;
  d64 = 2.69595353e67 / diffa - dcut64;
  h64 = (unsigned __int64)(d64 / 3.40282367e38);
  *(_QWORD *)&target[16] = h64;
  dcut64 = (double)h64 * 3.40282367e38;
  d64 = d64 - dcut64;
  h64 = (unsigned __int64)(d64 / 1.84467441e19);
  *(_QWORD *)&target[8] = h64;
  dcut64 = (double)h64 * 1.84467441e19;
  d64 = d64 - dcut64;
  h64 = (unsigned __int64)d64;
  data64 = (uint64_t *)target;
  *(_QWORD *)target = (unsigned __int64)d64;
  if ( opt_debug )
  {
    htarget = bin2hex(target, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated target %s", (const char *)htarget);
      applog(7, tmp42, 0);
    }
    free(htarget);
  }
  cg_memcpy(dest_target, target, 0x20u, "cgminer.c", _func___14088, 8197);
}
// 250E8: variable 'v2' is possibly undefined

//----- (00025470) --------------------------------------------------------
void __cdecl get_work_by_nonce2(
        thr_info *thr,
        work **work,
        pool *pool,
        pool *real_pool,
        uint64_t nonce2,
        unsigned int ntime,
        unsigned int version)
{
  int thr_id; // [sp+24h] [bp+1Ch]

  *work = make_work();
  thr_id = thr->id;
  cg_wlock_0(&pool->data_lock, "cgminer.c", _func___14101, 8214);
  pool->nonce2 = nonce2;
  version = (version << 24) | HIBYTE(version) | ((version & 0xFF0000) >> 8) | ((version & 0xFF00) << 8);
  cg_memcpy(pool->header_bin, &version, 4u, "cgminer.c", _func___14101, 8218);
  cg_wunlock_0(&pool->data_lock, "cgminer.c", _func___14101, 8219);
  gen_stratum_work(pool, *work);
  (*work)->pool = real_pool;
  (*work)->thr_id = thr_id;
  (*work)->work_block = work_block;
  ++(*work)->pool->works;
  (*work)->mined = 1;
  (*work)->version = version;
}

//----- (0002558C) --------------------------------------------------------
void __cdecl gen_stratum_work(pool *pool, work *work)
{
  uint64_t nonce2; // r2
  double v3; // r2
  double v4; // r2
  work *worka; // [sp+10h] [bp+0h] BYREF
  pool *poola; // [sp+14h] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  uint64_t nonce2le; // [sp+818h] [bp+808h] BYREF
  unsigned __int8 merkle_sha[64]; // [sp+820h] [bp+810h] BYREF
  unsigned __int8 merkle_root[32]; // [sp+860h] [bp+850h] BYREF
  int diff; // [sp+880h] [bp+870h]
  unsigned __int8 *merkle_hash; // [sp+884h] [bp+874h]
  unsigned __int8 *header; // [sp+888h] [bp+878h]
  unsigned int *swap32; // [sp+88Ch] [bp+87Ch]
  unsigned int *data32; // [sp+890h] [bp+880h]
  int i; // [sp+894h] [bp+884h]

  poola = pool;
  worka = work;
  cg_wlock_0(&pool->data_lock, "cgminer.c", _func___14112, 8245);
  nonce2le = poola->nonce2;
  cg_memcpy(&poola->coinbase[poola->nonce2_offset], &nonce2le, poola->n2size, "cgminer.c", _func___14112, 8250);
  nonce2 = poola->nonce2;
  worka->nonce2 = nonce2;
  poola->nonce2 = nonce2 + 1;
  worka->nonce2_len = poola->n2size;
  cg_dwlock(&poola->data_lock, "cgminer.c", _func___14112, 8256);
  gen_hash(poola->coinbase, merkle_root, poola->coinbase_len);
  cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", _func___14112, 8260);
  for ( i = 0; poola->merkles > i; ++i )
  {
    cg_memcpy(&merkle_sha[32], poola->swork.merkle_bin[i], 0x20u, "cgminer.c", _func___14112, 8264);
    gen_hash(merkle_sha, merkle_root, 64);
    cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", _func___14112, 8266);
  }
  data32 = (unsigned int *)merkle_sha;
  swap32 = (unsigned int *)merkle_root;
  flip32(merkle_root, merkle_sha);
  cg_memcpy(worka, poola->header_bin, 0x70u, "cgminer.c", _func___14112, 8275);
  cg_memcpy(&worka->data[36], merkle_root, 0x20u, "cgminer.c", _func___14112, 8276);
  worka->sdiff = poola->sdiff;
  worka->job_id = (unsigned __int8 *)strdup((const char *)poola->swork.job_id);
  worka->nonce1 = (unsigned __int8 *)strdup((const char *)poola->nonce1);
  worka->ntime = (unsigned __int8 *)strdup((const char *)poola->ntime);
  cg_runlock_0(&poola->data_lock, "cgminer.c", _func___14112, 8287);
  if ( opt_debug )
  {
    header = bin2hex(worka->data, 0x70u);
    merkle_hash = bin2hex(merkle_root, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated stratum merkle %s", (const char *)merkle_hash);
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated stratum header %s", (const char *)header);
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Work job_id %s nonce2 %llu ntime %s",
        (const char *)worka->job_id,
        worka->nonce2,
        (const char *)worka->ntime);
      applog(7, tmp42, 0);
    }
    free(header);
    free(merkle_hash);
  }
  calc_midstate(worka);
  HIDWORD(v3) = worka->target;
  LODWORD(v3) = worka;
  set_target(worka->target, v3);
  ++local_work;
  if ( time(0) - local_work_lasttime > 5 )
  {
    diff = local_work - local_work_last;
    local_work_lasttime = time(0);
    local_work_last = local_work;
  }
  worka->pool = poola;
  worka->stratum = 1;
  worka->nonce = 0;
  worka->longpoll = 0;
  worka->getwork_mode = 83;
  worka->work_block = work_block;
  LODWORD(v4) = 60;
  worka->drv_rolllimit = 60;
  HIDWORD(v4) = &worka;
  calc_diff(worka, v4);
  cgtime(&worka->tv_staged);
}

//----- (00025ACC) --------------------------------------------------------
int __cdecl share_work_tdiff(cgpu_info *cgpu)
{
  return last_getwork - cgpu->last_device_valid_work;
}

//----- (00025AF4) --------------------------------------------------------
void __cdecl set_benchmark_work(cgpu_info *cgpu, work *work)
{
  cgpu->lodiff += cgpu->direction;
  if ( cgpu->lodiff <= 0 )
    cgpu->direction = 1;
  if ( cgpu->lodiff <= 15 )
  {
    cg_memcpy(work, bench_lodiff_bins[cgpu->lodiff], 0xA0u, "cgminer.c", _func___14129, 8512);
  }
  else
  {
    cgpu->direction = -1;
    if ( ++cgpu->hidiff > 15 )
      cgpu->hidiff = 0;
    cg_memcpy(work, bench_hidiff_bins[cgpu->hidiff], 0xA0u, "cgminer.c", _func___14129, 8508);
  }
}

//----- (00025BD8) --------------------------------------------------------
work *__cdecl get_work(thr_info *thr, const int thr_id)
{
  double max_diff; // r2
  double device_diff; // r2
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  work *work; // [sp+80Ch] [bp+80Ch] BYREF
  time_t diff_t; // [sp+810h] [bp+810h]
  cgpu_info *cgpu; // [sp+814h] [bp+814h]

  cgpu = thr->cgpu;
  work = 0;
  thread_reportout(thr);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Popping work from get queue to get work");
    applog(7, tmp42, 0);
  }
  diff_t = time(0);
  while ( !work )
  {
    work = hash_pop(1);
    if ( stale_work(work, 0) )
    {
      discard_work(&work, "cgminer.c", _func___14138, 8531);
      wake_gws();
    }
  }
  diff_t = time(0) - diff_t;
  if ( diff_t > 0 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Get work blocked for %d seconds", diff_t);
      applog(7, tmp42, 0);
    }
    cgpu->last_device_valid_work += diff_t;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Got work from get queue to get work for thread %d", thr_id);
    applog(7, tmp42, 0);
  }
  work->thr_id = thr_id;
  if ( opt_benchmark )
    set_benchmark_work(cgpu, work);
  thread_reportin(thr);
  work->mined = 1;
  if ( cgpu->drv->max_diff <= work->work_difficulty )
    max_diff = cgpu->drv->max_diff;
  else
    max_diff = work->work_difficulty;
  work->device_diff = max_diff;
  if ( cgpu->drv->min_diff <= work->device_diff )
    device_diff = work->device_diff;
  else
    device_diff = cgpu->drv->min_diff;
  work->device_diff = device_diff;
  return work;
}

//----- (00025E68) --------------------------------------------------------
void __cdecl submit_work_async(work *work)
{
  work *worka[2]; // [sp+Ch] [bp+4h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  pthread_t submit_thread; // [sp+814h] [bp+80Ch] BYREF
  cgpu_info *cgpu; // [sp+818h] [bp+810h]
  pool *pool; // [sp+81Ch] [bp+814h]

  worka[0] = work;
  pool = work->pool;
  cgtime(&work->tv_work_found);
  if ( opt_benchmark )
  {
    cgpu = get_thr_cgpu(worka[0]->thr_id);
    mutex_lock_0(&stats_lock, "cgminer.c", _func___14150, 8575);
    ++cgpu->accepted;
    ++total_accepted;
    ++pool->accepted;
    cgpu->diff_accepted = cgpu->diff_accepted + worka[0]->work_difficulty;
    total_diff_accepted = worka[0]->work_difficulty + total_diff_accepted;
    pool->diff_accepted = pool->diff_accepted + worka[0]->work_difficulty;
    mutex_unlock_0(&stats_lock, "cgminer.c", _func___14150, 8582);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Accepted %s %d benchmark share nonce %08x",
        (const char *)cgpu->drv->name,
        cgpu->device_id,
        *(_DWORD *)&worka[0]->data[76]);
      applog(5, tmp42, 0);
    }
    return;
  }
  if ( !stale_work(worka[0], 1) )
    goto LABEL_23;
  if ( opt_submit_stale )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as user requested", pool->pool_no);
      applog(5, tmp42, 0);
    }
LABEL_22:
    worka[0]->stale = 1;
LABEL_23:
    if ( worka[0]->stratum )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Pushing pool %d work to stratum queue", pool->pool_no);
        applog(7, tmp42, 0);
      }
      if ( !pool->stratum_q || !tq_push(pool->stratum_q, worka[0]) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Discarding work from removed pool");
          applog(7, tmp42, 0);
        }
        free_work(worka, "cgminer.c", _func___14150, 8624);
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Pushing submit work to work thread");
        applog(7, tmp42, 0);
      }
      if ( pthread_create(&submit_thread, 0, (void *(*)(void *))submit_work_thread, worka[0]) )
      {
        strcpy((char *)tmp42, "Failed to create submit_work_thread");
        applog(3, tmp42, 1);
        quit(1);
      }
    }
    return;
  }
  if ( pool->submit_old )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as pool requested", pool->pool_no);
      applog(5, tmp42, 0);
    }
    goto LABEL_22;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, discarding", pool->pool_no);
    applog(5, tmp42, 0);
  }
  sharelog("discard", worka[0]);
  mutex_lock_0(&stats_lock, "cgminer.c", _func___14150, 8603);
  ++total_stale;
  ++pool->stale_shares;
  total_diff_stale = worka[0]->work_difficulty + total_diff_stale;
  pool->diff_stale = pool->diff_stale + worka[0]->work_difficulty;
  mutex_unlock_0(&stats_lock, "cgminer.c", _func___14150, 8610);
  free_work(worka, "cgminer.c", _func___14150, 8612);
}

//----- (000263F4) --------------------------------------------------------
void __cdecl inc_hw_errors(thr_info *thr)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s %d: invalid nonce - HW error",
      (const char *)thr->cgpu->drv->name,
      thr->cgpu->device_id);
    applog(6, tmp42, 0);
  }
  mutex_lock_0(&stats_lock, "cgminer.c", _func___14163, 8641);
  ++hw_errors;
  ++thr->cgpu->hw_errors;
  mutex_unlock_0(&stats_lock, "cgminer.c", _func___14163, 8644);
  thr->cgpu->drv->hw_error(thr);
}

//----- (000264E0) --------------------------------------------------------
void __cdecl inc_hw_errors_with_diff(thr_info *thr, int diff)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s%d: invalid nonce - HW error",
      (const char *)thr->cgpu->drv->name,
      thr->cgpu->device_id);
    applog(3, tmp42, 0);
  }
  mutex_lock_0(&stats_lock, "cgminer.c", _func___14169, 8654);
  hw_errors += diff;
  thr->cgpu->hw_errors += diff;
  mutex_unlock_0(&stats_lock, "cgminer.c", _func___14169, 8657);
  thr->cgpu->drv->hw_error(thr);
}

//----- (000265E0) --------------------------------------------------------
void __cdecl inc_dev_status(int max_fan, int max_temp)
{
  mutex_lock_0(&stats_lock, "cgminer.c", _func___14174, 8666);
  g_max_fan = max_fan;
  g_max_temp = max_temp;
  mutex_unlock_0(&stats_lock, "cgminer.c", _func___14174, 8669);
}

//----- (0002664C) --------------------------------------------------------
void __cdecl rebuild_nonce(work *work, unsigned int nonce)
{
  *(_DWORD *)&work->data[76] = nonce;
  regen_hash(work);
}

//----- (00026670) --------------------------------------------------------
bool __cdecl test_nonce(work *work, unsigned int nonce)
{
  unsigned int *hash_32; // [sp+Ch] [bp+Ch]

  hash_32 = (unsigned int *)&work->hash[28];
  rebuild_nonce(work, nonce);
  return *hash_32 == 0;
}

//----- (000266A0) --------------------------------------------------------
bool __cdecl test_nonce_diff(work *work, unsigned int nonce, double diff)
{
  double v3; // d0
  uint64_t *hash64; // [sp+1Ch] [bp+1Ch]

  hash64 = (uint64_t *)&work->hash[24];
  rebuild_nonce(work, nonce);
  return (unsigned __int64)((double)0xFFFF0000uLL / v3) >= *hash64;
}
// 266E0: variable 'v3' is possibly undefined

//----- (00026714) --------------------------------------------------------
void __cdecl update_work_stats(thr_info *thr, work *work)
{
  cgpu_info *cgpu; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  double test_diff; // [sp+808h] [bp+808h]

  test_diff = current_diff;
  work->share_diff = share_diff(work);
  if ( (double)work->share_diff >= test_diff )
  {
    work->block = 1;
    ++work->pool->solved;
    ++found_blocks;
    work->mandatory = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Found block for pool %d!", work->pool->pool_no);
      applog(5, tmp42, 0);
    }
  }
  mutex_lock_0(&stats_lock, "cgminer.c", _func___14198, 8719);
  total_diff1 = (__int64)((double)total_diff1 + work->device_diff);
  thr->cgpu->diff1 = (__int64)((double)thr->cgpu->diff1 + work->device_diff);
  work->pool->diff1 = (__int64)((double)work->pool->diff1 + work->device_diff);
  cgpu = thr->cgpu;
  cgpu->last_device_valid_work = time(0);
  mutex_unlock_0(&stats_lock, "cgminer.c", _func___14198, 8724);
}

//----- (0002690C) --------------------------------------------------------
void __cdecl inc_work_stats(thr_info *thr, pool *pool, int diff1)
{
  pool *v3; // r0
  cgpu_info *cgpu; // r4

  mutex_lock_0(&stats_lock, "cgminer.c", _func___14204, 8729);
  total_diff1 += diff1;
  thr->cgpu->diff1 += diff1;
  if ( pool )
  {
    pool->diff1 += diff1;
  }
  else
  {
    v3 = current_pool();
    v3->diff1 += diff1;
  }
  cgpu = thr->cgpu;
  cgpu->last_device_valid_work = time(0);
  mutex_unlock_0(&stats_lock, "cgminer.c", _func___14204, 8743);
}

//----- (000269F0) --------------------------------------------------------
bool __cdecl submit_tested_work(thr_info *thr, work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  work *work_out; // [sp+814h] [bp+80Ch]

  update_work_stats(thr, work);
  if ( !fulltest(work->hash, work->target) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s %s %d: Share above target",
        (const char *)_FUNCTION___14211,
        (const char *)thr->cgpu->drv->name,
        thr->cgpu->device_id);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    work_out = copy_work_noffset(work, 0);
    submit_work_async(work_out);
    return 1;
  }
}

//----- (00026AC0) --------------------------------------------------------
bool __cdecl new_nonce(thr_info *thr, unsigned int nonce)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  cgpu_info *cgpu; // [sp+814h] [bp+80Ch]

  cgpu = thr->cgpu;
  if ( cgpu->last_nonce == nonce )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s %d duplicate share detected as HW error",
        (const char *)cgpu->drv->name,
        cgpu->device_id);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    cgpu->last_nonce = nonce;
    return 1;
  }
}

//----- (00026B64) --------------------------------------------------------
bool __cdecl Hex2Bin(unsigned __int8 *hex, unsigned __int8 *pBytes)
{
  unsigned __int8 tmp; // [sp+Fh] [bp+Fh]
  int j; // [sp+10h] [bp+10h]
  unsigned int i; // [sp+14h] [bp+14h]

  j = 0;
  for ( i = 0; i < strlen((const char *)hex); ++i )
  {
    if ( hex[i] <= 0x2Fu || hex[i] > 0x39u )
    {
      if ( hex[i] <= 0x60u || hex[i] > 0x66u )
      {
        if ( hex[i] <= 0x40u || hex[i] > 0x46u )
          return 0;
        tmp = hex[i] - 55;
      }
      else
      {
        tmp = hex[i] - 87;
      }
    }
    else
    {
      tmp = hex[i] - 48;
    }
    if ( (i & 1) != 0 )
      pBytes[j++] += tmp;
    else
      pBytes[j] = 16 * tmp;
  }
  return 1;
}

//----- (00026C44) --------------------------------------------------------
int __cdecl getChipIndex(unsigned __int8 *nonce4)
{
  unsigned __int8 nonce_bytes[4]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 nonce[9]; // [sp+10h] [bp+10h] BYREF

  if ( !Hex2Bin(nonce, nonce_bytes) )
    return -1;
  return nonce_bytes[0] >> 2;
}

//----- (00026C7C) --------------------------------------------------------
void __cdecl cg_savelogwork(work *work, unsigned __int8 *nonce_bin)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  size_t v14; // r0
  unsigned __int8 midstate_tmp[32]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 data_tmp[32]; // [sp+34h] [bp+2Ch] BYREF
  unsigned __int8 hash_tmp[32]; // [sp+54h] [bp+4Ch] BYREF
  unsigned __int8 szmsg[1024]; // [sp+74h] [bp+6Ch] BYREF
  int chipIndex; // [sp+474h] [bp+46Ch]
  uint64_t worksharediff; // [sp+478h] [bp+470h]
  int asicnum; // [sp+484h] [bp+47Ch]
  unsigned __int8 *szhash; // [sp+488h] [bp+480h]
  unsigned __int8 *sznonce5; // [sp+48Ch] [bp+484h]
  unsigned __int8 *sznonce4; // [sp+490h] [bp+488h]
  unsigned __int8 *szdata; // [sp+494h] [bp+48Ch]
  unsigned __int8 *szmidstate; // [sp+498h] [bp+490h]
  unsigned __int8 *szworkdata; // [sp+49Ch] [bp+494h]

  if ( !fd_log )
    fd_log = fopen("/etc/config/worklog.txt", "wb");
  memset(szmsg, 0, sizeof(szmsg));
  memset(midstate_tmp, 0, sizeof(midstate_tmp));
  memset(data_tmp, 0, sizeof(data_tmp));
  memset(hash_tmp, 0, sizeof(hash_tmp));
  szworkdata = 0;
  szmidstate = 0;
  szdata = 0;
  sznonce4 = 0;
  sznonce5 = 0;
  szhash = 0;
  asicnum = 0;
  worksharediff = 0LL;
  v2 = *(_DWORD *)&work->midstate[4];
  v3 = *(_DWORD *)&work->midstate[8];
  v4 = *(_DWORD *)&work->midstate[12];
  *(_DWORD *)midstate_tmp = *(_DWORD *)work->midstate;
  *(_DWORD *)&midstate_tmp[4] = v2;
  *(_DWORD *)&midstate_tmp[8] = v3;
  *(_DWORD *)&midstate_tmp[12] = v4;
  v5 = *(_DWORD *)&work->midstate[20];
  v6 = *(_DWORD *)&work->midstate[24];
  v7 = *(_DWORD *)&work->midstate[28];
  *(_DWORD *)&midstate_tmp[16] = *(_DWORD *)&work->midstate[16];
  *(_DWORD *)&midstate_tmp[20] = v5;
  *(_DWORD *)&midstate_tmp[24] = v6;
  *(_DWORD *)&midstate_tmp[28] = v7;
  memcpy(data_tmp, &work->data[64], 0xCu);
  v8 = *(_DWORD *)&work->hash[4];
  v9 = *(_DWORD *)&work->hash[8];
  v10 = *(_DWORD *)&work->hash[12];
  *(_DWORD *)hash_tmp = *(_DWORD *)work->hash;
  *(_DWORD *)&hash_tmp[4] = v8;
  *(_DWORD *)&hash_tmp[8] = v9;
  *(_DWORD *)&hash_tmp[12] = v10;
  v11 = *(_DWORD *)&work->hash[20];
  v12 = *(_DWORD *)&work->hash[24];
  v13 = *(_DWORD *)&work->hash[28];
  *(_DWORD *)&hash_tmp[16] = *(_DWORD *)&work->hash[16];
  *(_DWORD *)&hash_tmp[20] = v11;
  *(_DWORD *)&hash_tmp[24] = v12;
  *(_DWORD *)&hash_tmp[28] = v13;
  rev(midstate_tmp, 0x20u);
  rev(data_tmp, 0xCu);
  rev(hash_tmp, 0x20u);
  szworkdata = bin2hex(work->data, 0x80u);
  szmidstate = bin2hex(midstate_tmp, 0x20u);
  szdata = bin2hex(data_tmp, 0xCu);
  sznonce4 = bin2hex(nonce_bin, 4u);
  sznonce5 = bin2hex(nonce_bin, 5u);
  szhash = bin2hex(hash_tmp, 0x20u);
  worksharediff = share_ndiff(work);
  chipIndex = getChipIndex(sznonce4);
  sprintf(
    (char *)szmsg,
    "midstate %s data %s nonce %s \r\n",
    (const char *)szmidstate,
    (const char *)szdata,
    (const char *)sznonce4);
  v14 = strlen((const char *)szmsg);
  fwrite(szmsg, v14, 1u, fd_log);
  fflush(fd_log);
  if ( szworkdata )
    free(szworkdata);
  if ( szmidstate )
    free(szmidstate);
  if ( szdata )
    free(szdata);
  if ( sznonce4 )
    free(sznonce4);
  if ( sznonce5 )
    free(sznonce5);
  if ( szhash )
    free(szhash);
}

//----- (00026F58) --------------------------------------------------------
void __cdecl cg_savelogwork_uint32(work *work, unsigned int nonce)
{
  unsigned int noncea; // [sp+0h] [bp+0h] BYREF
  work *worka; // [sp+4h] [bp+4h]
  unsigned __int8 nonce_bin[5]; // [sp+8h] [bp+8h] BYREF

  worka = work;
  noncea = nonce;
  nonce_bin[4] = 0;
  memcpy(nonce_bin, &noncea, 4u);
  cg_savelogwork(worka, nonce_bin);
}

//----- (00026F90) --------------------------------------------------------
bool __cdecl savelog_nonce(work *work, unsigned int nonce)
{
  _BOOL4 v2; // r3

  v2 = test_nonce(work, nonce);
  if ( v2 )
    cg_savelogwork_uint32(work, nonce);
  return v2;
}
// 26FB0: variable 'v2' is possibly undefined

//----- (00026FBC) --------------------------------------------------------
bool __cdecl submit_nonce(thr_info *thr, work *work, unsigned int nonce)
{
  if ( new_nonce(thr, nonce) && test_nonce(work, nonce) )
  {
    submit_tested_work(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
      benchfile_dspwork(work, nonce);
    return 1;
  }
  else
  {
    inc_hw_errors(thr);
    return 0;
  }
}

//----- (00027028) --------------------------------------------------------
bool __cdecl submit_nonce_1(thr_info *thr, work *work, unsigned int nonce, int *nofull)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+10h] BYREF

  if ( nofull )
    *nofull = 0;
  if ( test_nonce(work, nonce) )
  {
    update_work_stats(thr, work);
    if ( !fulltest(work->hash, work->target) )
    {
      if ( nofull )
        *nofull = 1;
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        strcpy((char *)tmp42, "Share above target");
        applog(6, tmp42, 0);
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    inc_hw_errors(thr);
    return 0;
  }
}

//----- (00027124) --------------------------------------------------------
void __cdecl submit_nonce_2(work *work)
{
  work *work_out; // [sp+Ch] [bp+Ch]

  work_out = copy_work_noffset(work, 0);
  submit_work_async(work_out);
}

//----- (00027144) --------------------------------------------------------
bool __cdecl submit_nonce_direct(thr_info *thr, work *work, unsigned int nonce)
{
  work *work_out; // [sp+10h] [bp+10h]

  *(_DWORD *)&work->data[76] = nonce;
  work_out = copy_work_noffset(work, 0);
  submit_work_async(work_out);
  return 1;
}

//----- (00027178) --------------------------------------------------------
bool __cdecl submit_noffset_nonce(thr_info *thr, work *work_in, unsigned int nonce, int noffset)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+10h] BYREF
  work *work; // [sp+818h] [bp+810h] BYREF
  bool ret; // [sp+81Fh] [bp+817h]

  work = make_work();
  ret = 0;
  copy_work(work, work_in, noffset);
  if ( !test_nonce(work, nonce) )
  {
    free_work(&work, "cgminer.c", _func___14296, 8981);
    inc_hw_errors(thr);
  }
  else
  {
    update_work_stats(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
      benchfile_dspwork(work, nonce);
    ret = 1;
    if ( !fulltest(work->hash, work->target) )
    {
      free_work(&work, "cgminer.c", _func___14296, 8997);
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s %d: Share above target",
          (const char *)thr->cgpu->drv->name,
          thr->cgpu->device_id);
        applog(6, tmp42, 0);
      }
    }
    else
    {
      submit_work_async(work);
    }
  }
  return ret;
}

//----- (00027304) --------------------------------------------------------
bool __cdecl abandon_work(work *work, timeval *wdiff, uint64_t hashes)
{
  return wdiff->tv_sec > opt_scantime || hashes > 0xFFFFFFFD || stale_work(work, 0);
}

//----- (00027358) --------------------------------------------------------
void __cdecl mt_disable(thr_info *mythr, const int thr_id, device_drv *drv)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+10h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being disabled", thr_id);
    applog(4, tmp42, 0);
  }
  mythr->cgpu->rolling = 0.0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Waiting on sem in miner thread");
    applog(7, tmp42, 0);
  }
  cgsem_wait(&mythr->sem, "cgminer.c", _func___14311, 9023);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being re-enabled", thr_id);
    applog(4, tmp42, 0);
  }
  drv->thread_enable(mythr);
}

//----- (000274CC) --------------------------------------------------------
void __cdecl hash_sole_work(thr_info *mythr)
{
  int v1; // r3
  bool v2; // r3
  double max_diff; // r2
  double device_diff; // r2
  bool v5; // zf
  int v6; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  timespec rgtp; // [sp+810h] [bp+808h] BYREF
  work *work; // [sp+818h] [bp+810h] BYREF
  timeval wdiff; // [sp+81Ch] [bp+814h] BYREF
  timeval diff; // [sp+824h] [bp+81Ch]
  timeval sdiff; // [sp+82Ch] [bp+824h]
  timeval tv_lastupdate; // [sp+834h] [bp+82Ch] BYREF
  timeval tv_workstart; // [sp+83Ch] [bp+834h] BYREF
  timeval tv_start; // [sp+844h] [bp+83Ch] BYREF
  timeval getwork_start; // [sp+84Ch] [bp+844h] BYREF
  int mult; // [sp+854h] [bp+84Ch]
  int64_t hashes; // [sp+858h] [bp+850h]
  cgminer_stats *pool_stats; // [sp+860h] [bp+858h]
  timeval *tv_end; // [sp+864h] [bp+85Ch]
  bool primary; // [sp+86Bh] [bp+863h]
  int cycle; // [sp+86Ch] [bp+864h]
  cgminer_stats *dev_stats; // [sp+870h] [bp+868h]
  device_drv *drv; // [sp+874h] [bp+86Ch]
  cgpu_info *cgpu; // [sp+878h] [bp+870h]
  int thr_id; // [sp+87Ch] [bp+874h]
  int64_t hashes_done; // [sp+880h] [bp+878h]
  unsigned int max_nonce; // [sp+88Ch] [bp+884h]

  thr_id = mythr->id;
  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  dev_stats = &cgpu->cgminer_stats;
  v1 = opt_log_interval / 5;
  if ( !(opt_log_interval / 5) )
    v1 = 1;
  cycle = v1;
  v2 = !mythr->device_thread || mythr->primary_thread;
  primary = v2;
  wdiff.tv_sec = 0;
  wdiff.tv_usec = 0;
  max_nonce = drv->can_limit_work(mythr);
  hashes_done = 0LL;
  tv_end = &getwork_start;
  cgtime(&getwork_start);
  sdiff.tv_usec = 0;
  sdiff.tv_sec = 0;
  cgtime(&tv_lastupdate);
  while ( !cgpu->shutdown )
  {
    work = get_work(mythr, thr_id);
    mythr->work_restart = 0;
    cgpu->new_work = 1;
    cgtime(&tv_workstart);
    work->nonce = 0;
    cgpu->max_hashes = 0LL;
    if ( !drv->prepare_work(mythr, work) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "work prepare failed, exiting mining thread %d", thr_id);
        applog(3, tmp42, 0);
      }
      break;
    }
    if ( drv->max_diff <= work->work_difficulty )
      max_diff = drv->max_diff;
    else
      max_diff = work->work_difficulty;
    work->device_diff = max_diff;
    if ( drv->min_diff <= work->device_diff )
      device_diff = work->device_diff;
    else
      device_diff = drv->min_diff;
    work->device_diff = device_diff;
    while ( 1 )
    {
      cgtime(&tv_start);
      subtime(&tv_start, &getwork_start);
      addtime(&getwork_start, &dev_stats->getwork_wait);
      if ( time_more(&getwork_start, &dev_stats->getwork_wait_max) )
        copy_time(&dev_stats->getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, &dev_stats->getwork_wait_min) )
        copy_time(&dev_stats->getwork_wait_min, &getwork_start);
      ++dev_stats->getwork_calls;
      pool_stats = &work->pool->cgminer_stats;
      addtime(&getwork_start, &pool_stats->getwork_wait);
      if ( time_more(&getwork_start, &pool_stats->getwork_wait_max) )
        copy_time(&pool_stats->getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, &pool_stats->getwork_wait_min) )
        copy_time(&pool_stats->getwork_wait_min, &getwork_start);
      ++pool_stats->getwork_calls;
      cgtime(&work->tv_work_start);
      pthread_setcancelstate(1, 0);
      thread_reportin(mythr);
      hashes = ((__int64 (__fastcall *)(thr_info *, work *, unsigned int, _DWORD))drv->scanhash)(
                 mythr,
                 work,
                 work->nonce + max_nonce,
                 0);
      thread_reportout(mythr);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      cgtime(&getwork_start);
      v5 = HIDWORD(hashes) == -1;
      if ( HIDWORD(hashes) == -1 )
        v5 = (_DWORD)hashes == -1;
      if ( v5 )
        break;
      hashes_done += hashes;
      if ( cgpu->max_hashes < hashes )
        cgpu->max_hashes = hashes;
      diff.tv_sec = tv_end->tv_sec - tv_start.tv_sec;
      diff.tv_usec = tv_end->tv_usec - tv_start.tv_usec;
      if ( diff.tv_usec < 0 )
      {
        --diff.tv_sec;
        diff.tv_usec += 1000000;
      }
      sdiff.tv_sec += diff.tv_sec;
      sdiff.tv_usec += diff.tv_usec;
      if ( sdiff.tv_usec > (int)&nonce_num[6][85][45] )
      {
        ++sdiff.tv_sec;
        sdiff.tv_usec -= 1000000;
      }
      wdiff.tv_sec = tv_end->tv_sec - tv_workstart.tv_sec;
      wdiff.tv_usec = tv_end->tv_usec - tv_workstart.tv_usec;
      if ( wdiff.tv_usec < 0 )
      {
        --wdiff.tv_sec;
        wdiff.tv_usec += 1000000;
      }
      if ( sdiff.tv_sec >= cycle )
      {
        if ( sdiff.tv_sec <= cycle )
        {
          if ( sdiff.tv_usec > 100000 )
            max_nonce = (max_nonce << 10)
                      / (((int)&nonce_num[6][85][45] * cycle + sdiff.tv_usec)
                       / ((int)&nonce_num[6][85][45]
                        * cycle
                        / 1024));
        }
        else
        {
          max_nonce = max_nonce * cycle / sdiff.tv_sec;
        }
      }
      else
      {
        if ( max_nonce == -1 )
          goto LABEL_70;
        v6 = sdiff.tv_usec + 1024;
        if ( sdiff.tv_usec + 1024 < 0 )
          v6 = sdiff.tv_usec + 2047;
        mult = cycle * ((int)&nonce_num[6][85][45] / (v6 >> 10) + 16);
        if ( 0xFFFFFC00 / mult >= max_nonce )
          max_nonce = (max_nonce * mult) >> 10;
        else
          max_nonce = -1;
      }
      diff.tv_sec = tv_end->tv_sec - tv_lastupdate.tv_sec;
      diff.tv_usec = tv_end->tv_usec - tv_lastupdate.tv_usec;
      if ( diff.tv_usec < 0 )
      {
        --diff.tv_sec;
        diff.tv_usec += 1000000;
      }
      if ( hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000) || diff.tv_sec >= opt_log_interval )
      {
        hashmeter(thr_id, hashes_done);
        hashes_done = 0LL;
        copy_time(&tv_lastupdate, tv_end);
      }
      if ( mythr->work_restart )
      {
        if ( !primary )
        {
          rgtp.tv_sec = 0;
          rgtp.tv_nsec = 250000000 * mythr->device_thread;
          nanosleep(&rgtp, 0);
        }
        goto LABEL_71;
      }
      if ( mythr->pause || cgpu->deven )
        mt_disable(mythr, thr_id, drv);
      sdiff.tv_usec = 0;
      sdiff.tv_sec = 0;
LABEL_70:
      if ( abandon_work(work, &wdiff, cgpu->max_hashes) )
        goto LABEL_71;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
      applog(3, tmp42, 0);
    }
    cgpu->deven = DEV_DISABLED;
    dev_error(cgpu, REASON_THREAD_ZERO_HASH);
    cgpu->shutdown = 1;
LABEL_71:
    free_work(&work, "cgminer.c", _func___14343, 9221);
  }
  cgpu->deven = DEV_DISABLED;
}
// 27550: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (00027C9C) --------------------------------------------------------
void __cdecl fill_queue(thr_info *mythr, cgpu_info *cgpu, device_drv *drv, const int thr_id)
{
  work *work; // [sp+10h] [bp+10h] BYREF
  bool need_work; // [sp+17h] [bp+17h]

  do
  {
    need_work = cgpu->unqueued_work == 0;
    if ( need_work )
    {
      work = get_work(mythr, thr_id);
      wr_lock_0(&cgpu->qlock, "cgminer.c", _func___14354, 9246);
      if ( cgpu->unqueued_work )
        need_work = 0;
      else
        cgpu->unqueued_work = work;
      wr_unlock(&cgpu->qlock, "cgminer.c", _func___14354, 9257);
      if ( !need_work )
        discard_work(&work, "cgminer.c", _func___14354, 9261);
    }
  }
  while ( !drv->queue_full(cgpu) );
}

//----- (00027D6C) --------------------------------------------------------
void __cdecl _add_queued(cgpu_info *cgpu, work *work)
{
  work *queued_work; // r4
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v4; // r3
  unsigned int v5; // r3
  UT_hash_bucket_0 *_he_newbkt; // [sp+8h] [bp+8h]
  UT_hash_handle *_he_hh_nxt; // [sp+10h] [bp+10h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+14h] [bp+14h]
  unsigned int _ha_bkt; // [sp+18h] [bp+18h]
  UT_hash_handle *_he_thh; // [sp+1Ch] [bp+1Ch]
  unsigned int _he_bkt_i; // [sp+20h] [bp+20h]
  unsigned int _hj_j; // [sp+2Ch] [bp+2Ch]
  unsigned int _hj_ja; // [sp+2Ch] [bp+2Ch]
  int _hj_i; // [sp+30h] [bp+30h]
  int _hj_ia; // [sp+30h] [bp+30h]
  int _hj_ib; // [sp+30h] [bp+30h]
  unsigned int _ha_hashva; // [sp+34h] [bp+34h]
  unsigned int _ha_hashvb; // [sp+34h] [bp+34h]
  unsigned int _ha_hashv; // [sp+34h] [bp+34h]

  ++cgpu->queued_count;
  _hj_i = ((HIBYTE(work->id) << 24) + (BYTE2(work->id) << 16) + (BYTE1(work->id) << 8) + LOBYTE(work->id) + 17973517) ^ 0x7F76D;
  _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
  _ha_hashva = (_hj_j >> 13) ^ (-17973517 - _hj_i - _hj_j);
  _hj_ia = (_ha_hashva >> 12) ^ (_hj_i - _hj_j - _ha_hashva);
  _hj_ja = (_hj_ia << 16) ^ (_hj_j - _ha_hashva - _hj_ia);
  _ha_hashvb = (_hj_ja >> 5) ^ (_ha_hashva - _hj_ia - _hj_ja);
  _hj_ib = (_ha_hashvb >> 3) ^ (_hj_ia - _hj_ja - _ha_hashvb);
  _ha_hashv = (((_hj_ib << 10) ^ (_hj_ja - _ha_hashvb - _hj_ib)) >> 15) ^ (_ha_hashvb
                                                                         - _hj_ib
                                                                         - ((_hj_ib << 10) ^ (_hj_ja
                                                                                            - _ha_hashvb
                                                                                            - _hj_ib)));
  work->hh.hashv = _ha_hashv;
  work->hh.key = &work->id;
  work->hh.keylen = 4;
  if ( cgpu->queued_work )
  {
    work->hh.tbl = cgpu->queued_work->hh.tbl;
    work->hh.next = 0;
    work->hh.prev = (char *)cgpu->queued_work->hh.tbl->tail - cgpu->queued_work->hh.tbl->hho;
    cgpu->queued_work->hh.tbl->tail->next = work;
    cgpu->queued_work->hh.tbl->tail = &work->hh;
  }
  else
  {
    work->hh.next = 0;
    work->hh.prev = 0;
    cgpu->queued_work = work;
    queued_work = cgpu->queued_work;
    queued_work->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
    if ( !cgpu->queued_work->hh.tbl )
      exit(-1);
    memset(cgpu->queued_work->hh.tbl, 0, sizeof(UT_hash_table));
    cgpu->queued_work->hh.tbl->tail = &cgpu->queued_work->hh;
    cgpu->queued_work->hh.tbl->num_buckets = 32;
    cgpu->queued_work->hh.tbl->log2_num_buckets = 5;
    cgpu->queued_work->hh.tbl->hho = 344;
    tbl = cgpu->queued_work->hh.tbl;
    tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
    if ( !cgpu->queued_work->hh.tbl->buckets )
      exit(-1);
    memset(cgpu->queued_work->hh.tbl->buckets, 0, 0x180u);
    cgpu->queued_work->hh.tbl->signature = -1609490463;
  }
  ++cgpu->queued_work->hh.tbl->num_items;
  _ha_bkt = _ha_hashv & (cgpu->queued_work->hh.tbl->num_buckets - 1);
  v4 = &cgpu->queued_work->hh.tbl->buckets[_ha_bkt];
  ++v4->count;
  work->hh.hh_next = cgpu->queued_work->hh.tbl->buckets[_ha_bkt].hh_head;
  work->hh.hh_prev = 0;
  if ( cgpu->queued_work->hh.tbl->buckets[_ha_bkt].hh_head )
    cgpu->queued_work->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &work->hh;
  cgpu->queued_work->hh.tbl->buckets[_ha_bkt].hh_head = &work->hh;
  if ( cgpu->queued_work->hh.tbl->buckets[_ha_bkt].count >= 10
                                                          * (cgpu->queued_work->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
    && work->hh.tbl->noexpand != 1 )
  {
    _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * work->hh.tbl->num_buckets);
    if ( !_he_new_buckets )
      exit(-1);
    memset(_he_new_buckets, 0, 24 * work->hh.tbl->num_buckets);
    work->hh.tbl->ideal_chain_maxlen = (work->hh.tbl->num_items >> (work->hh.tbl->log2_num_buckets + 1))
                                     + (((2 * work->hh.tbl->num_buckets - 1) & work->hh.tbl->num_items) != 0);
    work->hh.tbl->nonideal_items = 0;
    for ( _he_bkt_i = 0; work->hh.tbl->num_buckets > _he_bkt_i; ++_he_bkt_i )
    {
      for ( _he_thh = work->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
      {
        _he_hh_nxt = _he_thh->hh_next;
        _he_newbkt = &_he_new_buckets[(2 * work->hh.tbl->num_buckets - 1) & _he_thh->hashv];
        if ( ++_he_newbkt->count > work->hh.tbl->ideal_chain_maxlen )
        {
          ++work->hh.tbl->nonideal_items;
          _he_newbkt->expand_mult = _he_newbkt->count / work->hh.tbl->ideal_chain_maxlen;
        }
        _he_thh->hh_prev = 0;
        _he_thh->hh_next = _he_newbkt->hh_head;
        if ( _he_newbkt->hh_head )
          _he_newbkt->hh_head->hh_prev = _he_thh;
        _he_newbkt->hh_head = _he_thh;
      }
    }
    free(work->hh.tbl->buckets);
    work->hh.tbl->num_buckets *= 2;
    ++work->hh.tbl->log2_num_buckets;
    work->hh.tbl->buckets = _he_new_buckets;
    if ( work->hh.tbl->nonideal_items <= work->hh.tbl->num_items >> 1 )
      v5 = 0;
    else
      v5 = work->hh.tbl->ineff_expands + 1;
    work->hh.tbl->ineff_expands = v5;
    if ( work->hh.tbl->ineff_expands > 1 )
      work->hh.tbl->noexpand = 1;
  }
}
// 27F26: conditional instruction was optimized away because %_hj_k.4==4

//----- (00028554) --------------------------------------------------------
work *__cdecl _get_queued(cgpu_info *cgpu)
{
  work *work; // [sp+Ch] [bp+Ch] BYREF

  work = 0;
  if ( cgpu->unqueued_work )
  {
    work = cgpu->unqueued_work;
    if ( stale_work(work, 0) )
    {
      discard_work(&work, "cgminer.c", _func___14397, 9289);
      wake_gws();
    }
    else
    {
      _add_queued(cgpu, work);
    }
    cgpu->unqueued_work = 0;
  }
  return work;
}

//----- (000285C4) --------------------------------------------------------
work *__cdecl get_queued(cgpu_info *cgpu)
{
  work *work; // [sp+Ch] [bp+Ch]

  wr_lock_0(&cgpu->qlock, "cgminer.c", _func___14402, 9310);
  work = _get_queued(cgpu);
  wr_unlock(&cgpu->qlock, "cgminer.c", _func___14402, 9312);
  return work;
}

//----- (00028620) --------------------------------------------------------
void __cdecl add_queued(cgpu_info *cgpu, work *work)
{
  wr_lock_0(&cgpu->qlock, "cgminer.c", _func___14407, 9319);
  _add_queued(cgpu, work);
  wr_unlock(&cgpu->qlock, "cgminer.c", _func___14407, 9321);
}

//----- (0002867C) --------------------------------------------------------
work *__cdecl get_queue_work(thr_info *thr, cgpu_info *cgpu, int thr_id)
{
  work *work; // [sp+14h] [bp+14h]

  work = get_work(thr, thr_id);
  add_queued(cgpu, work);
  return work;
}

//----- (000286A8) --------------------------------------------------------
work *__cdecl _find_work_bymidstate(
        work *que,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  work *next; // r3
  work *v7; // r3
  work *ret; // [sp+14h] [bp+14h]
  work *tmp; // [sp+18h] [bp+18h]
  work *work; // [sp+1Ch] [bp+1Ch]

  ret = 0;
  work = que;
  if ( que )
    next = (work *)que->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( !memcmp(work->midstate, midstate, midstatelen) && !memcmp(&work->data[offset], data, datalen) )
      return work;
    work = tmp;
    if ( tmp )
      v7 = (work *)tmp->hh.next;
    else
      v7 = 0;
    tmp = v7;
  }
  return ret;
}

//----- (0002872C) --------------------------------------------------------
work *__cdecl find_queued_work_bymidstate(
        cgpu_info *cgpu,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  work *ret; // [sp+1Ch] [bp+14h]

  rd_lock_0(&cgpu->qlock, "cgminer.c", _func___14437, 9365);
  ret = _find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);
  rd_unlock_0(&cgpu->qlock, "cgminer.c", _func___14437, 9367);
  return ret;
}

//----- (000287A4) --------------------------------------------------------
work *__cdecl clone_queued_work_bymidstate(
        cgpu_info *cgpu,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  work *work; // [sp+18h] [bp+10h]
  work *ret; // [sp+1Ch] [bp+14h]

  ret = 0;
  rd_lock_0(&cgpu->qlock, "cgminer.c", _func___14448, 9377);
  work = _find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);
  if ( work )
    ret = copy_work_noffset(work, 0);
  rd_unlock_0(&cgpu->qlock, "cgminer.c", _func___14448, 9381);
  return ret;
}

//----- (00028830) --------------------------------------------------------
work *__cdecl _find_work_byid(work *que, unsigned int id)
{
  work *next; // r3
  work *v3; // r3
  work *ret; // [sp+Ch] [bp+Ch]
  work *tmp; // [sp+10h] [bp+10h]
  work *work; // [sp+14h] [bp+14h]

  ret = 0;
  work = que;
  if ( que )
    next = (work *)que->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( work->id == id )
      return work;
    work = tmp;
    if ( tmp )
      v3 = (work *)tmp->hh.next;
    else
      v3 = 0;
    tmp = v3;
  }
  return ret;
}

//----- (00028894) --------------------------------------------------------
work *__cdecl find_queued_work_byid(cgpu_info *cgpu, unsigned int id)
{
  work *ret; // [sp+Ch] [bp+Ch]

  rd_lock_0(&cgpu->qlock, "cgminer.c", _func___14464, 9412);
  ret = _find_work_byid(cgpu->queued_work, id);
  rd_unlock_0(&cgpu->qlock, "cgminer.c", _func___14464, 9414);
  return ret;
}

//----- (000288FC) --------------------------------------------------------
work *__cdecl clone_queued_work_byid(cgpu_info *cgpu, unsigned int id)
{
  work *work; // [sp+8h] [bp+8h]
  work *ret; // [sp+Ch] [bp+Ch]

  ret = 0;
  rd_lock_0(&cgpu->qlock, "cgminer.c", _func___14471, 9424);
  work = _find_work_byid(cgpu->queued_work, id);
  if ( work )
    ret = copy_work_noffset(work, 0);
  rd_unlock_0(&cgpu->qlock, "cgminer.c", _func___14471, 9428);
  return ret;
}

//----- (00028978) --------------------------------------------------------
void __cdecl _work_completed(cgpu_info *cgpu, work *work)
{
  UT_hash_bucket_0 *v2; // r3
  unsigned int _hd_bkt; // [sp+8h] [bp+8h]

  --cgpu->queued_count;
  if ( work->hh.prev || work->hh.next )
  {
    if ( (work *)((char *)cgpu->queued_work->hh.tbl->tail - cgpu->queued_work->hh.tbl->hho) == work )
      cgpu->queued_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + cgpu->queued_work->hh.tbl->hho);
    if ( work->hh.prev )
      *(_DWORD *)((char *)work->hh.prev + cgpu->queued_work->hh.tbl->hho + 8) = work->hh.next;
    else
      cgpu->queued_work = (work *)work->hh.next;
    if ( work->hh.next )
      *(_DWORD *)((char *)work->hh.next + cgpu->queued_work->hh.tbl->hho + 4) = work->hh.prev;
    _hd_bkt = (cgpu->queued_work->hh.tbl->num_buckets - 1) & work->hh.hashv;
    v2 = &cgpu->queued_work->hh.tbl->buckets[_hd_bkt];
    --v2->count;
    if ( cgpu->queued_work->hh.tbl->buckets[_hd_bkt].hh_head == &work->hh )
      cgpu->queued_work->hh.tbl->buckets[_hd_bkt].hh_head = work->hh.hh_next;
    if ( work->hh.hh_prev )
      work->hh.hh_prev->hh_next = work->hh.hh_next;
    if ( work->hh.hh_next )
      work->hh.hh_next->hh_prev = work->hh.hh_prev;
    --cgpu->queued_work->hh.tbl->num_items;
  }
  else
  {
    free(cgpu->queued_work->hh.tbl->buckets);
    free(cgpu->queued_work->hh.tbl);
    cgpu->queued_work = 0;
  }
}

//----- (00028B24) --------------------------------------------------------
int __cdecl age_queued_work(cgpu_info *cgpu, double secs)
{
  work *next; // r3
  work *v3; // r3
  timeval tv_now; // [sp+14h] [bp+14h] BYREF
  work *work; // [sp+1Ch] [bp+1Ch]
  int aged; // [sp+20h] [bp+20h]
  work *tmp; // [sp+24h] [bp+24h]

  aged = 0;
  cgtime(&tv_now);
  wr_lock_0(&cgpu->qlock, "cgminer.c", _func___14486, 9450);
  work = cgpu->queued_work;
  if ( cgpu->queued_work )
    next = (work *)cgpu->queued_work->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    tdiff(&tv_now, &work->tv_work_start);
    work = tmp;
    if ( tmp )
      v3 = (work *)tmp->hh.next;
    else
      v3 = 0;
    tmp = v3;
  }
  wr_unlock(&cgpu->qlock, "cgminer.c", _func___14486, 9461);
  return aged;
}

//----- (00028C1C) --------------------------------------------------------
void __cdecl work_completed(cgpu_info *cgpu, work *work)
{
  work *worka; // [sp+0h] [bp+0h] BYREF
  cgpu_info *cgpua; // [sp+4h] [bp+4h]

  cgpua = cgpu;
  worka = work;
  wr_lock_0(&cgpu->qlock, "cgminer.c", _func___14494, 9471);
  _work_completed(cgpua, worka);
  wr_unlock(&cgpua->qlock, "cgminer.c", _func___14494, 9473);
  free_work(&worka, "cgminer.c", _func___14494, 9475);
}

//----- (00028C94) --------------------------------------------------------
work *__cdecl take_queued_work_bymidstate(
        cgpu_info *cgpu,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  work *work; // [sp+1Ch] [bp+14h]

  wr_lock_0(&cgpu->qlock, "cgminer.c", _func___14504, 9484);
  work = _find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);
  if ( work )
    _work_completed(cgpu, work);
  wr_unlock(&cgpu->qlock, "cgminer.c", _func___14504, 9488);
  return work;
}

//----- (00028D18) --------------------------------------------------------
void __cdecl flush_queue(cgpu_info *cgpu)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  work *work; // [sp+80Ch] [bp+80Ch] BYREF

  work = 0;
  if ( cgpu )
  {
    if ( !wr_trylock(&cgpu->qlock, "cgminer.c", _func___14509, 9504) )
    {
      work = cgpu->unqueued_work;
      cgpu->unqueued_work = 0;
      wr_unlock(&cgpu->qlock, "cgminer.c", _func___14509, 9511);
      if ( work )
      {
        free_work(&work, "cgminer.c", _func___14509, 9515);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Discarded queued work item");
          applog(7, tmp42, 0);
        }
      }
    }
  }
}

//----- (00028E28) --------------------------------------------------------
void __cdecl hash_queued_work(thr_info *mythr)
{
  bool v1; // zf
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  timeval diff; // [sp+810h] [bp+808h]
  timeval tv_end; // [sp+818h] [bp+810h] BYREF
  timeval tv_start; // [sp+820h] [bp+818h] BYREF
  int64_t hashes; // [sp+828h] [bp+820h]
  int thr_id; // [sp+834h] [bp+82Ch]
  device_drv *drv; // [sp+838h] [bp+830h]
  cgpu_info *cgpu; // [sp+83Ch] [bp+834h]
  int64_t hashes_done; // [sp+840h] [bp+838h]

  tv_start.tv_sec = 0;
  tv_start.tv_usec = 0;
  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  thr_id = mythr->id;
  hashes_done = 0LL;
  while ( !cgpu->shutdown )
  {
    mythr->work_update = 0;
    fill_queue(mythr, cgpu, drv, thr_id);
    hashes = drv->scanwork(mythr);
    mythr->work_restart = 0;
    v1 = HIDWORD(hashes) == -1;
    if ( HIDWORD(hashes) == -1 )
      v1 = (_DWORD)hashes == -1;
    if ( v1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = DEV_DISABLED;
      dev_error(cgpu, REASON_THREAD_ZERO_HASH);
      break;
    }
    hashes_done += hashes;
    cgtime(&tv_end);
    diff.tv_sec = tv_end.tv_sec - tv_start.tv_sec;
    diff.tv_usec = tv_end.tv_usec - tv_start.tv_usec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    if ( hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000) || diff.tv_sec >= opt_log_interval )
    {
      hashmeter(thr_id, hashes_done);
      hashes_done = 0LL;
      copy_time(&tv_start, &tv_end);
    }
    if ( mythr->pause || cgpu->deven )
      mt_disable(mythr, thr_id, drv);
    if ( mythr->work_update )
      drv->update_work(cgpu);
  }
  cgpu->deven = DEV_DISABLED;
}

//----- (00029060) --------------------------------------------------------
void __cdecl hash_driver_work(thr_info *mythr)
{
  bool v1; // zf
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  timeval diff; // [sp+810h] [bp+808h]
  timeval tv_end; // [sp+818h] [bp+810h] BYREF
  timeval tv_start; // [sp+820h] [bp+818h] BYREF
  int64_t hashes; // [sp+828h] [bp+820h]
  int thr_id; // [sp+834h] [bp+82Ch]
  device_drv *drv; // [sp+838h] [bp+830h]
  cgpu_info *cgpu; // [sp+83Ch] [bp+834h]
  int64_t hashes_done; // [sp+840h] [bp+838h]

  tv_start.tv_sec = 0;
  tv_start.tv_usec = 0;
  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  thr_id = mythr->id;
  hashes_done = 0LL;
  while ( !cgpu->shutdown )
  {
    mythr->work_update = 0;
    hashes = drv->scanwork(mythr);
    mythr->work_restart = 0;
    v1 = HIDWORD(hashes) == -1;
    if ( HIDWORD(hashes) == -1 )
      v1 = (_DWORD)hashes == -1;
    if ( v1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = DEV_DISABLED;
      dev_error(cgpu, REASON_THREAD_ZERO_HASH);
      break;
    }
    hashes_done += hashes;
    cgtime(&tv_end);
    diff.tv_sec = tv_end.tv_sec - tv_start.tv_sec;
    diff.tv_usec = tv_end.tv_usec - tv_start.tv_usec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    if ( hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000) || diff.tv_sec >= opt_log_interval )
    {
      hashmeter(thr_id, hashes_done);
      hashes_done = 0LL;
      copy_time(&tv_start, &tv_end);
    }
    if ( mythr->pause || cgpu->deven )
      mt_disable(mythr, thr_id, drv);
    if ( mythr->work_update )
    {
      mutex_lock_0(&update_job_lock, "cgminer.c", _func___14539, 9634);
      drv->update_work(cgpu);
      mutex_unlock_0(&update_job_lock, "cgminer.c", _func___14539, 9636);
    }
  }
  cgpu->deven = DEV_DISABLED;
}

//----- (000292C4) --------------------------------------------------------
void *__cdecl miner_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 threadname[16]; // [sp+808h] [bp+808h] BYREF
  device_drv *drv; // [sp+818h] [bp+818h]
  cgpu_info *cgpu; // [sp+81Ch] [bp+81Ch]
  int thr_id; // [sp+820h] [bp+820h]
  thr_info *mythr; // [sp+824h] [bp+824h]

  mythr = (thr_info *)userdata;
  thr_id = *(_DWORD *)userdata;
  cgpu = (cgpu_info *)*((_DWORD *)userdata + 9);
  drv = cgpu->drv;
  snprintf((char *)threadname, 0x10u, "%d/Miner", thr_id);
  RenameThread(threadname);
  thread_reportout(mythr);
  if ( !drv->thread_init(mythr) )
  {
    dev_error(cgpu, REASON_THREAD_FAIL_INIT);
  }
  else
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Waiting on sem in miner thread");
      applog(7, tmp42, 0);
    }
    cgsem_wait(&mythr->sem, "cgminer.c", _func___14552, 9663);
    cgpu->last_device_valid_work = time(0);
    drv->hash_work(mythr);
    drv->thread_shutdown(mythr);
  }
  return 0;
}

//----- (00029404) --------------------------------------------------------
void __cdecl wait_lpcurrent(pool *pool)
{
  bool i; // r0

  for ( i = cnx_needed(pool);
        !i
     && (pool->enabled == POOL_DISABLED
      || current_pool() != pool && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE);
        i = cnx_needed(pool) )
  {
    mutex_lock_0(&lp_lock, "cgminer.c", _func___14560, 9775);
    pthread_cond_wait(&lp_cond, &lp_lock);
    mutex_unlock_0(&lp_lock, "cgminer.c", _func___14560, 9777);
  }
}

//----- (000294AC) --------------------------------------------------------
void *__cdecl longpoll_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (000294CC) --------------------------------------------------------
void __cdecl reinit_device(cgpu_info *cgpu)
{
  if ( cgpu->deven != DEV_DISABLED )
    cgpu->drv->reinit_device(cgpu);
}

//----- (000294F4) --------------------------------------------------------
void __cdecl reap_curl(pool *pool)
{
  const char *v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  timeval now; // [sp+814h] [bp+80Ch] BYREF
  int reaped; // [sp+81Ch] [bp+814h]
  curl_ent *iter; // [sp+820h] [bp+818h]
  curl_ent *ent; // [sp+824h] [bp+81Ch]

  reaped = 0;
  cgtime(&now);
  mutex_lock_0(&pool->pool_lock, "cgminer.c", _func___14578, 10020);
  ent = (curl_ent *)&pool->curlring.next[-1].prev;
  iter = CONTAINING_RECORD(ent->node.next, curl_ent, node);
  while ( &ent->node != &pool->curlring )
  {
    if ( pool->curls <= 1 )
      return;
    if ( now.tv_sec - ent->tv.tv_sec > 300 )
    {
      ++reaped;
      --pool->curls;
      list_del(&ent->node);
      free(ent);
    }
    ent = iter;
    iter = CONTAINING_RECORD(iter->node.next, curl_ent, node);
  }
  mutex_unlock_0(&pool->pool_lock, "cgminer.c", _func___14578, 10038);
  if ( reaped && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( reaped <= 1 )
      v1 = &byte_71100;
    else
      v1 = "s";
    snprintf((char *)tmp42, 0x800u, "Reaped %d curl%s from pool %d", reaped, v1, pool->pool_no);
    applog(7, tmp42, 0);
  }
}
// 71100: using guessed type char byte_71100;

//----- (00029678) --------------------------------------------------------
void __cdecl prune_stratum_shares(pool *pool)
{
  stratum_share *next; // r3
  stratum_share *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned int _hd_bkt; // [sp+810h] [bp+808h]
  UT_hash_handle *_hd_hh_del; // [sp+814h] [bp+80Ch]
  time_t current_time; // [sp+818h] [bp+810h]
  int cleared; // [sp+81Ch] [bp+814h]
  stratum_share *tmpshare; // [sp+820h] [bp+818h]
  stratum_share *sshare; // [sp+824h] [bp+81Ch]

  current_time = time(0);
  cleared = 0;
  mutex_lock_0(&sshare_lock, "cgminer.c", _func___14590, 10056);
  sshare = stratum_shares;
  if ( stratum_shares )
    next = (stratum_share *)stratum_shares->hh.next;
  else
    next = 0;
  tmpshare = next;
  while ( sshare )
  {
    if ( sshare->work->pool == pool && sshare->sshare_time + 120 < current_time )
    {
      if ( sshare->hh.prev || sshare->hh.next )
      {
        _hd_hh_del = &sshare->hh;
        if ( (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) == sshare )
          stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
        if ( sshare->hh.prev )
          *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
        else
          stratum_shares = (stratum_share *)sshare->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
        if ( stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head == _hd_hh_del )
          stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --stratum_shares->hh.tbl->num_items;
      }
      else
      {
        free(stratum_shares->hh.tbl->buckets);
        free(stratum_shares->hh.tbl);
        stratum_shares = 0;
      }
      free_work(&sshare->work, "cgminer.c", _func___14590, 10063);
      free(sshare);
      ++cleared;
    }
    sshare = tmpshare;
    if ( tmpshare )
      v2 = (stratum_share *)tmpshare->hh.next;
    else
      v2 = 0;
    tmpshare = v2;
  }
  mutex_unlock_0(&sshare_lock, "cgminer.c", _func___14590, 10069);
  if ( cleared )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Lost %d shares due to no stratum share response from pool %d",
        cleared,
        pool->pool_no);
      applog(4, tmp42, 0);
    }
    pool->stale_shares += cleared;
    total_stale += cleared;
  }
}

//----- (000299F8) --------------------------------------------------------
void *__cdecl __noreturn watchpool_thread(void *userdata)
{
  int prio; // r4
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  timeval now; // [sp+810h] [bp+808h] BYREF
  cgtimer_t cgt; // [sp+818h] [bp+810h] BYREF
  double shares; // [sp+820h] [bp+818h]
  pool *pool; // [sp+82Ch] [bp+824h]
  int i; // [sp+830h] [bp+828h]
  int intervals; // [sp+834h] [bp+82Ch]

  intervals = 0;
  pthread_setcanceltype(1, 0);
  RenameThread("Watchpool");
  set_lowprio();
  cgtimer_time(&cgt);
  while ( 1 )
  {
    if ( ++intervals > 120 )
      intervals = 0;
    cgtime(&now);
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( !opt_benchmark && !opt_benchfile )
      {
        reap_curl(pool);
        prune_stratum_shares(pool);
      }
      if ( intervals > 119 )
      {
        shares = (double)(pool->diff1 - pool->last_shares);
        pool->last_shares = pool->diff1;
        pool->utility = (pool->utility + shares * 0.63) / 1.63;
        pool->shares = (int)pool->utility;
      }
      if ( pool->enabled && !pool->testing )
      {
        if ( pool_active(pool, 1) )
        {
          if ( pool_tclear(pool, &pool->idle) )
            pool_resus(pool);
        }
        else
        {
          cgtime(&pool->tv_idle);
        }
        if ( !pool->idle && pool_strategy_0 == POOL_FAILOVER )
        {
          prio = pool->prio;
          if ( prio < cp_prio() && now.tv_sec - pool->tv_idle.tv_sec > opt_pool_fallback )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Pool %d %s stable for >%d seconds",
                pool->pool_no,
                (const char *)pool->rpc_url,
                opt_pool_fallback);
              applog(4, tmp42, 0);
            }
            switch_pools(0);
          }
        }
      }
    }
    if ( current_pool()->idle )
      switch_pools(0);
    if ( pool_strategy_0 == POOL_ROTATE && now.tv_sec - rotate_tv.tv_sec > 60 * opt_rotate_period )
    {
      cgtime(&rotate_tv);
      switch_pools(0);
    }
    cgsleep_ms_r(&cgt, 5000);
    cgtimer_time(&cgt);
  }
}

//----- (00029CE8) --------------------------------------------------------
void *__cdecl __noreturn watchdog_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 dev_str[8]; // [sp+810h] [bp+808h] BYREF
  timeval now; // [sp+818h] [bp+810h] BYREF
  timeval zero_tv; // [sp+820h] [bp+818h] BYREF
  dev_enable *denable; // [sp+828h] [bp+820h]
  thr_info *thr_0; // [sp+82Ch] [bp+824h]
  cgpu_info *cgpu; // [sp+830h] [bp+828h]
  thr_info *thr; // [sp+834h] [bp+82Ch]
  unsigned int interval; // [sp+838h] [bp+830h]
  int i; // [sp+83Ch] [bp+834h]

  interval = 2;
  pthread_setcanceltype(1, 0);
  RenameThread("Watchdog");
  set_lowprio();
  memset(&zero_tv, 0, sizeof(zero_tv));
  cgtime(&rotate_tv);
LABEL_2:
  sleep(interval);
  discard_stale();
  hashmeter(-1, 0LL);
  cgtime(&now);
  if ( !sched_paused && !should_run() )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Pausing execution as per stop time %02d:%02d scheduled",
        schedstop.tm.tm_hour,
        schedstop.tm.tm_min);
      applog(4, tmp42, 0);
    }
    if ( !schedstart.enable )
    {
      strcpy((char *)tmp42, "Terminating execution as planned");
      applog(3, tmp42, 1);
      quit(0);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Will restart execution as scheduled at %02d:%02d",
        schedstart.tm.tm_hour,
        schedstart.tm.tm_min);
      applog(4, tmp42, 0);
    }
    sched_paused = 1;
    rd_lock_0(&mining_thr_lock, "cgminer.c", _func___14623, 10287);
    for ( i = 0; i < mining_threads; ++i )
      mining_thr[i]->pause = 1;
    rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___14623, 10294);
  }
  else if ( sched_paused && should_run() )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Restarting execution as per start time %02d:%02d scheduled",
        schedstart.tm.tm_hour,
        schedstart.tm.tm_min);
      applog(4, tmp42, 0);
    }
    if ( schedstop.enable && (use_syslog || opt_log_output || opt_log_level > 3) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Will pause execution as scheduled at %02d:%02d",
        schedstop.tm.tm_hour,
        schedstop.tm.tm_min);
      applog(4, tmp42, 0);
    }
    sched_paused = 0;
    for ( i = 0; i < mining_threads; ++i )
    {
      thr = get_thread(i);
      if ( thr->cgpu->deven != DEV_DISABLED )
      {
        thr->pause = 0;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Pushing sem post to thread %d", thr->id);
          applog(7, tmp42, 0);
        }
        cgsem_post(&thr->sem, "cgminer.c", _func___14623, 10321);
      }
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= total_devices )
      goto LABEL_2;
    cgpu = get_devices(i);
    thr_0 = *cgpu->thr;
    if ( thr_0 )
    {
      cgpu->drv->get_stats(cgpu);
      denable = &cgpu->deven;
      snprintf((char *)dev_str, 8u, "%s %d", (const char *)cgpu->drv->name, cgpu->device_id);
      if ( !thr_0->getwork && *denable != DEV_DISABLED )
      {
        if ( cgpu->status && now.tv_sec - thr_0->last.tv_sec <= 119 )
        {
          if ( cgpu->status != LIFE_INIT && (use_syslog || opt_log_output || opt_log_level > 2) )
          {
            snprintf((char *)tmp42, 0x800u, "%s: Recovered, declaring WELL!", (const char *)dev_str);
            applog(3, tmp42, 0);
          }
          cgpu->status = LIFE_WELL;
          cgpu->device_last_well = time(0);
        }
        else if ( cgpu->status || now.tv_sec - thr_0->last.tv_sec <= 120 )
        {
          if ( cgpu->status == LIFE_SICK && now.tv_sec - thr_0->last.tv_sec > 600 )
          {
            cgpu->status = LIFE_DEAD;
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: Not responded for more than 10 minutes, declaring DEAD!",
                (const char *)dev_str);
              applog(3, tmp42, 0);
            }
            cgtime(&thr_0->sick);
            dev_error(cgpu, REASON_DEV_DEAD_IDLE_600);
          }
          else if ( now.tv_sec - thr_0->sick.tv_sec > 60 && (cgpu->status == LIFE_SICK || cgpu->status == LIFE_DEAD) )
          {
            cgtime(&thr_0->sick);
            if ( opt_restart )
              goto LABEL_74;
          }
        }
        else
        {
          cgpu->rolling = 0.0;
          cgpu->status = LIFE_SICK;
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf((char *)tmp42, 0x800u, "%s: Idle for more than 60 seconds, declaring SICK!", (const char *)dev_str);
            applog(3, tmp42, 0);
          }
          cgtime(&thr_0->sick);
          dev_error(cgpu, REASON_DEV_SICK_IDLE_60);
          if ( opt_restart )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf((char *)tmp42, 0x800u, "%s: Attempting to restart", (const char *)dev_str);
              applog(3, tmp42, 0);
            }
LABEL_74:
            reinit_device(cgpu);
            continue;
          }
        }
      }
    }
  }
}

//----- (0002A40C) --------------------------------------------------------
void __cdecl log_print_status(cgpu_info *cgpu)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 logline[255]; // [sp+808h] [bp+808h] BYREF

  get_statline(logline, 0xFFu, cgpu);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "%s", (const char *)logline);
    applog(4, tmp42, 0);
  }
}

//----- (0002A488) --------------------------------------------------------
void print_summary()
{
  const char *v0; // r3
  int64_t rejected; // r2
  int v2; // r1
  __int64 v3; // r2
  __int64 v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+0h] BYREF
  timeval diff; // [sp+810h] [bp+800h]
  cgpu_info *cgpu; // [sp+818h] [bp+808h]
  pool *pool; // [sp+81Ch] [bp+80Ch]
  double displayed_hashes; // [sp+820h] [bp+810h]
  double work_util; // [sp+828h] [bp+818h]
  double utility; // [sp+830h] [bp+820h]
  int secs; // [sp+838h] [bp+828h]
  int mins; // [sp+83Ch] [bp+82Ch]
  int hours; // [sp+840h] [bp+830h]
  int i; // [sp+844h] [bp+834h]

  diff.tv_sec = total_tv_end.tv_sec - total_tv_start.tv_sec;
  diff.tv_usec = total_tv_end.tv_usec - total_tv_start.tv_usec;
  if ( total_tv_end.tv_usec - total_tv_start.tv_usec < 0 )
  {
    --diff.tv_sec;
    diff.tv_usec += 1000000;
  }
  hours = diff.tv_sec / 3600;
  mins = diff.tv_sec % 3600 / 60;
  secs = diff.tv_sec % 60;
  utility = (double)total_accepted / total_secs * 60.0;
  work_util = (double)total_diff1 / total_secs * 60.0;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "\nSummary of runtime statistics:\n");
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Started at %s", (const char *)datestamp);
    applog(4, tmp42, 0);
  }
  if ( total_pools == 1 && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)(*pools)->rpc_url);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Runtime: %d hrs : %d mins : %d secs", hours, mins, secs);
    applog(4, tmp42, 0);
  }
  displayed_hashes = total_mhashes_done / total_secs;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Average hashrate: %.1f Mhash/s", displayed_hashes);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Solved blocks: %d", found_blocks);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Best share difficulty: %s", (const char *)best_share);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Share submissions: %lld", total_rejected + total_accepted);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Accepted shares: %lld", total_accepted);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Rejected shares: %lld", total_rejected);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Accepted difficulty shares: %1.f", total_diff_accepted);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Rejected difficulty shares: %1.f", total_diff_rejected);
    applog(4, tmp42, 0);
  }
  if ( (total_accepted || total_rejected) && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Reject ratio: %.1f%%",
      (double)(100 * total_rejected) / (double)(total_rejected + total_accepted));
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Hardware errors: %d", hw_errors);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Utility (accepted shares / min): %.2f/min", utility);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", work_util);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Stale submissions discarded due to new blocks: %lld", total_stale);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Unable to get work from server occasions: %d", total_go);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Work items generated locally: %d", local_work);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Submitting work remotely delay occasions: %d", total_ro);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "New blocks detected on network: %d\n", new_blocks);
    applog(4, tmp42, 0);
  }
  if ( total_pools > 1 )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)pool->rpc_url);
        applog(4, tmp42, 0);
      }
      if ( pool->solved && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        if ( pool->solved <= 1 )
          v0 = &byte_71100;
        else
          v0 = "S";
        snprintf((char *)tmp42, 0x800u, "SOLVED %d BLOCK%s!", pool->solved, v0);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Share submissions: %lld", pool->rejected + pool->accepted);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Accepted shares: %lld", pool->accepted);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Rejected shares: %lld", pool->rejected);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Accepted difficulty shares: %1.f", pool->diff_accepted);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Rejected difficulty shares: %1.f", pool->diff_rejected);
        applog(4, tmp42, 0);
      }
      if ( (pool->accepted || pool->rejected) && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        rejected = pool->rejected;
        v2 = 100 * HIDWORD(rejected);
        v3 = 100LL * (unsigned int)rejected;
        HIDWORD(v4) = v2 + HIDWORD(v3);
        LODWORD(v4) = v3;
        snprintf((char *)tmp42, 0x800u, " Reject ratio: %.1f%%", (double)v4 / (double)(pool->rejected + pool->accepted));
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Items worked on: %d", pool->works);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Stale submissions discarded due to new blocks: %d", pool->stale_shares);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Unable to get work from server occasions: %d", pool->getfail_occasions);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Submitting work remotely delay occasions: %d\n", pool->remotefail_occasions);
        applog(4, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Summary of per device statistics:\n");
    applog(4, tmp42, 0);
  }
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu = get_devices(i);
    cgpu->drv->get_statline_before = (void (*)(unsigned __int8 *, size_t, cgpu_info *))blank_get_statline_before;
    cgpu->drv->get_statline = (void (*)(unsigned __int8 *, size_t, cgpu_info *))noop_get_statline;
    log_print_status(cgpu);
  }
  if ( opt_shares )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Mined %.0f accepted shares of %d requested\n", total_diff_accepted, opt_shares);
      applog(4, tmp42, 0);
    }
    if ( (double)opt_shares > total_diff_accepted && (use_syslog || opt_log_output || opt_log_level > 3) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "WARNING - Mined only %.0f shares of %d requested.",
        total_diff_accepted,
        opt_shares);
      applog(4, tmp42, 0);
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, " ");
    applog(4, tmp42, 0);
  }
  fflush((FILE *)stderr);
  fflush((FILE *)stdout);
}
// 71100: using guessed type char byte_71100;
// 8A8B4: using guessed type int stdout;
// 8A8B8: using guessed type int stderr;

//----- (0002B4A8) --------------------------------------------------------
void __cdecl clean_up(bool restarting)
{
  int v1; // r4
  int *v2; // r0
  char *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  sysinfo sInfo; // [sp+810h] [bp+808h] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v1 = *_errno_location();
      v2 = _errno_location();
      v3 = strerror(*v2);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v1, v3);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
  }
  cgtime(&total_tv_end);
  if ( !restarting && !opt_realquiet && successful_connect )
    print_summary();
}

//----- (0002B5A0) --------------------------------------------------------
void *__cdecl __noreturn killall_thread(void *arg)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (0002B5C8) --------------------------------------------------------
void __cdecl __noreturn _quit(int status, bool clean)
{
  pthread_t killall_t; // [sp+Ch] [bp+Ch] BYREF

  if ( pthread_create(&killall_t, 0, (void *(*)(void *))killall_thread, 0) )
    exit(1);
  if ( clean )
    clean_up(0);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  pthread_cancel(killall_t);
  exit(status);
}

//----- (0002B63C) --------------------------------------------------------
void __cdecl __noreturn quit(int status)
{
  _quit(status, 1);
}

//----- (0002B654) --------------------------------------------------------
void *__cdecl test_pool_thread(void *arg)
{
  pthread_t v1; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  pool *pool; // [sp+810h] [bp+808h]
  bool first_pool; // [sp+817h] [bp+80Fh]

  pool = (pool *)arg;
  if ( *((_BYTE *)arg + 111) != 1 )
  {
    v1 = pthread_self();
    pthread_detach(v1);
  }
  while ( !pool->removed )
  {
    if ( pool_active(pool, 0) )
    {
      pool_tclear(pool, &pool->idle);
      first_pool = 0;
      cg_wlock_0(&control_lock, "cgminer.c", _func___14747, 10633);
      if ( !pools_active )
      {
        currentpool = pool;
        if ( pool->pool_no )
          first_pool = 1;
        pools_active = 1;
      }
      cg_wunlock_0(&control_lock, "cgminer.c", _func___14747, 10647);
      if ( first_pool && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Switching to pool %d %s - first alive pool",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(5, tmp42, 0);
      }
      pool_resus(pool);
      switch_pools(0);
LABEL_17:
      pool->testing = 0;
      return 0;
    }
    pool_died(pool);
    if ( pool->blocking )
      goto LABEL_17;
    sleep(0x1Eu);
  }
  return 0;
}

//----- (0002B7EC) --------------------------------------------------------
bool __cdecl add_pool_details(
        pool *pool,
        bool live,
        unsigned __int8 *url,
        unsigned __int8 *user,
        unsigned __int8 *pass)
{
  size_t v5; // r4
  unsigned int siz; // [sp+1Ch] [bp+14h]

  pool->rpc_url = get_proxy(url, pool);
  pool->rpc_user = user;
  pool->rpc_pass = pass;
  v5 = strlen((const char *)pool->rpc_user);
  siz = v5 + strlen((const char *)pool->rpc_pass) + 2;
  pool->rpc_userpass = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___14757, 10686);
  snprintf((char *)pool->rpc_userpass, siz, "%s:%s", (const char *)pool->rpc_user, (const char *)pool->rpc_pass);
  pool->testing = 1;
  pool->idle = 1;
  pool->blocking = !live;
  enable_pool(pool);
  pthread_create(&pool->test_thread, 0, (void *(*)(void *))test_pool_thread, pool);
  if ( live )
    return 1;
  pthread_join(pool->test_thread, 0);
  return pools_active;
}

//----- (0002B904) --------------------------------------------------------
void fork_monitor()
{
  int pfd[2]; // [sp+Ch] [bp+4h] BYREF
  sighandler_t sr1; // [sp+14h] [bp+Ch]
  sighandler_t sr0; // [sp+18h] [bp+10h]
  int r; // [sp+1Ch] [bp+14h]

  r = pipe(pfd);
  if ( r < 0 )
  {
    perror("pipe - failed to create pipe for --monitor");
    exit(1);
  }
  fflush((FILE *)stderr);
  r = dup2(pfd[1], 2);
  if ( r < 0 )
  {
    perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
    exit(1);
  }
  r = close(pfd[1]);
  if ( r < 0 )
  {
    perror("close - failed to close write end of pipe for --monitor");
    exit(1);
  }
  sr0 = signal(13, (__sighandler_t)1);
  sr1 = signal(13, (__sighandler_t)1);
  if ( sr0 == (sighandler_t)-1 || sr1 == (sighandler_t)-1 )
  {
    perror("signal - failed to edit signal mask for --monitor");
    exit(1);
  }
  forkpid = fork();
  if ( forkpid < 0 )
  {
    perror("fork - failed to fork child process for --monitor");
    exit(1);
  }
  if ( !forkpid )
  {
    r = dup2(pfd[0], 0);
    if ( r < 0 )
    {
      perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
      exit(1);
    }
    close(pfd[0]);
    if ( r < 0 )
    {
      perror("close - in child, failed to close read end of  pipe for --monitor");
      exit(1);
    }
    execl("/bin/bash", "/bin/bash", "-c", opt_stderr_cmd, 0);
    perror("execl - in child failed to exec user specified command for --monitor");
    exit(1);
  }
  r = close(pfd[0]);
  if ( r < 0 )
  {
    perror("close - failed to close read end of pipe for --monitor");
    exit(1);
  }
}
// 8A8B8: using guessed type int stderr;

//----- (0002BAA0) --------------------------------------------------------
void __cdecl noop_reinit_device(cgpu_info *cgpu)
{
  ;
}

//----- (0002BAB4) --------------------------------------------------------
void __cdecl blank_get_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  ;
}

//----- (0002BACC) --------------------------------------------------------
void __cdecl noop_get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  ;
}

//----- (0002BAE4) --------------------------------------------------------
bool __cdecl noop_get_stats(cgpu_info *cgpu)
{
  return 1;
}

//----- (0002BAFC) --------------------------------------------------------
bool __cdecl noop_thread_prepare(thr_info *thr)
{
  return 1;
}

//----- (0002BB14) --------------------------------------------------------
uint64_t __cdecl noop_can_limit_work(thr_info *thr)
{
  return 0xFFFFFFFFLL;
}

//----- (0002BB34) --------------------------------------------------------
bool __cdecl noop_thread_init(thr_info *thr)
{
  return 1;
}

//----- (0002BB4C) --------------------------------------------------------
bool __cdecl noop_prepare_work(thr_info *thr, work *work)
{
  return 1;
}

//----- (0002BB64) --------------------------------------------------------
void __cdecl noop_hw_error(thr_info *thr)
{
  ;
}

//----- (0002BB78) --------------------------------------------------------
void __cdecl noop_thread_shutdown(thr_info *thr)
{
  ;
}

//----- (0002BB8C) --------------------------------------------------------
void __cdecl noop_thread_enable(thr_info *thr)
{
  ;
}

//----- (0002BBA0) --------------------------------------------------------
void __cdecl noop_detect(bool hotplug)
{
  ;
}

//----- (0002BBB4) --------------------------------------------------------
api_data *__cdecl noop_get_api_stats(cgpu_info *cgpu)
{
  return 0;
}

//----- (0002BBCC) --------------------------------------------------------
void __cdecl noop_hash_work(thr_info *thr)
{
  ;
}

//----- (0002BBE0) --------------------------------------------------------
void __cdecl generic_zero_stats(cgpu_info *cgpu)
{
  cgpu->hw_errors = 0;
  cgpu->diff_rejected = 0.0;
  cgpu->diff_accepted = cgpu->diff_rejected;
}

//----- (0002BC14) --------------------------------------------------------
void __cdecl fill_device_drv(device_drv *drv)
{
  if ( !drv->drv_detect )
    drv->drv_detect = (void (*)(bool))noop_detect;
  if ( !drv->reinit_device )
    drv->reinit_device = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->get_statline_before )
    drv->get_statline_before = (void (*)(unsigned __int8 *, size_t, cgpu_info *))blank_get_statline_before;
  if ( !drv->get_statline )
    drv->get_statline = (void (*)(unsigned __int8 *, size_t, cgpu_info *))noop_get_statline;
  if ( !drv->get_stats )
    drv->get_stats = (bool (*)(cgpu_info *))noop_get_stats;
  if ( !drv->thread_prepare )
    drv->thread_prepare = (bool (*)(thr_info *))noop_thread_prepare;
  if ( !drv->thread_init )
    drv->thread_init = (bool (*)(thr_info *))noop_thread_init;
  if ( !drv->prepare_work )
    drv->prepare_work = (bool (*)(thr_info *, work *))noop_prepare_work;
  if ( !drv->hw_error )
    drv->hw_error = (void (*)(thr_info *))noop_hw_error;
  if ( !drv->thread_shutdown )
    drv->thread_shutdown = (void (*)(thr_info *))noop_thread_shutdown;
  if ( !drv->thread_enable )
    drv->thread_enable = (void (*)(thr_info *))noop_thread_enable;
  if ( !drv->hash_work )
    drv->hash_work = (void (*)(thr_info *))hash_sole_work;
  if ( !drv->flush_work )
    drv->flush_work = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->update_work )
    drv->update_work = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->queue_full )
    drv->queue_full = (bool (*)(cgpu_info *))noop_get_stats;
  if ( !drv->zero_stats )
    drv->zero_stats = (void (*)(cgpu_info *))generic_zero_stats;
  if ( drv->max_diff == 0.0 )
    drv->max_diff = 1.0;
}

//----- (0002BD88) --------------------------------------------------------
void __cdecl null_device_drv(device_drv *drv)
{
  drv->drv_detect = (void (*)(bool))noop_detect;
  drv->reinit_device = (void (*)(cgpu_info *))noop_reinit_device;
  drv->get_statline_before = (void (*)(unsigned __int8 *, size_t, cgpu_info *))blank_get_statline_before;
  drv->get_statline = (void (*)(unsigned __int8 *, size_t, cgpu_info *))noop_get_statline;
  drv->get_api_stats = (api_data *(*)(cgpu_info *))noop_get_api_stats;
  drv->get_stats = (bool (*)(cgpu_info *))noop_get_stats;
  drv->identify_device = (void (*)(cgpu_info *))noop_reinit_device;
  drv->set_device = 0;
  drv->thread_prepare = (bool (*)(thr_info *))noop_thread_prepare;
  drv->can_limit_work = (unsigned int (*)(thr_info *))noop_can_limit_work;
  drv->thread_init = (bool (*)(thr_info *))noop_thread_init;
  drv->prepare_work = (bool (*)(thr_info *, work *))noop_prepare_work;
  drv->hash_work = (void (*)(thr_info *))noop_hash_work;
  drv->hw_error = (void (*)(thr_info *))noop_hw_error;
  drv->thread_shutdown = (void (*)(thr_info *))noop_thread_shutdown;
  drv->thread_enable = (void (*)(thr_info *))noop_thread_enable;
  drv->zero_stats = (void (*)(cgpu_info *))generic_zero_stats;
  drv->hash_work = (void (*)(thr_info *))noop_hash_work;
  drv->queue_full = (bool (*)(cgpu_info *))noop_get_stats;
  drv->flush_work = (void (*)(cgpu_info *))noop_reinit_device;
  drv->update_work = (void (*)(cgpu_info *))noop_reinit_device;
  drv->max_diff = 1.0;
  drv->min_diff = 1.0;
}

//----- (0002BEB4) --------------------------------------------------------
void __cdecl enable_device(cgpu_info *cgpu)
{
  cgpu_info **v1; // r1
  int v2; // r3

  cgpu->deven = DEV_ENABLED;
  wr_lock_0(&devices_lock, "cgminer.c", _func___14851, 11096);
  v1 = devices;
  v2 = cgminer_id_count;
  cgpu->cgminer_id = cgminer_id_count;
  v1[cgpu->cgminer_id] = cgpu;
  cgminer_id_count = v2 + 1;
  wr_unlock(&devices_lock, "cgminer.c", _func___14851, 11098);
  if ( hotplug_mode )
    new_threads += cgpu->threads;
  else
    mining_threads += cgpu->threads;
  rwlock_init(&cgpu->qlock, "cgminer.c", _func___14851, 11109);
  cgpu->queued_work = 0;
}

//----- (0002BFAC) --------------------------------------------------------
void adjust_mostdevs()
{
  if ( total_devices - zombie_devs > most_devices )
    most_devices = total_devices - zombie_devs;
}

//----- (0002BFFC) --------------------------------------------------------
bool __cdecl add_cgpu(cgpu_info *cgpu)
{
  size_t v1; // r0
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v3; // r3
  int v4; // r3
  int v5; // r2
  int v6; // r3
  UT_hash_bucket_0 *_he_newbkt; // [sp+14h] [bp+Ch]
  UT_hash_handle *_he_hh_nxt; // [sp+1Ch] [bp+14h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+20h] [bp+18h]
  unsigned int _ha_bkt; // [sp+24h] [bp+1Ch]
  unsigned int _hf_bkt; // [sp+28h] [bp+20h]
  UT_hash_handle *_he_thh; // [sp+2Ch] [bp+24h]
  unsigned int _he_bkt_i; // [sp+30h] [bp+28h]
  const unsigned __int8 *_hj_key_0; // [sp+34h] [bp+2Ch]
  unsigned int _hj_k_0; // [sp+38h] [bp+30h]
  unsigned int _hj_j_0; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0a; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0b; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0c; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0d; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0e; // [sp+3Ch] [bp+34h]
  int _hj_i_0; // [sp+40h] [bp+38h]
  int _hj_i_0a; // [sp+40h] [bp+38h]
  int _hj_i_0b; // [sp+40h] [bp+38h]
  int _hj_i_0c; // [sp+40h] [bp+38h]
  int _hj_i_0d; // [sp+40h] [bp+38h]
  int _hj_i_0e; // [sp+40h] [bp+38h]
  int _ha_hashv; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvc; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvd; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashve; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashva; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvf; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvg; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvb; // [sp+44h] [bp+3Ch]
  unsigned __int8 *_hj_key; // [sp+48h] [bp+40h]
  unsigned int _hj_k; // [sp+4Ch] [bp+44h]
  unsigned int _hj_j; // [sp+50h] [bp+48h]
  unsigned int _hj_ja; // [sp+50h] [bp+48h]
  unsigned int _hj_jb; // [sp+50h] [bp+48h]
  unsigned int _hj_jc; // [sp+50h] [bp+48h]
  unsigned int _hj_jd; // [sp+50h] [bp+48h]
  unsigned int _hj_je; // [sp+50h] [bp+48h]
  int _hj_i; // [sp+54h] [bp+4Ch]
  int _hj_ia; // [sp+54h] [bp+4Ch]
  int _hj_ib; // [sp+54h] [bp+4Ch]
  int _hj_ic; // [sp+54h] [bp+4Ch]
  int _hj_id; // [sp+54h] [bp+4Ch]
  int _hj_ie; // [sp+54h] [bp+4Ch]
  int _hf_hashv; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvc; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvd; // [sp+58h] [bp+50h]
  unsigned int _hf_hashve; // [sp+58h] [bp+50h]
  unsigned int _hf_hashva; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvf; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvg; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvb; // [sp+58h] [bp+50h]
  _cgpu_devid_counter *d; // [sp+5Ch] [bp+54h]
  _cgpu_devid_counter *da; // [sp+5Ch] [bp+54h]

  _hj_key = cgpu->drv->name;
  _hf_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)_hj_key); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_ja = _hj_j + _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16) + (_hj_key[7] << 24);
    _hf_hashvc = _hf_hashv + _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16) + (_hj_key[11] << 24);
    _hj_ia = (_hf_hashvc >> 13) ^ (_hj_i
                                 + *_hj_key
                                 + (_hj_key[1] << 8)
                                 + (_hj_key[2] << 16)
                                 + (_hj_key[3] << 24)
                                 - _hj_ja
                                 - _hf_hashvc);
    _hj_jb = (_hj_ia << 8) ^ (_hj_ja - _hf_hashvc - _hj_ia);
    _hf_hashvd = (_hj_jb >> 13) ^ (_hf_hashvc - _hj_ia - _hj_jb);
    _hj_ib = (_hf_hashvd >> 12) ^ (_hj_ia - _hj_jb - _hf_hashvd);
    _hj_jc = (_hj_ib << 16) ^ (_hj_jb - _hf_hashvd - _hj_ib);
    _hf_hashve = (_hj_jc >> 5) ^ (_hf_hashvd - _hj_ib - _hj_jc);
    _hj_i = (_hf_hashve >> 3) ^ (_hj_ib - _hj_jc - _hf_hashve);
    _hj_j = (_hj_i << 10) ^ (_hj_jc - _hf_hashve - _hj_i);
    _hf_hashv = (_hj_j >> 15) ^ (_hf_hashve - _hj_i - _hj_j);
    _hj_key += 12;
  }
  _hf_hashva = _hf_hashv + strlen((const char *)cgpu->drv->name);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      goto LABEL_9;
    case 8u:
      goto LABEL_8;
    case 9u:
      goto LABEL_7;
    case 0xAu:
      goto LABEL_6;
    case 0xBu:
      _hf_hashva += _hj_key[10] << 24;
LABEL_6:
      _hf_hashva += _hj_key[9] << 16;
LABEL_7:
      _hf_hashva += _hj_key[8] << 8;
LABEL_8:
      _hj_j += _hj_key[7] << 24;
LABEL_9:
      _hj_j += _hj_key[6] << 16;
LABEL_10:
      _hj_j += _hj_key[5] << 8;
LABEL_11:
      _hj_j += _hj_key[4];
LABEL_12:
      _hj_i += _hj_key[3] << 24;
LABEL_13:
      _hj_i += _hj_key[2] << 16;
LABEL_14:
      _hj_i += _hj_key[1] << 8;
LABEL_15:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_ic = (_hf_hashva >> 13) ^ (_hj_i - _hj_j - _hf_hashva);
  _hj_jd = (_hj_ic << 8) ^ (_hj_j - _hf_hashva - _hj_ic);
  _hf_hashvf = (_hj_jd >> 13) ^ (_hf_hashva - _hj_ic - _hj_jd);
  _hj_id = (_hf_hashvf >> 12) ^ (_hj_ic - _hj_jd - _hf_hashvf);
  _hj_je = (_hj_id << 16) ^ (_hj_jd - _hf_hashvf - _hj_id);
  _hf_hashvg = (_hj_je >> 5) ^ (_hf_hashvf - _hj_id - _hj_je);
  _hj_ie = (_hf_hashvg >> 3) ^ (_hj_id - _hj_je - _hf_hashvg);
  _hf_hashvb = (((_hj_ie << 10) ^ (_hj_je - _hf_hashvg - _hj_ie)) >> 15) ^ (_hf_hashvg
                                                                          - _hj_ie
                                                                          - ((_hj_ie << 10) ^ (_hj_je
                                                                                             - _hf_hashvg
                                                                                             - _hj_ie)));
  d = 0;
  if ( devids_14862 )
  {
    _hf_bkt = _hf_hashvb & (devids_14862->hh.tbl->num_buckets - 1);
    if ( devids_14862->hh.tbl->buckets[_hf_bkt].hh_head )
      d = (_cgpu_devid_counter *)((char *)devids_14862->hh.tbl->buckets[_hf_bkt].hh_head - devids_14862->hh.tbl->hho);
    else
      d = 0;
    while ( d )
    {
      if ( d->hh.hashv == _hf_hashvb && d->hh.keylen == strlen((const char *)cgpu->drv->name) )
      {
        v1 = strlen((const char *)cgpu->drv->name);
        if ( !memcmp(d->hh.key, cgpu->drv->name, v1) )
          break;
      }
      if ( d->hh.hh_next )
        d = (_cgpu_devid_counter *)((char *)d->hh.hh_next - devids_14862->hh.tbl->hho);
      else
        d = 0;
    }
  }
  if ( d )
  {
    cgpu->device_id = ++d->lastid;
  }
  else
  {
    da = (_cgpu_devid_counter *)cgmalloc(0x28u, "cgminer.c", _func___14887, 11143);
    cg_memcpy(da, cgpu->drv->name, 4u, "cgminer.c", _func___14887, 11144);
    da->lastid = 0;
    cgpu->device_id = da->lastid;
    _hj_key_0 = (const unsigned __int8 *)da;
    _ha_hashv = -17973521;
    _hj_j_0 = -1640531527;
    _hj_i_0 = -1640531527;
    for ( _hj_k_0 = strlen((const char *)da); _hj_k_0 > 0xB; _hj_k_0 -= 12 )
    {
      _hj_j_0a = _hj_j_0 + _hj_key_0[4] + (_hj_key_0[5] << 8) + (_hj_key_0[6] << 16) + (_hj_key_0[7] << 24);
      _ha_hashvc = _ha_hashv + _hj_key_0[8] + (_hj_key_0[9] << 8) + (_hj_key_0[10] << 16) + (_hj_key_0[11] << 24);
      _hj_i_0a = (_ha_hashvc >> 13) ^ (_hj_i_0
                                     + *_hj_key_0
                                     + (_hj_key_0[1] << 8)
                                     + (_hj_key_0[2] << 16)
                                     + (_hj_key_0[3] << 24)
                                     - _hj_j_0a
                                     - _ha_hashvc);
      _hj_j_0b = (_hj_i_0a << 8) ^ (_hj_j_0a - _ha_hashvc - _hj_i_0a);
      _ha_hashvd = (_hj_j_0b >> 13) ^ (_ha_hashvc - _hj_i_0a - _hj_j_0b);
      _hj_i_0b = (_ha_hashvd >> 12) ^ (_hj_i_0a - _hj_j_0b - _ha_hashvd);
      _hj_j_0c = (_hj_i_0b << 16) ^ (_hj_j_0b - _ha_hashvd - _hj_i_0b);
      _ha_hashve = (_hj_j_0c >> 5) ^ (_ha_hashvd - _hj_i_0b - _hj_j_0c);
      _hj_i_0 = (_ha_hashve >> 3) ^ (_hj_i_0b - _hj_j_0c - _ha_hashve);
      _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0c - _ha_hashve - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashve - _hj_i_0 - _hj_j_0);
      _hj_key_0 += 12;
    }
    _ha_hashva = _ha_hashv + strlen((const char *)da);
    switch ( _hj_k_0 )
    {
      case 1u:
        goto LABEL_43;
      case 2u:
        goto LABEL_42;
      case 3u:
        goto LABEL_41;
      case 4u:
        goto LABEL_40;
      case 5u:
        goto LABEL_39;
      case 6u:
        goto LABEL_38;
      case 7u:
        goto LABEL_37;
      case 8u:
        goto LABEL_36;
      case 9u:
        goto LABEL_35;
      case 0xAu:
        goto LABEL_34;
      case 0xBu:
        _ha_hashva += _hj_key_0[10] << 24;
LABEL_34:
        _ha_hashva += _hj_key_0[9] << 16;
LABEL_35:
        _ha_hashva += _hj_key_0[8] << 8;
LABEL_36:
        _hj_j_0 += _hj_key_0[7] << 24;
LABEL_37:
        _hj_j_0 += _hj_key_0[6] << 16;
LABEL_38:
        _hj_j_0 += _hj_key_0[5] << 8;
LABEL_39:
        _hj_j_0 += _hj_key_0[4];
LABEL_40:
        _hj_i_0 += _hj_key_0[3] << 24;
LABEL_41:
        _hj_i_0 += _hj_key_0[2] << 16;
LABEL_42:
        _hj_i_0 += _hj_key_0[1] << 8;
LABEL_43:
        _hj_i_0 += *_hj_key_0;
        break;
      default:
        break;
    }
    _hj_i_0c = (_ha_hashva >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashva);
    _hj_j_0d = (_hj_i_0c << 8) ^ (_hj_j_0 - _ha_hashva - _hj_i_0c);
    _ha_hashvf = (_hj_j_0d >> 13) ^ (_ha_hashva - _hj_i_0c - _hj_j_0d);
    _hj_i_0d = (_ha_hashvf >> 12) ^ (_hj_i_0c - _hj_j_0d - _ha_hashvf);
    _hj_j_0e = (_hj_i_0d << 16) ^ (_hj_j_0d - _ha_hashvf - _hj_i_0d);
    _ha_hashvg = (_hj_j_0e >> 5) ^ (_ha_hashvf - _hj_i_0d - _hj_j_0e);
    _hj_i_0e = (_ha_hashvg >> 3) ^ (_hj_i_0d - _hj_j_0e - _ha_hashvg);
    _ha_hashvb = (((_hj_i_0e << 10) ^ (_hj_j_0e - _ha_hashvg - _hj_i_0e)) >> 15) ^ (_ha_hashvg
                                                                                  - _hj_i_0e
                                                                                  - ((_hj_i_0e << 10) ^ (_hj_j_0e - _ha_hashvg - _hj_i_0e)));
    da->hh.hashv = _ha_hashvb;
    da->hh.key = da;
    da->hh.keylen = strlen((const char *)da);
    if ( devids_14862 )
    {
      da->hh.tbl = devids_14862->hh.tbl;
      da->hh.next = 0;
      da->hh.prev = (char *)devids_14862->hh.tbl->tail - devids_14862->hh.tbl->hho;
      devids_14862->hh.tbl->tail->next = da;
      devids_14862->hh.tbl->tail = &da->hh;
    }
    else
    {
      da->hh.next = 0;
      da->hh.prev = 0;
      devids_14862 = da;
      da->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !devids_14862->hh.tbl )
        exit(-1);
      memset(devids_14862->hh.tbl, 0, sizeof(UT_hash_table));
      devids_14862->hh.tbl->tail = &devids_14862->hh;
      devids_14862->hh.tbl->num_buckets = 32;
      devids_14862->hh.tbl->log2_num_buckets = 5;
      devids_14862->hh.tbl->hho = 8;
      tbl = devids_14862->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !devids_14862->hh.tbl->buckets )
        exit(-1);
      memset(devids_14862->hh.tbl->buckets, 0, 0x180u);
      devids_14862->hh.tbl->signature = -1609490463;
    }
    ++devids_14862->hh.tbl->num_items;
    _ha_bkt = _ha_hashvb & (devids_14862->hh.tbl->num_buckets - 1);
    v3 = &devids_14862->hh.tbl->buckets[_ha_bkt];
    ++v3->count;
    da->hh.hh_next = devids_14862->hh.tbl->buckets[_ha_bkt].hh_head;
    da->hh.hh_prev = 0;
    if ( devids_14862->hh.tbl->buckets[_ha_bkt].hh_head )
      devids_14862->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &da->hh;
    devids_14862->hh.tbl->buckets[_ha_bkt].hh_head = &da->hh;
    if ( devids_14862->hh.tbl->buckets[_ha_bkt].count >= 10 * (devids_14862->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && da->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * da->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * da->hh.tbl->num_buckets);
      da->hh.tbl->ideal_chain_maxlen = (da->hh.tbl->num_items >> (da->hh.tbl->log2_num_buckets + 1))
                                     + (((2 * da->hh.tbl->num_buckets - 1) & da->hh.tbl->num_items) != 0);
      da->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; da->hh.tbl->num_buckets > _he_bkt_i; ++_he_bkt_i )
      {
        for ( _he_thh = da->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_newbkt = &_he_new_buckets[(2 * da->hh.tbl->num_buckets - 1) & _he_thh->hashv];
          if ( ++_he_newbkt->count > da->hh.tbl->ideal_chain_maxlen )
          {
            ++da->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / da->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(da->hh.tbl->buckets);
      da->hh.tbl->num_buckets *= 2;
      ++da->hh.tbl->log2_num_buckets;
      da->hh.tbl->buckets = _he_new_buckets;
      if ( da->hh.tbl->nonideal_items <= da->hh.tbl->num_items >> 1 )
        v4 = 0;
      else
        v4 = da->hh.tbl->ineff_expands + 1;
      da->hh.tbl->ineff_expands = v4;
      if ( da->hh.tbl->ineff_expands > 1 )
        da->hh.tbl->noexpand = 1;
    }
  }
  wr_lock_0(&devices_lock, "cgminer.c", _func___14887, 11149);
  devices = (cgpu_info **)cgrealloc(devices, 4 * (total_devices + new_devices + 2), "cgminer.c", _func___14887, 11150);
  wr_unlock(&devices_lock, "cgminer.c", _func___14887, 11151);
  mutex_lock_0(&stats_lock, "cgminer.c", _func___14887, 11153);
  cgpu->last_device_valid_work = time(0);
  mutex_unlock_0(&stats_lock, "cgminer.c", _func___14887, 11155);
  if ( hotplug_mode )
  {
    v5 = new_devices;
    *(&devices[new_devices] + total_devices) = cgpu;
    new_devices = v5 + 1;
  }
  else
  {
    v6 = total_devices;
    devices[total_devices] = cgpu;
    total_devices = v6 + 1;
  }
  adjust_mostdevs();
  return 1;
}

//----- (0002CE04) --------------------------------------------------------
device_drv *__cdecl copy_drv(device_drv *drv)
{
  device_drv *copy; // [sp+14h] [bp+Ch]

  copy = (device_drv *)cgmalloc(0x78u, "cgminer.c", _func___14924, 11179);
  cg_memcpy(copy, drv, 0x78u, "cgminer.c", _func___14924, 11180);
  copy->copy = 1;
  return copy;
}

//----- (0002CE60) --------------------------------------------------------
void probe_pools()
{
  pool *pool; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->testing = 1;
    pthread_create(&pool->test_thread, 0, (void *(*)(void *))test_pool_thread, pool);
  }
}

//----- (0002CEC0) --------------------------------------------------------
void setStartTimePoint()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  sysinfo sInfo; // [sp+800h] [bp+800h] BYREF
  unsigned __int8 logstr[256]; // [sp+840h] [bp+840h] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    v0 = *_errno_location();
    v1 = _errno_location();
    v2 = strerror(*v1);
    sprintf((char *)logstr, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v2);
    total_tv_start_sys = time(0);
    total_tv_end_sys = total_tv_start_sys + 1;
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
    total_tv_end_sys = sInfo.uptime + 1;
    sprintf(
      (char *)logstr,
      "setStartTimePoint total_tv_start_sys=%d total_tv_end_sys=%d\n",
      sInfo.uptime,
      sInfo.uptime + 1);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s", (const char *)logstr);
      applog(5, tmp42, 0);
    }
  }
}

//----- (0002CFD4) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int8 **v3; // r4
  char *v4; // r4
  char *v5; // r0
  block *v6; // r4
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v8; // r3
  unsigned int v9; // r3
  unsigned __int8 *v10; // r0
  double v11; // r2
  FILE *v12; // r0
  FILE *v13; // r0
  unsigned __int8 *v14; // r0
  size_t v15; // r4
  unsigned __int8 *v16; // r0
  thr_info **v17; // r4
  thr_info **v18; // r0
  int v19; // r4
  int *v20; // r0
  char *v21; // r0
  char v23; // [sp+10h] [bp-2010h] BYREF
  char v24[4088]; // [sp+1018h] [bp-1008h] BYREF
  unsigned __int8 **argva; // [sp+2020h] [bp+0h]
  int argca; // [sp+2024h] [bp+4h] BYREF
  unsigned __int8 szfilepath[256]; // [sp+2028h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+2128h] [bp+108h] BYREF
  sysinfo sInfo; // [sp+2928h] [bp+908h] BYREF
  work *work; // [sp+2968h] [bp+948h] BYREF
  sigaction handler; // [sp+296Ch] [bp+94Ch] BYREF
  pool *pool_3; // [sp+29F8h] [bp+9D8h]
  int max_staged; // [sp+29FCh] [bp+9DCh]
  cgpu_info *cgpu_1; // [sp+2A00h] [bp+9E0h]
  pool *pool_2; // [sp+2A04h] [bp+9E4h]
  pool *pool_1; // [sp+2A08h] [bp+9E8h]
  thr_info *thr; // [sp+2A0Ch] [bp+9ECh]
  cgpu_info *cgpu_0; // [sp+2A10h] [bp+9F0h]
  size_t siz; // [sp+2A14h] [bp+9F4h]
  pool *pool_0; // [sp+2A18h] [bp+9F8h]
  cgpu_info *cgpu; // [sp+2A1Ch] [bp+9FCh]
  unsigned __int8 *start; // [sp+2A20h] [bp+A00h]
  int len; // [sp+2A24h] [bp+A04h]
  FILE *fpversion; // [sp+2A28h] [bp+A08h]
  pool *pool; // [sp+2A2Ch] [bp+A0Ch]
  UT_hash_bucket_0 *_he_newbkt; // [sp+2A30h] [bp+A10h]
  unsigned int _he_bkt; // [sp+2A34h] [bp+A14h]
  UT_hash_handle *_he_hh_nxt; // [sp+2A38h] [bp+A18h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+2A3Ch] [bp+A1Ch]
  unsigned int _ha_bkt; // [sp+2A40h] [bp+A20h]
  block *block; // [sp+2A44h] [bp+A24h]
  unsigned __int8 *s; // [sp+2A48h] [bp+A28h]
  int ts; // [sp+2A4Ch] [bp+A2Ch]
  UT_hash_handle *_he_thh; // [sp+2A50h] [bp+A30h]
  unsigned int _he_bkt_i; // [sp+2A54h] [bp+A34h]
  const unsigned __int8 *_hj_key; // [sp+2A58h] [bp+A38h]
  unsigned int _hj_k; // [sp+2A5Ch] [bp+A3Ch]
  unsigned int _hj_j; // [sp+2A60h] [bp+A40h]
  unsigned int _hj_i; // [sp+2A64h] [bp+A44h]
  unsigned int _ha_hashv; // [sp+2A68h] [bp+A48h]
  unsigned int k; // [sp+2A6Ch] [bp+A4Ch]
  int slept; // [sp+2A70h] [bp+A50h]
  int j; // [sp+2A74h] [bp+A54h]
  int i; // [sp+2A78h] [bp+A58h]
  bool pool_msg; // [sp+2A7Fh] [bp+A5Fh]

  argca = argc;
  argva = (unsigned __int8 **)argv;
  work = 0;
  pool_msg = 0;
  slept = 0;
  g_logfile_enable = 0;
  strcpy((char *)g_logfile_path, "bmminer.log");
  strcpy((char *)g_logfile_openflag, "a+");
  if ( sysconf(84) == 1 )
    selective_yield = sched_yield;
  initial_args = (unsigned __int8 **)cgmalloc(4 * (argca + 1), "cgminer.c", _func___14954, 11430);
  for ( i = 0; i < argca; ++i )
  {
    v3 = &initial_args[i];
    *v3 = (unsigned __int8 *)strdup((const char *)argva[i]);
  }
  initial_args[argca] = 0;
  mutex_init_0(&hash_lock, "cgminer.c", _func___14954, 11439);
  mutex_init_0(&update_job_lock, "cgminer.c", _func___14954, 11440);
  mutex_init_0(&console_lock, "cgminer.c", _func___14954, 11441);
  cglock_init(&control_lock, "cgminer.c", _func___14954, 11442);
  mutex_init_0(&stats_lock, "cgminer.c", _func___14954, 11443);
  mutex_init_0(&sharelog_lock, "cgminer.c", _func___14954, 11444);
  cglock_init(&ch_lock, "cgminer.c", _func___14954, 11445);
  mutex_init_0(&sshare_lock, "cgminer.c", _func___14954, 11446);
  rwlock_init(&blk_lock, "cgminer.c", _func___14954, 11447);
  rwlock_init(&netacc_lock, "cgminer.c", _func___14954, 11448);
  rwlock_init(&mining_thr_lock, "cgminer.c", _func___14954, 11449);
  rwlock_init(&devices_lock, "cgminer.c", _func___14954, 11450);
  mutex_init_0(&lp_lock, "cgminer.c", _func___14954, 11452);
  if ( pthread_cond_init(&lp_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init lp_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  mutex_init_0(&restart_lock, "cgminer.c", _func___14954, 11459);
  if ( pthread_cond_init(&restart_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init restart_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( pthread_cond_init(&gws_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init gws_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  getq = tq_new();
  if ( !getq )
  {
    strcpy((char *)tmp42, "Failed to create getq");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  stgd_lock = &getq->mutex;
  snprintf((char *)packagename, 0x100u, "%s %s", "bmminer", "2.0.0");
  handler.sa_handler = (__sighandler_t)sighandler;
  handler.sa_flags = 0;
  sigemptyset(&handler.sa_mask);
  sigaction_0(15, &handler, &termhandler);
  sigaction_0(2, &handler, &inthandler);
  sigaction_0(6, &handler, &abrthandler);
  opt_kernel_path = (unsigned __int8 *)v24;
  strcpy(v24, "/usr/bin");
  cgminer_path = (unsigned __int8 *)&v23;
  s = (unsigned __int8 *)strdup((const char *)*argva);
  v4 = (char *)cgminer_path;
  v5 = dirname((char *)s);
  strcpy(v4, v5);
  free(s);
  strcat((char *)cgminer_path, "/");
  devcursor = 8;
  logstart = 9;
  logcursor = 10;
  block = (block *)cgcalloc(104, 1u, "cgminer.c", _func___14954, 11506);
  for ( i = 0; i <= 35; ++i )
    strcat((char *)block, "0");
  _hj_key = (const unsigned __int8 *)block;
  _ha_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)block); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_i += *_hj_key + (_hj_key[1] << 8) + (_hj_key[2] << 16) + (_hj_key[3] << 24);
    _hj_j += _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16) + (_hj_key[7] << 24);
    _ha_hashv += _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16) + (_hj_key[11] << 24);
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 13;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 8;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 13;
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 12;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 16;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 5;
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 3;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 10;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 15;
    _hj_key += 12;
  }
  _ha_hashv += strlen((const char *)block);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_31;
    case 2u:
      goto LABEL_30;
    case 3u:
      goto LABEL_29;
    case 4u:
      goto LABEL_28;
    case 5u:
      goto LABEL_27;
    case 6u:
      goto LABEL_26;
    case 7u:
      goto LABEL_25;
    case 8u:
      goto LABEL_24;
    case 9u:
      goto LABEL_23;
    case 0xAu:
      goto LABEL_22;
    case 0xBu:
      _ha_hashv += _hj_key[10] << 24;
LABEL_22:
      _ha_hashv += _hj_key[9] << 16;
LABEL_23:
      _ha_hashv += _hj_key[8] << 8;
LABEL_24:
      _hj_j += _hj_key[7] << 24;
LABEL_25:
      _hj_j += _hj_key[6] << 16;
LABEL_26:
      _hj_j += _hj_key[5] << 8;
LABEL_27:
      _hj_j += _hj_key[4];
LABEL_28:
      _hj_i += _hj_key[3] << 24;
LABEL_29:
      _hj_i += _hj_key[2] << 16;
LABEL_30:
      _hj_i += _hj_key[1] << 8;
LABEL_31:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 13;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 8;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 13;
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 12;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 16;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 5;
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 3;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 10;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 15;
  block->hh.hashv = _ha_hashv;
  block->hh.key = block;
  block->hh.keylen = strlen((const char *)block);
  if ( blocks )
  {
    block->hh.tbl = blocks->hh.tbl;
    block->hh.next = 0;
    block->hh.prev = (char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho;
    blocks->hh.tbl->tail->next = block;
    blocks->hh.tbl->tail = &block->hh;
  }
  else
  {
    block->hh.next = 0;
    block->hh.prev = 0;
    blocks = block;
    v6 = block;
    v6->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
    if ( !blocks->hh.tbl )
      exit(-1);
    memset(blocks->hh.tbl, 0, sizeof(UT_hash_table));
    blocks->hh.tbl->tail = &blocks->hh;
    blocks->hh.tbl->num_buckets = 32;
    blocks->hh.tbl->log2_num_buckets = 5;
    blocks->hh.tbl->hho = 68;
    tbl = blocks->hh.tbl;
    tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
    if ( !blocks->hh.tbl->buckets )
      exit(-1);
    memset(blocks->hh.tbl->buckets, 0, 0x180u);
    blocks->hh.tbl->signature = -1609490463;
  }
  ++blocks->hh.tbl->num_items;
  _ha_bkt = _ha_hashv & (blocks->hh.tbl->num_buckets - 1);
  v8 = &blocks->hh.tbl->buckets[_ha_bkt];
  ++v8->count;
  block->hh.hh_next = blocks->hh.tbl->buckets[_ha_bkt].hh_head;
  block->hh.hh_prev = 0;
  if ( blocks->hh.tbl->buckets[_ha_bkt].hh_head )
    blocks->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &block->hh;
  blocks->hh.tbl->buckets[_ha_bkt].hh_head = &block->hh;
  if ( blocks->hh.tbl->buckets[_ha_bkt].count >= 10 * (blocks->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
    && block->hh.tbl->noexpand != 1 )
  {
    _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * block->hh.tbl->num_buckets);
    if ( !_he_new_buckets )
      exit(-1);
    memset(_he_new_buckets, 0, 24 * block->hh.tbl->num_buckets);
    block->hh.tbl->ideal_chain_maxlen = (block->hh.tbl->num_items >> (block->hh.tbl->log2_num_buckets + 1))
                                      + (((2 * block->hh.tbl->num_buckets - 1) & block->hh.tbl->num_items) != 0);
    block->hh.tbl->nonideal_items = 0;
    for ( _he_bkt_i = 0; block->hh.tbl->num_buckets > _he_bkt_i; ++_he_bkt_i )
    {
      for ( _he_thh = block->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
      {
        _he_hh_nxt = _he_thh->hh_next;
        _he_bkt = (2 * block->hh.tbl->num_buckets - 1) & _he_thh->hashv;
        _he_newbkt = &_he_new_buckets[_he_bkt];
        if ( ++_he_newbkt->count > block->hh.tbl->ideal_chain_maxlen )
        {
          ++block->hh.tbl->nonideal_items;
          _he_newbkt->expand_mult = _he_newbkt->count / block->hh.tbl->ideal_chain_maxlen;
        }
        _he_thh->hh_prev = 0;
        _he_thh->hh_next = _he_newbkt->hh_head;
        if ( _he_newbkt->hh_head )
          _he_newbkt->hh_head->hh_prev = _he_thh;
        _he_newbkt->hh_head = _he_thh;
      }
    }
    free(block->hh.tbl->buckets);
    block->hh.tbl->num_buckets *= 2;
    ++block->hh.tbl->log2_num_buckets;
    block->hh.tbl->buckets = _he_new_buckets;
    if ( block->hh.tbl->nonideal_items <= block->hh.tbl->num_items >> 1 )
      v9 = 0;
    else
      v9 = block->hh.tbl->ineff_expands + 1;
    block->hh.tbl->ineff_expands = v9;
    if ( block->hh.tbl->ineff_expands > 1 )
      block->hh.tbl->noexpand = 1;
  }
  strcpy((char *)current_hash, (const char *)block);
  scan_devices.next = &scan_devices;
  scan_devices.prev = &scan_devices;
  opt_register_table(opt_config_table, "Options for both config file and command line");
  opt_register_table(opt_cmdline_table, "Options for command line only");
  opt_parse(&argca, argva, applog_and_exit);
  if ( argca != 1 )
  {
    strcpy((char *)tmp42, "Unexpected extra commandline arguments");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( !config_loaded )
    load_default_config();
  if ( opt_benchmark || opt_benchfile )
  {
    pool = add_pool();
    v10 = (unsigned __int8 *)cgmalloc(0xFFu, "cgminer.c", _func___14954, 11542);
    pool->rpc_url = v10;
    if ( opt_benchfile )
      strcpy((char *)pool->rpc_url, "Benchfile");
    else
      strcpy((char *)pool->rpc_url, "Benchmark");
    pool->rpc_user = pool->rpc_url;
    pool->rpc_pass = pool->rpc_url;
    pool->rpc_userpass = pool->rpc_url;
    pool->sockaddr_url = pool->rpc_url;
    strncpy((char *)pool->diff, "?", 7u);
    pool->diff[7] = 0;
    enable_pool(pool);
    pool->idle = 0;
    LODWORD(v11) = 1;
    successful_connect = 1;
    for ( i = 0; ; ++i )
    {
      HIDWORD(v11) = i;
      if ( i > 15 )
        break;
      hex2bin(bench_hidiff_bins[i], bench_hidiffs[i], 0xA0u);
      hex2bin(bench_lodiff_bins[i], bench_lodiffs[i], 0xA0u);
    }
    set_target(bench_target, v11);
  }
  if ( opt_version_path )
  {
    fpversion = fopen((const char *)opt_version_path, "rb");
    memset(szfilepath, 0, sizeof(szfilepath));
    len = 0;
    start = 0;
    if ( fpversion )
    {
      len = fread(szfilepath, 1u, 0x100u, fpversion);
      if ( len > 0 )
      {
        start = (unsigned __int8 *)strchr((const char *)szfilepath, 10);
        if ( start )
        {
          cg_memcpy(g_miner_compiletime, szfilepath, start - szfilepath, "cgminer.c", _func___14954, 11601);
          strcpy((char *)szfilepath, (const char *)start + 1);
          start = (unsigned __int8 *)strchr((const char *)szfilepath, 10);
          if ( start )
            cg_memcpy(g_miner_type, szfilepath, start - szfilepath, "cgminer.c", _func___14954, 11610);
          else
            strcpy((char *)g_miner_type, (const char *)szfilepath);
        }
        else
        {
          strcpy((char *)g_miner_compiletime, (const char *)szfilepath);
        }
        if ( g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] == 10 )
          g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] = 0;
        if ( g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] == 13 )
          g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] = 0;
        if ( g_miner_type[strlen((const char *)g_miner_type) - 1] == 10 )
          g_miner_type[strlen((const char *)g_miner_type) - 1] = 0;
        if ( g_miner_type[strlen((const char *)g_miner_type) - 1] == 13 )
          g_miner_type[strlen((const char *)g_miner_type) - 1] = 0;
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Read miner version file %s error %d", (const char *)opt_version_path, len);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Open miner version file %s error", (const char *)opt_version_path);
      applog(3, tmp42, 0);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Miner compile time: %s type: %s",
        (const char *)g_miner_compiletime,
        (const char *)g_miner_type);
      applog(3, tmp42, 0);
    }
  }
  g_logfile_enable = 1;
  strcpy((char *)g_logfile_path, "/tmp/pattern_test_log");
  strcpy((char *)g_logfile_openflag, "w");
  if ( opt_logwork_path )
  {
    memset(szfilepath, 0, sizeof(szfilepath));
    if ( opt_logwork_asicnum )
    {
      if ( !*opt_logwork_asicnum )
      {
        strcpy((char *)tmp42, "Log work asic num empty");
        applog(3, tmp42, 1);
        quit(1);
      }
      g_logwork_asicnum = atoi((const char *)opt_logwork_asicnum);
      if ( g_logwork_asicnum != 1 && g_logwork_asicnum != 32 && g_logwork_asicnum != 64 )
      {
        strcpy((char *)tmp42, "Log work asic num must be 1, 32, 64");
        applog(3, tmp42, 1);
        quit(1);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Log work path: %s Asic num: %s",
          (const char *)opt_logwork_path,
          (const char *)opt_logwork_asicnum);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Log work path: %s", (const char *)opt_logwork_path);
      applog(3, tmp42, 0);
    }
    sprintf((char *)szfilepath, "%s.txt", (const char *)opt_logwork_path);
    g_logwork_file = fopen((const char *)szfilepath, "a+");
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Log work open file %s", (const char *)szfilepath);
      applog(3, tmp42, 0);
    }
    if ( g_logwork_asicnum == 1 )
    {
      sprintf((char *)szfilepath, "%s%02d.txt", (const char *)opt_logwork_path, g_logwork_asicnum);
      g_logwork_files[0] = fopen((const char *)szfilepath, "a+");
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Log work open asic %d file %s", g_logwork_asicnum, (const char *)szfilepath);
        applog(3, tmp42, 0);
      }
    }
    else if ( g_logwork_asicnum == 32 || g_logwork_asicnum == 64 )
    {
      for ( i = 0; i <= g_logwork_asicnum; ++i )
      {
        sprintf((char *)szfilepath, "%s%02d_%02d.txt", (const char *)opt_logwork_path, g_logwork_asicnum, i);
        v12 = fopen((const char *)szfilepath, "a+");
        g_logwork_files[i] = v12;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "Log work open asic %d file %s", g_logwork_asicnum, (const char *)szfilepath);
          applog(3, tmp42, 0);
        }
      }
    }
    if ( opt_logwork_diff )
    {
      for ( i = 0; i <= 64; ++i )
      {
        sprintf((char *)szfilepath, "%s_diff_%02d.txt", (const char *)opt_logwork_path, i);
        v13 = fopen((const char *)szfilepath, "a+");
        g_logwork_diffs[i] = v13;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "Log work open diff file %s", (const char *)szfilepath);
          applog(3, tmp42, 0);
        }
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Started %s", (const char *)packagename);
    applog(4, tmp42, 0);
  }
  if ( cnfbuf )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Loaded configuration file %s", (const char *)cnfbuf);
      applog(5, tmp42, 0);
    }
    if ( fileconf_load == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Error in configuration file, partially loaded.");
        applog(4, tmp42, 0);
      }
      if ( use_curses && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        strcpy((char *)tmp42, "Start cgminer with -T to see what failed to load.");
        applog(4, tmp42, 0);
      }
    }
    else if ( !fileconf_load )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Fatal JSON error in configuration file.");
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Configuration file could not be used.");
        applog(4, tmp42, 0);
      }
    }
    free(cnfbuf);
    cnfbuf = 0;
  }
  strcat((char *)opt_kernel_path, "/");
  if ( want_per_device_stats )
    opt_log_output = 1;
  if ( opt_log_output )
    setlogmask(255);
  else
    setlogmask(63);
  if ( opt_scantime < 0 )
    opt_scantime = 60;
  total_control_threads = 8;
  control_thr = (thr_info *)cgcalloc(8, 0x40u, "cgminer.c", _func___14954, 11771);
  gwsched_thr_id = 0;
  fill_device_drv(&bitforce_drv);
  fill_device_drv(&modminer_drv);
  fill_device_drv(&bitmain_drv);
  fill_device_drv(&bitmain_soc_drv);
  bitforce_drv.drv_detect(0);
  modminer_drv.drv_detect(0);
  bitmain_drv.drv_detect(0);
  bitmain_soc_drv.drv_detect(0);
  if ( opt_display_devs )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "Devices detected:");
      applog(3, tmp42, 0);
    }
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = devices[i];
      if ( cgpu->name )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            " %2d. %s %d: %s (driver: %s)",
            i,
            (const char *)cgpu->drv->name,
            cgpu->device_id,
            (const char *)cgpu->name,
            (const char *)cgpu->drv->dname);
          applog(3, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          " %2d. %s %d (driver: %s)",
          i,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          (const char *)cgpu->drv->dname);
        applog(3, tmp42, 0);
      }
    }
    snprintf((char *)tmp42, 0x800u, "%d devices listed", total_devices);
    applog(3, tmp42, 1);
    _quit(0, 0);
  }
  mining_threads = 0;
  for ( i = 0; i < total_devices; ++i )
    enable_device(devices[i]);
  if ( !total_devices )
  {
    strcpy((char *)tmp42, "All devices disabled, cannot mint!");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  most_devices = total_devices;
  load_temp_cutoffs();
  for ( i = 0; i < total_devices; ++i )
    devices[i]->cgminer_stats.getwork_wait_min.tv_sec = 99999999;
  if ( !opt_compact )
  {
    logstart += most_devices;
    logcursor = logstart + 1;
  }
  if ( !total_pools )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Need to specify at least one pool server.");
      applog(4, tmp42, 0);
    }
    strcpy((char *)tmp42, "Pool setup failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  for ( i = 0; i < total_pools; ++i )
  {
    pool_0 = pools[i];
    pool_0->cgminer_stats.getwork_wait_min.tv_sec = 99999999;
    pool_0->cgminer_pool_stats.getwork_wait_min.tv_sec = 99999999;
    if ( !pool_0->rpc_userpass )
    {
      if ( !pool_0->rpc_pass )
      {
        v14 = (unsigned __int8 *)strdup(&byte_71100);
        pool_0->rpc_pass = v14;
      }
      if ( !pool_0->rpc_user )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "No login credentials supplied for pool %u %s",
          i,
          (const char *)pool_0->rpc_url);
        applog(3, tmp42, 1);
        _quit(1, 0);
      }
      v15 = strlen((const char *)pool_0->rpc_user);
      siz = v15 + strlen((const char *)pool_0->rpc_pass) + 2;
      v16 = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___14954, 11880);
      pool_0->rpc_userpass = v16;
      snprintf(
        (char *)pool_0->rpc_userpass,
        siz,
        "%s:%s",
        (const char *)pool_0->rpc_user,
        (const char *)pool_0->rpc_pass);
    }
  }
  currentpool = *pools;
  if ( use_syslog )
    openlog("bmminer", 1, 8);
  if ( opt_stderr_cmd )
    fork_monitor();
  mining_thr = (thr_info **)cgcalloc(mining_threads, 4u, "cgminer.c", _func___14954, 11897);
  for ( i = 0; i < mining_threads; ++i )
  {
    v17 = &mining_thr[i];
    *v17 = (thr_info *)cgcalloc(1, 0x40u, "cgminer.c", _func___14954, 11901);
  }
  k = 0;
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu_0 = devices[i];
    v18 = (thr_info **)cgmalloc(4 * (cgpu_0->threads + 1), "cgminer.c", _func___14954, 11910);
    cgpu_0->thr = v18;
    cgpu_0->thr[cgpu_0->threads] = 0;
    cgpu_0->status = LIFE_INIT;
    j = 0;
    while ( cgpu_0->threads > j )
    {
      thr = get_thread(k);
      thr->id = k;
      thr->cgpu = cgpu_0;
      thr->device_thread = j;
      if ( cgpu_0->drv->thread_prepare(thr) )
      {
        if ( thr_info_create(thr, 0, (void *(*)(void *))miner_thread, thr) )
        {
          snprintf((char *)tmp42, 0x800u, "thread %d create failed", thr->id);
          applog(3, tmp42, 1);
          _quit(1, 0);
        }
        cgpu_0->thr[j] = thr;
        if ( cgpu_0->deven != DEV_DISABLED )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "Pushing sem post to thread %d", thr->id);
            applog(7, tmp42, 0);
          }
          cgsem_post(&thr->sem, "cgminer.c", _func___14954, 11938);
        }
      }
      ++j;
      ++k;
    }
  }
  if ( !opt_benchmark && !opt_benchfile )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool_1 = pools[i];
      enable_pool(pool_1);
      pool_1->idle = 1;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "Probing for an alive pool");
      applog(5, tmp42, 0);
    }
    probe_pools();
    do
    {
      sleep(1u);
      ++slept;
    }
    while ( !pools_active && slept <= 59 );
    while ( !pools_active )
    {
      if ( !pool_msg )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "No servers were found that could be used to get work from.");
          applog(3, tmp42, 0);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "Please check the details from the list below of the servers you have input");
          applog(3, tmp42, 0);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy(
            (char *)tmp42,
            "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
          applog(3, tmp42, 0);
        }
        for ( i = 0; i < total_pools; ++i )
        {
          pool_2 = pools[i];
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Pool: %d  URL: %s  User: %s  Password: %s",
              i,
              (const char *)pool_2->rpc_url,
              (const char *)pool_2->rpc_user,
              (const char *)pool_2->rpc_pass);
            applog(4, tmp42, 0);
          }
        }
        pool_msg = 1;
        if ( use_curses && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          strcpy((char *)tmp42, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
          applog(3, tmp42, 0);
        }
      }
      if ( !use_curses )
      {
        strcpy((char *)tmp42, "No servers could be used! Exiting.");
        applog(3, tmp42, 1);
        _quit(0, 0);
      }
    }
  }
  total_mhashes_done = 0.0;
  for ( i = 0; i <= 11; ++i )
    g_local_mhashes_dones[i] = 0.0;
  g_local_mhashes_index = 0;
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu_1 = devices[i];
    cgpu_1->total_mhashes = 0.0;
    cgpu_1->rolling = cgpu_1->total_mhashes;
  }
  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v19 = *_errno_location();
      v20 = _errno_location();
      v21 = strerror(*v20);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v19, v21);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
    total_tv_start_sys = sInfo.uptime;
  }
  cgtime(&total_tv_start);
  cgtime(&total_tv_end);
  cgtime(&tv_hashmeter);
  get_datestamp(datestamp, 0x28u, &total_tv_start);
  watchpool_thr_id = 2;
  thr = control_thr + 2;
  if ( thr_info_create(control_thr + 2, 0, (void *(*)(void *))watchpool_thread, 0) )
  {
    strcpy((char *)tmp42, "watchpool thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  pthread_detach(thr->pth);
  watchdog_thr_id = 3;
  thr = control_thr + 3;
  if ( thr_info_create(control_thr + 3, 0, (void *(*)(void *))watchdog_thread, 0) )
  {
    strcpy((char *)tmp42, "watchdog thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  pthread_detach(thr->pth);
  api_thr_id = 5;
  thr = control_thr + 5;
  if ( thr_info_create(control_thr + 5, 0, (void *(*)(void *))api_thread, &control_thr[5]) )
  {
    strcpy((char *)tmp42, "API thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( total_control_threads != 8 )
  {
    snprintf((char *)tmp42, 0x800u, "incorrect total_control_threads (%d) should be 8", total_control_threads);
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  set_highprio();
  while ( 1 )
  {
    while ( 1 )
    {
      max_staged = max_queue;
      if ( opt_work_update )
        signal_work_update();
      opt_work_update = 0;
      mutex_lock_0(stgd_lock, "cgminer.c", _func___14954, 12113);
      ts = _total_staged();
      if ( ts > max_staged )
      {
        work_filled = 1;
        pthread_cond_wait(&gws_cond, stgd_lock);
        ts = _total_staged();
      }
      mutex_unlock_0(stgd_lock, "cgminer.c", _func___14954, 12124);
      if ( ts <= max_staged )
        break;
      work_filled = 1;
      work = hash_pop(0);
      if ( work )
        discard_work(&work, "cgminer.c", _func___14954, 12136);
    }
    if ( work )
      discard_work(&work, "cgminer.c", _func___14954, 12144);
    work = make_work();
    while ( 1 )
    {
      pool_3 = select_pool();
      if ( !pool_unusable(pool_3) )
        break;
      switch_pools(0);
      pool_3 = select_pool();
      if ( pool_unusable(pool_3) )
        cgsleep_ms(11);
    }
    if ( pool_3->has_stratum )
    {
      gen_stratum_work(pool_3, work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated stratum work");
        applog(7, tmp42, 0);
      }
      goto LABEL_355;
    }
    if ( opt_benchfile )
    {
      get_benchfile_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchfile work");
        applog(7, tmp42, 0);
      }
      goto LABEL_355;
    }
    if ( opt_benchmark )
    {
      get_benchmark_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchmark work");
        applog(7, tmp42, 0);
      }
      goto LABEL_355;
    }
    if ( opt_benchfile )
      break;
    if ( opt_benchmark )
    {
      get_benchmark_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchmark work");
        applog(7, tmp42, 0);
      }
LABEL_355:
      stage_work(work);
      work = 0;
    }
  }
  get_benchfile_work(work);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Generated benchfile work");
    applog(7, tmp42, 0);
  }
  goto LABEL_355;
}
// 2E254: variable 'v11' is possibly undefined
// 71100: using guessed type char byte_71100;

//----- (00030140) --------------------------------------------------------
unsigned __int16 __cdecl crc16(const unsigned __int8 *buffer, int len)
{
  unsigned __int16 crc; // [sp+Eh] [bp+Eh]

  for ( crc = 0; len-- > 0; crc = (crc << 8) ^ crc16_table[(unsigned __int8)(*buffer++ ^ HIBYTE(crc))] )
    ;
  return crc;
}

//----- (000301A8) --------------------------------------------------------
unsigned int __cdecl swab32_0(unsigned int v)
{
  return bswap32(v);
}

//----- (000301C0) --------------------------------------------------------
void __cdecl flip32_0(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32_0(*((_DWORD *)src_p + i));
}

//----- (00030208) --------------------------------------------------------
void __cdecl mutex_lock_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00030288) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00030308) --------------------------------------------------------
void __cdecl mutex_unlock_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_1(lock, file, func, line);
  selective_yield();
}

//----- (00030338) --------------------------------------------------------
void __cdecl wr_lock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000303B8) --------------------------------------------------------
void __cdecl rd_lock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00030438) --------------------------------------------------------
void __cdecl rw_unlock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000304B8) --------------------------------------------------------
void __cdecl wr_unlock_noyield_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
}

//----- (000304DC) --------------------------------------------------------
void __cdecl rd_unlock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
  selective_yield();
}

//----- (0003050C) --------------------------------------------------------
void __cdecl mutex_init_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0003058C) --------------------------------------------------------
void __cdecl rwlock_init_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0003060C) --------------------------------------------------------
void __cdecl cglock_init_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init_1(&lock->mutex, file, func, line);
  rwlock_init_0(&lock->rwlock, file, func, line);
}

//----- (00030640) --------------------------------------------------------
void __cdecl cg_rlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_1(&lock->mutex, file, func, line);
  rd_lock_1(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_1(&lock->mutex, file, func, line);
}

//----- (00030684) --------------------------------------------------------
void __cdecl cg_wlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_1(&lock->mutex, file, func, line);
  wr_lock_1(&lock->rwlock, file, func, line);
}

//----- (000306B8) --------------------------------------------------------
void __cdecl cg_runlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock_1(&lock->rwlock, file, func, line);
}

//----- (000306E0) --------------------------------------------------------
void __cdecl cg_wunlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_1(&lock->rwlock, file, func, line);
  mutex_unlock_1(&lock->mutex, file, func, line);
}

//----- (00030714) --------------------------------------------------------
void __cdecl hexdump(const unsigned __int8 *p, unsigned int len)
{
  unsigned __int8 v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 line[80]; // [sp+80Ch] [bp+80Ch] BYREF
  int pos; // [sp+85Ch] [bp+85Ch]
  unsigned __int8 v; // [sp+863h] [bp+863h]
  unsigned int wordlen; // [sp+864h] [bp+864h]
  unsigned int addr; // [sp+868h] [bp+868h]
  unsigned int i; // [sp+86Ch] [bp+86Ch]

  wordlen = 4;
  for ( addr = 0; addr < len; addr += 16 )
  {
    for ( i = 0; i <= 0x4F; ++i )
    {
      if ( 2 * (wordlen + 26) == i || 2 * wordlen + 69 == i )
      {
        line[i] = 124;
      }
      else if ( 2 * (wordlen + 35) == i )
      {
        line[i] = 0;
      }
      else
      {
        line[i] = 32;
      }
    }
    for ( i = 0; 2 * wordlen > i; ++i )
    {
      v = addr >> (4 * (2 * wordlen - i - 1));
      line[i] = nibble[(addr >> (4 * (2 * wordlen - i - 1))) & 0xF];
    }
    for ( i = 0; i <= 0xF; ++i )
    {
      pos = 2 * wordlen + (i >> 3) + 3;
      if ( addr + i >= len )
        break;
      v = p[addr + i];
      line[3 * i + pos] = nibble[v >> 4];
      line[3 * i + 1 + pos] = nibble[v & 0xF];
      if ( v <= 0x1Fu || v > 0x7Eu )
        v2 = 46;
      else
        v2 = v;
      line[2 * wordlen + 53 + i] = v2;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s", (const char *)line);
      applog(7, tmp42, 0);
    }
  }
}

//----- (00030974) --------------------------------------------------------
unsigned int get_iic()
{
  return axi_fpga_addr[12];
}

//----- (000309A0) --------------------------------------------------------
unsigned __int8 __cdecl set_iic(unsigned int data)
{
  signed int ret; // [sp+14h] [bp+14h]

  axi_fpga_addr[12] = data & 0x7FFFFFFF;
  while ( 1 )
  {
    ret = get_iic();
    if ( ret < 0 )
      break;
    usleep(0x3E8u);
  }
  return ret;
}

//----- (000309F0) --------------------------------------------------------
unsigned __int8 __cdecl T9_plus_write_pic_iic(
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 which_iic,
        unsigned __int8 data)
{
  unsigned int value; // [sp+14h] [bp+14h]

  value = 0;
  while ( (get_iic() & 0x80000000) == 0 )
    usleep(0x3E8u);
  if ( read )
    value = 0x2000000;
  if ( reg_addr_valid )
    value |= (reg_addr << 8) | 0x1000000;
  return set_iic(data | ((which_iic & 7) << 16) | value | 0x400000);
}

//----- (00030A7C) --------------------------------------------------------
unsigned __int8 __cdecl s11_write_vol_iic(
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 which_iic,
        unsigned __int8 which_chain,
        unsigned __int8 data)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned int ret; // [sp+814h] [bp+80Ch]
  unsigned int counter; // [sp+818h] [bp+810h]
  unsigned int value; // [sp+81Ch] [bp+814h]

  value = 0;
  counter = 0;
  ret = 0;
  while ( 1 )
  {
    ret = get_iic();
    if ( (ret & 0x80000000) != 0 )
      break;
    usleep(0x3E8u);
  }
  if ( read )
    value |= 0x2000000u;
  if ( reg_addr_valid )
    value |= (reg_addr << 8) | 0x1000000;
  if ( which_iic )
  {
    if ( which_iic == 1 )
      value |= 0x200000u;
  }
  else
  {
    value |= 0x400000u;
  }
  value |= data | ((which_chain & 7) << 16) | ((which_iic & 3) << 26);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "IIC[%d] write data: %x", which_iic, value);
    applog(7, tmp42, 0);
  }
  return set_iic(value);
}

//----- (00030BE0) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_jump_to_app_from_loader(unsigned __int8 which_iic)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C10h] [bp+C08h]
  unsigned __int8 crc_data[2]; // [sp+C14h] [bp+C0Ch]
  unsigned __int16 crc; // [sp+C18h] [bp+C10h]
  unsigned __int8 length; // [sp+C1Bh] [bp+C13h]
  int retry_count; // [sp+C1Ch] [bp+C14h]

  length = 4;
  *(_WORD *)crc_data = 2560;
  *(_WORD *)read_back_data = 255;
  retry_count = 0;
  crc = 10;
  while ( 1 )
  {
    if ( retry_count++ > 2 )
      return 0;
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, length);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 6u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[0]);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[1]);
    usleep(0x186A0u);
    read_back_data[0] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[1] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    if ( read_back_data[0] == 6 && read_back_data[1] == 1 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s failed on Chain[%d]!\n", (const char *)_FUNCTION___11769, which_iic);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  sleep(1u);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "\n--- %s ok\n\n", (const char *)_FUNCTION___11769);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (00030DF0) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_reset_pic(unsigned __int8 which_iic)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C10h] [bp+C08h]
  unsigned __int8 crc_data[2]; // [sp+C14h] [bp+C0Ch]
  unsigned __int16 crc; // [sp+C18h] [bp+C10h]
  unsigned __int8 length; // [sp+C1Bh] [bp+C13h]
  int retry_count; // [sp+C1Ch] [bp+C14h]

  length = 4;
  *(_WORD *)crc_data = 2816;
  *(_WORD *)read_back_data = 255;
  retry_count = 0;
  crc = 11;
  while ( 1 )
  {
    if ( retry_count++ > 2 )
      return 0;
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, length);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 7u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[0]);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[1]);
    usleep(0x61A80u);
    read_back_data[0] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[1] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    usleep(0x186A0u);
    if ( read_back_data[0] == 7 && read_back_data[1] == 1 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s failed on Chain[%d]!\n", (const char *)_FUNCTION___11784, which_iic);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "\n--- %s ok\n\n", (const char *)_FUNCTION___11784);
    applog(5, tmp42, 0);
  }
  sleep(1u);
  return 1;
}

//----- (0003100C) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_pic_heart_beat(unsigned __int8 which_iic)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 read_back_data[6]; // [sp+C1Ch] [bp+C0Ch]
  unsigned __int8 crc_data[2]; // [sp+C24h] [bp+C14h]
  unsigned __int16 crc; // [sp+C28h] [bp+C18h]
  unsigned __int8 length; // [sp+C2Bh] [bp+C1Bh]
  int retry_count; // [sp+C2Ch] [bp+C1Ch]

  length = 4;
  *(_WORD *)crc_data = 6656;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&read_back_data[4] = 0;
  retry_count = 0;
  crc = 26;
  while ( 1 )
  {
    if ( retry_count++ > 2 )
      return 0;
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, length);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x16u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[0]);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[1]);
    usleep((__useconds_t)"List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d");
    read_back_data[0] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[1] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[2] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[3] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[4] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[5] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    printf(
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
      (const char *)_FUNCTION___11798,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5]);
    if ( read_back_data[1] == 22 && read_back_data[2] == 1 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s Heartbeat failed on Chain[%d], retry_count=%d!!!\n",
        (const char *)_FUNCTION___11798,
        which_iic,
        retry_count);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "\n--- %s ok, HeartBeatReturnWord = %d\n\n",
      (const char *)_FUNCTION___11798,
      read_back_data[3]);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (000312C0) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_enable_pic_dc_dc(unsigned __int8 which_iic, unsigned __int8 enable)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C10h] [bp+C08h]
  unsigned __int8 crc_data[2]; // [sp+C14h] [bp+C0Ch]
  unsigned __int16 crc; // [sp+C18h] [bp+C10h]
  unsigned __int8 length; // [sp+C1Bh] [bp+C13h]
  int retry_count; // [sp+C1Ch] [bp+C14h]

  length = 5;
  *(_WORD *)read_back_data = 255;
  retry_count = 0;
  crc = enable + 26;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = enable + 26;
  while ( 1 )
  {
    if ( retry_count++ > 2 )
      return 0;
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, length);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x15u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, enable);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[0]);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[1]);
    usleep(0x2710u);
    read_back_data[0] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[1] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    if ( read_back_data[0] == 21 && read_back_data[1] == 1 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s failed on Chain[%d]!\n", (const char *)_FUNCTION___11815, which_iic);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s [%d] ok, i2c=%d!\n", (const char *)_FUNCTION___11815, enable, which_iic);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (000314F4) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_enable_pic_dc_dc_75j(
        unsigned __int8 which_iic,
        unsigned __int8 which_chain,
        unsigned __int8 enable)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C10h] [bp+C08h]
  unsigned __int8 crc_data[2]; // [sp+C14h] [bp+C0Ch]
  unsigned __int16 crc; // [sp+C18h] [bp+C10h]
  unsigned __int8 length; // [sp+C1Bh] [bp+C13h]
  int retry_count; // [sp+C1Ch] [bp+C14h]

  length = 5;
  *(_WORD *)read_back_data = 255;
  retry_count = 0;
  crc = enable + 26;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = enable + 26;
  while ( 1 )
  {
    if ( retry_count++ > 2 )
      return 0;
    s11_write_vol_iic(0, 0, 0, which_iic, which_chain, 0x55u);
    s11_write_vol_iic(0, 0, 0, which_iic, which_chain, 0xAAu);
    s11_write_vol_iic(0, 0, 0, which_iic, which_chain, length);
    s11_write_vol_iic(0, 0, 0, which_iic, which_chain, 0x15u);
    s11_write_vol_iic(0, 0, 0, which_iic, which_chain, enable);
    s11_write_vol_iic(0, 0, 0, which_iic, which_chain, crc_data[0]);
    s11_write_vol_iic(0, 0, 0, which_iic, which_chain, crc_data[1]);
    usleep(0x2710u);
    read_back_data[0] = s11_write_vol_iic(1, 0, 0, which_iic, which_chain, 0);
    read_back_data[1] = s11_write_vol_iic(1, 0, 0, which_iic, which_chain, 0);
    if ( read_back_data[0] == 21 && read_back_data[1] == 1 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s failed on Chain[%d]!\n", (const char *)_FUNCTION___11832, which_chain);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s [%d] ok, i2c=%d!\n", (const char *)_FUNCTION___11832, enable, which_chain);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (00031760) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_enable_pic_fix_voltage(unsigned __int8 which_iic, unsigned __int8 enable)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C10h] [bp+C08h]
  unsigned __int8 crc_data[2]; // [sp+C14h] [bp+C0Ch]
  unsigned __int16 crc; // [sp+C18h] [bp+C10h]
  unsigned __int8 length; // [sp+C1Bh] [bp+C13h]
  int retry_count; // [sp+C1Ch] [bp+C14h]

  length = 5;
  *(_WORD *)read_back_data = 255;
  retry_count = 0;
  crc = enable + 53;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = enable + 53;
  while ( 1 )
  {
    if ( retry_count++ > 2 )
      return 0;
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, length);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x30u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, enable);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[0]);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[1]);
    usleep(0x2710u);
    read_back_data[0] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[1] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    if ( read_back_data[0] == 48 && read_back_data[1] == 1 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s failed on Chain[%d]!\n", (const char *)_FUNCTION___11848, which_iic);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s [%d] ok, i2c=%d!\n", (const char *)_FUNCTION___11848, enable, which_iic);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (00031994) --------------------------------------------------------
bool __cdecl isDisabledCore(int chainIndex, int chipIndex, int coreIndex)
{
  int i; // [sp+14h] [bp+14h]

  if ( disabledcore_pos_buf[chainIndex][0] == 44 && disabledcore_pos_buf[chainIndex][1] == 101 )
  {
    for ( i = 1; i <= 7; ++i )
    {
      if ( disabledcore_pos_buf[chainIndex][2 * i] == chipIndex
        && disabledcore_pos_buf[chainIndex][2 * i + 1] == coreIndex )
      {
        return 1;
      }
    }
  }
  return 0;
}

//----- (00031A2C) --------------------------------------------------------
int hasDisabledCore()
{
  int j; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( disabledcore_pos_buf[i][0] == 44 && disabledcore_pos_buf[i][1] == 101 )
    {
      for ( j = 1; j <= 7; ++j )
      {
        if ( disabledcore_pos_buf[i][2 * j] <= 0x6Bu && disabledcore_pos_buf[i][2 * j + 1] <= 0xCFu )
          return 1;
      }
    }
  }
  return 0;
}

//----- (00031AC8) --------------------------------------------------------
bool __cdecl chainHasDisabledCore(int chainIndex)
{
  int j; // [sp+Ch] [bp+Ch]

  if ( disabledcore_pos_buf[chainIndex][0] == 44 && disabledcore_pos_buf[chainIndex][1] == 101 )
  {
    for ( j = 1; j <= 7; ++j )
    {
      if ( disabledcore_pos_buf[chainIndex][2 * j] <= 0x6Bu && disabledcore_pos_buf[chainIndex][2 * j + 1] <= 0xCFu )
        return 1;
    }
  }
  return 0;
}

//----- (00031B54) --------------------------------------------------------
char __cdecl getMeddleOffsetForTestPatten(int chainIndex)
{
  return middle_Offset[8 * chainIndex];
}

//----- (00031B78) --------------------------------------------------------
bool isFixedFreqMode()
{
  return opt_fixed_freq;
}

//----- (00031B90) --------------------------------------------------------
bool isC5_Board()
{
  unsigned __int8 board_type[32]; // [sp+0h] [bp+0h] BYREF
  FILE *fd; // [sp+20h] [bp+20h]
  int isC5; // [sp+24h] [bp+24h]

  isC5 = 0;
  memset(board_type, 0, sizeof(board_type));
  fd = fopen("/usr/bin/ctrl_bd", "rb");
  if ( fd )
  {
    fread(board_type, 1u, 0x20u, fd);
    fclose(fd);
    isC5 = strstr((const char *)board_type, "XILINX") == 0;
  }
  else
  {
    isC5 = 1;
  }
  return isC5 != 0;
}

//----- (00031C14) --------------------------------------------------------
uint16_t __cdecl CRC16(const unsigned __int8 *p_data, uint16_t w_len)
{
  uint16_t wIndex; // [sp+Ch] [bp+Ch]
  unsigned __int8 chCRCLo; // [sp+Eh] [bp+Eh]
  unsigned __int8 chCRCHi; // [sp+Fh] [bp+Fh]

  chCRCHi = -1;
  chCRCLo = -1;
  while ( w_len-- != 0 )
  {
    wIndex = (unsigned __int8)(chCRCLo ^ *p_data++);
    chCRCLo = chCRCHi ^ chCRCHTalbe[wIndex];
    chCRCHi = chCRCLTalbe[wIndex];
  }
  return chCRCLo | (chCRCHi << 8);
}

//----- (00031C94) --------------------------------------------------------
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  unsigned __int8 crcout[5]; // [sp+Ch] [bp+Ch]
  int crcin; // [sp+14h] [bp+14h]
  char crcin_4; // [sp+18h] [bp+18h]
  bool din; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 crc; // [sp+1Ch] [bp+1Ch]
  unsigned __int8 k; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 j; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  crcin = 16843009;
  crcin_4 = 1;
  j = 0x80;
  k = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    din = (j & *ptr) != 0;
    crcout[0] = din ^ crcin_4;
    crcout[1] = crcin;
    crcout[2] = din ^ crcin_4 ^ BYTE1(crcin);
    *(_WORD *)&crcout[3] = HIWORD(crcin);
    j >>= 1;
    if ( ++k == 8 )
    {
      j = 0x80;
      k = 0;
      ++ptr;
    }
    crcin = *(_DWORD *)crcout;
    crcin_4 = crcout[4];
  }
  crc = 0;
  if ( crcin_4 )
    crc = 16;
  if ( HIBYTE(crcin) )
    crc |= 8u;
  if ( BYTE2(crcin) )
    crc |= 4u;
  if ( BYTE1(crcin) )
    crc |= 2u;
  if ( (_BYTE)crcin )
    crc |= 1u;
  return crc;
}

//----- (00031DB4) --------------------------------------------------------
void __noreturn get_hash_rate()
{
  uint64_t v0; // r2
  int v1; // r1
  __int64 v2; // r2
  unsigned __int64 v3; // r0
  int index[16]; // [sp+0h] [bp+0h] BYREF
  double each_chain_h[16][10]; // [sp+40h] [bp+40h] BYREF
  timeval diff; // [sp+540h] [bp+540h]
  timeval new_h; // [sp+548h] [bp+548h] BYREF
  timeval old_h; // [sp+550h] [bp+550h] BYREF
  double each_chain_h_all; // [sp+558h] [bp+558h]
  unsigned int i; // [sp+560h] [bp+560h]
  unsigned int which_chain; // [sp+564h] [bp+564h]

  which_chain = 0;
  i = 0;
  memset(each_chain_h, 0, sizeof(each_chain_h));
  each_chain_h_all = 0.0;
  memset(index, 0, sizeof(index));
  cgtime(&old_h);
  cgtime(&new_h);
  while ( 1 )
  {
    cgtime(&new_h);
    diff.tv_sec = new_h.tv_sec - old_h.tv_sec;
    diff.tv_usec = new_h.tv_usec - old_h.tv_usec;
    if ( new_h.tv_usec - old_h.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    each_chain_h_all = 0.0;
    for ( which_chain = 0; which_chain <= 0xF; ++which_chain )
    {
      if ( dev->chain_exist[which_chain] )
      {
        v0 = h_each_chain[which_chain];
        v1 = -HIDWORD(v0);
        v2 = 0xFFFFFFFFLL * (unsigned int)v0;
        HIDWORD(v3) = v1 + HIDWORD(v2);
        LODWORD(v3) = v2;
        each_chain_h[which_chain][index[which_chain]] = (double)v3;
        h_each_chain[which_chain] = 0LL;
        each_chain_h[which_chain][index[which_chain]] = each_chain_h[which_chain][index[which_chain]]
                                                      / ((double)diff.tv_sec + (double)(diff.tv_usec + 1) / 1000000.0);
        each_chain_h_avg[which_chain] = 0.0;
        for ( i = 0; i <= 9; ++i )
          each_chain_h_avg[which_chain] = each_chain_h_avg[which_chain] + each_chain_h[which_chain][i];
        sprintf((char *)displayed_rate[which_chain], "%.2f", each_chain_h_avg[which_chain] / 1000000000.0 / 10.0);
        each_chain_h_all = each_chain_h_all + each_chain_h_avg[which_chain] / 1000000000.0 / 10.0;
        if ( ++index[which_chain] > 9 )
          index[which_chain] = 0;
      }
    }
    sprintf((char *)displayed_hash_rate, "%.2f", each_chain_h_all);
    geach_chain_h_all = each_chain_h_all;
    copy_time(&old_h, &new_h);
    sleep(5u);
  }
}

//----- (00032110) --------------------------------------------------------
void __cdecl read_fpga_id(unsigned __int8 *pFpgaID)
{
  sprintf((char *)pFpgaID, "%08x%08x", axi_fpga_addr[61], axi_fpga_addr[60]);
}

//----- (0003215C) --------------------------------------------------------
unsigned __int8 __cdecl getPICvoltageFromValue(int vol_value)
{
  return (unsigned int)(1608.42045 - (double)vol_value * 170.423497 / 100.0);
}

//----- (000321B8) --------------------------------------------------------
int __cdecl getVolValueFromPICvoltage(unsigned __int8 vol_pic)
{
  return (int)(((double)vol_pic * 218900.7 + 9332700.36) / ((double)vol_pic * 249.5 + 7664.64));
}

//----- (00032230) --------------------------------------------------------
void __cdecl getPICChainIndexOffset(int chainIndex, int *pChain, int *pOffset)
{
  int new_T9_PLUS_chainOffset; // [sp+10h] [bp+10h]
  int new_T9_PLUS_chainIndex; // [sp+14h] [bp+14h]

  switch ( chainIndex )
  {
    case 1:
      new_T9_PLUS_chainIndex = 1;
      new_T9_PLUS_chainOffset = 0;
      break;
    case 2:
      new_T9_PLUS_chainIndex = 2;
      new_T9_PLUS_chainOffset = 0;
      break;
    case 3:
      new_T9_PLUS_chainIndex = 3;
      new_T9_PLUS_chainOffset = 0;
      break;
    case 8:
      new_T9_PLUS_chainIndex = 1;
      new_T9_PLUS_chainOffset = 1;
      break;
    case 9:
      new_T9_PLUS_chainIndex = 1;
      new_T9_PLUS_chainOffset = 2;
      break;
    case 10:
      new_T9_PLUS_chainIndex = 2;
      new_T9_PLUS_chainOffset = 1;
      break;
    case 11:
      new_T9_PLUS_chainIndex = 2;
      new_T9_PLUS_chainOffset = 2;
      break;
    case 12:
      new_T9_PLUS_chainIndex = 3;
      new_T9_PLUS_chainOffset = 1;
      break;
    case 13:
      new_T9_PLUS_chainIndex = 3;
      new_T9_PLUS_chainOffset = 2;
      break;
    default:
      new_T9_PLUS_chainIndex = 0;
      new_T9_PLUS_chainOffset = 0;
      break;
  }
  *pChain = new_T9_PLUS_chainIndex;
  *pOffset = new_T9_PLUS_chainOffset;
}

//----- (000322FC) --------------------------------------------------------
int __cdecl getChainAsicFreqIndex(int chainIndex, int asicIndex)
{
  return last_freq[chainIndex][2 * asicIndex + 3];
}

//----- (0003232C) --------------------------------------------------------
int get_pic_iic()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[12];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: IIC_COMMAND is 0x%x\n", (const char *)_FUNCTION___11992, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (000323C8) --------------------------------------------------------
unsigned __int8 __cdecl set_pic_iic(unsigned int data)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 ret_data; // [sp+813h] [bp+80Bh]
  unsigned int ret; // [sp+814h] [bp+80Ch]

  ret = 0;
  ret_data = 0;
  axi_fpga_addr[12] = data & 0x7FFFFFFF;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set IIC_COMMAND is 0x%x\n", (const char *)_FUNCTION___11999, data & 0x7FFFFFFF);
    applog(7, tmp42, 0);
  }
  while ( 1 )
  {
    ret = get_pic_iic();
    if ( (ret & 0x80000000) != 0 )
      break;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: waiting write pic iic\n", (const char *)_FUNCTION___11999);
      applog(7, tmp42, 0);
    }
    cgsleep_us(1000LL);
  }
  return ret;
}

//----- (00032500) --------------------------------------------------------
unsigned __int8 __cdecl write_pic_iic(
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 chain,
        unsigned __int8 data)
{
  unsigned int value; // [sp+Ch] [bp+Ch]

  value = 0;
  if ( read )
    value = 0x2000000;
  if ( reg_addr_valid )
    value |= (reg_addr << 8) | 0x1000000;
  return set_pic_iic(data | ((chain & 0xF) << 16) | value | 0x400000);
}

//----- (00032570) --------------------------------------------------------
void __cdecl send_pic_command(unsigned __int8 chain)
{
  write_pic_iic(0, 0, 0, chain, 0x55u);
  write_pic_iic(0, 0, 0, chain, 0xAAu);
}

//----- (000325A4) --------------------------------------------------------
void __cdecl set_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 addr_H, unsigned __int8 addr_L)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 check_addr_L; // [sp+C1Ah] [bp+C0Ah] BYREF
  unsigned __int8 check_addr_H; // [sp+C1Bh] [bp+C0Bh] BYREF
  int try_count; // [sp+C1Ch] [bp+C0Ch]

  try_count = 0;
  while ( 1 )
  {
    send_pic_command(chain);
    write_pic_iic(0, 0, 0, chain, 1u);
    write_pic_iic(0, 0, 0, chain, addr_H);
    write_pic_iic(0, 0, 0, chain, addr_L);
    get_pic_iic_flash_addr_pointer(chain, &check_addr_H, &check_addr_L);
    if ( addr_H == check_addr_H && addr_L == check_addr_L )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Error of set PIC FLASH addr: addr_H=%x(%x) addr_L=%x(%x) on Chain[%d]\n",
        addr_H,
        check_addr_H,
        addr_L,
        check_addr_L,
        chain);
      applog(5, tmp42, 0);
    }
    if ( ++try_count > 3 )
      break;
    reset_iic_pic(chain);
    sleep(5u);
  }
}

//----- (000326CC) --------------------------------------------------------
void __cdecl send_data_to_pic_iic(
        unsigned __int8 chain,
        unsigned __int8 command,
        unsigned __int8 *buf,
        unsigned __int8 length)
{
  int i; // [sp+14h] [bp+Ch]

  write_pic_iic(0, 0, 0, chain, command);
  for ( i = 0; length > i; ++i )
    write_pic_iic(0, 0, 0, chain, buf[i]);
}

//----- (00032724) --------------------------------------------------------
void __cdecl get_data_from_pic_iic(
        unsigned __int8 chain,
        unsigned __int8 command,
        unsigned __int8 *buf,
        unsigned __int8 length)
{
  int i; // [sp+14h] [bp+Ch]

  write_pic_iic(0, 0, 0, chain, command);
  for ( i = 0; length > i; ++i )
    buf[i] = write_pic_iic(1, 0, 0, chain, 0);
}

//----- (00032780) --------------------------------------------------------
void __cdecl send_data_to_pic_flash(unsigned __int8 chain, unsigned __int8 *buf)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 2u, buf, 0x10u);
}

//----- (000327AC) --------------------------------------------------------
void __cdecl get_data_from_pic_flash(unsigned __int8 chain, unsigned __int8 *buf)
{
  send_pic_command(chain);
  get_data_from_pic_iic(chain, 3u, buf, 0x10u);
}

//----- (000327D8) --------------------------------------------------------
unsigned __int8 __cdecl erase_pic_flash(unsigned __int8 chain)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 4u);
  usleep(0x186A0u);
  return 0;
}

//----- (00032814) --------------------------------------------------------
unsigned __int8 __cdecl erase_pic_flash_all(unsigned __int8 chain)
{
  unsigned int i; // [sp+14h] [bp+14h]

  set_pic_iic_flash_addr_pointer(chain, 3u, 0);
  for ( i = 0; i < 0x64; ++i )
    erase_pic_flash(chain);
  return 100;
}

//----- (00032888) --------------------------------------------------------
void __cdecl set_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x22u, value, 8u);
  cgsleep_ms(100000);
}

//----- (000328C0) --------------------------------------------------------
void __cdecl get_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value)
{
  AT24C02_read_bytes(0x98u, value, chain, 8u);
}

//----- (000328E4) --------------------------------------------------------
unsigned __int8 __cdecl write_data_into_pic_flash(unsigned __int8 chain)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 5u);
  usleep(0x186A0u);
  return 0;
}

//----- (00032920) --------------------------------------------------------
unsigned __int8 __cdecl jump_to_app_from_loader(unsigned __int8 chain)
{
  unsigned __int8 v1; // r3

  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 6u);
  cgsleep_us(100000LL);
  return v1;
}
// 32956: variable 'v1' is possibly undefined

//----- (00032960) --------------------------------------------------------
unsigned __int8 __cdecl reset_iic_pic(unsigned __int8 chain)
{
  unsigned __int8 v1; // r3

  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 7u);
  cgsleep_us(100000LL);
  return v1;
}
// 32996: variable 'v1' is possibly undefined

//----- (000329A0) --------------------------------------------------------
void __cdecl get_pic_software_version(unsigned __int8 chain, unsigned __int8 *version)
{
  int i; // [sp+14h] [bp+Ch]

  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 0x17u);
  for ( i = 0; i <= 0; ++i )
    version[i] = write_pic_iic(1, 0, 0, chain, 0);
}

//----- (000329FC) --------------------------------------------------------
void __cdecl update_pic_program(unsigned __int8 chain)
{
  unsigned __int8 *v1; // r3
  int v2; // r0
  int v3; // r1
  int v4; // r2
  int v5; // r3
  unsigned __int8 buf[16]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 data_read[5]; // [sp+18h] [bp+18h] BYREF
  unsigned __int8 program_data[10240]; // [sp+20h] [bp+20h] BYREF
  FILE *pic_program_file; // [sp+2820h] [bp+2820h]
  unsigned int pic_flash_length; // [sp+2824h] [bp+2824h]
  unsigned __int8 end_addr_l; // [sp+2828h] [bp+2828h]
  unsigned __int8 end_addr_h; // [sp+2829h] [bp+2829h]
  unsigned __int8 start_addr_l; // [sp+282Ah] [bp+282Ah]
  unsigned __int8 start_addr_h; // [sp+282Bh] [bp+282Bh]
  unsigned int data_int; // [sp+282Ch] [bp+282Ch]
  unsigned int j; // [sp+2830h] [bp+2830h]
  unsigned int i; // [sp+2834h] [bp+2834h]

  memset(program_data, 0, sizeof(program_data));
  i = 0;
  data_read[0] = 0;
  data_read[1] = 0;
  data_read[2] = 0;
  data_read[3] = 0;
  data_read[4] = 0;
  memset(buf, 0, sizeof(buf));
  data_int = 0;
  start_addr_h = 3;
  start_addr_l = 0;
  end_addr_h = 15;
  end_addr_l = 127;
  pic_flash_length = 0;
  pic_program_file = fopen("/etc/config/hash_s8_app.txt", "r");
  if ( pic_program_file )
  {
    fseek(pic_program_file, 0, 0);
    memset(program_data, 0, sizeof(program_data));
    pic_flash_length = (end_addr_h << 8) + end_addr_l - ((start_addr_h << 8) + start_addr_l) + 1;
    for ( i = 0; i < pic_flash_length; ++i )
    {
      fgets((char *)data_read, 1023, pic_program_file);
      data_int = strtoul((const char *)data_read, 0, 16);
      program_data[2 * i] = BYTE1(data_int);
      program_data[2 * i + 1] = data_int;
    }
    fclose(pic_program_file);
    reset_iic_pic(chain);
    erase_pic_flash_all(chain);
    set_pic_iic_flash_addr_pointer(chain, 3u, 0);
    for ( i = 0; 4 * (pic_flash_length >> 5) > i; ++i )
    {
      v1 = &program_data[16 * i];
      v2 = *(_DWORD *)v1;
      v3 = *((_DWORD *)v1 + 1);
      v4 = *((_DWORD *)v1 + 2);
      v5 = *((_DWORD *)v1 + 3);
      *(_DWORD *)buf = v2;
      *(_DWORD *)&buf[4] = v3;
      *(_DWORD *)&buf[8] = v4;
      *(_DWORD *)&buf[12] = v5;
      printf("send pic program time: %d\n", i);
      for ( j = 0; j <= 0xF; ++j )
        printf("buf[%d] = 0x%02x\n", j, buf[j]);
      putchar(10);
      send_data_to_pic_flash(chain, buf);
      write_data_into_pic_flash(chain);
    }
  }
  else
  {
    printf("\n%s: open hash_s8_app.txt failed\n", (const char *)_FUNCTION___12116);
  }
}

//----- (00032D70) --------------------------------------------------------
void __cdecl jump_to_app_CheckAndRestorePIC(int chainIndex)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 pic_version; // [sp+C13h] [bp+C0Bh] BYREF
  int try_count; // [sp+C14h] [bp+C0Ch]

  try_count = 0;
  jump_to_app_from_loader(chainIndex);
  get_pic_software_version(chainIndex, &pic_version);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Check chain[%d] PIC fw version=0x%02x\n", chainIndex, pic_version);
    applog(5, tmp42, 0);
  }
}

//----- (00032E04) --------------------------------------------------------
void __cdecl get_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 *addr_H, unsigned __int8 *addr_L)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 8u);
  *addr_H = write_pic_iic(1, 0, 0, chain, 0);
  *addr_L = write_pic_iic(1, 0, 0, chain, 0);
}

//----- (00032E64) --------------------------------------------------------
unsigned __int8 __cdecl write_EEPROM_iic(
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 which_iic,
        unsigned __int8 data)
{
  unsigned int counter; // [sp+10h] [bp+10h]
  unsigned int value; // [sp+14h] [bp+14h]

  value = 0;
  counter = 0;
  while ( 1 )
  {
    get_iic();
    if ( counter++ > 3 )
      break;
    usleep(0x3E8u);
  }
  if ( read )
    value = 0x2000000;
  if ( reg_addr_valid )
    value |= (reg_addr << 8) | 0x1000000;
  return set_iic(data | ((which_iic & 7) << 16) | value | 0xA00000);
}

//----- (00032F04) --------------------------------------------------------
void __cdecl AT24C02_write_one_byte(unsigned __int8 address, unsigned __int8 data, unsigned __int8 which_iic)
{
  write_EEPROM_iic(0, 1, address, which_iic, data);
}

//----- (00032F30) --------------------------------------------------------
unsigned __int8 __cdecl AT24C02_read_one_byte(unsigned __int8 address, unsigned __int8 which_iic)
{
  return write_EEPROM_iic(1, 1, address, which_iic, 0);
}

//----- (00032F64) --------------------------------------------------------
void __cdecl AT24C02_write_bytes(
        unsigned __int8 address,
        unsigned __int8 *buf,
        unsigned __int8 which_iic,
        unsigned __int8 length)
{
  unsigned __int8 i; // [sp+Fh] [bp+Fh]

  if ( address + length <= 256 )
  {
    for ( i = 0; i < (unsigned int)length; ++i )
      AT24C02_write_one_byte(address + i, buf[i], which_iic);
  }
}

//----- (00032FC0) --------------------------------------------------------
void __cdecl AT24C02_read_bytes(
        unsigned __int8 address,
        unsigned __int8 *buf,
        unsigned __int8 which_iic,
        unsigned __int8 length)
{
  unsigned __int8 i; // [sp+Fh] [bp+Fh]

  if ( address + length <= 256 )
  {
    for ( i = 0; i < (unsigned int)length; ++i )
      buf[i] = AT24C02_read_one_byte(address + i, which_iic);
  }
}

//----- (0003301C) --------------------------------------------------------
unsigned __int8 __cdecl read_disabled_cores(unsigned __int8 chain, unsigned __int8 *buf)
{
  if ( fpga_version <= 13 && fpga_major_version <= 197 )
  {
    if ( chain % 3u )
      return 0;
    AT24C02_read_bytes(0xA0u, buf, chain / 3u, 0x10u);
    return 16;
  }
  if ( chain && chain <= 3u )
  {
    AT24C02_read_bytes(0xA0u, buf, chain, 0x10u);
    return 16;
  }
  return 0;
}

//----- (000330B0) --------------------------------------------------------
unsigned __int8 __cdecl read_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf)
{
  if ( fpga_version <= 13 && fpga_major_version <= 197 )
  {
    if ( chain % 3u )
      return 0;
    AT24C02_read_bytes(0, buf, chain / 3u, 0x80u);
    return 0x80;
  }
  if ( chain && chain <= 3u )
  {
    AT24C02_read_bytes(0, buf, chain, 0x80u);
    return 0x80;
  }
  return 0;
}

//----- (00033144) --------------------------------------------------------
unsigned __int8 __cdecl save_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf)
{
  if ( fpga_version <= 13 && fpga_major_version <= 197 )
  {
    if ( chain % 3u )
      return 0;
    AT24C02_write_bytes(0, buf, chain / 3u, 0x80u);
    return 0x80;
  }
  if ( chain && chain <= 3u )
  {
    AT24C02_write_bytes(0, buf, chain, 0x80u);
    return 0x80;
  }
  return 0;
}

//----- (000331D8) --------------------------------------------------------
void __cdecl AT24C02_save_voltage(unsigned __int8 which_iic, unsigned __int8 voltage)
{
  AT24C02_write_one_byte(0x90u, voltage, which_iic);
}

//----- (000331FC) --------------------------------------------------------
unsigned __int8 __cdecl AT24C02_read_voltage(unsigned __int8 which_iic)
{
  return AT24C02_read_one_byte(0x90u, which_iic);
}

//----- (0003321C) --------------------------------------------------------
unsigned __int8 __cdecl AT24C02_read_freq_one_chip(unsigned __int8 which_iic)
{
  return AT24C02_read_one_byte(0, which_iic);
}

//----- (0003323C) --------------------------------------------------------
int __cdecl set_Voltage_S9_plus_plus_BM1387_54(unsigned __int8 which_iic, unsigned __int8 pic_voltage)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C10h] [bp+C08h]
  unsigned __int8 crc_data[2]; // [sp+C14h] [bp+C0Ch]
  unsigned __int8 voltage3; // [sp+C19h] [bp+C11h]
  unsigned __int8 voltage2; // [sp+C1Ah] [bp+C12h]
  unsigned __int8 voltage1; // [sp+C1Bh] [bp+C13h]
  unsigned __int16 crc; // [sp+C1Ch] [bp+C14h]
  unsigned __int8 length; // [sp+C1Fh] [bp+C17h]
  double temp_voltage; // [sp+C20h] [bp+C18h]
  int retry_count; // [sp+C2Ch] [bp+C24h]

  temp_voltage = 0.0;
  length = 7;
  *(_WORD *)crc_data = 255;
  *(_WORD *)read_back_data = 255;
  crc = 0;
  voltage1 = pic_voltage;
  voltage2 = 0;
  voltage3 = 0;
  retry_count = 0;
  dsPIC33EP16GS202_enable_pic_dc_dc(which_iic, 0);
  cgsleep_ms(500);
  if ( (voltage1 & 0x80u) != 0 || (voltage2 & 0x80u) != 0 || (voltage3 & 0x80u) != 0 )
    return 0;
  crc = length + voltage1 + voltage2 + voltage3 + 16;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = length + voltage1 + voltage2 + voltage3 + 16;
  while ( retry_count++ <= 2 )
  {
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, length);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x10u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, voltage1);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, voltage2);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, voltage3);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[0]);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[1]);
    usleep(0x186A0u);
    read_back_data[0] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[1] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    if ( read_back_data[0] == 16 && read_back_data[1] == 1 )
    {
      printf("\n--- %s ok!\n\n", (const char *)_FUNCTION___12218);
      cgsleep_ms(500);
      dsPIC33EP16GS202_enable_pic_dc_dc(which_iic, 1u);
      sleep(1u);
      return 1;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s failed on Chain[%d]!\n\n", (const char *)_FUNCTION___12218, which_iic);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  return 0;
}

//----- (000334DC) --------------------------------------------------------
int __cdecl set_voltage_s11_into_PIC(unsigned __int8 which_chain, unsigned int pic_voltage)
{
  int data; // [sp+4h] [bp-Ch]
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C1Ch] [bp+C0Ch]
  unsigned __int8 crc_data[2]; // [sp+C20h] [bp+C10h]
  int retry_count; // [sp+C24h] [bp+C14h]
  unsigned __int8 voltage3; // [sp+C29h] [bp+C19h]
  unsigned __int8 voltage2; // [sp+C2Ah] [bp+C1Ah]
  unsigned __int8 voltage1; // [sp+C2Bh] [bp+C1Bh]
  unsigned __int16 crc; // [sp+C2Ch] [bp+C1Ch]
  unsigned __int8 length; // [sp+C2Fh] [bp+C1Fh]
  double temp_voltage; // [sp+C30h] [bp+C20h]

  length = 7;
  *(_WORD *)crc_data = 255;
  *(_WORD *)read_back_data = 255;
  crc = 0;
  voltage1 = 0;
  voltage2 = 0;
  voltage3 = 0;
  retry_count = 0;
  dsPIC33EP16GS202_enable_pic_dc_dc(which_chain, 0);
  cgsleep_ms(500);
  temp_voltage = 1718.45913 - (double)pic_voltage * 85.509875 / 100.0;
  if ( temp_voltage < 0.0 )
    temp_voltage = 0.0;
  voltage1 = (unsigned int)temp_voltage;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s,pic vol = %d ,temp vol = %d",
      (const char *)_FUNCTION___12238,
      pic_voltage,
      data);
    applog(5, tmp42, 0);
  }
  s11_write_vol_iic(0, 1, 2u, 1u, 0, voltage1);
  usleep(0x186A0u);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "\n--- %s chain[%d]ok! pic-vol=%d; vol index=%d\n\n",
      (const char *)_FUNCTION___12238,
      which_chain,
      pic_voltage,
      voltage1);
    applog(5, tmp42, 0);
  }
  cgsleep_ms(500);
  dsPIC33EP16GS202_enable_pic_dc_dc(which_chain, 1u);
  sleep(1u);
  return 1;
}
// 33604: variable 'data' is possibly undefined

//----- (000336E8) --------------------------------------------------------
int __cdecl set_voltage_s11_into_PIC_without_disable(unsigned __int8 which_chain, unsigned int pic_voltage)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C1Ch] [bp+C0Ch]
  unsigned __int8 crc_data[2]; // [sp+C20h] [bp+C10h]
  int retry_count; // [sp+C24h] [bp+C14h]
  unsigned __int8 voltage3; // [sp+C29h] [bp+C19h]
  unsigned __int8 voltage2; // [sp+C2Ah] [bp+C1Ah]
  unsigned __int8 voltage1; // [sp+C2Bh] [bp+C1Bh]
  unsigned __int16 crc; // [sp+C2Ch] [bp+C1Ch]
  unsigned __int8 length; // [sp+C2Fh] [bp+C1Fh]
  double temp_voltage; // [sp+C30h] [bp+C20h]

  length = 7;
  *(_WORD *)crc_data = 255;
  *(_WORD *)read_back_data = 255;
  crc = 0;
  voltage1 = 0;
  voltage2 = 0;
  voltage3 = 0;
  retry_count = 0;
  cgsleep_ms(500);
  temp_voltage = 1718.45913 - (double)pic_voltage * 85.509875 / 100.0;
  if ( temp_voltage < 0.0 )
    temp_voltage = 0.0;
  voltage1 = (unsigned int)temp_voltage;
  s11_write_vol_iic(0, 1, 2u, 1u, 0, voltage1);
  usleep(0x186A0u);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "\n--- %s chain[%d]ok! pic-vol=%d; vol index=%d\n\n",
      (const char *)_FUNCTION___12257,
      which_chain,
      pic_voltage,
      voltage1);
    applog(5, tmp42, 0);
  }
  cgsleep_ms(500);
  sleep(1u);
  return 1;
}

//----- (00033870) --------------------------------------------------------
int __cdecl set_Voltage_S9_plus_plus_BM1387_54_without_disable(unsigned __int8 which_iic, unsigned __int8 pic_voltage)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 read_back_data[2]; // [sp+C10h] [bp+C08h]
  unsigned __int8 crc_data[2]; // [sp+C14h] [bp+C0Ch]
  unsigned __int8 voltage3; // [sp+C19h] [bp+C11h]
  unsigned __int8 voltage2; // [sp+C1Ah] [bp+C12h]
  unsigned __int8 voltage1; // [sp+C1Bh] [bp+C13h]
  unsigned __int16 crc; // [sp+C1Ch] [bp+C14h]
  unsigned __int8 length; // [sp+C1Fh] [bp+C17h]
  double temp_voltage; // [sp+C20h] [bp+C18h]
  int retry_count; // [sp+C2Ch] [bp+C24h]

  temp_voltage = 0.0;
  length = 7;
  *(_WORD *)crc_data = 255;
  *(_WORD *)read_back_data = 255;
  crc = 0;
  voltage1 = pic_voltage;
  voltage2 = 0;
  voltage3 = 0;
  retry_count = 0;
  if ( (pic_voltage & 0x80u) != 0 || (voltage2 & 0x80u) != 0 || (voltage3 & 0x80u) != 0 )
    return 0;
  crc = length + voltage1 + voltage2 + voltage3 + 16;
  crc_data[0] = HIBYTE(crc);
  crc_data[1] = length + voltage1 + voltage2 + voltage3 + 16;
  while ( retry_count++ <= 2 )
  {
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, length);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x10u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, voltage1);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, voltage2);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, voltage3);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[0]);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, crc_data[1]);
    usleep(0x186A0u);
    read_back_data[0] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    read_back_data[1] = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    if ( read_back_data[0] == 16 && read_back_data[1] == 1 )
    {
      printf("\n--- %s ok!\n\n", (const char *)_FUNCTION___12275);
      cgsleep_ms(500);
      return 1;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s failed on Chain[%d]!\n\n", (const char *)_FUNCTION___12275, which_iic);
      applog(5, tmp42, 0);
    }
    sleep(1u);
  }
  return 0;
}

//----- (00033AEC) --------------------------------------------------------
void __cdecl set_voltage_T9_18_into_PIC(unsigned __int8 chain, unsigned __int8 voltage)
{
  set_Voltage_S9_plus_plus_BM1387_54(chain, voltage);
}

//----- (00033B10) --------------------------------------------------------
void __cdecl set_voltage_T9_18_into_PIC_without_disable(unsigned __int8 chain, unsigned __int8 voltage)
{
  set_Voltage_S9_plus_plus_BM1387_54_without_disable(chain, voltage);
}

//----- (00033B34) --------------------------------------------------------
unsigned __int8 __cdecl getHighestVoltagePIC(int chainIndex)
{
  int v1; // r2
  unsigned __int8 minVolPIC; // [sp+13h] [bp+13h]
  int i; // [sp+14h] [bp+14h]
  int ia; // [sp+14h] [bp+14h]
  int ib; // [sp+14h] [bp+14h]
  int ic; // [sp+14h] [bp+14h]

  if ( fpga_version <= 13 && fpga_major_version <= 197 )
  {
    minVolPIC = chain_voltage_pic[chainIndex];
    for ( ic = 3 * (chainIndex / 3); 3 * (chainIndex / 3) + 3 > ic; ++ic )
    {
      if ( minVolPIC > (unsigned int)chain_voltage_pic[ic] )
        minVolPIC = chain_voltage_pic[ic];
    }
  }
  else
  {
    if ( (unsigned int)chainIndex > 0xD )
      return 0;
    v1 = 1 << chainIndex;
    if ( ((1 << chainIndex) & 0x3008) != 0 )
    {
      minVolPIC = chain_voltage_pic[3];
      for ( ib = 12; ib <= 13; ++ib )
      {
        if ( minVolPIC > (unsigned int)chain_voltage_pic[ib] )
          minVolPIC = chain_voltage_pic[ib];
      }
    }
    else
    {
      if ( (v1 & 0xC04) == 0 )
      {
        if ( (v1 & 0x302) != 0 )
        {
          minVolPIC = chain_voltage_pic[1];
          for ( i = 8; i <= 9; ++i )
          {
            if ( minVolPIC > (unsigned int)chain_voltage_pic[i] )
              minVolPIC = chain_voltage_pic[i];
          }
          return minVolPIC;
        }
        return 0;
      }
      minVolPIC = chain_voltage_pic[2];
      for ( ia = 10; ia <= 11; ++ia )
      {
        if ( minVolPIC > (unsigned int)chain_voltage_pic[ia] )
          minVolPIC = chain_voltage_pic[ia];
      }
    }
  }
  return minVolPIC;
}

//----- (00033CC8) --------------------------------------------------------
void __cdecl set_pic_voltage_T9_18(unsigned __int8 chain)
{
  int VolValueFromPICvoltage; // r4
  int v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 vol_pic; // [sp+C17h] [bp+C0Fh]

  vol_pic = getHighestVoltagePIC(chain);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    VolValueFromPICvoltage = getVolValueFromPICvoltage(chain_voltage_pic[chain]);
    v2 = getVolValueFromPICvoltage(vol_pic);
    snprintf(
      (char *)tmp42,
      0x800u,
      "set voltage=%d on chain[%d], the real voltage=%d\n",
      VolValueFromPICvoltage,
      chain,
      v2);
    applog(5, tmp42, 0);
  }
  set_voltage_T9_18_into_PIC(chain, vol_pic);
}

//----- (00033D78) --------------------------------------------------------
void __cdecl set_pic_voltage(unsigned __int8 chain, unsigned __int8 voltage)
{
  if ( fpga_version <= 13 && fpga_major_version <= 197 )
  {
    if ( chain % 3u )
      return;
    goto LABEL_7;
  }
  if ( chain && chain <= 3u )
LABEL_7:
    set_pic_voltage_T9_18(chain);
}

//----- (00033DEC) --------------------------------------------------------
unsigned __int8 __cdecl get_pic_voltage(unsigned __int8 chain)
{
  int new_T9_PLUS_chainOffset; // [sp+8h] [bp+8h] BYREF
  int new_T9_PLUS_chainIndex; // [sp+Ch] [bp+Ch] BYREF

  if ( fpga_version <= 13 && fpga_major_version <= 197 )
    return AT24C02_read_voltage(chain / 3u);
  getPICChainIndexOffset(chain, &new_T9_PLUS_chainIndex, &new_T9_PLUS_chainOffset);
  return AT24C02_read_voltage(new_T9_PLUS_chainIndex);
}

//----- (00033E58) --------------------------------------------------------
void __cdecl set_voltage_setting_time(unsigned __int8 chain, unsigned __int8 *time)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x11u, time, 6u);
  cgsleep_us(100000LL);
}

//----- (00033E94) --------------------------------------------------------
void __cdecl set_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x12u, id, 0xCu);
  cgsleep_us(100000LL);
}

//----- (00033ED0) --------------------------------------------------------
void __cdecl get_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id)
{
  send_pic_command(chain);
  get_data_from_pic_iic(chain, 0x13u, id, 0xCu);
}

//----- (00033EFC) --------------------------------------------------------
void __cdecl write_host_MAC_and_time(unsigned __int8 chain, unsigned __int8 *buf)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x14u, buf, 0xCu);
  cgsleep_us(100000LL);
}

//----- (00033F38) --------------------------------------------------------
void __cdecl enable_pic_dc_dc(unsigned __int8 chain)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 0x15u);
  write_pic_iic(0, 0, 0, chain, 1u);
}

//----- (00033F74) --------------------------------------------------------
void enable_pic_dc_dc_all()
{
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      enable_pic_dc_dc(i);
      cgsleep_ms(1);
    }
  }
}

//----- (00033FBC) --------------------------------------------------------
void __cdecl enable_pic_dac(unsigned __int8 chain)
{
  dsPIC33EP16GS202_enable_pic_dc_dc(chain, 1u);
}

//----- (00033FD8) --------------------------------------------------------
void __cdecl disable_pic_dac(unsigned __int8 chain)
{
  dsPIC33EP16GS202_enable_pic_dc_dc(chain, 0);
}

//----- (00033FF4) --------------------------------------------------------
void __cdecl pic_heart_beat_each_chain(unsigned __int8 chain)
{
  dsPIC33EP16GS202_pic_heart_beat(chain);
}

//----- (00034010) --------------------------------------------------------
unsigned int get_nonce2_and_job_id_store_address()
{
  return axi_fpga_addr[68];
}

//----- (0003403C) --------------------------------------------------------
void __cdecl set_nonce2_and_job_id_store_address(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  get_nonce2_and_job_id_store_address();
  axi_fpga_addr[68] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set NONCE2_AND_JOBID_STORE_ADDRESS is 0x%x\n",
      (const char *)_FUNCTION___12373,
      value);
    applog(7, tmp42, 0);
  }
  get_nonce2_and_job_id_store_address();
}

//----- (000340DC) --------------------------------------------------------
int get_job_start_address()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[70];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: JOB_START_ADDRESS is 0x%x\n", (const char *)_FUNCTION___12379, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00034178) --------------------------------------------------------
void __cdecl set_job_start_address(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[70] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set JOB_START_ADDRESS is 0x%x\n", (const char *)_FUNCTION___12384, value);
    applog(7, tmp42, 0);
  }
  get_job_start_address();
}

//----- (00034214) --------------------------------------------------------
void __cdecl set_bmc_counter(unsigned int value)
{
  axi_fpga_addr[14] = value;
}

//----- (00034238) --------------------------------------------------------
unsigned int read_bmc_counter()
{
  return axi_fpga_addr[14];
}

//----- (0003425C) --------------------------------------------------------
int get_QN_write_data_command()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[32];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: QN_WRITE_DATA_COMMAND is 0x%x\n", (const char *)_FUNCTION___12396, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (000342F8) --------------------------------------------------------
void __cdecl set_QN_write_data_command(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[32] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set QN_WRITE_DATA_COMMAND is 0x%x\n", (const char *)_FUNCTION___12401, value);
    applog(7, tmp42, 0);
  }
  get_QN_write_data_command();
}

//----- (00034390) --------------------------------------------------------
void __cdecl set_reset_hashboard(int chainIndex, int resetBit)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned int resetFlag; // [sp+C08h] [bp+C08h]
  unsigned int ret; // [sp+C0Ch] [bp+C0Ch]

  ret = axi_fpga_addr[13];
  resetFlag = 1 << chainIndex;
  if ( resetBit <= 0 )
    ret &= ~resetFlag;
  else
    ret |= resetFlag;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "set_reset_hashboard = 0x%08x\n", ret);
    applog(5, tmp42, 0);
  }
  axi_fpga_addr[13] = ret;
}

//----- (00034454) --------------------------------------------------------
void reset_down_hash_board()
{
  printf("--- %s\n", (const char *)_FUNCTION___12413);
  axi_fpga_addr[13] = 0xFFFF;
}

//----- (00034480) --------------------------------------------------------
void reset_up_hash_board()
{
  printf("--- %s\n", (const char *)_FUNCTION___12417);
  axi_fpga_addr[13] = 0;
}

//----- (000344AC) --------------------------------------------------------
void reset_hash_board()
{
  printf("--- %s\n", (const char *)_FUNCTION___12421);
  axi_fpga_addr[13] = 0xFFFF;
  usleep((__useconds_t)"List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d");
  axi_fpga_addr[13] = 0;
}

//----- (000344F4) --------------------------------------------------------
void __cdecl set_reset_allhashboard(int resetBit)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int ret; // [sp+C0Ch] [bp+C0Ch]

  ret = axi_fpga_addr[13];
  if ( resetBit <= 0 )
    ret = HIWORD(ret) << 16;
  else
    ret = ~(~HIWORD(ret) << 16);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "set_reset_allhashboard = 0x%08x\n", ret);
    applog(5, tmp42, 0);
  }
  axi_fpga_addr[13] = ret;
}

//----- (000345A4) --------------------------------------------------------
int bitmain_axi_init()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  unsigned int data; // [sp+808h] [bp+800h]
  int ret; // [sp+80Ch] [bp+804h]

  ret = 0;
  fd = open("/dev/axi_fpga_dev", 2);
  if ( fd < 0 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "/dev/axi_fpga_dev open failed. fd = %d\n", fd);
      applog(7, tmp42, 0);
    }
LABEL_7:
    perror("open");
    return -1;
  }
  axi_fpga_addr = (unsigned int *)mmap(0, 0x160u, 3, 1, fd, 0);
  if ( axi_fpga_addr )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "mmap axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      applog(7, tmp42, 0);
    }
    data = *axi_fpga_addr;
    if ( (unsigned __int16)data != 50433 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n", data, 50433);
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "axi_fpga_addr data = 0x%x\n", data);
      applog(7, tmp42, 0);
    }
    fd_fpga_mem = open("/dev/fpga_mem", 2);
    if ( fd_fpga_mem < 0 )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "/dev/fpga_mem open failed. fd_fpga_mem = %d\n", fd_fpga_mem);
        applog(7, tmp42, 0);
      }
      goto LABEL_7;
    }
    fpga_mem_addr = (unsigned int *)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
    if ( fpga_mem_addr )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "mmap fpga_mem_addr = 0x%x\n", fpga_mem_addr);
        applog(7, tmp42, 0);
      }
      nonce2_jobid_address = fpga_mem_addr;
      job_start_address_1 = fpga_mem_addr + 0x80000;
      job_start_address_2 = fpga_mem_addr + 540672;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "job_start_address_1 = 0x%x\n", job_start_address_1);
        applog(7, tmp42, 0);
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "job_start_address_2 = 0x%x\n", job_start_address_2);
        applog(7, tmp42, 0);
      }
      set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
      dev = (all_parameters *)calloc(0x5478u, 1u);
      if ( dev )
      {
        dev->current_job_start_address = job_start_address_1;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "kmalloc for dev success.\n");
          applog(7, tmp42, 0);
        }
        return ret;
      }
      else
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "kmalloc for dev failed.\n");
          applog(7, tmp42, 0);
        }
        return -1;
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n", fpga_mem_addr);
        applog(7, tmp42, 0);
      }
      return -1;
    }
  }
  else
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      applog(7, tmp42, 0);
    }
    return -1;
  }
}

//----- (00034C08) --------------------------------------------------------
int bitmain_axi_Reinit()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  unsigned int data; // [sp+C08h] [bp+C00h]
  int ret; // [sp+C0Ch] [bp+C04h]

  ret = 0;
  data = *axi_fpga_addr;
  if ( (unsigned __int16)data != 50433 && (use_syslog || opt_log_output || opt_log_level > 4) )
  {
    snprintf((char *)tmp42, 0x800u, "data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n", data, 50433);
    applog(5, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "axi_fpga_addr data = 0x%x\n", data);
    applog(5, tmp42, 0);
  }
  nonce2_jobid_address = fpga_mem_addr;
  job_start_address_1 = fpga_mem_addr + 0x80000;
  job_start_address_2 = fpga_mem_addr + 540672;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  return ret;
}

//----- (00034D50) --------------------------------------------------------
int bitmain_axi_close()
{
  int v0; // r3
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+804h] [bp+804h]

  ret = munmap(axi_fpga_addr, 0x160u);
  if ( ret < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(7, tmp42, 0);
  }
  ret = munmap(fpga_mem_addr, 0x1000000u);
  if ( ret < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(7, tmp42, 0);
  }
  close(fd);
  close(fd_fpga_mem);
  return v0;
}
// 34E6A: variable 'v0' is possibly undefined

//----- (00034E78) --------------------------------------------------------
int get_fan_control()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[33];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: FAN_CONTROL is 0x%x\n", (const char *)_FUNCTION___12461, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00034F14) --------------------------------------------------------
void __cdecl set_fan_control(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[33] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set FAN_CONTROL is 0x%x\n", (const char *)_FUNCTION___12466, value);
    applog(7, tmp42, 0);
  }
  get_fan_control();
}

//----- (00034FAC) --------------------------------------------------------
int get_hash_on_plug()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[2];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: HASH_ON_PLUG is 0x%x\n", (const char *)_FUNCTION___12472, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035048) --------------------------------------------------------
unsigned int get_crc_count()
{
  return (unsigned __int16)axi_fpga_addr[62];
}

//----- (00035070) --------------------------------------------------------
int get_hardware_version()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = *axi_fpga_addr;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: HARDWARE_VERSION is 0x%x\n", (const char *)_FUNCTION___12481, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035108) --------------------------------------------------------
void __cdecl set_Hardware_version(unsigned int value)
{
  *axi_fpga_addr = value;
}

//----- (00035128) --------------------------------------------------------
int __cdecl get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int ret; // [sp+814h] [bp+80Ch]

  ret = -1;
  ret = axi_fpga_addr[1];
  *fan_speed = (unsigned __int8)ret;
  *fan_id = BYTE1(ret) & 7;
  if ( *fan_speed && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: fan_id is 0x%x, fan_speed is 0x%x\n",
      (const char *)_FUNCTION___12491,
      *fan_id,
      *fan_speed);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035200) --------------------------------------------------------
unsigned int get_temperature_0_3()
{
  return axi_fpga_addr[8];
}

//----- (00035228) --------------------------------------------------------
unsigned int get_temperature_4_7()
{
  return axi_fpga_addr[9];
}

//----- (00035250) --------------------------------------------------------
unsigned int get_temperature_8_11()
{
  return axi_fpga_addr[10];
}

//----- (00035278) --------------------------------------------------------
unsigned int get_temperature_12_15()
{
  return axi_fpga_addr[11];
}

//----- (000352A0) --------------------------------------------------------
int get_time_out_control()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[34];
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s: TIME_OUT_CONTROL is 0x%x\n", (const char *)_FUNCTION___12513, ret);
    applog(5, tmp42, 0);
  }
  return ret;
}

//----- (0003532C) --------------------------------------------------------
void __cdecl set_time_out_control(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[34] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set TIME_OUT_CONTROL is 0x%x\n", (const char *)_FUNCTION___12518, value);
    applog(7, tmp42, 0);
  }
  get_time_out_control();
}

//----- (000353C4) --------------------------------------------------------
int get_bt8d_control()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[15];
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s: get_bt8d_control is 0x%x\n", (const char *)_FUNCTION___12524, ret);
    applog(5, tmp42, 0);
  }
  return ret;
}

//----- (00035450) --------------------------------------------------------
void __cdecl set_bt8d_control(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[15] = value;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set_bt8d_control is 0x%x\n", (const char *)_FUNCTION___12529, value);
    applog(5, tmp42, 0);
  }
  get_bt8d_control();
}

//----- (000354DC) --------------------------------------------------------
int __cdecl get_BC_command_buffer(unsigned int *buf)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int ret; // [sp+81Ch] [bp+80Ch]

  ret = -1;
  ret = axi_fpga_addr[49];
  *buf = ret;
  ret = axi_fpga_addr[50];
  buf[1] = ret;
  ret = axi_fpga_addr[51];
  buf[2] = ret;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: BC_COMMAND_BUFFER buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x\n",
      (const char *)_FUNCTION___12535,
      *buf,
      buf[1],
      buf[2]);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (000355D8) --------------------------------------------------------
void __cdecl set_BC_command_buffer(unsigned int *value)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  unsigned int buf[4]; // [sp+818h] [bp+808h] BYREF

  memset(buf, 0, sizeof(buf));
  axi_fpga_addr[49] = *value;
  axi_fpga_addr[50] = value[1];
  axi_fpga_addr[51] = value[2];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set BC_COMMAND_BUFFER value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x\n",
      (const char *)_FUNCTION___12541,
      *value,
      value[1],
      value[2]);
    applog(7, tmp42, 0);
  }
  get_BC_command_buffer(buf);
}

//----- (000356D4) --------------------------------------------------------
void __cdecl set_BC_command_buffer_t(unsigned int *value)
{
  unsigned int buf[4]; // [sp+8h] [bp+8h] BYREF

  while ( get_BC_write_command() < 0 )
    usleep(0x3E8u);
  memset(buf, 0, sizeof(buf));
  axi_fpga_addr[49] = *value;
  axi_fpga_addr[50] = value[1];
  axi_fpga_addr[51] = value[2];
  get_BC_command_buffer(buf);
}

//----- (00035754) --------------------------------------------------------
unsigned int get_nonce_number_in_fifo()
{
  return axi_fpga_addr[6];
}

//----- (00035780) --------------------------------------------------------
int __cdecl get_return_nonce(unsigned int *buf)
{
  unsigned int ret; // [sp+Ch] [bp+Ch]

  *buf = axi_fpga_addr[4];
  ret = axi_fpga_addr[5];
  buf[1] = ret;
  return ret;
}

//----- (000357CC) --------------------------------------------------------
int get_BC_write_command()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[48];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: BC_WRITE_COMMAND is 0x%x\n", (const char *)_FUNCTION___12564, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035868) --------------------------------------------------------
void __cdecl set_BC_write_command(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int wait_count; // [sp+C0Ch] [bp+C0Ch]

  wait_count = 0;
  axi_fpga_addr[48] = value;
  if ( (value & 0x80000000) == 0 )
  {
    get_BC_write_command();
  }
  else
  {
    while ( get_BC_write_command() < 0 )
    {
      cgsleep_ms(1);
      if ( ++wait_count > 3000 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy((char *)tmp42, "Error: set_BC_write_command wait buffer ready timeout!\n");
          applog(5, tmp42, 0);
        }
        return;
      }
    }
  }
}

//----- (00035930) --------------------------------------------------------
int get_ticket_mask()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[35];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: TICKET_MASK_FPGA is 0x%x\n", (const char *)_FUNCTION___12579, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (000359CC) --------------------------------------------------------
void __cdecl set_ticket_mask(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[35] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set TICKET_MASK_FPGA is 0x%x\n", (const char *)_FUNCTION___12584, value);
    applog(7, tmp42, 0);
  }
  get_ticket_mask();
}

//----- (00035A64) --------------------------------------------------------
int get_job_id()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[73];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: JOB_ID is 0x%x\n", (const char *)_FUNCTION___12590, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035B00) --------------------------------------------------------
void __cdecl set_job_id(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[73] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set JOB_ID is 0x%x\n", (const char *)_FUNCTION___12595, value);
    applog(7, tmp42, 0);
  }
  get_job_id();
}

//----- (00035B9C) --------------------------------------------------------
int get_job_length()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[71];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: JOB_LENGTH is 0x%x\n", (const char *)_FUNCTION___12601, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035C38) --------------------------------------------------------
void __cdecl set_job_length(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[71] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set JOB_LENGTH is 0x%x\n", (const char *)_FUNCTION___12606, value);
    applog(7, tmp42, 0);
  }
  get_job_id();
}

//----- (00035CD4) --------------------------------------------------------
int get_block_header_version()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[76];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: BLOCK_HEADER_VERSION is 0x%x\n", (const char *)_FUNCTION___12612, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035D70) --------------------------------------------------------
void __cdecl set_block_header_version(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[76] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set BLOCK_HEADER_VERSION is 0x%x\n", (const char *)_FUNCTION___12617, value);
    applog(7, tmp42, 0);
  }
  get_block_header_version();
}

//----- (00035E0C) --------------------------------------------------------
int get_time_stamp()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[77];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: TIME_STAMP is 0x%x\n", (const char *)_FUNCTION___12622, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035EA8) --------------------------------------------------------
void __cdecl set_time_stamp(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[77] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set TIME_STAMP is 0x%x\n", (const char *)_FUNCTION___12627, value);
    applog(7, tmp42, 0);
  }
  get_time_stamp();
}

//----- (00035F44) --------------------------------------------------------
int get_target_bits()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[78];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: TARGET_BITS is 0x%x\n", (const char *)_FUNCTION___12633, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00035FE0) --------------------------------------------------------
void __cdecl set_target_bits(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[78] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set TARGET_BITS is 0x%x\n", (const char *)_FUNCTION___12638, value);
    applog(7, tmp42, 0);
  }
  get_target_bits();
}

//----- (0003607C) --------------------------------------------------------
int __cdecl get_pre_header_hash(unsigned int *buf)
{
  unsigned __int8 tmp42[2048]; // [sp+2Ch] [bp+Ch] BYREF
  int ret; // [sp+82Ch] [bp+80Ch]

  ret = -1;
  *buf = axi_fpga_addr[80];
  buf[1] = axi_fpga_addr[81];
  buf[2] = axi_fpga_addr[82];
  buf[3] = axi_fpga_addr[83];
  buf[4] = axi_fpga_addr[84];
  buf[5] = axi_fpga_addr[85];
  buf[6] = axi_fpga_addr[86];
  buf[7] = axi_fpga_addr[87];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: PRE_HEADER_HASH buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x, buf[3]: 0x%x, buf[4]: 0x%x, buf[5]: 0x%x, buf[6]: 0x"
      "%x, buf[7]: 0x%x\n",
      (const char *)_FUNCTION___12644,
      *buf,
      buf[1],
      buf[2],
      buf[3],
      buf[4],
      buf[5],
      buf[6],
      buf[7]);
    applog(7, tmp42, 0);
  }
  return buf[7];
}

//----- (00036224) --------------------------------------------------------
void __cdecl set_pre_header_hash(unsigned int *value)
{
  unsigned __int8 tmp42[2048]; // [sp+28h] [bp+8h] BYREF
  unsigned int buf[8]; // [sp+828h] [bp+808h] BYREF

  memset(buf, 0, sizeof(buf));
  axi_fpga_addr[80] = *value;
  axi_fpga_addr[81] = value[1];
  axi_fpga_addr[82] = value[2];
  axi_fpga_addr[83] = value[3];
  axi_fpga_addr[84] = value[4];
  axi_fpga_addr[85] = value[5];
  axi_fpga_addr[86] = value[6];
  axi_fpga_addr[87] = value[7];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set PRE_HEADER_HASH value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x, value[3]: 0x%x, value[4]: 0x%x, value[5]: "
      "0x%x, value[6]: 0x%x, value[7]: 0x%x\n",
      (const char *)_FUNCTION___12650,
      *value,
      value[1],
      value[2],
      value[3],
      value[4],
      value[5],
      value[6],
      value[7]);
    applog(7, tmp42, 0);
  }
}

//----- (000363DC) --------------------------------------------------------
int get_coinbase_length_and_nonce2_length()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[65];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: COINBASE_AND_NONCE2_LENGTH is 0x%x\n", (const char *)_FUNCTION___12656, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00036478) --------------------------------------------------------
void __cdecl set_coinbase_length_and_nonce2_length(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[65] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
      (const char *)_FUNCTION___12661,
      value);
    applog(7, tmp42, 0);
  }
  get_coinbase_length_and_nonce2_length();
}

//----- (00036514) --------------------------------------------------------
int __cdecl get_work_nonce2(unsigned int *buf)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int ret; // [sp+814h] [bp+80Ch]

  ret = -1;
  *buf = axi_fpga_addr[66];
  buf[1] = axi_fpga_addr[67];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: WORK_NONCE_2 buf[0]: 0x%x, buf[1]: 0x%x\n",
      (const char *)_FUNCTION___12667,
      *buf,
      buf[1]);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (000365D8) --------------------------------------------------------
void __cdecl set_work_nonce2(unsigned int *value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned int buf[2]; // [sp+810h] [bp+808h] BYREF

  buf[0] = 0;
  buf[1] = 0;
  axi_fpga_addr[66] = *value;
  axi_fpga_addr[67] = value[1];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set WORK_NONCE_2 value[0]: 0x%x, value[1]: 0x%x\n",
      (const char *)_FUNCTION___12673,
      *value,
      value[1]);
    applog(7, tmp42, 0);
  }
  get_work_nonce2(buf);
}

//----- (000366A4) --------------------------------------------------------
int get_merkle_bin_number()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = (unsigned __int16)axi_fpga_addr[69];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: MERKLE_BIN_NUMBER is 0x%x\n", (const char *)_FUNCTION___12679, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (0003674C) --------------------------------------------------------
void __cdecl set_merkle_bin_number(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[69] = (unsigned __int16)value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set MERKLE_BIN_NUMBER is 0x%x\n",
      (const char *)_FUNCTION___12684,
      (unsigned __int16)value);
    applog(7, tmp42, 0);
  }
  get_merkle_bin_number();
}

//----- (000367EC) --------------------------------------------------------
int get_nonce_fifo_interrupt()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[7];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: NONCE_FIFO_INTERRUPT is 0x%x\n", (const char *)_FUNCTION___12690, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00036888) --------------------------------------------------------
void __cdecl set_nonce_fifo_interrupt(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[7] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set NONCE_FIFO_INTERRUPT is 0x%x\n", (const char *)_FUNCTION___12695, value);
    applog(7, tmp42, 0);
  }
  get_nonce_fifo_interrupt();
}

//----- (00036920) --------------------------------------------------------
int get_dhash_acc_control()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[64];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: DHASH_ACC_CONTROL is 0x%x\n", (const char *)_FUNCTION___12701, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (000369BC) --------------------------------------------------------
void __cdecl set_dhash_acc_control(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int a; // [sp+814h] [bp+80Ch]

  a = 10;
  axi_fpga_addr[64] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set DHASH_ACC_CONTROL is 0x%x\n", (const char *)_FUNCTION___12707, value);
    applog(7, tmp42, 0);
  }
  while ( a > 0 && (value | 0x80) != (get_dhash_acc_control() | 0x80) )
  {
    axi_fpga_addr[64] = value;
    --a;
    cgsleep_ms(2);
  }
  if ( !a && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s set DHASH_ACC_CONTROL failed!", (const char *)_FUNCTION___12707);
    applog(7, tmp42, 0);
  }
}

//----- (00036B0C) --------------------------------------------------------
void __cdecl set_TW_write_command(unsigned int *value)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0xC; ++i )
    axi_fpga_addr[i + 16] = value[i];
}

//----- (00036B50) --------------------------------------------------------
void __cdecl set_TW_write_command_vil(unsigned int *value)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&fpga_mutex);
  for ( i = 0; i <= 0xC; ++i )
  {
    if ( i )
      axi_fpga_addr[17] = value[i];
    else
      axi_fpga_addr[16] = *value;
  }
  pthread_mutex_unlock(&fpga_mutex);
}

//----- (00036BC8) --------------------------------------------------------
unsigned int get_buffer_space()
{
  return axi_fpga_addr[3];
}

//----- (00036BF4) --------------------------------------------------------
int get_hash_counting_number()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  ret = -1;
  ret = axi_fpga_addr[36];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: DHASH_ACC_CONTROL is 0x%x\n", (const char *)_FUNCTION___12735, ret);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (00036C90) --------------------------------------------------------
void __cdecl set_hash_counting_number(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  axi_fpga_addr[36] = value;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set DHASH_ACC_CONTROL is 0x%x\n", (const char *)_FUNCTION___12740, value);
    applog(7, tmp42, 0);
  }
  get_hash_counting_number();
}

//----- (00036D28) --------------------------------------------------------
void check_chain()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int ret; // [sp+808h] [bp+800h]
  int i; // [sp+80Ch] [bp+804h]

  dev->chain_num = 0;
  ret = get_hash_on_plug();
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s: get_hash_on_plug is 0x%x\n", (const char *)_FUNCTION___12746, ret);
    applog(5, tmp42, 0);
  }
  if ( ret >= 0 )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( ((ret >> i) & 1) != 0 )
      {
        dev->chain_exist[i] = 1;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "!!%s: chain[%d]is exist\n", (const char *)_FUNCTION___12746, i);
          applog(5, tmp42, 0);
        }
        ++dev->chain_num;
      }
      else
      {
        dev->chain_exist[i] = 0;
      }
    }
  }
  else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: get_hash_on_plug functions error\n", (const char *)tmp42);
    applog(7, tmp42, 0);
  }
}

//----- (00036EF0) --------------------------------------------------------
void check_fan()
{
  all_parameters *v0; // r2
  all_parameters *v1; // r2
  unsigned int fan_speed; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 fan_id; // [sp+7h] [bp+7h] BYREF
  int j; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  i = 0;
  j = 0;
  fan_id = 0;
  v0 = dev;
  *(_DWORD *)&dev->temp_num = (unsigned __int8)*(_DWORD *)&dev->temp_num;
  HIBYTE(v0->fan_speed_top1) = 0;
  v1 = dev;
  *(unsigned int *)((char *)&dev->fan_speed_top1 + 3) = (unsigned __int8)*(unsigned int *)((char *)&dev->fan_speed_top1
                                                                                         + 3);
  HIBYTE(v1->fan_speed_low1) = 0;
  for ( j = 0; j <= 1; ++j )
  {
    for ( i = 0; i <= 7; ++i )
    {
      if ( get_fan_speed(&fan_id, &fan_speed) != -1 )
      {
        dev->fan_speed_value[fan_id] = 120 * fan_speed;
        if ( !fan_speed || dev->fan_exist[fan_id] )
        {
          if ( !fan_speed && dev->fan_exist[fan_id] == 1 )
          {
            dev->fan_exist[fan_id] = 0;
            --dev->fan_num;
            dev->fan_exist_map = (1 << fan_id == 0) & (unsigned __int8)dev->fan_exist_map;
          }
        }
        else
        {
          dev->fan_exist[fan_id] = 1;
          ++dev->fan_num;
          dev->fan_exist_map |= 1 << fan_id;
        }
        if ( dev->fan_speed_top1 < dev->fan_speed_value[fan_id] )
          dev->fan_speed_top1 = dev->fan_speed_value[fan_id];
        if ( dev->fan_speed_low1 > dev->fan_speed_value[fan_id] && dev->fan_speed_value[fan_id] || !dev->fan_speed_low1 )
          dev->fan_speed_low1 = dev->fan_speed_value[fan_id];
      }
    }
  }
}

//----- (00037190) --------------------------------------------------------
void check_fan_beforeInit()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  unsigned int fan_speed; // [sp+908h] [bp+900h] BYREF
  unsigned __int8 fan_id; // [sp+90Fh] [bp+907h] BYREF
  int j; // [sp+910h] [bp+908h]
  int i; // [sp+914h] [bp+90Ch]

  i = 0;
  fan_id = 0;
  for ( j = 0; j <= 1; ++j )
  {
    for ( i = 0; i <= 7; ++i )
    {
      if ( get_fan_speed(&fan_id, &fan_speed) != -1 )
      {
        dev->fan_speed_value[fan_id] = 120 * fan_speed;
        if ( !fan_speed || dev->fan_exist[fan_id] )
        {
          if ( !fan_speed && dev->fan_exist[fan_id] == 1 )
          {
            dev->fan_exist[fan_id] = 0;
            --dev->fan_num;
            dev->fan_exist_map = (1 << fan_id == 0) & (unsigned __int8)dev->fan_exist_map;
          }
        }
        else
        {
          dev->fan_exist[fan_id] = 1;
          ++dev->fan_num;
          dev->fan_exist_map |= 1 << fan_id;
        }
        if ( dev->fan_exist[fan_id] == 1 && print_num_12771 <= 99 )
        {
          ++print_num_12771;
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "get fan[%d] speed=%d\n", fan_id, dev->fan_speed_value[fan_id]);
            applog(5, tmp42, 0);
          }
          if ( print_num_12771 > 99 && (use_syslog || opt_log_output || opt_log_level > 4) )
          {
            strcpy((char *)tmp42, "Fatal Error: some Fan lost or Fan speed low!\n");
            applog(5, tmp42, 0);
          }
        }
        if ( dev->fan_speed_top1 < dev->fan_speed_value[fan_id] )
          dev->fan_speed_top1 = dev->fan_speed_value[fan_id];
        if ( dev->fan_speed_low1 > dev->fan_speed_value[fan_id] && dev->fan_speed_value[fan_id] || !dev->fan_speed_low1 )
          dev->fan_speed_low1 = dev->fan_speed_value[fan_id];
      }
    }
  }
}

//----- (0003753C) --------------------------------------------------------
void __cdecl set_PWM(unsigned __int8 pwm_percent)
{
  int temp_pwm_percent; // [sp+Ch] [bp+Ch]

  temp_pwm_percent = pwm_percent;
  if ( pwm_percent <= 0x13u )
    temp_pwm_percent = 20;
  if ( temp_pwm_percent > 100 )
    LOWORD(temp_pwm_percent) = 100;
  dev->pwm_value = (unsigned __int16)((__int16)(-50 * temp_pwm_percent + 5000) / 100) | ((unsigned __int16)((__int16)(50 * temp_pwm_percent) / 100) << 16);
  dev->pwm_percent = temp_pwm_percent;
  set_fan_control(dev->pwm_value);
}

//----- (000375F0) --------------------------------------------------------
int isTempTooLow()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int i; // [sp+C0Ch] [bp+C04h]

  for ( i = 0; ; ++i )
  {
    if ( i > 15 )
      return 0;
    if ( dev->chain_exist[i] != 1 || chain_temp_toolow[i] || dev->chain_asic_temp[i][1][0] <= 0 )
      continue;
    if ( lowest_testOK_temp[i] > 0 )
      break;
    if ( dev->chain_asic_temp[i][1][0] <= 79 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Detect temp too low: Chain[%d] curtemp=%d\n", i, dev->chain_asic_temp[i][1][0]);
        applog(5, tmp42, 0);
      }
      return 1;
    }
LABEL_18:
    ;
  }
  if ( dev->chain_asic_temp[i][1][0] >= lowest_testOK_temp[i] )
    goto LABEL_18;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Detect temp too low: Chain[%d] lowest_testOK_temp=%d curtemp=%d\n",
      i,
      lowest_testOK_temp[i],
      dev->chain_asic_temp[i][1][0]);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (000377C4) --------------------------------------------------------
void CheckChainTempTooLowFlag()
{
  bool isSomeBoardNotTooLow; // [sp+3h] [bp+3h]
  int i; // [sp+4h] [bp+4h]
  int ia; // [sp+4h] [bp+4h]

  isSomeBoardNotTooLow = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && !chain_temp_toolow[i] )
      isSomeBoardNotTooLow = 1;
  }
  if ( !isSomeBoardNotTooLow )
  {
    for ( ia = 0; ia <= 15; ++ia )
    {
      if ( dev->chain_exist[ia] == 1 )
        chain_temp_toolow[ia] = 0;
    }
  }
}

//----- (0003785C) --------------------------------------------------------
void setChainTempTooLowFlag()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int i; // [sp+C0Ch] [bp+C04h]

  for ( i = 0; i <= 15; ++i )
  {
    chain_temp_toolow[i] = 0;
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_maxtemp[i][0] > 0 )
    {
      if ( lowest_testOK_temp[i] > 0 )
      {
        if ( dev->chain_asic_maxtemp[i][0] < lowest_testOK_temp[i] )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Detect Chain[%d] temp too low, will ignore: temp=%d < %d\n",
              i,
              dev->chain_asic_maxtemp[i][0],
              lowest_testOK_temp[i]);
            applog(5, tmp42, 0);
          }
          chain_temp_toolow[i] = 1;
        }
      }
      else if ( dev->chain_asic_maxtemp[i][0] <= 79 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Detect Chain[%d] temp too low, will ignore: temp=%d\n",
            i,
            dev->chain_asic_maxtemp[i][0]);
          applog(5, tmp42, 0);
        }
        chain_temp_toolow[i] = 1;
      }
    }
  }
  CheckChainTempTooLowFlag();
}

//----- (00037A40) --------------------------------------------------------
void set_PWM_according_to_temperature()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int temp_change; // [sp+C08h] [bp+C00h]
  int pwm_percent; // [sp+C0Ch] [bp+C04h]

  pwm_percent = dev->fan_pwm;
  temp_change = 0;
  if ( is218_Temp || chip_hasNoMiddle )
    temp_highest = dev->temp_top1[0];
  else
    temp_highest = dev->temp_top1[0];
  temp_change = temp_highest - last_temperature;
  if ( temp_highest <= 74 && temp_highest )
  {
    if ( temp_change > 1 || temp_change < -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "set normal FAN speed...\n");
        applog(5, tmp42, 0);
      }
      pwm_percent = 2 * (temp_highest - 25);
      if ( pwm_percent <= 19 )
        pwm_percent = 20;
      if ( pwm_percent > 100 )
        pwm_percent = 100;
      dev->fan_pwm = pwm_percent;
      last_temperature = temp_highest;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "%s: Set PWM percent : %d\n", (const char *)_FUNCTION___12823, pwm_percent);
        applog(5, tmp42, 0);
      }
      set_PWM(pwm_percent);
    }
  }
  else
  {
    set_PWM(0x64u);
    dev->fan_pwm = 100;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "set full FAN speed...\n");
      applog(5, tmp42, 0);
    }
  }
}

//----- (00037C94) --------------------------------------------------------
void set_PWM_to_target_temperature()
{
  int v0; // r3
  int v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int pwm_percent; // [sp+80Ch] [bp+804h]
  int max_chip_temp; // [sp+810h] [bp+808h]
  int temp_diff; // [sp+814h] [bp+80Ch]

  temp_diff = 0;
  max_chip_temp = dev->temp_top1[1];
  if ( target_temp < max_chip_temp )
    v0 = max_chip_temp - target_temp;
  else
    v0 = target_temp - max_chip_temp;
  temp_diff = v0;
  if ( v0 > 2 )
  {
    if ( max_chip_temp >= target_temp )
      v1 = dev->pwm_percent + 2;
    else
      v1 = dev->pwm_percent - 2;
    pwm_percent = v1;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "target temp: %d,  current temp: %d, current pwm: %d\n",
        target_temp,
        max_chip_temp,
        dev->pwm_percent);
      applog(5, tmp42, 0);
    }
    set_PWM(pwm_percent);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "pwm_percent: %d\n", pwm_percent);
      applog(5, tmp42, 0);
    }
    sleep(2u);
  }
}

//----- (00037E20) --------------------------------------------------------
bool is_temp_adjusted_to_target()
{
  int v0; // r3

  temp_highest = dev->temp_top1[1];
  if ( target_temp < temp_highest )
    v0 = temp_highest - target_temp;
  else
    v0 = target_temp - temp_highest;
  return v0 <= 2;
}

//----- (00037EA8) --------------------------------------------------------
void wait_for_target_temp()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "wait for target temp %d, current temp is %d", target_temp, dev->temp_top1[1]);
    applog(5, tmp42, 0);
  }
  while ( !is_temp_adjusted_to_target() )
    sleep(1u);
}

//----- (00037F3C) --------------------------------------------------------
void __cdecl get_plldata(int type, int freq, unsigned int *reg_data, uint16_t *reg_data2, unsigned int *vil_data)
{
  unsigned __int8 vildivider[32]; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 plldivider2[32]; // [sp+34h] [bp+34h] BYREF
  unsigned __int8 plldivider1[32]; // [sp+54h] [bp+54h] BYREF
  unsigned int i; // [sp+74h] [bp+74h]

  memset(plldivider1, 0, sizeof(plldivider1));
  memset(plldivider2, 0, sizeof(plldivider2));
  memset(vildivider, 0, sizeof(vildivider));
  if ( type == 1393 )
  {
    for ( i = 0; i <= 0xB2 && freq_pll_1393_0[i].freq != freq; ++i )
      ;
  }
  if ( i == 179 )
    i = 4;
  sprintf((char *)plldivider1, "%08x", freq_pll_1393_0[i].fildiv1);
  sprintf((char *)plldivider2, "%04x", freq_pll_1393_0[i].fildiv2);
  sprintf((char *)vildivider, "%04x", freq_pll_1393_0[i].vilpll);
  *reg_data = freq_pll_1393_0[i].fildiv1;
  *reg_data2 = freq_pll_1393_0[i].fildiv2;
  *vil_data = freq_pll_1393_0[i].vilpll;
}

//----- (000380E8) --------------------------------------------------------
void __cdecl set_frequency_with_addr_plldatai(
        int pllindex,
        unsigned __int8 mode,
        unsigned __int8 addr,
        unsigned __int8 chain)
{
  char v4; // r4
  char v5; // r4
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+914h] [bp+90Ch] BYREF
  unsigned __int8 buf[9]; // [sp+920h] [bp+918h] BYREF
  unsigned int value; // [sp+92Ch] [bp+924h]
  unsigned int ret; // [sp+930h] [bp+928h]
  int i; // [sp+934h] [bp+92Ch]
  int chipIndex; // [sp+938h] [bp+930h]
  unsigned int reg_data_vil; // [sp+93Ch] [bp+934h]
  uint16_t reg_data_pll2; // [sp+942h] [bp+93Ah]
  unsigned int reg_data_pll; // [sp+944h] [bp+93Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  reg_data_pll = 0;
  reg_data_pll2 = 0;
  reg_data_vil = 0;
  chipIndex = (unsigned __int8)(addr / dev->addrInterval);
  if ( chain_badcore_num[chain][chipIndex] > 14 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Detect a bad chip=%d on chain[%d], fixed to 400M\n", chipIndex, chain);
      applog(5, tmp42, 0);
    }
    pllindex = 12;
  }
  i = chain;
  reg_data_vil = freq_pll_1393_0[pllindex].vilpll;
  if ( opt_multi_version )
  {
    memset(buf, 0, sizeof(buf));
    memset(cmd_buf, 0, sizeof(cmd_buf));
    if ( mode )
      buf[0] = 81;
    else
      buf[0] = 65;
    buf[1] = 9;
    buf[2] = addr;
    buf[3] = 8;
    buf[4] = HIBYTE(reg_data_vil);
    buf[5] = BYTE2(reg_data_vil);
    buf[6] = BYTE1(reg_data_vil);
    buf[7] = reg_data_vil;
    buf[8] = CRC5(buf, 0x40u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
    cmd_buf[2] = buf[8] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_us(500LL);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
    cgsleep_us(10000LL);
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    memset(cmd_buf, 0, sizeof(cmd_buf));
    buf[0] = 7;
    buf[1] = BYTE2(reg_data_pll);
    buf[2] = BYTE1(reg_data_pll);
    buf[3] = reg_data_pll;
    v4 = reg_data_pll;
    buf[3] = CRC5(buf, 0x1Bu) | v4;
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    ret = get_BC_write_command();
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
    cgsleep_us(3000LL);
    memset(buf, 0, sizeof(buf));
    memset(cmd_buf, 0, sizeof(cmd_buf));
    buf[0] = -126;
    buf[1] = 0;
    buf[2] = HIBYTE(reg_data_pll2);
    buf[3] = reg_data_pll2;
    v5 = reg_data_pll2;
    buf[3] = CRC5(buf, 0x1Bu) | v5;
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    ret = get_BC_write_command();
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
    cgsleep_us(5000LL);
  }
}

//----- (0003850C) --------------------------------------------------------
int __cdecl get_pll_index(int freq)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0xB2 && freq_pll_1393_0[i].freq != freq; ++i )
    ;
  if ( i == 179 )
    return -1;
  return i;
}

//----- (0003855C) --------------------------------------------------------
int __cdecl get_index_from_high_pll(int freq)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  for ( i = 0;
        (unsigned int)i <= 0x20
     && freq_high_pll_1393_0[i].freq != freq
     && (freq_high_pll_1393_0[i].freq <= freq || freq_high_pll_1393_0[i - 1].freq >= freq);
        ++i )
  {
    ;
  }
  if ( i != 33 )
    return i;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "high freq index set error,return default pll index");
    applog(3, tmp42, 0);
  }
  return get_index_from_high_pll(200);
}

//----- (0003866C) --------------------------------------------------------
int __cdecl get_freqvalue_by_index(int index)
{
  return freq_pll_1393_0[index].freq;
}

//----- (00038690) --------------------------------------------------------
int GetTotalRate()
{
  int totalrate; // [sp+4h] [bp+4h]
  int j; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  totalrate = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      for ( j = 0; j <= 107; ++j )
      {
        if ( chain_badcore_num[i][j] <= 14 )
          totalrate += (208 - chain_badcore_num[i][j]) * freq_pll_1393_0[last_freq[i][2 * j + 3]].freq;
      }
    }
  }
  return totalrate / 1000;
}

//----- (00038758) --------------------------------------------------------
int __cdecl GetRealBoardRate(int chainIndex)
{
  int totalrate; // [sp+8h] [bp+8h]
  int j; // [sp+Ch] [bp+Ch]

  totalrate = 0;
  if ( dev->chain_exist[chainIndex] == 1 )
  {
    for ( j = 0; j <= 107; ++j )
    {
      if ( chain_badcore_num[chainIndex][j] <= 14 )
        totalrate += (208 - chain_badcore_num[chainIndex][j])
                   * freq_pll_1393_0[chip_last_freq[chainIndex][2 * j + 3]].freq;
    }
  }
  return totalrate / 1000;
}

//----- (00038810) --------------------------------------------------------
int __cdecl GetBoardRate(int chainIndex)
{
  int totalrate; // [sp+8h] [bp+8h]
  int j; // [sp+Ch] [bp+Ch]

  totalrate = 0;
  if ( dev->chain_exist[chainIndex] == 1 )
  {
    for ( j = 0; j <= 107; ++j )
    {
      if ( chain_badcore_num[chainIndex][j] <= 14 )
        totalrate += (208 - chain_badcore_num[chainIndex][j]) * freq_pll_1393_0[last_freq[chainIndex][2 * j + 3]].freq;
    }
  }
  return totalrate / 1000;
}

//----- (000388C8) --------------------------------------------------------
bool isChainEnough()
{
  int chainnum; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]

  chainnum = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      ++chainnum;
  }
  return chainnum > 2;
}

//----- (00038918) --------------------------------------------------------
int __cdecl ConvirtTotalRate(int totalRate)
{
  int lowPart; // [sp+Ch] [bp+Ch]

  if ( totalRate % 1000 <= 500 )
    lowPart = 0;
  else
    lowPart = 500;
  return 1000 * (totalRate / 1000) + lowPart;
}

//----- (00038980) --------------------------------------------------------
int DownOneChipFreqOneStep()
{
  int v2; // [sp+0h] [bp+0h]
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int max_rate_chainIndex; // [sp+C04h] [bp+C04h]
  int max_freq_chipIndex; // [sp+C08h] [bp+C08h]
  int max_freq; // [sp+C0Ch] [bp+C0Ch]
  int board_rate; // [sp+C10h] [bp+C10h]
  int j; // [sp+C14h] [bp+C14h]

  max_freq = 0;
  max_freq_chipIndex = 0;
  board_rate = 0;
  max_rate_chainIndex = -1;
  for ( j = 0; j <= 15; ++j )
  {
    if ( dev->chain_exist[j] == 1 )
    {
      if ( dev->chain_asic_num[j] != 108 )
        return 0;
      if ( !board_rate || GetBoardRate(j) > board_rate )
      {
        board_rate = GetBoardRate(j);
        max_rate_chainIndex = j;
      }
    }
  }
  if ( max_rate_chainIndex >= 0 )
  {
    max_freq = 0;
    max_freq_chipIndex = -1;
    for ( j = 0; dev->chain_asic_num[max_rate_chainIndex] > j; ++j )
    {
      if ( chain_badcore_num[max_rate_chainIndex][j] <= 14
        && (!max_freq || last_freq[max_rate_chainIndex][2 * j + 3] > max_freq) )
      {
        max_freq_chipIndex = j;
        max_freq = last_freq[max_rate_chainIndex][2 * j + 3];
      }
    }
    if ( max_freq_chipIndex >= 0 )
    {
      if ( max_freq > 4 )
      {
        --last_freq[max_rate_chainIndex][2 * max_freq_chipIndex + 3];
        return 1;
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Fatal Error: DownOneChipFreqOneStep Chain[%d] has no chip can down freq!!!\n",
            max_rate_chainIndex);
          applog(5, tmp42, 0);
        }
        return 0;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Fatal Error: DownOneChipFreqOneStep Chain[%d] has Wrong chip index=%d\n",
          max_freq_chipIndex,
          v2);
        applog(5, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Fatal Error: DownOneChipFreqOneStep has Wrong chain index=%d\n",
        max_rate_chainIndex);
      applog(5, tmp42, 0);
    }
    return 0;
  }
}
// 38B82: variable 'v2' is possibly undefined

//----- (00038C3C) --------------------------------------------------------
void ProcessFixFreq()
{
  int fixed_totalRate; // [sp+0h] [bp+0h]
  int totalRate; // [sp+4h] [bp+4h]
  int j; // [sp+8h] [bp+8h]
  int ja; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]
  int ia; // [sp+Ch] [bp+Ch]

  totalRate = GetTotalRate();
  fixed_totalRate = ConvirtTotalRate(totalRate);
  if ( GetTotalRate() > fixed_totalRate )
  {
    do
    {
      for ( i = 0; i <= 15; ++i )
      {
        if ( dev->chain_exist[i] == 1 )
        {
          for ( j = 0; j <= 107; ++j )
            last_record_freq[i][j] = last_freq[i][2 * j + 3];
        }
      }
    }
    while ( (unsigned __int8)DownOneChipFreqOneStep() == 1 && GetTotalRate() > fixed_totalRate );
    for ( ia = 0; ia <= 15; ++ia )
    {
      if ( dev->chain_exist[ia] == 1 )
      {
        for ( ja = 0; ja <= 107; ++ja )
          last_freq[ia][2 * ja + 3] = last_record_freq[ia][ja];
      }
    }
  }
}

//----- (00038D54) --------------------------------------------------------
void ProcessFixFreqForChips()
{
  int fixed_totalRate; // [sp+0h] [bp+0h]
  int totalRate; // [sp+4h] [bp+4h]
  int j; // [sp+8h] [bp+8h]
  int ja; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]
  int ia; // [sp+Ch] [bp+Ch]

  totalRate = GetTotalRate();
  fixed_totalRate = 101 * ConvirtTotalRate(totalRate) / 100;
  if ( GetTotalRate() > fixed_totalRate )
  {
    do
    {
      for ( i = 0; i <= 15; ++i )
      {
        if ( dev->chain_exist[i] == 1 )
        {
          for ( j = 0; j <= 107; ++j )
            last_record_freq[i][j] = last_freq[i][2 * j + 3];
        }
      }
    }
    while ( (unsigned __int8)DownOneChipFreqOneStep() == 1 && GetTotalRate() > fixed_totalRate );
    for ( ia = 0; ia <= 15; ++ia )
    {
      if ( dev->chain_exist[ia] == 1 )
      {
        for ( ja = 0; ja <= 107; ++ja )
          last_freq[ia][2 * ja + 3] = last_record_freq[ia][ja];
      }
    }
  }
}

//----- (00038E88) --------------------------------------------------------
void __cdecl set_divider(unsigned int div, unsigned int chain, unsigned int mode, unsigned __int8 addr)
{
  unsigned __int8 diva; // [sp+Ch] [bp+Ch]
  unsigned int cmd_buf[3]; // [sp+10h] [bp+10h] BYREF
  unsigned __int8 buf[9]; // [sp+1Ch] [bp+1Ch] BYREF
  unsigned int value; // [sp+28h] [bp+28h]

  diva = div;
  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  gBM1393_PLL0_DIVIDER_reg = gBM1393_PLL0_DIVIDER_reg & 0xFFFFFF00 | diva;
  if ( mode )
    buf[0] = 81;
  else
    buf[0] = 65;
  buf[1] = 9;
  buf[2] = addr;
  buf[3] = 112;
  buf[4] = HIBYTE(gBM1393_PLL0_DIVIDER_reg);
  buf[5] = BYTE2(gBM1393_PLL0_DIVIDER_reg);
  buf[6] = BYTE1(gBM1393_PLL0_DIVIDER_reg);
  buf[7] = gBM1393_PLL0_DIVIDER_reg;
  buf[8] = CRC5(buf, 0x40u) & 0x1F;
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  set_BC_command_buffer(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (00038FF8) --------------------------------------------------------
int __cdecl set_frequency_with_addr(
        unsigned int frequency,
        unsigned __int8 mode,
        unsigned __int8 addr,
        unsigned __int8 chain)
{
  char v4; // r4
  char v5; // r4
  int frequencya; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned int reg_data_vil; // [sp+810h] [bp+808h] BYREF
  uint16_t reg_data_pll2; // [sp+816h] [bp+80Eh] BYREF
  unsigned int reg_data_pll; // [sp+818h] [bp+810h] BYREF
  unsigned int cmd_buf[3]; // [sp+81Ch] [bp+814h] BYREF
  unsigned __int8 buf[9]; // [sp+828h] [bp+820h] BYREF
  unsigned int value; // [sp+834h] [bp+82Ch]
  unsigned int ret; // [sp+838h] [bp+830h]
  int i; // [sp+83Ch] [bp+834h]
  unsigned int pll_index; // [sp+840h] [bp+838h]
  unsigned int pll; // [sp+844h] [bp+83Ch]
  unsigned __int8 divider; // [sp+84Bh] [bp+843h]
  int high_index; // [sp+84Ch] [bp+844h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  reg_data_pll = 0;
  reg_data_pll2 = 0;
  reg_data_vil = 0;
  divider = 2;
  pll = 0;
  pll_index = 0;
  i = chain;
  high_index = get_index_from_high_pll(frequency);
  divider = freq_high_pll_1393_0[high_index].divider;
  pll = freq_high_pll_1393_0[high_index].pll_out;
  pll_index = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "set freq %d, pll_out %d\n", freq_high_pll_1393_0[high_index].freq, pll);
    applog(5, tmp42, 0);
  }
  pll_index = get_pll_index(pll);
  frequencya = freq_high_pll_1393_0[high_index].freq;
  get_plldata(1393, frequencya, &reg_data_pll, &reg_data_pll2, &reg_data_vil);
  if ( opt_multi_version )
  {
    memset(buf, 0, sizeof(buf));
    memset(cmd_buf, 0, sizeof(cmd_buf));
    if ( mode )
      buf[0] = 81;
    else
      buf[0] = 65;
    buf[1] = 9;
    buf[2] = addr;
    buf[3] = 8;
    buf[4] = HIBYTE(reg_data_vil);
    buf[5] = BYTE2(reg_data_vil);
    buf[6] = BYTE1(reg_data_vil);
    buf[7] = reg_data_vil;
    buf[8] = CRC5(buf, 0x40u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
    cmd_buf[2] = buf[8] << 24;
    set_BC_command_buffer(cmd_buf);
    ret = get_BC_write_command();
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
    dev->freq[i] = frequencya;
    cgsleep_us(10000LL);
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    memset(cmd_buf, 0, sizeof(cmd_buf));
    buf[0] = 7;
    buf[1] = BYTE2(reg_data_pll);
    buf[2] = BYTE1(reg_data_pll);
    buf[3] = reg_data_pll;
    v4 = reg_data_pll;
    buf[3] = CRC5(buf, 0x1Bu) | v4;
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    ret = get_BC_write_command();
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
    cgsleep_us(3000LL);
    memset(buf, 0, sizeof(buf));
    memset(cmd_buf, 0, sizeof(cmd_buf));
    buf[0] = -126;
    buf[1] = 0;
    buf[2] = HIBYTE(reg_data_pll2);
    buf[3] = reg_data_pll2;
    v5 = reg_data_pll2;
    buf[3] = CRC5(buf, 0x1Bu) | v5;
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    ret = get_BC_write_command();
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
    dev->freq[i] = frequencya;
    cgsleep_us(5000LL);
  }
  return divider;
}

//----- (000394A8) --------------------------------------------------------
void __cdecl set_frequency_B1393(unsigned int freq)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+C14h] [bp+C0Ch] BYREF
  unsigned __int8 buf[9]; // [sp+C20h] [bp+C18h] BYREF
  int divider; // [sp+C2Ch] [bp+C24h]
  unsigned int reg_data_vil; // [sp+C30h] [bp+C28h]
  uint16_t reg_data_pll2; // [sp+C36h] [bp+C2Eh]
  unsigned int reg_data_pll; // [sp+C38h] [bp+C30h]
  int step_down; // [sp+C3Ch] [bp+C34h]
  int max_freq_index; // [sp+C40h] [bp+C38h]
  int i; // [sp+C44h] [bp+C3Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  max_freq_index = 0;
  step_down = 0;
  reg_data_pll = 0;
  reg_data_pll2 = 0;
  reg_data_vil = 0;
  divider = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "\n--- %s\n", (const char *)_FUNCTION___13040);
    applog(5, tmp42, 0);
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "begin to set frequency, chain %d, freq %d\n",
          i,
          freq_pll_1393_0[freq_one_board[i]].freq);
        applog(5, tmp42, 0);
      }
      divider = set_frequency_with_addr(freq_pll_1393_0[freq_one_board[i]].freq, 1u, 0, i);
      usleep(0x1F4u);
      set_divider(divider - 1, i, 1u, 0);
      usleep(0x1F4u);
      set_frequency_with_addr(freq_pll_1393_0[freq_one_board[i]].freq, 1u, 0, i);
      usleep(0x1F4u);
    }
  }
}

//----- (000396DC) --------------------------------------------------------
void __cdecl update_frequency_B1393(unsigned int freq, unsigned int chain, unsigned int mode, unsigned __int8 addr)
{
  set_frequency_with_addr(freq, mode, addr, chain);
  usleep(0x1F4u);
  set_divider(1u, chain, mode, addr);
  usleep(0x1F4u);
  set_frequency_with_addr(freq, mode, addr, chain);
  usleep(0x1F4u);
}

//----- (00039738) --------------------------------------------------------
void __cdecl set_frequency_new_B1393(unsigned __int16 frequency)
{
  int TotalRate; // r4
  int v2; // r0
  int v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+C14h] [bp+C0Ch] BYREF
  unsigned __int8 buf[9]; // [sp+C20h] [bp+C18h] BYREF
  unsigned int value; // [sp+C2Ch] [bp+C24h]
  int default_freq_index; // [sp+C30h] [bp+C28h]
  unsigned int reg_data_vil; // [sp+C34h] [bp+C2Ch]
  uint16_t reg_data_pll2; // [sp+C3Ah] [bp+C32h]
  unsigned int reg_data_pll; // [sp+C3Ch] [bp+C34h]
  int step_down; // [sp+C40h] [bp+C38h]
  int chain_min_freq; // [sp+C44h] [bp+C3Ch]
  int chain_max_freq; // [sp+C48h] [bp+C40h]
  int max_freq_index; // [sp+C4Ch] [bp+C44h]
  int j; // [sp+C50h] [bp+C48h]
  int i; // [sp+C54h] [bp+C4Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  max_freq_index = 0;
  step_down = 0;
  reg_data_pll = 0;
  reg_data_pll2 = 0;
  reg_data_vil = 0;
  default_freq_index = get_pll_index(frequency);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "--- %s", (const char *)_FUNCTION___13073);
    applog(7, tmp42, 0);
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      if ( isFixedFreqMode() || last_freq[i][1] != 125 )
      {
        isUseDefaultFreq = 1;
        last_freq[i][0] = 0;
        last_freq[i][1] = 125;
        for ( j = 0; j <= 107; ++j )
        {
          last_freq[i][2 * j + 2] = 0;
          last_freq[i][2 * j + 3] = freq_one_board[i];
        }
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Chain[J%d] has no freq in PIC, set default freq=%dM",
            i + 1,
            freq_pll_1393_0[freq_one_board[i]].freq);
          applog(5, tmp42, 0);
        }
      }
      if ( badcore_num_buf[i][0] == 35 && !isUseDefaultFreq )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Chain[J%d] has core num in PIC\n", i + 1);
          applog(5, tmp42, 0);
        }
        for ( j = 0; j <= 107; ++j )
        {
          if ( (j & 1) != 0 )
            chain_badcore_num[i][j] = badcore_num_buf[i][2 * (j / 2) + 1] & 0xF;
          else
            chain_badcore_num[i][j] = (badcore_num_buf[i][2 * (j / 2) + 1] >> 4) & 0xF;
          if ( chain_badcore_num[i][j] > 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
          {
            snprintf((char *)tmp42, 0x800u, "Chain[J%d] ASIC[%d] has core num=%d", i + 1, j, chain_badcore_num[i][j]);
            applog(5, tmp42, 0);
          }
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Chain[J%d] has no core num in PIC", i + 1);
          applog(5, tmp42, 0);
        }
        for ( j = 0; j <= 107; ++j )
          chain_badcore_num[i][j] = 0;
      }
    }
  }
  if ( !isUseDefaultFreq && (use_syslog || opt_log_output || opt_log_level > 4) )
  {
    TotalRate = GetTotalRate();
    v2 = GetTotalRate();
    v3 = ConvirtTotalRate(v2);
    snprintf((char *)tmp42, 0x800u, "miner total rate=%dGH/s fixed rate=%dGH/s", TotalRate, v3);
    applog(5, tmp42, 0);
  }
  max_freq_index = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "Miner fix freq ...");
    applog(5, tmp42, 0);
  }
  if ( !isUseDefaultFreq && isChainEnough() )
    ProcessFixFreqForChips();
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      memcpy(chip_last_freq[i], last_freq[i], sizeof(unsigned __int8[256]));
  }
  for ( i = 0; i <= 15; ++i )
  {
    chain_max_freq = 0;
    chain_min_freq = 100;
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Chain:%d chipnum=%d", i, dev->chain_asic_num[i]);
        applog(5, tmp42, 0);
      }
      for ( j = 0; dev->chain_asic_num[i] > j; ++j )
      {
        if ( last_freq[i][2 * j + 3] <= 3u )
          last_freq[i][2 * j + 3] = 4;
        if ( last_freq[i][2 * j + 3] > 0x64u )
          last_freq[i][2 * j + 3] = 100;
        if ( last_freq[i][2 * j + 3] > max_freq_index )
          max_freq_index = last_freq[i][2 * j + 3];
        if ( last_freq[i][2 * j + 3] > chain_max_freq )
          chain_max_freq = last_freq[i][2 * j + 3];
        if ( last_freq[i][2 * j + 3] < chain_min_freq )
          chain_min_freq = last_freq[i][2 * j + 3];
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Chain:%d max freq=%d", i, freq_pll_1393_0[chain_max_freq].freq);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Chain:%d min freq=%d", i, freq_pll_1393_0[chain_min_freq].freq);
        applog(5, tmp42, 0);
      }
    }
  }
  value = freq_pll_1393_0[max_freq_index].freq;
  dev->frequency = value;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "max freq = %d", dev->frequency);
    applog(5, tmp42, 0);
  }
  if ( !isUseDefaultFreq )
    ProcessFixFreq();
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      memcpy(show_last_freq[i], last_freq[i], sizeof(unsigned __int8[256]));
  }
}

//----- (0003A178) --------------------------------------------------------
void clear_nonce_fifo()
{
  pthread_mutex_lock(&nonce_mutex);
  nonce_read_out.p_wr = 0;
  nonce_read_out.p_rd = 0;
  nonce_read_out.nonce_num = 0;
  pthread_mutex_unlock(&nonce_mutex);
}

//----- (0003A1CC) --------------------------------------------------------
void clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  reg_value_buf.p_wr = 0;
  reg_value_buf.p_rd = 0;
  reg_value_buf.reg_value_num = 0;
  pthread_mutex_unlock(&reg_mutex);
}

//----- (0003A210) --------------------------------------------------------
void __cdecl read_asic_register(
        unsigned __int8 chain,
        unsigned __int8 mode,
        unsigned __int8 chip_addr,
        unsigned __int8 reg_addr)
{
  int hash_on_plug; // r0
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+C24h] [bp+C0Ch] BYREF
  unsigned __int8 buf_vil[12]; // [sp+C30h] [bp+C18h] BYREF
  unsigned __int8 buf[5]; // [sp+C3Ch] [bp+C24h] BYREF
  unsigned int value; // [sp+C44h] [bp+C2Ch]
  unsigned int ret; // [sp+C48h] [bp+C30h]
  int wait_count; // [sp+C4Ch] [bp+C34h]

  buf[0] = 0;
  buf[1] = 0;
  buf[2] = 0;
  buf[3] = 0;
  buf[4] = 0;
  memset(buf_vil, 0, sizeof(buf_vil));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  wait_count = 0;
  if ( opt_multi_version )
  {
    buf[0] = 66;
    if ( mode )
      buf[0] |= 0x10u;
    buf[1] = 5;
    buf[2] = chip_addr;
    buf[3] = reg_addr;
    buf[4] = CRC5(buf, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s:VIL buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x",
        (const char *)_FUNCTION___13127,
        buf[0],
        buf[1],
        buf[2],
        buf[3],
        buf[4]);
      applog(7, tmp42, 0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = buf[4] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
      if ( ++wait_count > 3000 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          hash_on_plug = get_hash_on_plug();
          snprintf(
            (char *)tmp42,
            0x800u,
            "Error: clement debug: wait BC ready timeout, PLUG ON=0x%08x..\n",
            hash_on_plug);
          applog(5, tmp42, 0);
        }
        break;
      }
    }
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
  else
  {
    buf[0] = 2;
    buf[1] = chip_addr;
    buf[2] = reg_addr;
    if ( mode )
      buf[0] |= 0x80u;
    buf[3] = CRC5(buf, 0x1Bu);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13127,
        buf[0],
        buf[1],
        buf[2],
        buf[3]);
      applog(7, tmp42, 0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (0003A5AC) --------------------------------------------------------
void __cdecl read_temp(
        unsigned __int8 device,
        unsigned int reg,
        unsigned __int8 data,
        unsigned __int8 write,
        unsigned __int8 chip_addr,
        int chain)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+18h] [bp+18h] BYREF
  unsigned int value; // [sp+24h] [bp+24h]
  unsigned int ret; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  i = chain;
  if ( opt_multi_version )
  {
    qmemcpy(buf, "A\t", 2);
    buf[2] = chip_addr;
    buf[3] = 28;
    buf[4] = 1;
    buf[5] = write | device;
    buf[6] = reg;
    buf[7] = data;
    buf[8] = CRC5(buf, 0x40u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
    cmd_buf[2] = buf[8] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (0003A6B8) --------------------------------------------------------
void __cdecl suffix_string_soc(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display)
{
  double v5; // r0
  double v6; // r0
  double v7; // d7
  unsigned __int8 suffix[2]; // [sp+28h] [bp+10h] BYREF
  int ndigits; // [sp+2Ch] [bp+14h]
  uint64_t exa; // [sp+30h] [bp+18h]
  uint64_t peta; // [sp+38h] [bp+20h]
  uint64_t tera; // [sp+40h] [bp+28h]
  uint64_t giga; // [sp+48h] [bp+30h]
  uint64_t mega; // [sp+50h] [bp+38h]
  uint64_t kilo; // [sp+58h] [bp+40h]
  double dkilo; // [sp+60h] [bp+48h]
  double dval; // [sp+68h] [bp+50h]
  bool decimal; // [sp+77h] [bp+5Fh]

  dkilo = 1000.0;
  kilo = 1000LL;
  mega = (unsigned int)&nonce_num[6][85][45];
  giga = 1000000000LL;
  tera = 1000000000000LL;
  peta = 1000000000000000LL;
  exa = 1000000000000000000LL;
  *(_WORD *)suffix = 0;
  decimal = 1;
  if ( val < 0x3B9ACA00 )
  {
    if ( val < mega )
    {
      v5 = (double)val;
      if ( val >= kilo )
      {
        dval = (double)val / dkilo;
        strcpy((char *)suffix, "K");
      }
      else
      {
        dval = (double)val;
        decimal = 0;
      }
    }
    else
    {
      v5 = (double)(val / kilo);
      dval = v5 / dkilo;
      strcpy((char *)suffix, "M");
    }
  }
  else
  {
    v5 = (double)(val / mega);
    dval = v5 / dkilo;
    strcpy((char *)suffix, "G");
  }
  if ( sigdigits )
  {
    if ( dval <= 0.0 )
    {
      v7 = 0.0;
    }
    else
    {
      v6 = log10(v5);
      floor(v6);
      v7 = dval;
    }
    ndigits = (int)((double)(sigdigits - 1) - v7);
    if ( display )
      snprintf((char *)buf, bufsiz, "%*.*f%s", sigdigits + 1, ndigits, dval, (const char *)suffix);
    else
      snprintf((char *)buf, bufsiz, "%*.*f", sigdigits + 1, ndigits, dval);
  }
  else if ( decimal )
  {
    snprintf((char *)buf, bufsiz, "%.3g%s", dval, (const char *)suffix);
  }
  else
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)dval, (const char *)suffix);
  }
}

//----- (0003A910) --------------------------------------------------------
void showAllBadRTInfo()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int j; // [sp+C08h] [bp+C00h]
  int i; // [sp+C0Ch] [bp+C04h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Check Chain[J%d] ASIC RT error: (asic index start from 1-%d)\n", i + 1, 108);
        applog(5, tmp42, 0);
      }
      for ( j = 0; j <= 107; ++j )
      {
        if ( chain_asic_RT[i][j] > 100.0 && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          snprintf((char *)tmp42, 0x800u, "Asic[%02d]=%f\n", j + 1, chain_asic_RT[i][j]);
          applog(5, tmp42, 0);
        }
      }
    }
  }
}

//----- (0003AA78) --------------------------------------------------------
bool __cdecl check_asic_reg(unsigned int reg)
{
  double v1; // d0
  int v3; // r6
  unsigned __int8 displayed_rate_asic[32]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+34h] [bp+2Ch] BYREF
  unsigned __int8 rate_buf[10]; // [sp+844h] [bp+83Ch] BYREF
  unsigned __int8 reg_buf[7]; // [sp+C50h] [bp+C48h] BYREF
  unsigned int buf[2]; // [sp+C58h] [bp+C50h]
  uint64_t temp_hash_rate; // [sp+C60h] [bp+C58h]
  unsigned __int8 crc_value; // [sp+C6Fh] [bp+C67h]
  int reg_value; // [sp+C70h] [bp+C68h]
  unsigned int temp_nonce; // [sp+C74h] [bp+C6Ch]
  unsigned int reg_value_num; // [sp+C78h] [bp+C70h]
  int nonce_number; // [sp+C7Ch] [bp+C74h]
  int ii; // [sp+C80h] [bp+C78h]
  int reg_processed_counter; // [sp+C84h] [bp+C7Ch]
  uint64_t tmp_rate; // [sp+C88h] [bp+C80h]
  unsigned __int8 reg_address; // [sp+C97h] [bp+C8Fh]
  int read_num; // [sp+C98h] [bp+C90h]
  int not_reg_data_time; // [sp+C9Ch] [bp+C94h]
  int j; // [sp+CA0h] [bp+C98h]
  int i; // [sp+CA4h] [bp+C9Ch]

  not_reg_data_time = 0;
  nonce_number = 0;
  buf[0] = 0;
  buf[1] = 0;
  reg_value_num = 0;
  temp_nonce = 0;
  memset(reg_buf, 0, sizeof(reg_buf));
  read_num = 0;
  reg_value = 0;
  reg_address = 0;
  tmp_rate = 0LL;
  reg_processed_counter = 0;
  crc_value = 0;
rerun_all:
  clear_register_value_buf();
  tmp_rate = 0LL;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && (use_syslog || opt_log_output || opt_log_level > 4) )
    {
      snprintf((char *)tmp42, 0x800u, "+Check asic reg, chain[%d] exist\n", i);
      applog(5, tmp42, 0);
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( i > 15 )
      return 1;
    reg_processed_counter = 0;
    read_num = 0;
    if ( dev->chain_exist[i] == 1 )
      break;
LABEL_118:
    ;
  }
  tmp_rate = 0LL;
  read_asic_register(i, 1u, 0, reg);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "!!Check asic reg, read asic chain[%d], reg=0x%x\n", i, reg);
    applog(5, tmp42, 0);
  }
  if ( !reg )
    dev->chain_asic_num[i] = 0;
  if ( reg == 8 && (use_syslog || opt_log_output || opt_log_level > 4) )
  {
    snprintf((char *)tmp42, 0x800u, "\nget RT hashrate from Chain[%d]: (asic index start from 1-%d)\n", i, 108);
    applog(5, tmp42, 0);
  }
  while ( 1 )
  {
    if ( not_reg_data_time > 2 )
      goto LABEL_107;
    cgsleep_ms(300);
    pthread_mutex_lock(&reg_mutex);
    reg_value_num = reg_value_buf.reg_value_num;
    if ( (reg_value_buf.reg_value_num > 0x1FE || reg_value_buf.p_rd > 0x1FE) && not_reg_data_time <= 2 )
    {
      ++not_reg_data_time;
      pthread_mutex_unlock(&reg_mutex);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "!!not_reg_data_time ++\n");
        applog(5, tmp42, 0);
      }
      goto rerun_all;
    }
    if ( not_reg_data_time == 3 )
    {
      pthread_mutex_unlock(&reg_mutex);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "!!not_reg_data_time is 3, return\n");
        applog(5, tmp42, 0);
      }
      return 1;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "!!reg_value_num = %d\n", reg_value_num);
      applog(5, tmp42, 0);
    }
    if ( !reg_value_num )
    {
      cgsleep_ms(100);
      ++not_reg_data_time;
      goto LABEL_105;
    }
    reg_processed_counter += reg_value_num;
    if ( reg_processed_counter > 600 )
      break;
    not_reg_data_time = 0;
    for ( j = 0; j < reg_value_num; ++j )
    {
      if ( reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number == i )
      {
        reg_buf[3] = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
        reg_buf[2] = BYTE1(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
        reg_buf[1] = BYTE2(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
        reg_buf[0] = HIBYTE(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
        reg_address = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_address;
        reg_value = *(&reg_value_buf.p_rd + 2 * ++reg_value_buf.p_rd);
        --reg_value_buf.reg_value_num;
        if ( reg_value_buf.p_rd > 0x1FE )
          reg_value_buf.p_rd = 0;
        if ( !reg_address )
        {
          if ( reg_value >> 16 == 5011 )
            ++dev->chain_asic_num[i];
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "chain[%02d] num[%d]: the asic CHIP_ADDRESS is 0x%08x\n", i, j, reg_value);
            applog(7, tmp42, 0);
          }
        }
        if ( reg_address == 8 && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "chain[%d]: the asic freq is 0x%x\n",
            i,
            reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
          applog(5, tmp42, 0);
        }
        if ( reg_address == 20 )
        {
          ++read_num;
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "chain[%02d] chip[%02d]: the asic TICKET_MASK is 0x%08x\n",
              i,
              read_num,
              reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            applog(5, tmp42, 0);
          }
        }
        if ( reg_address == 16 )
        {
          ++read_num;
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "chain[%02d] chip[%02d]: the asic HASH_COUNTING_NUMBER is 0x%08x\n",
              i,
              read_num,
              reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            applog(5, tmp42, 0);
          }
        }
        if ( reg_address == 16 )
        {
          ++read_num;
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "chain[%02d] chip[%02d]: the asic START_NONCE_OFFSET is 0x%08x\n",
              i,
              read_num,
              reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            applog(5, tmp42, 0);
          }
        }
        if ( reg_address == 4 )
        {
          temp_hash_rate = 0LL;
          if ( ++read_num <= 108 )
          {
            for ( ii = 0; ii <= 3; ++ii )
              sprintf((char *)&rate_buf[2 * ii], "%02x", reg_buf[ii]);
            temp_hash_rate = (__int64)strtol((const char *)rate_buf, 0, 16) << 24;
            tmp_rate += temp_hash_rate;
            suffix_string_soc(temp_hash_rate, displayed_rate_asic, 0x20u, 6, 0);
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf((char *)tmp42, 0x800u, "Asic[%02d]=%s ", read_num, (const char *)displayed_rate_asic);
              applog(5, tmp42, 0);
            }
            v3 = read_num - 1;
            atof((const char *)displayed_rate_asic);
            chain_asic_RT[i][v3] = v1;
            if ( ((read_num & 7) == 0 || read_num == 108) && (use_syslog || opt_log_output || opt_log_level > 4) )
            {
              strcpy((char *)tmp42, "\n");
              applog(5, tmp42, 0);
            }
          }
        }
      }
      else
      {
        ++reg_value_buf.p_rd;
        --reg_value_buf.reg_value_num;
        if ( reg_value_buf.p_rd > 0x1FE )
          reg_value_buf.p_rd = 0;
      }
    }
    if ( !reg_address && dev->chain_asic_num[i] == 108 )
    {
      pthread_mutex_unlock(&reg_mutex);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "!!chain_asic_num[%d] is CHAIN_ASIC_NUM\n", i);
        applog(5, tmp42, 0);
      }
LABEL_107:
      not_reg_data_time = 0;
      if ( !reg && dev->chain_asic_num[i] > (unsigned int)dev->max_asic_num_in_one_chain )
        dev->max_asic_num_in_one_chain = dev->chain_asic_num[i];
      if ( dev->chain_asic_num[i] == read_num )
      {
        rate[i] = tmp_rate;
        suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
        rate_error[i] = 0;
      }
      if ( (!read_num || status_error) && (++rate_error[i] > 3 || status_error) )
      {
        rate[i] = 0LL;
        suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
      }
      clear_register_value_buf();
      goto LABEL_118;
    }
LABEL_105:
    pthread_mutex_unlock(&reg_mutex);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "read asic reg Error on Chain[%d]\n", i);
    applog(5, tmp42, 0);
  }
  pthread_mutex_unlock(&reg_mutex);
  return 0;
}
// 3B452: variable 'v1' is possibly undefined

//----- (0003B728) --------------------------------------------------------
void __cdecl reset_one_hashboard(int chainIndex)
{
  set_QN_write_data_command((chainIndex << 16) | 0x8000000F);
  while ( get_QN_write_data_command() < 0 )
    usleep(0x2710u);
  sleep(1u);
}

//----- (0003B764) --------------------------------------------------------
bool __cdecl check_asic_reg_oneChain(int chainIndex, unsigned int reg)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 rate_buf[10]; // [sp+824h] [bp+81Ch] BYREF
  unsigned __int8 reg_buf[5]; // [sp+C30h] [bp+C28h]
  unsigned int buf[2]; // [sp+C38h] [bp+C30h]
  uint64_t temp_hash_rate; // [sp+C40h] [bp+C38h]
  int i; // [sp+C4Ch] [bp+C44h]
  unsigned int temp_nonce; // [sp+C50h] [bp+C48h]
  unsigned int reg_value_num; // [sp+C54h] [bp+C4Ch]
  int nonce_number; // [sp+C58h] [bp+C50h]
  int i_0; // [sp+C5Ch] [bp+C54h]
  unsigned __int8 reg_address; // [sp+C63h] [bp+C5Bh]
  int reg_processed_counter; // [sp+C64h] [bp+C5Ch]
  uint64_t tmp_rate; // [sp+C68h] [bp+C60h]
  int read_num; // [sp+C74h] [bp+C6Ch]
  int not_reg_data_time; // [sp+C78h] [bp+C70h]
  int j; // [sp+C7Ch] [bp+C74h]

  not_reg_data_time = 0;
  nonce_number = 0;
  buf[0] = 0;
  buf[1] = 0;
  reg_value_num = 0;
  temp_nonce = 0;
  reg_buf[0] = 0;
  reg_buf[1] = 0;
  reg_buf[2] = 0;
  reg_buf[3] = 0;
  reg_buf[4] = 0;
  read_num = 0;
  tmp_rate = 0LL;
  reg_processed_counter = 0;
rerun_all:
  clear_register_value_buf();
  tmp_rate = 0LL;
  i = chainIndex;
  reg_processed_counter = 0;
  read_num = 0;
  if ( dev->chain_exist[chainIndex] == 1 )
  {
    tmp_rate = 0LL;
    read_asic_register(i, 1u, 0, reg);
    if ( !reg )
      dev->chain_asic_num[i] = 0;
    while ( not_reg_data_time <= 2 )
    {
      cgsleep_ms(300);
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf.reg_value_num;
      if ( (reg_value_buf.reg_value_num > 0x1FE || reg_value_buf.p_rd > 0x1FE) && not_reg_data_time <= 2 )
      {
        ++not_reg_data_time;
        pthread_mutex_unlock(&reg_mutex);
        goto rerun_all;
      }
      if ( not_reg_data_time == 3 )
      {
        pthread_mutex_unlock(&reg_mutex);
        return 1;
      }
      if ( reg_value_num )
      {
        reg_processed_counter += reg_value_num;
        if ( reg_processed_counter > 600 )
        {
          pthread_mutex_unlock(&reg_mutex);
          return 0;
        }
        not_reg_data_time = 0;
        for ( j = 0; j < reg_value_num; ++j )
        {
          if ( reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number == i )
          {
            reg_buf[3] = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
            reg_buf[2] = BYTE1(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_buf[1] = BYTE2(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_buf[0] = HIBYTE(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_address = *((_BYTE *)&reg_value_buf.reg_value_num + 8 * ++reg_value_buf.p_rd + 2);
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
            if ( !reg_address )
              ++dev->chain_asic_num[i];
            if ( reg_address == 8 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: the asic freq is 0x%x\n",
                (const char *)_FUNCTION___13259,
                reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
              applog(7, tmp42, 0);
            }
            if ( reg == 8 )
            {
              temp_hash_rate = 0LL;
              for ( i_0 = 0; i_0 <= 3; ++i_0 )
                sprintf((char *)&rate_buf[2 * i_0], "%02x", reg_buf[i_0]);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  (char *)tmp42,
                  0x800u,
                  "%s: hashrate is %s\n",
                  (const char *)_FUNCTION___13259,
                  (const char *)rate_buf);
                applog(7, tmp42, 0);
              }
              temp_hash_rate = (__int64)strtol((const char *)rate_buf, 0, 16) << 24;
              tmp_rate += temp_hash_rate;
              ++read_num;
            }
          }
          else
          {
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
          }
        }
        if ( !reg_address && dev->chain_asic_num[i] == 108 )
        {
          pthread_mutex_unlock(&reg_mutex);
          break;
        }
      }
      else
      {
        cgsleep_ms(100);
        ++not_reg_data_time;
      }
      pthread_mutex_unlock(&reg_mutex);
    }
    not_reg_data_time = 0;
    if ( !reg_address && dev->chain_asic_num[i] > (unsigned int)dev->max_asic_num_in_one_chain )
      dev->max_asic_num_in_one_chain = dev->chain_asic_num[i];
    if ( dev->chain_asic_num[i] == read_num )
    {
      rate[i] = tmp_rate;
      suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
      rate_error[i] = 0;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: chain %d hashrate is %s\n",
          (const char *)_FUNCTION___13259,
          i,
          (const char *)displayed_rate[i]);
        applog(7, tmp42, 0);
      }
    }
    if ( (!read_num || status_error) && (++rate_error[i] > 3 || status_error) )
    {
      rate[i] = 0LL;
      suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
    }
    clear_register_value_buf();
  }
  return 1;
}

//----- (0003BED8) --------------------------------------------------------
unsigned int __cdecl check_asic_reg_with_addr_test(
        unsigned int reg,
        unsigned __int8 chip_addr,
        unsigned int chain,
        int check_num)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  int core_id_1; // [sp+824h] [bp+814h]
  int core_id_0; // [sp+828h] [bp+818h]
  int core_id; // [sp+82Ch] [bp+81Ch]
  unsigned __int8 chip_address; // [sp+833h] [bp+823h]
  unsigned int ret_count; // [sp+834h] [bp+824h]
  unsigned int check_count; // [sp+838h] [bp+828h]
  unsigned int reg_buf; // [sp+83Ch] [bp+82Ch]
  unsigned int reg_value_num; // [sp+840h] [bp+830h]
  int nonce_number; // [sp+844h] [bp+834h]
  int cc; // [sp+848h] [bp+838h]
  unsigned int no_reg_time; // [sp+84Ch] [bp+83Ch]
  int last_get_num; // [sp+850h] [bp+840h]
  int get_num; // [sp+854h] [bp+844h]
  int not_reg_data_time; // [sp+858h] [bp+848h]
  int i; // [sp+85Ch] [bp+84Ch]

  not_reg_data_time = 0;
  nonce_number = 0;
  reg_value_num = 0;
  reg_buf = 0;
  check_count = 16 * freq_pll_1393_0[freq_one_board[chain]].freq / 100;
  ret_count = 0;
  get_num = 0;
  last_get_num = 0;
  no_reg_time = 0;
  cc = 20;
  chip_address = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      cgsleep_ms(80);
LABEL_48:
      if ( not_reg_data_time > 4 )
        break;
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf.reg_value_num;
      pthread_mutex_unlock(&reg_mutex);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s: reg_value_num %d", (const char *)_FUNCTION___13296, reg_value_num);
        applog(7, tmp42, 0);
      }
      if ( reg_value_num <= 0x1FE && reg_value_buf.p_rd <= 0x1FE && reg_value_num || not_reg_data_time > 4 )
      {
        if ( not_reg_data_time > 4 )
          return 0;
        get_num += reg_value_num;
        pthread_mutex_lock(&reg_mutex);
        for ( i = 0; ; ++i )
        {
          if ( i >= reg_value_num )
          {
            pthread_mutex_unlock(&reg_mutex);
            goto LABEL_48;
          }
          reg_buf = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
          chip_address = reg_value_buf.reg_buffer[reg_value_buf.p_rd].chip_address;
          if ( reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number == chain && chip_address <= 0xD8u )
          {
            if ( reg == 64 )
            {
              if ( check_core_register )
              {
                if ( check_core_register == 6 )
                {
                  core_id_0 = HIBYTE(reg_buf);
                  ret_count = (unsigned __int8)reg_buf;
                  core_hash_clock_counter[0][(chain << 8) + (chip_address >> 1)][HIBYTE(reg_buf)] = reg_buf;
                  if ( use_syslog || opt_log_output || opt_log_level > 4 )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "chain[%02d] chip[%02d] core[%02d] hash clock counter is 0x%08x",
                      reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number,
                      chip_address >> 1,
                      core_id_0,
                      ret_count);
                    applog(5, tmp42, 0);
                  }
                }
                else if ( check_core_register == 5 )
                {
                  core_id_1 = HIBYTE(reg_buf);
                  core_hash_clock_control[chain][0][HIBYTE(reg_buf)] = reg_buf;
                }
              }
              else
              {
                core_id = HIBYTE(reg_buf);
                core_hash_clock_delay_control[0][(chain << 8) + (chip_address >> 1)][HIBYTE(reg_buf)] = reg_buf;
                if ( cc <= 9 )
                {
                  ++cc;
                  if ( use_syslog || opt_log_output || opt_log_level > 4 )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "chip %d CORE[%03d] 0x%08x %02x \n",
                      chip_address >> 1,
                      core_id,
                      reg_buf,
                      core_hash_clock_delay_control[0][(chain << 8) + (chip_addr >> 1)][core_id]);
                    applog(5, tmp42, 0);
                  }
                }
              }
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: chip %x reg %x reg_buff %x",
                (const char *)_FUNCTION___13296,
                chip_address,
                reg,
                reg_buf);
              applog(7, tmp42, 0);
            }
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
            if ( reg == 28 )
            {
              if ( (reg_buf & 0xC0000000) != 0 )
              {
                pthread_mutex_unlock(&reg_mutex);
                clear_register_value_buf();
                return 0;
              }
              else
              {
                pthread_mutex_unlock(&reg_mutex);
                clear_register_value_buf();
                return reg_buf;
              }
            }
          }
          else
          {
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
          }
        }
      }
      ++not_reg_data_time;
    }
    if ( get_num >= check_num )
    {
      clear_register_value_buf();
      return 0;
    }
    if ( get_num == last_get_num )
      ++no_reg_time;
    if ( no_reg_time > 5 )
      break;
    last_get_num = get_num;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: last_get =%d, get=%d\n",
        (const char *)_FUNCTION___13296,
        last_get_num,
        get_num);
      applog(7, tmp42, 0);
    }
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: no reg time %d, return\n", (const char *)_FUNCTION___13296, no_reg_time);
    applog(7, tmp42, 0);
  }
  return 0;
}

//----- (0003C57C) --------------------------------------------------------
unsigned int __cdecl check_asic_reg_with_addr(
        unsigned int reg,
        unsigned __int8 chip_addr,
        unsigned int chain,
        int check_num)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  int core_id_1; // [sp+820h] [bp+810h]
  int core_id_0; // [sp+824h] [bp+814h]
  int core_id; // [sp+828h] [bp+818h]
  unsigned int ret_count; // [sp+82Ch] [bp+81Ch]
  unsigned int check_count; // [sp+830h] [bp+820h]
  unsigned int reg_buf; // [sp+834h] [bp+824h]
  unsigned int reg_value_num; // [sp+838h] [bp+828h]
  int nonce_number; // [sp+83Ch] [bp+82Ch]
  int cc; // [sp+840h] [bp+830h]
  unsigned int no_reg_time; // [sp+844h] [bp+834h]
  int last_get_num; // [sp+848h] [bp+838h]
  int get_num; // [sp+84Ch] [bp+83Ch]
  int not_reg_data_time; // [sp+850h] [bp+840h]
  int i; // [sp+854h] [bp+844h]

  not_reg_data_time = 0;
  nonce_number = 0;
  reg_value_num = 0;
  reg_buf = 0;
  check_count = 16 * freq_pll_1393_0[freq_one_board[chain]].freq / 100;
  ret_count = 0;
  get_num = 0;
  last_get_num = 0;
  no_reg_time = 0;
  cc = 20;
  while ( 1 )
  {
    while ( 1 )
    {
      clear_register_value_buf();
      read_asic_register(chain, 0, chip_addr, reg);
      cgsleep_ms(80);
LABEL_55:
      if ( not_reg_data_time > 4 )
        break;
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf.reg_value_num;
      pthread_mutex_unlock(&reg_mutex);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s: reg_value_num %d", (const char *)_FUNCTION___13332, reg_value_num);
        applog(7, tmp42, 0);
      }
      if ( reg_value_num <= 0x1FE && reg_value_buf.p_rd <= 0x1FE && reg_value_num || not_reg_data_time > 4 )
      {
        if ( not_reg_data_time > 4 )
          return 0;
        get_num += reg_value_num;
        pthread_mutex_lock(&reg_mutex);
        for ( i = 0; ; ++i )
        {
          if ( i >= reg_value_num )
          {
            pthread_mutex_unlock(&reg_mutex);
            goto LABEL_55;
          }
          reg_buf = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
          if ( reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number == chain )
          {
            if ( reg == 64 )
            {
              if ( check_core_register )
              {
                if ( check_core_register == 6 )
                {
                  core_id_0 = HIBYTE(reg_buf);
                  ret_count = (unsigned __int8)reg_buf;
                  core_hash_clock_counter[0][(chain << 8) + (chip_addr >> 1)][HIBYTE(reg_buf)] = reg_buf;
                  if ( ret_count != check_count
                    && check_count + 1 != ret_count
                    && check_count - 1 != ret_count
                    && (use_syslog || opt_log_output || opt_log_level > 4) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "chain[%02d] chip[%02d] core[%02d] hash clock counter is 0x%08x",
                      reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number,
                      chip_addr >> 1,
                      core_id_0,
                      ret_count);
                    applog(5, tmp42, 0);
                  }
                }
                else if ( check_core_register == 5 )
                {
                  core_id_1 = HIBYTE(reg_buf);
                  core_hash_clock_control[chain][0][HIBYTE(reg_buf)] = reg_buf;
                }
              }
              else
              {
                core_id = HIBYTE(reg_buf);
                core_hash_clock_delay_control[0][(chain << 8) + (chip_addr >> 1)][HIBYTE(reg_buf)] = reg_buf;
                if ( cc <= 9 )
                {
                  ++cc;
                  if ( use_syslog || opt_log_output || opt_log_level > 4 )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "chip %d CORE[%03d] 0x%08x %02x \n",
                      chip_addr >> 1,
                      core_id,
                      reg_buf,
                      core_hash_clock_delay_control[0][(chain << 8) + (chip_addr >> 1)][core_id]);
                    applog(5, tmp42, 0);
                  }
                }
                if ( (unsigned __int8)reg_buf != 10 && (use_syslog || opt_log_output || opt_log_level > 4) )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "chain[%02d] chip[%02d] core[%d] clock delay control is 0x%08x",
                    reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number,
                    chip_addr,
                    core_id,
                    core_hash_clock_delay_control[0][(chain << 8) + (chip_addr >> 1)][core_id]);
                  applog(5, tmp42, 0);
                }
              }
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: chip %x reg %x reg_buff %x",
                (const char *)_FUNCTION___13332,
                chip_addr,
                reg,
                reg_buf);
              applog(7, tmp42, 0);
            }
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
            if ( reg == 28 )
            {
              if ( (reg_buf & 0xC0000000) != 0 )
              {
                pthread_mutex_unlock(&reg_mutex);
                clear_register_value_buf();
                return 0;
              }
              else
              {
                pthread_mutex_unlock(&reg_mutex);
                clear_register_value_buf();
                return reg_buf;
              }
            }
          }
          else
          {
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
          }
        }
      }
      ++not_reg_data_time;
    }
    if ( get_num >= check_num )
    {
      clear_register_value_buf();
      return 0;
    }
    if ( get_num == last_get_num )
      ++no_reg_time;
    if ( no_reg_time > 5 )
      break;
    last_get_num = get_num;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: last_get =%d, get=%d\n",
        (const char *)_FUNCTION___13332,
        last_get_num,
        get_num);
      applog(7, tmp42, 0);
    }
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: no reg time %d, return\n", (const char *)_FUNCTION___13332, no_reg_time);
    applog(7, tmp42, 0);
  }
  return 0;
}

//----- (0003CCF8) --------------------------------------------------------
unsigned int __cdecl wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update)
{
  unsigned __int8 chip_addra; // [sp+Ch] [bp+Ch]
  unsigned int ret; // [sp+10h] [bp+10h]
  int fail_time; // [sp+14h] [bp+14h]

  chip_addra = chip_addr;
  for ( fail_time = 0; fail_time <= 1; ++fail_time )
  {
    ret = check_asic_reg_with_addr(0x1Cu, chip_addra, chain, 1);
    if ( ret )
      return ret;
    cgsleep_ms(1);
  }
  return 0;
}

//----- (0003CD4C) --------------------------------------------------------
unsigned int __cdecl check_reg_temp(
        unsigned __int8 device,
        unsigned int reg,
        unsigned __int8 data,
        unsigned __int8 write,
        unsigned __int8 chip_addr,
        int chain)
{
  unsigned int ret; // [sp+10h] [bp+8h]
  int fail_time; // [sp+14h] [bp+Ch]

  fail_time = 0;
  if ( write )
  {
    do
    {
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, data, write, chip_addr, chain);
      wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, 0, 0, chip_addr, chain);
      ret = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      ++fail_time;
    }
    while ( (unsigned __int16)(ret & 0xFF00) >> 8 != reg && (unsigned __int8)ret != data && fail_time <= 1 );
  }
  else
  {
    do
    {
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, data, 0, chip_addr, chain);
      cgsleep_ms(1);
      ret = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      ++fail_time;
    }
    while ( ((unsigned __int16)(ret & 0xFF00) >> 8 != reg || (unsigned __int8)ret == 255 || (unsigned __int8)ret == 127)
         && fail_time <= 1 );
  }
  if ( fail_time == 2 )
    return 0;
  else
    return ret;
}

//----- (0003CE80) --------------------------------------------------------
int8_t __cdecl calc_offset(int remote, int local)
{
  float v2; // s15

  v2 = (double)remote - ((double)local + 273.15) * 0.101190476 - (double)local;
  return (int)(float)(0.0 - v2);
}

//----- (0003CEFC) --------------------------------------------------------
int16_t __cdecl get_remote(int16_t remote)
{
  float v1; // s15
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  float t_re_re; // [sp+814h] [bp+80Ch]

  v1 = ((double)(__int16)(remote - 64) * 1.008 - 27.8613) / 1.11;
  t_re_re = v1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "remote : %d temp : %f", (__int16)(remote - 64), t_re_re);
    applog(7, tmp42, 0);
  }
  return (int)t_re_re;
}

//----- (0003CFF0) --------------------------------------------------------
int16_t __cdecl get_local(int16_t local)
{
  return local - 64;
}

//----- (0003D014) --------------------------------------------------------
int8_t __cdecl do_calibration_sensor_offset(
        unsigned __int8 device,
        unsigned __int8 chip_addr,
        int chain,
        int temp_chip_index)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  int8_t middle; // [sp+C27h] [bp+C17h]
  int check_ok_counter; // [sp+C28h] [bp+C18h]
  int get_value_once; // [sp+C2Ch] [bp+C1Ch]
  int8_t retry_Time_Count; // [sp+C32h] [bp+C22h]
  int8_t error_Limit; // [sp+C33h] [bp+C23h]
  int16_t ret; // [sp+C34h] [bp+C24h]
  int8_t local; // [sp+C36h] [bp+C26h]
  int8_t offset; // [sp+C37h] [bp+C27h]

  offset = 0;
  local = 0;
  ret = 0;
  error_Limit = 0;
  retry_Time_Count = 0;
  get_value_once = 0;
  check_ok_counter = 0;
  if ( dev->TempChipType[chain][temp_chip_index] != 26 && dev->TempChipType[chain][temp_chip_index] != 85 )
  {
    DEVICEADDR[chain] = -104;
    device = DEVICEADDR[chain];
    ret = check_reg_temp(device, 0xFEu, 0, 0, chip_addr, chain);
    dev->TempChipType[chain][temp_chip_index] = ret;
    if ( dev->TempChipType[chain][temp_chip_index] != 26 && dev->TempChipType[chain][temp_chip_index] != 85 )
    {
      DEVICEADDR[chain] = -102;
      device = DEVICEADDR[chain];
      ret = check_reg_temp(device, 0xFEu, 0, 0, chip_addr, chain);
      dev->TempChipType[chain][temp_chip_index] = ret;
      if ( dev->TempChipType[chain][temp_chip_index] != 26 && dev->TempChipType[chain][temp_chip_index] != 85 )
      {
        DEVICEADDR[chain] = -100;
        device = DEVICEADDR[chain];
        ret = check_reg_temp(device, 0xFEu, 0, 0, chip_addr, chain);
        dev->TempChipType[chain][temp_chip_index] = ret;
      }
    }
  }
  if ( dev->TempChipType[chain][temp_chip_index] == 26 )
    is218_Temp = 1;
  check_reg_temp(device, 9u, 4u, 1u, chip_addr, chain);
  check_reg_temp(device, 0x11u, offset, 1u, chip_addr, chain);
  ret = check_reg_temp(device, 0, 0, 0, chip_addr, chain);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "[%s] get local temp is %d\n", (const char *)_func___13403, (unsigned __int8)ret);
    applog(5, tmp42, 0);
  }
  local = get_local((unsigned __int8)ret);
  ret = check_reg_temp(device, 1u, 0, 0, chip_addr, chain);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "[%s] get remote temp is %d\n", (const char *)_func___13403, (unsigned __int8)ret);
    applog(5, tmp42, 0);
  }
  middle = ret & 0xBF;
  offset = calc_offset((char)(ret & 0xBF), local);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "offset local:%d remote:%d offset:%d \n", local, middle, offset);
    applog(5, tmp42, 0);
  }
  if ( offset <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Warning: Chain[%d] chip[%d] local:%hhd remote:%hhd offset:%hhd, will fixed offset=27\n",
        chain,
        chip_addr,
        local,
        middle,
        offset);
      applog(5, tmp42, 0);
    }
    offset = 27;
  }
  ret = check_reg_temp(device, 0x11u, offset, 1u, chip_addr, chain);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "New offset Chain[%d] chip[%d] local:%hhd remote:%hhd offset:%hhd \n",
      chain,
      chip_addr,
      local,
      middle,
      offset);
    applog(5, tmp42, 0);
  }
  return offset;
}

//----- (0003D618) --------------------------------------------------------
void __cdecl set_misc_control(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 addr, int i2c)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned __int8 buf[9]; // [sp+828h] [bp+818h] BYREF
  unsigned int value; // [sp+834h] [bp+824h]
  unsigned int temp_misc; // [sp+83Ch] [bp+82Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  temp_misc = gBM1393_MISC_CONTROL_reg;
  if ( i2c )
    temp_misc |= 0x4060u;
  buf[0] = 65;
  if ( mode )
    buf[0] |= 0x10u;
  buf[1] = 9;
  buf[2] = addr;
  buf[3] = 24;
  buf[4] = HIBYTE(temp_misc);
  buf[5] = BYTE2(temp_misc);
  buf[6] = BYTE1(temp_misc);
  buf[7] = temp_misc;
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: cmd_buf[0]=0x%x, cmd_buf[1]=0x%x, cmd_buf[2]=0x%x, misc=0x%x\n",
      (const char *)_FUNCTION___13420,
      cmd_buf[0],
      cmd_buf[1],
      cmd_buf[2],
      temp_misc);
    applog(5, tmp42, 0);
  }
  set_BC_command_buffer(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (0003D7EC) --------------------------------------------------------
void __cdecl set_general_i2c(
        unsigned __int8 chain,
        unsigned __int8 chip_addr,
        int bottom_or_mid,
        unsigned __int8 reg,
        unsigned __int8 device,
        unsigned __int8 data,
        unsigned __int8 write)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp+14h] BYREF
  unsigned int value; // [sp+20h] [bp+20h]
  unsigned int ret; // [sp+24h] [bp+24h]

  *(_DWORD *)buf = 469764417;
  *(_DWORD *)&buf[4] = 1;
  buf[8] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  buf[2] = chip_addr;
  if ( bottom_or_mid == 1 )
    buf[4] |= 4u;
  buf[5] = write | device;
  buf[6] = reg;
  buf[7] = data;
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  while ( 1 )
  {
    ret = get_BC_write_command();
    if ( (ret & 0x80000000) == 0 )
      break;
    cgsleep_ms(1);
  }
  set_BC_command_buffer(cmd_buf);
  value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (0003D8E8) --------------------------------------------------------
void __cdecl set_baud_with_addr(
        unsigned __int8 bauddiv,
        int mode,
        unsigned __int8 chip_addr,
        int chain,
        int iic,
        int open_core,
        int bottom_or_mid)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  unsigned int cmd_buf[3]; // [sp+824h] [bp+814h] BYREF
  unsigned __int8 buf[9]; // [sp+830h] [bp+820h] BYREF
  unsigned int value; // [sp+83Ch] [bp+82Ch]
  unsigned int ret; // [sp+840h] [bp+830h]
  unsigned int i; // [sp+844h] [bp+834h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  i = chain;
  if ( opt_multi_version )
  {
    buf[0] = 65;
    if ( mode )
      buf[0] = 81;
    buf[1] = 9;
    buf[2] = chip_addr;
    buf[3] = 24;
    buf[4] = 64;
    if ( bottom_or_mid )
      buf[5] = 32;
    else
      buf[5] = 33;
    if ( iic )
    {
      buf[6] = bauddiv & 0x1F | 0x40;
      buf[7] = 96;
    }
    else
    {
      buf[6] = bauddiv & 0x1F;
      buf[7] = 0;
    }
    if ( open_core )
      buf[6] |= 0x80u;
    buf[8] = 0;
    buf[8] = CRC5(buf, 0x40u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
    cmd_buf[2] = buf[8] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
  }
  else
  {
    buf[1] = 16;
    buf[2] = bauddiv & 0x1F;
    buf[0] = -122;
    buf[3] = CRC5(buf, 0x1Bu);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13451,
        buf[0],
        buf[1],
        buf[2],
        buf[3]);
      applog(7, tmp42, 0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (0003DBD8) --------------------------------------------------------
int8_t __cdecl calibration_sensor_offset(unsigned __int8 device, int chain)
{
  int v2; // r4
  int8_t v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+8h] BYREF
  char temp_offset[10]; // [sp+C30h] [bp+C08h] BYREF
  int8_t local; // [sp+C3Bh] [bp+C13h]
  unsigned int ret; // [sp+C3Ch] [bp+C14h]
  int i; // [sp+C40h] [bp+C18h]
  unsigned __int8 v11; // [sp+C47h] [bp+C1Fh]

  ret = 0;
  local = 0;
  pthread_mutex_lock(&iic_mutex);
  get_temperature_offset_value(chain, (unsigned __int8 *)temp_offset);
  pthread_mutex_unlock(&iic_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Chain[J%d] PIC temp offset=%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
      chain,
      temp_offset[0],
      temp_offset[1],
      temp_offset[2],
      temp_offset[3],
      temp_offset[4],
      temp_offset[5],
      temp_offset[6],
      temp_offset[7],
      temp_offset[8],
      temp_offset[9]);
    applog(5, tmp42, 0);
  }
  temp_offset[8] &= 0x1Fu;
  if ( temp_offset[8] == 7 )
  {
    DEVICEADDR[chain] = -100;
  }
  else if ( temp_offset[8] == 9 || temp_offset[8] == 6 )
  {
    DEVICEADDR[chain] = -102;
  }
  else
  {
    DEVICEADDR[chain] = -104;
  }
  v11 = DEVICEADDR[chain];
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "chain[%d] temp chip I2C addr=0x%02x\n", chain, v11);
    applog(5, tmp42, 0);
  }
  if ( temp_offset[8] != 1 && temp_offset[8] != 2 )
  {
    chip_hasNoMiddle = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "chain[%d] has no middle temp, use special fix mode.\n", chain);
      applog(5, tmp42, 0);
    }
  }
  dev->chain_asic_temp_num[chain] = 0;
  for ( i = 0; i <= 3; ++i )
  {
    if ( temp_offset[2 * i] > 0 && temp_offset[2 * i] <= 107 )
    {
      dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]] = 2 * (temp_offset[2 * i] - 1);
      middle_Offset[8 * chain + dev->chain_asic_temp_num[chain]] = temp_offset[2 * i + 1];
      set_misc_control(chain, 0, dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]], 1);
      check_asic_reg_with_addr(0x18u, dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]], chain, 1);
      ret = check_reg_temp(v11, 0xFEu, 0, 0, dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]], chain);
      dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] = ret;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Chain[J%d] chip[%d] use PIC middle temp offset=%d typeID=%02x\n",
          chain,
          (dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]] >> 1) + 1,
          middle_Offset[8 * chain + dev->chain_asic_temp_num[chain]],
          dev->TempChipType[chain][dev->chain_asic_temp_num[chain]]);
        applog(5, tmp42, 0);
      }
      if ( dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 26
        && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 85
        && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 65 )
      {
        chip_hasNoMiddle = 1;
        DEVICEADDR[chain] = -104;
        v11 = DEVICEADDR[chain];
        ret = check_reg_temp(v11, 0xFEu, 0, 0, dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]], chain);
        dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] = ret;
        if ( dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 26
          && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 85
          && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 65 )
        {
          DEVICEADDR[chain] = -102;
          v11 = DEVICEADDR[chain];
          ret = check_reg_temp(v11, 0xFEu, 0, 0, dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]], chain);
          dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] = ret;
          if ( dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 26
            && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 85
            && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 65 )
          {
            DEVICEADDR[chain] = -100;
            v11 = DEVICEADDR[chain];
            ret = check_reg_temp(v11, 0xFEu, 0, 0, dev->TempChipAddr[chain][dev->chain_asic_temp_num[chain]], chain);
            dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] = ret;
          }
        }
      }
      if ( dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 26
        && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 85
        && dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 65 )
      {
        dev->chain_asic_temp_num[chain] = 0;
        break;
      }
      if ( dev->TempChipType[chain][dev->chain_asic_temp_num[chain]] != 85 )
        is218_Temp = 1;
      v2 = dev->chain_asic_temp_num[chain];
      middle_Offset[8 * chain + v2] = do_calibration_sensor_offset(v11, dev->TempChipAddr[chain][v2], chain, v2);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Chain[J%d] chip[%d] get middle temp offset=%d typeID=%02x\n",
          chain,
          dev->TempChipAddr[chain][i],
          middle_Offset[8 * chain + dev->chain_asic_temp_num[chain]],
          dev->TempChipType[chain][dev->chain_asic_temp_num[chain]]);
        applog(5, tmp42, 0);
      }
      ++dev->chain_asic_temp_num[chain];
    }
  }
  if ( dev->chain_asic_temp_num[chain] <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Warning: Chain[J%d] has no temp offset in PIC! will fix it\n", chain + 1);
      applog(5, tmp42, 0);
    }
    dev->chain_asic_temp_num[chain] = 4;
    dev->TempChipAddr[chain][0] = 2 * (temp_offset[0] - 1);
    dev->TempChipAddr[chain][1] = 2 * (temp_offset[2] - 1);
    dev->TempChipAddr[chain][2] = 2 * (temp_offset[4] - 1);
    dev->TempChipAddr[chain][3] = 2 * (temp_offset[6] - 1);
    for ( i = 0; dev->chain_asic_temp_num[chain] > i; ++i )
    {
      set_misc_control(chain, 0, dev->TempChipAddr[chain][i], 1);
      check_asic_reg_with_addr(0x18u, dev->TempChipAddr[chain][i], chain, 1);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Chain[J%d] use default temp chip[%d] \n",
          chain + 1,
          dev->TempChipAddr[chain][i]);
        applog(5, tmp42, 0);
      }
      v3 = do_calibration_sensor_offset(v11, dev->TempChipAddr[chain][i], chain, i);
      middle_Offset[8 * chain + i] = v3;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Chain[J%d] chip[%d] get middle temp offset=%d typeID=%02x\n",
          chain + 1,
          dev->TempChipAddr[chain][i],
          middle_Offset[8 * chain + i],
          dev->TempChipType[chain][i]);
        applog(5, tmp42, 0);
      }
    }
  }
  return 0;
}

//----- (0003EB2C) --------------------------------------------------------
int __cdecl fakeMiddleTempFromPCB(int local_temp)
{
  return local_temp + 15;
}

//----- (0003EB44) --------------------------------------------------------
void __noreturn read_temp_func()
{
  all_parameters *v0; // r4
  all_parameters *v1; // r4
  all_parameters *v2; // r4
  int dhash_acc_control; // r0
  unsigned int crc_count; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+0h] BYREF
  int mintemp[4]; // [sp+810h] [bp+800h]
  int maxtemp[4]; // [sp+820h] [bp+810h] BYREF
  int16_t temp_low[4]; // [sp+830h] [bp+820h] BYREF
  int16_t temp_top[4]; // [sp+838h] [bp+828h] BYREF
  int chain_asic_temp_error[16][8]; // [sp+840h] [bp+830h] BYREF
  timeval diff; // [sp+A40h] [bp+A30h]
  Temp_Type_E temp_Type; // [sp+F48h] [bp+F38h]
  bool already_offside; // [sp+F4Fh] [bp+F3Fh]
  unsigned int ret3; // [sp+F50h] [bp+F40h]
  unsigned int ret2; // [sp+F54h] [bp+F44h]
  unsigned int ret1; // [sp+F58h] [bp+F48h]
  unsigned int ret0; // [sp+F5Ch] [bp+F4Ch]
  unsigned int ret; // [sp+F60h] [bp+F50h]
  bool readTempHasSomeOneFailed; // [sp+F67h] [bp+F57h]
  int fatal_error_counter; // [sp+F68h] [bp+F58h]
  int cur_fan_num; // [sp+F6Ch] [bp+F5Ch]
  int j; // [sp+F70h] [bp+F60h]
  int i; // [sp+F74h] [bp+F64h]

  ret = 0;
  ret0 = 0;
  ret1 = 0;
  ret2 = 0;
  ret3 = 0;
  memset(chain_asic_temp_error, 0, sizeof(chain_asic_temp_error));
  already_offside = 0;
  temp_Type = TEMP_MIDDLE;
  cur_fan_num = 0;
  fatal_error_counter = 0;
  while ( 1 )
  {
    pthread_mutex_lock(&opencore_readtemp_mutex);
    memset(temp_top, 0, sizeof(temp_top));
    memset(temp_low, 0, sizeof(temp_low));
    readTempHasSomeOneFailed = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] == 1 )
      {
        memset(maxtemp, 0, 12);
        mintemp[0] = 1000;
        mintemp[1] = 1000;
        mintemp[2] = 1000;
        for ( j = 0; dev->chain_asic_temp_num[i] > j; ++j )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Chain[%d] Chip[%d] TempTypeID=%02x middle offset=%d\n",
              i,
              (dev->TempChipAddr[i][j] >> 1) + 1,
              dev->TempChipType[i][j],
              middle_Offset[8 * i + j]);
            applog(5, tmp42, 0);
          }
          ret = check_reg_temp(DEVICEADDR[i], 0, 0, 0, dev->TempChipAddr[i][j], i);
          if ( ret )
          {
            v0 = dev;
            v0->chain_asic_temp[i][j][0] = get_local((unsigned __int8)ret);
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Chain[%d] Chip[%d] local Temp=%d\n",
                i,
                (dev->TempChipAddr[i][j] >> 1) + 1,
                dev->chain_asic_temp[i][j][0]);
              applog(5, tmp42, 0);
            }
          }
          else
          {
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "read failed, old value: Chain[%d] Chip[%d] local Temp=%d\n",
                i,
                (dev->TempChipAddr[i][j] >> 1) + 1,
                dev->chain_asic_temp[i][j][0]);
              applog(5, tmp42, 0);
            }
            readTempHasSomeOneFailed = 1;
          }
          ret = check_reg_temp(DEVICEADDR[i], 1u, 0, 0, dev->TempChipAddr[i][j], i);
          if ( ret )
          {
            v1 = dev;
            v1->chain_asic_temp[i][j][1] = get_remote((unsigned __int8)ret);
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Chain[%d] Chip[%d] middle Temp=%d\n",
                i,
                (dev->TempChipAddr[i][j] >> 1) + 1,
                dev->chain_asic_temp[i][j][1]);
              applog(7, tmp42, 0);
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "read failed on Chain[%d] Chip[%d] middle Temp old value:%d\n",
              i,
              (dev->TempChipAddr[i][j] >> 1) + 1,
              dev->chain_asic_temp[i][j][1]);
            applog(7, tmp42, 0);
          }
          if ( is218_Temp || chip_hasNoMiddle || dev->chain_asic_temp[i][j][0] > dev->chain_asic_temp[i][j][1] )
          {
            v2 = dev;
            v2->chain_asic_temp[i][j][1] = fakeMiddleTempFromPCB(dev->chain_asic_temp[i][j][0]);
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Special fix Chain[%d] Chip[%d] middle Temp = %d\n",
                i,
                (dev->TempChipAddr[i][j] >> 1) + 1,
                dev->chain_asic_temp[i][j][1]);
              applog(7, tmp42, 0);
            }
          }
          if ( dev->chain_asic_temp[i][j][0] > maxtemp[0] )
            maxtemp[0] = dev->chain_asic_temp[i][j][0];
          if ( dev->chain_asic_temp[i][j][1] > maxtemp[1] )
            maxtemp[1] = dev->chain_asic_temp[i][j][1];
          if ( dev->chain_asic_temp[i][j][2] > maxtemp[2] )
            maxtemp[2] = dev->chain_asic_temp[i][j][2];
          if ( dev->chain_asic_temp[i][j][0] < mintemp[0] )
            mintemp[0] = dev->chain_asic_temp[i][j][0];
          if ( dev->chain_asic_temp[i][j][1] < mintemp[1] )
            mintemp[1] = dev->chain_asic_temp[i][j][1];
          if ( dev->chain_asic_temp[i][j][2] < mintemp[2] )
            mintemp[2] = dev->chain_asic_temp[i][j][2];
        }
        dev->chain_asic_maxtemp[i][0] = maxtemp[0];
        dev->chain_asic_maxtemp[i][1] = maxtemp[1];
        dev->chain_asic_maxtemp[i][2] = maxtemp[2];
        dev->chain_asic_mintemp[i][0] = mintemp[0];
        dev->chain_asic_mintemp[i][1] = mintemp[1];
        dev->chain_asic_mintemp[i][2] = mintemp[2];
        if ( dev->chain_asic_maxtemp[i][0] > temp_top[0] )
          temp_top[0] = dev->chain_asic_maxtemp[i][0];
        if ( dev->chain_asic_maxtemp[i][1] > temp_top[1] )
          temp_top[1] = dev->chain_asic_maxtemp[i][1];
        if ( dev->chain_asic_maxtemp[i][2] > temp_top[2] )
          temp_top[2] = dev->chain_asic_maxtemp[i][2];
        if ( dev->chain_asic_mintemp[i][0] < temp_low[0] && dev->chain_asic_mintemp[i][0] > 0 && !chain_temp_toolow[i]
          || !temp_low[0] )
        {
          temp_low[0] = dev->chain_asic_mintemp[i][0];
        }
        if ( dev->chain_asic_mintemp[i][1] < temp_low[1] && dev->chain_asic_mintemp[i][1] > 0 && !chain_temp_toolow[i]
          || !temp_low[1] )
        {
          temp_low[1] = dev->chain_asic_mintemp[i][1];
        }
        if ( dev->chain_asic_mintemp[i][2] < temp_low[2] && dev->chain_asic_mintemp[i][2] > 0 && !chain_temp_toolow[i]
          || !temp_low[2] )
        {
          temp_low[2] = dev->chain_asic_mintemp[i][2];
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Done read temp on Chain[%d]\n", i);
          applog(7, tmp42, 0);
        }
      }
    }
    dev->temp_top1[0] = temp_top[0];
    dev->temp_top1[1] = temp_top[1];
    dev->temp_top1[2] = temp_top[2];
    dev->temp_low1[0] = temp_low[0];
    dev->temp_low1[1] = temp_low[1];
    dev->temp_low1[2] = temp_low[2];
    last_testpatten_highest_pcb_temp = dev->temp_top1[0];
    check_fan();
    if ( (*((_BYTE *)&config_parameter + 4) & 2) != 0 )
    {
      if ( config_parameter.fan_pwm_percent > 0x64u )
      {
        if ( !readTempHasSomeOneFailed )
          goto LABEL_101;
        set_PWM(0x64u);
        dev->fan_pwm = 100;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          goto LABEL_93;
      }
      else
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Set fixed fan speed=%d\n", config_parameter.fan_pwm_percent);
          applog(7, tmp42, 0);
        }
        set_PWM(config_parameter.fan_pwm_percent);
      }
    }
    else
    {
      if ( !readTempHasSomeOneFailed )
      {
LABEL_101:
        set_PWM_according_to_temperature();
        goto LABEL_102;
      }
      set_PWM(0x64u);
      dev->fan_pwm = 100;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
LABEL_93:
        strcpy((char *)tmp42, "Set fixed full fan speed\n");
        applog(7, tmp42, 0);
      }
    }
LABEL_102:
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "fan map is 0x%08x, num = %d\n", dev->fan_exist_map, dev->fan_num);
      applog(7, tmp42, 0);
    }
    if ( startCheckNetworkJob )
    {
      cgtime(&tv_send);
      diff.tv_sec = tv_send.tv_sec - tv_send_job.tv_sec;
      diff.tv_usec = tv_send.tv_usec - tv_send_job.tv_usec;
      if ( tv_send.tv_usec - tv_send_job.tv_usec < 0 )
      {
        --diff.tv_sec;
        diff.tv_usec += 1000000;
      }
      cur_fan_num = dev->fan_num;
      if ( diff.tv_sec > 120 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Fatal Error: network connection lost!\n");
        applog(7, tmp42, 0);
      }
    }
    else
    {
      diff.tv_sec = 0;
      cur_fan_num = 2;
    }
    if ( diff.tv_sec <= 120 && dev->temp_top1[0] <= 95 && cur_fan_num > 1 )
    {
      fatal_error_counter = 0;
      global_stop = 0;
      if ( !once_error )
        status_error = 0;
    }
    else if ( ++fatal_error_counter <= 2 )
    {
      global_stop = 0;
      if ( !once_error )
        status_error = 0;
    }
    else
    {
      global_stop = 1;
      if ( dev->temp_top1[0] <= 95 )
      {
        if ( cur_fan_num > 1 )
          FatalErrorValue = 3;
        else
          FatalErrorValue = 2;
      }
      else
      {
        FatalErrorValue = 1;
      }
      if ( dev->temp_top1[0] > 95 || cur_fan_num <= 1 )
      {
        status_error = 1;
        once_error = 1;
        for ( i = 0; i <= 15; ++i )
        {
          if ( dev->chain_exist[i] == 1 )
          {
            pthread_mutex_lock(&iic_mutex);
            disable_pic_dac(i);
            pthread_mutex_unlock(&iic_mutex);
          }
        }
      }
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
    }
    if ( status_error )
    {
      switch ( FatalErrorValue )
      {
        case 2:
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Fatal Error: Fan lost!\n");
            applog(7, tmp42, 0);
          }
          break;
        case 3:
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Fatal Error: network connection lost!\n");
            applog(7, tmp42, 0);
          }
          break;
        case 1:
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Fatal Error: Temperature is too high!\n");
            applog(7, tmp42, 0);
          }
          break;
        default:
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Fatal Error: unkown status.\n");
            applog(7, tmp42, 0);
          }
          break;
      }
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "FAN PWM: %d\n", dev->fan_pwm);
      applog(7, tmp42, 0);
    }
    pthread_mutex_unlock(&opencore_readtemp_mutex);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "read_temp_func Done!\n");
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      crc_count = get_crc_count();
      snprintf((char *)tmp42, 0x800u, "CRC error counter=%d\n", crc_count);
      applog(7, tmp42, 0);
    }
    if ( doTestPatten )
      sleep(3u);
    else
      sleep(1u);
  }
}

//----- (0003FFA8) --------------------------------------------------------
void __noreturn scanfreq_read_temp_func()
{
  all_parameters *v0; // r4
  all_parameters *v1; // r4
  unsigned int crc_count; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+0h] BYREF
  int mintemp[4]; // [sp+810h] [bp+800h]
  int maxtemp[4]; // [sp+820h] [bp+810h] BYREF
  int16_t temp_low[4]; // [sp+830h] [bp+820h] BYREF
  int16_t temp_top[4]; // [sp+838h] [bp+828h] BYREF
  int chain_asic_temp_error[16][8]; // [sp+840h] [bp+830h] BYREF
  bool readTempHasSomeOneFailed; // [sp+F4Bh] [bp+F3Bh]
  int fatal_error_counter; // [sp+F4Ch] [bp+F3Ch]
  int cur_fan_num; // [sp+F50h] [bp+F40h]
  Temp_Type_E temp_Type; // [sp+F54h] [bp+F44h]
  bool already_offside; // [sp+F5Bh] [bp+F4Bh]
  unsigned int ret3; // [sp+F5Ch] [bp+F4Ch]
  unsigned int ret2; // [sp+F60h] [bp+F50h]
  unsigned int ret1; // [sp+F64h] [bp+F54h]
  unsigned int ret0; // [sp+F68h] [bp+F58h]
  unsigned int ret; // [sp+F6Ch] [bp+F5Ch]
  int j; // [sp+F70h] [bp+F60h]
  int i; // [sp+F74h] [bp+F64h]

  ret = 0;
  ret0 = 0;
  ret1 = 0;
  ret2 = 0;
  ret3 = 0;
  memset(chain_asic_temp_error, 0, sizeof(chain_asic_temp_error));
  already_offside = 0;
  temp_Type = TEMP_MIDDLE;
  cur_fan_num = 0;
  fatal_error_counter = 0;
  while ( 1 )
  {
    pthread_mutex_lock(&opencore_readtemp_mutex);
    memset(temp_top, 0, sizeof(temp_top));
    memset(temp_low, 0, sizeof(temp_low));
    readTempHasSomeOneFailed = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] == 1 )
      {
        memset(maxtemp, 0, 12);
        mintemp[0] = 1000;
        mintemp[1] = 1000;
        mintemp[2] = 1000;
        for ( j = 0; dev->chain_asic_temp_num[i] > j; ++j )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Chain[%d] Chip[%d] TempTypeID=%02x middle offset=%d\n",
              i,
              (dev->TempChipAddr[i][j] >> 1) + 1,
              dev->TempChipType[i][j],
              middle_Offset[8 * i + j]);
            applog(7, tmp42, 0);
          }
          ret = check_reg_temp(DEVICEADDR[i], 0, 0, 0, dev->TempChipAddr[i][j], i);
          if ( ret )
          {
            v0 = dev;
            v0->chain_asic_temp[i][j][0] = get_local((unsigned __int8)ret);
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Chain[%d] Chip[%d] local Temp=%d\n",
                i,
                (dev->TempChipAddr[i][j] >> 1) + 1,
                dev->chain_asic_temp[i][j][0]);
              applog(5, tmp42, 0);
            }
          }
          else
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "read failed, old value: Chain[%d] Chip[%d] local Temp=%d\n",
                i,
                (dev->TempChipAddr[i][j] >> 1) + 1,
                dev->chain_asic_temp[i][j][0]);
              applog(7, tmp42, 0);
            }
            readTempHasSomeOneFailed = 1;
          }
          ret = check_reg_temp(DEVICEADDR[i], 1u, 0, 0, dev->TempChipAddr[i][j], i);
          if ( ret )
          {
            v1 = dev;
            v1->chain_asic_temp[i][j][1] = get_remote((unsigned __int8)ret);
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Chain[%d] Chip[%d] Chip Temp=%d\n",
                i,
                (dev->TempChipAddr[i][j] >> 1) + 1,
                dev->chain_asic_temp[i][j][1]);
              applog(5, tmp42, 0);
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "read failed on Chain[%d] Chip[%d] middle Temp old value:%d\n",
              i,
              (dev->TempChipAddr[i][j] >> 1) + 1,
              dev->chain_asic_temp[i][j][1]);
            applog(7, tmp42, 0);
          }
          if ( dev->chain_asic_temp[i][j][0] > maxtemp[0] )
            maxtemp[0] = dev->chain_asic_temp[i][j][0];
          if ( dev->chain_asic_temp[i][j][1] > maxtemp[1] )
            maxtemp[1] = dev->chain_asic_temp[i][j][1];
          if ( dev->chain_asic_temp[i][j][2] > maxtemp[2] )
            maxtemp[2] = dev->chain_asic_temp[i][j][2];
          if ( dev->chain_asic_temp[i][j][0] < mintemp[0] )
            mintemp[0] = dev->chain_asic_temp[i][j][0];
          if ( dev->chain_asic_temp[i][j][1] < mintemp[1] )
            mintemp[1] = dev->chain_asic_temp[i][j][1];
          if ( dev->chain_asic_temp[i][j][2] < mintemp[2] )
            mintemp[2] = dev->chain_asic_temp[i][j][2];
        }
        dev->chain_asic_maxtemp[i][0] = maxtemp[0];
        dev->chain_asic_maxtemp[i][1] = maxtemp[1];
        dev->chain_asic_maxtemp[i][2] = maxtemp[2];
        dev->chain_asic_mintemp[i][0] = mintemp[0];
        dev->chain_asic_mintemp[i][1] = mintemp[1];
        dev->chain_asic_mintemp[i][2] = mintemp[2];
        if ( dev->chain_asic_maxtemp[i][0] > temp_top[0] )
          temp_top[0] = dev->chain_asic_maxtemp[i][0];
        if ( dev->chain_asic_maxtemp[i][1] > temp_top[1] )
          temp_top[1] = dev->chain_asic_maxtemp[i][1];
        if ( dev->chain_asic_maxtemp[i][2] > temp_top[2] )
          temp_top[2] = dev->chain_asic_maxtemp[i][2];
        if ( dev->chain_asic_mintemp[i][0] < temp_low[0] && dev->chain_asic_mintemp[i][0] > 0 && !chain_temp_toolow[i]
          || !temp_low[0] )
        {
          temp_low[0] = dev->chain_asic_mintemp[i][0];
        }
        if ( dev->chain_asic_mintemp[i][1] < temp_low[1] && dev->chain_asic_mintemp[i][1] > 0 && !chain_temp_toolow[i]
          || !temp_low[1] )
        {
          temp_low[1] = dev->chain_asic_mintemp[i][1];
        }
        if ( dev->chain_asic_mintemp[i][2] < temp_low[2] && dev->chain_asic_mintemp[i][2] > 0 && !chain_temp_toolow[i]
          || !temp_low[2] )
        {
          temp_low[2] = dev->chain_asic_mintemp[i][2];
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Done read temp on Chain[%d]\n", i);
          applog(7, tmp42, 0);
        }
      }
    }
    dev->temp_top1[0] = temp_top[0];
    dev->temp_top1[1] = temp_top[1];
    dev->temp_top1[2] = temp_top[2];
    dev->temp_low1[0] = temp_low[0];
    dev->temp_low1[1] = temp_low[1];
    dev->temp_low1[2] = temp_low[2];
    last_testpatten_highest_pcb_temp = dev->temp_top1[0];
    set_PWM_according_to_temperature();
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "FAN PWM: %d\n", dev->fan_pwm);
      applog(7, tmp42, 0);
    }
    pthread_mutex_unlock(&opencore_readtemp_mutex);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "read_temp_func Done!\n");
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      crc_count = get_crc_count();
      snprintf((char *)tmp42, 0x800u, "CRC error counter=%d\n", crc_count);
      applog(7, tmp42, 0);
    }
    if ( doTestPatten )
      sleep(3u);
    else
      sleep(5u);
  }
}

//----- (00040C34) --------------------------------------------------------
void __cdecl chain_inactive(unsigned __int8 chain)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+824h] [bp+80Ch] BYREF
  unsigned __int8 buf[5]; // [sp+830h] [bp+818h] BYREF
  unsigned int value; // [sp+838h] [bp+820h]
  unsigned int ret; // [sp+83Ch] [bp+824h]

  buf[0] = 0;
  buf[1] = 0;
  buf[2] = 0;
  buf[3] = 0;
  buf[4] = 5;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    buf[0] = 83;
    buf[1] = 5;
    buf[2] = 0;
    buf[3] = 0;
    buf[4] = CRC5(buf, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x\n",
        (const char *)_FUNCTION___13590,
        buf[0],
        buf[1],
        buf[2],
        buf[3],
        buf[4]);
      applog(7, tmp42, 0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = buf[4] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
  else
  {
    buf[0] = -125;
    buf[1] = 0;
    buf[2] = 0;
    buf[3] = CRC5(buf, 0x1Bu);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13590,
        buf[0],
        buf[1],
        buf[2],
        buf[3]);
      applog(7, tmp42, 0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (00040EC0) --------------------------------------------------------
void __cdecl set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  unsigned int cmd_buf[3]; // [sp+818h] [bp+808h] BYREF
  unsigned __int8 buf[9]; // [sp+824h] [bp+814h] BYREF
  unsigned int value; // [sp+830h] [bp+820h]
  unsigned int ret; // [sp+834h] [bp+824h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    buf[0] = 64;
    buf[1] = 5;
    buf[2] = address;
    buf[3] = 0;
    buf[4] = CRC5(buf, 0x20u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = buf[4] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
  else
  {
    buf[0] = 0;
    buf[1] = address;
    buf[2] = 0;
    if ( mode )
      buf[0] |= 0x80u;
    buf[3] = CRC5(buf, 0x1Bu);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13604,
        buf[0],
        buf[1],
        buf[2],
        buf[3]);
      applog(7, tmp42, 0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (000410D8) --------------------------------------------------------
int __cdecl calculate_asic_number(unsigned int actual_asic_number)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  i = 0;
  if ( actual_asic_number == 1 )
    return 1;
  if ( actual_asic_number == 2 )
    return 2;
  if ( actual_asic_number > 2 && actual_asic_number <= 4 )
    return 4;
  if ( actual_asic_number > 4 && actual_asic_number <= 8 )
    return 8;
  if ( actual_asic_number > 8 && actual_asic_number <= 0x10 )
    return 16;
  if ( actual_asic_number > 0x10 && actual_asic_number <= 0x20 )
    return 32;
  if ( actual_asic_number > 0x20 && actual_asic_number <= 0x40 )
    return 64;
  if ( actual_asic_number > 0x40 && actual_asic_number <= 0x80 )
    return 128;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "actual_asic_number = %d, but it is error\n", actual_asic_number);
    applog(7, tmp42, 0);
  }
  return -1;
}

//----- (00041210) --------------------------------------------------------
int __cdecl calculate_core_number(unsigned int actual_core_number)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  i = 0;
  if ( actual_core_number == 1 )
    return 1;
  if ( actual_core_number == 2 )
    return 2;
  if ( actual_core_number > 2 && actual_core_number <= 4 )
    return 4;
  if ( actual_core_number > 4 && actual_core_number <= 8 )
    return 8;
  if ( actual_core_number > 8 && actual_core_number <= 0x10 )
    return 16;
  if ( actual_core_number > 0x10 && actual_core_number <= 0x20 )
    return 32;
  if ( actual_core_number > 0x20 && actual_core_number <= 0x40 )
    return 64;
  if ( actual_core_number > 0x40 && actual_core_number <= 0x80 )
    return 128;
  if ( actual_core_number > 0x80 && actual_core_number <= 0xD0 )
    return 256;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "actual_core_number = %d, but it is error\n", actual_core_number);
    applog(7, tmp42, 0);
  }
  return -1;
}

//----- (00041360) --------------------------------------------------------
void __cdecl software_set_address_onChain(int chainIndex)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int i; // [sp+80Ch] [bp+80Ch]
  unsigned __int8 check_bit; // [sp+812h] [bp+812h]
  unsigned __int8 chip_addr; // [sp+813h] [bp+813h]
  unsigned int j; // [sp+814h] [bp+814h]

  i = chainIndex;
  chip_addr = 0;
  check_bit = 0;
  dev->check_bit = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "--- %s\n", (const char *)_FUNCTION___13625);
    applog(7, tmp42, 0);
  }
  dev->addrInterval = 2;
  check_bit = dev->addrInterval - 1;
  while ( check_bit )
  {
    check_bit >>= 1;
    ++dev->check_bit;
  }
  chip_addr = 0;
  chain_inactive(i);
  cgsleep_ms(30);
  chain_inactive(i);
  cgsleep_ms(30);
  chain_inactive(i);
  cgsleep_ms(30);
  for ( j = 0; 256 / dev->addrInterval > j; ++j )
  {
    set_address(i, 0, chip_addr);
    chip_addr += dev->addrInterval;
    cgsleep_ms(30);
  }
}

//----- (00041510) --------------------------------------------------------
void __cdecl set_core_number_BM1390(unsigned __int8 which_chain, unsigned __int8 chip_addr)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp+14h] BYREF
  unsigned int value; // [sp+20h] [bp+20h]

  buf[8] = 0;
  strcpy((char *)buf, "A\t");
  buf[3] = 0;
  buf[4] = 19;
  buf[5] = -109;
  buf[6] = -48;
  buf[7] = chip_addr;
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  set_BC_command_buffer(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (which_chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (000415E8) --------------------------------------------------------
void __cdecl software_set_address(int addrInterval)
{
  unsigned __int8 addrIntervala; // [sp+4h] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 check_bit; // [sp+80Eh] [bp+80Eh]
  unsigned __int8 chip_addr; // [sp+80Fh] [bp+80Fh]
  unsigned int j; // [sp+810h] [bp+810h]
  unsigned int i; // [sp+814h] [bp+814h]

  addrIntervala = addrInterval;
  chip_addr = 0;
  check_bit = 0;
  dev->check_bit = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "--- %s\n", (const char *)_FUNCTION___13648);
    applog(5, tmp42, 0);
  }
  dev->addrInterval = addrIntervala;
  check_bit = dev->addrInterval - 1;
  while ( check_bit )
  {
    check_bit >>= 1;
    ++dev->check_bit;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      chip_addr = 0;
      chain_inactive(i);
      cgsleep_ms(30);
      chain_inactive(i);
      cgsleep_ms(30);
      chain_inactive(i);
      cgsleep_ms(30);
      for ( j = 0; 256 / dev->addrInterval > j; ++j )
      {
        set_address(i, 0, chip_addr);
        chip_addr += dev->addrInterval;
        set_core_number_BM1390(i, chip_addr);
        cgsleep_ms(30);
      }
    }
  }
}

//----- (000417E8) --------------------------------------------------------
void __cdecl set_asic_ticket_mask(unsigned int ticket_mask)
{
  char ticket_maska; // [sp+14h] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  unsigned int cmd_buf[3]; // [sp+818h] [bp+808h] BYREF
  unsigned __int8 buf[9]; // [sp+824h] [bp+814h] BYREF
  unsigned int value; // [sp+830h] [bp+820h]
  unsigned int ret; // [sp+834h] [bp+824h]
  unsigned int tm; // [sp+838h] [bp+828h]
  unsigned int i; // [sp+83Ch] [bp+82Ch]

  ticket_maska = ticket_mask;
  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  tm = (ticket_mask << 24) | HIBYTE(ticket_mask) | ((ticket_mask & 0xFF0000) >> 8) | ((ticket_mask & 0xFF00) << 8);
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( opt_multi_version )
      {
        strcpy((char *)buf, "Q\t");
        buf[3] = 20;
        *(_DWORD *)&buf[4] = tm;
        buf[4] = bit_swap_table[(unsigned __int8)tm];
        buf[5] = bit_swap_table[BYTE1(tm)];
        buf[6] = bit_swap_table[BYTE2(tm)];
        buf[7] = bit_swap_table[HIBYTE(tm)];
        buf[8] = CRC5(buf, 0x40u);
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
        cmd_buf[2] = buf[8] << 24;
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
      else
      {
        buf[1] = 16;
        buf[2] = ticket_maska & 0x1F;
        buf[0] = -122;
        buf[3] = CRC5(buf, 0x1Bu);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
            (const char *)_FUNCTION___13668,
            buf[0],
            buf[1],
            buf[2],
            buf[3]);
          applog(7, tmp42, 0);
        }
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
    }
  }
}

//----- (00041ADC) --------------------------------------------------------
void __cdecl set_sno(unsigned int sno)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+18h] [bp+18h] BYREF
  unsigned int value; // [sp+24h] [bp+24h]
  unsigned int ret; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( opt_multi_version )
      {
        strcpy((char *)buf, "Q\t");
        buf[3] = 16;
        buf[4] = HIBYTE(sno);
        buf[5] = BYTE2(sno);
        buf[6] = BYTE1(sno);
        buf[7] = sno;
        buf[8] = CRC5(buf, 0x40u);
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
        cmd_buf[2] = buf[8] << 24;
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
    }
  }
}

//----- (00041BE8) --------------------------------------------------------
void __cdecl set_hcnt(unsigned int hcnt)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+18h] [bp+18h] BYREF
  unsigned int value; // [sp+24h] [bp+24h]
  unsigned int ret; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( opt_multi_version )
      {
        strcpy((char *)buf, "Q\t");
        buf[3] = 16;
        buf[4] = HIBYTE(hcnt);
        buf[5] = BYTE2(hcnt);
        buf[6] = BYTE1(hcnt);
        buf[7] = hcnt;
        buf[8] = CRC5(buf, 0x40u);
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
        cmd_buf[2] = buf[8] << 24;
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
    }
  }
}

//----- (00041CF4) --------------------------------------------------------
void __cdecl set_baud(unsigned __int8 bauddiv, int no_use)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned __int8 buf[9]; // [sp+828h] [bp+818h] BYREF
  unsigned int value; // [sp+834h] [bp+824h]
  unsigned int ret; // [sp+838h] [bp+828h]
  unsigned int i; // [sp+83Ch] [bp+82Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( opt_multi_version )
      {
        gBM1393_MISC_CONTROL_reg = gBM1393_MISC_CONTROL_reg & 0xFFFFE0FF | ((bauddiv & 0x1F) << 8);
        strcpy((char *)buf, "Q\t");
        buf[3] = 24;
        buf[4] = HIBYTE(gBM1393_MISC_CONTROL_reg);
        buf[5] = BYTE2(gBM1393_MISC_CONTROL_reg);
        buf[6] = BYTE1(gBM1393_MISC_CONTROL_reg);
        buf[7] = gBM1393_MISC_CONTROL_reg;
        buf[8] = CRC5(buf, 0x40u);
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
        cmd_buf[2] = buf[8] << 24;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: cmd_buf[0]=0x%x, cmd_buf[1]=0x%x, cmd_buf[2]=0x%x, misc=0x%x\n",
            (const char *)_FUNCTION___13704,
            cmd_buf[0],
            cmd_buf[1],
            cmd_buf[2],
            gBM1393_MISC_CONTROL_reg);
          applog(5, tmp42, 0);
        }
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
      else
      {
        buf[1] = 16;
        buf[2] = bauddiv & 0x1F;
        buf[0] = -122;
        buf[3] = CRC5(buf, 0x1Bu);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
            (const char *)_FUNCTION___13704,
            buf[0],
            buf[1],
            buf[2],
            buf[3]);
          applog(7, tmp42, 0);
        }
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
    }
  }
  cgsleep_us(50000LL);
  ret = get_BC_write_command();
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s: read bc write is 0x%0x\n", (const char *)_FUNCTION___13704, ret);
    applog(5, tmp42, 0);
  }
  value = bauddiv & 0x3F | ret & 0xFFFFFFC0;
  set_BC_write_command(value);
  dev->baud = bauddiv;
}

//----- (000420C8) --------------------------------------------------------
void init_uart_baud()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  int i; // [sp+C00h] [bp+C00h]
  unsigned __int8 bauddiv; // [sp+C07h] [bp+C07h]
  unsigned int baud; // [sp+C08h] [bp+C08h]
  unsigned int rBaudrate; // [sp+C0Ch] [bp+C0Ch]

  rBaudrate = 0;
  baud = 0;
  bauddiv = 0;
  i = 0;
  rBaudrate = (0x196E6A / dev->timeout) << 9;
  baud = (unsigned int)&scanfreq_info.asic_core_nonce_num[4][148][229] / rBaudrate - 1;
  if ( baud <= 0x1A )
    bauddiv = baud;
  else
    bauddiv = 26;
  bauddiv = 1;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "set baud=%d\n", bauddiv);
    applog(5, tmp42, 0);
  }
  set_baud(1u, 1);
}

//----- (000421A0) --------------------------------------------------------
void __cdecl set_led(bool stop)
{
  unsigned __int8 cmd[100]; // [sp+Ch] [bp+Ch] BYREF

  blink_13721 = !blink_13721;
  if ( stop )
  {
    sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/gpio/gpio38/value");
    system((const char *)cmd);
    sprintf((char *)cmd, "echo %d > %s", blink_13721, "/sys/class/gpio/gpio37/value");
  }
  else
  {
    sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/gpio/gpio37/value");
    system((const char *)cmd);
    sprintf((char *)cmd, "echo %d > %s", blink_13721, "/sys/class/gpio/gpio38/value");
  }
  system((const char *)cmd);
}

//----- (00042290) --------------------------------------------------------
void __noreturn pic_heart_beat_func()
{
  int i; // [sp+4h] [bp+4h]

  while ( 1 )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] )
      {
        pthread_mutex_lock(&iic_mutex);
        dsPIC33EP16GS202_pic_heart_beat(i);
        pthread_mutex_unlock(&iic_mutex);
        cgsleep_ms(10);
      }
    }
    sleep(0xAu);
  }
}

//----- (000422F0) --------------------------------------------------------
int __cdecl get_asic_nonce_num(int chain, int asic, int timeslice)
{
  int nonce; // [sp+14h] [bp+14h]
  int index; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  nonce = 0;
  for ( i = 1; i <= timeslice; ++i )
  {
    if ( nonce_times % 60 - i < 0 )
      index = nonce_times % 60 - i + 60;
    else
      index = nonce_times % 60 - i;
    nonce += LODWORD(nonce_num[chain][asic][index]);
  }
  return nonce;
}

//----- (000423EC) --------------------------------------------------------
void __cdecl get_lastn_nonce_num(unsigned __int8 *dest, int n)
{
  int asic_nonce_num; // r0
  int v3; // r0
  unsigned __int8 xtime[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 tmp[20]; // [sp+80Ch] [bp+80Ch] BYREF
  int j; // [sp+820h] [bp+820h]
  int i; // [sp+824h] [bp+824h]

  j = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      *(_DWORD *)xtime = 123;
      memset(&xtime[4], 0, 0x7FCu);
      memset(tmp, 0, sizeof(tmp));
      sprintf((char *)tmp, "Chain%d:{", i + 1);
      strcat((char *)xtime, (const char *)tmp);
      asic_nonce_num = get_asic_nonce_num(i, 0, n);
      sprintf((char *)tmp, "N%d=%d", 0, asic_nonce_num);
      strcat((char *)xtime, (const char *)tmp);
      for ( j = 1; dev->max_asic_num_in_one_chain > j; ++j )
      {
        v3 = get_asic_nonce_num(i, j, n);
        sprintf((char *)tmp, ",N%d=%d", j, v3);
        strcat((char *)xtime, (const char *)tmp);
      }
      strcat((char *)xtime, "},");
      strcat((char *)dest, (const char *)xtime);
    }
  }
  dest[strlen((const char *)dest) - 1] = 0;
}

//----- (00042590) --------------------------------------------------------
void __noreturn check_system_work()
{
  all_parameters *v0; // r2
  int v1; // r1
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+4h] BYREF
  timeval diff; // [sp+814h] [bp+804h]
  timeval tv_reboot_start; // [sp+C1Ch] [bp+C0Ch] BYREF
  timeval tv_reboot; // [sp+C24h] [bp+C14h] BYREF
  timeval tv_end; // [sp+C2Ch] [bp+C1Ch] BYREF
  timeval tv_start; // [sp+C34h] [bp+C24h] BYREF
  int error_asic; // [sp+C3Ch] [bp+C2Ch]
  int offset; // [sp+C40h] [bp+C30h]
  int run_counter; // [sp+C44h] [bp+C34h]
  int avg_num; // [sp+C48h] [bp+C38h]
  int asic_num; // [sp+C4Ch] [bp+C3Ch]
  int j; // [sp+C50h] [bp+C40h]
  int i; // [sp+C54h] [bp+C44h]

  i = 0;
  j = 0;
  cgtime(&tv_end);
  cgtime(&tv_reboot);
  copy_time(&tv_start, &tv_end);
  copy_time(&tv_reboot_start, &tv_reboot);
  asic_num = 0;
  error_asic = 0;
  avg_num = 0;
  run_counter = 0;
  while ( 1 )
  {
    while ( doTestPatten )
      cgsleep_ms(100);
    cgtime(&tv_end);
    cgtime(&tv_reboot);
    diff.tv_sec = tv_end.tv_sec - tv_start.tv_sec;
    diff.tv_usec = tv_end.tv_usec - tv_start.tv_usec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    if ( diff.tv_sec > 60 || global_stop && diff.tv_sec > 30 )
    {
      ++run_counter;
      asic_num = 0;
      error_asic = 0;
      avg_num = 0;
      for ( i = 0; i <= 15; ++i )
      {
        if ( dev->chain_exist[i] )
        {
          asic_num += dev->chain_asic_num[i];
          for ( j = 0; dev->chain_asic_num[i] > j; ++j )
          {
            nonce_num[i][j][nonce_times % 60] = dev->chain_asic_nonce[i][j];
            avg_num += LODWORD(dev->chain_asic_nonce[i][j]);
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: chain %d asic %d asic_nonce_num %d",
                (const char *)_FUNCTION___13773,
                i,
                j,
                LODWORD(dev->chain_asic_nonce[i][j]));
              applog(7, tmp42, 0);
            }
          }
        }
      }
      ++nonce_times;
      memset(nonce_num10_string, 0, sizeof(nonce_num10_string));
      memset(nonce_num30_string, 0, sizeof(nonce_num30_string));
      memset(nonce_num60_string, 0, sizeof(nonce_num60_string));
      get_lastn_nonce_num(nonce_num10_string, 10);
      get_lastn_nonce_num(nonce_num30_string, 30);
      get_lastn_nonce_num(nonce_num60_string, 60);
      if ( asic_num )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: avg_num %d asic_num %d",
            (const char *)_FUNCTION___13773,
            avg_num,
            asic_num);
          applog(7, tmp42, 0);
        }
        avg_num = 10;
      }
      else
      {
        avg_num = 1;
      }
      for ( i = 0; i <= 15; ++i )
      {
        if ( dev->chain_exist[i] )
        {
          offset = 0;
          for ( j = 0; dev->chain_asic_num[i] > j; ++j )
          {
            if ( (j & 7) == 0 )
              dev->chain_asic_status_string[i][j + offset++] = 32;
            if ( get_asic_nonce_num(i, j, 1) <= 1 )
            {
              dev->chain_asic_status_string[i][j + offset] = 111;
              if ( !status_error )
                ++x_time[i][j];
            }
            else
            {
              dev->chain_asic_status_string[i][j + offset] = 111;
            }
            v0 = dev;
            v1 = (i << 7) + j + 354;
            *(&dev->pwm_value + 2 * v1) = 0;
            v0->chain_exist[2 * v1] = 0;
          }
          dev->chain_asic_status_string[i][j + offset] = 0;
        }
      }
      if ( run_counter > 60 )
        run_counter = 0;
      copy_time(&tv_start, &tv_end);
    }
    cgsleep_ms(1000);
  }
}

//----- (00042B74) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl enable_core_clock_BM1393(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 chain)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  __int64 buf; // [sp+18h] [bp+18h] OVERLAPPED BYREF
  unsigned int value; // [sp+20h] [bp+20h]
  unsigned int ret; // [sp+24h] [bp+24h]

  BYTE4(buf) = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  LODWORD(buf) = 65;
  if ( mode )
    LOBYTE(buf) = buf | 0x10;
  *(_WORD *)((char *)&buf + 1) = 9;
  strcpy((char *)&buf + 3, "<");
  BYTE5(buf) = core_id;
  HIWORD(buf) = -21884;
  LOBYTE(value) = CRC5((unsigned __int8 *)&buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(buf);
  cmd_buf[1] = _byteswap_ulong(HIDWORD(buf));
  cmd_buf[2] = (unsigned __int8)value << 24;
  set_BC_command_buffer(cmd_buf);
  ret = get_BC_write_command();
  value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
  usleep(0x1388u);
}
// 42B74: variables would overlap: ^18.8 and stkvar "buf" ^18.5(has user info)

//----- (00042C5C) --------------------------------------------------------
void __cdecl open_core_BM1393_pre_open(unsigned __int8 num, unsigned __int8 set)
{
  int dhash_acc_control; // r0
  int v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf_vil[9]; // [sp+874h] [bp+86Ch] BYREF
  unsigned __int8 data[52]; // [sp+880h] [bp+878h] BYREF
  unsigned int buf_vil_tw[13]; // [sp+8B4h] [bp+8ACh] BYREF
  unsigned int buf[13]; // [sp+8E8h] [bp+8E0h] BYREF
  unsigned int cmd_buf[3]; // [sp+91Ch] [bp+914h] BYREF
  unsigned __int8 gateblk[4]; // [sp+928h] [bp+920h]
  unsigned int reg_data; // [sp+92Ch] [bp+924h]
  unsigned int core_index; // [sp+930h] [bp+928h]
  unsigned int core_id; // [sp+934h] [bp+92Ch]
  unsigned int slot; // [sp+938h] [bp+930h]
  unsigned int which_chain; // [sp+93Ch] [bp+934h]
  unsigned int work_fifo_ready; // [sp+940h] [bp+938h]
  unsigned int value; // [sp+944h] [bp+93Ch]
  unsigned int ret; // [sp+948h] [bp+940h]
  unsigned int work_id; // [sp+94Ch] [bp+944h]
  unsigned int j; // [sp+950h] [bp+948h]
  unsigned int loop; // [sp+954h] [bp+94Ch]
  unsigned int m; // [sp+958h] [bp+950h]
  unsigned int i; // [sp+95Ch] [bp+954h]

  i = 0;
  j = 0;
  work_id = 0;
  ret = 0;
  value = 0;
  work_fifo_ready = 0;
  loop = 0;
  which_chain = 0;
  slot = 0;
  core_id = 0;
  core_index = 0;
  reg_data = 0;
  gateblk[0] = 0;
  gateblk[1] = 0;
  gateblk[2] = 0;
  gateblk[3] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  memset(buf, 0, sizeof(buf));
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  *(_DWORD *)data = 255;
  memset(&data[4], 0, 48);
  memset(buf_vil, 0, sizeof(buf_vil));
  printf("\n--- %s\n", (const char *)_FUNCTION___13826);
  if ( set )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | dhash_acc_control & 0xFFFF7FDF | 0x8000);
    set_hash_counting_number(0);
  }
  printf("%s: pre open core = %d\n", (const char *)_FUNCTION___13826, num);
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] == 108 )
    {
      for ( m = 0; m <= 4; ++m )
      {
        for ( loop = 0; num > loop; ++loop )
        {
          enable_core_clock_BM1393(loop, 1u, i);
          usleep(0x3E8u);
          enable_core_clock_BM1393(loop + 52, 1u, i);
          usleep(0x3E8u);
          enable_core_clock_BM1393(loop + 104, 1u, i);
          usleep(0x3E8u);
          enable_core_clock_BM1393(loop - 100, 1u, i);
          usleep(0x3E8u);
        }
        buf_vil_tw[0] = (i << 16) | 0x1000080;
        while ( 1 )
        {
          work_fifo_ready = get_buffer_space();
          if ( (work_fifo_ready & (1 << i)) != 0 )
            break;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: chain%d work fifo not ready: 0x%x\n",
              (const char *)_FUNCTION___13826,
              i,
              work_fifo_ready);
            applog(7, tmp42, 0);
          }
          usleep(0x3E8u);
        }
        set_TW_write_command_vil(buf_vil_tw);
        usleep(0x186A0u);
      }
    }
  }
  if ( set )
  {
    v3 = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | v3 | 0x8000);
  }
  printf("--- %s end\n", (const char *)_FUNCTION___13826);
}

//----- (00043078) --------------------------------------------------------
void __cdecl open_core_bm1393(bool nullwork_enable)
{
  int dhash_acc_control; // r0
  int v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf_vil[9]; // [sp+C74h] [bp+C6Ch] BYREF
  unsigned __int8 data[52]; // [sp+C80h] [bp+C78h] BYREF
  unsigned int buf_vil_tw[13]; // [sp+CB4h] [bp+CACh] BYREF
  unsigned int buf[13]; // [sp+CE8h] [bp+CE0h] BYREF
  unsigned int cmd_buf[3]; // [sp+D1Ch] [bp+D14h] BYREF
  unsigned __int8 gateblk[4]; // [sp+D28h] [bp+D20h]
  int core_index; // [sp+D2Ch] [bp+D24h]
  int wati_count; // [sp+D30h] [bp+D28h]
  unsigned int loop; // [sp+D34h] [bp+D2Ch]
  unsigned int work_fifo_ready; // [sp+D38h] [bp+D30h]
  unsigned int value; // [sp+D3Ch] [bp+D34h]
  unsigned int ret; // [sp+D40h] [bp+D38h]
  unsigned int work_id; // [sp+D44h] [bp+D3Ch]
  unsigned int j; // [sp+D48h] [bp+D40h]
  int slot; // [sp+D4Ch] [bp+D44h]
  int core_id; // [sp+D50h] [bp+D48h]
  unsigned int i; // [sp+D54h] [bp+D4Ch]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "open_core_bm1393");
    applog(5, tmp42, 0);
  }
  i = 0;
  j = 0;
  work_id = 0;
  ret = 0;
  value = 0;
  work_fifo_ready = 0;
  gateblk[0] = 0;
  gateblk[1] = 0;
  gateblk[2] = 0;
  gateblk[3] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  memset(buf, 0, sizeof(buf));
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  *(_DWORD *)data = 255;
  memset(&data[4], 0, 48);
  memset(buf_vil, 0, sizeof(buf_vil));
  wati_count = 0;
  core_id = 0;
  slot = 0;
  core_index = 0;
  loop = 208;
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | dhash_acc_control & 0xFFFF7FDF | 0x8000);
    set_hash_counting_number(0);
    for ( core_id = 0; core_id <= 51; ++core_id )
    {
      for ( i = 0; i <= 0xF; ++i )
      {
        if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] == 108 )
        {
          buf_vil_tw[0] = (i << 16) | 0x1000080;
          for ( slot = 0; slot <= 3; ++slot )
          {
            core_index = 52 * slot + core_id;
            enable_core_clock_BM1393(52 * slot + core_id, 1u, i);
          }
          cgsleep_ms(5);
          while ( 1 )
          {
            work_fifo_ready = get_buffer_space();
            if ( (work_fifo_ready & (1 << i)) != 0 )
              break;
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: chain%d work fifo not ready: 0x%x\n",
                "open_core_bm1393",
                i,
                work_fifo_ready);
              applog(7, tmp42, 0);
            }
            usleep(0x3E8u);
          }
          set_TW_write_command_vil(buf_vil_tw);
          cgsleep_ms(100);
        }
      }
    }
    v2 = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | v2 | 0x8000);
  }
}

//----- (0004345C) --------------------------------------------------------
void __noreturn get_nonce_and_register()
{
  __int16 nonce_number_in_fifo; // r0
  unsigned int v1; // r1
  unsigned int *p_work_id; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  unsigned int buf[2]; // [sp+808h] [bp+800h] BYREF
  unsigned __int8 *buf_hex; // [sp+810h] [bp+808h]
  unsigned int reg_loop_back; // [sp+814h] [bp+80Ch]
  unsigned int reg_reg_value_num; // [sp+818h] [bp+810h]
  unsigned int reg_p_rd; // [sp+81Ch] [bp+814h]
  unsigned int reg_p_wr; // [sp+820h] [bp+818h]
  unsigned int nonce_loop_back; // [sp+824h] [bp+81Ch]
  unsigned int nonce_nonce_num; // [sp+828h] [bp+820h]
  unsigned int nonce_p_rd; // [sp+82Ch] [bp+824h]
  unsigned int nonce_p_wr; // [sp+830h] [bp+828h]
  unsigned __int8 ret; // [sp+837h] [bp+82Fh]
  uint64_t n2l; // [sp+838h] [bp+830h]
  uint64_t n2h; // [sp+840h] [bp+838h]
  unsigned int read_loop; // [sp+84Ch] [bp+844h]
  unsigned int nonce_number; // [sp+850h] [bp+848h]
  unsigned int i; // [sp+854h] [bp+84Ch]
  unsigned int *data_addr; // [sp+858h] [bp+850h]
  unsigned int work_id; // [sp+85Ch] [bp+854h]
  unsigned int m; // [sp+860h] [bp+858h]
  unsigned int j; // [sp+864h] [bp+85Ch]

  work_id = 0;
  data_addr = 0;
  i = 0;
  j = 0;
  m = 0;
  nonce_number = 0;
  read_loop = 0;
  buf[0] = 0;
  buf[1] = 0;
  n2h = 0LL;
  n2l = 0LL;
  ret = 0;
  nonce_p_wr = 0;
  nonce_p_rd = 0;
  nonce_nonce_num = 0;
  nonce_loop_back = 0;
  reg_p_wr = 0;
  reg_p_rd = 0;
  reg_reg_value_num = 0;
  reg_loop_back = 0;
  buf_hex = 0;
  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        cgsleep_ms(1);
        if ( !doTestPatten )
          break;
        cgsleep_ms(100);
      }
      i = 0;
      read_loop = 0;
      nonce_number_in_fifo = get_nonce_number_in_fifo();
      nonce_number = nonce_number_in_fifo & 0x1FF;
    }
    while ( (nonce_number_in_fifo & 0x1FF) == 0 );
    read_loop = nonce_number;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: read_loop = %d\n", (const char *)_FUNCTION___13902, read_loop);
      applog(7, tmp42, 0);
    }
    for ( j = 0; j < read_loop; ++j )
    {
      get_return_nonce(buf);
      if ( (buf[0] & 0x80000000) == 0 )
      {
        if ( reg_value_buf.reg_value_num <= 0x1FE && reg_value_buf.p_wr <= 0x1FE )
        {
          pthread_mutex_lock(&reg_mutex);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = buf[1];
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = HIBYTE(buf[0]) & 0x1F;
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = buf[0] & 0xF;
          if ( reg_value_buf.p_wr > 0x1FD )
            reg_value_buf.p_wr = 0;
          else
            ++reg_value_buf.p_wr;
          if ( reg_value_buf.reg_value_num > 0x1FE )
            reg_value_buf.reg_value_num = 511;
          else
            ++reg_value_buf.reg_value_num;
          pthread_mutex_unlock(&reg_mutex);
        }
        else
        {
          clear_register_value_buf();
        }
      }
      else if ( gBegin_get_nonce && (buf[0] & 0x80) != 0 )
      {
        pthread_mutex_lock(&nonce_mutex);
        work_id = HIWORD(buf[0]) & 0x7FFF;
        data_addr = &nonce2_jobid_address[16 * work_id];
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].work_id = work_id;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].nonce3 = buf[1];
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].chain_num = buf[0] & 0xF;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].job_id = *data_addr;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].header_version = data_addr[1];
        n2h = data_addr[3];
        n2l = data_addr[2];
        v1 = n2h | HIDWORD(n2l);
        p_work_id = &nonce_read_out.nonce_buffer[nonce_read_out.p_wr].work_id;
        p_work_id[2] = n2l;
        p_work_id[3] = v1;
        for ( m = 0; m <= 0x1F; ++m )
          nonce_read_out.nonce_buffer[nonce_read_out.p_wr].midstate[m] = *((_BYTE *)data_addr + m + 32);
        if ( nonce_read_out.p_wr > 0x1FD )
          nonce_read_out.p_wr = 0;
        else
          ++nonce_read_out.p_wr;
        if ( nonce_read_out.nonce_num > 0x1FE )
          nonce_read_out.nonce_num = 511;
        else
          ++nonce_read_out.nonce_num;
        pthread_mutex_unlock(&nonce_mutex);
      }
    }
  }
}

//----- (00043938) --------------------------------------------------------
void set_nonce2_jobid_phy_addr()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  sysinfo si; // [sp+800h] [bp+800h] BYREF

  sysinfo_0(&si);
  if ( si.totalram <= 0x3B9ACA00 )
  {
    if ( si.totalram <= 0x1DCD6500 )
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 251658240;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "Detect 256MB control board of XILINX\n");
        applog(5, tmp42, 0);
      }
    }
    else
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 520093696;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "Detect 512MB control board of XILINX\n");
        applog(5, tmp42, 0);
      }
    }
  }
  else
  {
    PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "Detect 1GB control board of XILINX\n");
      applog(5, tmp42, 0);
    }
  }
}

//----- (00043AA0) --------------------------------------------------------
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; i < length >> 2; ++i )
    *((_DWORD *)dest_p + i) = swab32_0(*((_DWORD *)src_p + i));
}

//----- (00043AF0) --------------------------------------------------------
void __cdecl set_core_cmd_BM1393(core_cmd *core)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp+14h] BYREF
  unsigned int ret; // [sp+24h] [bp+24h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( core )
  {
    buf[0] = 65;
    if ( core->mode )
      buf[0] |= 0x10u;
    buf[1] = 9;
    buf[2] = core->chip_addr;
    strcpy((char *)&buf[3], "<");
    if ( core->core_mode )
      buf[4] = 0x80;
    buf[5] = core->core_id;
    buf[6] = core->cmd_type | (core->rw_falg << 7);
    buf[7] = core->reg_data;
    buf[8] = 0;
    buf[8] = CRC5(buf, 0x40u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
    cmd_buf[2] = buf[8] << 24;
    set_BC_command_buffer(cmd_buf);
    ret = get_BC_write_command();
    set_BC_write_command(ret & 0xFFF0FFFF | (core->chain << 16) | 0x80800000);
  }
}

//----- (00043C08) --------------------------------------------------------
void read_clock_delay_control()
{
  core_cmd core; // [sp+0h] [bp+0h] BYREF
  int i; // [sp+Ch] [bp+Ch]

  *(_DWORD *)&core.chain = 0x1000000;
  *(_DWORD *)&core.core_id = 0;
  core.reg_data = 255;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( dev->chain_asic_num[i] )
      {
        core.chain = i;
        set_core_cmd_BM1393(&core);
        check_core_register = 0;
        check_asic_reg_with_addr(0x40u, 0, i, 208);
      }
    }
  }
}

//----- (00043CB4) --------------------------------------------------------
void read_clock_delay_control_all_chip()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  core_cmd core; // [sp+804h] [bp+804h] BYREF
  int asic; // [sp+810h] [bp+810h]
  int i; // [sp+814h] [bp+814h]

  asic = 0;
  *(_DWORD *)&core.chain = 0x1000000;
  *(_DWORD *)&core.core_id = 0;
  core.reg_data = 255;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      for ( asic = 0; asic <= 59; ++asic )
      {
        clear_register_value_buf();
        core.chain = i;
        core.chip_addr = 2 * asic;
        set_core_cmd_BM1393(&core);
        check_core_register = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "--- read chip[%d] clock delay control ---\n", asic);
          applog(5, tmp42, 0);
        }
        check_asic_reg_with_addr_test(0x40u, 2 * asic, i, 208);
      }
    }
  }
}

//----- (00043E14) --------------------------------------------------------
void read_clock_delay_control_all_chip_one_core()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  core_cmd core; // [sp+804h] [bp+804h] BYREF
  int m; // [sp+810h] [bp+810h]
  int i; // [sp+814h] [bp+814h]

  m = 0;
  core.chain = 0;
  *(_DWORD *)&core.core_id = 0;
  memset(core_hash_clock_delay_control, 255, sizeof(core_hash_clock_delay_control));
  core.chip_addr = 0;
  core.mode = 1;
  core.core_mode = 0;
  core.reg_data = 255;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      for ( m = 0; m <= 207; ++m )
      {
        clear_register_value_buf();
        core.core_id = m;
        core.chain = i;
        set_core_cmd_BM1393(&core);
        check_core_register = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "--- read all chip core[%d] clock delay control ---\n", m);
          applog(5, tmp42, 0);
        }
        check_asic_reg_with_addr_test(0x40u, 0, i, 108);
      }
    }
  }
}

//----- (00043F74) --------------------------------------------------------
void set_clock_delay_control()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  core_cmd core; // [sp+808h] [bp+800h] BYREF
  unsigned __int8 core_data; // [sp+816h] [bp+80Eh]
  unsigned __int8 i; // [sp+817h] [bp+80Fh]

  *(_DWORD *)&core.chain = 16842752;
  *(_DWORD *)&core.core_id = 0x10000;
  g_Clock_delay_control |= 2u;
  core_data = g_Clock_delay_control;
  core.reg_data = g_Clock_delay_control;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "in %s, core_data = 0x%02x", (const char *)_FUNCTION___13977, core_data);
    applog(5, tmp42, 0);
  }
  for ( i = 0; i <= 0xFu; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( dev->chain_asic_num[i] )
      {
        core.chain = i;
        set_core_cmd_BM1393(&core);
      }
    }
  }
}

//----- (000440AC) --------------------------------------------------------
void __cdecl set_core_clock_sel(unsigned __int8 chain, unsigned __int8 sel_index)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  core_cmd core; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 core_data; // [sp+81Fh] [bp+817h]

  *(_DWORD *)&core.chain = 16842752;
  *(_DWORD *)&core.core_id = 67328;
  core_data = sel_index & 0xF;
  core.reg_data = sel_index & 0xF;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "in %s, core_data = 0x%02x", (const char *)_FUNCTION___13989, core_data);
    applog(5, tmp42, 0);
  }
  core.chain = chain;
  set_core_cmd_BM1393(&core);
}

//----- (00044190) --------------------------------------------------------
void __cdecl rewrite_clock_delay_control(
        unsigned __int8 chain,
        unsigned __int8 chip_addr,
        unsigned __int8 core_id,
        unsigned __int8 core_data)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  core_cmd core; // [sp+81Ch] [bp+80Ch] BYREF

  memset(&core, 0, sizeof(core));
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "rewirte chain %d chip %d core %d clock delay, data=%d",
      chain,
      chip_addr,
      core_id,
      core_data);
    applog(5, tmp42, 0);
  }
  core.chip_addr = chip_addr;
  core.mode = 0;
  core.core_mode = 0;
  core.core_id = core_id;
  core.cmd_type = 0;
  core.reg_data = core_data;
  core.rw_falg = 1;
  core.chain = chain;
  set_core_cmd_BM1393(&core);
}

//----- (00044278) --------------------------------------------------------
unsigned __int8 __cdecl c2hex(unsigned __int8 value)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 ret; // [sp+80Fh] [bp+80Fh]

  ret = -1;
  if ( value > 0x2Fu && value <= 0x39u )
    return value & 0xF;
  switch ( value )
  {
    case 'a':
    case 'A':
      return 10;
    case 'b':
    case 'B':
      return 11;
    case 'c':
    case 'C':
      return 12;
    case 'd':
    case 'D':
      return 13;
    case 'e':
    case 'E':
      return 14;
    case 'f':
    case 'F':
      return 15;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "input value error: %c\n", value);
    applog(3, tmp42, 0);
  }
  return ret;
}

//----- (0004439C) --------------------------------------------------------
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  unsigned __int8 higha; // [sp+7h] [bp+7h]

  higha = c2hex(high);
  return c2hex(low) ^ (16 * higha);
}

//----- (000443E0) --------------------------------------------------------
int __cdecl s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 low; // [sp+81Ah] [bp+812h]
  unsigned __int8 high; // [sp+81Bh] [bp+813h]
  int p; // [sp+81Ch] [bp+814h]
  int len; // [sp+820h] [bp+818h]
  int i; // [sp+824h] [bp+81Ch]

  i = 0;
  len = 0;
  p = 0;
  if ( src && inlen > 0 && dst )
  {
    len = inlen / 2;
    p = inlen % 2;
    for ( i = 0; i < len; ++i )
    {
      high = src[2 * i];
      low = src[2 * i + 1];
      dst[i] = twoc2hex(high, low);
    }
    if ( p )
      dst[i] = twoc2hex(src[2 * i], 0);
    return len + p;
  }
  else
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "s2hex para error dst(%p), src(%p), inlen(%d)\n", dst, src, inlen);
      applog(7, tmp42, 0);
    }
    return -1;
  }
}

//----- (00044578) --------------------------------------------------------
int __cdecl get_work_of_core(int which_asic, int which_core, FILE *stream, int count)
{
  unsigned int v4; // r0
  unsigned __int8 str[1024]; // [sp+14h] [bp+14h] BYREF
  SCAN_FREQ_WORK *new_work; // [sp+414h] [bp+414h]
  int m; // [sp+418h] [bp+418h]
  int core_num; // [sp+41Ch] [bp+41Ch]
  unsigned int subid; // [sp+420h] [bp+420h]
  unsigned __int8 *temp; // [sp+424h] [bp+424h]

  memset(str, 0, sizeof(str));
  subid = 0;
  core_num = 0;
  m = 0;
  while ( 1 )
  {
    if ( !fgets((char *)str, 1023, stream) || count <= subid )
      return subid;
    new_work = &scanfreq_info.works[which_asic][count * which_core + subid];
    temp = (unsigned __int8 *)strstr((const char *)str, "nonce");
    if ( !temp )
      break;
    for ( temp += 5; *temp == 32; ++temp )
      ;
    s2hex((unsigned __int8 *)&new_work->nonce, temp, 8);
    v4 = htonl(new_work->nonce);
    new_work->nonce = v4;
    temp = (unsigned __int8 *)strstr((const char *)str, "midstate");
    if ( !temp )
      break;
    for ( temp += 8; *temp == 32; ++temp )
      ;
    s2hex(new_work->midstate, temp, 64);
    temp = (unsigned __int8 *)strstr((const char *)str, "data");
    if ( !temp )
      break;
    for ( temp += 4; *temp == 32; ++temp )
      ;
    s2hex(new_work->data, temp, 24);
    memset(new_work->is_nonce_return_back, 0, sizeof(new_work->is_nonce_return_back));
    new_work->id = subid++;
  }
  free(new_work);
  puts("get work err");
  return subid;
}

//----- (00044784) --------------------------------------------------------
int scanfreq_get_works()
{
  int v1; // r4
  int work_of_core; // r0
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  unsigned __int8 strFilePath[64]; // [sp+80Ch] [bp+804h] BYREF
  int AsicNum; // [sp+84Ch] [bp+844h]
  int CoreNum; // [sp+850h] [bp+848h]
  int asic_work_num; // [sp+854h] [bp+84Ch]
  int j; // [sp+858h] [bp+850h]
  int i; // [sp+85Ch] [bp+854h]

  memset(strFilePath, 0, sizeof(strFilePath));
  asic_work_num = 0;
  CoreNum = scanfreq_info.CoreNum;
  AsicNum = scanfreq_info.AsicNum;
  i = 0;
  while ( 2 )
  {
    if ( i >= AsicNum )
      return 0;
    asic_work_num = 0;
    scanfreq_info.works[i] = (SCAN_FREQ_WORK *)malloc(116 * scanfreq_info.AsicWorkCount);
    if ( scanfreq_info.works[i] )
    {
      for ( j = 0; j < CoreNum; ++j )
      {
        sprintf(
          (char *)strFilePath,
          "%s%02i%s%02i.txt",
          (const char *)scanfreq_info.workdataPathPrefix,
          i,
          (const char *)scanfreq_info.workdataFilePrefix,
          j);
        v1 = CoreNum * i + j;
        scanfreq_info.fps[v1] = fopen((const char *)strFilePath, "r");
        if ( !*((_DWORD *)&scanfreq_info.fps[CoreNum * i] + j) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "Open test file %s error\n", (const char *)strFilePath);
            applog(5, tmp42, 0);
          }
          return -1;
        }
        work_of_core = get_work_of_core(
                         i,
                         j,
                         *(&scanfreq_info.fps[CoreNum * i] + j),
                         scanfreq_info.AsicWorkCount / CoreNum);
        asic_work_num += work_of_core;
        fclose(*(&scanfreq_info.fps[CoreNum * i] + j));
      }
      if ( scanfreq_info.AsicWorkCount <= asic_work_num )
      {
        ++i;
        continue;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Error: Asic %d get %d work, required work=%d\n",
          i,
          asic_work_num,
          scanfreq_info.AsicWorkCount);
        applog(5, tmp42, 0);
      }
      return -1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "malloc struct work err\n");
        applog(5, tmp42, 0);
      }
      return -1;
    }
  }
}

//----- (00044A7C) --------------------------------------------------------
void __cdecl scanfreq_set_voltage(int voltage)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      *(_DWORD *)&scanfreq_info.chain_max_pcb_temp[2 * i - 32] = voltage;
      pthread_mutex_unlock(&iic_mutex);
      printf("Chain[%d] read pic voltage=%d\n", i, voltage);
      pthread_mutex_lock(&iic_mutex);
      set_voltage_T9_18_into_PIC(i, voltage);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00044B20) --------------------------------------------------------
void __cdecl scanfreq_set_voltage_75j(int voltage)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( voltage <= 1709 || voltage > 2009 )
    printf("wrong vol setting,[%d]", voltage);
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      *(_DWORD *)&scanfreq_info.chain_max_pcb_temp[2 * i - 32] = voltage;
      pthread_mutex_unlock(&iic_mutex);
      printf("Chain[%d] read pic voltage=%d\n", i, voltage);
      pthread_mutex_lock(&iic_mutex);
      set_voltage_s11_into_PIC(i, voltage);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00044BE4) --------------------------------------------------------
void __cdecl scanfreq_set_voltage_without_disable(int voltage)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      *(_DWORD *)&scanfreq_info.chain_max_pcb_temp[2 * i - 32] = voltage;
      pthread_mutex_unlock(&iic_mutex);
      printf("Chain[%d] read pic voltage=%d\n", i, voltage);
      pthread_mutex_lock(&iic_mutex);
      set_voltage_T9_18_into_PIC_without_disable(i, voltage);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00044C88) --------------------------------------------------------
void __cdecl scanfreq_set_voltage_without_disable_75j(int voltage)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( voltage <= 1709 || voltage > 2009 )
    printf("wrong vol setting,[%d]", voltage);
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      *(_DWORD *)&scanfreq_info.chain_max_pcb_temp[2 * i - 32] = voltage;
      pthread_mutex_unlock(&iic_mutex);
      printf("Chain[%d] read pic voltage=%d\n", i, voltage);
      pthread_mutex_lock(&iic_mutex);
      set_voltage_s11_into_PIC_without_disable(i, voltage);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00044D4C) --------------------------------------------------------
int __cdecl decrease_voltage_75j(unsigned __int8 which_chain, int opencore_vol, int target_vol, int step)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+10h] BYREF
  int diff; // [sp+810h] [bp+810h]
  int tmp_vol; // [sp+814h] [bp+814h]

  tmp_vol = opencore_vol;
  if ( opencore_vol > 1709 && tmp_vol <= 2009 && target_vol > 1709 && target_vol <= 2009 )
  {
    pthread_mutex_lock(&iic_mutex);
    while ( 1 )
    {
      diff = (tmp_vol - target_vol) / 2;
      tmp_vol -= diff;
      sleep(3u);
      if ( diff <= 2 )
        break;
      set_voltage_s11_into_PIC_without_disable(which_chain, tmp_vol);
      printf("the vol is %d...\n", tmp_vol);
    }
    set_voltage_s11_into_PIC_without_disable(which_chain, target_vol);
    printf("the final vol is %d\n", target_vol);
    pthread_mutex_unlock(&iic_mutex);
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "error: input vol is not right [1710,2009], restart program please!");
      applog(5, tmp42, 0);
    }
    return -1;
  }
}

//----- (00044EA0) --------------------------------------------------------
void scanfreq_init_pic()
{
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      dsPIC33EP16GS202_reset_pic(i);
      pthread_mutex_unlock(&iic_mutex);
      cgsleep_ms(100);
      pthread_mutex_lock(&iic_mutex);
      dsPIC33EP16GS202_jump_to_app_from_loader(i);
      pthread_mutex_unlock(&iic_mutex);
      cgsleep_ms(100);
      pthread_mutex_lock(&iic_mutex);
      dsPIC33EP16GS202_enable_pic_dc_dc(i, 0);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00044F4C) --------------------------------------------------------
void scanfreq_check_asic_num()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int retry_count; // [sp+808h] [bp+800h]
  int i; // [sp+80Ch] [bp+804h]

  check_asic_reg(0);
  cgsleep_ms(10);
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      retry_count = 0;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Chain[J%d] has %d asic\n", i, dev->chain_asic_num[i]);
        applog(5, tmp42, 0);
      }
      while ( dev->chain_asic_num[i] != 108 && retry_count <= 5 )
      {
        dev->chain_asic_num[i] = 0;
        set_reset_hashboard(i, 1);
        pthread_mutex_lock(&iic_mutex);
        dsPIC33EP16GS202_enable_pic_dc_dc(i, 0);
        pthread_mutex_unlock(&iic_mutex);
        sleep(1u);
        pthread_mutex_lock(&iic_mutex);
        dsPIC33EP16GS202_enable_pic_dc_dc(i, 1u);
        pthread_mutex_unlock(&iic_mutex);
        sleep(2u);
        set_reset_hashboard(i, 0);
        sleep(1u);
        check_asic_reg_oneChain(i, 0);
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "retry Chain[J%d] has %d asic\n", i, dev->chain_asic_num[i]);
          applog(5, tmp42, 0);
        }
        ++retry_count;
      }
      if ( !dev->chain_asic_num[i] )
        dev->chain_exist[i] = 0;
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] && (use_syslog || opt_log_output || opt_log_level > 4) )
    {
      snprintf((char *)tmp42, 0x800u, "Chain%d has %d ASICs", i + 1, dev->chain_asic_num[i]);
      applog(5, tmp42, 0);
    }
  }
}

//----- (00045210) --------------------------------------------------------
void check_domain_volt()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int ret; // [sp+80Ch] [bp+804h]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "in %s @line %d", (const char *)_FUNCTION___14178, 8345);
    applog(5, tmp42, 0);
  }
  while ( 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "in %s @line %d==========prress enter to continue==========",
        (const char *)_FUNCTION___14178,
        8349);
      applog(5, tmp42, 0);
    }
    ret = getchar();
    if ( ret == 10 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "in %s @line %d==========prress enter to continue==========",
        (const char *)_FUNCTION___14178,
        8352);
      applog(5, tmp42, 0);
    }
    usleep((__useconds_t)&nonce_num[6][85][45]);
  }
}

//----- (0004534C) --------------------------------------------------------
int __cdecl get_index_from_high_pll_yf(int freq)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  for ( i = 0;
        (unsigned int)i <= 0x25
     && freq_high_pll_1385[i].freq != freq
     && (freq_high_pll_1385[i].freq <= freq || freq_high_pll_1385[i - 1].freq >= freq);
        ++i )
  {
    ;
  }
  if ( i != 38 )
    return i;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "high freq index set error,return default pll index");
    applog(3, tmp42, 0);
  }
  return get_index_from_high_pll_yf(200);
}

//----- (0004545C) --------------------------------------------------------
int __cdecl get_index_from_pll_B1393(int pll)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  for ( i = 0; (unsigned int)i <= 0xB2 && freq_pll_1393_0[i].freq != pll; ++i )
    ;
  if ( i != 179 )
    return i;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "freq index set error,return default pll index");
    applog(3, tmp42, 0);
  }
  return get_index_from_pll_B1393(200);
}

//----- (00045518) --------------------------------------------------------
void __cdecl get_plldata_from_index(int index, unsigned __int8 *vil_pll)
{
  size_t v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 plldivider1[32]; // [sp+808h] [bp+808h] BYREF

  memset(plldivider1, 0, sizeof(plldivider1));
  if ( (unsigned int)index > 0xB2 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "freq set error");
      applog(3, tmp42, 0);
    }
    exit(0);
  }
  sprintf((char *)plldivider1, "%08x", freq_pll_1393_0[index].vilpll);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "vil pll data:%s", (const char *)plldivider1);
    applog(5, tmp42, 0);
  }
  v2 = strlen((const char *)plldivider1);
  if ( !hex2bin(vil_pll, plldivider1, v2 >> 1) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "hex2bin failed in %s", (const char *)_FUNCTION___14210);
      applog(4, tmp42, 0);
    }
    exit(-1);
  }
}

//----- (000456CC) --------------------------------------------------------
int __cdecl get_pllparam_divider(float freq, unsigned int *pll_param, unsigned __int8 *divider, float *pll_freq)
{
  float v4; // s0
  unsigned __int8 tmp42[2048]; // [sp+34h] [bp+14h] BYREF
  float real_freq; // [sp+834h] [bp+814h]
  unsigned int postdiv_i_0; // [sp+838h] [bp+818h]
  float postdiv_f_0; // [sp+83Ch] [bp+81Ch]
  unsigned int postdiv_i; // [sp+840h] [bp+820h]
  float postdiv_f; // [sp+844h] [bp+824h]
  unsigned __int8 post_div_choice; // [sp+84Bh] [bp+82Bh]
  float decimals; // [sp+84Ch] [bp+82Ch]
  unsigned int pll_out_div_i; // [sp+850h] [bp+830h]
  float pll_out_div_f; // [sp+854h] [bp+834h]
  unsigned __int8 fbdiv; // [sp+85Ah] [bp+83Ah]
  unsigned __int8 refdiv; // [sp+85Bh] [bp+83Bh]
  float min_vco; // [sp+85Ch] [bp+83Ch]
  float max_vco; // [sp+860h] [bp+840h]
  bool need_recal; // [sp+867h] [bp+847h]
  float decimals_last; // [sp+868h] [bp+848h]
  unsigned __int8 postdiv; // [sp+86Eh] [bp+84Eh]
  unsigned __int8 pll_div; // [sp+86Fh] [bp+84Fh]
  unsigned __int8 postdiv2; // [sp+870h] [bp+850h]
  unsigned __int8 postdiv1; // [sp+871h] [bp+851h]
  unsigned __int8 refdiv_choice; // [sp+872h] [bp+852h]
  unsigned __int8 fbdiv_choice; // [sp+873h] [bp+853h]
  float pll_vco_step; // [sp+874h] [bp+854h]
  float pll_vco_choice; // [sp+878h] [bp+858h]
  float pll_vco; // [sp+87Ch] [bp+85Ch]

  postdiv1 = 1;
  postdiv2 = 1;
  pll_div = 1;
  decimals_last = 25.0;
  max_vco = 3200.0;
  min_vco = 2000.0;
  need_recal = 0;
  pll_vco = 3200.0;
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        if ( pll_vco >= 3125.0 )
          pll_vco_step = 25.0;
        else
          pll_vco_step = 12.5;
        if ( need_recal )
        {
          pll_vco = pll_vco_choice - pll_vco_step;
          need_recal = 0;
          decimals_last = 25.0;
        }
        refdiv = (unsigned int)(float)(25.0 / pll_vco_step);
        fbdiv = (unsigned int)(float)((float)((float)refdiv * pll_vco) / 25.0);
        pll_out_div_f = pll_vco / v4;
        pll_out_div_i = (unsigned int)(float)(pll_vco / v4);
        decimals = (float)(pll_vco / v4) - (float)pll_out_div_i;
        if ( decimals < decimals_last )
        {
          postdiv = pll_out_div_i;
          pll_vco_choice = pll_vco;
          fbdiv_choice = fbdiv;
          refdiv_choice = refdiv;
          decimals_last = decimals;
          post_div_choice = pll_out_div_i;
        }
        pll_vco = pll_vco - pll_vco_step;
      }
      while ( pll_vco >= min_vco );
      if ( postdiv <= 0x10u )
      {
        pll_div = postdiv;
        postdiv2 = 1;
        postdiv1 = 1;
LABEL_55:
        real_freq = (float)((float)(25.0 / (float)refdiv_choice) * (float)fbdiv_choice)
                  / (float)(pll_div * postdiv2 * postdiv1);
        if ( divider )
          *(float *)divider = (float)((float)(25.0 / (float)refdiv_choice) * (float)fbdiv_choice)
                            / (float)(postdiv2 * postdiv1);
        *(_DWORD *)LODWORD(freq) = postdiv2 | (fbdiv_choice << 16) | (refdiv_choice << 8) | (16 * postdiv1);
        *(_BYTE *)pll_param = pll_div;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Want freq %f  real freq %f", v4, real_freq);
          applog(5, tmp42, 0);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "pll_vco %f, fbdiv %#x refdiv %#x postdiv1 %#x postdiv2 %#x, pll_divider %d ,{pll_value %#x}",
            pll_vco_choice,
            fbdiv_choice,
            refdiv_choice,
            postdiv1,
            postdiv2,
            *(unsigned __int8 *)pll_param,
            *(_DWORD *)LODWORD(freq));
          applog(5, tmp42, 0);
        }
        return 0;
      }
      pll_div = 16;
      while ( pll_div-- > 2u )
      {
        postdiv_f = (float)postdiv / (float)pll_div;
        postdiv_i = (unsigned int)postdiv_f;
        decimals = postdiv_f - (float)(unsigned int)postdiv_f;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "pll_div decimals %f postdiv_f %f", decimals, postdiv_f);
          applog(7, tmp42, 0);
        }
        if ( decimals < 0.0001 )
        {
          postdiv /= pll_div;
          break;
        }
      }
      if ( pll_div != 2 || (postdiv & 1) == 0 )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "need recal 1");
        applog(5, tmp42, 0);
      }
      if ( pll_vco_choice <= min_vco )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "!!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll");
          applog(3, tmp42, 0);
        }
        *(_DWORD *)LODWORD(freq) = 7864593;
        *(_BYTE *)pll_param = 15;
        return -1;
      }
      pll_vco = pll_vco_choice;
      need_recal = 1;
    }
    if ( postdiv <= 7u )
    {
      postdiv1 = postdiv;
      postdiv2 = 1;
      goto LABEL_55;
    }
    postdiv1 = 7;
    postdiv2 = 1;
    while ( postdiv1-- != 0 )
    {
      postdiv_f_0 = (float)postdiv / (float)postdiv1;
      postdiv_i_0 = (unsigned int)postdiv_f_0;
      decimals = postdiv_f_0 - (float)(unsigned int)postdiv_f_0;
      if ( decimals < 0.0001 )
      {
        postdiv2 = (unsigned int)postdiv_f_0;
        break;
      }
    }
    if ( postdiv1 >= (unsigned int)postdiv2 && postdiv2 <= 7u )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "need recal 2");
      applog(5, tmp42, 0);
    }
    if ( pll_vco_choice <= min_vco )
      break;
    pll_vco = pll_vco_choice;
    need_recal = 1;
  }
  if ( postdiv == postdiv2 * postdiv1 )
    goto LABEL_55;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "Don't find postdiv1 %d * postdiv2 %d = postdiv %d", postdiv1, postdiv2, postdiv);
    applog(3, tmp42, 0);
  }
  *(_DWORD *)LODWORD(freq) = 7864593;
  *(_BYTE *)pll_param = 15;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "!!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll");
    applog(3, tmp42, 0);
  }
  return -1;
}
// 45804: variable 'v4' is possibly undefined

//----- (00045F4C) --------------------------------------------------------
void __cdecl set_config_BM1393(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 mode,
        unsigned __int8 reg,
        unsigned int reg_data)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp+14h] BYREF
  unsigned int value; // [sp+20h] [bp+20h]
  unsigned int ret; // [sp+24h] [bp+24h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    buf[0] = 81;
  else
    buf[0] = 65;
  buf[1] = 9;
  buf[2] = chip_addr;
  buf[3] = reg;
  buf[4] = HIBYTE(reg_data);
  buf[5] = BYTE2(reg_data);
  buf[6] = BYTE1(reg_data);
  buf[7] = reg_data;
  if ( reg == 20 )
    ret = bit_swap_table[reg];
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  set_BC_command_buffer_t(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (which_chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (00046054) --------------------------------------------------------
void __cdecl change_high_pll_test(unsigned __int8 chain, float freq, int index)
{
  float v3; // s0
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF
  unsigned __int8 divider; // [sp+833h] [bp+813h] BYREF
  float pll_freq; // [sp+834h] [bp+814h] BYREF
  unsigned int vil_pll_t; // [sp+838h] [bp+818h] BYREF
  unsigned __int8 vil_pll[4]; // [sp+83Ch] [bp+81Ch]
  unsigned int pll_index; // [sp+840h] [bp+820h]
  unsigned int pll; // [sp+844h] [bp+824h]

  divider = freq_high_pll_1385[LODWORD(freq)].divider;
  pll = freq_high_pll_1385[LODWORD(freq)].pll_out;
  pll_index = 0;
  get_pllparam_divider(COERCE_FLOAT(&vil_pll_t), (unsigned int *)&divider, (unsigned __int8 *)&pll_freq, &pll_freq);
  *(_DWORD *)vil_pll = (vil_pll_t << 24) | HIBYTE(vil_pll_t) | ((vil_pll_t & 0xFF0000) >> 8) | ((vil_pll_t & 0xFF00) << 8);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "set freq %f, divider %d, vil_pll %02x%02x%02x%02x",
      v3,
      divider,
      vil_pll[0],
      vil_pll[1],
      vil_pll[2],
      vil_pll[3]);
    applog(5, tmp42, 0);
  }
  set_config_BM1393(chain, 0, 1u, 0x70u, divider - 1);
  set_config_BM1393(chain, 0, 1u, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_config_BM1393(chain, 0, 1u, 0x70u, divider - 1);
  set_config_BM1393(chain, 0, 1u, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
}
// 46146: variable 'v3' is possibly undefined

//----- (0004621C) --------------------------------------------------------
void __cdecl change_high_pll_by_pll_no(unsigned __int8 chain, float freq, int pll_no)
{
  float v3; // s0
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF
  unsigned __int8 divider; // [sp+833h] [bp+813h] BYREF
  float pll_freq; // [sp+834h] [bp+814h] BYREF
  unsigned int vil_pll_t; // [sp+838h] [bp+818h] BYREF
  unsigned __int8 vil_pll[4]; // [sp+83Ch] [bp+81Ch]
  unsigned int pll; // [sp+840h] [bp+820h]
  int local_pll_index; // [sp+844h] [bp+824h]
  unsigned int pll_index; // [sp+848h] [bp+828h]
  unsigned __int8 para_reg; // [sp+84Eh] [bp+82Eh]
  unsigned __int8 divider_reg; // [sp+84Fh] [bp+82Fh]

  pll_index = 0;
  local_pll_index = get_index_from_high_pll_yf((int)v3);
  divider = freq_high_pll_1385[local_pll_index].divider;
  pll = freq_high_pll_1385[local_pll_index].pll_out;
  get_pllparam_divider(COERCE_FLOAT(&vil_pll_t), (unsigned int *)&divider, (unsigned __int8 *)&pll_freq, &pll_freq);
  *(_DWORD *)vil_pll = (vil_pll_t << 24) | HIBYTE(vil_pll_t) | ((vil_pll_t & 0xFF0000) >> 8) | ((vil_pll_t & 0xFF00) << 8);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "set freq %f, pll_no %d, divider %d, vil_pll %02x%02x%02x%02x",
      v3,
      freq,
      divider,
      vil_pll[0],
      vil_pll[1],
      vil_pll[2],
      vil_pll[3]);
    applog(5, tmp42, 0);
  }
  if ( freq == 0.0 )
  {
    divider_reg = 112;
    para_reg = 8;
  }
  else
  {
    divider_reg = 124;
    para_reg = 104;
  }
  set_config_BM1393(chain, 0, 1u, divider_reg, divider - 1);
  set_config_BM1393(chain, 0, 1u, para_reg, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_config_BM1393(chain, 0, 1u, divider_reg, divider - 1);
  set_config_BM1393(chain, 0, 1u, para_reg, _byteswap_ulong(*(unsigned int *)vil_pll));
}
// 4624E: variable 'v3' is possibly undefined

//----- (00046430) --------------------------------------------------------
void __cdecl set_freq_by_chip(unsigned __int8 chain, unsigned __int8 chip_addr, float freq)
{
  float v3; // s0
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 divider; // [sp+81Fh] [bp+80Fh]
  unsigned __int8 vil_pll[4]; // [sp+828h] [bp+818h] BYREF
  unsigned int pll_index; // [sp+82Ch] [bp+81Ch]
  unsigned int pll; // [sp+830h] [bp+820h]
  int index; // [sp+834h] [bp+824h]

  index = get_index_from_high_pll_yf((int)v3);
  divider = freq_high_pll_1385[index].divider;
  pll = freq_high_pll_1385[index].pll_out;
  pll_index = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "chain %d chip %d set freq %d, pll_out %d",
      chain,
      chip_addr,
      freq_high_pll_1385[index].freq,
      pll);
    applog(5, tmp42, 0);
  }
  pll_index = get_index_from_pll_B1393(pll);
  get_plldata_from_index(pll_index, vil_pll);
  set_config_BM1393(chain, chip_addr, 0, 0x70u, divider - 1);
  usleep(0x1388u);
  set_config_BM1393(chain, chip_addr, 0, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
}
// 46458: variable 'v3' is possibly undefined

//----- (000465A4) --------------------------------------------------------
void __cdecl set_freq_yf(float freq)
{
  float v1; // s0
  int v2; // r2
  int local_pll_index; // [sp+8h] [bp+8h]
  int chain; // [sp+Ch] [bp+Ch]

  local_pll_index = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      v2 = chain;
      if ( !scanfreq_info.scan_finished[chain] )
      {
        if ( gUsePllList )
          local_pll_index = get_index_from_high_pll_yf((int)v1);
        change_high_pll_test(chain, *(float *)&local_pll_index, v2);
        open_core_BM1393_S11_single_board(chain);
      }
    }
  }
}
// 46602: variable 'v1' is possibly undefined
// 46616: variable 'v2' is possibly undefined

//----- (00046638) --------------------------------------------------------
void __cdecl set_freq_switch_two_pll(float freq, float nextfreq)
{
  float v2; // s0
  float v3; // s1
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int chain; // [sp+81Ch] [bp+80Ch]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "\n\nset_freq_switch_two_pll  curr freq %.2fM , next %.2fM\n", v2, v3);
    applog(5, tmp42, 0);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
    {
      if ( current_pll_14334[chain] )
      {
        if ( current_pll_14334[chain] == 1 )
        {
          current_pll_14334[chain] = 2;
          set_core_clock_sel(chain, 4u);
          change_high_pll_by_pll_no(chain, 0.0, (unsigned __int8)chain);
        }
        else if ( current_pll_14334[chain] == 2 )
        {
          current_pll_14334[chain] = 1;
          set_core_clock_sel(chain, 0);
          change_high_pll_by_pll_no(chain, COERCE_FLOAT(1), (unsigned __int8)chain);
        }
      }
      else
      {
        current_pll_14334[chain] = 1;
        change_high_pll_by_pll_no(chain, 0.0, (unsigned __int8)chain);
        change_high_pll_by_pll_no(chain, COERCE_FLOAT(1), (unsigned __int8)chain);
        set_core_clock_sel(chain, 0);
      }
    }
  }
}
// 4668E: variable 'v2' is possibly undefined
// 46692: variable 'v3' is possibly undefined

//----- (00046804) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl set_core_clock_delay_control_one_chain(
        unsigned __int8 core_id,
        unsigned __int8 mode,
        unsigned __int8 data,
        int chain)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  __int64 buf; // [sp+18h] [bp+18h] OVERLAPPED BYREF
  unsigned int value; // [sp+20h] [bp+20h]

  BYTE4(buf) = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  LODWORD(buf) = 65;
  if ( mode )
    LOBYTE(buf) = buf | 0x10;
  *(_WORD *)((char *)&buf + 1) = 9;
  strcpy((char *)&buf + 3, "<");
  BYTE5(buf) = core_id;
  BYTE6(buf) = 0x80;
  HIBYTE(buf) = data;
  LOBYTE(value) = CRC5((unsigned __int8 *)&buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(buf);
  cmd_buf[1] = _byteswap_ulong(HIDWORD(buf));
  cmd_buf[2] = (unsigned __int8)value << 24;
  set_BC_command_buffer(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
}
// 46804: variables would overlap: ^18.8 and stkvar "buf" ^18.5(has user info)

//----- (000468E8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl enable_core_clock_BM1390(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 chain)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  __int64 buf; // [sp+18h] [bp+18h] OVERLAPPED BYREF
  unsigned int value; // [sp+20h] [bp+20h]
  unsigned int ret; // [sp+24h] [bp+24h]

  BYTE4(buf) = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  LODWORD(buf) = 65;
  if ( mode )
    LOBYTE(buf) = buf | 0x10;
  *(_WORD *)((char *)&buf + 1) = 9;
  strcpy((char *)&buf + 3, "<");
  BYTE5(buf) = core_id;
  HIWORD(buf) = -21884;
  LOBYTE(value) = CRC5((unsigned __int8 *)&buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(buf);
  cmd_buf[1] = _byteswap_ulong(HIDWORD(buf));
  cmd_buf[2] = (unsigned __int8)value << 24;
  set_BC_command_buffer(cmd_buf);
  ret = get_BC_write_command();
  value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
  usleep(0x1388u);
}
// 468E8: variables would overlap: ^18.8 and stkvar "buf" ^18.5(has user info)

//----- (000469D0) --------------------------------------------------------
void __cdecl open_core_BM1393_pre_open_yf(unsigned __int8 num, int chain)
{
  int dhash_acc_control; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf_vil[9]; // [sp+874h] [bp+86Ch] BYREF
  unsigned __int8 data[52]; // [sp+880h] [bp+878h] BYREF
  unsigned int buf_vil_tw[13]; // [sp+8B4h] [bp+8ACh] BYREF
  unsigned int buf[13]; // [sp+8E8h] [bp+8E0h] BYREF
  unsigned int cmd_buf[3]; // [sp+91Ch] [bp+914h] BYREF
  unsigned __int8 gateblk[4]; // [sp+928h] [bp+920h]
  unsigned int reg_data; // [sp+92Ch] [bp+924h]
  unsigned int core_index; // [sp+930h] [bp+928h]
  unsigned int core_id; // [sp+934h] [bp+92Ch]
  unsigned int slot; // [sp+938h] [bp+930h]
  unsigned int which_chain; // [sp+93Ch] [bp+934h]
  unsigned int work_fifo_ready; // [sp+940h] [bp+938h]
  unsigned int value; // [sp+944h] [bp+93Ch]
  unsigned int ret; // [sp+948h] [bp+940h]
  unsigned int work_id; // [sp+94Ch] [bp+944h]
  unsigned int j; // [sp+950h] [bp+948h]
  unsigned int i; // [sp+954h] [bp+94Ch]
  unsigned int loop; // [sp+958h] [bp+950h]
  unsigned int m; // [sp+95Ch] [bp+954h]

  i = 0;
  j = 0;
  work_id = 0;
  ret = 0;
  value = 0;
  work_fifo_ready = 0;
  loop = 0;
  which_chain = 0;
  slot = 0;
  core_id = 0;
  core_index = 0;
  reg_data = 0;
  gateblk[0] = 0;
  gateblk[1] = 0;
  gateblk[2] = 0;
  gateblk[3] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  memset(buf, 0, sizeof(buf));
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  *(_DWORD *)data = 255;
  memset(&data[4], 0, 48);
  memset(buf_vil, 0, sizeof(buf_vil));
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFDF);
  set_hash_counting_number(0);
  printf("%s: pre open core = %d\n", (const char *)_FUNCTION___14387, num);
  for ( m = 0; m <= 4; ++m )
  {
    for ( loop = 0; num > loop; ++loop )
    {
      enable_core_clock_BM1390(loop, 1u, chain);
      usleep(0x3E8u);
      enable_core_clock_BM1390(loop + 52, 1u, chain);
      usleep(0x3E8u);
      enable_core_clock_BM1390(loop + 104, 1u, chain);
      usleep(0x3E8u);
      enable_core_clock_BM1390(loop - 100, 1u, chain);
      usleep(0x3E8u);
    }
    buf_vil_tw[0] = ((unsigned __int8)chain << 16) | 0x1000080;
    while ( 1 )
    {
      work_fifo_ready = get_buffer_space();
      if ( (work_fifo_ready & (1 << chain)) != 0 )
        break;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: chain%d work fifo not ready: 0x%x\n",
          (const char *)_FUNCTION___14387,
          chain,
          work_fifo_ready);
        applog(7, tmp42, 0);
      }
      usleep(0x3E8u);
    }
    set_TW_write_command_vil(buf_vil_tw);
    usleep(0x186A0u);
  }
  printf("--- %s end\n", (const char *)_FUNCTION___14387);
}

//----- (00046D3C) --------------------------------------------------------
void __cdecl open_core_BM1393_S11_single_board(unsigned __int8 chain)
{
  int dhash_acc_control; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf_vil[9]; // [sp+874h] [bp+86Ch] BYREF
  unsigned __int8 data[52]; // [sp+880h] [bp+878h] BYREF
  unsigned int buf_vil_tw[13]; // [sp+8B4h] [bp+8ACh] BYREF
  unsigned int buf[13]; // [sp+8E8h] [bp+8E0h] BYREF
  unsigned int cmd_buf[3]; // [sp+91Ch] [bp+914h] BYREF
  unsigned __int8 gateblk[4]; // [sp+928h] [bp+920h]
  unsigned __int8 core_data; // [sp+92Fh] [bp+927h]
  unsigned int reg_data; // [sp+930h] [bp+928h]
  unsigned int core_index; // [sp+934h] [bp+92Ch]
  unsigned int which_chain; // [sp+938h] [bp+930h]
  unsigned int loop; // [sp+93Ch] [bp+934h]
  unsigned int work_fifo_ready; // [sp+940h] [bp+938h]
  unsigned int value; // [sp+944h] [bp+93Ch]
  unsigned int ret; // [sp+948h] [bp+940h]
  unsigned int work_id; // [sp+94Ch] [bp+944h]
  unsigned int j; // [sp+950h] [bp+948h]
  unsigned int i; // [sp+954h] [bp+94Ch]
  unsigned int core_id; // [sp+958h] [bp+950h]
  unsigned int slot; // [sp+95Ch] [bp+954h]

  i = 0;
  j = 0;
  work_id = 0;
  ret = 0;
  value = 0;
  work_fifo_ready = 0;
  which_chain = 0;
  slot = 0;
  core_index = 0;
  reg_data = 0;
  gateblk[0] = 0;
  gateblk[1] = 0;
  gateblk[2] = 0;
  gateblk[3] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  memset(buf, 0, sizeof(buf));
  memset(&buf_vil_tw[1], 0, 48);
  *(_DWORD *)data = 255;
  memset(&data[4], 0, 48);
  memset(buf_vil, 0, sizeof(buf_vil));
  core_data = 0;
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFDF);
  set_hash_counting_number(0);
  loop = scanfreq_info.CoreNum;
  buf_vil_tw[0] = (chain << 16) | 0x1000080;
  for ( core_id = 0; core_id <= 0x33; ++core_id )
  {
    for ( slot = 0; slot <= 3; ++slot )
    {
      core_index = 52 * slot + core_id;
      usleep(0x3E8u);
      enable_core_clock_BM1390(core_index, 1u, chain);
    }
    usleep(0x1388u);
    while ( 1 )
    {
      work_fifo_ready = get_buffer_space();
      if ( (work_fifo_ready & (1 << chain)) != 0 )
        break;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: chain%d work fifo not ready: 0x%x\n",
          (const char *)_FUNCTION___14429,
          chain,
          work_fifo_ready);
        applog(7, tmp42, 0);
      }
      usleep(0x3E8u);
    }
    set_TW_write_command_vil(buf_vil_tw);
    usleep(0x186A0u);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s Done\n", (const char *)_FUNCTION___14429);
    applog(5, tmp42, 0);
  }
}

//----- (0004708C) --------------------------------------------------------
void scanfreq_read_temp()
{
  int16_t v0; // r3
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  unsigned int ret; // [sp+80Ch] [bp+804h]
  int16_t temp2; // [sp+810h] [bp+808h]
  int16_t temp1; // [sp+812h] [bp+80Ah]
  int chain; // [sp+814h] [bp+80Ch]

  temp1 = 0;
  temp2 = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      set_misc_control(chain, 0, 0x4Eu, 1);
      check_reg_temp(0x98u, 9u, 4u, 1u, 0x4Eu, chain);
      ret = check_reg_temp(0x98u, 0, 0, 0, 0x4Eu, chain);
      if ( ret )
      {
        temp1 = get_local((unsigned __int8)ret);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "chain %d read temp1 error\n", chain);
        applog(5, tmp42, 0);
      }
      set_misc_control(chain, 0, 0x3Cu, 1);
      check_reg_temp(0x98u, 9u, 4u, 1u, 0x3Cu, chain);
      ret = check_reg_temp(0x98u, 0, 0, 0, 0x3Cu, chain);
      if ( ret )
      {
        temp2 = get_local((unsigned __int8)ret);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "chain %d read temp2 error\n", chain);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "chain %d temp1 = %d, temp2 = %d\n", chain, temp1, temp2);
        applog(5, tmp42, 0);
      }
      v0 = temp1;
      if ( temp2 >= temp1 )
        v0 = temp2;
      scanfreq_info.chain_max_pcb_temp[chain] = v0;
    }
  }
}

//----- (000472CC) --------------------------------------------------------
void __cdecl increase_freq_slowly(float init_freq, float final_freq, float freq_step)
{
  float v3; // s0
  float v4; // s1
  float v5; // s2
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  float freq_tmp; // [sp+81Ch] [bp+814h]
  int steps; // [sp+820h] [bp+818h]
  int i; // [sp+824h] [bp+81Ch]

  steps = (int)(float)((float)(v4 - v3) / v5);
  if ( (float)((float)((float)steps * v5) + v3) < v4 )
    ++steps;
  for ( i = 0; i < steps; ++i )
  {
    freq_tmp = (float)((float)(i + 1) * v5) + v3;
    if ( freq_tmp > v4 )
      freq_tmp = v4;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "\n\nIncrease frequency to %.2fM\n", freq_tmp);
      applog(5, tmp42, 0);
    }
    set_freq_yf(init_freq);
    init_freq = COERCE_FLOAT(sleep(2u));
  }
}
// 472FA: variable 'v4' is possibly undefined
// 472FA: variable 'v3' is possibly undefined
// 47304: variable 'v5' is possibly undefined
// 47412: variable 'init_freq' is possibly undefined

//----- (0004743C) --------------------------------------------------------
void __cdecl increase_freq_slowly_chain(int chainid, float init_freq, float final_freq, float freq_step)
{
  float v4; // s0
  float v5; // s1
  float v6; // s2
  int v7; // r2
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+10h] BYREF
  int local_pll_index; // [sp+818h] [bp+810h]
  float freq_tmp; // [sp+81Ch] [bp+814h]
  int steps; // [sp+820h] [bp+818h]
  int i; // [sp+824h] [bp+81Ch]

  steps = (int)(float)((float)(v5 - v4) / v6);
  if ( (float)((float)((float)steps * v6) + v4) < v5 )
    ++steps;
  for ( i = 0; i < steps; ++i )
  {
    freq_tmp = (float)((float)(i + 1) * v6) + v4;
    if ( freq_tmp > v5 )
      freq_tmp = v5;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "\n\nIncrease CHAIN[%d] frequency to %.2fM\n", chainid, freq_tmp);
      applog(5, tmp42, 0);
    }
    local_pll_index = get_index_from_high_pll_yf((int)freq_tmp);
    change_high_pll_test(chainid, *(float *)&local_pll_index, v7);
    sleep(2u);
  }
}
// 4746C: variable 'v5' is possibly undefined
// 4746C: variable 'v4' is possibly undefined
// 47476: variable 'v6' is possibly undefined
// 475AC: variable 'v7' is possibly undefined

//----- (000475D8) --------------------------------------------------------
int __cdecl scanfreq_init(int max_freq)
{
  int dhash_acc_control; // r0
  int v3; // r0
  all_parameters *v4; // r4
  int v5; // r0
  all_parameters *v6; // r4
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  float freq_step; // [sp+814h] [bp+80Ch] BYREF
  float final_freq; // [sp+818h] [bp+810h]
  float init_freq; // [sp+81Ch] [bp+814h] BYREF
  int hardware_version; // [sp+820h] [bp+818h]
  int open_core_temp; // [sp+824h] [bp+81Ch]
  int pre_heat_temp; // [sp+828h] [bp+820h]
  bool pre_heat_finished; // [sp+82Eh] [bp+826h]
  bool need_pre_heat; // [sp+82Fh] [bp+827h]
  int i; // [sp+830h] [bp+828h]
  int chain; // [sp+834h] [bp+82Ch]

  need_pre_heat = 0;
  pre_heat_finished = 0;
  pre_heat_temp = 80;
  open_core_temp = 50;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "scanfreq init\n");
    applog(5, tmp42, 0);
  }
  set_QN_write_data_command(0x8080800F);
  sleep(2u);
  set_Hardware_version(0x40000000u);
  read_fpga_id(FPGA_ID_str);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "miner ID : %s\n", (const char *)FPGA_ID_str);
    applog(5, tmp42, 0);
  }
  hardware_version = get_hardware_version();
  pcb_version = (hardware_version >> 16) & 0x7FFF;
  fpga_version = (unsigned __int8)hardware_version;
  fpga_major_version = BYTE1(hardware_version);
  sprintf(
    (char *)g_miner_version,
    "%d.%d.%d.%d",
    ((BYTE1(hardware_version) - 197) << 8) + (unsigned __int8)hardware_version,
    (hardware_version >> 16) & 0x7FFF,
    1,
    3);
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  set_PWM(0x64u);
  puts("rst harshboard down...");
  sleep(1u);
  reset_down_hash_board();
  puts("===Init PIC===");
  scanfreq_init_pic();
  pic_heart_beat = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(pic_heart_beat, 0, (void *(*)(void *))pic_heart_beat_func, pic_heart_beat) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: create thread for get nonce and register from FPGA failed\n",
        (const char *)_FUNCTION___14489);
      applog(5, tmp42, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(pic_heart_beat->pth);
    set_reset_allhashboard(1);
    sleep(3u);
    puts("===Power on===");
    scanfreq_set_voltage_75j(g_opencore_vol);
    sleep(1u);
    puts("rst harshboard up...");
    reset_up_hash_board();
    sleep(1u);
    puts("==reset 2nd==");
    sleep(1u);
    reset_hash_board();
    usleep((__useconds_t)"List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d");
    if ( opt_multi_version )
    {
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
    }
    cgsleep_ms(10);
    dev->corenum = -48;
    scanfreq_check_asic_num();
    puts("===Scan Chip Done===!");
    sleep(2u);
    software_set_address(2);
    cgsleep_ms(10);
    set_baud(1u, 1);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "set baud=%d\n", 1);
      applog(5, tmp42, 0);
    }
    cgsleep_ms(10);
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] == 108 )
      {
        calibration_sensor_offset(0x98u, i);
        cgsleep_ms(10);
      }
    }
    read_temp_id = (thr_info *)calloc(1u, 0x40u);
    if ( thr_info_create(read_temp_id, 0, (void *(*)(void *))scanfreq_read_temp_func, read_temp_id) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "%s: fail to create thread for read temp\n", (const char *)_FUNCTION___14489);
        applog(5, tmp42, 0);
      }
      return -7;
    }
    else
    {
      v3 = pthread_detach(read_temp_id->pth);
      init_freq = 100.0;
      final_freq = 275.0;
      freq_step = 25.0;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "\n\nset initial frequency %.2fM\n", init_freq);
        applog(5, tmp42, 0);
      }
      set_freq_yf(*(float *)&v3);
      cgsleep_ms(10);
      sleep(1u);
      v4 = dev;
      v4->timeout = 95 * (dev->addrInterval * (0x1000000 / calculate_core_number(dev->corenum)) / max_freq) / 100;
      if ( dev->timeout > 0x1FFFF )
        dev->timeout = 0x1FFFF;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "dev->timeout = %d\n", dev->timeout);
        applog(5, tmp42, 0);
      }
      set_time_out_control(0x8000C350);
      sleep(1u);
      set_clock_delay_control();
      sleep(1u);
      puts("===Pre Open Core===");
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
        {
          open_core_BM1393_pre_open_yf(5u, chain);
          printf("Chain[%d] Pre open core,ready!\n", chain);
        }
      }
      sleep(2u);
      puts("===Open Core There===");
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
        {
          open_core_BM1393_S11_single_board(chain);
          printf("Chain[%d] Open core,ready!\n", chain);
        }
      }
      sleep(2u);
      puts("===increase the freq slowly===");
      v5 = puts("All Chains are in Same Freq");
      increase_freq_slowly(*(float *)&v5, COERCE_FLOAT(&freq_step), COERCE_FLOAT(&init_freq));
      puts("===Open Core Again===");
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
          open_core_BM1393_S11_single_board(chain);
      }
      decrease_voltage_75j(0, g_opencore_vol, g_target_vol, 10);
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
        {
          v6 = dev;
          v6->timeout = (unsigned int)(float)((float)((float)((float)(dev->addrInterval
                                                                    * (0x1000000
                                                                     / calculate_core_number(dev->corenum)))
                                                            / final_freq)
                                                    * 50.0)
                                            / 100.0);
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "\n\nfinal timeout=%d\n", dev->timeout);
        applog(5, tmp42, 0);
      }
      if ( opt_multi_version )
        set_time_out_control((opt_multi_version * dev->timeout) & 0x1FFFF | 0x80000000);
      else
        set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
      return 0;
    }
  }
}
// 47B06: variable 'v3' is possibly undefined

//----- (00047F74) --------------------------------------------------------
int scanfreq_is_all_finished()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
      return 0;
  }
  return 1;
}

//----- (00047FD8) --------------------------------------------------------
void __cdecl scanfreq_get_next_freq_chain(int chain)
{
  int *current_index; // [sp+10h] [bp+10h]

  current_index = &scanfreq_info.current_index[chain];
  if ( *current_index == -1 )
  {
    *current_index = (scanfreq_info.freq_index_max[chain] + scanfreq_info.freq_index_min[chain]) / 2;
  }
  else if ( ++counter_14531[chain] == 10 )
  {
    scanfreq_info.scan_finished[chain] = 1;
  }
}

//----- (000480A4) --------------------------------------------------------
int scanfreq_get_next_freq()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
      scanfreq_get_next_freq_chain(chain);
  }
  return chain;
}

//----- (00048100) --------------------------------------------------------
int scanfreq_get_max_freq_index()
{
  int chain; // [sp+0h] [bp+0h]
  int max_freq_index; // [sp+4h] [bp+4h]

  max_freq_index = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain]
      && !scanfreq_info.scan_finished[chain]
      && scanfreq_info.current_index[chain] > max_freq_index )
    {
      max_freq_index = scanfreq_info.current_index[chain];
    }
  }
  return max_freq_index;
}

//----- (00048194) --------------------------------------------------------
int scanfreq_init_freq_level()
{
  int chain; // [sp+3Ch] [bp+3Ch]

  scanfreq_info.MAX_INDEX = 13;
  scanfreq_info.MIN_INDEX = 0;
  scanfreq_info.scan_index[0] = 18;
  scanfreq_info.scan_index[1] = 17;
  scanfreq_info.scan_index[2] = 16;
  scanfreq_info.scan_index[3] = 15;
  scanfreq_info.scan_index[4] = 14;
  scanfreq_info.scan_index[5] = 13;
  scanfreq_info.scan_index[6] = 0;
  scanfreq_info.scan_index[7] = 0;
  scanfreq_info.scan_index[8] = 0;
  scanfreq_info.scan_index[9] = 0;
  scanfreq_info.scan_index[10] = 0;
  scanfreq_info.scan_index[11] = 0;
  scanfreq_info.scan_index[12] = 0;
  scanfreq_info.scan_index[13] = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    scanfreq_info.freq_index_max[chain] = scanfreq_info.MAX_INDEX;
    scanfreq_info.freq_index_min[chain] = scanfreq_info.MIN_INDEX;
    scanfreq_info.current_index[chain] = -1;
  }
  return chain;
}

//----- (000482E0) --------------------------------------------------------
void __cdecl clear_nonce_return_back_flag(int chain)
{
  SCAN_FREQ_WORK *works; // [sp+Ch] [bp+Ch]
  int n; // [sp+14h] [bp+14h]
  int j; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; scanfreq_info.AsicNum > i; ++i )
  {
    works = scanfreq_info.works[i];
    for ( n = 0; scanfreq_info.CoreNum > n; ++n )
    {
      for ( j = 0; scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum > j; ++j )
        works[n * (scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum) + j].is_nonce_return_back[chain] = 0;
    }
  }
}

//----- (000483B8) --------------------------------------------------------
void scanfreq_reset_result()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int chain; // [sp+804h] [bp+804h]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "scanfreq_reset_result");
    applog(5, tmp42, 0);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( !scanfreq_info.scan_finished[chain] )
      {
        memset(scanfreq_info.asic_nonce_num[chain], 0, sizeof(scanfreq_info.asic_nonce_num[chain]));
        memset(scanfreq_info.asic_core_nonce_num[chain], 0, sizeof(scanfreq_info.asic_core_nonce_num[chain]));
        scanfreq_info.send_work_num[chain] = 0;
        scanfreq_info.ret_nonce_num[chain] = 0;
        scanfreq_info.repeated_nonce_num[chain] = 0;
        scanfreq_info.other_nonce_num[chain] = 0;
        scanfreq_info.HW_nonce_num[chain] = 0;
        scanfreq_info.valid_nonce_num[chain] = 0;
        clear_nonce_return_back_flag(chain);
      }
    }
  }
}

//----- (00048564) --------------------------------------------------------
void *__cdecl scanfreq_send_work(void *arg)
{
  int nonce_fifo_interrupt; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned int buf_vil[13]; // [sp+810h] [bp+808h] BYREF
  vil_work_1387 work_vil_1387; // [sp+844h] [bp+83Ch] BYREF
  SCAN_FREQ_WORK *work; // [sp+878h] [bp+870h]
  SCAN_FREQ_WORK *works; // [sp+87Ch] [bp+874h]
  int AsicNum; // [sp+880h] [bp+878h]
  int CoreNum; // [sp+884h] [bp+87Ch]
  unsigned int work_fifo_ready; // [sp+888h] [bp+880h]
  int wait_count; // [sp+88Ch] [bp+884h]
  int last_recv_num; // [sp+890h] [bp+888h]
  unsigned int work_id; // [sp+894h] [bp+88Ch]
  int which_pattern; // [sp+898h] [bp+890h]
  int which_core; // [sp+89Ch] [bp+894h]
  int which_asic; // [sp+8A0h] [bp+898h]
  int chain; // [sp+8A4h] [bp+89Ch]
  int j; // [sp+8A8h] [bp+8A0h]
  int i; // [sp+8ACh] [bp+8A4h]

  chain = 0;
  which_asic = 0;
  which_core = 0;
  which_pattern = 0;
  work_fifo_ready = 0;
  work_id = 0;
  memset(buf_vil, 0, sizeof(buf_vil));
  CoreNum = scanfreq_info.CoreNum;
  AsicNum = scanfreq_info.AsicNum;
  last_recv_num = 0;
  wait_count = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "start send work\n");
    applog(5, tmp42, 0);
  }
  gBegin_get_nonce = 1;
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
    {
      for ( which_asic = 0; which_asic < AsicNum; ++which_asic )
      {
        works = scanfreq_info.works[which_asic];
        for ( which_core = 0; which_core < CoreNum; ++which_core )
        {
          for ( which_pattern = 0; scanfreq_info.AsicWorkCount / CoreNum > which_pattern; ++which_pattern )
          {
            while ( 1 )
            {
              work_fifo_ready = get_buffer_space();
              if ( (work_fifo_ready & (1 << chain)) != 0 )
                break;
              usleep(0x1388u);
            }
            memset(buf_vil, 0, 0xDu);
            work = &works[which_core * (scanfreq_info.AsicWorkCount / CoreNum) + which_pattern];
            memset(&work_vil_1387, 0, sizeof(work_vil_1387));
            work_vil_1387.work_type = 1;
            work_vil_1387.chain_id = chain | 0x80;
            work_vil_1387.reserved1[0] = 0;
            work_vil_1387.reserved1[1] = 0;
            if ( ++work_id > 0x7F )
              work_id = 0;
            work_vil_1387.work_count = (which_pattern << 7) | work_id & 0x7F;
            memcpy(&scanfreq_info.send_work[work_id], work, sizeof(scanfreq_info.send_work[work_id]));
            for ( i = 0; i <= 11; ++i )
              work_vil_1387.data[i] = work->data[i];
            for ( i = 0; i <= 31; ++i )
              work_vil_1387.midstate[i] = work->midstate[i];
            buf_vil[0] = _byteswap_ulong(*(unsigned int *)&work_vil_1387.work_type);
            buf_vil[1] = work_vil_1387.work_count;
            for ( j = 2; (unsigned int)j <= 4; ++j )
              buf_vil[j] = work_vil_1387.reserved1[4 * j + 1] | (*(&work_vil_1387.work_type + 4 * j) << 24) | (work_vil_1387.reserved1[4 * j - 1] << 16) | (work_vil_1387.reserved1[4 * j] << 8);
            for ( j = 5; (unsigned int)j <= 0xC; ++j )
              buf_vil[j] = work_vil_1387.reserved1[4 * j + 1] | (*(&work_vil_1387.work_type + 4 * j) << 24) | (work_vil_1387.reserved1[4 * j - 1] << 16) | (work_vil_1387.reserved1[4 * j] << 8);
            set_TW_write_command_vil(buf_vil);
            ++scanfreq_info.send_work_num[chain];
          }
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Chain[%d] send %d works\n", chain, scanfreq_info.send_work_num[chain]);
        applog(5, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "wait for receiving nonce\n");
    applog(5, tmp42, 0);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
    {
      last_recv_num = 0;
      wait_count = 0;
      while ( wait_count <= 2 && scanfreq_info.valid_nonce_num[chain] < scanfreq_info.RequiredChainNonce )
      {
        if ( scanfreq_info.valid_nonce_num[chain] == last_recv_num )
        {
          ++wait_count;
        }
        else
        {
          wait_count = 0;
          last_recv_num = scanfreq_info.valid_nonce_num[chain];
        }
        usleep(0x186A0u);
      }
    }
  }
  gBegin_get_nonce = 0;
  return &gBegin_get_nonce;
}

//----- (00048BF4) --------------------------------------------------------
int __cdecl check_hw(SCAN_FREQ_WORK *work, unsigned int nonce, bool print)
{
  unsigned int v4; // r1
  unsigned int v5; // r2
  unsigned int v6; // r3
  unsigned int v7; // r1
  unsigned int v8; // r2
  unsigned int v9; // r3
  sha2_context ctx; // [sp+14h] [bp+14h] BYREF
  unsigned int nonce_temp; // [sp+FCh] [bp+FCh] BYREF
  unsigned __int8 hash2[32]; // [sp+100h] [bp+100h] BYREF
  unsigned __int8 hash1[32]; // [sp+120h] [bp+120h] BYREF
  unsigned int *hash2_32; // [sp+140h] [bp+140h]
  unsigned int m; // [sp+144h] [bp+144h]

  m = 0;
  memset(hash1, 0, sizeof(hash1));
  memset(hash2, 0, sizeof(hash2));
  hash2_32 = (unsigned int *)hash1;
  nonce_temp = (nonce << 24) | HIBYTE(nonce) | ((nonce & 0xFF0000) >> 8) | ((nonce & 0xFF00) << 8);
  if ( !work )
    return 0;
  v4 = *(_DWORD *)&work->midstate[4];
  v5 = *(_DWORD *)&work->midstate[8];
  v6 = *(_DWORD *)&work->midstate[12];
  ctx.state[0] = *(_DWORD *)work->midstate;
  ctx.state[1] = v4;
  ctx.state[2] = v5;
  ctx.state[3] = v6;
  v7 = *(_DWORD *)&work->midstate[20];
  v8 = *(_DWORD *)&work->midstate[24];
  v9 = *(_DWORD *)&work->midstate[28];
  ctx.state[4] = *(_DWORD *)&work->midstate[16];
  ctx.state[5] = v7;
  ctx.state[6] = v8;
  ctx.state[7] = v9;
  rev((unsigned __int8 *)ctx.state, 0x20u);
  ctx.total[0] = 80;
  ctx.total[1] = 0;
  memcpy(hash1, work->data, 0xCu);
  rev(hash1, 0xCu);
  flip_swab(ctx.buffer, hash1, 0xCu);
  memcpy(hash1, &nonce_temp, 4u);
  rev(hash1, 4u);
  flip_swab(&ctx.buffer[12], hash1, 4u);
  sha2_finish(&ctx, hash1);
  memset(&ctx, 0, sizeof(ctx));
  sha2(hash1, 32, hash2);
  flip32_0(hash1, hash2);
  if ( !hash2_32[7] )
    return 0;
  if ( print )
  {
    printf("\n%s: Got a HW!\n", (const char *)_FUNCTION___14651);
    printf("hash1=0x");
    for ( m = 0; m <= 0x1F; ++m )
      printf("%02x", hash1[m]);
    putchar(10);
    printf("midstate=0x");
    for ( m = 0; m <= 0x1F; ++m )
      printf("%02x", work->midstate[m]);
    printf("\tdata2=0x");
    for ( m = 0; m <= 0xB; ++m )
      printf("%02x", work->data[m]);
    printf("\treturn nonce=0x%08x, but it should be nonce=0x%08x\n", nonce, work->nonce);
  }
  return 1;
}

//----- (00048ECC) --------------------------------------------------------
void __cdecl Nonce_Match(int chain, unsigned int buf, unsigned int which_pattern)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+10h] BYREF
  unsigned int whose_nonce; // [sp+818h] [bp+810h]
  unsigned int which_core_nonce; // [sp+81Ch] [bp+814h]

  which_core_nonce = (unsigned __int8)buf;
  whose_nonce = HIBYTE(buf) / dev->addrInterval;
  if ( whose_nonce <= 0xFF )
  {
    ++scanfreq_info.asic_nonce_num[chain][whose_nonce];
    ++scanfreq_info.asic_core_nonce_num[chain][whose_nonce][which_core_nonce];
    ++scanfreq_info.valid_nonce_num[chain];
    scanfreq_info.works[whose_nonce][which_core_nonce * (scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum)
                                   + which_pattern].is_nonce_return_back[chain] = 1;
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "%s: buf [%x] is error!\n", (const char *)_FUNCTION___14670, buf);
    applog(5, tmp42, 0);
  }
}
// 48F26: conditional instruction was optimized away because %which_core_nonce.4<100u

//----- (000490C8) --------------------------------------------------------
void *__cdecl __noreturn scanfreq_receive_nonce_register(void *arg)
{
  __int16 nonce_number_in_fifo; // r0
  SCAN_FREQ_WORK *v2; // r2
  unsigned int buf[2]; // [sp+Ch] [bp+Ch] BYREF
  SCAN_FREQ_WORK *work_1; // [sp+14h] [bp+14h]
  int chainIndex; // [sp+18h] [bp+18h]
  unsigned __int8 which_pattern; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 nonce_index; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 whose_nonce; // [sp+1Fh] [bp+1Fh]
  unsigned int which_nonce; // [sp+20h] [bp+20h]
  unsigned int m_nonce; // [sp+24h] [bp+24h]
  unsigned int which_asic; // [sp+28h] [bp+28h]
  unsigned __int8 *buf_hex; // [sp+2Ch] [bp+2Ch]
  unsigned int reg_loop_back; // [sp+30h] [bp+30h]
  unsigned int reg_reg_value_num; // [sp+34h] [bp+34h]
  unsigned int reg_p_rd; // [sp+38h] [bp+38h]
  unsigned int reg_p_wr; // [sp+3Ch] [bp+3Ch]
  unsigned int nonce_loop_back; // [sp+40h] [bp+40h]
  unsigned int nonce_nonce_num; // [sp+44h] [bp+44h]
  unsigned int nonce_p_rd; // [sp+48h] [bp+48h]
  unsigned int nonce_p_wr; // [sp+4Ch] [bp+4Ch]
  unsigned __int8 ret; // [sp+53h] [bp+53h]
  unsigned int read_loop; // [sp+54h] [bp+54h]
  unsigned int nonce_number; // [sp+58h] [bp+58h]
  unsigned int n; // [sp+5Ch] [bp+5Ch]
  unsigned int m; // [sp+60h] [bp+60h]
  unsigned int i; // [sp+64h] [bp+64h]
  unsigned int *data_addr; // [sp+68h] [bp+68h]
  unsigned int work_id; // [sp+6Ch] [bp+6Ch]
  unsigned __int8 which_core_nonce; // [sp+72h] [bp+72h]
  unsigned __int8 which_asic_nonce; // [sp+73h] [bp+73h]
  SCAN_FREQ_WORK *work_3; // [sp+74h] [bp+74h]
  SCAN_FREQ_WORK *work_2; // [sp+78h] [bp+78h]
  unsigned int j; // [sp+7Ch] [bp+7Ch]

  work_id = 0;
  data_addr = 0;
  i = 0;
  j = 0;
  m = 0;
  n = 0;
  nonce_number = 0;
  read_loop = 0;
  buf[0] = 0;
  buf[1] = 0;
  ret = 0;
  nonce_p_wr = 0;
  nonce_p_rd = 0;
  nonce_nonce_num = 0;
  nonce_loop_back = 0;
  reg_p_wr = 0;
  reg_p_rd = 0;
  reg_reg_value_num = 0;
  reg_loop_back = 0;
  buf_hex = 0;
  which_asic = 0;
  m_nonce = 0;
  which_nonce = 0;
  which_asic_nonce = 0;
  which_core_nonce = 0;
  whose_nonce = 0;
  nonce_index = 0;
  which_pattern = 0;
  chainIndex = 0;
  do
  {
LABEL_2:
    usleep(0x3E8u);
    i = 0;
    read_loop = 0;
    nonce_number_in_fifo = get_nonce_number_in_fifo();
    nonce_number = nonce_number_in_fifo & 0x1FF;
  }
  while ( (nonce_number_in_fifo & 0x1FF) == 0 );
  read_loop = nonce_number;
  for ( j = 0; ; ++j )
  {
    if ( j >= read_loop )
      goto LABEL_2;
    get_return_nonce(buf);
    if ( (buf[0] & 0x80000000) == 0 )
    {
      if ( reg_value_buf.reg_value_num <= 0x1FE && reg_value_buf.p_wr <= 0x1FE )
      {
        pthread_mutex_lock(&reg_mutex);
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = buf[1];
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = HIBYTE(buf[0]) & 0x1F;
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].chip_address = BYTE2(buf[0]);
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_address = BYTE1(buf[0]);
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = buf[0] & 0xF;
        if ( reg_value_buf.p_wr > 0x1FD )
          reg_value_buf.p_wr = 0;
        else
          ++reg_value_buf.p_wr;
        if ( reg_value_buf.reg_value_num > 0x1FE )
          reg_value_buf.reg_value_num = 511;
        else
          ++reg_value_buf.reg_value_num;
        pthread_mutex_unlock(&reg_mutex);
      }
      else
      {
        clear_register_value_buf();
      }
    }
    else if ( gBegin_get_nonce && (buf[0] & 0x80) != 0 && (buf[0] & 0x40) == 0 && (buf[0] & 0x20) == 0 )
    {
      chainIndex = buf[0] & 0xF;
      if ( (unsigned int)chainIndex <= 0xF && dev->chain_exist[chainIndex] && !scanfreq_info.scan_finished[chainIndex] )
      {
        ++scanfreq_info.ret_nonce_num[chainIndex];
        which_pattern = (unsigned int)(HIWORD(buf[0]) & 0x7FFF) >> 7;
        work_id = BYTE2(buf[0]) & 0x7F;
        if ( dev->addrInterval )
        {
          which_asic_nonce = HIBYTE(buf[1]) / dev->addrInterval;
          which_core_nonce = buf[1];
          if ( which_asic_nonce >= scanfreq_info.AsicNum )
            continue;
        }
        else
        {
          which_asic_nonce = buf[1] >> 26;
          if ( which_asic_nonce >= scanfreq_info.AsicNum )
            continue;
        }
        whose_nonce = which_asic_nonce;
        nonce_index = which_asic_nonce;
        if ( work_id <= 0x80 )
        {
          m_nonce = scanfreq_info.send_work[work_id].nonce;
          if ( buf[1] == m_nonce )
          {
            if ( which_pattern < scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum )
            {
              if ( scanfreq_info.works[which_asic_nonce][scanfreq_info.AsicWorkCount
                                                       / scanfreq_info.CoreNum
                                                       * which_core_nonce
                                                       + which_pattern].is_nonce_return_back[chainIndex] )
              {
                v2 = &scanfreq_info.works[which_asic_nonce][scanfreq_info.AsicWorkCount
                                                          / scanfreq_info.CoreNum
                                                          * which_core_nonce
                                                          + which_pattern];
                ++v2->is_nonce_return_back[chainIndex];
                ++scanfreq_info.repeated_nonce_num[chainIndex];
              }
              else
              {
                Nonce_Match(chainIndex, buf[1], which_pattern);
              }
            }
            else
            {
              ++scanfreq_info.other_nonce_num[chainIndex];
            }
          }
          else
          {
            work_1 = &scanfreq_info.send_work[work_id];
            if ( work_id <= 1 )
            {
              if ( work_id == 1 )
              {
                work_2 = scanfreq_info.send_work;
                work_3 = &scanfreq_info.send_work[127];
              }
              else
              {
                work_2 = &scanfreq_info.send_work[127];
                work_3 = &scanfreq_info.send_work[126];
              }
            }
            else
            {
              work_2 = (SCAN_FREQ_WORK *)&scanfreq_info.scan_success[116 * work_id];
              work_3 = (SCAN_FREQ_WORK *)&scanfreq_info.pass_noncerate[29 * work_id - 13];
            }
            ret = check_hw(work_1, buf[1], 0);
            if ( ret )
            {
              ret = check_hw(work_2, buf[1], 0);
              if ( ret )
              {
                ret = check_hw(work_3, buf[1], 0);
                if ( ret )
                  ++scanfreq_info.HW_nonce_num[chainIndex];
                else
                  ++scanfreq_info.other_nonce_num[chainIndex];
              }
              else
              {
                ++scanfreq_info.other_nonce_num[chainIndex];
              }
            }
            else
            {
              ++scanfreq_info.other_nonce_num[chainIndex];
            }
          }
        }
        else
        {
          printf("Error: work_id=%d\n", work_id);
        }
      }
    }
  }
}
// 494D4: conditional instruction was optimized away because %work_id.4==0

//----- (0004976C) --------------------------------------------------------
bool __cdecl isDisabledChipCore(int chainIndex, int chipIndex, int coreIndex)
{
  return 0;
}

//----- (00049788) --------------------------------------------------------
void __cdecl UpdateAsicCoreEnabledFlag(int chainIndex)
{
  int n; // [sp+Ch] [bp+Ch]
  int k; // [sp+10h] [bp+10h]
  int j; // [sp+14h] [bp+14h]
  int m; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  n = scanfreq_info.RequiredAsicNonce / 208;
  for ( j = 0; j <= 255; ++j )
  {
    for ( k = 0; k <= 255; ++k )
      scanfreq_info.asic_core_enabled_flag[chainIndex][j][k] = 1;
  }
  for ( i = 0; scanfreq_info.AsicNum > i; ++i )
  {
    if ( scanfreq_info.asic_nonce_num[chainIndex][i] < scanfreq_info.RequiredAsicNonce )
    {
      for ( m = 0; m <= 207; ++m )
      {
        if ( scanfreq_info.asic_core_nonce_num[chainIndex][i][m] < n && !isDisabledChipCore(chainIndex, i, m) )
          scanfreq_info.asic_core_enabled_flag[chainIndex][i][m] = 0;
      }
    }
  }
}

//----- (000498BC) --------------------------------------------------------
int __cdecl getChainAsicTempBadCoreNum(int chainIndex, int asicIndex)
{
  int badcore; // [sp+8h] [bp+8h]
  int m; // [sp+Ch] [bp+Ch]

  badcore = 0;
  for ( m = 0; m <= 207; ++m )
  {
    if ( scanfreq_info.asic_core_enabled_flag[chainIndex][asicIndex][m] <= 0 )
      ++badcore;
  }
  return badcore;
}

//----- (00049918) --------------------------------------------------------
void scanfreq_read_core_hash_clock_counter()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  bool ready[16]; // [sp+800h] [bp+800h] BYREF
  core_cmd core; // [sp+810h] [bp+810h] BYREF
  bool all_ready; // [sp+81Fh] [bp+81Fh]
  int asic; // [sp+820h] [bp+820h]
  int i; // [sp+824h] [bp+824h]

  memset(ready, 0, sizeof(ready));
  all_ready = 0;
  asic = 0;
  memset(&core, 0, sizeof(core));
  core.chip_addr = 0;
  core.mode = 1;
  core.core_mode = 1;
  core.core_id = 0;
  core.cmd_type = 5;
  core.reg_data = 1;
  core.rw_falg = 1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      core.chain = i;
      set_core_cmd_BM1393(&core);
    }
  }
  sleep(2u);
  memset(&core, 0, sizeof(core));
  core.chip_addr = 0;
  core.mode = 0;
  core.core_mode = 1;
  core.core_id = 0;
  core.cmd_type = 6;
  core.reg_data = 0;
  core.rw_falg = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      for ( asic = 0; asic <= 59; ++asic )
      {
        clear_register_value_buf();
        core.chain = i;
        core.chip_addr = 2 * asic;
        set_core_cmd_BM1393(&core);
        check_core_register = 6;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "--- read chip[%d] hash count ---\n", 2 * asic);
          applog(5, tmp42, 0);
        }
        check_asic_reg_with_addr_test(0x40u, 2 * asic, i, 208);
      }
    }
  }
}

//----- (00049B44) --------------------------------------------------------
void scanfreq_read_hash_clock_counter_all_chip_one_core()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  bool ready[16]; // [sp+800h] [bp+800h] BYREF
  core_cmd core; // [sp+810h] [bp+810h] BYREF
  bool all_ready; // [sp+81Fh] [bp+81Fh]
  int m; // [sp+820h] [bp+820h]
  int i; // [sp+824h] [bp+824h]

  memset(ready, 0, sizeof(ready));
  all_ready = 0;
  m = 0;
  memset(&core, 0, sizeof(core));
  core.chip_addr = 0;
  core.mode = 1;
  core.core_mode = 1;
  core.core_id = 0;
  core.cmd_type = 5;
  core.reg_data = 1;
  core.rw_falg = 1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      core.chain = i;
      set_core_cmd_BM1393(&core);
    }
  }
  sleep(2u);
  memset(&core, 0, sizeof(core));
  core.chip_addr = 0;
  core.mode = 1;
  core.core_mode = 0;
  core.core_id = 0;
  core.cmd_type = 6;
  core.reg_data = 0;
  core.rw_falg = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      for ( m = 0; m <= 207; ++m )
      {
        clear_register_value_buf();
        core.chain = i;
        core.core_id = m;
        set_core_cmd_BM1393(&core);
        check_core_register = 6;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "--- read all chip core[%d] hash counter ---\n", m);
          applog(5, tmp42, 0);
        }
        check_asic_reg_with_addr_test(0x40u, 0, i, scanfreq_info.AsicNum);
      }
    }
  }
}

//----- (00049D64) --------------------------------------------------------
void scanfreq_print_core_hash_clock_counter()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int m; // [sp+808h] [bp+800h]
  int chain; // [sp+80Ch] [bp+804h]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "----------- Chip 0 hash clock counter -----------\n", chain);
    applog(5, tmp42, 0);
  }
  g_logfile_no_datetime = 1;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "--- Chain[%d] ---\n", chain);
        applog(5, tmp42, 0);
      }
      for ( m = 0; m <= 207; ++m )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "CORE[%03d]=%08x ", m, core_hash_clock_counter[chain][0][m]);
          applog(5, tmp42, 0);
        }
        if ( (((_BYTE)m + 1) & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          strcpy((char *)tmp42, "\n");
          applog(5, tmp42, 0);
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "\n\n");
        applog(5, tmp42, 0);
      }
    }
  }
  g_logfile_no_datetime = 0;
}

//----- (00049F80) --------------------------------------------------------
void scanfreq_print_core_hash_clock_counter_error()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int error_asic[256]; // [sp+808h] [bp+800h]
  int clock_counter; // [sp+C08h] [bp+C00h]
  bool print_asic; // [sp+C0Fh] [bp+C07h]
  int error_num; // [sp+C10h] [bp+C08h]
  int i; // [sp+C14h] [bp+C0Ch]
  int error; // [sp+C18h] [bp+C10h]
  int asic; // [sp+C1Ch] [bp+C14h]
  int m; // [sp+C20h] [bp+C18h]
  int chain; // [sp+C24h] [bp+C1Ch]

  error_num = 0;
  print_asic = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "----------- hash clock counter Error Info -----------\n", chain);
    applog(5, tmp42, 0);
  }
  g_logfile_no_datetime = 1;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      error_num = 0;
      clock_counter = 16 * freq_pll_1393_0[freq_one_board[chain]].freq / 100;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "--- Chain[%d] ---\n", chain);
        applog(5, tmp42, 0);
      }
      for ( asic = 0; scanfreq_info.AsicNum > asic; ++asic )
      {
        print_asic = 0;
        error = 0;
        for ( m = 0; m <= 207; ++m )
        {
          if ( (unsigned __int8)core_hash_clock_counter[0][(chain << 8) + asic][m] != 255
            && (unsigned __int8)core_hash_clock_counter[0][(chain << 8) + asic][m] != clock_counter
            && (unsigned __int8)core_hash_clock_counter[0][(chain << 8) + asic][m] != clock_counter + 1
            && (unsigned __int8)core_hash_clock_counter[0][(chain << 8) + asic][m] != clock_counter - 1 )
          {
            if ( !print_asic )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)tmp42, 0x800u, "--- ASIC[%d] error clock counter ---\n", asic);
                applog(5, tmp42, 0);
              }
              print_asic = 1;
            }
            if ( (++error & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
            {
              strcpy((char *)tmp42, "\n");
              applog(5, tmp42, 0);
            }
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "CORE[%03d]=%02x ",
                m,
                (unsigned __int8)core_hash_clock_counter[0][(chain << 8) + asic][m]);
              applog(5, tmp42, 0);
            }
          }
        }
        if ( error > 0 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            strcpy((char *)tmp42, "\n");
            applog(5, tmp42, 0);
          }
          error_asic[error_num++] = asic;
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "--- ASIC[%d] all clock counter ---\n", asic);
            applog(5, tmp42, 0);
          }
          for ( m = 0; m <= 207; ++m )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "CORE[%03d]=%02x ",
                m,
                (unsigned __int8)core_hash_clock_counter[0][(chain << 8) + asic][m]);
              applog(5, tmp42, 0);
            }
            if ( (((_BYTE)m + 1) & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
            {
              strcpy((char *)tmp42, "\n");
              applog(5, tmp42, 0);
            }
          }
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            strcpy((char *)tmp42, "\n");
            applog(5, tmp42, 0);
          }
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "\n\n");
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "hash_clock_counter=0 chips:\n");
        applog(5, tmp42, 0);
      }
      for ( i = 0; i < error_num; ++i )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "%02d ", error_asic[i]);
          applog(5, tmp42, 0);
        }
        if ( (((_BYTE)i + 1) & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          strcpy((char *)tmp42, "\n");
          applog(5, tmp42, 0);
        }
      }
    }
  }
  g_logfile_no_datetime = 0;
}

//----- (0004A608) --------------------------------------------------------
void scanfreq_print_core_clock_delay_control_error()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int error_asic[256]; // [sp+808h] [bp+800h]
  int cc; // [sp+C08h] [bp+C00h]
  bool print_asic; // [sp+C0Fh] [bp+C07h]
  int error_num; // [sp+C10h] [bp+C08h]
  int i; // [sp+C14h] [bp+C0Ch]
  int error; // [sp+C18h] [bp+C10h]
  int asic; // [sp+C1Ch] [bp+C14h]
  int m; // [sp+C20h] [bp+C18h]
  int chain; // [sp+C24h] [bp+C1Ch]

  error_num = 0;
  print_asic = 0;
  cc = 20;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "----------- clock delay control Error Info -----------\n", chain);
    applog(5, tmp42, 0);
  }
  g_logfile_no_datetime = 1;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      error_num = 0;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "--- Chain[%d] ---\n", chain);
        applog(5, tmp42, 0);
      }
      for ( asic = 0; scanfreq_info.AsicNum > asic; ++asic )
      {
        print_asic = 0;
        error = 0;
        for ( m = 0; m <= 207; ++m )
        {
          if ( ++cc <= 9 && (use_syslog || opt_log_output || opt_log_level > 4) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "CORE[%03d]=%02x \n",
              m,
              core_hash_clock_delay_control[0][(chain << 8) + asic][m]);
            applog(5, tmp42, 0);
          }
          if ( core_hash_clock_delay_control[0][(chain << 8) + asic][m] != 10 )
          {
            if ( !print_asic )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)tmp42, 0x800u, "--- ASIC[%d] clock delay control error ---\n", asic);
                applog(5, tmp42, 0);
              }
              print_asic = 1;
            }
            if ( (++error & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
            {
              strcpy((char *)tmp42, "\n");
              applog(5, tmp42, 0);
            }
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "CORE[%03d]=%02x ",
                m,
                core_hash_clock_delay_control[0][(chain << 8) + asic][m]);
              applog(5, tmp42, 0);
            }
          }
        }
        if ( error > 0 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            strcpy((char *)tmp42, "\n");
            applog(5, tmp42, 0);
          }
          error_asic[error_num++] = asic;
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "\n\n");
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "clock delay control error chips:\n");
        applog(5, tmp42, 0);
      }
      for ( i = 0; i < error_num; ++i )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "%02d ", error_asic[i]);
          applog(5, tmp42, 0);
        }
        if ( (((_BYTE)i + 1) & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          strcpy((char *)tmp42, "\n");
          applog(5, tmp42, 0);
        }
      }
    }
  }
  g_logfile_no_datetime = 0;
}

//----- (0004AAF4) --------------------------------------------------------
void scanfreq_find_all_error_clock_delay_control_asic()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  int asic_id; // [sp+80Ch] [bp+804h]
  bool asic_error; // [sp+813h] [bp+80Bh]
  int asic; // [sp+814h] [bp+80Ch]
  int m; // [sp+818h] [bp+810h]
  int chain; // [sp+81Ch] [bp+814h]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "find all clock delay error chips");
    applog(5, tmp42, 0);
  }
  memset(clock_delay_control_error_asic, 0, sizeof(clock_delay_control_error_asic));
  memset(clock_delay_control_error_asic_num, 0, sizeof(clock_delay_control_error_asic_num));
  memset(clock_delay_control_error_core, 0, sizeof(clock_delay_control_error_core));
  memset(clock_delay_control_error_core_num, 0, sizeof(clock_delay_control_error_core_num));
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( asic = 0; scanfreq_info.AsicNum > asic; ++asic )
      {
        asic_error = 0;
        for ( m = 0; m <= 207; ++m )
        {
          if ( core_hash_clock_delay_control[0][(chain << 8) + asic][m] != 10 )
          {
            clock_delay_control_error_core[0][(chain << 8) + asic][clock_delay_control_error_core_num[chain][asic]++] = m;
            asic_error = 1;
          }
        }
        if ( asic_error )
          clock_delay_control_error_asic[chain][clock_delay_control_error_asic_num[chain]++] = asic;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "chain %d has %d error chips", chain, clock_delay_control_error_asic_num[chain]);
        applog(5, tmp42, 0);
      }
      for ( asic = 0; clock_delay_control_error_asic_num[chain] > asic; ++asic )
      {
        asic_id = clock_delay_control_error_asic[chain][asic];
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "chip %d has %d error cores",
            asic_id,
            clock_delay_control_error_core_num[chain][asic_id]);
          applog(5, tmp42, 0);
        }
        for ( m = 0; clock_delay_control_error_core_num[chain][asic_id] > m; ++m )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "core[%d]", clock_delay_control_error_core[0][(chain << 8) + asic_id][m]);
            applog(5, tmp42, 0);
          }
        }
      }
    }
  }
}

//----- (0004AEBC) --------------------------------------------------------
void scanfreq_rewrite_error_clock_delay_control_asic()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  int asic_id; // [sp+800h] [bp+800h]
  int core; // [sp+804h] [bp+804h]
  int asic; // [sp+808h] [bp+808h]
  int chain; // [sp+80Ch] [bp+80Ch]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "rewrite all clock delay error chips");
    applog(5, tmp42, 0);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && clock_delay_control_error_asic_num[chain] )
    {
      for ( asic = 0; clock_delay_control_error_asic_num[chain] > asic; ++asic )
      {
        asic_id = clock_delay_control_error_asic[chain][asic];
        for ( core = 0; clock_delay_control_error_core_num[chain][asic_id] > core; ++core )
        {
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
          usleep(0x2710u);
          rewrite_clock_delay_control(
            chain,
            2 * asic_id,
            clock_delay_control_error_core[0][(chain << 8) + asic_id][core],
            0xAu);
        }
      }
    }
  }
}

//----- (0004B290) --------------------------------------------------------
void __cdecl scanfreq_print_bad_chip(int chain)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int n; // [sp+814h] [bp+80Ch]
  int bad_chips; // [sp+818h] [bp+810h]
  int bad_core; // [sp+81Ch] [bp+814h]
  int m; // [sp+820h] [bp+818h]
  int i; // [sp+824h] [bp+81Ch]

  n = scanfreq_info.AsicWorkCount / 208;
  g_logfile_no_datetime = 1;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "-----------Chips not return all nonce -----------\n", chain);
    applog(5, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "------------------ Chain[%d] ------------------\n", chain);
    applog(5, tmp42, 0);
  }
  for ( i = 0; scanfreq_info.AsicNum > i; ++i )
  {
    if ( scanfreq_info.asic_nonce_num[chain][i] < scanfreq_info.AsicWorkCount )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "asic[%02d]=%02d\n", i, scanfreq_info.asic_nonce_num[chain][i]);
        applog(5, tmp42, 0);
      }
      bad_core = 0;
      for ( m = 0; m <= 207; ++m )
      {
        if ( scanfreq_info.asic_core_nonce_num[chain][i][m] != n )
        {
          if ( (++bad_core & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
          {
            strcpy((char *)tmp42, "\n");
            applog(5, tmp42, 0);
          }
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "CORE[%03d]=%02d ", m, scanfreq_info.asic_core_nonce_num[chain][i][m]);
            applog(5, tmp42, 0);
          }
        }
      }
      if ( bad_core > 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        strcpy((char *)tmp42, "\n\n");
        applog(5, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "nonce < 180 chips:\n");
    applog(5, tmp42, 0);
  }
  bad_chips = 0;
  for ( i = 0; scanfreq_info.AsicNum > i; ++i )
  {
    if ( scanfreq_info.asic_nonce_num[chain][i] <= 179 )
    {
      if ( (++bad_chips & 7) == 0 && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        strcpy((char *)tmp42, "\n");
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "%02d ", i);
        applog(5, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "\n\n\n");
    applog(5, tmp42, 0);
  }
  g_logfile_no_datetime = 0;
}

//----- (0004B754) --------------------------------------------------------
void scanfreq_print_nonce_zero_core_chip()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int m; // [sp+804h] [bp+804h]
  int chain; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]

  g_logfile_no_datetime = 1;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "-----------Chips have 0 nonce cores  -----------\n", chain);
    applog(5, tmp42, 0);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Chain[%d]\n", chain);
        applog(5, tmp42, 0);
      }
      for ( i = 0; scanfreq_info.AsicNum > i; ++i )
      {
        for ( m = 0; m <= 207; ++m )
        {
          if ( !scanfreq_info.asic_core_nonce_num[chain][i][m] )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf((char *)tmp42, 0x800u, "asic[%d] ", i);
              applog(5, tmp42, 0);
            }
            break;
          }
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "\n");
        applog(5, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "\n\n\n");
    applog(5, tmp42, 0);
  }
  g_logfile_no_datetime = 0;
}

//----- (0004B990) --------------------------------------------------------
int scanfreq_print_nonce_info()
{
  int v0; // r3
  unsigned int crc_count; // r0
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+804h] [bp+804h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] && !scanfreq_info.scan_finished[i] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "-------------Chain[%d]-----------\n", i);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "total send work       : %d\n", scanfreq_info.send_work_num[i]);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "require nonce of chain: %d\n", scanfreq_info.RequiredChainNonce);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "received valid nonce  : %d\n", scanfreq_info.valid_nonce_num[i]);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "repeated nonce     : %d\n", scanfreq_info.repeated_nonce_num[i]);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "hw nonce           : %d\n", scanfreq_info.HW_nonce_num[i]);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "other error nonce  : %d\n", scanfreq_info.other_nonce_num[i]);
        applog(5, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "total receive nonce: %d\n\n", scanfreq_info.ret_nonce_num[i]);
        applog(5, tmp42, 0);
      }
      scanfreq_print_bad_chip(i);
    }
  }
  scanfreq_print_nonce_zero_core_chip();
  if ( use_syslog || opt_log_output || (v0 = opt_log_level, opt_log_level > 4) )
  {
    crc_count = get_crc_count();
    snprintf((char *)tmp42, 0x800u, "CRC error counter=%d\n", crc_count);
    applog(5, tmp42, 0);
  }
  return v0;
}
// 4BD3A: variable 'v0' is possibly undefined

//----- (0004BD48) --------------------------------------------------------
void scanfreq_check_result()
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+0h] BYREF
  float nonce_rate; // [sp+810h] [bp+800h]
  int chain; // [sp+814h] [bp+804h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.scan_finished[chain] )
    {
      nonce_rate = (float)((float)scanfreq_info.valid_nonce_num[chain] / (float)scanfreq_info.RequiredChainNonce)
                 * 100.0;
      if ( scanfreq_info.PassNonceRate > nonce_rate )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "********** Chain[%d] is failed, freq=%d, nonce_rate=%f **********\n",
            chain,
            freq_pll_1393_0[freq_one_board[chain]].freq,
            nonce_rate);
          applog(5, tmp42, 0);
        }
        scanfreq_info.current_is_pass[chain] = 0;
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "********** Chain[%d] is pass, freq=%d, nonce_rate=%f **********\n",
            chain,
            freq_pll_1393_0[freq_one_board[chain]].freq,
            nonce_rate);
          applog(5, tmp42, 0);
        }
        scanfreq_info.current_is_pass[chain] = 1;
        scanfreq_info.scan_success[chain] = 1;
        scanfreq_info.pass_freq_index[chain] = scanfreq_info.current_index[chain];
        scanfreq_info.pass_noncerate[chain] = nonce_rate;
      }
      scanfreq_info.scan_freq_index_record[chain][scanfreq_info.scan_record_count[chain]] = scanfreq_info.current_index[chain];
      scanfreq_info.scan_noncerate_record[chain][scanfreq_info.scan_record_count[chain]++] = nonce_rate;
    }
  }
}

//----- (0004C074) --------------------------------------------------------
void scanfreq_finish()
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+0h] BYREF
  int index; // [sp+818h] [bp+800h]
  float volt; // [sp+81Ch] [bp+804h]
  int i; // [sp+820h] [bp+808h]
  int chain; // [sp+824h] [bp+80Ch]

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "\n\n");
    applog(5, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "     ********** Scan Result **********\n");
    applog(5, tmp42, 0);
  }
  scanfreq_info.all_chain_scan_success = 1;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      volt = (float)getVolValueFromPICvoltage(*(_DWORD *)&scanfreq_info.chain_max_pcb_temp[2 * chain - 32]) / 100.0;
      if ( scanfreq_info.scan_success[chain] )
      {
        index = scanfreq_info.scan_index[scanfreq_info.pass_freq_index[chain]];
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "******Chain[%d] Success, Freq=%dM, voltage=%.1fV, NonceRate=%.1f**********",
            chain,
            freq_pll_1393_0[index].freq,
            volt,
            scanfreq_info.pass_noncerate[chain]);
          applog(5, tmp42, 0);
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "******Chain[%d] Failed, voltage=%.1fV  **********", chain, volt);
          applog(5, tmp42, 0);
        }
        scanfreq_info.all_chain_scan_success = 0;
      }
      for ( i = 0; scanfreq_info.scan_record_count[chain] > i; ++i )
      {
        index = scanfreq_info.scan_index[scanfreq_info.scan_freq_index_record[chain][i]];
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%d. No=%d, Freq=%dM, NonceRate=%.1f%%",
            i + 1,
            scanfreq_info.scan_freq_index_record[chain][i],
            freq_pll_1393_0[index].freq,
            scanfreq_info.scan_noncerate_record[chain][i]);
          applog(5, tmp42, 0);
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "\n\n");
        applog(5, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "read clock delay control after test pattern \n");
    applog(5, tmp42, 0);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      pthread_mutex_lock(&iic_mutex);
      dsPIC33EP16GS202_enable_pic_dc_dc(chain, 0);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  pthread_mutex_lock(&iic_mutex);
  pthread_cancel(receive_id);
  pthread_mutex_unlock(&iic_mutex);
}

//----- (0004C55C) --------------------------------------------------------
int scanfreq_needed()
{
  return 1;
}

//----- (0004C56C) --------------------------------------------------------
int scanfreq_prepare()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+804h] [bp+804h]

  ret = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "scanfreq prepare\n");
    applog(5, tmp42, 0);
  }
  memset(&scanfreq_info, 0, (size_t)&scanfreq_info.asic_core_enabled_flag[9][209][240]);
  scanfreq_info.AsicNum = 108;
  scanfreq_info.CoreNum = 208;
  scanfreq_info.AsicWorkCount = 1664;
  scanfreq_info.RequiredChainNonce = 179712;
  scanfreq_info.RequiredAsicNonce = 1664;
  scanfreq_info.PassNonceRate = 98.0;
  strcpy((char *)scanfreq_info.workdataPathPrefix, "/mnt/card/minertest64-BM1393/btc-asic-");
  strcpy((char *)scanfreq_info.workdataFilePrefix, "/btc-core-");
  scanfreq_init_freq_level();
  set_nonce2_jobid_phy_addr();
  bitmain_axi_init();
  check_chain();
  ret = scanfreq_get_works();
  if ( ret >= 0 )
    return 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "scanfreq get works failed\n");
    applog(5, tmp42, 0);
  }
  return ret;
}

//----- (0004C724) --------------------------------------------------------
void bitmain_scan_freq()
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  int max_freq; // [sp+808h] [bp+800h]
  int max_freq_index; // [sp+80Ch] [bp+804h]
  int counter; // [sp+810h] [bp+808h]
  int chain; // [sp+814h] [bp+80Ch]

  chain = 0;
  puts("===Open Power Supply Output===");
  system("echo 907 > /sys/class/gpio/export");
  system("echo out > /sys/class/gpio/gpio907/direction");
  system("echo 0 > /sys/class/gpio/gpio907/value");
  scanfreq_prepare();
  if ( (unsigned __int8)scanfreq_needed() == 1 )
  {
    pthread_create(&receive_id, 0, (void *(*)(void *))scanfreq_receive_nonce_register, 0);
    pthread_detach(receive_id);
    while ( 1 )
    {
      memset(core_hash_clock_counter, 255, sizeof(core_hash_clock_counter));
      scanfreq_get_next_freq();
      if ( scanfreq_is_all_finished() )
        break;
      max_freq_index = scanfreq_get_max_freq_index();
      max_freq = freq_pll_1393_0[scanfreq_info.scan_index[max_freq_index]].freq;
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] )
        {
          if ( !scanfreq_info.scan_finished[chain] )
          {
            freq_one_board[chain] = scanfreq_info.scan_index[scanfreq_info.current_index[chain]];
            freq_one_board_backup[chain] = freq_one_board[chain];
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "\n\nScan frequency Chain[%d], Freq[%dM]\n",
                chain,
                freq_pll_1393_0[freq_one_board[chain]].freq);
              applog(5, tmp42, 0);
            }
          }
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "\n\nMax scan frequency [%dM]\n", max_freq);
        applog(5, tmp42, 0);
      }
      scanfreq_init(max_freq);
      for ( counter = 0; counter <= 0; ++counter )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "\n\nsend counter [%d]\n", counter);
          applog(5, tmp42, 0);
        }
        puts("Reset Rlt");
        scanfreq_reset_result();
        puts("Begin to Send Work");
        pthread_create(&send_id, 0, (void *(*)(void *))scanfreq_send_work, 0);
        pthread_join(send_id, 0);
        scanfreq_print_nonce_info();
        scanfreq_check_result();
      }
      if ( pic_heart_beat )
      {
        pthread_mutex_lock(&iic_mutex);
        pthread_cancel(pic_heart_beat->pth);
        pthread_mutex_unlock(&iic_mutex);
      }
      if ( read_temp_id )
      {
        pthread_mutex_lock(&opencore_readtemp_mutex);
        pthread_cancel(read_temp_id->pth);
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "%s: cancel thread for read temp\n", (const char *)_FUNCTION___15043);
          applog(5, tmp42, 0);
        }
        pthread_mutex_unlock(&opencore_readtemp_mutex);
      }
    }
    scanfreq_finish();
    while ( 1 )
      sleep(1u);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "scan freq is not needed\n");
    applog(5, tmp42, 0);
  }
}

//----- (0004CB58) --------------------------------------------------------
int __cdecl bitmain_soc_init(init_config config)
{
  int dhash_acc_control; // r0
  all_parameters *v3; // r4
  all_parameters *v4; // r2
  int v5; // r1
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  sysinfo si; // [sp+C08h] [bp+C00h] BYREF
  int init_freq; // [sp+C48h] [bp+C40h]
  int freq_step; // [sp+C4Ch] [bp+C44h]
  int hardware_version; // [sp+C50h] [bp+C48h]
  unsigned __int8 voltage; // [sp+C57h] [bp+C4Fh]
  int testCounter; // [sp+C58h] [bp+C50h]
  unsigned int data; // [sp+C5Ch] [bp+C54h]
  uint16_t crc; // [sp+C60h] [bp+C58h]
  unsigned __int8 ret; // [sp+C63h] [bp+C5Bh]
  int offset; // [sp+C64h] [bp+C5Ch]
  int retry_count; // [sp+C68h] [bp+C60h]
  int y; // [sp+C6Ch] [bp+C64h]
  int x; // [sp+C70h] [bp+C68h]
  int i; // [sp+C74h] [bp+C6Ch]

  ret = 0;
  crc = 0;
  i = 0;
  x = 0;
  y = 0;
  data = 0;
  testCounter = 0;
  voltage = 0;
  bitmain_scan_freq();
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "This is user mode for mining\n");
    applog(5, tmp42, 0);
  }
  bitmain_axi_init();
  sysinfo_0(&si);
  if ( si.totalram <= 0x3B9ACA00 )
  {
    if ( si.totalram <= 0x1DCD6500 )
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 251658240;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "Detect 256MB control board of XILINX\n");
        applog(5, tmp42, 0);
      }
    }
    else
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 520093696;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "Detect 512MB control board of XILINX\n");
        applog(5, tmp42, 0);
      }
    }
  }
  else
  {
    PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "Detect 1GB control board of XILINX\n");
      applog(5, tmp42, 0);
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "Miner Type = S11\n");
    applog(5, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Miner compile time: %s type: %s",
      (const char *)g_miner_compiletime,
      (const char *)g_miner_type);
    applog(5, tmp42, 0);
  }
  config_parameter = config;
  if ( config.token_type == 81 )
  {
    crc = CRC16(&config_parameter.token_type, 0x1Eu);
    if ( crc == config_parameter.crc )
    {
      read_nonce_reg_id = (thr_info *)calloc(1u, 0x40u);
      if ( thr_info_create(read_nonce_reg_id, 0, (void *(*)(void *))get_nonce_and_register, read_nonce_reg_id) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: create thread for get nonce and register from FPGA failed\n",
            (const char *)_FUNCTION___15070);
          applog(7, tmp42, 0);
        }
        return -5;
      }
      else
      {
        pthread_detach(read_nonce_reg_id->pth);
        if ( (*((_BYTE *)&config_parameter + 4) & 1) != 0 )
        {
          set_QN_write_data_command(0x8080800F);
          sleep(2u);
          set_PWM(0x64u);
        }
        set_Hardware_version(0x40000000u);
        read_fpga_id(FPGA_ID_str);
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "miner ID : %s\n", (const char *)FPGA_ID_str);
          applog(5, tmp42, 0);
        }
        hardware_version = get_hardware_version();
        pcb_version = (hardware_version >> 16) & 0x7FFF;
        fpga_version = (unsigned __int8)hardware_version;
        fpga_major_version = BYTE1(hardware_version);
        sprintf(
          (char *)g_miner_version,
          "%d.%d.%d.%d",
          ((BYTE1(hardware_version) - 197) << 8) + (unsigned __int8)hardware_version,
          (hardware_version >> 16) & 0x7FFF,
          1,
          3);
        dev->baud = 26;
        set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
        set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy((char *)tmp42, "begin to check chain\n");
          applog(5, tmp42, 0);
        }
        check_chain();
        set_PWM(0x64u);
        puts("reset down");
        reset_down_hash_board();
        for ( i = 0; i <= 15; ++i )
        {
          if ( dev->chain_exist[i] == 1 )
          {
            pthread_mutex_lock(&iic_mutex);
            dsPIC33EP16GS202_reset_pic(i);
            pthread_mutex_unlock(&iic_mutex);
            cgsleep_ms(100);
            pthread_mutex_lock(&iic_mutex);
            dsPIC33EP16GS202_jump_to_app_from_loader(i);
            pthread_mutex_unlock(&iic_mutex);
            cgsleep_ms(100);
          }
        }
        pic_heart_beat = (thr_info *)calloc(1u, 0x40u);
        if ( thr_info_create(pic_heart_beat, 0, (void *(*)(void *))pic_heart_beat_func, pic_heart_beat) )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: create thread for get nonce and register from FPGA failed\n",
              (const char *)_FUNCTION___15070);
            applog(7, tmp42, 0);
          }
          return -5;
        }
        else
        {
          pthread_detach(pic_heart_beat->pth);
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "============%s=========%d==========================",
              (const char *)_FUNCTION___15070,
              10945);
            applog(5, tmp42, 0);
          }
          for ( i = 0; i <= 15; ++i )
          {
            if ( dev->chain_exist[i] == 1 )
            {
              pthread_mutex_lock(&iic_mutex);
              AT24C02_read_voltage(i);
              voltage = 33;
              pthread_mutex_unlock(&iic_mutex);
              printf("Chain[%d] read pic voltage=%d\n", i, voltage);
              pthread_mutex_lock(&iic_mutex);
              set_voltage_T9_18_into_PIC(i, voltage);
              pthread_mutex_unlock(&iic_mutex);
            }
          }
          reset_up_hash_board();
          usleep(0x30D40u);
          reset_hash_board();
          puts("reset over, send data");
          if ( opt_multi_version )
          {
            dhash_acc_control = get_dhash_acc_control();
            set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
          }
          cgsleep_ms(10);
          dev->corenum = -48;
          check_asic_reg(0);
          cgsleep_ms(10);
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            strcpy(
              (char *)tmp42,
              "------------------------------------------------------------------------------------");
            applog(5, tmp42, 0);
          }
          for ( i = 0; i <= 15; ++i )
          {
            if ( dev->chain_exist[i] == 1 )
            {
              retry_count = 0;
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)tmp42, 0x800u, "Chain[J%d] has %d asic\n", i + 1, dev->chain_asic_num[i]);
                applog(5, tmp42, 0);
              }
              while ( dev->chain_asic_num[i] != 108 && retry_count <= 5 )
              {
                dev->chain_asic_num[i] = 0;
                set_reset_hashboard(i, 1);
                pthread_mutex_lock(&iic_mutex);
                dsPIC33EP16GS202_enable_pic_dc_dc(i, 0);
                pthread_mutex_unlock(&iic_mutex);
                sleep(1u);
                pthread_mutex_lock(&iic_mutex);
                dsPIC33EP16GS202_enable_pic_dc_dc(i, 1u);
                pthread_mutex_unlock(&iic_mutex);
                sleep(2u);
                set_reset_hashboard(i, 0);
                sleep(1u);
                check_asic_reg_oneChain(i, 0);
                if ( use_syslog || opt_log_output || opt_log_level > 4 )
                {
                  snprintf((char *)tmp42, 0x800u, "retry Chain[J%d] has %d asic\n", i + 1, dev->chain_asic_num[i]);
                  applog(5, tmp42, 0);
                }
                ++retry_count;
              }
              if ( !dev->chain_asic_num[i] )
                dev->chain_exist[i] = 0;
            }
          }
          for ( i = 0; i <= 15; ++i )
          {
            if ( dev->chain_exist[i] && (use_syslog || opt_log_output || opt_log_level > 4) )
            {
              snprintf((char *)tmp42, 0x800u, "Chain%d has %d ASICs", i, dev->chain_asic_num[i]);
              applog(5, tmp42, 0);
            }
          }
          software_set_address(2);
          cgsleep_ms(10);
          freq_step = 50;
          init_freq = 175;
          if ( (*((_BYTE *)&config_parameter + 4) & 8) != 0 )
          {
            dev->frequency = config_parameter.frequency;
            sprintf((char *)dev->frequency_t, "%u", dev->frequency);
          }
          cgsleep_ms(10);
          dev->fan_eft = (*((_BYTE *)&config_parameter + 4) & 2) != 0;
          dev->fan_pwm = config_parameter.fan_pwm_percent;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: fan_eft : %d  fan_pwm : %d\n",
              (const char *)_FUNCTION___15070,
              dev->fan_eft,
              dev->fan_pwm);
            applog(7, tmp42, 0);
          }
          if ( (*((_BYTE *)&config_parameter + 4) & 2) != 0 && config_parameter.fan_pwm_percent <= 0x64u )
            set_PWM(config_parameter.fan_pwm_percent);
          else
            set_PWM_according_to_temperature();
          if ( (*((_BYTE *)&config_parameter + 4) & 4) != 0 )
          {
            if ( config_parameter.timeout_data_integer || config_parameter.timeout_data_fractions )
            {
              dev->timeout = 1000 * config_parameter.timeout_data_integer + config_parameter.timeout_data_fractions;
            }
            else
            {
              v3 = dev;
              v3->timeout = 90
                          * (dev->addrInterval
                           * (0x1000000
                            / calculate_core_number(dev->corenum))
                           / dev->frequency)
                          / 100;
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)tmp42, 0x800u, "dev->timeout = %d\n", dev->timeout);
                applog(5, tmp42, 0);
              }
            }
            if ( dev->timeout > 0x1FFFF )
              dev->timeout = 0x1FFFF;
          }
          init_uart_baud();
          cgsleep_ms(10);
          set_clock_delay_control();
          puts("===pre open core===");
          open_core_BM1393_pre_open(5u, 1u);
          for ( i = 0; i <= 15; ++i )
          {
            if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] == 108 )
            {
              calibration_sensor_offset(0x98u, i);
              cgsleep_ms(10);
            }
          }
          if ( opt_multi_version )
            set_time_out_control(0x8000C350);
          else
            set_time_out_control((dev->timeout / 0xA) & 0x1FFFF | 0x80000000);
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            strcpy((char *)tmp42, "set TICKET_MASK");
            applog(5, tmp42, 0);
          }
          set_asic_ticket_mask(ticket_mask);
          cgsleep_ms(10);
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            strcpy((char *)tmp42, "Start Open Core!!");
            applog(5, tmp42, 0);
          }
          open_core_bm1393(0);
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            strcpy((char *)tmp42, "End Open Core!!");
            applog(5, tmp42, 0);
          }
          set_time_out_control((dev->timeout / 0xA) & 0x1FFFF | 0x80000000);
          for ( x = 0; x <= 15; ++x )
          {
            if ( dev->chain_exist[x] )
            {
              offset = 0;
              for ( y = 0; dev->chain_asic_num[x] > y; ++y )
              {
                if ( (y & 7) == 0 )
                  dev->chain_asic_status_string[x][y + offset++] = 32;
                dev->chain_asic_status_string[x][y + offset] = 111;
                v4 = dev;
                v5 = (x << 7) + y + 354;
                *(&dev->pwm_value + 2 * v5) = 0;
                v4->chain_exist[2 * v5] = 0;
              }
              dev->chain_asic_status_string[x][y + offset] = 0;
            }
          }
          read_temp_id = (thr_info *)calloc(1u, 0x40u);
          if ( thr_info_create(read_temp_id, 0, (void *(*)(void *))read_temp_func, read_temp_id) )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42, 0x800u, "%s: create thread for read temp\n", (const char *)_FUNCTION___15070);
              applog(7, tmp42, 0);
            }
            return -7;
          }
          else
          {
            pthread_detach(read_temp_id->pth);
            cgtime(&tv_send_job);
            cgtime(&tv_send);
            startCheckNetworkJob = 1;
            read_hash_rate = (thr_info *)calloc(1u, 0x40u);
            if ( thr_info_create(read_hash_rate, 0, (void *(*)(void *))get_hash_rate, read_hash_rate) )
            {
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  (char *)tmp42,
                  0x800u,
                  "%s: create thread for get hashrate from asic failed",
                  (const char *)_FUNCTION___15070);
                applog(7, tmp42, 0);
              }
              return -6;
            }
            else
            {
              pthread_detach(read_hash_rate->pth);
              cgsleep_ms(500);
              setStartTimePoint();
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                strcpy((char *)tmp42, "Init OK!");
                applog(5, tmp42, 0);
              }
              return 0;
            }
          }
        }
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
          (const char *)_FUNCTION___15070,
          config_parameter.crc,
          crc);
        applog(7, tmp42, 0);
      }
      return -2;
    }
  }
  else
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: config_parameter.token_type != 0x%x, it is 0x%x\n",
        (const char *)_FUNCTION___15070,
        81,
        config_parameter.token_type);
      applog(7, tmp42, 0);
    }
    return -1;
  }
}

//----- (0004DF70) --------------------------------------------------------
void bitmain_core_reInit()
{
  ;
}

//----- (0004DF88) --------------------------------------------------------
int __cdecl parse_job_to_soc(unsigned __int8 **buf, pool *pool, unsigned int id)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+10h] BYREF
  part_of_job part_job; // [sp+810h] [bp+810h] BYREF
  uint64_t nonce2; // [sp+860h] [bp+860h] BYREF
  uint16_t crc; // [sp+86Eh] [bp+86Eh] BYREF
  unsigned __int8 *tmp_buf; // [sp+870h] [bp+870h]
  unsigned __int8 *buf_hex; // [sp+874h] [bp+874h]
  unsigned int buf_len; // [sp+878h] [bp+878h]
  int i; // [sp+87Ch] [bp+87Ch]

  crc = 0;
  buf_len = 0;
  nonce2 = 0LL;
  buf_hex = 0;
  part_job.token_type = 82;
  part_job.version = 0;
  part_job.pool_nu = pool_send_nu_15141;
  *((_BYTE *)&part_job + 9) = *((_BYTE *)&part_job + 9) & 0xFE | pool->swork.clean | 2;
  part_job.asic_diff = 15;
  part_job.job_id = id;
  hex2bin((unsigned __int8 *)&part_job.bbversion, pool->bbversion, 4u);
  hex2bin(part_job.prev_hash, pool->prev_hash, 0x20u);
  hex2bin((unsigned __int8 *)&part_job.nbit, pool->nbit, 4u);
  hex2bin((unsigned __int8 *)&part_job.ntime, pool->ntime, 4u);
  part_job.coinbase_len = pool->coinbase_len;
  part_job.nonce2_offset = pool->nonce2_offset;
  part_job.nonce2_bytes_num = pool->n2size;
  nonce2 = pool->nonce2;
  memcpy(&part_job.nonce2_start_value, &pool->coinbase[pool->nonce2_offset], sizeof(part_job.nonce2_start_value));
  memcpy(&part_job.nonce2_start_value, &nonce2, pool->n2size);
  part_job.merkles_num = pool->merkles;
  buf_len = pool->coinbase_len + 32 * pool->merkles + 82;
  tmp_buf = (unsigned __int8 *)malloc(buf_len);
  if ( !tmp_buf )
  {
    strcpy((char *)tmp42, "Failed to malloc tmp_buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  part_job.length = buf_len - 8;
  memset(tmp_buf, 0, buf_len);
  memcpy(tmp_buf, &part_job, 0x50u);
  memcpy(tmp_buf + 80, pool->coinbase, pool->coinbase_len);
  for ( i = 0; pool->merkles > i; ++i )
    memcpy(&tmp_buf[32 * i + 80 + pool->coinbase_len], pool->swork.merkle_bin[i], 0x20u);
  crc = CRC16(tmp_buf, buf_len - 2);
  memcpy(&tmp_buf[buf_len - 2], &crc, 2u);
  ++pool_send_nu_15141;
  *buf = (unsigned __int8 *)malloc(buf_len);
  if ( !tmp_buf )
  {
    strcpy((char *)tmp42, "Failed to malloc buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  memcpy(*buf, tmp_buf, buf_len);
  memcpy(last_job_buffer, tmp_buf, buf_len);
  free(tmp_buf);
  return buf_len;
}

//----- (0004E308) --------------------------------------------------------
void __cdecl show_status(int if_quit)
{
  int dhash_acc_control; // r0
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int buf[2]; // [sp+80Ch] [bp+80Ch] BYREF
  unsigned __int8 *buf_hex; // [sp+814h] [bp+814h]
  int i; // [sp+818h] [bp+818h]
  unsigned int *l_job_start_address; // [sp+81Ch] [bp+81Ch]

  buf_hex = 0;
  l_job_start_address = 0;
  buf[0] = 0;
  buf[1] = 0;
  i = 0;
  get_work_nonce2(buf);
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  while ( (get_dhash_acc_control() & 0x40) != 0 )
  {
    cgsleep_ms(1);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: run bit is 1 after set it to 0", (const char *)_FUNCTION___15157);
      applog(7, tmp42, 0);
    }
  }
  buf_hex = bin2hex((const unsigned __int8 *)dev->current_job_start_address, c_coinbase_padding);
  free(buf_hex);
  for ( i = 0; i < c_merkles_num; ++i )
  {
    buf_hex = bin2hex((const unsigned __int8 *)&dev->current_job_start_address[8 * i] + c_coinbase_padding, 0x20u);
    free(buf_hex);
  }
  if ( dev->current_job_start_address == job_start_address_1 )
  {
    l_job_start_address = job_start_address_2;
  }
  else if ( dev->current_job_start_address == job_start_address_2 )
  {
    l_job_start_address = job_start_address_1;
  }
  buf_hex = bin2hex((const unsigned __int8 *)l_job_start_address, l_coinbase_padding);
  free(buf_hex);
  for ( i = 0; i < l_merkles_num; ++i )
  {
    buf_hex = bin2hex((const unsigned __int8 *)&l_job_start_address[8 * i] + l_coinbase_padding, 0x20u);
    free(buf_hex);
  }
  if ( if_quit )
  {
    strcpy((char *)tmp42, "HW is more than 5!!");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0004E54C) --------------------------------------------------------
void __cdecl show_pool_status(pool *pool, uint64_t nonce2)
{
  int nonce2a; // [sp+0h] [bp+0h]
  unsigned __int8 *buf_hex; // [sp+10h] [bp+10h]
  unsigned __int8 *buf_hexa; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  nonce2a = nonce2;
  buf_hex = bin2hex(pool->coinbase, pool->coinbase_len);
  printf("%s: nonce2 0x%x\n", (const char *)_FUNCTION___15174, nonce2a);
  printf("%s: coinbase : %s\n", (const char *)_FUNCTION___15174, (const char *)buf_hex);
  free(buf_hex);
  for ( i = 0; pool->merkles > i; ++i )
  {
    buf_hexa = bin2hex(pool->swork.merkle_bin[i], 0x20u);
    printf("%s: merkle_bin %d : %s\n", (const char *)_FUNCTION___15174, i, (const char *)buf_hexa);
    free(buf_hexa);
  }
}

//----- (0004E600) --------------------------------------------------------
int __cdecl send_job(unsigned __int8 *buf, pool *pool)
{
  int dhash_acc_control; // r0
  int nonce_fifo_interrupt; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  unsigned int buf2[32]; // [sp+818h] [bp+808h] BYREF
  unsigned __int8 buf1[32]; // [sp+898h] [bp+888h] BYREF
  part_of_job *part_job; // [sp+8B8h] [bp+8A8h]
  unsigned __int8 *coinbase_padding; // [sp+8BCh] [bp+8ACh]
  unsigned __int8 *temp_buf; // [sp+8C0h] [bp+8B0h]
  unsigned __int16 job_length; // [sp+8C4h] [bp+8B4h]
  unsigned __int16 crc; // [sp+8C6h] [bp+8B6h]
  unsigned int j; // [sp+8C8h] [bp+8B8h]
  unsigned int len; // [sp+8CCh] [bp+8BCh]
  int times; // [sp+8D0h] [bp+8C0h]
  unsigned __int8 *merkles_bin; // [sp+8D4h] [bp+8C4h]
  unsigned int coinbase_padding_len; // [sp+8D8h] [bp+8C8h]
  unsigned int i; // [sp+8DCh] [bp+8CCh]

  len = 0;
  i = 0;
  j = 0;
  coinbase_padding_len = 0;
  crc = 0;
  job_length = 0;
  temp_buf = 0;
  coinbase_padding = 0;
  merkles_bin = 0;
  memset(buf1, 0, sizeof(buf1));
  memset(buf2, 0, sizeof(buf2));
  times = 0;
  part_job = 0;
  if ( doTestPatten )
    return 0;
  if ( *buf != 82 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", (const char *)_FUNCTION___15196, *buf);
      applog(7, tmp42, 0);
    }
    return -1;
  }
  len = *((_DWORD *)buf + 1);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: len = 0x%x\n", (const char *)_FUNCTION___15196, len);
    applog(7, tmp42, 0);
  }
  temp_buf = (unsigned __int8 *)malloc(len + 8);
  if ( !temp_buf )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: malloc buffer failed.\n", (const char *)_FUNCTION___15196);
      applog(7, tmp42, 0);
    }
    return -2;
  }
  memset(temp_buf, 0, len + 8);
  memcpy(temp_buf, buf, len + 8);
  part_job = (part_of_job *)temp_buf;
  if ( dev->current_job_start_address == job_start_address_1 )
  {
    dev->current_job_start_address = job_start_address_2;
  }
  else
  {
    if ( dev->current_job_start_address != job_start_address_2 )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: dev->current_job_start_address = 0x%x, but job_start_address_1 = 0x%x, job_start_address_2 = 0x%x\n",
          (const char *)_FUNCTION___15196,
          dev->current_job_start_address,
          job_start_address_1,
          job_start_address_2);
        applog(7, tmp42, 0);
      }
      return -3;
    }
    dev->current_job_start_address = job_start_address_1;
  }
  if ( (part_job->coinbase_len & 0x3Fu) <= 0x37 )
    coinbase_padding_len = ((part_job->coinbase_len >> 6) + 1) << 6;
  else
    coinbase_padding_len = ((part_job->coinbase_len >> 6) + 2) << 6;
  coinbase_padding = (unsigned __int8 *)malloc(coinbase_padding_len);
  if ( !coinbase_padding )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: malloc coinbase_padding failed.\n", (const char *)_FUNCTION___15196);
      applog(7, tmp42, 0);
    }
    return -4;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: coinbase_padding = 0x%x", (const char *)_FUNCTION___15196, coinbase_padding);
    applog(7, tmp42, 0);
  }
  if ( part_job->merkles_num )
  {
    merkles_bin = (unsigned __int8 *)malloc(32 * part_job->merkles_num);
    if ( !merkles_bin )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s: malloc merkles_bin failed.\n", (const char *)_FUNCTION___15196);
        applog(7, tmp42, 0);
      }
      return -5;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: merkles_bin = 0x%x", (const char *)_FUNCTION___15196, merkles_bin);
      applog(7, tmp42, 0);
    }
  }
  memset(coinbase_padding, 0, coinbase_padding_len);
  memcpy(coinbase_padding, buf + 80, part_job->coinbase_len);
  coinbase_padding[part_job->coinbase_len] = 0x80;
  *(_DWORD *)&coinbase_padding[4 * ((coinbase_padding_len - 4) >> 2)] = (part_job->coinbase_len << 27) | ((8 * (unsigned int)part_job->coinbase_len) >> 24) | (((8 * part_job->coinbase_len) & 0xFF0000u) >> 8) | (((8 * part_job->coinbase_len) & 0xFF00) << 8);
  *(_DWORD *)&coinbase_padding[4 * ((coinbase_padding_len - 8) >> 2)] = 0;
  l_coinbase_padding = c_coinbase_padding;
  c_coinbase_padding = coinbase_padding_len;
  for ( i = 0; i < coinbase_padding_len; ++i )
    *((_BYTE *)dev->current_job_start_address + i) = coinbase_padding[i];
  for ( i = 0; i < coinbase_padding_len; ++i )
  {
    if ( *((unsigned __int8 *)dev->current_job_start_address + i) != coinbase_padding[i]
      && opt_debug
      && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
        (const char *)_FUNCTION___15196,
        i,
        *((unsigned __int8 *)dev->current_job_start_address + i),
        i,
        coinbase_padding[i]);
      applog(7, tmp42, 0);
    }
  }
  l_merkles_num = c_merkles_num;
  c_merkles_num = part_job->merkles_num;
  if ( part_job->merkles_num )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: copy merkle bin into memory ...\n", (const char *)_FUNCTION___15196);
      applog(7, tmp42, 0);
    }
    memset(merkles_bin, 0, 32 * part_job->merkles_num);
    memcpy(merkles_bin, &buf[part_job->coinbase_len + 80], 32 * part_job->merkles_num);
    for ( i = 0; 32 * (unsigned int)part_job->merkles_num > i; ++i )
      *((_BYTE *)dev->current_job_start_address + coinbase_padding_len + i) = merkles_bin[i];
    for ( i = 0; 32 * (unsigned int)part_job->merkles_num > i; ++i )
    {
      if ( *((unsigned __int8 *)dev->current_job_start_address + coinbase_padding_len + i) != merkles_bin[i]
        && opt_debug
        && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: merkles_in_ddr[%d] = 0x%x, but *(merkles_bin + %d) =0x%x",
          (const char *)_FUNCTION___15196,
          i,
          *((unsigned __int8 *)dev->current_job_start_address + coinbase_padding_len + i),
          i,
          merkles_bin[i]);
        applog(7, tmp42, 0);
      }
    }
  }
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  while ( (get_dhash_acc_control() & 0x40) != 0 )
  {
    cgsleep_ms(1);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: run bit is 1 after set it to 0\n", (const char *)_FUNCTION___15196);
      applog(7, tmp42, 0);
    }
    ++times;
  }
  cgsleep_ms(1);
  if ( dev->current_job_start_address == job_start_address_1 )
  {
    set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  }
  else if ( dev->current_job_start_address == job_start_address_2 )
  {
    set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2162688);
  }
  if ( (*((_BYTE *)part_job + 9) & 2) != 0 )
  {
    set_ticket_mask(part_job->asic_diff);
    dev->diff = part_job->asic_diff;
  }
  set_job_id(part_job->job_id);
  set_block_header_version(part_job->bbversion);
  memset(buf2, 0, sizeof(buf2));
  for ( i = 0; i <= 7; ++i )
    buf2[i] = part_job->prev_hash[4 * i] | (part_job->prev_hash[4 * i + 3] << 24) | (part_job->prev_hash[4 * i + 2] << 16) | (part_job->prev_hash[4 * i + 1] << 8);
  set_pre_header_hash(buf2);
  set_time_stamp(part_job->ntime);
  set_target_bits(part_job->nbit);
  j = (unsigned __int8)(coinbase_padding_len >> 6) | (part_job->nonce2_offset << 16) | ((unsigned __int8)part_job->nonce2_bytes_num << 8);
  set_coinbase_length_and_nonce2_length(j);
  buf2[0] = 0;
  buf2[1] = 0;
  *(_QWORD *)buf2 = part_job->nonce2_start_value;
  set_work_nonce2(buf2);
  set_merkle_bin_number(part_job->merkles_num);
  job_length = 32 * part_job->merkles_num + coinbase_padding_len;
  set_job_length(job_length);
  cgsleep_ms(1);
  pool->check_asicboost_over = 1;
  pool->support_asicboost = 0;
  if ( !gBegin_get_nonce )
  {
    nonce_fifo_interrupt = get_nonce_fifo_interrupt();
    set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
    gBegin_get_nonce = 1;
  }
  if ( (*((_BYTE *)part_job + 9) & 1) != 0 )
  {
    if ( opt_multi_version )
    {
      v7 = get_dhash_acc_control();
      set_dhash_acc_control(v7 | 0x80);
      v8 = get_dhash_acc_control();
      set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | v8 & 0xFFFFF0FF | 0x8060);
    }
    else
    {
      v5 = get_dhash_acc_control();
      set_dhash_acc_control(v5 | 0x80);
      v6 = get_dhash_acc_control();
      set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | v6 & 0xFFFFF0FF | 0x60);
    }
  }
  else if ( opt_multi_version )
  {
    v10 = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | v10 & 0xFFFFF0FF | 0x8060);
  }
  else
  {
    v9 = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | v9 & 0xFFFFF0FF | 0x60);
  }
  free(temp_buf);
  free(coinbase_padding);
  if ( part_job->merkles_num )
    free(merkles_bin);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "--- %s end\n", (const char *)_FUNCTION___15196);
    applog(7, tmp42, 0);
  }
  cgtime(&tv_send_job);
  cgsleep_ms(1);
  return 0;
}

//----- (0004F3A4) --------------------------------------------------------
void re_send_last_job()
{
  if ( last_job_buffer[0] != 23 )
  {
    pthread_mutex_lock(&reinit_mutex);
    pthread_mutex_unlock(&reinit_mutex);
  }
}

//----- (0004F3D0) --------------------------------------------------------
void __cdecl copy_pool_stratum(pool *pool_stratum, pool *pool)
{
  uint16_t v2; // r0
  unsigned __int8 **v3; // r4
  unsigned __int16 crc; // [sp+16h] [bp+Eh]
  uint16_t job_id_len; // [sp+18h] [bp+10h]
  unsigned int coinbase_len; // [sp+1Ch] [bp+14h]
  int merkles; // [sp+20h] [bp+18h]
  int i; // [sp+24h] [bp+1Ch]
  int ia; // [sp+24h] [bp+1Ch]

  merkles = pool->merkles;
  coinbase_len = pool->coinbase_len;
  if ( pool->swork.job_id )
  {
    if ( !pool_stratum->swork.job_id
      || (v2 = strlen((const char *)pool->swork.job_id),
          crc = CRC16(pool->swork.job_id, v2),
          job_id_len = strlen((const char *)pool_stratum->swork.job_id),
          crc != CRC16(pool_stratum->swork.job_id, job_id_len)) )
    {
      cg_wlock_1(&pool_stratum->data_lock, "driver-btm-soc.c", _func___15238, 11691);
      free(pool_stratum->swork.job_id);
      free(pool_stratum->nonce1);
      free(pool_stratum->coinbase);
      pool_stratum->coinbase = (unsigned __int8 *)cgcalloc(coinbase_len, 1u, "driver-btm-soc.c", _func___15238, 11696);
      memcpy(pool_stratum->coinbase, pool->coinbase, coinbase_len);
      for ( i = 0; pool_stratum->merkles > i; ++i )
        free(pool_stratum->swork.merkle_bin[i]);
      if ( merkles )
      {
        pool_stratum->swork.merkle_bin = (unsigned __int8 **)cgrealloc(
                                                               pool_stratum->swork.merkle_bin,
                                                               4 * merkles + 1,
                                                               "driver-btm-soc.c",
                                                               _func___15238,
                                                               11704);
        for ( ia = 0; ia < merkles; ++ia )
        {
          v3 = &pool_stratum->swork.merkle_bin[ia];
          *v3 = (unsigned __int8 *)cgmalloc(0x20u, "driver-btm-soc.c", _func___15238, 11707);
          memcpy(pool_stratum->swork.merkle_bin[ia], pool->swork.merkle_bin[ia], 0x20u);
        }
      }
      pool_stratum->sdiff = pool->sdiff;
      pool_stratum->coinbase_len = pool->coinbase_len;
      pool_stratum->nonce2_offset = pool->nonce2_offset;
      pool_stratum->n2size = pool->n2size;
      pool_stratum->merkles = pool->merkles;
      pool_stratum->swork.job_id = (unsigned __int8 *)strdup((const char *)pool->swork.job_id);
      pool_stratum->nonce1 = (unsigned __int8 *)strdup((const char *)pool->nonce1);
      memcpy(pool_stratum->ntime, pool->ntime, sizeof(pool_stratum->ntime));
      memcpy(pool_stratum->header_bin, pool->header_bin, sizeof(pool_stratum->header_bin));
      cg_wunlock_1(&pool_stratum->data_lock, "driver-btm-soc.c", _func___15238, 11722);
    }
  }
}

//----- (0004F664) --------------------------------------------------------
bool __cdecl bitmain_soc_prepare(thr_info *thr)
{
  init_config soc_config; // [sp+18h] [bp+8h] BYREF
  bitmain_soc_info *info; // [sp+38h] [bp+28h]
  cgpu_info *bitmain_soc; // [sp+3Ch] [bp+2Ch]

  bitmain_soc = thr->cgpu;
  info = (bitmain_soc_info *)bitmain_soc->device_data;
  info->thr = thr;
  mutex_init_1(&info->lock, "driver-btm-soc.c", _func___15250, 11731);
  cglock_init_0(&info->update_lock, "driver-btm-soc.c", _func___15250, 11732);
  cglock_init_0(&info->pool0.data_lock, "driver-btm-soc.c", _func___15250, 11733);
  cglock_init_0(&info->pool1.data_lock, "driver-btm-soc.c", _func___15250, 11734);
  cglock_init_0(&info->pool2.data_lock, "driver-btm-soc.c", _func___15250, 11735);
  *(_DWORD *)&soc_config.token_type = 1704017;
  *(_DWORD *)&soc_config.chain_num = 1342191113;
  *(_DWORD *)&soc_config.chain_check_time_integer = 2570;
  soc_config.reg_data = 0;
  *(_DWORD *)&soc_config.chip_address = 26214404;
  *(_DWORD *)&soc_config.chain_max_freq = 600;
  *((_DWORD *)&soc_config + 1) = (unsigned __int8)(2 * opt_bitmain_fan_ctrl) | 0xFD;
  *(_WORD *)((char *)&soc_config + 5) = 7;
  soc_config.fan_pwm_percent = opt_bitmain_fan_pwm;
  soc_config.frequency = opt_bitmain_soc_freq;
  soc_config.voltage[0] = 7;
  soc_config.voltage[1] = 37;
  soc_config.crc = CRC16(&soc_config.token_type, 0x1Eu);
  bitmain_soc_init(soc_config);
  return 1;
}

//----- (0004F838) --------------------------------------------------------
void __cdecl bitmain_soc_reinit_device(cgpu_info *bitmain)
{
  if ( !status_error )
    exit(0);
}

//----- (0004F864) --------------------------------------------------------
void __cdecl bitmain_soc_detect(bool hotplug)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  bitmain_soc_info *a; // [sp+80Ch] [bp+80Ch]
  device_drv *drv; // [sp+810h] [bp+810h]
  cgpu_info *cgpu; // [sp+814h] [bp+814h]

  cgpu = (cgpu_info *)calloc(1u, 0x188u);
  drv = &bitmain_soc_drv;
  if ( !cgpu )
    _assert_fail("cgpu", "driver-btm-soc.c", 0x2E13u, (const char *)_PRETTY_FUNCTION___15261);
  cgpu->drv = drv;
  cgpu->deven = DEV_ENABLED;
  cgpu->threads = 1;
  cgpu->device_data = calloc(0x18B0u, 1u);
  if ( !cgpu->device_data )
  {
    strcpy((char *)tmp42, "Failed to calloc cgpu_info data");
    applog(3, tmp42, 1);
    quit(1);
  }
  a = (bitmain_soc_info *)cgpu->device_data;
  a->pool0_given_id = 0;
  a->pool1_given_id = 1;
  a->pool2_given_id = 2;
  if ( !add_cgpu(cgpu) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-soc.c", 0x2E1Fu, (const char *)_PRETTY_FUNCTION___15261);
}

//----- (0004F98C) --------------------------------------------------------
void __cdecl btm_save_core_nonce(int asic, int core, int chain)
{
  if ( asic >= 0 && asic <= 108 && core >= 0 && core <= 208 && chain >= 0 && chain <= 16 )
  {
    if ( dev->chain_exist[chain] == 1 )
      ++asic_core_nonce_num_chain[chain][asic][core];
    else
      printf("[%s] chain num is not exist\n", (const char *)_func___15271);
  }
  else
  {
    printf("[%s] asic[%d]-core[%d]-chain[%d] input error!!", (const char *)_func___15271, asic, core, chain);
  }
}

//----- (0004FA5C) --------------------------------------------------------
void btm_clear_core_nonce()
{
  memset(asic_core_nonce_num_chain, 0, (size_t)&nonce_num[13][101][37]);
}

//----- (0004FA78) --------------------------------------------------------
void __cdecl btm_init_core_nonce_file(unsigned int num)
{
  unsigned __int8 tmp[100]; // [sp+Ch] [bp+Ch] BYREF

  memset(tmp, 0, sizeof(tmp));
  snprintf((char *)tmp, 0x64u, "/tmp/core_nonce[%d].txt", num);
  fd_core = fopen((const char *)tmp, "w");
  if ( fd_core )
    fclose(fd_core);
}

//----- (0004FAEC) --------------------------------------------------------
void btm_init_open_again_file()
{
  fd_open = fopen("/tmp/open_again.txt", "w");
  if ( fd_open )
    fclose(fd_open);
}

//----- (0004FB30) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl btm_enable_one_corebyasic(
        unsigned __int8 core_id,
        unsigned __int8 mode,
        unsigned __int8 chain,
        unsigned __int8 chip_addr)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  __int64 buf; // [sp+18h] [bp+18h] OVERLAPPED BYREF
  unsigned int value; // [sp+20h] [bp+20h]
  unsigned int ret; // [sp+24h] [bp+24h]

  BYTE4(buf) = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  LODWORD(buf) = 65;
  if ( mode )
    LOBYTE(buf) = buf | 0x10;
  BYTE1(buf) = 9;
  BYTE2(buf) = chip_addr;
  strcpy((char *)&buf + 3, "<");
  BYTE5(buf) = core_id;
  HIWORD(buf) = -21884;
  LOBYTE(value) = CRC5((unsigned __int8 *)&buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(buf);
  cmd_buf[1] = _byteswap_ulong(HIDWORD(buf));
  cmd_buf[2] = (unsigned __int8)value << 24;
  set_BC_command_buffer(cmd_buf);
  ret = get_BC_write_command();
  value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
  usleep(0x1388u);
}
// 4FB30: variables would overlap: ^18.8 and stkvar "buf" ^18.5(has user info)

//----- (0004FC14) --------------------------------------------------------
void __cdecl btm_reopen_core_again(int asic, int core, int chain)
{
  size_t v3; // r0
  unsigned __int8 tmp[200]; // [sp+18h] [bp+10h] BYREF

  memset(tmp, 0, sizeof(tmp));
  if ( asic >= 0 && asic <= 108 && core >= 0 && core <= 208 && chain >= 0 && chain <= 16 )
  {
    if ( dev->chain_exist[chain] == 1 )
    {
      printf("[%02d][%02d][%03d] open again\n", chain, asic, core);
      btm_enable_one_corebyasic(core, 0, chain, asic * dev->addrInterval);
      fd_open = fopen("/tmp/open_again.txt", "a+");
      if ( fd_open )
      {
        sprintf((char *)tmp, "Chain[%02d]-Asic[%02d]-Core[%03d] open again\n", chain, asic, core);
        v3 = strlen((const char *)tmp);
        fwrite(tmp, v3, 1u, fd_open);
        fclose(fd_open);
      }
    }
    else
    {
      printf("[%s] chain num is not exist\n", (const char *)_func___15299);
    }
  }
  else
  {
    printf("[%s] asic[%d]-core[%d]-chain[%d] input error!!", (const char *)_func___15299, asic, core, chain);
  }
}

//----- (0004FD64) --------------------------------------------------------
FILE *__cdecl btm_open_core_nonce_file(unsigned int num)
{
  FILE *result; // r0
  unsigned __int8 tmp[100]; // [sp+Ch] [bp+Ch] BYREF

  memset(tmp, 0, sizeof(tmp));
  snprintf((char *)tmp, 0x64u, "/tmp/core_nonce[%d].txt", num);
  result = fopen((const char *)tmp, "r+");
  fd_core = result;
  return result;
}

//----- (0004FDC4) --------------------------------------------------------
void btm_show_core_nonce()
{
  size_t v1; // r0
  unsigned __int8 *tmp; // [sp+0h] [bp+0h]
  FILE *file_tmp; // [sp+4h] [bp+4h]
  int len; // [sp+8h] [bp+8h]
  int k; // [sp+Ch] [bp+Ch]
  int j; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  len = 0;
  tmp = (unsigned __int8 *)malloc(0x40000u);
  if ( tmp )
  {
    memset(tmp, 0, 0x40000u);
    if ( loop_15312++ > 6 )
    {
      btm_init_core_nonce_file(++time_num);
      btm_clear_core_nonce();
      loop_15312 = 0;
    }
    file_tmp = btm_open_core_nonce_file(time_num);
    if ( file_tmp )
    {
      for ( k = 0; k <= 15; ++k )
      {
        if ( dev->chain_exist[k] == 1 )
        {
          len += sprintf((char *)&tmp[len], "\n----------chain[%02d]-loop[%d]----------\n", k, loop_15312);
          for ( i = 0; i <= 107; ++i )
          {
            len += sprintf((char *)&tmp[len], "\n----------asic[%02d]----------\n", i);
            for ( j = 0; j <= 207; ++j )
            {
              len += sprintf((char *)&tmp[len], "\tcore[%03d]=%d", j, asic_core_nonce_num_chain[k][i][j]);
              if ( (j & 7) == 0 )
                strcpy((char *)&tmp[len++], "\n");
            }
          }
        }
      }
      v1 = strlen((const char *)tmp);
      fwrite(tmp, v1, 1u, file_tmp);
      fclose(file_tmp);
    }
    free(tmp);
  }
}

//----- (0004FF94) --------------------------------------------------------
void btm_check_open_again()
{
  int k; // [sp+4h] [bp+4h]
  int j; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  ++time_15332;
  if ( first_time == 1 )
  {
    if ( time_15332 <= 17 )
      return;
    first_time = 0;
  }
  if ( time_15332 > 2 )
  {
    time_15332 = 0;
    for ( k = 0; k <= 15; ++k )
    {
      if ( dev->chain_exist[k] == 1 )
      {
        for ( i = 0; i <= 107; ++i )
        {
          for ( j = 0; j <= 207; ++j )
          {
            if ( !asic_core_nonce_num_chain[k][i][j] )
              btm_reopen_core_again(i, j, k);
          }
        }
      }
    }
  }
}

//----- (00050088) --------------------------------------------------------
void __noreturn btm_show_core_nonce_func()
{
  time_num = 0;
  while ( 1 )
  {
    btm_show_core_nonce();
    sleep(0xAu);
  }
}

//----- (000500A4) --------------------------------------------------------
uint64_t __cdecl hashtest_submit(
        thr_info *thr,
        work *work,
        unsigned int nonce,
        unsigned __int8 *midstate,
        pool *pool,
        uint64_t nonce2,
        unsigned int chain_id)
{
  unsigned int v7; // r1
  unsigned int v8; // r2
  unsigned int v9; // r3
  unsigned int v10; // r1
  unsigned int v11; // r2
  unsigned int v12; // r3
  unsigned int v14; // r4
  unsigned int noncea; // [sp+3Ch] [bp+24h] BYREF
  work *worka; // [sp+40h] [bp+28h]
  thr_info *thra; // [sp+44h] [bp+2Ch]
  unsigned __int8 tmp42[2048]; // [sp+48h] [bp+30h] BYREF
  sha2_context ctx; // [sp+848h] [bp+830h] BYREF
  unsigned __int8 hash2[32]; // [sp+930h] [bp+918h] BYREF
  unsigned __int8 hash1[32]; // [sp+950h] [bp+938h] BYREF
  unsigned __int8 which_core_nonce; // [sp+972h] [bp+95Ah]
  unsigned __int8 which_asic_nonce; // [sp+973h] [bp+95Bh]
  unsigned int *hash2_32; // [sp+974h] [bp+95Ch]
  uint64_t tmp_net_diff; // [sp+978h] [bp+960h]
  uint64_t tmp_pool_diff; // [sp+980h] [bp+968h]
  uint64_t hashes; // [sp+988h] [bp+970h]
  int i; // [sp+994h] [bp+97Ch]

  thra = thr;
  worka = work;
  noncea = nonce;
  hashes = 0LL;
  if ( (unsigned __int64)work->sdiff != pool_diff_15363 )
  {
    pool_diff_15363 = (unsigned __int64)worka->sdiff;
    pool_diff_bit_15365 = 0LL;
    tmp_pool_diff = pool_diff_15363;
    while ( tmp_pool_diff )
    {
      tmp_pool_diff >>= 1;
      ++pool_diff_bit_15365;
    }
    --pool_diff_bit_15365;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: pool_diff:%d work_diff:%d pool_diff_bit:%d ...\n",
        (const char *)_FUNCTION___15372,
        (_DWORD)pool_diff_15363,
        HIDWORD(pool_diff_15363),
        LODWORD(worka->sdiff));
      applog(7, tmp42, 0);
    }
  }
  if ( (unsigned __int64)current_diff != net_diff_15364 )
  {
    net_diff_15364 = (unsigned __int64)current_diff;
    net_diff_bit_15366 = 0LL;
    tmp_net_diff = (unsigned __int64)current_diff;
    while ( tmp_net_diff )
    {
      tmp_net_diff >>= 1;
      ++net_diff_bit_15366;
    }
    --net_diff_bit_15366;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s:net_diff:%d current_diff:%d net_diff_bit %d ...\n",
        (const char *)_FUNCTION___15372,
        (_DWORD)net_diff_15364,
        HIDWORD(net_diff_15364),
        LODWORD(current_diff));
      applog(7, tmp42, 0);
    }
  }
  hash2_32 = (unsigned int *)hash1;
  v7 = *(_DWORD *)&worka->midstate[4];
  v8 = *(_DWORD *)&worka->midstate[8];
  v9 = *(_DWORD *)&worka->midstate[12];
  ctx.state[0] = *(_DWORD *)worka->midstate;
  ctx.state[1] = v7;
  ctx.state[2] = v8;
  ctx.state[3] = v9;
  v10 = *(_DWORD *)&worka->midstate[20];
  v11 = *(_DWORD *)&worka->midstate[24];
  v12 = *(_DWORD *)&worka->midstate[28];
  ctx.state[4] = *(_DWORD *)&worka->midstate[16];
  ctx.state[5] = v10;
  ctx.state[6] = v11;
  ctx.state[7] = v12;
  ctx.total[0] = 80;
  ctx.total[1] = 0;
  memcpy(hash1, &worka->data[64], 0xCu);
  flip_swab(ctx.buffer, hash1, 0xCu);
  memcpy(hash1, &noncea, 4u);
  flip_swab(&ctx.buffer[12], hash1, 4u);
  sha2_finish(&ctx, hash1);
  memset(&ctx, 0, sizeof(ctx));
  sha2(hash1, 32, hash2);
  flip32_0(hash1, hash2);
  if ( hash2_32[7] )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      inc_hw_errors(thra);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "[%s] chain[%d] nonce fail\n", (const char *)_func___15381, chain_id);
        applog(7, tmp42, 0);
      }
      ++dev->chain_hw[chain_id];
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: HASH2_32[7] != 0", (const char *)_FUNCTION___15372);
      applog(7, tmp42, 0);
    }
    return 0LL;
  }
  else
  {
    for ( i = 0;
          i <= 6
       && !((hash2_32[6 - i] << 24) | HIBYTE(hash2_32[6 - i]) | ((hash2_32[6 - i] & 0xFF0000) >> 8) | ((hash2_32[6 - i] & 0xFF00) << 8));
          ++i )
    {
      ;
    }
    if ( i >= pool_diff_bit_15365 >> 5 )
    {
      which_asic_nonce = noncea >> (dev->check_bit + 24);
      which_core_nonce = noncea;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: chain %d which_asic_nonce %d which_core_nonce %d",
          (const char *)_FUNCTION___15372,
          chain_id,
          which_asic_nonce,
          which_core_nonce);
        applog(7, tmp42, 0);
      }
      ++dev->chain_asic_nonce[chain_id][which_asic_nonce];
      v14 = hash2_32[-(unsigned int)(pool_diff_bit_15365 >> 5) + 6];
      if ( (HIBYTE(v14) | ((v14 & 0xFF0000) >> 8) | ((v14 & 0xFF00) << 8) | (v14 << 24)) >= 0xFFFFFFFF >> (pool_diff_bit_15365 & 0x1F) )
      {
        if ( (HIBYTE(hash2_32[6]) | ((hash2_32[6] & 0xFF0000) >> 8) | ((hash2_32[6] & 0xFF00) << 8) | (hash2_32[6] << 24)) <= 0xFFFFFE )
        {
          hashes += 256LL;
          h_each_chain[chain_id] += 256LL;
        }
      }
      else
      {
        hashes += 256LL;
        if ( current_diff != 0.0 )
        {
          for ( i = 0;
                i < net_diff_bit_15366 >> 5
             && !((hash2_32[6 - i] << 24) | HIBYTE(hash2_32[6 - i]) | ((hash2_32[6 - i] & 0xFF0000) >> 8) | ((hash2_32[6 - i] & 0xFF00) << 8));
                ++i )
          {
            ;
          }
        }
        submit_nonce(thra, worka, noncea);
      }
    }
    return hashes;
  }
}

//----- (0005091C) --------------------------------------------------------
void *__cdecl bitmain_scanhash(void *arg)
{
  unsigned int v1; // r3
  __int64 v2; // r2
  unsigned __int8 midstate[32]; // [sp+28h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+48h] [bp+28h] BYREF
  work *work; // [sp+848h] [bp+828h] BYREF
  pool *c_pool; // [sp+84Ch] [bp+82Ch]
  pool *pool_stratum2; // [sp+850h] [bp+830h]
  pool *pool_stratum1; // [sp+854h] [bp+834h]
  pool *pool_stratum0; // [sp+858h] [bp+838h]
  unsigned int version; // [sp+85Ch] [bp+83Ch]
  unsigned int work_id; // [sp+860h] [bp+840h]
  unsigned int chain_id; // [sp+864h] [bp+844h]
  uint64_t nonce2; // [sp+868h] [bp+848h]
  unsigned int job_id; // [sp+874h] [bp+854h]
  unsigned int nonce3; // [sp+878h] [bp+858h]
  unsigned int b; // [sp+87Ch] [bp+85Ch]
  unsigned int a; // [sp+880h] [bp+860h]
  bitmain_soc_info *info; // [sp+884h] [bp+864h]
  cgpu_info *bitmain_soc; // [sp+888h] [bp+868h]
  thr_info *thr; // [sp+88Ch] [bp+86Ch]
  pool *pool; // [sp+890h] [bp+870h]
  int i; // [sp+894h] [bp+874h]

  thr = (thr_info *)arg;
  bitmain_soc = (cgpu_info *)*((_DWORD *)arg + 9);
  info = (bitmain_soc_info *)bitmain_soc->device_data;
  a = 0;
  b = 0;
  h = 0LL;
  pthread_mutex_lock(&nonce_mutex);
  cg_rlock_1(&info->update_lock, "driver-btm-soc.c", _func___15414, 12170);
  while ( nonce_read_out.nonce_num )
  {
    nonce3 = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce3;
    job_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].job_id;
    nonce2 = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce2;
    chain_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].chain_num;
    work_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].work_id;
    version = (nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version << 24) | HIBYTE(nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version) | ((nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version & 0xFF0000) >> 8) | ((nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version & 0xFF00) << 8);
    memset(midstate, 0, sizeof(midstate));
    for ( i = 0; i <= 31; ++i )
      midstate[4 * (7 - i / 4) + i % 4] = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].midstate[i];
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s:chain_id:%d   job_id:0x%x   work_id:0x%x   nonce2:0x%llx   nonce3:0x%x   version:0x%x\n",
        (const char *)_FUNCTION___15427,
        chain_id,
        job_id,
        work_id,
        nonce2,
        nonce3,
        version);
      applog(7, tmp42, 0);
    }
    pool_stratum0 = &info->pool0;
    pool_stratum1 = &info->pool1;
    pool_stratum2 = &info->pool2;
    if ( nonce_read_out.p_rd > 0x1FD )
      nonce_read_out.p_rd = 0;
    else
      ++nonce_read_out.p_rd;
    --nonce_read_out.nonce_num;
    if ( nonce3 == last_nonce3_15410 && work_id == last_workid_15411 )
    {
      if ( dev->chain_exist[chain_id] == 1 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "%s: recv same nonce ...\n", (const char *)_FUNCTION___15427);
          applog(7, tmp42, 0);
        }
LABEL_55:
        inc_hw_errors(thr);
        ++dev->chain_hw[chain_id];
      }
    }
    else
    {
      last_nonce3_15410 = nonce3;
      last_workid_15411 = work_id;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s: Chain ID J%d ...\n", (const char *)_FUNCTION___15427, chain_id + 1);
        applog(7, tmp42, 0);
      }
      if ( given_id - 2 <= job_id || given_id >= job_id )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: given_id:%d job_id:%d switch:%d  ...\n",
            (const char *)_FUNCTION___15427,
            given_id,
            job_id,
            given_id - job_id);
          applog(7, tmp42, 0);
        }
        v1 = given_id - job_id;
        if ( given_id - job_id == 1 )
        {
          pool = pool_stratum1;
          goto LABEL_56;
        }
        if ( !v1 )
        {
          pool = pool_stratum0;
          goto LABEL_56;
        }
        if ( v1 == 2 )
        {
          pool = pool_stratum2;
LABEL_56:
          c_pool = pools[pool->pool_no];
          get_work_by_nonce2(thr, &work, pool, c_pool, nonce2, (unsigned int)pool->ntime, version);
          h += hashtest_submit(thr, work, nonce3, midstate, pool, nonce2, chain_id);
          free_work(&work, "driver-btm-soc.c", _func___15414, 12257);
        }
        else
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: job_id non't found given=%d, job=%d...\n",
              (const char *)_FUNCTION___15427,
              given_id,
              job_id);
            applog(7, tmp42, 0);
          }
          if ( dev->chain_exist[chain_id] == 1 )
            goto LABEL_55;
        }
      }
      else
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "%s: job_id error ...\n", (const char *)_FUNCTION___15427);
          applog(7, tmp42, 0);
        }
        if ( dev->chain_exist[chain_id] == 1 )
          goto LABEL_55;
      }
    }
  }
  cg_runlock_1(&info->update_lock, "driver-btm-soc.c", _func___15414, 12259);
  pthread_mutex_unlock(&nonce_mutex);
  cgsleep_ms(1);
  if ( h && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: hashes %u ...\n", (const char *)_FUNCTION___15427, -(int)h);
    applog(7, tmp42, 0);
  }
  v2 = 0xFFFFFFFFLL * (unsigned int)h;
  HIDWORD(v2) -= HIDWORD(h);
  h = v2;
  return (void *)HIDWORD(v2);
}

//----- (0005122C) --------------------------------------------------------
int64_t __cdecl bitmain_soc_scanhash(thr_info *thr)
{
  pthread_t send_id; // [sp+Ch] [bp+Ch] BYREF

  h = 0LL;
  pthread_create(&send_id, 0, (void *(*)(void *))bitmain_scanhash, thr);
  pthread_join(send_id, 0);
  return h;
}

//----- (00051280) --------------------------------------------------------
void __cdecl bitmain_soc_update(cgpu_info *bitmain_soc)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 *buf; // [sp+80Ch] [bp+80Ch] BYREF
  work *work; // [sp+810h] [bp+810h] BYREF
  pool *pool; // [sp+814h] [bp+814h]
  bool same_job; // [sp+81Bh] [bp+81Bh]
  int count; // [sp+81Ch] [bp+81Ch]
  thr_info *thr; // [sp+820h] [bp+820h]
  bitmain_soc_info *info; // [sp+824h] [bp+824h]

  info = (bitmain_soc_info *)bitmain_soc->device_data;
  thr = *bitmain_soc->thr;
  count = 0;
  mutex_lock_1(&info->lock, "driver-btm-soc.c", _func___15463, 12285);
  same_job = 1;
  buf = 0;
  thr->work_update = 0;
  thr->work_restart = 0;
  work = get_work(thr, thr->id);
  discard_work(&work, "driver-btm-soc.c", _func___15463, 12293);
  pool = current_pool();
  if ( !pool->has_stratum )
  {
    strcpy((char *)tmp42, "Bitmain S9 has to use stratum pools");
    applog(3, tmp42, 1);
    quit(1);
  }
  cg_wlock_1(&info->update_lock, "driver-btm-soc.c", _func___15463, 12300);
  cg_rlock_1(&pool->data_lock, "driver-btm-soc.c", _func___15463, 12301);
  info->pool_no = pool->pool_no;
  copy_pool_stratum(&info->pool2, &info->pool1);
  info->pool2_given_id = info->pool1_given_id;
  copy_pool_stratum(&info->pool1, &info->pool0);
  info->pool1_given_id = info->pool0_given_id;
  copy_pool_stratum(&info->pool0, pool);
  info->pool0_given_id = ++given_id;
  parse_job_to_soc(&buf, pool, info->pool0_given_id);
  if ( !status_error )
  {
    pthread_mutex_lock(&reinit_mutex);
    send_job(buf, pool);
    pthread_mutex_unlock(&reinit_mutex);
  }
  cg_runlock_1(&pool->data_lock, "driver-btm-soc.c", _func___15463, 12319);
  cg_wunlock_1(&info->update_lock, "driver-btm-soc.c", _func___15463, 12320);
  free(buf);
  mutex_unlock_1(&info->lock, "driver-btm-soc.c", _func___15463, 12322);
}

//----- (0005151C) --------------------------------------------------------
void __cdecl get_bitmain_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *bitmain_soc)
{
  ;
}

//----- (00051538) --------------------------------------------------------
void __cdecl remove_dot_char(unsigned __int8 *number)
{
  unsigned __int8 tempStr[64]; // [sp+8h] [bp+8h] BYREF
  int j; // [sp+48h] [bp+48h]
  int i; // [sp+4Ch] [bp+4Ch]

  j = 0;
  for ( i = 0; i < strlen((const char *)number); ++i )
  {
    if ( number[i] != 44 )
      tempStr[j++] = number[i];
  }
  tempStr[j] = 0;
  strcpy((char *)number, (const char *)tempStr);
}

//----- (000515A4) --------------------------------------------------------
void __cdecl add_dot_number(unsigned __int8 *number)
{
  unsigned __int8 tempStr[32]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 *pstr; // [sp+2Ch] [bp+2Ch]

  remove_dot_char(number);
  strcpy((char *)tempStr, (const char *)number);
  pstr = (unsigned __int8 *)strchr((const char *)number, 46);
  if ( pstr && (unsigned int)(pstr - number) > 3 )
  {
    memcpy(tempStr, number, pstr - number - 3);
    tempStr[pstr - number - 3] = 44;
    strcpy((char *)&tempStr[pstr - number - 2], (const char *)pstr - 3);
  }
  strcpy((char *)number, (const char *)tempStr);
}

//----- (00051638) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
api_data *__cdecl bitmain_api_stats(cgpu_info *cgpu)
{
  double v1; // d0
  api_data *v2; // r0
  api_data *v3; // r0
  double v4; // d7
  _BYTE param_name[2048]; // [sp+Ch] [bp+Ch] OVERLAPPED BYREF
  unsigned __int8 tmp_1[20]; // [sp+80Ch] [bp+80Ch] BYREF
  unsigned __int8 chain_opencore[20]; // [sp+820h] [bp+820h] BYREF
  unsigned __int8 tmp_0[20]; // [sp+834h] [bp+834h] BYREF
  unsigned __int8 chain_offside[20]; // [sp+848h] [bp+848h] BYREF
  unsigned __int8 tmp[20]; // [sp+85Ch] [bp+85Ch] BYREF
  unsigned __int8 chain_xtime[16]; // [sp+870h] [bp+870h] BYREF
  unsigned __int8 chain_rate[16]; // [sp+880h] [bp+880h] BYREF
  unsigned __int8 chain_hw[16]; // [sp+890h] [bp+890h] BYREF
  unsigned __int8 chain_asic_name[12]; // [sp+8A0h] [bp+8A0h] BYREF
  unsigned __int8 chain_name[12]; // [sp+8ACh] [bp+8ACh] BYREF
  double dev_sum_freq_2; // [sp+8B8h] [bp+8B8h] BYREF
  double total_rate; // [sp+8C0h] [bp+8C0h] BYREF
  int16_t asic_num_total; // [sp+8CEh] [bp+8CEh] BYREF
  double dev_sum_freq_1; // [sp+8D0h] [bp+8D0h] BYREF
  double dev_sum_freq_0; // [sp+8D8h] [bp+8D8h] BYREF
  double dev_sum_freq; // [sp+8E0h] [bp+8E0h] BYREF
  unsigned __int8 freq_sum[12]; // [sp+8ECh] [bp+8ECh] BYREF
  unsigned __int8 temp3_name[12]; // [sp+8F8h] [bp+8F8h] BYREF
  unsigned __int8 temp2_name[12]; // [sp+904h] [bp+904h] BYREF
  unsigned __int8 temp_name[12]; // [sp+910h] [bp+910h] BYREF
  unsigned __int8 fan_name[12]; // [sp+91Ch] [bp+91Ch] BYREF
  double dev_hwp; // [sp+928h] [bp+928h] BYREF
  int j_5; // [sp+980h] [bp+980h]
  int j_4; // [sp+984h] [bp+984h]
  int temp_3; // [sp+988h] [bp+988h]
  int temp_2; // [sp+98Ch] [bp+98Ch]
  int temp_1; // [sp+990h] [bp+990h]
  int temp_0; // [sp+994h] [bp+994h]
  int temp; // [sp+998h] [bp+998h]
  bool copy_data; // [sp+99Fh] [bp+99Fh]
  bitmain_soc_info *info; // [sp+9A0h] [bp+9A0h]
  int j_3; // [sp+9A4h] [bp+9A4h]
  bool first; // [sp+9ABh] [bp+9ABh]
  int j_2; // [sp+9ACh] [bp+9ACh]
  int total_acn_num; // [sp+9B0h] [bp+9B0h]
  int j_1; // [sp+9B4h] [bp+9B4h]
  int j_0; // [sp+9B8h] [bp+9B8h]
  int j; // [sp+9BCh] [bp+9BCh]
  uint64_t hash_rate_all; // [sp+9C0h] [bp+9C0h]
  int i; // [sp+9C8h] [bp+9C8h]
  api_data *root; // [sp+9CCh] [bp+9CCh]

  root = 0;
  info = (bitmain_soc_info *)cgpu->device_data;
  hash_rate_all = 0LL;
  copy_data = 1;
  v2 = api_add_uint8(0, "miner_count", &dev->chain_num, 1);
  v3 = api_add_string(v2, "frequency", dev->frequency_t, 1);
  root = api_add_uint8(v3, "fan_num", &dev->fan_num, 1);
  for ( i = 0; i <= 7; ++i )
  {
    sprintf((char *)fan_name, "fan%d", i + 1);
    root = api_add_uint(root, fan_name, &dev->fan_speed_value[i], copy_data);
  }
  root = api_add_uint8(root, "temp_num", &dev->chain_num, copy_data);
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp_name, "temp%d", i + 1);
    root = api_add_int16(root, temp_name, (uint16_t *)dev->chain_asic_maxtemp[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp2_name, "temp2_%d", i + 1);
    root = api_add_int16(root, temp2_name, (uint16_t *)&dev->chain_asic_temp[i][0][1], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp3_name, "temp3_%d", i + 1);
    root = api_add_int16(root, temp3_name, (uint16_t *)&dev->chain_asic_temp[i][1][1], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    j = 0;
    dev_sum_freq = 0.0;
    sprintf((char *)freq_sum, "freq_avg%d", i + 1);
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j = 0; dev->chain_asic_num[i] > j; ++j )
      {
        if ( chain_badcore_num[i][j] > 14 )
          dev_sum_freq = (double)freq_pll_1393_0[12].freq + dev_sum_freq;
        else
          dev_sum_freq = (double)freq_pll_1393_0[last_freq[i][2 * j + 3]].freq + dev_sum_freq;
      }
      if ( dev->chain_asic_num[i] )
        dev_sum_freq = dev_sum_freq / (double)dev->chain_asic_num[i];
    }
    temp = (int)(dev_sum_freq * 100.0);
    dev_sum_freq = (double)temp / 100.0;
    root = api_add_mhs(root, freq_sum, &dev_sum_freq, 1);
  }
  j_0 = 0;
  dev_sum_freq_0 = 0.0;
  strcpy(param_name, "total_rateideal");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_0 = 0; dev->chain_asic_num[i] > j_0; ++j_0 )
      {
        if ( chain_badcore_num[i][j_0] <= 14 )
          dev_sum_freq_0 = (double)((208 - chain_badcore_num[i][j_0]) * freq_pll_1393_0[last_freq[i][2 * j_0 + 3]].freq)
                         + dev_sum_freq_0;
      }
    }
  }
  dev_sum_freq_0 = dev_sum_freq_0 / 1000.0;
  temp_0 = (int)(dev_sum_freq_0 * 100.0);
  dev_sum_freq_0 = (double)temp_0 / 100.0;
  root = api_add_mhs(root, param_name, &dev_sum_freq_0, 1);
  j_1 = 0;
  total_acn_num = 0;
  dev_sum_freq_1 = 0.0;
  strcpy(param_name, "total_freqavg");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_1 = 0; dev->chain_asic_num[i] > j_1; ++j_1 )
      {
        if ( chain_badcore_num[i][j_1] > 14 )
          dev_sum_freq_1 = (double)freq_pll_1393_0[12].freq + dev_sum_freq_1;
        else
          dev_sum_freq_1 = (double)freq_pll_1393_0[last_freq[i][2 * j_1 + 3]].freq + dev_sum_freq_1;
        ++total_acn_num;
      }
    }
  }
  dev_sum_freq_1 = dev_sum_freq_1 / (double)total_acn_num;
  temp_1 = (int)(dev_sum_freq_1 * 100.0);
  dev_sum_freq_1 = (double)temp_1 / 100.0;
  root = api_add_mhs(root, param_name, &dev_sum_freq_1, 1);
  asic_num_total = 0;
  strcpy(param_name, "total_acn");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      asic_num_total += dev->chain_asic_num[i];
  }
  root = api_add_int16(root, param_name, (uint16_t *)&asic_num_total, 1);
  total_rate = 0.0;
  strcpy(param_name, "total_rate");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && displayed_rate[i][0] )
    {
      atof((const char *)displayed_rate[i]);
      total_rate = v1 + total_rate;
    }
  }
  temp_2 = (int)(total_rate * 100.0);
  total_rate = (double)temp_2 / 100.0;
  root = api_add_mhs(root, param_name, &total_rate, 1);
  for ( i = 0; i <= 15; ++i )
  {
    j_2 = 0;
    dev_sum_freq_2 = 0.0;
    sprintf(param_name, "chain_rateideal%d", i + 1);
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_2 = 0; dev->chain_asic_num[i] > j_2; ++j_2 )
      {
        if ( chain_badcore_num[i][j_2] <= 14 )
          dev_sum_freq_2 = (double)((208 - chain_badcore_num[i][j_2]) * freq_pll_1393_0[last_freq[i][2 * j_2 + 3]].freq)
                         + dev_sum_freq_2;
      }
    }
    dev_sum_freq_2 = dev_sum_freq_2 / 1000.0;
    temp_3 = (int)(dev_sum_freq_2 * 100.0);
    dev_sum_freq_2 = (double)temp_3 / 100.0;
    root = api_add_mhs(root, param_name, &dev_sum_freq_2, 1);
  }
  root = api_add_int(root, "temp_max", dev->temp_top1, copy_data);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  if ( hw_errors + total_diff1 )
    v4 = (double)hw_errors / (double)(hw_errors + total_diff1);
  else
    v4 = 0.0;
  dev_hwp = v4;
  root = api_add_percent(root, "Device Hardware%", &dev_hwp, 1);
  root = api_add_int(root, "no_matching_work", &hw_errors, copy_data);
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_name, "chain_acn%d", i + 1);
    root = api_add_uint8(root, chain_name, &dev->chain_asic_num[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_asic_name, "chain_acs%d", i + 1);
    root = api_add_string(root, chain_asic_name, dev->chain_asic_status_string[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_hw, "chain_hw%d", i + 1);
    root = api_add_uint32(root, chain_hw, &dev->chain_hw[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_rate, "chain_rate%d", i + 1);
    root = api_add_string(root, chain_rate, displayed_rate[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      printf("chain_rate[%d]=(%s) ", i + 1, (const char *)displayed_rate[i]);
  }
  putchar(10);
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      first = 1;
      j_3 = 0;
      *(_DWORD *)param_name = 123;
      memset(&param_name[4], 0, 0x7FCu);
      memset(tmp, 0, sizeof(tmp));
      sprintf((char *)chain_xtime, "chain_xtime%d", i + 1);
      if ( x_time[i][0] )
      {
        sprintf((char *)tmp, "X%d=%d", 0, x_time[i][0]);
        strcat(param_name, (const char *)tmp);
        first = 0;
      }
      for ( j_3 = 1; dev->chain_asic_num[i] > j_3; ++j_3 )
      {
        if ( x_time[i][j_3] )
        {
          if ( first )
          {
            sprintf((char *)tmp, "X%d=%d", j_3, x_time[i][j_3]);
            first = 0;
          }
          else
          {
            sprintf((char *)tmp, ",X%d=%d", j_3, x_time[i][j_3]);
          }
          strcat(param_name, (const char *)tmp);
        }
      }
      strcat(param_name, "}");
      root = api_add_string(root, chain_xtime, param_name, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      j_4 = 0;
      sprintf((char *)chain_offside, "chain_offside_%d", i + 1);
      sprintf((char *)tmp_0, "%d", temp_offside[i]);
      root = api_add_string(root, chain_offside, tmp_0, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      j_5 = 0;
      sprintf((char *)chain_opencore, "chain_opencore_%d", i + 1);
      if ( isChainAllCoresOpened[i] )
        strcpy((char *)tmp_1, "1");
      else
        strcpy((char *)tmp_1, "0");
      root = api_add_string(root, chain_opencore, tmp_1, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      hash_rate_all += rate[i];
  }
  strcpy(param_name, "miner_version");
  root = api_add_string(root, param_name, g_miner_version, copy_data);
  strcpy(param_name, "miner_id");
  return api_add_string(root, param_name, FPGA_ID_str, copy_data);
}
// 51638: variables would overlap: ^C.2048 and stkvar "param_name" ^C.32(has user info)

//----- (00052960) --------------------------------------------------------
void __cdecl bitmain_soc_shutdown(thr_info *thr)
{
  int dhash_acc_control; // r0
  unsigned int ret; // [sp+Ch] [bp+Ch]

  thr_info_cancel(check_system_work_id);
  thr_info_cancel(read_nonce_reg_id);
  thr_info_cancel(read_temp_id);
  thr_info_cancel(pic_heart_beat);
  ret = get_BC_write_command() & 0xFFBFFFFF;
  set_BC_write_command(ret);
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
}

//----- (000529D8) --------------------------------------------------------
void __cdecl mutex_init_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00052A58) --------------------------------------------------------
void __cdecl mutex_destroy(pthread_mutex_t *lock)
{
  pthread_mutex_destroy(lock);
}

//----- (00052A70) --------------------------------------------------------
void __cdecl rwlock_init_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00052AF0) --------------------------------------------------------
void __cdecl rwlock_destroy(pthread_rwlock_t *lock)
{
  pthread_rwlock_destroy(lock);
}

//----- (00052B08) --------------------------------------------------------
void __cdecl cglock_init_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init_2(&lock->mutex, file, func, line);
  rwlock_init_1(&lock->rwlock, file, func, line);
}

//----- (00052B3C) --------------------------------------------------------
void __cdecl cglock_destroy(cglock_t *lock)
{
  rwlock_destroy(&lock->rwlock);
  mutex_destroy(&lock->mutex);
}

//----- (00052B60) --------------------------------------------------------
void __cdecl k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+34h] [bp+14h] BYREF
  int i; // [sp+834h] [bp+814h]
  int allocate; // [sp+838h] [bp+818h]
  K_ITEM *item; // [sp+83Ch] [bp+81Ch]

  if ( list->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9052,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9052,
      19);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( list->limit <= 0 || list->total < list->limit )
  {
    allocate = list->allocate;
    if ( list->limit > 0 && list->total + allocate > list->limit )
      allocate = list->limit - list->total;
    ++list->item_mem_count;
    list->item_memory = (void **)realloc(list->item_memory, 4 * list->item_mem_count);
    if ( !list->item_memory )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s item_memory failed to realloc count=%d in %s %s():%d",
        (const char *)list->name,
        list->item_mem_count,
        "klist.c",
        (const char *)_func___9052,
        33);
      applog(3, tmp42, 1);
      quit(1);
    }
    item = (K_ITEM *)calloc(allocate, 0x10u);
    if ( !item )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
        (const char *)list->name,
        allocate,
        list->total,
        list->limit,
        "klist.c",
        (const char *)_func___9052,
        38);
      applog(3, tmp42, 1);
      quit(1);
    }
    list->item_memory[list->item_mem_count - 1] = item;
    list->total += allocate;
    list->count = allocate;
    list->count_up = allocate;
    item->name = list->name;
    item->prev = 0;
    item->next = item + 1;
    for ( i = 1; allocate - 1 > i; ++i )
    {
      item[i].name = list->name;
      item[i].prev = &item[i - 1];
      item[i].next = &item[i + 1];
    }
    item[allocate - 1].name = list->name;
    item[allocate - 1].prev = &item[allocate - 2];
    item[allocate - 1].next = 0;
    list->head = item;
    if ( list->do_tail )
      list->tail = &item[allocate - 1];
    for ( item = list->head; item; item = item->next )
    {
      ++list->data_mem_count;
      list->data_memory = (void **)realloc(list->data_memory, 4 * list->data_mem_count);
      if ( !list->data_memory )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "List %s data_memory failed to realloc count=%d in %s %s():%d",
          (const char *)list->name,
          list->data_mem_count,
          "klist.c",
          (const char *)_func___9052,
          69);
        applog(3, tmp42, 1);
        quit(1);
      }
      item->data = calloc(1u, list->siz);
      if ( !item->data )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "List %s failed to calloc item data in %s %s():%d",
          (const char *)list->name,
          "klist.c",
          (const char *)_func___9052,
          73);
        applog(3, tmp42, 1);
        quit(1);
      }
      list->data_memory[list->data_mem_count - 1] = item->data;
    }
  }
}

//----- (00053020) --------------------------------------------------------
K_LIST *__cdecl k_new_store(K_LIST *list)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  K_LIST *store; // [sp+81Ch] [bp+80Ch]

  store = (K_LIST *)calloc(1u, 0x40u);
  if ( !store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc store for %s in %s %s():%d",
      (const char *)list->name,
      "klist.c",
      (const char *)_func___9068,
      85);
    applog(3, tmp42, 1);
    quit(1);
  }
  store->is_store = 1;
  store->lock = list->lock;
  store->name = list->name;
  store->do_tail = list->do_tail;
  return store;
}

//----- (000530D0) --------------------------------------------------------
K_LIST *__cdecl k_new_list(
        const unsigned __int8 *name,
        size_t siz,
        int allocate,
        int limit,
        bool do_tail,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  K_LIST *list; // [sp+824h] [bp+814h]

  if ( allocate <= 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      (const char *)name,
      allocate,
      "klist.c",
      (const char *)_func___9081,
      100);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( limit < 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      (const char *)name,
      limit,
      "klist.c",
      (const char *)_func___9081,
      103);
    applog(3, tmp42, 1);
    quit(1);
  }
  list = (K_LIST *)calloc(1u, 0x40u);
  if ( !list )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___9081,
      107);
    applog(3, tmp42, 1);
    quit(1);
  }
  list->is_store = 0;
  list->lock = (cglock_t *)calloc(1u, 0x38u);
  if ( !list->lock )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc lock for list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___9081,
      113);
    applog(3, tmp42, 1);
    quit(1);
  }
  cglock_init_1(list->lock, "klist.c", _func___9081, 115);
  list->name = name;
  list->siz = siz;
  list->allocate = allocate;
  list->limit = limit;
  list->do_tail = do_tail;
  k_alloc_items(list, file, func, line);
  return list;
}

//----- (000532E0) --------------------------------------------------------
K_ITEM *__cdecl k_unlink_head(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  k_item *item; // [sp+14h] [bp+14h]

  if ( !list->head && !list->is_store )
    k_alloc_items(list, file, func, line);
  if ( !list->head )
    return 0;
  item = list->head;
  list->head = item->next;
  if ( list->head )
  {
    list->head->prev = 0;
  }
  else if ( list->do_tail )
  {
    list->tail = 0;
  }
  item->next = 0;
  item->prev = item->next;
  --list->count;
  return item;
}

//----- (00053370) --------------------------------------------------------
K_ITEM *__cdecl k_unlink_head_zero(
        K_LIST *list,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  K_ITEM *item; // [sp+14h] [bp+14h]

  item = k_unlink_head(list, file, func, line);
  if ( item )
    memset(item->data, 0, list->siz);
  return item;
}

//----- (000533B0) --------------------------------------------------------
K_ITEM *__cdecl k_unlink_tail(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+34h] [bp+14h] BYREF
  K_ITEM *item; // [sp+834h] [bp+814h]

  if ( !list->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9107,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9107,
      181);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !list->tail )
    return 0;
  item = list->tail;
  list->tail = item->prev;
  if ( list->tail )
    list->tail->next = 0;
  else
    list->head = 0;
  item->next = 0;
  item->prev = item->next;
  --list->count;
  return item;
}

//----- (000534D0) --------------------------------------------------------
void __cdecl k_add_head(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9116,
      (const char *)item->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9116,
      205);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = 0;
  item->next = list->head;
  if ( list->head )
    list->head->prev = item;
  list->head = item;
  if ( list->do_tail && !list->tail )
    list->tail = item;
  ++list->count;
  ++list->count_up;
}

//----- (00053610) --------------------------------------------------------
void __cdecl k_add_tail(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9125,
      (const char *)item->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9125,
      236);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !list->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9125,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9125,
      241);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = list->tail;
  item->next = 0;
  if ( list->tail )
    list->tail->next = item;
  list->tail = item;
  if ( !list->head )
    list->head = item;
  ++list->count;
  ++list->count_up;
}

//----- (000537BC) --------------------------------------------------------
void __cdecl k_insert_before(
        K_LIST *list,
        K_ITEM *item,
        K_ITEM *before,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9136,
      (const char *)item->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9136,
      262);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !before )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      (const char *)_func___9136,
      (const char *)list->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9136,
      267);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->next = before;
  item->prev = before->prev;
  if ( before->prev )
    before->prev->next = item;
  else
    list->head = item;
  before->prev = item;
  ++list->count;
  ++list->count_up;
}

//----- (00053950) --------------------------------------------------------
void __cdecl k_insert_after(
        K_LIST *list,
        K_ITEM *item,
        K_ITEM *after,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9147,
      (const char *)item->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9147,
      286);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !after )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      (const char *)_func___9147,
      (const char *)list->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9147,
      291);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = after;
  item->next = after->next;
  if ( after->next )
  {
    after->next->prev = item;
  }
  else if ( list->do_tail )
  {
    list->tail = item;
  }
  after->next = item;
  ++list->count;
  ++list->count_up;
}

//----- (00053AF0) --------------------------------------------------------
void __cdecl k_unlink_item(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9157,
      (const char *)item->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9157,
      312);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( item->prev )
    item->prev->next = item->next;
  if ( item->next )
    item->next->prev = item->prev;
  if ( list->head == item )
    list->head = item->next;
  if ( list->do_tail && list->tail == item )
    list->tail = item->prev;
  item->next = 0;
  item->prev = item->next;
  --list->count;
}

//----- (00053C5C) --------------------------------------------------------
void __cdecl k_list_transfer_to_head(
        K_LIST *from,
        K_LIST *to,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( from->name != to->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9166,
      (const char *)to->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9166,
      338);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !from->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9166,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9166,
      343);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( from->head )
  {
    if ( to->head )
      to->head->prev = from->tail;
    else
      to->tail = from->tail;
    from->tail->next = to->head;
    to->head = from->head;
    from->tail = 0;
    from->head = from->tail;
    to->count += from->count;
    from->count = 0;
    to->count_up += from->count_up;
    from->count_up = 0;
  }
}

//----- (00053E50) --------------------------------------------------------
void __cdecl k_list_transfer_to_tail(
        K_LIST *from,
        K_LIST *to,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( from->name != to->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9176,
      (const char *)to->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9176,
      368);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !from->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9176,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9176,
      373);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( from->head )
  {
    if ( to->tail )
      to->tail->next = from->head;
    else
      to->head = from->head;
    from->head->prev = to->tail;
    to->tail = from->tail;
    from->tail = 0;
    from->head = from->tail;
    to->count += from->count;
    from->count = 0;
    to->count_up += from->count_up;
    from->count_up = 0;
  }
}

//----- (00054044) --------------------------------------------------------
K_LIST *__cdecl k_free_list(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+34h] [bp+14h] BYREF
  int i; // [sp+834h] [bp+814h]

  if ( list->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9186,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9186,
      400);
    applog(3, tmp42, 1);
    quit(1);
  }
  for ( i = 0; list->item_mem_count > i; ++i )
    free(list->item_memory[i]);
  free(list->item_memory);
  for ( i = 0; list->data_mem_count > i; ++i )
    free(list->data_memory[i]);
  free(list->data_memory);
  cglock_destroy(list->lock);
  free(list->lock);
  free(list);
  return 0;
}

//----- (000541A0) --------------------------------------------------------
K_LIST *__cdecl k_free_store(K_LIST *store, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( !store->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      (const char *)store->name,
      (const char *)_func___9200,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9200,
      424);
    applog(3, tmp42, 1);
    quit(1);
  }
  free(store);
  return 0;
}

//----- (00054254) --------------------------------------------------------
void __cdecl mutex_lock_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000542D4) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00054354) --------------------------------------------------------
void __cdecl mutex_unlock_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_2(lock, file, func, line);
  selective_yield();
}

//----- (00054384) --------------------------------------------------------
int __cdecl mutex_trylock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_mutex_trylock(lock);
}

//----- (000543A8) --------------------------------------------------------
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force)
{
  if ( !opt_quiet || prio == 3 )
  {
    if ( force )
    {
      mutex_trylock(&console_lock, "logging.c", _func___9625, 41);
      mutex_unlock_2(&console_lock, "logging.c", _func___9625, 42);
    }
    mutex_lock_2(&console_lock, "logging.c", _func___9625, 53);
    if ( g_logfile_no_datetime )
      printf("%s", (const char *)str);
    else
      printf("%s%s%s", (const char *)datetime, (const char *)str, "                    \n");
    mutex_unlock_2(&console_lock, "logging.c", _func___9625, 58);
  }
}

//----- (0005448C) --------------------------------------------------------
void __cdecl applog(int prio, const unsigned __int8 *str, bool force)
{
  int v3; // r0
  size_t v4; // r0
  size_t v5; // r0
  unsigned __int8 datetime[64]; // [sp+2Ch] [bp+14h] BYREF
  time_t tmp_time; // [sp+6Ch] [bp+54h] BYREF
  timeval tv; // [sp+70h] [bp+58h] BYREF
  tm *tm; // [sp+78h] [bp+60h]
  int ms; // [sp+7Ch] [bp+64h]

  if ( use_syslog )
  {
    syslog(prio | 0x80, "%s\n", (const char *)str);
  }
  else
  {
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    cgtime(&tv);
    tmp_time = tv.tv_sec;
    ms = tv.tv_usec / 1000;
    tm = localtime(&tmp_time);
    snprintf(
      (char *)datetime,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      tm->tm_year + 1900,
      tm->tm_mon + 1,
      tm->tm_mday,
      tm->tm_hour,
      tm->tm_min,
      tm->tm_sec,
      ms);
    v3 = fileno((FILE *)stderr);
    if ( !isatty(v3) )
    {
      if ( g_logfile_no_datetime )
        fputs((const char *)str, (FILE *)stderr);
      else
        fprintf((FILE *)stderr, "%s%s\n", (const char *)datetime, (const char *)str);
      fflush((FILE *)stderr);
    }
    if ( g_logfile_enable )
    {
      if ( !g_log_file )
        g_log_file = fopen((const char *)g_logfile_path, (const char *)g_logfile_openflag);
      if ( g_log_file )
      {
        if ( !g_logfile_no_datetime )
        {
          v4 = strlen((const char *)datetime);
          fwrite(datetime, v4, 1u, g_log_file);
        }
        v5 = strlen((const char *)str);
        fwrite(str, v5, 1u, g_log_file);
        if ( !g_logfile_no_datetime )
          fwrite("\n", 1u, 1u, g_log_file);
        fflush(g_log_file);
      }
    }
    my_log_curses(prio, datetime, str, force);
  }
}
// 8A8B8: using guessed type int stderr;

//----- (000546AC) --------------------------------------------------------
void __cdecl simplelog(int prio, const unsigned __int8 *str, bool force)
{
  int v3; // r0

  if ( use_syslog )
  {
    syslog(prio | 0x80, "%s", (const char *)str);
  }
  else
  {
    v3 = fileno((FILE *)stderr);
    if ( !isatty(v3) )
    {
      fprintf((FILE *)stderr, "%s\n", (const char *)str);
      fflush((FILE *)stderr);
    }
    my_log_curses(prio, byte_7A680, str, force);
  }
}
// 7A680: using guessed type unsigned __int8 byte_7A680[4];
// 8A8B8: using guessed type int stderr;

//----- (00054744) --------------------------------------------------------
void __cdecl mutex_lock_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000547C4) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00054844) --------------------------------------------------------
void __cdecl mutex_unlock_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_3(lock, file, func, line);
  selective_yield();
}

//----- (00054874) --------------------------------------------------------
void __cdecl wr_lock_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000548F4) --------------------------------------------------------
void __cdecl rw_unlock_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00054974) --------------------------------------------------------
void __cdecl wr_unlock_noyield_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_2(lock, file, func, line);
}

//----- (00054998) --------------------------------------------------------
void __cdecl cg_wlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_3(&lock->mutex, file, func, line);
  wr_lock_2(&lock->rwlock, file, func, line);
}

//----- (000549CC) --------------------------------------------------------
void __cdecl cg_wunlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_2(&lock->rwlock, file, func, line);
  mutex_unlock_3(&lock->mutex, file, func, line);
}

//----- (00054A00) --------------------------------------------------------
void __cdecl dupalloc(cgpu_info *cgpu, int timelimit)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  dupdata *dup; // [sp+81Ch] [bp+80Ch]

  dup = (dupdata *)calloc(1u, 0x20u);
  if ( !dup )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc dupdata in %s %s():%d",
      "noncedup.c",
      (const char *)_func___9059,
      36);
    applog(3, tmp42, 1);
    quit(1);
  }
  dup->timelimit = timelimit;
  dup->nfree_list = k_new_list("Nonces", 0x10u, 1024, 0, 1, "noncedup.c", _func___9059, 39);
  dup->nonce_list = k_new_store(dup->nfree_list);
  cgpu->dup_data = dup;
}

//----- (00054AD0) --------------------------------------------------------
void __cdecl dupcounters(cgpu_info *cgpu, uint64_t *checked, uint64_t *dups)
{
  dupdata *dup; // [sp+14h] [bp+14h]

  dup = (dupdata *)cgpu->dup_data;
  if ( dup )
  {
    *checked = dup->checked;
    *dups = dup->dups;
  }
  else
  {
    *checked = 0LL;
    *dups = 0LL;
  }
}

//----- (00054B28) --------------------------------------------------------
bool __cdecl isdupnonce(cgpu_info *cgpu, work *work, unsigned int nonce)
{
  double v3; // d0
  __time_t *v5; // r3
  __suseconds_t tv_usec; // r1
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  timeval now; // [sp+81Ch] [bp+814h] BYREF
  dupdata *dup; // [sp+824h] [bp+81Ch]
  K_ITEM *item; // [sp+828h] [bp+820h]
  bool unique; // [sp+82Fh] [bp+827h]

  dup = (dupdata *)cgpu->dup_data;
  unique = 1;
  if ( !dup )
    return 0;
  cgtime(&now);
  ++dup->checked;
  cg_wlock_2(dup->nfree_list->lock, "noncedup.c", _func___9075, 70);
  item = dup->nonce_list->tail;
  while ( unique && item )
  {
    if ( *(_DWORD *)item->data == work->id && *((_DWORD *)item->data + 1) == nonce )
    {
      unique = 0;
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s%d: Duplicate nonce %08x",
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          nonce);
        applog(4, tmp42, 0);
      }
    }
    else
    {
      item = item->prev;
    }
  }
  if ( unique )
  {
    item = k_unlink_head(dup->nfree_list, "noncedup.c", _func___9075, 81);
    *(_DWORD *)item->data = work->id;
    *((_DWORD *)item->data + 1) = nonce;
    v5 = (__time_t *)((char *)item->data + 8);
    tv_usec = now.tv_usec;
    *v5 = now.tv_sec;
    v5[1] = tv_usec;
    k_add_head(dup->nonce_list, item, "noncedup.c", _func___9075, 85);
  }
  for ( item = dup->nonce_list->tail; item; item = dup->nonce_list->tail )
  {
    tdiff((timeval *)item->data + 1, &now);
    if ( v3 <= (double)dup->timelimit )
      break;
    item = k_unlink_tail(dup->nonce_list, "noncedup.c", _func___9075, 89);
    k_add_head(dup->nfree_list, item, "noncedup.c", _func___9075, 90);
  }
  cg_wunlock_2(dup->nfree_list->lock, "noncedup.c", _func___9075, 93);
  if ( !unique )
    ++dup->dups;
  return !unique;
}
// 54D72: variable 'v3' is possibly undefined

//----- (00054DE0) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  unsigned int wv[8]; // [sp+14h] [bp+14h]
  unsigned int w[64]; // [sp+34h] [bp+34h]
  unsigned int t2; // [sp+134h] [bp+134h]
  unsigned int t1; // [sp+138h] [bp+138h]
  const unsigned __int8 *sub_block; // [sp+13Ch] [bp+13Ch]
  int j; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  for ( i = 0; (int)block_nb > i; ++i )
  {
    sub_block = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = sub_block[4 * j + 3] | (sub_block[4 * j + 2] << 8) | (sub_block[4 * j + 1] << 16) | (sub_block[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      wv[j] = ctx->h[j];
    for ( j = 0; j <= 63; ++j )
    {
      t1 = wv[7]
         + (__ROR4__(wv[4], 25) ^ __ROR4__(wv[4], 6) ^ __ROR4__(wv[4], 11))
         + (wv[6] & ~wv[4] ^ wv[4] & wv[5])
         + sha256_k[j]
         + w[j];
      t2 = (__ROR4__(wv[0], 2) ^ __ROR4__(wv[0], 13) ^ __ROR4__(wv[0], 22))
         + (wv[2] & wv[1] ^ wv[0] & wv[1] ^ wv[2] & wv[0]);
      wv[7] = wv[6];
      wv[6] = wv[5];
      wv[5] = wv[4];
      wv[4] = wv[3] + t1;
      wv[3] = wv[2];
      wv[2] = wv[1];
      wv[1] = wv[0];
      wv[0] = t1 + t2;
    }
    for ( j = 0; j <= 7; ++j )
      ctx->h[j] += wv[j];
  }
}

//----- (00055130) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  sha256_ctx ctx; // [sp+10h] [bp+10h] BYREF

  sha256_init(&ctx);
  sha256_update(&ctx, message, len);
  sha256_final(&ctx, digest);
}

//----- (00055168) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 7; ++i )
    ctx->h[i] = sha256_h0[i];
  ctx->len = 0;
  ctx->tot_len = 0;
}

//----- (000551B0) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v3; // r3
  const unsigned __int8 *shifted_message; // [sp+14h] [bp+14h]
  unsigned int block_nb; // [sp+18h] [bp+18h]
  unsigned int rem_len; // [sp+20h] [bp+20h]
  size_t rem_lena; // [sp+20h] [bp+20h]

  v3 = len;
  if ( 64 - ctx->len < len )
    v3 = 64 - ctx->len;
  rem_len = v3;
  memcpy(&ctx->block[ctx->len], message, v3);
  if ( ctx->len + len > 0x3F )
  {
    block_nb = (len - rem_len) >> 6;
    shifted_message = &message[rem_len];
    sha256_transf(ctx, ctx->block, 1u);
    sha256_transf(ctx, &message[rem_len], block_nb);
    rem_lena = (len - rem_len) & 0x3F;
    memcpy(ctx->block, &shifted_message[64 * block_nb], rem_lena);
    ctx->len = rem_lena;
    ctx->tot_len += (block_nb + 1) << 6;
  }
  else
  {
    ctx->len += len;
  }
}

//----- (0005526C) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  unsigned int pm_len; // [sp+8h] [bp+8h]
  unsigned int len_b; // [sp+Ch] [bp+Ch]
  unsigned int block_nb; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( (ctx->len & 0x3F) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  block_nb = v2;
  len_b = 8 * (ctx->tot_len + ctx->len);
  pm_len = v2 << 6;
  memset(&ctx->block[ctx->len], 0, (v2 << 6) - ctx->len);
  ctx->block[ctx->len] = 0x80;
  ctx->block[pm_len - 1] = len_b;
  ctx->block[pm_len - 2] = BYTE1(len_b);
  ctx->block[pm_len - 3] = BYTE2(len_b);
  ctx->block[pm_len - 4] = HIBYTE(len_b);
  sha256_transf(ctx, ctx->block, block_nb);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = ctx->h[i];
    digest[4 * i + 2] = BYTE1(ctx->h[i]);
    digest[4 * i + 1] = BYTE2(ctx->h[i]);
    digest[4 * i] = HIBYTE(ctx->h[i]);
  }
}

//----- (00055390) --------------------------------------------------------
void __cdecl sha2_starts(sha2_context *ctx)
{
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[0] = 1779033703;
  ctx->state[1] = -1150833019;
  ctx->state[2] = 1013904242;
  ctx->state[3] = -1521486534;
  ctx->state[4] = 1359893119;
  ctx->state[5] = -1694144372;
  ctx->state[6] = 528734635;
  ctx->state[7] = 1541459225;
}

//----- (00055410) --------------------------------------------------------
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int W; // [sp+8h] [bp+8h]
  unsigned int W_4; // [sp+Ch] [bp+Ch]
  unsigned int W_8; // [sp+10h] [bp+10h]
  unsigned int W_12; // [sp+14h] [bp+14h]
  unsigned int W_16; // [sp+18h] [bp+18h]
  unsigned int W_20; // [sp+1Ch] [bp+1Ch]
  unsigned int W_24; // [sp+20h] [bp+20h]
  unsigned int W_28; // [sp+24h] [bp+24h]
  unsigned int W_32; // [sp+28h] [bp+28h]
  unsigned int W_36; // [sp+2Ch] [bp+2Ch]
  unsigned int W_40; // [sp+30h] [bp+30h]
  unsigned int W_44; // [sp+34h] [bp+34h]
  unsigned int W_48; // [sp+38h] [bp+38h]
  unsigned int W_52; // [sp+3Ch] [bp+3Ch]
  unsigned int W_56; // [sp+40h] [bp+40h]
  unsigned int W_60; // [sp+44h] [bp+44h]
  unsigned int W_64; // [sp+48h] [bp+48h]
  unsigned int W_68; // [sp+4Ch] [bp+4Ch]
  unsigned int W_72; // [sp+50h] [bp+50h]
  unsigned int W_76; // [sp+54h] [bp+54h]
  unsigned int W_80; // [sp+58h] [bp+58h]
  unsigned int W_84; // [sp+5Ch] [bp+5Ch]
  unsigned int W_88; // [sp+60h] [bp+60h]
  unsigned int W_92; // [sp+64h] [bp+64h]
  unsigned int W_96; // [sp+68h] [bp+68h]
  unsigned int W_100; // [sp+6Ch] [bp+6Ch]
  unsigned int W_104; // [sp+70h] [bp+70h]
  unsigned int W_108; // [sp+74h] [bp+74h]
  unsigned int W_112; // [sp+78h] [bp+78h]
  unsigned int W_116; // [sp+7Ch] [bp+7Ch]
  unsigned int W_120; // [sp+80h] [bp+80h]
  unsigned int W_124; // [sp+84h] [bp+84h]
  unsigned int W_128; // [sp+88h] [bp+88h]
  unsigned int W_132; // [sp+8Ch] [bp+8Ch]
  unsigned int W_136; // [sp+90h] [bp+90h]
  unsigned int W_140; // [sp+94h] [bp+94h]
  unsigned int W_144; // [sp+98h] [bp+98h]
  unsigned int W_148; // [sp+9Ch] [bp+9Ch]
  unsigned int W_152; // [sp+A0h] [bp+A0h]
  unsigned int W_156; // [sp+A4h] [bp+A4h]
  unsigned int W_160; // [sp+A8h] [bp+A8h]
  unsigned int W_164; // [sp+ACh] [bp+ACh]
  unsigned int W_168; // [sp+B0h] [bp+B0h]
  unsigned int W_172; // [sp+B4h] [bp+B4h]
  unsigned int W_176; // [sp+B8h] [bp+B8h]
  unsigned int W_180; // [sp+BCh] [bp+BCh]
  unsigned int W_184; // [sp+C0h] [bp+C0h]
  unsigned int W_188; // [sp+C4h] [bp+C4h]
  unsigned int W_192; // [sp+C8h] [bp+C8h]
  unsigned int W_196; // [sp+CCh] [bp+CCh]
  unsigned int W_200; // [sp+D0h] [bp+D0h]
  unsigned int W_204; // [sp+D4h] [bp+D4h]
  unsigned int W_208; // [sp+D8h] [bp+D8h]
  unsigned int W_212; // [sp+DCh] [bp+DCh]
  unsigned int W_216; // [sp+E0h] [bp+E0h]
  unsigned int W_220; // [sp+E4h] [bp+E4h]
  unsigned int W_224; // [sp+E8h] [bp+E8h]
  unsigned int W_228; // [sp+ECh] [bp+ECh]
  unsigned int W_232; // [sp+F0h] [bp+F0h]
  unsigned int W_236; // [sp+F4h] [bp+F4h]
  unsigned int W_240; // [sp+F8h] [bp+F8h]
  unsigned int W_244; // [sp+FCh] [bp+FCh]
  unsigned int temp1; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1a; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1b; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1c; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1d; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1e; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1f; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1g; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1h; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1i; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1j; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1k; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1l; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1m; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1n; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1o; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1p; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1q; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1r; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1s; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1t; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1u; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1v; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1w; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1x; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1y; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1z; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1ba; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bb; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bc; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bd; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1be; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bf; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bg; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bh; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bi; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bj; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bk; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bl; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bm; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bn; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bo; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bp; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bq; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1br; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bs; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bt; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bu; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bv; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bw; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bx; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1by; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1bz; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1ca; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1cb; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1cc; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1cd; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1ce; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1cf; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1cg; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1ch; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1ci; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1cj; // [sp+10Ch] [bp+10Ch]
  unsigned int temp1ck; // [sp+10Ch] [bp+10Ch]
  unsigned int H; // [sp+110h] [bp+110h]
  unsigned int Ha; // [sp+110h] [bp+110h]
  unsigned int Hb; // [sp+110h] [bp+110h]
  unsigned int Hc; // [sp+110h] [bp+110h]
  unsigned int Hd; // [sp+110h] [bp+110h]
  unsigned int He; // [sp+110h] [bp+110h]
  unsigned int Hf; // [sp+110h] [bp+110h]
  unsigned int Hg; // [sp+110h] [bp+110h]
  unsigned int Hh; // [sp+110h] [bp+110h]
  unsigned int Hi; // [sp+110h] [bp+110h]
  unsigned int Hj; // [sp+110h] [bp+110h]
  unsigned int Hk; // [sp+110h] [bp+110h]
  unsigned int Hl; // [sp+110h] [bp+110h]
  unsigned int Hm; // [sp+110h] [bp+110h]
  unsigned int Hn; // [sp+110h] [bp+110h]
  unsigned int Ho; // [sp+110h] [bp+110h]
  unsigned int G; // [sp+114h] [bp+114h]
  unsigned int Ga; // [sp+114h] [bp+114h]
  unsigned int Gb; // [sp+114h] [bp+114h]
  unsigned int Gc; // [sp+114h] [bp+114h]
  unsigned int Gd; // [sp+114h] [bp+114h]
  unsigned int Ge; // [sp+114h] [bp+114h]
  unsigned int Gf; // [sp+114h] [bp+114h]
  unsigned int Gg; // [sp+114h] [bp+114h]
  unsigned int Gh; // [sp+114h] [bp+114h]
  unsigned int Gi; // [sp+114h] [bp+114h]
  unsigned int Gj; // [sp+114h] [bp+114h]
  unsigned int Gk; // [sp+114h] [bp+114h]
  unsigned int Gl; // [sp+114h] [bp+114h]
  unsigned int Gm; // [sp+114h] [bp+114h]
  unsigned int Gn; // [sp+114h] [bp+114h]
  unsigned int Go; // [sp+114h] [bp+114h]
  unsigned int Gp; // [sp+114h] [bp+114h]
  unsigned int F; // [sp+118h] [bp+118h]
  unsigned int Fa; // [sp+118h] [bp+118h]
  unsigned int Fb; // [sp+118h] [bp+118h]
  unsigned int Fc; // [sp+118h] [bp+118h]
  unsigned int Fd; // [sp+118h] [bp+118h]
  unsigned int Fe; // [sp+118h] [bp+118h]
  unsigned int Ff; // [sp+118h] [bp+118h]
  unsigned int Fg; // [sp+118h] [bp+118h]
  unsigned int Fh; // [sp+118h] [bp+118h]
  unsigned int Fi; // [sp+118h] [bp+118h]
  unsigned int Fj; // [sp+118h] [bp+118h]
  unsigned int Fk; // [sp+118h] [bp+118h]
  unsigned int Fl; // [sp+118h] [bp+118h]
  unsigned int Fm; // [sp+118h] [bp+118h]
  unsigned int Fn; // [sp+118h] [bp+118h]
  unsigned int Fo; // [sp+118h] [bp+118h]
  unsigned int Fp; // [sp+118h] [bp+118h]
  unsigned int E; // [sp+11Ch] [bp+11Ch]
  unsigned int Ea; // [sp+11Ch] [bp+11Ch]
  unsigned int Eb; // [sp+11Ch] [bp+11Ch]
  unsigned int Ec; // [sp+11Ch] [bp+11Ch]
  unsigned int Ed; // [sp+11Ch] [bp+11Ch]
  unsigned int Ee; // [sp+11Ch] [bp+11Ch]
  unsigned int Ef; // [sp+11Ch] [bp+11Ch]
  unsigned int Eg; // [sp+11Ch] [bp+11Ch]
  unsigned int Eh; // [sp+11Ch] [bp+11Ch]
  unsigned int Ei; // [sp+11Ch] [bp+11Ch]
  unsigned int Ej; // [sp+11Ch] [bp+11Ch]
  unsigned int Ek; // [sp+11Ch] [bp+11Ch]
  unsigned int El; // [sp+11Ch] [bp+11Ch]
  unsigned int Em; // [sp+11Ch] [bp+11Ch]
  unsigned int En; // [sp+11Ch] [bp+11Ch]
  unsigned int Eo; // [sp+11Ch] [bp+11Ch]
  unsigned int D; // [sp+120h] [bp+120h]
  unsigned int Da; // [sp+120h] [bp+120h]
  unsigned int Db; // [sp+120h] [bp+120h]
  unsigned int Dc; // [sp+120h] [bp+120h]
  unsigned int Dd; // [sp+120h] [bp+120h]
  unsigned int De; // [sp+120h] [bp+120h]
  unsigned int Df; // [sp+120h] [bp+120h]
  unsigned int Dg; // [sp+120h] [bp+120h]
  unsigned int Dh; // [sp+120h] [bp+120h]
  unsigned int Di; // [sp+120h] [bp+120h]
  unsigned int Dj; // [sp+120h] [bp+120h]
  unsigned int Dk; // [sp+120h] [bp+120h]
  unsigned int Dl; // [sp+120h] [bp+120h]
  unsigned int Dm; // [sp+120h] [bp+120h]
  unsigned int Dn; // [sp+120h] [bp+120h]
  unsigned int Do; // [sp+120h] [bp+120h]
  unsigned int C; // [sp+124h] [bp+124h]
  unsigned int Ca; // [sp+124h] [bp+124h]
  unsigned int Cb; // [sp+124h] [bp+124h]
  unsigned int Cc; // [sp+124h] [bp+124h]
  unsigned int Cd; // [sp+124h] [bp+124h]
  unsigned int Ce; // [sp+124h] [bp+124h]
  unsigned int Cf; // [sp+124h] [bp+124h]
  unsigned int Cg; // [sp+124h] [bp+124h]
  unsigned int Ch; // [sp+124h] [bp+124h]
  unsigned int Ci; // [sp+124h] [bp+124h]
  unsigned int Cj; // [sp+124h] [bp+124h]
  unsigned int Ck; // [sp+124h] [bp+124h]
  unsigned int Cl; // [sp+124h] [bp+124h]
  unsigned int Cm; // [sp+124h] [bp+124h]
  unsigned int Cn; // [sp+124h] [bp+124h]
  unsigned int Co; // [sp+124h] [bp+124h]
  unsigned int Cp; // [sp+124h] [bp+124h]
  unsigned int B; // [sp+128h] [bp+128h]
  unsigned int Ba; // [sp+128h] [bp+128h]
  unsigned int Bb; // [sp+128h] [bp+128h]
  unsigned int Bc; // [sp+128h] [bp+128h]
  unsigned int Bd; // [sp+128h] [bp+128h]
  unsigned int Be; // [sp+128h] [bp+128h]
  unsigned int Bf; // [sp+128h] [bp+128h]
  unsigned int Bg; // [sp+128h] [bp+128h]
  unsigned int Bh; // [sp+128h] [bp+128h]
  unsigned int Bi; // [sp+128h] [bp+128h]
  unsigned int Bj; // [sp+128h] [bp+128h]
  unsigned int Bk; // [sp+128h] [bp+128h]
  unsigned int Bl; // [sp+128h] [bp+128h]
  unsigned int Bm; // [sp+128h] [bp+128h]
  unsigned int Bn; // [sp+128h] [bp+128h]
  unsigned int Bo; // [sp+128h] [bp+128h]
  unsigned int Bp; // [sp+128h] [bp+128h]
  unsigned int A; // [sp+12Ch] [bp+12Ch]
  unsigned int Aa; // [sp+12Ch] [bp+12Ch]
  unsigned int Ab; // [sp+12Ch] [bp+12Ch]
  unsigned int Ac; // [sp+12Ch] [bp+12Ch]
  unsigned int Ad; // [sp+12Ch] [bp+12Ch]
  unsigned int Ae; // [sp+12Ch] [bp+12Ch]
  unsigned int Af; // [sp+12Ch] [bp+12Ch]
  unsigned int Ag; // [sp+12Ch] [bp+12Ch]
  unsigned int Ah; // [sp+12Ch] [bp+12Ch]
  unsigned int Ai; // [sp+12Ch] [bp+12Ch]
  unsigned int Aj; // [sp+12Ch] [bp+12Ch]
  unsigned int Ak; // [sp+12Ch] [bp+12Ch]
  unsigned int Al; // [sp+12Ch] [bp+12Ch]
  unsigned int Am; // [sp+12Ch] [bp+12Ch]
  unsigned int An; // [sp+12Ch] [bp+12Ch]
  unsigned int Ao; // [sp+12Ch] [bp+12Ch]

  W = _byteswap_ulong(*(_DWORD *)data);
  W_4 = _byteswap_ulong(*((_DWORD *)data + 1));
  W_8 = _byteswap_ulong(*((_DWORD *)data + 2));
  W_12 = _byteswap_ulong(*((_DWORD *)data + 3));
  W_16 = _byteswap_ulong(*((_DWORD *)data + 4));
  W_20 = _byteswap_ulong(*((_DWORD *)data + 5));
  W_24 = _byteswap_ulong(*((_DWORD *)data + 6));
  W_28 = _byteswap_ulong(*((_DWORD *)data + 7));
  W_32 = _byteswap_ulong(*((_DWORD *)data + 8));
  W_36 = _byteswap_ulong(*((_DWORD *)data + 9));
  W_40 = _byteswap_ulong(*((_DWORD *)data + 10));
  W_44 = _byteswap_ulong(*((_DWORD *)data + 11));
  W_48 = _byteswap_ulong(*((_DWORD *)data + 12));
  W_52 = _byteswap_ulong(*((_DWORD *)data + 13));
  W_56 = _byteswap_ulong(*((_DWORD *)data + 14));
  W_60 = _byteswap_ulong(*((_DWORD *)data + 15));
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  E = ctx->state[4];
  F = ctx->state[5];
  G = ctx->state[6];
  temp1 = (__ROR4__(E, 6) ^ __ROR4__(E, 11) ^ __ROR4__(E, 25)) + ctx->state[7] + (G ^ (F ^ G) & E) + W + 1116352408;
  D = ctx->state[3] + temp1;
  H = temp1 + (__ROR4__(A, 2) ^ __ROR4__(A, 13) ^ __ROR4__(A, 22)) + (C & (A | B) | A & B);
  temp1a = (__ROR4__(D, 6) ^ __ROR4__(D, 11) ^ __ROR4__(D, 25)) + G + (F ^ (E ^ F) & D) + W_4 + 1899447441;
  Ca = C + temp1a;
  Ga = temp1a + (__ROR4__(H, 2) ^ __ROR4__(H, 13) ^ __ROR4__(H, 22)) + (B & (H | A) | H & A);
  temp1b = (__ROR4__(Ca, 6) ^ __ROR4__(Ca, 11) ^ __ROR4__(Ca, 25)) + F + (E ^ (D ^ E) & Ca) + W_8 - 1245643825;
  Ba = B + temp1b;
  Fa = temp1b + (__ROR4__(Ga, 2) ^ __ROR4__(Ga, 13) ^ __ROR4__(Ga, 22)) + (A & (Ga | H) | Ga & H);
  temp1c = (__ROR4__(Ba, 6) ^ __ROR4__(Ba, 11) ^ __ROR4__(Ba, 25)) + E + (D ^ (Ca ^ D) & Ba) + W_12 - 373957723;
  Aa = A + temp1c;
  Ea = temp1c + (__ROR4__(Fa, 2) ^ __ROR4__(Fa, 13) ^ __ROR4__(Fa, 22)) + (H & (Fa | Ga) | Fa & Ga);
  temp1d = (__ROR4__(Aa, 6) ^ __ROR4__(Aa, 11) ^ __ROR4__(Aa, 25)) + D + (Ca ^ (Ba ^ Ca) & Aa) + W_16 + 961987163;
  Ha = H + temp1d;
  Da = temp1d + (__ROR4__(Ea, 2) ^ __ROR4__(Ea, 13) ^ __ROR4__(Ea, 22)) + (Ga & (Ea | Fa) | Ea & Fa);
  temp1e = (__ROR4__(Ha, 6) ^ __ROR4__(Ha, 11) ^ __ROR4__(Ha, 25)) + Ca + (Ba ^ (Aa ^ Ba) & Ha) + W_20 + 1508970993;
  Gb = Ga + temp1e;
  Cb = temp1e + (__ROR4__(Da, 2) ^ __ROR4__(Da, 13) ^ __ROR4__(Da, 22)) + (Fa & (Da | Ea) | Da & Ea);
  temp1f = (__ROR4__(Gb, 6) ^ __ROR4__(Gb, 11) ^ __ROR4__(Gb, 25)) + Ba + (Aa ^ (Ha ^ Aa) & Gb) + W_24 - 1841331548;
  Fb = Fa + temp1f;
  Bb = temp1f + (__ROR4__(Cb, 2) ^ __ROR4__(Cb, 13) ^ __ROR4__(Cb, 22)) + (Ea & (Cb | Da) | Cb & Da);
  temp1g = (__ROR4__(Fb, 6) ^ __ROR4__(Fb, 11) ^ __ROR4__(Fb, 25)) + Aa + (Ha ^ (Gb ^ Ha) & Fb) + W_28 - 1424204075;
  Eb = Ea + temp1g;
  Ab = temp1g + (__ROR4__(Bb, 2) ^ __ROR4__(Bb, 13) ^ __ROR4__(Bb, 22)) + (Da & (Bb | Cb) | Bb & Cb);
  temp1h = (__ROR4__(Eb, 6) ^ __ROR4__(Eb, 11) ^ __ROR4__(Eb, 25)) + Ha + (Gb ^ (Fb ^ Gb) & Eb) + W_32 - 670586216;
  Db = Da + temp1h;
  Hb = temp1h + (__ROR4__(Ab, 2) ^ __ROR4__(Ab, 13) ^ __ROR4__(Ab, 22)) + (Cb & (Ab | Bb) | Ab & Bb);
  temp1i = (__ROR4__(Db, 6) ^ __ROR4__(Db, 11) ^ __ROR4__(Db, 25)) + Gb + (Fb ^ (Eb ^ Fb) & Db) + W_36 + 310598401;
  Cc = Cb + temp1i;
  Gc = temp1i + (__ROR4__(Hb, 2) ^ __ROR4__(Hb, 13) ^ __ROR4__(Hb, 22)) + (Bb & (Hb | Ab) | Hb & Ab);
  temp1j = (__ROR4__(Cc, 6) ^ __ROR4__(Cc, 11) ^ __ROR4__(Cc, 25)) + Fb + (Eb ^ (Db ^ Eb) & Cc) + W_40 + 607225278;
  Bc = Bb + temp1j;
  Fc = temp1j + (__ROR4__(Gc, 2) ^ __ROR4__(Gc, 13) ^ __ROR4__(Gc, 22)) + (Ab & (Gc | Hb) | Gc & Hb);
  temp1k = (__ROR4__(Bc, 6) ^ __ROR4__(Bc, 11) ^ __ROR4__(Bc, 25)) + Eb + (Db ^ (Cc ^ Db) & Bc) + W_44 + 1426881987;
  Ac = Ab + temp1k;
  Ec = temp1k + (__ROR4__(Fc, 2) ^ __ROR4__(Fc, 13) ^ __ROR4__(Fc, 22)) + (Hb & (Fc | Gc) | Fc & Gc);
  temp1l = (__ROR4__(Ac, 6) ^ __ROR4__(Ac, 11) ^ __ROR4__(Ac, 25)) + Db + (Cc ^ (Bc ^ Cc) & Ac) + W_48 + 1925078388;
  Hc = Hb + temp1l;
  Dc = temp1l + (__ROR4__(Ec, 2) ^ __ROR4__(Ec, 13) ^ __ROR4__(Ec, 22)) + (Gc & (Ec | Fc) | Ec & Fc);
  temp1m = (__ROR4__(Hc, 6) ^ __ROR4__(Hc, 11) ^ __ROR4__(Hc, 25)) + Cc + (Bc ^ (Ac ^ Bc) & Hc) + W_52 - 2132889090;
  Gd = Gc + temp1m;
  Cd = temp1m + (__ROR4__(Dc, 2) ^ __ROR4__(Dc, 13) ^ __ROR4__(Dc, 22)) + (Fc & (Dc | Ec) | Dc & Ec);
  temp1n = (__ROR4__(Gd, 6) ^ __ROR4__(Gd, 11) ^ __ROR4__(Gd, 25)) + Bc + (Ac ^ (Hc ^ Ac) & Gd) + W_56 - 1680079193;
  Fd = Fc + temp1n;
  Bd = temp1n + (__ROR4__(Cd, 2) ^ __ROR4__(Cd, 13) ^ __ROR4__(Cd, 22)) + (Ec & (Cd | Dc) | Cd & Dc);
  temp1o = (__ROR4__(Fd, 6) ^ __ROR4__(Fd, 11) ^ __ROR4__(Fd, 25)) + Ac + (Hc ^ (Gd ^ Hc) & Fd) + W_60 - 1046744716;
  Ed = Ec + temp1o;
  Ad = temp1o + (__ROR4__(Bd, 2) ^ __ROR4__(Bd, 13) ^ __ROR4__(Bd, 22)) + (Dc & (Bd | Cd) | Bd & Cd);
  W_64 = (__ROR4__(W_56, 17) ^ __ROR4__(W_56, 19) ^ (W_56 >> 10))
       + W_36
       + ((W_4 >> 3) ^ __ROR4__(W_4, 7) ^ __ROR4__(W_4, 18))
       + W;
  temp1p = (__ROR4__(Ed, 6) ^ __ROR4__(Ed, 11) ^ __ROR4__(Ed, 25)) + Hc + (Gd ^ (Fd ^ Gd) & Ed) + W_64 - 459576895;
  Dd = Dc + temp1p;
  Hd = temp1p + (__ROR4__(Ad, 2) ^ __ROR4__(Ad, 13) ^ __ROR4__(Ad, 22)) + (Cd & (Ad | Bd) | Ad & Bd);
  W_68 = (__ROR4__(W_60, 17) ^ __ROR4__(W_60, 19) ^ (W_60 >> 10))
       + W_40
       + ((W_8 >> 3) ^ __ROR4__(W_8, 7) ^ __ROR4__(W_8, 18))
       + W_4;
  temp1q = (__ROR4__(Dd, 6) ^ __ROR4__(Dd, 11) ^ __ROR4__(Dd, 25)) + Gd + (Fd ^ (Ed ^ Fd) & Dd) + W_68 - 272742522;
  Ce = Cd + temp1q;
  Ge = temp1q + (__ROR4__(Hd, 2) ^ __ROR4__(Hd, 13) ^ __ROR4__(Hd, 22)) + (Bd & (Hd | Ad) | Hd & Ad);
  W_72 = (__ROR4__(W_64, 17) ^ __ROR4__(W_64, 19) ^ (W_64 >> 10))
       + W_44
       + ((W_12 >> 3) ^ __ROR4__(W_12, 7) ^ __ROR4__(W_12, 18))
       + W_8;
  temp1r = (__ROR4__(Ce, 6) ^ __ROR4__(Ce, 11) ^ __ROR4__(Ce, 25)) + Fd + (Ed ^ (Dd ^ Ed) & Ce) + W_72 + 264347078;
  Be = Bd + temp1r;
  Fe = temp1r + (__ROR4__(Ge, 2) ^ __ROR4__(Ge, 13) ^ __ROR4__(Ge, 22)) + (Ad & (Ge | Hd) | Ge & Hd);
  W_76 = (__ROR4__(W_68, 17) ^ __ROR4__(W_68, 19) ^ (W_68 >> 10))
       + W_48
       + ((W_16 >> 3) ^ __ROR4__(W_16, 7) ^ __ROR4__(W_16, 18))
       + W_12;
  temp1s = (__ROR4__(Be, 6) ^ __ROR4__(Be, 11) ^ __ROR4__(Be, 25)) + Ed + (Dd ^ (Ce ^ Dd) & Be) + W_76 + 604807628;
  Ae = Ad + temp1s;
  Ee = temp1s + (__ROR4__(Fe, 2) ^ __ROR4__(Fe, 13) ^ __ROR4__(Fe, 22)) + (Hd & (Fe | Ge) | Fe & Ge);
  W_80 = (__ROR4__(W_72, 17) ^ __ROR4__(W_72, 19) ^ (W_72 >> 10))
       + W_52
       + ((W_20 >> 3) ^ __ROR4__(W_20, 7) ^ __ROR4__(W_20, 18))
       + W_16;
  temp1t = (__ROR4__(Ae, 6) ^ __ROR4__(Ae, 11) ^ __ROR4__(Ae, 25)) + Dd + (Ce ^ (Be ^ Ce) & Ae) + W_80 + 770255983;
  He = Hd + temp1t;
  De = temp1t + (__ROR4__(Ee, 2) ^ __ROR4__(Ee, 13) ^ __ROR4__(Ee, 22)) + (Ge & (Ee | Fe) | Ee & Fe);
  W_84 = (__ROR4__(W_76, 17) ^ __ROR4__(W_76, 19) ^ (W_76 >> 10))
       + W_56
       + ((W_24 >> 3) ^ __ROR4__(W_24, 7) ^ __ROR4__(W_24, 18))
       + W_20;
  temp1u = (__ROR4__(He, 6) ^ __ROR4__(He, 11) ^ __ROR4__(He, 25)) + Ce + (Be ^ (Ae ^ Be) & He) + W_84 + 1249150122;
  Gf = Ge + temp1u;
  Cf = temp1u + (__ROR4__(De, 2) ^ __ROR4__(De, 13) ^ __ROR4__(De, 22)) + (Fe & (De | Ee) | De & Ee);
  W_88 = (__ROR4__(W_80, 17) ^ __ROR4__(W_80, 19) ^ (W_80 >> 10))
       + W_60
       + ((W_28 >> 3) ^ __ROR4__(W_28, 7) ^ __ROR4__(W_28, 18))
       + W_24;
  temp1v = (__ROR4__(Gf, 6) ^ __ROR4__(Gf, 11) ^ __ROR4__(Gf, 25)) + Be + (Ae ^ (He ^ Ae) & Gf) + W_88 + 1555081692;
  Ff = Fe + temp1v;
  Bf = temp1v + (__ROR4__(Cf, 2) ^ __ROR4__(Cf, 13) ^ __ROR4__(Cf, 22)) + (Ee & (Cf | De) | Cf & De);
  W_92 = (__ROR4__(W_84, 17) ^ __ROR4__(W_84, 19) ^ (W_84 >> 10))
       + W_64
       + ((W_32 >> 3) ^ __ROR4__(W_32, 7) ^ __ROR4__(W_32, 18))
       + W_28;
  temp1w = (__ROR4__(Ff, 6) ^ __ROR4__(Ff, 11) ^ __ROR4__(Ff, 25)) + Ae + (He ^ (Gf ^ He) & Ff) + W_92 + 1996064986;
  Ef = Ee + temp1w;
  Af = temp1w + (__ROR4__(Bf, 2) ^ __ROR4__(Bf, 13) ^ __ROR4__(Bf, 22)) + (De & (Bf | Cf) | Bf & Cf);
  W_96 = (__ROR4__(W_88, 17) ^ __ROR4__(W_88, 19) ^ (W_88 >> 10))
       + W_68
       + ((W_36 >> 3) ^ __ROR4__(W_36, 7) ^ __ROR4__(W_36, 18))
       + W_32;
  temp1x = (__ROR4__(Ef, 6) ^ __ROR4__(Ef, 11) ^ __ROR4__(Ef, 25)) + He + (Gf ^ (Ff ^ Gf) & Ef) + W_96 - 1740746414;
  Df = De + temp1x;
  Hf = temp1x + (__ROR4__(Af, 2) ^ __ROR4__(Af, 13) ^ __ROR4__(Af, 22)) + (Cf & (Af | Bf) | Af & Bf);
  W_100 = (__ROR4__(W_92, 17) ^ __ROR4__(W_92, 19) ^ (W_92 >> 10))
        + W_72
        + ((W_40 >> 3) ^ __ROR4__(W_40, 7) ^ __ROR4__(W_40, 18))
        + W_36;
  temp1y = (__ROR4__(Df, 6) ^ __ROR4__(Df, 11) ^ __ROR4__(Df, 25)) + Gf + (Ff ^ (Ef ^ Ff) & Df) + W_100 - 1473132947;
  Cg = Cf + temp1y;
  Gg = temp1y + (__ROR4__(Hf, 2) ^ __ROR4__(Hf, 13) ^ __ROR4__(Hf, 22)) + (Bf & (Hf | Af) | Hf & Af);
  W_104 = (__ROR4__(W_96, 17) ^ __ROR4__(W_96, 19) ^ (W_96 >> 10))
        + W_76
        + ((W_44 >> 3) ^ __ROR4__(W_44, 7) ^ __ROR4__(W_44, 18))
        + W_40;
  temp1z = (__ROR4__(Cg, 6) ^ __ROR4__(Cg, 11) ^ __ROR4__(Cg, 25)) + Ff + (Ef ^ (Df ^ Ef) & Cg) + W_104 - 1341970488;
  Bg = Bf + temp1z;
  Fg = temp1z + (__ROR4__(Gg, 2) ^ __ROR4__(Gg, 13) ^ __ROR4__(Gg, 22)) + (Af & (Gg | Hf) | Gg & Hf);
  W_108 = (__ROR4__(W_100, 17) ^ __ROR4__(W_100, 19) ^ (W_100 >> 10))
        + W_80
        + ((W_48 >> 3) ^ __ROR4__(W_48, 7) ^ __ROR4__(W_48, 18))
        + W_44;
  temp1ba = (__ROR4__(Bg, 6) ^ __ROR4__(Bg, 11) ^ __ROR4__(Bg, 25)) + Ef + (Df ^ (Cg ^ Df) & Bg) + W_108 - 1084653625;
  Ag = Af + temp1ba;
  Eg = temp1ba + (__ROR4__(Fg, 2) ^ __ROR4__(Fg, 13) ^ __ROR4__(Fg, 22)) + (Hf & (Fg | Gg) | Fg & Gg);
  W_112 = (__ROR4__(W_104, 17) ^ __ROR4__(W_104, 19) ^ (W_104 >> 10))
        + W_84
        + ((W_52 >> 3) ^ __ROR4__(W_52, 7) ^ __ROR4__(W_52, 18))
        + W_48;
  temp1bb = (__ROR4__(Ag, 6) ^ __ROR4__(Ag, 11) ^ __ROR4__(Ag, 25)) + Df + (Cg ^ (Bg ^ Cg) & Ag) + W_112 - 958395405;
  Hg = Hf + temp1bb;
  Dg = temp1bb + (__ROR4__(Eg, 2) ^ __ROR4__(Eg, 13) ^ __ROR4__(Eg, 22)) + (Gg & (Eg | Fg) | Eg & Fg);
  W_116 = (__ROR4__(W_108, 17) ^ __ROR4__(W_108, 19) ^ (W_108 >> 10))
        + W_88
        + ((W_56 >> 3) ^ __ROR4__(W_56, 7) ^ __ROR4__(W_56, 18))
        + W_52;
  temp1bc = (__ROR4__(Hg, 6) ^ __ROR4__(Hg, 11) ^ __ROR4__(Hg, 25)) + Cg + (Bg ^ (Ag ^ Bg) & Hg) + W_116 - 710438585;
  Gh = Gg + temp1bc;
  Ch = temp1bc + (__ROR4__(Dg, 2) ^ __ROR4__(Dg, 13) ^ __ROR4__(Dg, 22)) + (Fg & (Dg | Eg) | Dg & Eg);
  W_120 = (__ROR4__(W_112, 17) ^ __ROR4__(W_112, 19) ^ (W_112 >> 10))
        + W_92
        + ((W_60 >> 3) ^ __ROR4__(W_60, 7) ^ __ROR4__(W_60, 18))
        + W_56;
  temp1bd = (__ROR4__(Gh, 6) ^ __ROR4__(Gh, 11) ^ __ROR4__(Gh, 25)) + Bg + (Ag ^ (Hg ^ Ag) & Gh) + W_120 + 113926993;
  Fh = Fg + temp1bd;
  Bh = temp1bd + (__ROR4__(Ch, 2) ^ __ROR4__(Ch, 13) ^ __ROR4__(Ch, 22)) + (Eg & (Ch | Dg) | Ch & Dg);
  W_124 = (__ROR4__(W_116, 17) ^ __ROR4__(W_116, 19) ^ (W_116 >> 10))
        + W_96
        + ((W_64 >> 3) ^ __ROR4__(W_64, 7) ^ __ROR4__(W_64, 18))
        + W_60;
  temp1be = (__ROR4__(Fh, 6) ^ __ROR4__(Fh, 11) ^ __ROR4__(Fh, 25)) + Ag + (Hg ^ (Gh ^ Hg) & Fh) + W_124 + 338241895;
  Eh = Eg + temp1be;
  Ah = temp1be + (__ROR4__(Bh, 2) ^ __ROR4__(Bh, 13) ^ __ROR4__(Bh, 22)) + (Dg & (Bh | Ch) | Bh & Ch);
  W_128 = (__ROR4__(W_120, 17) ^ __ROR4__(W_120, 19) ^ (W_120 >> 10))
        + W_100
        + ((W_68 >> 3) ^ __ROR4__(W_68, 7) ^ __ROR4__(W_68, 18))
        + W_64;
  temp1bf = (__ROR4__(Eh, 6) ^ __ROR4__(Eh, 11) ^ __ROR4__(Eh, 25)) + Hg + (Gh ^ (Fh ^ Gh) & Eh) + W_128 + 666307205;
  Dh = Dg + temp1bf;
  Hh = temp1bf + (__ROR4__(Ah, 2) ^ __ROR4__(Ah, 13) ^ __ROR4__(Ah, 22)) + (Ch & (Ah | Bh) | Ah & Bh);
  W_132 = (__ROR4__(W_124, 17) ^ __ROR4__(W_124, 19) ^ (W_124 >> 10))
        + W_104
        + ((W_72 >> 3) ^ __ROR4__(W_72, 7) ^ __ROR4__(W_72, 18))
        + W_68;
  temp1bg = (__ROR4__(Dh, 6) ^ __ROR4__(Dh, 11) ^ __ROR4__(Dh, 25)) + Gh + (Fh ^ (Eh ^ Fh) & Dh) + W_132 + 773529912;
  Ci = Ch + temp1bg;
  Gi = temp1bg + (__ROR4__(Hh, 2) ^ __ROR4__(Hh, 13) ^ __ROR4__(Hh, 22)) + (Bh & (Hh | Ah) | Hh & Ah);
  W_136 = (__ROR4__(W_128, 17) ^ __ROR4__(W_128, 19) ^ (W_128 >> 10))
        + W_108
        + ((W_76 >> 3) ^ __ROR4__(W_76, 7) ^ __ROR4__(W_76, 18))
        + W_72;
  temp1bh = (__ROR4__(Ci, 6) ^ __ROR4__(Ci, 11) ^ __ROR4__(Ci, 25)) + Fh + (Eh ^ (Dh ^ Eh) & Ci) + W_136 + 1294757372;
  Bi = Bh + temp1bh;
  Fi = temp1bh + (__ROR4__(Gi, 2) ^ __ROR4__(Gi, 13) ^ __ROR4__(Gi, 22)) + (Ah & (Gi | Hh) | Gi & Hh);
  W_140 = (__ROR4__(W_132, 17) ^ __ROR4__(W_132, 19) ^ (W_132 >> 10))
        + W_112
        + ((W_80 >> 3) ^ __ROR4__(W_80, 7) ^ __ROR4__(W_80, 18))
        + W_76;
  temp1bi = (__ROR4__(Bi, 6) ^ __ROR4__(Bi, 11) ^ __ROR4__(Bi, 25)) + Eh + (Dh ^ (Ci ^ Dh) & Bi) + W_140 + 1396182291;
  Ai = Ah + temp1bi;
  Ei = temp1bi + (__ROR4__(Fi, 2) ^ __ROR4__(Fi, 13) ^ __ROR4__(Fi, 22)) + (Hh & (Fi | Gi) | Fi & Gi);
  W_144 = (__ROR4__(W_136, 17) ^ __ROR4__(W_136, 19) ^ (W_136 >> 10))
        + W_116
        + ((W_84 >> 3) ^ __ROR4__(W_84, 7) ^ __ROR4__(W_84, 18))
        + W_80;
  temp1bj = (__ROR4__(Ai, 6) ^ __ROR4__(Ai, 11) ^ __ROR4__(Ai, 25)) + Dh + (Ci ^ (Bi ^ Ci) & Ai) + W_144 + 1695183700;
  Hi = Hh + temp1bj;
  Di = temp1bj + (__ROR4__(Ei, 2) ^ __ROR4__(Ei, 13) ^ __ROR4__(Ei, 22)) + (Gi & (Ei | Fi) | Ei & Fi);
  W_148 = (__ROR4__(W_140, 17) ^ __ROR4__(W_140, 19) ^ (W_140 >> 10))
        + W_120
        + ((W_88 >> 3) ^ __ROR4__(W_88, 7) ^ __ROR4__(W_88, 18))
        + W_84;
  temp1bk = (__ROR4__(Hi, 6) ^ __ROR4__(Hi, 11) ^ __ROR4__(Hi, 25)) + Ci + (Bi ^ (Ai ^ Bi) & Hi) + W_148 + 1986661051;
  Gj = Gi + temp1bk;
  Cj = temp1bk + (__ROR4__(Di, 2) ^ __ROR4__(Di, 13) ^ __ROR4__(Di, 22)) + (Fi & (Di | Ei) | Di & Ei);
  W_152 = (__ROR4__(W_144, 17) ^ __ROR4__(W_144, 19) ^ (W_144 >> 10))
        + W_124
        + ((W_92 >> 3) ^ __ROR4__(W_92, 7) ^ __ROR4__(W_92, 18))
        + W_88;
  temp1bl = (__ROR4__(Gj, 6) ^ __ROR4__(Gj, 11) ^ __ROR4__(Gj, 25)) + Bi + (Ai ^ (Hi ^ Ai) & Gj) + W_152 - 2117940946;
  Fj = Fi + temp1bl;
  Bj = temp1bl + (__ROR4__(Cj, 2) ^ __ROR4__(Cj, 13) ^ __ROR4__(Cj, 22)) + (Ei & (Cj | Di) | Cj & Di);
  W_156 = (__ROR4__(W_148, 17) ^ __ROR4__(W_148, 19) ^ (W_148 >> 10))
        + W_128
        + ((W_96 >> 3) ^ __ROR4__(W_96, 7) ^ __ROR4__(W_96, 18))
        + W_92;
  temp1bm = (__ROR4__(Fj, 6) ^ __ROR4__(Fj, 11) ^ __ROR4__(Fj, 25)) + Ai + (Hi ^ (Gj ^ Hi) & Fj) + W_156 - 1838011259;
  Ej = Ei + temp1bm;
  Aj = temp1bm + (__ROR4__(Bj, 2) ^ __ROR4__(Bj, 13) ^ __ROR4__(Bj, 22)) + (Di & (Bj | Cj) | Bj & Cj);
  W_160 = (__ROR4__(W_152, 17) ^ __ROR4__(W_152, 19) ^ (W_152 >> 10))
        + W_132
        + ((W_100 >> 3) ^ __ROR4__(W_100, 7) ^ __ROR4__(W_100, 18))
        + W_96;
  temp1bn = (__ROR4__(Ej, 6) ^ __ROR4__(Ej, 11) ^ __ROR4__(Ej, 25)) + Hi + (Gj ^ (Fj ^ Gj) & Ej) + W_160 - 1564481375;
  Dj = Di + temp1bn;
  Hj = temp1bn + (__ROR4__(Aj, 2) ^ __ROR4__(Aj, 13) ^ __ROR4__(Aj, 22)) + (Cj & (Aj | Bj) | Aj & Bj);
  W_164 = (__ROR4__(W_156, 17) ^ __ROR4__(W_156, 19) ^ (W_156 >> 10))
        + W_136
        + ((W_104 >> 3) ^ __ROR4__(W_104, 7) ^ __ROR4__(W_104, 18))
        + W_100;
  temp1bo = (__ROR4__(Dj, 6) ^ __ROR4__(Dj, 11) ^ __ROR4__(Dj, 25)) + Gj + (Fj ^ (Ej ^ Fj) & Dj) + W_164 - 1474664885;
  Ck = Cj + temp1bo;
  Gk = temp1bo + (__ROR4__(Hj, 2) ^ __ROR4__(Hj, 13) ^ __ROR4__(Hj, 22)) + (Bj & (Hj | Aj) | Hj & Aj);
  W_168 = (__ROR4__(W_160, 17) ^ __ROR4__(W_160, 19) ^ (W_160 >> 10))
        + W_140
        + ((W_108 >> 3) ^ __ROR4__(W_108, 7) ^ __ROR4__(W_108, 18))
        + W_104;
  temp1bp = (__ROR4__(Ck, 6) ^ __ROR4__(Ck, 11) ^ __ROR4__(Ck, 25)) + Fj + (Ej ^ (Dj ^ Ej) & Ck) + W_168 - 1035236496;
  Bk = Bj + temp1bp;
  Fk = temp1bp + (__ROR4__(Gk, 2) ^ __ROR4__(Gk, 13) ^ __ROR4__(Gk, 22)) + (Aj & (Gk | Hj) | Gk & Hj);
  W_172 = (__ROR4__(W_164, 17) ^ __ROR4__(W_164, 19) ^ (W_164 >> 10))
        + W_144
        + ((W_112 >> 3) ^ __ROR4__(W_112, 7) ^ __ROR4__(W_112, 18))
        + W_108;
  temp1bq = (__ROR4__(Bk, 6) ^ __ROR4__(Bk, 11) ^ __ROR4__(Bk, 25)) + Ej + (Dj ^ (Ck ^ Dj) & Bk) + W_172 - 949202525;
  Ak = Aj + temp1bq;
  Ek = temp1bq + (__ROR4__(Fk, 2) ^ __ROR4__(Fk, 13) ^ __ROR4__(Fk, 22)) + (Hj & (Fk | Gk) | Fk & Gk);
  W_176 = (__ROR4__(W_168, 17) ^ __ROR4__(W_168, 19) ^ (W_168 >> 10))
        + W_148
        + ((W_116 >> 3) ^ __ROR4__(W_116, 7) ^ __ROR4__(W_116, 18))
        + W_112;
  temp1br = (__ROR4__(Ak, 6) ^ __ROR4__(Ak, 11) ^ __ROR4__(Ak, 25)) + Dj + (Ck ^ (Bk ^ Ck) & Ak) + W_176 - 778901479;
  Hk = Hj + temp1br;
  Dk = temp1br + (__ROR4__(Ek, 2) ^ __ROR4__(Ek, 13) ^ __ROR4__(Ek, 22)) + (Gk & (Ek | Fk) | Ek & Fk);
  W_180 = (__ROR4__(W_172, 17) ^ __ROR4__(W_172, 19) ^ (W_172 >> 10))
        + W_152
        + ((W_120 >> 3) ^ __ROR4__(W_120, 7) ^ __ROR4__(W_120, 18))
        + W_116;
  temp1bs = (__ROR4__(Hk, 6) ^ __ROR4__(Hk, 11) ^ __ROR4__(Hk, 25)) + Ck + (Bk ^ (Ak ^ Bk) & Hk) + W_180 - 694614492;
  Gl = Gk + temp1bs;
  Cl = temp1bs + (__ROR4__(Dk, 2) ^ __ROR4__(Dk, 13) ^ __ROR4__(Dk, 22)) + (Fk & (Dk | Ek) | Dk & Ek);
  W_184 = (__ROR4__(W_176, 17) ^ __ROR4__(W_176, 19) ^ (W_176 >> 10))
        + W_156
        + ((W_124 >> 3) ^ __ROR4__(W_124, 7) ^ __ROR4__(W_124, 18))
        + W_120;
  temp1bt = (__ROR4__(Gl, 6) ^ __ROR4__(Gl, 11) ^ __ROR4__(Gl, 25)) + Bk + (Ak ^ (Hk ^ Ak) & Gl) + W_184 - 200395387;
  Fl = Fk + temp1bt;
  Bl = temp1bt + (__ROR4__(Cl, 2) ^ __ROR4__(Cl, 13) ^ __ROR4__(Cl, 22)) + (Ek & (Cl | Dk) | Cl & Dk);
  W_188 = (__ROR4__(W_180, 17) ^ __ROR4__(W_180, 19) ^ (W_180 >> 10))
        + W_160
        + ((W_128 >> 3) ^ __ROR4__(W_128, 7) ^ __ROR4__(W_128, 18))
        + W_124;
  temp1bu = (__ROR4__(Fl, 6) ^ __ROR4__(Fl, 11) ^ __ROR4__(Fl, 25)) + Ak + (Hk ^ (Gl ^ Hk) & Fl) + W_188 + 275423344;
  El = Ek + temp1bu;
  Al = temp1bu + (__ROR4__(Bl, 2) ^ __ROR4__(Bl, 13) ^ __ROR4__(Bl, 22)) + (Dk & (Bl | Cl) | Bl & Cl);
  W_192 = (__ROR4__(W_184, 17) ^ __ROR4__(W_184, 19) ^ (W_184 >> 10))
        + W_164
        + ((W_132 >> 3) ^ __ROR4__(W_132, 7) ^ __ROR4__(W_132, 18))
        + W_128;
  temp1bv = (__ROR4__(El, 6) ^ __ROR4__(El, 11) ^ __ROR4__(El, 25)) + Hk + (Gl ^ (Fl ^ Gl) & El) + W_192 + 430227734;
  Dl = Dk + temp1bv;
  Hl = temp1bv + (__ROR4__(Al, 2) ^ __ROR4__(Al, 13) ^ __ROR4__(Al, 22)) + (Cl & (Al | Bl) | Al & Bl);
  W_196 = (__ROR4__(W_188, 17) ^ __ROR4__(W_188, 19) ^ (W_188 >> 10))
        + W_168
        + ((W_136 >> 3) ^ __ROR4__(W_136, 7) ^ __ROR4__(W_136, 18))
        + W_132;
  temp1bw = (__ROR4__(Dl, 6) ^ __ROR4__(Dl, 11) ^ __ROR4__(Dl, 25)) + Gl + (Fl ^ (El ^ Fl) & Dl) + W_196 + 506948616;
  Cm = Cl + temp1bw;
  Gm = temp1bw + (__ROR4__(Hl, 2) ^ __ROR4__(Hl, 13) ^ __ROR4__(Hl, 22)) + (Bl & (Hl | Al) | Hl & Al);
  W_200 = (__ROR4__(W_192, 17) ^ __ROR4__(W_192, 19) ^ (W_192 >> 10))
        + W_172
        + ((W_140 >> 3) ^ __ROR4__(W_140, 7) ^ __ROR4__(W_140, 18))
        + W_136;
  temp1bx = (__ROR4__(Cm, 6) ^ __ROR4__(Cm, 11) ^ __ROR4__(Cm, 25)) + Fl + (El ^ (Dl ^ El) & Cm) + W_200 + 659060556;
  Bm = Bl + temp1bx;
  Fm = temp1bx + (__ROR4__(Gm, 2) ^ __ROR4__(Gm, 13) ^ __ROR4__(Gm, 22)) + (Al & (Gm | Hl) | Gm & Hl);
  W_204 = (__ROR4__(W_196, 17) ^ __ROR4__(W_196, 19) ^ (W_196 >> 10))
        + W_176
        + ((W_144 >> 3) ^ __ROR4__(W_144, 7) ^ __ROR4__(W_144, 18))
        + W_140;
  temp1by = (__ROR4__(Bm, 6) ^ __ROR4__(Bm, 11) ^ __ROR4__(Bm, 25)) + El + (Dl ^ (Cm ^ Dl) & Bm) + W_204 + 883997877;
  Am = Al + temp1by;
  Em = temp1by + (__ROR4__(Fm, 2) ^ __ROR4__(Fm, 13) ^ __ROR4__(Fm, 22)) + (Hl & (Fm | Gm) | Fm & Gm);
  W_208 = (__ROR4__(W_200, 17) ^ __ROR4__(W_200, 19) ^ (W_200 >> 10))
        + W_180
        + ((W_148 >> 3) ^ __ROR4__(W_148, 7) ^ __ROR4__(W_148, 18))
        + W_144;
  temp1bz = (__ROR4__(Am, 6) ^ __ROR4__(Am, 11) ^ __ROR4__(Am, 25)) + Dl + (Cm ^ (Bm ^ Cm) & Am) + W_208 + 958139571;
  Hm = Hl + temp1bz;
  Dm = temp1bz + (__ROR4__(Em, 2) ^ __ROR4__(Em, 13) ^ __ROR4__(Em, 22)) + (Gm & (Em | Fm) | Em & Fm);
  W_212 = (__ROR4__(W_204, 17) ^ __ROR4__(W_204, 19) ^ (W_204 >> 10))
        + W_184
        + ((W_152 >> 3) ^ __ROR4__(W_152, 7) ^ __ROR4__(W_152, 18))
        + W_148;
  temp1ca = (__ROR4__(Hm, 6) ^ __ROR4__(Hm, 11) ^ __ROR4__(Hm, 25)) + Cm + (Bm ^ (Am ^ Bm) & Hm) + W_212 + 1322822218;
  Gn = Gm + temp1ca;
  Cn = temp1ca + (__ROR4__(Dm, 2) ^ __ROR4__(Dm, 13) ^ __ROR4__(Dm, 22)) + (Fm & (Dm | Em) | Dm & Em);
  W_216 = (__ROR4__(W_208, 17) ^ __ROR4__(W_208, 19) ^ (W_208 >> 10))
        + W_188
        + ((W_156 >> 3) ^ __ROR4__(W_156, 7) ^ __ROR4__(W_156, 18))
        + W_152;
  temp1cb = (__ROR4__(Gn, 6) ^ __ROR4__(Gn, 11) ^ __ROR4__(Gn, 25)) + Bm + (Am ^ (Hm ^ Am) & Gn) + W_216 + 1537002063;
  Fn = Fm + temp1cb;
  Bn = temp1cb + (__ROR4__(Cn, 2) ^ __ROR4__(Cn, 13) ^ __ROR4__(Cn, 22)) + (Em & (Cn | Dm) | Cn & Dm);
  W_220 = (__ROR4__(W_212, 17) ^ __ROR4__(W_212, 19) ^ (W_212 >> 10))
        + W_192
        + ((W_160 >> 3) ^ __ROR4__(W_160, 7) ^ __ROR4__(W_160, 18))
        + W_156;
  temp1cc = (__ROR4__(Fn, 6) ^ __ROR4__(Fn, 11) ^ __ROR4__(Fn, 25)) + Am + (Hm ^ (Gn ^ Hm) & Fn) + W_220 + 1747873779;
  En = Em + temp1cc;
  An = temp1cc + (__ROR4__(Bn, 2) ^ __ROR4__(Bn, 13) ^ __ROR4__(Bn, 22)) + (Dm & (Bn | Cn) | Bn & Cn);
  W_224 = (__ROR4__(W_216, 17) ^ __ROR4__(W_216, 19) ^ (W_216 >> 10))
        + W_196
        + ((W_164 >> 3) ^ __ROR4__(W_164, 7) ^ __ROR4__(W_164, 18))
        + W_160;
  temp1cd = (__ROR4__(En, 6) ^ __ROR4__(En, 11) ^ __ROR4__(En, 25)) + Hm + (Gn ^ (Fn ^ Gn) & En) + W_224 + 1955562222;
  Dn = Dm + temp1cd;
  Hn = temp1cd + (__ROR4__(An, 2) ^ __ROR4__(An, 13) ^ __ROR4__(An, 22)) + (Cn & (An | Bn) | An & Bn);
  W_228 = (__ROR4__(W_220, 17) ^ __ROR4__(W_220, 19) ^ (W_220 >> 10))
        + W_200
        + ((W_168 >> 3) ^ __ROR4__(W_168, 7) ^ __ROR4__(W_168, 18))
        + W_164;
  temp1ce = (__ROR4__(Dn, 6) ^ __ROR4__(Dn, 11) ^ __ROR4__(Dn, 25)) + Gn + (Fn ^ (En ^ Fn) & Dn) + W_228 + 2024104815;
  Co = Cn + temp1ce;
  Go = temp1ce + (__ROR4__(Hn, 2) ^ __ROR4__(Hn, 13) ^ __ROR4__(Hn, 22)) + (Bn & (Hn | An) | Hn & An);
  W_232 = (__ROR4__(W_224, 17) ^ __ROR4__(W_224, 19) ^ (W_224 >> 10))
        + W_204
        + ((W_172 >> 3) ^ __ROR4__(W_172, 7) ^ __ROR4__(W_172, 18))
        + W_168;
  temp1cf = (__ROR4__(Co, 6) ^ __ROR4__(Co, 11) ^ __ROR4__(Co, 25)) + Fn + (En ^ (Dn ^ En) & Co) + W_232 - 2067236844;
  Bo = Bn + temp1cf;
  Fo = temp1cf + (__ROR4__(Go, 2) ^ __ROR4__(Go, 13) ^ __ROR4__(Go, 22)) + (An & (Go | Hn) | Go & Hn);
  W_236 = (__ROR4__(W_228, 17) ^ __ROR4__(W_228, 19) ^ (W_228 >> 10))
        + W_208
        + ((W_176 >> 3) ^ __ROR4__(W_176, 7) ^ __ROR4__(W_176, 18))
        + W_172;
  temp1cg = (__ROR4__(Bo, 6) ^ __ROR4__(Bo, 11) ^ __ROR4__(Bo, 25)) + En + (Dn ^ (Co ^ Dn) & Bo) + W_236 - 1933114872;
  Ao = An + temp1cg;
  Eo = temp1cg + (__ROR4__(Fo, 2) ^ __ROR4__(Fo, 13) ^ __ROR4__(Fo, 22)) + (Hn & (Fo | Go) | Fo & Go);
  W_240 = (__ROR4__(W_232, 17) ^ __ROR4__(W_232, 19) ^ (W_232 >> 10))
        + W_212
        + ((W_180 >> 3) ^ __ROR4__(W_180, 7) ^ __ROR4__(W_180, 18))
        + W_176;
  temp1ch = (__ROR4__(Ao, 6) ^ __ROR4__(Ao, 11) ^ __ROR4__(Ao, 25)) + Dn + (Co ^ (Bo ^ Co) & Ao) + W_240 - 1866530822;
  Ho = Hn + temp1ch;
  Do = temp1ch + (__ROR4__(Eo, 2) ^ __ROR4__(Eo, 13) ^ __ROR4__(Eo, 22)) + (Go & (Eo | Fo) | Eo & Fo);
  W_244 = (__ROR4__(W_236, 17) ^ __ROR4__(W_236, 19) ^ (W_236 >> 10))
        + W_216
        + ((W_184 >> 3) ^ __ROR4__(W_184, 7) ^ __ROR4__(W_184, 18))
        + W_180;
  temp1ci = (__ROR4__(Ho, 6) ^ __ROR4__(Ho, 11) ^ __ROR4__(Ho, 25)) + Co + (Bo ^ (Ao ^ Bo) & Ho) + W_244 - 1538233109;
  Gp = Go + temp1ci;
  Cp = temp1ci + (__ROR4__(Do, 2) ^ __ROR4__(Do, 13) ^ __ROR4__(Do, 22)) + (Fo & (Do | Eo) | Do & Eo);
  temp1cj = (__ROR4__(Gp, 6) ^ __ROR4__(Gp, 11) ^ __ROR4__(Gp, 25))
          + Bo
          + (Ao ^ (Ho ^ Ao) & Gp)
          + (__ROR4__(W_240, 17) ^ __ROR4__(W_240, 19) ^ (W_240 >> 10))
          + W_220
          + ((W_188 >> 3) ^ __ROR4__(W_188, 7) ^ __ROR4__(W_188, 18))
          + W_184
          - 1090935817;
  Fp = Fo + temp1cj;
  Bp = temp1cj + (__ROR4__(Cp, 2) ^ __ROR4__(Cp, 13) ^ __ROR4__(Cp, 22)) + (Eo & (Cp | Do) | Cp & Do);
  temp1ck = (__ROR4__(Fp, 6) ^ __ROR4__(Fp, 11) ^ __ROR4__(Fp, 25))
          + Ao
          + (Ho ^ (Gp ^ Ho) & Fp)
          + (__ROR4__(W_244, 17) ^ __ROR4__(W_244, 19) ^ (W_244 >> 10))
          + W_224
          + ((W_192 >> 3) ^ __ROR4__(W_192, 7) ^ __ROR4__(W_192, 18))
          + W_188
          - 965641998;
  ctx->state[0] += temp1ck + (__ROR4__(Bp, 2) ^ __ROR4__(Bp, 13) ^ __ROR4__(Bp, 22)) + (Do & (Bp | Cp) | Bp & Cp);
  ctx->state[1] += Bp;
  ctx->state[2] += Cp;
  ctx->state[3] += Do;
  ctx->state[4] += Eo + temp1ck;
  ctx->state[5] += Fp;
  ctx->state[6] += Gp;
  ctx->state[7] += Ho;
}

//----- (00059514) --------------------------------------------------------
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  signed int ilena; // [sp+4h] [bp+4h]
  const unsigned __int8 *inputa; // [sp+8h] [bp+8h]
  signed int fill; // [sp+10h] [bp+10h]
  unsigned int left; // [sp+14h] [bp+14h]

  inputa = input;
  ilena = ilen;
  if ( ilen > 0 )
  {
    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    ctx->total[0] += ilen;
    ctx->total[0] = ctx->total[0];
    if ( ctx->total[0] < ilen )
      ++ctx->total[1];
    if ( left && ilen >= fill )
    {
      memcpy(&ctx->buffer[left], input, fill);
      sha2_process(ctx, ctx->buffer);
      inputa += fill;
      ilena -= fill;
      left = 0;
    }
    while ( ilena > 63 )
    {
      sha2_process(ctx, inputa);
      inputa += 64;
      ilena -= 64;
    }
    if ( ilena > 0 )
      memcpy(&ctx->buffer[left], inputa, ilena);
  }
}

//----- (000595E4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  unsigned int v2; // r3
  unsigned __int8 msglen[8]; // [sp+8h] [bp+8h] BYREF
  unsigned int padn; // [sp+10h] [bp+10h]
  unsigned int last; // [sp+14h] [bp+14h]
  __int64 low; // [sp+18h] [bp+18h] OVERLAPPED

  low = 8LL * *(_QWORD *)ctx->total;
  msglen[0] = HIBYTE(low);
  msglen[1] = BYTE6(low);
  msglen[2] = BYTE5(low);
  msglen[3] = BYTE4(low);
  msglen[4] = BYTE3(low);
  msglen[5] = BYTE2(low);
  msglen[6] = BYTE1(low);
  msglen[7] = low;
  last = ctx->total[0] & 0x3F;
  if ( last > 0x37 )
    v2 = 120 - last;
  else
    v2 = 56 - last;
  padn = v2;
  sha2_update(ctx, sha2_padding, v2);
  sha2_update(ctx, msglen, 8);
  *output = HIBYTE(ctx->state[0]);
  output[1] = BYTE2(ctx->state[0]);
  output[2] = BYTE1(ctx->state[0]);
  output[3] = ctx->state[0];
  output[4] = HIBYTE(ctx->state[1]);
  output[5] = BYTE2(ctx->state[1]);
  output[6] = BYTE1(ctx->state[1]);
  output[7] = ctx->state[1];
  output[8] = HIBYTE(ctx->state[2]);
  output[9] = BYTE2(ctx->state[2]);
  output[10] = BYTE1(ctx->state[2]);
  output[11] = ctx->state[2];
  output[12] = HIBYTE(ctx->state[3]);
  output[13] = BYTE2(ctx->state[3]);
  output[14] = BYTE1(ctx->state[3]);
  output[15] = ctx->state[3];
  output[16] = HIBYTE(ctx->state[4]);
  output[17] = BYTE2(ctx->state[4]);
  output[18] = BYTE1(ctx->state[4]);
  output[19] = ctx->state[4];
  output[20] = HIBYTE(ctx->state[5]);
  output[21] = BYTE2(ctx->state[5]);
  output[22] = BYTE1(ctx->state[5]);
  output[23] = ctx->state[5];
  output[24] = HIBYTE(ctx->state[6]);
  output[25] = BYTE2(ctx->state[6]);
  output[26] = BYTE1(ctx->state[6]);
  output[27] = ctx->state[6];
  output[28] = HIBYTE(ctx->state[7]);
  output[29] = BYTE2(ctx->state[7]);
  output[30] = BYTE1(ctx->state[7]);
  output[31] = ctx->state[7];
}
// 595E4: variables would overlap: ^18.8 and stkvar "low" ^18.4(has user info),stkvar "high" ^1C.4(has user info)

//----- (00059838) --------------------------------------------------------
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  sha2_context ctx; // [sp+10h] [bp+10h] BYREF

  sha2_starts(&ctx);
  sha2_update(&ctx, input, ilen);
  sha2_finish(&ctx, output);
  memset(&ctx, 0, sizeof(ctx));
}

//----- (00059880) --------------------------------------------------------
void __cdecl json_decref_1(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (000598B8) --------------------------------------------------------
void __cdecl _list_add(list_head *a1, list_head *prev, list_head *next)
{
  next->prev = a1;
  a1->next = next;
  a1->prev = prev;
  prev->next = a1;
}

//----- (000598E8) --------------------------------------------------------
void __cdecl list_add_tail(list_head *a1, list_head *head)
{
  _list_add(a1, head->prev, head);
}

//----- (00059908) --------------------------------------------------------
void __cdecl _list_del_0(list_head *prev, list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

//----- (00059928) --------------------------------------------------------
void __cdecl list_del_0(list_head *entry)
{
  _list_del_0(entry->prev, entry->next);
  entry->next = 0;
  entry->prev = 0;
}

//----- (00059954) --------------------------------------------------------
int __cdecl list_empty(list_head *head)
{
  return head->next == head;
}

//----- (00059978) --------------------------------------------------------
int sock_blocks_0()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (000599A4) --------------------------------------------------------
bool sock_timeout()
{
  return *_errno_location() == 110;
}

//----- (000599C0) --------------------------------------------------------
bool interrupted()
{
  return *_errno_location() == 4;
}

//----- (000599DC) --------------------------------------------------------
void __cdecl align_len(size_t *len)
{
  if ( (*len & 3) != 0 )
    *len = (*len & 0xFFFFFFFC) + 4;
}

//----- (00059A08) --------------------------------------------------------
unsigned int __cdecl swab32_1(unsigned int v)
{
  return bswap32(v);
}

//----- (00059A20) --------------------------------------------------------
void __cdecl swab256_0(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = swab32_1(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = swab32_1(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = swab32_1(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = swab32_1(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = swab32_1(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = swab32_1(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = swab32_1(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = swab32_1(*(_DWORD *)src_p);
}

//----- (00059AE4) --------------------------------------------------------
void __cdecl mutex_lock_4(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00059B64) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_4(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00059BE4) --------------------------------------------------------
void __cdecl mutex_unlock_4(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_4(lock, file, func, line);
  selective_yield();
}

//----- (00059C14) --------------------------------------------------------
void __cdecl wr_lock_3(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00059C94) --------------------------------------------------------
void __cdecl rw_unlock_3(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00059D14) --------------------------------------------------------
void __cdecl wr_unlock_noyield_3(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_3(lock, file, func, line);
}

//----- (00059D38) --------------------------------------------------------
void __cdecl cg_wlock_3(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_4(&lock->mutex, file, func, line);
  wr_lock_3(&lock->rwlock, file, func, line);
}

//----- (00059D6C) --------------------------------------------------------
void __cdecl cg_wunlock_3(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_3(&lock->rwlock, file, func, line);
  mutex_unlock_4(&lock->mutex, file, func, line);
}

//----- (00059DA0) --------------------------------------------------------
int no_yield()
{
  return 0;
}

//----- (00059DB0) --------------------------------------------------------
void __cdecl keep_sockalive(int fd)
{
  int tcp_keepintvl; // [sp+10h] [bp+8h] BYREF
  int tcp_keepidle; // [sp+14h] [bp+Ch] BYREF
  int tcp_one; // [sp+18h] [bp+10h] BYREF
  int flags; // [sp+1Ch] [bp+14h]

  tcp_one = 1;
  tcp_keepidle = 45;
  tcp_keepintvl = 30;
  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags | 0x800);
  setsockopt(fd, 1, 9, &tcp_one, 4u);
  if ( !opt_delaynet )
    fcntl(fd, 2, 1);
  setsockopt(fd, 6, 1, &tcp_one, 4u);
  setsockopt(fd, 6, 6, &tcp_one, 4u);
  setsockopt(fd, 6, 4, &tcp_keepidle, 4u);
  setsockopt(fd, 6, 5, &tcp_keepintvl, 4u);
}

//----- (00059E60) --------------------------------------------------------
void *__cdecl cgmalloc(unsigned int size, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  size_t sizea[2]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  void *ret; // [sp+824h] [bp+814h]

  sizea[0] = size;
  align_len(sizea);
  ret = malloc(sizea[0]);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to malloc size %d from %s %s:%d",
      sizea[0],
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}
// 59E60: using guessed type size_t size[2];

//----- (00059EF8) --------------------------------------------------------
void *__cdecl cgcalloc(int memb, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  size_t sizea; // [sp+18h] [bp+8h] BYREF
  int memba; // [sp+1Ch] [bp+Ch]
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  void *ret; // [sp+824h] [bp+814h]

  memba = memb;
  sizea = size;
  align_len(&sizea);
  ret = calloc(memba, sizea);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc memb %d size %d from %s %s:%d",
      memba,
      sizea,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}

//----- (00059F9C) --------------------------------------------------------
void *__cdecl cgrealloc(
        void *ptr,
        size_t size,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  size_t sizea; // [sp+18h] [bp+8h] BYREF
  void *ptra; // [sp+1Ch] [bp+Ch]
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  void *ret; // [sp+824h] [bp+814h]

  ptra = ptr;
  sizea = size;
  align_len(&sizea);
  ret = realloc(ptra, sizea);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to realloc size %d from %s %s:%d",
      sizea,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}

//----- (0005A034) --------------------------------------------------------
const unsigned __int8 *__cdecl proxytype(proxytypes_t a1)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; proxynames[i].name; ++i )
  {
    if ( proxynames[i].proxytype == a1 )
      return proxynames[i].name;
  }
  return "invalid";
}

//----- (0005A094) --------------------------------------------------------
unsigned __int8 *__cdecl get_proxy(unsigned __int8 *url, pool *pool)
{
  unsigned __int8 *split; // [sp+Ch] [bp+Ch]
  int plen; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  pool->rpc_proxy = 0;
  for ( i = 0; proxynames[i].name; ++i )
  {
    plen = strlen((const char *)proxynames[i].name);
    if ( !strncmp((const char *)url, (const char *)proxynames[i].name, plen) )
    {
      split = (unsigned __int8 *)strchr((const char *)url, 124);
      if ( !split )
        return url;
      *split = 0;
      pool->rpc_proxy = (unsigned __int8 *)cgmalloc(split - url - plen + 1, "util.c", _func___10003, 750);
      strcpy((char *)pool->rpc_proxy, (const char *)&url[plen]);
      extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
      pool->rpc_proxytype = proxynames[i].proxytype;
      return split + 1;
    }
  }
  return url;
}

//----- (0005A1A4) --------------------------------------------------------
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *sb; // [sp+Ch] [bp+Ch]
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; (int)len > i; ++i )
  {
    *s = hex_10013[p[i] >> 4];
    sb = s + 1;
    *sb = hex_10013[p[i] & 0xF];
    s = sb + 1;
  }
  *s = 0;
}

//----- (0005A21C) --------------------------------------------------------
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *s; // [sp+10h] [bp+8h]
  int slen; // [sp+14h] [bp+Ch]

  slen = 2 * len + 1;
  if ( (slen & 3) != 0 )
    slen += 4 - slen % 4;
  s = (unsigned __int8 *)cgcalloc(slen, 1u, "util.c", _func___10023, 789);
  _bin2hex(s, p, len);
  return s;
}

//----- (0005A288) --------------------------------------------------------
bool __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len)
{
  const unsigned __int8 *hexstrb; // [sp+8h] [bp+8h]
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+14h] BYREF
  int nibble2; // [sp+814h] [bp+814h]
  int nibble1; // [sp+818h] [bp+818h]
  unsigned __int8 idx; // [sp+81Eh] [bp+81Eh]
  bool ret; // [sp+81Fh] [bp+81Fh]

  ret = 0;
  while ( 1 )
  {
    if ( !*hexstr || !len )
    {
      if ( !len && !*hexstr )
        return 1;
      return ret;
    }
    if ( !hexstr[1] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "hex2bin str truncated");
        applog(3, tmp42, 0);
      }
      return ret;
    }
    idx = *hexstr;
    hexstrb = hexstr + 1;
    nibble1 = hex2bin_tbl[idx];
    idx = *hexstrb;
    hexstr = hexstrb + 1;
    nibble2 = hex2bin_tbl[idx];
    if ( nibble1 < 0 || nibble2 < 0 )
      break;
    *p++ = nibble2 | (16 * nibble1);
    --len;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "hex2bin scan failed");
    applog(3, tmp42, 0);
  }
  return ret;
}

//----- (0005A448) --------------------------------------------------------
bool __cdecl valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 idx; // [sp+823h] [bp+813h]
  int len; // [sp+824h] [bp+814h]
  bool ret; // [sp+82Bh] [bp+81Bh]
  int i; // [sp+82Ch] [bp+81Ch]

  ret = 0;
  if ( s )
  {
    len = strlen((const char *)s);
    for ( i = 0; ; ++i )
    {
      if ( i >= len )
      {
        ret = 1;
        return 1;
      }
      idx = s[i];
      if ( hex2bin_tbl[idx] < 0 )
        break;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Invalid char 0x%x passed to valid_hex from", " in %s %s():%d");
      applog(3, tmp42, 0);
    }
    return ret;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Null string passed to valid_hex from", " in %s %s():%d", file, func, line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
}

//----- (0005A5C8) --------------------------------------------------------
bool __cdecl valid_ascii(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 idx; // [sp+823h] [bp+813h]
  int len; // [sp+824h] [bp+814h]
  bool ret; // [sp+82Bh] [bp+81Bh]
  int i; // [sp+82Ch] [bp+81Ch]

  ret = 0;
  if ( s )
  {
    len = strlen((const char *)s);
    if ( len )
    {
      for ( i = 0; ; ++i )
      {
        if ( i >= len )
        {
          ret = 1;
          return 1;
        }
        idx = s[i];
        if ( idx <= 0x1Fu || idx > 0x7Eu )
          break;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Invalid char 0x%x passed to valid_ascii from", " in %s %s():%d");
        applog(3, tmp42, 0);
      }
      return ret;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Zero length string passed to valid_ascii from",
          " in %s %s():%d",
          file,
          func,
          line);
        applog(3, tmp42, 0);
      }
      return ret;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Null string passed to valid_ascii from", " in %s %s():%d", file, func, line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
}

//----- (0005A7BC) --------------------------------------------------------
void __cdecl b58tobin(unsigned __int8 *b58bin, const unsigned __int8 *b58)
{
  unsigned __int8 *b58binb; // [sp+4h] [bp+4h]
  unsigned int bin32[7]; // [sp+Ch] [bp+Ch] BYREF
  uint64_t t; // [sp+28h] [bp+28h]
  int len; // [sp+30h] [bp+30h]
  int j; // [sp+34h] [bp+34h]
  int i; // [sp+38h] [bp+38h]
  unsigned int c; // [sp+3Ch] [bp+3Ch]

  memset(bin32, 0, sizeof(bin32));
  len = strlen((const char *)b58);
  for ( i = 0; i < len; ++i )
  {
    c = b58[i];
    c = b58tobin_tbl[c];
    for ( j = 6; j >= 0; --j )
    {
      t = 58LL * bin32[j] + c;
      c = BYTE4(t) & 0x3F;
      bin32[j] = t;
    }
  }
  *b58bin = bin32[0];
  b58binb = b58bin + 1;
  for ( i = 1; i <= 6; ++i )
  {
    *(_DWORD *)b58binb = HIBYTE(bin32[i]) | ((bin32[i] & 0xFF0000) >> 8) | ((bin32[i] & 0xFF00) << 8) | (bin32[i] << 24);
    b58binb += 4;
  }
}

//----- (0005A8DC) --------------------------------------------------------
void __cdecl address_to_pubkeyhash(unsigned __int8 *pkh, const unsigned __int8 *addr)
{
  unsigned __int8 b58bin[25]; // [sp+14h] [bp+Ch] BYREF

  memset(b58bin, 0, sizeof(b58bin));
  b58tobin(b58bin, addr);
  *pkh = 118;
  pkh[1] = -87;
  pkh[2] = 20;
  cg_memcpy(pkh + 3, &b58bin[1], 0x14u, "util.c", _func___10097, 966);
  pkh[23] = -120;
  pkh[24] = -84;
}

//----- (0005A95C) --------------------------------------------------------
int __cdecl ser_number(unsigned __int8 *s, int32_t val)
{
  int len; // [sp+Ch] [bp+Ch]

  if ( val > 127 )
  {
    if ( val > 16511 )
    {
      if ( val > 2113663 )
        len = 4;
      else
        len = 3;
    }
    else
    {
      len = 2;
    }
  }
  else
  {
    len = 1;
  }
  *(_DWORD *)(s + 1) = val;
  *s = len;
  return len + 1;
}

//----- (0005A9C4) --------------------------------------------------------
unsigned __int8 *__cdecl ser_string(unsigned __int8 *s, int *slen)
{
  unsigned __int8 *ret; // [sp+20h] [bp+18h]
  unsigned int len; // [sp+24h] [bp+1Ch]

  len = strlen((const char *)s);
  ret = (unsigned __int8 *)cgmalloc(len + 9, "util.c", _func___10110, 996);
  if ( len > 0xFC )
  {
    if ( len > 0xFFFF )
    {
      *ret = -2;
      *(_DWORD *)(ret + 1) = HIBYTE(len) | ((len & 0xFF0000) >> 8) | ((len & 0xFF00) << 8) | (len << 24);
      cg_memcpy(ret + 5, s, len, "util.c", _func___10110, 1019);
      *slen = len + 5;
    }
    else
    {
      *ret = -3;
      *(_WORD *)(ret + 1) = ((_WORD)len << 8) | BYTE1(len);
      cg_memcpy(ret + 3, s, len, "util.c", _func___10110, 1009);
      *slen = len + 3;
    }
  }
  else
  {
    *ret = len;
    cg_memcpy(ret + 1, s, len, "util.c", _func___10110, 1000);
    *slen = len + 1;
  }
  return ret;
}

//----- (0005AAFC) --------------------------------------------------------
bool __cdecl fulltest(const unsigned __int8 *hash, const unsigned __int8 *target)
{
  const char *v2; // r3
  unsigned __int8 hash_swap[32]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 target_swap[32]; // [sp+30h] [bp+28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+50h] [bp+48h] BYREF
  unsigned __int8 *target_str; // [sp+850h] [bp+848h]
  unsigned __int8 *hash_str; // [sp+854h] [bp+84Ch]
  unsigned int t32tmp; // [sp+858h] [bp+850h]
  unsigned int h32tmp; // [sp+85Ch] [bp+854h]
  unsigned int *target32; // [sp+860h] [bp+858h]
  unsigned int *hash32; // [sp+864h] [bp+85Ch]
  int i; // [sp+868h] [bp+860h]
  bool rc; // [sp+86Fh] [bp+867h]

  hash32 = (unsigned int *)hash;
  target32 = (unsigned int *)target;
  rc = 1;
  for ( i = 7; i >= 0; --i )
  {
    h32tmp = hash32[i];
    t32tmp = target32[i];
    if ( h32tmp > t32tmp )
    {
      rc = 0;
      break;
    }
    if ( h32tmp < t32tmp )
    {
      rc = 1;
      break;
    }
  }
  if ( opt_debug )
  {
    swab256_0(hash_swap, hash);
    swab256_0(target_swap, target);
    hash_str = bin2hex(hash_swap, 0x20u);
    target_str = bin2hex(target_swap, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      if ( rc )
        v2 = "YES (hash <= target)";
      else
        v2 = "no (false positive; hash > target)";
      snprintf(
        (char *)tmp42,
        0x800u,
        " Proof: %s\nTarget: %s\nTrgVal? %s",
        (const char *)hash_str,
        (const char *)target_str,
        v2);
      applog(7, tmp42, 0);
    }
    free(hash_str);
    free(target_str);
  }
  return rc;
}

//----- (0005AC78) --------------------------------------------------------
thread_q *tq_new()
{
  thread_q *tq; // [sp+Ch] [bp+4h]

  tq = (thread_q *)cgcalloc(1, 0x58u, "util.c", _func___10139, 1077);
  tq->q.next = &tq->q;
  tq->q.prev = &tq->q;
  pthread_mutex_init(&tq->mutex, 0);
  pthread_cond_init(&tq->cond, 0);
  return tq;
}

//----- (0005ACD0) --------------------------------------------------------
void __cdecl tq_free(thread_q *tq)
{
  tq_ent *iter; // [sp+8h] [bp+8h]
  tq_ent *ent; // [sp+Ch] [bp+Ch]

  if ( tq )
  {
    ent = (tq_ent *)&tq->q.next[-1].prev;
    iter = (tq_ent *)&tq->q.next->next[-1].prev;
    while ( &ent->q_node != (list_head *)tq )
    {
      list_del_0(&ent->q_node);
      free(ent);
      ent = iter;
      iter = (tq_ent *)&iter->q_node.next[-1].prev;
    }
    pthread_cond_destroy(&tq->cond);
    pthread_mutex_destroy(&tq->mutex);
    memset(tq, 0, sizeof(thread_q));
    free(tq);
  }
}

//----- (0005AD48) --------------------------------------------------------
void __cdecl tq_freezethaw(thread_q *tq, bool frozen)
{
  mutex_lock_4(&tq->mutex, "util.c", _func___10152, 1108);
  tq->frozen = frozen;
  pthread_cond_signal(&tq->cond);
  mutex_unlock_4(&tq->mutex, "util.c", _func___10152, 1111);
}

//----- (0005ADA8) --------------------------------------------------------
void __cdecl tq_freeze(thread_q *tq)
{
  tq_freezethaw(tq, 1);
}

//----- (0005ADC0) --------------------------------------------------------
void __cdecl tq_thaw(thread_q *tq)
{
  tq_freezethaw(tq, 0);
}

//----- (0005ADD8) --------------------------------------------------------
bool __cdecl tq_push(thread_q *tq, void *data)
{
  tq_ent *ent; // [sp+10h] [bp+8h]
  bool rc; // [sp+17h] [bp+Fh]

  rc = 1;
  ent = (tq_ent *)cgcalloc(1, 0xCu, "util.c", _func___10165, 1129);
  ent->data = data;
  ent->q_node.next = &ent->q_node;
  ent->q_node.prev = &ent->q_node;
  mutex_lock_4(&tq->mutex, "util.c", _func___10165, 1133);
  if ( !tq->frozen )
  {
    list_add_tail(&ent->q_node, &tq->q);
  }
  else
  {
    free(ent);
    rc = 0;
  }
  pthread_cond_signal(&tq->cond);
  mutex_unlock_4(&tq->mutex, "util.c", _func___10165, 1146);
  return rc;
}

//----- (0005AE98) --------------------------------------------------------
void *__cdecl tq_pop(thread_q *tq, const timespec *abstime)
{
  tq_ent *ent; // [sp+Ch] [bp+Ch]
  int rc; // [sp+10h] [bp+10h]
  void *rval; // [sp+14h] [bp+14h]

  rval = 0;
  mutex_lock_4(&tq->mutex, "util.c", _func___10173, 1158);
  if ( !list_empty(&tq->q)
    || (!abstime ? (rc = pthread_cond_wait(&tq->cond, &tq->mutex)) : (rc = pthread_cond_timedwait(
                                                                             &tq->cond,
                                                                             &tq->mutex,
                                                                             abstime)),
        !rc && !list_empty(&tq->q)) )
  {
    ent = (tq_ent *)&tq->q.next[-1].prev;
    rval = ent->data;
    list_del_0(tq->q.next);
    free(ent);
  }
  mutex_unlock_4(&tq->mutex, "util.c", _func___10173, 1184);
  return rval;
}

//----- (0005AF6C) --------------------------------------------------------
int __cdecl thr_info_create(thr_info *thr, pthread_attr_t *attr, void *(*start)(void *), void *arg)
{
  cgsem_init(&thr->sem, "util.c", _func___10183_0, 1191);
  return pthread_create(&thr->pth, attr, start, arg);
}

//----- (0005AFB4) --------------------------------------------------------
void __cdecl thr_info_cancel(thr_info *thr)
{
  if ( thr )
  {
    if ( thr->pth )
    {
      pthread_cancel(thr->pth);
      thr->pth = 0;
    }
    cgsem_destroy(&thr->sem);
  }
}

//----- (0005AFF0) --------------------------------------------------------
void __cdecl subtime(timeval *a, timeval *b)
{
  b->tv_sec = a->tv_sec - b->tv_sec;
  b->tv_usec = a->tv_usec - b->tv_usec;
  if ( b->tv_usec < 0 )
  {
    --b->tv_sec;
    b->tv_usec += 1000000;
  }
}

//----- (0005B044) --------------------------------------------------------
void __cdecl addtime(timeval *a, timeval *b)
{
  b->tv_sec += a->tv_sec;
  b->tv_usec += a->tv_usec;
  if ( b->tv_usec > 999999 )
  {
    ++b->tv_sec;
    b->tv_usec -= 1000000;
  }
}

//----- (0005B0A0) --------------------------------------------------------
bool __cdecl time_more(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec > b->tv_usec;
  else
    return a->tv_sec > b->tv_sec;
}

//----- (0005B0E8) --------------------------------------------------------
bool __cdecl time_less(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec < b->tv_usec;
  else
    return a->tv_sec < b->tv_sec;
}

//----- (0005B130) --------------------------------------------------------
void __cdecl copy_time(timeval *dest, const timeval *src)
{
  cg_memcpy(dest, src, 8u, "util.c", _func___10207, 1236);
}

//----- (0005B164) --------------------------------------------------------
void __cdecl timespec_to_val(timeval *val, const timespec *spec)
{
  val->tv_sec = spec->tv_sec;
  val->tv_usec = spec->tv_nsec / 1000;
}

//----- (0005B19C) --------------------------------------------------------
void __cdecl timeval_to_spec(timespec *spec, const timeval *val)
{
  spec->tv_sec = val->tv_sec;
  spec->tv_nsec = 1000 * val->tv_usec;
}

//----- (0005B1C8) --------------------------------------------------------
void __cdecl us_to_timeval(timeval *val, int64_t us)
{
  lldiv_t tvdiv; // [sp+18h] [bp+10h] BYREF

  lldiv(&tvdiv, &tvdiv, us, HIDWORD(us), &nonce_num[6][85][45], 0, us, HIDWORD(us));
  val->tv_sec = tvdiv.quot;
  val->tv_usec = tvdiv.rem;
}
// A388: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005B20C) --------------------------------------------------------
void __cdecl us_to_timespec(timespec *spec, int64_t us)
{
  lldiv_t tvdiv; // [sp+18h] [bp+10h] BYREF

  lldiv(&tvdiv, &tvdiv, us, HIDWORD(us), &nonce_num[6][85][45], 0, us, HIDWORD(us));
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = 1000 * LODWORD(tvdiv.rem);
}
// A388: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005B25C) --------------------------------------------------------
void __cdecl ms_to_timespec(timespec *spec, int64_t ms)
{
  lldiv_t tvdiv; // [sp+18h] [bp+10h] BYREF

  lldiv(&tvdiv, &tvdiv, ms, HIDWORD(ms), 1000, 0, ms, HIDWORD(ms));
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = (_DWORD)&nonce_num[6][85][45] * LODWORD(tvdiv.rem);
}
// A388: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005B2A8) --------------------------------------------------------
void __cdecl ms_to_timeval(timeval *val, int64_t ms)
{
  lldiv_t tvdiv; // [sp+18h] [bp+10h] BYREF

  lldiv(&tvdiv, &tvdiv, ms, HIDWORD(ms), 1000, 0, ms, HIDWORD(ms));
  val->tv_sec = tvdiv.quot;
  val->tv_usec = 1000 * LODWORD(tvdiv.rem);
}
// A388: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005B2F4) --------------------------------------------------------
void __cdecl spec_nscheck(timespec *ts)
{
  while ( ts->tv_nsec > 999999999 )
  {
    ts->tv_nsec -= 1000000000;
    ++ts->tv_sec;
  }
  while ( ts->tv_nsec < 0 )
  {
    ts->tv_nsec += 1000000000;
    --ts->tv_sec;
  }
}

//----- (0005B35C) --------------------------------------------------------
void __cdecl timeraddspec(timespec *a, const timespec *b)
{
  a->tv_sec += b->tv_sec;
  a->tv_nsec += b->tv_nsec;
  spec_nscheck(a);
}

//----- (0005B390) --------------------------------------------------------
int __cdecl timespec_to_ms(timespec *ts)
{
  return 1000 * ts->tv_sec + ts->tv_nsec / 1000000;
}

//----- (0005B3C8) --------------------------------------------------------
void __cdecl timersubspec(timespec *a, const timespec *b)
{
  a->tv_sec -= b->tv_sec;
  a->tv_nsec -= b->tv_nsec;
  spec_nscheck(a);
}

//----- (0005B3FC) --------------------------------------------------------
unsigned __int8 *__cdecl Strcasestr(unsigned __int8 *haystack, const unsigned __int8 *needle)
{
  unsigned __int8 *v3; // r4
  unsigned __int8 *v4; // r4
  const unsigned __int8 *needlea; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 *haystacka; // [sp+4h] [bp+4h]
  int ofs; // [sp+Ch] [bp+Ch]
  unsigned __int8 *ret; // [sp+10h] [bp+10h]
  unsigned __int8 *lowneedle; // [sp+14h] [bp+14h]
  unsigned __int8 *lowhay; // [sp+18h] [bp+18h]
  int nlen; // [sp+1Ch] [bp+1Ch]
  int hlen; // [sp+20h] [bp+20h]
  int i; // [sp+24h] [bp+24h]

  haystacka = haystack;
  needlea = needle;
  if ( !haystack || !needlea )
    return 0;
  hlen = strlen((const char *)haystacka);
  nlen = strlen((const char *)needlea);
  if ( !hlen || !nlen )
    return 0;
  lowhay = (unsigned __int8 *)&needlea;
  lowneedle = (unsigned __int8 *)&needlea;
  for ( i = 0; i < hlen; ++i )
  {
    v3 = &lowhay[i];
    *v3 = tolower(haystacka[i]);
  }
  for ( i = 0; i < nlen; ++i )
  {
    v4 = &lowneedle[i];
    *v4 = tolower(needlea[i]);
  }
  ret = (unsigned __int8 *)strstr((const char *)lowhay, (const char *)lowneedle);
  if ( !ret )
    return 0;
  ofs = ret - lowhay;
  return &haystacka[ret - lowhay];
}

//----- (0005B4F4) --------------------------------------------------------
unsigned __int8 *__cdecl Strsep(unsigned __int8 **stringp, const unsigned __int8 *delim)
{
  char *v2; // r3
  unsigned __int8 *ret; // [sp+Ch] [bp+Ch]

  ret = *stringp;
  if ( *stringp )
    v2 = strpbrk((const char *)ret, (const char *)delim);
  else
    v2 = 0;
  if ( v2 )
  {
    *v2 = 0;
    *stringp = (unsigned __int8 *)(v2 + 1);
  }
  else
  {
    *stringp = 0;
  }
  return ret;
}

//----- (0005B544) --------------------------------------------------------
void __cdecl cgtime(timeval *tv)
{
  gettimeofday(tv, 0);
}

//----- (0005B55C) --------------------------------------------------------
int __cdecl cgtimer_to_ms(cgtimer_t *cgt)
{
  return timespec_to_ms(cgt);
}

//----- (0005B578) --------------------------------------------------------
void __cdecl cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)
{
  res->tv_sec = a->tv_sec - b->tv_sec;
  res->tv_nsec = a->tv_nsec - b->tv_nsec;
  if ( res->tv_nsec < 0 )
  {
    res->tv_nsec += 1000000000;
    --res->tv_sec;
  }
}

//----- (0005B5D0) --------------------------------------------------------
void __cdecl cgtimer_time(cgtimer_t *ts_start)
{
  clock_gettime(1, ts_start);
}

//----- (0005B5E8) --------------------------------------------------------
void __cdecl nanosleep_abstime(timespec *ts_end)
{
  while ( clock_nanosleep(1, 1, ts_end, 0) == 4 )
    ;
}

//----- (0005B60C) --------------------------------------------------------
void __cdecl cgsleep_ms_r(cgtimer_t *ts_start, int ms)
{
  timespec ts_end; // [sp+8h] [bp+8h] BYREF

  ms_to_timespec(&ts_end, ms);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (0005B644) --------------------------------------------------------
void __cdecl cgsleep_us_r(cgtimer_t *ts_start, int64_t us)
{
  timespec ts_end; // [sp+10h] [bp+10h] BYREF

  us_to_timespec(&ts_end, us);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (0005B67C) --------------------------------------------------------
void __cdecl cgsleep_ms(int ms)
{
  cgtimer_t ts_start; // [sp+8h] [bp+8h] BYREF

  cgtimer_time(&ts_start);
  cgsleep_ms_r(&ts_start, ms);
}

//----- (0005B6A4) --------------------------------------------------------
void __cdecl cgsleep_us(int64_t us)
{
  cgtimer_t ts_start; // [sp+8h] [bp+8h] BYREF

  cgtimer_time(&ts_start);
  cgsleep_us_r(&ts_start, us);
}

//----- (0005B6D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl us_tdiff(timeval *end, timeval *start)
{
  _DWORD *v2; // r1
  __suseconds_t tv_usec; // r1
  double result; // r0

  if ( end->tv_sec - *v2 <= 60 )
    tv_usec = end->tv_usec;
  LODWORD(result) = end;
  return result;
}
// 5B6D0: variables would overlap: r0.4 and r0.8
// 5B6D0: bad return variable

//----- (0005B730) --------------------------------------------------------
int __cdecl ms_tdiff(timeval *end, timeval *start)
{
  if ( end->tv_sec - start->tv_sec <= 3600 )
    return 1000 * (end->tv_sec - start->tv_sec) + (end->tv_usec - start->tv_usec) / 1000;
  else
    return (int)&scanfreq_info.asic_core_nonce_num[6][100][195];
}

//----- (0005B790) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl tdiff(timeval *end, timeval *start)
{
  double result; // r0

  LODWORD(result) = end;
  return result;
}
// 5B790: variables would overlap: r0.4 and r0.8
// 5B790: bad return variable

//----- (0005B7E0) --------------------------------------------------------
bool __cdecl extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port)
{
  unsigned __int8 port[6]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 url_address[256]; // [sp+20h] [bp+18h] BYREF
  unsigned __int8 *slash; // [sp+120h] [bp+118h]
  unsigned __int8 *ipv6_end; // [sp+124h] [bp+11Ch]
  unsigned __int8 *ipv6_begin; // [sp+128h] [bp+120h]
  int port_len; // [sp+12Ch] [bp+124h]
  int url_len; // [sp+130h] [bp+128h]
  unsigned __int8 *port_start; // [sp+134h] [bp+12Ch]
  unsigned __int8 *url_end; // [sp+138h] [bp+130h]
  unsigned __int8 *url_begin; // [sp+13Ch] [bp+134h]

  port_start = 0;
  port_len = 0;
  *sockaddr_url = url;
  url_begin = (unsigned __int8 *)strstr((const char *)url, "//");
  if ( url_begin )
    url_begin += 2;
  else
    url_begin = url;
  ipv6_begin = (unsigned __int8 *)strchr((const char *)url_begin, 91);
  ipv6_end = (unsigned __int8 *)strchr((const char *)url_begin, 93);
  if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin )
    url_end = (unsigned __int8 *)strchr((const char *)ipv6_end, 58);
  else
    url_end = (unsigned __int8 *)strchr((const char *)url_begin, 58);
  if ( url_end )
  {
    url_len = url_end - url_begin;
    port_len = strlen((const char *)url_begin) - (url_end - url_begin) - 1;
    if ( port_len <= 0 )
      return 0;
    port_start = url_end + 1;
  }
  else
  {
    url_len = strlen((const char *)url_begin);
  }
  if ( url_len <= 0 )
    return 0;
  if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin )
  {
    url_len -= 2;
    ++url_begin;
  }
  snprintf((char *)url_address, 0xFEu, "%.*s", url_len, (const char *)url_begin);
  if ( port_len )
  {
    snprintf((char *)port, 6u, "%.*s", port_len, (const char *)port_start);
    slash = (unsigned __int8 *)strpbrk((const char *)port, "/#");
    if ( slash )
      *slash = 0;
  }
  else
  {
    strcpy((char *)port, "80");
  }
  *sockaddr_port = (unsigned __int8 *)strdup((const char *)port);
  *sockaddr_url = (unsigned __int8 *)strdup((const char *)url_address);
  return 1;
}

//----- (0005B9E4) --------------------------------------------------------
send_ret __cdecl _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  signed int lenb; // [sp+Ch] [bp+4h]
  fd_set wd; // [sp+1Ch] [bp+14h] BYREF
  timeval timeout; // [sp+81Ch] [bp+814h] BYREF
  fd_set *__arr; // [sp+824h] [bp+81Ch]
  int sock; // [sp+828h] [bp+820h]
  unsigned int __i; // [sp+82Ch] [bp+824h]
  ssize_t sent; // [sp+830h] [bp+828h]
  ssize_t ssent; // [sp+834h] [bp+82Ch]

  sock = pool->sock;
  ssent = 0;
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)&wd, 0x800u, "SEND: %s", (const char *)s);
    applog(7, (const unsigned __int8 *)&wd, 0);
  }
  strcat((char *)s, "\n");
  for ( lenb = len + 1; lenb > 0; lenb -= sent )
  {
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    while ( 1 )
    {
      __arr = &wd;
      for ( __i = 0; __i <= 0x1F; ++__i )
        __arr->fds_bits[__i] = 0;
      wd.fds_bits[sock / 32] |= 1 << (sock % 32);
      if ( select(sock + 1, 0, &wd, 0, &timeout) > 0 )
        break;
      if ( !interrupted() )
        return 1;
    }
    sent = send(pool->sock, &s[ssent], lenb, 0x4000);
    if ( sent < 0 )
    {
      if ( (unsigned __int8)sock_blocks_0() != 1 )
        return 2;
      sent = 0;
    }
    ssent += sent;
  }
  ++pool->cgminer_pool_stats.times_sent;
  pool->cgminer_pool_stats.bytes_sent += ssent;
  pool->cgminer_pool_stats.net_bytes_sent += ssent;
  return 0;
}

//----- (0005BC50) --------------------------------------------------------
bool __cdecl stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+14h] BYREF
  send_ret ret; // [sp+814h] [bp+814h]

  ret = SEND_INACTIVE;
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "SEND: %s", (const char *)s);
    applog(7, tmp42, 0);
  }
  mutex_lock_4(&pool->stratum_lock, "util.c", _func___10376, 1688);
  if ( pool->stratum_active )
    ret = _stratum_send(pool, s, len);
  mutex_unlock_4(&pool->stratum_lock, "util.c", _func___10376, 1694);
  switch ( ret )
  {
    case SEND_SENDFAIL:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Failed to send in stratum_send");
        applog(7, tmp42, 0);
      }
      goto LABEL_17;
    case SEND_INACTIVE:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Stratum send failed due to no pool stratum_active");
        applog(7, tmp42, 0);
      }
      break;
    case SEND_SELECTFAIL:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Write select failed on pool %d sock", pool->pool_no);
        applog(7, tmp42, 0);
      }
LABEL_17:
      suspend_stratum(pool);
      break;
  }
  return ret == SEND_OK;
}

//----- (0005BEC8) --------------------------------------------------------
bool __cdecl socket_full(pool *pool, int wait)
{
  __time_t waita; // [sp+8h] [bp+0h]
  fd_set rd; // [sp+14h] [bp+Ch] BYREF
  timeval timeout; // [sp+94h] [bp+8Ch] BYREF
  fd_set *__arr; // [sp+9Ch] [bp+94h]
  int sock; // [sp+A0h] [bp+98h]
  unsigned int __i; // [sp+A4h] [bp+9Ch]

  waita = wait;
  sock = pool->sock;
  if ( wait < 0 )
    waita = 0;
  __arr = &rd;
  for ( __i = 0; __i <= 0x1F; ++__i )
    __arr->fds_bits[__i] = 0;
  rd.fds_bits[sock / 32] |= 1 << (sock % 32);
  timeout.tv_usec = 0;
  timeout.tv_sec = waita;
  return select(sock + 1, &rd, 0, 0, &timeout) > 0;
}

//----- (0005BF98) --------------------------------------------------------
bool __cdecl sock_full(pool *pool)
{
  return *pool->sockbuf || socket_full(pool, 0);
}

//----- (0005BFC4) --------------------------------------------------------
void __cdecl clear_sockbuf(pool *pool)
{
  if ( pool->sockbuf )
    *pool->sockbuf = 0;
}

//----- (0005BFEC) --------------------------------------------------------
void __cdecl clear_sock(pool *pool)
{
  int n; // [sp+Ch] [bp+Ch]

  mutex_lock_4(&pool->stratum_lock, "util.c", _func___10408, 1765);
  do
  {
    if ( pool->sock )
      n = recv(pool->sock, pool->sockbuf, 0x1FFCu, 0);
    else
      n = 0;
  }
  while ( n > 0 );
  mutex_unlock_4(&pool->stratum_lock, "util.c", _func___10408, 1774);
  clear_sockbuf(pool);
}

//----- (0005C074) --------------------------------------------------------
void __cdecl recalloc(
        void **ptr,
        size_t old,
        size_t news,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  if ( news != old )
  {
    *ptr = cgrealloc(*ptr, news, file, func, line);
    if ( news > old )
      memset((char *)*ptr + old, 0, news - old);
  }
}

//----- (0005C0D0) --------------------------------------------------------
void __cdecl recalloc_sock(pool *pool, size_t len)
{
  size_t news; // [sp+10h] [bp+8h]
  size_t old; // [sp+14h] [bp+Ch]

  old = strlen((const char *)pool->sockbuf);
  if ( pool->sockbuf_size <= old + len + 1 )
  {
    news = ((old + len + 1) & 0xFFFFE000) + 0x2000;
    pool->sockbuf = (unsigned __int8 *)cgrealloc(pool->sockbuf, news, "util.c", _func___10425, 1803);
    memset(&pool->sockbuf[old], 0, news - old);
    pool->sockbuf_size = news;
  }
}

//----- (0005C168) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned __int8 *__cdecl recv_line(pool *pool)
{
  double v1; // d0
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  _BYTE tmp42_0[8192]; // [sp+80Ch] [bp+80Ch] OVERLAPPED BYREF
  timeval now; // [sp+280Ch] [bp+280Ch] BYREF
  timeval rstart; // [sp+2814h] [bp+2814h] BYREF
  ssize_t len; // [sp+281Ch] [bp+281Ch]
  unsigned __int8 *tok; // [sp+2820h] [bp+2820h]
  ssize_t buflen; // [sp+2824h] [bp+2824h]
  size_t slen; // [sp+2828h] [bp+2828h]
  ssize_t n; // [sp+282Ch] [bp+282Ch]
  int waited; // [sp+2830h] [bp+2830h]
  unsigned __int8 *sret; // [sp+2834h] [bp+2834h]

  sret = 0;
  waited = 0;
  if ( strchr((const char *)pool->sockbuf, 10) )
    goto LABEL_27;
  cgtime(&rstart);
  if ( !socket_full(pool, 60) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42_0, "Timed out waiting for data on socket_full");
      applog(7, tmp42_0, 0);
    }
    goto out;
  }
  while ( 1 )
  {
    memset(tmp42_0, 0, sizeof(tmp42_0));
    n = recv(pool->sock, tmp42_0, 0x1FFCu, 0);
    if ( !n )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Socket closed waiting in recv_line");
        applog(7, tmp42, 0);
      }
      goto LABEL_14;
    }
    cgtime(&now);
    tdiff(&now, &rstart);
    waited = (int)v1;
    if ( n < 0 )
      break;
    slen = strlen(tmp42_0);
    recalloc_sock(pool, slen);
    strcat((char *)pool->sockbuf, tmp42_0);
LABEL_25:
    if ( waited > 59 || strchr((const char *)pool->sockbuf, 10) )
      goto LABEL_27;
  }
  if ( (unsigned __int8)sock_blocks_0() == 1 && socket_full(pool, 60 - waited) )
    goto LABEL_25;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Failed to recv sock in recv_line");
    applog(7, tmp42, 0);
  }
LABEL_14:
  suspend_stratum(pool);
LABEL_27:
  buflen = strlen((const char *)pool->sockbuf);
  tok = (unsigned __int8 *)strtok((char *)pool->sockbuf, "\n");
  if ( tok )
  {
    sret = (unsigned __int8 *)strdup((const char *)tok);
    len = strlen((const char *)sret);
    if ( len + 1 >= buflen )
      *pool->sockbuf = 0;
    else
      memmove(pool->sockbuf, &pool->sockbuf[len + 1], buflen - len + 1);
    ++pool->cgminer_pool_stats.times_received;
    pool->cgminer_pool_stats.bytes_received += len;
    pool->cgminer_pool_stats.net_bytes_received += len;
  }
  else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42_0, "Failed to parse a \\n terminated string in recv_line");
    applog(7, tmp42_0, 0);
  }
out:
  if ( sret )
  {
    if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42_0, 0x800u, "RECVD: %s", (const char *)sret);
      applog(7, tmp42_0, 0);
    }
  }
  else
  {
    clear_sock(pool);
  }
  return sret;
}
// 5C168: variables would overlap: ^80C.8192 and stkvar "tmp42_0" ^80C.2048(has user info)

//----- (0005C728) --------------------------------------------------------
unsigned __int8 *__cdecl _json_array_string(json_t_0 *val, unsigned int entry)
{
  const json_t_0 *arr_entry; // [sp+Ch] [bp+Ch]

  if ( val && val->type == JSON_NULL )
    return 0;
  if ( !val || val->type != JSON_ARRAY )
    return 0;
  if ( json_array_size(val) < entry )
    return 0;
  arr_entry = json_array_get(val, entry);
  if ( arr_entry && arr_entry->type == JSON_STRING )
    return (unsigned __int8 *)json_string_value(arr_entry);
  else
    return 0;
}

//----- (0005C798) --------------------------------------------------------
unsigned __int8 *__cdecl json_array_string(json_t_0 *val, unsigned int entry)
{
  unsigned __int8 *buf; // [sp+Ch] [bp+Ch]

  buf = _json_array_string(val, entry);
  if ( buf )
    return (unsigned __int8 *)strdup((const char *)buf);
  else
    return 0;
}

//----- (0005C7C8) --------------------------------------------------------
bool __cdecl parse_notify(pool *pool, json_t_0 *val)
{
  bool v2; // r3
  unsigned __int8 **v3; // r4
  unsigned __int8 *v4; // r0
  const char *v5; // r3
  json_t_0 *vala; // [sp+18h] [bp+0h] BYREF
  pool *poola; // [sp+1Ch] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 header[228]; // [sp+820h] [bp+808h] BYREF
  unsigned __int8 *cb; // [sp+904h] [bp+8ECh]
  unsigned __int8 *merkle; // [sp+908h] [bp+8F0h]
  size_t alloc_len; // [sp+90Ch] [bp+8F4h]
  size_t cb2_len; // [sp+910h] [bp+8F8h]
  size_t cb1_len; // [sp+914h] [bp+8FCh]
  bool clean; // [sp+91Bh] [bp+903h]
  unsigned __int8 *ntime; // [sp+91Ch] [bp+904h]
  unsigned __int8 *nbit; // [sp+920h] [bp+908h]
  unsigned __int8 *bbversion; // [sp+924h] [bp+90Ch]
  unsigned __int8 *coinbase2; // [sp+928h] [bp+910h]
  unsigned __int8 *coinbase1; // [sp+92Ch] [bp+914h]
  unsigned __int8 *prev_hash; // [sp+930h] [bp+918h]
  unsigned __int8 *job_id; // [sp+934h] [bp+91Ch]
  int merkles; // [sp+938h] [bp+920h]
  json_t_0 *arr; // [sp+93Ch] [bp+924h]
  unsigned __int8 *cb2; // [sp+940h] [bp+928h]
  unsigned __int8 *cb1; // [sp+944h] [bp+92Ch]
  int i; // [sp+948h] [bp+930h]
  bool ret; // [sp+94Fh] [bp+937h]

  poola = pool;
  vala = val;
  cb1 = 0;
  cb2 = 0;
  ret = 0;
  arr = json_array_get(val, 4u);
  if ( arr && arr->type == JSON_ARRAY )
  {
    merkles = json_array_size(arr);
    job_id = json_array_string(vala, 0);
    prev_hash = _json_array_string(vala, 1u);
    coinbase1 = json_array_string(vala, 2u);
    coinbase2 = json_array_string(vala, 3u);
    bbversion = _json_array_string(vala, 5u);
    nbit = _json_array_string(vala, 6u);
    ntime = _json_array_string(vala, 7u);
    v2 = json_array_get(vala, 8u) && json_array_get(vala, 8u)->type == JSON_TRUE;
    clean = v2;
    if ( !valid_ascii(job_id, "util.c", _func___10481, 1947)
      || !valid_hex(prev_hash, "util.c", _func___10481, 1947)
      || !valid_hex(coinbase1, "util.c", _func___10481, 1947)
      || !valid_hex(coinbase2, "util.c", _func___10481, 1948)
      || !valid_hex(bbversion, "util.c", _func___10481, 1948)
      || !valid_hex(nbit, "util.c", _func___10481, 1948)
      || !valid_hex(ntime, "util.c", _func___10481, 1949) )
    {
      free(job_id);
      free(coinbase1);
      free(coinbase2);
    }
    else
    {
      cg_wlock_3(&poola->data_lock, "util.c", _func___10481, 1958);
      free(poola->swork.job_id);
      poola->swork.job_id = job_id;
      snprintf((char *)poola->prev_hash, 0x41u, "%s", (const char *)prev_hash);
      cb1_len = strlen((const char *)coinbase1) >> 1;
      cb2_len = strlen((const char *)coinbase2) >> 1;
      snprintf((char *)poola->bbversion, 9u, "%s", (const char *)bbversion);
      snprintf((char *)poola->nbit, 9u, "%s", (const char *)nbit);
      snprintf((char *)poola->ntime, 9u, "%s", (const char *)ntime);
      poola->swork.clean = clean;
      if ( poola->next_diff > 0.0 )
        poola->sdiff = poola->next_diff;
      poola->coinbase_len = poola->n1_len + cb1_len + poola->n2size + cb2_len;
      alloc_len = poola->coinbase_len;
      poola->nonce2_offset = poola->n1_len + cb1_len;
      for ( i = 0; poola->merkles > i; ++i )
        free(poola->swork.merkle_bin[i]);
      if ( merkles )
      {
        poola->swork.merkle_bin = (unsigned __int8 **)cgrealloc(
                                                        poola->swork.merkle_bin,
                                                        4 * merkles + 1,
                                                        "util.c",
                                                        _func___10481,
                                                        1979);
        for ( i = 0; i < merkles; ++i )
        {
          merkle = json_array_string(arr, i);
          v3 = &poola->swork.merkle_bin[i];
          *v3 = (unsigned __int8 *)cgmalloc(0x20u, "util.c", _func___10481, 1984);
          if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "merkle %d: %s", i, (const char *)merkle);
            applog(7, tmp42, 0);
          }
          ret = hex2bin(poola->swork.merkle_bin[i], merkle, 0x20u);
          free(merkle);
          if ( !ret )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              strcpy((char *)tmp42, "Failed to convert merkle to merkle_bin in parse_notify");
              applog(3, tmp42, 0);
            }
            goto out_unlock;
          }
        }
      }
      poola->merkles = merkles;
      if ( poola->merkles <= 1 )
        ++poola->bad_work;
      if ( clean )
        poola->nonce2 = 0LL;
      snprintf(
        (char *)header,
        0xE1u,
        "%s%s%s%s%s%s%s",
        (const char *)poola->bbversion,
        (const char *)poola->prev_hash,
        (const char *)blank_merkle,
        (const char *)poola->ntime,
        (const char *)poola->nbit,
        "00000000",
        (const char *)workpadding);
      ret = hex2bin(poola->header_bin, header, 0x70u);
      if ( !ret )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "Failed to convert header to header_bin in parse_notify");
          applog(3, tmp42, 0);
        }
      }
      else
      {
        cb1 = (unsigned __int8 *)&vala;
        ret = hex2bin((unsigned __int8 *)&vala, coinbase1, cb1_len);
        if ( !ret )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            strcpy((char *)tmp42, "Failed to convert cb1 to cb1_bin in parse_notify");
            applog(3, tmp42, 0);
          }
        }
        else
        {
          cb2 = (unsigned __int8 *)&vala;
          ret = hex2bin((unsigned __int8 *)&vala, coinbase2, cb2_len);
          if ( !ret )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              strcpy((char *)tmp42, "Failed to convert cb2 to cb2_bin in parse_notify");
              applog(3, tmp42, 0);
            }
          }
          else
          {
            free(poola->coinbase);
            v4 = (unsigned __int8 *)cgcalloc(alloc_len, 1u, "util.c", _func___10481, 2041);
            poola->coinbase = v4;
            cg_memcpy(poola->coinbase, cb1, cb1_len, "util.c", _func___10481, 2042);
            if ( poola->n1_len )
              cg_memcpy(&poola->coinbase[cb1_len], poola->nonce1bin, poola->n1_len, "util.c", _func___10481, 2044);
            cg_memcpy(
              &poola->coinbase[poola->n1_len + cb1_len + poola->n2size],
              cb2,
              cb2_len,
              "util.c",
              _func___10481,
              2045);
            if ( opt_debug )
            {
              cb = bin2hex(poola->coinbase, poola->coinbase_len);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "Pool %d coinbase %s", poola->pool_no, (const char *)cb);
                applog(7, tmp42, 0);
              }
              free(cb);
            }
          }
        }
      }
out_unlock:
      cg_wunlock_3(&poola->data_lock, "util.c", _func___10481, 2054);
      if ( opt_protocol )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "job_id: %s", (const char *)job_id);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "prev_hash: %s", (const char *)prev_hash);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "coinbase1: %s", (const char *)coinbase1);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "coinbase2: %s", (const char *)coinbase2);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "bbversion: %s", (const char *)bbversion);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "nbit: %s", (const char *)nbit);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "ntime: %s", (const char *)ntime);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          if ( clean )
            v5 = "yes";
          else
            v5 = "no";
          snprintf((char *)tmp42, 0x800u, "clean: %s", v5);
          applog(7, tmp42, 0);
        }
      }
      free(coinbase1);
      free(coinbase2);
      ++poola->getwork_requested;
      ++total_getworks;
      if ( current_pool() == poola )
        opt_work_update = 1;
    }
  }
  return ret;
}

//----- (0005D500) --------------------------------------------------------
bool __cdecl parse_version(pool *pool, json_t_0 *val)
{
  json_t_0 *v2; // r0
  size_t v3; // r0
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; ; ++i )
  {
    v3 = json_array_size(val);
    if ( i >= v3 )
      break;
    v2 = json_array_get(val, i);
    pool->version[i] = json_integer_value(v2);
  }
  return v3;
}

//----- (0005D550) --------------------------------------------------------
bool __cdecl parse_diff(pool *pool, json_t_0 *val)
{
  double v2; // d0
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int idiff; // [sp+814h] [bp+80Ch]
  double diff; // [sp+818h] [bp+810h]
  double old_diff; // [sp+820h] [bp+818h]

  v3 = json_array_get(val, 0);
  json_number_value(v3);
  diff = v2;
  if ( v2 == 0.0 )
    return 0;
  cg_wlock_3(&pool->data_lock, "util.c", _func___10519, 2096);
  if ( pool->next_diff <= 0.0 )
  {
    old_diff = pool->sdiff;
    pool->sdiff = diff;
    pool->next_diff = pool->sdiff;
  }
  else
  {
    old_diff = pool->next_diff;
    pool->next_diff = diff;
  }
  cg_wunlock_3(&pool->data_lock, "util.c", _func___10519, 2109);
  if ( old_diff == diff )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d difficulty set to %f", pool->pool_no, diff);
      applog(7, tmp42, 0);
    }
  }
  else
  {
    idiff = (int)diff;
    if ( (double)(int)diff == diff )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %d", pool->pool_no, idiff);
        applog(5, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %.1f", pool->pool_no, diff);
      applog(5, tmp42, 0);
    }
  }
  return 1;
}
// 5D576: variable 'v2' is possibly undefined

//----- (0005D7E0) --------------------------------------------------------
bool __cdecl parse_extranonce(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  int n2size; // [sp+2810h] [bp+2808h]
  unsigned __int8 *nonce1; // [sp+2814h] [bp+280Ch]

  nonce1 = json_array_string(val, 0);
  if ( !valid_hex(nonce1, "util.c", _func___10531, 2140) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Failed to get valid nonce1 in parse_extranonce");
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    v3 = json_array_get(val, 1u);
    n2size = json_integer_value(v3);
    if ( n2size )
    {
      cg_wlock_3(&pool->data_lock, "util.c", _func___10531, 2152);
      free(pool->nonce1);
      pool->nonce1 = nonce1;
      pool->n1_len = strlen((const char *)nonce1) >> 1;
      free(pool->nonce1bin);
      pool->nonce1bin = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", _func___10531, 2157);
      if ( !pool->nonce1bin )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to calloc pool->nonce1bin in %s %s():%d",
          "util.c",
          (const char *)_func___10531,
          2159);
        applog(3, tmp42, 1);
        quit(1);
      }
      hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
      pool->n2size = n2size;
      cg_wunlock_3(&pool->data_lock, "util.c", _func___10531, 2162);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d extranonce change requested", pool->pool_no);
        applog(5, tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        strcpy((char *)tmp42, "Failed to get valid n2size in parse_extranonce");
        applog(6, tmp42, 0);
      }
      free(nonce1);
      return 0;
    }
  }
}

//----- (0005DB30) --------------------------------------------------------
void __cdecl _suspend_stratum(pool *pool)
{
  clear_sockbuf(pool);
  pool->stratum_notify = 0;
  pool->stratum_active = pool->stratum_notify;
  if ( pool->sock )
    close(pool->sock);
  pool->sock = 0;
}

//----- (0005DB78) --------------------------------------------------------
bool __cdecl parse_reconnect(pool *pool, json_t_0 *val)
{
  json_t_0 *v2; // r0
  json_t_0 *v4; // r0
  json_t_0 *v5; // r0
  char v7[264]; // [sp+8h] [bp-108h] BYREF
  json_t_0 *vala; // [sp+110h] [bp+0h]
  pool *poola; // [sp+114h] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+118h] [bp+8h] BYREF
  unsigned __int8 address[256]; // [sp+918h] [bp+808h] BYREF
  unsigned __int8 *stratum_port; // [sp+A18h] [bp+908h] BYREF
  unsigned __int8 *sockaddr_url; // [sp+A1Ch] [bp+90Ch] BYREF
  unsigned __int8 *tmp; // [sp+A20h] [bp+910h]
  int port_no; // [sp+A24h] [bp+914h]
  unsigned __int8 *dot_reconnect; // [sp+A28h] [bp+918h]
  unsigned __int8 *dot_pool; // [sp+A2Ch] [bp+91Ch]
  unsigned __int8 *port; // [sp+A30h] [bp+920h]
  unsigned __int8 *url; // [sp+A34h] [bp+924h]

  poola = pool;
  vala = val;
  memset(address, 0, 0xFFu);
  v2 = json_array_get(vala, 0);
  url = (unsigned __int8 *)json_string_value(v2);
  if ( !url )
  {
    url = poola->sockaddr_url;
LABEL_21:
    v4 = json_array_get(vala, 1u);
    port_no = json_integer_value(v4);
    if ( port_no )
    {
      port = (unsigned __int8 *)v7;
      sprintf(v7, "%d", port_no);
    }
    else
    {
      v5 = json_array_get(vala, 1u);
      port = (unsigned __int8 *)json_string_value(v5);
      if ( !port )
        port = poola->stratum_port;
    }
    snprintf((char *)address, 0xFEu, "%s:%s", (const char *)url, (const char *)port);
    if ( !extract_sockaddr(address, &sockaddr_url, &stratum_port) )
      return 0;
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Stratum reconnect requested from pool %d to %s",
        poola->pool_no,
        (const char *)address);
      applog(4, tmp42, 0);
    }
    clear_pool_work(poola);
    mutex_lock_4(&poola->stratum_lock, "util.c", _func___10556, 2232);
    _suspend_stratum(poola);
    tmp = poola->sockaddr_url;
    poola->sockaddr_url = sockaddr_url;
    poola->stratum_url = poola->sockaddr_url;
    free(tmp);
    tmp = poola->stratum_port;
    poola->stratum_port = stratum_port;
    free(tmp);
    mutex_unlock_4(&poola->stratum_lock, "util.c", _func___10556, 2241);
    return restart_stratum(poola);
  }
  dot_pool = (unsigned __int8 *)strchr((const char *)poola->sockaddr_url, 46);
  if ( dot_pool )
  {
    dot_reconnect = (unsigned __int8 *)strchr((const char *)url, 46);
    if ( dot_reconnect )
    {
      if ( !strcmp((const char *)dot_pool, (const char *)dot_reconnect) )
        goto LABEL_21;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Denied stratum reconnect request to non-matching domain url '%s'",
          (const char *)poola->sockaddr_url);
        applog(3, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Denied stratum reconnect request to url without domain '%s'",
          (const char *)url);
        applog(3, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Denied stratum reconnect request for pool without domain '%s'",
        (const char *)poola->sockaddr_url);
      applog(3, tmp42, 0);
    }
    return 0;
  }
}

//----- (0005DEDC) --------------------------------------------------------
bool __cdecl send_version(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  size_t v4; // r0
  unsigned __int8 s[8192]; // [sp+8h] [bp+8h] BYREF
  int id; // [sp+2008h] [bp+2008h]

  if ( !json_object_get(val, "id") )
    return 0;
  v3 = json_object_get(val, "id");
  id = json_integer_value(v3);
  sprintf((char *)s, "{\"id\": %d, \"result\": \"bmminer/2.0.0\", \"error\": null}", id);
  v4 = strlen((const char *)s);
  return stratum_send(pool, s, v4);
}

//----- (0005DFB8) --------------------------------------------------------
bool __cdecl send_pong(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  size_t v4; // r0
  unsigned __int8 s[8192]; // [sp+8h] [bp+8h] BYREF
  int id; // [sp+2008h] [bp+2008h]

  if ( !json_object_get(val, "id") )
    return 0;
  v3 = json_object_get(val, "id");
  id = json_integer_value(v3);
  sprintf((char *)s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", id);
  v4 = strlen((const char *)s);
  return stratum_send(pool, s, v4);
}

//----- (0005E094) --------------------------------------------------------
bool __cdecl show_message(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 *msg; // [sp+814h] [bp+80Ch]

  if ( !val || val->type != JSON_ARRAY )
    return 0;
  v3 = json_array_get(val, 0);
  msg = (unsigned __int8 *)json_string_value(v3);
  if ( !msg )
    return 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d message: %s", pool->pool_no, (const char *)msg);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (0005E144) --------------------------------------------------------
bool __cdecl parse_method(pool *pool, unsigned __int8 *s)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  json_error_t err; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 *buf; // [sp+90Ch] [bp+904h]
  json_t_0 *params; // [sp+910h] [bp+908h]
  json_t_0 *err_val; // [sp+914h] [bp+90Ch]
  json_t_0 *method; // [sp+918h] [bp+910h]
  json_t_0 *val; // [sp+91Ch] [bp+914h]
  unsigned __int8 *ss; // [sp+920h] [bp+918h]
  bool ret; // [sp+927h] [bp+91Fh]

  val = 0;
  ret = 0;
  if ( s )
  {
    val = json_loads(s, 0, &err);
    if ( val )
    {
      method = json_object_get(val, "method");
      if ( method )
      {
        err_val = json_object_get(val, "error");
        params = json_object_get(val, "params");
        if ( !err_val || err_val->type == JSON_NULL )
        {
          buf = (unsigned __int8 *)json_string_value(method);
          if ( buf )
          {
            if ( !strncasecmp((const char *)buf, "mining.multi_version", 0x14u) )
            {
              pool->support_vil = 1;
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                strcpy((char *)tmp42, "Pool support multi version");
                applog(6, tmp42, 0);
              }
              ret = parse_version(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.notify", 0xDu) )
            {
              if ( parse_notify(pool, params) )
              {
                ret = 1;
                pool->stratum_notify = 1;
              }
              else
              {
                ret = 0;
                pool->stratum_notify = 0;
              }
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_difficulty", 0x15u) )
            {
              ret = parse_diff(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_extranonce", 0x15u) )
            {
              ret = parse_extranonce(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "client.reconnect", 0x10u) )
            {
              ret = parse_reconnect(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "client.get_version", 0x12u) )
            {
              ret = send_version(pool, val);
            }
            else if ( !strncasecmp((const char *)buf, "client.show_message", 0x13u) )
            {
              ret = show_message(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.ping", 0xBu) )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                snprintf((char *)tmp42, 0x800u, "Pool %d ping", pool->pool_no);
                applog(6, tmp42, 0);
              }
              ret = send_pong(pool, val);
            }
          }
        }
        else
        {
          ss = json_dumps(err_val, 3u);
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "JSON-RPC method decode failed: %s", (const char *)ss);
            applog(6, tmp42, 0);
          }
          free(ss);
        }
      }
      json_decref_1(val);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
      applog(6, tmp42, 0);
    }
  }
  return ret;
}
// 5E23A: conditional instruction was optimized away because %err_val.4!=0
// 5E24C: conditional instruction was optimized away because %err_val.4!=0

//----- (0005E544) --------------------------------------------------------
bool __cdecl subscribe_extranonce(pool *pool)
{
  int v1; // r2
  size_t v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  json_error_t err; // [sp+814h] [bp+80Ch] BYREF
  unsigned __int8 s[8192]; // [sp+910h] [bp+908h] BYREF
  json_t_0 *err_val; // [sp+2910h] [bp+2908h]
  json_t_0 *res_val; // [sp+2914h] [bp+290Ch]
  unsigned __int8 *sret; // [sp+2918h] [bp+2910h]
  unsigned __int8 *ss; // [sp+291Ch] [bp+2914h]
  bool ret; // [sp+2923h] [bp+291Bh]
  json_t_0 *val; // [sp+2924h] [bp+291Ch]

  val = 0;
  sret = 0;
  ret = 0;
  v1 = swork_id++;
  sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v1);
  v2 = strlen((const char *)s);
  if ( stratum_send(pool, s, v2) )
  {
    while ( 1 )
    {
      if ( !socket_full(pool, 2) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Timed out waiting for response extranonce.subscribe");
          applog(7, tmp42, 0);
        }
        ret = 1;
        goto out;
      }
      sret = recv_line(pool);
      if ( !sret )
        return ret;
      if ( !parse_method(pool, sret) )
        break;
      free(sret);
    }
    val = json_loads(sret, 0, &err);
    free(sret);
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    if ( res_val && res_val->type != JSON_FALSE && (!err_val || err_val->type == JSON_NULL) )
    {
      ret = 1;
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum extranonce subscribe for pool %d", pool->pool_no);
        applog(6, tmp42, 0);
      }
      goto out;
    }
    if ( err_val )
    {
      ss = _json_array_string(err_val, 1u);
      if ( !ss )
        ss = (unsigned __int8 *)json_string_value(err_val);
      if ( ss && !strcmp((const char *)ss, "Method 'subscribe' not found for service 'mining.extranonce'") )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        ret = 1;
out:
        json_decref_1(val);
        return ret;
      }
      if ( ss && !strcmp((const char *)ss, "Unrecognized request provided") )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        ret = 1;
        goto out;
      }
      ss = json_dumps(err_val, 3u);
    }
    else
    {
      ss = (unsigned __int8 *)strdup("(unknown reason)");
    }
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d JSON extranonce subscribe failed: %s", pool->pool_no, (const char *)ss);
      applog(6, tmp42, 0);
    }
    free(ss);
    goto out;
  }
  return ret;
}
// 5E75E: conditional instruction was optimized away because %res_val.4!=0
// 5E78C: conditional instruction was optimized away because %err_val.4!=0

//----- (0005EA5C) --------------------------------------------------------
bool __cdecl auth_stratum(pool *pool)
{
  int v1; // r2
  size_t v2; // r0
  int v4; // r2
  size_t v5; // r0
  int v6; // r2
  size_t v7; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  json_error_t err; // [sp+814h] [bp+80Ch] BYREF
  unsigned __int8 s[8192]; // [sp+910h] [bp+908h] BYREF
  json_t_0 *err_val; // [sp+2910h] [bp+2908h]
  json_t_0 *res_val; // [sp+2914h] [bp+290Ch]
  unsigned __int8 *sret; // [sp+2918h] [bp+2910h]
  json_t_0 *val; // [sp+291Ch] [bp+2914h]
  unsigned __int8 *ss; // [sp+2920h] [bp+2918h]
  bool ret; // [sp+2927h] [bp+291Fh]

  val = 0;
  sret = 0;
  ret = 0;
  v1 = swork_id++;
  sprintf(
    (char *)s,
    "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}",
    v1,
    (const char *)pool->rpc_user,
    (const char *)pool->rpc_pass);
  v2 = strlen((const char *)s);
  if ( !stratum_send(pool, s, v2) )
    return ret;
  while ( 1 )
  {
    sret = recv_line(pool);
    if ( !sret )
      return ret;
    if ( !parse_method(pool, sret) )
      break;
    free(sret);
  }
  val = json_loads(sret, 0, &err);
  free(sret);
  res_val = json_object_get(val, "result");
  err_val = json_object_get(val, "error");
  if ( res_val && res_val->type != JSON_FALSE && (!err_val || err_val->type == JSON_NULL) )
  {
    ret = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Stratum authorisation success for pool %d", pool->pool_no);
      applog(6, tmp42, 0);
    }
    pool->probed = 1;
    successful_connect = 1;
    if ( opt_suggest_diff )
    {
      v4 = swork_id++;
      sprintf(
        (char *)s,
        "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}",
        v4,
        opt_suggest_diff);
      v5 = strlen((const char *)s);
      stratum_send(pool, s, v5);
    }
    if ( opt_multi_version )
    {
      v6 = swork_id++;
      sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.multi_version\", \"params\": [%d]}", v6, opt_multi_version);
      v7 = strlen((const char *)s);
      stratum_send(pool, s, v7);
    }
  }
  else
  {
    if ( err_val )
      ss = json_dumps(err_val, 3u);
    else
      ss = (unsigned __int8 *)strdup("(unknown reason)");
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "pool %d JSON stratum auth failed: %s", pool->pool_no, (const char *)ss);
      applog(6, tmp42, 0);
    }
    free(ss);
    suspend_stratum(pool);
  }
  json_decref_1(val);
  return ret;
}
// 5EC00: conditional instruction was optimized away because %res_val.4!=0
// 5EC2C: conditional instruction was optimized away because %err_val.4!=0

//----- (0005EE88) --------------------------------------------------------
int __cdecl recv_byte(int sockd)
{
  unsigned __int8 c; // [sp+Fh] [bp+Fh] BYREF

  if ( recv(sockd, &c, 1u, 0) == -1 )
    return -1;
  else
    return c;
}

//----- (0005EEBC) --------------------------------------------------------
bool __cdecl http_negotiate(pool *pool, int sockd, bool http0)
{
  size_t v3; // r0
  unsigned __int8 v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 buf[1024]; // [sp+820h] [bp+810h] BYREF
  int len; // [sp+C20h] [bp+C10h]
  int i; // [sp+C24h] [bp+C14h]

  if ( http0 )
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.0\r\n\r\n",
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port);
  else
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n",
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port,
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Sending proxy %s:%s - %s",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port,
      (const char *)buf);
    applog(7, tmp42, 0);
  }
  v3 = strlen((const char *)buf);
  send(sockd, buf, v3, 0);
  len = recv(sockd, buf, 0xCu, 0);
  if ( len > 0 )
  {
    buf[len] = 0;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Received from proxy %s:%s - %s",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port,
        (const char *)buf);
      applog(7, tmp42, 0);
    }
    if ( !strcmp((const char *)buf, "HTTP/1.1 200") || !strcmp((const char *)buf, "HTTP/1.0 200") )
    {
      for ( i = 0; i <= 3; ++i )
      {
        v5 = recv_byte(sockd);
        buf[i] = v5;
        if ( buf[i] == 255 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Couldn't read HTTP byte from proxy %s:%s",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(4, tmp42, 0);
          }
          return 0;
        }
      }
      do
      {
        if ( !strncmp((const char *)buf, "\r\n\r\n", 4u) )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Success negotiating with %s:%s HTTP proxy",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(7, tmp42, 0);
          }
          return 1;
        }
        for ( i = 0; i <= 2; ++i )
          buf[i] = buf[i + 1];
        buf[3] = recv_byte(sockd);
      }
      while ( buf[3] != 255 );
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Couldn't read HTTP byte from proxy %s:%s",
          (const char *)pool->sockaddr_proxy_url,
          (const char *)pool->sockaddr_proxy_port);
        applog(4, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "HTTP Error from proxy %s:%s - %s",
          (const char *)pool->sockaddr_proxy_url,
          (const char *)pool->sockaddr_proxy_port,
          (const char *)buf);
        applog(4, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Couldn't read from proxy %s:%s after sending CONNECT",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
}

//----- (0005F394) --------------------------------------------------------
bool __cdecl socks5_negotiate(pool *pool, int sockd)
{
  int v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf[515]; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 atyp; // [sp+A13h] [bp+A0Bh]
  unsigned __int16 port; // [sp+A14h] [bp+A0Ch]
  unsigned __int8 uclen; // [sp+A17h] [bp+A0Fh]
  int len; // [sp+A18h] [bp+A10h]
  int i; // [sp+A1Ch] [bp+A14h]

  buf[0] = 5;
  buf[1] = 1;
  buf[2] = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Attempting to negotiate with %s:%s SOCKS5 proxy",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port);
    applog(7, tmp42, 0);
  }
  send(sockd, buf, 3u, 0);
  if ( recv_byte(sockd) != 5 || (v2 = recv_byte(sockd), v2 != buf[2]) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS5 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  buf[0] = 5;
  buf[1] = 1;
  buf[2] = 0;
  buf[3] = 3;
  len = strlen((const char *)pool->sockaddr_url);
  if ( len > 255 )
    len = 255;
  uclen = len;
  buf[4] = len;
  cg_memcpy(&buf[5], pool->sockaddr_url, len, "util.c", _func___10670, 2636);
  port = atoi((const char *)pool->stratum_port);
  buf[len + 5] = HIBYTE(port);
  buf[len + 6] = port;
  send(sockd, buf, len + 7, 0);
  if ( recv_byte(sockd) != 5 || recv_byte(sockd) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS5 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  recv_byte(sockd);
  atyp = recv_byte(sockd);
  if ( atyp == 1 )
  {
    for ( i = 0; i <= 3; ++i )
      recv_byte(sockd);
LABEL_37:
    for ( i = 0; i <= 1; ++i )
      recv_byte(sockd);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Success negotiating with %s:%s SOCKS5 proxy",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(7, tmp42, 0);
    }
    return 1;
  }
  if ( atyp == 3 )
  {
    len = recv_byte(sockd);
    for ( i = 0; i < len; ++i )
      recv_byte(sockd);
    goto LABEL_37;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Bad response from %s:%s SOCKS5 server",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port);
    applog(4, tmp42, 0);
  }
  return 0;
}

//----- (0005F79C) --------------------------------------------------------
bool __cdecl socks4_negotiate(pool *pool, int sockd, bool socks4a)
{
  in_addr_t v3; // r0
  addrinfo servinfobase; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+3Ch] [bp+34h] BYREF
  addrinfo *servinfo; // [sp+83Ch] [bp+834h] BYREF
  unsigned __int8 buf[515]; // [sp+840h] [bp+838h] BYREF
  sockaddr_in_0 *saddr_in; // [sp+A44h] [bp+A3Ch]
  unsigned __int16 port; // [sp+A4Ah] [bp+A42h]
  int len; // [sp+A4Ch] [bp+A44h]
  int i; // [sp+A50h] [bp+A48h]
  in_addr_t_0 inp; // [sp+A54h] [bp+A4Ch]

  buf[0] = 4;
  buf[1] = 1;
  port = atoi((const char *)pool->stratum_port);
  buf[2] = HIBYTE(port);
  buf[3] = port;
  strcpy((char *)&buf[8], "CGMINER");
  v3 = inet_addr((const char *)pool->sockaddr_url);
  inp = ntohl(v3);
  if ( inp == -1 )
  {
    servinfo = &servinfobase;
    memset(tmp42, 0, 0x20u);
    *(_DWORD *)&tmp42[4] = 2;
    if ( !getaddrinfo((const char *)pool->sockaddr_url, 0, (const struct addrinfo *)tmp42, &servinfo) )
    {
      saddr_in = (sockaddr_in_0 *)servinfo->ai_addr;
      inp = ntohl(saddr_in->sin_addr.s_addr);
      socks4a = 0;
      freeaddrinfo(servinfo);
    }
  }
  else
  {
    socks4a = 0;
  }
  if ( !socks4a )
  {
    if ( inp == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Invalid IP address specified for socks4 proxy: %s",
          (const char *)pool->sockaddr_url);
        applog(4, tmp42, 0);
      }
      return 0;
    }
    buf[4] = HIBYTE(inp);
    buf[5] = BYTE2(inp);
    buf[6] = BYTE1(inp);
    buf[7] = inp;
    send(sockd, buf, 0x10u, 0);
  }
  else
  {
    buf[4] = 0;
    buf[5] = 0;
    buf[6] = 0;
    buf[7] = 1;
    len = strlen((const char *)pool->sockaddr_url);
    if ( len > 255 )
      len = 255;
    cg_memcpy(&buf[16], pool->sockaddr_url, len, "util.c", _func___10698, 2738);
    len += 16;
    buf[len++] = 0;
    send(sockd, buf, len, 0);
  }
  if ( !recv_byte(sockd) && recv_byte(sockd) == 90 )
  {
    for ( i = 0; i <= 5; ++i )
      recv_byte(sockd);
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS4 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
}

//----- (0005FAD8) --------------------------------------------------------
void __cdecl noblock_socket(int fd)
{
  int v1; // r0

  v1 = fcntl(fd, 3, 0);
  fcntl(fd, 4, v1 | 0x800);
}

//----- (0005FB04) --------------------------------------------------------
void __cdecl block_socket(int fd)
{
  int v1; // r0

  v1 = fcntl(fd, 3, 0);
  fcntl(fd, 4, v1 & 0xFFFFF7FF);
}

//----- (0005FB30) --------------------------------------------------------
bool sock_connecting()
{
  return *_errno_location() == 115;
}

//----- (0005FB4C) --------------------------------------------------------
bool __cdecl setup_stratum_socket(pool *pool)
{
  bool v1; // r3
  fd_set rw; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+94h] [bp+8Ch] BYREF
  int err; // [sp+894h] [bp+88Ch] BYREF
  socklen_t len; // [sp+898h] [bp+890h] BYREF
  timeval tv_timeout; // [sp+89Ch] [bp+894h] BYREF
  addrinfo hints; // [sp+8A4h] [bp+89Ch] BYREF
  addrinfo *servinfo; // [sp+8C4h] [bp+8BCh] BYREF
  int n; // [sp+8C8h] [bp+8C0h]
  int selret; // [sp+8CCh] [bp+8C4h]
  fd_set *__arr; // [sp+8D0h] [bp+8C8h]
  unsigned int __i; // [sp+8D4h] [bp+8CCh]
  int sockd; // [sp+8D8h] [bp+8D0h]
  unsigned __int8 *sockaddr_port; // [sp+8DCh] [bp+8D4h]
  unsigned __int8 *sockaddr_url; // [sp+8E0h] [bp+8D8h]
  addrinfo *p; // [sp+8E4h] [bp+8DCh]

  mutex_lock_4(&pool->stratum_lock, "util.c", _func___10723, 2785);
  pool->stratum_active = 0;
  if ( pool->sock )
    close(pool->sock);
  pool->sock = 0;
  mutex_unlock_4(&pool->stratum_lock, "util.c", _func___10723, 2790);
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  if ( !pool->rpc_proxy && opt_socks_proxy )
  {
    pool->rpc_proxy = opt_socks_proxy;
    extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
    pool->rpc_proxytype = 3;
  }
  if ( pool->rpc_proxy )
  {
    sockaddr_url = pool->sockaddr_proxy_url;
    sockaddr_port = pool->sockaddr_proxy_port;
  }
  else
  {
    sockaddr_url = pool->sockaddr_url;
    sockaddr_port = pool->stratum_port;
  }
  if ( getaddrinfo((const char *)sockaddr_url, (const char *)sockaddr_port, &hints, &servinfo) )
  {
    if ( !pool->probed )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to resolve (?wrong URL) %s:%s",
          (const char *)sockaddr_url,
          (const char *)sockaddr_port);
        applog(4, tmp42, 0);
      }
      pool->probed = 1;
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to getaddrinfo for %s:%s",
        (const char *)sockaddr_url,
        (const char *)sockaddr_port);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    for ( p = servinfo; p; p = p->ai_next )
    {
      sockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
      if ( sockd == -1 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Failed socket");
          applog(7, tmp42, 0);
        }
      }
      else
      {
        noblock_socket(sockd);
        if ( connect(sockd, p->ai_addr, p->ai_addrlen) != -1 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy((char *)tmp42, "Succeeded immediate connect");
            applog(4, tmp42, 0);
          }
LABEL_59:
          block_socket(sockd);
          break;
        }
        tv_timeout.tv_sec = 1;
        tv_timeout.tv_usec = 0;
        if ( !sock_connecting() )
        {
          close(sockd);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Failed sock connect");
            applog(7, tmp42, 0);
          }
        }
        else
        {
          do
          {
            __arr = &rw;
            for ( __i = 0; __i <= 0x1F; ++__i )
              __arr->fds_bits[__i] = 0;
            rw.fds_bits[sockd / 32] |= 1 << (sockd % 32);
            selret = select(sockd + 1, 0, &rw, 0, &tv_timeout);
            if ( selret > 0 && ((rw.fds_bits[sockd / 32] >> (sockd % 32)) & 1) != 0 )
            {
              len = 4;
              n = getsockopt(sockd, 1, 4, &err, &len);
              if ( !n && !err )
              {
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  strcpy((char *)tmp42, "Succeeded delayed connect");
                  applog(7, tmp42, 0);
                }
                goto LABEL_59;
              }
            }
          }
          while ( selret < 0 && interrupted() );
          close(sockd);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Select timeout/failed connect");
            applog(7, tmp42, 0);
          }
        }
      }
    }
    if ( p )
    {
      freeaddrinfo(servinfo);
      if ( pool->rpc_proxy )
      {
        switch ( pool->rpc_proxytype )
        {
          case 0:
            if ( http_negotiate(pool, sockd, 0) )
              goto LABEL_85;
            v1 = 0;
            break;
          case 1:
            if ( http_negotiate(pool, sockd, 1) )
              goto LABEL_85;
            v1 = 0;
            break;
          case 2:
            if ( socks4_negotiate(pool, sockd, 0) )
              goto LABEL_85;
            v1 = 0;
            break;
          case 3:
          case 5:
            if ( socks5_negotiate(pool, sockd) )
              goto LABEL_85;
            v1 = 0;
            break;
          case 4:
            if ( socks4_negotiate(pool, sockd, 1) )
              goto LABEL_85;
            v1 = 0;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Unsupported proxy type for %s:%s",
                (const char *)pool->sockaddr_proxy_url,
                (const char *)pool->sockaddr_proxy_port);
              applog(4, tmp42, 0);
            }
            v1 = 0;
            break;
        }
      }
      else
      {
LABEL_85:
        if ( !pool->sockbuf )
        {
          pool->sockbuf = (unsigned __int8 *)cgcalloc(0x2000, 1u, "util.c", _func___10723, 2927);
          pool->sockbuf_size = 0x2000;
        }
        pool->sock = sockd;
        keep_sockalive(sockd);
        return 1;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to connect to stratum on %s:%s",
          (const char *)sockaddr_url,
          (const char *)sockaddr_port);
        applog(6, tmp42, 0);
      }
      freeaddrinfo(servinfo);
      return 0;
    }
  }
  return v1;
}

//----- (00060328) --------------------------------------------------------
unsigned __int8 *__cdecl get_sessionid(json_t_0 *val)
{
  bool v1; // r3
  unsigned __int8 *notify; // [sp+8h] [bp+8h]
  json_t_0 *arr; // [sp+Ch] [bp+Ch]
  int arrsize; // [sp+10h] [bp+10h]
  const json_t_0 *arr_val; // [sp+14h] [bp+14h]
  int i; // [sp+18h] [bp+18h]
  unsigned __int8 *ret; // [sp+1Ch] [bp+1Ch]

  ret = 0;
  arr_val = json_array_get(val, 0);
  if ( arr_val && arr_val->type == JSON_ARRAY )
  {
    arrsize = json_array_size(arr_val);
    for ( i = 0; i < arrsize; ++i )
    {
      arr = json_array_get(arr_val, i);
      v1 = !arr || arr->type != JSON_ARRAY;
      if ( v1 || arr == 0 )
        break;
      notify = _json_array_string(arr, 0);
      if ( notify && !strncasecmp((const char *)notify, "mining.notify", 0xDu) )
        return json_array_string(arr, 1u);
    }
  }
  return ret;
}

//----- (000603F0) --------------------------------------------------------
void __cdecl suspend_stratum(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Closing socket for stratum pool %d", pool->pool_no);
    applog(6, tmp42, 0);
  }
  mutex_lock_4(&pool->stratum_lock, "util.c", _func___10775, 2970);
  _suspend_stratum(pool);
  mutex_unlock_4(&pool->stratum_lock, "util.c", _func___10775, 2972);
}

//----- (000604A8) --------------------------------------------------------
bool __cdecl initiate_stratum(pool *pool)
{
  int v1; // r2
  int v2; // r2
  size_t v3; // r0
  json_t_0 *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  json_error_t err; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 s[8192]; // [sp+90Ch] [bp+904h] BYREF
  int n2size; // [sp+290Ch] [bp+2904h]
  unsigned __int8 *nonce1; // [sp+2910h] [bp+2908h]
  unsigned __int8 *sessionid; // [sp+2914h] [bp+290Ch]
  json_t_0 *err_val; // [sp+2918h] [bp+2910h]
  json_t_0 *res_val; // [sp+291Ch] [bp+2914h]
  unsigned __int8 *sret; // [sp+2920h] [bp+2918h]
  unsigned __int8 *ss; // [sp+2924h] [bp+291Ch]
  json_t_0 *val; // [sp+2928h] [bp+2920h]
  bool sockd; // [sp+292Ch] [bp+2924h]
  bool noresume; // [sp+292Dh] [bp+2925h]
  bool recvd; // [sp+292Eh] [bp+2926h]
  bool ret; // [sp+292Fh] [bp+2927h]

  ret = 0;
  recvd = 0;
  noresume = 0;
  sockd = 0;
  sret = 0;
  for ( val = 0; ; json_decref_1(val) )
  {
    if ( !setup_stratum_socket(pool) )
    {
      sockd = 0;
    }
    else
    {
      sockd = 1;
      if ( recvd )
      {
        clear_sock(pool);
        v1 = swork_id++;
        sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v1);
      }
      else
      {
        v2 = swork_id;
        if ( pool->sessionid )
        {
          ++swork_id;
          sprintf(
            (char *)s,
            "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"bmminer/2.0.0\", \"%s\"]}",
            v2,
            (const char *)pool->sessionid);
        }
        else
        {
          ++swork_id;
          sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"bmminer/2.0.0\"]}", v2);
        }
      }
      v3 = strlen((const char *)s);
      if ( _stratum_send(pool, s, v3) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Failed to send s in initiate_stratum");
          applog(7, tmp42, 0);
        }
      }
      else if ( !socket_full(pool, 60) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Timed out waiting for response in initiate_stratum");
          applog(7, tmp42, 0);
        }
      }
      else
      {
        sret = recv_line(pool);
        if ( sret )
        {
          recvd = 1;
          val = json_loads(sret, 0, &err);
          free(sret);
          if ( val )
          {
            res_val = json_object_get(val, "result");
            err_val = json_object_get(val, "error");
            if ( res_val && res_val->type != JSON_NULL && (!err_val || err_val->type == JSON_NULL) )
            {
              sessionid = get_sessionid(res_val);
              if ( !sessionid && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "Failed to get sessionid in initiate_stratum");
                applog(7, tmp42, 0);
              }
              nonce1 = json_array_string(res_val, 1u);
              if ( !valid_hex(nonce1, "util.c", _func___10800, 3056) )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 5 )
                {
                  strcpy((char *)tmp42, "Failed to get valid nonce1 in initiate_stratum");
                  applog(6, tmp42, 0);
                }
                free(sessionid);
              }
              else
              {
                v4 = json_array_get(res_val, 2u);
                n2size = json_integer_value(v4);
                if ( n2size > 1 && n2size <= 16 )
                {
                  if ( sessionid
                    && pool->sessionid
                    && !strcmp((const char *)sessionid, (const char *)pool->sessionid)
                    && (use_syslog || opt_log_output || opt_log_level > 4) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "Pool %d successfully negotiated resume with the same session ID",
                      pool->pool_no);
                    applog(5, tmp42, 0);
                  }
                  cg_wlock_3(&pool->data_lock, "util.c", _func___10800, 3076);
                  free(pool->nonce1);
                  free(pool->sessionid);
                  pool->sessionid = sessionid;
                  pool->nonce1 = nonce1;
                  pool->n1_len = strlen((const char *)nonce1) >> 1;
                  free(pool->nonce1bin);
                  pool->nonce1bin = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", _func___10800, 3083);
                  hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
                  pool->n2size = n2size;
                  cg_wunlock_3(&pool->data_lock, "util.c", _func___10800, 3086);
                  if ( sessionid && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "Pool %d stratum session id: %s",
                      pool->pool_no,
                      (const char *)pool->sessionid);
                    applog(7, tmp42, 0);
                  }
                  ret = 1;
                }
                else
                {
                  if ( use_syslog || opt_log_output || opt_log_level > 5 )
                  {
                    strcpy((char *)tmp42, "Failed to get valid n2size in initiate_stratum");
                    applog(6, tmp42, 0);
                  }
                  free(sessionid);
                  free(nonce1);
                }
              }
            }
            else
            {
              if ( err_val )
                ss = json_dumps(err_val, 3u);
              else
                ss = (unsigned __int8 *)strdup("(unknown reason)");
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                snprintf((char *)tmp42, 0x800u, "JSON-RPC decode failed: %s", (const char *)ss);
                applog(6, tmp42, 0);
              }
              free(ss);
            }
          }
          else if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
            applog(6, tmp42, 0);
          }
        }
      }
    }
    if ( ret )
    {
      if ( !pool->stratum_url )
        pool->stratum_url = pool->sockaddr_url;
      pool->stratum_active = 1;
      pool->next_diff = 0.0;
      pool->sdiff = 1.0;
      if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
          pool->pool_no,
          (const char *)pool->nonce1,
          pool->n2size);
        applog(7, tmp42, 0);
      }
      goto LABEL_96;
    }
    if ( !recvd || noresume )
      break;
    cg_wlock_3(&pool->data_lock, "util.c", _func___10800, 3114);
    free(pool->sessionid);
    free(pool->nonce1);
    pool->nonce1 = 0;
    pool->sessionid = pool->nonce1;
    cg_wunlock_3(&pool->data_lock, "util.c", _func___10800, 3118);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Failed to resume stratum, trying afresh");
      applog(7, tmp42, 0);
    }
    noresume = 1;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Initiate stratum failed");
    applog(7, tmp42, 0);
  }
  if ( sockd )
    suspend_stratum(pool);
LABEL_96:
  json_decref_1(val);
  return ret;
}
// 60866: conditional instruction was optimized away because %res_val.4!=0
// 60894: conditional instruction was optimized away because %err_val.4!=0

//----- (000610FC) --------------------------------------------------------
bool __cdecl restart_stratum(pool *pool)
{
  bool ret; // [sp+Fh] [bp+Fh]

  ret = 0;
  if ( pool->stratum_active )
    suspend_stratum(pool);
  if ( initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool) )
    ret = 1;
  if ( !ret )
    pool_died(pool);
  else
    stratum_resumed(pool);
  return ret;
}

//----- (00061190) --------------------------------------------------------
void __cdecl dev_error(cgpu_info *dev, dev_reason reason)
{
  dev->device_last_not_well = time(0);
  dev->device_not_well_reason = reason;
  switch ( reason )
  {
    case REASON_THREAD_FAIL_INIT:
      ++dev->thread_fail_init_count;
      break;
    case REASON_THREAD_ZERO_HASH:
      ++dev->thread_zero_hash_count;
      break;
    case REASON_THREAD_FAIL_QUEUE:
      ++dev->thread_fail_queue_count;
      break;
    case REASON_DEV_SICK_IDLE_60:
      ++dev->dev_sick_idle_60_count;
      break;
    case REASON_DEV_DEAD_IDLE_600:
      ++dev->dev_dead_idle_600_count;
      break;
    case REASON_DEV_NOSTART:
      ++dev->dev_nostart_count;
      break;
    case REASON_DEV_OVER_HEAT:
      ++dev->dev_over_heat_count;
      break;
    case REASON_DEV_THERMAL_CUTOFF:
      ++dev->dev_thermal_cutoff_count;
      break;
    case REASON_DEV_COMMS_ERROR:
      ++dev->dev_comms_error_count;
      break;
    case REASON_DEV_THROTTLE:
      ++dev->dev_throttle_count;
      break;
    default:
      return;
  }
}

//----- (0006128C) --------------------------------------------------------
void *__cdecl realloc_strcat(unsigned __int8 *ptr, unsigned __int8 *s)
{
  size_t len; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 *ret; // [sp+10h] [bp+10h]
  size_t old; // [sp+14h] [bp+14h]

  old = 0;
  len = strlen((const char *)s);
  if ( !len )
    return ptr;
  if ( ptr )
    old = strlen((const char *)ptr);
  len += old + 1;
  align_len(&len);
  ret = (unsigned __int8 *)cgmalloc(len, "util.c", _func___10835, 3210);
  if ( ptr )
  {
    sprintf((char *)ret, "%s%s", (const char *)ptr, (const char *)s);
    free(ptr);
  }
  else
  {
    strcpy((char *)ret, (const char *)s);
  }
  return ret;
}

//----- (00061324) --------------------------------------------------------
void *__cdecl str_text(unsigned __int8 *ptr)
{
  size_t v1; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 *ret; // [sp+814h] [bp+80Ch]
  unsigned __int8 *txt; // [sp+818h] [bp+810h]
  unsigned __int8 *uptr; // [sp+81Ch] [bp+814h]

  if ( !ptr )
  {
    ret = (unsigned __int8 *)strdup("(null)");
    if ( !ret )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to malloc null in %s %s():%d",
        "util.c",
        (const char *)_func___10843,
        3235);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  uptr = ptr;
  v1 = strlen((const char *)ptr);
  txt = (unsigned __int8 *)cgmalloc(4 * v1 + 5, "util.c", _func___10843, 3240);
  ret = txt;
  do
  {
    if ( *uptr > 0x1Fu && *uptr <= 0x7Eu )
    {
      *txt++ = *uptr;
    }
    else
    {
      sprintf((char *)txt, "0x%02x", *uptr);
      txt += 4;
    }
  }
  while ( *uptr++ != 0 );
  *txt = 0;
  return ret;
}

//----- (00061458) --------------------------------------------------------
void __cdecl RenameThread(const unsigned __int8 *name)
{
  unsigned __int8 buf[16]; // [sp+10h] [bp+8h] BYREF

  snprintf((char *)buf, 0x10u, "cg@%s", (const char *)name);
  prctl(15, buf, 0, 0, 0);
}

//----- (00061494) --------------------------------------------------------
void __cdecl cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  int ret; // [sp+824h] [bp+814h]

  ret = sem_init(cgsem, 0, 0);
  if ( ret )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_init ret=%d errno=%d in %s %s():%d",
      ret,
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00061524) --------------------------------------------------------
void __cdecl cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( sem_post(cgsem) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d",
      *v4,
      cgsem,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000615AC) --------------------------------------------------------
void __cdecl cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  while ( sem_wait(cgsem) )
  {
    if ( !interrupted() )
    {
      v4 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d",
        *v4,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (00061640) --------------------------------------------------------
int __cdecl cgsem_mswait(
        cgsem_t *cgsem,
        int ms,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  timeval tv_now; // [sp+824h] [bp+814h] BYREF
  timespec ts_now; // [sp+82Ch] [bp+81Ch] BYREF
  timespec abs_timeout; // [sp+834h] [bp+824h] BYREF

  cgtime(&tv_now);
  timeval_to_spec(&ts_now, &tv_now);
  ms_to_timespec(&abs_timeout, ms);
  while ( 1 )
  {
    timeraddspec(&abs_timeout, &ts_now);
    if ( !sem_timedwait(cgsem, &abs_timeout) )
      break;
    if ( sock_timeout() )
      return 110;
    if ( !interrupted() )
    {
      v6 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        *v6,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  return 0;
}

//----- (00061730) --------------------------------------------------------
void __cdecl cgsem_reset(cgsem_t *cgsem)
{
  int ret; // [sp+Ch] [bp+Ch]

  do
  {
    ret = sem_trywait(cgsem);
    if ( ret < 0 && interrupted() )
      ret = 0;
  }
  while ( !ret );
}

//----- (00061764) --------------------------------------------------------
void __cdecl cgsem_destroy(cgsem_t *cgsem)
{
  sem_destroy(cgsem);
}

//----- (0006177C) --------------------------------------------------------
void *__cdecl completion_thread(void *arg)
{
  pthread_setcanceltype(1, 0);
  (*((void (__fastcall **)(_DWORD))arg + 4))(*((_DWORD *)arg + 5));
  cgsem_post((cgsem_t *)arg, "util.c", _func___10904, 3466);
  return 0;
}

//----- (000617C4) --------------------------------------------------------
bool __cdecl cg_completion_timeout(void *fn, void *fnarg, int timeout)
{
  pthread_t pthread; // [sp+1Ch] [bp+14h] BYREF
  cg_completion *cgc; // [sp+20h] [bp+18h]
  bool ret; // [sp+27h] [bp+1Fh]

  ret = 0;
  cgc = (cg_completion *)cgmalloc(0x18u, "util.c", _func___10913, 3477);
  cgsem_init(&cgc->cgsem, "util.c", _func___10913, 3478);
  cgc->fn = (void (*)(void *))fn;
  cgc->fnarg = fnarg;
  pthread_create(&pthread, 0, (void *(*)(void *))completion_thread, cgc);
  ret = cgsem_mswait(&cgc->cgsem, timeout, "util.c", _func___10913, 3484) != 0;
  if ( !ret )
  {
    pthread_join(pthread, 0);
    free(cgc);
  }
  else
  {
    pthread_cancel(pthread);
  }
  return !ret;
}

//----- (000618A4) --------------------------------------------------------
void __cdecl cg_memcpy(
        void *dest,
        const void *src,
        unsigned int n,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( n && n <= 0x80000000 )
  {
    if ( dest )
    {
      if ( src )
      {
        memcpy(dest, src, n);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d",
          n,
          (const char *)file,
          (const char *)func,
          line);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d",
        n,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "ERR: Asked to memcpy %u bytes from %s %s():%d",
      n,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (00061A48) --------------------------------------------------------
int __cdecl cg_timeval_subtract(timeval *result, timeval *x, timeval *y)
{
  if ( x->tv_sec > y->tv_sec )
    return -1;
  if ( x->tv_sec == y->tv_sec && x->tv_usec > y->tv_usec )
    return -1;
  result->tv_sec = y->tv_sec - x->tv_sec;
  result->tv_usec = y->tv_usec - x->tv_usec;
  if ( result->tv_usec < 0 )
  {
    --result->tv_sec;
    result->tv_usec += 1000000;
  }
  return 0;
}

//----- (00061AD4) --------------------------------------------------------
void __cdecl rev(unsigned __int8 *s, size_t l)
{
  unsigned __int8 t; // [sp+Fh] [bp+Fh]
  size_t j; // [sp+10h] [bp+10h]
  size_t i; // [sp+14h] [bp+14h]

  i = 0;
  for ( j = l - 1; i < j; --j )
  {
    t = s[i];
    s[i] = s[j];
    s[j] = t;
    ++i;
  }
}

//----- (00061B2C) --------------------------------------------------------
int __cdecl check_asicnum(int asic_num, unsigned __int8 nonce)
{
  int v2; // r3
  int v3; // r3
  int v4; // r3
  int v5; // r3

  switch ( asic_num )
  {
    case 1:
      return 1;
    case 2:
      if ( (nonce & 0x80) == 128 )
        return 2;
      else
        return 1;
    case 4:
      v3 = nonce & 0xC0;
      switch ( v3 )
      {
        case 128:
          return 3;
        case 192:
          return 4;
        case 64:
          return 2;
      }
      return 1;
    case 8:
      v4 = nonce & 0xE0;
      if ( v4 == 128 )
        return 5;
      if ( (nonce & 0xE0u) > 0x80 )
      {
        switch ( v4 )
        {
          case 192:
            return 7;
          case 224:
            return 8;
          case 160:
            return 6;
        }
      }
      else
      {
        switch ( v4 )
        {
          case '@':
            return 3;
          case '`':
            return 4;
          case ' ':
            return 2;
        }
      }
      return 1;
    case 16:
      v5 = nonce & 0xF0;
      if ( v5 == 128 )
        return 9;
      if ( (nonce & 0xF0u) > 0x80 )
      {
        if ( v5 == 192 )
          return 13;
        if ( (nonce & 0xF0u) > 0xC0 )
        {
          switch ( v5 )
          {
            case 224:
              return 15;
            case 240:
              return 16;
            case 208:
              return 14;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 160:
              return 11;
            case 176:
              return 12;
            case 144:
              return 10;
          }
        }
      }
      else
      {
        if ( v5 == 64 )
          return 5;
        if ( (nonce & 0xF0u) > 0x40 )
        {
          switch ( v5 )
          {
            case '`':
              return 7;
            case 'p':
              return 8;
            case 'P':
              return 6;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 32:
              return 3;
            case 48:
              return 4;
            case 16:
              return 2;
          }
        }
      }
      return 1;
    case 32:
      switch ( nonce & 0xF8 )
      {
        case 8:
          v2 = 2;
          break;
        case 0x10:
          v2 = 3;
          break;
        case 0x18:
          v2 = 4;
          break;
        case 0x20:
          v2 = 5;
          break;
        case 0x28:
          v2 = 6;
          break;
        case 0x30:
          v2 = 7;
          break;
        case 0x38:
          v2 = 8;
          break;
        case 0x40:
          v2 = 9;
          break;
        case 0x48:
          v2 = 10;
          break;
        case 0x50:
          v2 = 11;
          break;
        case 0x58:
          v2 = 12;
          break;
        case 0x60:
          v2 = 13;
          break;
        case 0x68:
          v2 = 14;
          break;
        case 0x70:
          v2 = 15;
          break;
        case 0x78:
          v2 = 16;
          break;
        case 0x80:
          v2 = 17;
          break;
        case 0x88:
          v2 = 18;
          break;
        case 0x90:
          v2 = 19;
          break;
        case 0x98:
          v2 = 20;
          break;
        case 0xA0:
          v2 = 21;
          break;
        case 0xA8:
          v2 = 22;
          break;
        case 0xB0:
          v2 = 23;
          break;
        case 0xB8:
          v2 = 24;
          break;
        case 0xC0:
          v2 = 25;
          break;
        case 0xC8:
          v2 = 26;
          break;
        case 0xD0:
          v2 = 27;
          break;
        case 0xD8:
          v2 = 28;
          break;
        case 0xE0:
          v2 = 29;
          break;
        case 0xE8:
          v2 = 30;
          break;
        case 0xF0:
          v2 = 31;
          break;
        case 0xF8:
          v2 = 32;
          break;
        default:
          v2 = 1;
          break;
      }
      return v2;
    case 64:
      switch ( nonce & 0xFC )
      {
        case 4:
          v2 = 2;
          break;
        case 8:
          v2 = 3;
          break;
        case 0xC:
          v2 = 4;
          break;
        case 0x10:
          v2 = 5;
          break;
        case 0x14:
          v2 = 6;
          break;
        case 0x18:
          v2 = 7;
          break;
        case 0x1C:
          v2 = 8;
          break;
        case 0x20:
          v2 = 9;
          break;
        case 0x24:
          v2 = 10;
          break;
        case 0x28:
          v2 = 11;
          break;
        case 0x2C:
          v2 = 12;
          break;
        case 0x30:
          v2 = 13;
          break;
        case 0x34:
          v2 = 14;
          break;
        case 0x38:
          v2 = 15;
          break;
        case 0x3C:
          v2 = 16;
          break;
        case 0x40:
          v2 = 17;
          break;
        case 0x44:
          v2 = 18;
          break;
        case 0x48:
          v2 = 19;
          break;
        case 0x4C:
          v2 = 20;
          break;
        case 0x50:
          v2 = 21;
          break;
        case 0x54:
          v2 = 22;
          break;
        case 0x58:
          v2 = 23;
          break;
        case 0x5C:
          v2 = 24;
          break;
        case 0x60:
          v2 = 25;
          break;
        case 0x64:
          v2 = 26;
          break;
        case 0x68:
          v2 = 27;
          break;
        case 0x6C:
          v2 = 28;
          break;
        case 0x70:
          v2 = 29;
          break;
        case 0x74:
          v2 = 30;
          break;
        case 0x78:
          v2 = 31;
          break;
        case 0x7C:
          v2 = 32;
          break;
        case 0x80:
          v2 = 33;
          break;
        case 0x84:
          v2 = 34;
          break;
        case 0x88:
          v2 = 35;
          break;
        case 0x8C:
          v2 = 36;
          break;
        case 0x90:
          v2 = 37;
          break;
        case 0x94:
          v2 = 38;
          break;
        case 0x98:
          v2 = 39;
          break;
        case 0x9C:
          v2 = 40;
          break;
        case 0xA0:
          v2 = 41;
          break;
        case 0xA4:
          v2 = 42;
          break;
        case 0xA8:
          v2 = 43;
          break;
        case 0xAC:
          v2 = 44;
          break;
        case 0xB0:
          v2 = 45;
          break;
        case 0xB4:
          v2 = 46;
          break;
        case 0xB8:
          v2 = 47;
          break;
        case 0xBC:
          v2 = 48;
          break;
        case 0xC0:
          v2 = 49;
          break;
        case 0xC4:
          v2 = 50;
          break;
        case 0xC8:
          v2 = 51;
          break;
        case 0xCC:
          v2 = 52;
          break;
        case 0xD0:
          v2 = 53;
          break;
        case 0xD4:
          v2 = 54;
          break;
        case 0xD8:
          v2 = 55;
          break;
        case 0xDC:
          v2 = 56;
          break;
        case 0xE0:
          v2 = 57;
          break;
        case 0xE4:
          v2 = 58;
          break;
        case 0xE8:
          v2 = 59;
          break;
        case 0xEC:
          v2 = 60;
          break;
        case 0xF0:
          v2 = 61;
          break;
        case 0xF4:
          v2 = 62;
          break;
        case 0xF8:
          v2 = 63;
          break;
        case 0xFC:
          v2 = 64;
          break;
        default:
          v2 = 1;
          break;
      }
      return v2;
    default:
      return 0;
  }
}

//----- (00062700) --------------------------------------------------------
void __cdecl cg_logwork(work *work, unsigned __int8 *nonce_bin, bool ok)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r1
  int v13; // r2
  int v14; // r3
  const char *v15; // r3
  char *v16; // r3
  size_t v17; // r0
  size_t v18; // r0
  size_t v19; // r0
  size_t v20; // r0
  int v21; // [sp+14h] [bp-Ch]
  unsigned __int8 midstate_tmp[32]; // [sp+30h] [bp+10h] BYREF
  unsigned __int8 data_tmp[32]; // [sp+50h] [bp+30h] BYREF
  unsigned __int8 hash_tmp[32]; // [sp+70h] [bp+50h] BYREF
  unsigned __int8 szmsg[1024]; // [sp+90h] [bp+70h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+490h] [bp+470h] BYREF
  uint64_t worksharediff; // [sp+C90h] [bp+C70h]
  int asicnum; // [sp+C9Ch] [bp+C7Ch]
  unsigned __int8 *szhash; // [sp+CA0h] [bp+C80h]
  unsigned __int8 *sznonce5; // [sp+CA4h] [bp+C84h]
  unsigned __int8 *sznonce4; // [sp+CA8h] [bp+C88h]
  unsigned __int8 *szdata; // [sp+CACh] [bp+C8Ch]
  unsigned __int8 *szmidstate; // [sp+CB0h] [bp+C90h]
  unsigned __int8 *szworkdata; // [sp+CB4h] [bp+C94h]
  uint64_t difftmp; // [sp+CB8h] [bp+C98h]
  int diffnum; // [sp+CC4h] [bp+CA4h]

  if ( opt_logwork_path )
  {
    memset(szmsg, 0, sizeof(szmsg));
    memset(midstate_tmp, 0, sizeof(midstate_tmp));
    memset(data_tmp, 0, sizeof(data_tmp));
    memset(hash_tmp, 0, sizeof(hash_tmp));
    szworkdata = 0;
    szmidstate = 0;
    szdata = 0;
    sznonce4 = 0;
    sznonce5 = 0;
    szhash = 0;
    asicnum = 0;
    worksharediff = 0LL;
    v3 = *(_DWORD *)&work->midstate[4];
    v4 = *(_DWORD *)&work->midstate[8];
    v5 = *(_DWORD *)&work->midstate[12];
    *(_DWORD *)midstate_tmp = *(_DWORD *)work->midstate;
    *(_DWORD *)&midstate_tmp[4] = v3;
    *(_DWORD *)&midstate_tmp[8] = v4;
    *(_DWORD *)&midstate_tmp[12] = v5;
    v6 = *(_DWORD *)&work->midstate[20];
    v7 = *(_DWORD *)&work->midstate[24];
    v8 = *(_DWORD *)&work->midstate[28];
    *(_DWORD *)&midstate_tmp[16] = *(_DWORD *)&work->midstate[16];
    *(_DWORD *)&midstate_tmp[20] = v6;
    *(_DWORD *)&midstate_tmp[24] = v7;
    *(_DWORD *)&midstate_tmp[28] = v8;
    memcpy(data_tmp, &work->data[64], 0xCu);
    v9 = *(_DWORD *)&work->hash[4];
    v10 = *(_DWORD *)&work->hash[8];
    v11 = *(_DWORD *)&work->hash[12];
    *(_DWORD *)hash_tmp = *(_DWORD *)work->hash;
    *(_DWORD *)&hash_tmp[4] = v9;
    *(_DWORD *)&hash_tmp[8] = v10;
    *(_DWORD *)&hash_tmp[12] = v11;
    v12 = *(_DWORD *)&work->hash[20];
    v13 = *(_DWORD *)&work->hash[24];
    v14 = *(_DWORD *)&work->hash[28];
    *(_DWORD *)&hash_tmp[16] = *(_DWORD *)&work->hash[16];
    *(_DWORD *)&hash_tmp[20] = v12;
    *(_DWORD *)&hash_tmp[24] = v13;
    *(_DWORD *)&hash_tmp[28] = v14;
    rev(midstate_tmp, 0x20u);
    rev(data_tmp, 0xCu);
    rev(hash_tmp, 0x20u);
    szworkdata = bin2hex(work->data, 0x80u);
    szmidstate = bin2hex(midstate_tmp, 0x20u);
    szdata = bin2hex(data_tmp, 0xCu);
    sznonce4 = bin2hex(nonce_bin, 4u);
    sznonce5 = bin2hex(nonce_bin, 5u);
    szhash = bin2hex(hash_tmp, 0x20u);
    worksharediff = share_ndiff(work);
    if ( ok )
      v15 = "o";
    else
      v15 = "x";
    sprintf(
      (char *)szmsg,
      "%s %08x midstate %s data %s nonce %s hash %s diff %I64d",
      v15,
      work->id,
      szmidstate,
      szdata,
      sznonce5,
      szhash,
      worksharediff);
    if ( !strcmp((const char *)opt_logwork_path, "screen") )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, (const char *)szmsg);
        applog(3, tmp42, 0);
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, (const char *)szmsg);
        applog(3, tmp42, 0);
      }
      if ( g_logwork_file )
      {
        v16 = ok ? "o" : "x";
        sprintf(
          (char *)szmsg,
          "%s %08x work %s midstate %s data %s nonce %s hash %s diff %I64d",
          v16,
          work->id,
          szworkdata,
          szmidstate,
          szdata,
          sznonce5,
          szhash,
          v21,
          worksharediff);
        v17 = strlen((const char *)szmsg);
        fwrite(szmsg, v17, 1u, g_logwork_file);
        fwrite("\n", 1u, 1u, g_logwork_file);
        fflush(g_logwork_file);
        if ( ok )
        {
          if ( g_logwork_asicnum == 1 )
          {
            sprintf(
              (char *)szmsg,
              "midstate %s data %s nonce %s hash %s",
              (const char *)szmidstate,
              (const char *)szdata,
              (const char *)sznonce4,
              (const char *)szhash);
            v18 = strlen((const char *)szmsg);
            fwrite(szmsg, v18, 1u, g_logwork_files[0]);
            fwrite("\n", 1u, 1u, g_logwork_files[0]);
            fflush(g_logwork_files[0]);
          }
          else if ( g_logwork_asicnum == 32 || g_logwork_asicnum == 64 )
          {
            sprintf(
              (char *)szmsg,
              "midstate %s data %s nonce %s hash %s",
              (const char *)szmidstate,
              (const char *)szdata,
              (const char *)sznonce4,
              (const char *)szhash);
            asicnum = check_asicnum(g_logwork_asicnum, *nonce_bin);
            v19 = strlen((const char *)szmsg);
            fwrite(szmsg, v19, 1u, g_logwork_files[asicnum]);
            fwrite("\n", 1u, 1u, g_logwork_files[asicnum]);
            fflush(g_logwork_files[asicnum]);
          }
          if ( opt_logwork_diff )
          {
            diffnum = 0;
            difftmp = worksharediff;
            do
            {
              difftmp >>= 1;
              if ( !difftmp )
                break;
              ++diffnum;
            }
            while ( diffnum <= 63 );
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42, 0x800u, "work diff %I64d diffnum %d");
              applog(7, tmp42, 0);
            }
            sprintf(
              (char *)szmsg,
              "midstate %s data %s nonce %s hash %s",
              (const char *)szmidstate,
              (const char *)szdata,
              (const char *)sznonce4,
              (const char *)szhash);
            v20 = strlen((const char *)szmsg);
            fwrite(szmsg, v20, 1u, g_logwork_diffs[diffnum]);
            fwrite("\n", 1u, 1u, g_logwork_diffs[diffnum]);
            fflush(g_logwork_diffs[diffnum]);
          }
        }
      }
    }
    if ( szworkdata )
      free(szworkdata);
    if ( szmidstate )
      free(szmidstate);
    if ( szdata )
      free(szdata);
    if ( sznonce4 )
      free(sznonce4);
    if ( sznonce5 )
      free(sznonce5);
    if ( szhash )
      free(szhash);
  }
}
// 62A90: variable 'v21' is possibly undefined

//----- (00062DF4) --------------------------------------------------------
void __cdecl cg_logwork_uint32(work *work, unsigned int nonce, bool ok)
{
  unsigned int noncea; // [sp+8h] [bp+8h] BYREF
  work *worka; // [sp+Ch] [bp+Ch]
  unsigned __int8 nonce_bin[5]; // [sp+10h] [bp+10h] BYREF

  worka = work;
  noncea = nonce;
  if ( opt_logwork_path )
  {
    nonce_bin[4] = 0;
    memcpy(nonce_bin, &noncea, 4u);
    cg_logwork(worka, nonce_bin, ok);
  }
}

//----- (00062E48) --------------------------------------------------------
unsigned __int8 *__cdecl arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg)
{
  size_t v2; // r4
  size_t v3; // r0
  unsigned __int8 *str; // [sp+Ch] [bp+Ch]

  v2 = strlen((const char *)fmt);
  v3 = strlen((const char *)arg);
  str = (unsigned __int8 *)malloc(v2 + v3);
  sprintf((char *)str, (const char *)fmt, arg);
  return str;
}

//----- (00062E84) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_bool(bool *b)
{
  *b = 1;
  return 0;
}

//----- (00062EA0) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_false(bool *b)
{
  *b = 0;
  return 0;
}

//----- (00062EBC) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_invbool(bool *b)
{
  *b = 0;
  return 0;
}

//----- (00062ED8) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_bool_arg(const unsigned __int8 *arg, bool *b)
{
  if ( !strcasecmp((const char *)arg, "yes") || !strcasecmp((const char *)arg, "true") )
    return opt_set_bool(b);
  if ( !strcasecmp((const char *)arg, "no") || !strcasecmp((const char *)arg, "false") )
    return opt_set_invbool(b);
  return opt_invalid_argument(arg);
}

//----- (00062F58) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_invbool_arg(const unsigned __int8 *arg, bool *b)
{
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_bool_arg(arg, b);
  if ( !err )
    *b = !*b;
  return err;
}

//----- (00062F9C) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p)
{
  *p = (unsigned __int8 *)arg;
  return 0;
}

//----- (00062FBC) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_intval(const unsigned __int8 *arg, int *i)
{
  int l; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_longval(arg, &l);
  if ( err )
    return err;
  *i = l;
  if ( *i == l )
    return err;
  else
    return arg_bad("value '%s' does not fit into an integer", arg);
}

//----- (0006300C) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_floatval(const unsigned __int8 *arg, float *f)
{
  int v2; // s0
  unsigned __int8 *endp; // [sp+Ch] [bp+Ch] BYREF

  *_errno_location() = 0;
  strtof(arg, &endp);
  *(_DWORD *)f = v2;
  if ( *endp || !*arg )
    return arg_bad("'%s' is not a number", arg);
  if ( *_errno_location() )
    return arg_bad("'%s' is out of range", arg);
  return 0;
}
// 63032: variable 'v2' is possibly undefined
// A448: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (00063084) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_uintval(const unsigned __int8 *arg, unsigned int *ui)
{
  int i; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_intval(arg, &i);
  if ( err )
    return err;
  if ( i < 0 )
    return arg_bad("'%s' is negative", arg);
  *ui = i;
  return 0;
}

//----- (000630D4) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_longval(const unsigned __int8 *arg, int *l)
{
  unsigned __int8 *endp; // [sp+Ch] [bp+Ch] BYREF

  *_errno_location() = 0;
  *l = strtol((const char *)arg, (char **)&endp, 0);
  if ( *endp || !*arg )
    return arg_bad("'%s' is not a number", arg);
  if ( *_errno_location() )
    return arg_bad("'%s' is out of range", arg);
  return 0;
}

//----- (00063148) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_ulongval(const unsigned __int8 *arg, unsigned int *ul)
{
  int l; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_longval(arg, &l);
  if ( err )
    return err;
  *ul = l;
  if ( l >= 0 )
    return 0;
  else
    return arg_bad("'%s' is negative", arg);
}

//----- (00063198) --------------------------------------------------------
unsigned __int8 *__cdecl opt_inc_intval(int *i)
{
  ++*i;
  return 0;
}

//----- (000631B8) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_version_and_exit(const unsigned __int8 *version)
{
  puts((const char *)version);
  fflush((FILE *)stdout);
  exit(0);
}
// 8A8B4: using guessed type int stdout;

//----- (000631DC) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_usage_and_exit(const unsigned __int8 *extra)
{
  unsigned __int8 *v1; // r0

  v1 = opt_usage(opt_argv0, extra);
  printf("%s", (const char *)v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 8A8B4: using guessed type int stdout;

//----- (0006321C) --------------------------------------------------------
void __cdecl opt_show_bool(unsigned __int8 *buf, const bool *b)
{
  const char *v2; // r3

  if ( *b )
    v2 = "true";
  else
    v2 = "false";
  strncpy((char *)buf, v2, 0x50u);
}

//----- (00063254) --------------------------------------------------------
void __cdecl opt_show_invbool(unsigned __int8 *buf, const bool *b)
{
  const char *v2; // r3

  if ( *b )
    v2 = "false";
  else
    v2 = "true";
  strncpy((char *)buf, v2, 0x50u);
}

//----- (0006328C) --------------------------------------------------------
void __cdecl opt_show_charp(unsigned __int8 *buf, unsigned __int8 *const *p)
{
  size_t len; // [sp+Ch] [bp+Ch]

  len = strlen(*(const char **)p);
  *buf = 34;
  if ( len > 0x4E )
    len = 78;
  strncpy((char *)buf + 1, *(const char **)p, len);
  buf[len + 1] = 34;
  if ( len <= 0x4D )
    buf[len + 2] = 0;
}

//----- (000632EC) --------------------------------------------------------
void __cdecl opt_show_intval(unsigned __int8 *buf, const int *i)
{
  snprintf((char *)buf, 0x50u, "%i", *i);
}

//----- (00063314) --------------------------------------------------------
void __cdecl opt_show_floatval(unsigned __int8 *buf, const float *f)
{
  snprintf((char *)buf, 0x50u, "%.1f", *f);
}

//----- (00063344) --------------------------------------------------------
void __cdecl opt_show_uintval(unsigned __int8 *buf, const unsigned int *ui)
{
  snprintf((char *)buf, 0x50u, "%u", *ui);
}

//----- (0006336C) --------------------------------------------------------
void __cdecl opt_show_longval(unsigned __int8 *buf, const int *l)
{
  snprintf((char *)buf, 0x50u, "%li", *l);
}

//----- (00063394) --------------------------------------------------------
void __cdecl opt_show_ulongval(unsigned __int8 *buf, const unsigned int *ul)
{
  snprintf((char *)buf, 0x50u, "%lu", *ul);
}

//----- (000633BC) --------------------------------------------------------
const unsigned __int8 *__cdecl first_name(const unsigned __int8 *names, unsigned int *len)
{
  *len = strcspn((const char *)names + 1, "|= ");
  return names + 1;
}

//----- (000633EC) --------------------------------------------------------
const unsigned __int8 *__cdecl next_name(const unsigned __int8 *names, unsigned int *len)
{
  const unsigned __int8 *namesa; // [sp+4h] [bp+4h]

  namesa = &names[*len];
  if ( *namesa == 32 || *namesa == 61 || !*namesa )
    return 0;
  else
    return first_name(namesa + 1, len);
}

//----- (00063434) --------------------------------------------------------
const unsigned __int8 *__cdecl first_opt(unsigned int *i, unsigned int *len)
{
  for ( *i = 0; *i < opt_count; ++*i )
  {
    if ( opt_table_0[*i].type != OPT_SUBTABLE )
      return first_name(opt_table_0[*i].names, len);
  }
  return 0;
}

//----- (000634B4) --------------------------------------------------------
const unsigned __int8 *__cdecl next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  while ( *i < opt_count )
  {
    if ( opt_table_0[*i].type != OPT_SUBTABLE )
    {
      if ( !p )
        return first_name(opt_table_0[*i].names, len);
      p = next_name(p, len);
      if ( p )
        return p;
    }
    ++*i;
  }
  return 0;
}

//----- (0006354C) --------------------------------------------------------
const unsigned __int8 *__cdecl first_lopt(unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *p; // [sp+Ch] [bp+Ch]

  for ( p = first_opt(i, len); p; p = next_opt(p, i, len) )
  {
    if ( *p == 45 )
    {
      --*len;
      ++p;
      return p;
    }
  }
  return p;
}

//----- (0006359C) --------------------------------------------------------
const unsigned __int8 *__cdecl next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *pa; // [sp+Ch] [bp+Ch]

  for ( pa = next_opt(p, i, len); pa; pa = next_opt(pa, i, len) )
  {
    if ( *pa == 45 )
    {
      --*len;
      ++pa;
      return pa;
    }
  }
  return pa;
}

//----- (000635F0) --------------------------------------------------------
const unsigned __int8 *__cdecl first_sopt(unsigned int *i)
{
  unsigned int len; // [sp+8h] [bp+8h] BYREF
  const unsigned __int8 *p; // [sp+Ch] [bp+Ch]

  len = 0;
  for ( p = first_opt(i, &len); p && *p == 45; p = next_opt(p, i, &len) )
    ;
  return p;
}

//----- (0006363C) --------------------------------------------------------
const unsigned __int8 *__cdecl next_sopt(const unsigned __int8 *p, unsigned int *i)
{
  const unsigned __int8 *pa; // [sp+4h] [bp+4h]
  unsigned int len; // [sp+Ch] [bp+Ch] BYREF

  len = 1;
  for ( pa = next_opt(p, i, &len); pa && *pa == 45; pa = next_opt(pa, i, &len) )
    ;
  return pa;
}

//----- (0006368C) --------------------------------------------------------
void __cdecl check_opt(const opt_table *entry)
{
  unsigned int len; // [sp+10h] [bp+8h] BYREF
  const unsigned __int8 *p; // [sp+14h] [bp+Ch]

  if ( entry->type != OPT_HASARG && entry->type != OPT_NOARG && entry->type != OPT_PROCESSARG )
    errx(1, "Option %s: unknown entry type %u", (const char *)entry->names, entry->type);
  if ( !entry->desc )
    errx(1, "Option %s: description cannot be NULL", (const char *)entry->names);
  if ( *entry->names != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)entry->names);
  for ( p = first_name(entry->names, &len); p; p = next_name(p, &len) )
  {
    if ( *p == 45 )
    {
      if ( len == 1 )
        errx(1, "Option %s: invalid long option '--'", (const char *)entry->names);
      ++opt_num_long;
    }
    else
    {
      if ( len != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", (const char *)entry->names, len + 1, (const char *)p - 1);
      ++opt_num_short;
      if ( entry->type == OPT_HASARG || entry->type == OPT_PROCESSARG )
        ++opt_num_short_arg;
    }
    if ( entry->type == OPT_NOARG && (p[len] == 32 || p[len] == 61) )
      errx(1, "Option %s: does not take arguments '%s'", (const char *)entry->names, (const char *)&p[len + 1]);
  }
}

//----- (00063800) --------------------------------------------------------
void __cdecl add_opt(const opt_table *entry)
{
  unsigned int v1; // r6
  opt_table *v2; // r4
  opt_type type; // r1
  unsigned __int8 *(*cb)(void *); // r2
  unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *); // r3
  const void *carg; // r1
  const unsigned __int8 *desc; // r2

  opt_table_0 = (opt_table *)realloc(opt_table_0, 28 * (opt_count + 1));
  v1 = opt_count;
  v2 = &opt_table_0[opt_count];
  type = entry->type;
  cb = entry->cb;
  cb_arg = entry->cb_arg;
  v2->names = entry->names;
  v2->type = type;
  v2->cb = cb;
  v2->cb_arg = cb_arg;
  v2 = (opt_table *)((char *)v2 + 16);
  carg = entry->u.carg;
  desc = entry->desc;
  v2->names = (const unsigned __int8 *)entry->show;
  v2->type = (opt_type)carg;
  v2->cb = (unsigned __int8 *(*)(void *))desc;
  opt_count = v1 + 1;
}

//----- (00063880) --------------------------------------------------------
void __cdecl opt_register(
        const unsigned __int8 *names,
        opt_type type,
        unsigned __int8 *(*cb)(void *),
        unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *),
        void (*show)(unsigned __int8 *, const void *),
        const void *arg,
        const unsigned __int8 *desc)
{
  opt_table opt; // [sp+14h] [bp+14h] BYREF

  opt.names = names;
  opt.type = type;
  opt.cb = cb;
  opt.cb_arg = cb_arg;
  opt.show = show;
  opt.u.tlen = (size_t)arg;
  opt.desc = desc;
  check_opt(&opt);
  add_opt(&opt);
}

//----- (000638C8) --------------------------------------------------------
void __cdecl opt_register_table(const opt_table *entry, const unsigned __int8 *desc)
{
  opt_table heading; // [sp+Ch] [bp+Ch] BYREF
  unsigned int start; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  start = opt_count;
  if ( desc )
  {
    heading.names = 0;
    heading.type = OPT_SUBTABLE;
    memset(&heading.cb, 0, 16);
    heading.desc = desc;
    add_opt(&heading);
  }
  for ( i = 0; entry[i].type != OPT_END; ++i )
  {
    if ( entry[i].type == OPT_SUBTABLE )
    {
      opt_register_table((const opt_table *)entry[i].names, entry[i].desc);
    }
    else
    {
      check_opt(&entry[i]);
      add_opt(&entry[i]);
    }
  }
  if ( desc )
    opt_table_0[start].u.tlen = opt_count - start;
}

//----- (000639C4) --------------------------------------------------------
bool __cdecl opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...))
{
  unsigned int offset; // [sp+10h] [bp+10h] BYREF
  int ret; // [sp+14h] [bp+14h]

  offset = 0;
  opt_argv0 = *argv;
  do
    ret = parse_one(argc, argv, &offset, errlog);
  while ( ret == 1 );
  return ret == 0;
}

//----- (00063A14) --------------------------------------------------------
void opt_free_table()
{
  free(opt_table_0);
  opt_table_0 = 0;
}

//----- (00063A38) --------------------------------------------------------
void opt_log_stderr(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+14h] BYREF

  va_start(varg_r1, fmt);
  vfprintf((FILE *)stderr, (const char *)fmt, varg_r1);
  fputc(10, (FILE *)stderr);
}
// 8A8B8: using guessed type int stderr;

//----- (00063A7C) --------------------------------------------------------
void __noreturn opt_log_stderr_exit(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+14h] BYREF

  va_start(varg_r1, fmt);
  vfprintf((FILE *)stderr, (const char *)fmt, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 8A8B8: using guessed type int stderr;

//----- (00063AB8) --------------------------------------------------------
unsigned __int8 *__cdecl opt_invalid_argument(const unsigned __int8 *arg)
{
  size_t v1; // r0
  unsigned __int8 *str; // [sp+Ch] [bp+Ch]

  v1 = strlen((const char *)arg);
  str = (unsigned __int8 *)malloc(v1 + 22);
  sprintf((char *)str, "Invalid argument '%s'", (const char *)arg);
  return str;
}

//----- (00063AF0) --------------------------------------------------------
int __cdecl parse_err(
        void (*errlog)(const unsigned __int8 *, ...),
        const unsigned __int8 *argv0,
        const unsigned __int8 *arg,
        unsigned int len,
        const unsigned __int8 *problem)
{
  errlog("%s: %.*s: %s", (const char *)argv0, len, (const char *)arg, (const char *)problem);
  return -1;
}

//----- (00063B24) --------------------------------------------------------
void __cdecl consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum)
{
  memmove(&argv[optnum], &argv[optnum + 1], 4 * (*argc - optnum));
  --*argc;
}

//----- (00063B6C) --------------------------------------------------------
int __cdecl parse_one(
        int *argc,
        unsigned __int8 **argv,
        unsigned int *offset,
        void (*errlog)(const unsigned __int8 *, ...))
{
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int len; // [sp+18h] [bp+10h] BYREF
  unsigned int i; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 *problem; // [sp+20h] [bp+18h]
  const unsigned __int8 *optarg; // [sp+24h] [bp+1Ch]
  const unsigned __int8 *o; // [sp+28h] [bp+20h]
  unsigned int arg; // [sp+2Ch] [bp+24h]

  optarg = 0;
  if ( getenv("POSIXLY_CORRECT") )
  {
    arg = 1;
  }
  else
  {
    for ( arg = 1; argv[arg] && *argv[arg] != 45; ++arg )
      ;
  }
  if ( !argv[arg] || *argv[arg] != 45 )
    return 0;
  if ( !strcmp((const char *)argv[arg], "--") )
  {
    consume_option(argc, argv, arg);
    return 0;
  }
  else
  {
    if ( argv[arg][1] == 45 )
    {
      if ( *offset )
        _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, (const char *)_PRETTY_FUNCTION___5165);
      for ( o = first_lopt(&i, &len); o; o = next_lopt(o, &i, &len) )
      {
        if ( !strncmp((const char *)argv[arg] + 2, (const char *)o, len) )
        {
          if ( argv[arg][len + 2] == 61 )
          {
            optarg = &argv[arg][len + 3];
            break;
          }
          if ( !argv[arg][len + 2] )
            break;
        }
      }
      if ( !o )
      {
        v5 = strlen((const char *)argv[arg]);
        return parse_err(errlog, *argv, argv[arg], v5, "unrecognized option");
      }
      o -= 2;
      len += 2;
    }
    else
    {
      for ( o = first_sopt(&i); o; o = next_sopt(o, &i) )
      {
        if ( argv[arg][*offset + 1] == *o )
        {
          ++*offset;
          break;
        }
      }
      if ( !o )
      {
        v6 = strlen((const char *)argv[arg]);
        return parse_err(errlog, *argv, argv[arg], v6, "unrecognized option");
      }
      --o;
      len = 2;
    }
    if ( opt_table_0[i].type == OPT_NOARG )
    {
      if ( optarg )
        return parse_err(errlog, *argv, o, len, "doesn't allow an argument");
      problem = opt_table_0[i].cb(opt_table_0[i].u.tlen);
    }
    else
    {
      if ( !optarg )
      {
        if ( *offset && argv[arg][*offset + 1] )
        {
          optarg = &argv[arg][*offset + 1];
          *offset = 0;
        }
        else
        {
          optarg = argv[arg + 1];
        }
      }
      if ( !optarg )
        return parse_err(errlog, *argv, o, len, "requires an argument");
      if ( opt_table_0[i].type == OPT_PROCESSARG )
        opt_set_charp(optarg, (unsigned __int8 **)opt_table_0[i].u.carg);
      problem = opt_table_0[i].cb_arg(optarg, opt_table_0[i].u.tlen);
    }
    if ( problem )
    {
      parse_err(errlog, *argv, o, len, problem);
      free(problem);
      return -1;
    }
    else
    {
      if ( *offset && !argv[arg][*offset + 1] )
        *offset = 0;
      if ( !*offset )
      {
        consume_option(argc, argv, arg);
        if ( optarg )
        {
          if ( argv[arg] == optarg )
            consume_option(argc, argv, arg);
        }
      }
      return 1;
    }
  }
}

//----- (00063FB4) --------------------------------------------------------
unsigned int __cdecl write_short_options(unsigned __int8 *str)
{
  unsigned int i; // [sp+Ch] [bp+Ch] BYREF
  const unsigned __int8 *p; // [sp+10h] [bp+10h]
  unsigned int num; // [sp+14h] [bp+14h]

  num = 0;
  for ( p = first_sopt(&i); p; p = next_sopt(p, &i) )
  {
    if ( opt_table_0[i].desc != opt_hidden )
      str[num++] = *p;
  }
  return num;
}

//----- (00064024) --------------------------------------------------------
unsigned __int8 *__cdecl opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra)
{
  size_t v2; // r4
  int v4; // r0
  unsigned int v5; // r3
  int v6; // r0
  int v7; // r0
  int v8; // r0
  const unsigned __int8 *extraa; // [sp+0h] [bp+0h]
  unsigned __int8 buf[84]; // [sp+8h] [bp+8h] BYREF
  unsigned int num; // [sp+5Ch] [bp+5Ch]
  unsigned __int8 *ret; // [sp+60h] [bp+60h]
  unsigned __int8 *p; // [sp+64h] [bp+64h]
  unsigned int len; // [sp+68h] [bp+68h]
  unsigned int i; // [sp+6Ch] [bp+6Ch]

  extraa = extra;
  if ( !extra )
  {
    extraa = (const unsigned __int8 *)&unk_7C728;
    for ( i = 0; i < opt_count; ++i )
    {
      if ( (unsigned __int8 *(__cdecl *)(const unsigned __int8 *))opt_table_0[i].cb == opt_usage_and_exit
        && opt_table_0[i].u.tlen )
      {
        extraa = (const unsigned __int8 *)opt_table_0[i].u.carg;
        break;
      }
    }
  }
  v2 = strlen((const char *)argv0) + opt_num_short;
  len = v2 + strlen((const char *)extraa) + 20;
  for ( i = 0; i < opt_count; ++i )
  {
    if ( opt_table_0[i].type == OPT_SUBTABLE )
    {
      len += strlen((const char *)opt_table_0[i].desc) + 3;
    }
    else if ( opt_table_0[i].desc != opt_hidden )
    {
      len += strlen((const char *)opt_table_0[i].names) + 6;
      len += strlen((const char *)opt_table_0[i].desc) + 21;
      if ( opt_table_0[i].show )
        len += 97;
      ++len;
    }
  }
  ret = (unsigned __int8 *)malloc(len);
  p = ret;
  if ( !ret )
    return 0;
  p += sprintf((char *)p, "Usage: %s", (const char *)argv0);
  *(_DWORD *)p = &scanfreq_info.asic_core_nonce_num[3][255][235];
  p += 3;
  num = write_short_options(p);
  if ( num )
  {
    p += num;
    strcpy((char *)p++, "]");
  }
  else
  {
    p -= 3;
  }
  if ( extraa )
    p += sprintf((char *)p, " %s", (const char *)extraa);
  strcpy((char *)p++, "\n");
  for ( i = 0; i < opt_count; ++i )
  {
    if ( opt_table_0[i].desc != opt_hidden )
    {
      if ( opt_table_0[i].type == OPT_SUBTABLE )
      {
        v4 = sprintf((char *)p, "%s:\n", (const char *)opt_table_0[i].desc);
        p += v4;
      }
      else
      {
        len = sprintf((char *)p, "%s", (const char *)opt_table_0[i].names);
        if ( opt_table_0[i].type == OPT_HASARG
          && !strchr((const char *)opt_table_0[i].names, 32)
          && !strchr((const char *)opt_table_0[i].names, 61) )
        {
          strcpy((char *)&p[len], " <arg>");
          len += 6;
        }
        if ( len > 0x13 )
          v5 = 1;
        else
          v5 = 20 - len;
        v6 = sprintf((char *)&p[len], "%.*s", v5, "                    ");
        len += v6;
        v7 = sprintf((char *)&p[len], "%s", (const char *)opt_table_0[i].desc);
        len += v7;
        if ( opt_table_0[i].show )
        {
          strcpy((char *)&buf[80], "...");
          opt_table_0[i].show(buf, (const void *)opt_table_0[i].u.tlen);
          v8 = sprintf((char *)&p[len], " (default: %s)", (const char *)buf);
          len += v8;
        }
        p += len;
        strcpy((char *)p++, "\n");
      }
    }
  }
  *p = 0;
  return ret;
}

//----- (000644EC) --------------------------------------------------------
int __cdecl dump_to_strbuffer(const unsigned __int8 *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
}

//----- (00064510) --------------------------------------------------------
int __cdecl dump_to_file(const unsigned __int8 *buffer, size_t size, void *data)
{
  if ( fwrite(buffer, size, 1u, (FILE *)data) == 1 )
    return 0;
  else
    return -1;
}

//----- (00064544) --------------------------------------------------------
int __cdecl dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data)
{
  size_t v6; // r3
  int cur_n; // [sp+14h] [bp+14h]
  unsigned int n_spaces; // [sp+1Ch] [bp+1Ch]

  if ( (flags & 0x1F) == 0 )
  {
    if ( space && (flags & 0x20) == 0 )
      return dump(byte_7C7B4, 1, data);
    return 0;
  }
  n_spaces = (flags & 0x1F) * depth;
  if ( !dump(byte_7C7B0, 1, data) )
  {
    while ( n_spaces )
    {
      v6 = n_spaces;
      if ( n_spaces >= 0x20 )
        v6 = 32;
      cur_n = v6;
      if ( dump(whitespace, v6, data) )
        return -1;
      n_spaces -= cur_n;
    }
    return 0;
  }
  return -1;
}
// 7C7B0: using guessed type unsigned __int8 byte_7C7B0[4];
// 7C7B4: using guessed type unsigned __int8 byte_7C7B4[4];

//----- (000645F4) --------------------------------------------------------
int __cdecl dump_string(const unsigned __int8 *str, size_t len, json_dump_callback_t dump, void *data, size_t flags)
{
  unsigned __int8 seq[13]; // [sp+18h] [bp+10h] BYREF
  int32_t codepoint; // [sp+28h] [bp+20h] BYREF
  int32_t last; // [sp+2Ch] [bp+24h]
  int32_t first; // [sp+30h] [bp+28h]
  const unsigned __int8 *lim; // [sp+34h] [bp+2Ch]
  int length; // [sp+38h] [bp+30h]
  const unsigned __int8 *text; // [sp+3Ch] [bp+34h]
  const unsigned __int8 *end; // [sp+40h] [bp+38h]
  const unsigned __int8 *pos; // [sp+44h] [bp+3Ch]

  if ( !dump(byte_7C7B8, 1, data) )
  {
    pos = str;
    end = str;
    lim = &str[len];
    while ( 1 )
    {
      while ( end < lim )
      {
        end = utf8_iterate(pos, lim - pos, &codepoint);
        if ( !end )
          return -1;
        if ( codepoint == 92
          || codepoint == 34
          || codepoint <= 31
          || (flags & 0x400) != 0 && codepoint == 47
          || (flags & 0x40) != 0 && codepoint > 127 )
        {
          break;
        }
        pos = end;
      }
      if ( pos != str && dump(str, pos - str, data) )
        return -1;
      if ( end == pos )
        return dump(byte_7C7B8, 1, data);
      length = 2;
      if ( codepoint == 12 )
      {
        text = (const unsigned __int8 *)&unk_7C7C8;
        goto LABEL_43;
      }
      if ( codepoint > 12 )
      {
        if ( codepoint == 34 )
        {
          text = (const unsigned __int8 *)&unk_7C7C0;
          goto LABEL_43;
        }
        if ( codepoint > 34 )
        {
          if ( codepoint == 47 )
          {
            text = (const unsigned __int8 *)&unk_7C7D8;
            goto LABEL_43;
          }
          if ( codepoint == 92 )
          {
            text = (const unsigned __int8 *)&unk_7C7BC;
            goto LABEL_43;
          }
        }
        else if ( codepoint == 13 )
        {
          text = (const unsigned __int8 *)&unk_7C7D0;
          goto LABEL_43;
        }
      }
      else
      {
        switch ( codepoint )
        {
          case 9:
            text = (const unsigned __int8 *)&unk_7C7D4;
            goto LABEL_43;
          case 10:
            text = (const unsigned __int8 *)&unk_7C7CC;
            goto LABEL_43;
          case 8:
            text = (const unsigned __int8 *)&unk_7C7C4;
            goto LABEL_43;
        }
      }
      if ( codepoint > 0xFFFF )
      {
        codepoint -= 0x10000;
        first = ((int)((unsigned int)&nonce_num[7][56][49] & codepoint) >> 10) | 0xD800;
        last = codepoint & 0x3FF | 0xDC00;
        snprintf((char *)seq, 0xDu, "\\u%04X\\u%04X", first, last);
        length = 12;
      }
      else
      {
        snprintf((char *)seq, 0xDu, "\\u%04X", codepoint);
        length = 6;
      }
      text = seq;
LABEL_43:
      if ( dump(text, length, data) )
        return -1;
      pos = end;
      str = end;
    }
  }
  return -1;
}
// 7C7B8: using guessed type unsigned __int8 byte_7C7B8[4];

//----- (00064810) --------------------------------------------------------
int __cdecl compare_keys(const void *key1, const void *key2)
{
  return strcmp(*(const char **)key1, *(const char **)key2);
}

//----- (00064838) --------------------------------------------------------
int __cdecl do_dump(const json_t_0 *json, size_t flags, int depth, json_dump_callback_t dump, void *data)
{
  double v5; // d0
  json_int_t v7; // r0
  double v8; // r2
  const unsigned __int8 *v9; // r4
  size_t v10; // r0
  json_t_0 *v11; // r0
  size_t v12; // r0
  size_t v13; // r0
  json_t_0 *v14; // r0
  int precision; // [sp+0h] [bp-8h]
  unsigned __int8 buffer[100]; // [sp+1Ch] [bp+14h] BYREF
  const unsigned __int8 *key_0; // [sp+80h] [bp+78h]
  void *next; // [sp+84h] [bp+7Ch]
  json_t_0 *value_0; // [sp+88h] [bp+80h]
  const unsigned __int8 *key; // [sp+8Ch] [bp+84h]
  const unsigned __int8 **keys; // [sp+90h] [bp+88h]
  size_t size_1; // [sp+94h] [bp+8Ch]
  json_object_t *object; // [sp+98h] [bp+90h]
  size_t n; // [sp+9Ch] [bp+94h]
  json_array_t *array; // [sp+A0h] [bp+98h]
  int size_0; // [sp+A4h] [bp+9Ch]
  double value; // [sp+A8h] [bp+A0h]
  int size; // [sp+B0h] [bp+A8h]
  size_t i_0; // [sp+B4h] [bp+ACh]
  int separator_length; // [sp+B8h] [bp+B0h]
  const unsigned __int8 *separator; // [sp+BCh] [bp+B4h]
  void *iter; // [sp+C0h] [bp+B8h]
  size_t i; // [sp+C4h] [bp+BCh]

  if ( json )
  {
    switch ( json->type )
    {
      case JSON_OBJECT:
        if ( (flags & 0x20) != 0 )
        {
          separator = ":";
          separator_length = 1;
        }
        else
        {
          separator = ": ";
          separator_length = 2;
        }
        object = (json_object_t *)json;
        if ( json[4].refcount )
          goto object_error;
        object->visited = 1;
        iter = json_object_iter((json_t_0 *)json);
        if ( dump("{", 1, data) )
          goto object_error;
        if ( !iter )
          goto LABEL_37;
        if ( dump_indent(flags, depth + 1, 0, dump, data) )
          goto object_error;
        if ( (flags & 0x80) != 0 )
        {
          size_1 = json_object_size(json);
          keys = (const unsigned __int8 **)jsonp_malloc(4 * size_1);
          if ( !keys )
          {
object_error:
            object->visited = 0;
            return -1;
          }
          i_0 = 0;
          while ( iter )
          {
            keys[i_0] = json_object_iter_key(iter);
            iter = json_object_iter_next((json_t_0 *)json, iter);
            ++i_0;
          }
          if ( i_0 != size_1 )
            _assert_fail("i == size", "compat/jansson-2.9/src/dump.c", 0x152u, (const char *)_PRETTY_FUNCTION___6031);
          qsort(keys, size_1, 4u, (__compar_fn_t)compare_keys);
          for ( i_0 = 0; i_0 < size_1; ++i_0 )
          {
            key = keys[i_0];
            value_0 = json_object_get(json, key);
            if ( !value_0 )
              _assert_fail("value", "compat/jansson-2.9/src/dump.c", 0x15Du, (const char *)_PRETTY_FUNCTION___6031);
            v12 = strlen((const char *)key);
            dump_string(key, v12, dump, data, flags);
            if ( dump(separator, separator_length, data) || do_dump(value_0, flags, depth + 1, dump, data) )
            {
LABEL_57:
              jsonp_free(keys);
              goto object_error;
            }
            if ( size_1 - 1 <= i_0 )
            {
              if ( dump_indent(flags, depth, 0, dump, data) )
                goto LABEL_57;
            }
            else if ( dump(",", 1, data) || dump_indent(flags, depth + 1, 1, dump, data) )
            {
              goto LABEL_57;
            }
          }
          jsonp_free(keys);
        }
        else
        {
          while ( iter )
          {
            next = json_object_iter_next((json_t_0 *)json, iter);
            key_0 = json_object_iter_key(iter);
            v13 = strlen((const char *)key_0);
            dump_string(key_0, v13, dump, data, flags);
            if ( dump(separator, separator_length, data) )
              goto object_error;
            v14 = json_object_iter_value(iter);
            if ( do_dump(v14, flags, depth + 1, dump, data) )
              goto object_error;
            if ( next )
            {
              if ( dump(",", 1, data) || dump_indent(flags, depth + 1, 1, dump, data) )
                goto object_error;
            }
            else if ( dump_indent(flags, depth, 0, dump, data) )
            {
              goto object_error;
            }
            iter = next;
          }
        }
LABEL_37:
        object->visited = 0;
        return dump("}", 1, data);
      case JSON_ARRAY:
        array = (json_array_t *)json;
        if ( json[2].refcount )
          goto array_error;
        array->visited = 1;
        n = json_array_size(json);
        if ( dump("[", 1, data) )
          goto array_error;
        if ( !n )
          goto LABEL_18;
        if ( dump_indent(flags, depth + 1, 0, dump, data) )
          goto array_error;
        i = 0;
        while ( 2 )
        {
          if ( i >= n )
          {
LABEL_18:
            array->visited = 0;
            return dump("]", 1, data);
          }
          v11 = json_array_get(json, i);
          if ( do_dump(v11, flags, depth + 1, dump, data) )
            break;
          if ( n - 1 <= i )
          {
            if ( !dump_indent(flags, depth, 0, dump, data) )
            {
LABEL_27:
              ++i;
              continue;
            }
          }
          else if ( !dump(",", 1, data) && !dump_indent(flags, depth + 1, 1, dump, data) )
          {
            goto LABEL_27;
          }
          break;
        }
array_error:
        array->visited = 0;
        return -1;
      case JSON_STRING:
        v9 = json_string_value(json);
        v10 = json_string_length(json);
        return dump_string(v9, v10, dump, data, flags);
      case JSON_INTEGER:
        v7 = json_integer_value(json);
        size = snprintf((char *)buffer, 0x64u, "%lld", v7);
        if ( size >= 0 && size <= 99 )
          return dump(buffer, size, data);
        else
          return -1;
      case JSON_REAL:
        json_real_value(json);
        value = v5;
        HIDWORD(v8) = (unsigned __int16)flags >> 11;
        LODWORD(v8) = HIDWORD(v8);
        size_0 = jsonp_dtostr(buffer, 0x64u, v8, precision);
        if ( size_0 >= 0 )
          return dump(buffer, size_0, data);
        else
          return -1;
      case JSON_TRUE:
        return dump("true", 4, data);
      case JSON_FALSE:
        return dump("false", 5, data);
      case JSON_NULL:
        return dump("null", 4, data);
      default:
        return -1;
    }
  }
  return -1;
}
// 64920: variable 'v5' is possibly undefined
// 6493A: variable 'precision' is possibly undefined

//----- (00064EAC) --------------------------------------------------------
unsigned __int8 *__cdecl json_dumps(const json_t_0 *json, size_t flags)
{
  const unsigned __int8 *v3; // r0
  strbuffer_t strbuff; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *result; // [sp+14h] [bp+14h]

  if ( strbuffer_init(&strbuff) )
    return 0;
  if ( json_dump_callback(json, (json_dump_callback_t)dump_to_strbuffer, &strbuff, flags) )
  {
    result = 0;
  }
  else
  {
    v3 = strbuffer_value(&strbuff);
    result = jsonp_strdup(v3);
  }
  strbuffer_close(&strbuff);
  return result;
}

//----- (00064F18) --------------------------------------------------------
int __cdecl json_dumpf(const json_t_0 *json, FILE *output, size_t flags)
{
  return json_dump_callback(json, (json_dump_callback_t)dump_to_file, output, flags);
}

//----- (00064F44) --------------------------------------------------------
int __cdecl json_dump_file(const json_t_0 *json, const unsigned __int8 *path, size_t flags)
{
  int result; // [sp+10h] [bp+10h]
  FILE *output; // [sp+14h] [bp+14h]

  output = fopen((const char *)path, "w");
  if ( !output )
    return -1;
  result = json_dumpf(json, output, flags);
  fclose(output);
  return result;
}

//----- (00064F8C) --------------------------------------------------------
int __cdecl json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags)
{
  if ( (flags & 0x200) != 0 || json && json->type == JSON_ARRAY || json && json->type == JSON_OBJECT )
    return do_dump(json, (unsigned __int16)flags, 0, callback, data);
  else
    return -1;
}

//----- (00064FE4) --------------------------------------------------------
void __cdecl jsonp_error_init(json_error_t *error, const unsigned __int8 *source)
{
  if ( error )
  {
    error->text[0] = 0;
    error->line = -1;
    error->column = -1;
    error->position = 0;
    if ( source )
      jsonp_error_set_source(error, source);
    else
      error->source[0] = 0;
  }
}

//----- (00065030) --------------------------------------------------------
void __cdecl jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source)
{
  size_t length; // [sp+Ch] [bp+Ch]

  if ( error && source )
  {
    length = strlen((const char *)source);
    if ( length > 0x4F )
    {
      *(_WORD *)error->source = 11822;
      error->source[2] = 46;
      strncpy((char *)&error->source[3], (const char *)&source[length - 76], 0x4Du);
    }
    else
    {
      strncpy((char *)error->source, (const char *)source, length + 1);
    }
  }
}

//----- (000650B0) --------------------------------------------------------
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...)
{
  va_list va; // [sp+2Ch] [bp+24h] BYREF

  va_start(va, msg);
  jsonp_error_vset(error, line, column, position, msg, va);
}

//----- (000650E0) --------------------------------------------------------
void __cdecl jsonp_error_vset(
        json_error_t *error,
        int line,
        int column,
        size_t position,
        const unsigned __int8 *msg,
        va_list ap)
{
  if ( error )
  {
    if ( !error->text[0] )
    {
      error->line = line;
      error->column = column;
      error->position = position;
      vsnprintf((char *)error->text, 0xA0u, (const char *)msg, ap);
      error->text[159] = 0;
    }
  }
}

//----- (00065138) --------------------------------------------------------
void __cdecl json_decref_2(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (00065170) --------------------------------------------------------
uint32_t __cdecl hashlittle(const void *key, size_t length, uint32_t initval)
{
  size_t lengtha; // [sp+8h] [bp+8h]
  const uint8_t *k_1; // [sp+20h] [bp+20h]
  const uint16_t *k_0; // [sp+24h] [bp+24h]
  const uint32_t *k; // [sp+28h] [bp+28h]
  int c; // [sp+2Ch] [bp+2Ch]
  uint32_t ca; // [sp+2Ch] [bp+2Ch]
  uint32_t cb; // [sp+2Ch] [bp+2Ch]
  int cc; // [sp+2Ch] [bp+2Ch]
  uint32_t cd; // [sp+2Ch] [bp+2Ch]
  uint32_t ce; // [sp+2Ch] [bp+2Ch]
  uint32_t cf; // [sp+2Ch] [bp+2Ch]
  int cg; // [sp+2Ch] [bp+2Ch]
  uint32_t ch; // [sp+2Ch] [bp+2Ch]
  uint32_t ci; // [sp+2Ch] [bp+2Ch]
  uint32_t cj; // [sp+2Ch] [bp+2Ch]
  int ck; // [sp+2Ch] [bp+2Ch]
  uint32_t cl; // [sp+2Ch] [bp+2Ch]
  uint32_t cm; // [sp+2Ch] [bp+2Ch]
  uint32_t cn; // [sp+2Ch] [bp+2Ch]
  uint32_t b; // [sp+30h] [bp+30h]
  uint32_t ba; // [sp+30h] [bp+30h]
  int bb; // [sp+30h] [bp+30h]
  uint32_t bc; // [sp+30h] [bp+30h]
  int bd; // [sp+30h] [bp+30h]
  uint32_t be; // [sp+30h] [bp+30h]
  int bf; // [sp+30h] [bp+30h]
  uint32_t bg; // [sp+30h] [bp+30h]
  int bh; // [sp+30h] [bp+30h]
  uint32_t bi; // [sp+30h] [bp+30h]
  int bj; // [sp+30h] [bp+30h]
  uint32_t bk; // [sp+30h] [bp+30h]
  int bl; // [sp+30h] [bp+30h]
  uint32_t bm; // [sp+30h] [bp+30h]
  uint32_t bn; // [sp+30h] [bp+30h]
  uint32_t a; // [sp+34h] [bp+34h]
  int aa; // [sp+34h] [bp+34h]
  uint32_t ab; // [sp+34h] [bp+34h]
  int ac; // [sp+34h] [bp+34h]
  int ad; // [sp+34h] [bp+34h]
  uint32_t ae; // [sp+34h] [bp+34h]
  int af; // [sp+34h] [bp+34h]
  int ag; // [sp+34h] [bp+34h]
  uint32_t ah; // [sp+34h] [bp+34h]
  int ai; // [sp+34h] [bp+34h]
  uint32_t aj; // [sp+34h] [bp+34h]
  uint32_t ak; // [sp+34h] [bp+34h]

  lengtha = length;
  c = length + initval - 559038737;
  b = c;
  a = c;
  if ( ((unsigned __int8)key & 3) != 0 )
  {
    if ( ((unsigned __int8)key & 1) != 0 )
    {
      k_1 = (const uint8_t *)key;
      while ( lengtha > 0xC )
      {
        bi = b + k_1[4] + (k_1[5] << 8) + (k_1[6] << 16) + (k_1[7] << 24);
        ci = c + k_1[8] + (k_1[9] << 8) + (k_1[10] << 16) + (k_1[11] << 24);
        ag = __ROR4__(ci, 28) ^ (a + *k_1 + (k_1[1] << 8) + (k_1[2] << 16) + (k_1[3] << 24) - ci);
        cj = ci + bi;
        bj = __ROR4__(ag, 26) ^ (bi - ag);
        ah = ag + cj;
        ck = __ROR4__(bj, 24) ^ (cj - bj);
        bk = bj + ah;
        ai = __ROR4__(ck, 16) ^ (ah - ck);
        cl = ck + bk;
        bl = __ROR4__(ai, 13) ^ (bk - ai);
        a = ai + cl;
        c = __ROR4__(bl, 28) ^ (cl - bl);
        b = bl + a;
        lengtha -= 12;
        k_1 += 12;
      }
      switch ( lengtha )
      {
        case 0u:
          return c;
        case 1u:
          goto LABEL_52;
        case 2u:
          goto LABEL_51;
        case 3u:
          goto LABEL_50;
        case 4u:
          goto LABEL_49;
        case 5u:
          goto LABEL_48;
        case 6u:
          goto LABEL_47;
        case 7u:
          goto LABEL_46;
        case 8u:
          goto LABEL_45;
        case 9u:
          goto LABEL_44;
        case 0xAu:
          goto LABEL_43;
        case 0xBu:
          goto LABEL_42;
        case 0xCu:
          c += k_1[11] << 24;
LABEL_42:
          c += k_1[10] << 16;
LABEL_43:
          c += k_1[9] << 8;
LABEL_44:
          c += k_1[8];
LABEL_45:
          b += k_1[7] << 24;
LABEL_46:
          b += k_1[6] << 16;
LABEL_47:
          b += k_1[5] << 8;
LABEL_48:
          b += k_1[4];
LABEL_49:
          a += k_1[3] << 24;
LABEL_50:
          a += k_1[2] << 16;
LABEL_51:
          a += k_1[1] << 8;
LABEL_52:
          a += *k_1;
          break;
        default:
          break;
      }
    }
    else
    {
      k_0 = (const uint16_t *)key;
      while ( lengtha > 0xC )
      {
        be = b + k_0[2] + (k_0[3] << 16);
        ce = c + k_0[4] + (k_0[5] << 16);
        ad = __ROR4__(ce, 28) ^ (a + *k_0 + (k_0[1] << 16) - ce);
        cf = ce + be;
        bf = __ROR4__(ad, 26) ^ (be - ad);
        ae = ad + cf;
        cg = __ROR4__(bf, 24) ^ (cf - bf);
        bg = bf + ae;
        af = __ROR4__(cg, 16) ^ (ae - cg);
        ch = cg + bg;
        bh = __ROR4__(af, 13) ^ (bg - af);
        a = af + ch;
        c = __ROR4__(bh, 28) ^ (ch - bh);
        b = bh + a;
        lengtha -= 12;
        k_0 += 6;
      }
      switch ( lengtha )
      {
        case 0u:
          return c;
        case 1u:
          a += *(unsigned __int8 *)k_0;
          break;
        case 2u:
          goto LABEL_34;
        case 3u:
          a += *((unsigned __int8 *)k_0 + 2) << 16;
LABEL_34:
          a += *k_0;
          break;
        case 4u:
          goto LABEL_32;
        case 5u:
          b += *((unsigned __int8 *)k_0 + 4);
LABEL_32:
          a += *k_0 + (k_0[1] << 16);
          break;
        case 6u:
          goto LABEL_30;
        case 7u:
          b += *((unsigned __int8 *)k_0 + 6) << 16;
LABEL_30:
          b += k_0[2];
          a += *k_0 + (k_0[1] << 16);
          break;
        case 8u:
          goto LABEL_28;
        case 9u:
          c += *((unsigned __int8 *)k_0 + 8);
LABEL_28:
          b += k_0[2] + (k_0[3] << 16);
          a += *k_0 + (k_0[1] << 16);
          break;
        case 0xAu:
          goto LABEL_26;
        case 0xBu:
          c += *((unsigned __int8 *)k_0 + 10) << 16;
LABEL_26:
          c += k_0[4];
          b += k_0[2] + (k_0[3] << 16);
          a += *k_0 + (k_0[1] << 16);
          break;
        case 0xCu:
          c += k_0[4] + (k_0[5] << 16);
          b += k_0[2] + (k_0[3] << 16);
          a += *k_0 + (k_0[1] << 16);
          break;
        default:
          break;
      }
    }
  }
  else
  {
    k = (const uint32_t *)key;
    while ( lengtha > 0xC )
    {
      ba = b + k[1];
      ca = c + k[2];
      aa = __ROR4__(ca, 28) ^ (a + *k - ca);
      cb = ca + ba;
      bb = __ROR4__(aa, 26) ^ (ba - aa);
      ab = aa + cb;
      cc = __ROR4__(bb, 24) ^ (cb - bb);
      bc = bb + ab;
      ac = __ROR4__(cc, 16) ^ (ab - cc);
      cd = cc + bc;
      bd = __ROR4__(ac, 13) ^ (bc - ac);
      a = ac + cd;
      c = __ROR4__(bd, 28) ^ (cd - bd);
      b = bd + a;
      lengtha -= 12;
      k += 3;
    }
    switch ( lengtha )
    {
      case 0u:
        return c;
      case 1u:
        goto LABEL_17;
      case 2u:
        goto LABEL_16;
      case 3u:
        a += *((unsigned __int8 *)k + 2) << 16;
LABEL_16:
        a += *((unsigned __int8 *)k + 1) << 8;
LABEL_17:
        a += *(unsigned __int8 *)k;
        break;
      case 4u:
        goto LABEL_14;
      case 5u:
        goto LABEL_13;
      case 6u:
        goto LABEL_12;
      case 7u:
        b += *((unsigned __int8 *)k + 6) << 16;
LABEL_12:
        b += *((unsigned __int8 *)k + 5) << 8;
LABEL_13:
        b += *((unsigned __int8 *)k + 4);
LABEL_14:
        a += *k;
        break;
      case 8u:
        goto LABEL_10;
      case 9u:
        goto LABEL_9;
      case 0xAu:
        goto LABEL_8;
      case 0xBu:
        c += *((unsigned __int8 *)k + 10) << 16;
LABEL_8:
        c += *((unsigned __int8 *)k + 9) << 8;
LABEL_9:
        c += *((unsigned __int8 *)k + 8);
LABEL_10:
        b += k[1];
        a += *k;
        break;
      case 0xCu:
        c += k[2];
        b += k[1];
        a += *k;
        break;
      default:
        break;
    }
  }
  cm = (b ^ c) - __ROR4__(b, 18);
  aj = (cm ^ a) - __ROR4__(cm, 21);
  bm = (aj ^ b) - __ROR4__(aj, 7);
  cn = (bm ^ cm) - __ROR4__(bm, 16);
  ak = (cn ^ aj) - __ROR4__(cn, 28);
  bn = (ak ^ bm) - __ROR4__(ak, 18);
  return (bn ^ cn) - __ROR4__(bn, 8);
}

//----- (00065924) --------------------------------------------------------
void __cdecl list_init(list_t *list)
{
  list->next = list;
  list->prev = list;
}

//----- (00065944) --------------------------------------------------------
void __cdecl list_insert(list_t *list, list_t *node)
{
  node->next = list;
  node->prev = list->prev;
  list->prev->next = node;
  list->prev = node;
}

//----- (00065974) --------------------------------------------------------
void __cdecl list_remove(list_t *list)
{
  list->prev->next = list->next;
  list->next->prev = list->prev;
}

//----- (0006599C) --------------------------------------------------------
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket)
{
  return bucket->first == &hashtable->list && bucket->first == bucket->last;
}

//----- (000659D0) --------------------------------------------------------
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list)
{
  if ( bucket_is_empty(hashtable, bucket) )
  {
    list_insert(&hashtable->list, list);
    bucket->last = list;
    bucket->first = bucket->last;
  }
  else
  {
    list_insert(bucket->first, list);
    bucket->first = list;
  }
}

//----- (00065A20) --------------------------------------------------------
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const unsigned __int8 *key, size_t hash)
{
  pair_t *list; // [sp+14h] [bp+14h]

  if ( bucket_is_empty(hashtable, bucket) )
    return 0;
  for ( list = (pair_t *)bucket->first; ; list = (pair_t *)list->list.next )
  {
    if ( list->hash == hash && !strcmp((const char *)list->key, (const char *)key) )
      return list;
    if ( (pair_t *)bucket->last == list )
      break;
  }
  return 0;
}

//----- (00065A8C) --------------------------------------------------------
int __cdecl hashtable_do_del(hashtable_t *hashtable, const unsigned __int8 *key, size_t hash)
{
  pair_t *pair; // [sp+14h] [bp+14h]
  bucket_t *bucket; // [sp+18h] [bp+18h]

  bucket = &hashtable->buckets[hash & ((1 << hashtable->order) - 1)];
  pair = hashtable_find_pair(hashtable, bucket, key, hash);
  if ( !pair )
    return -1;
  if ( pair == (pair_t *)bucket->first && pair == (pair_t *)bucket->last )
  {
    bucket->last = &hashtable->list;
    bucket->first = bucket->last;
  }
  else if ( pair == (pair_t *)bucket->first )
  {
    bucket->first = pair->list.next;
  }
  else if ( pair == (pair_t *)bucket->last )
  {
    bucket->last = pair->list.prev;
  }
  list_remove(&pair->list);
  list_remove(&pair->ordered_list);
  json_decref_2(pair->value);
  jsonp_free(pair);
  --hashtable->size;
  return 0;
}

//----- (00065B58) --------------------------------------------------------
void __cdecl hashtable_do_clear(hashtable_t *hashtable)
{
  list_t *next; // [sp+10h] [bp+10h]
  hashtable_list *list; // [sp+14h] [bp+14h]

  for ( list = hashtable->list.next; &hashtable->list != list; list = next )
  {
    next = list->next;
    json_decref_2((json_t_0 *)list[2].next);
    jsonp_free(list);
  }
}

//----- (00065B9C) --------------------------------------------------------
int __cdecl hashtable_do_rehash(hashtable_t *hashtable)
{
  size_t order; // r3
  hashtable_bucket *v3; // r2
  list_t *next; // [sp+10h] [bp+10h]
  hashtable_bucket *new_buckets; // [sp+14h] [bp+14h]
  size_t new_size; // [sp+18h] [bp+18h]
  size_t new_order; // [sp+1Ch] [bp+1Ch]
  size_t i; // [sp+20h] [bp+20h]
  hashtable_t *list; // [sp+24h] [bp+24h]

  order = hashtable->order;
  new_order = order + 1;
  new_size = 1 << (order + 1);
  new_buckets = (hashtable_bucket *)jsonp_malloc(8 * new_size);
  if ( !new_buckets )
    return -1;
  jsonp_free(hashtable->buckets);
  hashtable->buckets = new_buckets;
  hashtable->order = new_order;
  for ( i = 0; 1 << hashtable->order > i; ++i )
  {
    v3 = &hashtable->buckets[i];
    v3->last = &hashtable->list;
    v3->first = v3->last;
  }
  list = (hashtable_t *)hashtable->list.next;
  list_init(&hashtable->list);
  while ( &hashtable->list != (hashtable_list *)list )
  {
    next = (list_t *)list->buckets;
    insert_to_bucket(hashtable, &hashtable->buckets[(unsigned int)list->list.next % new_size], (list_t *)list);
    list = (hashtable_t *)next;
  }
  return 0;
}

//----- (00065C7C) --------------------------------------------------------
int __cdecl hashtable_init(hashtable_t *hashtable)
{
  hashtable_bucket *v2; // r2
  size_t i; // [sp+Ch] [bp+Ch]

  hashtable->size = 0;
  hashtable->order = 3;
  hashtable->buckets = (hashtable_bucket *)jsonp_malloc(8 << hashtable->order);
  if ( !hashtable->buckets )
    return -1;
  list_init(&hashtable->list);
  list_init(&hashtable->ordered_list);
  for ( i = 0; 1 << hashtable->order > i; ++i )
  {
    v2 = &hashtable->buckets[i];
    v2->last = &hashtable->list;
    v2->first = v2->last;
  }
  return 0;
}

//----- (00065D0C) --------------------------------------------------------
void __cdecl hashtable_close(hashtable_t *hashtable)
{
  hashtable_do_clear(hashtable);
  jsonp_free(hashtable->buckets);
}

//----- (00065D2C) --------------------------------------------------------
int __cdecl hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, json_t_0 *value)
{
  size_t v4; // r0
  size_t len; // [sp+14h] [bp+14h]
  pair_t *pair; // [sp+18h] [bp+18h]
  pair_t *paira; // [sp+18h] [bp+18h]
  hashtable_bucket *bucket; // [sp+1Ch] [bp+1Ch]
  uint32_t hash; // [sp+24h] [bp+24h]

  if ( !(hashtable->size >> hashtable->order) || !hashtable_do_rehash(hashtable) )
  {
    v4 = strlen((const char *)key);
    hash = hashlittle(key, v4, hashtable_seed);
    bucket = &hashtable->buckets[hash & ((1 << hashtable->order) - 1)];
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if ( pair )
    {
      json_decref_2(pair->value);
      pair->value = value;
    }
    else
    {
      len = strlen((const char *)key);
      if ( len > 0xFFFFFFE6 )
        return -1;
      paira = (pair_t *)jsonp_malloc(len + 25);
      if ( !paira )
        return -1;
      paira->hash = hash;
      strncpy((char *)paira->key, (const char *)key, len + 1);
      paira->value = value;
      list_init(&paira->list);
      list_init(&paira->ordered_list);
      insert_to_bucket(hashtable, bucket, &paira->list);
      list_insert(&hashtable->ordered_list, &paira->ordered_list);
      ++hashtable->size;
    }
    return 0;
  }
  return -1;
}

//----- (00065E50) --------------------------------------------------------
void *__cdecl hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v2; // r0
  pair_t *pair; // [sp+Ch] [bp+Ch]
  uint32_t hash; // [sp+14h] [bp+14h]

  v2 = strlen((const char *)key);
  hash = hashlittle(key, v2, hashtable_seed);
  pair = hashtable_find_pair(hashtable, &hashtable->buckets[hash & ((1 << hashtable->order) - 1)], key, hash);
  if ( pair )
    return pair->value;
  else
    return 0;
}

//----- (00065EB8) --------------------------------------------------------
int __cdecl hashtable_del(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v2; // r0
  uint32_t hash; // [sp+Ch] [bp+Ch]

  v2 = strlen((const char *)key);
  hash = hashlittle(key, v2, hashtable_seed);
  return hashtable_do_del(hashtable, key, hash);
}

//----- (00065EF8) --------------------------------------------------------
void __cdecl hashtable_clear(hashtable_t *hashtable)
{
  hashtable_bucket *v1; // r2
  size_t i; // [sp+Ch] [bp+Ch]

  hashtable_do_clear(hashtable);
  for ( i = 0; 1 << hashtable->order > i; ++i )
  {
    v1 = &hashtable->buckets[i];
    v1->last = &hashtable->list;
    v1->first = v1->last;
  }
  list_init(&hashtable->list);
  list_init(&hashtable->ordered_list);
  hashtable->size = 0;
}

//----- (00065F60) --------------------------------------------------------
void *__cdecl hashtable_iter(hashtable_t *hashtable)
{
  return hashtable_iter_next(hashtable, &hashtable->ordered_list);
}

//----- (00065F80) --------------------------------------------------------
void *__cdecl hashtable_iter_at(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v2; // r0
  pair_t *pair; // [sp+Ch] [bp+Ch]
  uint32_t hash; // [sp+14h] [bp+14h]

  v2 = strlen((const char *)key);
  hash = hashlittle(key, v2, hashtable_seed);
  pair = hashtable_find_pair(hashtable, &hashtable->buckets[hash & ((1 << hashtable->order) - 1)], key, hash);
  if ( pair )
    return &pair->ordered_list;
  else
    return 0;
}

//----- (00065FE8) --------------------------------------------------------
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter)
{
  if ( *((hashtable_t **)iter + 1) == (hashtable_t *)&hashtable->ordered_list )
    return 0;
  else
    return (void *)*((_DWORD *)iter + 1);
}

//----- (00066018) --------------------------------------------------------
void *__cdecl hashtable_iter_key(void *iter)
{
  return (char *)iter + 16;
}

//----- (00066038) --------------------------------------------------------
void *__cdecl hashtable_iter_value(void *iter)
{
  return (void *)*((_DWORD *)iter + 3);
}

//----- (00066058) --------------------------------------------------------
void __cdecl hashtable_iter_set(void *iter, json_t_0 *value)
{
  pair_t *pair; // [sp+Ch] [bp+Ch]

  pair = (pair_t *)((char *)iter - 8);
  json_decref_2(*((json_t_0 **)iter + 3));
  pair->value = value;
}

//----- (00066080) --------------------------------------------------------
uint32_t __cdecl buf_to_uint32(unsigned __int8 *data)
{
  int result; // [sp+8h] [bp+8h]
  size_t i; // [sp+Ch] [bp+Ch]

  result = 0;
  for ( i = 0; i <= 3; ++i )
    result = data[i] | (result << 8);
  return result;
}

//----- (000660BC) --------------------------------------------------------
int __cdecl seed_from_timestamp_and_pid(uint32_t *seed)
{
  *seed = time(0);
  return 0;
}

//----- (000660E0) --------------------------------------------------------
uint32_t generate_seed()
{
  uint32_t seed; // [sp+0h] [bp+0h] BYREF
  int done; // [sp+4h] [bp+4h]

  done = 0;
  seed_from_timestamp_and_pid(&seed);
  if ( !seed )
    return 1;
  return seed;
}

//----- (00066110) --------------------------------------------------------
void __cdecl json_object_seed(size_t seed)
{
  size_t new_seed; // [sp+Ch] [bp+Ch]

  new_seed = seed;
  if ( !hashtable_seed )
  {
    if ( !seed )
      new_seed = generate_seed();
    hashtable_seed = new_seed;
  }
}

//----- (0006614C) --------------------------------------------------------
json_t_0 *__cdecl json_incref(json_t_0 *json)
{
  if ( json )
  {
    if ( json->refcount != -1 )
      ++json->refcount;
  }
  return json;
}

//----- (0006617C) --------------------------------------------------------
void __cdecl json_decref_3(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (000661B4) --------------------------------------------------------
int __cdecl json_object_set_nocheck(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value)
{
  json_t_0 *v3; // r0

  v3 = json_incref(value);
  return json_object_set_new_nocheck(object, key, v3);
}

//----- (000661E0) --------------------------------------------------------
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value)
{
  json_t_0 *v2; // r0

  v2 = json_incref(value);
  return json_array_append_new(array, v2);
}

//----- (00066208) --------------------------------------------------------
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *msg, ...)
{
  unsigned __int8 msg_with_context[160]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 msg_text[160]; // [sp+B0h] [bp+A8h] BYREF
  va_list ap; // [sp+150h] [bp+148h]
  const unsigned __int8 *saved_text; // [sp+154h] [bp+14Ch]
  const unsigned __int8 *result; // [sp+158h] [bp+150h]
  size_t pos; // [sp+15Ch] [bp+154h]
  int col; // [sp+160h] [bp+158h]
  int line; // [sp+164h] [bp+15Ch]
  const unsigned __int8 *msga; // [sp+170h] [bp+168h]
  va_list varg_r3; // [sp+174h] [bp+16Ch] BYREF

  va_start(varg_r3, msg);
  msga = msg;
  line = -1;
  col = -1;
  pos = 0;
  result = msg_text;
  if ( error )
  {
    va_copy(ap, varg_r3);
    vsnprintf((char *)msg_text, 0xA0u, (const char *)msga, varg_r3);
    msg_text[159] = 0;
    if ( lex )
    {
      saved_text = strbuffer_value(&lex->saved_text);
      line = lex->stream.line;
      col = lex->stream.column;
      pos = lex->stream.position;
      if ( saved_text && *saved_text )
      {
        if ( lex->saved_text.length <= 0x14 )
        {
          snprintf((char *)msg_with_context, 0xA0u, "%s near '%s'", (const char *)msg_text, (const char *)saved_text);
          msg_with_context[159] = 0;
          result = msg_with_context;
        }
      }
      else if ( lex->stream.state == -2 )
      {
        result = msg_text;
      }
      else
      {
        snprintf((char *)msg_with_context, 0xA0u, "%s near end of file", (const char *)msg_text);
        msg_with_context[159] = 0;
        result = msg_with_context;
      }
    }
    jsonp_error_set(error, line, col, pos, "%s", (const char *)result);
  }
}

//----- (00066358) --------------------------------------------------------
void __cdecl stream_init(stream_t *stream, get_func get, void *data)
{
  stream->get = get;
  stream->data = data;
  stream->buffer[0] = 0;
  stream->buffer_pos = 0;
  stream->state = 0;
  stream->line = 1;
  stream->column = 0;
  stream->position = 0;
}

//----- (000663A0) --------------------------------------------------------
int __cdecl stream_get(stream_t *stream, json_error_t *error)
{
  size_t buffer_pos; // r3
  size_t count; // [sp+Ch] [bp+Ch]
  int c; // [sp+10h] [bp+10h]
  int ca; // [sp+10h] [bp+10h]
  size_t i; // [sp+14h] [bp+14h]

  if ( stream->state )
    return stream->state;
  if ( !stream->buffer[stream->buffer_pos] )
  {
    c = stream->get(stream->data);
    if ( c == -1 )
    {
      stream->state = -1;
      return -1;
    }
    stream->buffer[0] = c;
    stream->buffer_pos = 0;
    if ( c <= 127 || c > 255 )
    {
      stream->buffer[1] = 0;
    }
    else
    {
      count = utf8_check_first(c);
      if ( !count )
        goto out;
      if ( count <= 1 )
        _assert_fail("count >= 2", "compat/jansson-2.9/src/load.c", 0xBCu, (const char *)_PRETTY_FUNCTION___5992);
      for ( i = 1; i < count; stream->buffer[i++] = stream->get(stream->data) )
        ;
      if ( !utf8_check_full(stream->buffer, count, 0) )
      {
out:
        stream->state = -2;
        error_set(error, (const lex_t *)stream, "unable to decode byte 0x%x", c);
        return -2;
      }
      stream->buffer[count] = 0;
    }
  }
  buffer_pos = stream->buffer_pos;
  ca = stream->buffer[buffer_pos];
  stream->buffer_pos = buffer_pos + 1;
  ++stream->position;
  if ( ca == 10 )
  {
    ++stream->line;
    stream->last_column = stream->column;
    stream->column = 0;
  }
  else if ( utf8_check_first(ca) )
  {
    ++stream->column;
  }
  return ca;
}

//----- (00066518) --------------------------------------------------------
void __cdecl stream_unget(stream_t *stream, int c)
{
  if ( c != -1 && c != -2 )
  {
    --stream->position;
    if ( c == 10 )
    {
      --stream->line;
      stream->column = stream->last_column;
    }
    else if ( utf8_check_first(c) )
    {
      --stream->column;
    }
    if ( !stream->buffer_pos )
      _assert_fail(
        "stream->buffer_pos > 0",
        "compat/jansson-2.9/src/load.c",
        0xF0u,
        (const char *)_PRETTY_FUNCTION___6000);
    if ( stream->buffer[--stream->buffer_pos] != c )
      _assert_fail(
        "stream->buffer[stream->buffer_pos] == c",
        "compat/jansson-2.9/src/load.c",
        0xF2u,
        (const char *)_PRETTY_FUNCTION___6000);
  }
}

//----- (000665DC) --------------------------------------------------------
int __cdecl lex_get(lex_t *lex, json_error_t *error)
{
  return stream_get(&lex->stream, error);
}

//----- (000665FC) --------------------------------------------------------
void __cdecl lex_save(lex_t *lex, int c)
{
  strbuffer_append_byte(&lex->saved_text, c);
}

//----- (00066620) --------------------------------------------------------
int __cdecl lex_get_save(lex_t *lex, json_error_t *error)
{
  int c; // [sp+Ch] [bp+Ch]

  c = stream_get(&lex->stream, error);
  if ( c != -1 && c != -2 )
    lex_save(lex, c);
  return c;
}

//----- (0006665C) --------------------------------------------------------
void __cdecl lex_unget(lex_t *lex, int c)
{
  stream_unget(&lex->stream, c);
}

//----- (00066678) --------------------------------------------------------
void __cdecl lex_unget_unsave(lex_t *lex, int c)
{
  if ( c != -1 && c != -2 )
  {
    stream_unget(&lex->stream, c);
    if ( strbuffer_pop(&lex->saved_text) != c )
      _assert_fail("c == d", "compat/jansson-2.9/src/load.c", 0x11Du, (const char *)_PRETTY_FUNCTION___6023);
  }
}

//----- (000666DC) --------------------------------------------------------
void __cdecl lex_save_cached(lex_t *lex)
{
  while ( lex->stream.buffer[lex->stream.buffer_pos] )
  {
    lex_save(lex, lex->stream.buffer[lex->stream.buffer_pos]);
    ++lex->stream.buffer_pos;
    ++lex->stream.position;
  }
}

//----- (00066724) --------------------------------------------------------
void __cdecl lex_free_string(lex_t *lex)
{
  jsonp_free(lex->value.string.val);
  lex->value.string.val = 0;
  lex->value.string.len = 0;
}

//----- (0006674C) --------------------------------------------------------
int32_t __cdecl decode_unicode_escape(const unsigned __int8 *str)
{
  unsigned __int8 c; // [sp+Fh] [bp+Fh]
  int32_t value; // [sp+10h] [bp+10h]
  int32_t valuea; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  value = 0;
  if ( *str != 117 )
    _assert_fail("str[0] == 'u'", "compat/jansson-2.9/src/load.c", 0x138u, (const char *)_PRETTY_FUNCTION___6038);
  for ( i = 1; i <= 4; ++i )
  {
    c = str[i];
    valuea = 16 * value;
    if ( c <= 0x2Fu || c > 0x39u )
    {
      if ( c <= 0x60u || c > 0x7Au )
      {
        if ( c <= 0x40u || c > 0x5Au )
          return -1;
        value = valuea + c - 55;
      }
      else
      {
        value = valuea + c - 87;
      }
    }
    else
    {
      value = valuea + c - 48;
    }
  }
  return value;
}

//----- (000667FC) --------------------------------------------------------
void __cdecl lex_scan_string(lex_t *lex, json_error_t *error)
{
  int v2; // r3
  size_t length; // [sp+14h] [bp+Ch] BYREF
  int32_t value2; // [sp+18h] [bp+10h]
  int32_t value; // [sp+1Ch] [bp+14h]
  int i; // [sp+20h] [bp+18h]
  unsigned __int8 *t; // [sp+24h] [bp+1Ch]
  const unsigned __int8 *p; // [sp+28h] [bp+20h]
  int c; // [sp+2Ch] [bp+24h]

  lex->value.string.val = 0;
  lex->token = -1;
  c = lex_get_save(lex, error);
  while ( 1 )
  {
    if ( c == 34 )
    {
      t = (unsigned __int8 *)jsonp_malloc(lex->saved_text.length + 1);
      if ( !t )
        goto out;
      lex->value.string.val = t;
      for ( p = strbuffer_value(&lex->saved_text) + 1; ; ++p )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( *p == 34 )
            {
              *t = 0;
              lex->value.string.len = t - lex->value.string.val;
              lex->token = 256;
              return;
            }
            if ( *p == 92 )
              break;
            *t++ = *p++;
          }
          if ( *++p != 117 )
            break;
          value = decode_unicode_escape(p);
          if ( value < 0 )
            goto LABEL_40;
          p += 5;
          if ( value <= 55295 || value > 56319 )
          {
            if ( value > 56319 && value <= 57343 )
            {
LABEL_53:
              error_set(error, lex, "invalid Unicode '\\u%04X'", value);
              goto out;
            }
          }
          else
          {
            if ( *p != 92 || p[1] != 117 )
              goto LABEL_53;
            value2 = decode_unicode_escape(++p);
            if ( value2 < 0 )
            {
LABEL_40:
              error_set(error, lex, "invalid Unicode escape '%.6s'", (const char *)p - 1);
              goto out;
            }
            p += 5;
            if ( value2 <= 56319 || value2 > 57343 )
            {
              error_set(error, lex, "invalid Unicode '\\u%04X\\u%04X'", value, value2);
              goto out;
            }
            value = ((value - 55296) << 10) + value2 - 56320 + 0x10000;
          }
          if ( utf8_encode(value, t, &length) )
            _assert_fail("0", "compat/jansson-2.9/src/load.c", 0x1DBu, (const char *)_PRETTY_FUNCTION___6061);
          t += length;
        }
        v2 = *p;
        if ( v2 == 102 )
        {
          *t = 12;
        }
        else if ( *p > 0x66u )
        {
          switch ( v2 )
          {
            case 'r':
              *t = 13;
              break;
            case 't':
              *t = 9;
              break;
            case 'n':
              *t = 10;
              break;
            default:
              goto LABEL_76;
          }
        }
        else
        {
          if ( v2 == 92 )
            goto LABEL_70;
          if ( *p <= 0x5Cu )
          {
            if ( v2 != 34 && v2 != 47 )
LABEL_76:
              _assert_fail("0", "compat/jansson-2.9/src/load.c", 0x1F7u, (const char *)_PRETTY_FUNCTION___6061);
LABEL_70:
            *t = *p;
            goto LABEL_77;
          }
          if ( v2 != 98 )
            goto LABEL_76;
          *t = 8;
        }
LABEL_77:
        ++t;
      }
    }
    if ( c == -2 )
      goto out;
    if ( c == -1 )
      break;
    if ( c >= 0 && c <= 31 )
    {
      lex_unget_unsave(lex, c);
      if ( c == 10 )
        error_set(error, lex, "unexpected newline", 10);
      else
        error_set(error, lex, "control character 0x%x", c);
      goto out;
    }
    if ( c != 92 )
      goto LABEL_33;
    c = lex_get_save(lex, error);
    if ( c == 117 )
    {
      c = lex_get_save(lex, error);
      for ( i = 0; i <= 3; ++i )
      {
        if ( (c <= 47 || c > 57) && (c <= 64 || c > 70) && (c <= 96 || c > 102) )
          goto LABEL_19;
        c = lex_get_save(lex, error);
      }
    }
    else
    {
      if ( c != 34 && c != 92 && c != 47 && c != 98 && c != 102 && c != 110 && c != 114 && c != 116 )
      {
LABEL_19:
        error_set(error, lex, "invalid escape");
        goto out;
      }
LABEL_33:
      c = lex_get_save(lex, error);
    }
  }
  error_set(error, lex, "premature end of input");
out:
  lex_free_string(lex);
}

//----- (00066BC4) --------------------------------------------------------
int __cdecl lex_scan_number(lex_t *lex, int c, json_error_t *error)
{
  int ca; // [sp+8h] [bp+8h]
  int cb; // [sp+8h] [bp+8h]
  double doubleval; // [sp+10h] [bp+10h] BYREF
  unsigned __int8 *end; // [sp+1Ch] [bp+1Ch] BYREF
  json_int_t intval; // [sp+20h] [bp+20h]
  const unsigned __int8 *saved_text; // [sp+2Ch] [bp+2Ch]

  ca = c;
  lex->token = -1;
  if ( c == 45 )
    ca = lex_get_save(lex, error);
  if ( ca == 48 )
  {
    ca = lex_get_save(lex, error);
    if ( ca > 47 && ca <= 57 )
    {
LABEL_6:
      lex_unget_unsave(lex, ca);
      return -1;
    }
  }
  else
  {
    if ( ca <= 47 || ca > 57 )
      goto LABEL_6;
    do
      ca = lex_get_save(lex, error);
    while ( ca > 47 && ca <= 57 );
  }
  if ( (lex->flags & 8) != 0 || ca == 46 || ca == 69 || ca == 101 )
  {
    if ( ca == 46 )
    {
      cb = lex_get(lex, error);
      if ( cb <= 47 || cb > 57 )
      {
        lex_unget(lex, cb);
        return -1;
      }
      lex_save(lex, cb);
      do
        ca = lex_get_save(lex, error);
      while ( ca > 47 && ca <= 57 );
    }
    if ( ca == 69 || ca == 101 )
    {
      ca = lex_get_save(lex, error);
      if ( ca == 43 || ca == 45 )
        ca = lex_get_save(lex, error);
      if ( ca <= 47 || ca > 57 )
        goto LABEL_6;
      do
        ca = lex_get_save(lex, error);
      while ( ca > 47 && ca <= 57 );
    }
    lex_unget_unsave(lex, ca);
    if ( jsonp_strtod(&lex->saved_text, &doubleval) )
    {
      error_set(error, lex, "real number overflow");
      return -1;
    }
    lex->token = 258;
    lex->value.real = doubleval;
    return 0;
  }
  else
  {
    lex_unget_unsave(lex, ca);
    saved_text = strbuffer_value(&lex->saved_text);
    *_errno_location() = 0;
    intval = strtoll((const char *)saved_text, (char **)&end, 10);
    if ( *_errno_location() == 34 )
    {
      if ( intval >= 0 )
        error_set(error, lex, "too big integer");
      else
        error_set(error, lex, "too big negative integer");
      return -1;
    }
    if ( &saved_text[lex->saved_text.length] != end )
      _assert_fail(
        "end == saved_text + lex->saved_text.length",
        "compat/jansson-2.9/src/load.c",
        0x249u,
        (const char *)_PRETTY_FUNCTION___6087);
    lex->token = 257;
    lex->value.integer = intval;
    return 0;
  }
}

//----- (00066E00) --------------------------------------------------------
int __cdecl lex_scan(lex_t *lex, json_error_t *error)
{
  const unsigned __int8 *saved_text; // [sp+8h] [bp+8h]
  int c; // [sp+Ch] [bp+Ch]
  int ca; // [sp+Ch] [bp+Ch]

  strbuffer_clear(&lex->saved_text);
  if ( lex->token == 256 )
    lex_free_string(lex);
  do
  {
    do
      c = lex_get(lex, error);
    while ( c == 32 );
  }
  while ( c == 9 || c == 10 || c == 13 );
  if ( c == -1 )
  {
    lex->token = 0;
  }
  else if ( c == -2 )
  {
    lex->token = -1;
  }
  else
  {
    lex_save(lex, c);
    if ( c == 123 || c == 125 || c == 91 || c == 93 || c == 58 || c == 44 )
    {
      lex->token = c;
    }
    else if ( c == 34 )
    {
      lex_scan_string(lex, error);
    }
    else if ( c > 47 && c <= 57 || c == 45 )
    {
      lex_scan_number(lex, c, error);
    }
    else if ( (c <= 64 || c > 90) && (c <= 96 || c > 122) )
    {
      lex_save_cached(lex);
      lex->token = -1;
    }
    else
    {
      do
      {
        do
          ca = lex_get_save(lex, error);
        while ( ca > 64 && ca <= 90 );
      }
      while ( ca > 96 && ca <= 122 );
      lex_unget_unsave(lex, ca);
      saved_text = strbuffer_value(&lex->saved_text);
      if ( !strcmp((const char *)saved_text, "true") )
      {
        lex->token = 259;
      }
      else if ( !strcmp((const char *)saved_text, "false") )
      {
        lex->token = 260;
      }
      else if ( !strcmp((const char *)saved_text, "null") )
      {
        lex->token = 261;
      }
      else
      {
        lex->token = -1;
      }
    }
  }
  return lex->token;
}

//----- (00066F9C) --------------------------------------------------------
unsigned __int8 *__cdecl lex_steal_string(lex_t *lex, size_t *out_len)
{
  unsigned __int8 *result; // [sp+Ch] [bp+Ch]

  result = 0;
  if ( lex->token == 256 )
  {
    result = lex->value.string.val;
    *out_len = lex->value.string.len;
    lex->value.integer = 0LL;
  }
  return result;
}

//----- (00066FDC) --------------------------------------------------------
int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data)
{
  stream_init(&lex->stream, get, data);
  if ( strbuffer_init(&lex->saved_text) )
    return -1;
  lex->flags = flags;
  lex->token = -1;
  return 0;
}

//----- (00067028) --------------------------------------------------------
void __cdecl lex_close(lex_t *lex)
{
  if ( lex->token == 256 )
    lex_free_string(lex);
  strbuffer_close(&lex->saved_text);
}

//----- (00067054) --------------------------------------------------------
json_t_0 *__cdecl parse_object(lex_t *lex, size_t flags, json_error_t *error)
{
  size_t len; // [sp+10h] [bp+10h] BYREF
  json_t_0 *value; // [sp+14h] [bp+14h]
  unsigned __int8 *key; // [sp+18h] [bp+18h]
  json_t_0 *object; // [sp+1Ch] [bp+1Ch]

  object = (json_t_0 *)json_object();
  if ( !object )
    return 0;
  lex_scan(lex, error);
  if ( lex->token == 125 )
    return object;
  while ( 1 )
  {
    if ( lex->token != 256 )
    {
      error_set(error, lex, "string or '}' expected");
      goto LABEL_25;
    }
    key = lex_steal_string(lex, &len);
    if ( !key )
      return 0;
    if ( rpl_memchr(key, 0, len) )
    {
      jsonp_free(key);
      error_set(error, lex, "NUL byte in object key not supported");
      goto LABEL_25;
    }
    if ( (flags & 1) != 0 && json_object_get(object, key) )
    {
      jsonp_free(key);
      error_set(error, lex, "duplicate object key");
      goto LABEL_25;
    }
    lex_scan(lex, error);
    if ( lex->token != 58 )
    {
      jsonp_free(key);
      error_set(error, lex, "':' expected");
      goto LABEL_25;
    }
    lex_scan(lex, error);
    value = parse_value(lex, flags, error);
    if ( !value )
    {
      jsonp_free(key);
      goto LABEL_25;
    }
    if ( json_object_set_nocheck(object, key, value) )
    {
      jsonp_free(key);
      json_decref_3(value);
      goto LABEL_25;
    }
    json_decref_3(value);
    jsonp_free(key);
    lex_scan(lex, error);
    if ( lex->token != 44 )
      break;
    lex_scan(lex, error);
  }
  if ( lex->token == 125 )
    return object;
  error_set(error, lex, "'}' expected");
LABEL_25:
  json_decref_3(object);
  return 0;
}

//----- (000671D0) --------------------------------------------------------
json_t_0 *__cdecl parse_array(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t_0 *elem; // [sp+10h] [bp+10h]
  json_array_t *array; // [sp+14h] [bp+14h]

  array = json_array();
  if ( !array )
    return 0;
  lex_scan(lex, error);
  if ( lex->token == 93 )
    return &array->json;
  while ( lex->token )
  {
    elem = parse_value(lex, flags, error);
    if ( !elem )
      goto LABEL_14;
    if ( json_array_append(&array->json, elem) )
    {
      json_decref_3(elem);
      goto LABEL_14;
    }
    json_decref_3(elem);
    lex_scan(lex, error);
    if ( lex->token != 44 )
      break;
    lex_scan(lex, error);
  }
  if ( lex->token == 93 )
    return &array->json;
  error_set(error, lex, "']' expected");
LABEL_14:
  json_decref_3(&array->json);
  return 0;
}

//----- (00067288) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__cdecl parse_value(lex_t *lex, size_t flags, json_error_t *error)
{
  int token; // r3
  char v5; // r1
  size_t v6; // r1
  size_t v7; // r1
  size_t len; // [sp+14h] [bp+14h]
  unsigned __int8 *value; // [sp+18h] [bp+18h]
  json_t_0 *json; // [sp+1Ch] [bp+1Ch]

  if ( ++lex->depth > 0x800 )
  {
    error_set(error, lex, "maximum parsing depth reached");
    return 0;
  }
  token = lex->token;
  if ( token == 257 )
  {
    json = json_integer(lex->value.integer);
  }
  else if ( token > 257 )
  {
    if ( token == 259 )
    {
      json = json_true();
    }
    else if ( token < 259 )
    {
      json = json_real(*(double *)&lex);
    }
    else if ( token == 260 )
    {
      json = json_false();
    }
    else
    {
      if ( token != 261 )
        goto LABEL_30;
      json = json_null();
    }
  }
  else if ( token == 91 )
  {
    json = parse_array(lex, v7, error);
  }
  else
  {
    if ( token <= 91 )
    {
      if ( token == -1 )
      {
        error_set(error, lex, "invalid token");
        return 0;
      }
LABEL_30:
      error_set(error, lex, "unexpected token");
      return 0;
    }
    if ( token == 123 )
    {
      json = parse_object(lex, v6, error);
    }
    else
    {
      if ( token != 256 )
        goto LABEL_30;
      value = lex->value.string.val;
      len = lex->value.string.len;
      if ( (v5 & 0x10) == 0 && rpl_memchr(value, 0, len) )
      {
        error_set(error, lex, "\\u0000 is not allowed without JSON_ALLOW_NUL");
        return 0;
      }
      json = jsonp_stringn_nocheck_own(value, len);
      if ( json )
      {
        lex->value.string.val = 0;
        lex->value.string.len = 0;
      }
    }
  }
  if ( !json )
    return 0;
  --lex->depth;
  return json;
}
// 67288: variables would overlap: r0.4 and r0.8

//----- (00067408) --------------------------------------------------------
json_t_0 *__cdecl parse_json(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t_0 *result; // [sp+14h] [bp+14h]

  lex->depth = 0;
  lex_scan(lex, error);
  if ( (flags & 4) != 0 || lex->token == 91 || lex->token == 123 )
  {
    result = parse_value(lex, flags, error);
    if ( result )
    {
      if ( (flags & 2) != 0 || (lex_scan(lex, error), !lex->token) )
      {
        if ( error )
          error->position = lex->stream.position;
        return result;
      }
      else
      {
        error_set(error, lex, "end of file expected");
        json_decref_3(result);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    error_set(error, lex, "'[' or '{' expected");
    return 0;
  }
}

//----- (000674B8) --------------------------------------------------------
int __cdecl string_get(void *data)
{
  unsigned __int8 c; // [sp+Bh] [bp+Bh]

  c = *(_BYTE *)(*(_DWORD *)data + *((_DWORD *)data + 1));
  if ( !c )
    return -1;
  ++*((_DWORD *)data + 1);
  return c;
}

//----- (000674F8) --------------------------------------------------------
json_t_0 *__cdecl json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error)
{
  string_data_t stream_data; // [sp+10h] [bp+10h] BYREF
  lex_t lex; // [sp+18h] [bp+18h] BYREF
  json_t_0 *result; // [sp+64h] [bp+64h]

  jsonp_error_init(error, "<string>");
  if ( string )
  {
    stream_data.data = string;
    stream_data.pos = 0;
    if ( lex_init(&lex, (get_func)string_get, flags, &stream_data) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (0006757C) --------------------------------------------------------
int __cdecl buffer_get(void *data)
{
  if ( *((_DWORD *)data + 2) >= *((_DWORD *)data + 1) )
    return -1;
  return *(unsigned __int8 *)(*(_DWORD *)data + (*((_DWORD *)data + 2))++);
}

//----- (000675C0) --------------------------------------------------------
json_t_0 *__cdecl json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error)
{
  buffer_data_t stream_data; // [sp+14h] [bp+14h] BYREF
  lex_t lex; // [sp+20h] [bp+20h] BYREF
  json_t_0 *result; // [sp+6Ch] [bp+6Ch]

  jsonp_error_init(error, "<buffer>");
  if ( buffer )
  {
    stream_data.data = buffer;
    stream_data.pos = 0;
    stream_data.len = buflen;
    if ( lex_init(&lex, (get_func)buffer_get, flags, &stream_data) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (0006764C) --------------------------------------------------------
json_t_0 *__cdecl json_loadf(FILE *input, size_t flags, json_error_t *error)
{
  lex_t lex; // [sp+10h] [bp+10h] BYREF
  json_t_0 *result; // [sp+58h] [bp+58h]
  const unsigned __int8 *source; // [sp+5Ch] [bp+5Ch]

  if ( input == (FILE *)stdin )
    source = "<stdin>";
  else
    source = "<stream>";
  jsonp_error_init(error, source);
  if ( input )
  {
    if ( lex_init(&lex, (get_func)fgetc, flags, input) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}
// 8A8B0: using guessed type int stdin;

//----- (000676E8) --------------------------------------------------------
json_t_0 *__cdecl json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error)
{
  int *v4; // r0
  char *v5; // r0
  json_t_0 *result; // [sp+18h] [bp+10h]
  FILE *fp; // [sp+1Ch] [bp+14h]

  jsonp_error_init(error, path);
  if ( path )
  {
    fp = fopen((const char *)path, "rb");
    if ( fp )
    {
      result = json_loadf(fp, flags, error);
      fclose(fp);
      return result;
    }
    else
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      error_set(error, 0, "unable to open %s: %s", (const char *)path, v5);
      return 0;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (00067774) --------------------------------------------------------
int __cdecl callback_get(void *data)
{
  if ( *((_DWORD *)data + 257) >= *((_DWORD *)data + 256) )
  {
    *((_DWORD *)data + 257) = 0;
    *((_DWORD *)data + 256) = (*((int (__fastcall **)(void *, int, _DWORD))data + 258))(
                                data,
                                1024,
                                *((_DWORD *)data + 259));
    if ( !*((_DWORD *)data + 256) || *((_DWORD *)data + 256) == -1 )
      return -1;
  }
  return *((unsigned __int8 *)data + (*((_DWORD *)data + 257))++);
}

//----- (000677F8) --------------------------------------------------------
json_t_0 *__cdecl json_load_callback(json_load_callback_t callback, void *arg, size_t flags, json_error_t *error)
{
  json_error_t *errora; // [sp+0h] [bp+0h]
  size_t flagsa; // [sp+4h] [bp+4h]
  void *arga; // [sp+8h] [bp+8h]
  json_load_callback_t callbacka; // [sp+Ch] [bp+Ch]
  callback_data_t stream_data; // [sp+10h] [bp+10h] BYREF
  lex_t lex; // [sp+420h] [bp+420h] BYREF
  json_t_0 *result; // [sp+46Ch] [bp+46Ch]

  callbacka = callback;
  arga = arg;
  flagsa = flags;
  errora = error;
  memset(&stream_data, 0, sizeof(stream_data));
  stream_data.callback = callbacka;
  stream_data.arg = arga;
  jsonp_error_init(errora, "<callback>");
  if ( callbacka )
  {
    if ( lex_init(&lex, (get_func)callback_get, flagsa, &stream_data) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flagsa, errora);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(errora, 0, "wrong arguments");
    return 0;
  }
}

//----- (000678C8) --------------------------------------------------------
void *__cdecl jsonp_malloc(size_t size)
{
  if ( size )
    return do_malloc(size);
  else
    return 0;
}

//----- (000678F4) --------------------------------------------------------
void __cdecl jsonp_free(void *ptr)
{
  if ( ptr )
    do_free(ptr);
}

//----- (0006791C) --------------------------------------------------------
unsigned __int8 *__cdecl jsonp_strdup(const unsigned __int8 *str)
{
  size_t v1; // r0

  v1 = strlen((const char *)str);
  return jsonp_strndup(str, v1);
}

//----- (00067940) --------------------------------------------------------
unsigned __int8 *__cdecl jsonp_strndup(const unsigned __int8 *str, size_t len)
{
  unsigned __int8 *new_str; // [sp+Ch] [bp+Ch]

  new_str = (unsigned __int8 *)jsonp_malloc(len + 1);
  if ( !new_str )
    return 0;
  memcpy(new_str, str, len);
  new_str[len] = 0;
  return new_str;
}

//----- (00067980) --------------------------------------------------------
void __cdecl json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn)
{
  do_malloc = malloc_fn;
  do_free = free_fn;
}

//----- (000679AC) --------------------------------------------------------
void __cdecl json_get_alloc_funcs(json_malloc_t *malloc_fn, json_free_t *free_fn)
{
  if ( malloc_fn )
    *malloc_fn = do_malloc;
  if ( free_fn )
    *free_fn = do_free;
}

//----- (000679E8) --------------------------------------------------------
json_t_0 *__cdecl json_incref_0(json_t_0 *json)
{
  if ( json )
  {
    if ( json->refcount != -1 )
      ++json->refcount;
  }
  return json;
}

//----- (00067A18) --------------------------------------------------------
void __cdecl json_decref_4(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (00067A50) --------------------------------------------------------
void __cdecl scanner_init(scanner_t *s, json_error_t *error, size_t flags, const unsigned __int8 *fmt)
{
  s->error = error;
  s->flags = flags;
  s->start = fmt;
  s->fmt = s->start;
  memset(&s->prev_token, 0, sizeof(s->prev_token));
  memset(&s->token, 0, sizeof(s->token));
  memset(&s->next_token, 0, sizeof(s->next_token));
  s->line = 1;
  s->column = 0;
  s->pos = 0;
}

//----- (00067ABC) --------------------------------------------------------
void __cdecl next_token(scanner_t *s)
{
  int column; // r1
  size_t pos; // r2
  int v3; // r3
  int v4; // r1
  size_t v5; // r2
  int v6; // r3
  const unsigned __int8 *t; // [sp+Ch] [bp+Ch]

  column = s->token.column;
  pos = s->token.pos;
  v3 = *(_DWORD *)&s->token.token;
  s->prev_token.line = s->token.line;
  s->prev_token.column = column;
  s->prev_token.pos = pos;
  *(_DWORD *)&s->prev_token.token = v3;
  if ( s->next_token.line )
  {
    v4 = s->next_token.column;
    v5 = s->next_token.pos;
    v6 = *(_DWORD *)&s->next_token.token;
    s->token.line = s->next_token.line;
    s->token.column = v4;
    s->token.pos = v5;
    *(_DWORD *)&s->token.token = v6;
    s->next_token.line = 0;
  }
  else
  {
    t = s->fmt;
    ++s->column;
    ++s->pos;
    while ( *t == 32 || *t == 9 || *t == 10 || *t == 44 || *t == 58 )
    {
      if ( *t == 10 )
      {
        ++s->line;
        s->column = 1;
      }
      else
      {
        ++s->column;
      }
      ++s->pos;
      ++t;
    }
    s->token.token = *t;
    s->token.line = s->line;
    s->token.column = s->column;
    s->token.pos = s->pos;
    s->fmt = t + 1;
  }
}

//----- (00067BA4) --------------------------------------------------------
void __cdecl prev_token(scanner_t *s)
{
  int column; // r1
  size_t pos; // r2
  int v3; // r3
  int v4; // r1
  size_t v5; // r2
  int v6; // r3

  column = s->token.column;
  pos = s->token.pos;
  v3 = *(_DWORD *)&s->token.token;
  s->next_token.line = s->token.line;
  s->next_token.column = column;
  s->next_token.pos = pos;
  *(_DWORD *)&s->next_token.token = v3;
  v4 = s->prev_token.column;
  v5 = s->prev_token.pos;
  v6 = *(_DWORD *)&s->prev_token.token;
  s->token.line = s->prev_token.line;
  s->token.column = v4;
  s->token.pos = v5;
  *(_DWORD *)&s->token.token = v6;
}

//----- (00067BD8) --------------------------------------------------------
void set_error(scanner_t *s, const unsigned __int8 *source, const unsigned __int8 *fmt, ...)
{
  va_list varg_r3; // [sp+2Ch] [bp+24h] BYREF

  va_start(varg_r3, fmt);
  jsonp_error_vset(s->error, s->token.line, s->token.column, s->token.pos, fmt, varg_r3);
  jsonp_error_set_source(s->error, source);
}

//----- (00067C20) --------------------------------------------------------
unsigned __int8 *__cdecl read_string(
        scanner_t *s,
        va_list *ap,
        const unsigned __int8 *purpose,
        size_t *out_len,
        int *ours)
{
  const unsigned __int8 **v5; // r3
  const unsigned __int8 **v7; // r3
  size_t *v8; // r3
  size_t *v9; // r3
  strbuffer_t strbuff; // [sp+10h] [bp+10h] BYREF
  const unsigned __int8 *str; // [sp+1Ch] [bp+1Ch]
  unsigned __int8 t; // [sp+23h] [bp+23h]
  size_t length; // [sp+24h] [bp+24h]

  next_token(s);
  t = s->token.token;
  prev_token(s);
  if ( t == 35 || t == 37 || t == 43 )
  {
    strbuffer_init(&strbuff);
    do
    {
      v7 = (const unsigned __int8 **)ap->__ap;
      ap->__ap = (char *)ap->__ap + 4;
      str = *v7;
      if ( !str )
      {
        set_error(s, "<args>", "NULL string argument");
        strbuffer_close(&strbuff);
        return 0;
      }
      next_token(s);
      if ( s->token.token == 35 )
      {
        v8 = (size_t *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        length = *v8;
      }
      else if ( s->token.token == 37 )
      {
        v9 = (size_t *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        length = *v9;
      }
      else
      {
        prev_token(s);
        length = strlen((const char *)str);
      }
      if ( strbuffer_append_bytes(&strbuff, str, length) == -1 )
      {
        set_error(s, "<internal>", "Out of memory");
        strbuffer_close(&strbuff);
        return 0;
      }
      next_token(s);
    }
    while ( s->token.token == 43 );
    prev_token(s);
    if ( utf8_check_string(strbuff.value, strbuff.length) )
    {
      *out_len = strbuff.length;
      *ours = 1;
      return strbuffer_steal_value(&strbuff);
    }
    else
    {
      set_error(s, "<args>", "Invalid UTF-8 %s", (const char *)purpose);
      strbuffer_close(&strbuff);
      return 0;
    }
  }
  else
  {
    v5 = (const unsigned __int8 **)ap->__ap;
    ap->__ap = (char *)ap->__ap + 4;
    str = *v5;
    if ( str )
    {
      length = strlen((const char *)str);
      if ( utf8_check_string(str, length) )
      {
        *out_len = length;
        *ours = 0;
        return (unsigned __int8 *)str;
      }
      else
      {
        set_error(s, "<args>", "Invalid UTF-8 %s", (const char *)purpose);
        return 0;
      }
    }
    else
    {
      set_error(s, "<args>", "NULL string argument");
      return 0;
    }
  }
}

//----- (00067E08) --------------------------------------------------------
json_t_0 *__cdecl pack_object(scanner_t *s, va_list *ap)
{
  int ours; // [sp+14h] [bp+Ch] BYREF
  size_t len; // [sp+18h] [bp+10h] BYREF
  json_t_0 *value; // [sp+1Ch] [bp+14h]
  unsigned __int8 *key; // [sp+20h] [bp+18h]
  json_t_0 *object; // [sp+24h] [bp+1Ch]

  object = (json_t_0 *)json_object();
  next_token(s);
  while ( 1 )
  {
    if ( s->token.token == 125 )
      return object;
    if ( !s->token.token )
    {
      set_error(s, "<format>", "Unexpected end of format string");
      goto error;
    }
    if ( s->token.token != 115 )
    {
      set_error(s, "<format>", "Expected format 's', got '%c'", s->token.token);
      goto error;
    }
    key = read_string(s, ap, "object key", &len, &ours);
    if ( !key )
      goto error;
    next_token(s);
    value = pack(s, ap);
    if ( !value )
    {
      if ( !ours )
        goto error;
      goto LABEL_9;
    }
    if ( json_object_set_new_nocheck(object, key, value) )
      break;
    if ( ours )
      jsonp_free(key);
    next_token(s);
  }
  set_error(s, "<internal>", "Unable to add key \"%s\"", (const char *)key);
  if ( ours )
LABEL_9:
    jsonp_free(key);
error:
  json_decref_4(object);
  return 0;
}

//----- (00067F18) --------------------------------------------------------
json_t_0 *__cdecl pack_array(scanner_t *s, va_list *ap)
{
  json_t_0 *value; // [sp+8h] [bp+8h]
  json_array_t *array; // [sp+Ch] [bp+Ch]

  array = json_array();
  next_token(s);
  while ( 1 )
  {
    if ( s->token.token == 93 )
      return &array->json;
    if ( !s->token.token )
    {
      set_error(s, "<format>", "Unexpected end of format string");
      goto error;
    }
    value = pack(s, ap);
    if ( !value )
      goto error;
    if ( json_array_append_new(&array->json, value) )
      break;
    next_token(s);
  }
  set_error(s, "<internal>", "Unable to append to array");
error:
  json_decref_4(&array->json);
  return 0;
}

//----- (00067FB0) --------------------------------------------------------
json_t_0 *__cdecl pack_string(scanner_t *s, va_list *ap)
{
  bool v2; // r3
  int ours; // [sp+10h] [bp+8h] BYREF
  size_t len; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 *str; // [sp+18h] [bp+10h]
  int nullable; // [sp+1Ch] [bp+14h]

  next_token(s);
  v2 = s->token.token == 63;
  nullable = v2;
  if ( !v2 )
    prev_token(s);
  str = read_string(s, ap, "string", &len, &ours);
  if ( str )
  {
    if ( ours )
      return jsonp_stringn_nocheck_own(str, len);
    else
      return json_stringn_nocheck(str, len);
  }
  else if ( nullable )
  {
    return json_null();
  }
  else
  {
    return 0;
  }
}

//----- (0006803C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__cdecl pack(scanner_t *s, va_list *ap)
{
  va_list *v2; // r1
  va_list *v3; // r1
  json_t_0 *v4; // r3
  va_list *v5; // r1
  va_list *v6; // r1
  _DWORD **v7; // r1
  _DWORD *v8; // r3
  int **v9; // r1
  int *v10; // r3
  _DWORD *v11; // r1
  json_int_t *v12; // r3
  _DWORD *v13; // r1
  unsigned int v14; // r1
  json_t_0 **v15; // r3
  json_t_0 **v16; // r3
  va_list *apa; // [sp+0h] [bp+0h]
  int nullable_0; // [sp+Ch] [bp+Ch]
  int nullable; // [sp+14h] [bp+14h]

  apa = v2;
  switch ( s->token.token )
  {
    case 'I':
      v12 = (json_int_t *)((*v11 + 7) & 0xFFFFFFF8);
      *v11 = v12 + 1;
      v4 = json_integer(*v12);
      break;
    case 'O':
      next_token(s);
      nullable = s->token.token == 63;
      if ( s->token.token != 63 )
        prev_token(s);
      v15 = (json_t_0 **)apa->__ap;
      apa->__ap = (char *)apa->__ap + 4;
      if ( !*v15 && nullable )
        goto LABEL_20;
      v4 = json_incref_0(*v15);
      break;
    case '[':
      v4 = pack_array(s, v5);
      break;
    case 'b':
      v8 = (*v7)++;
      if ( *v8 )
        v4 = json_true();
      else
        v4 = json_false();
      break;
    case 'f':
      v14 = ((*v13 + 7) & 0xFFFFFFF8) + 8;
      apa->__ap = (void *)v14;
      v4 = json_real(*(double *)&s);
      break;
    case 'i':
      v10 = (*v9)++;
      v4 = json_integer(*v10);
      break;
    case 'n':
      goto LABEL_20;
    case 'o':
      next_token(s);
      nullable_0 = s->token.token == 63;
      if ( s->token.token != 63 )
        prev_token(s);
      v16 = (json_t_0 **)apa->__ap;
      apa->__ap = (char *)apa->__ap + 4;
      if ( *v16 || !nullable_0 )
        v4 = *v16;
      else
LABEL_20:
        v4 = json_null();
      break;
    case 's':
      v4 = pack_string(s, v6);
      break;
    case '{':
      v4 = pack_object(s, v3);
      break;
    default:
      set_error(s, "<format>", "Unexpected format character '%c'", s->token.token);
      v4 = 0;
      break;
  }
  return v4;
}
// 6803C: variables would overlap: r0.4 and r0.8

//----- (00068298) --------------------------------------------------------
int __cdecl unpack_object(scanner_t *s, json_t_0 *root, va_list *ap)
{
  int v4; // r3
  int v5; // r3
  const unsigned __int8 **v6; // r3
  json_t_0 *v7; // r0
  void *v8; // r0
  size_t v9; // r0
  void *v10; // r0
  void *v11; // r0
  void *v12; // r0
  size_t v13; // r0
  void *v14; // r0
  size_t v15; // r0
  void *v16; // r0
  void *v17; // r0
  void *v18; // r0
  const unsigned __int8 *v19; // r0
  strbuffer_t unrecognized_keys; // [sp+18h] [bp+10h] BYREF
  hashtable_t key_set; // [sp+24h] [bp+1Ch] BYREF
  json_t_0 *value_0; // [sp+40h] [bp+38h]
  const unsigned __int8 *key; // [sp+44h] [bp+3Ch]
  int unpacked; // [sp+48h] [bp+40h]
  int have_unrecognized_keys; // [sp+4Ch] [bp+44h]
  const unsigned __int8 *key_0; // [sp+50h] [bp+48h]
  int opt; // [sp+54h] [bp+4Ch]
  json_t_0 *value; // [sp+58h] [bp+50h]
  int gotopt; // [sp+5Ch] [bp+54h]
  int strict; // [sp+60h] [bp+58h]
  int ret; // [sp+64h] [bp+5Ch]

  ret = -1;
  strict = 0;
  gotopt = 0;
  if ( hashtable_init(&key_set) )
  {
    set_error(s, "<internal>", "Out of memory");
    return -1;
  }
  else
  {
    if ( root && root->type )
    {
      set_error(s, "<validation>", "Expected object, got %s", (const char *)type_names[root->type]);
    }
    else
    {
      next_token(s);
      while ( s->token.token != 125 )
      {
        opt = 0;
        if ( strict )
        {
          if ( strict == 1 )
            v4 = 33;
          else
            v4 = 42;
          set_error(s, "<format>", "Expected '}' after '%c', got '%c'", v4, s->token.token);
          goto out;
        }
        switch ( s->token.token )
        {
          case 0u:
            set_error(s, "<format>", "Unexpected end of format string");
            goto out;
          case 0x21u:
          case 0x2Au:
            if ( s->token.token == 33 )
              v5 = 1;
            else
              v5 = -1;
            strict = v5;
            next_token(s);
            break;
          case 0x73u:
            v6 = (const unsigned __int8 **)ap->__ap;
            ap->__ap = (char *)ap->__ap + 4;
            key = *v6;
            if ( !key )
            {
              set_error(s, "<args>", "NULL object key");
              goto out;
            }
            next_token(s);
            if ( s->token.token == 63 )
            {
              gotopt = 1;
              opt = 1;
              next_token(s);
            }
            if ( root )
            {
              value = json_object_get(root, key);
              if ( !value && !opt )
              {
                set_error(s, "<validation>", "Object item not found: %s", (const char *)key);
                goto out;
              }
            }
            else
            {
              value = 0;
            }
            if ( unpack(s, value, ap) )
              goto out;
            v7 = json_null();
            hashtable_set(&key_set, key, v7);
            next_token(s);
            break;
          default:
            set_error(s, "<format>", "Expected format 's', got '%c'", s->token.token);
            goto out;
        }
      }
      if ( !strict )
        strict = (s->flags & 2) != 0;
      if ( !root || strict != 1 )
        goto LABEL_62;
      have_unrecognized_keys = 0;
      unpacked = 0;
      if ( gotopt )
      {
        v8 = json_object_iter(root);
        for ( key_0 = json_object_iter_key(v8); key_0; key_0 = json_object_iter_key(v11) )
        {
          v12 = json_object_key_to_iter(key_0);
          value_0 = json_object_iter_value(v12);
          if ( !value_0 )
            break;
          if ( !hashtable_get(&key_set, key_0) )
          {
            ++unpacked;
            if ( have_unrecognized_keys )
            {
              strbuffer_append_bytes(&unrecognized_keys, ", ", 2u);
            }
            else
            {
              strbuffer_init(&unrecognized_keys);
              have_unrecognized_keys = 1;
            }
            v9 = strlen((const char *)key_0);
            strbuffer_append_bytes(&unrecognized_keys, key_0, v9);
          }
          v10 = json_object_key_to_iter(key_0);
          v11 = json_object_iter_next(root, v10);
        }
      }
      else
      {
        v13 = json_object_size(root);
        unpacked = v13 - key_set.size;
      }
      if ( unpacked )
      {
        if ( !gotopt )
        {
          v14 = json_object_iter(root);
          for ( key_0 = json_object_iter_key(v14); key_0; key_0 = json_object_iter_key(v17) )
          {
            v18 = json_object_key_to_iter(key_0);
            value_0 = json_object_iter_value(v18);
            if ( !value_0 )
              break;
            if ( !hashtable_get(&key_set, key_0) )
            {
              if ( have_unrecognized_keys )
              {
                strbuffer_append_bytes(&unrecognized_keys, ", ", 2u);
              }
              else
              {
                strbuffer_init(&unrecognized_keys);
                have_unrecognized_keys = 1;
              }
              v15 = strlen((const char *)key_0);
              strbuffer_append_bytes(&unrecognized_keys, key_0, v15);
            }
            v16 = json_object_key_to_iter(key_0);
            v17 = json_object_iter_next(root, v16);
          }
        }
        v19 = strbuffer_value(&unrecognized_keys);
        set_error(s, "<validation>", "%li object item(s) left unpacked: %s", unpacked, (const char *)v19);
        strbuffer_close(&unrecognized_keys);
      }
      else
      {
LABEL_62:
        ret = 0;
      }
    }
out:
    hashtable_close(&key_set);
    return ret;
  }
}
// 682E8: conditional instruction was optimized away because %root.4!=0

//----- (0006866C) --------------------------------------------------------
int __cdecl unpack_array(scanner_t *s, json_t_0 *root, va_list *ap)
{
  int v4; // r3
  int v5; // r3
  int v6; // r0
  size_t v7; // r0
  json_t_0 *value; // [sp+1Ch] [bp+14h]
  int strict; // [sp+20h] [bp+18h]
  size_t i; // [sp+24h] [bp+1Ch]

  i = 0;
  strict = 0;
  if ( !root || root->type == JSON_ARRAY )
  {
    next_token(s);
    while ( s->token.token != 93 )
    {
      if ( strict )
      {
        if ( strict == 1 )
          v4 = 33;
        else
          v4 = 42;
        set_error(s, "<format>", "Expected ']' after '%c', got '%c'", v4, s->token.token);
        return -1;
      }
      if ( !s->token.token )
      {
        set_error(s, "<format>", "Unexpected end of format string");
        return -1;
      }
      if ( s->token.token == 33 || s->token.token == 42 )
      {
        if ( s->token.token == 33 )
          v5 = 1;
        else
          v5 = -1;
        strict = v5;
        next_token(s);
      }
      else
      {
        if ( !strchr((const char *)unpack_value_starters, s->token.token) )
        {
          set_error(s, "<format>", "Unexpected format character '%c'", s->token.token);
          return -1;
        }
        if ( root )
        {
          value = json_array_get(root, i);
          if ( !value )
          {
            set_error(s, "<validation>", "Array index %lu out of range", i);
            return -1;
          }
          v6 = unpack(s, value, ap);
        }
        else
        {
          v6 = unpack(s, 0, ap);
        }
        if ( v6 )
          return -1;
        next_token(s);
        ++i;
      }
    }
    if ( !strict )
      strict = (s->flags & 2) != 0;
    if ( root && strict == 1 && json_array_size(root) != i )
    {
      v7 = json_array_size(root);
      set_error(s, "<validation>", "%li array item(s) left unpacked", v7 - i);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    set_error(s, "<validation>", "Expected array, got %s", (const char *)type_names[root->type]);
    return -1;
  }
}

//----- (00068864) --------------------------------------------------------
int __cdecl unpack(scanner_t *s, json_t_0 *root, va_list *ap)
{
  __int64 v3; // d0
  const unsigned __int8 ***v5; // r3
  size_t **v6; // r3
  int **v7; // r3
  json_int_t **v8; // r3
  _DWORD **v9; // r3
  double **v10; // r3
  double **v11; // r3
  _DWORD **v12; // r3
  double *target_3; // [sp+14h] [bp+14h]
  double *target_2; // [sp+18h] [bp+18h]
  json_int_t *target_0; // [sp+20h] [bp+20h]
  int *target; // [sp+24h] [bp+24h]
  const unsigned __int8 **str_target; // [sp+28h] [bp+28h]
  size_t *len_target; // [sp+2Ch] [bp+2Ch]

  switch ( s->token.token )
  {
    case 'F':
      if ( !root || root->type == JSON_INTEGER || root->type == JSON_REAL )
      {
        if ( (s->flags & 1) == 0 )
        {
          v11 = (double **)ap->__ap;
          ap->__ap = (char *)ap->__ap + 4;
          target_3 = *v11;
          if ( root )
          {
            json_number_value(root);
            *(_QWORD *)target_3 = v3;
          }
        }
        return 0;
      }
      else
      {
        set_error(s, "<validation>", "Expected real or integer, got %s", (const char *)type_names[root->type]);
        return -1;
      }
    case 'I':
      if ( root && root->type != JSON_INTEGER )
        goto LABEL_20;
      if ( (s->flags & 1) == 0 )
      {
        v8 = (json_int_t **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        if ( root )
        {
          target_0 = *v8;
          *target_0 = json_integer_value(root);
        }
      }
      return 0;
    case 'O':
      if ( root && (s->flags & 1) == 0 )
        json_incref_0(root);
      goto LABEL_57;
    case '[':
      return unpack_array(s, root, ap);
    case 'b':
      if ( !root || root->type == JSON_TRUE || root->type == JSON_FALSE )
      {
        if ( (s->flags & 1) == 0 )
        {
          v9 = (_DWORD **)ap->__ap;
          ap->__ap = (char *)ap->__ap + 4;
          if ( root )
            **v9 = root->type == JSON_TRUE;
        }
        return 0;
      }
      else
      {
        set_error(s, "<validation>", "Expected true or false, got %s", (const char *)type_names[root->type]);
        return -1;
      }
    case 'f':
      if ( !root || root->type == JSON_REAL )
      {
        if ( (s->flags & 1) == 0 )
        {
          v10 = (double **)ap->__ap;
          ap->__ap = (char *)ap->__ap + 4;
          target_2 = *v10;
          if ( root )
          {
            json_real_value(root);
            *(_QWORD *)target_2 = v3;
          }
        }
        return 0;
      }
      else
      {
        set_error(s, "<validation>", "Expected real, got %s", (const char *)type_names[root->type]);
        return -1;
      }
    case 'i':
      if ( !root || root->type == JSON_INTEGER )
      {
        if ( (s->flags & 1) == 0 )
        {
          v7 = (int **)ap->__ap;
          ap->__ap = (char *)ap->__ap + 4;
          if ( root )
          {
            target = *v7;
            *target = json_integer_value(root);
          }
        }
        return 0;
      }
      else
      {
LABEL_20:
        set_error(s, "<validation>", "Expected integer, got %s", (const char *)type_names[root->type]);
        return -1;
      }
    case 'n':
      if ( !root || root->type == JSON_NULL )
        return 0;
      set_error(s, "<validation>", "Expected null, got %s", (const char *)type_names[root->type]);
      return -1;
    case 'o':
LABEL_57:
      if ( (s->flags & 1) == 0 )
      {
        v12 = (_DWORD **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        if ( root )
          **v12 = root;
      }
      return 0;
    case 's':
      if ( root && root->type != JSON_STRING )
      {
        set_error(s, "<validation>", "Expected string, got %s", (const char *)type_names[root->type]);
        return -1;
      }
      if ( (s->flags & 1) != 0 )
        return 0;
      len_target = 0;
      v5 = (const unsigned __int8 ***)ap->__ap;
      ap->__ap = (char *)ap->__ap + 4;
      str_target = *v5;
      if ( !*v5 )
      {
        set_error(s, "<args>", "NULL string argument");
        return -1;
      }
      next_token(s);
      if ( s->token.token == 37 )
      {
        v6 = (size_t **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        len_target = *v6;
        if ( !*v6 )
        {
          set_error(s, "<args>", "NULL string length argument");
          return -1;
        }
      }
      else
      {
        prev_token(s);
      }
      if ( root )
      {
        *str_target = json_string_value(root);
        if ( len_target )
          *len_target = json_string_length(root);
      }
      return 0;
    case '{':
      return unpack_object(s, root, ap);
    default:
      set_error(s, "<format>", "Unexpected format character '%c'", s->token.token);
      return -1;
  }
}
// 68982: conditional instruction was optimized away because %root.4!=0
// 68A70: conditional instruction was optimized away because %root.4!=0
// 68AE2: conditional instruction was optimized away because %root.4!=0
// 68B56: conditional instruction was optimized away because %root.4!=0
// 68B64: conditional instruction was optimized away because %root.4!=0
// 68BBE: conditional instruction was optimized away because %root.4!=0
// 68BE0: conditional instruction was optimized away because %root.4!=0
// 68C54: conditional instruction was optimized away because %root.4!=0
// 68C62: conditional instruction was optimized away because %root.4!=0
// 68D18: conditional instruction was optimized away because %root.4!=0
// 68C42: variable 'v3' is possibly undefined

//----- (00068D7C) --------------------------------------------------------
json_t_0 *__cdecl json_vpack_ex(json_error_t *error, size_t flags, const unsigned __int8 *fmt, va_list ap)
{
  va_list ap_copy; // [sp+1Ch] [bp+14h] BYREF
  scanner_t s; // [sp+20h] [bp+18h] BYREF
  json_t_0 *value; // [sp+6Ch] [bp+64h]

  if ( fmt && *fmt )
  {
    jsonp_error_init(error, 0);
    scanner_init(&s, error, flags, fmt);
    next_token(&s);
    ap_copy.__ap = ap.__ap;
    value = pack(&s, &ap_copy);
    if ( value )
    {
      next_token(&s);
      if ( s.token.token )
      {
        json_decref_4(value);
        set_error(&s, "<format>", "Garbage after format string");
        return 0;
      }
      else
      {
        return value;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    jsonp_error_init(error, "<format>");
    jsonp_error_set(error, -1, -1, 0, "NULL or empty format string");
    return 0;
  }
}

//----- (00068E48) --------------------------------------------------------
json_t_0 *json_pack_ex(json_error_t *error, size_t flags, const unsigned __int8 *fmt, ...)
{
  va_list varg_r3; // [sp+1Ch] [bp+1Ch] BYREF

  va_start(varg_r3, fmt);
  return json_vpack_ex(error, flags, fmt, varg_r3);
}

//----- (00068E7C) --------------------------------------------------------
json_t_0 *json_pack(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+14h] BYREF

  va_start(varg_r1, fmt);
  return json_vpack_ex(0, 0, fmt, varg_r1);
}

//----- (00068EAC) --------------------------------------------------------
int __cdecl json_vunpack_ex(json_t_0 *root, json_error_t *error, size_t flags, const unsigned __int8 *fmt, va_list ap)
{
  va_list ap_copy; // [sp+18h] [bp+10h] BYREF
  scanner_t s; // [sp+1Ch] [bp+14h] BYREF

  if ( root )
  {
    if ( fmt && *fmt )
    {
      jsonp_error_init(error, 0);
      scanner_init(&s, error, flags, fmt);
      next_token(&s);
      ap_copy.__ap = ap.__ap;
      if ( unpack(&s, root, &ap_copy) )
      {
        return -1;
      }
      else
      {
        next_token(&s);
        if ( s.token.token )
        {
          set_error(&s, "<format>", "Garbage after format string");
          return -1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      jsonp_error_init(error, "<format>");
      jsonp_error_set(error, -1, -1, 0, "NULL or empty format string");
      return -1;
    }
  }
  else
  {
    jsonp_error_init(error, "<root>");
    jsonp_error_set(error, -1, -1, 0, "NULL root value");
    return -1;
  }
}

//----- (00068FAC) --------------------------------------------------------
int json_unpack_ex(json_t_0 *root, json_error_t *error, size_t flags, const unsigned __int8 *fmt, ...)
{
  va_list va; // [sp+30h] [bp+28h] BYREF

  va_start(va, fmt);
  return json_vunpack_ex(root, error, flags, fmt, va);
}

//----- (00068FE4) --------------------------------------------------------
int json_unpack(json_t_0 *root, const unsigned __int8 *fmt, ...)
{
  va_list varg_r2; // [sp+28h] [bp+20h] BYREF

  va_start(varg_r2, fmt);
  return json_vunpack_ex(root, 0, 0, fmt, varg_r2);
}

//----- (00069018) --------------------------------------------------------
int __cdecl strbuffer_init(strbuffer_t *strbuff)
{
  strbuff->size = 16;
  strbuff->length = 0;
  strbuff->value = (unsigned __int8 *)jsonp_malloc(strbuff->size);
  if ( !strbuff->value )
    return -1;
  *strbuff->value = 0;
  return 0;
}

//----- (00069060) --------------------------------------------------------
void __cdecl strbuffer_close(strbuffer_t *strbuff)
{
  if ( strbuff->value )
    jsonp_free(strbuff->value);
  strbuff->size = 0;
  strbuff->length = 0;
  strbuff->value = 0;
}

//----- (00069094) --------------------------------------------------------
void __cdecl strbuffer_clear(strbuffer_t *strbuff)
{
  strbuff->length = 0;
  *strbuff->value = 0;
}

//----- (000690B4) --------------------------------------------------------
const unsigned __int8 *__cdecl strbuffer_value(const strbuffer_t *strbuff)
{
  return strbuff->value;
}

//----- (000690CC) --------------------------------------------------------
unsigned __int8 *__cdecl strbuffer_steal_value(strbuffer_t *strbuff)
{
  unsigned __int8 *result; // [sp+Ch] [bp+Ch]

  result = strbuff->value;
  strbuff->value = 0;
  return result;
}

//----- (000690F0) --------------------------------------------------------
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte)
{
  unsigned __int8 bytea; // [sp+3h] [bp+3h] BYREF
  strbuffer_t *strbuffa; // [sp+4h] [bp+4h]

  strbuffa = strbuff;
  bytea = byte;
  return strbuffer_append_bytes(strbuff, &bytea, 1u);
}

//----- (00069114) --------------------------------------------------------
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size)
{
  size_t v4; // r3
  unsigned __int8 *new_value; // [sp+10h] [bp+10h]
  size_t new_size; // [sp+14h] [bp+14h]

  if ( strbuff->size - strbuff->length > size )
    goto LABEL_11;
  if ( (strbuff->size & 0x80000000) == 0 && size != -1 && strbuff->length <= -2 - size )
  {
    v4 = 2 * strbuff->size;
    if ( strbuff->length + size + 1 >= v4 )
      v4 = strbuff->length + size + 1;
    new_size = v4;
    new_value = (unsigned __int8 *)jsonp_malloc(v4);
    if ( !new_value )
      return -1;
    memcpy(new_value, strbuff->value, strbuff->length);
    jsonp_free(strbuff->value);
    strbuff->value = new_value;
    strbuff->size = new_size;
LABEL_11:
    memcpy(&strbuff->value[strbuff->length], data, size);
    strbuff->length += size;
    strbuff->value[strbuff->length] = 0;
    return 0;
  }
  return -1;
}

//----- (000691E8) --------------------------------------------------------
unsigned __int8 __cdecl strbuffer_pop(strbuffer_t *strbuff)
{
  unsigned __int8 *value; // r2
  unsigned __int8 c; // [sp+Fh] [bp+Fh]

  if ( !strbuff->length )
    return 0;
  value = strbuff->value;
  c = value[--strbuff->length];
  strbuff->value[strbuff->length] = 0;
  return c;
}

//----- (00069230) --------------------------------------------------------
void __cdecl to_locale(strbuffer_t *strbuffer)
{
  struct lconv *v1; // r0
  unsigned __int8 *pos; // [sp+8h] [bp+8h]
  const unsigned __int8 *point; // [sp+Ch] [bp+Ch]

  v1 = localeconv();
  point = (const unsigned __int8 *)v1->decimal_point;
  if ( *v1->decimal_point != 46 )
  {
    pos = (unsigned __int8 *)strchr((const char *)strbuffer->value, 46);
    if ( pos )
      *pos = *point;
  }
}

//----- (00069274) --------------------------------------------------------
void __cdecl from_locale(unsigned __int8 *buffer)
{
  struct lconv *v1; // r0
  unsigned __int8 *pos; // [sp+8h] [bp+8h]

  v1 = localeconv();
  if ( *v1->decimal_point != 46 )
  {
    pos = (unsigned __int8 *)strchr((const char *)buffer, *(unsigned __int8 *)v1->decimal_point);
    if ( pos )
      *pos = 46;
  }
}

//----- (000692B4) --------------------------------------------------------
int __cdecl jsonp_strtod(strbuffer_t *strbuffer, double *out)
{
  double v2; // d0
  unsigned __int8 *end; // [sp+Ch] [bp+Ch] BYREF
  double value; // [sp+10h] [bp+10h]

  to_locale(strbuffer);
  *_errno_location() = 0;
  strtod((const char *)strbuffer->value, (char **)&end);
  value = v2;
  if ( &strbuffer->value[strbuffer->length] != end )
    _assert_fail(
      "end == strbuffer->value + strbuffer->length",
      "compat/jansson-2.9/src/strconv.c",
      0x50u,
      (const char *)_PRETTY_FUNCTION___6782);
  if ( (value > 1.79769313e308 || value < -1.79769313e308) && *_errno_location() == 34 )
    return -1;
  *out = value;
  return 0;
}
// 692DE: variable 'v2' is possibly undefined

//----- (00069370) --------------------------------------------------------
int __cdecl jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value, int precision)
{
  double v4; // d0
  int precisiona; // [sp+Ch] [bp+4h]
  signed int ret; // [sp+20h] [bp+18h]
  int length; // [sp+24h] [bp+1Ch]
  unsigned __int8 *end; // [sp+28h] [bp+20h]
  unsigned __int8 *start; // [sp+2Ch] [bp+24h]
  unsigned __int8 *starta; // [sp+2Ch] [bp+24h]

  precisiona = LODWORD(value);
  if ( !LODWORD(value) )
    precisiona = 17;
  ret = snprintf((char *)buffer, size, "%.*g", precisiona, v4);
  if ( ret < 0 )
    return -1;
  length = ret;
  if ( ret >= size )
    return -1;
  from_locale(buffer);
  if ( !strchr((const char *)buffer, 46) && !strchr((const char *)buffer, 101) )
  {
    if ( ret + 3 >= size )
      return -1;
    buffer[ret] = 46;
    buffer[ret + 1] = 48;
    buffer[ret + 2] = 0;
    length = ret + 2;
  }
  start = (unsigned __int8 *)strchr((const char *)buffer, 101);
  if ( start )
  {
    starta = start + 1;
    end = starta + 1;
    if ( *starta == 45 )
      ++starta;
    while ( *end == 48 )
      ++end;
    if ( end != starta )
    {
      memmove(starta, end, buffer - end + length);
      length += starta - end;
    }
  }
  return length;
}
// 693A0: variable 'v4' is possibly undefined

//----- (00069498) --------------------------------------------------------
int __cdecl utf8_encode(int32_t codepoint, unsigned __int8 *buffer, size_t *size)
{
  if ( codepoint >= 0 )
  {
    if ( codepoint > 127 )
    {
      if ( codepoint > 2047 )
      {
        if ( codepoint > 0xFFFF )
        {
          if ( codepoint > 1114111 )
            return -1;
          *buffer = ((codepoint & 0x1C0000) >> 18) - 16;
          buffer[1] = ((codepoint & 0x3F000) >> 12) + 0x80;
          buffer[2] = ((codepoint & 0xFC0) >> 6) + 0x80;
          buffer[3] = (codepoint & 0x3F) + 0x80;
          *size = 4;
        }
        else
        {
          *buffer = ((codepoint & 0xF000) >> 12) - 32;
          buffer[1] = ((codepoint & 0xFC0) >> 6) + 0x80;
          buffer[2] = (codepoint & 0x3F) + 0x80;
          *size = 3;
        }
      }
      else
      {
        *buffer = ((codepoint & 0x7C0) >> 6) - 64;
        buffer[1] = (codepoint & 0x3F) + 0x80;
        *size = 2;
      }
    }
    else
    {
      *buffer = codepoint;
      *size = 1;
    }
    return 0;
  }
  return -1;
}

//----- (000695C4) --------------------------------------------------------
size_t __cdecl utf8_check_first(unsigned __int8 byte)
{
  if ( (byte & 0x80u) == 0 )
    return 1;
  if ( byte <= 0xBFu )
    return 0;
  if ( byte == 192 || byte == 193 )
    return 0;
  if ( byte > 0xC1u && byte <= 0xDFu )
    return 2;
  if ( byte > 0xDFu && byte <= 0xEFu )
    return 3;
  if ( byte <= 0xEFu || byte > 0xF4u )
    return 0;
  return 4;
}

//----- (00069640) --------------------------------------------------------
size_t __cdecl utf8_check_full(const unsigned __int8 *buffer, size_t size, int32_t *codepoint)
{
  _BYTE u[5]; // [sp+17h] [bp+17h]
  size_t i; // [sp+1Ch] [bp+1Ch]

  *(_DWORD *)u = *buffer;
  switch ( size )
  {
    case 2u:
      *(_DWORD *)&u[1] = u[0] & 0x1F;
      break;
    case 3u:
      *(_DWORD *)&u[1] = u[0] & 0xF;
      break;
    case 4u:
      *(_DWORD *)&u[1] = u[0] & 7;
      break;
    default:
      return 0;
  }
  for ( i = 1; i < size; ++i )
  {
    u[0] = buffer[i];
    if ( u[0] >= 0 || u[0] > 0xBFu )
      return 0;
    *(_DWORD *)&u[1] = (*(_DWORD *)&u[1] << 6) + (u[0] & 0x3F);
  }
  if ( *(int *)&u[1] > 1114111 )
    return 0;
  if ( *(int *)&u[1] > 55295 && *(int *)&u[1] <= 57343 )
    return 0;
  if ( size == 2 && *(int *)&u[1] <= 127 || size == 3 && *(int *)&u[1] <= 2047 || size == 4 && *(int *)&u[1] <= 0xFFFF )
    return 0;
  if ( codepoint )
    *codepoint = *(_DWORD *)&u[1];
  return 1;
}

//----- (0006973C) --------------------------------------------------------
const unsigned __int8 *__cdecl utf8_iterate(const unsigned __int8 *buffer, size_t bufsize, int32_t *codepoint)
{
  int32_t value; // [sp+10h] [bp+10h] BYREF
  size_t count; // [sp+14h] [bp+14h]

  if ( !bufsize )
    return buffer;
  count = utf8_check_first(*buffer);
  if ( !count )
    return 0;
  if ( count == 1 )
  {
    value = *buffer;
  }
  else if ( count > bufsize || !utf8_check_full(buffer, count, &value) )
  {
    return 0;
  }
  if ( codepoint )
    *codepoint = value;
  return &buffer[count];
}

//----- (000697B4) --------------------------------------------------------
int __cdecl utf8_check_string(const unsigned __int8 *string, size_t length)
{
  size_t count; // [sp+8h] [bp+8h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < length; ++i )
  {
    count = utf8_check_first(string[i]);
    if ( !count )
      return 0;
    if ( count > 1 )
    {
      if ( length - i < count )
        return 0;
      if ( !utf8_check_full(&string[i], count, 0) )
        return 0;
      i = count + i - 1;
    }
  }
  return 1;
}

//----- (00069834) --------------------------------------------------------
json_t_0 *__cdecl json_incref_1(json_t_0 *json)
{
  if ( json )
  {
    if ( json->refcount != -1 )
      ++json->refcount;
  }
  return json;
}

//----- (00069864) --------------------------------------------------------
void __cdecl json_decref_5(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0006989C) --------------------------------------------------------
int __cdecl json_object_set_nocheck_0(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value)
{
  json_t_0 *v3; // r0

  v3 = json_incref_1(value);
  return json_object_set_new_nocheck(object, key, v3);
}

//----- (000698C8) --------------------------------------------------------
int __cdecl json_array_append_0(json_t_0 *array, json_t_0 *value)
{
  json_t_0 *v2; // r0

  v2 = json_incref_1(value);
  return json_array_append_new(array, v2);
}

//----- (000698F0) --------------------------------------------------------
void __cdecl json_init(json_t_0 *json, json_type type)
{
  json->type = type;
  json->refcount = 1;
}

//----- (00069910) --------------------------------------------------------
json_object_t *json_object()
{
  json_object_t *object; // [sp+4h] [bp+4h]

  object = (json_object_t *)jsonp_malloc(0x28u);
  if ( !object )
    return 0;
  if ( !hashtable_seed )
    json_object_seed(0);
  json_init(&object->json, JSON_OBJECT);
  if ( hashtable_init(&object->hashtable) )
  {
    jsonp_free(object);
    return 0;
  }
  else
  {
    object->visited = 0;
    return object;
  }
}

//----- (00069974) --------------------------------------------------------
void __cdecl json_delete_object(json_object_t *object)
{
  hashtable_close(&object->hashtable);
  jsonp_free(object);
}

//----- (00069994) --------------------------------------------------------
size_t __cdecl json_object_size(const json_t_0 *json)
{
  if ( json && json->type == JSON_OBJECT )
    return json[1].type;
  else
    return 0;
}

//----- (000699C4) --------------------------------------------------------
json_t_0 *__cdecl json_object_get(const json_t_0 *json, const unsigned __int8 *key)
{
  if ( key && json && json->type == JSON_OBJECT )
    return (json_t_0 *)hashtable_get((hashtable_t *)&json[1], key);
  else
    return 0;
}

//----- (00069A04) --------------------------------------------------------
int __cdecl json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value)
{
  if ( !value )
    return -1;
  if ( key && json && json->type == JSON_OBJECT && json != value && !hashtable_set((hashtable_t *)&json[1], key, value) )
    return 0;
  json_decref_5(value);
  return -1;
}

//----- (00069A74) --------------------------------------------------------
int __cdecl json_object_set_new(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value)
{
  size_t v3; // r0

  if ( key )
  {
    v3 = strlen((const char *)key);
    if ( utf8_check_string(key, v3) )
      return json_object_set_new_nocheck(json, key, value);
  }
  json_decref_5(value);
  return -1;
}

//----- (00069AC0) --------------------------------------------------------
int __cdecl json_object_del(json_t_0 *json, const unsigned __int8 *key)
{
  if ( key && json && json->type == JSON_OBJECT )
    return hashtable_del((hashtable_t *)&json[1], key);
  else
    return -1;
}

//----- (00069B00) --------------------------------------------------------
int __cdecl json_object_clear(json_t_0 *json)
{
  if ( !json || json->type )
    return -1;
  hashtable_clear((hashtable_t *)&json[1]);
  return 0;
}

//----- (00069B38) --------------------------------------------------------
int __cdecl json_object_update(json_t_0 *object, json_t_0 *other)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  json_t_0 *value; // [sp+8h] [bp+8h]
  const unsigned __int8 *key; // [sp+Ch] [bp+Ch]

  if ( !object || object->type || !other || other->type )
    return -1;
  v3 = json_object_iter(other);
  for ( key = json_object_iter_key(v3); key; key = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(key);
    value = json_object_iter_value(v6);
    if ( !value )
      break;
    if ( json_object_set_nocheck_0(object, key, value) )
      return -1;
    v4 = json_object_key_to_iter(key);
    v5 = json_object_iter_next(other, v4);
  }
  return 0;
}

//----- (00069BD0) --------------------------------------------------------
int __cdecl json_object_update_existing(json_t_0 *object, json_t_0 *other)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  json_t_0 *value; // [sp+8h] [bp+8h]
  const unsigned __int8 *key; // [sp+Ch] [bp+Ch]

  if ( !object || object->type || !other || other->type )
    return -1;
  v3 = json_object_iter(other);
  for ( key = json_object_iter_key(v3); key; key = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(key);
    value = json_object_iter_value(v6);
    if ( !value )
      break;
    if ( json_object_get(object, key) )
      json_object_set_nocheck_0(object, key, value);
    v4 = json_object_key_to_iter(key);
    v5 = json_object_iter_next(other, v4);
  }
  return 0;
}

//----- (00069C68) --------------------------------------------------------
int __cdecl json_object_update_missing(json_t_0 *object, json_t_0 *other)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  json_t_0 *value; // [sp+8h] [bp+8h]
  const unsigned __int8 *key; // [sp+Ch] [bp+Ch]

  if ( !object || object->type || !other || other->type )
    return -1;
  v3 = json_object_iter(other);
  for ( key = json_object_iter_key(v3); key; key = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(key);
    value = json_object_iter_value(v6);
    if ( !value )
      break;
    if ( !json_object_get(object, key) )
      json_object_set_nocheck_0(object, key, value);
    v4 = json_object_key_to_iter(key);
    v5 = json_object_iter_next(other, v4);
  }
  return 0;
}

//----- (00069D00) --------------------------------------------------------
void *__cdecl json_object_iter(json_t_0 *json)
{
  if ( json && json->type == JSON_OBJECT )
    return hashtable_iter((hashtable_t *)&json[1]);
  else
    return 0;
}

//----- (00069D34) --------------------------------------------------------
void *__cdecl json_object_iter_at(json_t_0 *json, const unsigned __int8 *key)
{
  if ( key && json && json->type == JSON_OBJECT )
    return hashtable_iter_at((hashtable_t *)&json[1], key);
  else
    return 0;
}

//----- (00069D74) --------------------------------------------------------
void *__cdecl json_object_iter_next(json_t_0 *json, void *iter)
{
  if ( json && json->type == JSON_OBJECT && iter )
    return hashtable_iter_next((hashtable_t *)&json[1], iter);
  else
    return 0;
}

//----- (00069DB4) --------------------------------------------------------
const unsigned __int8 *__cdecl json_object_iter_key(void *iter)
{
  if ( iter )
    return (const unsigned __int8 *)hashtable_iter_key(iter);
  else
    return 0;
}

//----- (00069DD8) --------------------------------------------------------
json_t_0 *__cdecl json_object_iter_value(void *iter)
{
  if ( iter )
    return (json_t_0 *)hashtable_iter_value(iter);
  else
    return 0;
}

//----- (00069DFC) --------------------------------------------------------
int __cdecl json_object_iter_set_new(json_t_0 *json, void *iter, json_t_0 *value)
{
  if ( !json || json->type || !iter || !value )
    return -1;
  hashtable_iter_set(iter, value);
  return 0;
}

//----- (00069E3C) --------------------------------------------------------
void *__cdecl json_object_key_to_iter(const unsigned __int8 *key)
{
  if ( key )
    return (void *)(key - 16);
  else
    return 0;
}

//----- (00069E60) --------------------------------------------------------
int __cdecl json_object_equal(json_t_0 *object1, json_t_0 *object2)
{
  size_t v2; // r4
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0
  json_t_0 *value2; // [sp+Ch] [bp+Ch]
  json_t_0 *value1; // [sp+10h] [bp+10h]
  const unsigned __int8 *key; // [sp+14h] [bp+14h]

  v2 = json_object_size(object1);
  if ( v2 != json_object_size(object2) )
    return 0;
  v4 = json_object_iter(object1);
  for ( key = json_object_iter_key(v4); key; key = json_object_iter_key(v6) )
  {
    v7 = json_object_key_to_iter(key);
    value1 = json_object_iter_value(v7);
    if ( !value1 )
      break;
    value2 = json_object_get(object2, key);
    if ( !json_equal(value1, value2) )
      return 0;
    v5 = json_object_key_to_iter(key);
    v6 = json_object_iter_next(object1, v5);
  }
  return 1;
}

//----- (00069EF4) --------------------------------------------------------
json_t_0 *__cdecl json_object_copy(json_t_0 *object)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  json_t_0 *value; // [sp+Ch] [bp+Ch]
  json_object_t *result; // [sp+10h] [bp+10h]
  const unsigned __int8 *key; // [sp+14h] [bp+14h]

  result = json_object();
  if ( !result )
    return 0;
  v2 = json_object_iter(object);
  for ( key = json_object_iter_key(v2); key; key = json_object_iter_key(v4) )
  {
    v5 = json_object_key_to_iter(key);
    value = json_object_iter_value(v5);
    if ( !value )
      break;
    json_object_set_nocheck_0(&result->json, key, value);
    v3 = json_object_key_to_iter(key);
    v4 = json_object_iter_next(object, v3);
  }
  return &result->json;
}

//----- (00069F6C) --------------------------------------------------------
json_t_0 *__cdecl json_object_deep_copy(const json_t_0 *object)
{
  json_t_0 *v2; // r0
  json_t_0 *value; // [sp+8h] [bp+8h]
  const unsigned __int8 *key; // [sp+Ch] [bp+Ch]
  json_object_t *result; // [sp+10h] [bp+10h]
  void *iter; // [sp+14h] [bp+14h]

  result = json_object();
  if ( !result )
    return 0;
  for ( iter = json_object_iter((json_t_0 *)object); iter; iter = json_object_iter_next((json_t_0 *)object, iter) )
  {
    key = json_object_iter_key(iter);
    value = json_object_iter_value(iter);
    v2 = json_deep_copy(value);
    json_object_set_new_nocheck(&result->json, key, v2);
  }
  return &result->json;
}

//----- (00069FCC) --------------------------------------------------------
json_array_t *json_array()
{
  json_array_t *array; // [sp+4h] [bp+4h]

  array = (json_array_t *)jsonp_malloc(0x18u);
  if ( !array )
    return 0;
  json_init(&array->json, JSON_ARRAY);
  array->entries = 0;
  array->size = 8;
  array->table = (json_t_0 **)jsonp_malloc(4 * array->size);
  if ( array->table )
  {
    array->visited = 0;
    return array;
  }
  else
  {
    jsonp_free(array);
    return 0;
  }
}

//----- (0006A030) --------------------------------------------------------
void __cdecl json_delete_array(json_array_t *array)
{
  size_t i; // [sp+Ch] [bp+Ch]

  for ( i = 0; array->entries > i; ++i )
    json_decref_5(array->table[i]);
  jsonp_free(array->table);
  jsonp_free(array);
}

//----- (0006A078) --------------------------------------------------------
size_t __cdecl json_array_size(const json_t_0 *json)
{
  if ( json && json->type == JSON_ARRAY )
    return json[1].refcount;
  else
    return 0;
}

//----- (0006A0A4) --------------------------------------------------------
json_t_0 *__cdecl json_array_get(const json_t_0 *json, size_t index)
{
  if ( !json || json->type != JSON_ARRAY )
    return 0;
  if ( json[1].refcount > index )
    return *(json_t_0 **)(json[2].type + 4 * index);
  return 0;
}

//----- (0006A0EC) --------------------------------------------------------
int __cdecl json_array_set_new(json_t_0 *json, size_t index, json_t_0 *value)
{
  if ( !value )
    return -1;
  if ( json && json->type == JSON_ARRAY && json != value && json[1].refcount > index )
  {
    json_decref_5(*(json_t_0 **)(json[2].type + 4 * index));
    *(_DWORD *)(json[2].type + 4 * index) = value;
    return 0;
  }
  else
  {
    json_decref_5(value);
    return -1;
  }
}

//----- (0006A16C) --------------------------------------------------------
void __cdecl array_move(json_array_t *array, size_t dest, size_t src, size_t count)
{
  memmove(&array->table[dest], &array->table[src], 4 * count);
}

//----- (0006A1A4) --------------------------------------------------------
void __cdecl array_copy(json_t_0 **dest, size_t dpos, json_t_0 **src, size_t spos, size_t count)
{
  memcpy(&dest[dpos], &src[spos], 4 * count);
}

//----- (0006A1D8) --------------------------------------------------------
json_t_0 **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy)
{
  size_t v4; // r3
  json_t_0 **new_table; // [sp+1Ch] [bp+14h]
  size_t new_size; // [sp+20h] [bp+18h]
  json_t_0 **old_table; // [sp+24h] [bp+1Ch]

  if ( array->entries + amount <= array->size )
    return array->table;
  old_table = array->table;
  v4 = array->size + amount;
  if ( 2 * array->size >= v4 )
    v4 = 2 * array->size;
  new_size = v4;
  new_table = (json_t_0 **)jsonp_malloc(4 * v4);
  if ( !new_table )
    return 0;
  array->size = new_size;
  array->table = new_table;
  if ( !copy )
    return old_table;
  array_copy(array->table, 0, old_table, 0, array->entries);
  jsonp_free(old_table);
  return array->table;
}

//----- (0006A26C) --------------------------------------------------------
int __cdecl json_array_append_new(json_t_0 *json, json_t_0 *value)
{
  if ( !value )
    return -1;
  if ( json && json->type == JSON_ARRAY && json != value && json_array_grow((json_array_t *)json, 1u, 1) )
  {
    *(_DWORD *)(json[2].type + 4 * json[1].refcount++) = value;
    return 0;
  }
  else
  {
    json_decref_5(value);
    return -1;
  }
}

//----- (0006A2EC) --------------------------------------------------------
int __cdecl json_array_insert_new(json_t_0 *json, size_t index, json_t_0 *value)
{
  json_t_0 **old_table; // [sp+18h] [bp+10h]

  if ( !value )
    return -1;
  if ( json && json->type == JSON_ARRAY && json != value && json[1].refcount >= index )
  {
    old_table = json_array_grow((json_array_t *)json, 1u, 0);
    if ( old_table )
    {
      if ( (json_t_0 **)json[2].type == old_table )
      {
        array_move((json_array_t *)json, index + 1, index, json[1].refcount - index);
      }
      else
      {
        array_copy((json_t_0 **)json[2].type, 0, old_table, 0, index);
        array_copy((json_t_0 **)json[2].type, index + 1, old_table, index, json[1].refcount - index);
        jsonp_free(old_table);
      }
      *(_DWORD *)(json[2].type + 4 * index) = value;
      ++json[1].refcount;
      return 0;
    }
    else
    {
      json_decref_5(value);
      return -1;
    }
  }
  else
  {
    json_decref_5(value);
    return -1;
  }
}

//----- (0006A3DC) --------------------------------------------------------
int __cdecl json_array_remove(json_t_0 *json, size_t index)
{
  if ( !json || json->type != JSON_ARRAY )
    return -1;
  if ( json[1].refcount <= index )
    return -1;
  json_decref_5(*(json_t_0 **)(json[2].type + 4 * index));
  if ( json[1].refcount - 1 > index )
    array_move((json_array_t *)json, index, index + 1, json[1].refcount - index - 1);
  --json[1].refcount;
  return 0;
}

//----- (0006A458) --------------------------------------------------------
int __cdecl json_array_clear(json_t_0 *json)
{
  size_t i; // [sp+Ch] [bp+Ch]

  if ( !json || json->type != JSON_ARRAY )
    return -1;
  for ( i = 0; json[1].refcount > i; ++i )
    json_decref_5(*(json_t_0 **)(json[2].type + 4 * i));
  json[1].refcount = 0;
  return 0;
}

//----- (0006A4B4) --------------------------------------------------------
int __cdecl json_array_extend(json_t_0 *json, json_t_0 *other_json)
{
  size_t i; // [sp+1Ch] [bp+14h]

  if ( !json || json->type != JSON_ARRAY || !other_json || other_json->type != JSON_ARRAY )
    return -1;
  if ( !json_array_grow((json_array_t *)json, other_json[1].refcount, 1) )
    return -1;
  for ( i = 0; other_json[1].refcount > i; ++i )
    json_incref_1(*(json_t_0 **)(other_json[2].type + 4 * i));
  array_copy((json_t_0 **)json[2].type, json[1].refcount, (json_t_0 **)other_json[2].type, 0, other_json[1].refcount);
  json[1].refcount += other_json[1].refcount;
  return 0;
}

//----- (0006A564) --------------------------------------------------------
int __cdecl json_array_equal(json_t_0 *array1, json_t_0 *array2)
{
  json_t_0 *value2; // [sp+8h] [bp+8h]
  json_t_0 *value1; // [sp+Ch] [bp+Ch]
  size_t size; // [sp+10h] [bp+10h]
  size_t i; // [sp+14h] [bp+14h]

  size = json_array_size(array1);
  if ( json_array_size(array2) != size )
    return 0;
  for ( i = 0; i < size; ++i )
  {
    value1 = json_array_get(array1, i);
    value2 = json_array_get(array2, i);
    if ( !json_equal(value1, value2) )
      return 0;
  }
  return 1;
}

//----- (0006A5D0) --------------------------------------------------------
json_t_0 *__cdecl json_array_copy(json_t_0 *array)
{
  json_t_0 *v2; // r0
  json_array_t *result; // [sp+8h] [bp+8h]
  size_t i; // [sp+Ch] [bp+Ch]

  result = json_array();
  if ( !result )
    return 0;
  for ( i = 0; json_array_size(array) > i; ++i )
  {
    v2 = json_array_get(array, i);
    json_array_append_0(&result->json, v2);
  }
  return &result->json;
}

//----- (0006A620) --------------------------------------------------------
json_t_0 *__cdecl json_array_deep_copy(const json_t_0 *array)
{
  json_t_0 *v2; // r0
  json_t_0 *v3; // r0
  json_array_t *result; // [sp+8h] [bp+8h]
  size_t i; // [sp+Ch] [bp+Ch]

  result = json_array();
  if ( !result )
    return 0;
  for ( i = 0; json_array_size(array) > i; ++i )
  {
    v2 = json_array_get(array, i);
    v3 = json_deep_copy(v2);
    json_array_append_new(&result->json, v3);
  }
  return &result->json;
}

//----- (0006A678) --------------------------------------------------------
json_t_0 *__cdecl string_create(const unsigned __int8 *value, size_t len, int own)
{
  json_string_t *string; // [sp+10h] [bp+10h]
  unsigned __int8 *v; // [sp+14h] [bp+14h]

  if ( !value )
    return 0;
  if ( own )
  {
    v = (unsigned __int8 *)value;
  }
  else
  {
    v = jsonp_strndup(value, len);
    if ( !v )
      return 0;
  }
  string = (json_string_t *)jsonp_malloc(0x10u);
  if ( string )
  {
    json_init(&string->json, JSON_STRING);
    string->value = v;
    string->length = len;
    return &string->json;
  }
  else
  {
    if ( !own )
      jsonp_free(v);
    return 0;
  }
}

//----- (0006A6F0) --------------------------------------------------------
json_t_0 *__cdecl json_string_nocheck(const unsigned __int8 *value)
{
  size_t v2; // r0

  if ( !value )
    return 0;
  v2 = strlen((const char *)value);
  return string_create(value, v2, 0);
}

//----- (0006A720) --------------------------------------------------------
json_t_0 *__cdecl json_stringn_nocheck(const unsigned __int8 *value, size_t len)
{
  return string_create(value, len, 0);
}

//----- (0006A740) --------------------------------------------------------
json_t_0 *__cdecl jsonp_stringn_nocheck_own(const unsigned __int8 *value, size_t len)
{
  return string_create(value, len, 1);
}

//----- (0006A760) --------------------------------------------------------
json_t_0 *__cdecl json_string(const unsigned __int8 *value)
{
  size_t v2; // r0

  if ( !value )
    return 0;
  v2 = strlen((const char *)value);
  return json_stringn(value, v2);
}

//----- (0006A790) --------------------------------------------------------
json_t_0 *__cdecl json_stringn(const unsigned __int8 *value, size_t len)
{
  if ( value && utf8_check_string(value, len) )
    return json_stringn_nocheck(value, len);
  else
    return 0;
}

//----- (0006A7C8) --------------------------------------------------------
const unsigned __int8 *__cdecl json_string_value(const json_t_0 *json)
{
  if ( json && json->type == JSON_STRING )
    return (const unsigned __int8 *)json[1].type;
  else
    return 0;
}

//----- (0006A7F4) --------------------------------------------------------
size_t __cdecl json_string_length(const json_t_0 *json)
{
  if ( json && json->type == JSON_STRING )
    return json[1].refcount;
  else
    return 0;
}

//----- (0006A820) --------------------------------------------------------
int __cdecl json_string_set_nocheck(json_t_0 *json, const unsigned __int8 *value)
{
  size_t v3; // r0

  if ( !value )
    return -1;
  v3 = strlen((const char *)value);
  return json_string_setn_nocheck(json, value, v3);
}

//----- (0006A854) --------------------------------------------------------
int __cdecl json_string_setn_nocheck(json_t_0 *json, const unsigned __int8 *value, size_t len)
{
  unsigned __int8 *dup; // [sp+14h] [bp+14h]

  if ( !json || json->type != JSON_STRING || !value )
    return -1;
  dup = jsonp_strndup(value, len);
  if ( !dup )
    return -1;
  jsonp_free((void *)json[1].type);
  json[1].type = (json_type)dup;
  json[1].refcount = len;
  return 0;
}

//----- (0006A8B8) --------------------------------------------------------
int __cdecl json_string_set(json_t_0 *json, const unsigned __int8 *value)
{
  size_t v3; // r0

  if ( !value )
    return -1;
  v3 = strlen((const char *)value);
  return json_string_setn(json, value, v3);
}

//----- (0006A8EC) --------------------------------------------------------
int __cdecl json_string_setn(json_t_0 *json, const unsigned __int8 *value, size_t len)
{
  if ( value && utf8_check_string(value, len) )
    return json_string_setn_nocheck(json, value, len);
  else
    return -1;
}

//----- (0006A928) --------------------------------------------------------
void __cdecl json_delete_string(json_string_t *string)
{
  jsonp_free(string->value);
  jsonp_free(string);
}

//----- (0006A948) --------------------------------------------------------
int __cdecl json_string_equal(json_t_0 *string1, json_t_0 *string2)
{
  return string1
      && string1->type == JSON_STRING
      && string2
      && string2->type == JSON_STRING
      && string1[1].refcount == string2[1].refcount
      && !memcmp((const void *)string1[1].type, (const void *)string2[1].type, string1[1].refcount);
}

//----- (0006A9B4) --------------------------------------------------------
json_t_0 *__cdecl json_string_copy(const json_t_0 *string)
{
  if ( string && string->type == JSON_STRING )
    return json_stringn_nocheck((const unsigned __int8 *)string[1].type, string[1].refcount);
  else
    return 0;
}

//----- (0006A9F0) --------------------------------------------------------
json_t_0 *__cdecl json_integer(json_int_t value)
{
  json_integer_t *integer; // [sp+Ch] [bp+Ch]

  integer = (json_integer_t *)jsonp_malloc(0x10u);
  if ( !integer )
    return 0;
  json_init(&integer->json, JSON_INTEGER);
  integer->value = value;
  return &integer->json;
}

//----- (0006AA2C) --------------------------------------------------------
json_int_t __cdecl json_integer_value(const json_t_0 *json)
{
  if ( json && json->type == JSON_INTEGER )
    return (json_int_t)json[1];
  else
    return 0LL;
}

//----- (0006AA60) --------------------------------------------------------
int __cdecl json_integer_set(json_t_0 *json, json_int_t value)
{
  if ( !json || json->type != JSON_INTEGER )
    return -1;
  json[1] = (json_t_0)value;
  return 0;
}

//----- (0006AA98) --------------------------------------------------------
void __cdecl json_delete_integer(json_integer_t *integer)
{
  jsonp_free(integer);
}

//----- (0006AAB0) --------------------------------------------------------
int __cdecl json_integer_equal(json_t_0 *integer1, json_t_0 *integer2)
{
  json_int_t v2; // r4

  v2 = json_integer_value(integer1);
  return v2 == json_integer_value(integer2);
}

//----- (0006AAE8) --------------------------------------------------------
json_t_0 *__cdecl json_integer_copy(const json_t_0 *integer)
{
  json_int_t v1; // r0

  v1 = json_integer_value(integer);
  return json_integer(v1);
}

//----- (0006AB10) --------------------------------------------------------
json_t_0 *__cdecl json_real(double value)
{
  double v1; // d0
  double v2; // r0
  json_real_t *real; // [sp+Ch] [bp+Ch]

  LODWORD(v2) = _isnan(value);
  if ( LODWORD(v2) || _isinf(v2) )
    return 0;
  real = (json_real_t *)jsonp_malloc(0x10u);
  if ( !real )
    return 0;
  json_init(&real->json, JSON_REAL);
  real->value = v1;
  return &real->json;
}
// 6AB2C: variable 'v2' is possibly undefined
// 6AB5C: variable 'v1' is possibly undefined

//----- (0006AB6C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_real_value(const json_t_0 *json)
{
  double result; // r0

  LODWORD(result) = json;
  return result;
}
// 6AB6C: variables would overlap: r0.4 and r0.8
// 6AB6C: bad return variable

//----- (0006ABA4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __cdecl json_real_set(json_t_0 *json, double value)
{
  json_t_0 v2; // d0
  double v3; // r0

  if ( !json )
    return -1;
  if ( json->type != JSON_REAL )
    return -1;
  LODWORD(v3) = _isnan(*(double *)&json);
  if ( LODWORD(v3) || _isinf(v3) )
    return -1;
  json[1] = v2;
  return 0;
}
// 6ABA4: variables would overlap: r0.4 and r0.8

//----- (0006ABF8) --------------------------------------------------------
void __cdecl json_delete_real(json_real_t *real)
{
  jsonp_free(real);
}

//----- (0006AC10) --------------------------------------------------------
int __cdecl json_real_equal(json_t_0 *real1, json_t_0 *real2)
{
  json_real_value(real1);
  json_real_value(real2);
  return 1;
}

//----- (0006AC50) --------------------------------------------------------
json_t_0 *__cdecl json_real_copy(const json_t_0 *real)
{
  double v1; // r0

  v1 = json_real_value(real);
  return json_real(v1);
}

//----- (0006AC78) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_number_value(const json_t_0 *json)
{
  double result; // r0

  if ( json && json->type == JSON_INTEGER )
  {
    *(double *)&json = (double)json_integer_value(json);
  }
  else if ( json && json->type == JSON_REAL )
  {
    *(double *)&json = json_real_value(json);
  }
  LODWORD(result) = json;
  return result;
}
// 6AC78: variables would overlap: r0.4 and r0.8
// 6AC78: bad return variable

//----- (0006ACD8) --------------------------------------------------------
json_t_0 *json_true()
{
  return &the_true_7351;
}

//----- (0006ACEC) --------------------------------------------------------
json_t_0 *json_false()
{
  return &the_false_7355;
}

//----- (0006AD00) --------------------------------------------------------
json_t_0 *json_null()
{
  return &the_null_7359;
}

//----- (0006AD14) --------------------------------------------------------
void __cdecl json_delete(json_t_0 *json)
{
  if ( json )
  {
    switch ( json->type )
    {
      case JSON_OBJECT:
        json_delete_object((json_object_t *)json);
        break;
      case JSON_ARRAY:
        json_delete_array((json_array_t *)json);
        break;
      case JSON_STRING:
        json_delete_string((json_string_t *)json);
        break;
      case JSON_INTEGER:
        json_delete_integer((json_integer_t *)json);
        break;
      case JSON_REAL:
        json_delete_real((json_real_t *)json);
        break;
      default:
        return;
    }
  }
}

//----- (0006AD7C) --------------------------------------------------------
int __cdecl json_equal(json_t_0 *json1, json_t_0 *json2)
{
  int v2; // r3

  if ( !json1 || !json2 )
    return 0;
  if ( json1->type != json2->type )
    return 0;
  if ( json1 == json2 )
    return 1;
  switch ( json1->type )
  {
    case JSON_OBJECT:
      v2 = json_object_equal(json1, json2);
      break;
    case JSON_ARRAY:
      v2 = json_array_equal(json1, json2);
      break;
    case JSON_STRING:
      v2 = json_string_equal(json1, json2);
      break;
    case JSON_INTEGER:
      v2 = json_integer_equal(json1, json2);
      break;
    case JSON_REAL:
      v2 = json_real_equal(json1, json2);
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (0006AE1C) --------------------------------------------------------
json_t_0 *__cdecl json_copy(json_t_0 *json)
{
  json_t_0 *v1; // r3

  if ( !json )
    return 0;
  switch ( json->type )
  {
    case JSON_OBJECT:
      v1 = json_object_copy(json);
      break;
    case JSON_ARRAY:
      v1 = json_array_copy(json);
      break;
    case JSON_STRING:
      v1 = json_string_copy(json);
      break;
    case JSON_INTEGER:
      v1 = json_integer_copy(json);
      break;
    case JSON_REAL:
      v1 = json_real_copy(json);
      break;
    case JSON_TRUE:
    case JSON_FALSE:
    case JSON_NULL:
      v1 = json;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}

//----- (0006AEA0) --------------------------------------------------------
json_t_0 *__cdecl json_deep_copy(const json_t_0 *json)
{
  json_t_0 *v1; // r3

  if ( !json )
    return 0;
  switch ( json->type )
  {
    case JSON_OBJECT:
      v1 = json_object_deep_copy(json);
      break;
    case JSON_ARRAY:
      v1 = json_array_deep_copy(json);
      break;
    case JSON_STRING:
      v1 = json_string_copy(json);
      break;
    case JSON_INTEGER:
      v1 = json_integer_copy(json);
      break;
    case JSON_REAL:
      v1 = json_real_copy(json);
      break;
    case JSON_TRUE:
    case JSON_FALSE:
    case JSON_NULL:
      v1 = (json_t_0 *)json;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}

//----- (0006AF24) --------------------------------------------------------
void *__cdecl rpl_memchr(const void *s, int c_in, size_t n)
{
  int repeated_c; // [sp+14h] [bp+14h]
  const rpl_memchr::longword *longword_ptr; // [sp+20h] [bp+20h]
  const unsigned __int8 *char_ptra; // [sp+24h] [bp+24h]

  while ( n && ((unsigned __int8)s & 3) != 0 )
  {
    if ( (unsigned __int8)c_in == *(unsigned __int8 *)s )
      return (void *)s;
    --n;
    s = (char *)s + 1;
  }
  for ( longword_ptr = (const rpl_memchr::longword *)s; n > 3; ++longword_ptr )
  {
    repeated_c = ((((unsigned __int8)c_in << 8) | (unsigned __int8)c_in) << 16) | ((unsigned __int8)c_in << 8) | (unsigned __int8)c_in;
    if ( (((repeated_c ^ *longword_ptr) - 16843009) & ~(repeated_c ^ *longword_ptr) & 0x80808080) != 0 )
      break;
    n -= 4;
  }
  char_ptra = (const unsigned __int8 *)longword_ptr;
  while ( n )
  {
    if ( (unsigned __int8)c_in == *char_ptra )
      return (void *)char_ptra;
    --n;
    ++char_ptra;
  }
  return 0;
}

//----- (0006AFF0) --------------------------------------------------------
size_t __cdecl critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period)
{
  unsigned __int8 b; // [sp+12h] [bp+12h]
  unsigned __int8 ba; // [sp+12h] [bp+12h]
  unsigned __int8 a; // [sp+13h] [bp+13h]
  unsigned __int8 aa; // [sp+13h] [bp+13h]
  size_t p; // [sp+14h] [bp+14h]
  size_t pa; // [sp+14h] [bp+14h]
  size_t k; // [sp+18h] [bp+18h]
  size_t ka; // [sp+18h] [bp+18h]
  size_t j; // [sp+1Ch] [bp+1Ch]
  size_t ja; // [sp+1Ch] [bp+1Ch]
  size_t max_suffix_rev; // [sp+20h] [bp+20h]
  size_t max_suffix; // [sp+24h] [bp+24h]

  if ( needle_len > 2 )
  {
    max_suffix = -1;
    j = 0;
    p = 1;
    k = 1;
    while ( j + k < needle_len )
    {
      a = needle[j + k];
      b = needle[max_suffix + k];
      if ( a >= (unsigned int)b )
      {
        if ( a == b )
        {
          if ( k == p )
          {
            j += p;
            k = 1;
          }
          else
          {
            ++k;
          }
        }
        else
        {
          max_suffix = j++;
          p = 1;
          k = 1;
        }
      }
      else
      {
        j += k;
        k = 1;
        p = j - max_suffix;
      }
    }
    *period = p;
    max_suffix_rev = -1;
    ja = 0;
    pa = 1;
    ka = 1;
    while ( ja + ka < needle_len )
    {
      aa = needle[ja + ka];
      ba = needle[max_suffix_rev + ka];
      if ( ba >= (unsigned int)aa )
      {
        if ( aa == ba )
        {
          if ( ka == pa )
          {
            ja += pa;
            ka = 1;
          }
          else
          {
            ++ka;
          }
        }
        else
        {
          max_suffix_rev = ja++;
          pa = 1;
          ka = 1;
        }
      }
      else
      {
        ja += ka;
        ka = 1;
        pa = ja - max_suffix_rev;
      }
    }
    if ( max_suffix_rev + 1 >= max_suffix + 1 )
    {
      *period = pa;
      return max_suffix_rev + 1;
    }
    else
    {
      return max_suffix + 1;
    }
  }
  else
  {
    *period = 1;
    return needle_len - 1;
  }
}

//----- (0006B160) --------------------------------------------------------
void *__cdecl two_way_short_needle(
        const unsigned __int8 *haystack,
        size_t haystack_len,
        const unsigned __int8 *needle,
        size_t needle_len)
{
  size_t v4; // r3
  size_t v6; // r3
  size_t period; // [sp+14h] [bp+14h] BYREF
  size_t suffix; // [sp+18h] [bp+18h]
  size_t memory; // [sp+1Ch] [bp+1Ch]
  size_t j; // [sp+20h] [bp+20h]
  size_t i; // [sp+24h] [bp+24h]

  suffix = critical_factorization(needle, needle_len, &period);
  if ( !memcmp(needle, &needle[period], suffix) )
  {
    memory = 0;
    j = 0;
    while ( haystack_len - needle_len >= j )
    {
      v4 = memory;
      if ( suffix >= memory )
        v4 = suffix;
      for ( i = v4; i < needle_len && needle[i] == haystack[i + j]; ++i )
        ;
      if ( needle_len > i )
      {
        j += i - suffix + 1;
        memory = 0;
      }
      else
      {
        for ( i = suffix - 1; i + 1 > memory && needle[i] == haystack[i + j]; --i )
          ;
        if ( i + 1 < memory + 1 )
          return (void *)&haystack[j];
        j += period;
        memory = needle_len - period;
      }
    }
  }
  else
  {
    v6 = suffix;
    if ( needle_len - suffix >= suffix )
      v6 = needle_len - suffix;
    period = v6 + 1;
    j = 0;
    while ( haystack_len - needle_len >= j )
    {
      for ( i = suffix; i < needle_len && needle[i] == haystack[i + j]; ++i )
        ;
      if ( needle_len > i )
      {
        j += i - suffix + 1;
      }
      else
      {
        for ( i = suffix - 1; i != -1 && needle[i] == haystack[i + j]; --i )
          ;
        if ( i == -1 )
          return (void *)&haystack[j];
        j += period;
      }
    }
  }
  return 0;
}

//----- (0006B30C) --------------------------------------------------------
void *__cdecl two_way_long_needle(
        const unsigned __int8 *haystack,
        size_t haystack_len,
        const unsigned __int8 *needle,
        size_t needle_len)
{
  size_t v4; // r3
  size_t v6; // r3
  size_t shift_table[256]; // [sp+14h] [bp+14h]
  size_t period; // [sp+414h] [bp+414h] BYREF
  size_t shift_0; // [sp+418h] [bp+418h]
  size_t suffix; // [sp+41Ch] [bp+41Ch]
  size_t shift; // [sp+420h] [bp+420h]
  size_t memory; // [sp+424h] [bp+424h]
  size_t j; // [sp+428h] [bp+428h]
  size_t i; // [sp+42Ch] [bp+42Ch]

  suffix = critical_factorization(needle, needle_len, &period);
  for ( i = 0; i <= 0xFF; ++i )
    shift_table[i] = needle_len;
  for ( i = 0; i < needle_len; ++i )
    shift_table[needle[i]] = needle_len - i - 1;
  if ( !memcmp(needle, &needle[period], suffix) )
  {
    memory = 0;
    j = 0;
    while ( haystack_len - needle_len >= j )
    {
      shift = shift_table[haystack[j - 1 + needle_len]];
      if ( shift )
      {
        if ( memory && shift < period )
          shift = needle_len - period;
        memory = 0;
        j += shift;
      }
      else
      {
        v4 = memory;
        if ( suffix >= memory )
          v4 = suffix;
        for ( i = v4; needle_len - 1 > i && needle[i] == haystack[i + j]; ++i )
          ;
        if ( needle_len - 1 > i )
        {
          j += i - suffix + 1;
          memory = 0;
        }
        else
        {
          for ( i = suffix - 1; i + 1 > memory && needle[i] == haystack[i + j]; --i )
            ;
          if ( i + 1 < memory + 1 )
            return (void *)&haystack[j];
          j += period;
          memory = needle_len - period;
        }
      }
    }
  }
  else
  {
    v6 = suffix;
    if ( needle_len - suffix >= suffix )
      v6 = needle_len - suffix;
    period = v6 + 1;
    j = 0;
    while ( haystack_len - needle_len >= j )
    {
      shift_0 = shift_table[haystack[j - 1 + needle_len]];
      if ( shift_0 )
      {
        j += shift_0;
      }
      else
      {
        for ( i = suffix; needle_len - 1 > i && needle[i] == haystack[i + j]; ++i )
          ;
        if ( needle_len - 1 > i )
        {
          j += i - suffix + 1;
        }
        else
        {
          for ( i = suffix - 1; i != -1 && needle[i] == haystack[i + j]; --i )
            ;
          if ( i == -1 )
            return (void *)&haystack[j];
          j += period;
        }
      }
    }
  }
  return 0;
}

//----- (0006B6AC) --------------------------------------------------------
void *__cdecl memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len)
{
  char *haystack_lenb; // [sp+8h] [bp+8h]
  const unsigned __int8 *haystack; // [sp+14h] [bp+14h]

  if ( !needle_len )
    return (void *)haystack_start;
  if ( haystack_len < needle_len )
    return 0;
  if ( needle_len > 0x1F )
    return two_way_long_needle(
             (const unsigned __int8 *)haystack_start,
             haystack_len,
             (const unsigned __int8 *)needle_start,
             needle_len);
  haystack = (const unsigned __int8 *)rpl_memchr(haystack_start, *(unsigned __int8 *)needle_start, haystack_len);
  if ( !haystack || needle_len == 1 )
    return (void *)haystack;
  haystack_lenb = (char *)(haystack_len + (_BYTE *)haystack_start - haystack);
  if ( (unsigned int)haystack_lenb >= needle_len )
    return two_way_short_needle(haystack, (size_t)haystack_lenb, (const unsigned __int8 *)needle_start, needle_len);
  else
    return 0;
}

//----- (0006B9BE) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_6BA00 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 6B9C2: variable 'v2' is possibly undefined

//----- (0006C004) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (0006C080) --------------------------------------------------------
__int64 __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // r0

  result = a1 / a2;
  *a3 = a1 - result * a2;
  return result;
}

//----- (0006C0B0) --------------------------------------------------------
unsigned __int64 __fastcall _gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  unsigned __int64 result; // r0

  result = a1 / a2;
  *a3 = a1 - result * a2;
  return result;
}

//----- (0006C728) --------------------------------------------------------
__int64 init()
{
  unsigned int v0; // r5
  int i; // r4
  __int64 (__fastcall *v2)(); // t1
  __int64 result; // r0

  init_proc();
  v0 = 0x8508Cu;
  for ( i = 0; i != 1; ++i )
  {
    v2 = *(__int64 (__fastcall **)())(v0 + 4);
    v0 += 4;
    result = v2();
  }
  return result;
}

//----- (0006C770) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1519 queued=1167 decompiled=1167 lumina nreq=0 worse=0 better=0
// ALL OK, 1167 function(s) have been successfully decompiled
