/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_10DEC();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// void setbuf(FILE *stream, char *buf);
// int strcmp(const char *s1, const char *s2);
// int printf(const char *format, ...);
// int _isoc99_fscanf(_DWORD, const char *, ...); weak
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// time_t time(time_t *timer);
// __off_t lseek(int fd, __off_t offset, int whence);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned int sleep(unsigned int seconds);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int pthread_cond_destroy(pthread_cond_t *cond);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int usleep(__useconds_t useconds);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int puts(const char *s);
// void *malloc(size_t size);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// struct tm *localtime(const time_t *timer);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// void exit(int status);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int fprintf(FILE *stream, const char *format, ...);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// int pthread_cancel(pthread_t th);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// int pthread_join(pthread_t th, void **thread_return);
// int sprintf(char *s, const char *format, ...);
// int _isoc99_scanf(const char *, ...); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int fseek(FILE *stream, int off, int whence);
// int isatty(int fd);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// int close(int fd);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_weak_fn();
int *deregister_tm_clones();
int register_tm_clones(); // idb
int *_do_global_dtors_aux();
int frame_dummy(); // idb
uint64_t __cdecl load64(const void *src);
void __cdecl store32(void *dst, uint32_t w);
void __cdecl store64(void *dst, uint64_t w);
uint64_t __cdecl rotr64(const uint64_t w, const unsigned int c);
void __cdecl secure_zero_memory(void *v, size_t n);
int __cdecl blake2b_set_lastnode(blake2b_state *S);
int __cdecl blake2b_is_lastblock(const blake2b_state *S);
int __cdecl blake2b_set_lastblock(blake2b_state *S);
int __cdecl blake2b_increment_counter(blake2b_state *S, const uint64_t inc);
int __cdecl blake2b_init0(blake2b_state *S);
int __cdecl blake2b_init_param(blake2b_state *S, const blake2b_param *P);
int __cdecl blake2b_init(blake2b_state *S, const uint8_t outlen);
int __cdecl blake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen);
int __cdecl blake2b_compress(blake2b_state *S, const uint8_t *block);
int __cdecl blake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen);
int __cdecl blake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen);
int __cdecl blake2b(uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen);
__int64 miner_now(); // idb
int __cdecl bm174x_ioctl(int fd, uint32_t oper_type, void *param);
uint32_t __cdecl target_zero_cal(uint8_t *target);
uint32_t __fastcall targetValidator(const void *a1, const void *a2);
int __fastcall read_register(int a1, char a2, char a3, char a4);
int __fastcall write_register_2(int a1, char a2, char a3, char a4, int a5);
int __fastcall write_register(char a1, int a2);
int set_i2c_enable();
int __fastcall i2c_status(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall i2c_recv(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, _DWORD *a5);
int __fastcall i2c_send(unsigned __int8 a1, char a2, char a3, char a4, char a5);
void asic_num_calculate();
int __fastcall calculate_asic_number(unsigned int a1);
int asic_addr_interval();
int __fastcall set_frequency(int a1);
int __fastcall set_frequency_scanfreq(int result);
int __fastcall set_ticket_mask(int result);
int set_io_drive_strength();
int __fastcall set_baud_chain(int result);
int set_address();
int __fastcall set_core_timeout(int result);
int __fastcall set_txn_data(int result);
int __fastcall set_nonce_shift(char a1);
int __fastcall set_pt_ctrl(int result, char a2);
int __fastcall set_pt_result(int result, char a2);
int __fastcall x86_tty_open(int a1, int a2);
int x86_tty_close();
int __fastcall x86_tty_init(int a1, uint32_t a2);
int nonce_scanhash(); // weak
void __noreturn nonce_scanhash_loop();
int __fastcall nonce_integrality(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4);
void clear_register_value_buf(); // idb
int __fastcall pm_handle(int a1, size_t a2, unsigned __int8 a3);
int __fastcall pt_handle(int a1, int a2, unsigned __int8 a3);
int __fastcall reg_handle(int a1, char a2, char a3);
int __fastcall nonce_handle(int a1, int a2, const unsigned __int8 *a3, size_t a4, char a5);
void __cdecl add_point(int *point, int MAX_SIZE);
void __noreturn handle_asic_response();
int bm1744_app_init();
int bm1744_app_exit();
int __fastcall work_list_insert(char a1, const void *a2);
int __fastcall work_list_find(char a1, void *a2);
int __fastcall send_work(const unsigned __int8 *a1, char a2, char a3);
int __fastcall read_sensor(unsigned __int8 a1, int a2, char a3, unsigned __int8 a4, _BYTE *a5);
void app_config_init_registers();
void __noreturn rw_register_loop();
uint8_t __cdecl get_bt8d_from_baud(const uint32_t baud);
int __fastcall get_index_by_freq(int a1);
int __fastcall get_freq_by_index(int a1);
int __fastcall get_plldata(int result, _DWORD *a2);
int __cdecl makeup_work_pkg(uint8_t *str, uint8_t *work_str);
int __cdecl makeup_set_address_cmd(uint8_t *str, uint32_t str_len, uint8_t chip_addr);
int __cdecl makeup_set_config_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr, uint32_t regdata);
int __cdecl makeup_get_status_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr);
int __cdecl makeup_chain_inactive_cmd(uint8_t *str, uint32_t str_len);
int __cdecl bm174x_pack_ioctl_pkg(uint8_t *str, uint32_t str_len, uint32_t oper_type, void *param);
int __fastcall add_reg_item(int a1, int a2, int a3);
int __fastcall read_reg_item(unsigned __int8 *a1, int a2);
int reg_scan_aging();
int reg_scan_init();
int reg_scan_exit();
unsigned int __fastcall _bswap_32(unsigned int a1);
unsigned int __fastcall compressArray(int a1, int a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6);
unsigned int __fastcall expandArray(int a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6);
unsigned int __fastcall getIndices(int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl isZero(const uint8_t *hash, size_t len);
void __cdecl generateHash(blake2b_state *S, const uint32_t g, uint8_t *hash, const size_t hashLen);
int __cdecl compareSR(const void *p1, const void *p2);
void __cdecl sort_pair(uint32_t *a, uint32_t len);
int __cdecl sortValidator(void *data, const unsigned __int8 *soln);
void __cdecl zcashPerson(uint8_t *person, const int n, const int k);
void __cdecl digestInit(blake2b_state *S, const int n, const int k);
int __fastcall CRC5(_BYTE *, unsigned __int8); // idb
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len);
int bitmain_axi_init(); // idb
void bitmain_axi_close(); // idb
unsigned int __cdecl read_axi_fpga(unsigned int address);
void __cdecl write_axi_fpga(unsigned int address, unsigned int data);
void init_fpga(); // idb
void __cdecl get_return_nonce(unsigned int *buf);
void __cdecl set_BC_command_buffer(unsigned int *value);
unsigned int get_BC_write_command();
void __cdecl set_BC_write_command(unsigned int value);
unsigned __int8 __cdecl asic_baud_to_fpga_baud(unsigned __int8 asic_baud);
void __cdecl set_fpga_baud(unsigned __int8 asic_baud);
void __cdecl i2c_write(unsigned int config_data);
unsigned __int8 __cdecl i2c_read(unsigned int config_data);
int __fastcall ISL_page_enable(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall ISL_on(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_off(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_set_on_off_config(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall ISL_set_clear_faults(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_set_write_protect(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall ISL_set_vout_command(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int16 a4);
int __fastcall ISL_set_apply_settings(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall ISL_get_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3, _WORD *a4);
int __fastcall ISL_read_reg_default(unsigned __int8 a1, unsigned __int8 a2, char a3);
uint16_t __cdecl ISL_set_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage);
int open_key(); // idb
void close_key(); // idb
ssize_t __cdecl read_key(unsigned __int8 value);
int open_lcd(); // idb
int close_lcd(); // idb
void __cdecl write_lcd(unsigned int line, unsigned __int8 *buf, unsigned int size);
void __cdecl write_lcd_no_memset(unsigned int line, unsigned __int8 *buf, unsigned int size);
int open_red_led(); // idb
void close_red_led(); // idb
void red_led_on(); // idb
ssize_t red_led_off();
int open_green_led(); // idb
void close_green_led(); // idb
ssize_t green_led_on();
ssize_t green_led_off();
int __cdecl main(int argc, const char **argv, const char **envp);
void miner_start();
void miner_join();
int __fastcall print_solver_line(int a1, int a2, int a3, int a4);
int __fastcall set_baud(int a1);
int bm1744_hashboard_init();
void *show_nonce_detail();
void __noreturn singleboard_sensor_test(); // weak
int singleboard_set_address_test();
int __fastcall singleboard_step_increase_frequency(int a1, int a2);
void *singleboard_nonce_test();
unsigned int singleboard_patten_test();
int pcba_test();
int __cdecl vol_init(unsigned __int16 vol);
int __fastcall isl_communication_check(unsigned __int16 a1);
int start_single_board_test();
int hw_test_customized();
int pcba_app_manual_test();
int start_pcba_test();
void __cdecl write_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data);
unsigned __int8 __cdecl read_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain);
int __fastcall write_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5, int a6);
int __fastcall read_dc_dc(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, int a5, int a6);
int __cdecl set_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 flash_addr_h, unsigned __int8 flash_addr_l);
int __cdecl send_data_to_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl read_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *flash_addr_h, unsigned __int8 *flash_addr_l);
int __cdecl read_PIC16F1704_flash_data(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl erase_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl write_data_into_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl jump_from_loader_to_app_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall reset_PIC16F1704_pic(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl set_PIC16F1704_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage);
int __cdecl write_hash_ID_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 *buf);
int __cdecl read_hash_id_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl enable_PIC16F1704_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable);
int __cdecl heart_beat_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c);
void *__cdecl pic_heart_beat_func(void *arg);
int __cdecl get_PIC16F1704_software_version(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *version);
int __cdecl PIC16F1704_i2c_forward_send(uint32_t i2c, uint8_t chain, uint8_t dev_addr, int rw_flag, uint8_t reg_addr, int len, uint8_t *data);
void __cdecl set_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain, uint16_t vol);
void __cdecl get_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain);
int __cdecl get_PIC16F1704_voltage(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *voltage);
int __cdecl write_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl read_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __cdecl erase_PIC16F1704_app_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl PIC1704_update_pic_app_program(unsigned int which_i2c, unsigned __int8 which_chain);
int __cdecl save_freq_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 freq);
int __cdecl get_PIC16F1704_freq(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 *freq);
void __cdecl set_temperature_offset_value(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *value);
int __cdecl write_PIC16F1705_iic_slave(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf, unsigned __int8 buf_len);
int __cdecl read_PIC16F1705_iic_slave(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf, unsigned __int8 buf_len, unsigned __int8 *read_back_buf);
int __fastcall write_data_to_PIC16F1704_flash(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 *a3, signed int a4);
int __cdecl read_data_from_PIC16F1704_flash(int which_chain, int which_i2c, unsigned __int8 *buf, unsigned __int8 read_len);
unsigned int get_fan_speed();
void __fastcall set_fan_speed(unsigned int a1);
void __cdecl fan_control(unsigned __int8 level);
int __fastcall uart_open(const char *a1, _DWORD *a2);
int __cdecl uart_exit(int fd);
unsigned int __cdecl check_how_many_uart_data_in_fpga(unsigned __int8 which_uart);
unsigned int __cdecl read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length);
unsigned int __cdecl uart_send(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length);
unsigned int __cdecl uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length);
int __fastcall clear_uart_send_fifo(unsigned __int8 a1);
unsigned int __cdecl clear_uart_rx_fifo(unsigned __int8 which_chain);
int cgpu_init();
void cgpu_exit(); // idb
int __cdecl v9_key_read(unsigned __int8 *command, int len);
ssize_t display_arguments();
int check_chain();
void V9_print_lcd();
void __fastcall V9_print_lcd_type(int a1);
int __fastcall is_asic_pass(int a1);
int show_stats_func_z11_3chips();
int show_stats_func_z9_4chips();
int show_stats_func_z9_16chips();
int singleBoardTest_V9_BM1744_manual();
int singleBoardTest_V9_BM1744();
void *__fastcall get_app_config(void *a1);
int __fastcall app_config_handle(const char *a1);
unsigned __int16 __cdecl crc_itu_t_byte(unsigned __int16 crc, const unsigned __int8 data);
unsigned __int16 __cdecl CRC16_v1(const unsigned __int8 *buffer, int len);
int __fastcall CRC5_v1(_BYTE *a1, unsigned __int8 a2);
int power_init();
void power_exit();
int power_up();
int power_down();
int __fastcall my_log_curses(int result, const char *a2, const char *a3, char a4);
int __fastcall applog(int a1, const char *a2, char a3);
void __cdecl simplelog(int prio, const unsigned __int8 *str, bool force);
int patten_info_init();
void patten_info_destory(); // idb
int patten_load();
int __fastcall is_patten_match(int a1, const void *a2, const void *a3);
int display_single_board_test();
void clear_last_test_results(); // idb
int __fastcall rt_ringbuffer_get_size(int a1);
int __fastcall rt_ringbuffer_status(int a1);
uint16_t __cdecl rt_ringbuffer_data_len(rt_ringbuffer *rb);
int __fastcall rt_ringbuffer_init(int a1, int a2, __int16 a3, int a4);
void __cdecl rt_ringbuffer_lock_destory(rt_ringbuffer *rb);
uint32_t __cdecl rt_ringbuffer_put(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length);
uint32_t __cdecl rt_ringbuffer_put_force(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length);
uint32_t __cdecl rt_ringbuffer_get(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length);
uint32_t __cdecl rt_ringbuffer_prefetch(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length);
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __cdecl Sha256_Init(CSha256 *p);
void __cdecl Sha256_Transform(uint32_t *state, const uint32_t *data);
void __cdecl Sha256_WriteByteBlock(CSha256 *p);
void __cdecl Sha256_Update(CSha256 *p, const uint8_t *data, size_t size);
void __cdecl Sha256_Final(CSha256 *p, uint8_t *digest);
void __cdecl Sha256_Onestep(const uint8_t *data, size_t size, uint8_t *digest);
void __cdecl sha2_starts(sha2_context *ctx);
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
unsigned int __fastcall swab32(unsigned int a1);
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length);
void __cdecl flip32(void *dest_p, const void *src_p);
int __fastcall slt_notify_ui(int result, int a2);
int slt_init();
int slt_exit();
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len);
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len);
int __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len);
unsigned __int8 __cdecl swap_bit(unsigned __int8 chr);
void __fastcall dump_str(FILE *a1, const char *a2, const unsigned __int8 *a3, size_t a4);
unsigned __int8 __cdecl bit_read(unsigned __int8 *y, int x);
void __cdecl swab256(void *dest_p, void *src_p);
int __fastcall divsi3_skip_div0_test(int result, unsigned int); // idb
int _aeabi_ldiv0();
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_12520; // weak
_UNKNOWN loc_12528; // weak
_UNKNOWN loc_12530; // weak
_UNKNOWN loc_12538; // weak
_UNKNOWN loc_1253C; // weak
_UNKNOWN loc_12540; // weak
_UNKNOWN loc_12544; // weak
_UNKNOWN locret_12548; // weak
_UNKNOWN loc_1254C; // weak
_UNKNOWN loc_12550; // weak
_UNKNOWN loc_12554; // weak
_UNKNOWN loc_333F0; // weak
_QWORD blake2b_IV[8] =
{
  7640891576956012808LL,
  -4942790177534073029LL,
  4354685564936845355LL,
  -6534734903238641935LL,
  5840696475078001361LL,
  -7276294671716946913LL,
  2270897969802886507LL,
  6620516959819538809LL
}; // weak
_BYTE chCRCHTalbe[256] =
{
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64
}; // weak
_BYTE chCRCLTalbe[256] =
{
  0,
  -64,
  -63,
  1,
  -61,
  3,
  2,
  -62,
  -58,
  6,
  7,
  -57,
  5,
  -59,
  -60,
  4,
  -52,
  12,
  13,
  -51,
  15,
  -49,
  -50,
  14,
  10,
  -54,
  -53,
  11,
  -55,
  9,
  8,
  -56,
  -40,
  24,
  25,
  -39,
  27,
  -37,
  -38,
  26,
  30,
  -34,
  -33,
  31,
  -35,
  29,
  28,
  -36,
  20,
  -44,
  -43,
  21,
  -41,
  23,
  22,
  -42,
  -46,
  18,
  19,
  -45,
  17,
  -47,
  -48,
  16,
  -16,
  48,
  49,
  -15,
  51,
  -13,
  -14,
  50,
  54,
  -10,
  -9,
  55,
  -11,
  53,
  52,
  -12,
  60,
  -4,
  -3,
  61,
  -1,
  63,
  62,
  -2,
  -6,
  58,
  59,
  -5,
  57,
  -7,
  -8,
  56,
  40,
  -24,
  -23,
  41,
  -21,
  43,
  42,
  -22,
  -18,
  46,
  47,
  -17,
  45,
  -19,
  -20,
  44,
  -28,
  36,
  37,
  -27,
  39,
  -25,
  -26,
  38,
  34,
  -30,
  -29,
  35,
  -31,
  33,
  32,
  -32,
  -96,
  96,
  97,
  -95,
  99,
  -93,
  -94,
  98,
  102,
  -90,
  -89,
  103,
  -91,
  101,
  100,
  -92,
  108,
  -84,
  -83,
  109,
  -81,
  111,
  110,
  -82,
  -86,
  106,
  107,
  -85,
  105,
  -87,
  -88,
  104,
  120,
  -72,
  -71,
  121,
  -69,
  123,
  122,
  -70,
  -66,
  126,
  127,
  -65,
  125,
  -67,
  -68,
  124,
  -76,
  116,
  117,
  -75,
  119,
  -73,
  -74,
  118,
  114,
  -78,
  -77,
  115,
  -79,
  113,
  112,
  -80,
  80,
  -112,
  -111,
  81,
  -109,
  83,
  82,
  -110,
  -106,
  86,
  87,
  -105,
  85,
  -107,
  -108,
  84,
  -100,
  92,
  93,
  -99,
  95,
  -97,
  -98,
  94,
  90,
  -102,
  -101,
  91,
  -103,
  89,
  88,
  -104,
  -120,
  72,
  73,
  -119,
  75,
  -117,
  -118,
  74,
  78,
  -114,
  -113,
  79,
  -115,
  77,
  76,
  -116,
  68,
  -124,
  -123,
  69,
  -121,
  71,
  70,
  -122,
  -126,
  66,
  67,
  -125,
  65,
  -127,
  128,
  64
}; // weak
_BYTE isl68127_i2c_dev_addr[4] = { 80, 81, 84, 85 }; // weak
_WORD crc_itu_t_table[256] =
{
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  -32504,
  -28375,
  -24246,
  -20117,
  -15988,
  -11859,
  -7730,
  -3601,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  -27847,
  -31976,
  -19589,
  -23718,
  -11331,
  -15460,
  -3073,
  -7202,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  -23190,
  -19125,
  -31448,
  -27383,
  -6674,
  -2609,
  -14932,
  -10867,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  -18597,
  -22662,
  -26855,
  -30920,
  -2081,
  -6146,
  -10339,
  -14404,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  -13876,
  -9747,
  -5746,
  -1617,
  -30392,
  -26263,
  -22262,
  -18133,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  -9219,
  -13348,
  -1089,
  -5218,
  -25735,
  -29864,
  -17605,
  -21734,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  -4690,
  -625,
  -12820,
  -8755,
  -21206,
  -17141,
  -29336,
  -25271,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  -97,
  -4162,
  -8227,
  -12292,
  -16613,
  -20678,
  -24743,
  -28808,
  -28280,
  -32343,
  -20022,
  -24085,
  -12020,
  -16083,
  -3762,
  -7825,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  -31815,
  -27752,
  -23557,
  -19494,
  -15555,
  -11492,
  -7297,
  -3234,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  -18966,
  -23093,
  -27224,
  -31351,
  -2706,
  -6833,
  -10964,
  -15091,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  -22565,
  -18438,
  -30823,
  -26696,
  -6305,
  -2178,
  -14563,
  -10436,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  -9908,
  -13971,
  -1778,
  -5841,
  -26168,
  -30231,
  -18038,
  -22101,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  -13443,
  -9380,
  -5313,
  -1250,
  -29703,
  -25640,
  -21573,
  -17510,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  -722,
  -4849,
  -8852,
  -12979,
  -16982,
  -21109,
  -25112,
  -29239,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  -4321,
  -194,
  -12451,
  -8324,
  -20581,
  -16454,
  -28711,
  -24584,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
}; // weak
char byte_36B34[4] = { '\0', '\0', '\0', '\0' }; // weak
_DWORD K[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
_DWORD hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
_BYTE hex_6139[16] = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102 }; // weak
void *_frame_dummy_init_array_entry = (void *)0x111A5; // weak
int (__fastcall *memset_v_5089)(_DWORD, _DWORD, _DWORD) = &memset; // weak
char g_new_work = '\x01'; // weak
int g_pll_parameter = -2144337391; // weak
int g_ticket_mask = 5; // weak
int g_misc_control = 117455361; // weak
int g_core_timeout = -1; // weak
int g_io_drive_strength = 34677009; // weak
int g_nonce_shift = 20; // weak
int addr_interval = 85; // weak
void *status_period_8880 = &unk_7A120; // weak
_UNKNOWN baud_BT8D_values; // weak
_DWORD freq_pll[404] =
{
  25,
  0,
  0,
  2359654,
  100,
  131136,
  1056,
  2097729,
  125,
  163904,
  1056,
  2622017,
  150,
  196672,
  1056,
  3146305,
  175,
  229440,
  1056,
  3670593,
  200,
  262208,
  1056,
  4194881,
  225,
  294976,
  1056,
  4719169,
  250,
  327744,
  1056,
  5243457,
  275,
  360512,
  1056,
  5767745,
  300,
  393280,
  1056,
  6292033,
  325,
  426048,
  1056,
  6816321,
  350,
  458816,
  1056,
  7340609,
  375,
  491584,
  1056,
  7864897,
  400,
  524352,
  1056,
  8389185,
  404,
  397376,
  800,
  6357553,
  406,
  266304,
  544,
  4260385,
  408,
  401472,
  800,
  6423089,
  412,
  270400,
  544,
  4325921,
  416,
  409664,
  800,
  6554161,
  418,
  274496,
  544,
  4391457,
  420,
  413760,
  800,
  6619697,
  425,
  278592,
  544,
  4456993,
  429,
  421952,
  800,
  6750769,
  431,
  282688,
  544,
  4522529,
  433,
  426048,
  800,
  6816305,
  437,
  286784,
  544,
  4588065,
  441,
  434240,
  800,
  6947377,
  443,
  290880,
  544,
  4653601,
  445,
  438336,
  800,
  7012913,
  450,
  294976,
  544,
  4719137,
  454,
  446528,
  800,
  7143985,
  456,
  299072,
  544,
  4784673,
  458,
  450624,
  800,
  7209521,
  462,
  303168,
  544,
  4850209,
  466,
  458816,
  800,
  7340593,
  468,
  307264,
  544,
  4915745,
  470,
  462912,
  800,
  7406129,
  475,
  311360,
  544,
  4981281,
  479,
  471104,
  800,
  7537201,
  481,
  315456,
  544,
  5046817,
  483,
  475200,
  800,
  7602737,
  487,
  319552,
  544,
  5112353,
  491,
  483392,
  800,
  7733809,
  493,
  323648,
  544,
  5177889,
  495,
  487488,
  800,
  7799345,
  500,
  327744,
  544,
  5243425,
  504,
  495680,
  800,
  7930417,
  506,
  331840,
  544,
  5308961,
  508,
  499776,
  800,
  7995953,
  512,
  335936,
  544,
  5374497,
  516,
  507968,
  800,
  8127025,
  518,
  340032,
  544,
  5440033,
  520,
  512064,
  800,
  8192561,
  525,
  344128,
  544,
  5505569,
  529,
  520256,
  800,
  8323633,
  531,
  348224,
  544,
  5571105,
  533,
  524352,
  800,
  8389169,
  537,
  352320,
  544,
  5636641,
  543,
  356416,
  544,
  5702177,
  550,
  360512,
  544,
  5767713,
  556,
  364608,
  544,
  5833249,
  562,
  368704,
  544,
  5898785,
  568,
  372800,
  544,
  5964321,
  575,
  376896,
  544,
  6029857,
  581,
  380992,
  544,
  6095393,
  587,
  385088,
  544,
  6160929,
  593,
  389184,
  544,
  6226465,
  600,
  393280,
  544,
  6292001,
  606,
  397376,
  544,
  6357537,
  612,
  401472,
  544,
  6423073,
  618,
  405568,
  544,
  6488609,
  625,
  409664,
  544,
  6554145,
  631,
  413760,
  544,
  6619681,
  637,
  417856,
  544,
  6685217,
  643,
  421952,
  544,
  6750753,
  650,
  426048,
  544,
  6816289,
  656,
  430144,
  544,
  6881825,
  662,
  434240,
  544,
  6947361,
  668,
  438336,
  544,
  7012897,
  675,
  442432,
  544,
  7078433,
  681,
  446528,
  544,
  7143969,
  687,
  450624,
  544,
  7209505,
  693,
  454720,
  544,
  7275041,
  700,
  458816,
  544,
  7340577,
  706,
  462912,
  544,
  7406113,
  712,
  467008,
  544,
  7471649,
  718,
  471104,
  544,
  7537185,
  725,
  475200,
  544,
  7602721,
  731,
  479296,
  544,
  7668257,
  737,
  483392,
  544,
  7733793,
  743,
  487488,
  544,
  7799329,
  750,
  491584,
  544,
  7864865,
  756,
  495680,
  544,
  7930401,
  762,
  499776,
  544,
  7995937,
  768,
  503872,
  544,
  8061473,
  775,
  507968,
  544,
  8127009,
  781,
  512064,
  544,
  8192545,
  787,
  516160,
  544,
  8258081,
  793,
  520256,
  544,
  8323617,
  800,
  524352,
  544,
  8389153,
  825,
  270400,
  288,
  4325905
}; // weak
int alive = 1; // weak
int compare_size = 3; // weak
char lcd_output[2] = " "; // weak
char dword_47B4C[] = { '\0', '\0', '\0', '\0' }; // idb
int dword_47B50 = 0; // weak
int dword_47B54 = 0; // weak
int dword_47B58 = 0; // weak
char byte_47B5C[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char s[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_BYTE isl_dev_addr[4] = { 80, 81, 84, 0 }; // weak
char gChain = '\xFF'; // weak
int opt_log_level = 2; // weak
_DWORD sha256_h0[8] =
{
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
}; // weak
_DWORD sha256_k[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
int _bss_start; // weak
int stdin; // weak
int stdout; // weak
char completed_9251; // weak
char total_work; // weak
int g_general_i2c_command; // weak
int g_pt_ctrl; // weak
int nonce_num_each_asic[]; // weak
int dword_47E00; // weak
int dword_47E04; // weak
int nonce_invalid_num_each_asic[3]; // weak
int nonce_invalid_num_each_asic_2[]; // weak
int dword_47E18; // weak
int dword_47E1C; // weak
int dword_47E20; // weak
int dword_47E24; // weak
int dword_47E28; // weak
int one_work_nonce_each_asic[]; // weak
int dword_47E30; // weak
int dword_47E34; // weak
int one_work_invalid_nonce_each_asic[3]; // weak
_DWORD one_work_invalid_nonce_each_asic_2[6]; // weak
int valid_nonce_total; // weak
int invalid_nonce_total; // weak
int submit_nonce; // weak
_DWORD asic_num[1]; // weak
char sensor_chip_addr[]; // weak
char byte_47E6D; // weak
pthread_mutex_t g_rt_nonce_mutex; // weak
pthread_mutex_t nonce_mutex; // weak
char pattern_test_crc_error; // weak
char g_txok_test_enable; // weak
char start_recv; // weak
int g_work_list_insert_index; // weak
pthread_mutex_t g_work_list_mutex; // weak
int total_8876; // weak
int golden_nonce_8875; // weak
int total_shares_8877; // weak
__int64 t1_8879; // weak
__int64 t0_8878; // weak
int txok_flag_8982; // weak
int total_error_8981; // weak
int reg_scan_items[300]; // weak
pthread_mutex_t reg_scan_mutex; // weak
int p_reg_scan; // weak
int fpga_mem_addr; // weak
int axi_fpga_addr; // weak
int red_led_fd; // weak
int green_led_fd; // weak
int set_address_test_result; // weak
int read_temp_test_result; // weak
int tempture_value_test_result; // weak
char nonce_test_asic_result[]; // weak
char byte_483E5; // weak
char byte_483E6; // weak
pthread_mutex_t i2c_mutex; // weak
pthread_mutex_t uart_send_mutex[1]; // weak
pthread_mutex_t uart_receive_mutex[1]; // weak
_BYTE gChain_exist[4]; // weak
_UNKNOWN gChain_fd; // weak
char gI2c; // weak
int show_id_alive; // weak
char use_syslog; // weak
char opt_quiet; // weak
char opt_debug; // weak
char opt_log_output; // weak
pthread_mutex_t console_lock; // weak
int p_scanhash; // weak
int g_chain[8]; // weak
_UNKNOWN g_rt_nonce; // weak
_BYTE g_work_list[1412]; // weak
char sensor_info[]; // weak
char byte_48F51; // weak
char byte_48F54; // weak
char byte_48F55; // weak
_UNKNOWN unk_493E0; // weak
_UNKNOWN g_work_header; // weak
int nonce_fifo; // weak
int dword_49DF0; // weak
int dword_49DF4; // weak
_UNKNOWN unk_61A80; // weak
_UNKNOWN unk_7A120; // weak
int fd_fpga_mem; // weak
int fd_fpga; // weak
uint8_t g_work_info[32]; // weak
_UNKNOWN unk_F32D4; // weak
int dword_F3460; // weak
_UNKNOWN cgpu; // weak
pthread_t dword_F3484; // idb
pthread_t newthread; // idb
int dword_F34A0; // weak
int dword_F34A8; // weak
int dword_F34C8; // weak
_BYTE chain_info[4]; // weak
int app_conf; // weak
char byte_F34E0[40]; // weak
int dword_F3508; // weak
int dword_F3644; // weak
int dword_F3648; // weak
int dword_F364C; // weak
int dword_F3650; // weak
int dword_F3654; // weak
int dword_F3658; // weak
int dword_F365C; // weak
char s1[16]; // idb
int dword_F3670; // weak
int dword_F3674; // weak
int dword_F3678; // weak
int dword_F367C; // weak
int dword_F3680; // weak
int dword_F3684; // weak
int dword_F3688; // weak
int dword_F368C; // weak
int g_patten; // weak
int dword_F374C; // weak
int dword_F3750; // weak
int dword_F3754; // weak
int dword_F3758; // weak
int dword_F375C; // weak
int dword_F3760; // weak
char byte_F3770[16]; // weak
int dword_F3780; // weak
int dword_F3790; // weak
int dword_F37A0; // weak
int dword_F37A4; // weak
int dword_F37A8; // weak
int dword_F37AC; // weak
int dword_F37B0; // weak
int dword_F37B4; // weak
int dword_F37B8; // weak
int dword_F37BC; // weak
int dword_F37C0; // weak
int dword_F37C4; // weak
int dword_F37C8; // weak
pthread_mutex_t mutex; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00010DE0) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (00010DEC) --------------------------------------------------------
void sub_10DEC()
{
  JUMPOUT(0);
}
// 10DF8: control flows out of bounds to 0

//----- (000110E8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    _libc_csu_fini,
    a1,
    va);
  abort();
}
// 110F2: positive sp value 4 has been found
// 11104: variable 'v4' is possibly undefined

//----- (00011118) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 10FA4: using guessed type int _gmon_start__(void);

//----- (0001113C) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &_bss_start;
}
// 47DA8: using guessed type int _bss_start;

//----- (00011160) --------------------------------------------------------
int register_tm_clones()
{
  return 294312;
}

//----- (0001118C) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !completed_9251 )
  {
    result = deregister_tm_clones();
    completed_9251 = 1;
  }
  return result;
}
// 47DB8: using guessed type char completed_9251;

//----- (000111A4) --------------------------------------------------------
int frame_dummy()
{
  return register_tm_clones();
}

//----- (000111C8) --------------------------------------------------------
uint64_t __cdecl load64(const void *src)
{
  uint64_t v2; // [sp+28h] [bp+28h]

  LODWORD(v2) = *(unsigned __int8 *)src | (*((unsigned __int8 *)src + 1) << 8) | (*((unsigned __int8 *)src + 2) << 16) | (*((unsigned __int8 *)src + 3) << 24);
  HIDWORD(v2) = (*((unsigned __int8 *)src + 7) << 24) | (*((unsigned __int8 *)src + 6) << 16) | (*((unsigned __int8 *)src
                                                                                                 + 5) << 8) | *((unsigned __int8 *)src + 4);
  return v2;
}

//----- (0001132C) --------------------------------------------------------
void __cdecl store32(void *dst, uint32_t w)
{
  *(_DWORD *)dst = w;
}

//----- (00011388) --------------------------------------------------------
void __cdecl store64(void *dst, uint64_t w)
{
  *(_QWORD *)dst = w;
}

//----- (000114B0) --------------------------------------------------------
uint64_t __cdecl rotr64(const uint64_t w, const unsigned int c)
{
  return (w << (-(char)c & 0x3F)) | (w >> c);
}

//----- (00011524) --------------------------------------------------------
void __cdecl secure_zero_memory(void *v, size_t n)
{
  memset_v_5089(v, 0, n);
}
// 47440: using guessed type int (__fastcall *memset_v_5089)(_DWORD, _DWORD, _DWORD);

//----- (00011548) --------------------------------------------------------
int __cdecl blake2b_set_lastnode(blake2b_state *S)
{
  *((_DWORD *)S + 22) = -1;
  *((_DWORD *)S + 23) = -1;
  return 0;
}

//----- (0001156C) --------------------------------------------------------
int __cdecl blake2b_is_lastblock(const blake2b_state *S)
{
  return *((_QWORD *)S + 10) != 0LL;
}

//----- (00011590) --------------------------------------------------------
int __cdecl blake2b_set_lastblock(blake2b_state *S)
{
  if ( *((_BYTE *)S + 356) )
    blake2b_set_lastnode(S);
  *((_DWORD *)S + 20) = -1;
  *((_DWORD *)S + 21) = -1;
  return 0;
}

//----- (000115C0) --------------------------------------------------------
int __cdecl blake2b_increment_counter(blake2b_state *S, const uint64_t inc)
{
  *((_QWORD *)S + 8) += inc;
  *((_QWORD *)S + 9) += *((_QWORD *)S + 8) < inc;
  return 0;
}

//----- (00011620) --------------------------------------------------------
int __cdecl blake2b_init0(blake2b_state *S)
{
  int i; // [sp+Ch] [bp+Ch]

  memset(S, 0, 0x168u);
  for ( i = 0; i <= 7; ++i )
    *((_QWORD *)S + i) = blake2b_IV[i];
  return 0;
}
// 336B8: using guessed type _QWORD blake2b_IV[8];

//----- (00011670) --------------------------------------------------------
int __cdecl blake2b_init_param(blake2b_state *S, const blake2b_param *P)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  blake2b_init0(S);
  for ( i = 0; i <= 7; ++i )
    *((_QWORD *)S + i) ^= load64((char *)P + 8 * i);
  return 0;
}

//----- (000116D4) --------------------------------------------------------
int __cdecl blake2b_init(blake2b_state *S, const uint8_t outlen)
{
  char v5[4]; // [sp+8h] [bp+8h] BYREF
  int v6; // [sp+Ch] [bp+Ch] BYREF
  _BYTE v7[56]; // [sp+10h] [bp+10h] BYREF

  if ( !outlen || outlen > 0x40u )
    return -1;
  v5[0] = outlen;
  v5[1] = 0;
  v5[2] = 1;
  v5[3] = 1;
  store32(&v6, 0);
  store64(v7, 0LL);
  memset(&v7[8], 0, 48);
  return blake2b_init_param(S, (const blake2b_param *)v5);
}

//----- (00011774) --------------------------------------------------------
int __cdecl blake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen)
{
  uint8_t block[128]; // [sp+10h] [bp+10h] BYREF
  char v10[4]; // [sp+90h] [bp+90h] BYREF
  int v11; // [sp+94h] [bp+94h] BYREF
  _BYTE v12[56]; // [sp+98h] [bp+98h] BYREF

  if ( !outlen || outlen > 0x40u )
    return -1;
  if ( !key || !keylen || keylen > 0x40u )
    return -1;
  v10[0] = outlen;
  v10[1] = keylen;
  v10[2] = 1;
  v10[3] = 1;
  store32(&v11, 0);
  store64(v12, 0LL);
  memset(&v12[8], 0, 48);
  if ( blake2b_init_param(S, (const blake2b_param *)v10) < 0 )
    return -1;
  memset(block, 0, sizeof(block));
  memcpy(block, key, keylen);
  blake2b_update(S, block, 0x80uLL);
  secure_zero_memory(block, 0x80u);
  return 0;
}

//----- (00011888) --------------------------------------------------------
int __cdecl blake2b_compress(blake2b_state *S, const uint8_t *block)
{
  uint64_t v2; // r0
  __int64 v6; // [sp+8h] [bp+8h] BYREF
  __int64 v7; // [sp+10h] [bp+10h]
  __int64 v8; // [sp+18h] [bp+18h]
  __int64 v9; // [sp+20h] [bp+20h]
  uint64_t v10; // [sp+28h] [bp+28h]
  uint64_t v11; // [sp+30h] [bp+30h]
  uint64_t v12; // [sp+38h] [bp+38h]
  uint64_t v13; // [sp+40h] [bp+40h]
  __int64 v14; // [sp+48h] [bp+48h]
  __int64 v15; // [sp+50h] [bp+50h]
  __int64 v16; // [sp+58h] [bp+58h]
  __int64 v17; // [sp+60h] [bp+60h]
  unsigned __int64 v18; // [sp+68h] [bp+68h]
  unsigned __int64 v19; // [sp+70h] [bp+70h]
  unsigned __int64 v20; // [sp+78h] [bp+78h]
  unsigned __int64 v21; // [sp+80h] [bp+80h]
  uint64_t m[16]; // [sp+88h] [bp+88h]
  int i; // [sp+10Ch] [bp+10Ch]
  int v24; // [sp+110h] [bp+110h] BYREF

  for ( i = 0; i <= 15; ++i )
  {
    v2 = load64(&block[8 * i]);
    *((_QWORD *)&v24 + i - 17) = v2;
  }
  for ( i = 0; i <= 7; ++i )
    *(&v6 + i) = *((_QWORD *)S + i);
  v14 = 0x6A09E667F3BCC908LL;
  v15 = loc_12520;
  v16 = loc_12528;
  v17 = loc_12530;
  v18 = *((_QWORD *)S + 8) ^ __PAIR64__(loc_1253C, loc_12538);
  v19 = *((_QWORD *)S + 9) ^ __PAIR64__(loc_12544, loc_12540);
  v20 = *((_QWORD *)S + 10) ^ __PAIR64__(loc_1254C, locret_12548);
  v21 = *((_QWORD *)S + 11) ^ __PAIR64__(loc_12554, loc_12550);
  v6 += m[0] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[1] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[2] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[3] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[4] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[5] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[6] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[7] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[8] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[9] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[10] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[11] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[12] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[13] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[14] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[15] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[14] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[10] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[4] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[8] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[9] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[15] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[13] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[6] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[1] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[12] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[0] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[2] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[11] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[7] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[5] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[3] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[11] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[8] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[12] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[0] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[5] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[2] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[15] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[13] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[10] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[14] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[3] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[6] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[7] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[1] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[9] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[4] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[7] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[9] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[3] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[1] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[13] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[12] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[11] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[14] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[2] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[6] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[5] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[10] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[4] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[0] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[15] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[8] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[9] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[0] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[5] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[7] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[2] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[4] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[10] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[15] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[14] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[1] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[11] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[12] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[6] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[8] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[3] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[13] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[2] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[12] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[6] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[10] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[0] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[11] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[8] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[3] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[4] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[13] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[7] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[5] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[15] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[14] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[1] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[9] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[12] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[5] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[1] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[15] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[14] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[13] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[4] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[10] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[0] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[7] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[6] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[3] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[9] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[2] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[8] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[11] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[13] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[11] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[7] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[14] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[12] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[1] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[3] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[9] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[5] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[0] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[15] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[4] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[8] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[6] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[2] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[10] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[6] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[15] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[14] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[9] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[11] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[3] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[0] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[8] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[12] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[2] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[13] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[7] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[1] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[4] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[10] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[5] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[10] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[2] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[8] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[4] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[7] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[6] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[1] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[5] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[15] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[11] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[9] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[14] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[3] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[12] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[13] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[0] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[0] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[1] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[2] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[3] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[4] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[5] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[6] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[7] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[8] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[9] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[10] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[11] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[12] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[13] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[14] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[15] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  v6 += m[14] + v10;
  v18 = rotr64(v6 ^ v18, 0x20u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x18u);
  v6 += m[10] + v10;
  v18 = rotr64(v6 ^ v18, 0x10u);
  v14 += v18;
  v10 = rotr64(v14 ^ v10, 0x3Fu);
  v7 += m[4] + v11;
  v19 = rotr64(v7 ^ v19, 0x20u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x18u);
  v7 += m[8] + v11;
  v19 = rotr64(v7 ^ v19, 0x10u);
  v15 += v19;
  v11 = rotr64(v15 ^ v11, 0x3Fu);
  v8 += m[9] + v12;
  v20 = rotr64(v8 ^ v20, 0x20u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x18u);
  v8 += m[15] + v12;
  v20 = rotr64(v8 ^ v20, 0x10u);
  v16 += v20;
  v12 = rotr64(v16 ^ v12, 0x3Fu);
  v9 += m[13] + v13;
  v21 = rotr64(v9 ^ v21, 0x20u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x18u);
  v9 += m[6] + v13;
  v21 = rotr64(v9 ^ v21, 0x10u);
  v17 += v21;
  v13 = rotr64(v17 ^ v13, 0x3Fu);
  v6 += m[1] + v11;
  v21 = rotr64(v6 ^ v21, 0x20u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x18u);
  v6 += m[12] + v11;
  v21 = rotr64(v6 ^ v21, 0x10u);
  v16 += v21;
  v11 = rotr64(v16 ^ v11, 0x3Fu);
  v7 += m[0] + v12;
  v18 = rotr64(v7 ^ v18, 0x20u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x18u);
  v7 += m[2] + v12;
  v18 = rotr64(v7 ^ v18, 0x10u);
  v17 += v18;
  v12 = rotr64(v17 ^ v12, 0x3Fu);
  v8 += m[11] + v13;
  v19 = rotr64(v8 ^ v19, 0x20u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x18u);
  v8 += m[7] + v13;
  v19 = rotr64(v8 ^ v19, 0x10u);
  v14 += v19;
  v13 = rotr64(v14 ^ v13, 0x3Fu);
  v9 += m[5] + v10;
  v20 = rotr64(v9 ^ v20, 0x20u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x18u);
  v9 += m[3] + v10;
  v20 = rotr64(v9 ^ v20, 0x10u);
  v15 += v20;
  v10 = rotr64(v15 ^ v10, 0x3Fu);
  for ( i = 0; i <= 7; ++i )
    *((_QWORD *)S + i) ^= *(&v6 + i + 8) ^ *(&v6 + i);
  return 0;
}
// 1271A: fixed broken macro-insn

//----- (00019D14) --------------------------------------------------------
int __cdecl blake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen)
{
  size_t n; // [sp+10h] [bp+10h]
  int v8; // [sp+14h] [bp+14h]

  while ( inlen )
  {
    v8 = *((_DWORD *)S + 88);
    n = 256 - v8;
    if ( (unsigned int)(256 - v8) >= inlen )
    {
      memcpy((char *)S + v8 + 96, in, inlen);
      *((_DWORD *)S + 88) += inlen;
      in += inlen;
      inlen = 0LL;
    }
    else
    {
      memcpy((char *)S + v8 + 96, in, n);
      *((_DWORD *)S + 88) += n;
      blake2b_increment_counter(S, 0x80uLL);
      blake2b_compress(S, (const uint8_t *)S + 96);
      memcpy((char *)S + 96, (char *)S + 224, 0x80u);
      *((_DWORD *)S + 88) -= 128;
      in += n;
      inlen -= n;
    }
  }
  return 0;
}

//----- (00019E14) --------------------------------------------------------
int __cdecl blake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen)
{
  uint8_t buffer[64]; // [sp+14h] [bp+14h] BYREF
  int i; // [sp+54h] [bp+54h]

  memset(buffer, 0, sizeof(buffer));
  if ( !out || !outlen || outlen > 0x40u )
    return -1;
  if ( blake2b_is_lastblock(S) )
    return -1;
  if ( *((_DWORD *)S + 88) > 0x80u )
  {
    blake2b_increment_counter(S, 0x80uLL);
    blake2b_compress(S, (const uint8_t *)S + 96);
    *((_DWORD *)S + 88) -= 128;
    memcpy((char *)S + 96, (char *)S + 224, *((_DWORD *)S + 88));
  }
  blake2b_increment_counter(S, *((unsigned int *)S + 88));
  blake2b_set_lastblock(S);
  memset((char *)S + *((_DWORD *)S + 88) + 96, 0, 256 - *((_DWORD *)S + 88));
  blake2b_compress(S, (const uint8_t *)S + 96);
  for ( i = 0; i <= 7; ++i )
    store64(&buffer[8 * i], *((_QWORD *)S + i));
  memcpy(out, buffer, outlen);
  return 0;
}

//----- (00019F38) --------------------------------------------------------
int __cdecl blake2b(
        uint8_t *out,
        const void *in,
        const void *key,
        const uint8_t outlen,
        const uint64_t inlen,
        uint8_t keylen)
{
  char S[364]; // [sp+10h] [bp+10h] BYREF

  if ( !in && inlen )
    return -1;
  if ( !out )
    return -1;
  if ( !key && keylen )
    return -1;
  if ( !outlen || outlen > 0x40u )
    return -1;
  if ( keylen <= 0x40u )
  {
    if ( keylen )
    {
      if ( blake2b_init_key((blake2b_state *)S, outlen, key, keylen) < 0 )
        return -1;
    }
    else if ( blake2b_init((blake2b_state *)S, outlen) < 0 )
    {
      return -1;
    }
    blake2b_update((blake2b_state *)S, (const uint8_t *)in, inlen);
    blake2b_final((blake2b_state *)S, out, outlen);
    return 0;
  }
  return -1;
}

//----- (0001A038) --------------------------------------------------------
__int64 miner_now()
{
  struct timeval v1; // [sp+0h] [bp+0h] BYREF

  gettimeofday(&v1, 0);
  return v1.tv_usec + 1000000LL * v1.tv_sec;
}

//----- (0001A0B0) --------------------------------------------------------
int __cdecl bm174x_ioctl(int fd, uint32_t oper_type, void *param)
{
  unsigned __int8 fda; // [sp+Ch] [bp+Ch]
  uint8_t str[300]; // [sp+10h] [bp+10h] BYREF
  int v9; // [sp+13Ch] [bp+13Ch]

  fda = fd;
  memset(str, 0, sizeof(str));
  v9 = bm174x_pack_ioctl_pkg(str, 0x12Cu, oper_type, param);
  if ( v9 >= 0 )
    return uart_send(fda, str, v9);
  else
    return v9;
}

//----- (0001A124) --------------------------------------------------------
uint32_t __cdecl target_zero_cal(uint8_t *target)
{
  uint8_t tmphash[32]; // [sp+8h] [bp+8h] BYREF
  int k; // [sp+28h] [bp+28h]
  int j; // [sp+2Ch] [bp+2Ch]
  int i; // [sp+30h] [bp+30h]
  uint32_t v8; // [sp+34h] [bp+34h]

  v8 = 0;
  memset(tmphash, 0, sizeof(tmphash));
  for ( i = 0; i <= 31; ++i )
    tmphash[i] = target[31 - i];
  for ( j = 0; j <= 31; ++j )
  {
    for ( k = 7; k >= 0; --k )
    {
      if ( bit_read(&tmphash[j], k) )
        return v8;
      ++v8;
    }
  }
  return v8;
}

//----- (0001A1B8) --------------------------------------------------------
uint32_t __fastcall targetValidator(const void *a1, const void *a2)
{
  uint8_t v5[32]; // [sp+Ch] [bp+Ch] BYREF
  uint8_t v6[32]; // [sp+2Ch] [bp+2Ch] BYREF
  _WORD v7[745]; // [sp+4Ch] [bp+4Ch] BYREF
  char v8; // [sp+61Eh] [bp+61Eh]

  v7[744] = 16637;
  v8 = 5;
  memset(v7, 0, 0x5CFu);
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  memcpy(v7, a1, 0x8Cu);
  v7[70] = 16637;
  LOBYTE(v7[71]) = 5;
  memcpy((char *)&v7[71] + 1, a2, 0x540u);
  Sha256_Onestep((const uint8_t *)v7, 0x5CFu, v6);
  Sha256_Onestep(v6, 0x20u, v5);
  return target_zero_cal(v5);
}

//----- (0001A280) --------------------------------------------------------
int __fastcall read_register(int a1, char a2, char a3, char a4)
{
  char v5[4]; // [sp+10h] [bp+10h] BYREF
  int v6; // [sp+14h] [bp+14h]

  v5[1] = a2;
  v5[0] = a3;
  v5[2] = a4;
  v6 = 0;
  return bm174x_ioctl(g_chain[8 * a1], 0, v5);
}
// 4845C: using guessed type int g_chain[8];

//----- (0001A2CC) --------------------------------------------------------
int __fastcall write_register_2(int a1, char a2, char a3, char a4, int a5)
{
  char v6[4]; // [sp+10h] [bp+10h] BYREF
  int v7; // [sp+14h] [bp+14h]

  v6[1] = a2;
  v6[0] = a3;
  v6[2] = a4;
  v7 = a5;
  return bm174x_ioctl(g_chain[8 * a1], 1u, v6);
}
// 4845C: using guessed type int g_chain[8];

//----- (0001A318) --------------------------------------------------------
int __fastcall write_register(char a1, int a2)
{
  char v3[4]; // [sp+8h] [bp+8h] BYREF
  int v4; // [sp+Ch] [bp+Ch]

  v3[1] = 1;
  v3[0] = 0;
  v3[2] = a1;
  v4 = a2;
  return bm174x_ioctl(g_chain[0], 1u, v3);
}
// 4845C: using guessed type int g_chain[8];

//----- (0001A354) --------------------------------------------------------
int set_i2c_enable()
{
  int result; // r0
  char v1[1024]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+40Ch] [bp+404h]
  char v3[4]; // [sp+410h] [bp+408h] BYREF
  int v4; // [sp+414h] [bp+40Ch]
  int j; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v2 = g_misc_control | 0x4060;
  for ( i = 0; i <= 0; ++i )
  {
    for ( j = 0; j <= 1; ++j )
    {
      v3[1] = 0;
      v3[0] = sensor_chip_addr[j];
      v3[2] = 28;
      v4 = v2;
      bm174x_ioctl(g_chain[8 * i], 1u, v3);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v1, 0x400u, "enable i2c, chain %d sensor %08x\n", i, (unsigned __int8)sensor_chip_addr[j]);
        applog(2, v1, 0);
      }
      result = usleep(0xC350u);
    }
  }
  return result;
}
// 4745C: using guessed type int g_misc_control;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001A46C) --------------------------------------------------------
int __fastcall i2c_status(unsigned __int8 a1, unsigned __int8 a2)
{
  char v6[1024]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 v7[4]; // [sp+410h] [bp+408h] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9[8]; // [sp+41Ch] [bp+414h] BYREF
  int reg_item; // [sp+424h] [bp+41Ch]

  v9[1] = 0;
  v9[0] = a2;
  v9[2] = 32;
  bm174x_ioctl(g_chain[8 * a1], 0, v9);
  v7[0] = a1;
  v7[1] = a2;
  v7[2] = 32;
  v8 = 0;
  reg_item = read_reg_item(v7, 500);
  if ( reg_item >= 0 )
  {
    if ( v8 >= 0 )
    {
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        snprintf(v6, 0x400u, "chain %d, chipaddr %02x - i2c is busy\n", a1, a2);
        applog(1, v6, 0);
      }
      return 1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      snprintf(v6, 0x400u, "chain %d, chipaddr %02x - i2c no-response\n", a1, a2);
      applog(1, v6, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001A5B8) --------------------------------------------------------
int __fastcall i2c_recv(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, _DWORD *a5)
{
  int v11; // [sp+8h] [bp+8h]
  unsigned __int8 v12[4]; // [sp+Ch] [bp+Ch] BYREF
  int v13; // [sp+10h] [bp+10h]
  unsigned __int8 v14; // [sp+18h] [bp+18h] BYREF
  char v15; // [sp+19h] [bp+19h]
  char v16; // [sp+1Ah] [bp+1Ah]
  int v17; // [sp+1Ch] [bp+1Ch]

  if ( i2c_status(a1, a2) )
    return -1;
  LOBYTE(v11) = g_general_i2c_command;
  HIBYTE(v11) = HIBYTE(g_general_i2c_command) | 1;
  BYTE2(v11) = 2 * (a3 & 0x7F);
  BYTE1(v11) = a4;
  v15 = 0;
  v14 = a2;
  v16 = 32;
  v17 = v11;
  bm174x_ioctl(g_chain[8 * a1], 1u, &v14);
  usleep(0x30D40u);
  if ( i2c_status(a1, a2) )
    return -1;
  v15 = 0;
  v14 = a2;
  v16 = 32;
  bm174x_ioctl(g_chain[8 * a1], 0, &v14);
  v12[0] = a1;
  v12[1] = a2;
  v12[2] = 32;
  if ( read_reg_item(v12, 500) <= 0 )
    return -1;
  *a5 = v13;
  return 0;
}
// 47DE0: using guessed type int g_general_i2c_command;
// 4845C: using guessed type int g_chain[8];

//----- (0001A6CC) --------------------------------------------------------
int __fastcall i2c_send(unsigned __int8 a1, char a2, char a3, char a4, char a5)
{
  char v6[4]; // [sp+Ch] [bp+Ch] BYREF
  int v7; // [sp+10h] [bp+10h]
  int v8; // [sp+14h] [bp+14h]

  HIBYTE(v8) = HIBYTE(g_general_i2c_command);
  BYTE2(v8) = (2 * (a3 & 0x7F)) | 1;
  BYTE1(v8) = a4;
  LOBYTE(v8) = a5;
  v6[1] = 0;
  v6[0] = a2;
  v6[2] = 32;
  v7 = v8;
  return bm174x_ioctl(g_chain[8 * a1], 1u, v6);
}
// 47DE0: using guessed type int g_general_i2c_command;
// 4845C: using guessed type int g_chain[8];

//----- (0001A74C) --------------------------------------------------------
void asic_num_calculate()
{
  char v0[8]; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 v1[4]; // [sp+8h] [bp+8h] BYREF
  int v2; // [sp+Ch] [bp+Ch]
  int i; // [sp+14h] [bp+14h]

  v0[1] = 1;
  v0[0] = 0;
  v0[2] = 0;
  for ( i = 0; i <= 0; ++i )
    bm174x_ioctl(g_chain[8 * i], 0, v0);
  for ( i = 0; i <= 0; ++i )
  {
    v1[0] = i;
    v1[1] = 0;
    v1[2] = 0;
    v2 = 0;
    if ( read_reg_item(v1, 500) > 0 )
      ++asic_num[i];
  }
}
// 47E68: using guessed type _DWORD asic_num[1];
// 4845C: using guessed type int g_chain[8];

//----- (0001A7EC) --------------------------------------------------------
int __fastcall calculate_asic_number(unsigned int a1)
{
  char v3[1024]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+40Ch] [bp+40Ch]

  v4 = 0;
  if ( a1 == 1 )
    return 1;
  if ( a1 == 2 )
    return 2;
  if ( a1 > 2 && a1 <= 4 )
    return 4;
  if ( a1 > 4 && a1 <= 8 )
    return 8;
  if ( a1 > 8 && a1 <= 0x10 )
    return 16;
  if ( a1 > 0x10 && a1 <= 0x20 )
    return 32;
  if ( a1 > 0x20 && a1 <= 0x40 )
    return 64;
  if ( a1 > 0x40 && a1 <= 0x80 )
    return 128;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(v3, 0x400u, "actual_asic_number = %d, but it is error\n", a1);
    applog(4, v3, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843E: using guessed type char opt_debug;
// 4843F: using guessed type char opt_log_output;

//----- (0001A920) --------------------------------------------------------
int asic_addr_interval()
{
  int result; // r0
  char v1[1024]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+40Ch] [bp+404h]

  v2 = calculate_asic_number(3u);
  result = 256 / v2;
  addr_interval = 256 / v2;
  sensor_chip_addr = 0;
  byte_47E6D = 2 * (256 / v2);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v1, 0x400u, "%s %u\n", "asic_addr_interval", addr_interval);
    return applog(2, v1, 0);
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 47E6C: using guessed type char sensor_chip_addr;
// 47E6D: using guessed type char byte_47E6D;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001A9D8) --------------------------------------------------------
int __fastcall set_frequency(int a1)
{
  int result; // r0
  char v3[1024]; // [sp+10h] [bp+8h] BYREF
  char v4[4]; // [sp+410h] [bp+408h] BYREF
  int v5; // [sp+414h] [bp+40Ch]
  int v6; // [sp+418h] [bp+410h] BYREF
  int i; // [sp+41Ch] [bp+414h]

  i = 0;
  v6 = 0;
  result = get_plldata(a1, &v6);
  v4[0] = 0;
  v4[1] = 1;
  v4[2] = 12;
  v5 = v6;
  g_pll_parameter = v6;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v3, 0x400u, "%s %d, pll %08x\n", "set_frequency", a1, v6);
      applog(2, v3, 0);
    }
    result = bm174x_ioctl(g_chain[8 * i], 1u, v4);
  }
  return result;
}
// 47454: using guessed type int g_pll_parameter;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001AAC8) --------------------------------------------------------
int __fastcall set_frequency_scanfreq(int result)
{
  int v1; // [sp+14h] [bp+4h]
  char v2[1024]; // [sp+1Ch] [bp+Ch] BYREF
  char v3[4]; // [sp+41Ch] [bp+40Ch] BYREF
  int v4; // [sp+420h] [bp+410h]
  int v5; // [sp+424h] [bp+414h] BYREF
  int v6; // [sp+428h] [bp+418h]
  int i; // [sp+42Ch] [bp+41Ch]

  v1 = result;
  v5 = 0;
  v6 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    get_plldata(*(_DWORD *)(4 * i + v1), &v5);
    v3[0] = i * addr_interval;
    v3[1] = 0;
    v3[2] = 12;
    v4 = v5;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        v2,
        0x400u,
        "%s addr %02x %d %08x\n",
        "set_frequency_scanfreq",
        addr_interval * i,
        *(_DWORD *)(4 * i + v1),
        v5);
      applog(2, v2, 0);
    }
    bm174x_ioctl(g_chain[8 * v6], 1u, v3);
    result = usleep(0xC350u);
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001ABF4) --------------------------------------------------------
int __fastcall set_ticket_mask(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char v2[1024]; // [sp+14h] [bp+Ch] BYREF
  char v3[4]; // [sp+414h] [bp+40Ch] BYREF
  int v4; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 20;
  v4 = result;
  g_ticket_mask = result;
  for ( i = 0; i <= 0; ++i )
  {
    result = bm174x_ioctl(g_chain[8 * i], 1u, v3);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "chain %d ticket-mask %08x\n", i, v1);
      result = applog(2, v2, 0);
    }
  }
  return result;
}
// 47458: using guessed type int g_ticket_mask;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001ACC8) --------------------------------------------------------
int set_io_drive_strength()
{
  int result; // r0
  char v1[1024]; // [sp+8h] [bp+0h] BYREF
  char v2[4]; // [sp+408h] [bp+400h] BYREF
  int v3; // [sp+40Ch] [bp+404h]
  int v4; // [sp+410h] [bp+408h]
  unsigned __int8 i; // [sp+417h] [bp+40Fh]

  v4 = g_io_drive_strength;
  BYTE1(v4) = BYTE1(g_io_drive_strength) & 0xF | 0x30;
  v2[1] = 1;
  v2[0] = 0;
  v2[2] = 48;
  v3 = v4;
  g_io_drive_strength = v4;
  for ( i = 0; !i; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v1, 0x400u, "%s %08x\n", "set_io_drive_strength", v3);
      applog(2, v1, 0);
    }
    result = bm174x_ioctl(i, 1u, v2);
  }
  return result;
}
// 47464: using guessed type int g_io_drive_strength;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001ADA0) --------------------------------------------------------
int __fastcall set_baud_chain(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char v2[1024]; // [sp+10h] [bp+8h] BYREF
  char v3[4]; // [sp+410h] [bp+408h] BYREF
  int v4; // [sp+414h] [bp+40Ch]
  int v5; // [sp+418h] [bp+410h]
  unsigned __int8 i; // [sp+41Fh] [bp+417h]

  v1 = result;
  v5 = g_misc_control;
  BYTE1(v5) = BYTE1(g_misc_control) & 0xE0 | result & 0x1F;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 28;
  v4 = v5;
  g_misc_control = v5;
  for ( i = 0; !i; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "%s bt8d=%d\n", "set_baud_chain", v1);
      applog(2, v2, 0);
    }
    result = bm174x_ioctl(g_chain[8 * i], 1u, v3);
  }
  return result;
}
// 4745C: using guessed type int g_misc_control;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001AE98) --------------------------------------------------------
int set_address()
{
  int result; // r0
  char v1[1024]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+40Ch] [bp+404h] BYREF
  int j; // [sp+410h] [bp+408h]
  int i; // [sp+414h] [bp+40Ch]

  v2 = 0;
  j = 0;
  for ( i = 0; i <= 0; ++i )
  {
    bm174x_ioctl(g_chain[8 * i], 4u, 0);
    result = usleep(0x186A0u);
    for ( j = 0; j <= 2; ++j )
    {
      v2 = j * addr_interval;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v1, 0x400u, "%s %08x\n", "set_address", v2);
        applog(2, v1, 0);
      }
      bm174x_ioctl(g_chain[8 * i], 3u, &v2);
      result = usleep(0xC350u);
    }
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001AFAC) --------------------------------------------------------
int __fastcall set_core_timeout(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char v2[1024]; // [sp+14h] [bp+Ch] BYREF
  char v3[4]; // [sp+414h] [bp+40Ch] BYREF
  int v4; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 40;
  v4 = result;
  g_core_timeout = result;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "%s %08x\n", "set_core_timeout", v1);
      applog(2, v2, 0);
    }
    result = bm174x_ioctl(g_chain[8 * i], 1u, v3);
  }
  return result;
}
// 47460: using guessed type int g_core_timeout;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B084) --------------------------------------------------------
int __fastcall set_txn_data(int result)
{
  int v1; // [sp+Ch] [bp+4h]
  char v2[1024]; // [sp+14h] [bp+Ch] BYREF
  char v3[4]; // [sp+414h] [bp+40Ch] BYREF
  int v4; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v1 = result;
  v3[1] = 1;
  v3[0] = 0;
  v3[2] = 88;
  v4 = result;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "%s %08x\n", "set_txn_data", v1);
      applog(2, v2, 0);
    }
    result = bm174x_ioctl(g_chain[8 * i], 1u, v3);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B14C) --------------------------------------------------------
int __fastcall set_nonce_shift(char a1)
{
  int result; // r0
  char v3[1024]; // [sp+10h] [bp+8h] BYREF
  int v4; // [sp+410h] [bp+408h]
  _DWORD v5[2]; // [sp+414h] [bp+40Ch] BYREF
  int i; // [sp+41Ch] [bp+414h]

  result = 5243136;
  v5[0] = 5243136;
  v4 = g_nonce_shift;
  LOBYTE(v4) = g_nonce_shift & 0xE0 | a1 & 0x1F;
  g_nonce_shift = v4;
  v5[1] = v4;
  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v3, 0x400u, "%s %08x\n", "set_nonce_shift", g_nonce_shift);
      applog(2, v3, 0);
    }
    result = bm174x_ioctl(g_chain[8 * i], 1u, v5);
  }
  return result;
}
// 47470: using guessed type int g_nonce_shift;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B258) --------------------------------------------------------
int __fastcall set_pt_ctrl(int result, char a2)
{
  int v2; // [sp+Ch] [bp+4h]
  char v3[1024]; // [sp+10h] [bp+8h] BYREF
  int v4; // [sp+410h] [bp+408h]
  char v5[4]; // [sp+414h] [bp+40Ch] BYREF
  int v6; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v2 = result;
  BYTE1(v4) = BYTE1(g_pt_ctrl);
  LOBYTE(v4) = g_pt_ctrl & 0xFE | a2 & 1;
  HIWORD(v4) = HIWORD(g_pt_ctrl) & 0xF800 | result & 0x7FF;
  v5[1] = 1;
  v5[0] = 0;
  v5[2] = 92;
  v6 = v4;
  for ( i = 0; i <= 0; ++i )
  {
    result = bm174x_ioctl(g_chain[8 * i], 1u, v5);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(v3, 0x400u, "chain %d pt_ctrl %08x\n", i, v2);
      result = applog(3, v3, 0);
    }
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47DF4: using guessed type int g_pt_ctrl;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B360) --------------------------------------------------------
int __fastcall set_pt_result(int result, char a2)
{
  int v2; // [sp+Ch] [bp+4h]
  char v3[1024]; // [sp+10h] [bp+8h] BYREF
  int v4; // [sp+410h] [bp+408h]
  char v5[4]; // [sp+414h] [bp+40Ch] BYREF
  int v6; // [sp+418h] [bp+410h]
  int i; // [sp+41Ch] [bp+414h]

  v2 = result;
  LOBYTE(v4) = v4 & 0xFE | a2 & 1;
  BYTE1(v4) = BYTE1(v4) & 0xF0 | result & 0xF;
  v5[1] = 1;
  v5[0] = 0;
  v5[2] = 96;
  v6 = v4;
  for ( i = 0; i <= 0; ++i )
  {
    result = bm174x_ioctl(g_chain[8 * i], 1u, v5);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v3, 0x400u, "chain %d pt_result %08x\n", i, v2);
      result = applog(2, v3, 0);
    }
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B458) --------------------------------------------------------
int __fastcall x86_tty_open(int a1, int a2)
{
  char v5[1024]; // [sp+Ch] [bp+Ch] BYREF
  int v6[4]; // [sp+40Ch] [bp+40Ch] BYREF
  char v7; // [sp+41Ch] [bp+41Ch]
  int v8; // [sp+420h] [bp+420h]
  int v9; // [sp+424h] [bp+424h]
  int v10; // [sp+428h] [bp+428h]
  int i; // [sp+42Ch] [bp+42Ch]

  v6[0] = a2;
  v6[1] = 0;
  v6[2] = 8;
  v6[3] = 1;
  v7 = 78;
  v8 = 0;
  v9 = 1024;
  for ( i = 0; ; ++i )
  {
    if ( i > 0 )
      return 0;
    sprintf((char *)&g_chain[8 * i + 1] + 1, "ttyUSB%d", a1);
    v10 = uart_open((const char *)&g_chain[8 * i + 1] + 1, v6);
    if ( v10 < 0 )
      break;
    g_chain[8 * i] = v10;
    LOBYTE(g_chain[8 * i + 1]) = i;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 0 )
  {
    snprintf(v5, 0x400u, "open chain%d failed\n", i);
    applog(1, v5, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B590) --------------------------------------------------------
int x86_tty_close()
{
  int result; // r0
  char v1[1024]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+404h] [bp+404h]

  for ( i = 0; i <= 0; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v1, 0x400u, "uart close %s\n", (const char *)&g_chain[8 * i + 1] + 1);
      applog(2, v1, 0);
    }
    result = uart_exit(g_chain[8 * i]);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001B630) --------------------------------------------------------
int __fastcall x86_tty_init(int a1, uint32_t a2)
{
  int result; // r0
  int bt8d_from_baud; // [sp+Ch] [bp+Ch]

  result = x86_tty_open(a1, 19200);
  if ( a2 != 19200 )
  {
    bt8d_from_baud = get_bt8d_from_baud(a2);
    set_baud_chain(bt8d_from_baud);
    usleep(0x30D40u);
    x86_tty_close();
    return x86_tty_open(a1, a2);
  }
  return result;
}

//----- (0001B680) --------------------------------------------------------
int nonce_scanhash()
{
  uint32_t v0; // r0
  int v1; // r2
  _BYTE v3[360]; // [sp+18h] [bp+0h] BYREF
  char v4[1024]; // [sp+180h] [bp+168h] BYREF
  _DWORD v5[3]; // [sp+580h] [bp+568h] BYREF
  uint8_t v6[140]; // [sp+58Ch] [bp+574h] BYREF
  _DWORD v7[341]; // [sp+618h] [bp+600h] BYREF
  int v8; // [sp+B6Ch] [bp+B54h]
  uint32_t v9; // [sp+B70h] [bp+B58h]
  unsigned int j; // [sp+B74h] [bp+B5Ch]
  int i; // [sp+B78h] [bp+B60h]
  unsigned int m; // [sp+B7Ch] [bp+B64h]
  int k; // [sp+B80h] [bp+B68h]
  int v14; // [sp+B84h] [bp+B6Ch]

  v9 = 0;
  v8 = 0;
  memset(v6, 0, sizeof(v6));
  pthread_mutex_lock(&nonce_mutex);
  v14 = dword_49DF4;
  pthread_mutex_unlock(&nonce_mutex);
  while ( v14 )
  {
    pthread_mutex_lock(&nonce_mutex);
    --v14;
    --dword_49DF4;
    memcpy(v7, (char *)&nonce_fifo + 1357 * dword_49DF0 + 12, 0x54Du);
    pthread_mutex_unlock(&nonce_mutex);
    pthread_mutex_lock(&g_rt_nonce_mutex);
    memcpy(&g_rt_nonce, v7, 0x54Du);
    pthread_mutex_unlock(&g_rt_nonce_mutex);
    if ( LOBYTE(v7[339]) && (use_syslog || opt_log_output || opt_log_level > 1) )
    {
      snprintf(v4, 0x400u, "Error:scanhash chainid=%u\n", LOBYTE(v7[339]));
      applog(2, v4, 0);
    }
    work_list_find(SBYTE1(v7[336]), v6);
    *(_DWORD *)&v6[136 - g_nonce_shift] = v7[338];
    v5[0] = 200;
    v5[1] = 9;
    v5[2] = v3;
    digestInit((blake2b_state *)v3, 200, 9);
    blake2b_update((blake2b_state *)v3, v6, 0x8CuLL);
    v8 = sortValidator(v5, (const unsigned __int8 *)v7);
    v9 = targetValidator(v6, v7);
    if ( g_new_work )
    {
      memset(one_work_nonce_each_asic, 0, 0xCu);
      memset(one_work_invalid_nonce_each_asic, 0, sizeof(one_work_invalid_nonce_each_asic));
      memset(one_work_invalid_nonce_each_asic_2, 0, sizeof(one_work_invalid_nonce_each_asic_2));
      g_new_work = 0;
      v7[340] = time(0) - 1;
    }
    if ( v8 )
    {
      ++invalid_nonce_total;
      for ( i = 0; i <= 0; ++i )
      {
        for ( j = 0; j <= 2; ++j )
        {
          if ( LOBYTE(v7[336]) / (unsigned int)addr_interval == j )
          {
            if ( v8 == 1 )
            {
              ++nonce_invalid_num_each_asic_2[6 * i + 2 * j];
              ++one_work_invalid_nonce_each_asic_2[6 * i + 2 * j];
            }
            else if ( v8 == 2 )
            {
              ++nonce_invalid_num_each_asic_2[6 * i + 1 + 2 * j];
              ++one_work_invalid_nonce_each_asic_2[6 * i + 1 + 2 * j];
            }
            ++one_work_invalid_nonce_each_asic[3 * i + j];
            ++nonce_invalid_num_each_asic[3 * i + j];
            if ( use_syslog || opt_log_output || opt_log_level >= 0 )
            {
              snprintf(
                v4,
                0x400u,
                "Fail:invalid nonce: chainid=%d chipaddr=%02x nonces=%d tm=%d errtype=%d\n",
                i,
                LOBYTE(v7[336]),
                one_work_invalid_nonce_each_asic[3 * i + j],
                v9,
                v8);
              applog(0, v4, 0);
            }
          }
        }
      }
    }
    else
    {
      ++valid_nonce_total;
      ++submit_nonce;
      for ( k = 0; k <= 0; ++k )
      {
        for ( m = 0; m <= 2; ++m )
        {
          if ( LOBYTE(v7[336]) / (unsigned int)addr_interval == m )
          {
            ++one_work_nonce_each_asic[3 * k + m];
            ++nonce_num_each_asic[3 * k + m];
            if ( dword_F37C8 )
              is_patten_match(m, &v7[338], v7);
            if ( use_syslog || opt_log_output || opt_log_level > 0 )
            {
              snprintf(
                v4,
                0x400u,
                "Success:valid nonce: chainid=%d chipaddr=%02x nonces=%d total=%d tm=%d err=%d\n",
                k,
                LOBYTE(v7[336]),
                one_work_nonce_each_asic[3 * k + m],
                submit_nonce,
                v9,
                v8);
              applog(1, v4, 0);
            }
          }
        }
      }
      if ( dword_F3508 == 1 )
      {
        v0 = target_zero_cal(g_work_info);
        if ( v0 <= v9 )
        {
          ++*(_QWORD *)&total_8876;
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            v1 = golden_nonce_8875++;
            snprintf(v4, 0x400u, "Golden Nonce Found! %d\n", v1);
            applog(3, v4, 0);
          }
          print_solver_line((int)v7, (int)v6, dword_F3460, (int)&unk_F32D4);
          ++*(_QWORD *)&total_shares_8877;
          t1_8879 = miner_now();
          if ( *(_QWORD *)&status_period_8880 + t0_8878 < (unsigned __int64)t1_8879 )
          {
            t0_8878 = t1_8879;
            printf("status: %lld %lld\n", *(_QWORD *)&total_8876, *(_QWORD *)&total_shares_8877);
            fflush((FILE *)stdout);
          }
        }
      }
    }
    dump_str((FILE *)app_conf, 0, v6, 0x8Cu);
    dump_str((FILE *)app_conf, 0, (const unsigned __int8 *)v7, 0x540u);
    pthread_mutex_lock(&nonce_mutex);
    if ( (unsigned int)dword_49DF0 >= 0x1FE )
      dword_49DF0 = 0;
    else
      ++dword_49DF0;
    pthread_mutex_unlock(&nonce_mutex);
  }
  return 0;
}
// 1B680: using guessed type int nonce_scanhash();
// 47448: using guessed type char g_new_work;
// 47470: using guessed type int g_nonce_shift;
// 47478: using guessed type int addr_interval;
// 47480: using guessed type void *status_period_8880;
// 47C84: using guessed type int opt_log_level;
// 47DB4: using guessed type int stdout;
// 47DFC: using guessed type int nonce_num_each_asic[];
// 47E08: using guessed type int nonce_invalid_num_each_asic[3];
// 47E14: using guessed type int nonce_invalid_num_each_asic_2[];
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E38: using guessed type int one_work_invalid_nonce_each_asic[3];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 47E5C: using guessed type int valid_nonce_total;
// 47E60: using guessed type int invalid_nonce_total;
// 47E64: using guessed type int submit_nonce;
// 47E70: using guessed type pthread_mutex_t g_rt_nonce_mutex;
// 47E8C: using guessed type pthread_mutex_t nonce_mutex;
// 47EC8: using guessed type int total_8876;
// 47ED0: using guessed type int golden_nonce_8875;
// 47ED8: using guessed type int total_shares_8877;
// 47EE0: using guessed type __int64 t1_8879;
// 47EE8: using guessed type __int64 t0_8878;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 49DEC: using guessed type int nonce_fifo;
// 49DF0: using guessed type int dword_49DF0;
// 49DF4: using guessed type int dword_49DF4;
// F32B4: using guessed type uint8_t g_work_info[32];
// F3460: using guessed type int dword_F3460;
// F34DC: using guessed type int app_conf;
// F3508: using guessed type int dword_F3508;
// F37C8: using guessed type int dword_F37C8;

//----- (0001BF00) --------------------------------------------------------
void __noreturn nonce_scanhash_loop()
{
  pthread_t th; // [sp+4h] [bp+4h] BYREF

  while ( 1 )
  {
    pthread_create(&th, 0, (void *(*)(void *))nonce_scanhash, 0);
    pthread_join(th, 0);
    usleep(0x3E8u);
  }
}
// 1B680: using guessed type int nonce_scanhash();

//----- (0001BF2C) --------------------------------------------------------
int __fastcall nonce_integrality(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4)
{
  char v10[1026]; // [sp+24h] [bp+14h] BYREF
  unsigned __int16 v11; // [sp+426h] [bp+416h] BYREF
  void *dest; // [sp+428h] [bp+418h]
  int i; // [sp+42Ch] [bp+41Ch]

  for ( i = 0; i <= 15; ++i )
  {
    v11 = CRC16_v1((const unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1), 89);
    v11 = HIBYTE(v11) | (v11 << 8);
    if ( memcmp(&v11, (const void *)(a4 + 1456 * a1 + 1456 * a2 + 91 * i + 89), 2u) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          v10,
          0x400u,
          "%s CRC error. cal-crc=%x, chip-crc=%02x%02x\n",
          "nonce_integrality",
          v11,
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 89),
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 90));
        applog(0, v10, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( (*(_BYTE *)(1456 * a2 + 91 * i + a4 + 1456 * a1) & 0xF) != i )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(v10, 0x400u, "nonce is not continous i=%d\n", i);
        applog(0, v10, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    if ( *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 1) != *(unsigned __int8 *)(1456 * a2
                                                                                             + 91 * (i + 1)
                                                                                             + a4
                                                                                             + 1456 * a1
                                                                                             + 1) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          v10,
          0x400u,
          "chip_addr is different %02x != %02x\n",
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 1),
          *(unsigned __int8 *)(1456 * a2 + 91 * (i + 1) + a4 + 1456 * a1 + 1));
        applog(0, v10, 0);
      }
      return -1;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    if ( *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 2) != *(unsigned __int8 *)(1456 * a2
                                                                                             + 91 * (i + 1)
                                                                                             + a4
                                                                                             + 1456 * a1
                                                                                             + 2) )
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf(
          v10,
          0x400u,
          "workID is different %02x != %02x\n",
          *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 2),
          *(unsigned __int8 *)(1456 * a2 + 91 * (i + 1) + a4 + 1456 * a1 + 2));
        applog(0, v10, 0);
      }
      return -1;
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( i > 14 )
    {
      dest = (void *)(1357 * a2 + a3 + 1357 * a1);
      for ( i = 0; i <= 14; ++i )
      {
        memcpy(dest, (const void *)(1456 * a2 + 91 * i + 4 + a4 + 1456 * a1), 0x55u);
        dest = (char *)dest + 85;
      }
      memcpy(dest, (const void *)(1456 * a2 + 1369 + a4 + 1456 * a1), 0x45u);
      memcpy((void *)(a3 + 1357 * a1 + 1357 * a2 + 1352), (const void *)(1456 * a2 + 1450 + a4 + 1456 * a1), 4u);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1344) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1366);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1345) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1367);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1346) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1368);
      *(_BYTE *)(1357 * a2 + a3 + 1357 * a1 + 1347) = *(_BYTE *)(1456 * a2 + a4 + 1456 * a1 + 1441);
      memcpy((void *)(1357 * a2 + 1344 + a3 + 1357 * a1 + 4), (const void *)(1456 * a2 + 1442 + a4 + 1456 * a1), 4u);
      return 0;
    }
    if ( *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 3) != *(unsigned __int8 *)(1456 * a2
                                                                                             + 91 * (i + 1)
                                                                                             + a4
                                                                                             + 1456 * a1
                                                                                             + 3) )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(
      v10,
      0x400u,
      "nonceID is different %02x != %02x chipid=%d\n",
      *(unsigned __int8 *)(1456 * a2 + 91 * i + a4 + 1456 * a1 + 3),
      *(unsigned __int8 *)(1456 * a2 + 91 * (i + 1) + a4 + 1456 * a1 + 3),
      a1);
    applog(0, v10, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001C85C) --------------------------------------------------------
void clear_register_value_buf()
{
  pthread_mutex_lock(&nonce_mutex);
  nonce_fifo = 0;
  dword_49DF0 = 0;
  dword_49DF4 = 0;
  pthread_mutex_unlock(&nonce_mutex);
}
// 47E8C: using guessed type pthread_mutex_t nonce_mutex;
// 49DEC: using guessed type int nonce_fifo;
// 49DF0: using guessed type int dword_49DF0;
// 49DF4: using guessed type int dword_49DF4;

//----- (0001C8A0) --------------------------------------------------------
int __fastcall pm_handle(int a1, size_t a2, unsigned __int8 a3)
{
  int result; // r0
  char v5; // [sp+18h] [bp+8h]
  char v7[1027]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 v8; // [sp+423h] [bp+413h]
  unsigned __int8 *v9; // [sp+424h] [bp+414h]

  v5 = a2;
  v9 = (unsigned __int8 *)a1;
  dump_str((FILE *)app_conf, 0, (const unsigned __int8 *)a1, a2);
  result = CRC5_v1((_BYTE *)(a1 + 2), 8 * (v5 - 3) + 3);
  v8 = result;
  if ( (unsigned __int8)result == (v9[8] & 0x1F) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v7, 0x400u, "pmonitor[%02x] %02x %02x %02x %02x\n", v9[7], v9[3], v9[4], v9[5], v9[6]);
      return applog(2, v7, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(v7, 0x400u, "%s chain%d CRC error crc = %02x\n", "pm_handle", a3, v8);
    return applog(0, v7, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34DC: using guessed type int app_conf;

//----- (0001CA04) --------------------------------------------------------
int __fastcall pt_handle(int a1, int a2, unsigned __int8 a3)
{
  int result; // r0
  char v5[1024]; // [sp+18h] [bp+10h] BYREF
  FILE *stream; // [sp+418h] [bp+410h]
  unsigned __int16 v7; // [sp+41Eh] [bp+416h]
  int v8; // [sp+420h] [bp+418h]
  int i; // [sp+424h] [bp+41Ch]

  v8 = a1;
  result = CRC16_v1((const unsigned __int8 *)(a1 + 2), 1026);
  v7 = BYTE1(result) | ((_WORD)result << 8);
  if ( v7 == *(unsigned __int16 *)(v8 + 1028) )
  {
    result = (int)fopen("./pattern_result.txt", "a+");
    stream = (FILE *)result;
    if ( result )
    {
      for ( i = 0; i <= 127; ++i )
        dump_str(stream, 0, (const unsigned __int8 *)(8 * i + v8 + 4), 8u);
      return fclose(stream);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v5, "open failed pattern_result.txt\n");
      return applog(2, v5, 0);
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v5, 0x400u, "chainid=%d cal crc = %04x, chip crc = %04x\n", a3, v7, *(unsigned __int16 *)(v8 + 1028));
      result = applog(2, v5, 0);
    }
    pattern_test_crc_error = 1;
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47EA4: using guessed type char pattern_test_crc_error;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001CB98) --------------------------------------------------------
int __fastcall reg_handle(int a1, char a2, char a3)
{
  int result; // r0
  char v5[1024]; // [sp+1Ch] [bp+14h] BYREF
  int v6; // [sp+41Ch] [bp+414h]
  int v7; // [sp+424h] [bp+41Ch]
  unsigned __int8 v8; // [sp+42Bh] [bp+423h]
  int v9; // [sp+42Ch] [bp+424h]

  v9 = a1;
  result = CRC5_v1((_BYTE *)(a1 + 2), 8 * (a2 - 3) + 3);
  v8 = result;
  if ( (unsigned __int8)result == (*(_BYTE *)(v9 + 8) & 0x1F) )
  {
    v7 = 3;
    LOBYTE(v6) = a3;
    BYTE1(v6) = *(_BYTE *)(v9 + 7);
    BYTE2(v6) = *(_BYTE *)(v9 + 2);
    return add_reg_item(v6, _byteswap_ulong(*(_DWORD *)(v9 + 3)), 3);
  }
  else if ( use_syslog || opt_log_output || opt_log_level >= 0 )
  {
    snprintf(v5, 0x400u, "%s CRC error crc = %02x\n", "reg_handle", v8);
    return applog(0, v5, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001CCB8) --------------------------------------------------------
int __fastcall nonce_handle(int a1, int a2, const unsigned __int8 *a3, size_t a4, char a5)
{
  int v6; // r2
  char v12[1024]; // [sp+1Ch] [bp+14h] BYREF
  int v13; // [sp+41Ch] [bp+414h]
  int v14; // [sp+420h] [bp+418h]
  int v15; // [sp+424h] [bp+41Ch]
  unsigned __int8 v16; // [sp+42Bh] [bp+423h]
  unsigned __int8 v17; // [sp+42Ch] [bp+424h]
  unsigned __int8 v18; // [sp+42Dh] [bp+425h]
  unsigned __int8 v19; // [sp+42Eh] [bp+426h]
  unsigned __int8 v20; // [sp+42Fh] [bp+427h]

  v20 = a3[2] & 0xF;
  v19 = a3[3];
  v18 = v19 / (unsigned int)addr_interval;
  v17 = a3[5];
  v16 = 0;
  v15 = 1;
  if ( v18 > 2u )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      snprintf(v12, 0x400u, "%s chipid%d is not exist", "nonce_handle", v18);
      applog(1, v12, 0);
    }
    return -1;
  }
  memcpy((void *)(a2 + 1456 * v18 + 1456 * v16 + 91 * v20), a3 + 2, a4 - 2);
  if ( g_txok_test_enable )
    dump_str((FILE *)app_conf, 0, a3, a4);
  if ( v20 != 15 )
    return 1;
  if ( g_txok_test_enable )
  {
    if ( !txok_flag_8982 )
    {
      v14 = (v17 << 16) | 0x8000FFFE;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v12, 0x400u, "write txok %08x nonceid %02x\n", v14, v17);
        applog(2, v12, 0);
      }
      write_register(36, v14);
      txok_flag_8982 = 1;
      return 1;
    }
    v13 = (v17 << 16) | 0x8000FFFF;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v12, 0x400u, "write txok %08x nonceid %02x\n", v13, v17);
      applog(2, v12, 0);
    }
    write_register(36, v13);
    txok_flag_8982 = 0;
  }
  v15 = nonce_integrality(v18, v16, a1, a2);
  if ( v15 >= 0 )
  {
    pthread_mutex_lock(&nonce_mutex);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1368) = a5;
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1356) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1344);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1357) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1345);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1358) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1346);
    *((_BYTE *)&nonce_fifo + 1357 * nonce_fifo + 1359) = *(_BYTE *)(1357 * v16 + a1 + 1357 * v18 + 1347);
    memcpy(
      (char *)&nonce_fifo + 1357 * nonce_fifo + 1360,
      (const void *)(1357 * v16 + 1344 + a1 + 1357 * v18 + 4),
      sizeof(int));
    memcpy(
      (char *)&nonce_fifo + 1357 * nonce_fifo + 1364,
      (const void *)(1357 * v16 + 1352 + a1 + 1357 * v18),
      sizeof(int));
    memcpy((char *)&nonce_fifo + 1357 * nonce_fifo + 12, (const void *)(1357 * v16 + a1 + 1357 * v18), 0x540u);
    if ( (unsigned int)nonce_fifo >= 0x1FE )
      nonce_fifo = 0;
    else
      ++nonce_fifo;
    if ( (unsigned int)dword_49DF4 > 0x1FE )
    {
      dword_49DF4 = 511;
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        snprintf(v12, 0x400u, "%s: nonce fifo full!!!\n", "nonce_handle");
        applog(1, v12, 0);
      }
    }
    else
    {
      ++dword_49DF4;
    }
    pthread_mutex_unlock(&nonce_mutex);
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 0 )
    {
      v6 = total_error_8981++;
      snprintf(v12, 0x400u, "receive a error nonce. total = %u\n", v6);
      applog(1, v12, 0);
    }
    return -1;
  }
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 47E8C: using guessed type pthread_mutex_t nonce_mutex;
// 47EA5: using guessed type char g_txok_test_enable;
// 47EF0: using guessed type int txok_flag_8982;
// 47EF4: using guessed type int total_error_8981;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 49DEC: using guessed type int nonce_fifo;
// 49DF4: using guessed type int dword_49DF4;
// F34DC: using guessed type int app_conf;

//----- (0001D2E0) --------------------------------------------------------
void __cdecl add_point(int *point, int MAX_SIZE)
{
  if ( ++*point >= MAX_SIZE )
    *point = 0;
}

//----- (0001D310) --------------------------------------------------------
void __noreturn handle_asic_response()
{
  pthread_t v0; // r0
  int v1; // r3
  char v2[1024]; // [sp+8h] [bp+0h] BYREF
  __int16 v3; // [sp+408h] [bp+400h]
  unsigned __int8 v4; // [sp+40Ah] [bp+402h]
  int v5; // [sp+40Ch] [bp+404h] BYREF
  int v6; // [sp+410h] [bp+408h] BYREF
  int v7; // [sp+1520h] [bp+1518h] BYREF
  unsigned __int8 v8[1032]; // [sp+2508h] [bp+2500h] BYREF
  int v9; // [sp+2910h] [bp+2908h] BYREF
  int v10; // [sp+2914h] [bp+290Ch] BYREF
  _BYTE v11[74400]; // [sp+2918h] [bp+2910h] BYREF
  unsigned __int8 v12[1488]; // [sp+14BB8h] [bp+14BB0h] BYREF
  int v13; // [sp+15188h] [bp+15180h]
  unsigned __int8 v14; // [sp+1518Fh] [bp+15187h]
  int i; // [sp+15190h] [bp+15188h]
  int v16; // [sp+15194h] [bp+1518Ch]

  memset(v12, 0, sizeof(v12));
  v14 = 0;
  v16 = 0;
  v0 = pthread_self();
  pthread_detach(v0);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v2, 0x400u, "Start A New Asic Response.Chain Id:[%d]\n", v14);
    applog(2, v2, 0);
  }
  memset(v11, 0, sizeof(v11));
  v10 = 0;
  v9 = 0;
  memset(v8, 0, 0x406u);
  v13 = 74400;
  while ( 1 )
  {
    do
    {
LABEL_6:
      while ( start_recv != 1 )
        usleep(0x186A0u);
      usleep(0x1F4u);
      v16 = uart_receive(g_chain[8 * v14], v12, 0x5D0u);
      for ( i = 0; i < v16; ++i )
      {
        v11[v9] = v12[i];
        add_point(&v9, v13);
      }
    }
    while ( v10 == v9 );
    if ( v9 <= v10 )
      v1 = 74400 - v10 + v9;
    else
      v1 = v9 - v10;
    v16 = v1;
    while ( v16 > 2 )
    {
      v5 = v10;
      v3 = 0;
      v4 = 0;
      for ( i = 0; i <= 2; ++i )
      {
        *((_BYTE *)&v3 + i) = v11[v5];
        add_point(&v5, v13);
      }
      if ( (unsigned __int8)v3 == 170 && HIBYTE(v3) == 85 )
      {
        if ( (v4 & 0xF0) == 224 )
        {
          if ( v16 <= 92 )
            goto LABEL_6;
          for ( i = 0; i <= 92; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 93;
          nonce_handle((int)&v7, (int)&v6, v8, 0x5Du, v14);
        }
        else if ( v4 == 204 )
        {
          if ( v16 <= 8 )
            goto LABEL_6;
          for ( i = 0; i <= 8; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 9;
          pm_handle((int)v8, 9u, v14);
        }
        else if ( v4 == 208 )
        {
          if ( v16 <= 1029 )
            goto LABEL_6;
          for ( i = 0; i <= 1029; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 1030;
          pt_handle((int)v8, 1030, v14);
        }
        else
        {
          if ( v16 <= 8 )
            goto LABEL_6;
          for ( i = 0; i <= 8; ++i )
          {
            v8[i] = v11[v10];
            add_point(&v10, v13);
          }
          v16 -= 9;
          reg_handle((int)v8, 9, v14);
        }
      }
      else
      {
        add_point(&v10, v13);
        --v16;
      }
    }
  }
}
// 47C84: using guessed type int opt_log_level;
// 47EA6: using guessed type char start_recv;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];

//----- (0001D9E8) --------------------------------------------------------
int bm1744_app_init()
{
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+404h] [bp+404h] BYREF

  reg_scan_init();
  start_recv = 1;
  for ( i = 0; ; ++i )
  {
    if ( i > 0 )
    {
      if ( !pthread_create((pthread_t *)&p_scanhash, 0, (void *(*)(void *))nonce_scanhash_loop, 0) )
        return 0;
      if ( use_syslog || opt_log_output || opt_log_level > 0 )
      {
        strcpy(v2, "create bm1744_scanhash_loop thread failed\n");
        applog(1, v2, 0);
      }
      return -1;
    }
    if ( pthread_create((pthread_t *)&g_chain[8 * i + 6], 0, (void *(*)(void *))handle_asic_response, &i) )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 0 )
  {
    strcpy(v2, "create p_dispatch failed\n");
    applog(1, v2, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 47EA6: using guessed type char start_recv;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 48458: using guessed type int p_scanhash;
// 4845C: using guessed type int g_chain[8];

//----- (0001DB2C) --------------------------------------------------------
int bm1744_app_exit()
{
  int result; // r0
  char v1[1024]; // [sp+Ch] [bp+4h] BYREF
  int i; // [sp+40Ch] [bp+404h]

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v1, 0x400u, "%s[%d]\n", "bm1744_app_exit", 1290);
    applog(2, v1, 0);
  }
  reg_scan_exit();
  for ( i = 0; i <= 0; ++i )
  {
    pthread_cancel(g_chain[8 * i + 6]);
    pthread_join(g_chain[8 * i + 6], 0);
  }
  pthread_cancel(p_scanhash);
  result = pthread_join(p_scanhash, 0);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v1, 0x400u, "%s[%d]\n", "bm1744_app_exit", 1301);
    return applog(2, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 48458: using guessed type int p_scanhash;
// 4845C: using guessed type int g_chain[8];

//----- (0001DC60) --------------------------------------------------------
int __fastcall work_list_insert(char a1, const void *a2)
{
  pthread_mutex_lock(&g_work_list_mutex);
  g_work_list[141 * g_work_list_insert_index] = a1;
  memcpy(&g_work_list[141 * g_work_list_insert_index + 1], a2, 0x8Cu);
  if ( ++g_work_list_insert_index > 9 )
    g_work_list_insert_index = 0;
  return pthread_mutex_unlock(&g_work_list_mutex);
}
// 47EA8: using guessed type int g_work_list_insert_index;
// 47EAC: using guessed type pthread_mutex_t g_work_list_mutex;
// 489CC: using guessed type _BYTE g_work_list[1412];

//----- (0001DD00) --------------------------------------------------------
int __fastcall work_list_find(char a1, void *a2)
{
  int i; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&g_work_list_mutex);
  for ( i = 0; i <= 9; ++i )
  {
    if ( a1 == g_work_list[141 * i] )
    {
      memcpy(a2, &g_work_list[141 * i + 1], 0x8Cu);
      return pthread_mutex_unlock(&g_work_list_mutex);
    }
  }
  return pthread_mutex_unlock(&g_work_list_mutex);
}
// 47EAC: using guessed type pthread_mutex_t g_work_list_mutex;
// 489CC: using guessed type _BYTE g_work_list[1412];

//----- (0001DD78) --------------------------------------------------------
int __fastcall send_work(const unsigned __int8 *a1, char a2, char a3)
{
  char v3; // r2
  int result; // r0
  unsigned __int8 v8[140]; // [sp+14h] [bp+14h] BYREF
  char v9[148]; // [sp+A0h] [bp+A0h] BYREF
  int i; // [sp+134h] [bp+134h]

  memset(v9, 0, 0x92u);
  v9[2] = v9[2] & 0xEF | (16 * (a2 & 1));
  v9[2] = v9[2] & 0xFE | a3 & 1;
  v3 = total_work++;
  v9[3] = v3;
  memset(v8, 0, sizeof(v8));
  hex2bin(v8, a1, 0x8Cu);
  memcpy(&v9[4], v8, 0x8Cu);
  memcpy(&g_work_header, v8, 0x8Cu);
  result = work_list_insert(v9[3], &v9[4]);
  g_new_work = 1;
  for ( i = 0; i <= 0; ++i )
    result = bm174x_ioctl(g_chain[8 * i], 2u, v9);
  return result;
}
// 47448: using guessed type char g_new_work;
// 47DDC: using guessed type char total_work;
// 4845C: using guessed type int g_chain[8];

//----- (0001DE98) --------------------------------------------------------
int __fastcall read_sensor(unsigned __int8 a1, int a2, char a3, unsigned __int8 a4, _BYTE *a5)
{
  char v8[1024]; // [sp+18h] [bp+10h] BYREF
  int v9; // [sp+418h] [bp+410h] BYREF
  int v10; // [sp+41Ch] [bp+414h]

  v9 = 0;
  if ( i2c_recv(a1, sensor_chip_addr[a2], a3, a4, &v9) )
  {
    v10 = 6;
    if ( !use_syslog && !opt_log_output && opt_log_level <= 0 )
      return v10;
LABEL_17:
    snprintf(
      v8,
      0x400u,
      "Read i2c failed sensroid=%02x, sensor-regaddr=%02x sensor-regdata=%08x\n",
      (unsigned __int8)sensor_chip_addr[a2],
      a4,
      v9);
    applog(1, v8, 0);
    return v10;
  }
  if ( (v9 & 0xC0000000) != 0 || !(_BYTE)v9 )
  {
    v10 = 6;
    if ( !use_syslog && !opt_log_output && opt_log_level <= 0 )
      return v10;
    goto LABEL_17;
  }
  v10 = 5;
  if ( a5 )
    *a5 = v9;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      v8,
      0x400u,
      "Read i2c success sensroid=%02x, sensor-regaddr=%02x sensor-regdata=%08x\n",
      (unsigned __int8)sensor_chip_addr[a2],
      a4,
      v9);
    applog(3, v8, 0);
  }
  return v10;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E094) --------------------------------------------------------
void app_config_init_registers()
{
  g_ticket_mask = dword_F3644;
  g_core_timeout = dword_F3648;
  g_misc_control = dword_F364C;
}
// 47458: using guessed type int g_ticket_mask;
// 4745C: using guessed type int g_misc_control;
// 47460: using guessed type int g_core_timeout;
// F3644: using guessed type int dword_F3644;
// F3648: using guessed type int dword_F3648;
// F364C: using guessed type int dword_F364C;

//----- (0001E0E8) --------------------------------------------------------
void __noreturn rw_register_loop()
{
  while ( 1 )
  {
    write_register(88, 0);
    sleep(1u);
    read_register(0, 1, 0, 88);
    sleep(3u);
    write_register(88, 3);
    sleep(1u);
    read_register(0, 1, 0, 88);
    sleep(3u);
  }
}

//----- (0001E130) --------------------------------------------------------
uint8_t __cdecl get_bt8d_from_baud(const uint32_t baud)
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  unsigned int v4; // [sp+408h] [bp+408h]
  unsigned int i; // [sp+40Ch] [bp+40Ch]

  v4 = 5;
  for ( i = 0; ; ++i )
  {
    if ( i >= v4 )
    {
      if ( i != v4 )
        return -1;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "get bt8d value failed!!!,use default to continue\n");
        applog(3, (const char *)tmp42, 0);
      }
      return get_bt8d_from_baud(0x1C200u);
    }
    if ( *((_DWORD *)&baud_BT8D_values + 3 * i) == baud )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x400u, "get bt8d %d\n", *((unsigned __int8 *)&baud_BT8D_values + 12 * i + 4));
    applog(3, (const char *)tmp42, 0);
  }
  return *((_BYTE *)&baud_BT8D_values + 12 * i + 4);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E280) --------------------------------------------------------
int __fastcall get_index_by_freq(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0x64; ++i )
  {
    if ( freq_pll[4 * i] == a1 )
      return i;
  }
  return -1;
}
// 474C4: using guessed type _DWORD freq_pll[404];

//----- (0001E2C4) --------------------------------------------------------
int __fastcall get_freq_by_index(int a1)
{
  return freq_pll[4 * a1];
}
// 474C4: using guessed type _DWORD freq_pll[404];

//----- (0001E2E8) --------------------------------------------------------
int __fastcall get_plldata(int result, _DWORD *a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0x64 && freq_pll[4 * i] != result; ++i )
    ;
  if ( i == 101 )
    i = 4;
  *a2 = freq_pll[4 * i + 3];
  return result;
}
// 474C4: using guessed type _DWORD freq_pll[404];

//----- (0001E34C) --------------------------------------------------------
int __cdecl makeup_work_pkg(uint8_t *str, uint8_t *work_str)
{
  unsigned __int16 v5; // [sp+Ah] [bp+Ah]

  work_str[2] = work_str[2] & 0x1F | 0x20;
  *work_str = 85;
  work_str[1] = -86;
  v5 = CRC16_v1(work_str + 2, 142);
  *((_WORD *)work_str + 72) = HIBYTE(v5) | (v5 << 8);
  memcpy(str, work_str, 0x92u);
  return 146;
}

//----- (0001E3B0) --------------------------------------------------------
int __cdecl makeup_set_address_cmd(uint8_t *str, uint32_t str_len, uint8_t chip_addr)
{
  char v4; // r0
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  _DWORD v9[2]; // [sp+418h] [bp+410h] BYREF

  if ( str_len > 6 )
  {
    memset(v9, 0, 5u);
    LOBYTE(v9[0]) = v9[0] & 0x1F | 0x40;
    LOBYTE(v9[0]) &= ~0x10u;
    LOBYTE(v9[0]) &= 0xF0u;
    BYTE1(v9[0]) = 5;
    BYTE2(v9[0]) = chip_addr;
    v4 = CRC5_v1(v9, 0x20u);
    LOBYTE(v9[1]) = v9[1] & 0xE0 | v4 & 0x1F;
    *str = 85;
    str[1] = -86;
    *(_DWORD *)(str + 2) = v9[0];
    str[6] = v9[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", "makeup_set_address_cmd", 7);
      applog(0, (const char *)tmp42, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E4CC) --------------------------------------------------------
int __cdecl makeup_set_config_cmd(
        uint8_t *str,
        uint32_t str_len,
        uint8_t all,
        uint8_t chip_addr,
        uint8_t regaddr,
        uint32_t regdata)
{
  char v7; // r0
  int v8; // r1
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  _DWORD v14[4]; // [sp+41Ch] [bp+414h] BYREF

  if ( str_len > 0xA )
  {
    memset(v14, 0, 9u);
    LOBYTE(v14[0]) = v14[0] & 0x1F | 0x40;
    LOBYTE(v14[0]) = v14[0] & 0xEF | (16 * (all & 1));
    LOBYTE(v14[0]) = v14[0] & 0xF0 | 1;
    BYTE1(v14[0]) = 9;
    BYTE2(v14[0]) = chip_addr;
    HIBYTE(v14[0]) = regaddr;
    v14[1] = bswap32(regdata);
    v7 = CRC5_v1(v14, 0x40u);
    LOBYTE(v14[2]) = v14[2] & 0xE0 | v7 & 0x1F;
    *str = 85;
    str[1] = -86;
    v8 = v14[1];
    *(_DWORD *)(str + 2) = v14[0];
    *(_DWORD *)(str + 6) = v8;
    str[10] = v14[2];
    return 11;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", "makeup_set_config_cmd", 11);
      applog(0, (const char *)tmp42, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E618) --------------------------------------------------------
int __cdecl makeup_get_status_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr)
{
  char v6; // r0
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  _DWORD v12[3]; // [sp+418h] [bp+410h] BYREF

  if ( str_len > 6 )
  {
    memset(v12, 0, 5u);
    LOBYTE(v12[0]) = v12[0] & 0x1F | 0x40;
    LOBYTE(v12[0]) = v12[0] & 0xEF | (16 * (all & 1));
    LOBYTE(v12[0]) = v12[0] & 0xF0 | 2;
    BYTE1(v12[0]) = 5;
    BYTE2(v12[0]) = chip_addr;
    HIBYTE(v12[0]) = regaddr;
    v6 = CRC5_v1(v12, 0x20u);
    LOBYTE(v12[1]) = v12[1] & 0xE0 | v6 & 0x1F;
    *str = 85;
    str[1] = -86;
    *(_DWORD *)(str + 2) = v12[0];
    str[6] = v12[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", "makeup_get_status_cmd", 7);
      applog(0, (const char *)tmp42, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E750) --------------------------------------------------------
int __cdecl makeup_chain_inactive_cmd(uint8_t *str, uint32_t str_len)
{
  char v3; // r0
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF
  _DWORD v7[2]; // [sp+410h] [bp+408h] BYREF

  if ( str_len > 6 )
  {
    memset(v7, 0, 5u);
    LOBYTE(v7[0]) = v7[0] & 0x1F | 0x40;
    LOBYTE(v7[0]) |= 0x10u;
    LOBYTE(v7[0]) = v7[0] & 0xF0 | 3;
    BYTE1(v7[0]) = 5;
    v3 = CRC5_v1(v7, 0x20u);
    LOBYTE(v7[1]) = v7[1] & 0xE0 | v3 & 0x1F;
    *str = 85;
    str[1] = -86;
    *(_DWORD *)(str + 2) = v7[0];
    str[6] = v7[1];
    return 7;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf((char *)tmp42, 0x400u, "%s input param error: str length = %u\n", "makeup_chain_inactive_cmd", 7);
      applog(0, (const char *)tmp42, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E854) --------------------------------------------------------
int __cdecl bm174x_pack_ioctl_pkg(uint8_t *str, uint32_t str_len, uint32_t oper_type, void *param)
{
  int status_cmd; // r3
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  void *v7; // [sp+418h] [bp+410h]
  void *v8; // [sp+41Ch] [bp+414h]
  void *v9; // [sp+420h] [bp+418h]
  void *v10; // [sp+424h] [bp+41Ch]

  switch ( oper_type )
  {
    case 0u:
      v10 = param;
      status_cmd = makeup_get_status_cmd(str, str_len, *((_BYTE *)param + 1), *(_BYTE *)param, *((_BYTE *)param + 2));
      break;
    case 1u:
      v9 = param;
      status_cmd = makeup_set_config_cmd(
                     str,
                     str_len,
                     *((_BYTE *)param + 1),
                     *(_BYTE *)param,
                     *((_BYTE *)param + 2),
                     *((_DWORD *)param + 1));
      break;
    case 2u:
      v7 = param;
      status_cmd = makeup_work_pkg(str, (uint8_t *)param);
      break;
    case 3u:
      v8 = param;
      status_cmd = makeup_set_address_cmd(str, str_len, *(_BYTE *)param);
      break;
    case 4u:
      status_cmd = makeup_chain_inactive_cmd(str, str_len);
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf((char *)tmp42, 0x400u, "unknow ioctl type %d\n", oper_type);
        applog(0, (const char *)tmp42, 0);
      }
      status_cmd = 0;
      break;
  }
  return status_cmd;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001E9B0) --------------------------------------------------------
int __fastcall add_reg_item(int a1, int a2, int a3)
{
  int *v3; // r3
  char v9[1024]; // [sp+24h] [bp+14h] BYREF
  int i; // [sp+424h] [bp+414h]

  pthread_mutex_lock(&reg_scan_mutex);
  for ( i = 0; ; ++i )
  {
    if ( i > 99 )
    {
      pthread_mutex_unlock(&reg_scan_mutex);
      return -1;
    }
    if ( reg_scan_items[3 * i + 2] < 0 )
      break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      v9,
      0x400u,
      "ADD: chainid=%02x chipaddr=%02x regaddr=%02x regdata=%08x age=%d\n",
      (unsigned __int8)a1,
      BYTE1(a1),
      BYTE2(a1),
      a2,
      a3);
    applog(2, v9, 0);
  }
  v3 = &reg_scan_items[3 * i];
  *v3 = a1;
  v3[1] = a2;
  v3[2] = a3;
  pthread_mutex_unlock(&reg_scan_mutex);
  return 1;
}
// 47C84: using guessed type int opt_log_level;
// 47EF8: using guessed type int reg_scan_items[300];
// 483A8: using guessed type pthread_mutex_t reg_scan_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001EABC) --------------------------------------------------------
int __fastcall read_reg_item(unsigned __int8 *a1, int a2)
{
  int v3; // r3
  int i; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  v7 = a2 % 50 + a2 / 50;
  do
  {
    usleep(0xC350u);
    pthread_mutex_lock(&reg_scan_mutex);
    for ( i = 0; i <= 99; ++i )
    {
      if ( *((unsigned __int8 *)&reg_scan_items + 12 * i) == *a1
        && *((unsigned __int8 *)&reg_scan_items + 12 * i + 1) == a1[1]
        && *((unsigned __int8 *)&reg_scan_items + 12 * i + 2) == a1[2]
        && *((int *)&reg_scan_items + 3 * i + 2) >= 0 )
      {
        *((_DWORD *)a1 + 1) = *((_DWORD *)&reg_scan_items + 3 * i + 1);
        *((_DWORD *)&reg_scan_items + 3 * i + 2) = -1;
        pthread_mutex_unlock(&reg_scan_mutex);
        return 1;
      }
    }
    pthread_mutex_unlock(&reg_scan_mutex);
    v3 = v7--;
  }
  while ( v3 > 0 );
  return -1;
}
// 483A8: using guessed type pthread_mutex_t reg_scan_mutex;

//----- (0001EBFC) --------------------------------------------------------
int reg_scan_aging()
{
  pthread_t v0; // r0
  int i; // [sp+4h] [bp+4h]

  v0 = pthread_self();
  pthread_detach(v0);
  while ( alive == 1 )
  {
    sleep(1u);
    pthread_mutex_lock(&reg_scan_mutex);
    for ( i = 0; i <= 99; ++i )
    {
      if ( reg_scan_items[3 * i + 2] >= 0 )
        --reg_scan_items[3 * i + 2];
    }
    pthread_mutex_unlock(&reg_scan_mutex);
  }
  return 0;
}
// 47B14: using guessed type int alive;
// 47EF8: using guessed type int reg_scan_items[300];
// 483A8: using guessed type pthread_mutex_t reg_scan_mutex;

//----- (0001ECA8) --------------------------------------------------------
int reg_scan_init()
{
  int result; // r0
  char v1[1024]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+404h] [bp+404h]

  memset(reg_scan_items, 0, sizeof(reg_scan_items));
  for ( i = 0; i <= 99; ++i )
    reg_scan_items[3 * i + 2] = -1;
  result = pthread_create((pthread_t *)&p_reg_scan, 0, (void *(*)(void *))reg_scan_aging, 0);
  if ( result && (use_syslog || opt_log_output || opt_log_level > 2) )
  {
    strcpy(v1, "create pthread failed\n");
    return applog(3, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47EF8: using guessed type int reg_scan_items[300];
// 483C0: using guessed type int p_reg_scan;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0001ED7C) --------------------------------------------------------
int reg_scan_exit()
{
  alive = 0;
  usleep(0x16E360u);
  pthread_cancel(p_reg_scan);
  return pthread_join(p_reg_scan, 0);
}
// 47B14: using guessed type int alive;
// 483C0: using guessed type int p_reg_scan;

//----- (0001EDC0) --------------------------------------------------------
unsigned int __fastcall _bswap_32(unsigned int a1)
{
  return bswap32(a1);
}

//----- (0001EDD8) --------------------------------------------------------
unsigned int __fastcall compressArray(int a1, int a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int result; // r0
  unsigned int v8; // [sp+18h] [bp+18h]
  unsigned int j; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+20h] [bp+20h]
  int v11; // [sp+24h] [bp+24h]
  unsigned int v12; // [sp+28h] [bp+28h]
  unsigned int v13; // [sp+2Ch] [bp+2Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "bm1744/driver/sort-verify.c", 0x15u, "compressArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "bm1744/driver/sort-verify.c", 0x16u, "compressArray");
  v8 = a6 + ((a5 + 7) >> 3);
  result = a2 * a5 / (8 * v8);
  if ( result != a4 )
    _assert_fail("out_len == bit_len * in_len / (8 * in_width)", "bm1744/driver/sort-verify.c", 0x19u, "compressArray");
  v13 = 0;
  v12 = 0;
  v11 = 0;
  for ( i = 0; i < a4; ++i )
  {
    if ( v13 <= 7 )
    {
      v12 <<= a5;
      for ( j = a6; j < v8; ++j )
        v12 |= (((unsigned int)((1 << a5) - 1) >> (8 * (v8 - j - 1))) & *(_BYTE *)(j + v11 + a1)) << (8 * (v8 - j - 1));
      v11 += v8;
      v13 += a5;
    }
    v13 -= 8;
    *(_BYTE *)(i + a3) = v12 >> v13;
  }
  return result;
}

//----- (0001EF38) --------------------------------------------------------
unsigned int __fastcall expandArray(int a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int result; // r0
  unsigned int v8; // [sp+14h] [bp+14h]
  unsigned int k; // [sp+18h] [bp+18h]
  unsigned int j; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+20h] [bp+20h]
  int v12; // [sp+24h] [bp+24h]
  unsigned int v13; // [sp+28h] [bp+28h]
  unsigned int v14; // [sp+2Ch] [bp+2Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "bm1744/driver/sort-verify.c", 0x3Fu, "expandArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "bm1744/driver/sort-verify.c", 0x40u, "expandArray");
  v8 = a6 + ((a5 + 7) >> 3);
  result = 8 * a2 * v8 / a5;
  if ( result != a4 )
    _assert_fail("out_len == 8 * out_width * in_len / bit_len", "bm1744/driver/sort-verify.c", 0x43u, "expandArray");
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v13 = (v13 << 8) | *(unsigned __int8 *)(i + a1);
    v14 += 8;
    if ( v14 >= a5 )
    {
      v14 -= a5;
      for ( j = 0; j < a6; ++j )
        *(_BYTE *)(j + v12 + a3) = 0;
      for ( k = a6; k < v8; ++k )
      {
        result = (1 << a5) - 1;
        *(_BYTE *)(a3 + k + v12) = (result >> (8 * (v8 - k - 1))) & (v13 >> (v14 + 8 * (v8 - k - 1)));
      }
      v12 += v8;
    }
  }
  return result;
}

//----- (0001F0B0) --------------------------------------------------------
unsigned int __fastcall getIndices(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  if ( (unsigned int)(a4 + 8) > 0x27 )
    _assert_fail("((cBitLen + 1) + 7) / 8 <= sizeof(uint32_t)", "bm1744/driver/sort-verify.c", 0x6Du, "getIndices");
  if ( (unsigned int)(a3 * (a4 + 1)) >> 5 > a6 )
    return -1;
  if ( a5 )
    compressArray(a1 + a2, a3, a5, (unsigned int)(a3 * (a4 + 1)) >> 5, a4 + 1, 4 - ((unsigned int)(a4 + 8) >> 3));
  return (unsigned int)(a3 * (a4 + 1)) >> 5;
}

//----- (0001F138) --------------------------------------------------------
int __cdecl isZero(const uint8_t *hash, size_t len)
{
  size_t i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < len; ++i )
  {
    if ( hash[i] )
      return 0;
  }
  return 1;
}

//----- (0001F174) --------------------------------------------------------
void __cdecl generateHash(blake2b_state *S, const uint32_t g, uint8_t *hash, const size_t hashLen)
{
  uint8_t hashLena; // [sp+0h] [bp+0h]
  char digest[364]; // [sp+10h] [bp+10h] BYREF
  uint32_t v7[2]; // [sp+17Ch] [bp+17Ch] BYREF

  hashLena = hashLen;
  v7[0] = g;
  memcpy(digest, S, 0x168u);
  blake2b_update((blake2b_state *)digest, (const uint8_t *)v7, 4uLL);
  blake2b_final((blake2b_state *)digest, hash, hashLena);
}
// 1F174: using guessed type uint32_t var_8[2];

//----- (0001F1E0) --------------------------------------------------------
int __cdecl compareSR(const void *p1, const void *p2)
{
  return memcmp(p1, p2, compare_size);
}
// 47B18: using guessed type int compare_size;

//----- (0001F208) --------------------------------------------------------
void __cdecl sort_pair(uint32_t *a, uint32_t len)
{
  uint32_t v2; // [sp+8h] [bp+8h]
  uint32_t *v3; // [sp+Ch] [bp+Ch]
  uint32_t i; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]

  v3 = &a[len];
  v5 = 0;
  for ( i = 0; i < len; ++i )
  {
    if ( v5 || a[i] > v3[i] )
    {
      v5 = 1;
      v2 = a[i];
      a[i] = v3[i];
      v3[i] = v2;
    }
    else if ( a[i] < v3[i] )
    {
      return;
    }
  }
}

//----- (0001F2AC) --------------------------------------------------------
int __cdecl sortValidator(void *data, const unsigned __int8 *soln)
{
  int v2; // r3
  unsigned int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  uint8_t tmpHash[50]; // [sp+14h] [bp+Ch] BYREF
  int i_4; // [sp+48h] [bp+40h] BYREF
  uint8_t hash_0[30]; // [sp+4Ch] [bp+44h] BYREF
  uint8_t hash[30]; // [sp+6Ch] [bp+64h] BYREF
  uint8_t tmp_data[1344]; // [sp+8Ch] [bp+84h] BYREF
  uint32_t real_indices[512]; // [sp+5CCh] [bp+5C4h] BYREF
  uint8_t tmp_hash[30]; // [sp+DCCh] [bp+DC4h] BYREF
  uint8_t vHash[30]; // [sp+DECh] [bp+DE4h] BYREF
  uint32_t indices[512]; // [sp+E0Ch] [bp+E04h] BYREF
  uint8_t *__tmp_0; // [sp+160Ch] [bp+1604h]
  uint8_t *__tmp; // [sp+1610h] [bp+1608h]
  int i_0; // [sp+1614h] [bp+160Ch]
  unsigned __int8 *hex_buff; // [sp+1618h] [bp+1610h]
  int solnr; // [sp+161Ch] [bp+1614h]
  int equihashSolutionSize; // [sp+1620h] [bp+1618h]
  int hashOutput; // [sp+1624h] [bp+161Ch]
  int indicesPerHashOutput; // [sp+1628h] [bp+1620h]
  uint32_t hashLength; // [sp+162Ch] [bp+1624h]
  int collisionByteLength; // [sp+1630h] [bp+1628h]
  int collisionBitLength; // [sp+1634h] [bp+162Ch]
  blake2b_state *digest; // [sp+1638h] [bp+1630h]
  int k; // [sp+163Ch] [bp+1634h]
  int n; // [sp+1640h] [bp+1638h]
  const validData *v; // [sp+1644h] [bp+163Ch]
  uint32_t index_0; // [sp+1648h] [bp+1640h]
  uint32_t j_3; // [sp+164Ch] [bp+1644h]
  int i_5; // [sp+1650h] [bp+1648h]
  int j_2; // [sp+1654h] [bp+164Ch]
  int i_3; // [sp+1658h] [bp+1650h]
  uint32_t level; // [sp+165Ch] [bp+1654h]
  int i_2; // [sp+1660h] [bp+1658h]
  uint32_t index; // [sp+1664h] [bp+165Ch]
  size_t j_1; // [sp+1668h] [bp+1660h]
  int i_1; // [sp+166Ch] [bp+1664h]
  uint32_t m; // [sp+1670h] [bp+1668h]
  int j_0; // [sp+1674h] [bp+166Ch]
  int j; // [sp+1678h] [bp+1670h]
  int i; // [sp+167Ch] [bp+1674h]
  uint32_t xc_size; // [sp+1680h] [bp+1678h]
  uint8_t *xc; // [sp+1684h] [bp+167Ch]
  uint8_t *x; // [sp+1688h] [bp+1680h]
  int err_type; // [sp+168Ch] [bp+1684h]
  uint32_t x_size; // [sp+1690h] [bp+1688h]
  uint32_t indicesLen; // [sp+1694h] [bp+168Ch]

  v = (const validData *)data;
  n = *(_DWORD *)data;
  k = *((_DWORD *)data + 1);
  digest = (blake2b_state *)*((_DWORD *)data + 2);
  collisionBitLength = n / (k + 1);
  v2 = collisionBitLength + 7;
  if ( collisionBitLength + 7 < 0 )
    v2 = collisionBitLength + 14;
  collisionByteLength = v2 >> 3;
  hashLength = (v2 >> 3) * (k + 1);
  indicesPerHashOutput = 512 / n;
  hashOutput = n * (512 / n) / 8;
  equihashSolutionSize = ((n / (k + 1) + 1) << k) / 8;
  solnr = 512;
  indicesLen = 4;
  x_size = 512;
  err_type = 0;
  compare_size = 3;
  expandArray((int)soln, equihashSolutionSize, (int)indices, 2048, collisionBitLength + 1, 1u);
  memset(vHash, 0, sizeof(vHash));
  x = (uint8_t *)malloc(0x4400u);
  xc = (uint8_t *)malloc(0x4400u);
  hex_buff = 0;
  xc_size = 0;
  memset(tmp_hash, 0, sizeof(tmp_hash));
  for ( i = 0; i < solnr; ++i )
  {
    for ( j = i + 1; j < solnr; ++j )
    {
      if ( indices[i] == indices[j] )
      {
        err_type = 1;
        goto LABEL_51;
      }
    }
  }
  for ( j_0 = 0; j_0 < solnr; ++j_0 )
  {
    i_0 = _bswap_32(indices[j_0]);
    generateHash(digest, i_0 / indicesPerHashOutput, tmpHash, hashOutput);
    expandArray(
      (int)&tmpHash[n * (i_0 % indicesPerHashOutput) / 8],
      n / 8,
      (int)hash,
      hashLength,
      collisionBitLength,
      0);
    for ( m = 0; m < hashLength; ++m )
      vHash[m] ^= hash[m];
    memcpy(&x[j_0 * (indicesLen + hashLength)], hash, hashLength);
    memcpy(&x[hashLength + j_0 * (indicesLen + hashLength)], &indices[j_0], indicesLen);
  }
  if ( isZero(vHash, 0x1Eu) )
  {
    memset(vHash, 0, sizeof(vHash));
    for ( i_1 = 0; i_1 <= 8; ++i_1 )
    {
      qsort(x, x_size, hashLength + indicesLen, (__compar_fn_t)compareSR);
      xc_size = 0;
      for ( j_1 = 0; j_1 < x_size; j_1 += 2 )
      {
        for ( index = 0; index < hashLength; ++index )
          tmp_hash[index] = x[index + (j_1 + 1) * (indicesLen + hashLength)] ^ x[index + j_1 * (indicesLen + hashLength)];
        memcpy(&xc[(j_1 >> 1) * (hashLength + 2 * indicesLen)], tmp_hash, hashLength);
        memcpy(
          &xc[hashLength + (j_1 >> 1) * (hashLength + 2 * indicesLen)],
          &x[hashLength + j_1 * (indicesLen + hashLength)],
          indicesLen);
        memcpy(
          &xc[indicesLen + (j_1 >> 1) * (hashLength + 2 * indicesLen) + hashLength],
          &x[hashLength + (j_1 + 1) * (indicesLen + hashLength)],
          indicesLen);
        ++xc_size;
      }
      indicesLen *= 2;
      __tmp = x;
      x = xc;
      xc = __tmp;
      x_size = xc_size;
      compare_size += 3;
    }
    for ( i_2 = 0; i_2 < 512; ++i_2 )
    {
      v3 = _bswap_32(*(_DWORD *)&x[4 * i_2 + hashLength]);
      real_indices[i_2] = v3;
    }
    for ( level = 0; level <= 8; ++level )
    {
      for ( i_3 = 0; i_3 < 512; i_3 += 2 << level )
        sort_pair(&real_indices[i_3], 1 << level);
    }
    indicesLen = 4;
    x_size = 512;
    for ( j_2 = 0; j_2 < solnr; ++j_2 )
    {
      i_4 = real_indices[j_2];
      generateHash(digest, i_4 / indicesPerHashOutput, tmpHash, hashOutput);
      expandArray(
        (int)&tmpHash[n * (i_4 % indicesPerHashOutput) / 8],
        n / 8,
        (int)hash_0,
        hashLength,
        collisionBitLength,
        0);
      i_4 = _bswap_32(real_indices[j_2]);
      memcpy(&x[j_2 * (indicesLen + hashLength)], hash_0, hashLength);
      memcpy(&x[hashLength + j_2 * (indicesLen + hashLength)], &i_4, indicesLen);
      hex_buff = bin2hex(&x[j_2 * (indicesLen + hashLength)], 0x22u);
      free(hex_buff);
    }
    for ( i_5 = 0; i_5 <= 8; ++i_5 )
    {
      xc_size = 0;
      for ( j_3 = 0; j_3 < x_size; j_3 += 2 )
      {
        for ( index_0 = 0; index_0 < hashLength; ++index_0 )
          tmp_hash[index_0] = x[index_0 + (j_3 + 1) * (indicesLen + hashLength)] ^ x[index_0
                                                                                   + j_3 * (indicesLen + hashLength)];
        memcpy(&xc[(j_3 >> 1) * (hashLength + 2 * indicesLen)], tmp_hash, hashLength);
        memcpy(
          &xc[hashLength + (j_3 >> 1) * (hashLength + 2 * indicesLen)],
          &x[hashLength + j_3 * (indicesLen + hashLength)],
          indicesLen);
        memcpy(
          &xc[indicesLen + (j_3 >> 1) * (hashLength + 2 * indicesLen) + hashLength],
          &x[hashLength + (j_3 + 1) * (indicesLen + hashLength)],
          indicesLen);
        ++xc_size;
      }
      indicesLen *= 2;
      __tmp_0 = x;
      x = xc;
      xc = __tmp_0;
      x_size = xc_size;
      compare_size += 3;
    }
    getIndices((int)x, hashLength, 2048, 20, (int)tmp_data, 0x540u);
    hex_buff = bin2hex(tmp_data, 0x540u);
    free(hex_buff);
    hex_buff = bin2hex(x, indicesLen + hashLength);
    free(hex_buff);
    v4 = *((_DWORD *)x + 1);
    v5 = *((_DWORD *)x + 2);
    v6 = *((_DWORD *)x + 3);
    *(_DWORD *)vHash = *(_DWORD *)x;
    *(_DWORD *)&vHash[4] = v4;
    *(_DWORD *)&vHash[8] = v5;
    *(_DWORD *)&vHash[12] = v6;
    v7 = *((_DWORD *)x + 5);
    v8 = *((_DWORD *)x + 6);
    *(_DWORD *)&vHash[16] = *((_DWORD *)x + 4);
    *(_DWORD *)&vHash[20] = v7;
    *(_DWORD *)&vHash[24] = v8;
    *(_WORD *)&vHash[28] = *((_WORD *)x + 14);
    if ( !isZero(vHash, 0x1Eu) )
      err_type = 3;
  }
  else
  {
    err_type = 2;
  }
LABEL_51:
  free(x);
  free(xc);
  return err_type;
}
// 47B18: using guessed type int compare_size;

//----- (00020280) --------------------------------------------------------
void __cdecl zcashPerson(uint8_t *person, const int n, const int k)
{
  memcpy(person, "ZcashPoW", 8u);
  *((_DWORD *)person + 2) = n;
  *((_DWORD *)person + 3) = k;
}

//----- (000202B4) --------------------------------------------------------
void __cdecl digestInit(blake2b_state *S, const int n, const int k)
{
  char v6[64]; // [sp+10h] [bp+10h] BYREF

  memset(v6, 0, sizeof(v6));
  v6[2] = 1;
  v6[3] = 1;
  v6[0] = n * (512 / n) / 8;
  zcashPerson((uint8_t *)&v6[48], n, k);
  blake2b_init_param(S, (const blake2b_param *)v6);
}

//----- (00020320) --------------------------------------------------------
int __fastcall CRC5(_BYTE *a1, unsigned __int8 a2)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v8; // [sp+1Ch] [bp+1Ch]
  char v9; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 v10; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v5 = 16843009;
  v6 = 1;
  v10 = 0x80;
  v9 = 0;
  for ( i = 0; i < (unsigned int)a2; ++i )
  {
    v7 = (v10 & *a1) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 0x80;
      v9 = 0;
      ++a1;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (00020440) --------------------------------------------------------
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len)
{
  const uint8_t *v2; // r3
  unsigned __int16 v7; // [sp+Ch] [bp+Ch]
  unsigned __int8 v8; // [sp+Eh] [bp+Eh]
  unsigned __int8 v9; // [sp+Fh] [bp+Fh]

  v9 = -1;
  v8 = -1;
  while ( w_len-- )
  {
    v2 = p_data++;
    v7 = (unsigned __int8)(v8 ^ *v2);
    v8 = v9 ^ chCRCHTalbe[v8 ^ *v2];
    v9 = chCRCLTalbe[v7];
  }
  return v8 | (v9 << 8);
}
// 3408C: using guessed type _BYTE chCRCHTalbe[256];
// 3418C: using guessed type _BYTE chCRCLTalbe[256];

//----- (000204B0) --------------------------------------------------------
int bitmain_axi_init()
{
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+0h] BYREF
  int v3; // [sp+408h] [bp+400h]
  int v4; // [sp+40Ch] [bp+404h]

  v4 = 0;
  fd_fpga = open("/dev/axi_fpga_dev", 2);
  if ( fd_fpga >= 0 )
  {
    axi_fpga_addr = (int)mmap(0, 0x1200u, 3, 1, fd_fpga, 0);
    if ( axi_fpga_addr )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "mmap axi_fpga_addr = 0x%p\n", (const void *)axi_fpga_addr);
        applog(2, (const char *)tmp42, 0);
      }
      v3 = (unsigned __int16)*(_DWORD *)axi_fpga_addr;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "axi_fpga_addr data = 0x%x\n", v3);
        applog(2, (const char *)tmp42, 0);
      }
      fd_fpga_mem = open("/dev/fpga_mem", 2);
      if ( fd_fpga_mem >= 0 )
      {
        fpga_mem_addr = (int)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
        if ( fpga_mem_addr )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf((char *)tmp42, 0x400u, "mmap fpga_mem_addr = 0x%p\n", (const void *)fpga_mem_addr);
            applog(2, (const char *)tmp42, 0);
          }
          return v4;
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(
              (char *)tmp42,
              0x400u,
              "mmap fpga_mem_addr failed. fpga_mem_addr = 0x%p\n",
              (const void *)fpga_mem_addr);
            applog(2, (const char *)tmp42, 0);
          }
          return -1;
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "/dev/fpga_mem open failed. fd_fpga_mem = %d\n", fd_fpga_mem);
          applog(2, (const char *)tmp42, 0);
        }
        return -1;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "mmap axi_fpga_addr failed. axi_fpga_addr = 0x%p\n",
          (const void *)axi_fpga_addr);
        applog(2, (const char *)tmp42, 0);
      }
      return -1;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "/dev/axi_fpga_dev open failed. fd = %d\n", fd_fpga);
      applog(2, (const char *)tmp42, 0);
    }
    return -1;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483C4: using guessed type int fpga_mem_addr;
// 483C8: using guessed type int axi_fpga_addr;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F32AC: using guessed type int fd_fpga_mem;
// F32B0: using guessed type int fd_fpga;

//----- (000207F0) --------------------------------------------------------
void bitmain_axi_close()
{
  unsigned __int8 tmp42[1024]; // [sp+4h] [bp+4h] BYREF
  int v1; // [sp+404h] [bp+404h]

  v1 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", "bitmain_axi_close");
    applog(2, (const char *)tmp42, 0);
  }
  v1 = munmap((void *)axi_fpga_addr, 0x1200u);
  if ( v1 < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(2, (const char *)tmp42, 0);
  }
  v1 = munmap((void *)fpga_mem_addr, 0x1000000u);
  if ( v1 < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(2, (const char *)tmp42, 0);
  }
  close(fd_fpga);
  close(fd_fpga_mem);
}
// 47C84: using guessed type int opt_log_level;
// 483C4: using guessed type int fpga_mem_addr;
// 483C8: using guessed type int axi_fpga_addr;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F32AC: using guessed type int fd_fpga_mem;
// F32B0: using guessed type int fd_fpga;

//----- (00020948) --------------------------------------------------------
unsigned int __cdecl read_axi_fpga(unsigned int address)
{
  return *(_DWORD *)(4 * address + axi_fpga_addr);
}
// 483C8: using guessed type int axi_fpga_addr;

//----- (00020978) --------------------------------------------------------
void __cdecl write_axi_fpga(unsigned int address, unsigned int data)
{
  *(_DWORD *)(4 * address + axi_fpga_addr) = data;
}
// 483C8: using guessed type int axi_fpga_addr;

//----- (000209A4) --------------------------------------------------------
void init_fpga()
{
  unsigned __int8 tmp42[1024]; // [sp+4h] [bp+4h] BYREF
  unsigned int v1; // [sp+404h] [bp+404h]

  v1 = -2147450880;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", "init_fpga");
    applog(2, (const char *)tmp42, 0);
  }
  write_axi_fpga(0x20u, v1);
  while ( (read_axi_fpga(0x20u) & 0x80000000) != 0 )
    usleep(0x2710u);
  usleep(0x186A0u);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020A3C) --------------------------------------------------------
void __cdecl get_return_nonce(unsigned int *buf)
{
  *buf = read_axi_fpga(4u);
  buf[1] = read_axi_fpga(5u);
}

//----- (00020A68) --------------------------------------------------------
void __cdecl set_BC_command_buffer(unsigned int *value)
{
  write_axi_fpga(0x31u, *value);
  write_axi_fpga(0x32u, value[1]);
  write_axi_fpga(0x33u, value[2]);
}

//----- (00020AA0) --------------------------------------------------------
unsigned int get_BC_write_command()
{
  return read_axi_fpga(0x30u);
}

//----- (00020AC0) --------------------------------------------------------
void __cdecl set_BC_write_command(unsigned int value)
{
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  char v3; // [sp+40Fh] [bp+40Fh]

  v3 = 0;
  if ( (value & 0x80000000) != 0 )
  {
    while ( (get_BC_write_command() & 0x80000000) != 0 )
    {
      usleep(0x3E8u);
      if ( (unsigned __int8)++v3 > 0x64u )
      {
        v3 = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "%s: timeout\n\n", "set_BC_write_command");
          applog(2, (const char *)tmp42, 0);
        }
        break;
      }
    }
  }
  write_axi_fpga(0x30u, value);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020B74) --------------------------------------------------------
unsigned __int8 __cdecl asic_baud_to_fpga_baud(unsigned __int8 asic_baud)
{
  unsigned __int8 v1; // r3
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF

  switch ( asic_baud )
  {
    case 0u:
      v1 = 1;
      break;
    case 1u:
      v1 = 3;
      break;
    case 2u:
      v1 = 5;
      break;
    case 6u:
      v1 = 13;
      break;
    case 0x1Au:
      v1 = 53;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: Don't support ASIC baud = %d, error!!!\n",
          "asic_baud_to_fpga_baud",
          asic_baud);
        applog(2, (const char *)tmp42, 0);
      }
      v1 = 53;
      break;
  }
  return v1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020C78) --------------------------------------------------------
void __cdecl set_fpga_baud(unsigned __int8 asic_baud)
{
  unsigned __int8 v1; // [sp+Fh] [bp+Fh]

  v1 = asic_baud_to_fpga_baud(asic_baud);
  write_axi_fpga(0xFu, v1);
}

//----- (00020CA0) --------------------------------------------------------
void __cdecl i2c_write(unsigned int config_data)
{
  int v2; // [sp+40Ch] [bp+40Ch]

  v2 = 0;
  while ( (read_axi_fpga(0xCu) & 0x80000000) == 0 )
    usleep(0x1388u);
  write_axi_fpga(0xCu, config_data);
}
// 20CC2: conditional instruction was optimized away because %var_4.4==0
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020D3C) --------------------------------------------------------
unsigned __int8 __cdecl i2c_read(unsigned int config_data)
{
  int axi_fpga; // [sp+408h] [bp+408h]
  int v3; // [sp+40Ch] [bp+40Ch]

  v3 = 0;
  axi_fpga = 255;
  i2c_write(config_data | 0x2000000);
  do
  {
    usleep(0x1388u);
    axi_fpga = read_axi_fpga(0xCu);
  }
  while ( axi_fpga >= 0 );
  return axi_fpga;
}
// 20D82: conditional instruction was optimized away because %var_4.4==0
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00020DEC) --------------------------------------------------------
int __fastcall ISL_page_enable(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v5[8]; // [sp+Ch] [bp+4h] BYREF

  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  write_dc_dc(a1, a2, a3, 0, (int)v5, 1);
  return 0;
}

//----- (00020E28) --------------------------------------------------------
int __fastcall ISL_on(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 0x80;
  write_dc_dc(a1, a2, a3, 1, (int)&v4, 1);
  return 0;
}

//----- (00020E60) --------------------------------------------------------
int __fastcall ISL_off(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 64;
  write_dc_dc(a1, a2, a3, 1, (int)&v4, 1);
  return 0;
}

//----- (00020E98) --------------------------------------------------------
int __fastcall ISL_set_on_off_config(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v5[8]; // [sp+Ch] [bp+4h] BYREF

  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  write_dc_dc(a1, a2, a3, 2, (int)v5, 1);
  return 0;
}

//----- (00020ED4) --------------------------------------------------------
int __fastcall ISL_set_clear_faults(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 1;
  write_dc_dc(a1, a2, a3, 3, (int)&v4, 1);
  return 0;
}

//----- (00020F0C) --------------------------------------------------------
int __fastcall ISL_set_write_protect(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v5[8]; // [sp+Ch] [bp+4h] BYREF

  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  write_dc_dc(a1, a2, a3, 16, (int)v5, 1);
  return 0;
}

//----- (00020F48) --------------------------------------------------------
int __fastcall ISL_set_vout_command(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int16 a4)
{
  unsigned __int16 v8; // [sp+14h] [bp+Ch] BYREF

  v8 = a4;
  printf("uint16 = 0x%04x[%u], cmd0=%02x cmd1=%02x\n", a4, a4, (unsigned __int8)a4, HIBYTE(a4));
  write_dc_dc(a1, a2, a3, 33, (int)&v8, 2);
  return 0;
}

//----- (00020FB0) --------------------------------------------------------
int __fastcall ISL_set_apply_settings(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v4; // [sp+17h] [bp+Fh] BYREF

  v4 = 1;
  write_dc_dc(a1, a2, a3, 231, (int)&v4, 1);
  return 0;
}

//----- (00020FE8) --------------------------------------------------------
int __fastcall ISL_get_voltage(unsigned __int8 a1, unsigned __int8 a2, char a3, _WORD *a4)
{
  char v9[4]; // [sp+14h] [bp+Ch] BYREF

  memset(v9, 0, 2u);
  read_dc_dc(a1, a2, a3, 33, (int)v9, 2);
  *a4 = ((unsigned __int8)v9[1] << 8) | (unsigned __int8)v9[0];
  return 0;
}

//----- (00021040) --------------------------------------------------------
int __fastcall ISL_read_reg_default(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  char v7[4]; // [sp+14h] [bp+Ch] BYREF

  v7[0] = 0;
  v7[1] = 0;
  read_dc_dc(a1, a2, a3, 0, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 1, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 2, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 3, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 16, (int)v7, 1);
  read_dc_dc(a1, a2, a3, 33, (int)v7, 2);
  read_dc_dc(a1, a2, a3, 34, (int)v7, 1);
  return 0;
}

//----- (00021100) --------------------------------------------------------
uint16_t __cdecl ISL_set_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage)
{
  uint16_t v9; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 v10; // [sp+Eh] [bp+Eh]
  unsigned __int8 v11; // [sp+Fh] [bp+Fh]

  puts("begin to read voltage");
  ISL_page_enable(which_chain, which_i2c, i2c_dev_addr, 0);
  usleep(0x186A0u);
  usleep(0x186A0u);
  ISL_set_vout_command(which_chain, which_i2c, i2c_dev_addr, voltage);
  usleep(0x186A0u);
  usleep(0x186A0u);
  puts("end to read voltage");
  v11 = 0;
  v10 = 5;
  v9 = 0;
  do
  {
    usleep(0x186A0u);
    ISL_get_voltage(which_chain, which_i2c, i2c_dev_addr, &v9);
    ++v11;
  }
  while ( v11 <= (unsigned int)v10 && !v9 );
  printf("--- ISL_get_voltage, Voltage: 0.%03d V\n\n", v9);
  return v9;
}

//----- (000211D4) --------------------------------------------------------
int open_key()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  dword_F34A8 = open("/sys/class/gpio/gpio943/value", 2048);
  if ( dword_F34A8 < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open key failed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
  return dword_F34A8;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A8: using guessed type int dword_F34A8;

//----- (00021268) --------------------------------------------------------
void close_key()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  close(dword_F34A8);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "key closed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A8: using guessed type int dword_F34A8;

//----- (000212D8) --------------------------------------------------------
ssize_t __cdecl read_key(unsigned __int8 value)
{
  char valuea[5]; // [sp+7h] [bp+7h] BYREF
  unsigned __int8 tmp42[1024]; // [sp+Ch] [bp+Ch] BYREF
  ssize_t v5; // [sp+40Ch] [bp+40Ch]

  valuea[0] = value;
  v5 = 0;
  lseek(dword_F34A8, 0, 0);
  v5 = read(dword_F34A8, valuea, 1u);
  if ( v5 == 1 )
    return 1;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s: can't read out key value\n", "read_key");
    applog(2, (const char *)tmp42, 0);
  }
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A8: using guessed type int dword_F34A8;

//----- (00021388) --------------------------------------------------------
int open_lcd()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  dword_F34A0 = open("/dev/bitmain-lcd", 2178);
  if ( dword_F34A0 <= 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open lcd failed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
  return dword_F34A0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (0002141C) --------------------------------------------------------
int close_lcd()
{
  unsigned __int8 tmp42[1024]; // [sp+4h] [bp+4h] BYREF
  int v2; // [sp+404h] [bp+404h]

  v2 = close(dword_F34A0);
  if ( v2 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy((char *)tmp42, "lcd close failed!!!\n");
      applog(2, (const char *)tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "lcd closed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
  return v2;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (000214F8) --------------------------------------------------------
void __cdecl write_lcd(unsigned int line, unsigned __int8 *buf, unsigned int size)
{
  unsigned int v3; // r3
  size_t sizea; // [sp+4h] [bp+4h]
  unsigned int linea; // [sp+Ch] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+414h] [bp+414h]

  linea = line;
  sizea = size;
  v8 = 0;
  if ( buf && dword_F34A0 > 0 )
  {
    if ( line <= 3 && size <= 0x40 )
    {
      lseek(dword_F34A0, 0, 0);
      memset(lcd_output, 32, 0x40u);
      while ( sizea )
      {
        if ( sizea <= 0x10 )
        {
          memcpy(&lcd_output[16 * linea], &buf[v8], sizea);
          break;
        }
        v3 = linea++;
        memcpy(&lcd_output[16 * v3], &buf[v8], 0x10u);
        sizea -= 16;
        v8 += 16;
      }
      write(dword_F34A0, lcd_output, 0x40u);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: write_lcd's arg is overflow\n", "write_lcd");
      applog(2, (const char *)tmp42, 0);
    }
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (00021670) --------------------------------------------------------
void __cdecl write_lcd_no_memset(unsigned int line, unsigned __int8 *buf, unsigned int size)
{
  unsigned int v3; // r3
  size_t sizea; // [sp+4h] [bp+4h]
  unsigned int linea; // [sp+Ch] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+414h] [bp+414h]

  linea = line;
  sizea = size;
  v8 = 0;
  if ( buf && dword_F34A0 > 0 )
  {
    if ( line <= 3 && size <= 0x40 )
    {
      while ( sizea )
      {
        if ( sizea <= 0x10 )
        {
          memcpy(&lcd_output[16 * linea], &buf[v8], sizea);
          break;
        }
        v3 = linea++;
        memcpy(&lcd_output[16 * v3], &buf[v8], 0x10u);
        sizea -= 16;
        v8 += 16;
      }
      write(dword_F34A0, lcd_output, 0x40u);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: write_lcd's arg is overflow\n", "write_lcd_no_memset");
      applog(2, (const char *)tmp42, 0);
    }
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (000217C0) --------------------------------------------------------
int open_red_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  red_led_fd = open("/sys/class/gpio/gpio941/value", 2049);
  if ( red_led_fd < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open red led failed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
  return red_led_fd;
}
// 47C84: using guessed type int opt_log_level;
// 483CC: using guessed type int red_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00021858) --------------------------------------------------------
void close_red_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  close(red_led_fd);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "red led closed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
}
// 47C84: using guessed type int opt_log_level;
// 483CC: using guessed type int red_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000218D0) --------------------------------------------------------
void red_led_on()
{
  write(red_led_fd, "1", 1u);
}
// 483CC: using guessed type int red_led_fd;

//----- (000218F4) --------------------------------------------------------
ssize_t red_led_off()
{
  return write(red_led_fd, "0", 1u);
}
// 483CC: using guessed type int red_led_fd;

//----- (00021918) --------------------------------------------------------
int open_green_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  green_led_fd = open("/sys/class/gpio/gpio942/value", 2049);
  if ( green_led_fd < 0 && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    strcpy((char *)tmp42, "open green led failed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
  return green_led_fd;
}
// 47C84: using guessed type int opt_log_level;
// 483D0: using guessed type int green_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000219B0) --------------------------------------------------------
void close_green_led()
{
  unsigned __int8 tmp42[1024]; // [sp+0h] [bp+0h] BYREF

  close(green_led_fd);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "green led closed!!!\n");
    applog(2, (const char *)tmp42, 0);
  }
}
// 47C84: using guessed type int opt_log_level;
// 483D0: using guessed type int green_led_fd;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00021A24) --------------------------------------------------------
ssize_t green_led_on()
{
  return write(green_led_fd, "1", 1u);
}
// 483D0: using guessed type int green_led_fd;

//----- (00021A48) --------------------------------------------------------
ssize_t green_led_off()
{
  return write(green_led_fd, "0", 1u);
}
// 483D0: using guessed type int green_led_fd;

//----- (00021A6C) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[1024]; // [sp+0h] [bp+0h] BYREF
  char v5[32]; // [sp+400h] [bp+400h] BYREF

  app_config_handle("/mnt/card/app_config.ini");
  memset(v5, 0, sizeof(v5));
  sprintf(v5, "%s.log", byte_F34E0);
  app_conf = (int)fopen(v5, "w+");
  if ( app_conf )
  {
    start_pcba_test();
    fclose((FILE *)app_conf);
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v4, 0x400u, "open %s file error\n", v5);
    applog(2, v4, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34DC: using guessed type int app_conf;

//----- (00021B44) --------------------------------------------------------
void miner_start()
{
  ;
}

//----- (00021B54) --------------------------------------------------------
void miner_join()
{
  ;
}

//----- (00021B64) --------------------------------------------------------
int __fastcall print_solver_line(int a1, int a2, int a3, int a4)
{
  return a4;
}

//----- (00021B80) --------------------------------------------------------
int __fastcall set_baud(int a1)
{
  unsigned __int8 v2; // [sp+4h] [bp+4h]

  v2 = a1;
  set_baud_chain(a1);
  sleep(1u);
  set_fpga_baud(v2);
  return usleep(0x2710u);
}

//----- (00021BB0) --------------------------------------------------------
int bm1744_hashboard_init()
{
  set_baud(0);
  usleep(0xC350u);
  set_core_timeout(dword_F3648);
  usleep(0x2710u);
  set_ticket_mask(dword_F3644);
  usleep(0x2710u);
  set_frequency(dword_F3678);
  usleep(0x2710u);
  set_nonce_shift(0);
  return usleep(0x2710u);
}
// F3644: using guessed type int dword_F3644;
// F3648: using guessed type int dword_F3648;
// F3678: using guessed type int dword_F3678;

//----- (00021C24) --------------------------------------------------------
void *show_nonce_detail()
{
  void *result; // r0
  _WORD v1[512]; // [sp+8h] [bp+0h] BYREF
  _DWORD v2[2]; // [sp+408h] [bp+400h] BYREF
  _DWORD v3[2]; // [sp+410h] [bp+408h] BYREF
  char v4[64]; // [sp+418h] [bp+410h] BYREF
  char v5[64]; // [sp+458h] [bp+450h] BYREF
  int v6; // [sp+498h] [bp+490h]
  int v7; // [sp+49Ch] [bp+494h]
  int v8; // [sp+4A0h] [bp+498h]
  int i; // [sp+4A4h] [bp+49Ch]

  v6 = (unsigned __int8)gChain;
  memset(v5, 0, sizeof(v5));
  result = memset(v4, 0, sizeof(v4));
  v8 = 0;
  v7 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    v3[0] = 0;
    v3[1] = 0;
    sprintf((char *)v3, "%03d ", one_work_nonce_each_asic[3 * v6 + i]);
    strcat(v5, (const char *)v3);
    v2[0] = 0;
    v2[1] = 0;
    sprintf((char *)v2, "%03d ", one_work_invalid_nonce_each_asic_2[6 * v6 + 1 + 2 * i]);
    result = strcat(v4, (const char *)v2);
    v8 += one_work_nonce_each_asic[3 * v6 + i];
    v7 += one_work_invalid_nonce_each_asic_2[6 * v6 + 1 + 2 * i];
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)v1, 0x400u, "valid:    %s total=%d\n", v5, v8);
    result = (void *)applog(2, (const char *)v1, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)v1, 0x400u, "invalid:  %s total=%d\n", v4, v7);
    result = (void *)applog(2, (const char *)v1, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    v1[0] = 10;
    return (void *)applog(2, (const char *)v1, 0);
  }
  return result;
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00021E50) --------------------------------------------------------
void __noreturn singleboard_sensor_test()
{
  char v0[1024]; // [sp+8h] [bp+0h] BYREF
  int v1; // [sp+408h] [bp+400h]
  int v2; // [sp+40Ch] [bp+404h]
  int v3; // [sp+410h] [bp+408h]
  int v4; // [sp+414h] [bp+40Ch]
  unsigned __int8 v5; // [sp+41Ah] [bp+412h] BYREF
  unsigned __int8 v6; // [sp+41Bh] [bp+413h] BYREF
  int v7; // [sp+41Ch] [bp+414h]
  int v8; // [sp+420h] [bp+418h]
  int i; // [sp+424h] [bp+41Ch]
  __int64 savedregs; // [sp+428h] [bp+420h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v0, 0x400u, "%s Begin\n", "singleboard_sensor_test");
    applog(2, v0, 0);
  }
  set_i2c_enable();
  usleep(0x30D40u);
  v6 = 0;
  v5 = 0;
  v8 = 0;
  v7 = 100;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( 1 )
  {
    sleep(5u);
    for ( i = 0; i <= 1; ++i )
    {
      v6 = 0;
      v5 = 0;
      if ( read_sensor(0, i, 76, 1u, &v5) == 5 )
      {
        *((_DWORD *)&savedregs + 2 * i - 7) = 1;
        sensor_info[4 * i + 1] = v5;
        if ( v5 > v8 )
          v8 = v5;
        if ( v5 < v7 )
          v7 = v5;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v0, 0x400u, "Read Success Sensor%d ext-temp=%d\n\n", i, v5);
          applog(2, v0, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v0, 0x400u, "Read Fail ext-temp Sensor%d, try again\n", i);
        applog(2, v0, 0);
      }
      usleep(0x186A0u);
      if ( read_sensor(0, i, 76, 0, &v6) == 5 )
      {
        *((_DWORD *)&savedregs + 2 * i - 8) = 1;
        sensor_info[4 * i] = v6;
        if ( v6 > v8 )
          v8 = v6;
        if ( v6 < v7 )
          v7 = v6;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v0, 0x400u, "Read Success Sensor%d local-temp=%d\n\n", i, v6);
          applog(2, v0, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v0, 0x400u, "Read Fail local-temp Sensor%d, try again\n", i);
        applog(2, v0, 0);
      }
      usleep(0x186A0u);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v0, 0x400u, "%s high %d low %d\n", "singleboard_sensor_test", v8, v7);
      applog(2, v0, 0);
    }
    if ( v1 <= 0 || v2 <= 0 || v3 <= 0 || v4 <= 0 )
    {
      read_temp_test_result = -1;
    }
    else
    {
      read_temp_test_result = 1;
      if ( dword_F3684 <= v8 || dword_F3688 >= v7 )
        tempture_value_test_result = -1;
      else
        tempture_value_test_result = 1;
    }
  }
}
// 21E50: using guessed type void __noreturn singleboard_sensor_test();
// 47C84: using guessed type int opt_log_level;
// 483D8: using guessed type int read_temp_test_result;
// 483DC: using guessed type int tempture_value_test_result;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F3684: using guessed type int dword_F3684;
// F3688: using guessed type int dword_F3688;

//----- (00022220) --------------------------------------------------------
int singleboard_set_address_test()
{
  int result; // r0
  char v1[1024]; // [sp+8h] [bp+0h] BYREF
  unsigned __int8 v2; // [sp+408h] [bp+400h] BYREF
  unsigned __int8 v3; // [sp+409h] [bp+401h]
  char v4; // [sp+40Ah] [bp+402h]
  int v5; // [sp+40Ch] [bp+404h]
  int v6; // [sp+410h] [bp+408h]
  int i; // [sp+414h] [bp+40Ch]

  read_register(0, 0, 0, 0);
  read_register(0, 1, 0, 0);
  usleep(0x30D40u);
  asic_addr_interval();
  set_address();
  usleep(0x30D40u);
  result = read_register(0, 1, 0, 0);
  for ( i = 0; i <= 2; ++i )
  {
    v2 = 0;
    v3 = i * addr_interval;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    result = read_reg_item(&v2, 500);
    if ( result < 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        strcpy(v1, "read chip num timeout\n");
        result = applog(2, v1, 0);
      }
      break;
    }
    if ( (unsigned __int8)v5 != v3 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v1, 0x400u, "Set address Fail set:%02x get:%02x\n", v3, (unsigned __int8)v5);
        result = applog(2, v1, 0);
      }
      break;
    }
  }
  if ( i == 3 )
  {
    set_address_test_result = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v1, 0x400u, "%s Success\n", "singleboard_set_address_test");
      return applog(2, v1, 0);
    }
  }
  else
  {
    set_address_test_result = -1;
  }
  return result;
}
// 47478: using guessed type int addr_interval;
// 47C84: using guessed type int opt_log_level;
// 483D4: using guessed type int set_address_test_result;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022420) --------------------------------------------------------
int __fastcall singleboard_step_increase_frequency(int a1, int a2)
{
  int result; // r0
  char v4[1024]; // [sp+14h] [bp+14h] BYREF
  int freq_by_index; // [sp+414h] [bp+414h]
  int index_by_freq; // [sp+418h] [bp+418h]
  int v7; // [sp+41Ch] [bp+41Ch]

  index_by_freq = get_index_by_freq(a2);
  v7 = get_index_by_freq(a1);
  while ( 1 )
  {
    sleep(0xAu);
    if ( index_by_freq - v7 <= 5 )
      v7 = index_by_freq;
    else
      v7 += 5;
    freq_by_index = get_freq_by_index(v7);
    result = set_frequency(freq_by_index);
    if ( v7 == index_by_freq )
      break;
    show_nonce_detail();
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v4, "init freq done\n");
    return applog(2, v4, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022504) --------------------------------------------------------
void *singleboard_nonce_test()
{
  void *result; // r0
  char v2[1024]; // [sp+14h] [bp+4h] BYREF
  unsigned __int8 v3[1124]; // [sp+414h] [bp+404h] BYREF
  int i; // [sp+878h] [bp+868h]
  int v5; // [sp+87Ch] [bp+86Ch]

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "Begin Nonce Test...\n");
    applog(2, v2, 0);
  }
  memset(v3, 0, sizeof(v3));
  memcpy(
    &v3[843],
    "040000005a0995c5fe39ee678b290a2636ec3c32e26bfafb5711ee687ad3750e00000000bbd08c45cf29d96c4f1e5b9d136f2f0ffc22d6be511e"
    "204773afee519a2478db00000000000000000000000000000000000000000000000000000000000000008dc7205ab0f0131c0000000000000000"
    "aaaaad5327c5d2a66bda09d1000000000000000000000000",
    0x118u);
  memcpy(
    v3,
    "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d3d3ff15"
    "02b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771eccb5c5e3d6beb4"
    "70359446494d25e15f87df87c3119ebd9ca813a400000000",
    0x118u);
  memcpy(
    &v3[562],
    "0400000065747d1d1299b3422670ee656f86aa07d5dfefc485c2d2206304e6030000000067669e8d830bc95a3a2b88582f06f835ecfcfe85c92a"
    "f15d001376fb544a3db40000000000000000000000000000000000000000000000000000000000000000ee060c5ba21f0f1c4809000000000000"
    "000000000000000000000400000000000000000000000000",
    0x118u);
  memcpy(
    &v3[281],
    "04000000a250abe4ab99767ec31b0eec43786781bf556a27b99436d831ff8e020000000002f24739336a89e32ee1081592a1d2ebbf1321c94847"
    "89cf04d3234ad531c3d80000000000000000000000000000000000000000000000000000000000000000abe6ea5add990f1cf408000000000000"
    "cda79db66d4176ca36d5ad06000000000000000000000000",
    0x118u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "pre sending work begin\n");
    applog(2, v2, 0);
  }
  send_work(v3, 0, 0);
  sleep(5u);
  show_nonce_detail();
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "pre sending work end\n");
    applog(2, v2, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "normal send work begin \n");
    applog(2, v2, 0);
  }
  result = (void *)send_work(v3, 0, 0);
  v5 = dword_F3650;
  while ( v5-- )
  {
    sleep(1u);
    result = show_nonce_detail();
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "normal send work end \n");
    result = (void *)applog(2, v2, 0);
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( one_work_nonce_each_asic[3 * (unsigned __int8)gChain + i] >= (unsigned int)dword_F3654
      && one_work_invalid_nonce_each_asic_2[6 * (unsigned __int8)gChain + 1 + 2 * i] <= (unsigned int)dword_F3658 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v2,
          0x400u,
          "pass : asic%d valid [%d   %d], invalid[%d   %d]\n",
          i,
          one_work_nonce_each_asic[3 * (unsigned __int8)gChain + i],
          dword_F3654,
          one_work_invalid_nonce_each_asic_2[6 * (unsigned __int8)gChain + 1 + 2 * i],
          dword_F3658);
        result = (void *)applog(2, v2, 0);
      }
      nonce_test_asic_result[i] = 79;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v2,
          0x400u,
          "error: asic%d valid [%d   %d], invalid[%d   %d]\n",
          i,
          one_work_nonce_each_asic[3 * (unsigned __int8)gChain + i],
          dword_F3654,
          one_work_invalid_nonce_each_asic_2[6 * (unsigned __int8)gChain + 1 + 2 * i],
          dword_F3658);
        result = (void *)applog(2, v2, 0);
      }
      nonce_test_asic_result[i] = 88;
    }
  }
  return result;
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F3650: using guessed type int dword_F3650;
// F3654: using guessed type int dword_F3654;
// F3658: using guessed type int dword_F3658;

//----- (00022994) --------------------------------------------------------
unsigned int singleboard_patten_test()
{
  unsigned int result; // r0
  unsigned __int8 *ptr; // [sp+4h] [bp+4h]
  int v2; // [sp+8h] [bp+8h]
  int k; // [sp+Ch] [bp+Ch]
  int j; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]
  int m; // [sp+14h] [bp+14h]

  v2 = dword_F3758 + dword_F3750 + dword_F3754;
  dword_F37C8 = 1;
  sleep(1u);
  for ( i = 0; g_patten > i; ++i )
  {
    for ( j = 0; dword_F374C > j; ++j )
    {
      for ( k = 0; dword_F375C > k; ++k )
      {
        pthread_mutex_lock(&mutex);
        dword_F37A4 = dword_F37A0 + v2 * j * dword_F375C + v2 * dword_F375C * i * dword_F374C + v2 * k;
        dword_F37A8 = i;
        dword_F37AC = j;
        dword_F37B0 = k;
        pthread_mutex_unlock(&mutex);
        ptr = bin2hex((const unsigned __int8 *)dword_F37A4, dword_F3750);
        send_work(ptr, 1, 0);
        free(ptr);
        usleep(1000 * dword_F368C);
      }
    }
  }
  dword_F37C8 = 0;
  result = sleep(1u);
  for ( m = 0; g_patten > m; ++m )
  {
    if ( *(_DWORD *)(4 * m + dword_F37BC) >= (unsigned int)dword_F3654 )
      nonce_test_asic_result[m] = 79;
    else
      nonce_test_asic_result[m] = 88;
  }
  return result;
}
// F3654: using guessed type int dword_F3654;
// F368C: using guessed type int dword_F368C;
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F37A0: using guessed type int dword_F37A0;
// F37A4: using guessed type int dword_F37A4;
// F37A8: using guessed type int dword_F37A8;
// F37AC: using guessed type int dword_F37AC;
// F37B0: using guessed type int dword_F37B0;
// F37BC: using guessed type int dword_F37BC;
// F37C8: using guessed type int dword_F37C8;

//----- (00022B84) --------------------------------------------------------
int pcba_test()
{
  pthread_t th; // [sp+4h] [bp+4h] BYREF

  singleboard_set_address_test();
  pthread_create(&th, 0, (void *(*)(void *))singleboard_sensor_test, 0);
  singleboard_patten_test();
  pthread_cancel(th);
  return pthread_join(th, 0);
}
// 21E50: using guessed type void __noreturn singleboard_sensor_test();

//----- (00022BC0) --------------------------------------------------------
int __cdecl vol_init(unsigned __int16 vol)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF
  uint16_t v5; // [sp+412h] [bp+40Ah]
  int i; // [sp+414h] [bp+40Ch]

  if ( vol <= 0x384u && vol > 0x2EDu )
  {
    if ( vol == 800 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "setting voltage == configed voltage %d\n", vol);
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      for ( i = 0; i <= 2; ++i )
      {
        v5 = ISL_set_voltage(gChain, 0, isl_dev_addr[i], vol);
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "asic%d read back voltage = %d\n", i, v5);
          applog(2, (const char *)tmp42, 0);
        }
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "illeagel setting voltage is %d\n", vol);
      applog(2, (const char *)tmp42, 0);
    }
    return -1;
  }
}
// 47B7C: using guessed type _BYTE isl_dev_addr[4];
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022D40) --------------------------------------------------------
int __fastcall isl_communication_check(unsigned __int16 a1)
{
  char v4[1026]; // [sp+18h] [bp+8h] BYREF
  unsigned __int16 v5; // [sp+41Ah] [bp+40Ah] BYREF
  int v6; // [sp+41Ch] [bp+40Ch]
  int v7; // [sp+420h] [bp+410h]
  int i; // [sp+424h] [bp+414h]

  v7 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    v6 = 0;
    while ( 1 )
    {
      v5 = 0;
      ISL_get_voltage(gChain, 0, isl_dev_addr[i], &v5);
      if ( v5 <= 0x384u && v5 >= 0x320u )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v4, 0x400u, "asic%d read voltage again voltage %d, expect voltage %d retry %d\n", i, v5, a1, v6);
        applog(2, v4, 0);
      }
      usleep(0x30D40u);
      if ( ++v6 > 2 )
        goto LABEL_11;
    }
    ++v7;
LABEL_11:
    ;
  }
  if ( v7 == 3 )
    return 1;
  else
    return -1;
}
// 47B7C: using guessed type _BYTE isl_dev_addr[4];
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00022E60) --------------------------------------------------------
int start_single_board_test()
{
  bm1744_app_init();
  bm1744_hashboard_init();
  pcba_test();
  return bm1744_app_exit();
}

//----- (00022E78) --------------------------------------------------------
int hw_test_customized()
{
  int result; // r0
  char v1[1024]; // [sp+14h] [bp+4h] BYREF
  _BYTE v2[1124]; // [sp+414h] [bp+404h] BYREF
  int i; // [sp+878h] [bp+868h]
  int v4; // [sp+87Ch] [bp+86Ch]

  memset(v2, 0, sizeof(v2));
  memcpy(
    &v2[843],
    "040000005a0995c5fe39ee678b290a2636ec3c32e26bfafb5711ee687ad3750e00000000bbd08c45cf29d96c4f1e5b9d136f2f0ffc22d6be511e"
    "204773afee519a2478db00000000000000000000000000000000000000000000000000000000000000008dc7205ab0f0131c0000000000000000"
    "aaaaad5327c5d2a66bda09d1000000000000000000000000",
    0x118u);
  memcpy(
    v2,
    "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d3d3ff15"
    "02b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771eccb5c5e3d6beb4"
    "70359446494d25e15f87df87c3119ebd9ca813a400000000",
    0x118u);
  memcpy(
    &v2[562],
    "0400000065747d1d1299b3422670ee656f86aa07d5dfefc485c2d2206304e6030000000067669e8d830bc95a3a2b88582f06f835ecfcfe85c92a"
    "f15d001376fb544a3db40000000000000000000000000000000000000000000000000000000000000000ee060c5ba21f0f1c4809000000000000"
    "000000000000000000000400000000000000000000000000",
    0x118u);
  memcpy(
    &v2[281],
    "04000000a250abe4ab99767ec31b0eec43786781bf556a27b99436d831ff8e020000000002f24739336a89e32ee1081592a1d2ebbf1321c94847"
    "89cf04d3234ad531c3d80000000000000000000000000000000000000000000000000000000000000000abe6ea5add990f1cf408000000000000"
    "cda79db66d4176ca36d5ad06000000000000000000000000",
    0x118u);
  set_address();
  usleep(0x30D40u);
  read_register(0, 1, 0, 0);
  result = sleep(1u);
  v4 = 0;
  while ( v4 <= 300 )
  {
    for ( i = 0; i <= 3; ++i )
    {
      send_work(&v2[281 * i], 0, 0);
      result = sleep(0x1Eu);
      v4 += 30;
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v1, 0x400u, "seconds %d\n", v4);
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        strcpy(v1, "asic        1       2       3       4\n");
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v1,
          0x400u,
          "valid       %d      %d      %d      %d\n",
          nonce_num_each_asic[0],
          dword_47E00,
          dword_47E04,
          nonce_invalid_num_each_asic[0]);
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v1,
          0x400u,
          "invalid-1   %d      %d      %d      %d\n",
          nonce_invalid_num_each_asic_2[0],
          dword_47E1C,
          dword_47E24,
          one_work_nonce_each_asic[0]);
        result = applog(2, v1, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          v1,
          0x400u,
          "invalid-2   %d      %d      %d      %d\n",
          dword_47E18,
          dword_47E20,
          dword_47E28,
          dword_47E30);
        result = applog(2, v1, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v1, "test finished\n");
    return applog(2, v1, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 47DFC: using guessed type int nonce_num_each_asic[];
// 47E00: using guessed type int dword_47E00;
// 47E04: using guessed type int dword_47E04;
// 47E08: using guessed type int nonce_invalid_num_each_asic[3];
// 47E14: using guessed type int nonce_invalid_num_each_asic_2[];
// 47E18: using guessed type int dword_47E18;
// 47E1C: using guessed type int dword_47E1C;
// 47E20: using guessed type int dword_47E20;
// 47E24: using guessed type int dword_47E24;
// 47E28: using guessed type int dword_47E28;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E30: using guessed type int dword_47E30;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000231E0) --------------------------------------------------------
int pcba_app_manual_test()
{
  int result; // r0
  int v1; // r3
  _BYTE v2[280]; // [sp+8h] [bp+0h] BYREF
  char v3[280]; // [sp+120h] [bp+118h] BYREF
  char v4[1024]; // [sp+238h] [bp+230h] BYREF
  __int16 v5; // [sp+638h] [bp+630h] BYREF
  char v6; // [sp+63Ah] [bp+632h]
  __int16 v7; // [sp+63Ch] [bp+634h] BYREF
  char v8; // [sp+63Eh] [bp+636h]
  int v9; // [sp+640h] [bp+638h] BYREF
  int v10; // [sp+644h] [bp+63Ch] BYREF
  int v11; // [sp+648h] [bp+640h] BYREF
  uint16_t v12; // [sp+64Ch] [bp+644h] BYREF
  uint8_t v13; // [sp+64Fh] [bp+647h] BYREF
  unsigned __int16 v14; // [sp+650h] [bp+648h] BYREF
  unsigned __int8 v15; // [sp+653h] [bp+64Bh] BYREF
  int v16; // [sp+654h] [bp+64Ch] BYREF
  int v17; // [sp+658h] [bp+650h] BYREF
  unsigned int v18; // [sp+65Ch] [bp+654h] BYREF
  int v19; // [sp+660h] [bp+658h] BYREF
  int v20; // [sp+664h] [bp+65Ch] BYREF
  __int16 v21; // [sp+668h] [bp+660h] BYREF
  int v22; // [sp+66Ch] [bp+664h]
  uint8_t v23; // [sp+671h] [bp+669h]
  uint8_t v24; // [sp+672h] [bp+66Ah]
  unsigned __int8 v25; // [sp+673h] [bp+66Bh]
  int i; // [sp+674h] [bp+66Ch]
  int j; // [sp+678h] [bp+670h]
  int v28; // [sp+67Ch] [bp+674h]

  v28 = 1;
  result = bm1744_app_init();
  while ( v28 )
  {
    v21 = 0;
    sleep(1u);
    setbuf((FILE *)stdin, 0);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v4, "Input test paramter:");
      applog(2, v4, 0);
    }
    result = _isoc99_fscanf(stdin, "%s", &v21);
    switch ( (char)v21 )
    {
      case 'a':
        read_register(0, 1, 0, 0);
        asic_addr_interval();
        set_address();
        sleep(1u);
        result = read_register(0, 1, 0, 0);
        break;
      case 'b':
        v22 = 3;
        v7 = 21930;
        v8 = -18;
        result = write_data_to_PIC16F1704_flash(0, 0, (unsigned __int8 *)&v7, 3);
        break;
      case 'c':
        v5 = 0;
        v6 = 0;
        read_data_from_PIC16F1704_flash(0, 0, (unsigned __int8 *)&v5, 3u);
        for ( i = 0; i <= 2; ++i )
          printf("%02x\n", *((unsigned __int8 *)&v5 + i));
        result = putchar(10);
        break;
      case 'g':
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "get reg: input reg [regaddr]\n");
          applog(1, v4, 0);
        }
        result = _isoc99_scanf("%x", &v17);
        for ( j = 0; j <= 0; ++j )
          result = read_register(j, 1, 0, v17);
        break;
      case 'i':
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "did you init all the chips yet, 1/0\n");
          applog(2, v4, 0);
        }
        result = _isoc99_scanf("%d", &v9);
        if ( v9 == 1 )
        {
          result = hw_test_customized();
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            strcpy(v4, "Done!Done!Done!Done!");
            result = applog(2, v4, 0);
          }
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            strcpy(v4, "Done!Done!Done!Done!");
            result = applog(2, v4, 0);
          }
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            strcpy(v4, "Done!Done!Done!Done!");
            result = applog(2, v4, 0);
          }
        }
        break;
      case 'k':
        v11 = 0;
        v10 = 10;
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "Read Reg: Input [regAddr readTimes]\n");
          applog(1, v4, 0);
        }
        for ( result = _isoc99_scanf("%x %d", &v11, &v10); ; result = sleep(2u) )
        {
          v1 = v10--;
          if ( v1 <= 0 )
            break;
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(v4, 0x400u, "read chip number %d\n", v10);
            applog(2, v4, 0);
          }
          read_register(0, 1, 0, v11);
        }
        break;
      case 'm':
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "Input Frequenfy:\n");
          applog(1, v4, 0);
        }
        result = _isoc99_scanf("%d", &v16);
        if ( v16 > 99 && v16 <= 825 )
        {
          result = set_frequency(v16);
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "Frequency: [100, 825]\n");
          result = applog(1, v4, 0);
        }
        break;
      case 'q':
        v28 = 0;
        break;
      case 's':
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "write reg: input reg [address data]\n");
          applog(1, v4, 0);
        }
        _isoc99_scanf("%x %x", &v19, &v18);
        result = write_register(v19, v18);
        if ( v19 == 80 && v18 <= 0x1C )
          result = set_nonce_shift(v18);
        break;
      case 't':
        set_i2c_enable();
        usleep(0x30D40u);
        read_sensor(0, 0, 76, 1u, 0);
        result = read_sensor(0, 0, 76, 0, 0);
        break;
      case 'u':
        v24 = 0;
        v12 = 111;
        _isoc99_scanf("%d", &v13);
        v23 = v13;
        printf("i2c_devaddr=%d\n", v13);
        puts("Input i2c reg data");
        _isoc99_scanf("%d", &v12);
        result = printf("devaddr=%d\n", v13);
        if ( v12 <= 0x352u )
        {
          v13 = v23 + 80;
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf(v4, 0x400u, "write: chain%d dev_addr=%08x, reg_data=%d\n", v24, v13, v12);
            applog(2, v4, 0);
          }
          result = ISL_set_voltage(v24, 0, v13, v12);
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "Voltage: [750, 850]\n");
          result = applog(2, v4, 0);
        }
        break;
      case 'v':
        v25 = 0;
        v14 = 111;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "Input i2c dev addr\n");
          applog(2, v4, 0);
        }
        _isoc99_scanf("%x", &v15);
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v4, 0x400u, "read: chain%d dev_addr=%02x\n", v25, v15);
          applog(2, v4, 0);
        }
        result = ISL_get_voltage(v25, 0, v15, &v14);
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(v4, 0x400u, "read: reg_data = %d\n", v14);
          result = applog(2, v4, 0);
        }
        break;
      case 'w':
        memcpy(
          v2,
          "010203042cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3454151484151215484aa0ca1932037525e2eb9a22d3"
          "d3ff1502b320f8d9ca56377f56494b2cacf3377482ccd34188c1b25e04187ccf70af6e2244c3c96e5e2e3a6015d32fe451ad000e771ecc"
          "b5c5e3d6beb470359446494d25e15f87df87c3119ebd9ca813a400000000",
          sizeof(v2));
        memset(v3, 0, sizeof(v3));
        v20 = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          strcpy(v4, "input start nonce flag 1:enable 0:disable\n");
          applog(2, v4, 0);
        }
        _isoc99_scanf("%d", &v20);
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "input [work]\n");
          applog(1, v4, 0);
        }
        _isoc99_scanf("%s", v3);
        if ( strlen(v3) != 280 )
          memcpy(v3, v2, sizeof(v3));
        result = send_work((const unsigned __int8 *)v3, v20, 0);
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 0 )
        {
          strcpy(v4, "unknow command\n");
          result = applog(1, v4, 0);
        }
        break;
    }
  }
  return result;
}
// 10E54: using guessed type int _isoc99_fscanf(_DWORD, const char *, ...);
// 1107C: using guessed type int _isoc99_scanf(const char *, ...);
// 47C84: using guessed type int opt_log_level;
// 47DB0: using guessed type int stdin;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 231E0: using guessed type unsigned __int16 var_30;
// 231E0: using guessed type uint16_t var_34;

//----- (00023CA4) --------------------------------------------------------
int start_pcba_test()
{
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  char v3[64]; // [sp+404h] [bp+404h] BYREF
  int v4; // [sp+444h] [bp+444h]

  memset(v3, 0, sizeof(v3));
  if ( cgpu_init() < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "cgpu init failed\n");
      applog(2, v2, 0);
    }
    return -1;
  }
  display_arguments();
  while ( 1 )
  {
    memset(v3, 0, sizeof(v3));
    if ( strcmp(s1, "keyboard") )
      break;
    v4 = _isoc99_fscanf(stdin, "%s", v3);
LABEL_16:
    if ( v4 > 0 && v3[0] == 48 )
      singleBoardTest_V9_BM1744();
    usleep(0x186A0u);
  }
  if ( !strcmp(s1, "button") )
  {
    v4 = v9_key_read((unsigned __int8 *)v3, 64);
    goto LABEL_16;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy(v2, "please assign ctrl type: keyboard or button\n");
    applog(2, v2, 0);
  }
  cgpu_exit();
  return 0;
}
// 10E54: using guessed type int _isoc99_fscanf(_DWORD, const char *, ...);
// 47C84: using guessed type int opt_log_level;
// 47DB0: using guessed type int stdin;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00023E14) --------------------------------------------------------
void __cdecl write_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data)
{
  i2c_write(data | (which_i2c << 26) | 0xA00000 | (which_chain << 16));
}

//----- (00023E4C) --------------------------------------------------------
unsigned __int8 __cdecl read_pic(unsigned __int8 which_i2c, unsigned __int8 which_chain)
{
  return i2c_read((which_chain << 16) | (which_i2c << 26) | 0xA00000);
}

//----- (00023E80) --------------------------------------------------------
int __fastcall write_dc_dc(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5, int a6)
{
  int v6; // r4
  char v13[6]; // [sp+10h] [bp+8h] BYREF
  __int16 v14; // [sp+16h] [bp+Eh]
  int v15; // [sp+18h] [bp+10h]
  int v16; // [sp+1Ch] [bp+14h]
  _DWORD v17[4]; // [sp+20h] [bp+18h] BYREF
  __int16 v18; // [sp+30h] [bp+28h]
  unsigned __int8 v19; // [sp+33h] [bp+2Bh]
  int j; // [sp+34h] [bp+2Ch]
  int i; // [sp+38h] [bp+30h]
  unsigned __int8 k; // [sp+3Dh] [bp+35h]
  __int16 v23; // [sp+3Eh] [bp+36h]
  _BYTE v24[4]; // [sp+40h] [bp+38h] BYREF

  v18 = 255;
  v17[0] = 255;
  memset(&v17[1], 0, 12);
  v23 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v19 = a6 + 6;
  printf("%s dev addr = %02x\n", "write_dc_dc", a3);
  v13[0] = 85;
  v13[1] = -86;
  v13[2] = a6 + 6;
  v13[3] = 50;
  v13[4] = 2 * a3;
  v13[5] = a4;
  for ( i = 0; i < a6; ++i )
    v24[i - 42] = *(_BYTE *)(i + a5);
  for ( j = 2; a6 + 6 > j; ++j )
    v23 += (unsigned __int8)v13[j];
  LOBYTE(v18) = HIBYTE(v23);
  HIBYTE(v18) = v23;
  v24[a6 - 42] = HIBYTE(v23);
  v24[a6 - 41] = HIBYTE(v18);
  pthread_mutex_lock(&i2c_mutex);
  for ( k = 0; k < v19 + 2; ++k )
    write_pic(a2, a1, v24[k - 48]);
  usleep(0x186A0u);
  memset(v17, 0, sizeof(v17));
  for ( k = 0; k <= 4u; ++k )
  {
    v6 = k;
    *((_BYTE *)v17 + v6) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v17[0]) == 50 && BYTE2(v17[0]) == 1 )
    return 0;
  printf(
    "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n\n",
    "write_dc_dc",
    LOBYTE(v17[0]),
    BYTE1(v17[0]),
    BYTE2(v17[0]),
    HIBYTE(v17[0]));
  return -1;
}
// 483E8: using guessed type pthread_mutex_t i2c_mutex;

//----- (00024088) --------------------------------------------------------
int __fastcall read_dc_dc(unsigned __int8 a1, unsigned __int8 a2, char a3, char a4, int a5, int a6)
{
  int v6; // r4
  int v11; // [sp+14h] [bp+Ch] BYREF
  int v12; // [sp+18h] [bp+10h]
  char v13; // [sp+1Ch] [bp+14h]
  _DWORD v14[4]; // [sp+20h] [bp+18h] BYREF
  __int16 v15; // [sp+30h] [bp+28h]
  unsigned __int8 v16; // [sp+33h] [bp+2Bh]
  int k; // [sp+34h] [bp+2Ch]
  int i; // [sp+38h] [bp+30h]
  unsigned __int8 j; // [sp+3Dh] [bp+35h]
  __int16 v20; // [sp+3Eh] [bp+36h]
  _BYTE v21[4]; // [sp+40h] [bp+38h] BYREF

  v16 = 7;
  v15 = 255;
  v14[0] = 255;
  memset(&v14[1], 0, 12);
  v20 = 0;
  v11 = 839363157;
  v13 = 0;
  v12 = (unsigned __int8)(2 * a3) | 1;
  BYTE1(v12) = a4;
  BYTE2(v12) = a6;
  for ( i = 2; v16 > i; ++i )
    v20 += *((unsigned __int8 *)&v11 + i);
  LOBYTE(v15) = HIBYTE(v20);
  HIBYTE(v12) = HIBYTE(v20);
  HIBYTE(v15) = v20;
  v13 = v20;
  pthread_mutex_lock(&i2c_mutex);
  for ( j = 0; j < v16 + 2; ++j )
    write_pic(a2, a1, v21[j - 44]);
  usleep(0x186A0u);
  memset(v14, 0, sizeof(v14));
  for ( j = 0; j < a6 + 5; ++j )
  {
    v6 = j;
    *((_BYTE *)v14 + v6) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0xF4240u);
  if ( BYTE1(v14[0]) == 50 && BYTE2(v14[0]) == 1 )
  {
    for ( k = 0; k < a6; ++k )
      *(_BYTE *)(k + a5) = v21[k - 29];
    return 0;
  }
  else
  {
    printf(
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n",
      "read_dc_dc",
      LOBYTE(v14[0]),
      BYTE1(v14[0]),
      BYTE2(v14[0]),
      HIBYTE(v14[0]));
    return -1;
  }
}
// 483E8: using guessed type pthread_mutex_t i2c_mutex;

//----- (0002426C) --------------------------------------------------------
int __cdecl set_PIC16F1704_flash_pointer(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 flash_addr_h,
        unsigned __int8 flash_addr_l)
{
  __int16 v4; // r2
  int v5; // r4
  unsigned __int8 which_i2ca; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  int v12; // [sp+414h] [bp+40Ch]
  unsigned __int8 v13; // [sp+418h] [bp+410h]
  unsigned __int8 v14; // [sp+419h] [bp+411h]
  char v15; // [sp+41Ah] [bp+412h]
  char v16; // [sp+41Bh] [bp+413h]
  __int16 v17[2]; // [sp+41Ch] [bp+414h]
  char v18; // [sp+420h] [bp+418h]
  char v19; // [sp+421h] [bp+419h]
  __int16 v20; // [sp+424h] [bp+41Ch]
  char v21; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v23[4]; // [sp+428h] [bp+420h] BYREF

  which_i2ca = which_i2c;
  v21 = 6;
  v17[0] = 255;
  v12 = 17214037;
  v4 = flash_addr_h + 6;
  v20 = flash_addr_l + v4 + 1;
  v18 = HIBYTE(v20);
  v19 = flash_addr_l + v4 + 1;
  v13 = flash_addr_h;
  v14 = flash_addr_l;
  v15 = HIBYTE(v20);
  v16 = v19;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(which_i2ca, which_chain, v23[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v5 = i;
    *((_BYTE *)v17 + v5) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v17[0]) == 1 && HIBYTE(v17[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "set_PIC16F1704_flash_pointer");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "set_PIC16F1704_flash_pointer",
        LOBYTE(v17[0]),
        HIBYTE(v17[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000244A0) --------------------------------------------------------
int __cdecl send_data_to_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  int v9; // [sp+41Ch] [bp+414h]
  int v10; // [sp+420h] [bp+418h]
  int v11; // [sp+424h] [bp+41Ch]
  int v12; // [sp+428h] [bp+420h]
  int v13; // [sp+42Ch] [bp+424h]
  __int16 v14; // [sp+430h] [bp+428h]
  __int16 v15[2]; // [sp+434h] [bp+42Ch]
  __int16 v16; // [sp+438h] [bp+430h]
  char v17; // [sp+43Ch] [bp+434h]
  unsigned __int8 i; // [sp+43Dh] [bp+435h]
  __int16 v19; // [sp+43Eh] [bp+436h]
  _BYTE v20[4]; // [sp+440h] [bp+438h] BYREF

  which_i2ca = which_i2c;
  v17 = 20;
  v16 = 255;
  v15[0] = 255;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v19 = 22;
  for ( i = 0; i <= 0xFu; ++i )
    v19 += buf[i];
  LOBYTE(v16) = HIBYTE(v19);
  HIBYTE(v16) = v19;
  LOWORD(v9) = -21931;
  BYTE2(v9) = v17;
  HIBYTE(v9) = 2;
  for ( i = 0; i <= 0xFu; ++i )
    v20[i - 32] = buf[i];
  v14 = v16;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x15u; ++i )
    write_pic(which_i2ca, which_chain, v20[i - 36]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v15 + v3) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v15[0]) == 2 && HIBYTE(v15[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "send_data_to_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "send_data_to_PIC16F1704",
        LOBYTE(v15[0]),
        HIBYTE(v15[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002471C) --------------------------------------------------------
int __cdecl read_PIC16F1704_flash_pointer(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *flash_addr_h,
        unsigned __int8 *flash_addr_l)
{
  int v4; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  int v12; // [sp+428h] [bp+410h]
  char v13; // [sp+42Ch] [bp+414h]
  char v14; // [sp+42Dh] [bp+415h]
  int v15; // [sp+430h] [bp+418h]
  __int16 v16; // [sp+434h] [bp+41Ch]
  __int16 v17; // [sp+438h] [bp+420h]
  __int16 v18; // [sp+43Ch] [bp+424h]
  char v19; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE v21[4]; // [sp+440h] [bp+428h] BYREF

  which_i2ca = which_i2c;
  v19 = 4;
  v17 = 3072;
  v15 = 255;
  v16 = 0;
  v12 = 134523477;
  v18 = 12;
  v13 = 0;
  v14 = 12;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v21[i - 24]);
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v15 + v4) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v15) == 8 && (unsigned __int8)v15 == 6 )
  {
    v18 = HIBYTE(v15) + BYTE2(v15) + BYTE1(v15) + (unsigned __int8)v15;
    if ( HIBYTE(v18) == (unsigned __int8)v16 && (unsigned __int8)v18 == HIBYTE(v16) )
    {
      *flash_addr_h = BYTE2(v15);
      *flash_addr_l = HIBYTE(v15);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "--- %s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x\n\n",
          "read_PIC16F1704_flash_pointer",
          *flash_addr_h,
          *flash_addr_l);
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3]"
          " = 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
          "\n",
          "read_PIC16F1704_flash_pointer",
          (unsigned __int8)v15,
          BYTE1(v15),
          BYTE2(v15),
          HIBYTE(v15),
          (unsigned __int8)v16,
          HIBYTE(v16));
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] ="
        " 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
        "\n",
        "read_PIC16F1704_flash_pointer",
        (unsigned __int8)v15,
        BYTE1(v15),
        BYTE2(v15),
        HIBYTE(v15),
        (unsigned __int8)v16,
        HIBYTE(v16));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00024A40) --------------------------------------------------------
int __cdecl read_PIC16F1704_flash_data(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+94h] [bp+44h]
  unsigned __int8 tmp42[1024]; // [sp+9Ch] [bp+4Ch] BYREF
  int v10; // [sp+49Ch] [bp+44Ch]
  char v11; // [sp+4A0h] [bp+450h]
  char v12; // [sp+4A1h] [bp+451h]
  int v13; // [sp+4A4h] [bp+454h]
  int v14; // [sp+4A8h] [bp+458h]
  int v15; // [sp+4ACh] [bp+45Ch]
  int v16; // [sp+4B0h] [bp+460h]
  int v17; // [sp+4B4h] [bp+464h]
  __int16 v18; // [sp+4B8h] [bp+468h]
  unsigned __int16 v19; // [sp+4BCh] [bp+46Ch]
  char v20; // [sp+4BEh] [bp+46Eh]
  unsigned __int8 i; // [sp+4BFh] [bp+46Fh]
  _BYTE v22[4]; // [sp+4C0h] [bp+470h] BYREF

  which_i2ca = which_i2c;
  v20 = 4;
  v18 = 1792;
  v13 = 255;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v10 = 50637397;
  v19 = 7;
  v11 = 0;
  v12 = 7;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v22[i - 36]);
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 0x13u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t"
      "\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread"
      "_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x, \t\tread_bac"
      "k_data[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x, \t\tread_back_"
      "data[16] = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
      "read_PIC16F1704_flash_data",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15),
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16),
      (unsigned __int8)v17,
      BYTE1(v17),
      BYTE2(v17),
      HIBYTE(v17));
    applog(2, (const char *)tmp42, 0);
  }
  usleep(0x186A0u);
  if ( BYTE1(v13) == 3 && (unsigned __int8)v13 == 20 )
  {
    v19 = BYTE1(v17)
        + (unsigned __int8)v17
        + HIBYTE(v16)
        + BYTE2(v16)
        + BYTE1(v16)
        + (unsigned __int8)v16
        + HIBYTE(v15)
        + BYTE2(v15)
        + BYTE1(v15)
        + (unsigned __int8)v15
        + HIBYTE(v14)
        + BYTE2(v14)
        + BYTE1(v14)
        + (unsigned __int8)v14
        + HIBYTE(v13)
        + BYTE2(v13)
        + BYTE1(v13)
        + (unsigned __int8)v13;
    if ( HIBYTE(v19) == BYTE2(v17) && (unsigned __int8)v19 == HIBYTE(v17) )
    {
      for ( i = 0; i <= 0xFu; ++i )
        buf[i] = v22[i - 26];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "read_PIC16F1704_flash_data");
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "read_PIC16F1704_flash_data", v19);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", "read_PIC16F1704_flash_data");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00024ED0) --------------------------------------------------------
int __cdecl erase_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  int v2; // r4
  unsigned __int8 which_i2ca; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  __int16 v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  which_i2ca = which_i2c;
  v12 = 4;
  v11[2] = 2048;
  v11[0] = 255;
  v8 = 67414613;
  v11[4] = 8;
  v9 = 0;
  v10 = 8;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v11[0]) == 4 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "erase_PIC16F1704_flash");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "erase_PIC16F1704_flash",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000250D8) --------------------------------------------------------
int __cdecl write_data_into_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  int v2; // r4
  unsigned __int8 which_i2ca; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  __int16 v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  which_i2ca = which_i2c;
  v12 = 4;
  v11[2] = 2304;
  v11[0] = 255;
  v8 = 84191829;
  v11[4] = 9;
  v9 = 0;
  v10 = 9;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v14[i - 20]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v11[0]) == 5 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "write_data_into_PIC16F1704_flash");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "write_data_into_PIC16F1704_flash",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000252E0) --------------------------------------------------------
int __cdecl jump_from_loader_to_app_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  __int16 v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  v12 = 4;
  v11[2] = 2560;
  v11[0] = 255;
  v8 = 100969045;
  v11[4] = 10;
  v9 = 0;
  v10 = 10;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2c, which_chaina, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&unk_493E0);
  if ( LOBYTE(v11[0]) == 6 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "jump_from_loader_to_app_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "jump_from_loader_to_app_PIC16F1704",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000254E8) --------------------------------------------------------
int __fastcall reset_PIC16F1704_pic(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // r4
  char v7[1024]; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+414h] [bp+40Ch]
  char v9; // [sp+418h] [bp+410h]
  char v10; // [sp+419h] [bp+411h]
  __int16 v11[5]; // [sp+41Ch] [bp+414h]
  char v12; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v14[4]; // [sp+428h] [bp+420h] BYREF

  v12 = 4;
  v11[2] = 2816;
  v11[0] = 255;
  v8 = 117746261;
  v11[4] = 11;
  v9 = 0;
  v10 = 11;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, v14[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v11 + v2) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0xF4240u);
  if ( LOBYTE(v11[0]) == 7 && HIBYTE(v11[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v7, 0x400u, "--- %s ok\n\n", "reset_PIC16F1704_pic");
      applog(2, v7, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        v7,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "reset_PIC16F1704_pic",
        LOBYTE(v11[0]),
        HIBYTE(v11[0]));
      applog(2, v7, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000256F0) --------------------------------------------------------
int __cdecl set_PIC16F1704_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  __int16 v9; // [sp+414h] [bp+40Ch]
  char v10; // [sp+416h] [bp+40Eh]
  char v11; // [sp+417h] [bp+40Fh]
  unsigned __int8 v12; // [sp+418h] [bp+410h]
  char v13; // [sp+419h] [bp+411h]
  char v14; // [sp+41Ah] [bp+412h]
  __int16 v15[2]; // [sp+41Ch] [bp+414h]
  char v16; // [sp+420h] [bp+418h]
  char v17; // [sp+421h] [bp+419h]
  __int16 v18; // [sp+424h] [bp+41Ch]
  char v19; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v21[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  v19 = 5;
  v15[0] = 255;
  v9 = -21931;
  v11 = 16;
  v18 = voltage + 21;
  v16 = HIBYTE(v18);
  v17 = voltage + 21;
  v10 = 5;
  v12 = voltage;
  v13 = HIBYTE(v18);
  v14 = voltage + 21;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(which_i2c, which_chaina, v21[i - 20]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v15 + v3) = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v15[0]) == 16 && HIBYTE(v15[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "set_PIC16F1704_voltage");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "set_PIC16F1704_voltage",
        LOBYTE(v15[0]),
        HIBYTE(v15[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00025918) --------------------------------------------------------
int __cdecl write_hash_ID_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  int v9; // [sp+418h] [bp+410h]
  int v10; // [sp+41Ch] [bp+414h]
  int v11; // [sp+420h] [bp+418h]
  int v12; // [sp+424h] [bp+41Ch]
  __int16 v13; // [sp+428h] [bp+420h]
  __int16 v14[2]; // [sp+42Ch] [bp+424h]
  __int16 v15; // [sp+430h] [bp+428h]
  char v16; // [sp+434h] [bp+42Ch]
  unsigned __int8 i; // [sp+435h] [bp+42Dh]
  __int16 v18; // [sp+436h] [bp+42Eh]
  _BYTE v19[4]; // [sp+438h] [bp+430h] BYREF

  which_chaina = which_chain;
  v16 = 16;
  v15 = 255;
  v14[0] = 255;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v18 = 34;
  for ( i = 0; i <= 0xBu; ++i )
    v18 += buf[i];
  LOBYTE(v15) = HIBYTE(v18);
  HIBYTE(v15) = v18;
  LOWORD(v9) = -21931;
  BYTE2(v9) = v16;
  HIBYTE(v9) = 18;
  for ( i = 0; i <= 0xBu; ++i )
    v19[i - 28] = buf[i];
  v13 = v15;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0x11u; ++i )
    write_pic(which_i2c, which_chaina, v19[i - 32]);
  usleep((__useconds_t)&unk_61A80);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v14 + v3) = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v14[0]) == 18 && HIBYTE(v14[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "write_hash_ID_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "write_hash_ID_PIC16F1704",
        LOBYTE(v14[0]),
        HIBYTE(v14[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00025BA0) --------------------------------------------------------
int __cdecl read_hash_id_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+74h] [bp+34h]
  unsigned __int8 tmp42[1024]; // [sp+78h] [bp+38h] BYREF
  int v10; // [sp+478h] [bp+438h]
  char v11; // [sp+47Ch] [bp+43Ch]
  char v12; // [sp+47Dh] [bp+43Dh]
  int v13; // [sp+480h] [bp+440h]
  int v14; // [sp+484h] [bp+444h]
  int v15; // [sp+488h] [bp+448h]
  int v16; // [sp+48Ch] [bp+44Ch]
  __int16 v17; // [sp+490h] [bp+450h]
  unsigned __int16 v18; // [sp+494h] [bp+454h]
  char v19; // [sp+496h] [bp+456h]
  unsigned __int8 i; // [sp+497h] [bp+457h]
  _BYTE v21[4]; // [sp+498h] [bp+458h] BYREF

  which_i2ca = which_i2c;
  v19 = 4;
  v17 = 5888;
  v13 = 255;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v10 = 319072853;
  v18 = 23;
  v11 = 0;
  v12 = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v21[i - 32]);
  usleep(0x30D40u);
  for ( i = 0; i <= 0xFu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\t"
      "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_ba"
      "ck_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_da"
      "ta[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
      "read_hash_id_PIC16F1704",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15),
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16));
    applog(2, (const char *)tmp42, 0);
  }
  if ( BYTE1(v13) == 19 && (unsigned __int8)v13 == 16 )
  {
    v18 = BYTE1(v16)
        + (unsigned __int8)v16
        + HIBYTE(v15)
        + BYTE2(v15)
        + BYTE1(v15)
        + (unsigned __int8)v15
        + HIBYTE(v14)
        + BYTE2(v14)
        + BYTE1(v14)
        + (unsigned __int8)v14
        + HIBYTE(v13)
        + BYTE2(v13)
        + BYTE1(v13)
        + (unsigned __int8)v13;
    if ( HIBYTE(v18) == BYTE2(v16) && (unsigned __int8)v18 == HIBYTE(v16) )
    {
      for ( i = 0; i <= 0xBu; ++i )
        buf[i] = v21[i - 22];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "read_hash_id_PIC16F1704");
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "read_hash_id_PIC16F1704", v18);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", "read_hash_id_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00025FD0) --------------------------------------------------------
int __cdecl enable_PIC16F1704_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  __int16 v9; // [sp+414h] [bp+40Ch]
  char v10; // [sp+416h] [bp+40Eh]
  char v11; // [sp+417h] [bp+40Fh]
  unsigned __int8 v12; // [sp+418h] [bp+410h]
  char v13; // [sp+419h] [bp+411h]
  char v14; // [sp+41Ah] [bp+412h]
  __int16 v15[2]; // [sp+41Ch] [bp+414h]
  char v16; // [sp+420h] [bp+418h]
  char v17; // [sp+421h] [bp+419h]
  __int16 v18; // [sp+424h] [bp+41Ch]
  char v19; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v21[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  v19 = 5;
  v15[0] = 255;
  v9 = -21931;
  v11 = 21;
  v18 = enable + 26;
  v16 = HIBYTE(v18);
  v17 = enable + 26;
  v10 = 5;
  v12 = enable;
  v13 = HIBYTE(v18);
  v14 = enable + 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 6u; ++i )
    write_pic(which_i2c, which_chaina, v21[i - 20]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v15 + v3) = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( LOBYTE(v15[0]) == 21 && HIBYTE(v15[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "enable_PIC16F1704_dc_dc");
      applog(2, (const char *)tmp42, 0);
    }
    usleep((__useconds_t)&unk_7A120);
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "enable_PIC16F1704_dc_dc",
        LOBYTE(v15[0]),
        HIBYTE(v15[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000261F8) --------------------------------------------------------
int __cdecl heart_beat_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4
  unsigned __int8 which_chaina; // [sp+4h] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  int v8; // [sp+408h] [bp+408h]
  char v9; // [sp+40Ch] [bp+40Ch]
  char v10; // [sp+40Dh] [bp+40Dh]
  int v11; // [sp+410h] [bp+410h]
  __int16 v12; // [sp+414h] [bp+414h]
  __int16 v13; // [sp+418h] [bp+418h]
  __int16 v14; // [sp+41Ch] [bp+41Ch]
  char v15; // [sp+41Eh] [bp+41Eh]
  unsigned __int8 i; // [sp+41Fh] [bp+41Fh]
  _BYTE v17[4]; // [sp+420h] [bp+420h] BYREF

  which_chaina = which_chain;
  v15 = 4;
  v13 = 6656;
  v11 = 255;
  v12 = 0;
  v8 = 369404501;
  v14 = 26;
  v9 = 0;
  v10 = 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2c, which_chaina, v17[i - 24]);
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v2 = i;
    *((_BYTE *)&v11 + v2) = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( BYTE1(v11) == 22 && BYTE2(v11) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "heart_beat_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", "heart_beat_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000263EC) --------------------------------------------------------
void *__cdecl __noreturn pic_heart_beat_func(void *arg)
{
  unsigned __int8 v1; // [sp+Ah] [bp+Ah]
  unsigned __int8 v2; // [sp+Bh] [bp+Bh]

  v2 = *(_BYTE *)arg;
  v1 = *((_BYTE *)arg + 1);
  while ( 1 )
  {
    heart_beat_PIC16F1704(v2, v1);
    sleep(0xAu);
  }
}

//----- (00026418) --------------------------------------------------------
int __cdecl get_PIC16F1704_software_version(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *version)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  int v10; // [sp+428h] [bp+410h]
  char v11; // [sp+42Ch] [bp+414h]
  char v12; // [sp+42Dh] [bp+415h]
  int v13; // [sp+430h] [bp+418h]
  unsigned __int8 v14; // [sp+434h] [bp+41Ch]
  __int16 v15; // [sp+438h] [bp+420h]
  unsigned __int16 v16; // [sp+43Ch] [bp+424h]
  char v17; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  __int128 savedregs; // [sp+440h] [bp+428h] BYREF

  which_i2ca = which_i2c;
  v17 = 4;
  v15 = 6912;
  v13 = 255;
  v14 = 0;
  v10 = 386181717;
  v16 = 27;
  v11 = 0;
  v12 = 27;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, *((_BYTE *)&savedregs + i - 24));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x\n",
      "get_PIC16F1704_software_version",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      v14);
    applog(2, (const char *)tmp42, 0);
  }
  if ( BYTE1(v13) == 23 && (unsigned __int8)v13 == 5 )
  {
    v16 = BYTE2(v13) + BYTE1(v13) + (unsigned __int8)v13;
    if ( HIBYTE(v16) == HIBYTE(v13) && (unsigned __int8)v16 == v14 )
    {
      *version = BYTE2(v13);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok, version = 0x%02x\n\n", "get_PIC16F1704_software_version", *version);
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_software_version", v16);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", "get_PIC16F1704_software_version");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002674C) --------------------------------------------------------
int __cdecl PIC16F1704_i2c_forward_send(
        uint32_t i2c,
        uint8_t chain,
        uint8_t dev_addr,
        int rw_flag,
        uint8_t reg_addr,
        int len,
        uint8_t *data)
{
  unsigned __int8 i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  char v14[12]; // [sp+418h] [bp+410h] BYREF
  char v15[32]; // [sp+424h] [bp+41Ch] BYREF
  int k; // [sp+444h] [bp+43Ch]
  int i; // [sp+448h] [bp+440h]
  int j; // [sp+44Ch] [bp+444h]
  int v19; // [sp+450h] [bp+448h]
  unsigned __int16 v20; // [sp+456h] [bp+44Eh]
  _BYTE v21[4]; // [sp+458h] [bp+450h] BYREF

  i2ca = i2c;
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  v20 = 0;
  v19 = 0;
  j = 0;
  v15[0] = 85;
  v15[1] = -86;
  v15[2] = 0;
  v15[3] = 38;
  v15[4] = rw_flag | (2 * dev_addr);
  v15[5] = reg_addr;
  if ( rw_flag )
  {
    v19 = 5;
    v15[6] = len;
  }
  else
  {
    v19 = len + 4;
    memcpy(&v15[6], data, len);
  }
  v15[2] = v19 + 2;
  for ( i = 0; i < v19; ++i )
    v20 += (unsigned __int8)v21[i - 50];
  v21[v19 - 50] = HIBYTE(v20);
  v21[v19 - 49] = v20;
  pthread_mutex_lock(&i2c_mutex);
  for ( j = 0; v19 + 4 > j; ++j )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "write pic i2c[%d] %02x\n", j, (unsigned __int8)v15[j]);
      applog(2, (const char *)tmp42, 0);
    }
    write_pic(i2ca, chain, v15[j]);
  }
  usleep(0x30D40u);
  if ( rw_flag != 1 )
    goto LABEL_40;
  for ( j = 0; len + 5 > j; ++j )
  {
    v14[j] = read_pic(i2ca, chain);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "read pic i2c[%d] %02x\n", j, (unsigned __int8)v14[j]);
      applog(2, (const char *)tmp42, 0);
    }
  }
  for ( k = 0; len + 3 > k; ++k )
    v20 += (unsigned __int8)v14[k];
  if ( v20 == *(unsigned __int16 *)&v14[len + 3] )
  {
    if ( (unsigned __int8)v14[0] != v19 + 2 || v14[1] != 38 || v14[2] != 1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "pic read failed %d %d %d\n", *data, data[1], data[2]);
        applog(2, (const char *)tmp42, 0);
      }
      goto LABEL_30;
    }
    memcpy(data, &v14[3], len);
LABEL_40:
    pthread_mutex_unlock(&i2c_mutex);
    return 0;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "crc failed 0x%x\n", v20);
    applog(2, (const char *)tmp42, 0);
  }
LABEL_30:
  pthread_mutex_unlock(&i2c_mutex);
  return -1;
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00026B68) --------------------------------------------------------
void __cdecl set_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain, uint16_t vol)
{
  uint16_t v3; // [sp+10h] [bp+0h] BYREF
  char v4[5]; // [sp+13h] [bp+3h]
  unsigned int i; // [sp+1Ch] [bp+Ch]

  *(_DWORD *)&v4[1] = i2c;
  v4[0] = chain;
  v3 = vol;
  for ( i = 0; i <= 3; ++i )
  {
    PIC16F1704_i2c_forward_send(*(uint32_t *)&v4[1], v4[0], isl68127_i2c_dev_addr[i], 0, 0, 1, 0);
    PIC16F1704_i2c_forward_send(*(uint32_t *)&v4[1], v4[0], isl68127_i2c_dev_addr[i], 0, 0x21u, 2, (uint8_t *)&v3);
  }
}
// 35954: using guessed type _BYTE isl68127_i2c_dev_addr[4];
// 26B68: using guessed type uint16_t var_10;

//----- (00026BE0) --------------------------------------------------------
void __cdecl get_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain)
{
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+Ch] BYREF
  uint8_t v5[12]; // [sp+41Ch] [bp+40Ch] BYREF
  unsigned int i; // [sp+42Ch] [bp+41Ch]

  for ( i = 0; i <= 3; ++i )
  {
    memset(v5, 0, sizeof(v5));
    if ( PIC16F1704_i2c_forward_send(i2c, chain, isl68127_i2c_dev_addr[i], 1, 0x21u, 2, v5) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "read %02x vol failed, 0x%02x%02x\n",
          (unsigned __int8)isl68127_i2c_dev_addr[i],
          v5[0],
          v5[1]);
        applog(2, (const char *)tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "read %02x vol success, 0x%02x%02x\n",
        (unsigned __int8)isl68127_i2c_dev_addr[i],
        v5[0],
        v5[1]);
      applog(2, (const char *)tmp42, 0);
    }
  }
}
// 35954: using guessed type _BYTE isl68127_i2c_dev_addr[4];
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00026D38) --------------------------------------------------------
int __cdecl get_PIC16F1704_voltage(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *voltage)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  int v10; // [sp+428h] [bp+410h]
  char v11; // [sp+42Ch] [bp+414h]
  char v12; // [sp+42Dh] [bp+415h]
  int v13; // [sp+430h] [bp+418h]
  unsigned __int8 v14; // [sp+434h] [bp+41Ch]
  __int16 v15; // [sp+438h] [bp+420h]
  unsigned __int16 v16; // [sp+43Ch] [bp+424h]
  char v17; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  __int128 savedregs; // [sp+440h] [bp+428h] BYREF

  which_i2ca = which_i2c;
  v17 = 4;
  v15 = 7168;
  v13 = 255;
  v14 = 0;
  v10 = 402958933;
  v16 = 28;
  v11 = 0;
  v12 = 28;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, *((_BYTE *)&savedregs + i - 24));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x\n",
      "get_PIC16F1704_voltage",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      v14);
    applog(2, (const char *)tmp42, 0);
  }
  if ( BYTE1(v13) == 24 && (unsigned __int8)v13 == 5 )
  {
    v16 = BYTE2(v13) + BYTE1(v13) + (unsigned __int8)v13;
    if ( HIBYTE(v16) == HIBYTE(v13) && (unsigned __int8)v16 == v14 )
    {
      *voltage = BYTE2(v13);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok, voltage = 0x%02x\n\n", "get_PIC16F1704_voltage", *voltage);
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_voltage", v16);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", "get_PIC16F1704_voltage");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00027060) --------------------------------------------------------
int __cdecl write_temperature_offset_PIC16F1704(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  int v9; // [sp+41Ch] [bp+414h]
  int v10; // [sp+420h] [bp+418h]
  int v11; // [sp+424h] [bp+41Ch]
  __int16 v12; // [sp+428h] [bp+420h]
  __int16 v13[2]; // [sp+42Ch] [bp+424h]
  __int16 v14; // [sp+430h] [bp+428h]
  char v15; // [sp+434h] [bp+42Ch]
  unsigned __int8 i; // [sp+435h] [bp+42Dh]
  __int16 v17; // [sp+436h] [bp+42Eh]
  _BYTE v18[4]; // [sp+438h] [bp+430h] BYREF

  which_i2ca = which_i2c;
  v15 = 12;
  v14 = 255;
  v13[0] = 255;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v17 = 46;
  for ( i = 0; i <= 7u; ++i )
    v17 += buf[i];
  LOBYTE(v14) = HIBYTE(v17);
  HIBYTE(v14) = v17;
  LOWORD(v9) = -21931;
  BYTE2(v9) = v15;
  HIBYTE(v9) = 34;
  for ( i = 0; i <= 7u; ++i )
    v18[i - 24] = buf[i];
  v12 = v14;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 0xDu; ++i )
    write_pic(which_i2ca, which_chain, v18[i - 28]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    *((_BYTE *)v13 + v3) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v13[0]) == 34 && HIBYTE(v13[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "write_temperature_offset_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "write_temperature_offset_PIC16F1704",
        LOBYTE(v13[0]),
        HIBYTE(v13[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000272E4) --------------------------------------------------------
int __cdecl read_temperature_offset_PIC16F1704(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf)
{
  int v3; // r4
  unsigned __int8 which_i2ca; // [sp+54h] [bp+24h]
  unsigned __int8 tmp42[1024]; // [sp+5Ch] [bp+2Ch] BYREF
  int v10; // [sp+45Ch] [bp+42Ch]
  char v11; // [sp+460h] [bp+430h]
  char v12; // [sp+461h] [bp+431h]
  int v13; // [sp+464h] [bp+434h]
  int v14; // [sp+468h] [bp+438h]
  int v15; // [sp+46Ch] [bp+43Ch]
  __int16 v16; // [sp+470h] [bp+440h]
  unsigned __int16 v17; // [sp+474h] [bp+444h]
  char v18; // [sp+476h] [bp+446h]
  unsigned __int8 i; // [sp+477h] [bp+447h]
  _BYTE v20[4]; // [sp+478h] [bp+448h] BYREF

  which_i2ca = which_i2c;
  v18 = 4;
  v16 = 9984;
  v13 = 255;
  v14 = 0;
  v15 = 0;
  v10 = 587508309;
  v17 = 39;
  v11 = 0;
  v12 = 39;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2ca, which_chain, v20[i - 28]);
  usleep(0x30D40u);
  for ( i = 0; i <= 0xBu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t"
      "\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread"
      "_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
      "read_temperature_offset_PIC16F1704",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15));
    applog(2, (const char *)tmp42, 0);
  }
  if ( BYTE1(v13) == 35 && (unsigned __int8)v13 == 12 )
  {
    v17 = BYTE1(v15)
        + (unsigned __int8)v15
        + HIBYTE(v14)
        + BYTE2(v14)
        + BYTE1(v14)
        + (unsigned __int8)v14
        + HIBYTE(v13)
        + BYTE2(v13)
        + BYTE1(v13)
        + (unsigned __int8)v13;
    if ( HIBYTE(v17) == BYTE2(v15) && (unsigned __int8)v17 == HIBYTE(v15) )
    {
      for ( i = 0; i <= 7u; ++i )
        buf[i] = v20[i - 18];
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "read_temperature_offset_PIC16F1704");
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "read_temperature_offset_PIC16F1704", v17);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", "read_temperature_offset_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000276C8) --------------------------------------------------------
int __cdecl erase_PIC16F1704_app_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF
  int v6; // [sp+410h] [bp+408h]
  char v7; // [sp+414h] [bp+40Ch]
  char v8; // [sp+415h] [bp+40Dh]
  char v9; // [sp+416h] [bp+40Eh]
  char v10; // [sp+417h] [bp+40Fh]
  unsigned int v11; // [sp+418h] [bp+410h]
  unsigned int i; // [sp+41Ch] [bp+414h]

  i = 0;
  v10 = 6;
  v9 = 0;
  v8 = 15;
  v7 = 127;
  set_PIC16F1704_flash_pointer(which_i2c, which_chain, 6u, 0);
  v6 = 2432;
  v11 = 76;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash", v11);
    applog(2, (const char *)tmp42, 0);
  }
  for ( i = 0; i < v11; ++i )
    erase_PIC16F1704_flash(which_i2c, which_chain);
  return 1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000277D0) --------------------------------------------------------
int __cdecl PIC1704_update_pic_app_program(unsigned int which_i2c, unsigned __int8 which_chain)
{
  unsigned __int8 *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  unsigned __int8 tmp42[1024]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[16]; // [sp+408h] [bp+408h] BYREF
  unsigned __int8 data_read[5]; // [sp+418h] [bp+418h] BYREF
  unsigned __int8 program_data[5000]; // [sp+420h] [bp+420h] BYREF
  FILE *pic_program_file; // [sp+17A8h] [bp+17A8h]
  int ret; // [sp+17ACh] [bp+17ACh]
  unsigned int pic_flash_length; // [sp+17B0h] [bp+17B0h]
  unsigned __int8 end_addr_l; // [sp+17B4h] [bp+17B4h]
  unsigned __int8 end_addr_h; // [sp+17B5h] [bp+17B5h]
  unsigned __int8 start_addr_l; // [sp+17B6h] [bp+17B6h]
  unsigned __int8 start_addr_h; // [sp+17B7h] [bp+17B7h]
  unsigned int data_int; // [sp+17B8h] [bp+17B8h]
  unsigned int i; // [sp+17BCh] [bp+17BCh]

  memset(program_data, 0, sizeof(program_data));
  i = 0;
  memset(data_read, 0, sizeof(data_read));
  memset(buf, 0, sizeof(buf));
  data_int = 0;
  start_addr_h = 6;
  start_addr_l = 0;
  end_addr_h = 15;
  end_addr_l = 127;
  pic_flash_length = 0;
  ret = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    strcpy((char *)tmp42, "--- update pic program\n");
    applog(2, (const char *)tmp42, 0);
  }
  pic_program_file = fopen("/mnt/card/pic16f1704_app.txt", "r");
  if ( pic_program_file )
  {
    fseek(pic_program_file, 0, 0);
    memset(program_data, 0, sizeof(program_data));
    pic_flash_length = (end_addr_h << 8) + end_addr_l - (start_addr_l + (start_addr_h << 8)) + 1;
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "pic_flash_length = %d\n", pic_flash_length);
      applog(2, (const char *)tmp42, 0);
    }
    for ( i = 0; i < pic_flash_length; ++i )
    {
      fgets((char *)data_read, 1023, pic_program_file);
      data_int = strtoul((const char *)data_read, 0, 16);
      program_data[2 * i] = BYTE1(data_int);
      program_data[2 * i + 1] = data_int;
    }
    fclose(pic_program_file);
    ret = reset_PIC16F1704_pic(which_i2c, which_chain);
    if ( ret )
    {
      ret = erase_PIC16F1704_app_flash(which_i2c, which_chain);
      if ( ret )
      {
        ret = set_PIC16F1704_flash_pointer(which_i2c, which_chain, 6u, 0);
        if ( ret )
        {
          for ( i = 0; 4 * (pic_flash_length >> 5) > i; ++i )
          {
            v3 = &program_data[16 * i];
            v4 = *(_DWORD *)v3;
            v5 = *((_DWORD *)v3 + 1);
            v6 = *((_DWORD *)v3 + 2);
            v7 = *((_DWORD *)v3 + 3);
            *(_DWORD *)buf = v4;
            *(_DWORD *)&buf[4] = v5;
            *(_DWORD *)&buf[8] = v6;
            *(_DWORD *)&buf[12] = v7;
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf((char *)tmp42, 0x400u, "send pic program time: %d\n", i);
              applog(2, (const char *)tmp42, 0);
            }
            send_data_to_PIC16F1704(which_i2c, which_chain, buf);
            write_data_into_PIC16F1704_flash(which_i2c, which_chain);
          }
          ret = reset_PIC16F1704_pic(which_i2c, which_chain);
          if ( ret )
          {
            return 1;
          }
          else
          {
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf((char *)tmp42, 0x400u, "!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
              applog(2, (const char *)tmp42, 0);
            }
            return 0;
          }
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 1 )
          {
            snprintf((char *)tmp42, 0x400u, "!!! %s: set flash pointer error!\n\n", "PIC1704_update_pic_app_program");
            applog(2, (const char *)tmp42, 0);
          }
          return 0;
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf((char *)tmp42, 0x400u, "!!! %s: erase flash error!\n\n", "PIC1704_update_pic_app_program");
          applog(2, (const char *)tmp42, 0);
        }
        return 0;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "%s: open pic16f1704_app.txt failed\n", "PIC1704_update_pic_app_program");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00027DF8) --------------------------------------------------------
int __cdecl save_freq_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 freq)
{
  __int16 v3; // r2
  int v4; // r4
  unsigned __int8 which_chaina; // [sp+Ch] [bp+4h]
  unsigned __int8 tmp42[1024]; // [sp+14h] [bp+Ch] BYREF
  int v11; // [sp+414h] [bp+40Ch]
  char v12; // [sp+418h] [bp+410h]
  char v13; // [sp+419h] [bp+411h]
  char v14; // [sp+41Ah] [bp+412h]
  char v15; // [sp+41Bh] [bp+413h]
  __int16 v16[2]; // [sp+41Ch] [bp+414h]
  char v17; // [sp+420h] [bp+418h]
  char v18; // [sp+421h] [bp+419h]
  __int16 v19; // [sp+424h] [bp+41Ch]
  char v20; // [sp+426h] [bp+41Eh]
  unsigned __int8 i; // [sp+427h] [bp+41Fh]
  _BYTE v22[4]; // [sp+428h] [bp+420h] BYREF

  which_chaina = which_chain;
  v20 = 6;
  v16[0] = 255;
  v11 = 604416597;
  v3 = HIBYTE(freq) + 6;
  v19 = (unsigned __int8)freq + v3 + 36;
  v17 = HIBYTE(v19);
  v18 = freq + v3 + 36;
  v12 = HIBYTE(freq);
  v13 = freq;
  v14 = HIBYTE(v19);
  v15 = v18;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(which_i2c, which_chaina, v22[i - 20]);
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 1u; ++i )
  {
    v4 = i;
    *((_BYTE *)v16 + v4) = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( LOBYTE(v16[0]) == 36 && HIBYTE(v16[0]) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "save_freq_PIC16F1704");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
        "save_freq_PIC16F1704",
        LOBYTE(v16[0]),
        HIBYTE(v16[0]));
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002803C) --------------------------------------------------------
int __cdecl get_PIC16F1704_freq(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 *freq)
{
  int v3; // r4
  unsigned __int8 which_chaina; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+28h] [bp+10h] BYREF
  int v10; // [sp+428h] [bp+410h]
  char v11; // [sp+42Ch] [bp+414h]
  char v12; // [sp+42Dh] [bp+415h]
  int v13; // [sp+430h] [bp+418h]
  __int16 v14; // [sp+434h] [bp+41Ch]
  __int16 v15; // [sp+438h] [bp+420h]
  unsigned __int16 v16; // [sp+43Ch] [bp+424h]
  char v17; // [sp+43Eh] [bp+426h]
  unsigned __int8 i; // [sp+43Fh] [bp+427h]
  _BYTE v19[4]; // [sp+440h] [bp+428h] BYREF

  which_chaina = which_chain;
  v17 = 4;
  v15 = 10496;
  v13 = 255;
  v14 = 0;
  v10 = 621062741;
  v16 = 41;
  v11 = 0;
  v12 = 41;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 5u; ++i )
    write_pic(which_i2c, which_chaina, v19[i - 24]);
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 5u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v13 + v3) = read_pic(which_i2c, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
      "get_PIC16F1704_freq",
      (unsigned __int8)v13,
      BYTE1(v13),
      BYTE2(v13),
      HIBYTE(v13),
      (unsigned __int8)v14,
      HIBYTE(v14));
    applog(2, (const char *)tmp42, 0);
  }
  if ( BYTE1(v13) == 37 && (unsigned __int8)v13 == 6 )
  {
    v16 = HIBYTE(v13) + BYTE2(v13) + BYTE1(v13) + (unsigned __int8)v13;
    if ( HIBYTE(v16) == (unsigned __int8)v14 && (unsigned __int8)v16 == HIBYTE(v14) )
    {
      *freq = _byteswap_ushort(HIWORD(v13));
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq", *freq);
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_freq", v16);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s failed!\n\n", "get_PIC16F1704_freq");
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00028390) --------------------------------------------------------
void __cdecl set_temperature_offset_value(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *value)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+10h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", "set_temperature_offset_value");
    applog(2, (const char *)tmp42, 0);
  }
  write_temperature_offset_PIC16F1704(which_i2c, which_chain, value);
  usleep(0x186A0u);
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00028428) --------------------------------------------------------
int __cdecl write_PIC16F1705_iic_slave(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf,
        unsigned __int8 buf_len)
{
  int v4; // r4
  unsigned __int8 which_i2ca; // [sp+24h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+2Ch] [bp+14h] BYREF
  char v12[100]; // [sp+42Ch] [bp+414h] BYREF
  int v13; // [sp+490h] [bp+478h]
  unsigned __int8 v14; // [sp+494h] [bp+47Ch]
  __int16 v15; // [sp+498h] [bp+480h]
  unsigned __int8 v16; // [sp+49Ch] [bp+484h]
  unsigned __int8 i; // [sp+49Dh] [bp+485h]
  __int16 v18; // [sp+49Eh] [bp+486h]
  __int128 savedregs; // [sp+4A0h] [bp+488h] BYREF

  which_i2ca = which_i2c;
  v16 = buf_len + 4;
  v15 = 255;
  v13 = 255;
  v14 = 0;
  v18 = 0;
  memset(v12, 0, sizeof(v12));
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", "write_PIC16F1705_iic_slave");
    applog(2, (const char *)tmp42, 0);
  }
  v18 = v16 + 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    v18 += buf[i];
  LOBYTE(v15) = HIBYTE(v18);
  HIBYTE(v15) = v18;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "write_PIC16F1705_iic_slave",
      (unsigned __int8)v15,
      HIBYTE(v15));
    applog(2, (const char *)tmp42, 0);
  }
  v12[0] = 85;
  v12[1] = -86;
  v12[2] = v16;
  v12[3] = 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    *((_BYTE *)&savedregs + i - 112) = buf[i];
  *((_BYTE *)&savedregs + buf_len - 112) = v15;
  *((_BYTE *)&savedregs + buf_len - 111) = HIBYTE(v15);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v16 + 2; ++i )
    write_pic(which_i2ca, which_chain, *((_BYTE *)&savedregs + i - 116));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v13 + v4) = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( BYTE1(v13) == 38 && BYTE2(v13) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "write_PIC16F1705_iic_slave");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_dat"
        "a[3] = 0x%02x, read_back_data[4] = 0x%02x\n"
        "\n",
        "write_PIC16F1705_iic_slave",
        (unsigned __int8)v13,
        BYTE1(v13),
        BYTE2(v13),
        HIBYTE(v13),
        v14);
      applog(2, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000287BC) --------------------------------------------------------
int __cdecl read_PIC16F1705_iic_slave(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf,
        unsigned __int8 buf_len,
        unsigned __int8 *read_back_buf)
{
  int v5; // r4
  unsigned __int8 which_i2ca; // [sp+14h] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  char v13[100]; // [sp+418h] [bp+410h] BYREF
  char v14[100]; // [sp+47Ch] [bp+474h] BYREF
  __int16 v15; // [sp+4E0h] [bp+4D8h]
  unsigned __int8 v16; // [sp+4E4h] [bp+4DCh]
  unsigned __int8 i; // [sp+4E5h] [bp+4DDh]
  __int16 v18; // [sp+4E6h] [bp+4DEh]
  _BYTE v19[4]; // [sp+4E8h] [bp+4E0h] BYREF

  which_i2ca = which_i2c;
  v16 = buf_len + 4;
  v15 = 255;
  memset(v14, 0, sizeof(v14));
  v14[0] = -1;
  v18 = 0;
  memset(v13, 0, sizeof(v13));
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", "read_PIC16F1705_iic_slave");
    applog(2, (const char *)tmp42, 0);
  }
  v18 = v16 + 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    v18 += buf[i];
  LOBYTE(v15) = HIBYTE(v18);
  HIBYTE(v15) = v18;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "read_PIC16F1705_iic_slave",
      (unsigned __int8)v15,
      HIBYTE(v15));
    applog(2, (const char *)tmp42, 0);
  }
  v13[0] = 85;
  v13[1] = -86;
  v13[2] = v16;
  v13[3] = 38;
  for ( i = 0; i < (unsigned int)buf_len; ++i )
    v19[i - 204] = buf[i];
  v19[buf_len - 204] = v15;
  v19[buf_len - 203] = HIBYTE(v15);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v16 + 2; ++i )
    write_pic(which_i2ca, which_chain, v19[i - 208]);
  usleep(0x30D40u);
  for ( i = 0; i < buf[2] + 3; ++i )
  {
    v5 = i;
    v14[v5] = read_pic(which_i2ca, which_chain);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( v14[1] == 38 && v14[2] == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf((char *)tmp42, 0x400u, "--- %s ok\n\n", "read_PIC16F1705_iic_slave");
      applog(2, (const char *)tmp42, 0);
    }
    return 1;
  }
  else
  {
    for ( i = 0; i < buf[2] + 3; ++i )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "--- %s failed! read_back_data[%d] = 0x%02x\n\n",
          "read_PIC16F1705_iic_slave",
          i,
          (unsigned __int8)v19[i - 108]);
        applog(2, (const char *)tmp42, 0);
      }
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00028B74) --------------------------------------------------------
int __fastcall write_data_to_PIC16F1704_flash(
        unsigned __int8 a1,
        unsigned __int8 a2,
        unsigned __int8 *a3,
        signed int a4)
{
  int v4; // r4
  char v11[1024]; // [sp+24h] [bp+14h] BYREF
  int v12; // [sp+424h] [bp+414h]
  _DWORD v13[2]; // [sp+428h] [bp+418h] BYREF
  int v14; // [sp+430h] [bp+420h]
  char v15; // [sp+434h] [bp+424h]
  __int16 v16; // [sp+438h] [bp+428h]
  int v17; // [sp+43Ch] [bp+42Ch]
  char v18; // [sp+443h] [bp+433h]
  unsigned __int8 v19; // [sp+444h] [bp+434h]
  unsigned __int8 i; // [sp+445h] [bp+435h]
  __int16 v21; // [sp+446h] [bp+436h]
  _BYTE v22[4]; // [sp+448h] [bp+438h] BYREF

  v19 = 6;
  v16 = 255;
  v14 = 255;
  v15 = 0;
  v21 = 0;
  v12 = 0;
  v13[0] = 0;
  v13[1] = 0;
  v18 = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(v11, 0x400u, "\n--- %s\n", "write_data_to_PIC16F1704_flash");
    applog(4, v11, 0);
  }
  v21 = a4 + a4 + v19 + 51;
  for ( i = 0; i < a4; ++i )
    v21 += a3[i];
  LOBYTE(v16) = HIBYTE(v21);
  HIBYTE(v16) = v21;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      v11,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "write_data_to_PIC16F1704_flash",
      (unsigned __int8)v16,
      HIBYTE(v16));
    applog(2, v11, 0);
  }
  LOWORD(v12) = -21931;
  BYTE2(v12) = v19 + a4;
  HIBYTE(v12) = 51;
  LOBYTE(v13[0]) = 0;
  BYTE1(v13[0]) = a4;
  memcpy((char *)v13 + 2, a3, a4);
  v22[a4 - 30] = v16;
  v22[a4 - 29] = HIBYTE(v16);
  for ( i = 0; i < a4 + 8; ++i )
    printf("%02x ", (unsigned __int8)v22[i - 36]);
  putchar(10);
  v17 = a4 + v19 + 2;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i < v17; ++i )
    write_pic(a2, a1, v22[i - 36]);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v14 + v4) = read_pic(a2, a1);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
    printf("%02x ", (unsigned __int8)v22[i - 24]);
  putchar(10);
  if ( (unsigned __int8)v14 == 5 && BYTE1(v14) == 51 && BYTE2(v14) == 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v11, 0x400u, "\n--- %s ok\n\n", "write_data_to_PIC16F1704_flash");
      applog(2, v11, 0);
    }
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(
        v11,
        0x400u,
        "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        "write_data_to_PIC16F1704_flash",
        (unsigned __int8)v14,
        BYTE1(v14),
        BYTE2(v14));
      applog(0, v11, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843E: using guessed type char opt_debug;
// 4843F: using guessed type char opt_log_output;

//----- (00028F90) --------------------------------------------------------
int __cdecl read_data_from_PIC16F1704_flash(
        int which_chain,
        int which_i2c,
        unsigned __int8 *buf,
        unsigned __int8 read_len)
{
  int v4; // r4
  unsigned __int8 which_i2ca; // [sp+18h] [bp+8h]
  unsigned __int8 which_chaina; // [sp+1Ch] [bp+Ch]
  unsigned __int8 tmp42[1024]; // [sp+20h] [bp+10h] BYREF
  int v12; // [sp+420h] [bp+410h]
  int v13; // [sp+424h] [bp+414h]
  char v14[40]; // [sp+428h] [bp+418h] BYREF
  __int16 v15; // [sp+450h] [bp+440h]
  unsigned __int8 v16; // [sp+454h] [bp+444h]
  unsigned __int8 i; // [sp+455h] [bp+445h]
  unsigned __int16 v18; // [sp+456h] [bp+446h]
  _BYTE v19[4]; // [sp+458h] [bp+448h] BYREF

  which_chaina = which_chain;
  which_i2ca = which_i2c;
  v16 = 6;
  v15 = 255;
  memset(v14, 0, sizeof(v14));
  v14[0] = -1;
  v18 = 0;
  v12 = 0;
  v13 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "\n--- %s\n", "read_data_from_PIC16F1704_flash");
    applog(2, (const char *)tmp42, 0);
  }
  v18 = read_len + v16 + 52;
  LOBYTE(v15) = HIBYTE(v18);
  HIBYTE(v15) = read_len + v16 + 52;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(
      (char *)tmp42,
      0x400u,
      "--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n",
      "read_data_from_PIC16F1704_flash",
      (unsigned __int8)v15,
      HIBYTE(v15));
    applog(2, (const char *)tmp42, 0);
  }
  LOWORD(v12) = -21931;
  BYTE2(v12) = v16;
  HIBYTE(v12) = 52;
  LOBYTE(v13) = 0;
  BYTE1(v13) = read_len;
  HIWORD(v13) = v15;
  for ( i = 0; i <= 7u; ++i )
    printf("%02x ", (unsigned __int8)v19[i - 56]);
  putchar(10);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 0; i <= 7u; ++i )
    write_pic(which_i2ca, which_chaina, v19[i - 56]);
  usleep(0x30D40u);
  for ( i = 0; i < read_len + 5; ++i )
  {
    v4 = i;
    v14[v4] = read_pic(which_i2ca, which_chaina);
  }
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  for ( i = 0; i < read_len + 5; ++i )
    printf("%02x ", (unsigned __int8)v19[i - 48]);
  putchar(10);
  if ( v14[1] == 52 && (unsigned __int8)v14[0] == read_len + 5 && v14[2] == 1 )
  {
    v18 = 0;
    for ( i = 0; i < read_len + 3; ++i )
      v18 += (unsigned __int8)v19[i - 48];
    if ( HIBYTE(v18) == (unsigned __int8)v19[read_len - 45]
      && (unsigned __int8)v18 == (unsigned __int8)v19[read_len - 44] )
    {
      memcpy(buf, &v14[3], read_len);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "\n--- %s ok\n\n", "read_data_from_PIC16F1704_flash");
        applog(2, (const char *)tmp42, 0);
      }
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level >= 0 )
      {
        snprintf((char *)tmp42, 0x400u, "\n--- %s failed! crc = 0x%04x\n\n", "read_data_from_PIC16F1704_flash", v18);
        applog(0, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level >= 0 )
    {
      snprintf(
        (char *)tmp42,
        0x400u,
        "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
        "read_data_from_PIC16F1704_flash",
        (unsigned __int8)v14[0],
        (unsigned __int8)v14[1],
        (unsigned __int8)v14[2]);
      applog(0, (const char *)tmp42, 0);
    }
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00029408) --------------------------------------------------------
unsigned int get_fan_speed()
{
  return read_axi_fpga(1u);
}

//----- (00029418) --------------------------------------------------------
void __fastcall set_fan_speed(unsigned int a1)
{
  write_axi_fpga(0x21u, a1);
}

//----- (00029430) --------------------------------------------------------
void __cdecl fan_control(unsigned __int8 level)
{
  switch ( level )
  {
    case 0u:
      set_fan_speed(0x64u);
      break;
    case 1u:
      set_fan_speed(0xA005Au);
      break;
    case 2u:
      set_fan_speed(0x140050u);
      break;
    case 3u:
      set_fan_speed(0x1E0046u);
      break;
    case 4u:
      set_fan_speed(0x28003Cu);
      break;
    case 5u:
      set_fan_speed(0x320032u);
      break;
    case 6u:
      set_fan_speed(0x3C0028u);
      break;
    case 7u:
      set_fan_speed(0x46001Eu);
      break;
    case 8u:
      set_fan_speed(0x500014u);
      break;
    case 9u:
      set_fan_speed(0x5A000Au);
      break;
    default:
      set_fan_speed(0x640000u);
      break;
  }
}

//----- (000294F4) --------------------------------------------------------
int __fastcall uart_open(const char *a1, _DWORD *a2)
{
  char v3[1024]; // [sp+14h] [bp+Ch] BYREF
  _DWORD *v4; // [sp+414h] [bp+40Ch]

  v4 = a2;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v3, 0x400u, "%s name=%s baudrate=%d\n", "uart_open", a1, *v4);
    applog(2, v3, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002957C) --------------------------------------------------------
int __cdecl uart_exit(int fd)
{
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s fd=%d\n", "uart_close", fd);
    applog(2, (const char *)tmp42, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (000295F0) --------------------------------------------------------
unsigned int __cdecl check_how_many_uart_data_in_fpga(unsigned __int8 which_uart)
{
  unsigned int v1; // r3
  unsigned __int8 tmp42[1024]; // [sp+10h] [bp+8h] BYREF

  switch ( which_uart )
  {
    case 0u:
      v1 = (read_axi_fpga(0x440u) >> 16) & 0x3FF;
      break;
    case 1u:
      v1 = read_axi_fpga(0x440u) & 0x3FF;
      break;
    case 2u:
      v1 = (read_axi_fpga(0x441u) >> 16) & 0x3FF;
      break;
    case 3u:
      v1 = read_axi_fpga(0x441u) & 0x3FF;
      break;
    case 4u:
      v1 = (read_axi_fpga(0x442u) >> 16) & 0x3FF;
      break;
    case 5u:
      v1 = read_axi_fpga(0x442u) & 0x3FF;
      break;
    case 6u:
      v1 = (read_axi_fpga(0x443u) >> 16) & 0x3FF;
      break;
    case 7u:
      v1 = read_axi_fpga(0x443u) & 0x3FF;
      break;
    case 8u:
      v1 = (read_axi_fpga(0x444u) >> 16) & 0x3FF;
      break;
    case 9u:
      v1 = read_axi_fpga(0x444u) & 0x3FF;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: The uart%d is not supported!!!\n",
          "check_how_many_uart_data_in_fpga",
          which_uart);
        applog(2, (const char *)tmp42, 0);
      }
      v1 = 0;
      break;
  }
  return v1;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00029744) --------------------------------------------------------
unsigned int __cdecl read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
{
  unsigned int v3; // r3
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+14h] BYREF
  unsigned int axi_fpga; // [sp+41Ch] [bp+414h]
  unsigned int v10; // [sp+420h] [bp+418h]
  unsigned int v11; // [sp+424h] [bp+41Ch]
  unsigned int v12; // [sp+428h] [bp+420h]
  unsigned int i; // [sp+42Ch] [bp+424h]
  unsigned int v14; // [sp+430h] [bp+428h]
  unsigned int v15; // [sp+434h] [bp+42Ch]

  v15 = 0;
  v14 = 0;
  v11 = 0;
  v10 = 0;
  i = 0;
  axi_fpga = 0;
  v12 = 0;
  switch ( which_uart )
  {
    case 0u:
      v15 = 1100;
      v14 = 1101;
      goto LABEL_17;
    case 1u:
      v15 = 1102;
      v14 = 1103;
      goto LABEL_17;
    case 2u:
      v15 = 1104;
      v14 = 1105;
      goto LABEL_17;
    case 3u:
      v15 = 1106;
      v14 = 1107;
      goto LABEL_17;
    case 4u:
      v15 = 1108;
      v14 = 1109;
      goto LABEL_17;
    case 5u:
      v15 = 1110;
      v14 = 1111;
      goto LABEL_17;
    case 6u:
      v15 = 1112;
      v14 = 1113;
      goto LABEL_17;
    case 7u:
      v15 = 1114;
      v14 = 1115;
      goto LABEL_17;
    case 8u:
      v15 = 1116;
      v14 = 1117;
      goto LABEL_17;
    case 9u:
      v15 = 1118;
      v14 = 1119;
LABEL_17:
      v11 = length & 0x3FF | 0x80000000;
      write_axi_fpga(v15, v11);
      v10 = length >> 2;
      for ( i = 0; i < v10; ++i )
      {
        axi_fpga = read_axi_fpga(v14);
        buf[4 * i] = HIBYTE(axi_fpga);
        buf[4 * i + 1] = BYTE2(axi_fpga);
        buf[4 * i + 2] = BYTE1(axi_fpga);
        buf[4 * i + 3] = axi_fpga;
      }
      v12 = 4 * v10;
      v10 = length & 3;
      if ( (length & 3) != 0 )
      {
        axi_fpga = read_axi_fpga(v14);
        switch ( v10 )
        {
          case 2u:
            buf[4 * i] = HIBYTE(axi_fpga);
            buf[4 * i + 1] = BYTE2(axi_fpga);
            v12 += 2;
            break;
          case 3u:
            buf[4 * i] = HIBYTE(axi_fpga);
            buf[4 * i + 1] = BYTE2(axi_fpga);
            buf[4 * i + 2] = BYTE1(axi_fpga);
            v12 += 3;
            break;
          case 1u:
            buf[4 * i] = HIBYTE(axi_fpga);
            ++v12;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(
                (char *)tmp42,
                0x400u,
                "%s: the uart%d left data is 4*N length, error!!!\n",
                "read_uart_data_in_fpga",
                which_uart);
              applog(2, (const char *)tmp42, 0);
            }
            break;
        }
      }
      v3 = v12;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "%s: The uart%d is not supported!!!\n", "read_uart_data_in_fpga", which_uart);
        applog(2, (const char *)tmp42, 0);
      }
      v3 = 0;
      break;
  }
  return v3;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00029AEC) --------------------------------------------------------
unsigned int __cdecl uart_send(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
{
  unsigned int axi_fpga; // r0
  unsigned __int8 tmp42[1024]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 send_buf[512]; // [sp+418h] [bp+410h] BYREF
  unsigned int v11; // [sp+618h] [bp+610h]
  unsigned int v12; // [sp+61Ch] [bp+614h]
  int v13; // [sp+620h] [bp+618h]
  int v14; // [sp+624h] [bp+61Ch]
  unsigned int v15; // [sp+628h] [bp+620h]
  unsigned int v16; // [sp+62Ch] [bp+624h]
  unsigned int v17; // [sp+630h] [bp+628h]
  int v18; // [sp+634h] [bp+62Ch]
  int i; // [sp+638h] [bp+630h]
  int v20; // [sp+63Ch] [bp+634h]

  v20 = 0;
  v13 = 0;
  i = 0;
  memset(send_buf, 0, sizeof(send_buf));
  v12 = length;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v11 = 0;
  v14 = 0;
  pthread_mutex_lock(&uart_send_mutex[which_uart]);
  switch ( which_uart )
  {
    case 0u:
      v14 = 24;
      v17 = 1024;
      v16 = 1028;
      v15 = 1029;
      goto LABEL_17;
    case 1u:
      v14 = 16;
      v17 = 1024;
      v16 = 1030;
      v15 = 1031;
      goto LABEL_17;
    case 2u:
      v14 = 8;
      v17 = 1024;
      v16 = 1032;
      v15 = 1033;
      goto LABEL_17;
    case 3u:
      v14 = 0;
      v17 = 1024;
      v16 = 1034;
      v15 = 1035;
      goto LABEL_17;
    case 4u:
      v14 = 24;
      v17 = 1025;
      v16 = 1036;
      v15 = 1037;
      goto LABEL_17;
    case 5u:
      v14 = 16;
      v17 = 1025;
      v16 = 1038;
      v15 = 1039;
      goto LABEL_17;
    case 6u:
      v14 = 8;
      v17 = 1025;
      v16 = 1040;
      v15 = 1041;
      goto LABEL_17;
    case 7u:
      v14 = 0;
      v17 = 1025;
      v16 = 1042;
      v15 = 1043;
      goto LABEL_17;
    case 8u:
      v14 = 24;
      v17 = 1026;
      v16 = 1044;
      v15 = 1045;
      goto LABEL_17;
    case 9u:
      v14 = 16;
      v17 = 1026;
      v16 = 1046;
      v15 = 1047;
LABEL_17:
      v20 = 0;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "%s: The uart%d is not supported!!!\n", "uart_send", which_uart);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
  }
  while ( 1 )
  {
    axi_fpga = read_axi_fpga(v17);
    v11 = (unsigned __int8)(axi_fpga >> v14);
    if ( v11 >= length )
      break;
    usleep(0xBB8u);
    if ( ++v20 > 20 )
    {
      pthread_mutex_unlock(&uart_send_mutex[which_uart]);
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: uart%d always dose not has enough send fifo space, break\n",
          "uart_send",
          which_uart);
        applog(2, (const char *)tmp42, 0);
      }
      return 0;
    }
  }
  v20 = 0;
  while ( 1 )
  {
    if ( (read_axi_fpga(v16) & 0x80000000) == 0 )
    {
      memcpy(send_buf, buf, length);
      v13 = v12 >> 2;
      for ( i = 0; i < v13; ++i )
      {
        v18 = (send_buf[4 * i + 2] << 8) | (send_buf[4 * i] << 24) | (send_buf[4 * i + 1] << 16) | send_buf[4 * i + 3];
        write_axi_fpga(v15, v18);
      }
      v13 = v12 & 3;
      if ( (v12 & 3) != 0 )
      {
        switch ( v13 )
        {
          case 2:
            v18 = (send_buf[4 * i + 1] << 16) | (send_buf[4 * i] << 24);
            break;
          case 3:
            v18 = (send_buf[4 * i + 2] << 8) | (send_buf[4 * i] << 24) | (send_buf[4 * i + 1] << 16);
            break;
          case 1:
            v18 = send_buf[4 * i] << 24;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 1 )
            {
              snprintf(
                (char *)tmp42,
                0x400u,
                "%s: the uart%d send left data is 4*N length, error!!!\n",
                "uart_send",
                which_uart);
              applog(2, (const char *)tmp42, 0);
            }
            break;
        }
        write_axi_fpga(v15, v18);
      }
      write_axi_fpga(v16, v12 | 0x80000000);
      pthread_mutex_unlock(&uart_send_mutex[which_uart]);
      return v12;
    }
    if ( v20 > 20 )
      break;
    ++v20;
    usleep(0xBB8u);
  }
  pthread_mutex_unlock(&uart_send_mutex[which_uart]);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "%s: uart%d always busy, break\n", "uart_send", which_uart);
    applog(2, (const char *)tmp42, 0);
  }
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 48400: using guessed type pthread_mutex_t uart_send_mutex[1];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002A08C) --------------------------------------------------------
unsigned int __cdecl uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length)
{
  unsigned int v7; // [sp+10h] [bp+10h]
  unsigned int uart_data_in_fpga; // [sp+14h] [bp+14h]

  pthread_mutex_lock(&uart_receive_mutex[which_uart]);
  v7 = check_how_many_uart_data_in_fpga(which_uart);
  if ( v7 < buf_length )
  {
    if ( v7 )
      uart_data_in_fpga = read_uart_data_in_fpga(which_uart, buf, v7);
    else
      uart_data_in_fpga = 0;
  }
  else
  {
    uart_data_in_fpga = read_uart_data_in_fpga(which_uart, buf, buf_length);
  }
  pthread_mutex_unlock(&uart_receive_mutex[which_uart]);
  return uart_data_in_fpga;
}
// 48418: using guessed type pthread_mutex_t uart_receive_mutex[1];

//----- (0002A11C) --------------------------------------------------------
int __fastcall clear_uart_send_fifo(unsigned __int8 a1)
{
  unsigned int axi_fpga; // r0
  char v5[1024]; // [sp+10h] [bp+8h] BYREF
  int v6; // [sp+410h] [bp+408h]
  int v7; // [sp+414h] [bp+40Ch]
  int v8; // [sp+418h] [bp+410h]
  unsigned int v9; // [sp+41Ch] [bp+414h]
  int v10; // [sp+420h] [bp+418h]
  unsigned int v11; // [sp+424h] [bp+41Ch]

  v11 = 0;
  v8 = 0;
  v7 = 0;
  v10 = 0;
  v9 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v5, 0x400u, "--- %s\n", "clear_uart_send_fifo");
    applog(2, v5, 0);
  }
  pthread_mutex_lock(&uart_send_mutex[a1]);
  switch ( a1 )
  {
    case 0u:
      v10 = 24;
      v11 = 1024;
      v8 = 1028;
      v6 = 1029;
      goto LABEL_21;
    case 1u:
      v10 = 16;
      v11 = 1024;
      v8 = 1030;
      v6 = 1031;
      goto LABEL_21;
    case 2u:
      v10 = 8;
      v11 = 1024;
      v8 = 1032;
      v6 = 1033;
      goto LABEL_21;
    case 3u:
      v10 = 0;
      v11 = 1024;
      v8 = 1034;
      v6 = 1035;
      goto LABEL_21;
    case 4u:
      v10 = 24;
      v11 = 1025;
      v8 = 1036;
      v6 = 1037;
      goto LABEL_21;
    case 5u:
      v10 = 16;
      v11 = 1025;
      v8 = 1038;
      v6 = 1039;
      goto LABEL_21;
    case 6u:
      v10 = 8;
      v11 = 1025;
      v8 = 1040;
      v6 = 1041;
      goto LABEL_21;
    case 7u:
      v10 = 0;
      v11 = 1025;
      v8 = 1042;
      v6 = 1043;
      goto LABEL_21;
    case 8u:
      v10 = 24;
      v11 = 1026;
      v8 = 1044;
      v6 = 1045;
      goto LABEL_21;
    case 9u:
      v10 = 16;
      v11 = 1026;
      v8 = 1046;
      v6 = 1047;
LABEL_21:
      v9 = 0;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf(v5, 0x400u, "%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo", a1);
        applog(2, v5, 0);
      }
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 1;
  }
  do
  {
    axi_fpga = read_axi_fpga(v11);
    v7 = (unsigned __int8)(axi_fpga >> v10);
    if ( v7 == 255 )
    {
      pthread_mutex_unlock(&uart_send_mutex[a1]);
      return 0;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v5, 0x400u, "%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_send_fifo", a1);
      applog(2, v5, 0);
    }
    usleep(0xBB8u);
    ++v9;
  }
  while ( v9 <= 0x14 );
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v5, 0x400u, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_send_fifo", a1);
    applog(2, v5, 0);
  }
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v7;
}
// 47C84: using guessed type int opt_log_level;
// 48400: using guessed type pthread_mutex_t uart_send_mutex[1];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002A4E8) --------------------------------------------------------
unsigned int __cdecl clear_uart_rx_fifo(unsigned __int8 which_chain)
{
  unsigned __int8 tmp42[1024]; // [sp+1Ch] [bp+Ch] BYREF
  void *ptr; // [sp+41Ch] [bp+40Ch]
  size_t size; // [sp+420h] [bp+410h]
  unsigned int uart_data_in_fpga; // [sp+424h] [bp+414h]

  uart_data_in_fpga = 0;
  size = 0;
  ptr = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf((char *)tmp42, 0x400u, "--- %s\n", "clear_uart_rx_fifo");
    applog(2, (const char *)tmp42, 0);
  }
  pthread_mutex_lock(&uart_receive_mutex[which_chain]);
  size = check_how_many_uart_data_in_fpga(which_chain);
  if ( size )
  {
    ptr = malloc(size);
    if ( ptr )
    {
      uart_data_in_fpga = read_uart_data_in_fpga(which_chain, (unsigned __int8 *)ptr, size);
      if ( uart_data_in_fpga != size && (use_syslog || opt_log_output || opt_log_level > 1) )
      {
        snprintf(
          (char *)tmp42,
          0x400u,
          "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
          "clear_uart_rx_fifo",
          which_chain,
          size,
          uart_data_in_fpga);
        applog(2, (const char *)tmp42, 0);
      }
      free(ptr);
      ptr = 0;
      usleep(0x2710u);
      pthread_mutex_unlock(&uart_receive_mutex[which_chain]);
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 1 )
      {
        snprintf((char *)tmp42, 0x400u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", which_chain);
        applog(2, (const char *)tmp42, 0);
      }
      ptr = 0;
      usleep((__useconds_t)&unk_7A120);
      pthread_mutex_unlock(&uart_receive_mutex[which_chain]);
      return 1;
    }
  }
  else
  {
    pthread_mutex_unlock(&uart_receive_mutex[which_chain]);
    return 0;
  }
}
// 47C84: using guessed type int opt_log_level;
// 48418: using guessed type pthread_mutex_t uart_receive_mutex[1];
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (0002A74C) --------------------------------------------------------
int cgpu_init()
{
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  int v3; // [sp+404h] [bp+404h]

  v3 = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v2, 0x400u, "--- %s\n", "cgpu_init");
    applog(2, v2, 0);
  }
  memset(&cgpu, 0, 0x5Cu);
  v3 = open_lcd();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "!!! %s: open lcd driver error\n", "cgpu_init");
      applog(2, v2, 0);
    }
    goto LABEL_31;
  }
  memset(lcd_output, 32, 0x40u);
  write(dword_F34A0, lcd_output, 0x40u);
  v3 = open_key();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "!!! %s: open start key error\n", "cgpu_init");
      applog(2, v2, 0);
    }
    goto LABEL_30;
  }
  v3 = open_red_led();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "!!! %s: open red led error\n", "cgpu_init");
      applog(2, v2, 0);
    }
    goto LABEL_29;
  }
  v3 = open_green_led();
  if ( v3 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "!!! %s: open green led error\n", "cgpu_init");
      applog(2, v2, 0);
    }
    goto LABEL_28;
  }
  v3 = bitmain_axi_init();
  if ( v3 < 0 )
  {
    bitmain_axi_close();
LABEL_28:
    close_green_led();
LABEL_29:
    close_red_led();
LABEL_30:
    close_key();
LABEL_31:
    close_lcd();
    return -1;
  }
  patten_info_init();
  patten_load();
  return 0;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34A0: using guessed type int dword_F34A0;

//----- (0002A9C0) --------------------------------------------------------
void cgpu_exit()
{
  bitmain_axi_close();
  close_green_led();
  close_red_led();
  close_key();
  close_lcd();
  patten_info_destory();
}

//----- (0002A9E0) --------------------------------------------------------
int __cdecl v9_key_read(unsigned __int8 *command, int len)
{
  lseek(dword_F34A8, 0, 0);
  return read(dword_F34A8, command, len);
}
// F34A8: using guessed type int dword_F34A8;

//----- (0002AA1C) --------------------------------------------------------
ssize_t display_arguments()
{
  size_t v0; // r0
  char v2[64]; // [sp+4h] [bp+4h] BYREF
  int v3; // [sp+44h] [bp+44h] BYREF
  char v4[400]; // [sp+48h] [bp+48h] BYREF
  int v5; // [sp+1D8h] [bp+1D8h]
  int v6; // [sp+1E0h] [bp+1E0h]
  int v7; // [sp+1E4h] [bp+1E4h]

  get_app_config(&v3);
  memset(v2, 0, sizeof(v2));
  lseek(dword_F34A0, 0, 0);
  memset(v2, 32, sizeof(v2));
  v0 = strlen(v4);
  memcpy(v2, v4, v0);
  sprintf(&v2[16], "IC:%2d", v5);
  sprintf(&v2[32], "FREQ: %d", v6);
  sprintf(&v2[48], "Voltage: %d", v7);
  return write(dword_F34A0, v2, 0x40u);
}
// F34A0: using guessed type int dword_F34A0;

//----- (0002AAE4) --------------------------------------------------------
int check_chain()
{
  char v2[1024]; // [sp+8h] [bp+0h] BYREF
  unsigned int axi_fpga; // [sp+408h] [bp+400h]
  unsigned __int8 i; // [sp+40Fh] [bp+407h]

  i = -1;
  axi_fpga = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v2, 0x400u, "--- %s\n", "check_chain");
    applog(2, v2, 0);
  }
  dword_F34C8 = 0;
  axi_fpga = read_axi_fpga(2u);
  if ( axi_fpga == 1 || axi_fpga == 2 || axi_fpga == 4 || axi_fpga == 8 )
  {
    for ( i = 0; !i; ++i )
    {
      chain_info[0] = 0;
      chain_info[1] = 0;
      if ( (axi_fpga & 1) != 0 )
      {
        *((_DWORD *)&cgpu + i + 21) = 1;
        ++dword_F34C8;
        gChain_exist[i] = 1;
        *((_BYTE *)&gChain_fd + i) = i;
        gChain = i;
        gI2c = 0;
        chain_info[2 * i] = i;
        chain_info[2 * i + 1] = gI2c;
        g_chain[8 * i] = *((unsigned __int8 *)&gChain_fd + i);
        LOBYTE(g_chain[8 * i + 1]) = i;
        if ( use_syslog || opt_log_output || opt_log_level > 1 )
        {
          snprintf(
            v2,
            0x400u,
            "%s: gChain = %d, gI2c = %d\n",
            "check_chain",
            (unsigned __int8)gChain,
            (unsigned __int8)gI2c);
          applog(2, v2, 0);
        }
      }
      else
      {
        *((_DWORD *)&cgpu + i + 21) = 0;
      }
    }
    return 0;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "%s: Test zhiju only support 1 plug, but now is 0x%08x\n", "check_chain", axi_fpga);
      applog(2, v2, 0);
    }
    return -1;
  }
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 48430: using guessed type _BYTE gChain_exist[4];
// 48435: using guessed type char gI2c;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 4845C: using guessed type int g_chain[8];
// F34C8: using guessed type int dword_F34C8;
// F34D8: using guessed type _BYTE chain_info[4];

//----- (0002AD98) --------------------------------------------------------
void V9_print_lcd()
{
  char v0[20]; // [sp+Ch] [bp+4h] BYREF

  if ( set_address_test_result <= 0 )
    write_lcd_no_memset(0, "Address NG      ", 0x10u);
  else
    write_lcd_no_memset(0, "Address OK      ", 0x10u);
  memset(v0, 0, 17);
  sprintf(
    v0,
    "Pattern %c %c %c   ",
    (unsigned __int8)nonce_test_asic_result[0],
    (unsigned __int8)byte_483E5,
    (unsigned __int8)byte_483E6);
  write_lcd_no_memset(1u, (unsigned __int8 *)v0, 0x10u);
  if ( read_temp_test_result <= 0 )
    write_lcd_no_memset(2u, "Sensor NG       ", 0x10u);
  else
    write_lcd_no_memset(2u, "Sensor OK       ", 0x10u);
  if ( tempture_value_test_result <= 0 )
    write_lcd_no_memset(3u, "Temperature NG  ", 0x10u);
  else
    write_lcd_no_memset(3u, "Temperature OK  ", 0x10u);
}
// 483D4: using guessed type int set_address_test_result;
// 483D8: using guessed type int read_temp_test_result;
// 483DC: using guessed type int tempture_value_test_result;
// 483E5: using guessed type char byte_483E5;
// 483E6: using guessed type char byte_483E6;

//----- (0002AE84) --------------------------------------------------------
void __fastcall V9_print_lcd_type(int a1)
{
  if ( a1 == 1 )
  {
    write_lcd_no_memset(0, " hardware error ", 0x10u);
    write_lcd_no_memset(1u, "     check      ", 0x10u);
    write_lcd_no_memset(2u, " u2 u44 u16 u23 ", 0x10u);
    write_lcd_no_memset(3u, " u30            ", 0x10u);
  }
  else
  {
    V9_print_lcd();
  }
}

//----- (0002AEE0) --------------------------------------------------------
int __fastcall is_asic_pass(int a1)
{
  return nonce_num_each_asic[a1];
}
// 47DFC: using guessed type int nonce_num_each_asic[];

//----- (0002AF04) --------------------------------------------------------
int show_stats_func_z11_3chips()
{
  int v1; // [sp+8h] [bp+0h] BYREF
  int v2; // [sp+Ch] [bp+4h]
  int v3; // [sp+10h] [bp+8h]
  int v4; // [sp+14h] [bp+Ch]
  size_t v5; // [sp+18h] [bp+10h]
  int v6; // [sp+1Ch] [bp+14h]

  v6 = 0;
  while ( show_id_alive )
  {
    usleep(0xF4240u);
    memset(lcd_output, 32, 0x40u);
    sprintf(lcd_output, "time %ds", v6);
    v1 = 0;
    v2 = 0;
    v3 = 0;
    v4 = 0;
    sprintf(
      (char *)&v1,
      "nonce=%d %d %d",
      *(_DWORD *)dword_F37BC,
      *(_DWORD *)(dword_F37BC + 4),
      *(_DWORD *)(dword_F37BC + 8));
    v5 = strlen((const char *)&v1);
    memset((char *)&v1 + v5, 32, 16 - v5);
    *(_DWORD *)dword_47B4C = v1;
    dword_47B50 = v2;
    dword_47B54 = v3;
    dword_47B58 = v4;
    sprintf(
      s,
      "%d-%d'C %d-%d'C",
      (unsigned __int8)byte_48F51,
      (unsigned __int8)sensor_info,
      (unsigned __int8)byte_48F55,
      (unsigned __int8)byte_48F54);
    ++v6;
    write(dword_F34A0, lcd_output, 0x40u);
  }
  return 0;
}
// 47B50: using guessed type int dword_47B50;
// 47B54: using guessed type int dword_47B54;
// 47B58: using guessed type int dword_47B58;
// 48438: using guessed type int show_id_alive;
// 48F50: using guessed type char sensor_info;
// 48F51: using guessed type char byte_48F51;
// 48F54: using guessed type char byte_48F54;
// 48F55: using guessed type char byte_48F55;
// F34A0: using guessed type int dword_F34A0;
// F37BC: using guessed type int dword_F37BC;

//----- (0002B044) --------------------------------------------------------
int show_stats_func_z9_4chips()
{
  int v1; // [sp+Ch] [bp+4h]

  v1 = 0;
  while ( show_id_alive )
  {
    usleep(0xF4240u);
    memset(lcd_output, 32, 0x40u);
    sprintf(lcd_output, "time %ds", v1);
    sprintf(dword_47B4C, "nonce=%d %d", one_work_nonce_each_asic, dword_47E30);
    sprintf(byte_47B5C, "      %d %d", dword_47E34, one_work_invalid_nonce_each_asic);
    sprintf(
      s,
      "%d-%d'C %d-%d'C",
      (unsigned __int8)byte_48F51,
      (unsigned __int8)sensor_info,
      (unsigned __int8)byte_48F55,
      (unsigned __int8)byte_48F54);
    ++v1;
    write(dword_F34A0, lcd_output, 0x40u);
  }
  return 0;
}
// 47E2C: using guessed type int one_work_nonce_each_asic;
// 47E30: using guessed type int dword_47E30;
// 47E34: using guessed type int dword_47E34;
// 47E38: using guessed type int one_work_invalid_nonce_each_asic;
// 48438: using guessed type int show_id_alive;
// 48F50: using guessed type char sensor_info;
// 48F51: using guessed type char byte_48F51;
// 48F54: using guessed type char byte_48F54;
// 48F55: using guessed type char byte_48F55;
// F34A0: using guessed type int dword_F34A0;

//----- (0002B150) --------------------------------------------------------
int show_stats_func_z9_16chips()
{
  _BOOL4 v0; // r8
  _BOOL4 v1; // r9
  _BOOL4 v2; // r4
  _BOOL4 v3; // r5
  _BOOL4 v4; // r6
  bool v5; // r3
  _BOOL4 v6; // r8
  _BOOL4 v7; // r9
  _BOOL4 v8; // r4
  _BOOL4 v9; // r5
  _BOOL4 v10; // r6
  bool v11; // r3
  _BOOL4 v13; // [sp+18h] [bp+0h]
  _BOOL4 v14; // [sp+18h] [bp+0h]
  _BOOL4 v15; // [sp+1Ch] [bp+4h]
  _BOOL4 v16; // [sp+1Ch] [bp+4h]
  int v17; // [sp+24h] [bp+Ch]

  v17 = 0;
  while ( show_id_alive )
  {
    usleep(0xF4240u);
    memset(lcd_output, 32, 0x40u);
    sprintf(lcd_output, "time %ds", v17);
    v0 = is_asic_pass(0) != 0;
    v1 = is_asic_pass(1) != 0;
    v2 = is_asic_pass(2) != 0;
    v3 = is_asic_pass(3) != 0;
    v4 = is_asic_pass(4) != 0;
    v15 = is_asic_pass(5) != 0;
    v13 = is_asic_pass(6) != 0;
    v5 = is_asic_pass(7) != 0;
    sprintf(dword_47B4C, "nonce=%d%d%d%d %d%d%d%d", v0, v1, v2, v3, v4, v15, v13, v5);
    v6 = is_asic_pass(8) != 0;
    v7 = is_asic_pass(9) != 0;
    v8 = is_asic_pass(10) != 0;
    v9 = is_asic_pass(11) != 0;
    v10 = is_asic_pass(12) != 0;
    v16 = is_asic_pass(13) != 0;
    v14 = is_asic_pass(14) != 0;
    v11 = is_asic_pass(15) != 0;
    sprintf(byte_47B5C, "      %d%d%d%d %d%d%d%d", v6, v7, v8, v9, v10, v16, v14, v11);
    sprintf(
      s,
      "%d-%d'C %d-%d'C",
      (unsigned __int8)byte_48F51,
      (unsigned __int8)sensor_info[0],
      (unsigned __int8)byte_48F55,
      (unsigned __int8)byte_48F54);
    ++v17;
    write(dword_F34A0, lcd_output, 0x40u);
  }
  return 0;
}
// 48438: using guessed type int show_id_alive;
// 48F51: using guessed type char byte_48F51;
// 48F54: using guessed type char byte_48F54;
// 48F55: using guessed type char byte_48F55;
// F34A0: using guessed type int dword_F34A0;

//----- (0002B39C) --------------------------------------------------------
int singleBoardTest_V9_BM1744_manual()
{
  char v2[1024]; // [sp+Ch] [bp+4h] BYREF
  int v3; // [sp+40Ch] [bp+404h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v2, 0x400u, "%s[%d]\n", "singleBoardTest_V9_BM1744_manual", 345);
    applog(2, v2, 0);
  }
  get_app_config(&v3);
  memset(sensor_info, 0, 8u);
  memset(nonce_num_each_asic, 0, 0xCu);
  init_fpga();
  set_fpga_baud(0x1Au);
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "--- Chain Check Fail\n");
      applog(2, v2, 0);
    }
    return -1;
  }
  else
  {
    reset_PIC16F1704_pic(gChain, gI2c);
    jump_from_loader_to_app_PIC16F1704((unsigned __int8)gChain, gI2c);
    pthread_create(&newthread, 0, (void *(*)(void *))pic_heart_beat_func, &chain_info[2 * (unsigned __int8)gChain]);
    write_axi_fpga(0xDu, 0xFFFFu);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc((unsigned __int8)gChain, gI2c, 1u);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(0xDu, 0);
    usleep((__useconds_t)&unk_493E0);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      snprintf(v2, 0x400u, "%s[%d]\n", "singleBoardTest_V9_BM1744_manual", 375);
      applog(2, v2, 0);
    }
    pcba_app_manual_test();
    write_axi_fpga(0xDu, 0xFFFFu);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(0xDu, 0);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc((unsigned __int8)gChain, gI2c, 0);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(newthread);
    pthread_join(newthread, 0);
    pthread_mutex_unlock(&i2c_mutex);
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "Test finished\n");
      applog(2, v2, 0);
    }
    return 1;
  }
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47DFC: using guessed type int nonce_num_each_asic[];
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 48435: using guessed type char gI2c;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34D8: using guessed type _BYTE chain_info[4];

//----- (0002B688) --------------------------------------------------------
int singleBoardTest_V9_BM1744()
{
  char v2[1024]; // [sp+4h] [bp+4h] BYREF
  int v3; // [sp+404h] [bp+404h]

  v3 = 0;
  memset(&sensor_info, 0, 8u);
  memset(one_work_nonce_each_asic, 0, 0xCu);
  memset(one_work_invalid_nonce_each_asic_2, 0, sizeof(one_work_invalid_nonce_each_asic_2));
  show_id_alive = 1;
  pthread_create(&dword_F3484, 0, (void *(*)(void *))show_stats_func_z11_3chips, 0);
  init_fpga();
  set_fpga_baud(0x1Au);
  check_chain();
  if ( (unsigned __int8)gChain == 255 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "--- Chain Check Fail\n");
      applog(2, v2, 0);
    }
    return -1;
  }
  else
  {
    reset_PIC16F1704_pic(gChain, gI2c);
    jump_from_loader_to_app_PIC16F1704((unsigned __int8)gChain, gI2c);
    pthread_create(&newthread, 0, (void *(*)(void *))pic_heart_beat_func, &chain_info[2 * (unsigned __int8)gChain]);
    write_axi_fpga(0xDu, 0xFFFFu);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc((unsigned __int8)gChain, gI2c, 1u);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(0xDu, 0);
    if ( isl_communication_check(dword_F367C) <= 0 )
    {
      v3 = 1;
    }
    else
    {
      if ( dword_F3680 == 1 )
        vol_init(dword_F367C);
      usleep((__useconds_t)&unk_493E0);
      start_single_board_test();
      v3 = 0;
    }
    show_id_alive = 0;
    sleep(1u);
    pthread_cancel(dword_F3484);
    pthread_join(dword_F3484, 0);
    V9_print_lcd_type(v3);
    write_axi_fpga(0xDu, 0xFFFFu);
    usleep((__useconds_t)&unk_493E0);
    write_axi_fpga(0xDu, 0);
    usleep((__useconds_t)&unk_493E0);
    enable_PIC16F1704_dc_dc((unsigned __int8)gChain, gI2c, 0);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(newthread);
    pthread_join(newthread, 0);
    pthread_mutex_unlock(&i2c_mutex);
    clear_last_test_results();
    if ( use_syslog || opt_log_output || opt_log_level > 1 )
    {
      strcpy(v2, "Test finished\n");
      applog(2, v2, 0);
    }
    return 1;
  }
}
// 47B80: using guessed type char gChain;
// 47C84: using guessed type int opt_log_level;
// 47E2C: using guessed type int one_work_nonce_each_asic[];
// 47E44: using guessed type _DWORD one_work_invalid_nonce_each_asic_2[6];
// 483E8: using guessed type pthread_mutex_t i2c_mutex;
// 48435: using guessed type char gI2c;
// 48438: using guessed type int show_id_alive;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// 48F50: using guessed type char sensor_info;
// F34D8: using guessed type _BYTE chain_info[4];
// F367C: using guessed type int dword_F367C;
// F3680: using guessed type int dword_F3680;

//----- (0002B984) --------------------------------------------------------
void *__fastcall get_app_config(void *a1)
{
  return memcpy(a1, &app_conf, 0x26Cu);
}
// F34DC: using guessed type int app_conf;

//----- (0002B9A8) --------------------------------------------------------
int __fastcall app_config_handle(const char *a1)
{
  int result; // r0
  char v3[1024]; // [sp+Ch] [bp+Ch] BYREF
  char v4[1024]; // [sp+40Ch] [bp+40Ch] BYREF
  FILE *stream; // [sp+80Ch] [bp+80Ch]
  char *v6; // [sp+810h] [bp+810h]
  int *v7; // [sp+814h] [bp+814h]

  v7 = &app_conf;
  memset(v4, 0, sizeof(v4));
  v6 = 0;
  stream = fopen(a1, "r");
  if ( !stream && (use_syslog || opt_log_output || opt_log_level > 1) )
  {
    snprintf(v3, 0x400u, "open %s failed\n", a1);
    applog(2, v3, 0);
  }
  while ( fgets(v4, 1023, stream) )
  {
    if ( v4[0] != 35 && v4[1] != 35 )
    {
      v6 = strstr(v4, "Name=");
      if ( v6 )
      {
        v6 += 5;
        _isoc99_sscanf(v6, "%s", v7 + 1);
      }
      else
      {
        v6 = strstr(v4, "type=");
        if ( v6 )
        {
          v6 += 5;
          _isoc99_sscanf(v6, "%s", v7 + 6);
        }
        else
        {
          v6 = strstr(v4, "comport=");
          if ( v6 )
          {
            v6 += 8;
            _isoc99_sscanf(v6, "%d", v7 + 5);
          }
          else
          {
            v6 = strstr(v4, "baudrate=");
            if ( v6 )
            {
              v6 += 9;
              _isoc99_sscanf(v6, "%d", v7 + 10);
            }
            else
            {
              v6 = strstr(v4, "miner_mode=");
              if ( v6 )
              {
                v6 += 11;
                _isoc99_sscanf(v6, "%d", v7 + 11);
              }
              else
              {
                v6 = strstr(v4, "reg_ticket_mask=");
                if ( v6 )
                {
                  v6 += 16;
                  _isoc99_sscanf(v6, "%d", v7 + 90);
                }
                else
                {
                  v6 = strstr(v4, "reg_core_timeout=");
                  if ( v6 )
                  {
                    v6 += 17;
                    _isoc99_sscanf(v6, "%x", v7 + 91);
                  }
                  else
                  {
                    v6 = strstr(v4, "reg_misc=");
                    if ( v6 )
                    {
                      v6 += 9;
                      _isoc99_sscanf(v6, "%x", v7 + 92);
                    }
                    else
                    {
                      v6 = strstr(v4, "workstr=");
                      if ( v6 )
                      {
                        v6 += 8;
                        _isoc99_sscanf(v6, "%s", v7 + 20);
                      }
                      else
                      {
                        v6 = strstr(v4, "single_pattern_send_timeout=");
                        if ( v6 )
                        {
                          v6 += 28;
                          _isoc99_sscanf(v6, "%d", v7 + 93);
                        }
                        else
                        {
                          v6 = strstr(v4, "single_chip_return_nonce=");
                          if ( v6 )
                          {
                            v6 += 25;
                            _isoc99_sscanf(v6, "%d", v7 + 94);
                          }
                          else
                          {
                            v6 = strstr(v4, "single_chip_hw=");
                            if ( v6 )
                            {
                              v6 += 15;
                              _isoc99_sscanf(v6, "%d", v7 + 95);
                            }
                            else
                            {
                              v6 = strstr(v4, "TunelPath=");
                              if ( v6 )
                              {
                                v6 += 10;
                                _isoc99_sscanf(v6, "%s", v7 + 109);
                              }
                              else
                              {
                                v6 = strstr(v4, "CP210xRuntime=");
                                if ( v6 )
                                {
                                  v6 += 14;
                                  _isoc99_sscanf(v6, "%s", v7 + 125);
                                }
                                else
                                {
                                  v6 = strstr(v4, "pattern_number=");
                                  if ( v6 )
                                  {
                                    v6 += 15;
                                    _isoc99_sscanf(v6, "%d", v7 + 96);
                                  }
                                  else
                                  {
                                    v6 = strstr(v4, "repeat_ctrl=");
                                    if ( v6 )
                                    {
                                      v6 += 12;
                                      _isoc99_sscanf(v6, "%s", v7 + 97);
                                    }
                                    else
                                    {
                                      v6 = strstr(v4, "AsicNum=");
                                      if ( v6 )
                                      {
                                        v6 += 8;
                                        _isoc99_sscanf(v6, "%d", v7 + 101);
                                      }
                                      else
                                      {
                                        v6 = strstr(v4, "CoreNum=");
                                        if ( v6 )
                                        {
                                          v6 += 8;
                                          _isoc99_sscanf(v6, "%d", v7 + 102);
                                        }
                                        else
                                        {
                                          v6 = strstr(v4, "Freq=");
                                          if ( v6 )
                                          {
                                            v6 += 5;
                                            _isoc99_sscanf(v6, "%d", v7 + 103);
                                          }
                                          else
                                          {
                                            v6 = strstr(v4, "Voltage=");
                                            if ( v6 )
                                            {
                                              v6 += 8;
                                              _isoc99_sscanf(v6, "%d", v7 + 104);
                                            }
                                            else
                                            {
                                              v6 = strstr(v4, "slt_method=");
                                              if ( v6 )
                                              {
                                                v6 += 11;
                                                _isoc99_sscanf(v6, "%d", v7 + 141);
                                              }
                                              else
                                              {
                                                v6 = strstr(v4, "bin1_freq=");
                                                if ( v6 )
                                                {
                                                  v6 += 10;
                                                  _isoc99_sscanf(v6, "%d", v7 + 142);
                                                }
                                                else
                                                {
                                                  v6 = strstr(v4, "bin2_freq=");
                                                  if ( v6 )
                                                  {
                                                    v6 += 10;
                                                    _isoc99_sscanf(v6, "%d", v7 + 143);
                                                  }
                                                  else
                                                  {
                                                    v6 = strstr(v4, "bin3_freq=");
                                                    if ( v6 )
                                                    {
                                                      v6 += 10;
                                                      _isoc99_sscanf(v6, "%d", v7 + 144);
                                                    }
                                                    else
                                                    {
                                                      v6 = strstr(v4, "bin1_require_nonce=");
                                                      if ( v6 )
                                                      {
                                                        v6 += 19;
                                                        _isoc99_sscanf(v6, "%d", v7 + 145);
                                                      }
                                                      else
                                                      {
                                                        v6 = strstr(v4, "bin2_require_nonce=");
                                                        if ( v6 )
                                                        {
                                                          v6 += 19;
                                                          _isoc99_sscanf(v6, "%d", v7 + 146);
                                                        }
                                                        else
                                                        {
                                                          v6 = strstr(v4, "bin3_require_nonce=");
                                                          if ( v6 )
                                                          {
                                                            v6 += 19;
                                                            _isoc99_sscanf(v6, "%d", v7 + 147);
                                                          }
                                                          else
                                                          {
                                                            v6 = strstr(v4, "bin1_max_hw=");
                                                            if ( v6 )
                                                            {
                                                              v6 += 12;
                                                              _isoc99_sscanf(v6, "%d", v7 + 148);
                                                            }
                                                            else
                                                            {
                                                              v6 = strstr(v4, "bin2_max_hw=");
                                                              if ( v6 )
                                                              {
                                                                v6 += 12;
                                                                _isoc99_sscanf(v6, "%d", v7 + 149);
                                                              }
                                                              else
                                                              {
                                                                v6 = strstr(v4, "bin3_max_hw=");
                                                                if ( v6 )
                                                                {
                                                                  v6 += 12;
                                                                  _isoc99_sscanf(v6, "%d", v7 + 150);
                                                                }
                                                                else
                                                                {
                                                                  v6 = strstr(v4, "bin1_rate=");
                                                                  if ( v6 )
                                                                  {
                                                                    v6 += 10;
                                                                    _isoc99_sscanf(v6, "%f", v7 + 151);
                                                                  }
                                                                  else
                                                                  {
                                                                    v6 = strstr(v4, "bin2_rate=");
                                                                    if ( v6 )
                                                                    {
                                                                      v6 += 10;
                                                                      _isoc99_sscanf(v6, "%f", v7 + 152);
                                                                    }
                                                                    else
                                                                    {
                                                                      v6 = strstr(v4, "bin3_rate=");
                                                                      if ( v6 )
                                                                      {
                                                                        v6 += 10;
                                                                        _isoc99_sscanf(v6, "%f", v7 + 153);
                                                                      }
                                                                      else
                                                                      {
                                                                        v6 = strstr(v4, "tempture_high=");
                                                                        if ( v6 )
                                                                        {
                                                                          v6 += 14;
                                                                          _isoc99_sscanf(v6, "%d", v7 + 106);
                                                                        }
                                                                        else
                                                                        {
                                                                          v6 = strstr(v4, "tempture_low=");
                                                                          if ( v6 )
                                                                          {
                                                                            v6 += 13;
                                                                            _isoc99_sscanf(v6, "%d", v7 + 107);
                                                                          }
                                                                          else
                                                                          {
                                                                            v6 = strstr(v4, "slt_delay=");
                                                                            if ( v6 )
                                                                            {
                                                                              v6 += 10;
                                                                              _isoc99_sscanf(v6, "%d", v7 + 154);
                                                                            }
                                                                            else
                                                                            {
                                                                              v6 = strstr(v4, "enable_adjust_vol=");
                                                                              if ( v6 )
                                                                              {
                                                                                v6 += 18;
                                                                                _isoc99_sscanf(v6, "%d", v7 + 105);
                                                                              }
                                                                              else
                                                                              {
                                                                                v6 = strstr(v4, "timeout=");
                                                                                if ( v6 )
                                                                                {
                                                                                  v6 += 8;
                                                                                  _isoc99_sscanf(v6, "%d", v7 + 108);
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  result = fclose(stream);
  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v3, 0x400u, "%s done=========\n ", "app_config_handle");
    return applog(2, v3, 0);
  }
  return result;
}
// 11004: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;
// F34DC: using guessed type int app_conf;

//----- (0002C500) --------------------------------------------------------
unsigned __int16 __cdecl crc_itu_t_byte(unsigned __int16 crc, const unsigned __int8 data)
{
  return crc_itu_t_table[(unsigned __int8)(data ^ HIBYTE(crc))] ^ (crc << 8);
}
// 368F8: using guessed type _WORD crc_itu_t_table[256];

//----- (0002C544) --------------------------------------------------------
unsigned __int16 __cdecl CRC16_v1(const unsigned __int8 *buffer, int len)
{
  const unsigned __int8 *v2; // r3
  unsigned __int16 i; // [sp+Eh] [bp+Eh]

  for ( i = -1; len--; i = crc_itu_t_byte(i, *v2) )
    v2 = buffer++;
  return i;
}

//----- (0002C580) --------------------------------------------------------
int __fastcall CRC5_v1(_BYTE *a1, unsigned __int8 a2)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v8; // [sp+1Ch] [bp+1Ch]
  char v9; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 v10; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v5 = 16843009;
  v6 = 1;
  v10 = 0x80;
  v9 = 0;
  for ( i = 0; i < (unsigned int)a2; ++i )
  {
    v7 = (v10 & *a1) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 0x80;
      v9 = 0;
      ++a1;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (0002C6A0) --------------------------------------------------------
int power_init()
{
  return 0;
}

//----- (0002C6B0) --------------------------------------------------------
void power_exit()
{
  ;
}

//----- (0002C6C0) --------------------------------------------------------
int power_up()
{
  return 0;
}

//----- (0002C6D0) --------------------------------------------------------
int power_down()
{
  return 0;
}

//----- (0002C6E0) --------------------------------------------------------
int __fastcall my_log_curses(int result, const char *a2, const char *a3, char a4)
{
  if ( !opt_quiet || !result )
  {
    if ( a4 )
    {
      pthread_mutex_trylock(&console_lock);
      pthread_mutex_unlock(&console_lock);
    }
    pthread_mutex_lock(&console_lock);
    fprintf((FILE *)_bss_start, "%s%s", a2, a3);
    fflush((FILE *)_bss_start);
    return pthread_mutex_unlock(&console_lock);
  }
  return result;
}
// 47DA8: using guessed type int _bss_start;
// 4843D: using guessed type char opt_quiet;
// 48440: using guessed type pthread_mutex_t console_lock;

//----- (0002C76C) --------------------------------------------------------
int __fastcall applog(int a1, const char *a2, char a3)
{
  int result; // r0
  int v4; // r0
  char v8[64]; // [sp+2Ch] [bp+14h] BYREF
  time_t tv_sec; // [sp+6Ch] [bp+54h] BYREF
  struct timeval v10; // [sp+70h] [bp+58h] BYREF
  struct tm *v11; // [sp+78h] [bp+60h]
  int v12; // [sp+7Ch] [bp+64h]

  v10.tv_sec = 0;
  v10.tv_usec = 0;
  gettimeofday(&v10, 0);
  tv_sec = v10.tv_sec;
  v12 = v10.tv_usec / 1000;
  v11 = localtime(&tv_sec);
  result = snprintf(
             v8,
             0x40u,
             " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
             v11->tm_year + 1900,
             v11->tm_mon + 1,
             v11->tm_mday,
             v11->tm_hour,
             v11->tm_min,
             v11->tm_sec,
             v12);
  if ( app_conf )
  {
    v4 = fileno((FILE *)app_conf);
    result = isatty(v4);
    if ( !result )
    {
      fprintf((FILE *)app_conf, "%s%s", v8, a2);
      result = fflush((FILE *)app_conf);
    }
  }
  if ( dword_F3508 != 1 )
    return my_log_curses(a1, v8, a2, a3);
  return result;
}
// F34DC: using guessed type int app_conf;
// F3508: using guessed type int dword_F3508;

//----- (0002C874) --------------------------------------------------------
void __cdecl simplelog(int prio, const unsigned __int8 *str, bool force)
{
  int v3; // r0

  v3 = fileno((FILE *)_bss_start);
  if ( !isatty(v3) )
  {
    fprintf((FILE *)_bss_start, "%s\n", (const char *)str);
    fflush((FILE *)_bss_start);
  }
  my_log_curses(prio, byte_36B34, (const char *)str, force);
}
// 47DA8: using guessed type int _bss_start;

//----- (0002C8E4) --------------------------------------------------------
int patten_info_init()
{
  memset(&g_patten, 0, 0x9Cu);
  g_patten = dword_F3670;
  dword_F374C = dword_F3674;
  dword_F375C = dword_F365C;
  strcpy((char *)&dword_F3760, "patten");
  strcpy(byte_F3770, "zec-z11");
  strcpy((char *)&dword_F3780, "asic");
  strcpy((char *)&dword_F3790, "core");
  dword_F3750 = 140;
  dword_F3754 = 4;
  dword_F3758 = 1344;
  dword_F37C0 = dword_F365C * dword_F3674 * dword_F3670;
  dword_F37A0 = (int)malloc(1488 * dword_F365C * dword_F3674 * dword_F3670);
  if ( !dword_F37A0 )
  {
    printf("%s[%d] malloc failed\n", "patten_info_init", 29);
    exit(1);
  }
  memset((void *)dword_F37A0, 0, 1488 * dword_F375C * dword_F374C * g_patten);
  dword_F37B4 = (int)malloc(dword_F375C * dword_F374C * g_patten);
  if ( !dword_F37B4 )
  {
    printf("%s[%d] malloc failed\n", "patten_info_init", 35);
    exit(1);
  }
  memset((void *)dword_F37B4, 0, dword_F375C * dword_F374C * g_patten);
  dword_F37BC = (int)malloc(4 * g_patten);
  if ( !dword_F37BC )
  {
    printf("%s[%d] malloc failed\n", "patten_info_init", 41);
    exit(1);
  }
  memset((void *)dword_F37BC, 0, 4 * g_patten);
  return pthread_mutex_init(&mutex, 0);
}
// F365C: using guessed type int dword_F365C;
// F3670: using guessed type int dword_F3670;
// F3674: using guessed type int dword_F3674;
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F3760: using guessed type int dword_F3760;
// F3780: using guessed type int dword_F3780;
// F3790: using guessed type int dword_F3790;
// F37A0: using guessed type int dword_F37A0;
// F37B4: using guessed type int dword_F37B4;
// F37BC: using guessed type int dword_F37BC;
// F37C0: using guessed type int dword_F37C0;

//----- (0002CBDC) --------------------------------------------------------
void patten_info_destory()
{
  if ( dword_F37A0 )
    free((void *)dword_F37A0);
  if ( dword_F37B4 )
    free((void *)dword_F37B4);
  if ( dword_F37BC )
    free((void *)dword_F37BC);
  pthread_mutex_destroy(&mutex);
}
// F37A0: using guessed type int dword_F37A0;
// F37B4: using guessed type int dword_F37B4;
// F37BC: using guessed type int dword_F37BC;

//----- (0002CC48) --------------------------------------------------------
int patten_load()
{
  char v1[128]; // [sp+14h] [bp+4h] BYREF
  char v2[4096]; // [sp+94h] [bp+84h] BYREF
  const unsigned __int8 *v3; // [sp+1094h] [bp+1084h]
  unsigned __int8 *v4; // [sp+1098h] [bp+1088h]
  FILE *v5; // [sp+109Ch] [bp+108Ch]
  int v6; // [sp+10A0h] [bp+1090h]
  int k; // [sp+10A4h] [bp+1094h]
  int j; // [sp+10A8h] [bp+1098h]
  int i; // [sp+10ACh] [bp+109Ch]

  v6 = dword_F3758 + dword_F3750 + dword_F3754;
  for ( i = 0; g_patten > i; ++i )
  {
    for ( j = 0; dword_F374C > j; ++j )
    {
      memset(v1, 0, sizeof(v1));
      sprintf(
        v1,
        "/mnt/card/%s/%s/%s-0x%02x/%s-0x%02x.txt",
        (const char *)&dword_F3760,
        byte_F3770,
        (const char *)&dword_F3780,
        i,
        (const char *)&dword_F3790,
        j);
      printf("fname %s\n", v1);
      v5 = fopen(v1, "r");
      for ( k = 0; dword_F375C > k; ++k )
      {
        v4 = (unsigned __int8 *)(v6 * j * dword_F375C + v6 * dword_F375C * i * dword_F374C + v6 * k + dword_F37A0);
        memset(v2, 0, sizeof(v2));
        fgets(v2, 4096, v5);
        v3 = (const unsigned __int8 *)strstr(v2, "work");
        hex2bin(v4, v3 + 5, dword_F3750);
        v3 = (const unsigned __int8 *)strstr(v2, "nonce");
        hex2bin(&v4[dword_F3750], v3 + 6, dword_F3754);
        v3 = (const unsigned __int8 *)strstr(v2, "sol");
        hex2bin(&v4[dword_F3754 + dword_F3750], v3 + 4, dword_F3758);
        printf("load asic%d core%d patten%d\n", i, j, k);
      }
      fclose(v5);
    }
  }
  return puts("Load Patten Done");
}
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F3760: using guessed type int dword_F3760;
// F3780: using guessed type int dword_F3780;
// F3790: using guessed type int dword_F3790;
// F37A0: using guessed type int dword_F37A0;

//----- (0002CFC0) --------------------------------------------------------
int __fastcall is_patten_match(int a1, const void *a2, const void *a3)
{
  int v6; // [sp+24h] [bp+14h]
  int v7; // [sp+28h] [bp+18h]
  int v8; // [sp+2Ch] [bp+1Ch]

  pthread_mutex_lock(&mutex);
  v7 = memcmp((const void *)(dword_F37A4 + dword_F3750), a2, dword_F3754);
  v6 = memcmp((const void *)(dword_F37A4 + dword_F3754 + dword_F3750), a3, dword_F3758);
  if ( v7 || v6 )
  {
    v8 = -1;
  }
  else
  {
    *(_BYTE *)(dword_F37B0 + dword_F375C * (dword_F374C * dword_F37A8 + dword_F37AC) + dword_F37B4) = 1;
    *(float *)&dword_F37C4 = (float)++dword_F37B8 / (float)dword_F37C0;
    ++*(_DWORD *)(4 * dword_F37A8 + dword_F37BC);
    dump_str((FILE *)_bss_start, "Match Recv:", (const unsigned __int8 *)a2, dword_F3754);
    dump_str((FILE *)_bss_start, "Match Expect:", (const unsigned __int8 *)(dword_F37A4 + dword_F3750), dword_F3754);
    printf(
      "Patten Success Rate %.2f recv %d total %d asic %d recv %d\n",
      (float)(*(float *)&dword_F37C4 * 100.0),
      dword_F37B8,
      dword_F37C0,
      dword_F37A8,
      *(_DWORD *)(4 * dword_F37A8 + dword_F37BC));
    v8 = 0;
  }
  pthread_mutex_unlock(&mutex);
  return v8;
}
// 47DA8: using guessed type int _bss_start;
// F374C: using guessed type int dword_F374C;
// F3750: using guessed type int dword_F3750;
// F3754: using guessed type int dword_F3754;
// F3758: using guessed type int dword_F3758;
// F375C: using guessed type int dword_F375C;
// F37A4: using guessed type int dword_F37A4;
// F37A8: using guessed type int dword_F37A8;
// F37AC: using guessed type int dword_F37AC;
// F37B0: using guessed type int dword_F37B0;
// F37B4: using guessed type int dword_F37B4;
// F37B8: using guessed type int dword_F37B8;
// F37BC: using guessed type int dword_F37BC;
// F37C0: using guessed type int dword_F37C0;
// F37C4: using guessed type int dword_F37C4;

//----- (0002D1E4) --------------------------------------------------------
int display_single_board_test()
{
  return puts("******************Display Results*******************");
}

//----- (0002D1F8) --------------------------------------------------------
void clear_last_test_results()
{
  memset((void *)dword_F37B4, 0, dword_F375C * dword_F374C * g_patten);
  memset((void *)dword_F37BC, 0, 4 * g_patten);
  dword_F37B8 = 0;
  dword_F37C4 = 0;
}
// F3748: using guessed type int g_patten;
// F374C: using guessed type int dword_F374C;
// F375C: using guessed type int dword_F375C;
// F37B4: using guessed type int dword_F37B4;
// F37B8: using guessed type int dword_F37B8;
// F37BC: using guessed type int dword_F37BC;
// F37C4: using guessed type int dword_F37C4;

//----- (0002D270) --------------------------------------------------------
int __fastcall rt_ringbuffer_get_size(int a1)
{
  return *(unsigned __int16 *)(a1 + 12);
}

//----- (0002D288) --------------------------------------------------------
int __fastcall rt_ringbuffer_status(int a1)
{
  if ( *(_WORD *)(a1 + 4) >> 1 == *(_WORD *)(a1 + 6) >> 1 )
    return (*(_BYTE *)(a1 + 4) & 1) != (*(_BYTE *)(a1 + 6) & 1);
  else
    return 2;
}

//----- (0002D2D8) --------------------------------------------------------
uint16_t __cdecl rt_ringbuffer_data_len(rt_ringbuffer *rb)
{
  int v1; // r0

  v1 = rt_ringbuffer_status((int)rb);
  if ( !v1 )
    return 0;
  if ( v1 == 1 )
    return *((_WORD *)rb + 6);
  if ( *((_WORD *)rb + 3) >> 1 <= *((_WORD *)rb + 2) >> 1 )
    return (*((_WORD *)rb + 3) >> 1) - (*((_WORD *)rb + 2) >> 1) + *((_WORD *)rb + 6);
  return (*((_WORD *)rb + 3) >> 1) - (*((_WORD *)rb + 2) >> 1);
}

//----- (0002D35C) --------------------------------------------------------
int __fastcall rt_ringbuffer_init(int a1, int a2, __int16 a3, int a4)
{
  int result; // r0

  *(_WORD *)(a1 + 4) &= 1u;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a1 + 4) & 0xFE | ((*(_WORD *)(a1 + 4) & 2) != 0);
  *(_WORD *)(a1 + 6) &= 1u;
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a1 + 6) & 0xFE | ((*(_WORD *)(a1 + 6) & 2) != 0);
  *(_DWORD *)a1 = a2;
  *(_WORD *)(a1 + 12) = a3 & 0xFFFC;
  *(_DWORD *)(a1 + 136) = a4;
  result = pthread_mutex_init((pthread_mutex_t *)(a1 + 16), 0);
  if ( !*(_DWORD *)(a1 + 136) )
  {
    pthread_cond_init((pthread_cond_t *)(a1 + 40), 0);
    return pthread_cond_init((pthread_cond_t *)(a1 + 88), 0);
  }
  return result;
}

//----- (0002D408) --------------------------------------------------------
void __cdecl rt_ringbuffer_lock_destory(rt_ringbuffer *rb)
{
  pthread_mutex_destroy((pthread_mutex_t *)((char *)rb + 16));
  if ( !*((_DWORD *)rb + 34) )
  {
    pthread_cond_destroy((pthread_cond_t *)((char *)rb + 40));
    pthread_cond_destroy((pthread_cond_t *)((char *)rb + 88));
  }
}

//----- (0002D440) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_put(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length)
{
  __int16 v3; // r4
  __int16 v5; // r4
  uint16_t v10; // [sp+16h] [bp+16h]

  pthread_mutex_lock((pthread_mutex_t *)((char *)rb + 16));
  v3 = *((_WORD *)rb + 6);
  v10 = v3 - rt_ringbuffer_data_len(rb);
  if ( *((_DWORD *)rb + 34) == 1 )
  {
    if ( !v10 )
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rb + 16));
      return 0;
    }
    if ( v10 < (unsigned int)length )
      length = v10;
  }
  else if ( !*((_DWORD *)rb + 34) )
  {
    while ( v10 < (unsigned int)length )
    {
      pthread_cond_wait((pthread_cond_t *)((char *)rb + 40), (pthread_mutex_t *)((char *)rb + 16));
      v5 = *((_WORD *)rb + 6);
      v10 = v5 - rt_ringbuffer_data_len(rb);
    }
  }
  if ( *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1) <= length )
  {
    memcpy(
      (void *)(*(_DWORD *)rb + (*((_WORD *)rb + 3) >> 1)),
      ptr,
      *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1));
    memcpy(
      *(void **)rb,
      &ptr[*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1)],
      length - (*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1)));
    *((_BYTE *)rb + 6) = *((_BYTE *)rb + 6) & 0xFE | ((*((_BYTE *)rb + 6) & 1) == 0);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2
                                                 * ((length + (*((_WORD *)rb + 3) >> 1) - *((_WORD *)rb + 6)) & 0x7FFF));
  }
  else
  {
    memcpy((void *)(*(_DWORD *)rb + (*((_WORD *)rb + 3) >> 1)), ptr, length);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2 * ((length + (*((_WORD *)rb + 3) >> 1)) & 0x7FFF));
  }
  pthread_cond_signal((pthread_cond_t *)((char *)rb + 88));
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rb + 16));
  return length;
}

//----- (0002D600) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_put_force(rt_ringbuffer *rb, const uint8_t *ptr, uint16_t length)
{
  __int16 v3; // r4
  unsigned __int16 v8; // [sp+16h] [bp+16h]

  pthread_mutex_lock((pthread_mutex_t *)((char *)rb + 16));
  v3 = *((_WORD *)rb + 6);
  v8 = v3 - rt_ringbuffer_data_len(rb);
  if ( length > (unsigned int)v8 )
    length = *((_WORD *)rb + 6);
  if ( *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1) <= length )
  {
    memcpy(
      (void *)(*(_DWORD *)rb + (*((_WORD *)rb + 3) >> 1)),
      ptr,
      *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1));
    memcpy(
      *(void **)rb,
      &ptr[*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1)],
      length - (*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 3) >> 1)));
    *((_BYTE *)rb + 6) = *((_BYTE *)rb + 6) & 0xFE | ((*((_BYTE *)rb + 6) & 1) == 0);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2
                                                 * ((length + (*((_WORD *)rb + 3) >> 1) - *((_WORD *)rb + 6)) & 0x7FFF));
    if ( length > (unsigned int)v8 )
    {
      *((_BYTE *)rb + 4) = *((_BYTE *)rb + 4) & 0xFE | ((*((_BYTE *)rb + 4) & 1) == 0);
      *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2 * ((*((_WORD *)rb + 3) >> 1) & 0x7FFF));
    }
  }
  else
  {
    memcpy((void *)(*(_DWORD *)rb + (*((_WORD *)rb + 3) >> 1)), ptr, length);
    *((_WORD *)rb + 3) = *((_WORD *)rb + 3) & 1 | (2 * ((length + (*((_WORD *)rb + 3) >> 1)) & 0x7FFF));
    if ( length > (unsigned int)v8 )
      *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2 * ((*((_WORD *)rb + 3) >> 1) & 0x7FFF));
  }
  pthread_cond_signal((pthread_cond_t *)((char *)rb + 88));
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rb + 16));
  return length;
}

//----- (0002D7C0) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_get(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length)
{
  unsigned int v8; // [sp+14h] [bp+14h]

  pthread_mutex_lock((pthread_mutex_t *)((char *)rb + 16));
  v8 = rt_ringbuffer_data_len(rb);
  if ( *((_DWORD *)rb + 34) == 1 )
  {
    if ( !v8 )
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rb + 16));
      return 0;
    }
    if ( length > v8 )
      length = v8;
  }
  else if ( !*((_DWORD *)rb + 34) )
  {
    while ( length > v8 )
    {
      pthread_cond_wait((pthread_cond_t *)((char *)rb + 88), (pthread_mutex_t *)((char *)rb + 16));
      v8 = rt_ringbuffer_data_len(rb);
    }
  }
  if ( *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1) <= length )
  {
    memcpy(
      ptr,
      (const void *)(*(_DWORD *)rb + (*((_WORD *)rb + 2) >> 1)),
      *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1));
    memcpy(
      &ptr[*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1)],
      *(const void **)rb,
      length - (*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1)));
    *((_BYTE *)rb + 4) = *((_BYTE *)rb + 4) & 0xFE | ((*((_BYTE *)rb + 4) & 1) == 0);
    *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2
                                                 * ((length + (*((_WORD *)rb + 2) >> 1) - *((_WORD *)rb + 6)) & 0x7FFF));
    pthread_cond_signal((pthread_cond_t *)((char *)rb + 40));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rb + 16));
  }
  else
  {
    memcpy(ptr, (const void *)(*(_DWORD *)rb + (*((_WORD *)rb + 2) >> 1)), length);
    *((_WORD *)rb + 2) = *((_WORD *)rb + 2) & 1 | (2 * ((length + (*((_WORD *)rb + 2) >> 1)) & 0x7FFF));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rb + 16));
    pthread_cond_signal((pthread_cond_t *)((char *)rb + 40));
  }
  return length;
}

//----- (0002D974) --------------------------------------------------------
uint32_t __cdecl rt_ringbuffer_prefetch(rt_ringbuffer *rb, uint8_t *ptr, uint16_t length)
{
  unsigned int v8; // [sp+14h] [bp+14h]

  v8 = rt_ringbuffer_data_len(rb);
  if ( !v8 )
    return 0;
  if ( length > v8 )
    length = v8;
  if ( *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1) <= length )
  {
    memcpy(
      ptr,
      (const void *)(*(_DWORD *)rb + (*((_WORD *)rb + 2) >> 1)),
      *((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1));
    memcpy(
      &ptr[*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1)],
      *(const void **)rb,
      length - (*((unsigned __int16 *)rb + 6) - (*((_WORD *)rb + 2) >> 1)));
  }
  else
  {
    memcpy(ptr, (const void *)(*(_DWORD *)rb + (*((_WORD *)rb + 2) >> 1)), length);
  }
  return length;
}

//----- (0002DA44) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  uint32_t wv[8]; // [sp+14h] [bp+14h]
  uint32_t w[64]; // [sp+34h] [bp+34h]
  uint32_t v5; // [sp+134h] [bp+134h]
  uint32_t v6; // [sp+138h] [bp+138h]
  const unsigned __int8 *v7; // [sp+13Ch] [bp+13Ch]
  int j; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  for ( i = 0; i < (int)block_nb; ++i )
  {
    v7 = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = v7[4 * j + 3] | (v7[4 * j + 2] << 8) | (v7[4 * j + 1] << 16) | (v7[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      wv[j] = *((_DWORD *)ctx + j + 34);
    for ( j = 0; j <= 63; ++j )
    {
      v6 = w[j]
         + wv[7]
         + (__ROR4__(wv[4], 25) ^ __ROR4__(wv[4], 6) ^ __ROR4__(wv[4], 11))
         + (wv[6] & ~wv[4] ^ wv[4] & wv[5])
         + sha256_k[j];
      v5 = (wv[2] & wv[1] ^ wv[0] & wv[1] ^ wv[2] & wv[0])
         + (__ROR4__(wv[0], 2) ^ __ROR4__(wv[0], 13) ^ __ROR4__(wv[0], 22));
      wv[7] = wv[6];
      wv[6] = wv[5];
      wv[5] = wv[4];
      wv[4] = wv[3] + v6;
      wv[3] = wv[2];
      wv[2] = wv[1];
      wv[1] = wv[0];
      wv[0] = v6 + v5;
    }
    for ( j = 0; j <= 7; ++j )
      *((_DWORD *)ctx + j + 34) += wv[j];
  }
}
// 47CA8: using guessed type _DWORD sha256_k[64];

//----- (0002DDA0) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  char ctx[168]; // [sp+10h] [bp+10h] BYREF

  sha256_init((sha256_ctx *)ctx);
  sha256_update((sha256_ctx *)ctx, message, len);
  sha256_final((sha256_ctx *)ctx, digest);
}

//----- (0002DDD8) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)ctx + i + 34) = sha256_h0[i];
  *((_DWORD *)ctx + 1) = 0;
  *(_DWORD *)ctx = 0;
}
// 47C88: using guessed type _DWORD sha256_h0[8];

//----- (0002DE24) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v3; // r3
  const unsigned __int8 *v7; // [sp+14h] [bp+14h]
  unsigned int v8; // [sp+18h] [bp+18h]
  size_t n; // [sp+20h] [bp+20h]
  unsigned int na; // [sp+20h] [bp+20h]

  v3 = len;
  if ( len >= 64 - *((_DWORD *)ctx + 1) )
    v3 = 64 - *((_DWORD *)ctx + 1);
  n = v3;
  memcpy((char *)ctx + *((_DWORD *)ctx + 1) + 8, message, v3);
  if ( len + *((_DWORD *)ctx + 1) > 0x3F )
  {
    v8 = (len - n) >> 6;
    v7 = &message[n];
    sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, 1u);
    sha256_transf(ctx, &message[n], v8);
    na = (len - n) & 0x3F;
    memcpy((char *)ctx + 8, &v7[64 * v8], na);
    *((_DWORD *)ctx + 1) = na;
    *(_DWORD *)ctx += (v8 + 1) << 6;
  }
  else
  {
    *((_DWORD *)ctx + 1) += len;
  }
}

//----- (0002DEDC) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  int v5; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]
  unsigned int v7; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( (*((_DWORD *)ctx + 1) & 0x3Fu) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  v7 = v2;
  v6 = 8 * (*((_DWORD *)ctx + 1) + *(_DWORD *)ctx);
  v5 = v2 << 6;
  memset((char *)ctx + *((_DWORD *)ctx + 1) + 8, 0, (v2 << 6) - *((_DWORD *)ctx + 1));
  *((_BYTE *)ctx + *((_DWORD *)ctx + 1) + 8) = 0x80;
  *((_BYTE *)ctx + v5 + 7) = v6;
  *((_BYTE *)ctx + v5 + 6) = BYTE1(v6);
  *((_BYTE *)ctx + v5 + 5) = BYTE2(v6);
  *((_BYTE *)ctx + v5 + 4) = HIBYTE(v6);
  sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, v7);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = *((_DWORD *)ctx + i + 34);
    digest[4 * i + 2] = BYTE1(*((_DWORD *)ctx + i + 34));
    digest[4 * i + 1] = BYTE2(*((_DWORD *)ctx + i + 34));
    digest[4 * i] = HIBYTE(*((_DWORD *)ctx + i + 34));
  }
}

//----- (0002E014) --------------------------------------------------------
void __cdecl Sha256_Init(CSha256 *p)
{
  *(_DWORD *)p = 1779033703;
  *((_DWORD *)p + 1) = -1150833019;
  *((_DWORD *)p + 2) = 1013904242;
  *((_DWORD *)p + 3) = -1521486534;
  *((_DWORD *)p + 4) = 1359893119;
  *((_DWORD *)p + 5) = -1694144372;
  *((_DWORD *)p + 6) = 528734635;
  *((_DWORD *)p + 7) = 1541459225;
  *((_DWORD *)p + 8) = 0;
  *((_DWORD *)p + 9) = 0;
}

//----- (0002E094) --------------------------------------------------------
void __cdecl Sha256_Transform(uint32_t *state, const uint32_t *data)
{
  int v2; // r1
  unsigned int v3; // r2
  int v4; // r3
  unsigned int j; // [sp+68h] [bp+68h]
  unsigned int i; // [sp+6Ch] [bp+6Ch]
  int v8; // [sp+70h] [bp+70h] BYREF

  for ( i = 0; i <= 7; ++i )
    *(&v8 + i - 26) = state[i];
  for ( i = 0; i <= 0x3F; i += 16 )
  {
    for ( j = 0; j <= 0xF; ++j )
    {
      v2 = (__ROR4__(*(&v8 + ((4 - (_BYTE)j) & 7) - 26), 6) ^ __ROR4__(*(&v8 + ((4 - (_BYTE)j) & 7) - 26), 11) ^ __ROR4__(*(&v8 + ((4 - (_BYTE)j) & 7) - 26), 25))
         + ((*(&v8 + ((6 - (_BYTE)j) & 7) - 26) ^ *(&v8 + ((5 - (_BYTE)j) & 7) - 26)) & *(&v8 + ((4 - (_BYTE)j) & 7)
                                                                                              - 26) ^ *(&v8 + ((6 - (_BYTE)j) & 7) - 26))
         + K[j + i];
      if ( i )
      {
        v3 = j;
        *(&v8 + j - 18) = *(&v8 + (j & 0xF) - 18)
                        + (((unsigned int)*(&v8 + (((_BYTE)j - 15) & 0xF) - 18) >> 3) ^ __ROR4__(
                                                                                          *(&v8
                                                                                          + (((_BYTE)j - 15) & 0xF)
                                                                                          - 18),
                                                                                          7) ^ __ROR4__(
                                                                                                 *(&v8
                                                                                                 + (((_BYTE)j - 15) & 0xF)
                                                                                                 - 18),
                                                                                                 18))
                        + (__ROR4__(*(&v8 + (((_BYTE)j - 2) & 0xF) - 18), 17) ^ __ROR4__(
                                                                                  *(&v8 + (((_BYTE)j - 2) & 0xF) - 18),
                                                                                  19) ^ ((unsigned int)*(&v8 + (((_BYTE)j - 2) & 0xF) - 18) >> 10))
                        + *(&v8 + (((_BYTE)j - 7) & 0xF) - 18);
        v4 = *(&v8 + v3 - 18);
      }
      else
      {
        *(&v8 + j - 18) = data[j];
        v4 = *(&v8 + j - 18);
      }
      *(&v8 + ((7 - (_BYTE)j) & 7) - 26) += v2 + v4;
      *(&v8 + ((3 - (_BYTE)j) & 7) - 26) += *(&v8 + ((7 - (_BYTE)j) & 7) - 26);
      *(&v8 + ((7 - (_BYTE)j) & 7) - 26) += ((*(&v8 + ((1 - (_BYTE)j) & 7) - 26) | *(&v8 + (-j & 7) - 26)) & *(&v8 + ((2 - (_BYTE)j) & 7) - 26) | *(&v8 + (-j & 7) - 26) & *(&v8 + ((1 - (_BYTE)j) & 7) - 26))
                                          + (__ROR4__(*(&v8 + (-j & 7) - 26), 2) ^ __ROR4__(*(&v8 + (-j & 7) - 26), 13) ^ __ROR4__(*(&v8 + (-j & 7) - 26), 22));
    }
  }
  for ( i = 0; i <= 7; ++i )
    state[i] += *(&v8 + i - 26);
}
// 2E1A2: masking with 0xF was optimized away because %var_C.4 <= 0xF
// 36C94: using guessed type _DWORD K[64];

//----- (0002E464) --------------------------------------------------------
void __cdecl Sha256_WriteByteBlock(CSha256 *p)
{
  uint32_t data32[16]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int i; // [sp+4Ch] [bp+4Ch]
  __int64 savedregs; // [sp+50h] [bp+50h] BYREF

  for ( i = 0; i <= 0xF; ++i )
    *((_DWORD *)&savedregs + i - 17) = *((unsigned __int8 *)p + 4 * i + 43)
                                     + (*((unsigned __int8 *)p + 4 * i + 42) << 8)
                                     + (*((unsigned __int8 *)p + 4 * i + 40) << 24)
                                     + (*((unsigned __int8 *)p + 4 * i + 41) << 16);
  Sha256_Transform((uint32_t *)p, data32);
}

//----- (0002E4E4) --------------------------------------------------------
void __cdecl Sha256_Update(CSha256 *p, const uint8_t *data, size_t size)
{
  int v3; // r3
  const uint8_t *v4; // r2
  int v8; // [sp+14h] [bp+14h]

  v8 = *((_QWORD *)p + 4) & 0x3F;
  while ( size )
  {
    v3 = v8++;
    v4 = data++;
    *((_BYTE *)p + v3 + 40) = *v4;
    ++*((_QWORD *)p + 4);
    --size;
    if ( v8 == 64 )
    {
      v8 = 0;
      Sha256_WriteByteBlock(p);
    }
  }
}

//----- (0002E54C) --------------------------------------------------------
void __cdecl Sha256_Final(CSha256 *p, uint8_t *digest)
{
  int v2; // r3
  int v3; // r3
  int v4; // r1
  uint8_t *v5; // r3
  unsigned int i; // [sp+8h] [bp+8h]
  unsigned int j; // [sp+8h] [bp+8h]
  int v10; // [sp+Ch] [bp+Ch]
  int v11; // [sp+Ch] [bp+Ch]
  __int64 v12; // [sp+10h] [bp+10h]

  v12 = 8LL * *((_QWORD *)p + 4);
  v2 = *((_QWORD *)p + 4) & 0x3F;
  v10 = v2 + 1;
  *((_BYTE *)p + v2 + 40) = 0x80;
  while ( v10 != 56 )
  {
    v11 = v10 & 0x3F;
    if ( !v11 )
      Sha256_WriteByteBlock(p);
    v3 = v11;
    v10 = v11 + 1;
    *((_BYTE *)p + v3 + 40) = 0;
  }
  for ( i = 0; i <= 7; ++i )
  {
    v4 = v10++;
    *((_BYTE *)p + v4 + 40) = HIBYTE(v12);
    v12 <<= 8;
  }
  Sha256_WriteByteBlock(p);
  for ( j = 0; j <= 7; ++j )
  {
    *digest = HIBYTE(*((_DWORD *)p + j));
    digest[1] = BYTE2(*((_DWORD *)p + j));
    digest[2] = BYTE1(*((_DWORD *)p + j));
    v5 = digest + 3;
    digest += 4;
    *v5 = *((_DWORD *)p + j);
  }
  Sha256_Init(p);
}

//----- (0002E66C) --------------------------------------------------------
void __cdecl Sha256_Onestep(const uint8_t *data, size_t size, uint8_t *digest)
{
  char p[104]; // [sp+10h] [bp+10h] BYREF

  Sha256_Init((CSha256 *)p);
  Sha256_Update((CSha256 *)p, data, size);
  Sha256_Final((CSha256 *)p, digest);
}

//----- (0002E6A4) --------------------------------------------------------
void __cdecl sha2_starts(sha2_context *ctx)
{
  *(_DWORD *)ctx = 0;
  *((_DWORD *)ctx + 1) = 0;
  *((_DWORD *)ctx + 2) = 1779033703;
  *((_DWORD *)ctx + 3) = -1150833019;
  *((_DWORD *)ctx + 4) = 1013904242;
  *((_DWORD *)ctx + 5) = -1521486534;
  *((_DWORD *)ctx + 6) = 1359893119;
  *((_DWORD *)ctx + 7) = -1694144372;
  *((_DWORD *)ctx + 8) = 528734635;
  *((_DWORD *)ctx + 9) = 1541459225;
}

//----- (0002E724) --------------------------------------------------------
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int W; // [sp+8h] [bp+8h]
  unsigned int W_4; // [sp+Ch] [bp+Ch]
  unsigned int W_8; // [sp+10h] [bp+10h]
  unsigned int W_12; // [sp+14h] [bp+14h]
  unsigned int W_16; // [sp+18h] [bp+18h]
  unsigned int W_20; // [sp+1Ch] [bp+1Ch]
  unsigned int W_24; // [sp+20h] [bp+20h]
  unsigned int W_28; // [sp+24h] [bp+24h]
  unsigned int W_32; // [sp+28h] [bp+28h]
  unsigned int W_36; // [sp+2Ch] [bp+2Ch]
  unsigned int W_40; // [sp+30h] [bp+30h]
  unsigned int W_44; // [sp+34h] [bp+34h]
  unsigned int W_48; // [sp+38h] [bp+38h]
  unsigned int W_52; // [sp+3Ch] [bp+3Ch]
  unsigned int W_56; // [sp+40h] [bp+40h]
  unsigned int W_60; // [sp+44h] [bp+44h]
  unsigned int W_64; // [sp+48h] [bp+48h]
  unsigned int W_68; // [sp+4Ch] [bp+4Ch]
  unsigned int W_72; // [sp+50h] [bp+50h]
  unsigned int W_76; // [sp+54h] [bp+54h]
  unsigned int W_80; // [sp+58h] [bp+58h]
  unsigned int W_84; // [sp+5Ch] [bp+5Ch]
  unsigned int W_88; // [sp+60h] [bp+60h]
  unsigned int W_92; // [sp+64h] [bp+64h]
  unsigned int W_96; // [sp+68h] [bp+68h]
  unsigned int W_100; // [sp+6Ch] [bp+6Ch]
  unsigned int W_104; // [sp+70h] [bp+70h]
  unsigned int W_108; // [sp+74h] [bp+74h]
  unsigned int W_112; // [sp+78h] [bp+78h]
  unsigned int W_116; // [sp+7Ch] [bp+7Ch]
  unsigned int W_120; // [sp+80h] [bp+80h]
  unsigned int W_124; // [sp+84h] [bp+84h]
  unsigned int W_128; // [sp+88h] [bp+88h]
  unsigned int W_132; // [sp+8Ch] [bp+8Ch]
  unsigned int W_136; // [sp+90h] [bp+90h]
  unsigned int W_140; // [sp+94h] [bp+94h]
  unsigned int W_144; // [sp+98h] [bp+98h]
  unsigned int W_148; // [sp+9Ch] [bp+9Ch]
  unsigned int W_152; // [sp+A0h] [bp+A0h]
  unsigned int W_156; // [sp+A4h] [bp+A4h]
  unsigned int W_160; // [sp+A8h] [bp+A8h]
  unsigned int W_164; // [sp+ACh] [bp+ACh]
  unsigned int W_168; // [sp+B0h] [bp+B0h]
  unsigned int W_172; // [sp+B4h] [bp+B4h]
  unsigned int W_176; // [sp+B8h] [bp+B8h]
  unsigned int W_180; // [sp+BCh] [bp+BCh]
  unsigned int W_184; // [sp+C0h] [bp+C0h]
  unsigned int W_188; // [sp+C4h] [bp+C4h]
  unsigned int W_192; // [sp+C8h] [bp+C8h]
  unsigned int W_196; // [sp+CCh] [bp+CCh]
  unsigned int W_200; // [sp+D0h] [bp+D0h]
  unsigned int W_204; // [sp+D4h] [bp+D4h]
  unsigned int W_208; // [sp+D8h] [bp+D8h]
  unsigned int W_212; // [sp+DCh] [bp+DCh]
  unsigned int W_216; // [sp+E0h] [bp+E0h]
  unsigned int W_220; // [sp+E4h] [bp+E4h]
  unsigned int W_224; // [sp+E8h] [bp+E8h]
  unsigned int W_228; // [sp+ECh] [bp+ECh]
  unsigned int W_232; // [sp+F0h] [bp+F0h]
  unsigned int W_236; // [sp+F4h] [bp+F4h]
  unsigned int W_240; // [sp+F8h] [bp+F8h]
  unsigned int W_244; // [sp+FCh] [bp+FCh]
  int v64; // [sp+10Ch] [bp+10Ch]
  int v65; // [sp+10Ch] [bp+10Ch]
  int v66; // [sp+10Ch] [bp+10Ch]
  int v67; // [sp+10Ch] [bp+10Ch]
  int v68; // [sp+10Ch] [bp+10Ch]
  int v69; // [sp+10Ch] [bp+10Ch]
  int v70; // [sp+10Ch] [bp+10Ch]
  int v71; // [sp+10Ch] [bp+10Ch]
  int v72; // [sp+10Ch] [bp+10Ch]
  int v73; // [sp+10Ch] [bp+10Ch]
  int v74; // [sp+10Ch] [bp+10Ch]
  int v75; // [sp+10Ch] [bp+10Ch]
  int v76; // [sp+10Ch] [bp+10Ch]
  int v77; // [sp+10Ch] [bp+10Ch]
  int v78; // [sp+10Ch] [bp+10Ch]
  int v79; // [sp+10Ch] [bp+10Ch]
  int v80; // [sp+10Ch] [bp+10Ch]
  int v81; // [sp+10Ch] [bp+10Ch]
  int v82; // [sp+10Ch] [bp+10Ch]
  int v83; // [sp+10Ch] [bp+10Ch]
  int v84; // [sp+10Ch] [bp+10Ch]
  int v85; // [sp+10Ch] [bp+10Ch]
  int v86; // [sp+10Ch] [bp+10Ch]
  int v87; // [sp+10Ch] [bp+10Ch]
  int v88; // [sp+10Ch] [bp+10Ch]
  int v89; // [sp+10Ch] [bp+10Ch]
  int v90; // [sp+10Ch] [bp+10Ch]
  int v91; // [sp+10Ch] [bp+10Ch]
  int v92; // [sp+10Ch] [bp+10Ch]
  int v93; // [sp+10Ch] [bp+10Ch]
  int v94; // [sp+10Ch] [bp+10Ch]
  int v95; // [sp+10Ch] [bp+10Ch]
  int v96; // [sp+10Ch] [bp+10Ch]
  int v97; // [sp+10Ch] [bp+10Ch]
  int v98; // [sp+10Ch] [bp+10Ch]
  int v99; // [sp+10Ch] [bp+10Ch]
  int v100; // [sp+10Ch] [bp+10Ch]
  int v101; // [sp+10Ch] [bp+10Ch]
  int v102; // [sp+10Ch] [bp+10Ch]
  int v103; // [sp+10Ch] [bp+10Ch]
  int v104; // [sp+10Ch] [bp+10Ch]
  int v105; // [sp+10Ch] [bp+10Ch]
  int v106; // [sp+10Ch] [bp+10Ch]
  int v107; // [sp+10Ch] [bp+10Ch]
  int v108; // [sp+10Ch] [bp+10Ch]
  int v109; // [sp+10Ch] [bp+10Ch]
  int v110; // [sp+10Ch] [bp+10Ch]
  int v111; // [sp+10Ch] [bp+10Ch]
  int v112; // [sp+10Ch] [bp+10Ch]
  int v113; // [sp+10Ch] [bp+10Ch]
  int v114; // [sp+10Ch] [bp+10Ch]
  int v115; // [sp+10Ch] [bp+10Ch]
  int v116; // [sp+10Ch] [bp+10Ch]
  int v117; // [sp+10Ch] [bp+10Ch]
  int v118; // [sp+10Ch] [bp+10Ch]
  int v119; // [sp+10Ch] [bp+10Ch]
  int v120; // [sp+10Ch] [bp+10Ch]
  int v121; // [sp+10Ch] [bp+10Ch]
  int v122; // [sp+10Ch] [bp+10Ch]
  int v123; // [sp+10Ch] [bp+10Ch]
  int v124; // [sp+10Ch] [bp+10Ch]
  int v125; // [sp+10Ch] [bp+10Ch]
  int v126; // [sp+10Ch] [bp+10Ch]
  int v127; // [sp+10Ch] [bp+10Ch]
  int v128; // [sp+110h] [bp+110h]
  int v129; // [sp+110h] [bp+110h]
  int v130; // [sp+110h] [bp+110h]
  int v131; // [sp+110h] [bp+110h]
  int v132; // [sp+110h] [bp+110h]
  int v133; // [sp+110h] [bp+110h]
  int v134; // [sp+110h] [bp+110h]
  int v135; // [sp+110h] [bp+110h]
  int v136; // [sp+110h] [bp+110h]
  int v137; // [sp+110h] [bp+110h]
  int v138; // [sp+110h] [bp+110h]
  int v139; // [sp+110h] [bp+110h]
  int v140; // [sp+110h] [bp+110h]
  int v141; // [sp+110h] [bp+110h]
  int v142; // [sp+110h] [bp+110h]
  int v143; // [sp+110h] [bp+110h]
  int v144; // [sp+114h] [bp+114h]
  int v145; // [sp+114h] [bp+114h]
  int v146; // [sp+114h] [bp+114h]
  int v147; // [sp+114h] [bp+114h]
  int v148; // [sp+114h] [bp+114h]
  int v149; // [sp+114h] [bp+114h]
  int v150; // [sp+114h] [bp+114h]
  int v151; // [sp+114h] [bp+114h]
  int v152; // [sp+114h] [bp+114h]
  int v153; // [sp+114h] [bp+114h]
  int v154; // [sp+114h] [bp+114h]
  int v155; // [sp+114h] [bp+114h]
  int v156; // [sp+114h] [bp+114h]
  int v157; // [sp+114h] [bp+114h]
  int v158; // [sp+114h] [bp+114h]
  int v159; // [sp+114h] [bp+114h]
  int v160; // [sp+114h] [bp+114h]
  int v161; // [sp+118h] [bp+118h]
  int v162; // [sp+118h] [bp+118h]
  int v163; // [sp+118h] [bp+118h]
  int v164; // [sp+118h] [bp+118h]
  int v165; // [sp+118h] [bp+118h]
  int v166; // [sp+118h] [bp+118h]
  int v167; // [sp+118h] [bp+118h]
  int v168; // [sp+118h] [bp+118h]
  int v169; // [sp+118h] [bp+118h]
  int v170; // [sp+118h] [bp+118h]
  int v171; // [sp+118h] [bp+118h]
  int v172; // [sp+118h] [bp+118h]
  int v173; // [sp+118h] [bp+118h]
  int v174; // [sp+118h] [bp+118h]
  int v175; // [sp+118h] [bp+118h]
  int v176; // [sp+118h] [bp+118h]
  int v177; // [sp+118h] [bp+118h]
  int v178; // [sp+11Ch] [bp+11Ch]
  int v179; // [sp+11Ch] [bp+11Ch]
  int v180; // [sp+11Ch] [bp+11Ch]
  int v181; // [sp+11Ch] [bp+11Ch]
  int v182; // [sp+11Ch] [bp+11Ch]
  int v183; // [sp+11Ch] [bp+11Ch]
  int v184; // [sp+11Ch] [bp+11Ch]
  int v185; // [sp+11Ch] [bp+11Ch]
  int v186; // [sp+11Ch] [bp+11Ch]
  int v187; // [sp+11Ch] [bp+11Ch]
  int v188; // [sp+11Ch] [bp+11Ch]
  int v189; // [sp+11Ch] [bp+11Ch]
  int v190; // [sp+11Ch] [bp+11Ch]
  int v191; // [sp+11Ch] [bp+11Ch]
  int v192; // [sp+11Ch] [bp+11Ch]
  int v193; // [sp+11Ch] [bp+11Ch]
  int v194; // [sp+120h] [bp+120h]
  int v195; // [sp+120h] [bp+120h]
  int v196; // [sp+120h] [bp+120h]
  int v197; // [sp+120h] [bp+120h]
  int v198; // [sp+120h] [bp+120h]
  int v199; // [sp+120h] [bp+120h]
  int v200; // [sp+120h] [bp+120h]
  int v201; // [sp+120h] [bp+120h]
  int v202; // [sp+120h] [bp+120h]
  int v203; // [sp+120h] [bp+120h]
  int v204; // [sp+120h] [bp+120h]
  int v205; // [sp+120h] [bp+120h]
  int v206; // [sp+120h] [bp+120h]
  int v207; // [sp+120h] [bp+120h]
  int v208; // [sp+120h] [bp+120h]
  int v209; // [sp+120h] [bp+120h]
  int v210; // [sp+124h] [bp+124h]
  int v211; // [sp+124h] [bp+124h]
  int v212; // [sp+124h] [bp+124h]
  int v213; // [sp+124h] [bp+124h]
  int v214; // [sp+124h] [bp+124h]
  int v215; // [sp+124h] [bp+124h]
  int v216; // [sp+124h] [bp+124h]
  int v217; // [sp+124h] [bp+124h]
  int v218; // [sp+124h] [bp+124h]
  int v219; // [sp+124h] [bp+124h]
  int v220; // [sp+124h] [bp+124h]
  int v221; // [sp+124h] [bp+124h]
  int v222; // [sp+124h] [bp+124h]
  int v223; // [sp+124h] [bp+124h]
  int v224; // [sp+124h] [bp+124h]
  int v225; // [sp+124h] [bp+124h]
  int v226; // [sp+124h] [bp+124h]
  int v227; // [sp+128h] [bp+128h]
  int v228; // [sp+128h] [bp+128h]
  int v229; // [sp+128h] [bp+128h]
  int v230; // [sp+128h] [bp+128h]
  int v231; // [sp+128h] [bp+128h]
  int v232; // [sp+128h] [bp+128h]
  int v233; // [sp+128h] [bp+128h]
  int v234; // [sp+128h] [bp+128h]
  int v235; // [sp+128h] [bp+128h]
  int v236; // [sp+128h] [bp+128h]
  int v237; // [sp+128h] [bp+128h]
  int v238; // [sp+128h] [bp+128h]
  int v239; // [sp+128h] [bp+128h]
  int v240; // [sp+128h] [bp+128h]
  int v241; // [sp+128h] [bp+128h]
  int v242; // [sp+128h] [bp+128h]
  int v243; // [sp+128h] [bp+128h]
  int v244; // [sp+12Ch] [bp+12Ch]
  int v245; // [sp+12Ch] [bp+12Ch]
  int v246; // [sp+12Ch] [bp+12Ch]
  int v247; // [sp+12Ch] [bp+12Ch]
  int v248; // [sp+12Ch] [bp+12Ch]
  int v249; // [sp+12Ch] [bp+12Ch]
  int v250; // [sp+12Ch] [bp+12Ch]
  int v251; // [sp+12Ch] [bp+12Ch]
  int v252; // [sp+12Ch] [bp+12Ch]
  int v253; // [sp+12Ch] [bp+12Ch]
  int v254; // [sp+12Ch] [bp+12Ch]
  int v255; // [sp+12Ch] [bp+12Ch]
  int v256; // [sp+12Ch] [bp+12Ch]
  int v257; // [sp+12Ch] [bp+12Ch]
  int v258; // [sp+12Ch] [bp+12Ch]
  int v259; // [sp+12Ch] [bp+12Ch]

  W = _byteswap_ulong(*(_DWORD *)data);
  W_4 = _byteswap_ulong(*((_DWORD *)data + 1));
  W_8 = _byteswap_ulong(*((_DWORD *)data + 2));
  W_12 = _byteswap_ulong(*((_DWORD *)data + 3));
  W_16 = _byteswap_ulong(*((_DWORD *)data + 4));
  W_20 = _byteswap_ulong(*((_DWORD *)data + 5));
  W_24 = _byteswap_ulong(*((_DWORD *)data + 6));
  W_28 = _byteswap_ulong(*((_DWORD *)data + 7));
  W_32 = _byteswap_ulong(*((_DWORD *)data + 8));
  W_36 = _byteswap_ulong(*((_DWORD *)data + 9));
  W_40 = _byteswap_ulong(*((_DWORD *)data + 10));
  W_44 = _byteswap_ulong(*((_DWORD *)data + 11));
  W_48 = _byteswap_ulong(*((_DWORD *)data + 12));
  W_52 = _byteswap_ulong(*((_DWORD *)data + 13));
  W_56 = _byteswap_ulong(*((_DWORD *)data + 14));
  W_60 = _byteswap_ulong(*((_DWORD *)data + 15));
  v244 = *((_DWORD *)ctx + 2);
  v227 = *((_DWORD *)ctx + 3);
  v210 = *((_DWORD *)ctx + 4);
  v178 = *((_DWORD *)ctx + 6);
  v161 = *((_DWORD *)ctx + 7);
  v144 = *((_DWORD *)ctx + 8);
  v64 = (__ROR4__(v178, 6) ^ __ROR4__(v178, 11) ^ __ROR4__(v178, 25))
      + *((_DWORD *)ctx + 9)
      + (v144 ^ (v161 ^ v144) & v178)
      + W
      + 1116352408;
  v194 = v64 + *((_DWORD *)ctx + 5);
  v128 = (v210 & (v244 | v227) | v244 & v227) + (__ROR4__(v244, 2) ^ __ROR4__(v244, 13) ^ __ROR4__(v244, 22)) + v64;
  v65 = (__ROR4__(v194, 6) ^ __ROR4__(v194, 11) ^ __ROR4__(v194, 25))
      + v144
      + (v161 ^ (v178 ^ v161) & v194)
      + W_4
      + 1899447441;
  v211 = v65 + v210;
  v145 = (v227 & (v128 | v244) | v128 & v244) + (__ROR4__(v128, 2) ^ __ROR4__(v128, 13) ^ __ROR4__(v128, 22)) + v65;
  v66 = (__ROR4__(v211, 6) ^ __ROR4__(v211, 11) ^ __ROR4__(v211, 25))
      + v161
      + (v178 ^ (v194 ^ v178) & v211)
      + W_8
      - 1245643825;
  v228 = v66 + v227;
  v162 = (v244 & (v145 | v128) | v145 & v128) + (__ROR4__(v145, 2) ^ __ROR4__(v145, 13) ^ __ROR4__(v145, 22)) + v66;
  v67 = (__ROR4__(v228, 6) ^ __ROR4__(v228, 11) ^ __ROR4__(v228, 25))
      + v178
      + (v194 ^ (v211 ^ v194) & v228)
      + W_12
      - 373957723;
  v245 = v67 + v244;
  v179 = (v128 & (v162 | v145) | v162 & v145) + (__ROR4__(v162, 2) ^ __ROR4__(v162, 13) ^ __ROR4__(v162, 22)) + v67;
  v68 = (__ROR4__(v245, 6) ^ __ROR4__(v245, 11) ^ __ROR4__(v245, 25))
      + v194
      + (v211 ^ (v228 ^ v211) & v245)
      + W_16
      + 961987163;
  v129 = v68 + v128;
  v195 = (v145 & (v179 | v162) | v179 & v162) + (__ROR4__(v179, 2) ^ __ROR4__(v179, 13) ^ __ROR4__(v179, 22)) + v68;
  v69 = (__ROR4__(v129, 6) ^ __ROR4__(v129, 11) ^ __ROR4__(v129, 25))
      + v211
      + (v228 ^ (v245 ^ v228) & v129)
      + W_20
      + 1508970993;
  v146 = v69 + v145;
  v212 = (v162 & (v195 | v179) | v195 & v179) + (__ROR4__(v195, 2) ^ __ROR4__(v195, 13) ^ __ROR4__(v195, 22)) + v69;
  v70 = (__ROR4__(v146, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25))
      + v228
      + (v245 ^ (v129 ^ v245) & v146)
      + W_24
      - 1841331548;
  v163 = v70 + v162;
  v229 = (v179 & (v212 | v195) | v212 & v195) + (__ROR4__(v212, 2) ^ __ROR4__(v212, 13) ^ __ROR4__(v212, 22)) + v70;
  v71 = (__ROR4__(v163, 6) ^ __ROR4__(v163, 11) ^ __ROR4__(v163, 25))
      + v245
      + (v129 ^ (v146 ^ v129) & v163)
      + W_28
      - 1424204075;
  v180 = v71 + v179;
  v246 = (v195 & (v229 | v212) | v229 & v212) + (__ROR4__(v229, 2) ^ __ROR4__(v229, 13) ^ __ROR4__(v229, 22)) + v71;
  v72 = (__ROR4__(v180, 6) ^ __ROR4__(v180, 11) ^ __ROR4__(v180, 25))
      + v129
      + (v146 ^ (v163 ^ v146) & v180)
      + W_32
      - 670586216;
  v196 = v72 + v195;
  v130 = (v212 & (v246 | v229) | v246 & v229) + (__ROR4__(v246, 2) ^ __ROR4__(v246, 13) ^ __ROR4__(v246, 22)) + v72;
  v73 = (__ROR4__(v196, 6) ^ __ROR4__(v196, 11) ^ __ROR4__(v196, 25))
      + v146
      + (v163 ^ (v180 ^ v163) & v196)
      + W_36
      + 310598401;
  v213 = v73 + v212;
  v147 = (v229 & (v130 | v246) | v130 & v246) + (__ROR4__(v130, 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22)) + v73;
  v74 = (__ROR4__(v213, 6) ^ __ROR4__(v213, 11) ^ __ROR4__(v213, 25))
      + v163
      + (v180 ^ (v196 ^ v180) & v213)
      + W_40
      + 607225278;
  v230 = v74 + v229;
  v164 = (v246 & (v147 | v130) | v147 & v130) + (__ROR4__(v147, 2) ^ __ROR4__(v147, 13) ^ __ROR4__(v147, 22)) + v74;
  v75 = (__ROR4__(v230, 6) ^ __ROR4__(v230, 11) ^ __ROR4__(v230, 25))
      + v180
      + (v196 ^ (v213 ^ v196) & v230)
      + W_44
      + 1426881987;
  v247 = v75 + v246;
  v181 = (v130 & (v164 | v147) | v164 & v147) + (__ROR4__(v164, 2) ^ __ROR4__(v164, 13) ^ __ROR4__(v164, 22)) + v75;
  v76 = (__ROR4__(v247, 6) ^ __ROR4__(v247, 11) ^ __ROR4__(v247, 25))
      + v196
      + (v213 ^ (v230 ^ v213) & v247)
      + W_48
      + 1925078388;
  v131 = v76 + v130;
  v197 = (v147 & (v181 | v164) | v181 & v164) + (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + v76;
  v77 = (__ROR4__(v131, 6) ^ __ROR4__(v131, 11) ^ __ROR4__(v131, 25))
      + v213
      + (v230 ^ (v247 ^ v230) & v131)
      + W_52
      - 2132889090;
  v148 = v77 + v147;
  v214 = (v164 & (v197 | v181) | v197 & v181) + (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + v77;
  v78 = (__ROR4__(v148, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25))
      + v230
      + (v247 ^ (v131 ^ v247) & v148)
      + W_56
      - 1680079193;
  v165 = v78 + v164;
  v231 = (v181 & (v214 | v197) | v214 & v197) + (__ROR4__(v214, 2) ^ __ROR4__(v214, 13) ^ __ROR4__(v214, 22)) + v78;
  v79 = (__ROR4__(v165, 6) ^ __ROR4__(v165, 11) ^ __ROR4__(v165, 25))
      + v247
      + (v131 ^ (v148 ^ v131) & v165)
      + W_60
      - 1046744716;
  v182 = v79 + v181;
  v248 = (v197 & (v231 | v214) | v231 & v214) + (__ROR4__(v231, 2) ^ __ROR4__(v231, 13) ^ __ROR4__(v231, 22)) + v79;
  W_64 = (__ROR4__(W_56, 17) ^ __ROR4__(W_56, 19) ^ (W_56 >> 10))
       + W_36
       + ((W_4 >> 3) ^ __ROR4__(W_4, 7) ^ __ROR4__(W_4, 18))
       + W;
  v80 = (__ROR4__(v182, 6) ^ __ROR4__(v182, 11) ^ __ROR4__(v182, 25))
      + v131
      + (v148 ^ (v165 ^ v148) & v182)
      + W_64
      - 459576895;
  v198 = v80 + v197;
  v132 = (v214 & (v248 | v231) | v248 & v231) + (__ROR4__(v248, 2) ^ __ROR4__(v248, 13) ^ __ROR4__(v248, 22)) + v80;
  W_68 = (__ROR4__(W_60, 17) ^ __ROR4__(W_60, 19) ^ (W_60 >> 10))
       + W_40
       + ((W_8 >> 3) ^ __ROR4__(W_8, 7) ^ __ROR4__(W_8, 18))
       + W_4;
  v81 = (__ROR4__(v198, 6) ^ __ROR4__(v198, 11) ^ __ROR4__(v198, 25))
      + v148
      + (v165 ^ (v182 ^ v165) & v198)
      + W_68
      - 272742522;
  v215 = v81 + v214;
  v149 = (v231 & (v132 | v248) | v132 & v248) + (__ROR4__(v132, 2) ^ __ROR4__(v132, 13) ^ __ROR4__(v132, 22)) + v81;
  W_72 = (__ROR4__(W_64, 17) ^ __ROR4__(W_64, 19) ^ (W_64 >> 10))
       + W_44
       + ((W_12 >> 3) ^ __ROR4__(W_12, 7) ^ __ROR4__(W_12, 18))
       + W_8;
  v82 = (__ROR4__(v215, 6) ^ __ROR4__(v215, 11) ^ __ROR4__(v215, 25))
      + v165
      + (v182 ^ (v198 ^ v182) & v215)
      + W_72
      + 264347078;
  v232 = v82 + v231;
  v166 = (v248 & (v149 | v132) | v149 & v132) + (__ROR4__(v149, 2) ^ __ROR4__(v149, 13) ^ __ROR4__(v149, 22)) + v82;
  W_76 = (__ROR4__(W_68, 17) ^ __ROR4__(W_68, 19) ^ (W_68 >> 10))
       + W_48
       + ((W_16 >> 3) ^ __ROR4__(W_16, 7) ^ __ROR4__(W_16, 18))
       + W_12;
  v83 = (__ROR4__(v232, 6) ^ __ROR4__(v232, 11) ^ __ROR4__(v232, 25))
      + v182
      + (v198 ^ (v215 ^ v198) & v232)
      + W_76
      + 604807628;
  v249 = v83 + v248;
  v183 = (v132 & (v166 | v149) | v166 & v149) + (__ROR4__(v166, 2) ^ __ROR4__(v166, 13) ^ __ROR4__(v166, 22)) + v83;
  W_80 = (__ROR4__(W_72, 17) ^ __ROR4__(W_72, 19) ^ (W_72 >> 10))
       + W_52
       + ((W_20 >> 3) ^ __ROR4__(W_20, 7) ^ __ROR4__(W_20, 18))
       + W_16;
  v84 = (__ROR4__(v249, 6) ^ __ROR4__(v249, 11) ^ __ROR4__(v249, 25))
      + v198
      + (v215 ^ (v232 ^ v215) & v249)
      + W_80
      + 770255983;
  v133 = v84 + v132;
  v199 = (v149 & (v183 | v166) | v183 & v166) + (__ROR4__(v183, 2) ^ __ROR4__(v183, 13) ^ __ROR4__(v183, 22)) + v84;
  W_84 = (__ROR4__(W_76, 17) ^ __ROR4__(W_76, 19) ^ (W_76 >> 10))
       + W_56
       + ((W_24 >> 3) ^ __ROR4__(W_24, 7) ^ __ROR4__(W_24, 18))
       + W_20;
  v85 = (__ROR4__(v133, 6) ^ __ROR4__(v133, 11) ^ __ROR4__(v133, 25))
      + v215
      + (v232 ^ (v249 ^ v232) & v133)
      + W_84
      + 1249150122;
  v150 = v85 + v149;
  v216 = (v166 & (v199 | v183) | v199 & v183) + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + v85;
  W_88 = (__ROR4__(W_80, 17) ^ __ROR4__(W_80, 19) ^ (W_80 >> 10))
       + W_60
       + ((W_28 >> 3) ^ __ROR4__(W_28, 7) ^ __ROR4__(W_28, 18))
       + W_24;
  v86 = (__ROR4__(v150, 6) ^ __ROR4__(v150, 11) ^ __ROR4__(v150, 25))
      + v232
      + (v249 ^ (v133 ^ v249) & v150)
      + W_88
      + 1555081692;
  v167 = v86 + v166;
  v233 = (v183 & (v216 | v199) | v216 & v199) + (__ROR4__(v216, 2) ^ __ROR4__(v216, 13) ^ __ROR4__(v216, 22)) + v86;
  W_92 = (__ROR4__(W_84, 17) ^ __ROR4__(W_84, 19) ^ (W_84 >> 10))
       + W_64
       + ((W_32 >> 3) ^ __ROR4__(W_32, 7) ^ __ROR4__(W_32, 18))
       + W_28;
  v87 = (__ROR4__(v167, 6) ^ __ROR4__(v167, 11) ^ __ROR4__(v167, 25))
      + v249
      + (v133 ^ (v150 ^ v133) & v167)
      + W_92
      + 1996064986;
  v184 = v87 + v183;
  v250 = (v199 & (v233 | v216) | v233 & v216) + (__ROR4__(v233, 2) ^ __ROR4__(v233, 13) ^ __ROR4__(v233, 22)) + v87;
  W_96 = (__ROR4__(W_88, 17) ^ __ROR4__(W_88, 19) ^ (W_88 >> 10))
       + W_68
       + ((W_36 >> 3) ^ __ROR4__(W_36, 7) ^ __ROR4__(W_36, 18))
       + W_32;
  v88 = (__ROR4__(v184, 6) ^ __ROR4__(v184, 11) ^ __ROR4__(v184, 25))
      + v133
      + (v150 ^ (v167 ^ v150) & v184)
      + W_96
      - 1740746414;
  v200 = v88 + v199;
  v134 = (v216 & (v250 | v233) | v250 & v233) + (__ROR4__(v250, 2) ^ __ROR4__(v250, 13) ^ __ROR4__(v250, 22)) + v88;
  W_100 = (__ROR4__(W_92, 17) ^ __ROR4__(W_92, 19) ^ (W_92 >> 10))
        + W_72
        + ((W_40 >> 3) ^ __ROR4__(W_40, 7) ^ __ROR4__(W_40, 18))
        + W_36;
  v89 = (__ROR4__(v200, 6) ^ __ROR4__(v200, 11) ^ __ROR4__(v200, 25))
      + v150
      + (v167 ^ (v184 ^ v167) & v200)
      + W_100
      - 1473132947;
  v217 = v89 + v216;
  v151 = (v233 & (v134 | v250) | v134 & v250) + (__ROR4__(v134, 2) ^ __ROR4__(v134, 13) ^ __ROR4__(v134, 22)) + v89;
  W_104 = (__ROR4__(W_96, 17) ^ __ROR4__(W_96, 19) ^ (W_96 >> 10))
        + W_76
        + ((W_44 >> 3) ^ __ROR4__(W_44, 7) ^ __ROR4__(W_44, 18))
        + W_40;
  v90 = (__ROR4__(v217, 6) ^ __ROR4__(v217, 11) ^ __ROR4__(v217, 25))
      + v167
      + (v184 ^ (v200 ^ v184) & v217)
      + W_104
      - 1341970488;
  v234 = v90 + v233;
  v168 = (v250 & (v151 | v134) | v151 & v134) + (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + v90;
  W_108 = (__ROR4__(W_100, 17) ^ __ROR4__(W_100, 19) ^ (W_100 >> 10))
        + W_80
        + ((W_48 >> 3) ^ __ROR4__(W_48, 7) ^ __ROR4__(W_48, 18))
        + W_44;
  v91 = (__ROR4__(v234, 6) ^ __ROR4__(v234, 11) ^ __ROR4__(v234, 25))
      + v184
      + (v200 ^ (v217 ^ v200) & v234)
      + W_108
      - 1084653625;
  v251 = v91 + v250;
  v185 = (v134 & (v168 | v151) | v168 & v151) + (__ROR4__(v168, 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + v91;
  W_112 = (__ROR4__(W_104, 17) ^ __ROR4__(W_104, 19) ^ (W_104 >> 10))
        + W_84
        + ((W_52 >> 3) ^ __ROR4__(W_52, 7) ^ __ROR4__(W_52, 18))
        + W_48;
  v92 = (__ROR4__(v251, 6) ^ __ROR4__(v251, 11) ^ __ROR4__(v251, 25))
      + v200
      + (v217 ^ (v234 ^ v217) & v251)
      + W_112
      - 958395405;
  v135 = v92 + v134;
  v201 = (v151 & (v185 | v168) | v185 & v168) + (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22)) + v92;
  W_116 = (__ROR4__(W_108, 17) ^ __ROR4__(W_108, 19) ^ (W_108 >> 10))
        + W_88
        + ((W_56 >> 3) ^ __ROR4__(W_56, 7) ^ __ROR4__(W_56, 18))
        + W_52;
  v93 = (__ROR4__(v135, 6) ^ __ROR4__(v135, 11) ^ __ROR4__(v135, 25))
      + v217
      + (v234 ^ (v251 ^ v234) & v135)
      + W_116
      - 710438585;
  v152 = v93 + v151;
  v218 = (v168 & (v201 | v185) | v201 & v185) + (__ROR4__(v201, 2) ^ __ROR4__(v201, 13) ^ __ROR4__(v201, 22)) + v93;
  W_120 = (__ROR4__(W_112, 17) ^ __ROR4__(W_112, 19) ^ (W_112 >> 10))
        + W_92
        + ((W_60 >> 3) ^ __ROR4__(W_60, 7) ^ __ROR4__(W_60, 18))
        + W_56;
  v94 = (__ROR4__(v152, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25))
      + v234
      + (v251 ^ (v135 ^ v251) & v152)
      + W_120
      + 113926993;
  v169 = v94 + v168;
  v235 = (v185 & (v218 | v201) | v218 & v201) + (__ROR4__(v218, 2) ^ __ROR4__(v218, 13) ^ __ROR4__(v218, 22)) + v94;
  W_124 = (__ROR4__(W_116, 17) ^ __ROR4__(W_116, 19) ^ (W_116 >> 10))
        + W_96
        + ((W_64 >> 3) ^ __ROR4__(W_64, 7) ^ __ROR4__(W_64, 18))
        + W_60;
  v95 = (__ROR4__(v169, 6) ^ __ROR4__(v169, 11) ^ __ROR4__(v169, 25))
      + v251
      + (v135 ^ (v152 ^ v135) & v169)
      + W_124
      + 338241895;
  v186 = v95 + v185;
  v252 = (v201 & (v235 | v218) | v235 & v218) + (__ROR4__(v235, 2) ^ __ROR4__(v235, 13) ^ __ROR4__(v235, 22)) + v95;
  W_128 = (__ROR4__(W_120, 17) ^ __ROR4__(W_120, 19) ^ (W_120 >> 10))
        + W_100
        + ((W_68 >> 3) ^ __ROR4__(W_68, 7) ^ __ROR4__(W_68, 18))
        + W_64;
  v96 = (__ROR4__(v186, 6) ^ __ROR4__(v186, 11) ^ __ROR4__(v186, 25))
      + v135
      + (v152 ^ (v169 ^ v152) & v186)
      + W_128
      + 666307205;
  v202 = v96 + v201;
  v136 = (v218 & (v252 | v235) | v252 & v235) + (__ROR4__(v252, 2) ^ __ROR4__(v252, 13) ^ __ROR4__(v252, 22)) + v96;
  W_132 = (__ROR4__(W_124, 17) ^ __ROR4__(W_124, 19) ^ (W_124 >> 10))
        + W_104
        + ((W_72 >> 3) ^ __ROR4__(W_72, 7) ^ __ROR4__(W_72, 18))
        + W_68;
  v97 = (__ROR4__(v202, 6) ^ __ROR4__(v202, 11) ^ __ROR4__(v202, 25))
      + v152
      + (v169 ^ (v186 ^ v169) & v202)
      + W_132
      + 773529912;
  v219 = v97 + v218;
  v153 = (v235 & (v136 | v252) | v136 & v252) + (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + v97;
  W_136 = (__ROR4__(W_128, 17) ^ __ROR4__(W_128, 19) ^ (W_128 >> 10))
        + W_108
        + ((W_76 >> 3) ^ __ROR4__(W_76, 7) ^ __ROR4__(W_76, 18))
        + W_72;
  v98 = (__ROR4__(v219, 6) ^ __ROR4__(v219, 11) ^ __ROR4__(v219, 25))
      + v169
      + (v186 ^ (v202 ^ v186) & v219)
      + W_136
      + 1294757372;
  v236 = v98 + v235;
  v170 = (v252 & (v153 | v136) | v153 & v136) + (__ROR4__(v153, 2) ^ __ROR4__(v153, 13) ^ __ROR4__(v153, 22)) + v98;
  W_140 = (__ROR4__(W_132, 17) ^ __ROR4__(W_132, 19) ^ (W_132 >> 10))
        + W_112
        + ((W_80 >> 3) ^ __ROR4__(W_80, 7) ^ __ROR4__(W_80, 18))
        + W_76;
  v99 = (__ROR4__(v236, 6) ^ __ROR4__(v236, 11) ^ __ROR4__(v236, 25))
      + v186
      + (v202 ^ (v219 ^ v202) & v236)
      + W_140
      + 1396182291;
  v253 = v99 + v252;
  v187 = (v136 & (v170 | v153) | v170 & v153) + (__ROR4__(v170, 2) ^ __ROR4__(v170, 13) ^ __ROR4__(v170, 22)) + v99;
  W_144 = (__ROR4__(W_136, 17) ^ __ROR4__(W_136, 19) ^ (W_136 >> 10))
        + W_116
        + ((W_84 >> 3) ^ __ROR4__(W_84, 7) ^ __ROR4__(W_84, 18))
        + W_80;
  v100 = (__ROR4__(v253, 6) ^ __ROR4__(v253, 11) ^ __ROR4__(v253, 25))
       + v202
       + (v219 ^ (v236 ^ v219) & v253)
       + W_144
       + 1695183700;
  v137 = v100 + v136;
  v203 = (v153 & (v187 | v170) | v187 & v170) + (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + v100;
  W_148 = (__ROR4__(W_140, 17) ^ __ROR4__(W_140, 19) ^ (W_140 >> 10))
        + W_120
        + ((W_88 >> 3) ^ __ROR4__(W_88, 7) ^ __ROR4__(W_88, 18))
        + W_84;
  v101 = (__ROR4__(v137, 6) ^ __ROR4__(v137, 11) ^ __ROR4__(v137, 25))
       + v219
       + (v236 ^ (v253 ^ v236) & v137)
       + W_148
       + 1986661051;
  v154 = v101 + v153;
  v220 = (v170 & (v203 | v187) | v203 & v187) + (__ROR4__(v203, 2) ^ __ROR4__(v203, 13) ^ __ROR4__(v203, 22)) + v101;
  W_152 = (__ROR4__(W_144, 17) ^ __ROR4__(W_144, 19) ^ (W_144 >> 10))
        + W_124
        + ((W_92 >> 3) ^ __ROR4__(W_92, 7) ^ __ROR4__(W_92, 18))
        + W_88;
  v102 = (__ROR4__(v154, 6) ^ __ROR4__(v154, 11) ^ __ROR4__(v154, 25))
       + v236
       + (v253 ^ (v137 ^ v253) & v154)
       + W_152
       - 2117940946;
  v171 = v102 + v170;
  v237 = (v187 & (v220 | v203) | v220 & v203) + (__ROR4__(v220, 2) ^ __ROR4__(v220, 13) ^ __ROR4__(v220, 22)) + v102;
  W_156 = (__ROR4__(W_148, 17) ^ __ROR4__(W_148, 19) ^ (W_148 >> 10))
        + W_128
        + ((W_96 >> 3) ^ __ROR4__(W_96, 7) ^ __ROR4__(W_96, 18))
        + W_92;
  v103 = (__ROR4__(v171, 6) ^ __ROR4__(v171, 11) ^ __ROR4__(v171, 25))
       + v253
       + (v137 ^ (v154 ^ v137) & v171)
       + W_156
       - 1838011259;
  v188 = v103 + v187;
  v254 = (v203 & (v237 | v220) | v237 & v220) + (__ROR4__(v237, 2) ^ __ROR4__(v237, 13) ^ __ROR4__(v237, 22)) + v103;
  W_160 = (__ROR4__(W_152, 17) ^ __ROR4__(W_152, 19) ^ (W_152 >> 10))
        + W_132
        + ((W_100 >> 3) ^ __ROR4__(W_100, 7) ^ __ROR4__(W_100, 18))
        + W_96;
  v104 = (__ROR4__(v188, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25))
       + v137
       + (v154 ^ (v171 ^ v154) & v188)
       + W_160
       - 1564481375;
  v204 = v104 + v203;
  v138 = (v220 & (v254 | v237) | v254 & v237) + (__ROR4__(v254, 2) ^ __ROR4__(v254, 13) ^ __ROR4__(v254, 22)) + v104;
  W_164 = (__ROR4__(W_156, 17) ^ __ROR4__(W_156, 19) ^ (W_156 >> 10))
        + W_136
        + ((W_104 >> 3) ^ __ROR4__(W_104, 7) ^ __ROR4__(W_104, 18))
        + W_100;
  v105 = (__ROR4__(v204, 6) ^ __ROR4__(v204, 11) ^ __ROR4__(v204, 25))
       + v154
       + (v171 ^ (v188 ^ v171) & v204)
       + W_164
       - 1474664885;
  v221 = v105 + v220;
  v155 = (v237 & (v138 | v254) | v138 & v254) + (__ROR4__(v138, 2) ^ __ROR4__(v138, 13) ^ __ROR4__(v138, 22)) + v105;
  W_168 = (__ROR4__(W_160, 17) ^ __ROR4__(W_160, 19) ^ (W_160 >> 10))
        + W_140
        + ((W_108 >> 3) ^ __ROR4__(W_108, 7) ^ __ROR4__(W_108, 18))
        + W_104;
  v106 = (__ROR4__(v221, 6) ^ __ROR4__(v221, 11) ^ __ROR4__(v221, 25))
       + v171
       + (v188 ^ (v204 ^ v188) & v221)
       + W_168
       - 1035236496;
  v238 = v106 + v237;
  v172 = (v254 & (v155 | v138) | v155 & v138) + (__ROR4__(v155, 2) ^ __ROR4__(v155, 13) ^ __ROR4__(v155, 22)) + v106;
  W_172 = (__ROR4__(W_164, 17) ^ __ROR4__(W_164, 19) ^ (W_164 >> 10))
        + W_144
        + ((W_112 >> 3) ^ __ROR4__(W_112, 7) ^ __ROR4__(W_112, 18))
        + W_108;
  v107 = (__ROR4__(v238, 6) ^ __ROR4__(v238, 11) ^ __ROR4__(v238, 25))
       + v188
       + (v204 ^ (v221 ^ v204) & v238)
       + W_172
       - 949202525;
  v255 = v107 + v254;
  v189 = (v138 & (v172 | v155) | v172 & v155) + (__ROR4__(v172, 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + v107;
  W_176 = (__ROR4__(W_168, 17) ^ __ROR4__(W_168, 19) ^ (W_168 >> 10))
        + W_148
        + ((W_116 >> 3) ^ __ROR4__(W_116, 7) ^ __ROR4__(W_116, 18))
        + W_112;
  v108 = (__ROR4__(v255, 6) ^ __ROR4__(v255, 11) ^ __ROR4__(v255, 25))
       + v204
       + (v221 ^ (v238 ^ v221) & v255)
       + W_176
       - 778901479;
  v139 = v108 + v138;
  v205 = (v155 & (v189 | v172) | v189 & v172) + (__ROR4__(v189, 2) ^ __ROR4__(v189, 13) ^ __ROR4__(v189, 22)) + v108;
  W_180 = (__ROR4__(W_172, 17) ^ __ROR4__(W_172, 19) ^ (W_172 >> 10))
        + W_152
        + ((W_120 >> 3) ^ __ROR4__(W_120, 7) ^ __ROR4__(W_120, 18))
        + W_116;
  v109 = (__ROR4__(v139, 6) ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25))
       + v221
       + (v238 ^ (v255 ^ v238) & v139)
       + W_180
       - 694614492;
  v156 = v109 + v155;
  v222 = (v172 & (v205 | v189) | v205 & v189) + (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + v109;
  W_184 = (__ROR4__(W_176, 17) ^ __ROR4__(W_176, 19) ^ (W_176 >> 10))
        + W_156
        + ((W_124 >> 3) ^ __ROR4__(W_124, 7) ^ __ROR4__(W_124, 18))
        + W_120;
  v110 = (__ROR4__(v156, 6) ^ __ROR4__(v156, 11) ^ __ROR4__(v156, 25))
       + v238
       + (v255 ^ (v139 ^ v255) & v156)
       + W_184
       - 200395387;
  v173 = v110 + v172;
  v239 = (v189 & (v222 | v205) | v222 & v205) + (__ROR4__(v222, 2) ^ __ROR4__(v222, 13) ^ __ROR4__(v222, 22)) + v110;
  W_188 = (__ROR4__(W_180, 17) ^ __ROR4__(W_180, 19) ^ (W_180 >> 10))
        + W_160
        + ((W_128 >> 3) ^ __ROR4__(W_128, 7) ^ __ROR4__(W_128, 18))
        + W_124;
  v111 = (__ROR4__(v173, 6) ^ __ROR4__(v173, 11) ^ __ROR4__(v173, 25))
       + v255
       + (v139 ^ (v156 ^ v139) & v173)
       + W_188
       + 275423344;
  v190 = v111 + v189;
  v256 = (v205 & (v239 | v222) | v239 & v222) + (__ROR4__(v239, 2) ^ __ROR4__(v239, 13) ^ __ROR4__(v239, 22)) + v111;
  W_192 = (__ROR4__(W_184, 17) ^ __ROR4__(W_184, 19) ^ (W_184 >> 10))
        + W_164
        + ((W_132 >> 3) ^ __ROR4__(W_132, 7) ^ __ROR4__(W_132, 18))
        + W_128;
  v112 = (__ROR4__(v190, 6) ^ __ROR4__(v190, 11) ^ __ROR4__(v190, 25))
       + v139
       + (v156 ^ (v173 ^ v156) & v190)
       + W_192
       + 430227734;
  v206 = v112 + v205;
  v140 = (v222 & (v256 | v239) | v256 & v239) + (__ROR4__(v256, 2) ^ __ROR4__(v256, 13) ^ __ROR4__(v256, 22)) + v112;
  W_196 = (__ROR4__(W_188, 17) ^ __ROR4__(W_188, 19) ^ (W_188 >> 10))
        + W_168
        + ((W_136 >> 3) ^ __ROR4__(W_136, 7) ^ __ROR4__(W_136, 18))
        + W_132;
  v113 = (__ROR4__(v206, 6) ^ __ROR4__(v206, 11) ^ __ROR4__(v206, 25))
       + v156
       + (v173 ^ (v190 ^ v173) & v206)
       + W_196
       + 506948616;
  v223 = v113 + v222;
  v157 = (v239 & (v140 | v256) | v140 & v256) + (__ROR4__(v140, 2) ^ __ROR4__(v140, 13) ^ __ROR4__(v140, 22)) + v113;
  W_200 = (__ROR4__(W_192, 17) ^ __ROR4__(W_192, 19) ^ (W_192 >> 10))
        + W_172
        + ((W_140 >> 3) ^ __ROR4__(W_140, 7) ^ __ROR4__(W_140, 18))
        + W_136;
  v114 = (__ROR4__(v223, 6) ^ __ROR4__(v223, 11) ^ __ROR4__(v223, 25))
       + v173
       + (v190 ^ (v206 ^ v190) & v223)
       + W_200
       + 659060556;
  v240 = v114 + v239;
  v174 = (v256 & (v157 | v140) | v157 & v140) + (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + v114;
  W_204 = (__ROR4__(W_196, 17) ^ __ROR4__(W_196, 19) ^ (W_196 >> 10))
        + W_176
        + ((W_144 >> 3) ^ __ROR4__(W_144, 7) ^ __ROR4__(W_144, 18))
        + W_140;
  v115 = (__ROR4__(v240, 6) ^ __ROR4__(v240, 11) ^ __ROR4__(v240, 25))
       + v190
       + (v206 ^ (v223 ^ v206) & v240)
       + W_204
       + 883997877;
  v257 = v115 + v256;
  v191 = (v140 & (v174 | v157) | v174 & v157) + (__ROR4__(v174, 2) ^ __ROR4__(v174, 13) ^ __ROR4__(v174, 22)) + v115;
  W_208 = (__ROR4__(W_200, 17) ^ __ROR4__(W_200, 19) ^ (W_200 >> 10))
        + W_180
        + ((W_148 >> 3) ^ __ROR4__(W_148, 7) ^ __ROR4__(W_148, 18))
        + W_144;
  v116 = (__ROR4__(v257, 6) ^ __ROR4__(v257, 11) ^ __ROR4__(v257, 25))
       + v206
       + (v223 ^ (v240 ^ v223) & v257)
       + W_208
       + 958139571;
  v141 = v116 + v140;
  v207 = (v157 & (v191 | v174) | v191 & v174) + (__ROR4__(v191, 2) ^ __ROR4__(v191, 13) ^ __ROR4__(v191, 22)) + v116;
  W_212 = (__ROR4__(W_204, 17) ^ __ROR4__(W_204, 19) ^ (W_204 >> 10))
        + W_184
        + ((W_152 >> 3) ^ __ROR4__(W_152, 7) ^ __ROR4__(W_152, 18))
        + W_148;
  v117 = (__ROR4__(v141, 6) ^ __ROR4__(v141, 11) ^ __ROR4__(v141, 25))
       + v223
       + (v240 ^ (v257 ^ v240) & v141)
       + W_212
       + 1322822218;
  v158 = v117 + v157;
  v224 = (v174 & (v207 | v191) | v207 & v191) + (__ROR4__(v207, 2) ^ __ROR4__(v207, 13) ^ __ROR4__(v207, 22)) + v117;
  W_216 = (__ROR4__(W_208, 17) ^ __ROR4__(W_208, 19) ^ (W_208 >> 10))
        + W_188
        + ((W_156 >> 3) ^ __ROR4__(W_156, 7) ^ __ROR4__(W_156, 18))
        + W_152;
  v118 = (__ROR4__(v158, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25))
       + v240
       + (v257 ^ (v141 ^ v257) & v158)
       + W_216
       + 1537002063;
  v175 = v118 + v174;
  v241 = (v191 & (v224 | v207) | v224 & v207) + (__ROR4__(v224, 2) ^ __ROR4__(v224, 13) ^ __ROR4__(v224, 22)) + v118;
  W_220 = (__ROR4__(W_212, 17) ^ __ROR4__(W_212, 19) ^ (W_212 >> 10))
        + W_192
        + ((W_160 >> 3) ^ __ROR4__(W_160, 7) ^ __ROR4__(W_160, 18))
        + W_156;
  v119 = (__ROR4__(v175, 6) ^ __ROR4__(v175, 11) ^ __ROR4__(v175, 25))
       + v257
       + (v141 ^ (v158 ^ v141) & v175)
       + W_220
       + 1747873779;
  v192 = v119 + v191;
  v258 = (v207 & (v241 | v224) | v241 & v224) + (__ROR4__(v241, 2) ^ __ROR4__(v241, 13) ^ __ROR4__(v241, 22)) + v119;
  W_224 = (__ROR4__(W_216, 17) ^ __ROR4__(W_216, 19) ^ (W_216 >> 10))
        + W_196
        + ((W_164 >> 3) ^ __ROR4__(W_164, 7) ^ __ROR4__(W_164, 18))
        + W_160;
  v120 = (__ROR4__(v192, 6) ^ __ROR4__(v192, 11) ^ __ROR4__(v192, 25))
       + v141
       + (v158 ^ (v175 ^ v158) & v192)
       + W_224
       + 1955562222;
  v208 = v120 + v207;
  v142 = (v224 & (v258 | v241) | v258 & v241) + (__ROR4__(v258, 2) ^ __ROR4__(v258, 13) ^ __ROR4__(v258, 22)) + v120;
  W_228 = (__ROR4__(W_220, 17) ^ __ROR4__(W_220, 19) ^ (W_220 >> 10))
        + W_200
        + ((W_168 >> 3) ^ __ROR4__(W_168, 7) ^ __ROR4__(W_168, 18))
        + W_164;
  v121 = (__ROR4__(v208, 6) ^ __ROR4__(v208, 11) ^ __ROR4__(v208, 25))
       + v158
       + (v175 ^ (v192 ^ v175) & v208)
       + W_228
       + 2024104815;
  v225 = v121 + v224;
  v159 = (v241 & (v142 | v258) | v142 & v258) + (__ROR4__(v142, 2) ^ __ROR4__(v142, 13) ^ __ROR4__(v142, 22)) + v121;
  W_232 = (__ROR4__(W_224, 17) ^ __ROR4__(W_224, 19) ^ (W_224 >> 10))
        + W_204
        + ((W_172 >> 3) ^ __ROR4__(W_172, 7) ^ __ROR4__(W_172, 18))
        + W_168;
  v122 = (__ROR4__(v225, 6) ^ __ROR4__(v225, 11) ^ __ROR4__(v225, 25))
       + v175
       + (v192 ^ (v208 ^ v192) & v225)
       + W_232
       - 2067236844;
  v242 = v122 + v241;
  v176 = (v258 & (v159 | v142) | v159 & v142) + (__ROR4__(v159, 2) ^ __ROR4__(v159, 13) ^ __ROR4__(v159, 22)) + v122;
  W_236 = (__ROR4__(W_228, 17) ^ __ROR4__(W_228, 19) ^ (W_228 >> 10))
        + W_208
        + ((W_176 >> 3) ^ __ROR4__(W_176, 7) ^ __ROR4__(W_176, 18))
        + W_172;
  v123 = (__ROR4__(v242, 6) ^ __ROR4__(v242, 11) ^ __ROR4__(v242, 25))
       + v192
       + (v208 ^ (v225 ^ v208) & v242)
       + W_236
       - 1933114872;
  v259 = v123 + v258;
  v193 = (v142 & (v176 | v159) | v176 & v159) + (__ROR4__(v176, 2) ^ __ROR4__(v176, 13) ^ __ROR4__(v176, 22)) + v123;
  W_240 = (__ROR4__(W_232, 17) ^ __ROR4__(W_232, 19) ^ (W_232 >> 10))
        + W_212
        + ((W_180 >> 3) ^ __ROR4__(W_180, 7) ^ __ROR4__(W_180, 18))
        + W_176;
  v124 = (__ROR4__(v259, 6) ^ __ROR4__(v259, 11) ^ __ROR4__(v259, 25))
       + v208
       + (v225 ^ (v242 ^ v225) & v259)
       + W_240
       - 1866530822;
  v143 = v124 + v142;
  v209 = (v159 & (v193 | v176) | v193 & v176) + (__ROR4__(v193, 2) ^ __ROR4__(v193, 13) ^ __ROR4__(v193, 22)) + v124;
  W_244 = (__ROR4__(W_236, 17) ^ __ROR4__(W_236, 19) ^ (W_236 >> 10))
        + W_216
        + ((W_184 >> 3) ^ __ROR4__(W_184, 7) ^ __ROR4__(W_184, 18))
        + W_180;
  v125 = (__ROR4__(v143, 6) ^ __ROR4__(v143, 11) ^ __ROR4__(v143, 25))
       + v225
       + (v242 ^ (v259 ^ v242) & v143)
       + W_244
       - 1538233109;
  v160 = v125 + v159;
  v226 = (v176 & (v209 | v193) | v209 & v193) + (__ROR4__(v209, 2) ^ __ROR4__(v209, 13) ^ __ROR4__(v209, 22)) + v125;
  v126 = (__ROR4__(v160, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25))
       + v242
       + (v259 ^ (v143 ^ v259) & v160)
       + (__ROR4__(W_240, 17) ^ __ROR4__(W_240, 19) ^ (W_240 >> 10))
       + W_220
       + ((W_188 >> 3) ^ __ROR4__(W_188, 7) ^ __ROR4__(W_188, 18))
       + W_184
       - 1090935817;
  v177 = v126 + v176;
  v243 = (v193 & (v226 | v209) | v226 & v209) + (__ROR4__(v226, 2) ^ __ROR4__(v226, 13) ^ __ROR4__(v226, 22)) + v126;
  v127 = (__ROR4__(v177, 6) ^ __ROR4__(v177, 11) ^ __ROR4__(v177, 25))
       + v259
       + (v143 ^ (v160 ^ v143) & v177)
       + (__ROR4__(W_244, 17) ^ __ROR4__(W_244, 19) ^ (W_244 >> 10))
       + W_224
       + ((W_192 >> 3) ^ __ROR4__(W_192, 7) ^ __ROR4__(W_192, 18))
       + W_188
       - 965641998;
  *((_DWORD *)ctx + 2) += (v209 & (v243 | v226) | v243 & v226)
                        + (__ROR4__(v243, 2) ^ __ROR4__(v243, 13) ^ __ROR4__(v243, 22))
                        + v127;
  *((_DWORD *)ctx + 3) += v243;
  *((_DWORD *)ctx + 4) += v226;
  *((_DWORD *)ctx + 5) += v209;
  *((_DWORD *)ctx + 6) += v127 + v193;
  *((_DWORD *)ctx + 7) += v177;
  *((_DWORD *)ctx + 8) += v160;
  *((_DWORD *)ctx + 9) += v143;
}

//----- (0003282C) --------------------------------------------------------
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  int v3; // [sp+4h] [bp+4h]
  const unsigned __int8 *src; // [sp+8h] [bp+8h]
  int n; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  src = input;
  v3 = ilen;
  if ( ilen > 0 )
  {
    v7 = *(_DWORD *)ctx & 0x3F;
    n = 64 - v7;
    *(_DWORD *)ctx += ilen;
    *(_DWORD *)ctx = *(_DWORD *)ctx;
    if ( *(_DWORD *)ctx < (unsigned int)ilen )
      ++*((_DWORD *)ctx + 1);
    if ( v7 && ilen >= n )
    {
      memcpy((char *)ctx + v7 + 40, input, n);
      sha2_process(ctx, (const unsigned __int8 *)ctx + 40);
      src += n;
      v3 -= n;
      v7 = 0;
    }
    while ( v3 > 63 )
    {
      sha2_process(ctx, src);
      src += 64;
      v3 -= 64;
    }
    if ( v3 > 0 )
      memcpy((char *)ctx + v7 + 40, src, v3);
  }
}

//----- (000328FC) --------------------------------------------------------
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  int v2; // r3
  unsigned __int8 v5[8]; // [sp+8h] [bp+8h] BYREF
  int v6; // [sp+10h] [bp+10h]
  unsigned int v7; // [sp+14h] [bp+14h]
  __int64 v8; // [sp+18h] [bp+18h]

  v8 = 8LL * *(_QWORD *)ctx;
  v5[0] = HIBYTE(v8);
  v5[1] = BYTE6(v8);
  v5[2] = BYTE5(v8);
  v5[3] = BYTE4(v8);
  v5[4] = BYTE3(v8);
  v5[5] = BYTE2(v8);
  v5[6] = BYTE1(v8);
  v5[7] = v8;
  v7 = *(_DWORD *)ctx & 0x3F;
  if ( v7 > 0x37 )
    v2 = 120 - v7;
  else
    v2 = 56 - v7;
  v6 = v2;
  sha2_update(ctx, sha2_padding, v2);
  sha2_update(ctx, v5, 8);
  *output = HIBYTE(*((_DWORD *)ctx + 2));
  output[1] = BYTE2(*((_DWORD *)ctx + 2));
  output[2] = BYTE1(*((_DWORD *)ctx + 2));
  output[3] = *((_DWORD *)ctx + 2);
  output[4] = HIBYTE(*((_DWORD *)ctx + 3));
  output[5] = BYTE2(*((_DWORD *)ctx + 3));
  output[6] = BYTE1(*((_DWORD *)ctx + 3));
  output[7] = *((_DWORD *)ctx + 3);
  output[8] = HIBYTE(*((_DWORD *)ctx + 4));
  output[9] = BYTE2(*((_DWORD *)ctx + 4));
  output[10] = BYTE1(*((_DWORD *)ctx + 4));
  output[11] = *((_DWORD *)ctx + 4);
  output[12] = HIBYTE(*((_DWORD *)ctx + 5));
  output[13] = BYTE2(*((_DWORD *)ctx + 5));
  output[14] = BYTE1(*((_DWORD *)ctx + 5));
  output[15] = *((_DWORD *)ctx + 5);
  output[16] = HIBYTE(*((_DWORD *)ctx + 6));
  output[17] = BYTE2(*((_DWORD *)ctx + 6));
  output[18] = BYTE1(*((_DWORD *)ctx + 6));
  output[19] = *((_DWORD *)ctx + 6);
  output[20] = HIBYTE(*((_DWORD *)ctx + 7));
  output[21] = BYTE2(*((_DWORD *)ctx + 7));
  output[22] = BYTE1(*((_DWORD *)ctx + 7));
  output[23] = *((_DWORD *)ctx + 7);
  output[24] = HIBYTE(*((_DWORD *)ctx + 8));
  output[25] = BYTE2(*((_DWORD *)ctx + 8));
  output[26] = BYTE1(*((_DWORD *)ctx + 8));
  output[27] = *((_DWORD *)ctx + 8);
  output[28] = HIBYTE(*((_DWORD *)ctx + 9));
  output[29] = BYTE2(*((_DWORD *)ctx + 9));
  output[30] = BYTE1(*((_DWORD *)ctx + 9));
  output[31] = *((_DWORD *)ctx + 9);
}
// 36D94: using guessed type unsigned __int8 sha2_padding[64];

//----- (00032B50) --------------------------------------------------------
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  char ctx[232]; // [sp+10h] [bp+10h] BYREF

  sha2_starts((sha2_context *)ctx);
  sha2_update((sha2_context *)ctx, input, ilen);
  sha2_finish((sha2_context *)ctx, output);
  memset(ctx, 0, sizeof(ctx));
}

//----- (00032B98) --------------------------------------------------------
unsigned int __fastcall swab32(unsigned int a1)
{
  return bswap32(a1);
}

//----- (00032BB0) --------------------------------------------------------
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; length >> 2 > i; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00032C00) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00032C48) --------------------------------------------------------
int __fastcall slt_notify_ui(int result, int a2)
{
  char v2[1024]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 1 )
  {
    snprintf(v2, 0x400u, "pass %d bin %d\n", result, a2);
    return applog(2, v2, 0);
  }
  return result;
}
// 47C84: using guessed type int opt_log_level;
// 4843C: using guessed type char use_syslog;
// 4843F: using guessed type char opt_log_output;

//----- (00032CB8) --------------------------------------------------------
int slt_init()
{
  return 0;
}

//----- (00032CC8) --------------------------------------------------------
int slt_exit()
{
  return 0;
}

//----- (00032CD8) --------------------------------------------------------
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *v3; // r2
  signed int i; // [sp+14h] [bp+14h]

  for ( i = 0; i < (int)len; ++i )
  {
    *s = hex_6139[p[i] >> 4];
    v3 = s + 1;
    s += 2;
    *v3 = hex_6139[p[i] & 0xF];
  }
  *s = 0;
}
// 3720C: using guessed type _BYTE hex_6139[16];

//----- (00032D4C) --------------------------------------------------------
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *v5; // [sp+8h] [bp+8h]
  unsigned int nmemb; // [sp+Ch] [bp+Ch]

  nmemb = 2 * len + 1;
  if ( (nmemb & 3) != 0 )
    nmemb = (nmemb & 0xFFFFFFFC) + 4;
  v5 = (unsigned __int8 *)calloc(nmemb, 1u);
  if ( !v5 )
    fwrite("Failed to calloc", 1u, 0x10u, (FILE *)_bss_start);
  _bin2hex(v5, p, len);
  return v5;
}
// 47DA8: using guessed type int _bss_start;

//----- (00032DB4) --------------------------------------------------------
int __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len)
{
  const unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r3
  int v10; // [sp+10h] [bp+10h]
  int v11; // [sp+14h] [bp+14h]
  int v12; // [sp+1Ch] [bp+1Ch]

  v12 = 0;
  while ( *hexstr && len )
  {
    if ( !hexstr[1] )
      return 0;
    v11 = hex2bin_tbl[*hexstr];
    v4 = hexstr + 1;
    hexstr += 2;
    v10 = hex2bin_tbl[*v4];
    if ( v11 < 0 || v10 < 0 )
      return 0;
    v5 = p++;
    *v5 = v10 | (16 * v11);
    --len;
  }
  if ( !len && !*hexstr )
    return 1;
  return v12;
}
// 36DF8: using guessed type _DWORD hex2bin_tbl[256];

//----- (00032E68) --------------------------------------------------------
unsigned __int8 __cdecl swap_bit(unsigned __int8 chr)
{
  int i; // [sp+8h] [bp+8h]
  unsigned __int8 v3; // [sp+Fh] [bp+Fh]

  v3 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( (((int)chr >> i) & 1) != 0 )
      v3 |= 1 << (7 - i);
  }
  return v3;
}

//----- (00032EC0) --------------------------------------------------------
void __fastcall dump_str(FILE *a1, const char *a2, const unsigned __int8 *a3, size_t a4)
{
  unsigned __int8 *ptr; // [sp+1Ch] [bp+14h]

  if ( a1 )
  {
    ptr = bin2hex(a3, a4);
    if ( a2 )
      fprintf(a1, "%s %s len=%d\n", a2, (const char *)ptr, a4);
    else
      fprintf(a1, "%s\n", (const char *)ptr);
    fflush(a1);
    free(ptr);
  }
}

//----- (00032F24) --------------------------------------------------------
unsigned __int8 __cdecl bit_read(unsigned __int8 *y, int x)
{
  int v2; // r3
  unsigned __int8 v3; // r3

  v2 = x & 7;
  if ( x <= 0 )
    v2 = -(-x & 7);
  switch ( v2 )
  {
    case 0:
      v3 = (y[x / 8] & 1) != 0;
      break;
    case 1:
      v3 = (y[x / 8] & 2) != 0;
      break;
    case 2:
      v3 = (y[x / 8] & 4) != 0;
      break;
    case 3:
      v3 = (y[x / 8] & 8) != 0;
      break;
    case 4:
      v3 = (y[x / 8] & 0x10) != 0;
      break;
    case 5:
      v3 = (y[x / 8] & 0x20) != 0;
      break;
    case 6:
      v3 = (y[x / 8] & 0x40) != 0;
      break;
    case 7:
      v3 = y[x / 8] >> 7;
      break;
    default:
      v3 = 0;
      break;
  }
  return v3;
}

//----- (000330A4) --------------------------------------------------------
void __cdecl swab256(void *dest_p, void *src_p)
{
  *(_DWORD *)dest_p = bswap32(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = bswap32(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = bswap32(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = bswap32(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = bswap32(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = bswap32(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = bswap32(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = bswap32(*(_DWORD *)src_p);
}

//----- (000333AE) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_333F0 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 333B2: variable 'v2' is possibly undefined

//----- (00033658) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00033664) --------------------------------------------------------
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp)
{
  int i; // r4
  void (__fastcall *v4)(); // r3

  init_proc();
  for ( i = 0; i != 1; ++i )
  {
    v4 = (void (__fastcall *)())*(&_frame_dummy_init_array_entry + i);
    v4();
  }
}
// 47228: using guessed type void *_frame_dummy_init_array_entry;

//----- (000336A8) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=404 queued=275 decompiled=275 lumina nreq=0 worse=0 better=0
// ALL OK, 275 function(s) have been successfully decompiled
