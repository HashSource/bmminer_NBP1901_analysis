/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>
#include <sys/time.h>
#include <stdio.h>
#include <pthread.h>
#include <openssl/sha.h>
#include <semaphore.h>
#include <klist.h>

//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_9F68();
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int open(const char *file, int oflag, ...);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// const __int32_t **_ctype_toupper_loc(void);
// int fileno(FILE *stream);
// int mkdir(const char *path, __mode_t mode);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// void abort(void);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void srand(unsigned int seed);
// struct tm *localtime(const time_t *timer);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int memcmp(const void *s1, const void *s2, size_t n);
// int sysconf(int name);
void sub_A054(int pri, const char *fmt, ...); // idb
// void syslog(int pri, const char *fmt, ...);
int sub_A064(clockid_t clock_id, struct timespec *tp); // idb
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int _isinf(double value);
int sub_A098(void); // weak
// int sched_yield(void);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// in_addr_t inet_addr(const char *cp);
char *sub_A0CC(char *dest, const char *src, size_t n); // idb
// char *strncpy(char *dest, const char *src, size_t n);
int sub_A0DC(FILE *stream); // idb
// int fclose(FILE *stream);
// char *fgets(char *s, int n, FILE *stream);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *getenv(const char *name);
// double strtod(const char *nptr, char **endptr);
int sub_A11C(const char *command); // idb
// int system(const char *command);
// char *strchr(const char *s, int c);
// int putchar(int c);
// int strcasecmp(const char *s1, const char *s2);
// char *dirname(char *path);
// int setlogmask(int mask);
// int listen(int fd, int n);
// void *calloc(size_t nmemb, size_t size);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
void *sub_A1BC(void *s, int c, size_t n); // idb
// void *memset(void *s, int c, size_t n);
int sub_A1CC(sem_t *sem); // idb
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// void freeaddrinfo(struct addrinfo *ai);
// void perror(const char *s);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// double floor(double x);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// double exp(double x);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int usleep(__useconds_t useconds);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
void j_free(void *ptr);
// void free(void *ptr);
// int access(const char *name, int type);
// void openlog(const char *ident, int option, int facility);
// int inet_pton(int af, const char *cp, void *buf);
int j_gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int sem_trywait(sem_t *sem);
// int fseek(FILE *stream, int off, int whence);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
int j_pthread_mutex_unlock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int round(void); weak
// int socket(int domain, int type, int protocol);
// int execl(const char *path, const char *arg, ...);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fflush(FILE *stream);
// int ioctl(int fd, unsigned int request, ...);
// int isatty(int fd);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int sscanf(const char *s, const char *format, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
int j_pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int execv(const char *path, char *const argv[]);
// int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
void *j_memcpy(void *dest, const void *src, size_t n);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// const __int32_t **_ctype_tolower_loc(void);
// struct lconv *localeconv(void);
// int ftell(FILE *stream);
// int fgetc(FILE *stream);
int j_strtol(const char *nptr, char **endptr, int base);
// int strtol(const char *nptr, char **endptr, int base);
char *j_strcpy(char *dest, const char *src);
// char *strcpy(char *dest, const char *src);
// int sem_post(sem_t *sem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// char *strncat(char *dest, const char *src, size_t n);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
int j_printf(const char *format, ...);
// int printf(const char *format, ...);
// int raise(int sig);
// void errx(int status, const char *format, ...);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int shutdown(int fd, int how);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// FILE *fdopen(int fd, const char *modes);
// char *strstr(const char *haystack, const char *needle);
// int nice(int inc);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int _isnan(double value);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// time_t time(time_t *timer);
// double log10(double x);
// const unsigned __int16 **_ctype_b_loc(void);
// int fprintf(FILE *stream, const char *format, ...);
void *j_malloc(size_t size);
// void *malloc(size_t size);
// int sigaction_0(int sig, const struct sigaction *act, struct sigaction *oact);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
unsigned int j_sleep(unsigned int seconds);
// unsigned int sleep(unsigned int seconds);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// char *strcat(char *dest, const char *src);
// void *memmove(void *dest, const void *src, size_t n);
// void pthread_testcancel(void);
// int dup2(int fd, int fd2);
// int puts(const char *s);
// int prctl(int option, ...);
int j_fcntl(int fd, int cmd, ...);
// int fcntl(int fd, int cmd, ...);
// __pid_t fork(void);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int rand(void);
// int munmap(void *addr, size_t len);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
int j_snprintf(char *s, size_t maxlen, const char *format, ...);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int strncmp(const char *s1, const char *s2, size_t n);
// int kill(__pid_t pid, int sig);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_detach(pthread_t th);
void *j_realloc(void *ptr, size_t size);
// void *realloc(void *ptr, size_t size);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_setcancelstate(int state, int *oldstate);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int sysinfo_0(struct sysinfo *info);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int pipe(int pipedes[2]);
char *j___strdup(const char *s);
// char *_strdup(const char *s);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// char *strpbrk(const char *s, const char *accept);
// int sem_wait(sem_t *sem);
int j_strcmp(const char *s1, const char *s2);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int pthread_setcanceltype(int type, int *oldtype);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int *_errno_location(void);
// pthread_t pthread_self(void);
// int pthread_cancel(pthread_t th);
// int sprintf(char *s, const char *format, ...);
// int pthread_join(pthread_t th, void **thread_return);
void __fastcall __noreturn mutex_lock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn mutex_lock_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn rw_unlock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn mutex_unlock_noyield_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
pool *__fastcall priority_pool_0(int choice);
void free_work_0(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void __noreturn restart_threads_0();
void __fastcall __noreturn mutex_unlock_noyield_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn mutex_lock_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn wr_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn mutex_init(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn rwlock_init(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn rw_unlock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn rd_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn mutex_init_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn rw_unlock_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn mutex_unlock_noyield_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall __noreturn mutex_lock_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl main(int argc, const char **argv, const char **envp);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_gmon_start();
int *deregister_tm_clones();
__int64 register_tm_clones();
int *_do_global_dtors_aux();
__int64 frame_dummy();
void __fastcall sha2_starts(sha2_context *ctx);
void __fastcall sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __fastcall sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __fastcall sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __fastcall sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
unsigned int __fastcall crc16(const unsigned __int8 *buffer, int len);
void __fastcall applog(int prio, const unsigned __int8 *str, bool force);
void mutex_unlock_noyield(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void mutex_lock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force); // idb
void __fastcall simplelog(int prio, const unsigned __int8 *str, bool force);
void __fastcall k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__fastcall k_new_store(K_LIST *list);
K_LIST *__fastcall k_new_list(const unsigned __int8 *name, size_t siz, int allocate, int limit, bool do_tail, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__fastcall k_unlink_head(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__fastcall k_unlink_head_zero(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__fastcall k_unlink_tail(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall k_add_head(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall k_add_tail(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall k_insert_before(K_LIST *list, K_ITEM *item, K_ITEM *before, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall k_insert_after(K_LIST *list, K_ITEM *item, K_ITEM *after, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall k_unlink_item(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall k_list_transfer_to_head(K_LIST *from, K_LIST *to, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall k_list_transfer_to_tail(K_LIST *from, K_LIST *to, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__fastcall k_free_list(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__fastcall k_free_store(K_LIST *store, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __fastcall sha256_init(sha256_ctx *ctx);
void __fastcall sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __fastcall sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __fastcall sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
int no_yield(); // idb
void __fastcall clear_sockbuf(pool *pool);
bool __fastcall socket_full(pool *pool, int wait);
void __fastcall block_socket(int fd);
int __fastcall recv_byte(int sockd);
bool __fastcall http_negotiate(pool *pool, int sockd, bool http0);
void __fastcall nanosleep_abstime(timespec *ts_end);
unsigned __int8 *__fastcall _json_array_string(json_t_0 *val, unsigned int entry);
unsigned __int8 *__fastcall json_array_string(json_t_0 *val, unsigned int entry);
bool valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void rw_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void wr_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void mutex_unlock_noyield_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
send_ret __fastcall _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
void __fastcall clear_sock(pool *pool);
void __fastcall tq_freezethaw(thread_q *tq, bool frozen);
void *__fastcall cgmalloc(unsigned int size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__fastcall cgcalloc(int memb, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__fastcall cgrealloc(void *ptr, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
const unsigned __int8 *__fastcall proxytype(proxytypes_t proxytype);
void __fastcall _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len);
unsigned __int8 *__fastcall bin2hex(const unsigned __int8 *p, size_t len);
bool __fastcall hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len);
void __fastcall b58tobin(unsigned __int8 *b58bin, const unsigned __int8 *b58);
int __fastcall ser_number(unsigned __int8 *s, int32_t val);
bool __fastcall fulltest(const unsigned __int8 *hash, const unsigned __int8 *target);
thread_q *tq_new(); // idb
void __fastcall tq_free(thread_q *tq);
void __fastcall tq_freeze(thread_q *tq);
void __fastcall tq_thaw(thread_q *tq);
bool __fastcall tq_push(thread_q *tq, void *data);
void *__fastcall tq_pop(thread_q *tq, const timespec *abstime);
void __fastcall thr_info_cancel(thr_info *thr);
void __fastcall subtime(timeval *a, timeval *b);
void __fastcall addtime(timeval *a, timeval *b);
bool __fastcall time_more(timeval *a, timeval *b);
bool __fastcall time_less(timeval *a, timeval *b);
void __fastcall timespec_to_val(timeval *val, const timespec *spec);
void __fastcall timeval_to_spec(timespec *spec, const timeval *val);
void __fastcall us_to_timeval(timeval *val, int a2, int64_t us);
void __fastcall us_to_timespec(timespec *spec, int a2, int64_t us);
void __fastcall ms_to_timespec(timespec *spec, int a2, int64_t ms);
void __fastcall ms_to_timeval(timeval *val, int a2, int64_t ms);
void __fastcall timeraddspec(timespec *a, const timespec *b);
unsigned __int8 *__fastcall Strcasestr(unsigned __int8 *haystack, const unsigned __int8 *needle);
unsigned __int8 *__fastcall Strsep(unsigned __int8 **stringp, const unsigned __int8 *delim);
void __fastcall cgtime(timeval *tv);
int __fastcall cgtimer_to_ms(cgtimer_t *cgt);
void __fastcall cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res);
void __fastcall cgtimer_time(cgtimer_t *ts_start);
void __fastcall cgsleep_ms_r(cgtimer_t *ts_start, int ms);
void __fastcall cgsleep_us_r(cgtimer_t *ts_start, int a2, int64_t us);
void __fastcall cgsleep_ms(int ms);
void __fastcall cgsleep_us(int64_t us);
double __fastcall us_tdiff(timeval *end, timeval *start);
int __fastcall ms_tdiff(timeval *end, timeval *start);
double __fastcall tdiff(timeval *end, timeval *start);
bool __fastcall extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port);
unsigned __int8 *__fastcall get_proxy(unsigned __int8 *url, pool *pool);
bool __fastcall sock_full(pool *pool);
void __fastcall recalloc(void **ptr, size_t old, size_t news, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall suspend_stratum(pool *pool);
unsigned __int8 *__fastcall recv_line(pool *pool);
bool __fastcall stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
void __fastcall dev_error(cgpu_info *dev, dev_reason reason);
void *__fastcall realloc_strcat(unsigned __int8 *ptr, unsigned __int8 *s);
void *__fastcall str_text(unsigned __int8 *ptr);
void __fastcall RenameThread(const unsigned __int8 *name);
void __fastcall cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __fastcall thr_info_create(thr_info *thr, pthread_attr_t *attr, void *(*start)(void *), void *arg);
void __fastcall cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__fastcall completion_thread(void *arg);
void __fastcall cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __fastcall cgsem_mswait(cgsem_t *cgsem, int ms, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall cgsem_reset(cgsem_t *cgsem);
bool __fastcall cg_completion_timeout(void *fn, void *fnarg, int timeout);
void __fastcall cg_memcpy(void *dest, const void *src, unsigned int n, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __fastcall socks4_negotiate(pool *pool, int sockd, bool socks4a);
bool __fastcall initiate_stratum(pool *pool);
bool __fastcall parse_notify(pool *pool, json_t_0 *val);
bool __fastcall parse_method(pool *pool, unsigned __int8 *s);
bool __fastcall auth_stratum(pool *pool);
bool __fastcall subscribe_extranonce(pool *pool);
bool __fastcall restart_stratum(pool *pool);
bool __fastcall parse_reconnect(pool *pool, json_t_0 *val);
void __fastcall copy_time(timeval *dest, const timeval *src);
unsigned __int8 *__fastcall ser_string(unsigned __int8 *s, int *slen);
void __fastcall address_to_pubkeyhash(unsigned __int8 *pkh, const unsigned __int8 *addr);
int __fastcall cg_timeval_subtract(timeval *result, timeval *x, timeval *y);
void __fastcall rev(unsigned __int8 *s, size_t l);
int __fastcall check_asicnum(int asic_num, unsigned __int8 nonce);
void __fastcall cg_logwork(work *work, unsigned __int8 *nonce_bin, bool ok);
void __fastcall cg_logwork_uint32(work *work, unsigned int nonce, bool ok);
char *read_config();
void __fastcall writeLogFile(unsigned __int8 *logstr);
void *__fastcall receive_func(void *arg);
int __fastcall doTestBoard(int test_times);
int process_config(); // idb
int get_works(); // idb
int configMiner(); // idb
bool __fastcall clement_doTestBoard(bool showlog);
bool __fastcall clement_doTestBoardOnce(bool showlog);
unsigned __int8 *__fastcall escape_string(unsigned __int8 *str, bool isjson);
void __fastcall add_item_buf(K_ITEM *item, const unsigned __int8 *str);
bool __fastcall io_add(io_data *io_data, unsigned __int8 *buf);
void __fastcall head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin);
bool __fastcall io_put(io_data *io_data, unsigned __int8 *buf);
void __fastcall dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
bool __fastcall check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group);
void __fastcall send_result(io_data *io_data, int c, bool isjson);
void mcast(); // idb
void *__fastcall mcast_thread(void *userdata);
api_data *__fastcall api_add_data_full(api_data *root, unsigned __int8 *name, api_data_type type, void *data, bool copy_data);
void __fastcall tail_join(io_data *io_data, bool isjson);
void __fastcall copyadvanceafter(unsigned __int8 **ch, unsigned __int8 **param, unsigned __int8 **buf);
bool __fastcall pooldetails(unsigned __int8 *param, unsigned __int8 **url, unsigned __int8 **user, unsigned __int8 **pass);
void rd_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void mutex_unlock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void *__fastcall restart_thread(void *userdata);
void *__fastcall quit_thread(void *userdata);
void __fastcall tidyup(void *arg);
api_data *__fastcall print_data(io_data *io_data, api_data *root, bool isjson, bool precom);
api_data *__fastcall api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__fastcall api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__fastcall api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data);
api_data *__fastcall api_add_uint8(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__fastcall api_add_int16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data);
api_data *__fastcall api_add_uint16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data);
api_data *__fastcall api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data);
api_data *__fastcall api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__fastcall api_add_uint32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__fastcall api_add_hex32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__fastcall api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data);
api_data *__fastcall api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data);
api_data *__fastcall api_add_double(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__fastcall api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__fastcall api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data);
api_data *__fastcall api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data);
api_data *__fastcall api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data);
void __fastcall message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson);
void __fastcall lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
api_data *__fastcall api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
void __fastcall lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
int itemstats(io_data *io_data, int i, unsigned __int8 *id, cgminer_stats *stats, cgminer_pool_stats *pool_stats, api_data *extra, cgpu_info *cgpu, bool isjson); // idb
void __fastcall minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
api_data *__fastcall api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__fastcall api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
api_data *__fastcall api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__fastcall api_add_freq(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__fastcall api_add_volts(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
api_data *__fastcall api_add_hs(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__fastcall api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
void __fastcall minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
api_data *__fastcall api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
void __fastcall summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __fastcall poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
api_data *__fastcall api_add_avg(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
void __fastcall notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group);
void __fastcall notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void mcast_init(); // idb
void reCalculateAVG(); // idb
void __fastcall api(int api_thr_id);
unsigned __int8 *__fastcall set_balance(pool_strategy *strategy);
unsigned __int8 *__fastcall set_loadbalance(pool_strategy *strategy);
unsigned __int8 *__fastcall set_rr(pool_strategy *strategy);
unsigned __int8 *__fastcall enable_debug(bool *flag);
unsigned __int8 *__fastcall set_null(const unsigned __int8 *arg);
void __fastcall noop_reinit_device(cgpu_info *cgpu);
void __fastcall blank_get_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
void __fastcall noop_get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
bool __fastcall noop_get_stats(cgpu_info *cgpu);
bool __fastcall noop_thread_prepare(thr_info *thr);
uint64_t __fastcall noop_can_limit_work(thr_info *thr);
bool __fastcall noop_thread_init(thr_info *thr);
bool __fastcall noop_prepare_work(thr_info *thr, work *work);
void __fastcall noop_hw_error(thr_info *thr);
void __fastcall noop_thread_shutdown(thr_info *thr);
void __fastcall noop_thread_enable(thr_info *thr);
void __fastcall noop_detect(bool hotplug);
api_data *__fastcall noop_get_api_stats(cgpu_info *cgpu);
void __fastcall noop_hash_work(thr_info *thr);
void __fastcall generic_zero_stats(cgpu_info *cgpu);
bool __fastcall new_nonce(thr_info *thr, unsigned int nonce);
unsigned __int8 *__fastcall json_escape(unsigned __int8 *str);
void __fastcall thread_reportin(thr_info *thr);
void __fastcall thread_reportout(thr_info *thr);
unsigned __int8 *__fastcall set_default_config(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_logfile_path(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_logwork_asicnum(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_logwork_path(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_logfile_openflag(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_version_path(const unsigned __int8 *arg);
void __fastcall __noreturn opt_verusage_and_exit(const unsigned __int8 *a1);
unsigned __int8 *__fastcall set_sharelog(unsigned __int8 *arg);
void *__fastcall submit_work_thread(void *userdata);
void __fastcall get_benchmark_work(work *work);
void __fastcall suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits);
void __fastcall sub_1DEA4(work *a1, double a2);
void calc_diff(work *work, double known); // idb
void __fastcall benchfile_dspwork(work *work, unsigned int nonce);
bool should_run(); // idb
void __fastcall regen_hash(work *work);
void __fastcall calc_midstate(work *work);
void *__fastcall killall_thread(void *arg);
void __noreturn errlog(const char *a1, ...);
void __fastcall mt_disable(thr_info *mythr, const int thr_id, device_drv *drv);
void *__fastcall start(void *userdata);
bool __fastcall pool_unusable(pool *pool);
pool *__fastcall select_balanced(pool *cp);
pool *__fastcall priority_pool(int choice);
unsigned __int8 *__fastcall load_config(const unsigned __int8 *arg, void *unused);
unsigned __int8 *__fastcall parse_config(json_t_0 *config, bool fileconf);
void set_lowprio_0(); // idb
void set_lowprio(); // idb
void *__fastcall api_thread(void *userdata);
unsigned __int8 *__fastcall set_float_100_to_250(const unsigned __int8 *arg, float *i);
unsigned __int8 *__fastcall set_float_125_to_500(const unsigned __int8 *arg, float *i);
unsigned __int8 *__fastcall set_sched_stop(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_sched_start(const unsigned __int8 *arg);
void __fastcall get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv);
void adjust_quota_gcd(); // idb
unsigned __int8 *__fastcall set_int_range(const unsigned __int8 *arg, int *i, int min, int max);
unsigned __int8 *__fastcall set_rotate(const unsigned __int8 *arg, unsigned __int8 *i);
unsigned __int8 *__fastcall set_int_0_to_9999(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_0_to_100(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_1_to_65535(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_42_to_65(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_22_to_55(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_42_to_85(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_22_to_75(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_32_to_63(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_0_to_4(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_0_to_200(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_0_to_7680(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_1_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_0_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_1_to_10(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall set_int_0_to_10(const unsigned __int8 *arg, int *i);
void __fastcall get_intrange(unsigned __int8 *arg, int *val1, int *val2);
bool __fastcall detect_stratum(pool *pool, unsigned __int8 *url);
unsigned __int8 *__fastcall setup_url(pool *pool, unsigned __int8 *arg);
unsigned __int8 *__fastcall set_temp_cutoff(unsigned __int8 *arg);
void __fastcall clean_work(work *work);
void __fastcall copy_work(work *work, const work *base_work, int noffset);
void __fastcall free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall decay_time(double f, double fadd, double fsecs, double interval);
double __fastcall cgpu_runtime(cgpu_info *cgpu);
double tsince_restart(); // idb
double tsince_update(); // idb
void __fastcall set_work_ntime(work *work, int ntime);
uint64_t __fastcall share_ndiff(const work *work);
void __fastcall discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __fastcall remove_pool(pool *pool);
void __fastcall write_config(FILE *fcfg);
void zero_bestshare(); // idb
void __fastcall default_save_file(unsigned __int8 *filename);
void set_target(unsigned __int8 *dest_target, double diff); // idb
int __fastcall share_work_tdiff(cgpu_info *cgpu);
bool __fastcall test_nonce(work *work, unsigned int nonce);
bool test_nonce_diff(work *work, unsigned int nonce, double diff); // idb
void __fastcall cg_savelogwork(work *work, unsigned __int8 *nonce_bin);
void __fastcall cg_savelogwork_uint32(work *work, unsigned int nonce);
bool __fastcall savelog_nonce(work *work, unsigned int nonce);
void __fastcall _add_queued(cgpu_info *cgpu, work *work);
work *__fastcall _find_work_bymidstate(work *que, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
work *__fastcall _find_work_byid(work *que, unsigned int id);
void __fastcall _work_completed(cgpu_info *cgpu, work *work);
void __fastcall reinit_device(cgpu_info *cgpu);
void __fastcall quit(int status);
void restart_threads(); // idb
bool __fastcall benchfile_get_work(work *work);
void __fastcall get_benchfile_work(work *work);
void __fastcall get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
void __noreturn kill_work();
void __fastcall sighandler(int sig);
int __fastcall restart_wait(thr_info *thr, unsigned int mstime);
work *__fastcall hash_pop(bool blocking);
void __fastcall inc_hw_errors(thr_info *thr);
void __fastcall inc_hw_errors_with_diff(thr_info *thr, int diff);
void wake_gws(); // idb
void __fastcall inc_dev_status(int max_fan, int max_temp);
bool __fastcall pool_tset(pool *pool, bool *var);
bool __fastcall pool_tclear(pool *pool, bool *var);
bool __fastcall pool_active(pool *pool, bool pinging);
void __fastcall clear_stratum_shares(pool *pool);
void __fastcall clear_pool_work(pool *pool);
void mutex_init_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void rwlock_init_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
pool *add_pool(); // idb
unsigned __int8 *__fastcall set_userpass(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_user(const unsigned __int8 *arg);
pool *add_url(); // idb
unsigned __int8 *__fastcall set_url(unsigned __int8 *arg);
unsigned __int8 *__fastcall set_quota(unsigned __int8 *arg);
unsigned __int8 *__fastcall set_pass(const unsigned __int8 *arg);
unsigned __int8 *__fastcall set_extranonce_subscribe(unsigned __int8 *arg);
void rd_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line); // idb
void __fastcall flush_queue(cgpu_info *cgpu);
int age_queued_work(cgpu_info *cgpu, double secs); // idb
void __fastcall work_completed(cgpu_info *cgpu, work *work);
void __fastcall add_queued(cgpu_info *cgpu, work *work);
work *__fastcall take_queued_work_bymidstate(cgpu_info *cgpu, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
void __fastcall switch_pools(pool *selected);
unsigned int total_work_inc();
void __fastcall roll_work(work *work);
work *make_work(); // idb
work *__fastcall copy_work_noffset(work *base_work, int noffset);
work *__fastcall make_clone(work *work);
uint64_t __fastcall share_diff(const work *work);
void __fastcall update_work_stats(thr_info *thr, work *work);
bool __fastcall submit_nonce_1(thr_info *thr, work *work, unsigned int nonce, int *nofull);
work *__fastcall clone_queued_work_bymidstate(cgpu_info *cgpu, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
void __fastcall gen_stratum_work(pool *pool, work *work);
void __fastcall get_work_by_nonce2(thr_info *thr, work **work, pool *pool, pool *real_pool, uint64_t nonce2, unsigned int ntime, unsigned int version);
work *__fastcall clone_queued_work_byid(cgpu_info *cgpu, unsigned int id);
thr_info *__fastcall get_thread(int thr_id);
void _kill_work_0(); // idb
void _kill_work(); // idb
void kill_mining(); // idb
int __fastcall dev_from_id(int thr_id);
void __fastcall sharelog(const unsigned __int8 *disposition, const work *work);
cgpu_info *__fastcall get_devices(int id);
void zero_stats(); // idb
void __fastcall hashmeter(int thr_id, int a2, uint64_t hashes_done);
void __fastcall hash_driver_work(thr_info *mythr);
void print_summary(); // idb
void __fastcall clean_up(bool restarting);
void __fastcall __noreturn _quit(int a1, int a2);
void app_restart(); // idb
work *__fastcall find_queued_work_bymidstate(cgpu_info *cgpu, unsigned __int8 *midstate, size_t midstatelen, unsigned __int8 *data, int offset, size_t datalen);
work *__fastcall find_queued_work_byid(cgpu_info *cgpu, unsigned int id);
int cp_prio(); // idb
void __fastcall pool_resus(pool *pool);
void __fastcall stratum_resumed(pool *pool);
pool *current_pool(); // idb
bool __fastcall cnx_needed(pool *pool);
bool __fastcall test_work_current(work *work);
void __fastcall stage_work(work *work);
void __fastcall inc_work_stats(thr_info *thr, pool *pool, int diff1);
void __fastcall pool_died(pool *pool);
void *__fastcall start_routine(void *arg);
void *__fastcall watchpool_thread(void *userdata);
void *__fastcall stratum_rthread(void *userdata);
void *__fastcall stratum_sthread(void *userdata);
bool __fastcall stale_work(work *work, bool share);
void discard_stale(); // idb
void *__fastcall restart_thread_0(void *arg);
void *__fastcall watchdog_thread(void *userdata);
work *__fastcall _get_queued(cgpu_info *cgpu);
work *__fastcall get_queued(cgpu_info *cgpu);
work *__fastcall get_work(thr_info *thr, const int thr_id);
void __fastcall hash_queued_work(thr_info *mythr);
work *__fastcall get_queue_work(thr_info *thr, cgpu_info *cgpu, int thr_id);
void __fastcall hash_sole_work(thr_info *mythr);
void __fastcall submit_work_async(work *work);
bool __fastcall submit_noffset_nonce(thr_info *thr, work *work_in, unsigned int nonce, int noffset);
bool __fastcall submit_nonce_direct(thr_info *thr, work *work, unsigned int nonce);
void __fastcall submit_nonce_2(work *work);
bool __fastcall submit_tested_work(thr_info *thr, work *work);
bool __fastcall submit_nonce(thr_info *thr, work *work, unsigned int nonce);
bool __fastcall add_pool_details(pool *pool, bool live, unsigned __int8 *url, unsigned __int8 *user, unsigned __int8 *pass);
void __fastcall fill_device_drv(device_drv *drv);
void __fastcall null_device_drv(device_drv *drv);
void __fastcall enable_device(cgpu_info *cgpu);
bool __fastcall add_cgpu(cgpu_info *cgpu);
device_drv *__fastcall copy_drv(device_drv *drv);
void setStartTimePoint(); // idb
int64_t __fastcall bitmain_c5_scanhash(thr_info *thr);
void __fastcall bitmain_c5_reinit_device(cgpu_info *bitmain);
void __fastcall bitmain_c5_detect(bool hotplug);
void __fastcall block_socket_0(int fd);
void __fastcall set_nonce2_and_job_id_store_address_0(unsigned int value);
void __fastcall check_chain_0(int a1, int a2, int a3, const char *a4);
int __fastcall calculate_core_number_0(unsigned int actual_core_number);
void *send_mac(); // idb
void suffix_string_c5(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display); // idb
int get_macBytes(unsigned __int8 *device, unsigned __int8 *mac); // idb
void get_plldata(int type, int freq, unsigned int *reg_data, uint16_t *reg_data2, unsigned int *vil_data); // idb
void __fastcall copy_pool_stratum(pool *pool_stratum, pool *pool);
void *__fastcall bitmain_scanhash(void *arg);
char __fastcall getMeddleOffsetForTestPatten(int chainIndex);
bool isFixedFreqMode(); // idb
bool isC5_Board(); // idb
uint16_t __fastcall CRC16(const unsigned __int8 *p_data, uint16_t w_len);
unsigned __int8 __fastcall CRC5(unsigned __int8 *ptr, unsigned __int8 len);
unsigned __int8 __fastcall getPICvoltageFromValue(int vol_value);
int __fastcall getVolValueFromPICvoltage(unsigned __int8 vol_pic);
int __fastcall getVoltageLimitedFromHashrate(int hashrate_GHz);
int __fastcall getFixedFreqVoltageValue(int freq);
void __fastcall getPICChainIndexOffset(int chainIndex, int *pChain, int *pOffset);
int __fastcall getChainAsicFreqIndex(int chainIndex, int asicIndex);
unsigned int get_pic_iic(); // idb
unsigned __int8 __fastcall set_pic_iic(unsigned int data);
unsigned __int8 __fastcall write_pic_iic(bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 chain, unsigned __int8 data);
void __fastcall send_pic_command(unsigned __int8 chain);
void __fastcall send_data_to_pic_iic(unsigned __int8 chain, unsigned __int8 command, unsigned __int8 *buf, unsigned __int8 length);
void __fastcall get_data_from_pic_iic(unsigned __int8 chain, unsigned __int8 command, unsigned __int8 *buf, unsigned __int8 length);
void __fastcall send_data_to_pic_flash(unsigned __int8 chain, unsigned __int8 *buf);
void __fastcall get_data_from_pic_flash(unsigned __int8 chain, unsigned __int8 *buf);
unsigned __int8 __fastcall erase_pic_flash(unsigned __int8 chain);
void __fastcall set_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value);
unsigned __int8 __fastcall write_data_into_pic_flash(unsigned __int8 chain);
void __fastcall get_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 *addr_H, unsigned __int8 *addr_L);
unsigned __int8 __fastcall getHighestVoltagePIC(int chainIndex);
void __fastcall set_voltage_setting_time(unsigned __int8 chain, unsigned __int8 *time);
void __fastcall set_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id);
void __fastcall write_host_MAC_and_time(unsigned __int8 chain, unsigned __int8 *buf);
void __fastcall enable_pic_dc_dc(unsigned __int8 chain);
void enable_pic_dc_dc_all(); // idb
int __fastcall getChainPICMagicNumber(int chainIndex);
api_data *__fastcall bitmain_api_stats(cgpu_info *cgpu);
unsigned int get_iic(); // idb
unsigned __int8 __fastcall set_iic(unsigned int data);
unsigned __int8 __fastcall write_EEPROM_iic(bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 data);
unsigned __int8 __fastcall AT24C02_read_one_byte(unsigned __int8 address, unsigned __int8 which_iic);
unsigned __int8 __fastcall AT24C02_read_voltage(unsigned __int8 which_iic);
unsigned __int8 __fastcall get_pic_voltage(unsigned __int8 chain);
void __fastcall AT24C02_read_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 length);
void __fastcall get_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id);
unsigned __int8 __fastcall read_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf);
void __fastcall get_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value);
void __fastcall AT24C02_write_one_byte(unsigned __int8 address, unsigned __int8 data, unsigned __int8 which_iic);
void __fastcall AT24C02_save_voltage(unsigned __int8 which_iic, unsigned __int8 voltage);
void __fastcall AT24C02_write_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 length);
unsigned __int8 __fastcall save_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf);
unsigned __int8 __fastcall T9_plus_write_pic_iic(bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 data);
int __fastcall dsPIC33EP16GS202_pic_heart_beat(unsigned __int8 which_iic);
void __fastcall pic_heart_beat_each_chain(unsigned __int8 chain);
void __noreturn pic_heart_beat_func();
unsigned int get_nonce2_and_job_id_store_address();
void __fastcall set_nonce2_and_job_id_store_address(unsigned int value);
unsigned int get_job_start_address();
void __fastcall set_job_start_address(unsigned int value);
void __fastcall set_bmc_counter(unsigned int value);
unsigned int read_bmc_counter(); // idb
unsigned int get_QN_write_data_command();
void __fastcall set_QN_write_data_command(unsigned int value);
int bitmain_axi_init(); // idb
int bitmain_axi_close(); // idb
unsigned int get_fan_control();
void __fastcall set_fan_control(unsigned int value);
unsigned int get_hash_on_plug();
unsigned int get_crc_count(); // idb
int get_hardware_version(); // idb
void __fastcall set_Hardware_version(unsigned int value);
int __fastcall get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed);
unsigned int get_temperature_0_3();
unsigned int get_temperature_4_7();
unsigned int get_temperature_8_11();
unsigned int get_temperature_12_15();
unsigned int get_time_out_control();
void __fastcall set_time_out_control(unsigned int value);
int __fastcall get_BC_command_buffer(unsigned int *buf);
void __fastcall set_BC_command_buffer(unsigned int *value);
unsigned int get_nonce_number_in_fifo();
int __fastcall get_return_nonce(unsigned int *buf);
unsigned int get_BC_write_command();
unsigned int get_ticket_mask();
void __fastcall set_ticket_mask(unsigned int value);
unsigned int get_job_id();
void __fastcall set_job_id(unsigned int value);
unsigned int get_job_length();
void __fastcall set_job_length(unsigned int value);
unsigned int get_block_header_version();
void __fastcall set_block_header_version(unsigned int value);
unsigned int get_time_stamp();
void __fastcall set_time_stamp(unsigned int value);
unsigned int get_target_bits();
void __fastcall set_target_bits(unsigned int value);
int __fastcall get_pre_header_hash(unsigned int *buf);
void __fastcall set_pre_header_hash(unsigned int *value);
unsigned int get_coinbase_length_and_nonce2_length();
void __fastcall set_coinbase_length_and_nonce2_length(unsigned int value);
int __fastcall get_work_nonce2(unsigned int *buf);
void __fastcall set_work_nonce2(unsigned int *value);
int get_merkle_bin_number(); // idb
void __fastcall set_merkle_bin_number(unsigned int value);
unsigned int get_nonce_fifo_interrupt();
void __fastcall set_nonce_fifo_interrupt(unsigned int value);
unsigned int get_dhash_acc_control();
void __fastcall set_dhash_acc_control(unsigned int value);
void __fastcall set_TW_write_command(unsigned int *value);
void __fastcall set_TW_write_command_vil(unsigned int *value);
unsigned int get_buffer_space();
unsigned int get_hash_counting_number();
void __fastcall set_hash_counting_number(unsigned int value);
void check_chain(); // idb
void check_fan(); // idb
void __fastcall set_PWM(unsigned __int8 pwm_percent);
void CheckChainTempTooLowFlag(); // idb
int __fastcall get_pll_index(int freq);
int __fastcall get_freqvalue_by_index(int index);
int GetTotalRate(); // idb
int __fastcall GetBoardRate(int chainIndex);
bool isChainEnough(); // idb
void __fastcall writeInitLogFile(unsigned __int8 *logstr);
int DownOneChipFreqOneStep();
void __fastcall set_BC_write_command(unsigned int value);
void __fastcall bitmain_c5_shutdown(thr_info *thr);
void __fastcall set_frequency_with_addr_plldatai(int pllindex, unsigned __int8 mode, unsigned __int8 addr, unsigned __int8 chain);
int bitmain_axi_Reinit(); // idb
void __fastcall set_reset_allhashboard(int resetBit);
void __fastcall set_reset_hashboard(int chainIndex, int resetBit);
int __fastcall dsPIC33EP16GS202_send_data_to_pic(unsigned __int8 which_iic, unsigned __int8 *buf);
int __fastcall dsPIC33EP16GS202_erase_pic_app_program(unsigned __int8 which_iic);
int __fastcall dsPIC33EP16GS202_enable_pic_dc_dc(unsigned __int8 which_iic, unsigned __int8 enable);
void __fastcall disable_pic_dac(unsigned __int8 chain);
void __fastcall enable_pic_dac(unsigned __int8 chain);
int __fastcall set_Voltage_S9_plus_plus_BM1387_54(unsigned __int8 which_iic, unsigned __int8 pic_voltage);
void __fastcall set_voltage_T9_18_into_PIC(unsigned __int8 chain, unsigned __int8 voltage);
void __fastcall set_pic_voltage_T9_18(unsigned __int8 chain);
void __fastcall set_pic_voltage(unsigned __int8 chain, unsigned __int8 voltage);
int __fastcall dsPIC33EP16GS202_reset_pic(unsigned __int8 which_iic);
int __fastcall dsPIC33EP16GS202_update_pic_app_program(unsigned __int8 which_iic);
unsigned __int8 __fastcall reset_iic_pic(unsigned __int8 chain);
int __fastcall dsPIC33EP16GS202_jump_to_app_from_loader(unsigned __int8 which_iic);
int __fastcall dsPIC33EP16GS202_get_pic_sw_version(unsigned __int8 which_iic, unsigned __int8 *version);
void __fastcall get_pic_software_version(unsigned __int8 chain, unsigned __int8 *version);
void __fastcall jump_to_app_CheckAndRestorePIC_T9_18(int chainIndex);
void __fastcall set_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 addr_H, unsigned __int8 addr_L);
unsigned __int8 __fastcall erase_pic_flash_all(unsigned __int8 chain);
void clearInitLogFile(); // idb
void __fastcall set_frequency(unsigned __int16 frequency);
void __fastcall set_frequency_with_addr(unsigned __int16 frequency, unsigned __int8 mode, unsigned __int8 addr, unsigned __int8 chain);
void clear_nonce_fifo(); // idb
void clear_register_value_buf(); // idb
void __noreturn get_nonce_and_register();
void __fastcall read_asic_register(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 chip_addr, unsigned __int8 reg_addr);
void __fastcall read_temp(unsigned __int8 device, unsigned int reg, unsigned __int8 data, unsigned __int8 write, unsigned __int8 chip_addr, int chain);
void __fastcall reset_one_hashboard(int chainIndex);
bool __fastcall check_asic_reg_oneChain(int chainIndex, unsigned int reg);
unsigned int __fastcall check_asic_reg_with_addr(unsigned int reg, unsigned int chip_addr, unsigned int chain, int check_num);
unsigned int __fastcall wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update);
unsigned int __fastcall check_reg_temp(unsigned __int8 device, unsigned int reg, unsigned __int8 data, unsigned __int8 write, unsigned __int8 chip_addr, int chain);
int8_t __fastcall calc_offset(int remote, int local);
int16_t __fastcall get_remote(int16_t remote);
int16_t __fastcall get_local(int16_t local);
int8_t __fastcall do_calibration_sensor_offset(unsigned __int8 device, unsigned __int8 chip_addr, int chain, int temp_chip_index);
void __fastcall set_baud_with_addr(unsigned __int8 bauddiv, int mode, unsigned __int8 chip_addr, int chain, int iic, int open_core, int bottom_or_mid);
int8_t __fastcall calibration_sensor_offset_0(unsigned __int8 device, int chain);
int8_t __fastcall calibration_sensor_offset(unsigned __int8 device, int chain);
void clearTempLogFile(); // idb
void __fastcall writeLogFile_0(unsigned __int8 *logstr);
bool __fastcall check_asic_reg(unsigned int reg);
void showAllBadRTInfo(); // idb
void set_PWM_according_to_temperature(); // idb
void setChainTempTooLowFlag(); // idb
int isTempTooLow();
void updateLogFile(); // idb
void __fastcall saveTestID(int testID);
FILE *readTestID();
int __fastcall fakeMiddleTempFromPCB(int local_temp);
void __fastcall chain_inactive(unsigned __int8 chain);
void __fastcall set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address);
int __fastcall calculate_asic_number(unsigned int actual_asic_number);
int __fastcall calculate_core_number(unsigned int actual_core_number);
void __fastcall software_set_address_onChain(int chainIndex);
void software_set_address(); // idb
void __fastcall set_asic_ticket_mask(unsigned int ticket_mask);
void __fastcall set_hcnt(unsigned int hcnt);
void __fastcall set_baud(unsigned __int8 bauddiv, int no_use);
void init_uart_baud(); // idb
void __fastcall set_led(bool stop);
void change_pic_voltage_old(); // idb
int __fastcall get_asic_nonce_num(int chain, int asic, int timeslice);
void __fastcall get_lastn_nonce_num(unsigned __int8 *dest, int n);
void __noreturn check_system_work();
bool if_hashrate_ok(); // idb
bool check_hashrate_maybe_ok(double level); // idb
void __fastcall saveRebootTestNum(int num);
int readRebootTestNum(); // idb
void __fastcall saveRestartNum(int num);
int readRestartNum(); // idb
void __fastcall open_core(bool nullwork_enable);
void __fastcall open_core_one_chain(int chainIndex, bool nullwork_enable);
void bitmain_reinit_test(); // idb
void __fastcall open_core_onChain(int chainIndex, int coreNum, int opencore_num, bool nullwork_enable);
void __fastcall opencore_onebyone_onChain(int chainIndex);
void __fastcall insert_reg_data(unsigned int *buf);
int __fastcall getChainAsicNum(int chainIndex);
int __fastcall getChainExistFlag(int chainIndex);
void bitmain_reinit(); // idb
void __fastcall saveSearchFailedFlagInfo(unsigned __int8 *search_failed_info);
int __cdecl bitmain_c5_init(init_config config);
bool __fastcall bitmain_c5_prepare(thr_info *thr);
int __fastcall parse_job_to_c5(unsigned __int8 **buf, pool *pool, unsigned int id);
int __fastcall send_job(unsigned __int8 *buf);
void __fastcall bitmain_c5_update(cgpu_info *bitmain_c5);
void re_send_last_job(); // idb
void bitmain_core_reInit(); // idb
void doReInitTest(); // idb
void do8xPattenTest(); // idb
void processTEST(); // idb
void __noreturn read_temp_func();
void __fastcall remove_dot_char(unsigned __int8 *number);
void __fastcall add_dot_number(unsigned __int8 *number);
void __fastcall dupalloc(cgpu_info *cgpu, int timelimit);
void __fastcall dupcounters(cgpu_info *cgpu, uint64_t *checked, uint64_t *dups);
bool __fastcall isdupnonce(cgpu_info *cgpu, work *work, unsigned int nonce);
unsigned __int8 *__fastcall arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg);
unsigned __int8 *__fastcall opt_set_bool(bool *b);
unsigned __int8 *__fastcall opt_set_false(bool *b);
unsigned __int8 *__fastcall opt_set_invbool(bool *b);
unsigned __int8 *__fastcall opt_set_bool_arg(const unsigned __int8 *arg, bool *b);
unsigned __int8 *__fastcall opt_set_invbool_arg(const unsigned __int8 *arg, bool *b);
unsigned __int8 *__fastcall opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p);
unsigned __int8 *__fastcall opt_set_floatval(const unsigned __int8 *arg, float *f);
unsigned __int8 *__fastcall opt_set_longval(const unsigned __int8 *arg, int *l);
unsigned __int8 *__fastcall opt_set_intval(const unsigned __int8 *arg, int *i);
unsigned __int8 *__fastcall opt_set_uintval(const unsigned __int8 *arg, unsigned int *ui);
unsigned __int8 *__fastcall opt_set_ulongval(const unsigned __int8 *arg, unsigned int *ul);
unsigned __int8 *__fastcall opt_inc_intval(int *i);
unsigned __int8 *__fastcall opt_version_and_exit(const unsigned __int8 *version);
unsigned __int8 *__fastcall opt_usage_and_exit(const unsigned __int8 *extra);
void __fastcall opt_show_bool(unsigned __int8 *buf, const bool *b);
void __fastcall opt_show_invbool(unsigned __int8 *buf, const bool *b);
void __fastcall opt_show_charp(unsigned __int8 *buf, unsigned __int8 *const *p);
void __fastcall opt_show_intval(unsigned __int8 *buf, const int *i);
void __fastcall opt_show_floatval(unsigned __int8 *buf, const float *f);
void __fastcall opt_show_uintval(unsigned __int8 *buf, const unsigned int *ui);
void __fastcall opt_show_longval(unsigned __int8 *buf, const int *l);
void __fastcall opt_show_ulongval(unsigned __int8 *buf, const unsigned int *ul);
const unsigned __int8 *__fastcall next_name(const unsigned __int8 *names, unsigned int *len);
const unsigned __int8 *__fastcall first_opt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__fastcall next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__fastcall check_opt(const unsigned __int8 *result);
void __fastcall add_opt(const opt_table *entry);
const unsigned __int8 *__fastcall first_lopt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__fastcall next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__fastcall first_sopt(unsigned int *i);
const unsigned __int8 *__fastcall next_sopt(const unsigned __int8 *p, unsigned int *i);
void __fastcall opt_register(const unsigned __int8 *names, opt_type type, unsigned __int8 *(*cb)(void *), unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *), void (*show)(unsigned __int8 *, const void *), const void *arg, const unsigned __int8 *desc);
void __fastcall opt_register_table(const opt_table *entry, const unsigned __int8 *desc);
bool __fastcall opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...));
void opt_free_table(); // idb
void opt_log_stderr(const unsigned __int8 *fmt, ...);
void opt_log_stderr_exit(const unsigned __int8 *fmt, ...);
unsigned __int8 *__fastcall opt_invalid_argument(const unsigned __int8 *arg);
unsigned __int8 *__fastcall opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra);
void __fastcall consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum);
int __fastcall parse_one(int *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
void set_error(scanner_t *s, const unsigned __int8 *source, const unsigned __int8 *msg, ...);
void __fastcall next_token(scanner_t *s);
int __fastcall unpack(scanner_t *s, json_t_0 *root, va_list *ap);
unsigned __int8 *__fastcall read_string(scanner_t *s, va_list *ap, const unsigned __int8 *purpose, int *ours);
json_t_0 *__fastcall pack(scanner_t *s, va_list *ap);
json_t_0 *__fastcall json_vpack_ex(json_error_t *error, size_t flags, const unsigned __int8 *fmt, va_list ap);
json_t_0 *json_pack_ex(json_error_t *error, size_t flags, const unsigned __int8 *a3, ...);
json_t_0 *json_pack(const unsigned __int8 *fmt, ...);
int json_vunpack_ex(json_t_0 *root, json_error_t *error, size_t flags, const unsigned __int8 *fmt, va_list ap); // idb
int json_unpack_ex(json_t_0 *root, json_error_t *error, size_t flags, const unsigned __int8 *a4, ...);
int json_unpack(json_t_0 *root, const unsigned __int8 *a2, ...);
int __fastcall strbuffer_init(strbuffer_t *strbuff);
void __fastcall strbuffer_close(strbuffer_t *strbuff);
void __fastcall strbuffer_clear(strbuffer_t *strbuff);
const unsigned __int8 *__fastcall strbuffer_value(const strbuffer_t *strbuff);
unsigned __int8 *__fastcall strbuffer_steal_value(strbuffer_t *strbuff);
int __fastcall strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size);
int __fastcall strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte);
int __fastcall strbuffer_append(strbuffer_t *strbuff, const unsigned __int8 *string);
unsigned __int8 __fastcall strbuffer_pop(strbuffer_t *strbuff);
void __fastcall jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source);
void __fastcall jsonp_error_init(json_error_t *error, const unsigned __int8 *source);
void jsonp_error_vset(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, va_list ap); // idb
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...);
int __fastcall jsonp_strtod(int a1, double *a2);
int jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value); // idb
void __fastcall json_object_seed(size_t seed);
int __fastcall get(void *data);
int __fastcall buffer_get(void *data);
int __fastcall callback_get(void *data);
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *a3, ...);
int __fastcall lex_init(lex_t *lex, get_func get, void *data);
void __fastcall lex_close(lex_t *lex);
int __fastcall decode_unicode_escape(_BYTE *a1);
_DWORD *__fastcall stream_unget(_DWORD *result, int a2);
int __fastcall stream_get(const lex_t *a1, json_error_t *a2);
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2);
int __fastcall lex_get_save(lex_t *lex, json_error_t *error);
int __fastcall lex_scan(lex_t *lex, json_error_t *error);
json_t_0 *__fastcall parse_value(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__fastcall parse_json(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__fastcall json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error);
json_t_0 *__fastcall json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error);
json_t_0 *__fastcall json_loadf(FILE *input, size_t flags, json_error_t *error);
json_t_0 *__fastcall json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error);
json_t_0 *__fastcall json_load_callback(json_load_callback_t callback, void *arg, size_t flags, json_error_t *error);
int __fastcall compar(const void *key1, const void *key2);
int __fastcall dump_string(const unsigned __int8 *str, json_dump_callback_t dump, void *data, size_t flags);
int __fastcall object_key_compare_keys(const void *key1, const void *key2);
int __fastcall dump_to_file(const unsigned __int8 *buffer, size_t size, void *data);
int __fastcall callback(const unsigned __int8 *buffer, size_t size, void *data);
int __fastcall dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data);
int __fastcall do_dump(int a1, size_t a2, int a3, int (*a4)(const unsigned __int8 *, size_t, void *), void *data);
int __fastcall json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags);
int __fastcall json_dumpf(const json_t_0 *json, FILE *output, size_t flags);
int __fastcall json_dump_file(const json_t_0 *json, const unsigned __int8 *path, size_t flags);
unsigned __int8 *__fastcall json_dumps(const json_t_0 *json, size_t flags);
void *__fastcall jsonp_malloc(size_t size);
void __fastcall jsonp_free(void **ptr);
unsigned __int8 *__fastcall jsonp_strdup(const unsigned __int8 *str);
unsigned __int8 *__fastcall jsonp_strsteal(strbuffer_t *strbuff);
unsigned __int8 *__fastcall jsonp_eolstrsteal(strbuffer_t *strbuff);
void __fastcall json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
int __fastcall utf8_encode(int32_t codepoint, unsigned __int8 *buffer, int *size);
int __fastcall utf8_check_first(unsigned __int8 byte);
int __fastcall utf8_check_full(const unsigned __int8 *buffer, int size, int32_t *codepoint);
const unsigned __int8 *__fastcall utf8_iterate(const unsigned __int8 *buffer, int32_t *codepoint);
int __fastcall utf8_check_string(const unsigned __int8 *string, int length);
uint32_t __fastcall hashlittle(const void *key, size_t length, uint32_t initval);
void __fastcall insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list);
pair_t *__fastcall hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const unsigned __int8 *key, size_t hash);
void __fastcall hashtable_do_clear(hashtable_t *hashtable);
int __fastcall hashtable_init(hashtable_t *hashtable);
void __fastcall hashtable_close(hashtable_t *hashtable);
int __fastcall hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, size_t serial, json_t_0 *value);
void *__fastcall hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key);
int __fastcall hashtable_del(hashtable_t *hashtable, const unsigned __int8 *key);
void __fastcall hashtable_clear(hashtable_t *hashtable);
void *__fastcall hashtable_iter(hashtable_t *hashtable);
void *__fastcall hashtable_iter_at(hashtable_t *hashtable, const unsigned __int8 *key);
void *__fastcall hashtable_iter_next(hashtable_t *hashtable, void *iter);
void *__fastcall hashtable_iter_key(void *iter);
size_t __fastcall hashtable_iter_serial(void *iter);
void *__fastcall hashtable_iter_value(void *iter);
void __fastcall hashtable_iter_set(void *iter, json_t_0 *value);
json_t_0 **__fastcall json_array_grow(json_array_t *array, size_t amount, int copy);
json_object_t *json_object();
size_t __fastcall json_object_size(const json_t_0 *json);
json_t_0 *__fastcall json_object_get(const json_t_0 *json, const unsigned __int8 *key);
int __fastcall json_object_del(json_t_0 *json, const unsigned __int8 *key);
int __fastcall json_object_clear(json_t_0 *json);
void *__fastcall json_object_iter(json_t_0 *json);
void *__fastcall json_object_iter_at(json_t_0 *json, const unsigned __int8 *key);
void *__fastcall json_object_iter_next(json_t_0 *json, void *iter);
const unsigned __int8 *__fastcall json_object_iter_key(void *iter);
json_t_0 *__fastcall json_object_iter_value(void *iter);
int __fastcall json_object_iter_set_new(json_t_0 *json, void *iter, json_t_0 *value);
void *__fastcall json_object_key_to_iter(const unsigned __int8 *key);
json_array_t *json_array();
size_t __fastcall json_array_size(const json_t_0 *json);
json_t_0 *__fastcall json_array_get(const json_t_0 *json, size_t index);
int __fastcall json_array_extend(json_t_0 *json, json_t_0 *other_json);
json_t_0 *__fastcall json_string_nocheck(const unsigned __int8 *value);
json_t_0 *__fastcall json_string(const unsigned __int8 *value);
const unsigned __int8 *__fastcall json_string_value(const json_t_0 *json);
int __fastcall json_string_set_nocheck(json_t_0 *json, const unsigned __int8 *value);
int __fastcall json_string_set(json_t_0 *json, const unsigned __int8 *value);
json_t_0 *__fastcall json_integer(json_int_t value);
json_int_t __fastcall json_integer_value(const json_t_0 *json);
int __fastcall json_integer_set(json_t_0 *json, int a2, json_int_t value);
json_t_0 *json_real(double value); // idb
double __fastcall json_real_value(const json_t_0 *json);
int __fastcall json_real_set(double json, double value);
double __fastcall json_number_value(const json_t_0 *json);
json_t_0 *json_true(); // idb
json_t_0 *json_false(); // idb
json_t_0 *json_null(); // idb
void __fastcall json_delete(json_t_0 *json);
int __fastcall json_array_clear(json_t_0 *json);
int __fastcall json_array_remove(json_t_0 *json, size_t index);
int __fastcall json_array_insert_new(json_t_0 *json, size_t index, json_t_0 *value);
int __fastcall json_array_append_new(json_t_0 *json, json_t_0 *value);
int __fastcall json_array_set_new(json_t_0 *json, size_t index, json_t_0 *value);
int __fastcall json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value);
int __fastcall json_object_update_missing(json_t_0 *object, json_t_0 *other);
int __fastcall json_object_set_new(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value);
int __fastcall json_object_update(json_t_0 *object, json_t_0 *other);
int __fastcall json_object_update_existing(json_t_0 *object, json_t_0 *other);
int __fastcall json_equal(json_t_0 *json1, json_t_0 *json2);
json_t_0 *__fastcall json_copy(json_t_0 *json);
json_t_0 *__fastcall json_deep_copy(const json_t_0 *json);
void *__fastcall rpl_memchr(const void *s, int c_in, size_t n);
size_t __fastcall critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period);
void *__fastcall two_way_long_needle(const unsigned __int8 *haystack, size_t haystack_len, const unsigned __int8 *needle, size_t needle_len);
void *__fastcall memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len);
int __fastcall uncompress(int, int *, unsigned int, int); // idb
int __fastcall updatewindow(int, int, size_t n); // idb
int __fastcall inflateResetKeep(_DWORD *); // idb
int __fastcall inflateReset(_DWORD *); // idb
int __fastcall inflateReset2(int, int); // idb
int __fastcall inflateInit2_(_DWORD *, int, _BYTE *, int); // idb
int __fastcall inflateInit_(_DWORD *, _BYTE *, int); // idb
int __fastcall inflatePrime(int, int, int); // idb
int __fastcall inflate(unsigned int *, int); // idb
int __fastcall inflateEnd(_DWORD *); // idb
int __fastcall inflateGetDictionary(int, void *dest, _DWORD *); // idb
int __fastcall inflateSetDictionary(int, unsigned __int8 *, size_t n); // idb
int __fastcall inflateGetHeader(int a1, int a2);
int __fastcall inflateSync(int *); // idb
int __fastcall inflateSyncPoint(int); // idb
int __fastcall inflateCopy(_DWORD *, int *); // idb
int __fastcall inflateUndermine(int a1);
int __fastcall inflateMark(int); // idb
int __fastcall inflate_table(int, int, unsigned int, int *, unsigned int *, void **); // idb
const char *zlibVersion();
int zlibCompileFlags();
char *__fastcall zError(int a1);
void *__fastcall zcalloc(int a1, int a2, int a3);
void __fastcall zcfree(int a1, void *ptr);
int __fastcall adler32(unsigned int, unsigned __int8 *, unsigned int); // idb
unsigned int __fastcall adler32_combine(unsigned int a1, unsigned int a2, int a3);
unsigned int __fastcall adler32_combine64(unsigned int a1, unsigned int a2, __int64 a3);
int __fastcall crc32_combine_(int result, int, __int64); // idb
void *get_crc_table();
unsigned int __fastcall crc32(int a1, char *a2, unsigned int a3);
int __fastcall crc32_combine(int a1, int a2, int a3);
unsigned int __fastcall inflate_fast(unsigned int *a1, int a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int); // idb
int _aeabi_ldiv0();
__int64 __fastcall _gnu_ldivmod_helper(__int64, __int64, _QWORD *); // idb
unsigned __int64 __fastcall _gnu_uldivmod_helper(unsigned __int64, unsigned __int64, _QWORD *); // idb
__int64 init();
int _libc_csu_fini(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_186A0; // weak
char (*off_30D40)[16] = &base_freq_index; // weak
_UNKNOWN loc_3A97E; // weak
_UNKNOWN loc_43370; // weak
const unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const unsigned __int8 _func___9900[14] =
{
  109u,
  121u,
  95u,
  108u,
  111u,
  103u,
  95u,
  99u,
  117u,
  114u,
  115u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___9328[14] = { 107u, 95u, 97u, 108u, 108u, 111u, 99u, 95u, 105u, 116u, 101u, 109u, 115u, 0u }; // idb
const unsigned __int8 _func___9344[12] = { 107u, 95u, 110u, 101u, 119u, 95u, 115u, 116u, 111u, 114u, 101u, 0u }; // idb
const unsigned __int8 _func___9357[12] = { 95u, 107u, 95u, 110u, 101u, 119u, 95u, 108u, 105u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___9383[15] =
{
  95u,
  107u,
  95u,
  117u,
  110u,
  108u,
  105u,
  110u,
  107u,
  95u,
  116u,
  97u,
  105u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___9392[12] = { 95u, 107u, 95u, 97u, 100u, 100u, 95u, 104u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___9401[12] = { 95u, 107u, 95u, 97u, 100u, 100u, 95u, 116u, 97u, 105u, 108u, 0u }; // idb
const unsigned __int8 _func___9412[17] =
{
  95u,
  107u,
  95u,
  105u,
  110u,
  115u,
  101u,
  114u,
  116u,
  95u,
  98u,
  101u,
  102u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___9423[16] =
{
  95u,
  107u,
  95u,
  105u,
  110u,
  115u,
  101u,
  114u,
  116u,
  95u,
  97u,
  102u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _func___9433[15] =
{
  95u,
  107u,
  95u,
  117u,
  110u,
  108u,
  105u,
  110u,
  107u,
  95u,
  105u,
  116u,
  101u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___9442[25] =
{
  95u,
  107u,
  95u,
  108u,
  105u,
  115u,
  116u,
  95u,
  116u,
  114u,
  97u,
  110u,
  115u,
  102u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  104u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___9452[25] =
{
  95u,
  107u,
  95u,
  108u,
  105u,
  115u,
  116u,
  95u,
  116u,
  114u,
  97u,
  110u,
  115u,
  102u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  116u,
  97u,
  105u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___9462[13] = { 95u, 107u, 95u, 102u, 114u, 101u, 101u, 95u, 108u, 105u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___9476[14] =
{
  95u,
  107u,
  95u,
  102u,
  114u,
  101u,
  101u,
  95u,
  115u,
  116u,
  111u,
  114u,
  101u,
  0u
}; // idb
const int hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // idb
const pthread_mutex_t _func___10719 = { { 1634036835, 1869832050u, 27491, 1717530996, 2053465458u, { 1634235493 } } }; // idb
const $262D70590CF6D71EA9430194459E5D8E proxynames[7] =
{
  { &aHttp, 0 },
  { &aHttp0, 1 },
  { &aSocks4, 2 },
  { &aSocks5, 3 },
  { &aSocks4a, 4 },
  { &aSocks5h, 5 },
  { NULL, 0 }
}; // idb
const unsigned __int8 _func___10314[8] = { 98u, 105u, 110u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 _func___10430[7] = { 116u, 113u, 95u, 110u, 101u, 119u, 0u }; // idb
const pthread_mutex_t _func___10456 = { { 1885303156, 6845301u, 1885303156, 28783, 1601463655u, { 2020569712 } } }; // idb
const pthread_mutex_t _func___11159 =
{
  { 1886614899, 1600417381u, 1634890867, 7173492, 1633903986u, { 1668246636 } }
}; // idb
const pthread_mutex_t _func___10687 = { { 1634890867, 1601009012u, 1684956531, 0, 1818322290u, { 1600352108 } } }; // idb
const unsigned __int8 _func___11242[9] = { 115u, 116u, 114u, 95u, 116u, 101u, 120u, 116u, 0u }; // idb
const unsigned __int8 _func___10474[16] =
{
  116u,
  104u,
  114u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  99u,
  114u,
  101u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___11303[18] =
{
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___11312[22] =
{
  99u,
  103u,
  95u,
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___11082[17] =
{
  115u,
  111u,
  99u,
  107u,
  115u,
  52u,
  95u,
  110u,
  101u,
  103u,
  111u,
  116u,
  105u,
  97u,
  116u,
  101u,
  0u
}; // idb
const pthread_mutex_t _func___11107 = { { 1970562419, 1953718128u, 1970561394, 1869832045, 1952803683u, { 0 } } }; // idb
const pthread_mutex_t _func___11187 = { { 1953066601, 1702125929u, 1920234335, 1836414049, 0u, { 1936875888 } } }; // idb
const pthread_mutex_t _func___10836 = { { 1936875888, 1768185701u, 26214, 1936875888, 2019909477u, { 1851880052 } } }; // idb
const pthread_mutex_t lock =
{
  { 1936875888, 1701994341u, 1852731235, 7627621, 2037411683u, { 1835627615 } }
}; // idb
const unsigned __int8 _func___10401[11] = { 115u, 101u, 114u, 95u, 115u, 116u, 114u, 105u, 110u, 103u, 0u }; // idb
const unsigned __int8 _func___10388[22] =
{
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  95u,
  116u,
  111u,
  95u,
  112u,
  117u,
  98u,
  107u,
  101u,
  121u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
_UNKNOWN unk_45E28; // weak
const unsigned __int8 _FUNCTION___12328[13] = { 114u, 101u, 99u, 101u, 105u, 118u, 101u, 95u, 102u, 117u, 110u, 99u, 0u }; // idb
const unsigned __int8 _func___10238[14] =
{
  101u,
  115u,
  99u,
  97u,
  112u,
  101u,
  95u,
  115u,
  116u,
  114u,
  105u,
  110u,
  103u,
  0u
}; // idb
const unsigned __int8 _func___10467[13] = { 97u, 100u, 100u, 95u, 105u, 116u, 101u, 109u, 95u, 98u, 117u, 102u, 0u }; // idb
const pthread_mutex_t _func___11333 = { { 1953719666, 1601466977u, 1701996660, 25697, 1953068401u, { 1919448159 } } }; // idb
const pthread_mutex_t _func___11145 = { { 2036623732, 28789u, 1852404336, 1633967988, 24948u, { 1953068915 } } }; // idb
const pthread_mutex_t _func___10950 = { { 1701734765, 1852403555u, 0, 1835890035, 7959137u, { 297860 } } }; // idb
const pthread_mutex_t _func___11476 =
{
  { 6910049, 1818845510u, 1948279909, 1634541679, 1668246636u, { 1668506912 } }
}; // idb
const unsigned __int8 byte_479F8 = 80u; // idb
const unsigned __int8 _func___14048[12] = { 106u, 115u, 111u, 110u, 95u, 101u, 115u, 99u, 97u, 112u, 101u, 0u }; // idb
const unsigned __int8 _func___13488[19] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  101u,
  110u,
  99u,
  104u,
  109u,
  97u,
  114u,
  107u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___13261[14] = { 99u, 97u, 108u, 99u, 95u, 109u, 105u, 100u, 115u, 116u, 97u, 116u, 101u, 0u }; // idb
const unsigned __int8 _func___14730[11] = { 109u, 116u, 95u, 100u, 105u, 115u, 97u, 98u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___14971[13] = { 109u, 105u, 110u, 101u, 114u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___13218[12] = { 108u, 111u, 97u, 100u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___13187[13] = { 112u, 97u, 114u, 115u, 101u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _func___12629[10] = { 115u, 101u, 116u, 117u, 112u, 95u, 117u, 114u, 108u, 0u }; // idb
const unsigned __int8 _func___13623[11] = { 95u, 99u, 111u, 112u, 121u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___14498[11] = { 115u, 101u, 116u, 95u, 116u, 97u, 114u, 103u, 101u, 116u, 0u }; // idb
const benchfile_layout benchfile_data[5] =
{
  { 1, &aVersion_1 },
  { 64, &aMerkleroot },
  { 64, &aPrevhash },
  { 8, &aDifficultybits },
  { 10, &aNoncetime }
}; // idb
const unsigned __int8 _func___13364[13] = { 103u, 101u, 116u, 95u, 115u, 116u, 97u, 116u, 108u, 105u, 110u, 101u, 0u }; // idb
const pthread_mutex_t _func___13787 = { { 1953719666, 1601466977u, 1953063287, 0, 1752392040u, { 1886351455 } } }; // idb
const pthread_mutex_t _func___14582 = { { 1600351849, 1700755304u, 1919906418, 115, 1600351849u, { 1700755304 } } }; // idb
const pthread_mutex_t _func___13764 = { { 1701536119, 1937205087u, 0, 1600351849, 1601594724u, { 1952543859 } } }; // idb
const pthread_mutex_t _func___12498 = { { 1819242352, 1702065247u, 116, 1819242352, 1818457183u, { 7496037 } } }; // idb
const pthread_mutex_t _func___14230 = { { 1634036835, 1953718130u, 1970561394, 1752391533, 1936028257u, { 0 } } }; // idb
const pthread_mutex_t _func___14243 =
{
  { 1634036835, 1869635442u, 2002742383, 7041647, 1600414817u, { 1819242352 } }
}; // idb
const pthread_rwlock_t _func___14928 =
{
  {
    1937075302,
    1970364264u,
    6649189u,
    1600481121u,
    1969583473u,
    2002740325u,
    111u,
    114u,
    107u,
    0u,
    1802661751
  }
}; // idb
const pthread_rwlock_t _func___14826 =
{
  {
    1600414817,
    1969583473u,
    25701u,
    1701536116u,
    1702195551u,
    1600415093u,
    119u,
    111u,
    114u,
    107u,
    1836671583
  }
}; // idb
const pthread_rwlock_t _func___13731 =
{
  {
    1953068915,
    1885300835u,
    1936486255u,
    0u,
    1635020660u,
    1870094188u,
    114u,
    107u,
    95u,
    105u,
    25454
  }
}; // idb
const unsigned __int8 _func___13271[10] = { 109u, 97u, 107u, 101u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const pthread_mutex_t _func___13696 = { { 1918986355, 1768185701u, 26214, 1633972341, 2002740596u, { 1600877167 } } }; // idb
const pthread_rwlock_t _func___14867 =
{
  {
    1852796003,
    1970364261u,
    1684370789u,
    1919907679u,
    2036490091u,
    1935960429u,
    116u,
    97u,
    116u,
    101u,
    0
  }
}; // idb
const pthread_mutex_t _func___14522 = { { 1601070439, 1634890867u, 1601009012, 1802661751, 0u, { 1601463655 } } }; // idb
const pthread_rwlock_t _func___14890 =
{
  {
    1852796003,
    1970364261u,
    1684370789u,
    1919907679u,
    2036490091u,
    25705u,
    103u,
    101u,
    116u,
    95u,
    1701996660
  }
}; // idb
const pthread_mutex_t _func___12458 = { { 1918986355, 1735355493u, 0, 1601463655, 1769366884u, { 7562595 } } }; // idb
const pthread_mutex_t _func___14098 = { { 1869768058, 1635021663u, 29556, 1752392040, 1702126957u, { 114 } } }; // idb
const pthread_mutex_t _func___14958 = { { 1752392040, 1769104479u, 1601332598, 1802661751, 0u, { 1684957542 } } }; // idb
const pthread_rwlock_t _func___14883 =
{
  {
    1684957542,
    1702195551u,
    1600415093u,
    1802661751u,
    1769562719u,
    100u,
    99u,
    112u,
    95u,
    112u,
    7301490
  }
}; // idb
const pthread_mutex_t _func___12509 = { { 1920103779, 1601465957u, 1819242352, 0, 1953719668u, { 1919907679 } } }; // idb
const pthread_rwlock_t _func___13846 =
{
  {
    1668246626,
    2019909483u,
    1937011561u,
    0u,
    1601463667u,
    1651668323u,
    108u,
    111u,
    99u,
    107u,
    0
  }
}; // idb
const pthread_mutex_t _func___13962 = { { 1752392040, 1937076319u, 104, 1600351849, 1802661751u, { 1635021663 } } }; // idb
const pthread_rwlock_t _func___15166 =
{
  {
    1953719668,
    1869574239u,
    1752457068u,
    1684104562u,
    0u,
    1885431154u,
    95u,
    99u,
    117u,
    114u,
    108
  }
}; // idb
const pthread_mutex_t _func___15009 = { { 1853190768, 1953718117u, 1970561394, 1752391533, 1936028257u, { 0 } } }; // idb
const pthread_mutex_t _func___14979 = { { 1953063287, 1668312159u, 1701999221, 29806, 1886418291u, { 1937011311 } } }; // idb
const pthread_mutex_t _func___14194 = { { 1936875888, 1953718117u, 1970561394, 1701994349, 1852797043u, { 25971 } } }; // idb
const pthread_mutex_t _func___13387 = { { 1918986355, 1701994341u, 1953265011, 0, 1701471602u, { 29795 } } }; // idb
const unsigned __int8 _func___14302[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  114u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const pthread_mutex_t _func___14326 =
{
  { 1634890867, 1601009012u, 1919448179, 6578533, 1818326131u, { 1870094181 } }
}; // idb
const pthread_mutex_t _func___13771 = { { 1668508004, 1600418401u, 1818326131, 101, 1953719666u, { 1601466977 } } }; // idb
const pthread_rwlock_t _func___15042 =
{
  {
    1668571511,
    1735353448u,
    1919448159u,
    6578533u,
    1701273439u,
    1970364276u,
    101u,
    117u,
    101u,
    100u,
    0
  }
}; // idb
const pthread_rwlock_t _func___14821 =
{
  {
    1601463655,
    1969583473u,
    25701u,
    1601463655u,
    1802661751u,
    0u,
    115u,
    101u,
    116u,
    95u,
    1668179298
  }
}; // idb
const pthread_rwlock_t _func___14773 =
{
  {
    1819044198,
    1702195551u,
    25973u,
    1752392040u,
    1819243359u,
    1870094181u,
    114u,
    107u,
    0u,
    0u,
    1835169139
  }
}; // idb
const unsigned __int8 _func___14715[21] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  110u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14630[19] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  116u,
  101u,
  115u,
  116u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___15176[17] =
{
  97u,
  100u,
  100u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  100u,
  101u,
  116u,
  97u,
  105u,
  108u,
  115u,
  0u
}; // idb
const pthread_rwlock_t _func___15270 =
{
  {
    1650552421,
    1683973484u,
    1667855973u,
    101u,
    1600414817u,
    1970300771u,
    0u,
    0u,
    0u,
    0u,
    2037411683
  }
}; // idb
const pthread_mutex_t _func___15372 = { { 1852399981, 0u, 1684107116, 1717920863, 1953264993u, { 1852793695 } } }; // idb
const unsigned __int8 bench_hidiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    50u,
    98u,
    49u,
    53u,
    49u,
    52u,
    101u,
    55u,
    98u,
    54u,
    53u,
    54u,
    53u,
    57u,
    52u,
    49u,
    101u,
    53u,
    56u,
    50u,
    52u,
    102u,
    48u,
    56u,
    52u,
    50u,
    57u,
    50u,
    49u,
    54u,
    52u,
    101u,
    99u,
    53u,
    102u,
    57u,
    55u,
    101u,
    55u,
    101u,
    97u,
    50u,
    48u,
    99u,
    52u,
    57u,
    52u,
    98u,
    100u,
    57u,
    54u,
    101u,
    53u,
    50u,
    52u,
    100u,
    52u,
    55u,
    56u,
    57u,
    55u,
    55u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    50u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    98u,
    49u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    101u,
    52u,
    101u,
    51u,
    98u,
    101u,
    99u,
    99u,
    48u,
    49u,
    48u,
    54u,
    52u,
    100u,
    56u,
    48u,
    56u,
    50u,
    54u,
    57u,
    98u,
    51u,
    51u,
    48u,
    102u,
    52u,
    48u,
    102u,
    52u,
    100u,
    101u,
    56u,
    50u,
    100u,
    99u,
    57u,
    50u,
    101u,
    56u,
    57u,
    52u,
    100u,
    54u,
    51u,
    53u,
    48u,
    50u,
    53u,
    100u,
    97u,
    97u,
    51u,
    101u,
    50u,
    101u,
    50u,
    99u,
    52u,
    49u,
    48u,
    98u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    57u,
    101u,
    98u,
    98u,
    99u,
    101u,
    50u,
    102u,
    53u,
    102u,
    48u,
    100u,
    54u,
    99u,
    99u,
    48u,
    97u,
    99u,
    97u,
    50u,
    56u,
    52u,
    101u,
    99u,
    98u,
    49u,
    48u,
    53u,
    57u,
    99u,
    56u,
    53u,
    54u,
    101u,
    102u,
    50u,
    102u,
    55u,
    102u,
    52u,
    50u,
    101u,
    55u,
    101u,
    100u,
    100u,
    52u,
    48u,
    51u,
    100u,
    50u,
    52u,
    54u,
    55u,
    53u,
    52u,
    101u,
    101u,
    52u,
    99u,
    57u,
    48u,
    53u,
    97u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    102u,
    100u,
    97u,
    48u,
    51u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    55u,
    56u,
    100u,
    97u,
    102u,
    49u,
    98u,
    53u,
    101u,
    98u,
    51u,
    51u,
    57u,
    55u,
    97u,
    102u,
    49u,
    99u,
    48u,
    48u,
    100u,
    98u,
    100u,
    57u,
    98u,
    48u,
    54u,
    54u,
    53u,
    57u,
    99u,
    100u,
    99u,
    48u,
    52u,
    49u,
    56u,
    51u,
    99u,
    56u,
    98u,
    97u,
    97u,
    102u,
    53u,
    98u,
    101u,
    49u,
    100u,
    98u,
    102u,
    51u,
    50u,
    102u,
    55u,
    57u,
    101u,
    48u,
    48u,
    52u,
    53u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    48u,
    52u,
    54u,
    53u,
    48u,
    97u,
    56u,
    101u,
    55u,
    52u,
    56u,
    100u,
    50u,
    101u,
    54u,
    102u,
    100u,
    101u,
    56u,
    54u,
    97u,
    56u,
    97u,
    57u,
    50u,
    48u,
    98u,
    50u,
    56u,
    53u,
    102u,
    51u,
    101u,
    50u,
    50u,
    51u,
    57u,
    56u,
    102u,
    53u,
    56u,
    51u,
    55u,
    48u,
    48u,
    50u,
    51u,
    54u,
    57u,
    53u,
    56u,
    51u,
    50u,
    51u,
    101u,
    102u,
    57u,
    101u,
    97u,
    56u,
    51u,
    50u,
    49u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    52u,
    53u,
    55u,
    48u,
    101u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    49u,
    100u,
    54u,
    53u,
    52u,
    97u,
    101u,
    50u,
    98u,
    48u,
    54u,
    102u,
    50u,
    49u,
    57u,
    99u,
    99u,
    102u,
    52u,
    54u,
    48u,
    49u,
    57u,
    51u,
    51u,
    102u,
    97u,
    98u,
    52u,
    48u,
    56u,
    100u,
    101u,
    49u,
    99u,
    51u,
    98u,
    55u,
    99u,
    56u,
    99u,
    57u,
    99u,
    56u,
    53u,
    101u,
    48u,
    51u,
    50u,
    51u,
    49u,
    100u,
    52u,
    97u,
    97u,
    102u,
    53u,
    97u,
    50u,
    54u,
    99u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    52u,
    98u,
    51u,
    57u,
    49u,
    51u,
    52u,
    99u,
    50u,
    57u,
    51u,
    48u,
    100u,
    50u,
    102u,
    50u,
    101u,
    55u,
    51u,
    51u,
    57u,
    102u,
    57u,
    100u,
    53u,
    48u,
    50u,
    99u,
    55u,
    55u,
    54u,
    99u,
    52u,
    52u,
    100u,
    54u,
    101u,
    101u,
    53u,
    57u,
    57u,
    102u,
    55u,
    101u,
    102u,
    101u,
    98u,
    101u,
    99u,
    54u,
    99u,
    57u,
    98u,
    98u,
    100u,
    48u,
    52u,
    55u,
    56u,
    55u,
    97u,
    97u,
    101u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    50u,
    55u,
    49u,
    48u,
    102u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    57u,
    52u,
    101u,
    54u,
    48u,
    99u,
    49u,
    49u,
    56u,
    48u,
    48u,
    50u,
    50u,
    102u,
    51u,
    51u,
    55u,
    50u,
    51u,
    50u,
    97u,
    98u,
    51u,
    100u,
    50u,
    57u,
    56u,
    102u,
    56u,
    51u,
    56u,
    51u,
    48u,
    52u,
    98u,
    54u,
    48u,
    48u,
    56u,
    97u,
    98u,
    50u,
    51u,
    55u,
    99u,
    102u,
    55u,
    101u,
    49u,
    55u,
    49u,
    55u,
    102u,
    49u,
    57u,
    51u,
    51u,
    52u,
    48u,
    55u,
    101u,
    53u,
    57u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    53u,
    98u,
    56u,
    50u,
    49u,
    102u,
    98u,
    48u,
    98u,
    50u,
    54u,
    100u,
    54u,
    51u,
    98u,
    48u,
    48u,
    99u,
    99u,
    50u,
    54u,
    101u,
    55u,
    97u,
    99u,
    52u,
    100u,
    54u,
    99u,
    102u,
    100u,
    49u,
    100u,
    51u,
    102u,
    99u,
    49u,
    48u,
    57u,
    98u,
    48u,
    100u,
    98u,
    49u,
    56u,
    56u,
    101u,
    55u,
    101u,
    55u,
    57u,
    50u,
    101u,
    51u,
    100u,
    49u,
    56u,
    51u,
    52u,
    50u,
    57u,
    49u,
    57u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    100u,
    52u,
    56u,
    48u,
    53u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    57u,
    48u,
    101u,
    97u,
    99u,
    54u,
    49u,
    54u,
    52u,
    50u,
    57u,
    52u,
    57u,
    99u,
    48u,
    48u,
    100u,
    49u,
    55u,
    102u,
    55u,
    99u,
    100u,
    53u,
    57u,
    56u,
    48u,
    97u,
    98u,
    101u,
    100u,
    98u,
    56u,
    54u,
    52u,
    55u,
    102u,
    99u,
    53u,
    100u,
    102u,
    57u,
    57u,
    53u,
    53u,
    100u,
    99u,
    102u,
    101u,
    52u,
    100u,
    53u,
    54u,
    97u,
    53u,
    48u,
    97u,
    48u,
    99u,
    53u,
    54u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    101u,
    57u,
    100u,
    57u,
    52u,
    98u,
    102u,
    53u,
    97u,
    48u,
    97u,
    98u,
    55u,
    98u,
    50u,
    48u,
    50u,
    100u,
    51u,
    57u,
    101u,
    49u,
    50u,
    48u,
    48u,
    97u,
    102u,
    57u,
    54u,
    48u,
    55u,
    52u,
    101u,
    52u,
    102u,
    54u,
    52u,
    49u,
    102u,
    52u,
    101u,
    53u,
    53u,
    101u,
    51u,
    101u,
    57u,
    101u,
    51u,
    97u,
    101u,
    101u,
    55u,
    50u,
    97u,
    97u,
    48u,
    48u,
    97u,
    55u,
    48u,
    101u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    48u,
    102u,
    55u,
    48u,
    49u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    52u,
    55u,
    55u,
    99u,
    97u,
    56u,
    53u,
    51u,
    54u,
    55u,
    48u,
    50u,
    101u,
    97u,
    99u,
    98u,
    100u,
    54u,
    53u,
    97u,
    54u,
    97u,
    49u,
    54u,
    50u,
    99u,
    102u,
    101u,
    57u,
    48u,
    100u,
    54u,
    50u,
    48u,
    49u,
    54u,
    97u,
    49u,
    52u,
    102u,
    102u,
    101u,
    53u,
    56u,
    100u,
    53u,
    50u,
    98u,
    55u,
    100u,
    100u,
    52u,
    99u,
    51u,
    54u,
    50u,
    56u,
    97u,
    50u,
    55u,
    101u,
    53u,
    98u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    98u,
    98u,
    98u,
    50u,
    53u,
    48u,
    102u,
    50u,
    100u,
    99u,
    50u,
    51u,
    55u,
    49u,
    55u,
    101u,
    56u,
    49u,
    57u,
    50u,
    99u,
    48u,
    98u,
    56u,
    98u,
    101u,
    99u,
    54u,
    97u,
    49u,
    55u,
    53u,
    99u,
    100u,
    48u,
    53u,
    57u,
    101u,
    52u,
    48u,
    56u,
    57u,
    100u,
    51u,
    50u,
    53u,
    48u,
    48u,
    54u,
    101u,
    97u,
    101u,
    101u,
    51u,
    52u,
    52u,
    54u,
    50u,
    53u,
    52u,
    99u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    57u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    54u,
    57u,
    56u,
    48u,
    99u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    56u,
    100u,
    98u,
    53u,
    57u,
    57u,
    100u,
    54u,
    98u,
    55u,
    97u,
    53u,
    53u,
    102u,
    100u,
    54u,
    49u,
    100u,
    52u,
    50u,
    52u,
    52u,
    97u,
    51u,
    100u,
    102u,
    97u,
    52u,
    54u,
    53u,
    48u,
    53u,
    53u,
    101u,
    97u,
    100u,
    54u,
    98u,
    53u,
    99u,
    48u,
    97u,
    51u,
    55u,
    99u,
    55u,
    97u,
    51u,
    100u,
    52u,
    53u,
    53u,
    53u,
    98u,
    53u,
    56u,
    101u,
    57u,
    57u,
    48u,
    54u,
    53u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    50u,
    101u,
    49u,
    55u,
    98u,
    97u,
    98u,
    100u,
    52u,
    48u,
    56u,
    57u,
    98u,
    50u,
    48u,
    52u,
    55u,
    57u,
    55u,
    99u,
    101u,
    98u,
    100u,
    97u,
    55u,
    100u,
    99u,
    54u,
    101u,
    50u,
    55u,
    55u,
    57u,
    53u,
    48u,
    101u,
    97u,
    98u,
    49u,
    98u,
    50u,
    57u,
    48u,
    56u,
    57u,
    57u,
    49u,
    97u,
    101u,
    49u,
    100u,
    55u,
    50u,
    51u,
    51u,
    53u,
    102u,
    56u,
    50u,
    100u,
    50u,
    48u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    102u,
    50u,
    100u,
    48u,
    57u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    99u,
    55u,
    100u,
    54u,
    48u,
    49u,
    99u,
    101u,
    51u,
    98u,
    48u,
    49u,
    101u,
    53u,
    54u,
    57u,
    97u,
    52u,
    57u,
    53u,
    48u,
    56u,
    100u,
    53u,
    52u,
    49u,
    98u,
    98u,
    99u,
    98u,
    97u,
    57u,
    98u,
    51u,
    99u,
    56u,
    51u,
    57u,
    52u,
    98u,
    49u,
    56u,
    51u,
    52u,
    53u,
    50u,
    51u,
    101u,
    102u,
    49u,
    101u,
    53u,
    99u,
    98u,
    50u,
    99u,
    54u,
    48u,
    98u,
    100u,
    51u,
    52u,
    97u,
    51u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    56u,
    56u,
    98u,
    54u,
    102u,
    48u,
    50u,
    50u,
    49u,
    52u,
    52u,
    100u,
    98u,
    49u,
    51u,
    52u,
    97u,
    102u,
    49u,
    98u,
    99u,
    56u,
    101u,
    54u,
    49u,
    98u,
    51u,
    56u,
    53u,
    99u,
    97u,
    51u,
    55u,
    99u,
    97u,
    101u,
    48u,
    51u,
    56u,
    99u,
    49u,
    100u,
    49u,
    54u,
    53u,
    97u,
    101u,
    57u,
    56u,
    99u,
    52u,
    57u,
    54u,
    98u,
    51u,
    98u,
    52u,
    49u,
    101u,
    56u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    97u,
    56u,
    101u,
    97u,
    48u,
    101u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    49u,
    48u,
    55u,
    54u,
    49u,
    101u,
    57u,
    55u,
    101u,
    54u,
    55u,
    98u,
    52u,
    57u,
    52u,
    102u,
    100u,
    53u,
    52u,
    55u,
    99u,
    102u,
    101u,
    57u,
    102u,
    102u,
    98u,
    98u,
    51u,
    54u,
    56u,
    57u,
    51u,
    100u,
    97u,
    55u,
    97u,
    101u,
    99u,
    55u,
    53u,
    99u,
    54u,
    98u,
    53u,
    49u,
    98u,
    56u,
    100u,
    53u,
    102u,
    51u,
    56u,
    102u,
    56u,
    55u,
    98u,
    53u,
    100u,
    54u,
    51u,
    99u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    49u,
    102u,
    48u,
    99u,
    102u,
    100u,
    102u,
    53u,
    97u,
    100u,
    56u,
    50u,
    52u,
    56u,
    102u,
    99u,
    52u,
    53u,
    50u,
    48u,
    102u,
    51u,
    98u,
    98u,
    48u,
    98u,
    50u,
    48u,
    52u,
    48u,
    50u,
    50u,
    54u,
    52u,
    51u,
    48u,
    51u,
    52u,
    56u,
    99u,
    100u,
    100u,
    101u,
    102u,
    102u,
    53u,
    99u,
    97u,
    57u,
    49u,
    56u,
    49u,
    98u,
    101u,
    101u,
    98u,
    55u,
    56u,
    56u,
    55u,
    48u,
    100u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    48u,
    100u,
    54u,
    48u,
    48u,
    102u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    49u,
    97u,
    56u,
    100u,
    51u,
    53u,
    52u,
    97u,
    55u,
    101u,
    56u,
    98u,
    49u,
    51u,
    101u,
    99u,
    52u,
    55u,
    102u,
    52u,
    99u,
    51u,
    100u,
    57u,
    48u,
    55u,
    100u,
    48u,
    48u,
    57u,
    52u,
    53u,
    97u,
    54u,
    49u,
    101u,
    56u,
    54u,
    48u,
    53u,
    57u,
    102u,
    52u,
    57u,
    52u,
    51u,
    101u,
    52u,
    50u,
    99u,
    49u,
    101u,
    53u,
    50u,
    51u,
    57u,
    56u,
    101u,
    98u,
    97u,
    53u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    50u,
    97u,
    49u,
    54u,
    100u,
    51u,
    56u,
    99u,
    99u,
    48u,
    101u,
    49u,
    51u,
    101u,
    52u,
    98u,
    49u,
    54u,
    100u,
    57u,
    49u,
    55u,
    98u,
    102u,
    102u,
    52u,
    99u,
    51u,
    52u,
    55u,
    50u,
    55u,
    100u,
    101u,
    98u,
    51u,
    98u,
    53u,
    99u,
    53u,
    48u,
    101u,
    52u,
    50u,
    52u,
    102u,
    98u,
    56u,
    52u,
    53u,
    51u,
    102u,
    102u,
    57u,
    98u,
    50u,
    97u,
    100u,
    99u,
    98u,
    52u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    50u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    102u,
    49u,
    48u,
    48u,
    50u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    99u,
    54u,
    55u,
    100u,
    51u,
    56u,
    102u,
    51u,
    49u,
    102u,
    53u,
    56u,
    57u,
    98u,
    49u,
    56u,
    98u,
    57u,
    100u,
    56u,
    101u,
    53u,
    51u,
    49u,
    98u,
    57u,
    57u,
    52u,
    99u,
    101u,
    53u,
    55u,
    51u,
    51u,
    99u,
    48u,
    50u,
    49u,
    97u,
    48u,
    51u,
    100u,
    56u,
    56u,
    100u,
    51u,
    56u,
    54u,
    49u,
    49u,
    101u,
    101u,
    54u,
    98u,
    52u,
    99u,
    50u,
    55u,
    49u,
    48u,
    97u,
    53u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    56u,
    54u,
    48u,
    52u,
    55u,
    49u,
    50u,
    55u,
    55u,
    98u,
    52u,
    97u,
    57u,
    51u,
    102u,
    101u,
    97u,
    50u,
    97u,
    56u,
    98u,
    54u,
    100u,
    56u,
    99u,
    50u,
    56u,
    49u,
    102u,
    97u,
    98u,
    55u,
    98u,
    100u,
    101u,
    51u,
    98u,
    55u,
    56u,
    102u,
    50u,
    97u,
    99u,
    100u,
    49u,
    98u,
    102u,
    100u,
    99u,
    56u,
    57u,
    100u,
    52u,
    54u,
    52u,
    101u,
    100u,
    51u,
    98u,
    98u,
    51u,
    99u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    53u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    100u,
    51u,
    48u,
    48u,
    52u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    51u,
    55u,
    54u,
    56u,
    54u,
    99u,
    54u,
    49u,
    49u,
    97u,
    97u,
    101u,
    52u,
    51u,
    57u,
    55u,
    99u,
    55u,
    99u,
    48u,
    52u,
    98u,
    50u,
    99u,
    49u,
    57u,
    48u,
    55u,
    48u,
    56u,
    52u,
    53u,
    51u,
    100u,
    48u,
    48u,
    101u,
    56u,
    99u,
    57u,
    53u,
    54u,
    51u,
    53u,
    50u,
    53u,
    54u,
    49u,
    48u,
    99u,
    51u,
    49u,
    98u,
    97u,
    52u,
    54u,
    101u,
    56u,
    48u,
    100u,
    98u,
    99u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    51u,
    55u,
    48u,
    50u,
    51u,
    48u,
    54u,
    48u,
    55u,
    57u,
    57u,
    56u,
    102u,
    98u,
    98u,
    100u,
    49u,
    48u,
    50u,
    55u,
    53u,
    99u,
    53u,
    56u,
    57u,
    48u,
    56u,
    56u,
    53u,
    102u,
    99u,
    100u,
    56u,
    49u,
    98u,
    54u,
    56u,
    48u,
    49u,
    56u,
    98u,
    97u,
    50u,
    51u,
    55u,
    51u,
    97u,
    98u,
    102u,
    48u,
    102u,
    57u,
    51u,
    97u,
    48u,
    54u,
    100u,
    48u,
    50u,
    97u,
    98u,
    50u,
    56u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    51u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    51u,
    55u,
    55u,
    53u,
    48u,
    98u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    102u,
    100u,
    100u,
    97u,
    57u,
    53u,
    50u,
    100u,
    97u,
    54u,
    97u,
    98u,
    100u,
    55u,
    48u,
    48u,
    50u,
    50u,
    97u,
    54u,
    101u,
    53u,
    102u,
    50u,
    98u,
    57u,
    100u,
    99u,
    53u,
    101u,
    49u,
    98u,
    54u,
    54u,
    48u,
    49u,
    49u,
    49u,
    50u,
    56u,
    99u,
    51u,
    102u,
    97u,
    50u,
    52u,
    57u,
    102u,
    48u,
    98u,
    55u,
    52u,
    51u,
    57u,
    102u,
    48u,
    48u,
    100u,
    53u,
    57u,
    52u,
    51u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    97u,
    50u,
    99u,
    57u,
    49u,
    102u,
    99u,
    52u,
    49u,
    50u,
    53u,
    52u,
    53u,
    51u,
    57u,
    97u,
    53u,
    98u,
    50u,
    97u,
    50u,
    55u,
    98u,
    101u,
    50u,
    56u,
    100u,
    101u,
    50u,
    97u,
    54u,
    49u,
    56u,
    55u,
    101u,
    50u,
    97u,
    102u,
    51u,
    102u,
    49u,
    50u,
    57u,
    100u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    52u,
    53u,
    102u,
    102u,
    99u,
    53u,
    49u,
    50u,
    100u,
    53u,
    99u,
    97u,
    51u,
    98u,
    99u,
    52u,
    100u,
    50u,
    48u,
    54u,
    51u,
    100u,
    100u,
    51u,
    97u,
    102u,
    49u,
    54u,
    54u,
    57u,
    99u,
    50u,
    57u,
    54u,
    97u,
    101u,
    49u,
    50u,
    54u,
    97u,
    53u,
    97u,
    50u,
    101u,
    102u,
    56u,
    57u,
    54u,
    100u,
    49u,
    101u,
    49u,
    57u,
    48u,
    99u,
    101u,
    100u,
    102u,
    54u,
    55u,
    98u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    53u,
    53u,
    98u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    48u,
    57u,
    52u,
    100u,
    54u,
    99u,
    98u,
    101u,
    55u,
    54u,
    53u,
    51u,
    56u,
    97u,
    56u,
    56u,
    54u,
    49u,
    50u,
    54u,
    50u,
    52u,
    102u,
    99u,
    53u,
    101u,
    54u,
    53u,
    53u,
    99u,
    99u,
    52u,
    48u,
    53u,
    99u,
    98u,
    56u,
    49u,
    57u,
    56u,
    100u,
    99u,
    97u,
    100u,
    53u,
    49u,
    54u,
    98u,
    56u,
    56u,
    100u,
    98u,
    97u,
    99u,
    53u,
    98u,
    102u,
    56u,
    98u,
    57u,
    48u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    99u,
    53u,
    52u,
    56u,
    56u,
    49u,
    53u,
    49u,
    50u,
    55u,
    99u,
    49u,
    50u,
    53u,
    49u,
    52u,
    55u,
    97u,
    102u,
    57u,
    49u,
    99u,
    51u,
    53u,
    54u,
    99u,
    50u,
    57u,
    51u,
    102u,
    48u,
    100u,
    101u,
    102u,
    98u,
    100u,
    50u,
    55u,
    55u,
    49u,
    102u,
    56u,
    100u,
    99u,
    51u,
    98u,
    49u,
    49u,
    52u,
    50u,
    98u,
    51u,
    54u,
    55u,
    53u,
    50u,
    56u,
    54u,
    53u,
    54u,
    100u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    54u,
    55u,
    55u,
    48u,
    97u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    98u,
    100u,
    98u,
    98u,
    51u,
    98u,
    49u,
    98u,
    101u,
    55u,
    50u,
    49u,
    54u,
    56u,
    55u,
    50u,
    101u,
    97u,
    55u,
    56u,
    55u,
    54u,
    50u,
    55u,
    98u,
    48u,
    51u,
    99u,
    51u,
    56u,
    57u,
    97u,
    53u,
    50u,
    55u,
    52u,
    53u,
    49u,
    102u,
    54u,
    100u,
    100u,
    56u,
    51u,
    50u,
    100u,
    56u,
    53u,
    52u,
    48u,
    56u,
    55u,
    52u,
    51u,
    48u,
    54u,
    102u,
    57u,
    99u,
    48u,
    55u,
    99u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    101u,
    102u,
    55u,
    53u,
    56u,
    55u,
    55u,
    48u,
    98u,
    98u,
    57u,
    48u,
    99u,
    53u,
    98u,
    49u,
    51u,
    55u,
    54u,
    57u,
    99u,
    53u,
    98u,
    54u,
    49u,
    97u,
    102u,
    102u,
    98u,
    51u,
    50u,
    50u,
    98u,
    50u,
    52u,
    99u,
    55u,
    52u,
    55u,
    53u,
    55u,
    51u,
    98u,
    51u,
    56u,
    101u,
    98u,
    101u,
    50u,
    101u,
    101u,
    56u,
    49u,
    55u,
    52u,
    56u,
    100u,
    48u,
    98u,
    53u,
    53u,
    55u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    48u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    57u,
    102u,
    48u,
    48u,
    49u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    97u,
    99u,
    56u,
    101u,
    101u,
    97u,
    54u,
    51u,
    50u,
    56u,
    53u,
    51u,
    53u,
    51u,
    57u,
    52u,
    52u,
    101u,
    52u,
    48u,
    101u,
    101u,
    99u,
    53u,
    52u,
    100u,
    50u,
    100u,
    100u,
    54u,
    99u,
    100u,
    48u,
    57u,
    57u,
    52u,
    98u,
    52u,
    52u,
    55u,
    52u,
    50u,
    57u,
    98u,
    98u,
    48u,
    101u,
    100u,
    48u,
    53u,
    57u,
    56u,
    100u,
    51u,
    56u,
    102u,
    52u,
    50u,
    100u,
    97u,
    48u,
    101u,
    50u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
const unsigned __int8 bench_lodiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    49u,
    102u,
    53u,
    48u,
    50u,
    99u,
    98u,
    51u,
    101u,
    57u,
    102u,
    100u,
    98u,
    48u,
    53u,
    51u,
    50u,
    51u,
    48u,
    101u,
    99u,
    49u,
    50u,
    97u,
    52u,
    57u,
    53u,
    52u,
    99u,
    49u,
    48u,
    50u,
    49u,
    97u,
    54u,
    98u,
    51u,
    53u,
    56u,
    54u,
    50u,
    98u,
    53u,
    101u,
    50u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    52u,
    100u,
    49u,
    98u,
    56u,
    51u,
    97u,
    101u,
    52u,
    52u,
    48u,
    53u,
    55u,
    48u,
    50u,
    53u,
    101u,
    56u,
    99u,
    53u,
    98u,
    53u,
    55u,
    53u,
    54u,
    98u,
    52u,
    52u,
    102u,
    48u,
    52u,
    100u,
    102u,
    53u,
    102u,
    102u,
    102u,
    101u,
    52u,
    97u,
    55u,
    97u,
    51u,
    48u,
    101u,
    53u,
    99u,
    49u,
    50u,
    100u,
    49u,
    50u,
    97u,
    57u,
    55u,
    97u,
    55u,
    97u,
    52u,
    99u,
    50u,
    101u,
    97u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    54u,
    100u,
    54u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    48u,
    56u,
    102u,
    55u,
    101u,
    49u,
    52u,
    99u,
    53u,
    48u,
    100u,
    97u,
    100u,
    55u,
    55u,
    100u,
    99u,
    50u,
    51u,
    56u,
    98u,
    52u,
    100u,
    98u,
    50u,
    57u,
    48u,
    49u,
    97u,
    48u,
    53u,
    55u,
    56u,
    101u,
    54u,
    53u,
    55u,
    98u,
    49u,
    57u,
    53u,
    52u,
    55u,
    55u,
    57u,
    97u,
    98u,
    57u,
    99u,
    100u,
    56u,
    50u,
    97u,
    55u,
    51u,
    56u,
    50u,
    57u,
    101u,
    100u,
    102u,
    55u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    49u,
    97u,
    49u,
    55u,
    52u,
    50u,
    53u,
    52u,
    97u,
    54u,
    53u,
    57u,
    51u,
    102u,
    102u,
    98u,
    97u,
    57u,
    56u,
    55u,
    102u,
    54u,
    56u,
    102u,
    101u,
    50u,
    54u,
    101u,
    55u,
    49u,
    54u,
    101u,
    51u,
    99u,
    49u,
    50u,
    57u,
    97u,
    55u,
    102u,
    51u,
    51u,
    97u,
    57u,
    99u,
    52u,
    51u,
    97u,
    101u,
    55u,
    101u,
    99u,
    102u,
    57u,
    48u,
    99u,
    56u,
    99u,
    100u,
    48u,
    100u,
    50u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    101u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    102u,
    56u,
    49u,
    48u,
    48u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    55u,
    48u,
    48u,
    97u,
    101u,
    101u,
    100u,
    97u,
    100u,
    97u,
    50u,
    98u,
    51u,
    56u,
    55u,
    55u,
    57u,
    48u,
    48u,
    98u,
    53u,
    56u,
    97u,
    49u,
    56u,
    51u,
    99u,
    52u,
    50u,
    99u,
    52u,
    48u,
    57u,
    52u,
    57u,
    57u,
    53u,
    54u,
    98u,
    98u,
    56u,
    98u,
    52u,
    97u,
    56u,
    100u,
    50u,
    49u,
    52u,
    56u,
    49u,
    102u,
    56u,
    57u,
    51u,
    54u,
    98u,
    53u,
    55u,
    50u,
    57u,
    50u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    51u,
    56u,
    99u,
    102u,
    52u,
    98u,
    54u,
    49u,
    100u,
    102u,
    102u,
    55u,
    52u,
    101u,
    51u,
    99u,
    50u,
    54u,
    98u,
    50u,
    100u,
    56u,
    48u,
    48u,
    52u,
    53u,
    48u,
    54u,
    52u,
    101u,
    56u,
    97u,
    98u,
    52u,
    56u,
    48u,
    50u,
    53u,
    50u,
    49u,
    98u,
    97u,
    98u,
    50u,
    99u,
    100u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    49u,
    101u,
    101u,
    102u,
    54u,
    52u,
    97u,
    55u,
    101u,
    102u,
    52u,
    101u,
    52u,
    55u,
    99u,
    100u,
    97u,
    49u,
    54u,
    101u,
    57u,
    54u,
    54u,
    55u,
    51u,
    49u,
    57u,
    55u,
    100u,
    51u,
    54u,
    99u,
    55u,
    50u,
    51u,
    53u,
    97u,
    52u,
    97u,
    97u,
    100u,
    100u,
    50u,
    51u,
    99u,
    50u,
    49u,
    97u,
    51u,
    56u,
    99u,
    101u,
    53u,
    51u,
    56u,
    50u,
    55u,
    100u,
    49u,
    102u,
    56u,
    98u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    57u,
    54u,
    98u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    51u,
    48u,
    99u,
    102u,
    55u,
    97u,
    54u,
    98u,
    56u,
    97u,
    56u,
    53u,
    101u,
    98u,
    49u,
    99u,
    99u,
    48u,
    49u,
    55u,
    98u,
    49u,
    48u,
    57u,
    100u,
    50u,
    51u,
    99u,
    51u,
    57u,
    50u,
    52u,
    54u,
    52u,
    102u,
    57u,
    57u,
    97u,
    97u,
    56u,
    99u,
    48u,
    50u,
    48u,
    101u,
    97u,
    49u,
    48u,
    55u,
    99u,
    53u,
    50u,
    53u,
    98u,
    54u,
    55u,
    49u,
    97u,
    100u,
    100u,
    101u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    101u,
    50u,
    99u,
    54u,
    98u,
    57u,
    50u,
    54u,
    52u,
    54u,
    56u,
    53u,
    54u,
    53u,
    101u,
    53u,
    50u,
    52u,
    97u,
    98u,
    55u,
    99u,
    50u,
    102u,
    49u,
    49u,
    49u,
    48u,
    51u,
    53u,
    100u,
    99u,
    100u,
    101u,
    55u,
    99u,
    54u,
    48u,
    57u,
    53u,
    53u,
    56u,
    52u,
    50u,
    49u,
    49u,
    49u,
    57u,
    51u,
    48u,
    53u,
    56u,
    57u,
    101u,
    99u,
    99u,
    98u,
    52u,
    49u,
    48u,
    102u,
    56u,
    51u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    102u,
    52u,
    50u,
    57u,
    48u,
    48u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    100u,
    98u,
    98u,
    51u,
    55u,
    52u,
    97u,
    57u,
    55u,
    102u,
    49u,
    53u,
    99u,
    53u,
    57u,
    53u,
    56u,
    55u,
    50u,
    53u,
    54u,
    54u,
    54u,
    50u,
    102u,
    51u,
    54u,
    57u,
    48u,
    52u,
    100u,
    48u,
    55u,
    53u,
    100u,
    48u,
    101u,
    54u,
    49u,
    102u,
    55u,
    52u,
    57u,
    54u,
    49u,
    56u,
    49u,
    56u,
    50u,
    55u,
    49u,
    49u,
    50u,
    56u,
    56u,
    97u,
    99u,
    54u,
    49u,
    55u,
    99u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    48u,
    55u,
    51u,
    51u,
    56u,
    53u,
    101u,
    48u,
    53u,
    99u,
    50u,
    57u,
    102u,
    48u,
    52u,
    51u,
    53u,
    97u,
    54u,
    48u,
    48u,
    49u,
    99u,
    56u,
    101u,
    99u,
    97u,
    57u,
    99u,
    56u,
    100u,
    53u,
    54u,
    48u,
    50u,
    56u,
    57u,
    48u,
    97u,
    101u,
    102u,
    102u,
    57u,
    100u,
    52u,
    100u,
    49u,
    48u,
    51u,
    100u,
    51u,
    51u,
    56u,
    51u,
    99u,
    102u,
    56u,
    48u,
    100u,
    97u,
    101u,
    53u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    50u,
    49u,
    100u,
    48u,
    48u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    55u,
    100u,
    97u,
    51u,
    98u,
    57u,
    55u,
    101u,
    56u,
    50u,
    99u,
    48u,
    99u,
    51u,
    49u,
    50u,
    53u,
    97u,
    53u,
    56u,
    100u,
    97u,
    100u,
    56u,
    97u,
    48u,
    100u,
    49u,
    100u,
    48u,
    51u,
    54u,
    57u,
    50u,
    52u,
    52u,
    55u,
    51u,
    49u,
    102u,
    51u,
    98u,
    48u,
    57u,
    54u,
    101u,
    57u,
    55u,
    50u,
    52u,
    56u,
    52u,
    50u,
    57u,
    56u,
    100u,
    49u,
    53u,
    98u,
    56u,
    52u,
    51u,
    100u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    98u,
    53u,
    98u,
    52u,
    100u,
    49u,
    57u,
    99u,
    50u,
    48u,
    97u,
    55u,
    102u,
    99u,
    50u,
    98u,
    49u,
    55u,
    52u,
    102u,
    102u,
    54u,
    55u,
    51u,
    99u,
    48u,
    48u,
    54u,
    101u,
    100u,
    100u,
    50u,
    50u,
    52u,
    55u,
    99u,
    52u,
    98u,
    50u,
    51u,
    51u,
    54u,
    53u,
    55u,
    49u,
    56u,
    54u,
    52u,
    100u,
    102u,
    57u,
    51u,
    101u,
    98u,
    55u,
    101u,
    99u,
    48u,
    99u,
    56u,
    99u,
    50u,
    55u,
    54u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    48u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    54u,
    51u,
    99u,
    48u,
    48u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    53u,
    49u,
    52u,
    98u,
    100u,
    53u,
    56u,
    54u,
    53u,
    49u,
    49u,
    101u,
    53u,
    51u,
    49u,
    101u,
    50u,
    98u,
    54u,
    50u,
    55u,
    55u,
    97u,
    54u,
    100u,
    49u,
    49u,
    50u,
    98u,
    49u,
    55u,
    49u,
    102u,
    57u,
    101u,
    48u,
    48u,
    56u,
    100u,
    53u,
    54u,
    101u,
    102u,
    52u,
    97u,
    57u,
    55u,
    49u,
    101u,
    54u,
    49u,
    57u,
    97u,
    99u,
    102u,
    50u,
    50u,
    101u,
    55u,
    53u,
    48u,
    55u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    101u,
    51u,
    48u,
    51u,
    48u,
    54u,
    50u,
    57u,
    102u,
    102u,
    52u,
    50u,
    53u,
    56u,
    48u,
    53u,
    54u,
    100u,
    99u,
    57u,
    101u,
    102u,
    97u,
    102u,
    57u,
    50u,
    50u,
    98u,
    100u,
    49u,
    55u,
    51u,
    97u,
    54u,
    53u,
    102u,
    54u,
    53u,
    101u,
    101u,
    55u,
    57u,
    57u,
    98u,
    48u,
    99u,
    55u,
    54u,
    53u,
    48u,
    57u,
    55u,
    100u,
    51u,
    100u,
    101u,
    101u,
    100u,
    100u,
    101u,
    102u,
    49u,
    48u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    56u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    52u,
    51u,
    48u,
    48u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    98u,
    55u,
    55u,
    97u,
    57u,
    99u,
    51u,
    54u,
    100u,
    56u,
    57u,
    52u,
    100u,
    50u,
    100u,
    98u,
    99u,
    51u,
    49u,
    52u,
    51u,
    55u,
    101u,
    53u,
    99u,
    50u,
    97u,
    49u,
    53u,
    54u,
    52u,
    101u,
    57u,
    50u,
    55u,
    57u,
    51u,
    55u,
    56u,
    52u,
    56u,
    101u,
    97u,
    50u,
    101u,
    98u,
    50u,
    48u,
    98u,
    51u,
    56u,
    54u,
    51u,
    56u,
    97u,
    102u,
    99u,
    54u,
    52u,
    98u,
    57u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    49u,
    51u,
    99u,
    50u,
    50u,
    98u,
    98u,
    57u,
    57u,
    101u,
    57u,
    100u,
    97u,
    97u,
    57u,
    57u,
    51u,
    54u,
    98u,
    48u,
    100u,
    102u,
    53u,
    100u,
    99u,
    101u,
    54u,
    52u,
    100u,
    55u,
    55u,
    51u,
    55u,
    101u,
    51u,
    55u,
    48u,
    54u,
    98u,
    101u,
    57u,
    57u,
    101u,
    53u,
    48u,
    57u,
    56u,
    100u,
    49u,
    49u,
    50u,
    48u,
    48u,
    50u,
    52u,
    57u,
    50u,
    99u,
    102u,
    56u,
    49u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    54u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    52u,
    52u,
    49u,
    48u,
    48u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    100u,
    56u,
    57u,
    54u,
    50u,
    54u,
    55u,
    102u,
    100u,
    97u,
    53u,
    100u,
    100u,
    97u,
    48u,
    102u,
    56u,
    53u,
    51u,
    48u,
    56u,
    101u,
    55u,
    55u,
    102u,
    55u,
    53u,
    52u,
    99u,
    56u,
    98u,
    57u,
    52u,
    98u,
    55u,
    98u,
    56u,
    56u,
    101u,
    51u,
    99u,
    98u,
    51u,
    49u,
    53u,
    52u,
    55u,
    53u,
    99u,
    100u,
    57u,
    101u,
    102u,
    100u,
    49u,
    54u,
    52u,
    48u,
    49u,
    101u,
    51u,
    99u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    102u,
    53u,
    99u,
    102u,
    102u,
    100u,
    55u,
    101u,
    53u,
    97u,
    55u,
    48u,
    56u,
    55u,
    102u,
    49u,
    98u,
    52u,
    56u,
    52u,
    98u,
    53u,
    50u,
    54u,
    99u,
    55u,
    51u,
    53u,
    48u,
    99u,
    56u,
    54u,
    100u,
    56u,
    51u,
    56u,
    57u,
    50u,
    56u,
    51u,
    53u,
    48u,
    57u,
    99u,
    97u,
    56u,
    55u,
    56u,
    53u,
    48u,
    50u,
    102u,
    55u,
    57u,
    50u,
    49u,
    49u,
    53u,
    101u,
    56u,
    100u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    97u,
    100u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    57u,
    57u,
    100u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    51u,
    51u,
    57u,
    51u,
    53u,
    52u,
    53u,
    54u,
    56u,
    102u,
    53u,
    48u,
    54u,
    97u,
    99u,
    51u,
    99u,
    100u,
    54u,
    57u,
    98u,
    98u,
    52u,
    50u,
    55u,
    98u,
    49u,
    97u,
    102u,
    56u,
    51u,
    97u,
    48u,
    52u,
    55u,
    51u,
    98u,
    56u,
    55u,
    99u,
    49u,
    54u,
    98u,
    102u,
    51u,
    98u,
    53u,
    54u,
    50u,
    97u,
    57u,
    51u,
    100u,
    48u,
    97u,
    50u,
    102u,
    102u,
    99u,
    53u,
    51u,
    101u,
    53u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    50u,
    53u,
    97u,
    54u,
    50u,
    52u,
    101u,
    53u,
    99u,
    56u,
    52u,
    102u,
    57u,
    54u,
    100u,
    50u,
    99u,
    51u,
    52u,
    100u,
    99u,
    101u,
    51u,
    98u,
    54u,
    97u,
    55u,
    51u,
    54u,
    97u,
    100u,
    100u,
    98u,
    56u,
    57u,
    49u,
    55u,
    50u,
    52u,
    98u,
    52u,
    56u,
    97u,
    51u,
    54u,
    51u,
    50u,
    48u,
    99u,
    55u,
    52u,
    57u,
    52u,
    52u,
    51u,
    53u,
    102u,
    57u,
    99u,
    57u,
    49u,
    53u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    54u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    102u,
    98u,
    48u,
    48u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    56u,
    51u,
    54u,
    50u,
    48u,
    48u,
    57u,
    99u,
    48u,
    55u,
    99u,
    102u,
    52u,
    56u,
    50u,
    52u,
    57u,
    102u,
    52u,
    56u,
    49u,
    98u,
    101u,
    54u,
    98u,
    55u,
    57u,
    101u,
    54u,
    55u,
    50u,
    52u,
    55u,
    99u,
    97u,
    98u,
    49u,
    100u,
    50u,
    48u,
    48u,
    53u,
    48u,
    99u,
    102u,
    49u,
    49u,
    99u,
    50u,
    55u,
    54u,
    48u,
    56u,
    53u,
    98u,
    57u,
    48u,
    55u,
    51u,
    50u,
    49u,
    49u,
    48u,
    99u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    54u,
    57u,
    102u,
    49u,
    100u,
    54u,
    53u,
    48u,
    55u,
    102u,
    52u,
    98u,
    55u,
    98u,
    53u,
    48u,
    57u,
    56u,
    48u,
    57u,
    51u,
    48u,
    102u,
    55u,
    100u,
    56u,
    48u,
    56u,
    57u,
    56u,
    51u,
    52u,
    102u,
    98u,
    101u,
    54u,
    53u,
    102u,
    48u,
    57u,
    56u,
    48u,
    98u,
    56u,
    53u,
    57u,
    50u,
    100u,
    53u,
    51u,
    99u,
    100u,
    100u,
    97u,
    48u,
    56u,
    101u,
    53u,
    48u,
    100u,
    50u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    55u,
    100u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    101u,
    101u,
    98u,
    48u,
    48u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    101u,
    52u,
    102u,
    54u,
    53u,
    52u,
    100u,
    50u,
    54u,
    97u,
    98u,
    56u,
    99u,
    57u,
    49u,
    54u,
    52u,
    102u,
    102u,
    51u,
    49u,
    49u,
    54u,
    53u,
    55u,
    97u,
    57u,
    102u,
    57u,
    99u,
    52u,
    99u,
    100u,
    99u,
    48u,
    101u,
    56u,
    97u,
    48u,
    57u,
    51u,
    51u,
    52u,
    57u,
    50u,
    53u,
    102u,
    55u,
    99u,
    48u,
    50u,
    49u,
    51u,
    56u,
    56u,
    49u,
    57u,
    100u,
    55u,
    101u,
    54u,
    49u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    57u,
    50u,
    51u,
    98u,
    54u,
    51u,
    102u,
    53u,
    51u,
    99u,
    55u,
    50u,
    99u,
    48u,
    52u,
    101u,
    98u,
    101u,
    54u,
    99u,
    49u,
    99u,
    57u,
    49u,
    52u,
    48u,
    98u,
    54u,
    51u,
    55u,
    55u,
    49u,
    51u,
    50u,
    98u,
    54u,
    101u,
    53u,
    48u,
    56u,
    54u,
    53u,
    56u,
    49u,
    52u,
    102u,
    101u,
    53u,
    54u,
    50u,
    50u,
    57u,
    49u,
    98u,
    100u,
    48u,
    50u,
    51u,
    100u,
    51u,
    52u,
    56u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    53u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    53u,
    50u,
    101u,
    48u,
    48u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    100u,
    98u,
    57u,
    49u,
    97u,
    50u,
    53u,
    52u,
    48u,
    49u,
    97u,
    56u,
    57u,
    100u,
    97u,
    102u,
    57u,
    102u,
    102u,
    55u,
    100u,
    55u,
    57u,
    53u,
    52u,
    98u,
    97u,
    98u,
    55u,
    50u,
    50u,
    98u,
    56u,
    57u,
    52u,
    98u,
    97u,
    52u,
    56u,
    48u,
    102u,
    101u,
    102u,
    97u,
    102u,
    49u,
    102u,
    48u,
    97u,
    57u,
    53u,
    97u,
    97u,
    102u,
    53u,
    102u,
    54u,
    48u,
    48u,
    53u,
    54u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    101u,
    57u,
    56u,
    49u,
    55u,
    49u,
    54u,
    48u,
    101u,
    51u,
    53u,
    100u,
    52u,
    52u,
    49u,
    48u,
    54u,
    48u,
    49u,
    99u,
    56u,
    100u,
    99u,
    55u,
    52u,
    49u,
    99u,
    49u,
    97u,
    56u,
    49u,
    48u,
    99u,
    52u,
    56u,
    53u,
    102u,
    51u,
    98u,
    52u,
    48u,
    97u,
    48u,
    56u,
    53u,
    57u,
    98u,
    101u,
    53u,
    102u,
    53u,
    56u,
    102u,
    48u,
    98u,
    102u,
    54u,
    101u,
    102u,
    49u,
    54u,
    57u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    51u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    101u,
    49u,
    102u,
    48u,
    48u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    101u,
    50u,
    49u,
    53u,
    55u,
    56u,
    53u,
    49u,
    55u,
    56u,
    102u,
    102u,
    54u,
    51u,
    53u,
    48u,
    48u,
    54u,
    52u,
    48u,
    54u,
    48u,
    101u,
    98u,
    98u,
    98u,
    50u,
    49u,
    57u,
    97u,
    55u,
    49u,
    55u,
    49u,
    54u,
    97u,
    49u,
    48u,
    101u,
    56u,
    56u,
    53u,
    50u,
    56u,
    102u,
    99u,
    52u,
    98u,
    98u,
    49u,
    99u,
    98u,
    53u,
    99u,
    56u,
    102u,
    100u,
    100u,
    48u,
    99u,
    102u,
    54u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    53u,
    49u,
    52u,
    99u,
    102u,
    55u,
    51u,
    56u,
    52u,
    53u,
    53u,
    97u,
    53u,
    52u,
    102u,
    48u,
    48u,
    52u,
    101u,
    99u,
    56u,
    54u,
    101u,
    100u,
    97u,
    102u,
    99u,
    102u,
    100u,
    57u,
    102u,
    100u,
    50u,
    48u,
    50u,
    50u,
    48u,
    49u,
    55u,
    98u,
    98u,
    51u,
    49u,
    99u,
    50u,
    52u,
    53u,
    51u,
    52u,
    48u,
    51u,
    53u,
    51u,
    57u,
    49u,
    49u,
    55u,
    52u,
    52u,
    102u,
    98u,
    55u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    49u,
    102u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    54u,
    53u,
    102u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    97u,
    102u,
    97u,
    97u,
    56u,
    54u,
    100u,
    101u,
    102u,
    101u,
    56u,
    53u,
    48u,
    98u,
    48u,
    53u,
    55u,
    97u,
    101u,
    55u,
    52u,
    102u,
    55u,
    50u,
    49u,
    56u,
    97u,
    55u,
    57u,
    98u,
    48u,
    101u,
    100u,
    101u,
    48u,
    56u,
    54u,
    97u,
    49u,
    57u,
    54u,
    102u,
    49u,
    56u,
    102u,
    48u,
    101u,
    55u,
    99u,
    53u,
    56u,
    53u,
    101u,
    98u,
    56u,
    56u,
    100u,
    49u,
    49u,
    51u,
    57u,
    97u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    100u,
    98u,
    100u,
    53u,
    51u,
    102u,
    99u,
    99u,
    54u,
    52u,
    56u,
    53u,
    48u,
    98u,
    53u,
    51u,
    51u,
    52u,
    54u,
    55u,
    56u,
    49u,
    57u,
    57u,
    100u,
    55u,
    54u,
    57u,
    53u,
    49u,
    52u,
    56u,
    49u,
    56u,
    102u,
    98u,
    99u,
    99u,
    55u,
    57u,
    56u,
    54u,
    49u,
    102u,
    99u,
    55u,
    55u,
    101u,
    53u,
    55u,
    50u,
    98u,
    98u,
    52u,
    55u,
    53u,
    51u,
    98u,
    55u,
    102u,
    101u,
    50u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    100u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    51u,
    56u,
    57u,
    48u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    54u,
    53u,
    51u,
    100u,
    102u,
    53u,
    57u,
    53u,
    54u,
    101u,
    99u,
    101u,
    53u,
    49u,
    56u,
    97u,
    55u,
    56u,
    97u,
    53u,
    100u,
    49u,
    49u,
    50u,
    57u,
    55u,
    52u,
    51u,
    49u,
    97u,
    102u,
    57u,
    52u,
    99u,
    101u,
    56u,
    98u,
    97u,
    57u,
    49u,
    100u,
    56u,
    48u,
    99u,
    102u,
    98u,
    50u,
    97u,
    97u,
    56u,
    99u,
    53u,
    98u,
    51u,
    48u,
    57u,
    53u,
    102u,
    97u,
    50u,
    53u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    54u,
    102u,
    99u,
    52u,
    97u,
    97u,
    53u,
    100u,
    97u,
    56u,
    51u,
    57u,
    98u,
    97u,
    50u,
    54u,
    55u,
    99u,
    51u,
    54u,
    97u,
    97u,
    49u,
    97u,
    53u,
    98u,
    50u,
    57u,
    100u,
    56u,
    49u,
    51u,
    55u,
    52u,
    55u,
    98u,
    50u,
    50u,
    55u,
    51u,
    100u,
    99u,
    48u,
    51u,
    97u,
    97u,
    57u,
    101u,
    52u,
    48u,
    52u,
    99u,
    52u,
    100u,
    97u,
    48u,
    50u,
    51u,
    56u,
    101u,
    50u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    99u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    101u,
    55u,
    48u,
    48u,
    48u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    50u,
    51u,
    56u,
    48u,
    54u,
    97u,
    53u,
    51u,
    51u,
    98u,
    100u,
    57u,
    53u,
    54u,
    55u,
    56u,
    55u,
    101u,
    101u,
    102u,
    53u,
    50u,
    100u,
    100u,
    56u,
    101u,
    100u,
    101u,
    101u,
    52u,
    53u,
    54u,
    99u,
    54u,
    48u,
    100u,
    54u,
    99u,
    101u,
    99u,
    98u,
    98u,
    54u,
    49u,
    55u,
    53u,
    52u,
    53u,
    56u,
    101u,
    101u,
    53u,
    51u,
    102u,
    99u,
    56u,
    99u,
    54u,
    99u,
    56u,
    49u,
    51u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
const pthread_rwlock_t _func___12716 =
{
  {
    1684107116,
    1835365471u,
    1969446768u,
    1717989236u,
    115u,
    1852270963u,
    97u,
    108u,
    95u,
    119u,
    1600877167
  }
}; // idb
const char a02d02d02d03d[20] = "[%02d:%02d:%02d.%03d"; // idb
const unsigned __int8 word_4D07C = 93u; // idb
const char word_4E82C[] = { '0', '\0' }; // idb
const unsigned __int8 _PRETTY_FUNCTION___14401[18] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  99u,
  53u,
  95u,
  100u,
  101u,
  116u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12561[36] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  97u,
  110u,
  100u,
  95u,
  106u,
  111u,
  98u,
  95u,
  105u,
  100u,
  95u,
  115u,
  116u,
  111u,
  114u,
  101u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const freq_pll freq_pll_1385[114] =
{
  { &a100, 131136u, 1056u, 2097729u },
  { &a125, 163904u, 1056u, 2622017u },
  { &a150, 196672u, 1056u, 3146305u },
  { &a175, 229440u, 1056u, 3670593u },
  { &a200_0, 262208u, 1056u, 4194881u },
  { &a225, 294976u, 1056u, 4719169u },
  { &a250, 327744u, 1056u, 5243457u },
  { &a275, 360512u, 1056u, 5767745u },
  { &a300, 393280u, 1056u, 6292033u },
  { &a325, 426048u, 1056u, 6816321u },
  { &a350, 458816u, 1056u, 7340609u },
  { &a375, 491584u, 1056u, 7864897u },
  { &off_536BC, 524352u, 1056u, 8389185u },
  { &off_536C0, 397376u, 800u, 6357553u },
  { &off_536C4, 266304u, 544u, 4260385u },
  { &off_536C8, 401472u, 800u, 6423089u },
  { &off_536CC, 270400u, 544u, 4325921u },
  { &off_536D0, 409664u, 800u, 6554161u },
  { &off_536D4, 274496u, 544u, 4391457u },
  { &off_536D8, 413760u, 800u, 6619697u },
  { &off_536DC, 278592u, 544u, 4456993u },
  { &off_536E0, 421952u, 800u, 6750769u },
  { &off_536E4, 282688u, 544u, 4522529u },
  { &off_536E8, 426048u, 800u, 6816305u },
  { &off_536EC, 286784u, 544u, 4588065u },
  { &off_536F0, 434240u, 800u, 6947377u },
  { &off_536F4, 290880u, 544u, 4653601u },
  { &off_536F8, 438336u, 800u, 7012913u },
  { &off_536FC, 294976u, 544u, 4719137u },
  { &off_53700, 446528u, 800u, 7143985u },
  { &off_53704, 299072u, 544u, 4784673u },
  { &off_53708, 450624u, 800u, 7209521u },
  { &off_5370C, 303168u, 544u, 4850209u },
  { &off_53710, 458816u, 800u, 7340593u },
  { &off_53714, 307264u, 544u, 4915745u },
  { &off_53718, 462912u, 800u, 7406129u },
  { &off_5371C, 311360u, 544u, 4981281u },
  { &off_53720, 471104u, 800u, 7537201u },
  { &off_53724, 315456u, 544u, 5046817u },
  { &off_53728, 475200u, 800u, 7602737u },
  { &off_5372C, 319552u, 544u, 5112353u },
  { &off_53730, 483392u, 800u, 7733809u },
  { &off_53734, 323648u, 544u, 5177889u },
  { &off_53738, 487488u, 800u, 7799345u },
  { &unk_5373C, 327744u, 544u, 5243425u },
  { &unk_53740, 495680u, 800u, 7930417u },
  { &unk_53744, 331840u, 544u, 5308961u },
  { &unk_53748, 499776u, 800u, 7995953u },
  { &unk_5374C, 335936u, 544u, 5374497u },
  { &unk_53750, 507968u, 800u, 8127025u },
  { &unk_53754, 340032u, 544u, 5440033u },
  { &unk_53758, 512064u, 800u, 8192561u },
  { &unk_5375C, 344128u, 544u, 5505569u },
  { &unk_53760, 520256u, 800u, 8323633u },
  { &unk_53764, 348224u, 544u, 5571105u },
  { &unk_53768, 524352u, 800u, 8389169u },
  { &unk_5376C, 352320u, 544u, 5636641u },
  { &unk_53770, 356416u, 544u, 5702177u },
  { &unk_53774, 360512u, 544u, 5767713u },
  { &unk_53778, 364608u, 544u, 5833249u },
  { &unk_5377C, 368704u, 544u, 5898785u },
  { &unk_53780, 372800u, 544u, 5964321u },
  { &unk_53784, 376896u, 544u, 6029857u },
  { &unk_53788, 380992u, 544u, 6095393u },
  { &unk_5378C, 385088u, 544u, 6160929u },
  { &unk_53790, 389184u, 544u, 6226465u },
  { &unk_53794, 393280u, 544u, 6292001u },
  { &unk_53798, 397376u, 544u, 6357537u },
  { &unk_5379C, 401472u, 544u, 6423073u },
  { &unk_537A0, 405568u, 544u, 6488609u },
  { &unk_537A4, 409664u, 544u, 6554145u },
  { &unk_537A8, 413760u, 544u, 6619681u },
  { &unk_537AC, 417856u, 544u, 6685217u },
  { &unk_537B0, 421952u, 544u, 6750753u },
  { &unk_537B4, 426048u, 544u, 6816289u },
  { &unk_537B8, 430144u, 544u, 6881825u },
  { &unk_537BC, 434240u, 544u, 6947361u },
  { &unk_537C0, 438336u, 544u, 7012897u },
  { &unk_537C4, 442432u, 544u, 7078433u },
  { &unk_537C8, 446528u, 544u, 7143969u },
  { &unk_537CC, 450624u, 544u, 7209505u },
  { &unk_537D0, 454720u, 544u, 7275041u },
  { &unk_537D4, 458816u, 544u, 7340577u },
  { &unk_537D8, 462912u, 544u, 7406113u },
  { &unk_537DC, 467008u, 544u, 7471649u },
  { &unk_537E0, 471104u, 544u, 7537185u },
  { &unk_537E4, 475200u, 544u, 7602721u },
  { &unk_537E8, 479296u, 544u, 7668257u },
  { &unk_537EC, 483392u, 544u, 7733793u },
  { &unk_537F0, 487488u, 544u, 7799329u },
  { &unk_537F4, 491584u, 544u, 7864865u },
  { &unk_537F8, 495680u, 544u, 7930401u },
  { &unk_537FC, 499776u, 544u, 7995937u },
  { &unk_53800, 503872u, 544u, 8061473u },
  { &unk_53804, 507968u, 544u, 8127009u },
  { &unk_53808, 512064u, 544u, 8192545u },
  { &unk_5380C, 516160u, 544u, 8258081u },
  { &unk_53810, 520256u, 544u, 8323617u },
  { &off_53814, 524352u, 544u, 8389153u },
  { &off_53818, 270400u, 288u, 4325905u },
  { &off_5381C, 278592u, 288u, 4456977u },
  { &off_53820, 286784u, 288u, 4588049u },
  { &unk_53824, 294976u, 288u, 4719121u },
  { &unk_53828, 303168u, 288u, 4850193u },
  { &unk_5382C, 311360u, 288u, 4981265u },
  { &unk_53830, 319552u, 288u, 5112337u },
  { &a1000, 327744u, 288u, 5243409u },
  { &a1025, 335936u, 288u, 5374481u },
  { &a1050, 344128u, 288u, 5505553u },
  { &a1075, 352320u, 288u, 5636625u },
  { &a1100, 360512u, 288u, 5767697u },
  { &a1125, 368704u, 288u, 5898769u },
  { &a1150, 376896u, 288u, 6029841u },
  { &a1175, 385088u, 288u, 6160913u }
}; // idb
const unsigned __int8 _func___14388[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  99u,
  53u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  0u
}; // idb
const pthread_mutex_t _func___14299 = { { 2037411683, 1869574239u, 1953718124, 1970561394, 109u, { 1836345698 } } }; // idb
const unsigned __int8 _FUNCTION___14492[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
int CSWTCH_824[] = { 1 }; // weak
int CSWTCH_825[] = { 0 }; // weak
const unsigned __int8 _FUNCTION___12110[12] = { 103u, 101u, 116u, 95u, 112u, 105u, 99u, 95u, 105u, 105u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___12117[12] = { 115u, 101u, 116u, 95u, 112u, 105u, 99u, 95u, 105u, 105u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___12317[19] =
{
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  98u,
  121u,
  116u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12333[21] =
{
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  115u,
  97u,
  118u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12306[20] =
{
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  98u,
  121u,
  116u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12567[22] =
{
  103u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12572[22] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12584[26] =
{
  103u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12589[26] =
{
  115u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12633[16] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12638[16] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12644[17] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  111u,
  110u,
  95u,
  112u,
  108u,
  117u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12653[21] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  114u,
  100u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12663[14] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  115u,
  112u,
  101u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12685[21] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12690[21] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12696[22] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12702[22] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12716[21] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12730[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12735[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12741[11] = { 103u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___12746[11] = { 115u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___12752[15] =
{
  103u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12757[15] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12763[25] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12768[25] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12773[15] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12778[15] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12784[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12789[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12795[20] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  114u,
  101u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12801[20] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  114u,
  101u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12807[38] =
{
  103u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12812[38] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12818[16] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12824[16] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12830[22] =
{
  103u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12835[22] =
{
  115u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12841[25] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12846[25] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12852[22] =
{
  103u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12858[22] =
{
  115u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12886[25] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12891[25] =
{
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12508[34] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  116u,
  111u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12490[39] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  101u,
  114u,
  97u,
  115u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  97u,
  112u,
  112u,
  95u,
  112u,
  114u,
  111u,
  103u,
  114u,
  97u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12447[34] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  100u,
  99u,
  95u,
  100u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12352[35] =
{
  115u,
  101u,
  116u,
  95u,
  86u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  83u,
  57u,
  95u,
  112u,
  108u,
  117u,
  115u,
  95u,
  112u,
  108u,
  117u,
  115u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  55u,
  95u,
  53u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12251[27] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12528[40] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  97u,
  112u,
  112u,
  95u,
  112u,
  114u,
  111u,
  103u,
  114u,
  97u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12238[41] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  106u,
  117u,
  109u,
  112u,
  95u,
  116u,
  111u,
  95u,
  97u,
  112u,
  112u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  108u,
  111u,
  97u,
  100u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12219[36] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  103u,
  101u,
  116u,
  95u,
  112u,
  105u,
  99u,
  95u,
  115u,
  119u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13127[14] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  117u,
  101u,
  110u,
  99u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13215[24] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  117u,
  101u,
  110u,
  99u,
  121u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14025[23] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  97u,
  110u,
  100u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13236[19] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13343[24] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  111u,
  110u,
  101u,
  67u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13373[25] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13448[19] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12949[33] =
{
  115u,
  101u,
  116u,
  95u,
  80u,
  87u,
  77u,
  95u,
  97u,
  99u,
  99u,
  111u,
  114u,
  100u,
  105u,
  110u,
  103u,
  95u,
  116u,
  111u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13640[15] =
{
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  105u,
  110u,
  97u,
  99u,
  116u,
  105u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13654[12] = { 115u, 101u, 116u, 95u, 97u, 100u, 100u, 114u, 101u, 115u, 115u, 0u }; // idb
const unsigned __int8 _FUNCTION___13675[29] =
{
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  95u,
  111u,
  110u,
  67u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13689[21] =
{
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13709[21] =
{
  115u,
  101u,
  116u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13734[9] = { 115u, 101u, 116u, 95u, 98u, 97u, 117u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___13835[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  115u,
  121u,
  115u,
  116u,
  101u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13874[10] = { 111u, 112u, 101u, 110u, 95u, 99u, 111u, 114u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___13924[20] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13527[20] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  114u,
  101u,
  105u,
  110u,
  105u,
  116u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13970[18] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  111u,
  110u,
  67u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14073[15] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  114u,
  101u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14112[16] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  99u,
  53u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14391[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  99u,
  53u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14261[9] = { 115u, 101u, 110u, 100u, 95u, 106u, 111u, 98u, 0u }; // idb
const pthread_mutex_t _func___14527 = { { 1836345698, 1601071457u, 1969173859, 1952539760, 101u, { 1668572463 } } }; // idb
const char aSVoltage1D127[28] = "\n--- %s voltage1(%d) > 127 \n"; // idb
const char ptr[] = { '\n', '\0' }; // idb
const char aSResetPicError[24] = "!!! %s: reset pic error!"; // idb
const unsigned __int8 _func___9335[9] = { 100u, 117u, 112u, 97u, 108u, 108u, 111u, 99u, 0u }; // idb
const unsigned __int8 _func___9351[11] = { 105u, 115u, 100u, 117u, 112u, 110u, 111u, 110u, 99u, 101u, 0u }; // idb
const unsigned __int8 *const type_names[8] =
{
  &aObject,
  (const unsigned __int8 *const)0x53DF8,
  &aString,
  (const unsigned __int8 *const)0x540D0,
  &aReal,
  &aTrue,
  &aFalse,
  &aNull_0
}; // idb
const unsigned __int8 unpack_value_starters[12] = { 123u, 91u, 115u, 105u, 73u, 98u, 102u, 70u, 79u, 111u, 110u, 0u }; // idb
const unsigned __int8 whitespace[33] =
{
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  0u
}; // idb
_UNKNOWN distfix_6142; // weak
__int16 order_6170[7] = { 16, 17, 18, 0, 8, 7, 9 }; // weak
_UNKNOWN unk_54B56; // weak
_UNKNOWN unk_54B6C; // weak
_UNKNOWN unk_54B88; // weak
_UNKNOWN unk_54B96; // weak
void *dext_6056 = (void *)0x100010; // weak
_UNKNOWN dbase_6055; // weak
char *z_errmsg[2] = { "need dictionary", "stream end" }; // weak
_DWORD crc_table[2048] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  0,
  421212481,
  842424962,
  724390851,
  1684849924,
  2105013317,
  1448781702,
  1329698503,
  -925267448,
  -775767223,
  -84940662,
  -470492725,
  -1397403892,
  -1246855603,
  -1635570290,
  -2020074289,
  1254232657,
  1406739216,
  2029285587,
  1643069842,
  783210325,
  934667796,
  479770071,
  92505238,
  -2112120743,
  -1694455528,
  -1339163941,
  -1456026726,
  -428384931,
  -9671652,
  -733921313,
  -849736034,
  -1786501982,
  -1935731229,
  -1481488864,
  -1096190111,
  -236396122,
  -386674457,
  -1008827612,
  -624577947,
  1566420650,
  1145479147,
  1869335592,
  1987116393,
  959540142,
  539646703,
  185010476,
  303839341,
  -549046541,
  -966981710,
  -311405455,
  -194288336,
  -1154812937,
  -1573797194,
  -1994616459,
  -1878548428,
  396344571,
  243568058,
  631889529,
  1018359608,
  1945336319,
  1793607870,
  1103436669,
  1490954812,
  -260485371,
  -379421116,
  -1034998393,
  -615244602,
  -1810527743,
  -1928414400,
  -1507596157,
  -1086793278,
  950060301,
  565965900,
  177645455,
  328046286,
  1556873225,
  1171730760,
  1861902987,
  2011255754,
  -1162125996,
  -1549767659,
  -2004009002,
  -1852436841,
  -556296112,
  -942888687,
  -320734510,
  -168113261,
  1919080284,
  1803150877,
  1079293406,
  1498383519,
  370020952,
  253043481,
  607678682,
  1025720731,
  1711106983,
  2095471334,
  1472923941,
  1322268772,
  26324643,
  411738082,
  866634785,
  717028704,
  -1390091857,
  -1270886162,
  -1626176723,
  -2046184852,
  -918018901,
  -799861270,
  -75610583,
  -496666776,
  792689142,
  908347575,
  487136116,
  68299317,
  1263779058,
  1380486579,
  2036719216,
  1618931505,
  -404294658,
  -16923969,
  -707751556,
  -859070403,
  -2088093958,
  -1701771333,
  -1313057672,
  -1465424583,
  998479947,
  580430090,
  162921161,
  279890824,
  1609522511,
  1190423566,
  1842954189,
  1958874764,
  -212200893,
  -364829950,
  -1049857855,
  -663273088,
  -1758013625,
  -1909594618,
  -1526680123,
  -1139047292,
  1900120602,
  1750776667,
  1131931800,
  1517083097,
  355290910,
  204897887,
  656092572,
  1040194781,
  -1181220846,
  -1602014893,
  -1951505776,
  -1833610287,
  -571161322,
  -990907305,
  -272455788,
  -153512235,
  -1375224599,
  -1222865496,
  -1674453397,
  -2060783830,
  -898926099,
  -747616084,
  -128115857,
  -515495378,
  1725839073,
  2143618976,
  1424512099,
  1307796770,
  45282277,
  464110244,
  813994343,
  698327078,
  -456806728,
  -35741703,
  -688665542,
  -806814341,
  -2136380484,
  -1716364547,
  -1298200258,
  -1417398145,
  740041904,
  889656817,
  506086962,
  120682355,
  1215357364,
  1366020341,
  2051441462,
  1667084919,
  -872753330,
  -756947441,
  -104024628,
  -522746739,
  -1349119414,
  -1232264437,
  -1650429752,
  -2068102775,
  52649286,
  439905287,
  823476164,
  672009861,
  1733269570,
  2119477507,
  1434057408,
  1281543041,
  -2126985953,
  -1742474146,
  -1290885219,
  -1441425700,
  -447479781,
  -61918886,
  -681418087,
  -830909480,
  1239502615,
  1358593622,
  2077699477,
  1657543892,
  764250643,
  882293586,
  532408465,
  111204816,
  1585378284,
  1197851309,
  1816695150,
  1968414767,
  974272232,
  587794345,
  136598634,
  289367339,
  -1767409180,
  -1883486043,
  -1533994138,
  -1115018713,
  -221528864,
  -338653791,
  -1057104286,
  -639176925,
  347922877,
  229101820,
  646611775,
  1066513022,
  1892689081,
  1774917112,
  1122387515,
  1543337850,
  -597333067,
  -981574924,
  -296548041,
  -146261898,
  -1207325007,
  -1592614928,
  -1975530445,
  -1826292366,
  0,
  29518391,
  59036782,
  38190681,
  118073564,
  114017003,
  76381362,
  89069189,
  236147128,
  265370511,
  228034006,
  206958561,
  152762724,
  148411219,
  178138378,
  190596925,
  472294256,
  501532999,
  530741022,
  509615401,
  456068012,
  451764635,
  413917122,
  426358261,
  305525448,
  334993663,
  296822438,
  275991697,
  356276756,
  352202787,
  381193850,
  393929805,
  944588512,
  965684439,
  1003065998,
  973863097,
  1061482044,
  1049003019,
  1019230802,
  1023561829,
  912136024,
  933002607,
  903529270,
  874031361,
  827834244,
  815125939,
  852716522,
  856752605,
  611050896,
  631869351,
  669987326,
  640506825,
  593644876,
  580921211,
  551983394,
  556069653,
  712553512,
  733666847,
  704405574,
  675154545,
  762387700,
  749958851,
  787859610,
  792175277,
  1889177024,
  1901651959,
  1931368878,
  1927033753,
  2006131996,
  1985040171,
  1947726194,
  1976933189,
  2122964088,
  2135668303,
  2098006038,
  2093965857,
  2038461604,
  2017599123,
  2047123658,
  2076625661,
  1824272048,
  1836991623,
  1866005214,
  1861914857,
  1807058540,
  1786244187,
  1748062722,
  1777547317,
  1655668488,
  1668093247,
  1630251878,
  1625932113,
  1705433044,
  1684323811,
  1713505210,
  1742760333,
  1222101792,
  1226154263,
  1263738702,
  1251046777,
  1339974652,
  1310460363,
  1281013650,
  1301863845,
  1187289752,
  1191637167,
  1161842422,
  1149379777,
  1103966788,
  1074747507,
  1112139306,
  1133218845,
  1425107024,
  1429406311,
  1467333694,
  1454888457,
  1408811148,
  1379576507,
  1350309090,
  1371438805,
  1524775400,
  1528845279,
  1499917702,
  1487177649,
  1575719220,
  1546255107,
  1584350554,
  1605185389,
  -516613248,
  -520654409,
  -491663378,
  -478960167,
  -432229540,
  -402728597,
  -440899790,
  -461763323,
  -282703304,
  -287039473,
  -324886954,
  -312413087,
  -399514908,
  -370308909,
  -341100918,
  -362193731,
  -49039120,
  -53357881,
  -23630690,
  -11204951,
  -98955220,
  -69699045,
  -107035582,
  -128143755,
  -218044088,
  -222133377,
  -259769050,
  -247048431,
  -200719980,
  -171234397,
  -141715974,
  -162529331,
  -646423200,
  -658884777,
  -620984050,
  -616635591,
  -562956868,
  -541876341,
  -571137582,
  -600355867,
  -680850216,
  -693541137,
  -722478922,
  -718425471,
  -798841852,
  -777990605,
  -739872662,
  -769385891,
  -983630320,
  -996371417,
  -958780802,
  -954711991,
  -1034463540,
  -1013629701,
  -1043103070,
  -1072568171,
  -884101208,
  -896547425,
  -926319674,
  -922021391,
  -867956876,
  -846828221,
  -809446630,
  -838682323,
  -1850763712,
  -1871840137,
  -1842658770,
  -1813436391,
  -1767489892,
  -1755032405,
  -1792873742,
  -1797226299,
  -1615017992,
  -1635865137,
  -1674046570,
  -1644529247,
  -1732939996,
  -1720253165,
  -1691239606,
  -1695297155,
  -1920387792,
  -1941217529,
  -1911692962,
  -1882223767,
  -1971282452,
  -1958545445,
  -1996207742,
  -2000280651,
  -2087033720,
  -2108158273,
  -2145472282,
  -2116232495,
  -2070688684,
  -2058246557,
  -2028529606,
  -2032831987,
  -1444753248,
  -1474250089,
  -1436154674,
  -1415287047,
  -1360299908,
  -1356262837,
  -1385190382,
  -1397897691,
  -1477345000,
  -1506546897,
  -1535814282,
  -1514717375,
  -1594349116,
  -1590017037,
  -1552089686,
  -1564567651,
  -1245416496,
  -1274668569,
  -1237276738,
  -1216164471,
  -1295131892,
  -1290817221,
  -1320611998,
  -1333041835,
  -1143528856,
  -1173010337,
  -1202457082,
  -1181639631,
  -1126266188,
  -1122180989,
  -1084596518,
  -1097321235,
  0,
  -1195612315,
  -1442199413,
  313896942,
  -1889364137,
  937357362,
  627793884,
  -1646839623,
  -978048785,
  2097696650,
  1874714724,
  -687765759,
  1255587768,
  -227878691,
  -522225869,
  1482887254,
  1343838111,
  -391827206,
  -99573996,
  1118632049,
  -545537848,
  1741137837,
  1970407491,
  -842109146,
  -1783791760,
  756094997,
  1067759611,
  -2028416866,
  449832999,
  -1569484990,
  -1329192788,
  142231497,
  -1607291074,
  412010587,
  171665333,
  -1299775280,
  793786473,
  -1746116852,
  -2057703198,
  1038456711,
  1703315409,
  -583343948,
  -812691622,
  1999841343,
  -354152314,
  1381529571,
  1089329165,
  -128860312,
  -265553759,
  1217896388,
  1512189994,
  -492939441,
  2135519222,
  -940242797,
  -717183107,
  1845280792,
  899665998,
  -1927039189,
  -1617553211,
  657096608,
  -1157806311,
  37822588,
  284462994,
  -1471616777,
  -1693165507,
  598228824,
  824021174,
  -1985873965,
  343330666,
  -1396004849,
  -1098971167,
  113467524,
  1587572946,
  -434366537,
  -190203815,
  1276501820,
  -775755899,
  1769898208,
  2076913422,
  -1015592853,
  -888336478,
  1941006535,
  1627703081,
  -642211764,
  1148164341,
  -53215344,
  -295284610,
  1457141531,
  247015245,
  -1241169880,
  -1531908154,
  470583459,
  -2116308966,
  963106687,
  735213713,
  -1821499404,
  992409347,
  -2087022490,
  -1859174520,
  697522413,
  -1270587308,
  217581361,
  508405983,
  -1494102086,
  -23928852,
  1177467017,
  1419450215,
  -332959742,
  1911572667,
  -917753890,
  -604405712,
  1665525589,
  1799331996,
  -746338311,
  -1053399017,
  2039091058,
  -463652917,
  1558270126,
  1314193216,
  -152528859,
  -1366587277,
  372764438,
  75645176,
  -1136777315,
  568925988,
  -1722451903,
  -1948198993,
  861712586,
  -312887749,
  1441124702,
  1196457648,
  -1304107,
  1648042348,
  -628668919,
  -936187417,
  1888390786,
  686661332,
  -1873675855,
  -2098964897,
  978858298,
  -1483798141,
  523464422,
  226935048,
  -1254447507,
  -1119821404,
  100435649,
  390670639,
  -1342878134,
  841119475,
  -1969352298,
  -1741963656,
  546822429,
  2029308235,
  -1068978642,
  -755170880,
  1782671013,
  -141140452,
  1328167289,
  1570739863,
  -450629134,
  1298864389,
  -170426784,
  -412954226,
  1608431339,
  -1039561134,
  2058742071,
  1744848601,
  -792976964,
  -1998638614,
  811816591,
  584513889,
  -1704288764,
  129869501,
  -1090403880,
  -1380684234,
  352848211,
  494030490,
  -1513215489,
  -1216641519,
  264757620,
  -1844389427,
  715964072,
  941166918,
  -2136639965,
  -658086283,
  1618608400,
  1926213374,
  -898381413,
  1470427426,
  -283601337,
  -38979159,
  1158766284,
  1984818694,
  -823031453,
  -599513459,
  1693991400,
  -114329263,
  1100160564,
  1395044826,
  -342174017,
  -1275476247,
  189112716,
  435162722,
  -1588827897,
  1016811966,
  -2077804837,
  -1768777419,
  774831696,
  643086745,
  -1628905732,
  -1940033262,
  887166583,
  -1456066866,
  294275499,
  54519365,
  -1149009632,
  -471821962,
  1532818963,
  1240029693,
  -246071656,
  1820460577,
  -734109372,
  -963916118,
  2117577167,
  -696303304,
  1858283101,
  2088143283,
  -993333546,
  1495127663,
  -509497078,
  -216785180,
  1269332353,
  332098007,
  -1418260814,
  -1178427044,
  25085497,
  -1666580864,
  605395429,
  916469259,
  -1910746770,
  -2040129881,
  1054503362,
  745528876,
  -1798063799,
  151290352,
  -1313282411,
  -1559410309,
  464596510,
  1137851976,
  -76654291,
  -371460413,
  1365741990,
  -860837601,
  1946996346,
  1723425172,
  -570095887,
  0,
  -1775237257,
  744558318,
  -1169094247,
  432303367,
  -1879807376,
  900031465,
  -1550490466,
  847829774,
  -1531388807,
  518641120,
  -1998990697,
  726447625,
  -1115901570,
  120436967,
  -1860321392,
  1678817053,
  -232738710,
  1215412723,
  -566116732,
  2111101466,
  -337322643,
  1370871028,
  -947530877,
  1452829715,
  -1062704284,
  2063164157,
  -322345590,
  1331429652,
  -647231901,
  1664946170,
  -183695219,
  -937398725,
  1578133836,
  -465477419,
  1920034722,
  -773586116,
  1205077067,
  -41611822,
  1807026853,
  -89606859,
  1821946434,
  -691422245,
  1090108588,
  -479406030,
  1969020741,
  -821176612,
  1497223595,
  -1406084826,
  973135441,
  -2142119992,
  375509183,
  -1242254303,
  600093526,
  -1718240561,
  262520248,
  -1632107992,
  143131999,
  -1294398266,
  619252657,
  -2021888209,
  290220120,
  -1424137791,
  1026385590,
  -1874731914,
  108124929,
  -1138699624,
  705746415,
  -1987726991,
  532002310,
  -1511735393,
  869578984,
  -1563883656,
  888733711,
  -1901590122,
  412618465,
  -1156748673,
  759000328,
  -1754504047,
  22832102,
  -195990677,
  1650551836,
  -667916923,
  1308648178,
  -309000596,
  2074411291,
  -1040971646,
  1472466933,
  -958812059,
  1357494034,
  -356991349,
  2089335292,
  -551690910,
  1227741717,
  -209923188,
  1699534075,
  1482797645,
  -833505990,
  1946205347,
  -500122668,
  1101389642,
  -678045635,
  1841615268,
  -67840301,
  1793681731,
  -52859340,
  1183344557,
  -793222950,
  1932330052,
  -451083469,
  1598818986,
  -914616867,
  1014039888,
  -1438580185,
  269487038,
  -2044719927,
  632645719,
  -1283100896,
  164914873,
  -1612422706,
  251256414,
  -1731602135,
  580440240,
  -1264003129,
  389919577,
  -2129808338,
  995933623,
  -1385383232,
  545503469,
  -1229733990,
  216184323,
  -1697468044,
  961009130,
  -1351101795,
  354867972,
  -2095653773,
  302736355,
  -2076482412,
  1047162125,
  -1470469510,
  198119140,
  -1644230253,
  665714698,
  -1315043459,
  1150488560,
  -761067385,
  1760690462,
  -20838807,
  1566008055,
  -882416256,
  1899392025,
  -419009682,
  1981535486,
  -533998711,
  1518000656,
  -867508889,
  1876933113,
  -101728626,
  1136572183,
  -712069024,
  -391915818,
  2123616673,
  -993863624,
  1391648591,
  -244859951,
  1733803174,
  -586762945,
  1261875784,
  -634712616,
  1276840623,
  -162921674,
  1618609217,
  -1007722273,
  1440704424,
  -275878351,
  2042521926,
  -1934401077,
  444819132,
  -1596821723,
  920807506,
  -1787360052,
  54987707,
  -1189739998,
  791020885,
  -1103381819,
  671858098,
  -1839549397,
  74101596,
  -1476405310,
  835702965,
  -1952523988,
  497999451,
  -1329437541,
  653419500,
  -1667011979,
  177433858,
  -1459222116,
  1060507371,
  -2056845454,
  324468741,
  -2109030507,
  343587042,
  -1372868229,
  941340172,
  -1685138798,
  230610405,
  -1209017220,
  568318731,
  -724380794,
  1122161905,
  -122430104,
  1854134815,
  -854147455,
  1529264630,
  -512249745,
  2001188632,
  -430307192,
  1885999103,
  -902101402,
  1544225041,
  -6396529,
  1773036280,
  -738235551,
  1171221526,
  2028079776,
  -288223785,
  1417872462,
  -1028455623,
  1629906855,
  -149528368,
  1296525641,
  -612929986,
  1248514478,
  -598026535,
  1712054080,
  -264513481,
  1403960489,
  -979452962,
  2144318023,
  -369117904,
  485670333,
  -1966949686,
  814986067,
  -1499220956,
  87478458,
  -1828268083,
  693624404,
  -1083713245,
  779773619,
  -1203084860,
  35350621,
  -1809092822,
  935201716,
  -1584526141,
  467600730,
  -1913716179,
  0,
  1093737241,
  -2107492814,
  -1017959125,
  80047204,
  1173649277,
  -2035852714,
  -946454193,
  143317448,
  1237041873,
  -1964445702,
  -874908445,
  206550444,
  1300147893,
  -1909619810,
  -820209529,
  1360183882,
  270784851,
  -747572104,
  -1841172639,
  1440198190,
  350663991,
  -675964900,
  -1769700603,
  1503140738,
  413728923,
  -604361296,
  -1697958231,
  1566406630,
  476867839,
  -549502508,
  -1643226419,
  -1574665067,
  -485122164,
  541504167,
  1635232190,
  -1495144207,
  -405736472,
  612622019,
  1706214874,
  -1431413411,
  -341883324,
  684485487,
  1778217078,
  -1368706759,
  -279303648,
  738789131,
  1832393746,
  -214546721,
  -1308140090,
  1901359341,
  811953140,
  -135058757,
  -1228787294,
  1972444297,
  882902928,
  -71524585,
  -1165130738,
  2044635429,
  955232828,
  -8785037,
  -1102518166,
  2098971969,
  1009442392,
  89094640,
  1149133545,
  -2027073598,
  -971221797,
  25826708,
  1086000781,
  -2081938522,
  -1025951553,
  231055416,
  1291107105,
  -1884842486,
  -828994285,
  151047260,
  1211225925,
  -1956447634,
  -900472457,
  1415429050,
  359440547,
  -700478072,
  -1760651631,
  1352194014,
  296340679,
  -755310100,
  -1815348491,
  1557619314,
  501643627,
  -558541760,
  -1618718887,
  1477578262,
  421729551,
  -630179804,
  -1690229955,
  -1486095003,
  -430250372,
  621398871,
  1681444942,
  -1548840703,
  -492860904,
  567060275,
  1627241514,
  -1344199507,
  -288342092,
  763564703,
  1823607174,
  -1423685431,
  -367701040,
  692485883,
  1752655330,
  -159826129,
  -1220008906,
  1947928861,
  891949572,
  -222538933,
  -1282586542,
  1893623161,
  837779040,
  -17570073,
  -1077740034,
  2089930965,
  1033948108,
  -97088893,
  -1157131878,
  2018819249,
  962963368,
  1268286267,
  178886690,
  -906316535,
  -1999917552,
  1331556191,
  242021446,
  -851453587,
  -1945189772,
  1125276403,
  35865066,
  -1049596735,
  -2143193128,
  1205286551,
  115748238,
  -977993563,
  -2071716932,
  445268337,
  1539005032,
  -1729595581,
  -640062374,
  508505365,
  1602106892,
  -1674765529,
  -585367490,
  302028985,
  1395753888,
  -1872580981,
  -783043182,
  382072029,
  1475669956,
  -1800944913,
  -711534090,
  -373553234,
  -1467147081,
  1809723804,
  720317061,
  -310809654,
  -1404538669,
  1864064504,
  774522593,
  -516497818,
  -1610103425,
  1666508884,
  577106765,
  -437014014,
  -1530746597,
  1737589808,
  648060713,
  -1196505628,
  -106963203,
  986510294,
  2080237775,
  -1133794944,
  -44387687,
  1040818098,
  2134410411,
  -1339810772,
  -250280139,
  843459102,
  1937191175,
  -1260294072,
  -170890415,
  914572922,
  2008178019,
  1322777291,
  266789330,
  -860500743,
  -1920673824,
  1242732207,
  186879414,
  -932142947,
  -1992180860,
  1180508931,
  124532762,
  -1002498767,
  -2062676440,
  1117278055,
  61428862,
  -1057326763,
  -2117377460,
  533018753,
  1593058200,
  -1649996109,
  -594143830,
  453006565,
  1513181180,
  -1721605417,
  -665617970,
  391110985,
  1451162192,
  -1792157829,
  -736310174,
  327847213,
  1388025396,
  -1847018721,
  -791044090,
  -319586722,
  -1379769017,
  1855015020,
  799036277,
  -399109574,
  -1459156701,
  1783899144,
  728055569,
  -461789290,
  -1521959793,
  1713082788,
  657099453,
  -524497934,
  -1584541461,
  1658781120,
  602924761,
  -1109279724,
  -53434611,
  1065585190,
  2125631807,
  -1188769680,
  -132789399,
  994502210,
  2054683995,
  -1251252772,
  -195395899,
  923358190,
  1983400183,
  -1313994312,
  -258010463,
  869023626,
  1929192595,
  0,
  929743361,
  1859421187,
  1505641986,
  -592967417,
  -339555578,
  -1300460284,
  -2062135547,
  -1202646258,
  -1891905265,
  -695888115,
  -504408820,
  1694046729,
  1402198024,
  170761738,
  1028086795,
  1889740316,
  1204413469,
  511156767,
  689791006,
  -1408553189,
  -1688081126,
  -1025529064,
  -172660455,
  -923650798,
  -6752493,
  -1507413743,
  -1857260784,
  341457941,
  590413332,
  2056173590,
  1306819095,
  -532263624,
  -684945607,
  -1902982853,
  -1174926534,
  1022247999,
  193234494,
  1379582012,
  1699742269,
  1477926454,
  1870502967,
  918805045,
  27858996,
  -2067835087,
  -1277848272,
  -362032334,
  -587132621,
  -1864013020,
  -1483757275,
  -30281945,
  -916771546,
  1280139811,
  2066194466,
  580511264,
  368256033,
  682915882,
  534690347,
  1180761129,
  1896496680,
  -199462611,
  -1015631060,
  -1698106066,
  -1381877969,
  -1064461712,
  -135833487,
  -1369891213,
  -1724654478,
  472224631,
  726618486,
  1928402804,
  1167840629,
  2027719038,
  1337346943,
  369626493,
  560123772,
  -1535868807,
  -1826733448,
  -895482758,
  -37042565,
  -1339114388,
  -2025554323,
  -554026897,
  -376374674,
  1820767595,
  1542223722,
  38941032,
  892924777,
  142585698,
  1058368867,
  1722493793,
  1371662688,
  -724064667,
  -474127260,
  -1174199706,
  -1922441113,
  550229832,
  396432713,
  1310675787,
  2037748042,
  -60563889,
  -888595378,
  -1833477556,
  -1512204211,
  -1734687674,
  -1343224249,
  -162643899,
  -1054571964,
  1144180033,
  1935150912,
  719735106,
  495749955,
  1349054804,
  1728197461,
  1052538199,
  165066582,
  -1933510573,
  -1146471854,
  -501973936,
  -713114031,
  -398859686,
  -548200357,
  -2031262119,
  -1316510632,
  881978205,
  66791772,
  1514499934,
  1831841119,
  -2145700383,
  -1217267744,
  -288378398,
  -643468317,
  1555250406,
  1809448679,
  845658341,
  84769508,
  944383727,
  253813998,
  1453236972,
  1643405549,
  -454938648,
  -746000919,
  -1976128533,
  -1118017046,
  -256371715,
  -942484996,
  -1637050370,
  -1459202561,
  739252986,
  461035771,
  1120182009,
  1974361336,
  1223229683,
  2139341554,
  641565936,
  290932465,
  -1807676940,
  -1557410827,
  -90862089,
  -838905866,
  1616738521,
  1463270104,
  243924186,
  971194075,
  -1124765218,
  -1952468001,
  -769526307,
  -448055332,
  -670274601,
  -278484522,
  -1227296812,
  -2119029291,
  77882064,
  869179601,
  1785784019,
  1561994450,
  285105861,
  664050884,
  2116737734,
  1228937415,
  -866756670,
  -79915581,
  -1568484415,
  -1779953216,
  -1464906293,
  -1614442550,
  -964965944,
  -250541111,
  1946633420,
  1131251405,
  450085071,
  767099598,
  1083617169,
  2013031824,
  776088466,
  422111635,
  -1673615722,
  -1420532585,
  -219536747,
  -981409644,
  -121127777,
  -810713442,
  -1777125220,
  -1585841507,
  611300760,
  319125401,
  1253781915,
  2110911386,
  808814989,
  123685772,
  1591807374,
  1770770319,
  -325222262,
  -604552565,
  -2109143927,
  -1255946616,
  -2006672765,
  -1089578878,
  -424665472,
  -774185855,
  1422693252,
  1671844229,
  974657415,
  225629574,
  -1596923223,
  -1749409624,
  -838572374,
  -110189397,
  2088299438,
  1259481519,
  313290669,
  633777580,
  411169191,
  803943334,
  1985312164,
  1094694821,
  -1003882336,
  -213697887,
  -1426228061,
  -1650999646,
  -797719371,
  -417790284,
  -1096335178,
  -1983020361,
  215731634,
  1001459635,
  1645169073,
  1432718256,
  1747113915,
  1598559674,
  116806584,
  832344505,
  -1265967428,
  -2082464579,
  -631350593,
  -315320130,
  0,
  1701297336,
  -1949824598,
  -290474734,
  1469538959,
  854646327,
  -597726427,
  -1187457123,
  -282544955,
  -1974531971,
  1692450159,
  25625047,
  -1195387318,
  -573019406,
  863494112,
  1443914584,
  -1621681840,
  -97475096,
  345968890,
  1912122434,
  -926909473,
  -1381513369,
  1124627061,
  644861645,
  1887415701,
  353898797,
  -71850945,
  -1630529401,
  669568794,
  1116697506,
  -1407138128,
  -918062584,
  1051669152,
  1539870232,
  -1251525878,
  -805271630,
  1765298223,
  207613079,
  -487564923,
  -2020088515,
  -779647387,
  -1260373283,
  1515163599,
  1059599223,
  -2045713174,
  -478717870,
  232320320,
  1757368824,
  -1577571344,
  -996174008,
  707797594,
  1331142370,
  -160478849,
  -1828129337,
  2108113109,
  415300717,
  1322295093,
  733422477,
  -988244321,
  -1602278873,
  424148410,
  2082488578,
  -1836059632,
  -135771992,
  1029182619,
  1480566819,
  -1232069327,
  -738745975,
  1791981076,
  262720172,
  -519602242,
  -2074033402,
  -764370850,
  -1223222042,
  1505274356,
  1021252940,
  -2048408879,
  -528449943,
  238013307,
  1799911363,
  -1576071733,
  -949440141,
  700908641,
  1285601497,
  -174559420,
  -1862282244,
  2119198446,
  456645206,
  1294448910,
  675284406,
  -957370204,
  -1551365092,
  447798145,
  2144823097,
  -1854352853,
  -199266669,
  66528827,
  1720752771,
  -2009124975,
  -312962263,
  1415595188,
  822605836,
  -542618338,
  -1160777306,
  -320892162,
  -1984418234,
  1729600340,
  40904684,
  -1152847759,
  -567325495,
  813758939,
  1441219939,
  -1667219605,
  -104365101,
  392705729,
  1913621113,
  -885563932,
  -1370431140,
  1090475086,
  630778102,
  1938328494,
  384775958,
  -129990140,
  -1658372420,
  606071073,
  1098405273,
  -1344806773,
  -894411725,
  1001806317,
  1590814037,
  -1333899193,
  -719721217,
  1814117218,
  155617242,
  -404147512,
  -2104586640,
  -727782104,
  -1309060720,
  1599530114,
  976312378,
  -2096525401,
  -428985569,
  146900493,
  1839610549,
  -1528741699,
  -1048118267,
  791234839,
  1246688687,
  -210361806,
  -1777230198,
  2025728920,
  500799264,
  1271526520,
  783173824,
  -1073611310,
  -1520025238,
  475961079,
  2033789519,
  -1751736483,
  -219077659,
  85551949,
  1618925557,
  -1898880281,
  -340337057,
  1385040322,
  938063226,
  -649723800,
  -1138639664,
  -365830264,
  -1890163920,
  1643763234,
  77490842,
  -1113146105,
  -658439745,
  913224877,
  1393100821,
  -1706135011,
  -14037339,
  294026167,
  1960953615,
  -841412462,
  -1463899094,
  1175525688,
  594978176,
  1969669848,
  268532320,
  -22098062,
  -1681296438,
  586261591,
  1201019119,
  -1455837699,
  -866250427,
  116280694,
  1669984718,
  -1926871844,
  -398329756,
  1366896633,
  874419009,
  -625924525,
  -1076454677,
  -372835917,
  -1935588085,
  1645146137,
  124341409,
  -1101948100,
  -617207932,
  899256982,
  1358835246,
  -1715907546,
  -52500322,
  309419404,
  1997988148,
  -835832151,
  -1421243887,
  1172717315,
  545358779,
  1989271779,
  334912603,
  -44439223,
  -1740745231,
  554074732,
  1147223764,
  -1429304378,
  -810993794,
  943816662,
  1562821486,
  -1282836868,
  -688993596,
  1876303193,
  179413473,
  -467790605,
  -2122733493,
  -680932589,
  -1307674709,
  1554105017,
  969309697,
  -2130794084,
  -442952412,
  188129334,
  1850809486,
  -1491704186,
  -1032725954,
  752774956,
  1236915092,
  -259980279,
  -1780041551,
  2068385187,
  506376475,
  1212076611,
  760835835,
  -1007232023,
  -1500420271,
  531214540,
  2060323956,
  -1805534874,
  -251263522
}; // weak
unsigned int crc16_table[256] =
{
  0u,
  4129u,
  8258u,
  12387u,
  16516u,
  20645u,
  24774u,
  28903u,
  33032u,
  37161u,
  41290u,
  45419u,
  49548u,
  53677u,
  57806u,
  61935u,
  4657u,
  528u,
  12915u,
  8786u,
  21173u,
  17044u,
  29431u,
  25302u,
  37689u,
  33560u,
  45947u,
  41818u,
  54205u,
  50076u,
  62463u,
  58334u,
  9314u,
  13379u,
  1056u,
  5121u,
  25830u,
  29895u,
  17572u,
  21637u,
  42346u,
  46411u,
  34088u,
  38153u,
  58862u,
  62927u,
  50604u,
  54669u,
  13907u,
  9842u,
  5649u,
  1584u,
  30423u,
  26358u,
  22165u,
  18100u,
  46939u,
  42874u,
  38681u,
  34616u,
  63455u,
  59390u,
  55197u,
  51132u,
  18628u,
  22757u,
  26758u,
  30887u,
  2112u,
  6241u,
  10242u,
  14371u,
  51660u,
  55789u,
  59790u,
  63919u,
  35144u,
  39273u,
  43274u,
  47403u,
  23285u,
  19156u,
  31415u,
  27286u,
  6769u,
  2640u,
  14899u,
  10770u,
  56317u,
  52188u,
  64447u,
  60318u,
  39801u,
  35672u,
  47931u,
  43802u,
  27814u,
  31879u,
  19684u,
  23749u,
  11298u,
  15363u,
  3168u,
  7233u,
  60846u,
  64911u,
  52716u,
  56781u,
  44330u,
  48395u,
  36200u,
  40265u,
  32407u,
  28342u,
  24277u,
  20212u,
  15891u,
  11826u,
  7761u,
  3696u,
  65439u,
  61374u,
  57309u,
  53244u,
  48923u,
  44858u,
  40793u,
  36728u,
  37256u,
  33193u,
  45514u,
  41451u,
  53516u,
  49453u,
  61774u,
  57711u,
  4224u,
  161u,
  12482u,
  8419u,
  20484u,
  16421u,
  28742u,
  24679u,
  33721u,
  37784u,
  41979u,
  46042u,
  49981u,
  54044u,
  58239u,
  62302u,
  689u,
  4752u,
  8947u,
  13010u,
  16949u,
  21012u,
  25207u,
  29270u,
  46570u,
  42443u,
  38312u,
  34185u,
  62830u,
  58703u,
  54572u,
  50445u,
  13538u,
  9411u,
  5280u,
  1153u,
  29798u,
  25671u,
  21540u,
  17413u,
  42971u,
  47098u,
  34713u,
  38840u,
  59231u,
  63358u,
  50973u,
  55100u,
  9939u,
  14066u,
  1681u,
  5808u,
  26199u,
  30326u,
  17941u,
  22068u,
  55628u,
  51565u,
  63758u,
  59695u,
  39368u,
  35305u,
  47498u,
  43435u,
  22596u,
  18533u,
  30726u,
  26663u,
  6336u,
  2273u,
  14466u,
  10403u,
  52093u,
  56156u,
  60223u,
  64286u,
  35833u,
  39896u,
  43963u,
  48026u,
  19061u,
  23124u,
  27191u,
  31254u,
  2801u,
  6864u,
  10931u,
  14994u,
  64814u,
  60687u,
  56684u,
  52557u,
  48554u,
  44427u,
  40424u,
  36297u,
  31782u,
  27655u,
  23652u,
  19525u,
  15522u,
  11395u,
  7392u,
  3265u,
  61215u,
  65342u,
  53085u,
  57212u,
  44955u,
  49082u,
  36825u,
  40952u,
  28183u,
  32310u,
  20053u,
  24180u,
  11923u,
  16050u,
  3793u,
  7920u
}; // idb
int opt_log_level = 5; // idb
unsigned int sha256_k[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
unsigned int sha256_h0[8] =
{
  1779033703u,
  3144134277u,
  1013904242u,
  2773480762u,
  1359893119u,
  2600822924u,
  528734635u,
  1541459225u
}; // idb
int (*selective_yield)(void) = (int (*)(void))0x10751; // idb
bool showLogToKernelLog = true; // idb
int init_once = 1; // idb
CODES codes[68] =
{
  { SEVERITY_SUCC, 7, PARAM_PMAX, &aDPoolS },
  { SEVERITY_ERR, 8, PARAM_NONE, &aNoPools },
  { SEVERITY_SUCC, 9, PARAM_DMAX, NULL },
  { SEVERITY_ERR, 10, PARAM_NONE, &aNo_0 },
  { SEVERITY_SUCC, 11, PARAM_NONE, &aSummary_1 },
  { SEVERITY_SUCC, 16, PARAM_NONE, &aNonceNum },
  { SEVERITY_ERR, 14, PARAM_NONE, &aInvalidCommand },
  { SEVERITY_ERR, 15, PARAM_NONE, &aMissingDeviceI },
  { SEVERITY_SUCC, 59, PARAM_NONE, &aPgaCount },
  { SEVERITY_SUCC, 104, PARAM_NONE, &aAscCount_0 },
  { SEVERITY_SUCC, 22, PARAM_NONE, &aBmminerVersion },
  { SEVERITY_ERR, 23, PARAM_NONE, &aInvalidJson },
  { SEVERITY_ERR, 24, PARAM_CMD, &aMissingJsonS },
  { SEVERITY_ERR, 25, PARAM_NONE, &unk_485C4 },
  { SEVERITY_ERR, 26, PARAM_POOLMAX, &aInvalidPoolIdD },
  { SEVERITY_SUCC, 27, PARAM_POOL, &aSwitchingToPoo_1 },
  { SEVERITY_SUCC, 33, PARAM_NONE, &aBmminerConfig },
  { SEVERITY_ERR, 42, PARAM_NONE, &aMissingSaveFil },
  { SEVERITY_ERR, 43, PARAM_STR, &aCanTOpenOrCrea },
  { SEVERITY_SUCC, 44, PARAM_STR, &aConfigurationS },
  { SEVERITY_ERR, 45, PARAM_STR, &aAccessDeniedTo },
  { SEVERITY_SUCC, 46, PARAM_NONE, &aPrivilegedAcce },
  { SEVERITY_SUCC, 47, PARAM_POOL, &aEnablingPoolDS },
  { SEVERITY_SUCC, 73, PARAM_NONE, &aChangedPoolPri },
  { SEVERITY_ERR, 74, PARAM_PID, &aDuplicatePoolS },
  { SEVERITY_SUCC, 48, PARAM_POOL, &aDisablingPoolD },
  { SEVERITY_INFO, 49, PARAM_POOL, &aPoolDSAlreadyE },
  { SEVERITY_INFO, 50, PARAM_POOL, &aPoolDSAlreadyD },
  { SEVERITY_ERR, 51, PARAM_POOL, &aCannotDisableL },
  { SEVERITY_ERR, 52, PARAM_NONE, &aMissingAddpool },
  { SEVERITY_ERR, 53, PARAM_STR, &aInvalidAddpool },
  { SEVERITY_ERR, 54, PARAM_NONE, &aReachedMaximum },
  { SEVERITY_SUCC, 55, PARAM_POOL, &aAddedPoolDS },
  { SEVERITY_ERR, 66, PARAM_POOL, &aCannotRemoveLa },
  { SEVERITY_ERR, 67, PARAM_POOL, &aCannotRemoveAc },
  { SEVERITY_SUCC, 68, PARAM_BOTH, &aRemovedPoolDS },
  { SEVERITY_SUCC, 60, PARAM_NONE, &aNotify_1 },
  { SEVERITY_SUCC, 69, PARAM_NONE, &aDeviceDetails },
  { SEVERITY_SUCC, 70, PARAM_NONE, &aBmminerStats },
  { SEVERITY_ERR, 71, PARAM_NONE, &aMissingCheckCm },
  { SEVERITY_SUCC, 72, PARAM_NONE, &aCheckCommand },
  { SEVERITY_ERR, 75, PARAM_NONE, &aMissingParamet },
  { SEVERITY_ERR, 76, PARAM_NONE, &unk_488DC },
  { SEVERITY_SUCC, 77, PARAM_BOOL, &aFailoverOnlySe },
  { SEVERITY_SUCC, 78, PARAM_NONE, &aBmminerCoin },
  { SEVERITY_SUCC, 79, PARAM_NONE, &aDebugSettings },
  { SEVERITY_SUCC, 82, PARAM_SET, &aSetConfigSToD },
  { SEVERITY_ERR, 83, PARAM_STR, &aUnknownConfigS },
  { SEVERITY_ERR, 84, PARAM_BOTH, &aInvalidNumberD },
  { SEVERITY_ERR, 121, PARAM_BOTH, &aInvalidNegativ_0 },
  { SEVERITY_SUCC, 122, PARAM_SET, &aSetPoolSToQuot },
  { SEVERITY_ERR, 85, PARAM_NONE, &aMissingConfigP },
  { SEVERITY_ERR, 86, PARAM_STR, &aMissingConfigV },
  { SEVERITY_SUCC, 87, PARAM_NONE, &aUsbStatistics },
  { SEVERITY_INFO, 88, PARAM_NONE, &aNoUsbStatistic },
  { SEVERITY_ERR, 94, PARAM_NONE, &aMissingZeroPar },
  { SEVERITY_ERR, 95, PARAM_STR, &aInvalidZeroPar },
  { SEVERITY_SUCC, 96, PARAM_STR, &aZeroedSStatsWi },
  { SEVERITY_SUCC, 97, PARAM_STR, &aZeroedSStatsWi_0 },
  { SEVERITY_ERR, 99, PARAM_STR, &aInvalidValueFo },
  { SEVERITY_SUCC, 100, PARAM_INT, &aHotplugCheckSe },
  { SEVERITY_SUCC, 101, PARAM_NONE, &aHotplugDisable },
  { SEVERITY_WARN, 102, PARAM_NONE, &aHotplugIsNotAv },
  { SEVERITY_ERR, 103, PARAM_NONE, &aMissingHotplug },
  { SEVERITY_SUCC, 125, PARAM_NONE, &aLcd },
  { SEVERITY_SUCC, 123, PARAM_NONE, &aLockStatsCreat },
  { SEVERITY_WARN, 124, PARAM_NONE, &aLockStatsNotEn },
  { SEVERITY_FAIL, 0, PARAM_PGA, NULL }
}; // idb
CMDS cmds[35] =
{
  {
    &aVersion_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B009,
    false,
    true
  },
  {
    (unsigned __int8 *)0x4862C,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1AED9,
    false,
    true
  },
  {
    &aDevs,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1AECD,
    false,
    true
  },
  {
    &aEdevs,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1AEC1,
    false,
    true
  },
  {
    &aPools_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1BC21,
    false,
    true
  },
  {
    (unsigned __int8 *)0x48AB8,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B7C5,
    false,
    true
  },
  {
    &aNoncenum_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1AE11,
    false,
    true
  },
  {
    &aPgacount,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1AD9D,
    false,
    true
  },
  {
    &aSwitchpool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1AC91,
    true,
    false
  },
  {
    &aAddpool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1ABF5,
    true,
    false
  },
  {
    &aPoolpriority,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1AA79,
    true,
    false
  },
  {
    &aPoolquota,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A9A5,
    true,
    false
  },
  {
    &aEnablepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A8F1,
    true,
    false
  },
  {
    &aDisablepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A825,
    true,
    false
  },
  {
    &aRemovepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A719,
    true,
    false
  },
  {
    &aSave,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B0F1,
    true,
    false
  },
  {
    &aQuit_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x184E5,
    true,
    false
  },
  {
    &aPrivileged,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B17D,
    true,
    false
  },
  {
    (unsigned __int8 *)0x45D94,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1C195,
    false,
    true
  },
  {
    &aDevdetails_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A601,
    false,
    true
  },
  {
    (unsigned __int8 *)0x4D1C8,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x184BD,
    true,
    false
  },
  {
    (unsigned __int8 *)0x48890,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B521,
    false,
    true
  },
  {
    &aEstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B481,
    false,
    true
  },
  {
    &aCheck_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A4E9,
    false,
    false
  },
  {
    &aFailoverOnly_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A475,
    true,
    false
  },
  {
    (unsigned __int8 *)0x48928,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B6A1,
    false,
    true
  },
  {
    &aDebug_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A281,
    true,
    false
  },
  {
    &aSetconfig,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A1A1,
    true,
    false
  },
  {
    &aUsbstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A195,
    false,
    true
  },
  {
    &aZero,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A055,
    true,
    false
  },
  {
    &aHotplug_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1A049,
    true,
    false
  },
  {
    &aAsccount,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x19FD5,
    false,
    true
  },
  {
    &aLcd_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x1B19D,
    false,
    true
  },
  {
    &aLockstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x19FC9,
    true,
    true
  },
  { NULL, NULL, false, false }
}; // idb
opt_table opt_config_table[72] =
{
  {
    &aVersionFile,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1DAA5,
    NULL,
    { &opt_hidden },
    &aSetMinerVersio
  },
  {
    &aLogfileOpenfla,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1DA95,
    NULL,
    { &opt_hidden },
    &aSetLogFileOpen
  },
  {
    &aLogwork,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1DA85,
    NULL,
    { &opt_hidden },
    &aSetLogWorkFile
  },
  {
    &aLogworkAsicnum,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1DA75,
    NULL,
    { &opt_hidden },
    &aSetLogWorkAsic
  },
  {
    &aLogworkDiff,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_logwork_diff },
    &aAllowLogWorkDi
  },
  {
    &aLogfile,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1DA65,
    NULL,
    { &opt_hidden },
    &aSetLogFileDefa
  },
  {
    &aApiAllow,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_api_allow },
    &aAllowApiAccess
  },
  {
    &aApiDescription,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_api_description },
    &aDescriptionPla
  },
  {
    &aApiGroups,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_api_groups },
    &aApiOneLetterGr
  },
  {
    &aApiListen,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_api_listen },
    &aEnableApiDefau
  },
  {
    &aApiMcast,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_api_mcast },
    &aEnableApiMulti
  },
  {
    &aApiMcastAddr,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_api_mcast_addr },
    &aApiMulticastLi_0
  },
  {
    &aApiMcastCode,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_api_mcast_code },
    &aCodeExpectedIn
  },
  {
    &aApiMcastDes,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_api_mcast_des },
    &aDescriptionApp
  },
  {
    &aApiMcastPort,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAC5,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_api_mcast_port },
    &aApiMulticastLi_1
  },
  {
    &aApiNetwork,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_api_network },
    &aAllowApiIfEnab
  },
  {
    &aApiPort,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAC5,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_api_port },
    &aPortNumberOfMi
  },
  {
    &aApiHost,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_api_host },
    &aSpecifyApiList
  },
  {
    &aBalance,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x1D8B9,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo
  },
  {
    &aBenchfile_0,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_benchfile },
    &aRunCgminerInBe
  },
  {
    &aBenchfileDispl,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_benchfile_display },
    &aDisplayEachBen
  },
  {
    &aBenchmark_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_benchmark },
    &aRunCgminerInBe_0
  },
  {
    &aBitmainFanCtrl,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_bitmain_fan_ctrl },
    &aEnableBitmainM
  },
  {
    &aBitmainFanPwm,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EABD,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_bitmain_fan_pwm },
    &aSetBitmainFanP
  },
  {
    &aBitmainFreq,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAB1,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_bitmain_c5_freq },
    &unk_4EE8C
  },
  {
    &aBitmainVoltage,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAB1,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_bitmain_c5_voltage },
    &aSetVoltage
  },
  {
    &aFixedFreq,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_fixed_freq },
    &aSetBitmainMine
  },
  {
    &aNoPreHeat,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA8D,
    NULL,
    NULL,
    { &opt_pre_heat },
    &aSetBitmainMine_0
  },
  {
    &aDebugD,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x1D8D1,
    NULL,
    NULL,
    { &opt_debug },
    &aEnableDebugOut
  },
  {
    &aDisableRejecti,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_disable_pool },
    &aAutomaticallyD
  },
  {
    &aExpiryE,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAB1,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_expiry },
    &aUpperBoundOnHo
  },
  {
    &aExtranonceSubs_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x216E1,
    NULL,
    NULL,
    { NULL },
    &aEnableExtranon_0
  },
  {
    &aFailoverOnly_1,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_fail_only },
    &aDonTLeakWorkTo
  },
  {
    &aFixProtocol,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_fix_protocol },
    &aDoNotRedirectT
  },
  {
    &aFallbackTime,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3ABA9,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_pool_fallback },
    &aSetTimeInSecon
  },
  {
    &aHotplug_1,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAB1,
    NULL,
    { &hotplug_time },
    &opt_hidden
  },
  {
    &aLoadBalance,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x1D8C1,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_0
  },
  {
    &aLogL,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAB1,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_log_interval },
    &aIntervalInSeco
  },
  {
    &aLowmem,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_lowmem },
    &aMinimiseCachin
  },
  {
    &aMonitorM,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_stderr_cmd },
    &aUseCustomPipeC
  },
  {
    &aNetDelay,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_delaynet },
    &aImposeSmallDel
  },
  {
    &aNoPoolDisable,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA95,
    NULL,
    NULL,
    { &opt_disable_pool },
    &opt_hidden
  },
  {
    &aNoSubmitStale,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA95,
    NULL,
    NULL,
    { &opt_submit_stale },
    &aDonTSubmitShar
  },
  {
    &aPassP,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x2168D,
    NULL,
    { &opt_set_null },
    &aPasswordForBit
  },
  {
    &aPerDeviceStats,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &want_per_device_stats },
    &aForceVerboseMo
  },
  {
    &aPools_2,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AA85,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aProtocolDumpP,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_protocol },
    &aVerboseDumpOfP
  },
  {
    &aQueueQ,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAB1,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_queue },
    &aMaximumNumberO
  },
  {
    &aQuietQ,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_quiet },
    &aDisableLogging
  },
  {
    &aQuotaU,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x215CD,
    NULL,
    { &opt_set_null },
    &aQuotaUrlCombin
  },
  {
    &aRealQuiet,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_realquiet },
    &aDisableAllOutp
  },
  {
    &aRetries,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1D8E5,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRetryPause,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1D8E5,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRotate,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EA8D,
    NULL,
    { &opt_set_null },
    &aChangeMultipoo_1
  },
  {
    &aRoundRobin,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x1D8C9,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_2
  },
  {
    &aScanTimeS,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1EAB1,
    (void (*)(unsigned __int8 *, const void *))0x3ACF9,
    { &opt_scantime },
    &aUpperBoundOnTi
  },
  {
    &aSchedStart,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1E8C5,
    NULL,
    { &opt_set_sched_start },
    &aSetATimeOfDayI
  },
  {
    &aSchedStop,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1E879,
    NULL,
    { &opt_set_sched_stop },
    &aSetATimeOfDayI_0
  },
  {
    &aSharelog,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1DB01,
    NULL,
    { &opt_set_sharelog },
    &aAppendShareLog
  },
  {
    &aShares,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3ABA9,
    NULL,
    { &opt_shares },
    &aQuitAfterMinin
  },
  {
    &aSocksProxy,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3AB0D,
    NULL,
    { &opt_socks_proxy },
    &aSetSocks4Proxy
  },
  {
    &aSuggestDiff,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3ABA9,
    NULL,
    { &opt_suggest_diff },
    &aSuggestMinerDi
  },
  {
    &unk_4F768,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x3ABA9,
    NULL,
    { &opt_multi_version },
    &aMultiVersionMi
  },
  {
    &aSyslog_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &use_syslog },
    &aUseSystemLogFo
  },
  {
    &aTextOnlyT,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA95,
    NULL,
    NULL,
    { &use_curses },
    &opt_hidden
  },
  {
    &aUrlO,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x2153D,
    NULL,
    { &opt_set_null },
    &aUrlForBitcoinJ
  },
  {
    &aUserU,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x214B1,
    NULL,
    { &opt_set_null },
    &aUsernameForBit
  },
  {
    &aUserpassO,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x21415,
    NULL,
    { &opt_set_null },
    &aUsernamePasswo
  },
  {
    &aVerbose_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_log_output },
    &aLogVerboseOutp
  },
  {
    &aWidescreen,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_widescreen },
    &aUseExtraWideDi
  },
  {
    &aWorktime_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AA85,
    NULL,
    NULL,
    { &opt_worktime },
    &aDisplayExtraWo
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
unsigned int global_quota_gcd = 1u; // idb
double total_secs = 1.0; // idb
unsigned __int8 best_share[8] = { 48u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // idb
int opt_log_interval = 5; // idb
unsigned __int8 *curly = &aD; // idb
double current_diff = 1.84467441e19; // idb
double new_total_secs = 1.0; // idb
double last_total_secs = 1.0; // idb
int opt_pool_fallback = 120; // idb
int opt_scantime = -1; // idb
int opt_expiry = 120; // idb
bool opt_restart = true; // idb
bool opt_submit_stale = true; // idb
opt_table opt_cmdline_table[5] =
{
  {
    &aConfigC,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1E491,
    NULL,
    { &opt_set_null },
    &aLoadAJsonForma
  },
  {
    &aDefaultConfig,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x1DA55,
    NULL,
    { &opt_set_null },
    &aSpecifyTheFile
  },
  {
    &aHelpH,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x1DAB5,
    NULL,
    NULL,
    { NULL },
    &aPrintThisMessa
  },
  {
    &aVersionV,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x3AC25,
    NULL,
    NULL,
    { &packagename },
    &aDisplayVersion
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
unsigned __int8 *workpadding = &a00000080000000; // idb
int opt_multi_version = 1; // idb
int opt_api_mcast_port = 4028; // idb
unsigned __int8 *opt_api_mcast_des = (unsigned __int8 *)0x46BB8; // idb
unsigned __int8 *opt_api_mcast_code = &aFtw; // idb
unsigned __int8 *opt_api_mcast_addr = &a2240075; // idb
unsigned __int8 *opt_api_host = &a0000; // idb
int opt_api_port = 4028; // idb
unsigned __int8 *opt_api_description = &unk_4E820; // idb
int opt_queue = 1; // idb
strategies strategies_0[5] =
{
  { &aFailover },
  { &aRoundRobin_0 },
  { &aRotate_0 },
  { &aLoadBalance_0 },
  { &aBalance_0 }
}; // idb
device_drv bitmain_c5_drv =
{
  DRIVER_bitmain_c5,
  &aBitmainC5,
  &aBc5,
  (void (*)(bool))0x2A46D,
  (void (*)(cgpu_info *))0x2A455,
  (void (*)(unsigned __int8 *, size_t, cgpu_info *))0x2A419,
  NULL,
  (api_data *(*)(cgpu_info *))0x2C02D,
  NULL,
  NULL,
  NULL,
  (bool (*)(thr_info *))0x383FD,
  NULL,
  NULL,
  NULL,
  (void (*)(thr_info *))0x23681,
  NULL,
  (int64_t (*)(thr_info *))0x2A41D,
  NULL,
  (void (*)(cgpu_info *))0x39105,
  (void (*)(cgpu_info *))0x39105,
  NULL,
  (void (*)(thr_info *))0x2F101,
  NULL,
  NULL,
  false,
  0.0,
  0.0
}; // idb
unsigned int given_id = 2u; // idb
unsigned __int8 chain_voltage_pic[16] = { 255u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // idb
unsigned int PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608u; // idb
bool blink_13750 = true; // idb
unsigned __int8 de_voltage = 176u; // idb
bool opt_pre_heat = true; // idb
int opt_bitmain_c5_freq = 600; // idb
unsigned __int8 last_job_buffer[8192] =
{
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
json_malloc_t do_malloc = &malloc; // idb
json_free_t do_free = &free; // idb
json_t_0 the_true_7530 = { JSON_TRUE, 4294967295u }; // idb
json_t_0 the_false_7534 = { JSON_FALSE, 4294967295u }; // idb
json_t_0 the_null_7538 = { JSON_NULL, 4294967295u }; // idb
int stdin; // weak
int stdout; // weak
int stderr; // weak
char completed_8605; // weak
bool g_logfile_enable; // idb
FILE *g_log_file; // idb
unsigned __int8 g_logfile_path[256]; // idb
unsigned __int8 g_logfile_openflag[32]; // idb
bool opt_log_output; // idb
bool opt_debug; // idb
bool successful_connect; // idb
testpatten_cgpu_info cgpu; // idb
configuration Conf; // idb
unsigned int repeated_nonce_id[16][256]; // idb
unsigned int last_nonce[16]; // idb
unsigned int llast_nonce[16]; // idb
unsigned int work_id[16]; // idb
unsigned int m_nonce[16]; // idb
volatile bool start_receive; // idb
volatile bool gBegin_get_nonce; // idb
int last_nonce_num[16]; // idb
_CONFIG conf; // idb
int asic_nonce_num[16][256]; // idb
int valid_nonce_num[16]; // idb
int total_valid_nonce_num; // idb
int asic_core_nonce_num[16][256][256]; // idb
int repeated_nonce_num[16]; // idb
int err_nonce_num[16]; // idb
bool ExitFlag; // idb
bool receiveExit; // idb
unsigned int send_work_num[16]; // idb
bool chain_need_opencore[16]; // idb
bool StartSendFlag[16]; // idb
int chain_DataCount[16]; // idb
bool sendExit[16]; // idb
int chain_ValidNonce[16]; // idb
int last_result[16][256]; // idb
int last_result_opencore[16][256]; // idb
int chain_PassCount[16]; // idb
int result; // idb
bool search_freq_result[16]; // idb
int testModeOKCounter[16]; // idb
int chain_vol_value[16]; // idb
int chain_vol_final[16]; // idb
int chain_vol_added[16]; // idb
bool bye; // idb
bool do_a_restart; // idb
bool do_a_quit; // idb
int ips; // idb
IPACCESS *ipaccess; // idb
pthread_mutex_t quit_restart_lock; // idb
io_list *io_head; // idb
K_LIST *strbufs; // idb
time_t when; // idb
int my_thr_id; // idb
JE *jedata; // idb
unsigned __int8 *default_config; // idb
unsigned __int8 *opt_logfile_path; // idb
unsigned __int8 *opt_logwork_asicnum; // idb
unsigned __int8 *opt_logwork_path; // idb
unsigned __int8 *opt_logfile_openflag; // idb
unsigned __int8 *opt_version_path; // idb
unsigned __int8 packagename[256]; // idb
FILE *sharelog_file; // idb
unsigned __int8 bench_target[32]; // idb
unsigned __int8 exit_buf[512]; // idb
unsigned __int8 *cnfbuf; // idb
int include_count; // idb
bool config_loaded; // idb
unsigned __int8 err_buf_13181[200]; // idb
int fileconf_load; // idb
int api_thr_id; // idb
pool_strategy pool_strategy_0; // idb
unsigned __int8 *temp_cutoff_str; // idb
timeval restart_tv_start; // idb
timeval update_tv_start; // idb
unsigned __int8 *opt_set_null; // idb
uint64_t best_diff; // idb
FILE *fd_log; // idb
FILE *benchfile_in; // idb
unsigned __int8 *opt_benchfile; // idb
int benchfile_line; // idb
int benchfile_work; // idb
pthread_mutex_t *stgd_lock; // idb
work *staged_work; // idb
bool no_work; // idb
bool work_emptied; // idb
int staged_rollable; // idb
bool opt_fix_protocol; // idb
pthread_mutex_t sshare_lock; // idb
stratum_share *stratum_shares; // idb
int total_users; // idb
int total_passes; // idb
int total_userpasses; // idb
int total_urls; // idb
int total_extranonce; // idb
pool *currentpool; // idb
pthread_mutex_t lp_lock; // idb
pthread_cond_t lp_cond; // idb
unsigned int total_work; // idb
int local_work_lasttime; // idb
unsigned int local_work_last; // idb
unsigned int work_block; // idb
int watchpool_thr_id; // idb
int watchdog_thr_id; // idb
pthread_mutex_t sharelog_lock; // idb
timeval total_tv_start; // idb
timeval tv_hashmeter; // idb
double g_local_mhashes_dones[12]; // idb
int g_local_mhashes_index; // idb
timeval total_tv_end; // idb
time_t hashdisplay_t; // idb
double g_displayed_rolling; // idb
unsigned __int8 statusline[256]; // idb
unsigned __int8 datestamp[40]; // idb
int opt_shares; // idb
int forkpid; // idb
unsigned __int8 **initial_args; // idb
pthread_rwlock_t blk_lock; // idb
block *blocks; // idb
unsigned __int8 block_diff[8]; // idb
unsigned __int8 current_block[32]; // idb
unsigned __int8 blocktime[32]; // idb
unsigned __int8 prev_block[12]; // idb
bool pools_active; // idb
bool opt_benchmark; // idb
timeval rotate_tv; // idb
unsigned __int8 bench_hidiff_bins[16][160]; // idb
unsigned __int8 bench_lodiff_bins[16][160]; // idb
bool opt_benchfile_display; // idb
int cgminer_id_count; // idb
int new_threads; // idb
_cgpu_devid_counter *devids_15281; // idb
int new_devices; // idb
int most_devices; // idb
int devcursor; // idb
int logstart; // idb
int logcursor; // idb
unsigned __int8 g_miner_compiletime[256]; // idb
unsigned __int8 g_miner_type[256]; // idb
int g_logwork_asicnum; // idb
FILE *g_logwork_file; // idb
FILE *g_logwork_files[65]; // idb
bool opt_logwork_diff; // idb
FILE *g_logwork_diffs[65]; // idb
int total_control_threads; // idb
int gwsched_thr_id; // idb
unsigned __int8 *opt_stderr_cmd; // idb
bool work_filled; // idb
int rotating_pool_13439; // weak
unsigned __int8 *opt_socks_proxy; // idb
unsigned __int8 displayed_hash_rate[16]; // idb
unsigned __int8 g_miner_version[256]; // idb
unsigned __int8 *opt_api_allow; // idb
uint64_t h; // idb
bool status_error; // idb
bool stop_mining; // idb
int id_14377; // idb
pthread_mutex_t nonce_mutex; // idb
unsigned int last_nonce3_14475; // idb
unsigned int last_workid_14476; // idb
__int64 pool_diff_14430; // weak
int pool_diff_bit_14432; // weak
__int64 net_diff_14431; // weak
_UNKNOWN net_diff_bit_14433; // weak
int8_t middle_Offset[128]; // idb
bool opt_fixed_freq; // idb
unsigned __int8 chain_pic_buf[16][128]; // idb
unsigned int *axi_fpga_addr; // idb
int chain_badcore_num[16][256]; // idb
int x_time[16][256]; // idb
int temp_offside[16]; // idb
bool isChainAllCoresOpened[16]; // idb
uint64_t rate[16]; // idb
pthread_mutex_t iic_mutex; // idb
unsigned int *fpga_mem_addr; // idb
unsigned int *nonce2_jobid_address; // idb
unsigned int *job_start_address_1; // idb
unsigned int *job_start_address_2; // idb
pthread_mutex_t fpga_mutex; // idb
int chain_temp_toolow[16]; // idb
pthread_mutex_t init_log_mutex; // idb
bool isUseDefaultFreq; // idb
unsigned __int8 base_freq_index[16]; // idb
int last_record_freq[16][256]; // idb
unsigned __int8 chip_last_freq[16][256]; // idb
unsigned __int8 show_last_freq[16][256]; // idb
pthread_mutex_t reg_mutex; // idb
bool doTestPatten; // idb
bool gBegin_get_nonce_0; // idb
int rate_error[16]; // idb
bool is218_Temp; // idb
double chain_asic_RT[16][18]; // idb
int temp_highest; // idb
int last_temperature; // idb
int fix_fan_steps_12944; // idb
int lowest_testOK_temp[16]; // idb
bool isC5_CtrlBoard; // idb
int nonce_times; // idb
uint64_t nonce_num[16][64][60]; // idb
bool global_stop; // idb
bool check_temp_offside; // idb
int chain_voltage_value[16]; // idb
init_config config_parameter; // idb
bool someBoardUpVoltage; // idb
timeval tv_send_job; // idb
timeval tv_send; // idb
bool startCheckNetworkJob; // idb
bool opt_bitmain_fan_ctrl; // idb
int opt_bitmain_fan_pwm; // idb
uint64_t pool_send_nu_14203; // idb
unsigned int l_coinbase_padding; // idb
unsigned int c_coinbase_padding; // idb
unsigned int l_merkles_num; // idb
unsigned int c_merkles_num; // idb
pthread_mutex_t reinit_mutex; // idb
pthread_mutex_t opencore_readtemp_mutex; // idb
int FatalErrorValue; // idb
bool once_error; // idb
volatile uint32_t hashtable_seed; // idb
device_drv modminer_drv; // idb
device_drv bitforce_drv; // idb
device_drv bitmain_drv; // idb
APIGROUPS apigroups[26]; // idb
double total_mhashes_done; // idb
bool use_syslog; // idb
pthread_mutex_t stats_lock; // idb
unsigned int total_ro; // idb
timeval block_timeval; // idb
int swork_id; // idb
thr_info *control_thr; // idb
int64_t total_diff1; // idb
sigaction termhandler; // idb
bool sched_paused; // idb
int total_pools; // idb
pthread_cond_t gws_cond; // idb
bool opt_disable_pool; // idb
pthread_rwlock_t netacc_lock; // idb
double rolling15; // idb
bool opt_protocol; // idb
double new_total_mhashes_done; // idb
pthread_mutex_t hash_lock; // idb
int64_t total_accepted; // idb
double total_diff_stale; // idb
pool **pools; // idb
unsigned int total_go; // idb
list_head scan_devices; // idb
unsigned int local_work; // idb
unsigned __int8 nonce_num60_string[4096]; // idb
int opt_rotate_period; // idb
thr_info **mining_thr; // idb
unsigned __int8 nonce_num30_string[4096]; // idb
int enabled_pools; // idb
double total_diff_accepted; // idb
schedtime schedstop; // idb
thread_q *getq; // idb
bool opt_api_mcast; // idb
bool opt_fail_only; // idb
cgpu_info **devices; // idb
pthread_mutex_t restart_lock; // idb
bool opt_lowmem; // idb
int64_t total_getworks; // idb
pthread_rwlock_t mining_thr_lock; // idb
double total_diff_rejected; // idb
int64_t total_rejected; // idb
pthread_rwlock_t devices_lock; // idb
int total_devices; // idb
pthread_mutex_t console_lock; // idb
bool opt_api_network; // idb
int64_t total_discarded; // idb
bool hotplug_mode; // idb
bool opt_api_listen; // idb
unsigned __int8 nonce_num10_string[4096]; // idb
bool want_per_device_stats; // idb
bool opt_worktime; // idb
pthread_mutex_t update_job_lock; // idb
schedtime schedstart; // idb
int hw_errors; // idb
int g_max_fan; // idb
bool opt_work_update; // idb
int zombie_devs; // idb
unsigned __int8 *cgminer_path; // idb
unsigned int found_blocks; // idb
bool opt_compact; // idb
bool use_curses; // idb
unsigned __int8 *opt_api_groups; // idb
time_t last_getwork; // idb
sigaction inthandler; // idb
cglock_t ch_lock; // idb
cglock_t control_lock; // idb
unsigned __int64 global_hashrate; // idb
time_t total_tv_start_sys; // idb
pthread_cond_t restart_cond; // idb
double total_rolling; // idb
bool opt_realquiet; // idb
time_t total_tv_end_sys; // idb
unsigned int new_blocks; // idb
int g_max_temp; // idb
int opt_suggest_diff; // idb
unsigned __int8 current_hash[68]; // idb
int mining_threads; // idb
unsigned __int8 *opt_kernel_path; // idb
bool opt_quiet; // idb
sigaction abrthandler; // idb
bool have_longpoll; // idb
int64_t total_stale; // idb
double rolling5; // idb
double rolling1; // idb
bool opt_delaynet; // idb
int fpga_version; // idb
volatile nonce_buf nonce_read_out; // idb
unsigned __int8 displayed_rate[16][32]; // idb
int fd_fpga_mem; // idb
int fd; // idb
unsigned __int8 hash_board_id[16][12]; // idb
unsigned __int8 hash_board_id_string[544]; // idb
thr_info *read_temp_id; // idb
int pcb_version; // idb
thr_info *check_system_work_id; // idb
thr_info *pic_heart_beat; // idb
all_parameters *dev; // idb
unsigned __int8 *mac; // idb
volatile reg_buf reg_value_buf; // idb
thr_info *read_nonce_reg_id; // idb
thr_info *send_mac_thr; // idb
unsigned int opt_num_long; // idb
unsigned int opt_num_short; // idb
unsigned int opt_count; // idb
unsigned int opt_num_short_arg; // idb
opt_table *opt_table_0; // idb
const unsigned __int8 *opt_argv0; // idb
const unsigned __int8 opt_hidden[1]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00009F5C) --------------------------------------------------------
int init_proc()
{
  return call_gmon_start();
}

//----- (00009F68) --------------------------------------------------------
void sub_9F68()
{
  JUMPOUT(0);
}
// 9F74: control flows out of bounds to 0

//----- (0000A254) --------------------------------------------------------
// attributes: thunk
void j_free(void *ptr)
{
  free(ptr);
}

//----- (0000A288) --------------------------------------------------------
// attributes: thunk
int j_gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
{
  return gettimeofday(tv, tz);
}

//----- (0000A2BC) --------------------------------------------------------
// attributes: thunk
int j_pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (0000A350) --------------------------------------------------------
// attributes: thunk
int j_pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
{
  return pthread_create(newthread, attr, start_routine, arg);
}

//----- (0000A378) --------------------------------------------------------
// attributes: thunk
void *j_memcpy(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (0000A3C4) --------------------------------------------------------
// attributes: thunk
int j_strtol(const char *nptr, char **endptr, int base)
{
  return strtol(nptr, endptr, base);
}

//----- (0000A3D4) --------------------------------------------------------
// attributes: thunk
char *j_strcpy(char *dest, const char *src)
{
  return strcpy(dest, src);
}

//----- (0000A414) --------------------------------------------------------
// attributes: thunk
int j_printf(const char *format, ...)
{
  return printf(format);
}

//----- (0000A4FC) --------------------------------------------------------
// attributes: thunk
void *j_malloc(size_t size)
{
  return malloc(size);
}

//----- (0000A548) --------------------------------------------------------
// attributes: thunk
unsigned int j_sleep(unsigned int seconds)
{
  return sleep(seconds);
}

//----- (0000A5B8) --------------------------------------------------------
// attributes: thunk
int j_fcntl(int fd, int cmd, ...)
{
  return fcntl(fd, cmd);
}

//----- (0000A610) --------------------------------------------------------
// attributes: thunk
int j_snprintf(char *s, size_t maxlen, const char *format, ...)
{
  return snprintf(s, maxlen, format);
}

//----- (0000A668) --------------------------------------------------------
// attributes: thunk
void *j_realloc(void *ptr, size_t size)
{
  return realloc(ptr, size);
}

//----- (0000A6C0) --------------------------------------------------------
// attributes: thunk
char *j___strdup(const char *s)
{
  return _strdup(s);
}

//----- (0000A6F4) --------------------------------------------------------
// attributes: thunk
int j_strcmp(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}

//----- (0000A780) --------------------------------------------------------
void __fastcall __noreturn mutex_lock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "util.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000A7C8) --------------------------------------------------------
void __fastcall __noreturn mutex_lock_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "api.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000A810) --------------------------------------------------------
void __fastcall __noreturn rw_unlock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "api.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000A858) --------------------------------------------------------
void __fastcall __noreturn mutex_unlock_noyield_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "api.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000A8A0) --------------------------------------------------------
pool *__fastcall priority_pool_0(int choice)
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-808h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "WTF No pool %d found!", choice);
    applog(3, tmp42, 0);
  }
  return pools[choice];
}

//----- (0000A8F8) --------------------------------------------------------
void __fastcall free_work_0(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  snprintf(
    (char *)tmp42,
    0x800u,
    "Free work called with NULL work from %s %s:%d",
    (const char *)workptr,
    (const char *)file,
    func);
  applog(3, tmp42, 0);
}

//----- (0000A928) --------------------------------------------------------
void __noreturn restart_threads_0()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  strcpy((char *)tmp42, "Failed to create restart thread");
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000A95C) --------------------------------------------------------
void __fastcall __noreturn mutex_unlock_noyield_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000A9A4) --------------------------------------------------------
void __fastcall __noreturn mutex_lock_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000A9EC) --------------------------------------------------------
void __fastcall __noreturn wr_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000AA34) --------------------------------------------------------
void __fastcall __noreturn mutex_init(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000AA7C) --------------------------------------------------------
void __fastcall __noreturn rwlock_init(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000AAC4) --------------------------------------------------------
void __fastcall __noreturn rw_unlock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000AB0C) --------------------------------------------------------
void __fastcall __noreturn rd_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000AB54) --------------------------------------------------------
void __fastcall __noreturn mutex_init_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v5 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v5,
    "driver-btm-c5.c",
    (const char *)_func___14388,
    lock);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000ABA0) --------------------------------------------------------
void __fastcall __noreturn rw_unlock_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "driver-btm-c5.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000ABE8) --------------------------------------------------------
void __fastcall __noreturn mutex_unlock_noyield_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "driver-btm-c5.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000AC30) --------------------------------------------------------
void __fastcall __noreturn mutex_lock_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v6 = _errno_location();
  snprintf(
    (char *)tmp42,
    0x800u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "driver-btm-c5.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0000AC78) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int8 *v3; // r4
  int v4; // r0
  int (*v5)(void); // r3
  bool v6; // zf
  unsigned int v7; // r0
  unsigned __int8 **v8; // r0
  int v9; // r3
  unsigned __int8 **v10; // r8
  unsigned __int8 **v11; // r6
  int v12; // r4
  int v13; // r5
  char *v14; // r0
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int v19; // r3
  int v20; // r3
  int v21; // r3
  int v22; // r3
  int v23; // r3
  int v24; // r3
  int v25; // r3
  int v26; // r3
  int v27; // r3
  thread_q *v28; // r0
  int v29; // r4
  char *v30; // r0
  char *v31; // r8
  char *v32; // r6
  char *v33; // r0
  block *v34; // r11
  pool *v35; // r0
  unsigned int v36; // r2
  int v37; // r0
  int v38; // r1
  unsigned __int8 *v39; // r3
  pool *v40; // lr
  int v41; // r12
  int v42; // r4
  int v43; // r6
  int v44; // r8
  int v45; // r11
  unsigned int v46; // r2
  unsigned int v47; // r0
  int v48; // r1
  unsigned int v49; // r2
  unsigned int v50; // r0
  int v51; // r1
  unsigned int v52; // r2
  unsigned int v53; // r0
  unsigned int v54; // r6
  int v55; // r1
  unsigned int v56; // r2
  unsigned int v57; // r3
  int v58; // r1
  unsigned int v59; // r2
  unsigned int v60; // r3
  int v61; // r1
  unsigned int v62; // r4
  block *v63; // r6
  UT_hash_table *tbl; // r3
  UT_hash_handle_0 *p_hh; // r8
  UT_hash_table *v66; // r3
  UT_hash_handle *tail; // r2
  ptrdiff_t hho; // r1
  UT_hash_table *v69; // r0
  UT_hash_bucket_0 *buckets; // r2
  int v71; // r4
  int v72; // r3
  UT_hash_handle *hh_head; // r4
  unsigned int v74; // r1
  int v75; // r0
  UT_hash_table *v76; // r3
  size_t v77; // r4
  UT_hash_bucket_0 *v78; // r0
  UT_hash_bucket_0 *v79; // r6
  UT_hash_table *v80; // r10
  unsigned int num_buckets; // r3
  unsigned int v82; // r4
  unsigned int log2_num_buckets; // r2
  unsigned int v84; // r2
  unsigned int v85; // r12
  UT_hash_bucket_0 *v86; // r4
  bool *v87; // r2
  UT_hash_table *v88; // r11
  UT_hash_handle *v89; // r4
  UT_hash_table *v90; // r9
  unsigned int v91; // r11
  unsigned int hashv; // r3
  UT_hash_handle *hh_next; // r10
  unsigned int v94; // r8
  int v95; // r12
  unsigned int v96; // r0
  UT_hash_handle *v97; // r3
  UT_hash_table *v98; // r0
  unsigned int nonideal_items; // r3
  unsigned int v100; // r2
  unsigned int v101; // r4
  unsigned int v102; // r1
  bool v103; // cc
  int v104; // r4
  unsigned int v105; // r1
  unsigned int v106; // r3
  unsigned __int8 *v107; // r6
  pool *v108; // r4
  unsigned __int8 *v109; // r0
  unsigned __int8 *v110; // r2
  unsigned __int8 *v111; // r3
  const char *v112; // r2
  int v113; // r0
  int v114; // r1
  __int16 v115; // r2
  unsigned __int8 *rpc_url; // r3
  pool_enable enabled; // r3
  double v118; // r2
  int v119; // r6
  int v120; // r4
  int v121; // r8
  FILE *v122; // r4
  signed int v123; // r0
  char *v124; // r0
  char *v125; // r4
  unsigned __int8 *v126; // r3
  unsigned __int8 *v127; // r3
  unsigned __int8 *v128; // r3
  unsigned __int8 *v129; // r3
  int v130; // r0
  bool v131; // zf
  unsigned __int8 **v132; // r6
  int v133; // r3
  bool v134; // zf
  FILE **v135; // r6
  int v136; // r9
  char *v137; // r10
  unsigned __int8 *v138; // r11
  FILE *v139; // r0
  int v140; // r3
  bool *v141; // r6
  int v142; // r9
  bool *v143; // r11
  char *v144; // r10
  FILE *v145; // r0
  unsigned __int8 *v146; // r12
  unsigned __int8 **v147; // r4
  unsigned __int8 **v148; // r4
  int v149; // r4
  int v150; // r2
  thr_info *v151; // r0
  int v152; // r6
  cgpu_info *v153; // r0
  char *v154; // r8
  char *v155; // r10
  int v156; // r4
  const unsigned __int8 *v157; // r2
  int v158; // r3
  unsigned int v159; // r6
  const unsigned __int8 *v160; // r2
  int v161; // r3
  const unsigned __int8 *v162; // r2
  cgpu_info **v163; // r3
  cgpu_info **v164; // r4
  int v165; // t1
  const unsigned __int8 *v166; // r2
  cgpu_info **v167; // r3
  cgpu_info **v168; // r2
  int v169; // r1
  int v170; // t1
  cgpu_info **v171; // r3
  cgpu_info **v172; // r2
  int v173; // t1
  int v174; // r2
  int v175; // r9
  pool **v176; // r3
  pool *v177; // r4
  unsigned __int8 *rpc_userpass; // r2
  const char *rpc_user; // r0
  size_t v180; // r6
  unsigned int v181; // r6
  char *v182; // r0
  const char *rpc_pass; // r3
  unsigned __int8 **v184; // r4
  unsigned __int8 **v185; // lr
  unsigned __int8 **v186; // r4
  unsigned __int8 **v187; // r4
  UT_hash_table *v188; // r0
  UT_hash_table *v189; // r9
  UT_hash_bucket_0 *v190; // r0
  int v191; // r2
  __sighandler_t v192; // r6
  __pid_t v193; // r0
  __pid_t v194; // r6
  unsigned __int8 **v195; // r4
  unsigned __int8 **v196; // r4
  int v197; // r8
  thr_info **v198; // r4
  thr_info *v199; // r0
  int v200; // r3
  int v201; // r10
  int v202; // r6
  cgpu_info *v203; // r4
  thr_info **v204; // r0
  int threads; // r3
  thr_info *thread; // r0
  device_drv *drv; // r3
  thr_info *v208; // r8
  int (*thread_prepare)(void); // r3
  dev_enable deven; // r3
  int v211; // r3
  int *v212; // r3
  cgpu_info **v213; // r3
  cgpu_info **v214; // r2
  int v215; // t1
  int v216; // r4
  char *v217; // r0
  thr_info *v218; // r6
  int v219; // lr
  int v220; // r2
  pool **v221; // r12
  pool *v222; // r1
  pool_enable v223; // r0
  unsigned __int8 **v224; // r4
  pool ***v225; // r8
  int i; // r4
  pool *v227; // r3
  int v228; // r4
  bool *v229; // r9
  int v230; // r2
  char *v231; // r8
  thr_info *v232; // r10
  bool *v233; // r3
  unsigned __int8 **v234; // r4
  unsigned __int8 **v235; // r4
  pthread_mutex_t *v236; // r0
  const unsigned __int8 *v237; // r2
  int v238; // r3
  signed int num_items; // r4
  const unsigned __int8 *v240; // r2
  int v241; // r3
  pool *v242; // r0
  pool *v243; // r0
  int v244; // r10
  pool **v245; // r6
  pool **v246; // r0
  int v247; // r3
  pool *v248; // t1
  int v249; // lr
  int v250; // t1
  int v251; // r6
  bool *v252; // r1
  int v253; // r11
  pool *v254; // r4
  int quota_used; // r3
  int quota_gcd; // r2
  _BOOL4 v257; // r0
  int v258; // r6
  pool *v259; // r4
  pool *v260; // r6
  int v261; // r10
  pool **v262; // r6
  pool **v263; // r0
  int v264; // r3
  pool *v265; // t1
  int v266; // lr
  int v267; // t1
  int v268; // r6
  bool *v269; // r1
  int v270; // r11
  pool *v271; // r4
  int v272; // r3
  int v273; // r2
  _BOOL4 v274; // r0
  int v275; // r6
  pool *v276; // r4
  pool *v277; // r6
  const char *v278; // r6
  unsigned __int8 *v279; // r0
  unsigned __int8 *v280; // r1
  unsigned __int8 *v281; // r2
  unsigned __int8 *v282; // r3
  unsigned __int8 **v283; // r6
  unsigned __int8 **v284; // r4
  unsigned __int8 *v285; // r1
  unsigned __int8 *v286; // r2
  unsigned __int8 **v287; // r4
  const unsigned __int8 *v288; // r2
  int v289; // r3
  thr_info **v290; // r3
  thr_info **v291; // r1
  int v292; // t1
  const unsigned __int8 *v293; // r2
  int v294; // r3
  unsigned __int8 **v295; // r4
  unsigned __int8 **v296; // r1
  unsigned __int8 **v297; // r5
  unsigned __int8 **v298; // r4
  unsigned __int8 **v299; // r4
  thr_info *v300; // r3
  bool *v301; // r10
  char *v302; // r9
  int v303; // r8
  thr_info *v304; // r12
  pool *v305; // lr
  unsigned __int8 *func; // [sp+0h] [bp-2020h]
  const char *v308; // [sp+4h] [bp-201Ch]
  const char *v309; // [sp+8h] [bp-2018h]
  char v310; // [sp+10h] [bp-2010h] BYREF
  char v311[4088]; // [sp+1018h] [bp-1008h] BYREF
  thr_info *v312; // [sp+2020h] [bp+0h]
  bool *diff; // [sp+2024h] [bp+4h]
  void (**v314)(void); // [sp+2028h] [bp+8h]
  bool *v315; // [sp+202Ch] [bp+Ch]
  int *v316; // [sp+2030h] [bp+10h]
  pool ***v317; // [sp+2034h] [bp+14h]
  bool *v318; // [sp+2038h] [bp+18h]
  unsigned __int8 *v319; // [sp+203Ch] [bp+1Ch]
  void *ptr; // [sp+2040h] [bp+20h]
  unsigned __int8 **argva; // [sp+2044h] [bp+24h]
  pool *pool; // [sp+2048h] [bp+28h]
  int line; // [sp+204Ch] [bp+2Ch] BYREF
  work *work; // [sp+2050h] [bp+30h] BYREF
  struct sigaction v325; // [sp+2054h] [bp+34h] BYREF
  struct sysinfo v326[4]; // [sp+20E0h] [bp+C0h] BYREF
  char v327[2052]; // [sp+21E0h] [bp+1C0h] BYREF

  argva = (unsigned __int8 **)argv;
  line = argc;
  v3 = g_logfile_path;
  strcpy((char *)g_logfile_path, "bmminer.log");
  strcpy((char *)g_logfile_openflag, "a+");
  g_logfile_enable = 0;
  work = 0;
  v4 = sysconf(84);
  v6 = v4 == 1;
  if ( v4 == 1 )
  {
    v5 = sched_yield;
    v3 = (unsigned __int8 *)&selective_yield;
  }
  v7 = 4 * (line + 1);
  if ( v6 )
    *(_DWORD *)v3 = v5;
  v8 = (unsigned __int8 **)cgmalloc(v7, "cgminer.c", (const unsigned __int8 *)&_func___15372, 11423);
  v9 = line;
  v10 = v8;
  initial_args = v8;
  if ( line > 0 )
  {
    v11 = argva;
    v12 = 0;
    v13 = 0;
    do
    {
      ++v13;
      v14 = _strdup((const char *)v11[v12]);
      v9 = line;
      v10[v12++] = (unsigned __int8 *)v14;
    }
    while ( v9 > v13 );
  }
  v10[v9] = 0;
  mutex_init_0(&hash_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CA8, v9);
  mutex_init_0(&update_job_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CA9, v15);
  mutex_init_0(&console_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CAA, v16);
  cglock_init(&control_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CAB, v17);
  mutex_init_0(&stats_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CAC, v18);
  mutex_init_0(&sharelog_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CAD, v19);
  cglock_init(&ch_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CAE, v20);
  mutex_init_0(&sshare_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CAF, v21);
  rwlock_init_0(&blk_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CB0, v22);
  rwlock_init_0(&netacc_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CB1, v23);
  rwlock_init_0(&mining_thr_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CB2, v24);
  rwlock_init_0(&devices_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CB3, v25);
  mutex_init_0(&lp_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CB5, v26);
  if ( pthread_cond_init(&lp_cond, 0) )
  {
    strcpy(v327, "Failed to pthread_cond_init lp_cond");
    applog(3, (const unsigned __int8 *)v327, 1);
    _quit(1, 0);
  }
  mutex_init_0(&restart_lock, (const unsigned __int8 *)&_func___15372, (const unsigned __int8 *)0x2CBC, v27);
  if ( pthread_cond_init(&restart_cond, 0) )
  {
    strcpy(v327, "Failed to pthread_cond_init restart_cond");
    applog(3, (const unsigned __int8 *)v327, 1);
    _quit(1, 0);
  }
  if ( pthread_cond_init(&gws_cond, 0) )
  {
    strcpy(v327, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v28 = tq_new();
    getq = v28;
    if ( v28 )
    {
      stgd_lock = &v28->mutex;
      snprintf((char *)packagename, 0x100u, "%s %s", "bmminer", "2.0.0");
      v325.sa_flags = 0;
      v29 = 36;
      v325.sa_handler = sighandler;
      sigemptyset(&v325.sa_mask);
      sigaction_0(15, &v325, &termhandler);
      sigaction_0(2, &v325, &inthandler);
      sigaction_0(6, &v325, &abrthandler);
      opt_kernel_path = (unsigned __int8 *)v311;
      strcpy(v311, "/usr/bin");
      cgminer_path = (unsigned __int8 *)&v310;
      v30 = _strdup((const char *)*argva);
      v31 = (char *)cgminer_path;
      v32 = v30;
      v33 = dirname(v30);
      strcpy(v31, v33);
      free(v32);
      strcat((char *)cgminer_path, "/");
      logstart = 9;
      logcursor = 10;
      devcursor = 8;
      v34 = (block *)cgcalloc(104, 1u, "cgminer.c", (const unsigned __int8 *)&_func___15372, 11499);
      do
      {
        --v29;
        *(_WORD *)&v34->hash[strlen((const char *)v34)] = 48;
      }
      while ( v29 );
      v35 = (pool *)strlen((const char *)v34);
      v36 = -1640531527;
      v103 = (unsigned int)v35 > 0xB;
      pool = v35;
      v37 = -17973521;
      v38 = -1640531527;
      v39 = (unsigned __int8 *)v34;
      v40 = pool;
      if ( v103 )
      {
        ptr = v34;
        do
        {
          v40 = (pool *)((char *)v40 - 12);
          v41 = (v39[10] << 16) + (v39[9] << 8);
          v42 = v39[3];
          v43 = v39[8];
          v44 = *v39 + (v39[2] << 16) + (v39[1] << 8);
          v45 = v39[11];
          v46 = v36 + (v39[6] << 16) + (v39[5] << 8) + v39[4] + (v39[7] << 24);
          v39 += 12;
          v47 = v37 + v43 + v41 + (v45 << 24);
          v48 = (v38 + v44 + (v42 << 24) - v46 - v47) ^ (v47 >> 13);
          v49 = (v46 - v47 - v48) ^ (v48 << 8);
          v50 = (v47 - v48 - v49) ^ (v49 >> 13);
          v51 = (v48 - v49 - v50) ^ (v50 >> 12);
          v52 = (v49 - v50 - v51) ^ (v51 << 16);
          v53 = (v50 - v51 - v52) ^ (v52 >> 5);
          v38 = (v51 - v52 - v53) ^ (v53 >> 3);
          v36 = (v52 - v53 - v38) ^ (v38 << 10);
          v37 = (v53 - v38 - v36) ^ (v36 >> 15);
        }
        while ( (unsigned int)v40 > 0xB );
        v34 = (block *)ptr;
      }
      v54 = (unsigned int)pool + v37;
      switch ( (unsigned int)v40 )
      {
        case 1u:
          goto LABEL_30;
        case 2u:
          goto LABEL_29;
        case 3u:
          goto LABEL_28;
        case 4u:
          goto LABEL_27;
        case 5u:
          goto LABEL_26;
        case 6u:
          goto LABEL_25;
        case 7u:
          goto LABEL_24;
        case 8u:
          goto LABEL_23;
        case 9u:
          goto LABEL_22;
        case 0xAu:
          goto LABEL_21;
        case 0xBu:
          v54 += v39[10] << 24;
LABEL_21:
          v54 += v39[9] << 16;
LABEL_22:
          v54 += v39[8] << 8;
LABEL_23:
          v36 += v39[7] << 24;
LABEL_24:
          v36 += v39[6] << 16;
LABEL_25:
          v36 += v39[5] << 8;
LABEL_26:
          v36 += v39[4];
LABEL_27:
          v38 += v39[3] << 24;
LABEL_28:
          v38 += v39[2] << 16;
LABEL_29:
          v38 += v39[1] << 8;
LABEL_30:
          v38 += *v39;
          break;
        default:
          break;
      }
      v34->hh.key = v34;
      v55 = (v38 - v36 - v54) ^ (v54 >> 13);
      v56 = (v36 - v54 - v55) ^ (v55 << 8);
      v57 = (v54 - v55 - v56) ^ (v56 >> 13);
      v58 = (v55 - v56 - v57) ^ (v57 >> 12);
      v59 = (v56 - v57 - v58) ^ (v58 << 16);
      v60 = (v57 - v58 - v59) ^ (v59 >> 5);
      v61 = (v58 - v59 - v60) ^ (v60 >> 3);
      v62 = (v60 - v61 - ((v59 - v60 - v61) ^ (v61 << 10))) ^ (((v59 - v60 - v61) ^ (v61 << 10)) >> 15);
      v34->hh.hashv = v62;
      v34->hh.keylen = strlen((const char *)v34);
      v63 = blocks;
      if ( blocks )
      {
        tbl = blocks->hh.tbl;
        v34->hh.next = 0;
        p_hh = &v34->hh;
        v34->hh.tbl = tbl;
        v66 = v63->hh.tbl;
        tail = v66->tail;
        hho = v66->hho;
        tail->next = v34;
        v34->hh.prev = (char *)tail - hho;
        v66->tail = &v34->hh;
      }
      else
      {
        v34->hh.next = blocks;
        v34->hh.prev = v63;
        blocks = v34;
        v188 = (UT_hash_table *)malloc(0x2Cu);
        v34->hh.tbl = v188;
        if ( !v188 )
          goto LABEL_228;
        memset(v188, (int)v63, sizeof(UT_hash_table));
        p_hh = &v34->hh;
        v189 = v34->hh.tbl;
        v189->tail = &v34->hh;
        v189->num_buckets = 32;
        v189->log2_num_buckets = 5;
        v189->hho = 68;
        v190 = (UT_hash_bucket_0 *)malloc(0x180u);
        v189->buckets = v190;
        if ( !v190 )
          goto LABEL_228;
        memset(v190, (int)v63, 0x180u);
        v63 = v34;
        v34->hh.tbl->signature = -1609490463;
      }
      v69 = v63->hh.tbl;
      buckets = v69->buckets;
      v71 = 3 * (v62 & (v69->num_buckets - 1));
      ++v69->num_items;
      v72 = 4 * v71;
      hh_head = buckets[v71 / 3u].hh_head;
      v74 = *(unsigned int *)((char *)&buckets->count + v72) + 1;
      *(unsigned int *)((char *)&buckets->count + v72) = v74;
      v34->hh.hh_next = hh_head;
      v34->hh.hh_prev = 0;
      if ( hh_head )
        hh_head->hh_prev = p_hh;
      v75 = *(unsigned int *)((char *)&buckets->expand_mult + v72);
      *(UT_hash_handle **)((char *)&buckets->hh_head + v72) = p_hh;
      if ( v74 < 10 * (v75 + 1) || (v76 = v34->hh.tbl, v76->noexpand == 1) )
      {
LABEL_59:
        strcpy((char *)current_hash, (const char *)v34);
        scan_devices.next = &scan_devices;
        scan_devices.prev = &scan_devices;
        opt_register_table(opt_config_table, "Options for both config file and command line");
        opt_register_table(opt_cmdline_table, "Options for command line only");
        opt_parse(&line, argva, (void (*)(const unsigned __int8 *, ...))errlog);
        if ( line != 1 )
        {
          strcpy(v327, "Unexpected extra commandline arguments");
          applog(3, (const unsigned __int8 *)v327, 1);
          _quit(1, 0);
        }
        v107 = (unsigned __int8 *)config_loaded;
        if ( !config_loaded )
        {
          cnfbuf = (unsigned __int8 *)cgmalloc(0x1000u, "cgminer.c", &_func___15372.__size[8], 2066);
          default_save_file(cnfbuf);
          if ( access((const char *)cnfbuf, 4) )
          {
            free(cnfbuf);
            cnfbuf = v107;
          }
          else
          {
            load_config(cnfbuf, 0);
          }
        }
        if ( opt_benchmark || opt_benchfile )
        {
          v108 = add_pool();
          v109 = (unsigned __int8 *)cgmalloc(0xFFu, "cgminer.c", (const unsigned __int8 *)&_func___15372, 11535);
          v110 = opt_benchfile;
          v111 = v109;
          v108->rpc_url = v109;
          if ( v110 )
            v112 = "Benchfile";
          else
            v112 = "Benchmark";
          v113 = *(_DWORD *)v112;
          v114 = *((_DWORD *)v112 + 1);
          v115 = *((_WORD *)v112 + 4);
          *(_DWORD *)v111 = v113;
          *((_DWORD *)v111 + 1) = v114;
          *((_WORD *)v111 + 4) = v115;
          rpc_url = v108->rpc_url;
          v108->rpc_user = rpc_url;
          v108->rpc_pass = rpc_url;
          v108->rpc_userpass = rpc_url;
          v108->sockaddr_url = rpc_url;
          strncpy((char *)v108->diff, "?", 7u);
          enabled = v108->enabled;
          v108->diff[7] = 0;
          if ( enabled != POOL_ENABLED )
          {
            v108->enabled = POOL_ENABLED;
            ++enabled_pools;
          }
          HIDWORD(v118) = bench_hidiff_bins;
          v119 = 0;
          v108->idle = 0;
          successful_connect = 1;
          do
          {
            v120 = v119;
            diff = (bool *)HIDWORD(v118);
            v121 = v119++;
            hex2bin((unsigned __int8 *)(HIDWORD(v118) + v121 * 160), bench_hidiffs[v120], 0xA0u);
            hex2bin(bench_lodiff_bins[v121], bench_lodiffs[v120], 0xA0u);
            HIDWORD(v118) = diff;
          }
          while ( v119 != 16 );
          set_target(bench_target, v118);
        }
        if ( !opt_version_path )
        {
          argva = (unsigned __int8 **)v327;
          v319 = (unsigned __int8 *)&use_syslog;
          v318 = &opt_log_output;
          goto LABEL_88;
        }
        v122 = fopen((const char *)opt_version_path, "rb");
        memset(v326, 0, sizeof(v326));
        if ( v122 )
        {
          v123 = fread(v326, 1u, 0x100u, v122);
          if ( v123 > 0 )
          {
            v124 = strchr((const char *)v326, 10);
            v125 = v124;
            if ( v124 )
            {
              cg_memcpy(
                g_miner_compiletime,
                v326,
                v124 - (char *)v326,
                "cgminer.c",
                (const unsigned __int8 *)&_func___15372,
                11594);
              strcpy((char *)g_miner_type, v125 + 1);
            }
            else
            {
              strcpy((char *)g_miner_compiletime, (const char *)v326);
            }
            v126 = &bench_hidiff_bins[15][strlen((const char *)g_miner_compiletime) + 63];
            if ( v126[2692] == 10 )
              v126[2692] = 0;
            v127 = &bench_hidiff_bins[15][strlen((const char *)g_miner_compiletime) + 63];
            if ( v127[2692] == 13 )
              v127[2692] = 0;
            v128 = &bench_hidiff_bins[15][strlen((const char *)g_miner_type) + 63];
            if ( v128[2948] == 10 )
              v128[2948] = 0;
            v129 = &bench_hidiff_bins[15][strlen((const char *)g_miner_type) + 63];
            if ( v129[2948] == 13 )
            {
              argva = (unsigned __int8 **)v327;
              v319 = (unsigned __int8 *)&use_syslog;
              v318 = &opt_log_output;
              v129[2948] = 0;
            }
            else
            {
              argva = (unsigned __int8 **)v327;
              v319 = (unsigned __int8 *)&use_syslog;
              v318 = &opt_log_output;
            }
LABEL_84:
            if ( *v319 )
            {
LABEL_87:
              snprintf(
                (char *)argva,
                0x800u,
                "Miner compile time: %s type: %s",
                (const char *)g_miner_compiletime,
                (const char *)g_miner_type);
              applog(3, (const unsigned __int8 *)argva, 0);
              goto LABEL_88;
            }
            goto LABEL_85;
          }
          v319 = (unsigned __int8 *)&use_syslog;
          if ( use_syslog )
          {
            v318 = &opt_log_output;
          }
          else
          {
            v318 = &opt_log_output;
            if ( !opt_log_output && opt_log_level <= 2 )
            {
              argva = (unsigned __int8 **)v327;
              goto LABEL_85;
            }
          }
          argva = (unsigned __int8 **)v327;
          snprintf(v327, 0x800u, "Read miner version file %s error %d", (const char *)opt_version_path, v123);
          applog(3, (const unsigned __int8 *)argva, 0);
          goto LABEL_84;
        }
        v319 = (unsigned __int8 *)&use_syslog;
        if ( use_syslog )
        {
          v318 = &opt_log_output;
        }
        else
        {
          v318 = &opt_log_output;
          if ( !opt_log_output && opt_log_level <= 2 )
          {
            argva = (unsigned __int8 **)v327;
LABEL_85:
            if ( *v318 || opt_log_level > 2 )
              goto LABEL_87;
LABEL_88:
            if ( opt_logfile_path )
            {
              g_logfile_enable = 1;
              strcpy((char *)g_logfile_path, (const char *)opt_logfile_path);
              if ( opt_logfile_openflag )
                strcpy((char *)g_logfile_openflag, (const char *)opt_logfile_openflag);
              if ( *v319 || *v318 || opt_log_level > 2 )
              {
                snprintf(
                  (char *)argva,
                  0x800u,
                  "Log file path: %s Open flag: %s",
                  (const char *)g_logfile_path,
                  (const char *)g_logfile_openflag);
                applog(3, (const unsigned __int8 *)argva, 0);
              }
            }
            if ( opt_logwork_path )
            {
              memset(v326, 0, sizeof(v326));
              if ( opt_logwork_asicnum )
              {
                if ( !*opt_logwork_asicnum )
                {
                  v185 = argva;
                  *argva = *(unsigned __int8 **)"Log work asic num empty";
                  strcpy((char *)v185 + 4, "work asic num empty");
                  applog(3, (const unsigned __int8 *)argva, 1);
                  quit(1);
                }
                v130 = strtol((const char *)opt_logwork_asicnum, 0, 10);
                v131 = v130 == 32;
                if ( v130 != 32 )
                  v131 = v130 == 1;
                g_logwork_asicnum = v130;
                if ( !v131 && v130 != 64 )
                {
                  v132 = argva;
                  *argva = *(unsigned __int8 **)"Log work asic num must be 1, 32, 64";
                  strcpy((char *)v132 + 4, "work asic num must be 1, 32, 64");
                  applog(3, (const unsigned __int8 *)argva, 1);
                  quit(1);
                }
                if ( *v319 || *v318 || opt_log_level > 2 )
                {
                  snprintf(
                    (char *)argva,
                    0x800u,
                    "Log work path: %s Asic num: %s",
                    (const char *)opt_logwork_path,
                    (const char *)opt_logwork_asicnum);
                  applog(3, (const unsigned __int8 *)argva, 0);
                }
              }
              else if ( *v319 || *v318 || opt_log_level > 2 )
              {
                snprintf((char *)argva, 0x800u, "Log work path: %s", (const char *)opt_logwork_path);
                applog(3, (const unsigned __int8 *)argva, 0);
              }
              sprintf((char *)v326, "%s.txt", (const char *)opt_logwork_path);
              g_logwork_file = fopen((const char *)v326, "a+");
              if ( *v319 || *v318 || opt_log_level > 2 )
              {
                snprintf((char *)argva, 0x800u, "Log work open file %s", (const char *)v326);
                applog(3, (const unsigned __int8 *)argva, 0);
              }
              v133 = g_logwork_asicnum;
              if ( g_logwork_asicnum == 1 )
              {
                sprintf((char *)v326, "%s%02d.txt", (const char *)opt_logwork_path, 1);
                g_logwork_files[0] = fopen((const char *)v326, "a+");
                if ( *v319 || *v318 || opt_log_level > 2 )
                {
                  snprintf(
                    (char *)argva,
                    0x800u,
                    "Log work open asic %d file %s",
                    g_logwork_asicnum,
                    (const char *)v326);
                  applog(3, (const unsigned __int8 *)argva, 0);
                }
              }
              else
              {
                v134 = g_logwork_asicnum == 32;
                if ( g_logwork_asicnum != 32 )
                  v134 = g_logwork_asicnum == 64;
                if ( v134 && g_logwork_asicnum >= 0 )
                {
                  v135 = &g_logwork_file;
                  v136 = 0;
                  v137 = (char *)argva;
                  v138 = v319;
                  do
                  {
                    sprintf((char *)v326, "%s%02d_%02d.txt", (const char *)opt_logwork_path, v133, v136);
                    v139 = fopen((const char *)v326, "a+");
                    v140 = *v138;
                    v135[1] = v139;
                    ++v135;
                    if ( v140 || *v318 || opt_log_level > 2 )
                    {
                      snprintf(v137, 0x800u, "Log work open asic %d file %s", g_logwork_asicnum, (const char *)v326);
                      applog(3, (const unsigned __int8 *)v137, 0);
                    }
                    v133 = g_logwork_asicnum;
                    ++v136;
                  }
                  while ( g_logwork_asicnum >= v136 );
                }
              }
              if ( opt_logwork_diff )
              {
                v141 = &opt_logwork_diff;
                v142 = 0;
                v143 = v318;
                v144 = (char *)argva;
                do
                {
                  sprintf((char *)v326, "%s_diff_%02d.txt", (const char *)opt_logwork_path, v142);
                  v145 = fopen((const char *)v326, "a+");
                  v146 = v319;
                  *((_DWORD *)v141 + 1) = v145;
                  v141 += 4;
                  if ( *v146 || *v143 || opt_log_level > 2 )
                  {
                    snprintf(v144, 0x800u, "Log work open diff file %s", (const char *)v326);
                    applog(3, (const unsigned __int8 *)v144, 0);
                  }
                  ++v142;
                }
                while ( v142 != 65 );
              }
            }
            if ( *v319 || *v318 || opt_log_level > 3 )
            {
              snprintf((char *)argva, 0x800u, "Started %s", (const char *)packagename);
              applog(4, (const unsigned __int8 *)argva, 0);
            }
            if ( !cnfbuf )
            {
LABEL_150:
              strcat((char *)opt_kernel_path, "/");
              if ( want_per_device_stats )
              {
                *v318 = 1;
              }
              else if ( !*v318 )
              {
                setlogmask(63);
                goto LABEL_153;
              }
              setlogmask(255);
LABEL_153:
              v149 = 0;
              v150 = opt_scantime;
              if ( opt_scantime < 0 )
                v150 = 60;
              if ( opt_scantime < 0 )
                opt_scantime = v150;
              total_control_threads = 8;
              v151 = (thr_info *)cgcalloc(8, 0x40u, "cgminer.c", (const unsigned __int8 *)&_func___15372, 11750);
              gwsched_thr_id = 0;
              control_thr = v151;
              fill_device_drv(&bitforce_drv);
              fill_device_drv(&modminer_drv);
              fill_device_drv(&bitmain_drv);
              fill_device_drv(&bitmain_c5_drv);
              bitforce_drv.drv_detect(0);
              modminer_drv.drv_detect(0);
              bitmain_drv.drv_detect(0);
              bitmain_c5_drv.drv_detect(0);
              v152 = total_devices;
              mining_threads = 0;
              if ( total_devices > 0 )
              {
                do
                {
                  v153 = devices[v149++];
                  enable_device(v153);
                  v152 = total_devices;
                }
                while ( total_devices > v149 );
              }
              if ( !v152 )
              {
                v184 = argva;
                *argva = *(unsigned __int8 **)"All devices disabled, cannot mint!";
                strcpy((char *)v184 + 4, "devices disabled, cannot mint!");
                applog(3, (const unsigned __int8 *)argva, 1);
                _quit(1, 0);
              }
              most_devices = v152;
              if ( !temp_cutoff_str )
              {
                if ( pthread_rwlock_rdlock(&devices_lock) )
                  rd_lock_0((pthread_rwlock_t *)&_func___12716, (const unsigned __int8 *)0x51C, v166, (const int)v167);
                if ( total_devices > 0 )
                {
                  v167 = devices;
                  v168 = &devices[total_devices];
                  do
                  {
                    v170 = (int)*v167++;
                    v169 = v170;
                    if ( !*(_DWORD *)(v170 + 184) )
                      *(_DWORD *)(v169 + 184) = 95;
                  }
                  while ( v167 != v168 );
                }
                rd_unlock(
                  &devices_lock,
                  (const unsigned __int8 *)&_func___12716,
                  (const unsigned __int8 *)0x525,
                  (const int)v167);
                goto LABEL_189;
              }
              v154 = strtok((char *)temp_cutoff_str, ",");
              if ( v154 )
              {
                v155 = (char *)argva;
                v314 = (void (**)(void))&selective_yield;
                v156 = 0;
                do
                {
                  if ( total_devices <= v156 )
                  {
                    strcpy(v155, "Too many values passed to set temp cutoff");
                    applog(3, (const unsigned __int8 *)v155, 1);
                    quit(1);
                  }
                  v159 = strtol(v154, 0, 10);
                  if ( v159 > 0xC8 )
                  {
                    strcpy(v155, "Invalid value passed to set temp cutoff");
                    applog(3, (const unsigned __int8 *)v155, 1);
                    quit(1);
                  }
                  if ( pthread_rwlock_rdlock(&devices_lock) )
                    rd_lock_0((pthread_rwlock_t *)&_func___12716, (const unsigned __int8 *)0x515, v160, v161);
                  devices[v156]->cutofftemp = v159;
                  if ( pthread_rwlock_unlock(&devices_lock) )
                    rw_unlock_1((pthread_rwlock_t *)&_func___12716, (const unsigned __int8 *)0x517, v157, v158);
                  ++v156;
                  (*v314)();
                  v154 = strtok(0, ",");
                }
                while ( v154 );
                if ( v156 != 1 )
                  goto LABEL_189;
              }
              else
              {
                v159 = 0;
                v156 = 0;
              }
              if ( pthread_rwlock_rdlock(&devices_lock) )
                rd_lock_0((pthread_rwlock_t *)&_func___12716, (const unsigned __int8 *)0x52C, v162, (const int)v163);
              if ( v156 < total_devices )
              {
                v164 = &devices[v156];
                v163 = &devices[total_devices];
                do
                {
                  v165 = (int)*v164++;
                  *(_DWORD *)(v165 + 184) = v159;
                }
                while ( v164 != v163 );
              }
              rd_unlock(
                &devices_lock,
                (const unsigned __int8 *)&_func___12716,
                (const unsigned __int8 *)0x532,
                (const int)v163);
LABEL_189:
              if ( total_devices > 0 )
              {
                v171 = devices;
                v172 = &devices[total_devices];
                do
                {
                  v173 = (int)*v171++;
                  *(_DWORD *)(v173 + 312) = 99999999;
                }
                while ( v171 != v172 );
              }
              if ( !opt_compact )
              {
                v174 = logstart + most_devices + 1;
                logstart += most_devices;
                logcursor = v174;
              }
              if ( !total_pools )
              {
                if ( *v319 || *v318 || opt_log_level > 3 )
                {
                  v195 = argva;
                  *argva = *(unsigned __int8 **)"Need to specify at least one pool server.";
                  strcpy((char *)v195 + 4, " to specify at least one pool server.");
                  applog(4, (const unsigned __int8 *)argva, 0);
                }
                v196 = argva;
                *argva = *(unsigned __int8 **)"Pool setup failed";
                strcpy((char *)v196 + 4, " setup failed");
                applog(3, (const unsigned __int8 *)argva, 1);
                _quit(1, 0);
              }
              v317 = &pools;
              if ( total_pools > 0 )
              {
                v175 = 0;
                v176 = pools;
                do
                {
                  v177 = v176[v175];
                  rpc_userpass = v177->rpc_userpass;
                  v177->cgminer_stats.getwork_wait_min.tv_sec = 99999999;
                  v177->cgminer_pool_stats.getwork_wait_min.tv_sec = 99999999;
                  if ( !rpc_userpass )
                  {
                    if ( !v177->rpc_pass )
                      v177->rpc_pass = (unsigned __int8 *)calloc(1u, 1u);
                    rpc_user = (const char *)v177->rpc_user;
                    if ( !rpc_user )
                    {
                      snprintf(
                        (char *)argva,
                        0x800u,
                        "No login credentials supplied for pool %u %s",
                        v175,
                        (const char *)v177->rpc_url);
                      v296 = argva;
                      goto LABEL_456;
                    }
                    v180 = strlen(rpc_user);
                    v181 = v180 + strlen((const char *)v177->rpc_pass) + 2;
                    v182 = (char *)cgmalloc(v181, "cgminer.c", (const unsigned __int8 *)&_func___15372, 11859);
                    rpc_pass = (const char *)v177->rpc_pass;
                    v177->rpc_userpass = (unsigned __int8 *)v182;
                    snprintf(v182, v181, "%s:%s", (const char *)v177->rpc_user, rpc_pass);
                    v176 = *v317;
                  }
                  ++v175;
                }
                while ( total_pools > v175 );
              }
              v191 = *v319;
              currentpool = **v317;
              if ( v191 )
                openlog("bmminer", 1, 8);
              if ( opt_stderr_cmd )
              {
                if ( pipe((int *)argva) < 0 )
                {
                  perror("pipe - failed to create pipe for --monitor");
                  exit(1);
                }
                fflush((FILE *)stderr);
                if ( dup2((int)argva[1], 2) < 0 )
                {
                  perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                  exit(1);
                }
                if ( close((int)argva[1]) < 0 )
                {
                  perror("close - failed to close write end of pipe for --monitor");
                  exit(1);
                }
                v192 = signal(13, (__sighandler_t)1);
                if ( signal(13, (__sighandler_t)1) == (__sighandler_t)-1 || v192 == (__sighandler_t)-1 )
                {
                  perror("signal - failed to edit signal mask for --monitor");
                  exit(1);
                }
                v193 = fork();
                v194 = v193;
                forkpid = v193;
                if ( v193 < 0 )
                {
                  perror("fork - failed to fork child process for --monitor");
                  exit(1);
                }
                if ( !v193 )
                {
                  if ( dup2((int)*argva, 0) >= 0 )
                  {
                    close((int)*argva);
                    execl("/bin/bash", "/bin/bash", "-c", opt_stderr_cmd, v194);
                    perror("execl - in child failed to exec user specified command for --monitor");
                    exit(1);
                  }
                  perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                  exit(1);
                }
                if ( close((int)*argva) < 0 )
                {
                  perror("close - failed to close read end of pipe for --monitor");
                  exit(1);
                }
              }
              mining_thr = (thr_info **)cgcalloc(
                                          mining_threads,
                                          4u,
                                          "cgminer.c",
                                          (const unsigned __int8 *)&_func___15372,
                                          11876);
              if ( mining_threads > 0 )
              {
                v197 = 0;
                do
                {
                  v198 = mining_thr;
                  v199 = (thr_info *)cgcalloc(1, 0x40u, "cgminer.c", (const unsigned __int8 *)&_func___15372, 11880);
                  v200 = mining_threads;
                  v198[v197++] = v199;
                }
                while ( v200 > v197 );
              }
              if ( total_devices > 0 )
              {
                v201 = 0;
                pool = 0;
                do
                {
                  v202 = 0;
                  v203 = devices[(_DWORD)pool];
                  v204 = (thr_info **)cgmalloc(
                                        4 * (v203->threads + 1),
                                        "cgminer.c",
                                        (const unsigned __int8 *)&_func___15372,
                                        11889);
                  threads = v203->threads;
                  v203->thr = v204;
                  v204[threads] = 0;
                  v203->status = LIFE_INIT;
                  if ( threads > 0 )
                  {
                    do
                    {
                      while ( 1 )
                      {
                        thread = get_thread(v201);
                        drv = v203->drv;
                        v208 = thread;
                        thread->id = v201;
                        thread->cgpu = v203;
                        thread_prepare = (int (*)(void))drv->thread_prepare;
                        thread->device_thread = v202;
                        if ( thread_prepare() )
                        {
                          if ( thr_info_create(v208, 0, start, v208) )
                          {
                            snprintf((char *)argva, 0x800u, "thread %d create failed", v208->id);
                            applog(3, (const unsigned __int8 *)argva, 1);
                            _quit(1, 0);
                          }
                          deven = v203->deven;
                          v203->thr[v202] = v208;
                          if ( deven != DEV_DISABLED )
                            break;
                        }
                        ++v202;
                        ++v201;
                        if ( v203->threads <= v202 )
                          goto LABEL_286;
                      }
                      if ( opt_debug && (*v319 || *v318 || opt_log_level > 6) )
                      {
                        snprintf((char *)argva, 0x800u, "Pushing sem post to thread %d", v208->id);
                        applog(7, (const unsigned __int8 *)argva, 0);
                      }
                      ++v202;
                      ++v201;
                      cgsem_post(&v208->sem, "cgminer.c", (const unsigned __int8 *)&_func___15372, 11917);
                    }
                    while ( v203->threads > v202 );
                  }
LABEL_286:
                  v103 = total_devices <= (int)&pool->pool_no + 1;
                  pool = (pool *)((char *)pool + 1);
                }
                while ( !v103 );
              }
              if ( opt_benchmark || (v211 = (int)opt_benchfile) != 0 )
              {
begin_bench:
                v212 = (int *)g_local_mhashes_dones;
                total_mhashes_done = 0.0;
                do
                {
                  *(_QWORD *)v212 = 0LL;
                  v212 += 2;
                }
                while ( v212 != &g_local_mhashes_index );
                g_local_mhashes_index = 0;
                if ( total_devices > 0 )
                {
                  v213 = devices;
                  v214 = &devices[total_devices];
                  do
                  {
                    v215 = (int)*v213++;
                    *(_QWORD *)(v215 + 80) = 0LL;
                    *(_QWORD *)(v215 + 48) = 0LL;
                  }
                  while ( v213 != v214 );
                }
                if ( sysinfo_0(v326) )
                {
                  if ( *v319 || *v318 || opt_log_level > 5 )
                  {
                    v216 = *_errno_location();
                    v217 = strerror(v216);
                    snprintf((char *)argva, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v216, v217);
                    applog(6, (const unsigned __int8 *)argva, 0);
                  }
                  total_tv_end_sys = time(0);
                  total_tv_start_sys = time(0);
                }
                else
                {
                  total_tv_end_sys = v326[0].uptime;
                  total_tv_start_sys = v326[0].uptime;
                }
                cgtime(&total_tv_start);
                cgtime(&total_tv_end);
                cgtime(&tv_hashmeter);
                get_datestamp(datestamp, 0x28u, &total_tv_start);
                v218 = control_thr;
                watchpool_thr_id = 2;
                if ( thr_info_create(control_thr + 2, 0, watchpool_thread, 0) )
                {
                  v298 = argva;
                  *argva = *(unsigned __int8 **)"watchpool thread create failed";
                  strcpy((char *)v298 + 4, "hpool thread create failed");
                  applog(3, (const unsigned __int8 *)argva, 1);
                  _quit(1, 0);
                }
                pthread_detach(v218[2].pth);
                watchdog_thr_id = 3;
                v312 = control_thr;
                if ( thr_info_create(control_thr + 3, 0, watchdog_thread, 0) )
                {
                  v297 = argva;
                  *argva = *(unsigned __int8 **)"watchdog thread create failed";
                  strcpy((char *)v297 + 4, "hdog thread create failed");
                  applog(3, (const unsigned __int8 *)argva, 1);
                  _quit(1, 0);
                }
                pthread_detach(v312[3].pth);
                api_thr_id = 5;
                if ( thr_info_create(control_thr + 5, 0, api_thread, &control_thr[5]) )
                {
                  v299 = argva;
                  *argva = *(unsigned __int8 **)"API thread create failed";
                  strcpy((char *)v299 + 4, "thread create failed");
                  v296 = argva;
LABEL_456:
                  applog(3, (const unsigned __int8 *)v296, 1);
                  _quit(1, 0);
                }
                if ( total_control_threads != 8 )
                {
                  snprintf(
                    (char *)argva,
                    0x800u,
                    "incorrect total_control_threads (%d) should be 8",
                    total_control_threads);
                  applog(3, (const unsigned __int8 *)argva, 1);
                  _quit(1, 0);
                }
                if ( nice(-10) )
                {
                  v314 = (void (**)(void))&selective_yield;
                  v316 = &opt_log_level;
                  ptr = &opt_debug;
                  v315 = &opt_work_update;
                }
                else
                {
                  ptr = &opt_debug;
                  if ( opt_debug )
                  {
                    if ( *v319 || *v318 )
                    {
                      v316 = &opt_log_level;
LABEL_337:
                      v235 = argva;
                      v314 = (void (**)(void))&selective_yield;
                      v315 = &opt_work_update;
                      *argva = *(unsigned __int8 **)"Unable to set thread to high priority";
                      strcpy((char *)v235 + 4, "le to set thread to high priority");
                      applog(7, (const unsigned __int8 *)argva, 0);
                      goto LABEL_338;
                    }
                    v316 = &opt_log_level;
                    if ( opt_log_level > 6 )
                      goto LABEL_337;
                    v314 = (void (**)(void))&selective_yield;
                    v315 = &opt_work_update;
                  }
                  else
                  {
                    v314 = (void (**)(void))&selective_yield;
                    v316 = &opt_log_level;
                    v315 = &opt_work_update;
                  }
                }
LABEL_338:
                if ( *v315 )
                  goto LABEL_423;
                while ( 1 )
                {
                  v236 = stgd_lock;
                  *v315 = 0;
                  if ( pthread_mutex_lock(v236) )
                    mutex_lock_2((pthread_mutex_t *)&_func___15372, (const unsigned __int8 *)0x2F3C, v237, v238);
                  num_items = (signed int)staged_work;
                  if ( staged_work )
                  {
                    num_items = staged_work->hh.tbl->num_items;
                    if ( num_items > 1 )
                    {
                      work_filled = 1;
                      pthread_cond_wait(&gws_cond, stgd_lock);
                      num_items = (signed int)staged_work;
                      if ( staged_work )
                        num_items = staged_work->hh.tbl->num_items;
                    }
                  }
                  if ( pthread_mutex_unlock(stgd_lock) )
                    mutex_unlock_noyield_2(
                      (pthread_mutex_t *)&_func___15372,
                      (const unsigned __int8 *)0x2F47,
                      v240,
                      v241);
                  (*v314)();
                  if ( num_items > 1 )
                  {
                    work_filled = 1;
                    work = hash_pop(0);
                    if ( work )
                      discard_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___15372, 12115);
                    goto LABEL_338;
                  }
                  if ( work )
                    discard_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___15372, 12123);
                  work = make_work();
                  while ( 1 )
                  {
                    v243 = current_pool();
                    pool = v243;
                    if ( pool_strategy_0 == POOL_BALANCE )
                    {
                      pool = select_balanced(v243);
                      goto LABEL_347;
                    }
                    if ( pool_strategy_0 == POOL_LOADBALANCE )
                    {
                      v244 = total_pools;
                      if ( total_pools <= 0 )
                        goto LABEL_372;
                      if ( (**v317)->quota_gcd <= (**v317)->quota_used )
                      {
                        v245 = *v317;
                        v246 = *v317;
                        v247 = 0;
                        while ( ++v247 != total_pools )
                        {
                          v248 = v246[1];
                          ++v246;
                          if ( v248->quota_used < v248->quota_gcd )
                            goto LABEL_374;
                        }
                        v249 = (int)&(*v317)[total_pools];
                        do
                        {
                          v250 = (int)*v245++;
                          *(_DWORD *)(v250 + 64) = 0;
                        }
                        while ( v245 != (pool **)v249 );
LABEL_372:
                        if ( v244 <= ++rotating_pool_13439 )
                          rotating_pool_13439 = 0;
                      }
LABEL_374:
                      v251 = 0;
                      v252 = (bool *)*v317;
                      while ( v244 > v251 )
                      {
                        v253 = rotating_pool_13439;
                        v254 = *(pool **)&v252[4 * rotating_pool_13439];
                        quota_used = v254->quota_used;
                        quota_gcd = v254->quota_gcd;
                        v254->quota_used = quota_used + 1;
                        if ( quota_used < quota_gcd )
                        {
                          diff = v252;
                          v257 = pool_unusable(v254);
                          v252 = diff;
                          if ( !v257 )
                          {
                            pool = v254;
                            goto LABEL_347;
                          }
                        }
                        ++v251;
                        rotating_pool_13439 = v253 + 1;
                        if ( v244 <= v253 + 1 )
                          rotating_pool_13439 = 0;
                      }
                      if ( v244 > 0 )
                      {
                        v258 = 0;
                        while ( 1 )
                        {
                          v259 = priority_pool(v258);
                          if ( !pool_unusable(v259) )
                            break;
                          if ( ++v258 >= total_pools )
                            goto LABEL_347;
                        }
                        v260 = pool;
                        if ( v259 )
                          v260 = v259;
                        pool = v260;
                      }
                    }
LABEL_347:
                    if ( *(_BYTE *)ptr && (*v319 || *v318 || *v316 > 6) )
                    {
                      snprintf((char *)argva, 0x800u, "Selecting pool %d for work", pool->pool_no);
                      applog(7, (const unsigned __int8 *)argva, 0);
                    }
                    if ( !pool_unusable(pool) )
                      break;
                    switch_pools(0);
                    v242 = current_pool();
                    pool = v242;
                    if ( pool_strategy_0 == POOL_BALANCE )
                    {
                      pool = select_balanced(v242);
                      goto LABEL_355;
                    }
                    if ( pool_strategy_0 == POOL_LOADBALANCE )
                    {
                      v261 = total_pools;
                      if ( total_pools <= 0 )
                        goto LABEL_395;
                      if ( (**v317)->quota_gcd <= (**v317)->quota_used )
                      {
                        v262 = *v317;
                        v263 = *v317;
                        v264 = 0;
                        while ( ++v264 != total_pools )
                        {
                          v265 = v263[1];
                          ++v263;
                          if ( v265->quota_used < v265->quota_gcd )
                            goto LABEL_397;
                        }
                        v266 = (int)&(*v317)[total_pools];
                        do
                        {
                          v267 = (int)*v262++;
                          *(_DWORD *)(v267 + 64) = 0;
                        }
                        while ( v262 != (pool **)v266 );
LABEL_395:
                        if ( ++rotating_pool_13439 >= v261 )
                          rotating_pool_13439 = 0;
                      }
LABEL_397:
                      v268 = 0;
                      v269 = (bool *)*v317;
                      while ( v268 < v261 )
                      {
                        v270 = rotating_pool_13439;
                        v271 = *(pool **)&v269[4 * rotating_pool_13439];
                        v272 = v271->quota_used;
                        v273 = v271->quota_gcd;
                        v271->quota_used = v272 + 1;
                        if ( v272 < v273 )
                        {
                          diff = v269;
                          v274 = pool_unusable(v271);
                          v269 = diff;
                          if ( !v274 )
                          {
                            pool = v271;
                            goto LABEL_355;
                          }
                        }
                        ++v268;
                        rotating_pool_13439 = v270 + 1;
                        if ( v270 + 1 >= v261 )
                          rotating_pool_13439 = 0;
                      }
                      if ( v261 > 0 )
                      {
                        v275 = 0;
                        while ( 1 )
                        {
                          v276 = priority_pool(v275);
                          if ( !pool_unusable(v276) )
                            break;
                          if ( ++v275 >= total_pools )
                            goto LABEL_355;
                        }
                        v277 = pool;
                        if ( v276 )
                          v277 = v276;
                        pool = v277;
                      }
                    }
LABEL_355:
                    if ( *(_BYTE *)ptr && (*v319 || *v318 || *v316 > 6) )
                    {
                      snprintf((char *)argva, 0x800u, "Selecting pool %d for work", pool->pool_no);
                      applog(7, (const unsigned __int8 *)argva, 0);
                    }
                    if ( pool_unusable(pool) )
                      cgsleep_ms(11);
                  }
                  if ( pool->has_stratum )
                  {
                    gen_stratum_work(pool, work);
                    if ( *(_BYTE *)ptr && (*v319 || *v318 || *v316 > 6) )
                    {
                      v295 = argva;
                      *argva = *(unsigned __int8 **)"Generated stratum work";
                      strcpy((char *)v295 + 4, "rated stratum work");
                      applog(7, (const unsigned __int8 *)argva, 0);
                    }
                    goto LABEL_422;
                  }
                  if ( opt_benchfile )
                  {
                    get_benchfile_work(work);
                    if ( *(_BYTE *)ptr && (*v319 || *v318 || *v316 > 6) )
                    {
                      v278 = "Generated benchfile work";
                      goto LABEL_421;
                    }
                    goto LABEL_422;
                  }
                  if ( !opt_benchmark )
                    goto LABEL_338;
                  get_benchmark_work(work);
                  if ( *(_BYTE *)ptr && (*v319 || *v318 || *v316 > 6) )
                  {
                    v278 = "Generated benchmark work";
LABEL_421:
                    v279 = *(unsigned __int8 **)v278;
                    v280 = (unsigned __int8 *)*((_DWORD *)v278 + 1);
                    v281 = (unsigned __int8 *)*((_DWORD *)v278 + 2);
                    v282 = (unsigned __int8 *)*((_DWORD *)v278 + 3);
                    v283 = (unsigned __int8 **)(v278 + 16);
                    v284 = argva;
                    *argva = v279;
                    v284[1] = v280;
                    v284[2] = v281;
                    v284[3] = v282;
                    v284 += 4;
                    v285 = v283[1];
                    v286 = v283[2];
                    *v284 = *v283;
                    v284[1] = v285;
                    *((_BYTE *)v284 + 8) = (_BYTE)v286;
                    applog(7, (const unsigned __int8 *)argva, 0);
                  }
LABEL_422:
                  stage_work(work);
                  work = 0;
                  if ( *v315 )
                  {
LABEL_423:
                    if ( *v319 || *v318 || *v316 > 5 )
                    {
                      v287 = argva;
                      *argva = *(unsigned __int8 **)"Work update message received";
                      strcpy((char *)v287 + 4, " update message received");
                      applog(6, (const unsigned __int8 *)argva, 0);
                    }
                    cgtime(&update_tv_start);
                    if ( pthread_rwlock_rdlock(&mining_thr_lock) )
                      rd_lock_0(
                        (pthread_rwlock_t *)&_func___12716.__size[20],
                        (const unsigned __int8 *)0x151A,
                        v288,
                        v289);
                    if ( mining_threads > 0 )
                    {
                      v290 = mining_thr;
                      v291 = &mining_thr[mining_threads];
                      do
                      {
                        v292 = (int)*v290++;
                        *(_BYTE *)(v292 + 63) = 1;
                      }
                      while ( v290 != v291 );
                    }
                    if ( pthread_rwlock_unlock(&mining_thr_lock) )
                      rw_unlock_1(
                        (pthread_rwlock_t *)&_func___12716.__size[20],
                        (const unsigned __int8 *)0x1521,
                        v293,
                        v294);
                    (*v314)();
                  }
                }
              }
              v219 = total_pools;
              v220 = enabled_pools;
              v221 = *v317;
              while ( v211 < v219 )
              {
                v222 = v221[v211++];
                v223 = v222->enabled;
                v222->idle = 1;
                if ( v223 != POOL_ENABLED )
                {
                  ++v220;
                  v222->enabled = POOL_ENABLED;
                }
              }
              enabled_pools = v220;
              if ( *v319 || *v318 || opt_log_level > 4 )
              {
                v224 = argva;
                *argva = *(unsigned __int8 **)"Probing for an alive pool";
                strcpy((char *)v224 + 4, "ing for an alive pool");
                applog(5, (const unsigned __int8 *)argva, 0);
              }
              v225 = v317;
              for ( i = 0; i < total_pools; ++i )
              {
                v227 = (*v225)[i];
                v227->testing = 1;
                pthread_create(&v227->test_thread, 0, start_routine, v227);
              }
              v228 = 60;
              do
              {
                sleep(1u);
                if ( pools_active )
                  break;
                --v228;
              }
              while ( v228 );
              v229 = v318;
              v230 = 0;
              v231 = (char *)argva;
              v232 = (thr_info *)v319;
              while ( 1 )
              {
                while ( 1 )
                {
                  if ( pools_active )
                    goto begin_bench;
                  if ( !v230 )
                    break;
                  v233 = &use_curses;
LABEL_330:
                  if ( !*v233 )
                    goto LABEL_331;
                }
                if ( ((LOBYTE(v232->id) || *v229 || opt_log_level > 2)
                   && ((strcpy(v231, "No servers were found that could be used to get work from."),
                        applog(3, (const unsigned __int8 *)v231, 0),
                        LOBYTE(v232->id))
                    || *v229)
                   || opt_log_level > 2)
                  && ((strcpy(v231, "Please check the details from the list below of the servers you have input"),
                       applog(3, (const unsigned __int8 *)v231, 0),
                       LOBYTE(v232->id))
                   || *v229)
                  || opt_log_level > 2 )
                {
                  strcpy(
                    v231,
                    "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                  applog(3, (const unsigned __int8 *)v231, 0);
                }
                v300 = v232;
                v301 = v229;
                v302 = v231;
                v303 = 0;
                v304 = v300;
                while ( v303 < total_pools )
                {
                  v305 = (*v317)[v303];
                  if ( LOBYTE(v304->id) || *v301 || opt_log_level > 3 )
                  {
                    func = v305->rpc_url;
                    v308 = (const char *)v305->rpc_user;
                    v309 = (const char *)v305->rpc_pass;
                    v312 = v304;
                    snprintf(
                      v302,
                      0x800u,
                      "Pool: %d  URL: %s  User: %s  Password: %s",
                      v303,
                      (const char *)func,
                      v308,
                      v309);
                    applog(4, (const unsigned __int8 *)v302, 0);
                    v304 = v312;
                  }
                  ++v303;
                }
                v231 = v302;
                v229 = v301;
                v232 = v304;
                if ( !use_curses )
                {
LABEL_331:
                  v234 = argva;
                  *argva = *(unsigned __int8 **)"No servers could be used! Exiting.";
                  strcpy((char *)v234 + 4, "ervers could be used! Exiting.");
                  applog(3, (const unsigned __int8 *)argva, 1);
                  _quit(0, 0);
                }
                if ( LOBYTE(v304->id) || *v229 || opt_log_level > 2 )
                {
                  diff = &use_curses;
                  strcpy(v231, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                  applog(3, (const unsigned __int8 *)v231, 0);
                  v230 = 1;
                  v233 = diff;
                  goto LABEL_330;
                }
                v230 = 1;
              }
            }
            if ( *v319 || *v318 || opt_log_level > 4 )
            {
              snprintf((char *)argva, 0x800u, "Loaded configuration file %s", (const char *)cnfbuf);
              applog(5, (const unsigned __int8 *)argva, 0);
            }
            if ( fileconf_load == -1 )
            {
              if ( *v319 || *v318 || opt_log_level > 3 )
              {
                v186 = argva;
                *argva = *(unsigned __int8 **)"Error in configuration file, partially loaded.";
                strcpy((char *)v186 + 4, "r in configuration file, partially loaded.");
                applog(4, (const unsigned __int8 *)argva, 0);
              }
              if ( use_curses && (*v319 || *v318 || opt_log_level > 3) )
              {
                v187 = argva;
                *argva = *(unsigned __int8 **)"Start cgminer with -T to see what failed to load.";
                strcpy((char *)v187 + 4, "t cgminer with -T to see what failed to load.");
                applog(4, (const unsigned __int8 *)argva, 0);
              }
              goto LABEL_149;
            }
            if ( !fileconf_load )
            {
              if ( *v319 || *v318 || (v316 = &opt_log_level, opt_log_level > 3) )
              {
                v147 = argva;
                *argva = *(unsigned __int8 **)"Fatal JSON error in configuration file.";
                strcpy((char *)v147 + 4, "l JSON error in configuration file.");
                applog(4, (const unsigned __int8 *)argva, 0);
                if ( *v319 || *v318 )
                  goto LABEL_148;
                v316 = &opt_log_level;
              }
              if ( *v316 > 3 )
              {
LABEL_148:
                v148 = argva;
                *argva = *(unsigned __int8 **)"Configuration file could not be used.";
                strcpy((char *)v148 + 4, "iguration file could not be used.");
                applog(4, (const unsigned __int8 *)argva, 0);
              }
            }
LABEL_149:
            free(cnfbuf);
            cnfbuf = 0;
            goto LABEL_150;
          }
        }
        argva = (unsigned __int8 **)v327;
        snprintf(v327, 0x800u, "Open miner version file %s error", (const char *)opt_version_path);
        applog(3, (const unsigned __int8 *)argva, 0);
        goto LABEL_84;
      }
      v77 = 24 * v76->num_buckets;
      v78 = (UT_hash_bucket_0 *)malloc(v77);
      v79 = v78;
      if ( v78 )
      {
        memset(v78, 0, v77);
        v80 = v34->hh.tbl;
        num_buckets = v80->num_buckets;
        v82 = v80->num_items;
        log2_num_buckets = v80->log2_num_buckets;
        v80->nonideal_items = 0;
        v84 = v82 >> (log2_num_buckets + 1);
        pool = (pool *)(2 * num_buckets - 1);
        if ( ((unsigned int)pool & v82) != 0 )
          v85 = v84 + 1;
        else
          v85 = v84;
        v80->ideal_chain_maxlen = v85;
        if ( num_buckets )
        {
          v86 = v80->buckets;
          v318 = (bool *)v34;
          v87 = 0;
          v88 = v80;
          ptr = v86;
          v319 = (unsigned __int8 *)(12 * num_buckets);
          do
          {
            v89 = *(UT_hash_handle **)&v87[(_DWORD)ptr];
            if ( v89 )
            {
              v90 = v88;
              v91 = v85;
              do
              {
                hashv = v89->hashv;
                hh_next = v89->hh_next;
                v94 = (unsigned int)pool & hashv;
                v95 = (int)&v79[(unsigned int)pool & hashv];
                v96 = *(_DWORD *)(v95 + 4) + 1;
                *(_DWORD *)(v95 + 4) = v96;
                if ( v91 < v96 )
                {
                  ++v90->nonideal_items;
                  diff = v87;
                  v312 = (thr_info *)v95;
                  *(_DWORD *)(v95 + 8) = v96 / v91;
                }
                v97 = v79[v94].hh_head;
                v89->hh_prev = 0;
                v89->hh_next = v97;
                if ( v97 )
                  v97->hh_prev = v89;
                v79[v94].hh_head = v89;
                v89 = hh_next;
              }
              while ( hh_next );
              v85 = v91;
              v88 = v90;
            }
            v87 += 12;
          }
          while ( v87 != (bool *)v319 );
          v34 = (block *)v318;
        }
        else
        {
          ptr = v80->buckets;
        }
        free(ptr);
        v98 = v34->hh.tbl;
        nonideal_items = v98->nonideal_items;
        v100 = v98->num_items;
        v101 = v98->num_buckets;
        v102 = v98->log2_num_buckets;
        v98->buckets = v79;
        v103 = nonideal_items > v100 >> 1;
        v104 = 2 * v101;
        v105 = v102 + 1;
        if ( nonideal_items <= v100 >> 1 )
          nonideal_items = 0;
        v98->log2_num_buckets = v105;
        v98->num_buckets = v104;
        if ( v103 )
        {
          v106 = v98->ineff_expands + 1;
          v98->ineff_expands = v106;
          if ( v106 > 1 )
            v98->noexpand = 1;
        }
        else
        {
          v98->ineff_expands = nonideal_items;
        }
        goto LABEL_59;
      }
LABEL_228:
      exit(-1);
    }
    strcpy(v327, "Failed to create getq");
  }
  applog(3, (const unsigned __int8 *)v327, 1);
  _quit(1, 0);
}
// ACDC: variable 'v5' is possibly undefined
// AD28: variable 'v15' is possibly undefined
// AD34: variable 'v16' is possibly undefined
// AD40: variable 'v17' is possibly undefined
// AD4C: variable 'v18' is possibly undefined
// AD5A: variable 'v19' is possibly undefined
// AD66: variable 'v20' is possibly undefined
// AD74: variable 'v21' is possibly undefined
// AD82: variable 'v22' is possibly undefined
// AD8E: variable 'v23' is possibly undefined
// AD9A: variable 'v24' is possibly undefined
// ADA6: variable 'v25' is possibly undefined
// ADB4: variable 'v26' is possibly undefined
// ADD2: variable 'v27' is possibly undefined
// B460: variable 'v118' is possibly undefined
// BBAE: variable 'v160' is possibly undefined
// BBAE: variable 'v161' is possibly undefined
// BBFE: variable 'v162' is possibly undefined
// BBFE: variable 'v163' is possibly undefined
// BC42: variable 'v166' is possibly undefined
// BC42: variable 'v167' is possibly undefined
// BDC8: variable 'v157' is possibly undefined
// BDC8: variable 'v158' is possibly undefined
// CD8A: variable 'v288' is possibly undefined
// CD8A: variable 'v289' is possibly undefined
// CD96: variable 'v240' is possibly undefined
// CD96: variable 'v241' is possibly undefined
// CDA2: variable 'v237' is possibly undefined
// CDA2: variable 'v238' is possibly undefined
// CF28: variable 'v293' is possibly undefined
// CF28: variable 'v294' is possibly undefined
// 1E1D4: using guessed type void __noreturn errlog();
// 62990: using guessed type int stderr;
// 6E6A10: using guessed type int rotating_pool_13439;

//----- (0000D0B8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)&va,
    (void (*)(void))init,
    (void (*)(void))_libc_csu_fini,
    a1,
    &va);
  abort();
}
// D0C4: positive sp value 4 has been found
// D0DA: variable 'v4' is possibly undefined
// 440D0: using guessed type int init();
// 44114: using guessed type int _libc_csu_fini();

//----- (0000D0F0) --------------------------------------------------------
int call_gmon_start()
{
  int result; // r0

  if ( &__gmon_start__ )
    return sub_A098();
  return result;
}
// A098: using guessed type int sub_A098(void);

//----- (0000D108) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &stdin;
}
// 62988: using guessed type int stdin;

//----- (0000D12C) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &stdin;
  HIDWORD(result) = 0;
  return result;
}
// 62988: using guessed type int stdin;

//----- (0000D158) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !completed_8605 )
  {
    result = deregister_tm_clones();
    completed_8605 = 1;
  }
  return result;
}
// 62994: using guessed type char completed_8605;

//----- (0000D170) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (0000D190) --------------------------------------------------------
void __fastcall sha2_starts(sha2_context *ctx)
{
  ctx->state[0] = 1779033703;
  ctx->state[1] = -1150833019;
  ctx->state[2] = 1013904242;
  ctx->state[3] = -1521486534;
  ctx->state[4] = 1359893119;
  ctx->state[5] = -1694144372;
  ctx->state[6] = 528734635;
  ctx->state[7] = 1541459225;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
}

//----- (0000D1F8) --------------------------------------------------------
void __fastcall sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int v2; // r3
  unsigned int v3; // r4
  unsigned int v4; // r10
  int v5; // r7
  int v6; // r7
  int v7; // r2
  int v8; // r3
  unsigned int v9; // r5
  int v10; // r8
  unsigned int v11; // r4
  int v12; // r8
  unsigned int v13; // r0
  int v14; // r11
  int v15; // r6
  unsigned int v16; // r11
  unsigned int v17; // r2
  int v18; // r5
  int v19; // r3
  int v20; // r4
  unsigned int v21; // r6
  unsigned int v22; // r7
  int v23; // r0
  unsigned int v24; // r8
  unsigned int v25; // r11
  int v26; // r2
  unsigned int v27; // r6
  unsigned int v28; // r2
  int v29; // r3
  unsigned int v30; // r5
  int v31; // r10
  unsigned int v32; // r3
  int v33; // r8
  unsigned int v34; // r10
  unsigned int v35; // r4
  int v36; // r12
  unsigned int v37; // r0
  int v38; // r12
  int v39; // r12
  unsigned int v40; // r2
  unsigned int v41; // r7
  int v42; // r5
  unsigned int v43; // r3
  unsigned int v44; // r6
  int v45; // r5
  unsigned int v46; // r11
  unsigned int v47; // r8
  int v48; // r12
  unsigned int v49; // r0
  unsigned int v50; // r1
  unsigned int v51; // r10
  int v52; // r0
  unsigned int v53; // r0
  unsigned int v54; // r7
  unsigned int v55; // r9
  int v56; // r3
  unsigned int v57; // r6
  int v58; // r5
  int v59; // r3
  int v60; // r4
  unsigned int v61; // r11
  int v62; // r3
  int v63; // r0
  unsigned int v64; // r10
  int v65; // r3
  int v66; // r1
  unsigned int v67; // r9
  int v68; // r6
  int v69; // r2
  int v70; // r7
  int v71; // r6
  int v72; // r4
  int v73; // r11
  int v74; // r12
  int v75; // r0
  int v76; // r3
  int v77; // r8
  int v78; // r12
  int v79; // r6
  int v80; // r7
  int v81; // r5
  int v82; // r10
  int v83; // r7
  int v84; // r11
  int v85; // r1
  int v86; // r7
  int v87; // r2
  int v88; // r9
  int v89; // r7
  int v90; // r3
  int v91; // r12
  int v92; // r10
  int v93; // r7
  int v94; // r8
  int v95; // r10
  int v96; // r1
  int v97; // r6
  int v98; // r11
  int v99; // r2
  int v100; // r4
  int v101; // r11
  int v102; // r3
  int v103; // r5
  int v104; // r11
  int v105; // r7
  int v106; // r0
  int v107; // r10
  int v108; // r6
  int v109; // r1
  int v110; // r10
  int v111; // r4
  int v112; // r2
  int v113; // r11
  int v114; // r5
  int v115; // r3
  int v116; // r11
  int v117; // r0
  int v118; // r12
  int v119; // r11
  int v120; // r7
  int v121; // r1
  int v122; // r6
  int v123; // r2
  int v124; // r4
  int v125; // r9
  int v126; // r3
  int v127; // r5
  int v128; // r10
  int v129; // r12
  int v130; // r6
  int v131; // r10
  int v132; // r7
  int v133; // r0
  int v134; // r9
  int v135; // r4
  int v136; // r2
  int v137; // r9
  int v138; // r5
  int v139; // r3
  int v140; // r10
  int v141; // r6
  int v142; // r8
  int v143; // r10
  int v144; // r0
  int v145; // r1
  int v146; // r9
  int v147; // r2
  int v148; // r4
  int v149; // r9
  int v150; // r3
  int v151; // r5
  int v152; // r10
  int v153; // r9
  int v154; // r12
  int v155; // r6
  int v156; // r1
  int v157; // r0
  int v158; // r8
  int v159; // r4
  int v160; // r2
  int v161; // r8
  int v162; // r5
  int v163; // r7
  int v164; // r10
  int v165; // r12
  int v166; // r6
  unsigned int v167; // r8
  unsigned int v168; // r0
  int v169; // r1
  unsigned int v170; // r4
  unsigned int v171; // r6
  int v172; // r5
  unsigned int v173; // r3
  int v174; // r9
  unsigned int v175; // r0
  unsigned int v176; // r2
  int v177; // r5
  unsigned int v178; // r0
  int v179; // r0
  unsigned int v180; // r3
  unsigned int v181; // r1
  unsigned int v182; // r10
  int v183; // r5
  unsigned int v184; // r2
  unsigned int v185; // r4
  int v186; // r5
  unsigned int v187; // r0
  unsigned int v188; // r5
  int v189; // r9
  unsigned int v190; // r6
  unsigned int v191; // r7
  unsigned int v192; // [sp+0h] [bp-98h]
  unsigned int v193; // [sp+4h] [bp-94h]
  unsigned int v194; // [sp+8h] [bp-90h]
  unsigned int v195; // [sp+Ch] [bp-8Ch]
  unsigned int v196; // [sp+10h] [bp-88h]
  unsigned int v197; // [sp+14h] [bp-84h]
  unsigned int v198; // [sp+18h] [bp-80h]
  unsigned int v199; // [sp+1Ch] [bp-7Ch]
  unsigned int E; // [sp+20h] [bp-78h]
  unsigned int Ea; // [sp+20h] [bp-78h]
  unsigned int Eb; // [sp+20h] [bp-78h]
  unsigned int Ec; // [sp+20h] [bp-78h]
  unsigned int Ed; // [sp+20h] [bp-78h]
  unsigned int Ee; // [sp+20h] [bp-78h]
  unsigned int Ef; // [sp+20h] [bp-78h]
  unsigned int F; // [sp+24h] [bp-74h]
  unsigned int Fa; // [sp+24h] [bp-74h]
  unsigned int Fb; // [sp+24h] [bp-74h]
  unsigned int Fc; // [sp+24h] [bp-74h]
  unsigned int Fd; // [sp+24h] [bp-74h]
  unsigned int Fe; // [sp+24h] [bp-74h]
  unsigned int Ff; // [sp+24h] [bp-74h]
  unsigned int v214; // [sp+28h] [bp-70h]
  unsigned int v215; // [sp+28h] [bp-70h]
  unsigned int v216; // [sp+28h] [bp-70h]
  unsigned int v217; // [sp+28h] [bp-70h]
  unsigned int v218; // [sp+28h] [bp-70h]
  unsigned int v219; // [sp+28h] [bp-70h]
  unsigned int v220; // [sp+2Ch] [bp-6Ch]
  unsigned int v221; // [sp+2Ch] [bp-6Ch]
  unsigned int v222; // [sp+2Ch] [bp-6Ch]
  unsigned int v223; // [sp+2Ch] [bp-6Ch]
  unsigned int v224; // [sp+2Ch] [bp-6Ch]
  unsigned int v225; // [sp+30h] [bp-68h]
  unsigned int v226; // [sp+30h] [bp-68h]
  unsigned int v227; // [sp+30h] [bp-68h]
  unsigned int v228; // [sp+34h] [bp-64h]
  unsigned int v229; // [sp+34h] [bp-64h]
  unsigned int v230; // [sp+34h] [bp-64h]
  int v231; // [sp+34h] [bp-64h]
  int v232; // [sp+34h] [bp-64h]
  unsigned int v233; // [sp+38h] [bp-60h]
  unsigned int v234; // [sp+38h] [bp-60h]
  unsigned int v235; // [sp+38h] [bp-60h]
  int v236; // [sp+38h] [bp-60h]
  unsigned int B; // [sp+3Ch] [bp-5Ch]
  unsigned int Ba; // [sp+3Ch] [bp-5Ch]
  unsigned int Bb; // [sp+3Ch] [bp-5Ch]
  unsigned int Bc; // [sp+3Ch] [bp-5Ch]
  unsigned int v241; // [sp+40h] [bp-58h]
  unsigned int v242; // [sp+40h] [bp-58h]
  unsigned int v243; // [sp+40h] [bp-58h]
  unsigned int v244; // [sp+40h] [bp-58h]
  unsigned int v245; // [sp+44h] [bp-54h]
  unsigned int v246; // [sp+44h] [bp-54h]
  unsigned int v247; // [sp+44h] [bp-54h]
  unsigned int v248; // [sp+44h] [bp-54h]
  unsigned int v249; // [sp+48h] [bp-50h]
  unsigned int v250; // [sp+48h] [bp-50h]
  unsigned int v251; // [sp+48h] [bp-50h]
  unsigned int v252; // [sp+48h] [bp-50h]
  unsigned int v253; // [sp+4Ch] [bp-4Ch]
  unsigned int v254; // [sp+4Ch] [bp-4Ch]
  unsigned int v255; // [sp+4Ch] [bp-4Ch]
  unsigned int v256; // [sp+50h] [bp-48h]
  unsigned int v257; // [sp+50h] [bp-48h]
  unsigned int v258; // [sp+50h] [bp-48h]
  int v259; // [sp+50h] [bp-48h]
  unsigned int v260; // [sp+54h] [bp-44h]
  unsigned int v261; // [sp+54h] [bp-44h]
  unsigned int v262; // [sp+54h] [bp-44h]
  unsigned int v263; // [sp+58h] [bp-40h]
  unsigned int v264; // [sp+58h] [bp-40h]
  unsigned int v265; // [sp+58h] [bp-40h]
  unsigned int v266; // [sp+5Ch] [bp-3Ch]
  unsigned int v267; // [sp+5Ch] [bp-3Ch]
  unsigned int v268; // [sp+5Ch] [bp-3Ch]
  unsigned int v270; // [sp+64h] [bp-34h]
  unsigned int v271; // [sp+64h] [bp-34h]
  unsigned int v272; // [sp+68h] [bp-30h]
  unsigned int v273; // [sp+68h] [bp-30h]
  unsigned int v274; // [sp+6Ch] [bp-2Ch]
  unsigned int v275; // [sp+6Ch] [bp-2Ch]
  unsigned int v276; // [sp+70h] [bp-28h]
  unsigned int v277; // [sp+74h] [bp-24h]

  v195 = ctx->state[4];
  v199 = ctx->state[0];
  v194 = ctx->state[5];
  v193 = ctx->state[6];
  v192 = ctx->state[7];
  v197 = ctx->state[2];
  v198 = ctx->state[1];
  v274 = _byteswap_ulong(*(_DWORD *)data);
  v196 = ctx->state[3];
  v2 = v192
     + 1116352408
     + (__ROR4__(v195, 6) ^ __ROR4__(v195, 11) ^ __ROR4__(v195, 25))
     + ((v193 ^ v194) & v195 ^ v193)
     + v274;
  v3 = ((v198 | v199) & v197 | v199 & v198) + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + v2;
  v228 = _byteswap_ulong(*((_DWORD *)data + 1));
  v4 = v2 + v196;
  v5 = ((v2 + v196) & (v194 ^ v195) ^ v194)
     + v193
     + 1899447441
     + v228
     + (__ROR4__(v2 + v196, 6) ^ __ROR4__(v2 + v196, 11) ^ __ROR4__(v2 + v196, 25));
  F = v5 + v197;
  v214 = ((v3 | v199) & v198 | v3 & v199) + (__ROR4__(v3, 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + v5;
  v233 = _byteswap_ulong(*((_DWORD *)data + 2));
  v6 = (((v2 + v196) ^ v195) & F ^ v195)
     + v194
     - 1245643825
     + v233
     + (__ROR4__(v5 + v197, 6) ^ __ROR4__(v5 + v197, 11) ^ __ROR4__(F, 25));
  B = _byteswap_ulong(*((_DWORD *)data + 3));
  v220 = ((v214 | v3) & v199 | v214 & v3) + (__ROR4__(v214, 2) ^ __ROR4__(v214, 13) ^ __ROR4__(v214, 22)) + v6;
  v7 = v195
     - 373957723
     + B
     + ((F ^ v4) & (v6 + v198) ^ v4)
     + (__ROR4__(v6 + v198, 6) ^ __ROR4__(v6 + v198, 11) ^ __ROR4__(v6 + v198, 25));
  v8 = ((v220 | v214) & v3 | v220 & v214) + (__ROR4__(v220, 2) ^ __ROR4__(v220, 13) ^ __ROR4__(v220, 22)) + v7;
  v241 = _byteswap_ulong(*((_DWORD *)data + 4));
  v9 = v7 + v199;
  v10 = (__ROR4__(v7 + v199, 6) ^ __ROR4__(v7 + v199, 11) ^ __ROR4__(v7 + v199, 25))
      + v241
      + 961987163
      + v4
      + ((v7 + v199) & ((v6 + v198) ^ F) ^ F);
  v11 = v3 + v10;
  E = ((v220 | v8) & v214 | v8 & v220) + (__ROR4__(v8, 2) ^ __ROR4__(v8, 13) ^ __ROR4__(v8, 22)) + v10;
  v245 = _byteswap_ulong(*((_DWORD *)data + 5));
  v12 = (__ROR4__(v11, 6) ^ __ROR4__(v11, 11) ^ __ROR4__(v11, 25))
      + v245
      + 1508970993
      + F
      + (v11 & ((v7 + v199) ^ (v6 + v198)) ^ (v6 + v198));
  v13 = v12 + v214;
  v14 = __ROR4__(v12 + v214, 6) ^ __ROR4__(v12 + v214, 11);
  v215 = ((E | v8) & v220 | E & v8) + (__ROR4__(E, 2) ^ __ROR4__(E, 13) ^ __ROR4__(E, 22)) + v12;
  v249 = _byteswap_ulong(*((_DWORD *)data + 6));
  v15 = v249 - 1841331548 + v6 + v198 + (v13 & (v11 ^ v9) ^ v9) + (v14 ^ __ROR4__(v13, 25));
  v16 = v220;
  v221 = (__ROR4__(v215, 2) ^ __ROR4__(v215, 13) ^ __ROR4__(v215, 22)) + ((v215 | E) & v8 | E & v215) + v15;
  v17 = v15 + v16;
  v270 = _byteswap_ulong(*((_DWORD *)data + 7));
  v18 = v270
      - 1424204075
      + v9
      + (v17 & (v13 ^ v11) ^ v11)
      + (__ROR4__(v15 + v16, 6) ^ __ROR4__(v17, 11) ^ __ROR4__(v17, 25));
  v19 = v18 + v8;
  Fa = (__ROR4__(v221, 2) ^ __ROR4__(v221, 13) ^ __ROR4__(v221, 22)) + ((v221 | v215) & E | v221 & v215) + v18;
  v272 = _byteswap_ulong(*((_DWORD *)data + 8));
  v20 = v272
      - 670586216
      + v11
      + (v19 & ((v15 + v16) ^ v13) ^ v13)
      + (__ROR4__(v19, 6) ^ __ROR4__(v19, 11) ^ __ROR4__(v19, 25));
  v21 = E;
  Ea = (__ROR4__(Fa, 2) ^ __ROR4__(Fa, 13) ^ __ROR4__(Fa, 22)) + ((Fa | v221) & v215 | Fa & v221) + v20;
  v253 = _byteswap_ulong(*((_DWORD *)data + 9));
  v22 = v20 + v21;
  v23 = v253
      + 310598401
      + v13
      + (v22 & (v19 ^ v17) ^ v17)
      + (__ROR4__(v20 + v21, 6) ^ __ROR4__(v22, 11) ^ __ROR4__(v22, 25));
  v24 = v215;
  v216 = (__ROR4__(Ea, 2) ^ __ROR4__(Ea, 13) ^ __ROR4__(Ea, 22)) + ((Ea | Fa) & v221 | Ea & Fa) + v23;
  v256 = _byteswap_ulong(*((_DWORD *)data + 10));
  v25 = v23 + v24;
  v26 = v256
      + 607225278
      + v17
      + (v25 & ((v20 + v21) ^ v19) ^ v19)
      + (__ROR4__(v23 + v24, 6) ^ __ROR4__(v23 + v24, 11) ^ __ROR4__(v25, 25));
  v27 = v26 + v221;
  v260 = _byteswap_ulong(*((_DWORD *)data + 11));
  v28 = v26 + ((v216 | Ea) & Fa | v216 & Ea) + (__ROR4__(v216, 2) ^ __ROR4__(v216, 13) ^ __ROR4__(v216, 22));
  v29 = v19
      + v260
      + 1426881987
      + (v27 & ((v23 + v24) ^ v22) ^ v22)
      + (__ROR4__(v27, 6) ^ __ROR4__(v27, 11) ^ __ROR4__(v27, 25));
  v30 = v29 + Fa;
  v31 = __ROR4__(v29 + Fa, 6);
  v32 = (__ROR4__(v28, 2) ^ __ROR4__(v28, 13) ^ __ROR4__(v28, 22)) + ((v28 | v216) & Ea | v28 & v216) + v29;
  v263 = _byteswap_ulong(*((_DWORD *)data + 12));
  v33 = (v31 ^ __ROR4__(v30, 11) ^ __ROR4__(v30, 25)) + v263 + 1925078388 + v22 + ((v27 ^ v25) & v30 ^ v25);
  v34 = Ea;
  Eb = (__ROR4__(v32, 2) ^ __ROR4__(v32, 13) ^ __ROR4__(v32, 22)) + ((v32 | v28) & v216 | v32 & v28) + v33;
  v35 = v33 + v34;
  v266 = _byteswap_ulong(*((_DWORD *)data + 13));
  v36 = (__ROR4__(v33 + v34, 6) ^ __ROR4__(v35, 11) ^ __ROR4__(v35, 25))
      + ((v30 ^ v27) & v35 ^ v27)
      + v25
      + v266
      - 2132889090;
  Fb = (__ROR4__(Eb, 2) ^ __ROR4__(Eb, 13) ^ __ROR4__(Eb, 22)) + ((Eb | v32) & v28 | Eb & v32) + v36;
  v37 = v36 + v216;
  v38 = __ROR4__(v36 + v216, 6);
  v217 = _byteswap_ulong(*((_DWORD *)data + 14));
  v39 = (v38 ^ __ROR4__(v37, 11) ^ __ROR4__(v37, 25)) + v27 + v217 - 1680079193 + (v37 & ((v33 + v34) ^ v30) ^ v30);
  v40 = v28 + v39;
  v41 = ((Fb | Eb) & v32 | Fb & Eb) + (__ROR4__(Fb, 2) ^ __ROR4__(Fb, 13) ^ __ROR4__(Fb, 22)) + v39;
  v222 = _byteswap_ulong(*((_DWORD *)data + 15));
  v42 = ((v37 ^ v35) & v40 ^ v35) + v222 - 1046744716 + v30 + (__ROR4__(v40, 6) ^ __ROR4__(v40, 11) ^ __ROR4__(v40, 25));
  v43 = v42 + v32;
  v44 = ((v41 | Fb) & Eb | v41 & Fb) + (__ROR4__(v41, 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + v42;
  v225 = (__ROR4__(v228, 7) ^ __ROR4__(v228, 18) ^ (v228 >> 3))
       + (__ROR4__(v217, 17) ^ __ROR4__(v217, 19) ^ (v217 >> 10))
       + v253
       + v274;
  v45 = ((v40 ^ v37) & v43 ^ v37)
      + v225
      - 459576895
      + v33
      + v34
      + (__ROR4__(v43, 6) ^ __ROR4__(v43, 11) ^ __ROR4__(v43, 25));
  v46 = ((v44 | v41) & Fb | v44 & v41) + (__ROR4__(v44, 2) ^ __ROR4__(v44, 13) ^ __ROR4__(v44, 22)) + v45;
  v47 = v45 + Eb;
  v48 = __ROR4__(v45 + Eb, 6) ^ __ROR4__(v45 + Eb, 11) ^ __ROR4__(v45 + Eb, 25);
  Ec = (__ROR4__(v233, 7) ^ __ROR4__(v233, 18) ^ (v233 >> 3))
     + v256
     + v228
     + (__ROR4__(v222, 17) ^ __ROR4__(v222, 19) ^ (v222 >> 10));
  v49 = v37 + Ec - 272742522 + (v47 & (v43 ^ v40) ^ v40) + v48;
  v50 = ((v46 | v44) & v41 | v46 & v44) + (__ROR4__(v46, 2) ^ __ROR4__(v46, 13) ^ __ROR4__(v46, 22)) + v49;
  v51 = v49 + Fb;
  v52 = __ROR4__(v49 + Fb, 6) ^ __ROR4__(v49 + Fb, 11) ^ __ROR4__(v49 + Fb, 25);
  Fc = (__ROR4__(v225, 17) ^ __ROR4__(v225, 19) ^ (v225 >> 10))
     + v233
     + v260
     + (__ROR4__(B, 7) ^ __ROR4__(B, 18) ^ (B >> 3));
  v53 = Fc + 264347078 + v40 + (v51 & (v47 ^ v43) ^ v43) + v52;
  v54 = v53 + v41;
  v55 = ((v50 | v46) & v44 | v50 & v46) + (__ROR4__(v50, 2) ^ __ROR4__(v50, 13) ^ __ROR4__(v50, 22)) + v53;
  v229 = v263
       + B
       + (__ROR4__(v241, 7) ^ __ROR4__(v241, 18) ^ (v241 >> 3))
       + (__ROR4__(Ec, 17) ^ __ROR4__(Ec, 19) ^ (Ec >> 10));
  v56 = v229 + 604807628 + v43 + ((v51 ^ v47) & v54 ^ v47) + (__ROR4__(v54, 6) ^ __ROR4__(v54, 11) ^ __ROR4__(v54, 25));
  v57 = v56 + v44;
  v58 = ((v55 | v50) & v46 | v55 & v50) + (__ROR4__(v55, 2) ^ __ROR4__(v55, 13) ^ __ROR4__(v55, 22)) + v56;
  v234 = (__ROR4__(Fc, 17) ^ __ROR4__(Fc, 19) ^ (Fc >> 10))
       + v266
       + v241
       + (__ROR4__(v245, 7) ^ __ROR4__(v245, 18) ^ (v245 >> 3));
  v59 = (__ROR4__(v57, 6) ^ __ROR4__(v57, 11) ^ __ROR4__(v57, 25)) + (v57 & (v54 ^ v51) ^ v51) + v47 + v234 + 770255983;
  v60 = (__ROR4__(v58, 2) ^ __ROR4__(v58, 13) ^ __ROR4__(v58, 22)) + ((v58 | v55) & v50 | v58 & v55) + v59;
  v61 = v46 + v59;
  Ba = v217
     + v245
     + (__ROR4__(v249, 7) ^ __ROR4__(v249, 18) ^ (v249 >> 3))
     + (__ROR4__(v229, 17) ^ __ROR4__(v229, 19) ^ (v229 >> 10));
  v62 = (v61 & (v57 ^ v54) ^ v54) + Ba + 1249150122 + v51 + (__ROR4__(v61, 6) ^ __ROR4__(v61, 11) ^ __ROR4__(v61, 25));
  v63 = (__ROR4__(v60, 2) ^ __ROR4__(v60, 13) ^ __ROR4__(v60, 22)) + ((v60 | v58) & v55 | v60 & v58) + v62;
  v64 = v62 + v50;
  v242 = (__ROR4__(v234, 17) ^ __ROR4__(v234, 19) ^ (v234 >> 10))
       + (__ROR4__(v270, 7) ^ __ROR4__(v270, 18) ^ (v270 >> 3))
       + v222
       + v249;
  v65 = v242 + 1555081692 + v54 + (v64 & (v61 ^ v57) ^ v57) + (__ROR4__(v64, 6) ^ __ROR4__(v64, 11) ^ __ROR4__(v64, 25));
  v66 = ((v63 | v60) & v58 | v63 & v60) + (__ROR4__(v63, 2) ^ __ROR4__(v63, 13) ^ __ROR4__(v63, 22)) + v65;
  v67 = v55 + v65;
  v246 = (__ROR4__(Ba, 17) ^ __ROR4__(Ba, 19) ^ (Ba >> 10))
       + (__ROR4__(v272, 7) ^ __ROR4__(v272, 18) ^ (v272 >> 3))
       + v270
       + v225;
  v68 = v246 + 1996064986 + v57 + (v67 & (v64 ^ v61) ^ v61) + (__ROR4__(v67, 6) ^ __ROR4__(v67, 11) ^ __ROR4__(v67, 25));
  v69 = ((v66 | v63) & v60 | v66 & v63) + (__ROR4__(v66, 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + v68;
  v70 = v68 + v58;
  v250 = (__ROR4__(v242, 17) ^ __ROR4__(v242, 19) ^ (v242 >> 10))
       + (__ROR4__(v253, 7) ^ __ROR4__(v253, 18) ^ (v253 >> 3))
       + v272
       + Ec;
  v71 = (__ROR4__(v68 + v58, 6) ^ __ROR4__(v68 + v58, 11) ^ __ROR4__(v68 + v58, 25))
      + v61
      + v250
      - 1740746414
      + ((v68 + v58) & (v67 ^ v64) ^ v64);
  v72 = v71 + v60;
  v73 = ((v69 | v66) & v63 | v69 & v66) + (__ROR4__(v69, 2) ^ __ROR4__(v69, 13) ^ __ROR4__(v69, 22)) + v71;
  v254 = (__ROR4__(v246, 17) ^ __ROR4__(v246, 19) ^ (v246 >> 10))
       + (__ROR4__(v256, 7) ^ __ROR4__(v256, 18) ^ (v256 >> 3))
       + v253
       + Fc;
  v74 = (__ROR4__(v72, 6) ^ __ROR4__(v72, 11) ^ __ROR4__(v72, 25)) + ((v70 ^ v67) & v72 ^ v67) + v64 + v254 - 1473132947;
  v75 = v63 + v74;
  v76 = ((v73 | v69) & v66 | v73 & v69) + (__ROR4__(v73, 2) ^ __ROR4__(v73, 13) ^ __ROR4__(v73, 22)) + v74;
  v257 = (__ROR4__(v250, 17) ^ __ROR4__(v250, 19) ^ (v250 >> 10))
       + (__ROR4__(v260, 7) ^ __ROR4__(v260, 18) ^ (v260 >> 3))
       + v256
       + v229;
  v77 = (__ROR4__(v75, 6) ^ __ROR4__(v75, 11) ^ __ROR4__(v75, 25)) + ((v72 ^ v70) & v75 ^ v70) + v67 + v257 - 1341970488;
  v78 = v77 + v66;
  v79 = ((v76 | v73) & v69 | v76 & v73) + (__ROR4__(v76, 2) ^ __ROR4__(v76, 13) ^ __ROR4__(v76, 22)) + v77;
  v261 = (__ROR4__(v254, 17) ^ __ROR4__(v254, 19) ^ (v254 >> 10))
       + (__ROR4__(v263, 7) ^ __ROR4__(v263, 18) ^ (v263 >> 3))
       + v260
       + v234;
  v80 = v70
      + v261
      - 1084653625
      + ((v77 + v66) & (v75 ^ v72) ^ v72)
      + (__ROR4__(v77 + v66, 6) ^ __ROR4__(v77 + v66, 11) ^ __ROR4__(v77 + v66, 25));
  v81 = ((v79 | v76) & v73 | v79 & v76) + (__ROR4__(v79, 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + v80;
  v82 = v80 + v69;
  v264 = (__ROR4__(v257, 17) ^ __ROR4__(v257, 19) ^ (v257 >> 10))
       + (__ROR4__(v266, 7) ^ __ROR4__(v266, 18) ^ (v266 >> 3))
       + v263
       + Ba;
  v83 = v264
      - 958395405
      + v72
      + (v82 & ((v77 + v66) ^ v75) ^ v75)
      + (__ROR4__(v80 + v69, 6) ^ __ROR4__(v80 + v69, 11) ^ __ROR4__(v82, 25));
  v84 = v73 + v83;
  v85 = ((v81 | v79) & v76 | v81 & v79) + (__ROR4__(v81, 2) ^ __ROR4__(v81, 13) ^ __ROR4__(v81, 22)) + v83;
  v267 = (__ROR4__(v261, 17) ^ __ROR4__(v261, 19) ^ (v261 >> 10))
       + (__ROR4__(v217, 7) ^ __ROR4__(v217, 18) ^ (v217 >> 3))
       + v266
       + v242;
  v86 = v267 - 710438585 + v75 + (v84 & (v82 ^ v78) ^ v78) + (__ROR4__(v84, 6) ^ __ROR4__(v84, 11) ^ __ROR4__(v84, 25));
  v87 = ((v85 | v81) & v79 | v85 & v81) + (__ROR4__(v85, 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + v86;
  v88 = v86 + v76;
  v218 = (__ROR4__(v264, 17) ^ __ROR4__(v264, 19) ^ (v264 >> 10))
       + (__ROR4__(v222, 7) ^ __ROR4__(v222, 18) ^ (v222 >> 3))
       + v217
       + v246;
  v89 = ((v86 + v76) & (v84 ^ v82) ^ v82)
      + v78
      + v218
      + 113926993
      + (__ROR4__(v86 + v76, 6) ^ __ROR4__(v86 + v76, 11) ^ __ROR4__(v86 + v76, 25));
  v90 = ((v87 | v85) & v81 | v87 & v85) + (__ROR4__(v87, 2) ^ __ROR4__(v87, 13) ^ __ROR4__(v87, 22)) + v89;
  v91 = v89 + v79;
  v223 = (__ROR4__(v267, 17) ^ __ROR4__(v267, 19) ^ (v267 >> 10))
       + (__ROR4__(v225, 7) ^ __ROR4__(v225, 18) ^ (v225 >> 3))
       + v222
       + v250;
  v92 = v82
      + v223
      + 338241895
      + (v91 & (v88 ^ v84) ^ v84)
      + (__ROR4__(v89 + v79, 6) ^ __ROR4__(v91, 11) ^ __ROR4__(v91, 25));
  v93 = ((v90 | v87) & v85 | v90 & v87) + (__ROR4__(v90, 2) ^ __ROR4__(v90, 13) ^ __ROR4__(v90, 22)) + v92;
  v94 = v92 + v81;
  v226 = (__ROR4__(Ec, 7) ^ __ROR4__(Ec, 18) ^ (Ec >> 3))
       + v225
       + v254
       + (__ROR4__(v218, 17) ^ __ROR4__(v218, 19) ^ (v218 >> 10));
  v95 = (__ROR4__(v92 + v81, 6) ^ __ROR4__(v92 + v81, 11) ^ __ROR4__(v92 + v81, 25))
      + ((v92 + v81) & (v91 ^ v88) ^ v88)
      + v84
      + v226
      + 666307205;
  v96 = v85 + v95;
  v97 = ((v93 | v90) & v87 | v93 & v90) + (__ROR4__(v93, 2) ^ __ROR4__(v93, 13) ^ __ROR4__(v93, 22)) + v95;
  Ed = (__ROR4__(Fc, 7) ^ __ROR4__(Fc, 18) ^ (Fc >> 3))
     + Ec
     + v257
     + (__ROR4__(v223, 17) ^ __ROR4__(v223, 19) ^ (v223 >> 10));
  v98 = (__ROR4__(v96, 6) ^ __ROR4__(v96, 11) ^ __ROR4__(v96, 25)) + ((v94 ^ v91) & v96 ^ v91) + v88 + Ed + 773529912;
  v99 = v87 + v98;
  v100 = ((v97 | v93) & v90 | v97 & v93) + (__ROR4__(v97, 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + v98;
  Fd = (__ROR4__(v229, 7) ^ __ROR4__(v229, 18) ^ (v229 >> 3))
     + Fc
     + v261
     + (__ROR4__(v226, 17) ^ __ROR4__(v226, 19) ^ (v226 >> 10));
  v101 = (__ROR4__(v99, 6) ^ __ROR4__(v99, 11) ^ __ROR4__(v99, 25)) + ((v96 ^ v94) & v99 ^ v94) + v91 + Fd + 1294757372;
  v102 = v90 + v101;
  v103 = ((v100 | v97) & v93 | v100 & v97) + (__ROR4__(v100, 2) ^ __ROR4__(v100, 13) ^ __ROR4__(v100, 22)) + v101;
  v230 = (__ROR4__(Ed, 17) ^ __ROR4__(Ed, 19) ^ (Ed >> 10))
       + (__ROR4__(v234, 7) ^ __ROR4__(v234, 18) ^ (v234 >> 3))
       + v229
       + v264;
  v104 = (__ROR4__(v102, 6) ^ __ROR4__(v102, 11) ^ __ROR4__(v102, 25))
       + ((v99 ^ v96) & v102 ^ v96)
       + v94
       + v230
       + 1396182291;
  v105 = v93 + v104;
  v106 = ((v103 | v100) & v97 | v103 & v100) + (__ROR4__(v103, 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + v104;
  v235 = (__ROR4__(Fd, 17) ^ __ROR4__(Fd, 19) ^ (Fd >> 10))
       + (__ROR4__(Ba, 7) ^ __ROR4__(Ba, 18) ^ (Ba >> 3))
       + v234
       + v267;
  v107 = (__ROR4__(v105, 6) ^ __ROR4__(v105, 11) ^ __ROR4__(v105, 25))
       + v96
       + v235
       + 1695183700
       + (v105 & (v102 ^ v99) ^ v99);
  v108 = v97 + v107;
  v109 = ((v106 | v103) & v100 | v106 & v103) + (__ROR4__(v106, 2) ^ __ROR4__(v106, 13) ^ __ROR4__(v106, 22)) + v107;
  Bb = (__ROR4__(v230, 17) ^ __ROR4__(v230, 19) ^ (v230 >> 10))
     + (__ROR4__(v242, 7) ^ __ROR4__(v242, 18) ^ (v242 >> 3))
     + Ba
     + v218;
  v110 = (__ROR4__(v108, 6) ^ __ROR4__(v108, 11) ^ __ROR4__(v108, 25))
       + v99
       + Bb
       + 1986661051
       + (v108 & (v105 ^ v102) ^ v102);
  v111 = v100 + v110;
  v112 = ((v109 | v106) & v103 | v109 & v106) + (__ROR4__(v109, 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + v110;
  v243 = (__ROR4__(v235, 17) ^ __ROR4__(v235, 19) ^ (v235 >> 10))
       + (__ROR4__(v246, 7) ^ __ROR4__(v246, 18) ^ (v246 >> 3))
       + v242
       + v223;
  v113 = (__ROR4__(v111, 6) ^ __ROR4__(v111, 11) ^ __ROR4__(v111, 25))
       + v102
       + v243
       - 2117940946
       + (v111 & (v108 ^ v105) ^ v105);
  v114 = v103 + v113;
  v115 = ((v112 | v109) & v106 | v112 & v109) + (__ROR4__(v112, 2) ^ __ROR4__(v112, 13) ^ __ROR4__(v112, 22)) + v113;
  v247 = (__ROR4__(Bb, 17) ^ __ROR4__(Bb, 19) ^ (Bb >> 10))
       + (__ROR4__(v250, 7) ^ __ROR4__(v250, 18) ^ (v250 >> 3))
       + v246
       + v226;
  v116 = (__ROR4__(v114, 6) ^ __ROR4__(v114, 11) ^ __ROR4__(v114, 25))
       + v105
       + v247
       - 1838011259
       + (v114 & (v111 ^ v108) ^ v108);
  v117 = v106 + v116;
  v118 = ((v115 | v112) & v109 | v115 & v112) + (__ROR4__(v115, 2) ^ __ROR4__(v115, 13) ^ __ROR4__(v115, 22)) + v116;
  v251 = (__ROR4__(v243, 17) ^ __ROR4__(v243, 19) ^ (v243 >> 10))
       + (__ROR4__(v254, 7) ^ __ROR4__(v254, 18) ^ (v254 >> 3))
       + v250
       + Ed;
  v119 = (__ROR4__(v117, 6) ^ __ROR4__(v117, 11) ^ __ROR4__(v117, 25))
       + v108
       + v251
       - 1564481375
       + ((v114 ^ v111) & v117 ^ v111);
  v120 = ((v118 | v115) & v112 | v118 & v115) + (__ROR4__(v118, 2) ^ __ROR4__(v118, 13) ^ __ROR4__(v118, 22)) + v119;
  v121 = v109 + v119;
  v255 = (__ROR4__(v247, 17) ^ __ROR4__(v247, 19) ^ (v247 >> 10))
       + (__ROR4__(v257, 7) ^ __ROR4__(v257, 18) ^ (v257 >> 3))
       + v254
       + Fd;
  v122 = v111
       + v255
       - 1474664885
       + (v121 & (v117 ^ v114) ^ v114)
       + (__ROR4__(v121, 6) ^ __ROR4__(v121, 11) ^ __ROR4__(v121, 25));
  v123 = v122 + v112;
  v124 = ((v120 | v118) & v115 | v120 & v118) + (__ROR4__(v120, 2) ^ __ROR4__(v120, 13) ^ __ROR4__(v120, 22)) + v122;
  v258 = (__ROR4__(v251, 17) ^ __ROR4__(v251, 19) ^ (v251 >> 10))
       + (__ROR4__(v261, 7) ^ __ROR4__(v261, 18) ^ (v261 >> 3))
       + v257
       + v230;
  v125 = (__ROR4__(v123, 6) ^ __ROR4__(v123, 11) ^ __ROR4__(v123, 25))
       + v114
       + v258
       - 1035236496
       + (v123 & (v121 ^ v117) ^ v117);
  v126 = v115 + v125;
  v127 = ((v124 | v120) & v118 | v124 & v120) + (__ROR4__(v124, 2) ^ __ROR4__(v124, 13) ^ __ROR4__(v124, 22)) + v125;
  v262 = (__ROR4__(v255, 17) ^ __ROR4__(v255, 19) ^ (v255 >> 10))
       + (__ROR4__(v264, 7) ^ __ROR4__(v264, 18) ^ (v264 >> 3))
       + v261
       + v235;
  v128 = (__ROR4__(v126, 6) ^ __ROR4__(v126, 11) ^ __ROR4__(v126, 25))
       + v262
       - 949202525
       + v117
       + ((v123 ^ v121) & v126 ^ v121);
  v129 = v118 + v128;
  v130 = ((v127 | v124) & v120 | v127 & v124) + (__ROR4__(v127, 2) ^ __ROR4__(v127, 13) ^ __ROR4__(v127, 22)) + v128;
  v265 = (__ROR4__(v258, 17) ^ __ROR4__(v258, 19) ^ (v258 >> 10))
       + (__ROR4__(v267, 7) ^ __ROR4__(v267, 18) ^ (v267 >> 3))
       + v264
       + Bb;
  v131 = (__ROR4__(v129, 6) ^ __ROR4__(v129, 11) ^ __ROR4__(v129, 25))
       + v265
       - 778901479
       + v121
       + (v129 & (v126 ^ v123) ^ v123);
  v132 = v120 + v131;
  v133 = ((v130 | v127) & v124 | v130 & v127) + (__ROR4__(v130, 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22)) + v131;
  v268 = (__ROR4__(v262, 17) ^ __ROR4__(v262, 19) ^ (v262 >> 10))
       + (__ROR4__(v218, 7) ^ __ROR4__(v218, 18) ^ (v218 >> 3))
       + v267
       + v243;
  v134 = (__ROR4__(v132, 6) ^ __ROR4__(v132, 11) ^ __ROR4__(v132, 25))
       + v123
       + v268
       - 694614492
       + (v132 & (v129 ^ v126) ^ v126);
  v135 = v124 + v134;
  v136 = ((v133 | v130) & v127 | v133 & v130) + (__ROR4__(v133, 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + v134;
  v219 = (__ROR4__(v265, 17) ^ __ROR4__(v265, 19) ^ (v265 >> 10))
       + (__ROR4__(v223, 7) ^ __ROR4__(v223, 18) ^ (v223 >> 3))
       + v218
       + v247;
  v137 = (__ROR4__(v135, 6) ^ __ROR4__(v135, 11) ^ __ROR4__(v135, 25))
       + v126
       + v219
       - 200395387
       + (v135 & (v132 ^ v129) ^ v129);
  v138 = v127 + v137;
  v139 = ((v136 | v133) & v130 | v136 & v133) + (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + v137;
  v224 = (__ROR4__(v268, 17) ^ __ROR4__(v268, 19) ^ (v268 >> 10))
       + (__ROR4__(v226, 7) ^ __ROR4__(v226, 18) ^ (v226 >> 3))
       + v223
       + v251;
  v140 = (__ROR4__(v138, 6) ^ __ROR4__(v138, 11) ^ __ROR4__(v138, 25))
       + v129
       + v224
       + 275423344
       + (v138 & (v135 ^ v132) ^ v132);
  v141 = v130 + v140;
  v142 = ((v139 | v136) & v133 | v139 & v136) + (__ROR4__(v139, 2) ^ __ROR4__(v139, 13) ^ __ROR4__(v139, 22)) + v140;
  v227 = (__ROR4__(v219, 17) ^ __ROR4__(v219, 19) ^ (v219 >> 10))
       + (__ROR4__(Ed, 7) ^ __ROR4__(Ed, 18) ^ (Ed >> 3))
       + v226
       + v255;
  v143 = (__ROR4__(v141, 6) ^ __ROR4__(v141, 11) ^ __ROR4__(v141, 25))
       + v227
       + 430227734
       + v132
       + ((v138 ^ v135) & v141 ^ v135);
  v144 = v133 + v143;
  v145 = ((v142 | v139) & v136 | v142 & v139) + (__ROR4__(v142, 2) ^ __ROR4__(v142, 13) ^ __ROR4__(v142, 22)) + v143;
  v271 = (__ROR4__(v224, 17) ^ __ROR4__(v224, 19) ^ (v224 >> 10))
       + (__ROR4__(Fd, 7) ^ __ROR4__(Fd, 18) ^ (Fd >> 3))
       + Ed
       + v258;
  v146 = (__ROR4__(v144, 6) ^ __ROR4__(v144, 11) ^ __ROR4__(v144, 25))
       + v135
       + v271
       + 506948616
       + (v144 & (v141 ^ v138) ^ v138);
  v147 = v136 + v146;
  v148 = ((v145 | v142) & v139 | v145 & v142) + (__ROR4__(v145, 2) ^ __ROR4__(v145, 13) ^ __ROR4__(v145, 22)) + v146;
  Fe = (__ROR4__(v227, 17) ^ __ROR4__(v227, 19) ^ (v227 >> 10))
     + (__ROR4__(v230, 7) ^ __ROR4__(v230, 18) ^ (v230 >> 3))
     + Fd
     + v262;
  v149 = (__ROR4__(v147, 6) ^ __ROR4__(v147, 11) ^ __ROR4__(v147, 25))
       + v138
       + Fe
       + 659060556
       + (v147 & (v144 ^ v141) ^ v141);
  v150 = v139 + v149;
  v151 = ((v148 | v145) & v142 | v148 & v145) + (__ROR4__(v148, 2) ^ __ROR4__(v148, 13) ^ __ROR4__(v148, 22)) + v149;
  v273 = (__ROR4__(v271, 17) ^ __ROR4__(v271, 19) ^ (v271 >> 10))
       + (__ROR4__(v235, 7) ^ __ROR4__(v235, 18) ^ (v235 >> 3))
       + v230
       + v265;
  v152 = (__ROR4__(v150, 6) ^ __ROR4__(v150, 11) ^ __ROR4__(v150, 25))
       + (v150 & (v147 ^ v144) ^ v144)
       + v141
       + v273
       + 883997877;
  v153 = v152 + v142;
  v154 = ((v151 | v148) & v145 | v151 & v148) + (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + v152;
  v275 = (__ROR4__(Fe, 17) ^ __ROR4__(Fe, 19) ^ (Fe >> 10))
       + (__ROR4__(Bb, 7) ^ __ROR4__(Bb, 18) ^ (Bb >> 3))
       + v235
       + v268;
  v155 = v144
       + v275
       + 958139571
       + (v153 & (v150 ^ v147) ^ v147)
       + (__ROR4__(v152 + v142, 6) ^ __ROR4__(v153, 11) ^ __ROR4__(v153, 25));
  v156 = v155 + v145;
  v157 = ((v154 | v151) & v148 | v154 & v151) + (__ROR4__(v154, 2) ^ __ROR4__(v154, 13) ^ __ROR4__(v154, 22)) + v155;
  v276 = (__ROR4__(v273, 17) ^ __ROR4__(v273, 19) ^ (v273 >> 10))
       + (__ROR4__(v243, 7) ^ __ROR4__(v243, 18) ^ (v243 >> 3))
       + Bb
       + v219;
  v158 = (__ROR4__(v156, 6) ^ __ROR4__(v156, 11) ^ __ROR4__(v156, 25))
       + v147
       + v276
       + 1322822218
       + (v156 & ((v152 + v142) ^ v150) ^ v150);
  v159 = v148 + v158;
  v160 = ((v157 | v154) & v151 | v157 & v154) + (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + v158;
  v277 = (__ROR4__(v247, 7) ^ __ROR4__(v247, 18) ^ (v247 >> 3))
       + v243
       + v224
       + (__ROR4__(v275, 17) ^ __ROR4__(v275, 19) ^ (v275 >> 10));
  v161 = (__ROR4__(v159, 6) ^ __ROR4__(v159, 11) ^ __ROR4__(v159, 25))
       + v277
       + 1537002063
       + v150
       + ((v156 ^ v153) & v159 ^ v153);
  v162 = v151 + v161;
  v163 = ((v160 | v157) & v154 | v160 & v157) + (__ROR4__(v160, 2) ^ __ROR4__(v160, 13) ^ __ROR4__(v160, 22)) + v161;
  v248 = (__ROR4__(v276, 17) ^ __ROR4__(v276, 19) ^ (v276 >> 10))
       + (__ROR4__(v251, 7) ^ __ROR4__(v251, 18) ^ (v251 >> 3))
       + v247
       + v227;
  v164 = (__ROR4__(v162, 6) ^ __ROR4__(v162, 11) ^ __ROR4__(v162, 25))
       + v153
       + v248
       + 1747873779
       + (v162 & (v159 ^ v156) ^ v156);
  v165 = v154 + v164;
  Ee = (__ROR4__(v163, 2) ^ __ROR4__(v163, 13) ^ __ROR4__(v163, 22)) + ((v163 | v160) & v157 | v163 & v160) + v164;
  v252 = (__ROR4__(v277, 17) ^ __ROR4__(v277, 19) ^ (v277 >> 10))
       + (__ROR4__(v255, 7) ^ __ROR4__(v255, 18) ^ (v255 >> 3))
       + v251
       + v271;
  v166 = v156
       + v252
       + 1955562222
       + (v165 & (v162 ^ v159) ^ v159)
       + (__ROR4__(v165, 6) ^ __ROR4__(v165, 11) ^ __ROR4__(v165, 25));
  v231 = v166 + v157;
  v167 = ((Ee | v163) & v160 | Ee & v163) + (__ROR4__(Ee, 2) ^ __ROR4__(Ee, 13) ^ __ROR4__(Ee, 22)) + v166;
  v168 = (__ROR4__(v258, 7) ^ __ROR4__(v258, 18) ^ (v258 >> 3))
       + v255
       + Fe
       + (__ROR4__(v248, 17) ^ __ROR4__(v248, 19) ^ (v248 >> 10));
  v169 = v159
       + v168
       + 2024104815
       + (v231 & (v165 ^ v162) ^ v162)
       + (__ROR4__(v231, 6) ^ __ROR4__(v231, 11) ^ __ROR4__(v231, 25));
  v236 = v169 + v160;
  v170 = ((v167 | Ee) & v163 | v167 & Ee) + (__ROR4__(v167, 2) ^ __ROR4__(v167, 13) ^ __ROR4__(v167, 22)) + v169;
  v171 = (__ROR4__(v262, 7) ^ __ROR4__(v262, 18) ^ (v262 >> 3))
       + v258
       + v273
       + (__ROR4__(v252, 17) ^ __ROR4__(v252, 19) ^ (v252 >> 10));
  v172 = v162
       + v171
       - 2067236844
       + ((v169 + v160) & (v231 ^ v165) ^ v165)
       + (__ROR4__(v169 + v160, 6) ^ __ROR4__(v169 + v160, 11) ^ __ROR4__(v169 + v160, 25));
  Bc = v172 + v163;
  Ff = ((v170 | v167) & Ee | v170 & v167) + (__ROR4__(v170, 2) ^ __ROR4__(v170, 13) ^ __ROR4__(v170, 22)) + v172;
  v173 = (__ROR4__(v265, 7) ^ __ROR4__(v265, 18) ^ (v265 >> 3))
       + v262
       + v275
       + (__ROR4__(v168, 17) ^ __ROR4__(v168, 19) ^ (v168 >> 10));
  v174 = ((v172 + v163) & ((v169 + v160) ^ v231) ^ v231)
       + v173
       - 1933114872
       + v165
       + (__ROR4__(v172 + v163, 6) ^ __ROR4__(v172 + v163, 11) ^ __ROR4__(v172 + v163, 25));
  v175 = Ee;
  Ef = (Ff & v170 | (Ff | v170) & v167) + (__ROR4__(Ff, 2) ^ __ROR4__(Ff, 13) ^ __ROR4__(Ff, 22)) + v174;
  v244 = v175 + v174;
  v176 = (__ROR4__(v268, 7) ^ __ROR4__(v268, 18) ^ (v268 >> 3))
       + v265
       + v276
       + (__ROR4__(v171, 17) ^ __ROR4__(v171, 19) ^ (v171 >> 10));
  v259 = __ROR4__(v173, 17) ^ __ROR4__(v173, 19) ^ (v173 >> 10);
  v177 = __ROR4__(v175 + v174, 6) ^ __ROR4__(v175 + v174, 11);
  v178 = v176 - 1866530822 + v231;
  v232 = __ROR4__(v176, 17) ^ __ROR4__(v176, 19) ^ (v176 >> 10);
  v179 = v178 + (v244 & (Bc ^ v236) ^ v236) + (v177 ^ __ROR4__(v244, 25));
  v180 = ((Ef | Ff) & v170 | Ef & Ff) + (__ROR4__(Ef, 2) ^ __ROR4__(Ef, 13) ^ __ROR4__(Ef, 22)) + v179;
  v181 = v179 + v167;
  v182 = (__ROR4__(v219, 7) ^ __ROR4__(v219, 18) ^ (v219 >> 3)) + v268 + v277 + v259;
  v183 = (__ROR4__(v179 + v167, 6) ^ __ROR4__(v181, 11) ^ __ROR4__(v181, 25))
       + (v181 & (v244 ^ Bc) ^ Bc)
       + v182
       - 1538233109
       + v236;
  v184 = (v180 & Ef | (v180 | Ef) & Ff) + (__ROR4__(v180, 2) ^ __ROR4__(v180, 13) ^ __ROR4__(v180, 22)) + v183;
  v185 = v183 + v170;
  v186 = (((v179 + v167) ^ v244) & v185 ^ v244)
       + v219
       - 1090935817
       + (__ROR4__(v224, 7) ^ __ROR4__(v224, 18) ^ (v224 >> 3))
       + v248
       + v232
       + Bc
       + (__ROR4__(v185, 6) ^ __ROR4__(v185, 11) ^ __ROR4__(v185, 25));
  v187 = ((v184 | v180) & Ef | v184 & v180) + (__ROR4__(v184, 2) ^ __ROR4__(v184, 13) ^ __ROR4__(v184, 22)) + v186;
  v188 = v186 + Ff;
  v189 = (v188 & (v185 ^ v181) ^ v181)
       + (__ROR4__(v182, 17) ^ __ROR4__(v182, 19) ^ (v182 >> 10))
       + v224
       - 965641998
       + (__ROR4__(v227, 7) ^ __ROR4__(v227, 18) ^ (v227 >> 3))
       + v252
       + v244
       + (__ROR4__(v188, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25));
  v190 = ctx->state[6];
  v191 = ctx->state[2];
  ctx->state[3] = v180 + v196;
  ctx->state[0] = ((v187 | v184) & v180 | v187 & v184)
                + (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22))
                + v199
                + v189;
  ctx->state[4] = Ef + v195 + v189;
  ctx->state[1] = v187 + v198;
  ctx->state[5] = v188 + v194;
  ctx->state[2] = v184 + v191;
  ctx->state[6] = v185 + v190;
  ctx->state[7] = v181 + v192;
}

//----- (0000F330) --------------------------------------------------------
void __fastcall sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  int v3; // r7
  const unsigned __int8 *v5; // r8
  unsigned int v6; // r9
  unsigned int v7; // r3
  bool v8; // cc
  int v9; // r4
  _BOOL4 v10; // r3
  int v11; // r5
  const unsigned __int8 *v12; // r4
  const unsigned __int8 *v13; // r1
  unsigned int v14; // r7
  int v15; // r2

  v3 = ilen;
  v5 = input;
  if ( ilen > 0 )
  {
    v6 = ctx->total[0] & 0x3F;
    v7 = ilen + ctx->total[0];
    v8 = ilen > v7;
    ctx->total[0] = v7;
    if ( ilen > v7 )
      v7 = ctx->total[1];
    v9 = 64 - v6;
    if ( v8 )
      ctx->total[1] = v7 + 1;
    v10 = ilen >= v9;
    if ( !v6 )
      v10 = 0;
    if ( v10 )
    {
      v3 = ilen - v9;
      memcpy(&ctx->buffer[v6], input, 64 - v6);
      v5 += v9;
      v6 = 0;
      sha2_process(ctx, ctx->buffer);
    }
    if ( v3 > 63 )
    {
      v11 = v3;
      v12 = v5;
      do
      {
        v13 = v12;
        v11 -= 64;
        v12 += 64;
        sha2_process(ctx, v13);
      }
      while ( v11 > 63 );
      v14 = v3 - 64;
      v15 = (v14 >> 6) + 1;
      v3 = v14 - (v14 >> 6 << 6);
      v5 += 64 * v15;
    }
    if ( v3 > 0 )
      j_memcpy(&ctx->buffer[v6], v5, v3);
  }
}

//----- (0000F3C8) --------------------------------------------------------
void __fastcall sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  unsigned int v4; // r2
  unsigned int v5; // r3
  int v6; // r1
  int v7; // r2
  unsigned __int8 msglen[8]; // [sp+0h] [bp-20h] BYREF

  v4 = ctx->total[0] & 0x3F;
  v5 = 8 * ctx->total[0];
  v6 = *(__int64 *)ctx->total >> 29;
  msglen[3] = *(__int64 *)ctx->total >> 29;
  msglen[6] = BYTE1(v5);
  if ( v4 > 0x37 )
    v7 = 120 - v4;
  else
    v7 = 56 - v4;
  msglen[7] = v5;
  msglen[1] = BYTE2(v6);
  msglen[2] = BYTE1(v6);
  msglen[0] = HIBYTE(v6);
  msglen[4] = HIBYTE(v5);
  msglen[5] = BYTE2(v5);
  sha2_update(ctx, sha2_padding, v7);
  sha2_update(ctx, msglen, 8);
  *output = HIBYTE(ctx->state[0]);
  output[1] = HIWORD(ctx->state[0]);
  output[2] = BYTE1(ctx->state[0]);
  output[3] = ctx->state[0];
  output[4] = HIBYTE(ctx->state[1]);
  output[5] = HIWORD(ctx->state[1]);
  output[6] = BYTE1(ctx->state[1]);
  output[7] = ctx->state[1];
  output[8] = HIBYTE(ctx->state[2]);
  output[9] = HIWORD(ctx->state[2]);
  output[10] = BYTE1(ctx->state[2]);
  output[11] = ctx->state[2];
  output[12] = HIBYTE(ctx->state[3]);
  output[13] = HIWORD(ctx->state[3]);
  output[14] = BYTE1(ctx->state[3]);
  output[15] = ctx->state[3];
  output[16] = HIBYTE(ctx->state[4]);
  output[17] = HIWORD(ctx->state[4]);
  output[18] = BYTE1(ctx->state[4]);
  output[19] = ctx->state[4];
  output[20] = HIBYTE(ctx->state[5]);
  output[21] = HIWORD(ctx->state[5]);
  output[22] = BYTE1(ctx->state[5]);
  output[23] = ctx->state[5];
  output[24] = HIBYTE(ctx->state[6]);
  output[25] = HIWORD(ctx->state[6]);
  output[26] = BYTE1(ctx->state[6]);
  output[27] = ctx->state[6];
  output[28] = HIBYTE(ctx->state[7]);
  output[29] = HIWORD(ctx->state[7]);
  output[30] = BYTE1(ctx->state[7]);
  output[31] = ctx->state[7];
}

//----- (0000F4D0) --------------------------------------------------------
void __fastcall sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  sha2_context ctx; // [sp+0h] [bp-108h] BYREF

  ctx.state[2] = 1013904242;
  ctx.state[3] = -1521486534;
  ctx.state[7] = 1541459225;
  ctx.state[0] = 1779033703;
  ctx.state[1] = -1150833019;
  ctx.state[4] = 1359893119;
  ctx.state[5] = -1694144372;
  ctx.state[6] = 528734635;
  ctx.total[0] = 0;
  ctx.total[1] = 0;
  sha2_update(&ctx, input, ilen);
  sha2_finish(&ctx, output);
  memset(&ctx, 0, sizeof(ctx));
}

//----- (0000F55C) --------------------------------------------------------
unsigned int __fastcall crc16(const unsigned __int8 *buffer, int len)
{
  const unsigned __int8 *v2; // r4
  unsigned int v3; // r3
  int v4; // t1

  if ( len <= 0 )
    return 0;
  v2 = &buffer[len];
  v3 = 0;
  do
  {
    v4 = *buffer++;
    v3 = LOWORD(crc16_table[v4 ^ (v3 >> 8)]) ^ (unsigned __int16)((_WORD)v3 << 8);
  }
  while ( buffer != v2 );
  return v3;
}

//----- (0000F590) --------------------------------------------------------
void __fastcall applog(int prio, const unsigned __int8 *str, bool force)
{
  _BOOL4 v5; // r8
  int v6; // r9
  struct tm *v7; // r0
  int v8; // r0
  FILE *v9; // r7
  size_t v10; // r0
  size_t v11; // r0
  time_t timer; // [sp+1Ch] [bp-6Ch] BYREF
  timeval tv; // [sp+20h] [bp-68h] BYREF
  char s[96]; // [sp+28h] [bp-60h] BYREF

  v5 = force;
  if ( use_syslog )
  {
    syslog(prio | 0x80, "%s", (const char *)str);
    return;
  }
  tv.tv_sec = use_syslog;
  tv.tv_usec = use_syslog;
  cgtime(&tv);
  timer = tv.tv_sec;
  v6 = tv.tv_usec / 1000;
  v7 = localtime(&timer);
  snprintf(
    s,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
    v7->tm_year + 1900,
    v7->tm_mon + 1,
    v7->tm_mday,
    v7->tm_hour,
    v7->tm_min,
    v7->tm_sec,
    v6);
  v8 = fileno((FILE *)stderr);
  if ( isatty(v8) )
  {
    if ( g_logfile_enable )
    {
LABEL_4:
      v9 = g_log_file;
      if ( g_log_file
        || (v9 = fopen((const char *)g_logfile_path, (const char *)g_logfile_openflag), (g_log_file = v9) != 0) )
      {
        v10 = strlen(s);
        fwrite(s, v10, 1u, v9);
        v11 = strlen((const char *)str);
        fwrite(str, v11, 1u, g_log_file);
        fwrite(ptr, 1u, 1u, g_log_file);
        fflush(g_log_file);
      }
    }
  }
  else
  {
    fprintf((FILE *)stderr, "%s%s\n", s, (const char *)str);
    fflush((FILE *)stderr);
    if ( g_logfile_enable )
      goto LABEL_4;
  }
  if ( !opt_quiet || prio == 3 )
    my_log_curses((int)s, str, (const unsigned __int8 *)v5, opt_quiet);
}
// 62990: using guessed type int stderr;

//----- (0000F6D4) --------------------------------------------------------
void __fastcall mutex_unlock_noyield(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  if ( pthread_mutex_unlock(&console_lock) )
  {
    v5 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v5,
      "logging.c",
      (const char *)_func___9900,
      lock);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000F72C) --------------------------------------------------------
void __fastcall mutex_lock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-808h] BYREF

  if ( pthread_mutex_lock(&console_lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      "logging.c",
      (const char *)_func___9900,
      49);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0000F784) --------------------------------------------------------
void __fastcall my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force)
{
  const char *v4; // r6
  const unsigned __int8 *v6; // r1
  const unsigned __int8 *v7; // r2
  int v8; // r3
  const unsigned __int8 *v9; // r1
  const unsigned __int8 *v10; // r2
  int v11; // r3

  v4 = (const char *)prio;
  if ( str )
  {
    pthread_mutex_trylock(&console_lock);
    mutex_unlock_noyield((pthread_mutex_t *)0x26, v9, v10, v11);
    prio = selective_yield();
  }
  mutex_lock((pthread_mutex_t *)prio, datetime, str, force);
  printf("%s%s%s", v4, (const char *)datetime, "                    \n");
  mutex_unlock_noyield((pthread_mutex_t *)0x33, v6, v7, v8);
  selective_yield();
}
// F7B2: variable 'v9' is possibly undefined
// F7B2: variable 'v10' is possibly undefined
// F7B2: variable 'v11' is possibly undefined
// F78E: variable 'datetime' is possibly undefined
// F78E: variable 'str' is possibly undefined
// F78E: variable 'force' is possibly undefined
// F7A0: variable 'v6' is possibly undefined
// F7A0: variable 'v7' is possibly undefined
// F7A0: variable 'v8' is possibly undefined

//----- (0000F7CC) --------------------------------------------------------
void __fastcall simplelog(int prio, const unsigned __int8 *str, bool force)
{
  _BOOL4 v5; // r7
  int v6; // r0
  bool v7; // [sp+0h] [bp-18h]

  v5 = force;
  if ( !use_syslog )
  {
    v6 = fileno((FILE *)stderr);
    if ( isatty(v6) )
    {
      if ( opt_quiet )
        goto LABEL_4;
    }
    else
    {
      fprintf((FILE *)stderr, "%s\n", (const char *)str);
      fflush((FILE *)stderr);
      if ( opt_quiet )
      {
LABEL_4:
        if ( prio != 3 )
          return;
      }
    }
    my_log_curses((int)"", str, (const unsigned __int8 *)v5, v7);
    return;
  }
  sub_A054(prio | 0x80, "%s", (const char *)str);
}
// F800: variable 'v7' is possibly undefined
// 62990: using guessed type int stderr;

//----- (0000F848) --------------------------------------------------------
void __fastcall k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int limit; // r3
  int total; // r2
  int allocate; // r8
  void **item_memory; // r0
  int v9; // r1
  void **v10; // r0
  k_item *v11; // r0
  k_item *v12; // r5
  int v13; // r7
  int v14; // r3
  int v15; // r2
  const unsigned __int8 *name; // r6
  int v17; // r3
  _BOOL4 do_tail; // r2
  k_item *v19; // r3
  int data_mem_count; // r1
  int v21; // r1
  void **data_memory; // r0
  void **v23; // r0
  void *v24; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  if ( list->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9328,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9328,
      19);
    applog(3, tmp42, 1);
    quit(1);
  }
  limit = list->limit;
  if ( limit <= 0 )
  {
    allocate = list->allocate;
  }
  else
  {
    total = list->total;
    if ( limit <= total )
      return;
    allocate = list->allocate;
    if ( limit < total + allocate )
      allocate = limit - total;
  }
  item_memory = list->item_memory;
  v9 = list->item_mem_count + 1;
  list->item_mem_count = v9;
  v10 = (void **)realloc(item_memory, 4 * v9);
  list->item_memory = v10;
  if ( !v10 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      (const char *)list->name,
      list->item_mem_count,
      "klist.c",
      (const char *)_func___9328,
      33);
    applog(3, tmp42, 1);
    quit(1);
  }
  v11 = (k_item *)calloc(allocate, 0x10u);
  v12 = v11;
  if ( !v11 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      (const char *)list->name,
      allocate,
      list->total,
      list->limit,
      "klist.c",
      (const char *)_func___9328,
      38);
    applog(3, tmp42, 1);
    quit(1);
  }
  v13 = allocate - 1;
  v14 = list->total;
  v15 = 0;
  list->item_memory[list->item_mem_count - 1] = v11;
  name = list->name;
  v17 = v14 + allocate;
  list->total = v17;
  if ( allocate - 1 > 1 )
    v17 = (int)&v11[2];
  list->count = allocate;
  list->count_up = allocate;
  v11->prev = 0;
  if ( allocate - 1 > 1 )
    v15 = 1;
  v11->name = name;
  v11->next = v11 + 1;
  if ( allocate - 1 > 1 )
  {
    do
    {
      ++v15;
      *(_DWORD *)(v17 - 16) = name;
      *(_DWORD *)(v17 - 8) = v17;
      *(_DWORD *)(v17 - 12) = v17 - 32;
      v17 += 16;
    }
    while ( v15 != v13 );
  }
  do_tail = list->do_tail;
  v19 = &v11[v13];
  v19->name = name;
  v19->prev = &v11[allocate - 2];
  v19->next = 0;
  list->head = v11;
  if ( do_tail )
    list->tail = v19;
  data_mem_count = list->data_mem_count;
  do
  {
    v21 = data_mem_count + 1;
    data_memory = list->data_memory;
    list->data_mem_count = v21;
    v23 = (void **)realloc(data_memory, 4 * v21);
    list->data_memory = v23;
    if ( !v23 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        (const char *)list->name,
        list->data_mem_count,
        "klist.c",
        (const char *)_func___9328,
        69);
      applog(3, tmp42, 1);
      quit(1);
    }
    v24 = calloc(1u, list->siz);
    v12->data = v24;
    if ( !v24 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s failed to calloc item data in %s %s():%d",
        (const char *)list->name,
        "klist.c",
        (const char *)_func___9328,
        73);
      applog(3, tmp42, 1);
      quit(1);
    }
    data_mem_count = list->data_mem_count;
    list->data_memory[data_mem_count - 1] = v24;
    v12 = v12->next;
  }
  while ( v12 );
}

//----- (0000FA74) --------------------------------------------------------
K_LIST *__fastcall k_new_store(K_LIST *list)
{
  K_LIST *result; // r0
  cglock_t *lock; // r2
  const unsigned __int8 *name; // r3
  bool do_tail; // r5
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  result = (K_LIST *)calloc(1u, 0x40u);
  if ( !result )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc store for %s in %s %s():%d",
      (const char *)list->name,
      "klist.c",
      (const char *)_func___9344,
      85);
    applog(3, tmp42, 1);
    quit(1);
  }
  lock = list->lock;
  name = list->name;
  do_tail = list->do_tail;
  result->lock = lock;
  result->name = name;
  result->do_tail = do_tail;
  result->is_store = 1;
  return result;
}

//----- (0000FADC) --------------------------------------------------------
K_LIST *__fastcall k_new_list(
        const unsigned __int8 *name,
        size_t siz,
        int allocate,
        int limit,
        bool do_tail,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  K_LIST *v12; // r4
  pthread_mutex_t *v13; // r0
  pthread_mutex_t *v14; // r9
  int *v16; // r0
  int *v17; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-820h] BYREF

  if ( allocate <= 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      (const char *)name,
      allocate,
      "klist.c",
      (const char *)_func___9357,
      100);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( limit < 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      (const char *)name,
      limit,
      "klist.c",
      (const char *)_func___9357,
      103);
    applog(3, tmp42, 1);
    quit(1);
  }
  v12 = (K_LIST *)calloc(1u, 0x40u);
  if ( !v12 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___9357,
      107);
    applog(3, tmp42, 1);
    quit(1);
  }
  v12->is_store = 0;
  v13 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v14 = v13;
  v12->lock = (cglock_t *)v13;
  if ( !v13 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc lock for list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___9357,
      113);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_init(v13, 0) )
  {
    v17 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v17,
      "klist.c",
      (const char *)_func___9357,
      115);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v14[1], 0) )
  {
    v16 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v16,
      "klist.c",
      (const char *)_func___9357,
      115);
    applog(3, tmp42, 1);
    quit(1);
  }
  v12->name = name;
  v12->siz = siz;
  v12->allocate = allocate;
  v12->limit = limit;
  v12->do_tail = do_tail;
  k_alloc_items(v12, file, func, line);
  return v12;
}

//----- (0000FC9C) --------------------------------------------------------
K_ITEM *__fastcall k_unlink_head(
        K_LIST *list,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  k_item *head; // r4
  k_item *next; // r3
  int count; // r2

  head = list->head;
  if ( !head )
  {
    if ( list->is_store )
      return head;
    k_alloc_items(list, file, func, line);
    if ( !list->head )
      return head;
    head = list->head;
  }
  next = head->next;
  list->head = next;
  if ( next )
  {
    next->prev = 0;
  }
  else if ( list->do_tail )
  {
    list->tail = 0;
  }
  count = list->count;
  head->next = 0;
  head->prev = 0;
  list->count = count - 1;
  return head;
}

//----- (0000FCE0) --------------------------------------------------------
K_ITEM *__fastcall k_unlink_head_zero(
        K_LIST *list,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  K_ITEM *v5; // r0
  K_ITEM *v6; // r4

  v5 = k_unlink_head(list, file, func, line);
  v6 = v5;
  if ( v5 )
    memset(v5->data, 0, list->siz);
  return v6;
}

//----- (0000FCFC) --------------------------------------------------------
K_ITEM *__fastcall k_unlink_tail(
        K_LIST *list,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  K_ITEM *result; // r0
  k_item *prev; // r3
  int count; // r2
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  if ( !list->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9383,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9383,
      181);
    applog(3, tmp42, 1);
    quit(1);
  }
  result = list->tail;
  if ( result )
  {
    prev = result->prev;
    list->tail = prev;
    if ( prev )
      prev->next = 0;
    else
      list->head = 0;
    count = list->count;
    result->next = 0;
    result->prev = 0;
    list->count = count - 1;
  }
  return result;
}

//----- (0000FD78) --------------------------------------------------------
void __fastcall k_add_head(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *name; // r0
  const unsigned __int8 *v8; // r1
  k_item *head; // r3
  _BOOL4 do_tail; // r3
  int v11; // r3
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  name = list->name;
  v8 = item->name;
  if ( v8 != name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)name,
      (const char *)_func___9392,
      (const char *)v8,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9392,
      205);
    applog(3, tmp42, 1);
    quit(1);
  }
  head = list->head;
  item->prev = 0;
  item->next = head;
  if ( head )
    head->prev = item;
  do_tail = list->do_tail;
  list->head = item;
  if ( do_tail && !list->tail )
    list->tail = item;
  v11 = list->count_up + 1;
  ++list->count;
  list->count_up = v11;
}

//----- (0000FE08) --------------------------------------------------------
void __fastcall k_add_tail(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *name; // r0
  const unsigned __int8 *v8; // r1
  k_item *tail; // r3
  k_item *head; // r3
  int v11; // r3
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  name = list->name;
  v8 = item->name;
  if ( v8 != name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)name,
      (const char *)_func___9401,
      (const char *)v8,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9401,
      236);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !list->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9401,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9401,
      241);
    applog(3, tmp42, 1);
    quit(1);
  }
  tail = list->tail;
  item->next = 0;
  item->prev = tail;
  if ( tail )
    tail->next = item;
  head = list->head;
  list->tail = item;
  if ( !head )
    list->head = item;
  v11 = list->count_up + 1;
  ++list->count;
  list->count_up = v11;
}

//----- (0000FEE0) --------------------------------------------------------
void __fastcall k_insert_before(
        K_LIST *list,
        K_ITEM *item,
        K_ITEM *before,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *name; // r1
  k_item *prev; // r3
  k_item *v10; // r3
  int count; // r2
  int count_up; // r3
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  name = item->name;
  if ( name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9412,
      (const char *)name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9412,
      262);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !before )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      (const char *)_func___9412,
      (const char *)list->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9412,
      267);
    applog(3, tmp42, 1);
    quit(1);
  }
  prev = before->prev;
  item->next = before;
  item->prev = prev;
  v10 = before->prev;
  if ( v10 )
    v10->next = item;
  else
    list->head = item;
  count = list->count;
  count_up = list->count_up;
  before->prev = item;
  list->count = count + 1;
  list->count_up = count_up + 1;
}

//----- (0000FFC0) --------------------------------------------------------
void __fastcall k_insert_after(
        K_LIST *list,
        K_ITEM *item,
        K_ITEM *after,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *name; // r1
  k_item *next; // r3
  k_item *v10; // r3
  int count; // r2
  int count_up; // r3
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  name = item->name;
  if ( name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9423,
      (const char *)name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9423,
      286);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !after )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      (const char *)_func___9423,
      (const char *)list->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9423,
      291);
    applog(3, tmp42, 1);
    quit(1);
  }
  next = after->next;
  item->prev = after;
  item->next = next;
  v10 = after->next;
  if ( v10 )
  {
    v10->prev = item;
  }
  else if ( list->do_tail )
  {
    list->tail = item;
  }
  count = list->count;
  count_up = list->count_up;
  after->next = item;
  list->count = count + 1;
  list->count_up = count_up + 1;
}

//----- (000100A8) --------------------------------------------------------
void __fastcall k_unlink_item(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *name; // r0
  const unsigned __int8 *v8; // r1
  k_item *prev; // r3
  k_item *next; // r2
  _BOOL4 do_tail; // r3
  int count; // r2
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  name = list->name;
  v8 = item->name;
  if ( v8 != name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)name,
      (const char *)_func___9433,
      (const char *)v8,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9433,
      312);
    applog(3, tmp42, 1);
    quit(1);
  }
  prev = item->prev;
  if ( prev )
    prev->next = item->next;
  next = item->next;
  if ( next )
    next->prev = prev;
  do_tail = list->do_tail;
  if ( list->head == item )
    list->head = next;
  if ( do_tail && list->tail == item )
    list->tail = item->prev;
  count = list->count;
  item->next = 0;
  item->prev = 0;
  list->count = count - 1;
}

//----- (00010144) --------------------------------------------------------
void __fastcall k_list_transfer_to_head(
        K_LIST *from,
        K_LIST *to,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  k_item *head; // r1
  k_item *v8; // r2
  k_item *tail; // r0
  int count; // r6
  int v11; // r7
  int count_up; // r0
  int v13; // r2
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  if ( from->name != to->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9442,
      (const char *)to->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9442,
      338);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !from->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9442,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9442,
      343);
    applog(3, tmp42, 1);
    quit(1);
  }
  head = from->head;
  if ( head )
  {
    v8 = to->head;
    if ( v8 )
    {
      tail = from->tail;
      v8->prev = tail;
    }
    else
    {
      to->tail = from->tail;
      tail = from->tail;
    }
    count = to->count;
    v11 = from->count;
    tail->next = v8;
    count_up = to->count_up;
    v13 = from->count_up;
    to->head = head;
    to->count = count + v11;
    from->tail = 0;
    to->count_up = count_up + v13;
    from->head = 0;
    from->count = 0;
    from->count_up = 0;
  }
}

//----- (00010234) --------------------------------------------------------
void __fastcall k_list_transfer_to_tail(
        K_LIST *from,
        K_LIST *to,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  k_item *head; // r2
  k_item *tail; // r1
  int count; // r7
  int v10; // r6
  int count_up; // r0
  int v12; // r2
  int v13; // r6
  k_item *v14; // r7
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  if ( from->name != to->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9452,
      (const char *)to->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9452,
      368);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !from->do_tail )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      (const char *)from->name,
      (const char *)_func___9452,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9452,
      373);
    applog(3, tmp42, 1);
    quit(1);
  }
  head = from->head;
  if ( head )
  {
    tail = to->tail;
    if ( tail )
    {
      tail->next = head;
    }
    else
    {
      to->head = head;
      head = from->head;
    }
    count = to->count;
    v10 = from->count;
    count_up = to->count_up;
    head->prev = tail;
    v12 = from->count_up;
    v13 = count + v10;
    v14 = from->tail;
    to->count = v13;
    from->head = 0;
    to->count_up = count_up + v12;
    to->tail = v14;
    from->count = 0;
    from->tail = 0;
    from->count_up = 0;
  }
}

//----- (0001031C) --------------------------------------------------------
K_LIST *__fastcall k_free_list(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  cglock_t *lock; // r5
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  if ( list->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___9462,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9462,
      400);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( list->item_mem_count > 0 )
  {
    v5 = 0;
    do
    {
      v6 = list->item_memory[v5++];
      free(v6);
    }
    while ( list->item_mem_count > v5 );
  }
  free(list->item_memory);
  if ( list->data_mem_count > 0 )
  {
    v7 = 0;
    do
    {
      v8 = list->data_memory[v7++];
      free(v8);
    }
    while ( list->data_mem_count > v7 );
  }
  free(list->data_memory);
  lock = list->lock;
  pthread_rwlock_destroy(&lock->rwlock);
  pthread_mutex_destroy(&lock->mutex);
  free(list->lock);
  free(list);
  return 0;
}

//----- (000103DC) --------------------------------------------------------
K_LIST *__fastcall k_free_store(
        K_LIST *store,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  if ( !store->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      (const char *)store->name,
      (const char *)_func___9476,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___9476,
      424);
    applog(3, tmp42, 1);
    quit(1);
  }
  free(store);
  return 0;
}

//----- (00010440) --------------------------------------------------------
void __fastcall sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  int v3; // r3
  unsigned int *v4; // r1
  unsigned int *v5; // r2
  unsigned int *v6; // r3
  int i; // r2
  unsigned int v8; // r7
  int j; // r3
  unsigned int v10; // r7
  int v11; // r1
  unsigned int v12; // r3
  unsigned int v13; // r5
  unsigned int v14; // r2
  unsigned int v15; // r4
  unsigned int v16; // r0
  unsigned int v17; // r6
  unsigned int v18; // r10
  unsigned int v19; // r7
  unsigned int v20; // r11
  unsigned int v21; // r12
  int v22; // r5
  unsigned int v23; // r2
  sha256_ctx *v24; // r1
  unsigned int v26; // [sp+0h] [bp-158h]
  unsigned int v27; // [sp+4h] [bp-154h]
  int v28; // [sp+8h] [bp-150h]
  unsigned int wv[8]; // [sp+18h] [bp-140h] BYREF
  unsigned int w[64]; // [sp+38h] [bp-120h] BYREF

  if ( (int)block_nb > 0 )
  {
    v28 = 0;
    do
    {
      v3 = 0;
      v4 = &wv[7];
      do
      {
        v5 = (unsigned int *)&message[64 * v28 + 4 * v3++];
        v4[1] = _byteswap_ulong(*v5);
        ++v4;
      }
      while ( v3 != 16 );
      v6 = w;
      for ( i = 0; i != 48; ++i )
      {
        v8 = w[i];
        v6[16] = (__ROR4__(v6[1], 7) ^ __ROR4__(v6[1], 18) ^ (v6[1] >> 3))
               + (__ROR4__(v6[14], 17) ^ __ROR4__(v6[14], 19) ^ (v6[14] >> 10))
               + v6[9]
               + v8;
        ++v6;
      }
      for ( j = 0; j != 8; ++j )
        wv[j] = ctx->h[j];
      v10 = wv[7];
      v27 = wv[3];
      v11 = 0;
      v12 = wv[4];
      v13 = wv[6];
      v14 = wv[0];
      v15 = wv[1];
      v16 = wv[2];
      v26 = wv[5];
      while ( 1 )
      {
        v17 = v27;
        v18 = (v13 & ~v12 ^ v26 & v12)
            + w[v11]
            + sha256_k[v11]
            + (__ROR4__(v12, 6) ^ __ROR4__(v12, 11) ^ __ROR4__(v12, 25));
        ++v11;
        v27 = v16;
        v19 = v10 + v18;
        v20 = v17 + v19;
        v21 = (__ROR4__(v14, 2) ^ __ROR4__(v14, 13) ^ __ROR4__(v14, 22)) + ((v15 ^ v16) & v14 ^ v16 & v15) + v19;
        v10 = v13;
        if ( v11 == 64 )
          break;
        v16 = v15;
        v13 = v26;
        v15 = v14;
        v26 = v12;
        v14 = v21;
        v12 = v20;
      }
      wv[7] = v13;
      v22 = 0;
      wv[1] = v14;
      v23 = v21;
      v24 = ctx;
      wv[4] = v20;
      wv[5] = v12;
      wv[6] = v26;
      wv[0] = v21;
      wv[2] = v15;
      wv[3] = v16;
      while ( 1 )
      {
        ++v22;
        v24->h[0] += v23;
        v24 = (sha256_ctx *)((char *)v24 + 4);
        if ( v22 == 8 )
          break;
        v23 = wv[v22];
      }
    }
    while ( block_nb != ++v28 );
  }
}

//----- (000105B4) --------------------------------------------------------
void __fastcall sha256_init(sha256_ctx *ctx)
{
  int i; // r3
  unsigned int v2; // r1
  char *v3; // r2

  for ( i = 0; i != 8; ++i )
  {
    v2 = sha256_h0[i];
    v3 = (char *)ctx + i * 4;
    *((_DWORD *)v3 + 34) = v2;
  }
  ctx->len = 0;
  ctx->tot_len = 0;
}

//----- (000105D8) --------------------------------------------------------
void __fastcall sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v4; // r0
  size_t v7; // r6
  unsigned int v8; // r0
  unsigned int v9; // r3
  unsigned int v10; // r5
  unsigned int v11; // r8
  const unsigned __int8 *v12; // r6
  int v13; // r5
  unsigned int tot_len; // r3

  v4 = ctx->len;
  v7 = 64 - v4;
  v8 = v4 + 8;
  if ( len < v7 )
    v7 = len;
  memcpy((char *)ctx + v8, message, v7);
  v9 = len + ctx->len;
  if ( v9 > 0x3F )
  {
    v10 = len - v7;
    v11 = v10 >> 6;
    v12 = &message[v7];
    sha256_transf(ctx, ctx->block, 1u);
    v13 = v10 & 0x3F;
    sha256_transf(ctx, v12, v11);
    memcpy(ctx->block, &v12[64 * v11], v13);
    tot_len = ctx->tot_len;
    ctx->len = v13;
    ctx->tot_len = tot_len + ((v11 + 1) << 6);
  }
  else
  {
    ctx->len = v9;
  }
}

//----- (00010648) --------------------------------------------------------
void __fastcall sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  unsigned int len; // r3
  sha256_ctx *v3; // r5
  int v5; // r2
  unsigned int v6; // r6
  size_t v7; // r2
  unsigned __int8 *v8; // r0
  int v9; // r8
  int v10; // r9
  int v11; // r10
  int v12; // r11
  unsigned int v13; // r7
  int i; // r3
  unsigned __int8 *v15; // r2

  len = ctx->len;
  v3 = ctx;
  if ( (len & 0x3F) >= 0x38 )
    v5 = 128;
  else
    v5 = 64;
  v6 = 8 * (ctx->tot_len + len);
  v7 = v5 - len;
  v8 = &ctx->block[len];
  if ( (len & 0x3F) >= 0x38 )
    v9 = 124;
  else
    v9 = 60;
  if ( (len & 0x3F) >= 0x38 )
    v10 = 125;
  else
    v10 = 61;
  if ( (len & 0x3F) >= 0x38 )
    v11 = 126;
  else
    v11 = 62;
  if ( (len & 0x3F) >= 0x38 )
    v12 = 127;
  else
    v12 = 63;
  if ( (len & 0x3F) >= 0x38 )
    v13 = 2;
  else
    v13 = 1;
  memset(v8, 0, v7);
  v3->block[v3->len] = 0x80;
  v3->block[v12] = v6;
  v3->block[v11] = BYTE1(v6);
  v3->block[v10] = BYTE2(v6);
  v3->block[v9] = HIBYTE(v6);
  sha256_transf(v3, v3->block, v13);
  for ( i = 0; i != 8; ++i )
  {
    v15 = &digest[4 * i];
    v15[3] = v3->h[0];
    v15[2] = BYTE1(v3->h[0]);
    v15[1] = HIWORD(v3->h[0]);
    LOBYTE(v15) = HIBYTE(v3->h[0]);
    v3 = (sha256_ctx *)((char *)v3 + 4);
    digest[4 * i] = (unsigned __int8)v15;
  }
}

//----- (00010714) --------------------------------------------------------
void __fastcall sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  int i; // r3
  unsigned int v5; // r5
  char *v6; // r4
  sha256_ctx ctx; // [sp+0h] [bp-C0h] BYREF

  for ( i = 0; i != 8; ++i )
  {
    v5 = sha256_h0[i];
    v6 = (char *)&ctx + i * 4;
    *((_DWORD *)v6 + 34) = v5;
  }
  ctx.len = 0;
  ctx.tot_len = 0;
  sha256_update(&ctx, message, len);
  sha256_final(&ctx, digest);
}

//----- (00010750) --------------------------------------------------------
int no_yield()
{
  return 0;
}

//----- (00010754) --------------------------------------------------------
void __fastcall clear_sockbuf(pool *pool)
{
  unsigned __int8 *sockbuf; // r3

  sockbuf = pool->sockbuf;
  if ( sockbuf )
    *sockbuf = 0;
}

//----- (00010760) --------------------------------------------------------
bool __fastcall socket_full(pool *pool, int wait)
{
  int sock; // r0
  int v3; // r1
  fd_set *p_tv_usec; // r3
  timeval timeout; // [sp+8h] [bp-98h] BYREF
  fd_set rd; // [sp+10h] [bp-90h] BYREF

  sock = pool->sock;
  v3 = wait & ~(wait >> 31);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( p_tv_usec != (fd_set *)&rd.fds_bits[31] );
  timeout.tv_sec = v3;
  timeout.tv_usec = 0;
  rd.fds_bits[sock / 32] |= 1 << (sock % 32);
  return select(sock + 1, &rd, 0, 0, &timeout) > 0;
}

//----- (000107C8) --------------------------------------------------------
void __fastcall block_socket(int fd)
{
  unsigned int v2; // r2

  v2 = fcntl(fd, 3, 0) & 0xFFFFF7FF;
  j_fcntl(fd, 4, v2);
}

//----- (000107E4) --------------------------------------------------------
int __fastcall recv_byte(int sockd)
{
  int result; // r0
  unsigned __int8 c; // [sp+7h] [bp-9h] BYREF

  result = recv(sockd, &c, 1u, 0);
  if ( result != -1 )
    return c;
  return result;
}

//----- (00010800) --------------------------------------------------------
bool __fastcall http_negotiate(pool *pool, int sockd, bool http0)
{
  unsigned __int8 *sockaddr_url; // r3
  unsigned __int8 *stratum_port; // r6
  size_t v7; // r0
  ssize_t v8; // r0
  _BOOL4 v9; // r3
  unsigned __int8 *v10; // r6
  unsigned __int8 v11; // r0
  char v13; // [sp+Fh] [bp-C21h] BYREF
  unsigned __int8 buf[1024]; // [sp+10h] [bp-C20h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+410h] [bp-820h] BYREF

  sockaddr_url = pool->sockaddr_url;
  stratum_port = pool->stratum_port;
  if ( http0 )
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.0\r\n\r\n",
      (const char *)sockaddr_url,
      (const char *)stratum_port);
  else
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n",
      (const char *)sockaddr_url,
      (const char *)stratum_port,
      (const char *)sockaddr_url,
      (const char *)stratum_port);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Sending proxy %s:%s - %s",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port,
      (const char *)buf);
    applog(7, tmp42, 0);
  }
  v7 = strlen((const char *)buf);
  send(sockd, buf, v7, 0);
  v8 = recv(sockd, buf, 0xCu, 0);
  if ( v8 <= 0 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      return 0;
    snprintf(
      (char *)tmp42,
      0x800u,
      "Couldn't read from proxy %s:%s after sending CONNECT",
      pool->sockaddr_proxy_url,
      pool->sockaddr_proxy_port);
LABEL_22:
    applog(4, tmp42, 0);
    return 0;
  }
  v9 = opt_debug;
  buf[v8] = 0;
  if ( v9 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Received from proxy %s:%s - %s",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port,
      (const char *)buf);
    applog(7, tmp42, 0);
  }
  if ( strcmp((const char *)buf, "HTTP/1.1 200") && strcmp((const char *)buf, "HTTP/1.0 200") )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      return 0;
    snprintf(
      (char *)tmp42,
      0x800u,
      "HTTP Error from proxy %s:%s - %s",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port,
      (const char *)buf);
    goto LABEL_22;
  }
  v10 = (unsigned __int8 *)&v13;
  while ( 1 )
  {
    v11 = recv_byte(sockd);
    *++v10 = v11;
    if ( v11 == 255 )
      break;
    if ( v10 == &buf[3] )
    {
      while ( strncmp((const char *)buf, "\r\n\r\n", 4u) )
      {
        buf[0] = buf[1];
        buf[1] = buf[2];
        buf[2] = buf[3];
        buf[3] = recv_byte(sockd);
        if ( buf[3] == 255 )
          goto LABEL_18;
      }
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return 1;
      snprintf(
        (char *)tmp42,
        0x800u,
        "Success negotiating with %s:%s HTTP proxy",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(7, tmp42, 0);
      return 1;
    }
  }
LABEL_18:
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Couldn't read HTTP byte from proxy %s:%s",
      pool->sockaddr_proxy_url,
      pool->sockaddr_proxy_port);
    goto LABEL_22;
  }
  return 0;
}

//----- (00010A70) --------------------------------------------------------
void __fastcall nanosleep_abstime(timespec *ts_end)
{
  while ( clock_nanosleep(1, 1, ts_end, 0) == 4 )
    ;
}

//----- (00010A88) --------------------------------------------------------
unsigned __int8 *__fastcall _json_array_string(json_t_0 *val, unsigned int entry)
{
  json_t_0 *v4; // r0

  if ( val
    && val->type != JSON_NULL
    && val->type == JSON_ARRAY
    && json_array_size(val) >= entry
    && (v4 = json_array_get(val, entry)) != 0
    && v4->type == JSON_STRING )
  {
    return (unsigned __int8 *)json_string_value(v4);
  }
  else
  {
    return 0;
  }
}

//----- (00010AC0) --------------------------------------------------------
unsigned __int8 *__fastcall json_array_string(json_t_0 *val, unsigned int entry)
{
  unsigned __int8 *result; // r0

  result = _json_array_string(val, entry);
  if ( result )
    return (unsigned __int8 *)j___strdup((const char *)result);
  return result;
}

//----- (00010AD4) --------------------------------------------------------
bool __fastcall valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 *v4; // r5
  signed int v5; // r0
  int v6; // r3
  int v7; // t1
  _BOOL4 result; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v4 = s;
  if ( s )
  {
    v5 = strlen((const char *)s);
    if ( v5 <= 0 )
      return 1;
    if ( hex2bin_tbl[*v4] >= 0 )
    {
      v6 = 0;
      while ( v5 != ++v6 )
      {
        v7 = *++v4;
        if ( hex2bin_tbl[v7] < 0 )
          goto LABEL_10;
      }
      return 1;
    }
LABEL_10:
    if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Invalid char 0x%x passed to valid_hex from", " in %s %s():%d");
LABEL_14:
      applog(3, tmp42, 0);
      return 0;
    }
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "Null string passed to valid_hex from", " in %s %s():%d", "util.c", file, func);
    goto LABEL_14;
  }
  return result;
}

//----- (00010BA8) --------------------------------------------------------
void __fastcall rw_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v6 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v6,
      "util.c",
      (const char *)file,
      func);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00010BF8) --------------------------------------------------------
void __fastcall wr_lock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v6 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v6,
      "util.c",
      (const char *)file,
      func);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00010C48) --------------------------------------------------------
void __fastcall mutex_unlock_noyield_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v6 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v6,
      "util.c",
      (const char *)file,
      func);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00010C98) --------------------------------------------------------
send_ret __fastcall _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  int sock; // r4
  signed int v5; // r10
  unsigned int v6; // r2
  int v7; // r5
  int v8; // r5
  char v9; // r9
  int v10; // r4
  int v11; // r9
  unsigned int v12; // r6
  ssize_t v13; // r0
  int v14; // r1
  __int64 v15; // r2
  send_ret result; // r0
  uint64_t net_bytes_sent; // r10
  uint64_t v18; // r6
  int v19; // [sp+Ch] [bp-83Ch]
  timeval timeout; // [sp+18h] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-828h] BYREF

  sock = pool->sock;
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "SEND: %s", (const char *)s);
    applog(7, tmp42, 0);
  }
  v5 = len + 1;
  *(_WORD *)&s[strlen((const char *)s)] = 10;
  if ( v5 <= 0 )
  {
    v15 = 0LL;
    goto LABEL_15;
  }
  v6 = (unsigned int)(sock >> 31) >> 27;
  v7 = (sock + 31) & (sock >> 31);
  if ( sock >= 0 )
    v7 = sock;
  v8 = v7 >> 5;
  v19 = 0;
  v9 = (sock + v6) & 0x1F;
  v10 = sock + 1;
  v11 = 1 << (v9 - v6);
  while ( 2 )
  {
    v12 = 0;
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    while ( 1 )
    {
      if ( v12 <= 0x1F )
        goto LABEL_11;
      *(_DWORD *)&tmp42[4 * v8] |= v11;
      if ( select(v10, 0, (fd_set *)tmp42, 0, &timeout) > 0 )
        break;
      v12 = 0;
      if ( *_errno_location() != 4 )
        return 1;
LABEL_11:
      *(_DWORD *)&tmp42[4 * v12++] = 0;
    }
    v13 = send(pool->sock, &s[v19], v5, 0x4000);
    if ( v13 >= 0 )
      goto LABEL_13;
    if ( *_errno_location() != 11 )
      return 2;
    v13 = 0;
LABEL_13:
    v5 -= v13;
    v14 = v19 + v13;
    v19 += v13;
    if ( v5 > 0 )
      continue;
    break;
  }
  v15 = v14;
LABEL_15:
  result = SEND_OK;
  net_bytes_sent = pool->cgminer_pool_stats.net_bytes_sent;
  v18 = pool->cgminer_pool_stats.bytes_sent + v15;
  ++pool->cgminer_pool_stats.times_sent;
  pool->cgminer_pool_stats.bytes_sent = v18;
  pool->cgminer_pool_stats.net_bytes_sent = v15 + net_bytes_sent;
  return result;
}

//----- (00010E20) --------------------------------------------------------
void __fastcall clear_sock(pool *pool)
{
  pthread_mutex_t *p_stratum_lock; // r5
  const unsigned __int8 *v3; // r2
  int v4; // r3
  int sock; // r0

  p_stratum_lock = &pool->stratum_lock;
  if ( pthread_mutex_lock(&pool->stratum_lock) )
    mutex_lock_0((pthread_mutex_t *)&_func___10719, (const unsigned __int8 *)0x6E5, v3, v4);
  do
    sock = pool->sock;
  while ( sock && recv(sock, pool->sockbuf, 0x1FFCu, 0) > 0 );
  mutex_unlock_noyield_0(p_stratum_lock, (const unsigned __int8 *)&_func___10719, (const unsigned __int8 *)0x6EE, v4);
  selective_yield();
  clear_sockbuf(pool);
}
// 10E3E: variable 'v4' is possibly undefined
// 10E6C: variable 'v3' is possibly undefined

//----- (00010E7C) --------------------------------------------------------
void __fastcall tq_freezethaw(thread_q *tq, bool frozen)
{
  pthread_mutex_t *p_mutex; // r5
  const unsigned __int8 *v5; // r2
  int v6; // r3
  int v7; // r3

  p_mutex = &tq->mutex;
  if ( pthread_mutex_lock(&tq->mutex) )
    mutex_lock_0((pthread_mutex_t *)&_func___10719.__size[12], (const unsigned __int8 *)0x454, v5, v6);
  tq->frozen = frozen;
  pthread_cond_signal(&tq->cond);
  mutex_unlock_noyield_0(p_mutex, &_func___10719.__size[12], (const unsigned __int8 *)0x457, v7);
  selective_yield();
}
// 10EA0: variable 'v7' is possibly undefined
// 10EB2: variable 'v5' is possibly undefined
// 10EB2: variable 'v6' is possibly undefined

//----- (00010EC0) --------------------------------------------------------
void *__fastcall cgmalloc(unsigned int size, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned int v5; // r4
  void *result; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v5 = size;
  if ( size << 30 )
    v5 = size & 0xFFFFFFFC;
  if ( size << 30 )
    v5 += 4;
  result = malloc(v5);
  if ( !result )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to malloc size %d from %s %s:%d",
      v5,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return result;
}

//----- (00010F1C) --------------------------------------------------------
void *__fastcall cgcalloc(
        int memb,
        size_t size,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  size_t v5; // r4
  size_t v6; // r1
  void *result; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v5 = size;
  v6 = size << 30;
  if ( v6 )
    v5 &= 0xFFFFFFFC;
  if ( v6 )
    v5 += 4;
  result = calloc(memb, v5);
  if ( !result )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc memb %d size %d from %s %s:%d",
      memb,
      v5,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return result;
}

//----- (00010F7C) --------------------------------------------------------
void *__fastcall cgrealloc(
        void *ptr,
        size_t size,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  size_t v5; // r4
  void *result; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v5 = size;
  if ( size << 30 )
    v5 = (size & 0xFFFFFFFC) + 4;
  result = realloc(ptr, v5);
  if ( !result )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to realloc size %d from %s %s:%d",
      v5,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return result;
}

//----- (00010FD4) --------------------------------------------------------
const unsigned __int8 *__fastcall proxytype(proxytypes_t a1)
{
  const $262D70590CF6D71EA9430194459E5D8E *v1; // r3
  const unsigned __int8 *name; // r2

  if ( !a1 )
    return "http:";
  v1 = proxynames;
  while ( 1 )
  {
    name = v1[1].name;
    ++v1;
    if ( !name )
      break;
    if ( v1->proxytype == a1 )
      return name;
  }
  return "invalid";
}

//----- (00011000) --------------------------------------------------------
void __fastcall _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *v3; // r4
  char v4; // t1

  if ( (int)len <= 0 )
  {
    v3 = s;
  }
  else
  {
    v3 = &s[2 * len];
    do
    {
      *s = *((_BYTE *)&hex2bin_tbl[277] + (*p >> 4));
      v4 = *p++;
      s[1] = *((_BYTE *)&hex2bin_tbl[277] + (v4 & 0xF));
      s += 2;
    }
    while ( v3 != s );
  }
  *v3 = 0;
}

//----- (00011040) --------------------------------------------------------
unsigned __int8 *__fastcall bin2hex(const unsigned __int8 *p, size_t len)
{
  size_t v2; // r8
  unsigned __int8 *result; // r0
  unsigned __int8 *v6; // r2
  int v7; // r3
  unsigned __int8 v8; // r6
  unsigned __int8 *v9; // r8

  v2 = 2 * len;
  result = (unsigned __int8 *)cgcalloc(4 - (int)(v2 + 1) % 4 + v2 + 1, 1u, "util.c", _func___10314, 789);
  if ( (int)len <= 0 )
  {
    v9 = result;
  }
  else
  {
    v6 = result + 2;
    v7 = 0;
    do
    {
      *(v6 - 2) = *((_BYTE *)&hex2bin_tbl[277] + (p[v7] >> 4));
      v8 = p[v7++];
      *(v6 - 1) = *((_BYTE *)&hex2bin_tbl[277] + (v8 & 0xF));
      v6 += 2;
    }
    while ( v7 != len );
    v9 = &result[v2];
  }
  *v9 = 0;
  return result;
}

//----- (000110C4) --------------------------------------------------------
bool __fastcall hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len)
{
  int v3; // r3
  int v4; // r4
  const unsigned __int8 *v5; // r1
  int v6; // r4
  int v7; // r3
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  if ( !*hexstr )
    return len == 0;
  if ( !len )
    return 0;
  if ( !hexstr[1] )
  {
LABEL_12:
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "hex2bin str truncated");
      applog(3, tmp42, 0);
    }
    return 0;
  }
  v3 = hex2bin_tbl[*hexstr];
  v4 = hex2bin_tbl[hexstr[1]];
  if ( (v4 | v3) >= 0 )
  {
    v5 = hexstr + 4;
    do
    {
      --len;
      *p++ = v4 | (16 * v3);
      v7 = *(v5 - 2);
      if ( !*(v5 - 2) )
        return len == 0;
      if ( !len )
        return 0;
      v6 = *(v5 - 1);
      v5 += 2;
      if ( !v6 )
        goto LABEL_12;
      v3 = hex2bin_tbl[v7];
      v4 = hex2bin_tbl[v6];
    }
    while ( (v4 | v3) >= 0 );
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
    return 0;
  strcpy((char *)tmp42, "hex2bin scan failed");
  applog(3, tmp42, 0);
  return 0;
}

//----- (000111A4) --------------------------------------------------------
void __fastcall b58tobin(unsigned __int8 *b58bin, const unsigned __int8 *b58)
{
  unsigned int v2; // r5
  signed int v4; // r0
  int v5; // r10
  unsigned int *v6; // r12
  int v7; // r8
  int v8; // r4
  unsigned __int8 v9; // r4
  unsigned int v10; // r2
  unsigned int *v11; // r1
  unsigned __int8 *v12; // r3
  unsigned int v13; // t1
  unsigned int bin32[7]; // [sp+Ch] [bp-44h] BYREF

  v2 = 0;
  memset(bin32, 0, sizeof(bin32));
  v4 = strlen((const char *)b58);
  if ( v4 <= 0 )
  {
    v10 = 0;
    v9 = 0;
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = bin32;
      v7 = 6;
      v8 = hex2bin_tbl[b58[v5] + 283];
      while ( 1 )
      {
        --v7;
        v6[6] = 58 * v2 + v8;
        v8 = ((58LL * v2 + (unsigned __int64)(unsigned int)v8) >> 32) & 0x3F;
        --v6;
        if ( v7 == -1 )
          break;
        v2 = v6[6];
      }
      if ( v4 == ++v5 )
        break;
      v2 = bin32[6];
    }
    v9 = bin32[0];
    v10 = bswap32(bin32[1]);
  }
  v11 = &bin32[1];
  *b58bin = v9;
  v12 = b58bin + 5;
  while ( 1 )
  {
    *((_DWORD *)v12 - 1) = v10;
    v12 += 4;
    if ( v12 == b58bin + 29 )
      break;
    v13 = v11[1];
    ++v11;
    v10 = bswap32(v13);
  }
}

//----- (00011250) --------------------------------------------------------
int __fastcall ser_number(unsigned __int8 *s, int32_t val)
{
  unsigned __int8 v3; // r2
  int result; // r0

  if ( val > 127 )
  {
    if ( val >= 16512 )
    {
      if ( val <= 2113663 )
        result = 4;
      else
        result = 5;
      if ( val <= 2113663 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(s + 1) = val;
  *s = v3;
  return result;
}

//----- (00011288) --------------------------------------------------------
bool __fastcall fulltest(const unsigned __int8 *hash, const unsigned __int8 *target)
{
  int v3; // r2
  const unsigned __int8 *v4; // r0
  unsigned int v5; // r4
  unsigned int v6; // r0
  _BOOL4 v7; // r8
  unsigned int v9; // r10
  unsigned int v10; // r7
  unsigned int v11; // lr
  unsigned int v12; // r11
  unsigned int v13; // r6
  unsigned int v14; // r9
  unsigned int v15; // r12
  unsigned int v16; // r5
  unsigned int v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r10
  unsigned int v20; // r7
  unsigned int v21; // r3
  unsigned int v22; // r11
  unsigned int v23; // r3
  unsigned int v24; // r5
  unsigned int v25; // lr
  unsigned int v26; // r3
  unsigned int v27; // r6
  unsigned int v28; // r3
  unsigned int v29; // r1
  unsigned int v30; // r9
  unsigned __int8 *v32; // r6
  unsigned __int8 *v33; // r5
  const char *v34; // r4
  unsigned __int8 hash_swap[32]; // [sp+8h] [bp-868h] BYREF
  unsigned __int8 target_swap[32]; // [sp+28h] [bp-848h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+48h] [bp-828h] BYREF

  v3 = 0;
  while ( 1 )
  {
    v4 = &target[v3];
    v5 = *(_DWORD *)&hash[v3 + 28];
    v3 -= 4;
    v6 = *((_DWORD *)v4 + 7);
    if ( v5 > v6 )
      break;
    if ( v5 < v6 || v3 == -32 )
    {
      v7 = 1;
      goto LABEL_6;
    }
  }
  v7 = 0;
LABEL_6:
  if ( opt_debug )
  {
    v9 = *((_DWORD *)hash + 2);
    v10 = bswap32(*((_DWORD *)hash + 7));
    v11 = bswap32(*((_DWORD *)hash + 6));
    v12 = *(_DWORD *)hash;
    v13 = bswap32(*((_DWORD *)hash + 5));
    v14 = *((_DWORD *)hash + 3);
    v15 = *((_DWORD *)hash + 1);
    v16 = bswap32(*((_DWORD *)hash + 4));
    v17 = *((_DWORD *)target + 7);
    v18 = bswap32(v9);
    *(_DWORD *)hash_swap = v10;
    v19 = bswap32(v12);
    *(_DWORD *)&hash_swap[4] = v11;
    v20 = bswap32(v17);
    v21 = *((_DWORD *)target + 6);
    *(_DWORD *)&hash_swap[8] = v13;
    *(_DWORD *)&hash_swap[12] = v16;
    v22 = bswap32(v21);
    v23 = *((_DWORD *)target + 5);
    v24 = *((_DWORD *)target + 2);
    *(_DWORD *)&hash_swap[16] = bswap32(v14);
    v25 = bswap32(v23);
    v26 = *((_DWORD *)target + 4);
    *(_DWORD *)&hash_swap[20] = v18;
    *(_DWORD *)&hash_swap[24] = bswap32(v15);
    v27 = bswap32(v26);
    v28 = *((_DWORD *)target + 3);
    v29 = *(_DWORD *)target;
    v30 = *((_DWORD *)target + 1);
    *(_DWORD *)&target_swap[8] = v25;
    *(_DWORD *)&target_swap[12] = v27;
    *(_DWORD *)&target_swap[16] = bswap32(v28);
    *(_DWORD *)&target_swap[20] = bswap32(v24);
    *(_DWORD *)&target_swap[24] = bswap32(v30);
    *(_DWORD *)&target_swap[28] = bswap32(v29);
    *(_DWORD *)&hash_swap[28] = v19;
    *(_DWORD *)target_swap = v20;
    *(_DWORD *)&target_swap[4] = v22;
    v32 = bin2hex(hash_swap, 0x20u);
    v33 = bin2hex(target_swap, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      v34 = "YES (hash <= target)";
      if ( !v7 )
        v34 = "no (false positive; hash > target)";
      snprintf((char *)tmp42, 0x800u, " Proof: %s\nTarget: %s\nTrgVal? %s", v32, v33, v34);
      applog(7, tmp42, 0);
    }
    free(v32);
    free(v33);
  }
  return v7;
}

//----- (000113D0) --------------------------------------------------------
thread_q *tq_new()
{
  char *v0; // r4

  v0 = (char *)cgcalloc(1, 0x58u, "util.c", _func___10430, 1077);
  *(_DWORD *)v0 = v0;
  *((_DWORD *)v0 + 1) = v0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v0 + 40), 0);
  return (thread_q *)v0;
}

//----- (00011410) --------------------------------------------------------
void __fastcall tq_free(thread_q *tq)
{
  list_head *v1; // r5
  list_head *next; // r2
  list_head **p_prev; // r3
  list_head **v5; // r4
  list_head *v6; // r1
  bool v7; // zf

  if ( tq )
  {
    next = tq->q.next->next;
    p_prev = &tq->q.next[-1].prev;
    if ( tq != (thread_q *)tq->q.next )
      v1 = 0;
    v5 = &next[-1].prev;
    if ( tq != (thread_q *)tq->q.next )
    {
      do
      {
        v6 = p_prev[2];
        next->prev = v6;
        v6->next = next;
        p_prev[2] = v1;
        p_prev[1] = v1;
        free(p_prev);
        p_prev = v5;
        next = v5[1];
        v7 = v5 + 1 == (list_head **)tq;
        v5 = &next[-1].prev;
      }
      while ( !v7 );
    }
    pthread_cond_destroy(&tq->cond);
    pthread_mutex_destroy(&tq->mutex);
    memset(tq, 0, sizeof(thread_q));
    j_free(tq);
  }
}
// 11434: variable 'v1' is possibly undefined

//----- (00011474) --------------------------------------------------------
void __fastcall tq_freeze(thread_q *tq)
{
  tq_freezethaw(tq, 1);
}

//----- (0001147C) --------------------------------------------------------
void __fastcall tq_thaw(thread_q *tq)
{
  tq_freezethaw(tq, 0);
}

//----- (00011484) --------------------------------------------------------
bool __fastcall tq_push(thread_q *tq, void *data)
{
  _DWORD *v4; // r6
  list_head *v5; // r4
  const unsigned __int8 *v6; // r2
  int v7; // r3
  list_head *prev; // r3
  bool v9; // r8
  int v10; // r3

  v4 = cgcalloc(1, 0xCu, "util.c", (const unsigned __int8 *)&_func___10456, 1129);
  *v4 = data;
  v5 = (list_head *)(v4 + 1);
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock(&tq->mutex) )
    mutex_lock_0((pthread_mutex_t *)&_func___10456, (const unsigned __int8 *)0x46D, v6, v7);
  if ( tq->frozen )
  {
    v9 = 0;
    free(v4);
  }
  else
  {
    prev = tq->q.prev;
    v9 = 1;
    v4[1] = tq;
    tq->q.prev = v5;
    prev->next = v5;
    v4[2] = prev;
  }
  pthread_cond_signal(&tq->cond);
  mutex_unlock_noyield_0(&tq->mutex, (const unsigned __int8 *)&_func___10456, (const unsigned __int8 *)0x47A, v10);
  selective_yield();
  return v9;
}
// 114D8: variable 'v10' is possibly undefined
// 114FC: variable 'v6' is possibly undefined
// 114FC: variable 'v7' is possibly undefined

//----- (00011510) --------------------------------------------------------
void *__fastcall tq_pop(thread_q *tq, const timespec *abstime)
{
  pthread_mutex_t *p_mutex; // r5
  const unsigned __int8 *v5; // r2
  int v6; // r3
  list_head *next; // r3
  list_head *prev; // r1
  list_head *v9; // r4
  list_head *v10; // r6
  int v12; // r0

  p_mutex = &tq->mutex;
  if ( pthread_mutex_lock(&tq->mutex) )
    mutex_lock_0((pthread_mutex_t *)&_func___10456.__size[8], (const unsigned __int8 *)0x486, v5, v6);
  next = tq->q.next;
  if ( tq != (thread_q *)tq->q.next )
    goto pop;
  if ( abstime )
    v12 = pthread_cond_timedwait(&tq->cond, p_mutex, abstime);
  else
    v12 = pthread_cond_wait(&tq->cond, p_mutex);
  if ( v12 )
  {
    v10 = 0;
    goto out;
  }
  next = tq->q.next;
  if ( tq == (thread_q *)tq->q.next )
  {
    v10 = 0;
  }
  else
  {
pop:
    prev = next->prev;
    v9 = next->next;
    v10 = next[-1].prev;
    v9->prev = prev;
    prev->next = v9;
    next->prev = 0;
    next->next = 0;
    free(&next[-1].prev);
  }
out:
  mutex_unlock_noyield_0(p_mutex, &_func___10456.__size[8], (const unsigned __int8 *)0x4A0, (const int)next);
  selective_yield();
  return v10;
}
// 1154A: variable 'next' is possibly undefined
// 11588: variable 'v5' is possibly undefined
// 11588: variable 'v6' is possibly undefined

//----- (00011598) --------------------------------------------------------
void __fastcall thr_info_cancel(thr_info *thr)
{
  pthread_t pth; // r0

  if ( thr )
  {
    pth = thr->pth;
    if ( pth )
    {
      pthread_cancel(pth);
      thr->pth = 0;
    }
    sub_A1CC(&thr->sem);
  }
}

//----- (000115BC) --------------------------------------------------------
void __fastcall subtime(timeval *a, timeval *b)
{
  __time_t v2; // r2
  __suseconds_t v3; // r3

  v2 = a->tv_sec - b->tv_sec;
  v3 = a->tv_usec - b->tv_usec;
  b->tv_sec = v2;
  b->tv_usec = v3;
  if ( v3 < 0 )
  {
    b->tv_sec = v2 - 1;
    b->tv_usec = v3 + 1000000;
  }
}

//----- (000115E8) --------------------------------------------------------
void __fastcall addtime(timeval *a, timeval *b)
{
  __suseconds_t v2; // r3
  __time_t v3; // r0

  v2 = a->tv_usec + b->tv_usec;
  v3 = a->tv_sec + b->tv_sec;
  b->tv_sec = v3;
  b->tv_usec = v2;
  if ( v2 > (int)&cgpu.results[29][3662] + 3 )
  {
    b->tv_sec = v3 + 1;
    b->tv_usec = v2 - 1000000;
  }
}

//----- (00011618) --------------------------------------------------------
bool __fastcall time_more(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec > b->tv_usec;
  else
    return a->tv_sec > b->tv_sec;
}

//----- (00011638) --------------------------------------------------------
bool __fastcall time_less(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec < b->tv_usec;
  else
    return a->tv_sec < b->tv_sec;
}

//----- (00011658) --------------------------------------------------------
void __fastcall timespec_to_val(timeval *val, const timespec *spec)
{
  int tv_nsec; // r3

  tv_nsec = spec->tv_nsec;
  val->tv_sec = spec->tv_sec;
  val->tv_usec = tv_nsec / 1000;
}

//----- (00011678) --------------------------------------------------------
void __fastcall timeval_to_spec(timespec *spec, const timeval *val)
{
  int v2; // r2

  v2 = 1000 * val->tv_usec;
  spec->tv_sec = val->tv_sec;
  spec->tv_nsec = v2;
}

//----- (00011690) --------------------------------------------------------
void __fastcall us_to_timeval(timeval *val, int a2, int64_t us)
{
  __suseconds_t rem; // r3
  lldiv_t tvdiv; // [sp+8h] [bp-20h] BYREF

  lldiv(&tvdiv, a2, us, HIDWORD(us), &cgpu.results[29][3663], 0);
  rem = tvdiv.rem;
  val->tv_sec = tvdiv.quot;
  val->tv_usec = rem;
}
// A36C: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000116B8) --------------------------------------------------------
void __fastcall us_to_timespec(timespec *spec, int a2, int64_t us)
{
  int v4; // r2
  lldiv_t tvdiv; // [sp+8h] [bp-20h] BYREF

  lldiv(&tvdiv, a2, us, HIDWORD(us), &cgpu.results[29][3663], 0);
  v4 = 1000 * LODWORD(tvdiv.rem);
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = v4;
}
// A36C: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000116E8) --------------------------------------------------------
void __fastcall ms_to_timespec(timespec *spec, int a2, int64_t ms)
{
  int v4; // r3
  lldiv_t tvdiv; // [sp+8h] [bp-20h] BYREF

  lldiv(&tvdiv, a2, ms, HIDWORD(ms), 1000, 0);
  v4 = (_DWORD)&cgpu.results[29][3663] * LODWORD(tvdiv.rem);
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = v4;
}
// A36C: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00011718) --------------------------------------------------------
void __fastcall ms_to_timeval(timeval *val, int a2, int64_t ms)
{
  __suseconds_t v4; // r2
  lldiv_t tvdiv; // [sp+8h] [bp-20h] BYREF

  lldiv(&tvdiv, a2, ms, HIDWORD(ms), 1000, 0);
  v4 = 1000 * LODWORD(tvdiv.rem);
  val->tv_sec = tvdiv.quot;
  val->tv_usec = v4;
}
// A36C: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00011744) --------------------------------------------------------
void __fastcall timeraddspec(timespec *a, const timespec *b)
{
  int v2; // r3
  __time_t v3; // r2
  int v4; // r2
  __time_t v5; // r1
  int v6; // r2
  __time_t v7; // r1

  v2 = a->tv_nsec + b->tv_nsec;
  v3 = a->tv_sec + b->tv_sec;
  a->tv_sec = v3;
  a->tv_nsec = v2;
  if ( v2 > 999999999 )
  {
    v4 = v3 + 1;
    do
    {
      v5 = v4++;
      v2 -= 1000000000;
    }
    while ( v2 > 999999999 );
    a->tv_sec = v5;
    a->tv_nsec = v2;
  }
  if ( v2 < 0 )
  {
    v6 = a->tv_sec - 1;
    do
    {
      v7 = v6--;
      v2 += 1000000000;
    }
    while ( v2 < 0 );
    a->tv_sec = v7;
    a->tv_nsec = v2;
  }
}

//----- (000117A0) --------------------------------------------------------
unsigned __int8 *__fastcall Strcasestr(unsigned __int8 *haystack, const unsigned __int8 *needle)
{
  bool v2; // zf
  signed int v5; // r10
  size_t v6; // r0
  bool v7; // zf
  int v8; // r4
  const __int32_t *v9; // r1
  int i; // r3
  const __int32_t *v11; // r1
  int j; // r3
  unsigned __int8 *result; // r0
  _BYTE savedregs[40]; // [sp+0h] [bp+0h] BYREF

  v2 = haystack == 0;
  if ( haystack )
    v2 = needle == 0;
  if ( v2 )
    return 0;
  v5 = strlen((const char *)haystack);
  v6 = strlen((const char *)needle);
  v7 = v5 == 0;
  if ( v5 )
    v7 = v6 == 0;
  v8 = v6;
  if ( v7 )
    return 0;
  if ( v5 > 0 )
  {
    v9 = *_ctype_tolower_loc();
    for ( i = 0; i != v5; ++i )
      savedregs[i] = v9[haystack[i]];
  }
  if ( v8 > 0 )
  {
    v11 = *_ctype_tolower_loc();
    for ( j = 0; j != v8; ++j )
      savedregs[j] = v11[needle[j]];
  }
  result = (unsigned __int8 *)strstr(savedregs, savedregs);
  if ( result )
    return &haystack[result - savedregs];
  return result;
}

//----- (0001184C) --------------------------------------------------------
unsigned __int8 *__fastcall Strsep(unsigned __int8 **stringp, const unsigned __int8 *delim)
{
  unsigned __int8 *v3; // r4
  char *v4; // r0
  unsigned __int8 *v5; // r3
  unsigned __int8 *result; // r0

  v3 = *stringp;
  if ( *stringp && (v4 = strpbrk((const char *)*stringp, (const char *)delim)) != 0 )
  {
    *v4 = 0;
    v5 = (unsigned __int8 *)(v4 + 1);
    result = v3;
    *stringp = v5;
  }
  else
  {
    result = v3;
    *stringp = 0;
  }
  return result;
}

//----- (00011874) --------------------------------------------------------
void __fastcall cgtime(timeval *tv)
{
  j_gettimeofday(tv, 0);
}

//----- (0001187C) --------------------------------------------------------
int __fastcall cgtimer_to_ms(cgtimer_t *cgt)
{
  return cgt->tv_nsec / 1000000 + 1000 * cgt->tv_sec;
}

//----- (000118A0) --------------------------------------------------------
void __fastcall cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)
{
  __time_t tv_sec; // r4
  int tv_nsec; // r0
  int v5; // r3
  __time_t v6; // r1

  tv_sec = a->tv_sec;
  tv_nsec = a->tv_nsec;
  v5 = tv_nsec - b->tv_nsec;
  if ( v5 < 0 )
    tv_nsec = 51712;
  v6 = tv_sec - b->tv_sec;
  if ( v5 < 0 )
    HIWORD(tv_nsec) = 15258;
  res->tv_sec = v6;
  if ( v5 >= 0 )
  {
    res->tv_nsec = v5;
  }
  else
  {
    tv_nsec += v5;
    --v6;
  }
  if ( v5 < 0 )
  {
    res->tv_sec = v6;
    res->tv_nsec = tv_nsec;
  }
}

//----- (000118D4) --------------------------------------------------------
void __fastcall cgtimer_time(cgtimer_t *ts_start)
{
  sub_A064(1, ts_start);
}

//----- (000118DC) --------------------------------------------------------
void __fastcall cgsleep_ms_r(cgtimer_t *ts_start, int ms)
{
  timespec ts_end; // [sp+0h] [bp-10h] BYREF

  ms_to_timespec(&ts_end, ms, ms);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (00011900) --------------------------------------------------------
void __fastcall cgsleep_us_r(cgtimer_t *ts_start, int a2, int64_t us)
{
  timespec ts_end; // [sp+0h] [bp-10h] BYREF

  us_to_timespec(&ts_end, a2, us);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (00011920) --------------------------------------------------------
void __fastcall cgsleep_ms(int ms)
{
  cgtimer_t ts_start; // [sp+0h] [bp-10h] BYREF

  cgtimer_time(&ts_start);
  cgsleep_ms_r(&ts_start, ms);
}

//----- (00011938) --------------------------------------------------------
void __fastcall cgsleep_us(int64_t us)
{
  int v2; // r1
  cgtimer_t ts_start; // [sp+0h] [bp-18h] BYREF

  cgtimer_time(&ts_start);
  cgsleep_us_r(&ts_start, v2, us);
}
// 1194C: variable 'v2' is possibly undefined

//----- (00011954) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall us_tdiff(timeval *end, timeval *start)
{
  _DWORD *v2; // r1
  int v3; // r1
  char *v4; // r1
  double result; // r0

  if ( end->tv_sec - *v2 <= 60 )
  {
    end = (timeval *)end->tv_usec;
    v4 = (char *)end - *(_DWORD *)(v3 + 4);
  }
  LODWORD(result) = end;
  return result;
}
// 11954: variables would overlap: r0.4 and r0.8
// 11954: bad return variable

//----- (00011988) --------------------------------------------------------
int __fastcall ms_tdiff(timeval *end, timeval *start)
{
  int v2; // r3

  v2 = end->tv_sec - start->tv_sec;
  if ( v2 > 3600 )
    return (int)&asic_core_nonce_num[2][73][195];
  else
    return (end->tv_usec - start->tv_usec) / 1000 + 1000 * v2;
}

//----- (000119C4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall tdiff(timeval *end, timeval *start)
{
  double result; // r0

  end = (timeval *)end->tv_sec;
  LODWORD(result) = end;
  return result;
}
// 119C4: variables would overlap: r0.4 and r0.8
// 119C4: bad return variable

//----- (000119F8) --------------------------------------------------------
bool __fastcall extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port)
{
  unsigned __int8 *v4; // r4
  char *v6; // r0
  char *v7; // r5
  char *v8; // r0
  bool v9; // zf
  char *v10; // r9
  int v11; // r3
  char *v12; // r0
  const char *v13; // r11
  signed int v14; // r6
  signed int v15; // r10
  unsigned __int8 *v16; // r4
  unsigned __int8 *v17; // r5
  int v18; // r3
  int v19; // t1
  bool v20; // r3
  unsigned __int8 *v21; // r0
  int v23; // [sp+Ch] [bp-134h]
  unsigned __int8 port[6]; // [sp+10h] [bp-130h] BYREF
  unsigned __int8 url_address[256]; // [sp+18h] [bp-128h] BYREF

  *sockaddr_url = url;
  v4 = url;
  v6 = strstr((const char *)url, "//");
  if ( v6 )
    v4 = (unsigned __int8 *)(v6 + 2);
  v7 = strchr((const char *)v4, 91);
  v8 = strchr((const char *)v4, 93);
  v9 = v8 == 0;
  if ( v8 )
    v9 = v7 == 0;
  v10 = v8;
  v11 = !v9;
  v23 = v11;
  if ( v9 || v7 >= v8 )
  {
    v12 = strchr((const char *)v4, 58);
    v13 = v12;
    if ( v12 )
      goto LABEL_11;
  }
  else
  {
    v12 = strchr(v8, 58);
    v13 = v12;
    if ( v12 )
    {
LABEL_11:
      v14 = v13 - (const char *)v4;
      v15 = ~(v13 - (const char *)v4) + strlen((const char *)v4);
      if ( v15 > 0 )
      {
        ++v13;
        if ( v14 > 0 )
          goto LABEL_15;
      }
      return 0;
    }
  }
  v15 = (signed int)v12;
  v14 = strlen((const char *)v4);
  if ( v14 <= 0 )
    return 0;
LABEL_15:
  if ( v23 && v7 < v10 )
  {
    v14 -= 2;
    ++v4;
  }
  snprintf((char *)url_address, 0xFEu, "%.*s", v14, (const char *)v4);
  if ( v15 )
  {
    snprintf((char *)port, 6u, "%.*s", v15, v13);
    if ( port[0] )
    {
      if ( port[0] == 47 || port[0] == 35 )
      {
        v17 = port;
LABEL_27:
        *v17 = 0;
      }
      else
      {
        v16 = &port[1];
        while ( 1 )
        {
          v17 = v16;
          v19 = *v16++;
          v18 = v19;
          if ( !v19 )
            break;
          if ( v18 == 47 || v18 == 35 )
          {
            if ( !v17 )
              break;
            goto LABEL_27;
          }
        }
      }
    }
  }
  else
  {
    strcpy((char *)port, "80");
  }
  *sockaddr_port = (unsigned __int8 *)_strdup((const char *)port);
  v21 = (unsigned __int8 *)_strdup((const char *)url_address);
  v20 = 1;
  *sockaddr_url = v21;
  return v20;
}

//----- (00011B20) --------------------------------------------------------
unsigned __int8 *__fastcall get_proxy(unsigned __int8 *url, pool *pool)
{
  const char *name; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r8
  unsigned __int8 *v9; // r0
  const char *v10; // r1

  name = "http:";
  v4 = 0;
  v5 = 5;
  pool->rpc_proxy = 0;
  while ( strncmp((const char *)url, name, v5) )
  {
    name = (const char *)proxynames[++v4].name;
    if ( !name )
      return url;
    v5 = strlen(name);
  }
  v7 = strchr((const char *)url, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (unsigned __int8 *)cgmalloc(1 - v5 + v7 - (char *)url, "util.c", &_func___10456.__size[16], 750);
    v10 = (const char *)&url[v5];
    pool->rpc_proxy = v9;
    url = (unsigned __int8 *)(v8 + 1);
    strcpy((char *)v9, v10);
    extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
    pool->rpc_proxytype = hex2bin_tbl[2 * v4 + 264];
  }
  return url;
}

//----- (00011BC8) --------------------------------------------------------
bool __fastcall sock_full(pool *pool)
{
  unsigned __int8 *sockbuf; // r3

  sockbuf = pool->sockbuf;
  return *sockbuf || socket_full(pool, *sockbuf);
}

//----- (00011BD8) --------------------------------------------------------
void __fastcall recalloc(
        void **ptr,
        size_t old,
        size_t news,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  char *v9; // r0

  if ( news != old )
  {
    v9 = (char *)cgrealloc(*ptr, news, file, func, line);
    *ptr = v9;
    if ( news > old )
      sub_A1BC(&v9[old], 0, news - old);
  }
}

//----- (00011C14) --------------------------------------------------------
void __fastcall suspend_stratum(pool *pool)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  int sock; // r0
  int *v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Closing socket for stratum pool %d", pool->pool_no);
    applog(6, tmp42, 0);
  }
  if ( pthread_mutex_lock(&pool->stratum_lock) )
    mutex_lock_0((pthread_mutex_t *)&_func___11159, (const unsigned __int8 *)0xB9A, v2, v3);
  clear_sockbuf(pool);
  sock = pool->sock;
  pool->stratum_notify = 0;
  pool->stratum_active = 0;
  if ( sock )
    close(sock);
  pool->sock = 0;
  if ( pthread_mutex_unlock(&pool->stratum_lock) )
  {
    v5 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v5,
      "util.c",
      (const char *)&_func___11159,
      2972);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
}
// 11C94: variable 'v2' is possibly undefined
// 11C94: variable 'v3' is possibly undefined

//----- (00011CF0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned __int8 *__fastcall recv_line(pool *pool)
{
  unsigned __int8 *sockbuf; // r4
  signed int v3; // r5
  char *v4; // r0
  char *v5; // r9
  size_t v6; // r0
  signed int v7; // r4
  uint64_t v8; // r2
  uint64_t v9; // r0
  unsigned __int8 *v11; // r4
  size_t v12; // r7
  size_t v13; // r6
  size_t v14; // r0
  size_t v15; // r7
  unsigned __int8 *v16; // r0
  ssize_t v17; // r4
  int v18; // r5
  timeval rstart; // [sp+8h] [bp-2840h] BYREF
  timeval now; // [sp+10h] [bp-2838h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-2830h] BYREF
  _BYTE tmp42_0[8192]; // [sp+818h] [bp-2030h] OVERLAPPED BYREF

  sockbuf = pool->sockbuf;
  if ( !strchr((const char *)sockbuf, 10) )
  {
    cgtime(&rstart);
    if ( !socket_full(pool, 60) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(tmp42_0, "Timed out waiting for data on socket_full");
        applog(7, tmp42_0, 0);
      }
      goto LABEL_18;
    }
    while ( 1 )
    {
      memset(tmp42_0, 0, sizeof(tmp42_0));
      v17 = recv(pool->sock, tmp42_0, 0x1FFCu, 0);
      if ( !v17 )
        break;
      cgtime(&now);
      v18 = (int)((double)(now.tv_sec - rstart.tv_sec) + (double)(now.tv_usec - rstart.tv_usec) / 1000000.0);
      if ( v17 >= 0 )
      {
        v11 = pool->sockbuf;
        v12 = strlen(tmp42_0);
        v13 = strlen((const char *)v11);
        v14 = v12 + v13 + 1;
        if ( v14 >= pool->sockbuf_size )
        {
          v15 = (v14 & 0xFFFFE000) + 0x2000;
          v16 = (unsigned __int8 *)cgrealloc(v11, v15, "util.c", &_func___11159.__size[16], 1803);
          pool->sockbuf = v16;
          memset(&v16[v13], 0, v15 - v13);
          v11 = pool->sockbuf;
          pool->sockbuf_size = v15;
        }
        strcat((char *)v11, tmp42_0);
      }
      else if ( *_errno_location() != 11 || !socket_full(pool, 60 - v18) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Failed to recv sock in recv_line");
          applog(7, tmp42, 0);
        }
        goto LABEL_37;
      }
      sockbuf = pool->sockbuf;
      if ( v18 > 59 || strchr((const char *)pool->sockbuf, 10) )
        goto LABEL_2;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Socket closed waiting in recv_line");
      applog(7, tmp42, 0);
    }
LABEL_37:
    suspend_stratum(pool);
    sockbuf = pool->sockbuf;
  }
LABEL_2:
  v3 = strlen((const char *)sockbuf);
  v4 = strtok((char *)sockbuf, ptr);
  if ( !v4 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42_0, "Failed to parse a \\n terminated string in recv_line");
      applog(7, tmp42_0, 0);
    }
    goto LABEL_18;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( v3 > (int)(v6 + 1) )
    memmove(pool->sockbuf, &pool->sockbuf[v6 + 1], v3 - v6 + 1);
  else
    *pool->sockbuf = 0;
  v8 = v7 + pool->cgminer_pool_stats.net_bytes_received;
  v9 = pool->cgminer_pool_stats.times_received + 1;
  pool->cgminer_pool_stats.bytes_received += v7;
  pool->cgminer_pool_stats.net_bytes_received = v8;
  pool->cgminer_pool_stats.times_received = v9;
  if ( !v5 )
  {
LABEL_18:
    v5 = 0;
    clear_sock(pool);
    return (unsigned __int8 *)v5;
  }
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42_0, 0x800u, "RECVD: %s", v5);
    applog(7, tmp42_0, 0);
  }
  return (unsigned __int8 *)v5;
}
// 11CF0: variables would overlap: ^818.8192 and stkvar "tmp42_0" ^818.2048(has user info)

//----- (00012040) --------------------------------------------------------
bool __fastcall stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  const unsigned __int8 *v6; // r2
  int v7; // r3
  char stratum_active; // r7
  int v9; // r5
  send_ret v11; // r0
  int *v12; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "SEND: %s", (const char *)s);
    applog(7, tmp42, 0);
  }
  if ( pthread_mutex_lock(&pool->stratum_lock) )
    mutex_lock_0((pthread_mutex_t *)&_func___10687, (const unsigned __int8 *)0x698, v6, v7);
  if ( pool->stratum_active )
  {
    v11 = _stratum_send(pool, s, len);
    stratum_active = 1 - v11;
    v9 = v11;
    if ( (unsigned int)v11 > SEND_SELECTFAIL )
      stratum_active = 0;
  }
  else
  {
    stratum_active = pool->stratum_active;
    v9 = 3;
  }
  if ( pthread_mutex_unlock(&pool->stratum_lock) )
  {
    v12 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v12,
      "util.c",
      (const char *)&_func___10687,
      1694);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
  if ( v9 == 2 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Failed to send in stratum_send");
      applog(7, tmp42, 0);
      suspend_stratum(pool);
      return stratum_active;
    }
    goto LABEL_20;
  }
  if ( v9 != 3 )
  {
    if ( v9 != 1 )
      return stratum_active;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Write select failed on pool %d sock", pool->pool_no);
      applog(7, tmp42, 0);
    }
LABEL_20:
    suspend_stratum(pool);
    return stratum_active;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Stratum send failed due to no pool stratum_active");
    applog(7, tmp42, 0);
  }
  return stratum_active;
}
// 121D6: variable 'v6' is possibly undefined
// 121D6: variable 'v7' is possibly undefined

//----- (00012210) --------------------------------------------------------
void __fastcall dev_error(cgpu_info *dev, dev_reason reason)
{
  time_t v4; // r0

  v4 = time(0);
  dev->device_not_well_reason = reason;
  dev->device_last_not_well = v4;
  switch ( reason )
  {
    case REASON_THREAD_FAIL_INIT:
      ++dev->thread_fail_init_count;
      break;
    case REASON_THREAD_ZERO_HASH:
      ++dev->thread_zero_hash_count;
      break;
    case REASON_THREAD_FAIL_QUEUE:
      ++dev->thread_fail_queue_count;
      break;
    case REASON_DEV_SICK_IDLE_60:
      ++dev->dev_sick_idle_60_count;
      break;
    case REASON_DEV_DEAD_IDLE_600:
      ++dev->dev_dead_idle_600_count;
      break;
    case REASON_DEV_NOSTART:
      ++dev->dev_nostart_count;
      break;
    case REASON_DEV_OVER_HEAT:
      ++dev->dev_over_heat_count;
      break;
    case REASON_DEV_THERMAL_CUTOFF:
      ++dev->dev_thermal_cutoff_count;
      break;
    case REASON_DEV_COMMS_ERROR:
      ++dev->dev_comms_error_count;
      break;
    case REASON_DEV_THROTTLE:
      ++dev->dev_throttle_count;
      break;
    default:
      return;
  }
}

//----- (000122B0) --------------------------------------------------------
void *__fastcall realloc_strcat(unsigned __int8 *ptr, unsigned __int8 *s)
{
  size_t v4; // r5
  unsigned __int8 *v5; // r0
  unsigned int v6; // r0
  char *v7; // r0
  unsigned __int8 *v8; // r5
  unsigned __int8 *v9; // r0

  v4 = strlen((const char *)s);
  if ( v4 )
  {
    v5 = ptr;
    if ( ptr )
      v5 = (unsigned __int8 *)strlen((const char *)ptr);
    v6 = (unsigned int)&v5[v4 + 1];
    if ( v6 << 30 )
      v6 = (v6 & 0xFFFFFFFC) + 4;
    v7 = (char *)cgmalloc(v6, "util.c", &_func___10687.__size[16], 3210);
    v8 = (unsigned __int8 *)v7;
    if ( ptr )
    {
      sprintf(v7, "%s%s", (const char *)ptr, (const char *)s);
      v9 = ptr;
      ptr = v8;
      free(v9);
    }
    else
    {
      ptr = (unsigned __int8 *)v7;
      strcpy(v7, (const char *)s);
    }
  }
  return ptr;
}

//----- (00012314) --------------------------------------------------------
void *__fastcall str_text(unsigned __int8 *ptr)
{
  unsigned __int8 *v1; // r4
  size_t v2; // r0
  char *v3; // r6
  char *v4; // r5
  char v5; // r3
  int v6; // r2
  int v7; // t1
  char *v9; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  v1 = ptr;
  if ( !ptr )
  {
    v9 = (char *)malloc(7u);
    if ( !v9 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to malloc null in %s %s():%d",
        "util.c",
        (const char *)_func___11242,
        3235);
      applog(3, tmp42, 1);
      quit(1);
    }
    strcpy(v9, "(null)");
  }
  v2 = strlen((const char *)v1);
  v3 = (char *)cgmalloc(4 * v2 + 5, "util.c", _func___11242, 3240);
  v4 = v3;
  do
  {
    while ( 1 )
    {
      v7 = *v1++;
      v6 = v7;
      if ( (unsigned int)(v7 - 32) <= 0x5E )
        break;
      sprintf(v4, "0x%02x", v6);
      v5 = *(v1 - 1);
      v4 += 4;
      if ( !v5 )
        goto LABEL_7;
    }
    *v4++ = v6;
    v5 = *(v1 - 1);
  }
  while ( v5 );
LABEL_7:
  *v4 = v5;
  return v3;
}

//----- (000123CC) --------------------------------------------------------
void __fastcall RenameThread(const unsigned __int8 *name)
{
  unsigned __int8 buf[16]; // [sp+8h] [bp-18h] BYREF

  snprintf((char *)buf, 0x10u, "cg@%s", (const char *)name);
  prctl(15, buf, 0);
}

//----- (000123F4) --------------------------------------------------------
void __fastcall cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int v7; // r4
  int *v8; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v7 = sem_init(cgsem, 0, 0);
  if ( v7 )
  {
    v8 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_init ret=%d errno=%d in %s %s():%d",
      v7,
      *v8,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00012444) --------------------------------------------------------
int __fastcall thr_info_create(thr_info *thr, pthread_attr_t *attr, void *(*start)(void *), void *arg)
{
  cgsem_init(&thr->sem, "util.c", _func___10474, 1191);
  return j_pthread_create(&thr->pth, attr, start, arg);
}

//----- (0001247C) --------------------------------------------------------
void __fastcall cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v8; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  if ( sem_post(cgsem) )
  {
    v8 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d",
      *v8,
      cgsem,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000124CC) --------------------------------------------------------
void *__fastcall completion_thread(void *arg)
{
  pthread_setcanceltype(1, 0);
  (*((void (__fastcall **)(_DWORD))arg + 4))(*((_DWORD *)arg + 5));
  cgsem_post((cgsem_t *)arg, "util.c", _func___11303, 3466);
  return 0;
}

//----- (000124FC) --------------------------------------------------------
void __fastcall cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int v8; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  while ( sem_wait(cgsem) )
  {
    v8 = *_errno_location();
    if ( v8 != 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d",
        v8,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (00012550) --------------------------------------------------------
int __fastcall cgsem_mswait(
        cgsem_t *cgsem,
        int ms,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int result; // r0
  int v10; // r3
  timespec abs_timeout; // [sp+10h] [bp-830h] BYREF
  timespec ts_now; // [sp+18h] [bp-828h] BYREF
  timeval tv_now; // [sp+20h] [bp-820h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+28h] [bp-818h] BYREF

  cgtime(&tv_now);
  ts_now.tv_sec = tv_now.tv_sec;
  ts_now.tv_nsec = 1000 * tv_now.tv_usec;
  ms_to_timespec(&abs_timeout, 1000 * tv_now.tv_usec, ms);
  while ( 1 )
  {
    timeraddspec(&abs_timeout, &ts_now);
    result = sem_timedwait(cgsem, &abs_timeout);
    if ( !result )
      break;
    v10 = *_errno_location();
    if ( v10 == 110 )
      return 110;
    if ( v10 != 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        v10,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  return result;
}

//----- (000125DC) --------------------------------------------------------
void __fastcall cgsem_reset(cgsem_t *cgsem)
{
  int v2; // r0

  do
  {
    while ( 1 )
    {
      v2 = sem_trywait(cgsem);
      if ( v2 < 0 )
        break;
      if ( v2 )
        return;
    }
  }
  while ( *_errno_location() == 4 );
}

//----- (00012600) --------------------------------------------------------
bool __fastcall cg_completion_timeout(void *fn, void *fnarg, int timeout)
{
  cgsem_t *v6; // r4
  _BOOL4 v7; // r5
  pthread_t pthread; // [sp+Ch] [bp-1Ch] BYREF

  v6 = (cgsem_t *)cgmalloc(0x18u, "util.c", _func___11312, 3477);
  cgsem_init(v6, "util.c", _func___11312, 3478);
  *(&v6[1].__align + 1) = (int)fnarg;
  v6[1].__align = (int)fn;
  pthread_create(&pthread, 0, completion_thread, v6);
  v7 = cgsem_mswait(v6, timeout, "util.c", _func___11312, 3484) != 0;
  if ( v7 )
  {
    pthread_cancel(pthread);
  }
  else
  {
    pthread_join(pthread, 0);
    free(v6);
  }
  return !v7;
}

//----- (00012678) --------------------------------------------------------
void __fastcall cg_memcpy(
        void *dest,
        const void *src,
        unsigned int n,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  if ( (int)(n - 1) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "ERR: Asked to memcpy %u bytes from %s %s():%d", n, file, func, line);
LABEL_9:
      applog(3, tmp42, 0);
    }
  }
  else if ( dest )
  {
    if ( src )
    {
      j_memcpy(dest, src, n);
      return;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d", n, file, func, line);
      goto LABEL_9;
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d", n, file, func, line);
    goto LABEL_9;
  }
}

//----- (00012744) --------------------------------------------------------
bool __fastcall socks4_negotiate(pool *pool, int sockd, bool socks4a)
{
  _BOOL4 v5; // r7
  unsigned __int8 *stratum_port; // r0
  __int16 v7; // kr00_2
  unsigned int v8; // r5
  int v10; // r4
  unsigned __int8 *sockaddr_url; // r0
  unsigned __int8 *v12; // r9
  signed int v13; // r0
  unsigned int v14; // r7
  unsigned int v15; // r5
  addrinfo *servinfo; // [sp+8h] [bp-A48h] BYREF
  addrinfo servinfobase; // [sp+Ch] [bp-A44h] BYREF
  unsigned __int8 buf[515]; // [sp+2Ch] [bp-A24h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+230h] [bp-820h] BYREF

  v5 = socks4a;
  stratum_port = pool->stratum_port;
  buf[0] = 4;
  buf[1] = 1;
  v7 = strtol((const char *)stratum_port, 0, 10);
  buf[2] = HIBYTE(v7);
  buf[3] = v7;
  strcpy((char *)&buf[8], "CGMINER");
  v8 = bswap32(inet_addr((const char *)pool->sockaddr_url));
  if ( v8 != -1 )
    goto LABEL_2;
  sockaddr_url = pool->sockaddr_url;
  memset(&tmp42[8], 0, 24);
  *(_DWORD *)tmp42 = 0;
  *(_DWORD *)&tmp42[4] = 2;
  servinfo = &servinfobase;
  if ( !getaddrinfo((const char *)sockaddr_url, 0, (const struct addrinfo *)tmp42, &servinfo) )
  {
    v15 = *(_DWORD *)&servinfo->ai_addr->sa_data[2];
    freeaddrinfo(servinfo);
    v8 = bswap32(v15);
    if ( v8 != -1 )
    {
LABEL_2:
      buf[7] = v8;
      buf[4] = HIBYTE(v8);
      buf[5] = BYTE2(v8);
      buf[6] = BYTE1(v8);
      send(sockd, buf, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_22:
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      return 0;
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid IP address specified for socks4 proxy: %s",
      (const char *)pool->sockaddr_url);
    goto LABEL_8;
  }
  if ( !v5 )
    goto LABEL_22;
  v12 = pool->sockaddr_url;
  buf[4] = 0;
  buf[5] = 0;
  buf[6] = 0;
  buf[7] = 1;
  v13 = strlen((const char *)v12);
  if ( v13 >= 255 )
    v14 = 255;
  else
    v14 = v13;
  cg_memcpy(&buf[16], v12, v14, "util.c", _func___11082, 2738);
  buf[v14 + 16] = 0;
  send(sockd, buf, v14 + 17, 0);
LABEL_3:
  if ( recv_byte(sockd) || recv_byte(sockd) != 90 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      return 0;
    snprintf(
      (char *)tmp42,
      0x800u,
      "Bad response from %s:%s SOCKS4 server",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port);
LABEL_8:
    applog(4, tmp42, 0);
    return 0;
  }
  v10 = 6;
  do
  {
    recv_byte(sockd);
    --v10;
  }
  while ( v10 );
  return 1;
}

//----- (000128F8) --------------------------------------------------------
bool __fastcall initiate_stratum(pool *pool)
{
  int i; // r0
  const unsigned __int8 *v3; // r2
  int v4; // r3
  int v5; // r5
  const unsigned __int8 *v6; // r2
  int v7; // r3
  size_t refcount; // r3
  size_t v9; // r3
  int sock; // r0
  unsigned __int8 *rpc_proxy; // r2
  int v12; // r0
  struct addrinfo *v13; // r4
  int v14; // r0
  int v15; // r1
  int v16; // r2
  __int16 v17; // r3
  unsigned __int8 *v18; // r5
  int v19; // r0
  int v20; // r8
  int v21; // r0
  unsigned int v22; // r6
  int *v23; // r10
  int v24; // r7
  int v25; // r0
  int v26; // r0
  unsigned __int8 *sessionid; // r3
  int v28; // r2
  size_t v29; // r0
  unsigned __int8 *v30; // r0
  unsigned __int8 *v31; // r3
  int v32; // r2
  bool v33; // r4
  size_t v34; // r3
  size_t v35; // r3
  unsigned __int8 *v37; // r0
  unsigned __int8 *v38; // r5
  json_t_0 *v39; // r5
  json_t_0 *v40; // r0
  unsigned __int8 *v41; // r6
  char *v42; // r0
  int v43; // r0
  unsigned __int8 *sockaddr_url; // r9
  signed int v45; // r0
  unsigned int v46; // r7
  __int16 v47; // r0
  char *v48; // r4
  json_t_0 *v49; // r0
  const json_t_0 *v50; // r8
  signed int v51; // r7
  size_t v52; // r4
  json_t_0 *v53; // r0
  json_t_0 *v54; // r9
  _BOOL4 v55; // r3
  unsigned __int8 *v56; // r7
  unsigned __int8 *v57; // r6
  int v58; // r3
  unsigned __int8 *v59; // r0
  json_t_0 *v60; // r0
  unsigned int v61; // r0
  unsigned int v62; // r5
  unsigned __int8 *v63; // r1
  const unsigned __int8 *v64; // r2
  int v65; // r3
  size_t v66; // r3
  unsigned __int8 *nonce1bin; // r0
  unsigned __int8 *v68; // r0
  unsigned __int8 *nonce1; // r1
  int v70; // r3
  _BOOL4 v71; // r3
  int *v72; // r0
  int *v73; // r0
  int v74; // r4
  char v75; // r0
  int v76; // r5
  int *v77; // r0
  int *v78; // r0
  int *v79; // r0
  int *v80; // r0
  json_t_0 *val; // [sp+1Ch] [bp-2B7Ch]
  char *name; // [sp+20h] [bp-2B78h]
  char *service; // [sp+24h] [bp-2B74h]
  int noresume; // [sp+28h] [bp-2B70h]
  pthread_mutex_t *mutex; // [sp+2Ch] [bp-2B6Ch]
  int recvd; // [sp+30h] [bp-2B68h]
  struct addrinfo *pai; // [sp+38h] [bp-2B60h] BYREF
  int v88; // [sp+3Ch] [bp-2B5Ch] BYREF
  socklen_t optlen; // [sp+40h] [bp-2B58h] BYREF
  int optval; // [sp+44h] [bp-2B54h] BYREF
  struct timeval timeout; // [sp+48h] [bp-2B50h] BYREF
  struct addrinfo req; // [sp+50h] [bp-2B48h] BYREF
  json_error_t err; // [sp+70h] [bp-2B28h] BYREF
  fd_set writefds; // [sp+16Ch] [bp-2A2Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+370h] [bp-2828h] BYREF
  unsigned __int8 s[8192]; // [sp+B70h] [bp-2028h] BYREF

  val = 0;
  mutex = &pool->stratum_lock;
  noresume = 0;
  recvd = 0;
  for ( i = pthread_mutex_lock(&pool->stratum_lock); ; i = pthread_mutex_lock(mutex) )
  {
    if ( i )
      mutex_lock_0((pthread_mutex_t *)&_func___11107, (const unsigned __int8 *)0xAE1, v3, v4);
    sock = pool->sock;
    pool->stratum_active = 0;
    if ( sock )
      close(sock);
    pool->sock = 0;
    if ( pthread_mutex_unlock(mutex) )
    {
      v79 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v79,
        "util.c",
        (const char *)&_func___11107,
        2790);
      applog(3, tmp42, 1);
      quit(1);
    }
    selective_yield();
    rpc_proxy = pool->rpc_proxy;
    req.ai_flags = 0;
    req.ai_family = 0;
    memset(&req.ai_protocol, 0, 20);
    req.ai_socktype = 1;
    if ( rpc_proxy
      || (v30 = opt_socks_proxy) != 0
      && (pool->rpc_proxy = opt_socks_proxy,
          extract_sockaddr(v30, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port),
          v31 = pool->rpc_proxy,
          pool->rpc_proxytype = 3,
          v31) )
    {
      name = (char *)pool->sockaddr_proxy_url;
      service = (char *)pool->sockaddr_proxy_port;
      v12 = getaddrinfo(name, service, &req, &pai);
    }
    else
    {
      name = (char *)pool->sockaddr_url;
      service = (char *)pool->stratum_port;
      v12 = getaddrinfo(name, service, &req, &pai);
    }
    if ( v12 )
    {
      if ( pool->probed )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Failed to getaddrinfo for %s:%s", name, service);
          applog(6, tmp42, 0);
        }
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf((char *)tmp42, 0x800u, "Failed to resolve (?wrong URL) %s:%s", name, service);
          applog(4, tmp42, 0);
        }
        pool->probed = 1;
      }
      goto LABEL_8;
    }
    v13 = pai;
    if ( !pai )
    {
LABEL_58:
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "Failed to connect to stratum on %s:%s", name, service);
        applog(6, tmp42, 0);
      }
      freeaddrinfo(pai);
      goto LABEL_8;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v19 = socket(v13->ai_family, v13->ai_socktype, v13->ai_protocol);
        v20 = v19;
        if ( v19 != -1 )
          break;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          v14 = *(_DWORD *)"Failed socket";
          v15 = *(_DWORD *)"ed socket";
          v16 = *(_DWORD *)"ocket";
          v17 = *(_WORD *)"t";
          v18 = tmp42;
          goto LABEL_38;
        }
LABEL_39:
        v13 = v13->ai_next;
        if ( !v13 )
          goto LABEL_58;
      }
      v21 = fcntl(v19, 3, 0);
      fcntl(v20, 4, v21 | 0x800);
      if ( connect(v20, v13->ai_addr, v13->ai_addrlen) != -1 )
        break;
      v22 = 0;
      timeout.tv_usec = 0;
      timeout.tv_sec = 1;
      v23 = _errno_location();
      if ( *v23 == 115 )
      {
        v24 = v20 / 32;
        while ( 1 )
        {
          if ( v22 > 0x1F )
          {
            writefds.fds_bits[v24] |= 1 << (v20 % 32);
            v25 = select(v20 + 1, 0, &writefds, 0, &timeout);
            if ( v25 > 0 )
            {
              if ( ((writefds.fds_bits[v24] >> (v20 % 32)) & 1) != 0 )
              {
                optlen = 4;
                if ( !getsockopt(v20, 1, 4, &optval, &optlen) && !optval )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    strcpy((char *)tmp42, "Succeeded delayed connect");
                    applog(7, tmp42, 0);
                  }
                  goto LABEL_72;
                }
              }
LABEL_47:
              close(v20);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                qmemcpy(tmp42, "Select timeout/f", 16);
                v18 = &tmp42[16];
                v14 = *(_DWORD *)"ailed connect";
                v15 = *(_DWORD *)"d connect";
                v16 = *(_DWORD *)"nnect";
                v17 = *(_WORD *)"t";
LABEL_38:
                *(_DWORD *)v18 = v14;
                *((_DWORD *)v18 + 1) = v15;
                *((_DWORD *)v18 + 2) = v16;
                *((_WORD *)v18 + 6) = v17;
                applog(7, tmp42, 0);
              }
              goto LABEL_39;
            }
            v22 = 0;
            if ( !v25 || *v23 != 4 )
              goto LABEL_47;
          }
          writefds.fds_bits[v22++] = 0;
        }
      }
      close(v20);
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_39;
      strcpy((char *)tmp42, "Failed sock connect");
      applog(7, tmp42, 0);
      v13 = v13->ai_next;
      if ( !v13 )
        goto LABEL_58;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Succeeded immediate connect");
      applog(4, tmp42, 0);
    }
LABEL_72:
    block_socket(v20);
    freeaddrinfo(pai);
    if ( pool->rpc_proxy )
    {
      switch ( pool->rpc_proxytype )
      {
        case 0:
          if ( !http_negotiate(pool, v20, 0) )
            goto LABEL_8;
          break;
        case 1:
          if ( !http_negotiate(pool, v20, 1) )
            goto LABEL_8;
          break;
        case 2:
          if ( !socks4_negotiate(pool, v20, 0) )
            goto LABEL_8;
          if ( !pool->sockbuf )
            goto LABEL_107;
          goto LABEL_85;
        case 3:
        case 5:
          LOWORD(writefds.fds_bits[0]) = 261;
          BYTE2(writefds.fds_bits[0]) = 0;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Attempting to negotiate with %s:%s SOCKS5 proxy",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(7, tmp42, 0);
          }
          send(v20, &writefds, 3u, 0);
          if ( recv_byte(v20) != 5 )
            goto LABEL_101;
          v43 = recv_byte(v20);
          if ( v43 != BYTE2(writefds.fds_bits[0]) )
            goto LABEL_101;
          sockaddr_url = pool->sockaddr_url;
          LOBYTE(writefds.fds_bits[0]) = 5;
          *(_WORD *)((char *)writefds.fds_bits + 1) = 1;
          HIBYTE(writefds.fds_bits[0]) = 3;
          v45 = strlen((const char *)sockaddr_url);
          if ( v45 >= 255 )
            v46 = 255;
          else
            v46 = v45;
          LOBYTE(writefds.fds_bits[1]) = v46;
          cg_memcpy((char *)&writefds.fds_bits[1] + 1, sockaddr_url, v46, "util.c", "socks5_negotiate", 2636);
          v47 = strtol((const char *)pool->stratum_port, 0, 10);
          v48 = (char *)&writefds + v46;
          v48[6] = v47;
          v48[5] = HIBYTE(v47);
          send(v20, &writefds, v46 + 7, 0);
          if ( recv_byte(v20) != 5 || (v74 = recv_byte(v20)) != 0 )
          {
            if ( use_syslog )
              goto LABEL_104;
            goto LABEL_102;
          }
          recv_byte(v20);
          v75 = recv_byte(v20);
          if ( v75 == 1 )
          {
            recv_byte(v20);
            recv_byte(v20);
            recv_byte(v20);
            recv_byte(v20);
          }
          else
          {
            if ( v75 != 3 )
            {
LABEL_101:
              if ( use_syslog )
                goto LABEL_104;
LABEL_102:
              if ( opt_log_output || opt_log_level > 3 )
              {
LABEL_104:
                snprintf(
                  (char *)tmp42,
                  0x800u,
                  "Bad response from %s:%s SOCKS5 server",
                  (const char *)pool->sockaddr_proxy_url,
                  (const char *)pool->sockaddr_proxy_port);
                applog(4, tmp42, 0);
              }
LABEL_8:
              v5 = 0;
              goto LABEL_9;
            }
            v76 = recv_byte(v20);
            if ( v76 > 0 )
            {
              do
              {
                ++v74;
                recv_byte(v20);
              }
              while ( v74 != v76 );
            }
          }
          recv_byte(v20);
          recv_byte(v20);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Success negotiating with %s:%s SOCKS5 proxy",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(7, tmp42, 0);
          }
          break;
        case 4:
          if ( socks4_negotiate(pool, v20, 1) )
            break;
          goto LABEL_8;
        default:
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Unsupported proxy type for %s:%s",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(4, tmp42, 0);
          }
          goto LABEL_8;
      }
    }
    if ( !pool->sockbuf )
    {
LABEL_107:
      pool->sockbuf = (unsigned __int8 *)cgcalloc(0x2000, 1u, "util.c", (const unsigned __int8 *)&_func___11107, 2927);
      pool->sockbuf_size = 0x2000;
    }
LABEL_85:
    pool->sock = v20;
    optval = 30;
    v88 = 1;
    optlen = 45;
    v26 = fcntl(v20, 3, 0);
    fcntl(v20, 4, v26 | 0x800);
    setsockopt(v20, 1, 9, &v88, 4u);
    if ( !opt_delaynet )
      fcntl(v20, 2, 1);
    setsockopt(v20, 6, 1, &v88, 4u);
    setsockopt(v20, 6, 6, &v88, 4u);
    setsockopt(v20, 6, 4, &optlen, 4u);
    setsockopt(v20, 6, 5, &optval, 4u);
    if ( recvd )
    {
      clear_sock(pool);
      v32 = swork_id++;
      sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v32);
    }
    else
    {
      sessionid = pool->sessionid;
      v28 = swork_id++;
      if ( sessionid )
        sprintf(
          (char *)s,
          "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"bmminer/2.0.0\", \"%s\"]}",
          v28,
          (const char *)sessionid);
      else
        sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"bmminer/2.0.0\"]}", v28);
    }
    v29 = strlen((const char *)s);
    if ( _stratum_send(pool, s, v29) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        v5 = 1;
        strcpy((char *)tmp42, "Failed to send s in initiate_stratum");
        applog(7, tmp42, 0);
        goto LABEL_9;
      }
LABEL_121:
      v5 = 1;
      goto LABEL_9;
    }
    if ( socket_full(pool, 60) )
      break;
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      goto LABEL_121;
    v5 = 1;
    strcpy((char *)tmp42, "Timed out waiting for response in initiate_stratum");
    applog(7, tmp42, 0);
LABEL_9:
    if ( (recvd & (noresume ^ 1)) == 0 )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Initiate stratum failed");
        applog(7, tmp42, 0);
      }
      if ( v5 )
      {
        suspend_stratum(pool);
        if ( val )
          goto LABEL_133;
      }
      else if ( val )
      {
LABEL_133:
        v33 = 0;
        goto LABEL_134;
      }
      return (char)val;
    }
    if ( pthread_mutex_lock(&pool->data_lock.mutex) )
      mutex_lock_0((pthread_mutex_t *)&_func___11187, (const unsigned __int8 *)0xC2A, v6, v7);
    if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
    {
      v77 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v77,
        "util.c",
        (const char *)&_func___11187,
        3114);
      applog(3, tmp42, 1);
      quit(1);
    }
    free(pool->sessionid);
    free(pool->nonce1);
    pool->nonce1 = 0;
    pool->sessionid = 0;
    if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
    {
      v78 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v78,
        "util.c",
        (const char *)&_func___11187,
        3118);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
    {
      v80 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v80,
        "util.c",
        (const char *)&_func___11187,
        3118);
      applog(3, tmp42, 1);
      quit(1);
    }
    selective_yield();
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Failed to resume stratum, trying afresh");
      applog(7, tmp42, 0);
    }
    if ( val )
    {
      refcount = val->refcount;
      if ( refcount != -1 )
      {
        v9 = refcount - 1;
        val->refcount = v9;
        if ( !v9 )
          json_delete(val);
      }
    }
    noresume = 1;
  }
  v37 = recv_line(pool);
  v38 = v37;
  if ( !v37 )
  {
    v5 = 1;
    goto LABEL_9;
  }
  val = json_loads(v37, 0, &err);
  free(v38);
  if ( !val )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v5 = 1;
      snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
      applog(6, tmp42, 0);
      recvd = 1;
    }
    else
    {
      recvd = 1;
      v5 = 1;
    }
    goto LABEL_9;
  }
  v39 = json_object_get(val, "result");
  v40 = json_object_get(val, (const unsigned __int8 *)"error");
  if ( !v39 || v39->type == JSON_NULL )
  {
    if ( v40 )
    {
LABEL_148:
      v41 = json_dumps(v40, 3u);
    }
    else
    {
      v41 = 0;
      v42 = (char *)malloc(0x11u);
      if ( v42 )
      {
        v41 = (unsigned __int8 *)v42;
        strcpy(v42, "(unknown reason)");
      }
    }
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "JSON-RPC decode failed: %s", (const char *)v41);
      applog(6, tmp42, 0);
    }
    v5 = 1;
    free(v41);
    recvd = 1;
    goto LABEL_9;
  }
  if ( v40 && v40->type != JSON_NULL )
    goto LABEL_148;
  v49 = json_array_get(v39, 0);
  v50 = v49;
  if ( v49 )
  {
    if ( v49->type == JSON_ARRAY )
    {
      v51 = json_array_size(v49);
      if ( v51 > 0 )
      {
        v52 = 0;
        do
        {
          v53 = json_array_get(v50, v52);
          v54 = v53;
          if ( !v53 || v53->type != JSON_ARRAY )
            break;
          ++v52;
          v59 = _json_array_string(v53, 0);
          if ( v59 && !strncasecmp((const char *)v59, "mining.notify", 0xDu) )
          {
            v56 = json_array_string(v54, 1u);
            if ( v56 )
              goto LABEL_184;
            break;
          }
        }
        while ( v51 != v52 );
      }
    }
  }
  v55 = opt_debug;
  if ( opt_debug && (use_syslog || (v55 = opt_log_output) || opt_log_level > 6) )
  {
    v56 = 0;
    strcpy((char *)tmp42, "Failed to get sessionid in initiate_stratum");
    applog(7, tmp42, 0);
  }
  else
  {
    v56 = (unsigned __int8 *)v55;
  }
LABEL_184:
  v57 = json_array_string(v39, 1u);
  if ( !valid_hex(v57, (const unsigned __int8 *)&_func___11187, (const unsigned __int8 *)0xBF0, v58) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Failed to get valid nonce1 in initiate_stratum");
      applog(6, tmp42, 0);
    }
    v5 = 1;
    free(v56);
    recvd = 1;
    goto LABEL_9;
  }
  v60 = json_array_get(v39, 2u);
  v61 = json_integer_value(v60);
  if ( v61 - 2 > 0xE )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Failed to get valid n2size in initiate_stratum");
      applog(6, tmp42, 0);
    }
    v5 = 1;
    free(v56);
    free(v57);
    recvd = 1;
    goto LABEL_9;
  }
  v62 = v61;
  if ( v56 )
  {
    v63 = pool->sessionid;
    if ( v63 )
    {
      if ( !strcmp((const char *)v56, (const char *)v63) && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d successfully negotiated resume with the same session ID",
          pool->pool_no);
        applog(5, tmp42, 0);
      }
    }
  }
  if ( pthread_mutex_lock(&pool->data_lock.mutex) )
    mutex_lock_0((pthread_mutex_t *)&_func___11187, (const unsigned __int8 *)0xC04, v64, v65);
  if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
  {
    v72 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v72,
      "util.c",
      (const char *)&_func___11187,
      3076);
    applog(3, tmp42, 1);
    quit(1);
  }
  free(pool->nonce1);
  free(pool->sessionid);
  pool->nonce1 = v57;
  pool->sessionid = v56;
  v66 = strlen((const char *)v57) >> 1;
  nonce1bin = pool->nonce1bin;
  pool->n1_len = v66;
  free(nonce1bin);
  v68 = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", (const unsigned __int8 *)&_func___11187, 3083);
  nonce1 = pool->nonce1;
  pool->nonce1bin = v68;
  hex2bin(v68, nonce1, pool->n1_len);
  pool->n2size = v62;
  if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
  {
    v73 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v73,
      "util.c",
      (const char *)&_func___11187,
      3086);
    applog(3, tmp42, 1);
    quit(1);
  }
  mutex_unlock_noyield_0(
    &pool->data_lock.mutex,
    (const unsigned __int8 *)&_func___11187,
    (const unsigned __int8 *)0xC0E,
    v70);
  selective_yield();
  if ( v56 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stratum session id: %s", pool->pool_no, (const char *)pool->sessionid);
    applog(7, tmp42, 0);
  }
  if ( !pool->stratum_url )
    pool->stratum_url = pool->sockaddr_url;
  v71 = opt_protocol;
  pool->next_diff = 0.0;
  pool->stratum_active = 1;
  pool->sdiff = 1.0;
  if ( v71 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
      pool->pool_no,
      (const char *)pool->nonce1,
      pool->n2size);
    applog(7, tmp42, 0);
  }
  v33 = 1;
LABEL_134:
  v34 = val->refcount;
  if ( v34 != -1 )
  {
    v35 = v34 - 1;
    val->refcount = v35;
    if ( !v35 )
      json_delete(val);
  }
  return v33;
}
// 13464: variable 'v58' is possibly undefined
// 13656: variable 'v70' is possibly undefined
// 13764: variable 'v64' is possibly undefined
// 13764: variable 'v65' is possibly undefined
// 138FA: variable 'v6' is possibly undefined
// 138FA: variable 'v7' is possibly undefined
// 13942: variable 'v3' is possibly undefined
// 13942: variable 'v4' is possibly undefined

//----- (00013994) --------------------------------------------------------
bool __fastcall parse_notify(pool *pool, json_t_0 *val)
{
  json_t_0 *v4; // r0
  json_t_0 *v5; // r4
  _BOOL4 v6; // r6
  unsigned __int8 *v8; // r8
  unsigned __int8 *v9; // r9
  unsigned __int8 *v10; // r10
  signed int v11; // r0
  int v12; // r3
  unsigned __int8 *v13; // r1
  int v14; // t1
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int v19; // r3
  const unsigned __int8 *v20; // r2
  int v21; // r3
  unsigned __int8 *v22; // r0
  unsigned __int8 *v23; // r3
  double next_diff; // d7
  unsigned int n2size; // r1
  int v26; // r2
  int v27; // r3
  int v28; // r6
  unsigned int v29; // r1
  unsigned __int8 *v30; // r0
  unsigned __int8 *v31; // r0
  unsigned int n1_len; // r3
  int v33; // r3
  int v34; // r3
  const char *v35; // r3
  int64_t v36; // r2
  const char *v37; // lr
  int v38; // r0
  int v39; // r1
  int v40; // r2
  int v41; // r3
  int *v42; // lr
  int v43; // r0
  int v44; // r1
  int v45; // r2
  int v46; // r3
  int v47; // r0
  int v48; // r1
  int v49; // r2
  int v50; // r3
  int v51; // lr
  unsigned __int8 *v52; // r0
  unsigned __int8 *v53; // r4
  int v54; // r6
  unsigned int v55; // r9
  unsigned __int8 *v56; // r8
  unsigned __int8 **merkle_bin; // r6
  unsigned __int8 *v58; // r0
  _BOOL4 v59; // r3
  const char *v60; // lr
  int v61; // r0
  int v62; // r1
  int v63; // r2
  int v64; // r3
  int *v65; // lr
  int v66; // r0
  int v67; // r1
  int v68; // r2
  int v69; // r3
  int v70; // r0
  int v71; // r1
  int v72; // r2
  int v73; // r3
  int v74; // r1
  int v75; // r4
  unsigned __int8 p[4]; // [sp+18h] [bp+0h] BYREF
  unsigned int v77; // [sp+1Ch] [bp+4h]
  unsigned __int8 *coinbase1; // [sp+20h] [bp+8h]
  unsigned __int8 *job_id; // [sp+24h] [bp+Ch]
  pthread_rwlock_t *lock; // [sp+28h] [bp+10h]
  pthread_mutex_t *p_mutex; // [sp+2Ch] [bp+14h]
  size_t alloc_len; // [sp+30h] [bp+18h]
  char *v83; // [sp+34h] [bp+1Ch]
  char *v84; // [sp+38h] [bp+20h]
  char *v85; // [sp+3Ch] [bp+24h]
  char *s; // [sp+40h] [bp+28h]
  bool *v87; // [sp+44h] [bp+2Ch]
  size_t cb2_len; // [sp+48h] [bp+30h]
  size_t cb1_len; // [sp+4Ch] [bp+34h]
  _BOOL4 clean; // [sp+50h] [bp+38h]
  unsigned __int8 *ntime; // [sp+54h] [bp+3Ch]
  unsigned __int8 *nbit; // [sp+58h] [bp+40h]
  unsigned __int8 *bbversion; // [sp+5Ch] [bp+44h]
  int merkles; // [sp+60h] [bp+48h]
  unsigned __int8 *prev_hash; // [sp+64h] [bp+4Ch]
  unsigned __int8 header[228]; // [sp+6Ch] [bp+54h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+150h] [bp+138h] BYREF

  v4 = json_array_get(val, 4u);
  v5 = v4;
  if ( !v4 )
  {
    LOBYTE(v6) = 0;
    return v6;
  }
  if ( v4->type != JSON_ARRAY )
  {
    LOBYTE(v6) = 0;
    return v6;
  }
  merkles = json_array_size(v4);
  v8 = json_array_string(val, 0);
  prev_hash = _json_array_string(val, 1u);
  v9 = json_array_string(val, 2u);
  v10 = json_array_string(val, 3u);
  bbversion = _json_array_string(val, 5u);
  nbit = _json_array_string(val, 6u);
  ntime = _json_array_string(val, 7u);
  if ( json_array_get(val, 8u) )
    clean = json_array_get(val, 8u)->type == JSON_TRUE;
  else
    clean = 0;
  if ( !v8 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      goto LABEL_17;
    snprintf(
      (char *)tmp42,
      0x800u,
      "Null string passed to valid_ascii from",
      " in %s %s():%d",
      "util.c",
      &_func___11187.__align + 5,
      1947);
LABEL_102:
    applog(3, tmp42, 0);
    goto LABEL_17;
  }
  v11 = strlen((const char *)v8);
  if ( !v11 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      goto LABEL_17;
    snprintf(
      (char *)tmp42,
      0x800u,
      "Zero length string passed to valid_ascii from",
      " in %s %s():%d",
      "util.c",
      &_func___11187.__align + 5,
      1947);
    goto LABEL_102;
  }
  if ( v11 > 0 )
  {
    if ( (unsigned int)*v8 - 32 > 0x5E )
    {
LABEL_81:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Invalid char 0x%x passed to valid_ascii from", " in %s %s():%d");
        applog(3, tmp42, 0);
      }
      goto LABEL_17;
    }
    v13 = v8;
    v12 = 0;
    while ( v11 != ++v12 )
    {
      v14 = *++v13;
      if ( (unsigned int)(v14 - 32) > 0x5E )
        goto LABEL_81;
    }
  }
  if ( !valid_hex(prev_hash, &_func___11187.__size[20], (const unsigned __int8 *)0x79B, v12)
    || !valid_hex(v9, &_func___11187.__size[20], (const unsigned __int8 *)0x79B, v15)
    || !valid_hex(v10, &_func___11187.__size[20], (const unsigned __int8 *)0x79C, v16)
    || !valid_hex(bbversion, &_func___11187.__size[20], (const unsigned __int8 *)0x79C, v17)
    || !valid_hex(nbit, &_func___11187.__size[20], (const unsigned __int8 *)0x79C, v18)
    || !valid_hex(ntime, &_func___11187.__size[20], (const unsigned __int8 *)0x79D, v19) )
  {
LABEL_17:
    LOBYTE(v6) = 0;
    free(v8);
    free(v9);
    free(v10);
    return v6;
  }
  p_mutex = &pool->data_lock.mutex;
  if ( pthread_mutex_lock(&pool->data_lock.mutex) )
    mutex_lock_0((pthread_mutex_t *)&_func___11187.__size[20], (const unsigned __int8 *)0x7A6, v20, v21);
  lock = &pool->data_lock.rwlock;
  wr_lock(&pool->data_lock.rwlock, &_func___11187.__size[20], (const unsigned __int8 *)0x7A6, v21);
  v22 = pool->swork.job_id;
  s = (char *)pool->prev_hash;
  free(v22);
  v23 = prev_hash;
  pool->swork.job_id = v8;
  v85 = (char *)pool->bbversion;
  snprintf(s, 0x41u, "%s", (const char *)v23);
  v84 = (char *)pool->nbit;
  cb1_len = strlen((const char *)v9) >> 1;
  cb2_len = strlen((const char *)v10) >> 1;
  v83 = (char *)pool->ntime;
  snprintf((char *)pool->bbversion, 9u, "%s", (const char *)bbversion);
  snprintf((char *)pool->nbit, 9u, "%s", (const char *)nbit);
  snprintf((char *)pool->ntime, 9u, "%s", (const char *)ntime);
  next_diff = pool->next_diff;
  pool->swork.clean = clean;
  if ( next_diff > 0.0 )
    pool->sdiff = next_diff;
  n2size = pool->n2size;
  v26 = pool->merkles;
  v27 = cb1_len + pool->n1_len;
  v28 = cb2_len;
  pool->nonce2_offset = v27;
  v29 = n2size + v28;
  if ( v26 > 0 )
    v28 = 0;
  alloc_len = v29 + v27;
  pool->coinbase_len = v29 + v27;
  if ( v26 > 0 )
  {
    do
    {
      v30 = pool->swork.merkle_bin[v28++];
      free(v30);
    }
    while ( pool->merkles > v28 );
  }
  if ( merkles
    && (v54 = merkles,
        pool->swork.merkle_bin = (unsigned __int8 **)cgrealloc(
                                                       pool->swork.merkle_bin,
                                                       4 * merkles + 1,
                                                       "util.c",
                                                       &_func___11187.__size[20],
                                                       1979),
        v54 > 0) )
  {
    coinbase1 = v9;
    job_id = v8;
    v87 = &opt_protocol;
    v55 = 0;
    do
    {
      v56 = json_array_string(v5, v55);
      v77 = 4 * v55;
      merkle_bin = pool->swork.merkle_bin;
      v58 = (unsigned __int8 *)cgmalloc(0x20u, "util.c", &_func___11187.__size[20], 1984);
      v59 = *v87;
      merkle_bin[v55] = v58;
      if ( v59 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        *(_DWORD *)p = tmp42;
        snprintf((char *)tmp42, 0x800u, "merkle %d: %s", v55, v56);
        applog(7, tmp42, 0);
      }
      ++v55;
      v6 = hex2bin(pool->swork.merkle_bin[v77 / 4], v56, 0x20u);
      free(v56);
      if ( !v6 )
      {
        v8 = job_id;
        v9 = coinbase1;
        if ( use_syslog || opt_log_output || (v33 = opt_log_level, opt_log_level > 2) )
        {
          v60 = "Failed to convert merkle to merkle_bin in parse_notify";
          goto LABEL_129;
        }
        goto LABEL_90;
      }
    }
    while ( merkles != v55 );
    v75 = merkles;
    v8 = job_id;
    v9 = coinbase1;
    pool->merkles = merkles;
    if ( v75 > 1 )
      goto LABEL_35;
  }
  else
  {
    pool->merkles = merkles;
    v87 = &opt_protocol;
  }
  ++pool->bad_work;
LABEL_35:
  if ( clean )
    pool->nonce2 = 0LL;
  snprintf(
    (char *)header,
    0xE1u,
    "%s%s%s%s%s%s%s",
    v85,
    s,
    "0000000000000000000000000000000000000000000000000000000000000000",
    v83,
    v84,
    "00000000",
    (const char *)workpadding);
  v6 = hex2bin(pool->header_bin, header, 0x70u);
  if ( v6 )
  {
    v6 = hex2bin(p, v9, cb1_len);
    if ( v6 )
    {
      merkles = (int)p;
      v6 = hex2bin(p, v10, cb2_len);
      if ( v6 )
      {
        free(pool->coinbase);
        v31 = (unsigned __int8 *)cgcalloc(alloc_len, 1u, "util.c", &_func___11187.__size[20], 2041);
        pool->coinbase = v31;
        cg_memcpy(v31, p, cb1_len, "util.c", &_func___11187.__size[20], 2042);
        n1_len = pool->n1_len;
        if ( n1_len )
        {
          cg_memcpy(&pool->coinbase[cb1_len], pool->nonce1bin, n1_len, "util.c", &_func___11187.__size[20], 2044);
          n1_len = pool->n1_len;
        }
        cg_memcpy(
          &pool->coinbase[pool->n2size + n1_len + cb1_len],
          (const void *)merkles,
          cb2_len,
          "util.c",
          &_func___11187.__size[20],
          2045);
        v33 = opt_debug;
        if ( opt_debug )
        {
          v52 = bin2hex(pool->coinbase, pool->coinbase_len);
          v53 = v52;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "Pool %d coinbase %s", pool->pool_no, (const char *)v52);
            applog(7, tmp42, 0);
          }
          free(v53);
        }
        goto out_unlock;
      }
      if ( use_syslog || opt_log_output || (v33 = opt_log_level, opt_log_level > 2) )
      {
        v37 = "Failed to convert cb2 to cb2_bin in parse_notify";
LABEL_89:
        v38 = *(_DWORD *)v37;
        v39 = *((_DWORD *)v37 + 1);
        v40 = *((_DWORD *)v37 + 2);
        v41 = *((_DWORD *)v37 + 3);
        v42 = (int *)(v37 + 16);
        *(_DWORD *)tmp42 = v38;
        *(_DWORD *)&tmp42[4] = v39;
        *(_DWORD *)&tmp42[8] = v40;
        *(_DWORD *)&tmp42[12] = v41;
        v43 = *v42;
        v44 = v42[1];
        v45 = v42[2];
        v46 = v42[3];
        v42 += 4;
        *(_DWORD *)&tmp42[16] = v43;
        *(_DWORD *)&tmp42[20] = v44;
        *(_DWORD *)&tmp42[24] = v45;
        *(_DWORD *)&tmp42[28] = v46;
        v47 = *v42;
        v48 = v42[1];
        v49 = v42[2];
        v50 = v42[3];
        v51 = v42[4];
        *(_DWORD *)&tmp42[32] = v47;
        *(_DWORD *)&tmp42[36] = v48;
        *(_DWORD *)&tmp42[40] = v49;
        *(_DWORD *)&tmp42[44] = v50;
        tmp42[48] = v51;
        applog(3, tmp42, 0);
        goto out_unlock;
      }
    }
    else if ( use_syslog || opt_log_output || (v33 = opt_log_level, opt_log_level > 2) )
    {
      v37 = (const char *)&unk_45E28;
      goto LABEL_89;
    }
LABEL_90:
    LOBYTE(v6) = 0;
    goto out_unlock;
  }
  if ( !use_syslog && !opt_log_output )
  {
    v33 = opt_log_level;
    if ( opt_log_level <= 2 )
      goto LABEL_90;
  }
  v60 = "Failed to convert header to header_bin in parse_notify";
LABEL_129:
  v61 = *(_DWORD *)v60;
  v62 = *((_DWORD *)v60 + 1);
  v63 = *((_DWORD *)v60 + 2);
  v64 = *((_DWORD *)v60 + 3);
  v65 = (int *)(v60 + 16);
  *(_DWORD *)tmp42 = v61;
  *(_DWORD *)&tmp42[4] = v62;
  *(_DWORD *)&tmp42[8] = v63;
  *(_DWORD *)&tmp42[12] = v64;
  v66 = *v65;
  v67 = v65[1];
  v68 = v65[2];
  v69 = v65[3];
  v65 += 4;
  *(_DWORD *)&tmp42[16] = v66;
  *(_DWORD *)&tmp42[20] = v67;
  *(_DWORD *)&tmp42[24] = v68;
  *(_DWORD *)&tmp42[28] = v69;
  v70 = *v65;
  v71 = v65[1];
  v72 = v65[2];
  v73 = v65[3];
  v65 += 4;
  *(_DWORD *)&tmp42[32] = v70;
  *(_DWORD *)&tmp42[36] = v71;
  *(_DWORD *)&tmp42[40] = v72;
  *(_DWORD *)&tmp42[44] = v73;
  v74 = v65[1];
  *(_DWORD *)&tmp42[48] = *v65;
  *(_WORD *)&tmp42[52] = v74;
  tmp42[54] = BYTE2(v74);
  applog(3, tmp42, 0);
out_unlock:
  rw_unlock(lock, &_func___11187.__size[20], (const unsigned __int8 *)0x806, v33);
  mutex_unlock_noyield_0(p_mutex, &_func___11187.__size[20], (const unsigned __int8 *)0x806, v34);
  selective_yield();
  if ( *v87 && opt_debug )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      snprintf((char *)tmp42, 0x800u, "job_id: %s", (const char *)v8);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_79;
      if ( use_syslog )
        goto LABEL_53;
    }
    if ( opt_log_output || opt_log_level > 6 )
    {
LABEL_53:
      snprintf((char *)tmp42, 0x800u, "prev_hash: %s", (const char *)prev_hash);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_79;
      if ( use_syslog )
        goto LABEL_57;
    }
    if ( opt_log_output || opt_log_level > 6 )
    {
LABEL_57:
      snprintf((char *)tmp42, 0x800u, "coinbase1: %s", (const char *)v9);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_79;
      if ( use_syslog )
        goto LABEL_61;
    }
    if ( opt_log_output || opt_log_level > 6 )
    {
LABEL_61:
      snprintf((char *)tmp42, 0x800u, "coinbase2: %s", (const char *)v10);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_79;
      if ( use_syslog )
        goto LABEL_65;
    }
    if ( opt_log_output || opt_log_level > 6 )
    {
LABEL_65:
      snprintf((char *)tmp42, 0x800u, "bbversion: %s", (const char *)bbversion);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_79;
      if ( use_syslog )
        goto LABEL_69;
    }
    if ( opt_log_output || opt_log_level > 6 )
    {
LABEL_69:
      snprintf((char *)tmp42, 0x800u, "nbit: %s", (const char *)nbit);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_79;
      if ( use_syslog )
        goto LABEL_72;
    }
    if ( opt_log_output || opt_log_level > 6 )
    {
LABEL_72:
      snprintf((char *)tmp42, 0x800u, "ntime: %s", (const char *)ntime);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_79;
      if ( use_syslog )
      {
LABEL_76:
        v35 = "yes";
        if ( !clean )
          v35 = "no";
        snprintf((char *)tmp42, 0x800u, "clean: %s", v35);
        applog(7, tmp42, 0);
        goto LABEL_79;
      }
    }
    if ( opt_log_output || opt_log_level > 6 )
      goto LABEL_76;
  }
LABEL_79:
  free(v9);
  free(v10);
  v36 = total_getworks;
  ++pool->getwork_requested;
  total_getworks = v36 + 1;
  if ( pool == current_pool() )
    opt_work_update = 1;
  return v6;
}
// 13A82: variable 'v12' is possibly undefined
// 13AB4: variable 'v15' is possibly undefined
// 13AC4: variable 'v16' is possibly undefined
// 13AD4: variable 'v17' is possibly undefined
// 13AE4: variable 'v18' is possibly undefined
// 13AF4: variable 'v19' is possibly undefined
// 13B20: variable 'v21' is possibly undefined
// 13D16: variable 'v33' is possibly undefined
// 13D22: variable 'v34' is possibly undefined
// 140EE: variable 'v20' is possibly undefined

//----- (0001432C) --------------------------------------------------------
bool __fastcall parse_method(pool *pool, unsigned __int8 *s)
{
  const char *v2; // r5
  double v3; // d0
  json_t_0 *v5; // r0
  json_t_0 *v6; // r4
  json_t_0 *v7; // r7
  json_t_0 *v8; // r6
  json_t_0 *v9; // r9
  char *v10; // r0
  size_t refcount; // r3
  size_t v12; // r3
  const unsigned __int8 *v14; // r0
  const char *v15; // r6
  size_t v16; // r6
  json_t_0 *v17; // r0
  bool v18; // cf
  size_t v19; // r1
  json_t_0 *v20; // r0
  int v21; // r0
  size_t v22; // r0
  json_t_0 *v23; // r0
  const unsigned __int8 *v24; // r2
  int v25; // r3
  double next_diff; // d9
  unsigned __int8 *v27; // r7
  int v28; // r3
  json_t_0 *v29; // r0
  int v30; // r0
  json_t_0 *v31; // r0
  const unsigned __int8 *v32; // r0
  json_t_0 *v33; // r0
  unsigned int v34; // r5
  const unsigned __int8 *v35; // r2
  int v36; // r3
  size_t v37; // r3
  unsigned __int8 *nonce1bin; // r0
  unsigned __int8 *v39; // r0
  int v40; // r3
  int v41; // r3
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  json_error_t err; // [sp+14h] [bp-212Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+110h] [bp-2030h] BYREF

  if ( !s )
  {
LABEL_15:
    LOBYTE(v2) = 0;
    return (char)v2;
  }
  v5 = json_loads(s, 0, &err);
  v6 = v5;
  if ( !v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
      LOBYTE(v2) = 0;
      applog(6, tmp42, 0);
      return (char)v2;
    }
    goto LABEL_15;
  }
  v7 = json_object_get(v5, "method");
  if ( !v7 )
    goto LABEL_20;
  v8 = json_object_get(v6, (const unsigned __int8 *)"error");
  v9 = json_object_get(v6, "params");
  if ( v8 && v8->type != JSON_NULL )
  {
    v2 = (const char *)json_dumps(v8, 3u);
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "JSON-RPC method decode failed: %s", v2);
      applog(6, tmp42, 0);
    }
    v10 = (char *)v2;
    LOBYTE(v2) = 0;
    free(v10);
    goto out_decref;
  }
  v14 = json_string_value(v7);
  v15 = (const char *)v14;
  if ( !v14 )
    goto LABEL_20;
  if ( !strncasecmp((const char *)v14, "mining.multi_version", 0x14u) )
  {
    pool->support_vil = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Pool support multi version");
      applog(6, tmp42, 0);
    }
    v16 = 0;
    while ( 1 )
    {
      pool = (pool *)((char *)pool + 4);
      v18 = v16 >= json_array_size(v9);
      v19 = v16++;
      if ( v18 )
        break;
      v17 = json_array_get(v9, v19);
      pool->version_num = json_integer_value(v17);
    }
    goto out_decref;
  }
  if ( strncasecmp(v15, "mining.notify", 0xDu) )
  {
    v2 = (const char *)strncasecmp(v15, "mining.set_difficulty", 0x15u);
    if ( !v2 )
    {
      v23 = json_array_get(v9, 0);
      json_number_value(v23);
      if ( v3 == 0.0 )
        goto out_decref;
      if ( pthread_mutex_lock(&pool->data_lock.mutex) )
        mutex_lock_0((pthread_mutex_t *)&_func___10836, (const unsigned __int8 *)0x830, v24, v25);
      if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
      {
        v44 = _errno_location();
        snprintf(
          (char *)tmp42,
          0x800u,
          "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v44,
          "util.c",
          (const char *)&_func___10836,
          2096);
        applog(3, tmp42, 1);
        quit(1);
      }
      next_diff = pool->next_diff;
      pool->next_diff = v3;
      if ( next_diff <= 0.0 )
      {
        next_diff = pool->sdiff;
        pool->sdiff = v3;
      }
      if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
      {
        v42 = _errno_location();
        snprintf(
          (char *)tmp42,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v42,
          "util.c",
          (const char *)&_func___10836,
          2109);
        applog(3, tmp42, 1);
        quit(1);
      }
      if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
      {
        v43 = _errno_location();
        snprintf(
          (char *)tmp42,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v43,
          "util.c",
          (const char *)&_func___10836,
          2109);
        applog(3, tmp42, 1);
        quit(1);
      }
      selective_yield();
      if ( v3 == next_diff )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          LOBYTE(v2) = 1;
          snprintf((char *)tmp42, 0x800u, "Pool %d difficulty set to %f", pool->pool_no, v3);
          applog(7, tmp42, 0);
          goto out_decref;
        }
      }
      else if ( v3 == (double)(int)v3 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %d", pool->pool_no, (int)v3);
LABEL_60:
          LOBYTE(v2) = 1;
          applog(5, tmp42, 0);
          goto out_decref;
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %.1f", pool->pool_no, v3);
        goto LABEL_60;
      }
LABEL_88:
      LOBYTE(v2) = 1;
      goto out_decref;
    }
    if ( !strncasecmp(v15, "mining.set_extranonce", 0x15u) )
    {
      v27 = json_array_string(v9, 0);
      if ( !valid_hex(v27, &_func___10836.__size[12], (const unsigned __int8 *)0x85C, v28) )
      {
        if ( use_syslog || (LOBYTE(v2) = opt_log_output) != 0 || opt_log_level > 5 )
        {
          LOBYTE(v2) = 0;
          strcpy((char *)tmp42, "Failed to get valid nonce1 in parse_extranonce");
          applog(6, tmp42, 0);
        }
        goto out_decref;
      }
      v33 = json_array_get(v9, 1u);
      v34 = json_integer_value(v33);
      if ( !v34 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          strcpy((char *)tmp42, "Failed to get valid n2size in parse_extranonce");
          applog(6, tmp42, 0);
        }
        LOBYTE(v2) = 0;
        free(v27);
        goto out_decref;
      }
      if ( pthread_mutex_lock(&pool->data_lock.mutex) )
        mutex_lock_0((pthread_mutex_t *)&_func___10836.__size[12], (const unsigned __int8 *)0x868, v35, v36);
      wr_lock(&pool->data_lock.rwlock, &_func___10836.__size[12], (const unsigned __int8 *)0x868, v36);
      free(pool->nonce1);
      pool->nonce1 = v27;
      v37 = strlen((const char *)v27) >> 1;
      nonce1bin = pool->nonce1bin;
      pool->n1_len = v37;
      free(nonce1bin);
      v39 = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", &_func___10836.__size[12], 2157);
      pool->nonce1bin = v39;
      if ( !v39 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to calloc pool->nonce1bin in %s %s():%d",
          "util.c",
          (const char *)&_func___10836.__size[12],
          2159);
        applog(3, tmp42, 1);
        quit(1);
      }
      hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
      pool->n2size = v34;
      rw_unlock(&pool->data_lock.rwlock, &_func___10836.__size[12], (const unsigned __int8 *)0x872, v40);
      mutex_unlock_noyield_0(&pool->data_lock.mutex, &_func___10836.__size[12], (const unsigned __int8 *)0x872, v41);
      selective_yield();
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d extranonce change requested", pool->pool_no);
        LOBYTE(v2) = 1;
        applog(5, tmp42, 0);
        goto out_decref;
      }
      goto LABEL_88;
    }
    if ( !strncasecmp(v15, "client.reconnect", 0x10u) )
    {
      LOBYTE(v2) = parse_reconnect(pool, v9);
      goto out_decref;
    }
    if ( !strncasecmp(v15, "client.get_version", 0x12u) )
    {
      if ( json_object_get(v6, "id") )
      {
        v29 = json_object_get(v6, "id");
        v30 = json_integer_value(v29);
        sprintf((char *)tmp42, "{\"id\": %d, \"result\": \"bmminer/2.0.0\", \"error\": null}", v30);
LABEL_44:
        v22 = strlen((const char *)tmp42);
        LOBYTE(v2) = stratum_send(pool, tmp42, v22);
        goto out_decref;
      }
      goto LABEL_20;
    }
    if ( strncasecmp(v15, "client.show_message", 0x13u) )
    {
      if ( !strncasecmp(v15, "mining.ping", 0xBu) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Pool %d ping", pool->pool_no);
          applog(6, tmp42, 0);
        }
        v2 = (const char *)json_object_get(v6, "id");
        if ( !v2 )
          goto out_decref;
        v20 = json_object_get(v6, "id");
        v21 = json_integer_value(v20);
        sprintf((char *)tmp42, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v21);
        goto LABEL_44;
      }
      goto LABEL_20;
    }
    if ( v9 )
    {
      if ( v9->type == JSON_ARRAY )
      {
        v31 = json_array_get(v9, 0);
        v32 = json_string_value(v31);
        if ( v32 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "Pool %d message: %s", pool->pool_no, v32);
            goto LABEL_60;
          }
          goto LABEL_88;
        }
      }
    }
LABEL_20:
    LOBYTE(v2) = 0;
    goto out_decref;
  }
  if ( parse_notify(pool, v9) )
  {
    LOBYTE(v2) = 1;
    pool->stratum_notify = 1;
  }
  else
  {
    pool->stratum_notify = 0;
    LOBYTE(v2) = 0;
  }
out_decref:
  refcount = v6->refcount;
  if ( refcount != -1 )
  {
    v12 = refcount - 1;
    v6->refcount = v12;
    if ( !v12 )
      json_delete(v6);
  }
  return (char)v2;
}
// 143CA: variable 'v2' is possibly undefined
// 145E4: variable 'v3' is possibly undefined
// 146A6: variable 'v28' is possibly undefined
// 1488C: variable 'v36' is possibly undefined
// 148E8: variable 'v40' is possibly undefined
// 148F4: variable 'v41' is possibly undefined
// 14960: variable 'v35' is possibly undefined
// 14A08: variable 'v24' is possibly undefined
// 14A08: variable 'v25' is possibly undefined

//----- (00014A40) --------------------------------------------------------
bool __fastcall auth_stratum(pool *pool)
{
  unsigned __int8 *rpc_pass; // r4
  int v3; // r2
  unsigned __int8 *rpc_user; // r3
  size_t v5; // r0
  unsigned __int8 *v6; // r4
  bool v7; // r4
  json_t_0 *v9; // r7
  json_t_0 *v10; // r8
  json_t_0 *v11; // r0
  unsigned __int8 *v12; // r4
  unsigned __int8 *v13; // r0
  size_t refcount; // r3
  size_t v15; // r3
  char *v16; // r0
  int v17; // r2
  size_t v18; // r0
  int v19; // r2
  size_t v20; // r0
  json_error_t err; // [sp+Ch] [bp-2914h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+108h] [bp-2818h] BYREF
  unsigned __int8 s[8192]; // [sp+908h] [bp-2018h] BYREF

  rpc_pass = pool->rpc_pass;
  v3 = swork_id;
  rpc_user = pool->rpc_user;
  ++swork_id;
  sprintf(
    (char *)s,
    "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}",
    v3,
    (const char *)rpc_user,
    (const char *)rpc_pass);
  v5 = strlen((const char *)s);
  if ( stratum_send(pool, s, v5) )
  {
    while ( 1 )
    {
      v6 = recv_line(pool);
      if ( !v6 )
        return 0;
      if ( !parse_method(pool, v6) )
        break;
      free(v6);
    }
    v9 = json_loads(v6, 0, &err);
    free(v6);
    v10 = json_object_get(v9, "result");
    v11 = json_object_get(v9, (const unsigned __int8 *)"error");
    v12 = (unsigned __int8 *)v11;
    if ( !v10 || v10->type == JSON_FALSE )
    {
      if ( !v11 )
      {
        v16 = (char *)malloc(0x11u);
        if ( v16 )
        {
          v12 = (unsigned __int8 *)v16;
          strcpy(v16, "(unknown reason)");
        }
        goto LABEL_13;
      }
    }
    else if ( !v11 || v11->type == JSON_NULL )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum authorisation success for pool %d", pool->pool_no);
        applog(6, tmp42, 0);
      }
      pool->probed = 1;
      successful_connect = 1;
      if ( opt_suggest_diff )
      {
        v19 = swork_id++;
        sprintf(
          (char *)s,
          "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}",
          v19,
          opt_suggest_diff);
        v20 = strlen((const char *)s);
        stratum_send(pool, s, v20);
      }
      v7 = 1;
      if ( opt_multi_version )
      {
        v17 = swork_id;
        v7 = 1;
        ++swork_id;
        sprintf(
          (char *)s,
          "{\"id\": %d, \"method\": \"mining.multi_version\", \"params\": [%d]}",
          v17,
          opt_multi_version);
        v18 = strlen((const char *)s);
        stratum_send(pool, s, v18);
      }
      goto out;
    }
    v12 = json_dumps(v11, 3u);
LABEL_13:
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "pool %d JSON stratum auth failed: %s", pool->pool_no, (const char *)v12);
      applog(6, tmp42, 0);
    }
    v13 = v12;
    v7 = 0;
    free(v13);
    suspend_stratum(pool);
out:
    if ( v9 )
    {
      refcount = v9->refcount;
      if ( refcount != -1 )
      {
        v15 = refcount - 1;
        v9->refcount = v15;
        if ( !v15 )
          json_delete(v9);
      }
    }
    return v7;
  }
  return 0;
}

//----- (00014C44) --------------------------------------------------------
bool __fastcall subscribe_extranonce(pool *pool)
{
  int v2; // r2
  size_t v3; // r0
  unsigned __int8 *v4; // r4
  bool v5; // r4
  json_t_0 *v7; // r6
  json_t_0 *v8; // r7
  json_t_0 *v9; // r0
  unsigned __int8 *v10; // r4
  const char *v11; // r7
  unsigned __int8 *v12; // r0
  size_t refcount; // r3
  size_t v14; // r3
  char *v15; // r0
  json_error_t err; // [sp+Ch] [bp-2914h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+108h] [bp-2818h] BYREF
  unsigned __int8 s[8192]; // [sp+908h] [bp-2018h] BYREF

  v2 = swork_id++;
  sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v2);
  v3 = strlen((const char *)s);
  if ( !stratum_send(pool, s, v3) )
    return 0;
  while ( 1 )
  {
    if ( !socket_full(pool, 2) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Timed out waiting for response extranonce.subscribe");
        applog(7, tmp42, 0);
      }
      return 1;
    }
    v4 = recv_line(pool);
    if ( !v4 )
      return 0;
    if ( !parse_method(pool, v4) )
      break;
    free(v4);
  }
  v7 = json_loads(v4, 0, &err);
  free(v4);
  v8 = json_object_get(v7, "result");
  v9 = json_object_get(v7, (const unsigned __int8 *)"error");
  v10 = (unsigned __int8 *)v9;
  if ( !v8 || v8->type == JSON_FALSE )
  {
    if ( !v9 )
    {
      v15 = (char *)malloc(0x11u);
      if ( v15 )
      {
        v10 = (unsigned __int8 *)v15;
        strcpy(v15, "(unknown reason)");
      }
      goto LABEL_22;
    }
    goto LABEL_18;
  }
  if ( v9 && v9->type != JSON_NULL )
  {
LABEL_18:
    v11 = (const char *)_json_array_string(v9, 1u);
    if ( !v11 && (v11 = (const char *)json_string_value((const json_t_0 *)v10)) == 0
      || strcmp(v11, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(v11, "Unrecognized request provided") )
    {
      v10 = json_dumps((const json_t_0 *)v10, 3u);
LABEL_22:
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d JSON extranonce subscribe failed: %s",
          pool->pool_no,
          (const char *)v10);
        applog(6, tmp42, 0);
      }
      v12 = v10;
      v5 = 0;
      free(v12);
      goto out;
    }
    if ( !use_syslog && !opt_log_output && opt_log_level <= 5 )
      goto LABEL_41;
    snprintf((char *)tmp42, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
    goto LABEL_34;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 5 )
  {
LABEL_41:
    v5 = 1;
    goto out;
  }
  snprintf((char *)tmp42, 0x800u, "Stratum extranonce subscribe for pool %d", pool->pool_no);
LABEL_34:
  v5 = 1;
  applog(6, tmp42, 0);
out:
  if ( v7 )
  {
    refcount = v7->refcount;
    if ( refcount != -1 )
    {
      v14 = refcount - 1;
      v7->refcount = v14;
      if ( !v14 )
        json_delete(v7);
    }
  }
  return v5;
}

//----- (00014E70) --------------------------------------------------------
bool __fastcall restart_stratum(pool *pool)
{
  if ( pool->stratum_active )
    suspend_stratum(pool);
  if ( initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool) )
  {
    stratum_resumed(pool);
    return 1;
  }
  else
  {
    pool_died(pool);
    return 0;
  }
}

//----- (00014EB4) --------------------------------------------------------
bool __fastcall parse_reconnect(pool *pool, json_t_0 *val)
{
  json_t_0 *v4; // r0
  const char *v5; // r5
  unsigned __int8 *v6; // r9
  char *v7; // r8
  char *v8; // r1
  json_t_0 *v9; // r0
  int v10; // r0
  const char *v11; // r6
  const unsigned __int8 *v12; // r2
  int v13; // r3
  int sock; // r0
  unsigned __int8 *v15; // r3
  unsigned __int8 *v16; // r0
  unsigned __int8 *v17; // r0
  json_t_0 *v19; // r0
  int *v20; // r0
  char s[264]; // [sp+10h] [bp-108h] BYREF
  unsigned __int8 *sockaddr_url; // [sp+118h] [bp+0h] BYREF
  unsigned __int8 *stratum_port; // [sp+11Ch] [bp+4h] BYREF
  unsigned __int8 address[256]; // [sp+120h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+220h] [bp+108h] BYREF

  memset(address, 0, 0xFFu);
  v4 = json_array_get(val, 0);
  v5 = (const char *)json_string_value(v4);
  if ( v5 )
  {
    v6 = pool->sockaddr_url;
    v7 = strchr((const char *)v6, 46);
    if ( v7 )
    {
      v8 = strchr(v5, 46);
      if ( v8 )
      {
        if ( !strcmp(v7, v8) )
          goto LABEL_5;
        if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
          return 0;
        snprintf((char *)tmp42, 0x800u, "Denied stratum reconnect request to non-matching domain url '%s'", v6);
      }
      else
      {
        if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
          return 0;
        snprintf((char *)tmp42, 0x800u, "Denied stratum reconnect request to url without domain '%s'", v5);
      }
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        return 0;
      snprintf((char *)tmp42, 0x800u, "Denied stratum reconnect request for pool without domain '%s'", v6);
    }
    applog(3, tmp42, 0);
    return 0;
  }
  v5 = (const char *)pool->sockaddr_url;
LABEL_5:
  v9 = json_array_get(val, 1u);
  v10 = json_integer_value(v9);
  if ( v10 )
  {
    v11 = s;
    sprintf(s, "%d", v10);
  }
  else
  {
    v19 = json_array_get(val, 1u);
    v11 = (const char *)json_string_value(v19);
    if ( !v11 )
      v11 = (const char *)pool->stratum_port;
  }
  snprintf((char *)address, 0xFEu, "%s:%s", v5, v11);
  if ( !extract_sockaddr(address, &sockaddr_url, &stratum_port) )
    return 0;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Stratum reconnect requested from pool %d to %s",
      pool->pool_no,
      (const char *)address);
    applog(4, tmp42, 0);
  }
  clear_pool_work(pool);
  if ( pthread_mutex_lock(&pool->stratum_lock) )
    mutex_lock_0((pthread_mutex_t *)&lock, (const unsigned __int8 *)0x8B8, v12, v13);
  clear_sockbuf(pool);
  sock = pool->sock;
  pool->stratum_notify = 0;
  pool->stratum_active = 0;
  if ( sock )
    close(sock);
  v15 = sockaddr_url;
  v16 = pool->sockaddr_url;
  pool->sock = 0;
  pool->stratum_url = v15;
  pool->sockaddr_url = v15;
  free(v16);
  v17 = pool->stratum_port;
  pool->stratum_port = stratum_port;
  free(v17);
  if ( pthread_mutex_unlock(&pool->stratum_lock) )
  {
    v20 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v20,
      "util.c",
      (const char *)&lock,
      2241);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
  return restart_stratum(pool);
}
// 150DA: variable 'v12' is possibly undefined
// 150DA: variable 'v13' is possibly undefined

//----- (00015114) --------------------------------------------------------
void __fastcall copy_time(timeval *dest, const timeval *src)
{
  cg_memcpy(dest, src, 8u, "util.c", &lock.__size[16], 1236);
}

//----- (00015138) --------------------------------------------------------
unsigned __int8 *__fastcall ser_string(unsigned __int8 *s, int *slen)
{
  unsigned int v4; // r4
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r5

  v4 = strlen((const char *)s);
  v5 = (unsigned __int8 *)cgmalloc(v4 + 9, "util.c", _func___10401, 996);
  v6 = v5;
  if ( v4 <= 0xFC )
  {
    *v5 = v4;
    cg_memcpy(v5 + 1, s, v4, "util.c", _func___10401, 1000);
    *slen = v4 + 1;
  }
  else if ( v4 < 0x10000 )
  {
    *v5 = -3;
    *(_WORD *)(v5 + 1) = BYTE1(v4) | (unsigned __int16)((_WORD)v4 << 8);
    cg_memcpy(v5 + 3, s, v4, "util.c", _func___10401, 1009);
    *slen = v4 + 3;
  }
  else
  {
    *v5 = -2;
    *(_DWORD *)(v5 + 1) = bswap32(v4);
    cg_memcpy(v5 + 5, s, v4, "util.c", _func___10401, 1019);
    *slen = v4 + 5;
  }
  return v6;
}

//----- (000151DC) --------------------------------------------------------
void __fastcall address_to_pubkeyhash(unsigned __int8 *pkh, const unsigned __int8 *addr)
{
  unsigned __int8 b58bin[25]; // [sp+Ch] [bp-2Ch] BYREF

  memset(b58bin, 0, sizeof(b58bin));
  b58tobin(b58bin, addr);
  *pkh = 118;
  pkh[1] = -87;
  pkh[2] = 20;
  cg_memcpy(pkh + 3, &b58bin[1], 0x14u, "util.c", _func___10388, 966);
  pkh[23] = -120;
  pkh[24] = -84;
}

//----- (00015234) --------------------------------------------------------
int __fastcall cg_timeval_subtract(timeval *result, timeval *x, timeval *y)
{
  __time_t tv_sec; // r5
  bool v4; // zf
  __suseconds_t tv_usec; // r3
  __suseconds_t v6; // r2
  __suseconds_t v7; // r3
  __time_t v8; // r4

  tv_sec = y->tv_sec;
  v4 = x->tv_sec == y->tv_sec;
  if ( x->tv_sec > y->tv_sec )
    return -1;
  tv_usec = x->tv_usec;
  v6 = y->tv_usec;
  if ( v4 && tv_usec > v6 )
    return -1;
  v7 = v6 - tv_usec;
  v8 = tv_sec - x->tv_sec;
  result->tv_sec = v8;
  result->tv_usec = v7;
  if ( v7 < 0 )
  {
    result->tv_sec = v8 - 1;
    result->tv_usec = v7 + 1000000;
  }
  return 0;
}

//----- (00015274) --------------------------------------------------------
void __fastcall rev(unsigned __int8 *s, size_t l)
{
  size_t v2; // r1
  size_t i; // r3
  unsigned __int8 v4; // r2

  v2 = l - 1;
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = s[i];
      s[i] = s[v2];
      s[v2--] = v4;
    }
  }
}

//----- (00015290) --------------------------------------------------------
int __fastcall check_asicnum(int asic_num, unsigned __int8 nonce)
{
  int v3; // r1
  unsigned int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1
  unsigned int v7; // r1

  switch ( asic_num )
  {
    case 1:
      return 1;
    case 2:
      if ( (nonce & 0x80) == 0 )
        return 1;
      return 2;
    case 4:
      v3 = nonce & 0xC0;
      switch ( v3 )
      {
        case 128:
          return 3;
        case 192:
          return 4;
        case 64:
          return 2;
        default:
          return 1;
      }
    case 8:
      v4 = nonce & 0xE0;
      if ( v4 == 128 )
        return 5;
      if ( v4 > 0x80 )
      {
        if ( v4 == 192 )
          return 7;
        if ( v4 == 224 )
          return 8;
        if ( v4 != 160 )
          return 1;
        return 6;
      }
      if ( v4 == 64 )
        return 3;
      if ( v4 == 96 )
        return 4;
      if ( v4 != 32 )
        return 1;
      return 2;
    case 16:
      v5 = nonce & 0xF0;
      if ( v5 == 128 )
        return 9;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
        {
          return 5;
        }
        else if ( v5 > 0x40 )
        {
          switch ( v5 )
          {
            case '`':
              return 7;
            case 'p':
              return 8;
            case 'P':
              return 6;
            default:
              return 1;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 0x20u:
              return 3;
            case 0x30u:
              return 4;
            case 0x10u:
              return 2;
            default:
              return 1;
          }
        }
      }
      else if ( v5 == 192 )
      {
        return 13;
      }
      else if ( v5 > 0xC0 )
      {
        switch ( v5 )
        {
          case 0xE0u:
            return 15;
          case 0xF0u:
            return 16;
          case 0xD0u:
            return 14;
          default:
            return 1;
        }
      }
      else
      {
        switch ( v5 )
        {
          case 0xA0u:
            return 11;
          case 0xB0u:
            return 12;
          case 0x90u:
            return 10;
          default:
            return 1;
        }
      }
    case 32:
      v6 = (unsigned __int8)((nonce & 0xF8) - 8);
      if ( v6 > 0xF0 )
        return 1;
      return *((char *)&hex2bin_tbl[498] + v6);
    case 64:
      v7 = (unsigned __int8)((nonce & 0xFC) - 4);
      if ( v7 > 0xF8 )
        return 1;
      return *((char *)&hex2bin_tbl[559] + v7);
    default:
      return 0;
  }
}

//----- (000153D4) --------------------------------------------------------
void __fastcall cg_logwork(work *work, unsigned __int8 *nonce_bin, bool ok)
{
  int v4; // t1
  int v5; // r1
  int v6; // r2
  unsigned __int8 *v7; // r8
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r4
  int v13; // r1
  int v14; // r2
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  int v20; // r3
  unsigned __int8 v21; // r3
  unsigned __int8 *v22; // r2
  int i; // r3
  unsigned __int8 v24; // r1
  unsigned __int8 *v25; // r2
  int j; // r3
  unsigned __int8 v27; // r1
  unsigned __int8 *v28; // r8
  unsigned __int8 *v29; // r4
  unsigned __int8 *v30; // r5
  unsigned __int8 *v31; // r9
  unsigned __int8 *v32; // r7
  unsigned __int8 *v33; // r6
  uint64_t v34; // r0
  const char *v35; // r2
  size_t v36; // r0
  bool v37; // zf
  unsigned __int64 v38; // r2
  int k; // r11
  size_t v40; // r0
  size_t v41; // r0
  int v42; // r11
  size_t v43; // r0
  size_t v44; // r0
  int v45; // [sp+14h] [bp-CACh]
  int n; // [sp+24h] [bp-C9Ch]
  unsigned int v47; // [sp+28h] [bp-C98h]
  _BOOL4 v49; // [sp+30h] [bp-C90h]
  unsigned int v50; // [sp+34h] [bp-C8Ch]
  unsigned __int8 midstate_tmp[32]; // [sp+38h] [bp-C88h] BYREF
  unsigned __int8 data_tmp[32]; // [sp+58h] [bp-C68h] BYREF
  unsigned __int8 hash_tmp[32]; // [sp+78h] [bp-C48h] BYREF
  unsigned __int8 szmsg[1024]; // [sp+98h] [bp-C28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+498h] [bp-828h] BYREF

  v49 = ok;
  if ( opt_logwork_path )
  {
    memset(szmsg, 0, sizeof(szmsg));
    v4 = *(_DWORD *)work->midstate;
    v5 = *(_DWORD *)&work->midstate[4];
    v6 = *(_DWORD *)&work->midstate[8];
    v7 = midstate_tmp;
    v8 = *(_DWORD *)&work->midstate[12];
    memset(&data_tmp[12], 0, 20);
    *(_DWORD *)midstate_tmp = v4;
    *(_DWORD *)&midstate_tmp[4] = v5;
    *(_DWORD *)&midstate_tmp[8] = v6;
    *(_DWORD *)&midstate_tmp[12] = v8;
    v9 = *(_DWORD *)&work->midstate[20];
    v10 = *(_DWORD *)&work->midstate[24];
    v11 = *(_DWORD *)&work->midstate[28];
    *(_DWORD *)&midstate_tmp[16] = *(_DWORD *)&work->midstate[16];
    *(_DWORD *)&midstate_tmp[20] = v9;
    *(_DWORD *)&midstate_tmp[24] = v10;
    *(_DWORD *)&midstate_tmp[28] = v11;
    v12 = 0;
    v13 = *(_DWORD *)&work->data[68];
    v14 = *(_DWORD *)&work->data[72];
    *(_DWORD *)data_tmp = *(_DWORD *)&work->data[64];
    *(_DWORD *)&data_tmp[4] = v13;
    *(_DWORD *)&data_tmp[8] = v14;
    v15 = *(_DWORD *)&work->hash[4];
    v16 = *(_DWORD *)&work->hash[8];
    v17 = *(_DWORD *)&work->hash[12];
    *(_DWORD *)hash_tmp = *(_DWORD *)work->hash;
    *(_DWORD *)&hash_tmp[4] = v15;
    *(_DWORD *)&hash_tmp[8] = v16;
    *(_DWORD *)&hash_tmp[12] = v17;
    v18 = *(_DWORD *)&work->hash[20];
    v19 = *(_DWORD *)&work->hash[24];
    v20 = *(_DWORD *)&work->hash[28];
    *(_DWORD *)&hash_tmp[16] = *(_DWORD *)&work->hash[16];
    *(_DWORD *)&hash_tmp[20] = v18;
    *(_DWORD *)&hash_tmp[24] = v19;
    *(_DWORD *)&hash_tmp[28] = v20;
    do
    {
      v21 = midstate_tmp[v12];
      midstate_tmp[v12++] = v7[31];
      v7[31] = v21;
      --v7;
    }
    while ( v12 != 16 );
    v22 = data_tmp;
    for ( i = 0; i != 6; ++i )
    {
      v24 = data_tmp[i];
      data_tmp[i] = v22[11];
      v22[11] = v24;
      --v22;
    }
    v25 = hash_tmp;
    for ( j = 0; j != 16; ++j )
    {
      v27 = hash_tmp[j];
      hash_tmp[j] = v25[31];
      v25[31] = v27;
      --v25;
    }
    v28 = bin2hex(work->data, 0x80u);
    v29 = bin2hex(midstate_tmp, 0x20u);
    v30 = bin2hex(data_tmp, 0xCu);
    v31 = bin2hex(nonce_bin, 4u);
    v32 = bin2hex(nonce_bin, 5u);
    v33 = bin2hex(hash_tmp, 0x20u);
    v34 = share_ndiff(work);
    v50 = HIDWORD(v34);
    v35 = "o";
    v47 = v34;
    if ( !v49 )
      v35 = "x";
    sprintf(
      (char *)szmsg,
      "%s %08x midstate %s data %s nonce %s hash %s diff %I64d",
      v35,
      work->id,
      v29,
      v30,
      v32,
      v33,
      v34);
    if ( !strcmp((const char *)opt_logwork_path, "screen") )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, (const char *)szmsg);
        applog(3, tmp42, 0);
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, (const char *)szmsg);
        applog(3, tmp42, 0);
      }
      if ( g_logwork_file )
      {
        if ( v49 )
        {
          sprintf(
            (char *)szmsg,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %I64d",
            "o",
            work->id,
            v28,
            v29,
            v30,
            v32,
            v33,
            v45,
            v47,
            v50);
          v36 = strlen((const char *)szmsg);
          fwrite(szmsg, v36, 1u, g_logwork_file);
          fwrite(ptr, 1u, 1u, g_logwork_file);
          fflush(g_logwork_file);
          if ( g_logwork_asicnum == 1 )
          {
            n = g_logwork_asicnum;
            sprintf(
              (char *)szmsg,
              "midstate %s data %s nonce %s hash %s",
              (const char *)v29,
              (const char *)v30,
              (const char *)v31,
              (const char *)v33);
            v44 = strlen((const char *)szmsg);
            fwrite(szmsg, v44, n, g_logwork_files[0]);
            fwrite(ptr, n, n, g_logwork_files[0]);
            fflush(g_logwork_files[0]);
          }
          else
          {
            v37 = g_logwork_asicnum == 32;
            if ( g_logwork_asicnum != 32 )
              v37 = g_logwork_asicnum == 64;
            if ( v37 )
            {
              sprintf(
                (char *)szmsg,
                "midstate %s data %s nonce %s hash %s",
                (const char *)v29,
                (const char *)v30,
                (const char *)v31,
                (const char *)v33);
              v42 = check_asicnum(g_logwork_asicnum, *nonce_bin);
              v43 = strlen((const char *)szmsg);
              fwrite(szmsg, v43, 1u, g_logwork_files[v42]);
              fwrite(ptr, 1u, 1u, g_logwork_files[v42]);
              fflush(g_logwork_files[v42]);
            }
          }
          if ( opt_logwork_diff )
          {
            v38 = __PAIR64__(v50, v47);
            for ( k = 0; k != 64; ++k )
            {
              v38 >>= 1;
              if ( !v38 )
                break;
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42, 0x800u, "work diff %I64d diffnum %d");
              applog(7, tmp42, 0);
            }
            sprintf(
              (char *)szmsg,
              "midstate %s data %s nonce %s hash %s",
              (const char *)v29,
              (const char *)v30,
              (const char *)v31,
              (const char *)v33);
            v40 = strlen((const char *)szmsg);
            fwrite(szmsg, v40, 1u, g_logwork_diffs[k]);
            fwrite(ptr, 1u, 1u, g_logwork_diffs[k]);
            fflush(g_logwork_diffs[k]);
          }
        }
        else
        {
          sprintf(
            (char *)szmsg,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %I64d",
            "x",
            work->id,
            v28,
            v29,
            v30,
            v32,
            v33,
            v45,
            v47,
            v50);
          v41 = strlen((const char *)szmsg);
          fwrite(szmsg, v41, 1u, g_logwork_file);
          fwrite(ptr, 1u, 1u, g_logwork_file);
          fflush(g_logwork_file);
        }
      }
    }
    if ( v28 )
      free(v28);
    if ( v29 )
      free(v29);
    if ( v30 )
      free(v30);
    if ( v31 )
      free(v31);
    if ( v32 )
      free(v32);
    if ( v33 )
      free(v33);
  }
}
// 1560E: variable 'v45' is possibly undefined

//----- (00015860) --------------------------------------------------------
void __fastcall cg_logwork_uint32(work *work, unsigned int nonce, bool ok)
{
  unsigned __int8 nonce_bin[5]; // [sp+0h] [bp-10h] BYREF

  if ( opt_logwork_path )
  {
    *(_DWORD *)nonce_bin = nonce;
    nonce_bin[4] = 0;
    cg_logwork(work, nonce_bin, ok);
  }
}

//----- (00015888) --------------------------------------------------------
char *read_config()
{
  FILE *v0; // r6
  char *result; // r0
  char *v2; // r0
  int v3; // r1
  int v4; // r3
  char *v5; // r4
  bool v6; // zf
  char *v7; // r0
  char *v8; // r0
  char *v9; // r0
  char *v10; // r0
  char *v11; // r0
  char *v12; // r0
  char *v13; // r0
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r0
  char *v18; // r0
  char *v19; // r0
  char *v20; // r0
  char *v21; // r0
  char *v22; // r0
  char *v23; // r0
  char *v24; // r0
  char *v25; // r0
  char *v26; // r0
  char *v27; // r0
  char *v28; // r0
  char *v29; // r0
  char *v30; // r0
  char *v31; // r0
  char *v32; // r0
  char *v33; // r0
  char *v34; // r0
  char *v35; // r0
  char *v36; // r0
  char *v37; // r0
  char *v38; // r0
  char *v39; // r0
  char *v40; // r0
  char *v41; // r0
  char *v42; // r0
  char *v43; // r0
  char *v44; // r0
  char *v45; // r0
  char *v46; // r0
  char *v47; // r0
  int v48; // r3
  char *v49; // r0
  char *v50; // r0
  char *v51; // r0
  char *v52; // r0
  char *v53; // r0
  char *v54; // r0
  char *v55; // r0
  char *v56; // r0
  const char *v57; // r4
  int v58; // r3
  int offset; // [sp+0h] [bp-420h] BYREF
  int starttemp; // [sp+4h] [bp-41Ch] BYREF
  unsigned __int8 str[1024]; // [sp+8h] [bp-418h] BYREF

  memset(str, 0, sizeof(str));
  offset = 0;
  starttemp = 0;
  v0 = fopen("/etc/config/Config.ini", (const char *)"r");
  while ( 1 )
  {
    result = fgets((char *)str, 1023, v0);
    if ( !result )
      break;
    if ( str[0] != 35 && str[1] != 35 )
    {
      v2 = strstr((const char *)str, "TestDir=");
      if ( v2 )
      {
        LOBYTE(v3) = v2[8];
        v4 = 0;
        while ( 1 )
        {
          v5 = &v2[v4];
          cgpu.workdataPathPrefix[v4++] = v3;
          v3 = (unsigned __int8)v5[9];
          v6 = v3 == 10;
          if ( v3 != 10 )
            v6 = v3 == 13;
          if ( v6 )
            break;
          if ( v4 == 64 )
          {
            v4 = 65;
            break;
          }
        }
        cgpu.workdataPathPrefix[v4] = 0;
        printf("workdataPathPrefix:%s\n", (const char *)cgpu.workdataPathPrefix);
      }
      else
      {
        v7 = strstr((const char *)str, "DataCount=");
        if ( v7 )
        {
          sscanf(v7 + 10, "%d", &Conf.DataCount);
        }
        else
        {
          v8 = strstr((const char *)str, "PassCount1=");
          if ( v8 )
          {
            sscanf(v8 + 11, "%d", &Conf.PassCount1);
          }
          else
          {
            v9 = strstr((const char *)str, "PassCount2=");
            if ( v9 )
            {
              sscanf(v9 + 11, "%d", &Conf.PassCount2);
            }
            else
            {
              v10 = strstr((const char *)str, "PassCount3=");
              if ( v10 )
              {
                sscanf(v10 + 11, "%d", &Conf.PassCount3);
              }
              else
              {
                v11 = strstr((const char *)str, "Freq=");
                if ( v11 )
                {
                  sscanf(v11 + 5, "%d", &Conf.Freq);
                  Conf.force_freq = 0;
                }
                else
                {
                  v12 = strstr((const char *)str, "freq_e=");
                  if ( v12 )
                  {
                    sscanf(v12 + 7, "%d", &Conf.freq_e);
                  }
                  else
                  {
                    v13 = strstr((const char *)str, "UseConfigVol=");
                    if ( v13 )
                    {
                      sscanf(v13 + 13, "%d", &Conf.UseConfigVol);
                    }
                    else
                    {
                      v14 = strstr((const char *)str, "freq_m=");
                      if ( v14 )
                      {
                        sscanf(v14 + 7, "%d", &Conf.freq_m);
                      }
                      else
                      {
                        v15 = strstr((const char *)str, "freq_a=");
                        if ( v15 )
                        {
                          sscanf(v15 + 7, "%d", &Conf.freq_a);
                        }
                        else
                        {
                          v16 = strstr((const char *)str, "freq_t=");
                          if ( v16 )
                          {
                            sscanf(v16 + 7, "%d", &Conf.freq_t);
                          }
                          else if ( !strstr((const char *)str, "force_freq=") )
                          {
                            v17 = strstr((const char *)str, "Timeout=");
                            if ( v17 )
                            {
                              sscanf(v17 + 8, "%d", &Conf.Timeout);
                            }
                            else
                            {
                              v18 = strstr((const char *)str, "UseFreqPIC=");
                              if ( v18 )
                              {
                                sscanf(v18 + 11, "%d", &Conf.UseFreqPIC);
                              }
                              else
                              {
                                v19 = strstr((const char *)str, "TestMode=");
                                if ( v19 )
                                {
                                  sscanf(v19 + 9, "%d", &Conf.TestMode);
                                }
                                else
                                {
                                  v20 = strstr((const char *)str, "CheckChain=");
                                  if ( v20 )
                                  {
                                    sscanf(v20 + 11, "%d", &Conf.CheckChain);
                                  }
                                  else
                                  {
                                    v21 = strstr((const char *)str, "CommandMode=");
                                    if ( v21 )
                                    {
                                      sscanf(v21 + 12, "%d", &Conf.CommandMode);
                                    }
                                    else
                                    {
                                      v22 = strstr((const char *)str, "ValidNonce1=");
                                      if ( v22 )
                                      {
                                        sscanf(v22 + 12, "%d", &Conf.ValidNonce1);
                                      }
                                      else
                                      {
                                        v23 = strstr((const char *)str, "ValidNonce2=");
                                        if ( v23 )
                                        {
                                          sscanf(v23 + 12, "%d", &Conf.ValidNonce2);
                                        }
                                        else
                                        {
                                          v24 = strstr((const char *)str, "ValidNonce3=");
                                          if ( v24 )
                                          {
                                            sscanf(v24 + 12, "%d", &Conf.ValidNonce3);
                                          }
                                          else
                                          {
                                            v25 = strstr((const char *)str, "Pic_VOLTAGE=");
                                            if ( v25 )
                                            {
                                              sscanf(v25 + 12, "%d", &Conf.Pic);
                                            }
                                            else
                                            {
                                              v26 = strstr((const char *)str, "Voltage1=");
                                              if ( v26 )
                                              {
                                                sscanf(v26 + 9, "%d", &Conf.Voltage1);
                                              }
                                              else
                                              {
                                                v27 = strstr((const char *)str, "Voltage2=");
                                                if ( v27 )
                                                {
                                                  sscanf(v27 + 9, "%d", &Conf.Voltage2);
                                                }
                                                else
                                                {
                                                  v28 = strstr((const char *)str, "Voltage3=");
                                                  if ( v28 )
                                                  {
                                                    sscanf(v28 + 9, "%d", &Conf.Voltage3);
                                                  }
                                                  else
                                                  {
                                                    v29 = strstr((const char *)str, "final_voltage1=");
                                                    if ( v29 )
                                                    {
                                                      sscanf(v29 + 15, "%ud", &Conf.final_voltage1);
                                                    }
                                                    else
                                                    {
                                                      v30 = strstr((const char *)str, "final_voltage2=");
                                                      if ( v30 )
                                                      {
                                                        sscanf(v30 + 15, "%ud", &Conf.final_voltage2);
                                                      }
                                                      else
                                                      {
                                                        v31 = strstr((const char *)str, "final_voltage3=");
                                                        if ( v31 )
                                                        {
                                                          sscanf(v31 + 15, "%ud", &Conf.final_voltage3);
                                                        }
                                                        else
                                                        {
                                                          v32 = strstr((const char *)str, "freq_gap=");
                                                          if ( v32 )
                                                          {
                                                            sscanf(v32 + 9, "%ud", &Conf.freq_gap);
                                                          }
                                                          else
                                                          {
                                                            v33 = strstr((const char *)str, "OpenCoreGap=");
                                                            if ( v33 )
                                                            {
                                                              sscanf(v33 + 12, "%d", &Conf.OpenCoreGap);
                                                            }
                                                            else
                                                            {
                                                              v34 = strstr((const char *)str, "CheckTemp=");
                                                              if ( v34 )
                                                              {
                                                                sscanf(v34 + 10, "%d", &Conf.checktemp);
                                                              }
                                                              else
                                                              {
                                                                v35 = strstr((const char *)str, "IICPic=");
                                                                if ( v35 )
                                                                {
                                                                  sscanf(v35 + 7, "%d", &Conf.IICPic);
                                                                }
                                                                else
                                                                {
                                                                  v36 = strstr((const char *)str, "Open_Core_Num1=");
                                                                  if ( v36 )
                                                                  {
                                                                    sscanf(v36 + 15, "%ud", &Conf.OpenCoreNum1);
                                                                  }
                                                                  else
                                                                  {
                                                                    v37 = strstr((const char *)str, "Open_Core_Num2=");
                                                                    if ( v37 )
                                                                    {
                                                                      sscanf(v37 + 15, "%ud", &Conf.OpenCoreNum2);
                                                                    }
                                                                    else
                                                                    {
                                                                      v38 = strstr((const char *)str, "Open_Core_Num3=");
                                                                      if ( v38 )
                                                                      {
                                                                        sscanf(v38 + 15, "%ud", &Conf.OpenCoreNum3);
                                                                      }
                                                                      else
                                                                      {
                                                                        v39 = strstr(
                                                                                (const char *)str,
                                                                                "Open_Core_Num4=");
                                                                        if ( v39 )
                                                                        {
                                                                          sscanf(v39 + 15, "%ud", &Conf.OpenCoreNum4);
                                                                        }
                                                                        else
                                                                        {
                                                                          v40 = strstr((const char *)str, "DAC=");
                                                                          if ( v40 )
                                                                          {
                                                                            sscanf(v40 + 4, "%ud", &Conf.dac);
                                                                          }
                                                                          else
                                                                          {
                                                                            v41 = strstr(
                                                                                    (const char *)str,
                                                                                    "GetTempFrom=");
                                                                            if ( v41 )
                                                                            {
                                                                              sscanf(v41 + 12, "%ud", &Conf.GetTempFrom);
                                                                            }
                                                                            else
                                                                            {
                                                                              v42 = strstr(
                                                                                      (const char *)str,
                                                                                      "TempSel=");
                                                                              if ( v42 )
                                                                              {
                                                                                sscanf(v42 + 8, "%ud", &Conf.TempSel);
                                                                              }
                                                                              else
                                                                              {
                                                                                v43 = strstr(
                                                                                        (const char *)str,
                                                                                        "TempSensor1=");
                                                                                if ( v43 )
                                                                                {
                                                                                  sscanf(
                                                                                    v43 + 12,
                                                                                    "%ud",
                                                                                    &Conf.TempSensor1);
                                                                                }
                                                                                else
                                                                                {
                                                                                  v44 = strstr(
                                                                                          (const char *)str,
                                                                                          "TempSensor2=");
                                                                                  if ( v44 )
                                                                                  {
                                                                                    sscanf(
                                                                                      v44 + 12,
                                                                                      "%ud",
                                                                                      &Conf.TempSensor2);
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v45 = strstr(
                                                                                            (const char *)str,
                                                                                            "TempSensor3=");
                                                                                    if ( v45 )
                                                                                    {
                                                                                      sscanf(
                                                                                        v45 + 12,
                                                                                        "%ud",
                                                                                        &Conf.TempSensor3);
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v46 = strstr(
                                                                                              (const char *)str,
                                                                                              "TempSensor4=");
                                                                                      if ( v46 )
                                                                                      {
                                                                                        sscanf(
                                                                                          v46 + 12,
                                                                                          "%ud",
                                                                                          &Conf.TempSensor4);
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v47 = strstr(
                                                                                                (const char *)str,
                                                                                                "DefaultTempOffset=");
                                                                                        if ( v47 )
                                                                                        {
                                                                                          sscanf(
                                                                                            v47 + 18,
                                                                                            "%d",
                                                                                            &offset);
                                                                                          v48 = offset;
                                                                                          if ( offset >= 0 )
                                                                                            Conf.DefaultTempOffset = offset;
                                                                                          else
                                                                                            v48 = -offset;
                                                                                          if ( offset < 0 )
                                                                                          {
                                                                                            offset = v48;
                                                                                            Conf.DefaultTempOffset = -(char)v48;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          v49 = strstr(
                                                                                                  (const char *)str,
                                                                                                  "year=");
                                                                                          if ( v49 )
                                                                                          {
                                                                                            sscanf(
                                                                                              v49 + 5,
                                                                                              "%d",
                                                                                              &Conf.year);
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            v50 = strstr(
                                                                                                    (const char *)str,
                                                                                                    "month=");
                                                                                            if ( v50 )
                                                                                            {
                                                                                              sscanf(
                                                                                                v50 + 6,
                                                                                                "%d",
                                                                                                &Conf.month);
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              v51 = strstr((const char *)str, "date=");
                                                                                              if ( v51 )
                                                                                              {
                                                                                                sscanf(
                                                                                                  v51 + 5,
                                                                                                  "%d",
                                                                                                  &Conf.date);
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                v52 = strstr((const char *)str, "hour=");
                                                                                                if ( v52 )
                                                                                                {
                                                                                                  sscanf(
                                                                                                    v52 + 5,
                                                                                                    "%d",
                                                                                                    &Conf.hour);
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  v53 = strstr((const char *)str, "minute=");
                                                                                                  if ( v53 )
                                                                                                  {
                                                                                                    sscanf(v53 + 7, "%d", &Conf.minute);
                                                                                                  }
                                                                                                  else
                                                                                                  {
                                                                                                    v54 = strstr((const char *)str, "second=");
                                                                                                    if ( v54 )
                                                                                                    {
                                                                                                      sscanf(v54 + 7, "%d", &Conf.second);
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      v55 = strstr((const char *)str, "StartSensor=");
                                                                                                      if ( v55 )
                                                                                                      {
                                                                                                        sscanf(v55 + 12, "%d", &Conf.StartSensor);
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        v56 = strstr((const char *)str, "StartTemp=");
                                                                                                        if ( v56 )
                                                                                                        {
                                                                                                          v57 = v56 + 10;
                                                                                                          sscanf(v56 + 10, "%d", &Conf.StartTemp);
                                                                                                          sscanf(v57, "%d", &starttemp);
                                                                                                          v58 = starttemp;
                                                                                                          if ( starttemp < 0 )
                                                                                                          {
                                                                                                            starttemp = -starttemp;
                                                                                                            v58 = -(char)starttemp;
                                                                                                          }
                                                                                                          Conf.StartTemp = v58;
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  Conf.AsicNum = 18;
  Conf.AsicType = 1387;
  Conf.CoreNum = 114;
  return result;
}

//----- (00015F6C) --------------------------------------------------------
void __fastcall writeLogFile(unsigned __int8 *logstr)
{
  if ( showLogToKernelLog )
    writeInitLogFile(logstr);
}

//----- (00015F7C) --------------------------------------------------------
void *__fastcall receive_func(void *arg)
{
  unsigned int v1; // r9
  int v2; // r5
  void *result; // r0
  unsigned int v4; // r7
  int v5; // r0
  int v6; // r4
  unsigned int v7; // r1
  unsigned int *v8; // r6
  unsigned int v9; // r0
  unsigned int v10; // r6
  _DWORD *v11; // r3
  unsigned int v12; // r2
  unsigned int nonce; // r0
  unsigned int OpenCoreNum1; // r2
  unsigned int OpenCoreNum2; // r12
  unsigned int v16; // r3
  unsigned int OpenCoreNum3; // r0
  unsigned int OpenCoreNum4; // r4
  unsigned int v19; // r12
  char *v20; // r4
  int v21; // r2
  unsigned int v22; // r1
  int *v23; // r3
  unsigned int real_asic_num; // [sp+0h] [bp-50h]
  int v25; // [sp+4h] [bp-4Ch]
  int chainIndex; // [sp+8h] [bp-48h]
  unsigned int which_core_nonce; // [sp+Ch] [bp-44h]
  int v28; // [sp+10h] [bp-40h]
  unsigned int v29; // [sp+1Ch] [bp-34h]
  unsigned int buf[2]; // [sp+20h] [bp-30h] BYREF

  v1 = 0;
  buf[0] = 0;
  buf[1] = 0;
  which_core_nonce = 0;
  memset(repeated_nonce_id, 255, sizeof(repeated_nonce_id));
  memset(last_nonce, 0, sizeof(last_nonce));
  memset(llast_nonce, 0, sizeof(llast_nonce));
  memset(work_id, 0, sizeof(work_id));
  memset(m_nonce, 0, sizeof(m_nonce));
LABEL_2:
  while ( 1 )
  {
    v2 = ExitFlag;
    if ( ExitFlag )
      break;
    while ( !start_receive )
    {
      v1 = start_receive;
      buf[0] = start_receive;
      buf[1] = start_receive;
      memset(repeated_nonce_id, 255, sizeof(repeated_nonce_id));
      which_core_nonce = start_receive;
      memset(last_nonce, start_receive, sizeof(last_nonce));
      memset(llast_nonce, start_receive, sizeof(llast_nonce));
      memset(work_id, start_receive, sizeof(work_id));
      memset(m_nonce, start_receive, sizeof(m_nonce));
      usleep(0x186A0u);
      v2 = ExitFlag;
      if ( ExitFlag )
        goto LABEL_5;
    }
    v4 = get_nonce_number_in_fifo() & 0x1FF;
    if ( v4 )
    {
      while ( 1 )
      {
        get_return_nonce(buf);
        if ( (buf[0] & 0x80000000) == 0 )
        {
          insert_reg_data(buf);
        }
        else
        {
          if ( !gBegin_get_nonce || (buf[0] & 0x80) == 0 )
            goto LABEL_9;
          v5 = buf[0] & 0xF;
          chainIndex = v5;
          if ( cgpu.CommandMode )
          {
            v6 = 4 * v5;
            v7 = buf[1];
            v8 = &repeated_nonce_id[13][v5 + 6];
            v9 = v8[762];
            v8[794] = HIWORD(buf[0]) & 0x7FFF;
            if ( v7 == v9 )
              goto LABEL_24;
          }
          else
          {
            v6 = 4 * v5;
            v7 = buf[1];
            v8 = &repeated_nonce_id[13][v5 + 6];
            v9 = v8[762];
            v8[794] = HIWORD(buf[0]) & 0x7FFF;
            if ( v7 == v9 )
            {
LABEL_24:
              ++*(unsigned int *)((char *)&repeated_nonce_id[16][65] + v6);
              goto LABEL_9;
            }
          }
          if ( v7 == v8[778] )
            goto LABEL_24;
          if ( cgpu.real_asic_num == 1 )
          {
            if ( conf.core > 64 )
            {
              if ( (unsigned int)(conf.core - 65) > 0x3F )
              {
                printf("%s: conf.core = %d, but it is error\n", (const char *)_FUNCTION___12328, conf.core);
                v9 = v8[762];
                v7 = buf[1];
              }
              else
              {
                which_core_nonce = v7 & 0x7F;
                if ( which_core_nonce <= 0x38 )
                {
                  v1 = v7 & 0x7F;
                }
                else if ( (v7 & 0x7F) - 64 <= 0x3F )
                {
                  v1 = (unsigned __int8)(which_core_nonce - 7);
                }
              }
            }
            else
            {
              v1 = v7 & 0x3F;
              which_core_nonce = v1;
            }
            OpenCoreNum1 = conf.OpenCoreNum1;
            OpenCoreNum2 = conf.OpenCoreNum2;
            if ( !v1 )
            {
              v10 = 0;
              goto LABEL_20;
            }
            v10 = 0;
            v29 = v9;
            v16 = 0;
            OpenCoreNum3 = conf.OpenCoreNum3;
            v28 = v6;
            OpenCoreNum4 = conf.OpenCoreNum4;
            while ( 2 )
            {
              while ( v16 > 0x1F )
              {
                if ( v16 - 32 > 0x1F )
                {
                  if ( v16 - 64 > 0x1F )
                  {
                    if ( (OpenCoreNum4 & 1) != 0 )
                    {
                      OpenCoreNum4 >>= 1;
                      v10 = (unsigned __int8)(v10 + 1);
                    }
                    else
                    {
                      OpenCoreNum4 >>= 1;
                    }
                  }
                  else if ( (OpenCoreNum3 & 1) != 0 )
                  {
                    OpenCoreNum3 >>= 1;
                    v10 = (unsigned __int8)(v10 + 1);
                  }
                  else
                  {
                    OpenCoreNum3 >>= 1;
                  }
                  goto LABEL_32;
                }
                ++v16;
                if ( (OpenCoreNum2 & 1) != 0 )
                {
                  OpenCoreNum2 >>= 1;
                  v10 = (unsigned __int8)(v10 + 1);
                }
                else
                {
                  OpenCoreNum2 >>= 1;
                }
                if ( v16 >= v1 )
                {
LABEL_39:
                  v9 = v29;
                  v6 = v28;
                  goto LABEL_20;
                }
              }
              if ( (OpenCoreNum1 & 1) != 0 )
              {
                OpenCoreNum1 >>= 1;
                v10 = (unsigned __int8)(v10 + 1);
              }
              else
              {
                OpenCoreNum1 >>= 1;
              }
LABEL_32:
              if ( ++v16 >= v1 )
                goto LABEL_39;
              continue;
            }
          }
          if ( v7 >> 26 <= 0x11 )
          {
            v1 = v7 >> 26;
            v10 = v7 >> 26;
LABEL_20:
            v11 = (unsigned int *)((char *)&repeated_nonce_id[13][6] + v6);
            v12 = *(unsigned int *)((char *)&repeated_nonce_id[16][32] + v6);
            v11[778] = v9;
            v11[762] = v7;
            if ( v12 <= 0x1387 )
            {
              nonce = cgpu.works[v10][v12].nonce;
              v11[810] = nonce;
              if ( v7 == nonce )
              {
                v19 = (chainIndex << 8) + v1;
                if ( v12 == *((_DWORD *)&cgpu + v19 + 640664) )
                {
                  ++*(int *)((char *)asic_core_nonce_num[16][0] + v6);
                }
                else
                {
                  *((_DWORD *)&cgpu + v19 + 640664) = v12;
                  v20 = (char *)&asic_nonce_num[13][124] + v6;
                  v25 = total_valid_nonce_num;
                  v21 = *((_DWORD *)v20 + 644);
                  ++repeated_nonce_id[16][v19 + 130];
                  real_asic_num = cgpu.real_asic_num;
                  *((_DWORD *)v20 + 644) = v21 + 1;
                  total_valid_nonce_num = v25 + 1;
                  if ( real_asic_num != 1 )
                  {
                    if ( conf.core > 64 )
                    {
                      if ( (unsigned int)(conf.core - 65) > 0x3F )
                      {
                        printf("%s: conf.core = %d, but it is error\n", (const char *)_FUNCTION___12328, conf.core);
                      }
                      else
                      {
                        v22 = v7 & 0x7F;
                        which_core_nonce = v22;
                        if ( v22 > 0x38 && v22 - 64 <= 0x3F )
                          which_core_nonce = (unsigned __int8)(v22 - 7);
                      }
                    }
                    else
                    {
                      which_core_nonce = v7 & 0x3F;
                    }
                    v23 = &asic_nonce_num[(chainIndex << 8) + v1 + 13][which_core_nonce + 124];
                    ++v23[661];
                  }
                }
              }
              else
              {
                ++*(int *)((char *)&asic_core_nonce_num[16][0][16] + v6);
              }
            }
          }
        }
LABEL_9:
        if ( v4 == ++v2 )
          goto LABEL_2;
      }
    }
    usleep(0x3E8u);
  }
LABEL_5:
  result = 0;
  receiveExit = 1;
  return result;
}

//----- (00016318) --------------------------------------------------------
int __fastcall doTestBoard(int test_times)
{
  unsigned int *v1; // r6
  int v2; // r4
  int v3; // r0
  int asicNum; // r5
  int dataCount; // r6
  int v6; // r0
  unsigned int *v7; // r4
  testpatten_work **v8; // r2
  testpatten_work **v9; // r3
  unsigned int *v10; // r4
  int v11; // r7
  unsigned int v12; // t1
  char ChainAsicNum; // r0
  _BOOL4 v14; // r2
  int v15; // r2
  unsigned int *v16; // r5
  int j; // r4
  unsigned int v18; // t1
  int v19; // r2
  int v20; // r0
  bool v21; // r3
  int v22; // r10
  int v23; // r8
  int v24; // r4
  FILE **v25; // r1
  int v26; // r5
  int v27; // r4
  int v28; // r11
  FILE *v29; // r0
  int v30; // r3
  int v31; // r0
  char *v32; // r2
  char v33; // r1
  int k; // r3
  char *v35; // r2
  char v36; // r1
  unsigned int *v37; // r3
  unsigned int *v38; // r1
  int m; // r2
  int v40; // r2
  int v41; // r3
  int v42; // r2
  int v43; // r4
  int v44; // r2
  int ii; // r1
  int v46; // r5
  int jj; // r4
  unsigned int v48; // r2
  int v49; // r4
  int v50; // r10
  int v51; // r8
  int v52; // r9
  int v53; // r5
  FILE *v54; // r2
  int v55; // r0
  unsigned int CommandMode; // r3
  int v57; // r2
  char *v58; // r1
  char v59; // lr
  int n; // r3
  char *v61; // r1
  char v62; // lr
  int *v63; // r3
  int *v64; // r2
  unsigned int *v65; // r1
  int v66; // r0
  int v67; // r10
  int v68; // r12
  int v69; // lr
  int *v70; // r2
  int v71; // r1
  int v72; // r12
  int v73; // lr
  int v74; // r0
  int v75; // r7
  unsigned int OpenCoreNum2; // r6
  unsigned int OpenCoreNum1; // r4
  unsigned int OpenCoreNum3; // r9
  unsigned int OpenCoreNum4; // r10
  const char *v80; // r1
  int v81; // r11
  unsigned int real_asic_num; // lr
  int v83; // r5
  int *v84; // r8
  int v85; // r3
  int v86; // r2
  int v87; // r0
  int v88; // r6
  int *v89; // r0
  int v90; // r2
  int v91; // r9
  int v92; // r10
  int v93; // r11
  char *v94; // r12
  int v95; // r1
  int *v96; // r3
  int v97; // t1
  int v98; // r3
  int (*v99)[256]; // r5
  int (*v100)[256]; // r4
  bool v101; // cc
  int v102; // r3
  bool v103; // cc
  int ChainAsicFreqIndex; // r0
  int freqvalue_by_index; // r0
  int v106; // r4
  int v107; // r0
  int v108; // r0
  int v109; // r4
  int *v110; // r5
  int v111; // r3
  int v112; // t1
  int v113; // r2
  int v114; // r2
  int v115; // r5
  int v116; // r9
  int (*v117)[256]; // r10
  int (*v118)[256]; // r11
  unsigned int v119; // r3
  int v120; // r2
  int v122; // r2
  unsigned int nonce_fifo_interrupt; // r0
  int v126; // [sp+8h] [bp-3D0h]
  int CoreNum; // [sp+8h] [bp-3D0h]
  int v128; // [sp+Ch] [bp-3CCh]
  int v129; // [sp+Ch] [bp-3CCh]
  FILE **v130; // [sp+10h] [bp-3C8h]
  int (*v131)[256]; // [sp+10h] [bp-3C8h]
  int (*v132)[256]; // [sp+18h] [bp-3C0h]
  int (*v133)[256]; // [sp+20h] [bp-3B8h]
  int (*v134)[256]; // [sp+24h] [bp-3B4h]
  int v135; // [sp+28h] [bp-3B0h]
  int v136; // [sp+2Ch] [bp-3ACh]
  int i; // [sp+34h] [bp-3A4h]
  unsigned int *p_CommandMode; // [sp+3Ch] [bp-39Ch]
  int v139; // [sp+40h] [bp-398h]
  int v140; // [sp+4Ch] [bp-38Ch]
  char v141[16]; // [sp+50h] [bp-388h]
  int v142; // [sp+60h] [bp-378h] BYREF
  int v143; // [sp+64h] [bp-374h]
  int v144; // [sp+68h] [bp-370h]
  int v145; // [sp+6Ch] [bp-36Ch]
  int v146; // [sp+70h] [bp-368h]
  int v147; // [sp+74h] [bp-364h]
  int v148; // [sp+78h] [bp-360h]
  int v149; // [sp+7Ch] [bp-35Ch]
  int v150; // [sp+80h] [bp-358h]
  int v151; // [sp+84h] [bp-354h]
  int v152; // [sp+88h] [bp-350h]
  int v153; // [sp+8Ch] [bp-34Ch]
  int v154; // [sp+90h] [bp-348h]
  int v155[3]; // [sp+94h] [bp-344h] BYREF
  _DWORD v156[5]; // [sp+A0h] [bp-338h] BYREF
  int v157[4]; // [sp+B4h] [bp-324h] BYREF
  unsigned int v158; // [sp+C4h] [bp-314h] BYREF
  unsigned int value; // [sp+C8h] [bp-310h] BYREF
  int v160; // [sp+CCh] [bp-30Ch]
  int v161; // [sp+D0h] [bp-308h]
  int v162; // [sp+D4h] [bp-304h]
  int v163; // [sp+D8h] [bp-300h]
  int v164; // [sp+DCh] [bp-2FCh]
  int v165; // [sp+E0h] [bp-2F8h]
  int v166; // [sp+E4h] [bp-2F4h]
  int v167; // [sp+E8h] [bp-2F0h]
  int v168; // [sp+ECh] [bp-2ECh]
  int v169; // [sp+F0h] [bp-2E8h]
  int v170; // [sp+F4h] [bp-2E4h]
  int v171; // [sp+F8h] [bp-2E0h]
  unsigned int v172; // [sp+FCh] [bp-2DCh] BYREF
  unsigned int v173; // [sp+100h] [bp-2D8h] BYREF
  unsigned int v174; // [sp+104h] [bp-2D4h]
  int v175; // [sp+108h] [bp-2D0h]
  int v176[41]; // [sp+10Ch] [bp-2CCh] BYREF
  unsigned __int8 logstr[256]; // [sp+1B0h] [bp-228h] BYREF
  char s[296]; // [sp+2B0h] [bp-128h] BYREF

  p_CommandMode = &cgpu.CommandMode;
  memset(asic_nonce_num, 0, sizeof(asic_nonce_num));
  memset(asic_core_nonce_num, 0, sizeof(asic_core_nonce_num));
  v1 = &cgpu.CommandMode;
  memset(repeated_nonce_id, 255, sizeof(repeated_nonce_id));
  memset(err_nonce_num, 0, sizeof(err_nonce_num));
  memset(last_nonce_num, 0, sizeof(last_nonce_num));
  memset(repeated_nonce_num, 0, sizeof(repeated_nonce_num));
  memset(valid_nonce_num, 0, sizeof(valid_nonce_num));
  memset(send_work_num, 0, sizeof(send_work_num));
  v2 = 0;
  total_valid_nonce_num = 0;
  start_receive = 1;
  do
  {
    v3 = v2++;
    v1[1] = getChainExistFlag(v3);
    ++v1;
  }
  while ( v2 != 16 );
  asicNum = conf.asicNum;
  if ( conf.asicNum > 0 )
  {
    dataCount = conf.dataCount;
    v6 = 0;
    v7 = &cgpu.results[127][4999];
    v8 = &cgpu.works[conf.dataCount + 127];
    do
    {
      if ( dataCount > 0 )
      {
        v9 = &cgpu.works[5000 * v6 + 127];
        do
        {
          v9[1] = 0;
          ++v9;
        }
        while ( v9 != v8 );
      }
      ++v6;
      v8 += 5000;
      v7[1] = 0;
      ++v7;
    }
    while ( v6 != asicNum );
  }
  cgpu.real_asic_num = 18;
  cgpu.index = 0;
  v10 = &cgpu.CommandMode;
  cgpu.repeated_nonce = 0;
  cgpu.err_nonce = 0;
  cgpu.asicNum = asicNum;
  cgpu.valid_nonce = 0;
  v11 = 0;
  cgpu.CommandMode = 0;
  cgpu.AsicType = 1387;
  cgpu.core_num = conf.core;
  pthread_mutex_lock(&opencore_readtemp_mutex);
  do
  {
    while ( 1 )
    {
      v12 = v10[1];
      ++v10;
      if ( v12 )
      {
        ChainAsicNum = getChainAsicNum(v11);
        v14 = chain_need_opencore[v11];
        *((_BYTE *)&cgpu.result_array[-100749] + (_DWORD)&cgpu + v11) = ChainAsicNum;
        if ( v14 )
          break;
      }
      if ( ++v11 == 16 )
        goto LABEL_15;
    }
    sprintf((char *)logstr, "do open core on Chain[%d]...\n", v11);
    writeLogFile(logstr);
    open_core_one_chain(v11, 1);
    v15 = v11++;
    sprintf((char *)logstr, "Done open core on Chain[%d]!\n", v15);
    writeLogFile(logstr);
  }
  while ( v11 != 16 );
LABEL_15:
  pthread_mutex_unlock(&opencore_readtemp_mutex);
  if ( !gBegin_get_nonce )
  {
    puts("clement2 set_nonce_fifo_interrupt");
    nonce_fifo_interrupt = get_nonce_fifo_interrupt();
    set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
    gBegin_get_nonce = 1;
  }
  v16 = &cgpu.CommandMode;
  for ( j = 0; j != 16; ++j )
  {
    v18 = v16[1];
    ++v16;
    if ( v18 )
    {
      sprintf((char *)logstr, "start send works on chain[%d]\n", j);
      writeLogFile(logstr);
      StartSendFlag[j] = 1;
    }
  }
  v142 = 255;
  v19 = 0;
  v20 = 0;
  v163 = 0;
  v164 = 0;
  v165 = 0;
  v166 = 0;
  v167 = 0;
  v168 = 0;
  v169 = 0;
  v170 = 0;
  v171 = 0;
  v143 = 0;
  v144 = 0;
  v145 = 0;
  v146 = 0;
  v147 = 0;
  v148 = 0;
  v149 = 0;
  v150 = 0;
  v151 = 0;
  v152 = 0;
  v153 = 0;
  v154 = 0;
  value = 0;
  v160 = 0;
  v161 = 0;
  v162 = 0;
  v172 = 0;
  v173 = 0;
  v174 = 0;
  v175 = 0;
  memset(v176, 0, 36);
  do
  {
    v176[v19 + 25] = 0;
    v21 = StartSendFlag[v20];
    v176[v19 + 9] = 0;
    ++v19;
    v141[v20++] = v21;
  }
  while ( v20 != 16 );
  v22 = 0;
  do
  {
    v23 = 0;
    v126 = 0;
    while ( 1 )
    {
      if ( !*(int *)((char *)&cgpu.result_array[-100766] + (_DWORD)&cgpu + v23 * 4) || !v141[v126] )
        goto LABEL_45;
      v24 = v176[v23 + 9];
      if ( v24 <= 17 )
        break;
LABEL_42:
      v41 = v176[v23 + 25];
      v176[v23 + 9] = 0;
      v42 = chain_DataCount[v23];
      v176[v23 + 25] = ++v41;
      if ( v41 >= v42 )
        v141[v126] = 0;
      if ( v22 > 2000 )
        goto LABEL_75;
LABEL_45:
      ++v23;
      if ( ++v126 == 16 )
        goto LABEL_46;
    }
    v25 = &cgpu.fps[v24];
    v26 = 0;
    v27 = v24 + 1;
    v130 = v25;
    while ( (get_buffer_space() & (1 << v126)) != 0 )
    {
      if ( cgpu.CommandMode )
      {
        v28 = v176[v23 + 25];
        v142 = 0;
        v29 = v130[v26 + 167];
        v30 = 0;
        value = 0;
        v160 = 0;
        v161 = 0;
        v31 = (int)v29 + 52 * v28;
        LOBYTE(v162) = 0;
        v143 = 0;
        v144 = 0;
        v145 = 0;
        v146 = 0;
        v147 = 0;
        v148 = 0;
        v149 = 0;
        v150 = 0;
        v151 = 0;
        v152 = 0;
        v153 = 0;
        v154 = 0;
        LOBYTE(v142) = 1;
        *(_WORD *)((char *)&v142 + 1) = (unsigned __int8)v126 | 0x80;
        do
        {
          v32 = (char *)&v142 + v30;
          v33 = *(_BYTE *)(v31 + v30++ + 20);
          v32[4] = v33;
        }
        while ( v30 != 32 );
        for ( k = 0; k != 12; ++k )
        {
          v35 = (char *)&v142 + k;
          v36 = *(_BYTE *)(v31 + k + 8);
          v35[40] = v36;
        }
        v37 = (unsigned int *)&v142;
        v38 = &v158;
        for ( m = 1; ; ++m )
        {
          v38[1] = _byteswap_ulong(*v37);
          ++v38;
          if ( m == 10 )
          {
            v168 = v28;
          }
          else if ( m == 13 )
          {
            pthread_mutex_lock(&opencore_readtemp_mutex);
            set_TW_write_command(&value);
            pthread_mutex_unlock(&opencore_readtemp_mutex);
            v40 = v27;
            v176[v23 + 9] = v27;
            goto LABEL_41;
          }
          ++v37;
        }
      }
      v155[0] = cgpu.CommandMode;
      v155[2] = cgpu.CommandMode;
      v54 = v130[v26 + 167];
      v55 = v176[v23 + 25];
      CommandMode = cgpu.CommandMode;
      v156[1] = cgpu.CommandMode;
      v156[2] = cgpu.CommandMode;
      v156[3] = cgpu.CommandMode;
      v156[4] = cgpu.CommandMode;
      v57 = (int)v54 + 52 * v55;
      v157[0] = cgpu.CommandMode;
      v172 = cgpu.CommandMode;
      v157[1] = cgpu.CommandMode;
      v157[2] = cgpu.CommandMode;
      v157[3] = cgpu.CommandMode;
      v173 = cgpu.CommandMode;
      v174 = cgpu.CommandMode;
      LOBYTE(v175) = cgpu.CommandMode;
      v156[0] = cgpu.CommandMode;
      v158 = cgpu.CommandMode;
      v155[1] = v55;
      LOBYTE(v155[0]) = 1;
      BYTE1(v155[0]) = v126 | 0x80;
      do
      {
        v58 = (char *)v155 + CommandMode;
        v59 = *(_BYTE *)(v57 + CommandMode++ + 8);
        v58[8] = v59;
      }
      while ( CommandMode != 12 );
      for ( n = 0; n != 32; ++n )
      {
        v61 = (char *)v155 + n;
        v62 = *(_BYTE *)(v57 + n + 20);
        v61[20] = v62;
      }
      v63 = v155;
      v64 = v155;
      v173 = v55;
      v172 = (v126 << 16) | 0x1800000;
      v65 = &v173;
      do
      {
        v66 = *((unsigned __int8 *)v64 + 9);
        v67 = *((unsigned __int8 *)v64 + 8);
        v68 = *((unsigned __int8 *)v64 + 11);
        v69 = *((unsigned __int8 *)v64++ + 10);
        v65[1] = (v66 << 16) | (v67 << 24) | v68 | (v69 << 8);
        ++v65;
      }
      while ( v64 != v156 );
      v70 = v176;
      do
      {
        v71 = *((unsigned __int8 *)v63 + 21);
        v72 = *((unsigned __int8 *)v63 + 20);
        v73 = *((unsigned __int8 *)v63 + 23);
        v74 = *((unsigned __int8 *)v63++ + 22);
        v70[1] = (v71 << 16) | (v72 << 24) | v73 | (v74 << 8);
        ++v70;
      }
      while ( v63 != v157 );
      pthread_mutex_lock(&opencore_readtemp_mutex);
      set_TW_write_command_vil(&v172);
      pthread_mutex_unlock(&opencore_readtemp_mutex);
      v40 = v27;
      v176[v23 + 9] = v27;
LABEL_41:
      ++v27;
      ++v26;
      v22 = 0;
      ++send_work_num[v23];
      if ( v40 > 17 )
        goto LABEL_42;
    }
    if ( ++v22 <= 2000 )
      goto LABEL_45;
LABEL_75:
    strcpy(s, "Fatal Error: send work timeout\n");
    writeLogFile((unsigned __int8 *)s);
LABEL_46:
    v43 = 1;
    usleep(0x1388u);
    v44 = 0;
    for ( ii = 0; ii != 16; ++ii )
    {
      if ( *(int *)((char *)&cgpu.result_array[-100766] + (_DWORD)&cgpu + v44 * 4)
        && StartSendFlag[ii]
        && v176[v44 + 25] < chain_DataCount[v44] )
      {
        v43 = 0;
      }
      ++v44;
    }
  }
  while ( !v43 );
  v46 = 0;
  for ( jj = 0; jj != 16; ++jj )
  {
    while ( !*(int *)((char *)&cgpu.result_array[-100766] + (_DWORD)&cgpu + v46 * 4) || !StartSendFlag[jj] )
    {
      ++jj;
      ++v46;
      if ( jj == 16 )
        goto LABEL_58;
    }
    v48 = send_work_num[v46];
    StartSendFlag[jj] = 0;
    ++v46;
    sprintf(s, "get send work num :%d on Chain[%d]\n", v48, jj);
    writeLogFile((unsigned __int8 *)s);
    sendExit[jj] = 1;
  }
LABEL_58:
  v49 = 0;
  v50 = 0;
  do
  {
LABEL_60:
    if ( *(int *)((char *)&cgpu.result_array[-100766] + (_DWORD)&cgpu + v49 * 4) )
    {
      v51 = 0;
      v52 = 0;
      sprintf((char *)logstr, "wait recv nonce on chain[%d]\n", v50);
      writeLogFile(logstr);
      while ( 1 )
      {
        v53 = valid_nonce_num[v49];
        if ( v53 >= chain_ValidNonce[v49] )
          break;
        if ( v52 == v53 )
        {
          ++v51;
          usleep((__useconds_t)&loc_186A0);
          if ( v51 > 19 )
          {
            ++v49;
            ++v50;
            if ( v49 != 16 )
              goto LABEL_60;
            goto LABEL_78;
          }
        }
        else
        {
          usleep((__useconds_t)&loc_186A0);
          v52 = v53;
          v51 = 0;
        }
      }
    }
    ++v49;
    ++v50;
  }
  while ( v49 != 16 );
LABEL_78:
  v131 = last_result;
  gBegin_get_nonce = 0;
  v136 = 0;
  v135 = 0;
  i = 0;
  v134 = chain_badcore_num;
  v132 = asic_nonce_num;
  v133 = last_result_opencore;
  start_receive = 0;
  while ( 2 )
  {
    if ( !*(int *)((char *)&cgpu.result_array[-100766] + (_DWORD)&cgpu + v135 * 4) )
      goto LABEL_79;
    sprintf((char *)logstr, "get nonces on chain[%d]\n", i);
    writeLogFile(logstr);
    v75 = chain_PassCount[v135];
    v139 = chain_ValidNonce[v135];
    OpenCoreNum2 = conf.OpenCoreNum2;
    OpenCoreNum1 = conf.OpenCoreNum1;
    OpenCoreNum3 = conf.OpenCoreNum3;
    OpenCoreNum4 = conf.OpenCoreNum4;
    puts("\n------------------------------------------------------------------------------------------------------");
    if ( conf.CommandMode )
      puts("Command mode is FIL");
    else
      puts("Command mode is VIL");
    if ( cgpu.real_asic_num == 1 )
    {
      printf("Open core number : Conf.OpenCoreNum1 = %ud = 0x%x\n", Conf.OpenCoreNum1, Conf.OpenCoreNum1);
      printf("Open core number : Conf.OpenCoreNum2 = %ud = 0x%x\n", Conf.OpenCoreNum2, Conf.OpenCoreNum2);
      printf("Open core number : Conf.OpenCoreNum3 = %ud = 0x%x\n", Conf.OpenCoreNum3, Conf.OpenCoreNum3);
      printf("Open core number : Conf.OpenCoreNum4 = %ud = 0x%x\n", Conf.OpenCoreNum4, Conf.OpenCoreNum4);
      CoreNum = Conf.CoreNum;
    }
    else
    {
      CoreNum = cgpu.real_asic_num;
    }
    sprintf(s, "require nonce number:%d\n", v75);
    writeLogFile((unsigned __int8 *)s);
    sprintf(s, "require validnonce number:%d\n", v139);
    writeLogFile((unsigned __int8 *)s);
    if ( CoreNum <= 0 )
    {
      v83 = 3;
      goto LABEL_113;
    }
    v128 = 0;
    v81 = 0;
    real_asic_num = cgpu.real_asic_num;
    v83 = 3;
    v84 = asic_nonce_num[i];
LABEL_91:
    while ( 2 )
    {
      if ( real_asic_num == 1 )
        v80 = "core[%02d]=%02d\t";
      if ( real_asic_num != 1 )
        v80 = "asic[%02d]=%02d\t";
      sprintf(s, v80, v81, *v84);
      writeLogFile((unsigned __int8 *)s);
      if ( (v81 & 7) == 7 )
      {
        strcpy(s, "\n");
        writeLogFile((unsigned __int8 *)s);
      }
      real_asic_num = cgpu.real_asic_num;
      if ( cgpu.real_asic_num == 1 )
      {
        if ( v128 > 127 )
          goto LABEL_90;
        v85 = v128;
        v86 = 0;
        v80 = (char *)asic_nonce_num + 4 * v128 + 4 * v136;
        while ( 2 )
        {
          while ( v85 > 31 )
          {
            if ( (unsigned int)(v85 - 32) > 0x1F )
            {
              if ( (unsigned int)(v85 - 64) > 0x1F )
              {
                if ( (OpenCoreNum4 & 1) != 0 )
                {
                  OpenCoreNum4 >>= 1;
                  if ( v75 > *(_DWORD *)&v80[v86] )
                    v83 = 2;
                }
                else
                {
                  OpenCoreNum4 >>= 1;
                }
              }
              else if ( (OpenCoreNum3 & 1) != 0 )
              {
                OpenCoreNum3 >>= 1;
                if ( v75 > *(_DWORD *)&v80[v86] )
                  v83 = 2;
              }
              else
              {
                OpenCoreNum3 >>= 1;
              }
              goto LABEL_104;
            }
            if ( (OpenCoreNum2 & 1) == 0 )
            {
              OpenCoreNum2 >>= 1;
              goto LABEL_104;
            }
            v87 = *(_DWORD *)&v80[v86];
            ++v85;
            OpenCoreNum2 >>= 1;
            v86 += 4;
            if ( v75 > v87 )
              v83 = 2;
            if ( v85 == 128 )
            {
LABEL_112:
              ++v81;
              ++v84;
              v128 = 128;
              if ( v81 == CoreNum )
                goto LABEL_113;
              goto LABEL_91;
            }
          }
          if ( (OpenCoreNum1 & 1) != 0 )
          {
            OpenCoreNum1 >>= 1;
            if ( v75 > *(_DWORD *)&v80[v86] )
              v83 = 2;
          }
          else
          {
            OpenCoreNum1 >>= 1;
          }
LABEL_104:
          ++v85;
          v86 += 4;
          if ( v85 == 128 )
            goto LABEL_112;
          continue;
        }
      }
      if ( v75 > *v84 )
        v83 = 2;
LABEL_90:
      ++v81;
      ++v84;
      if ( v81 != CoreNum )
        continue;
      break;
    }
LABEL_113:
    if ( Conf.StartSensor <= 0 || cgpu.real_asic_num == 1 )
    {
      strcpy(s, "\n\n");
      writeLogFile((unsigned __int8 *)s);
      if ( CoreNum > 0 )
        goto LABEL_139;
    }
    else
    {
      v88 = v75 / Conf.CoreNum;
      sprintf(
        s,
        "\n\n\nBelow ASIC's core didn't receive all the nonce, they should receive %d nonce each!\n\n",
        v75 / Conf.CoreNum);
      writeLogFile((unsigned __int8 *)s);
      if ( CoreNum <= 0 )
      {
        strcpy(s, "\n\n");
        writeLogFile((unsigned __int8 *)s);
      }
      else
      {
        v91 = 0;
        v92 = 0;
        v140 = v83;
        v93 = i << 16;
        v94 = &s[2];
        v129 = i << 8;
        do
        {
          if ( Conf.CoreNum > 0 )
          {
            v94 = (char *)asic_core_nonce_num;
            v95 = 0;
            v89 = &total_valid_nonce_num + Conf.CoreNum + v93;
            v96 = &asic_core_nonce_num[0][v129 - 1][256 * v92 + 255];
            do
            {
              v97 = v96[1];
              ++v96;
              v90 = v97;
              if ( v97 > 0 )
                ++v95;
            }
            while ( v96 != v89 );
          }
          else
          {
            v95 = 0;
          }
          v98 = (*v134)[v91];
          v99 = v132;
          v100 = (int (*)[256])(Conf.CoreNum - v98);
          v101 = Conf.CoreNum - v98 <= v95;
          if ( Conf.CoreNum - v98 > v95 )
          {
            v100 = v133;
            v89 = 0;
          }
          else
          {
            v94 = (char *)v133;
            v90 = 1;
          }
          if ( Conf.CoreNum - v98 <= v95 )
            *(_DWORD *)&v94[v91 * 4] = v90;
          v90 = v75 - v98 * v88;
          v102 = (*v132)[v91];
          if ( !v101 )
            (*v100)[v91] = (int)v89;
          v103 = v102 < v90;
          if ( v102 >= v90 )
          {
            v99 = v131;
            v90 = 1;
          }
          else
          {
            v100 = v131;
            v89 = 0;
          }
          if ( v103 )
            (*v100)[v91] = (int)v89;
          else
            (*v99)[v91] = v90;
          if ( v75 > v102 )
          {
            sprintf(s, "asic[%02d]=%02d\n", v92, v102);
            writeLogFile((unsigned __int8 *)s);
            if ( Conf.CoreNum > 0 )
            {
              v109 = 0;
              v110 = &asic_core_nonce_num[0][v129 - 1][256 * v92 + 255];
              do
              {
                v112 = v110[1];
                ++v110;
                v111 = v112;
                v113 = v109++;
                if ( v88 != v112 )
                {
                  sprintf(s, "core[%03d]=%d\t", v113, v111);
                  writeLogFile((unsigned __int8 *)s);
                }
              }
              while ( v109 < Conf.CoreNum );
            }
            strcpy(s, "\n\n");
            writeLogFile((unsigned __int8 *)s);
          }
          ++v92;
          ++v91;
          v93 += 256;
        }
        while ( v92 != CoreNum );
        v83 = v140;
        strcpy(s, "\n\n");
        writeLogFile((unsigned __int8 *)s);
LABEL_139:
        ChainAsicFreqIndex = getChainAsicFreqIndex(i, 0);
        freqvalue_by_index = get_freqvalue_by_index(ChainAsicFreqIndex);
        v106 = 0;
        sprintf(s, "freq[%02d]=%d\t", 0, freqvalue_by_index);
        writeLogFile((unsigned __int8 *)s);
        while ( CoreNum > ++v106 )
        {
          v107 = getChainAsicFreqIndex(i, v106);
          v108 = get_freqvalue_by_index(v107);
          sprintf(s, "freq[%02d]=%d\t", v106, v108);
          writeLogFile((unsigned __int8 *)s);
          if ( v106 % 8 == 7 )
          {
            strcpy(s, "\n");
            writeLogFile((unsigned __int8 *)s);
          }
        }
      }
    }
    strcpy(s, "\n\n");
    writeLogFile((unsigned __int8 *)s);
    v114 = valid_nonce_num[v135];
    if ( v139 > v114 )
      v83 = 2;
    sprintf(s, "total valid nonce number:%d\n", v114);
    writeLogFile((unsigned __int8 *)s);
    sprintf(s, "total send work number:%d\n", send_work_num[v135]);
    writeLogFile((unsigned __int8 *)s);
    sprintf(s, "require valid nonce number:%d\n", v139);
    writeLogFile((unsigned __int8 *)s);
    sprintf(s, "repeated_nonce_num:%d\n", repeated_nonce_num[v135]);
    writeLogFile((unsigned __int8 *)s);
    sprintf(s, "err_nonce_num:%d\n", err_nonce_num[v135]);
    writeLogFile((unsigned __int8 *)s);
    sprintf(s, "last_nonce_num:%d\n", last_nonce_num[v135]);
    writeLogFile((unsigned __int8 *)s);
    result = v83;
LABEL_79:
    ++v135;
    ++v131;
    ++i;
    v136 += 256;
    ++v132;
    ++v133;
    ++v134;
    if ( v135 != 16 )
      continue;
    break;
  }
  v115 = 1;
  v116 = 0;
  v117 = last_result;
  v118 = last_result_opencore;
  do
  {
    v119 = p_CommandMode[1];
    ++p_CommandMode;
    if ( v119 )
    {
      v120 = 0;
      while ( (*v118)[v120++] )
      {
        if ( v120 == 18 )
        {
          sprintf((char *)logstr, "chain[%d]: All chip cores are opened OK!\n", v116);
          writeLogFile(logstr);
          chain_need_opencore[v116] = 0;
          isChainAllCoresOpened[v116] = 1;
          goto LABEL_173;
        }
      }
      sprintf((char *)logstr, "chain[%d]: some chip cores are not opened FAILED!\n", v116);
      writeLogFile(logstr);
      chain_need_opencore[v116] = 1;
      isChainAllCoresOpened[v116] = 0;
LABEL_173:
      v122 = 0;
      while ( (*v117)[v122++] )
      {
        if ( v122 == 18 )
        {
          sprintf((char *)logstr, "Test Patten on chain[%d]: OK!\n", v116);
          writeLogFile(logstr);
          goto LABEL_177;
        }
      }
      v115 = 0;
      sprintf((char *)logstr, "Test Patten on chain[%d]: FAILED!\n", v116);
      writeLogFile(logstr);
      search_freq_result[v116] = 0;
    }
LABEL_177:
    ++v116;
    ++v117;
    ++v118;
  }
  while ( v116 != 16 );
  return v115;
}
// 16BB0: variable 'v80' is possibly undefined
// 16CF6: variable 'v90' is possibly undefined
// 16CF6: variable 'v94' is possibly undefined
// 16D04: variable 'v89' is possibly undefined
// 16318: using guessed type char var_388[16];

//----- (0001711C) --------------------------------------------------------
int process_config()
{
  int CoreNum; // r3
  int Timeout; // r1
  int v2; // r3
  int DataCount; // r3
  int PassCount2; // r2
  int PassCount3; // r2
  int result; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-828h] BYREF

  conf.CommandMode = Conf.CommandMode;
  conf.TempSel = Conf.TempSel;
  conf.GetTempFrom = Conf.GetTempFrom;
  if ( Conf.CommandMode == 1 )
  {
    if ( Conf.GetTempFrom == 1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "Can't get temperature from ASIC in FIL mode!\n");
        applog(3, tmp42, 0);
      }
      return -1;
    }
  }
  else if ( !Conf.CommandMode && Conf.GetTempFrom == 1 )
  {
    cgpu.temp_sel = Conf.TempSel;
    cgpu.rfs = 1;
    cgpu.tfs = 3;
    if ( !(Conf.TempSensor2 + Conf.TempSensor1 + Conf.TempSensor3 + Conf.TempSensor4) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "Must set temperature sensor address!\n");
        applog(3, tmp42, 0);
        return -1;
      }
      return -1;
    }
    conf.TempSensor1 = Conf.TempSensor1;
    conf.TempSensor2 = Conf.TempSensor2;
    conf.TempSensor3 = Conf.TempSensor3;
    conf.TempSensor4 = Conf.TempSensor4;
    cgpu.T1_offset_value = Conf.DefaultTempOffset;
    conf.DefaultTempOffset = Conf.DefaultTempOffset;
    cgpu.T2_offset_value = Conf.DefaultTempOffset;
    cgpu.T3_offset_value = Conf.DefaultTempOffset;
    cgpu.T4_offset_value = Conf.DefaultTempOffset;
    conf.StartSensor = Conf.StartSensor;
    conf.StartTemp = Conf.StartTemp;
  }
  CoreNum = 4;
  conf.freq_e = Conf.freq_e;
  conf.freq_t = Conf.freq_t;
  conf.freq_m = Conf.freq_m;
  conf.force_freq = Conf.force_freq;
  conf.UseConfigVol = Conf.UseConfigVol;
  conf.OpenCoreNum1 = Conf.OpenCoreNum1;
  conf.OpenCoreNum2 = Conf.OpenCoreNum2;
  conf.core = Conf.CoreNum;
  conf.freq_a = Conf.freq_a;
  conf.OpenCoreNum3 = Conf.OpenCoreNum3;
  conf.OpenCoreNum4 = Conf.OpenCoreNum4;
  conf.AsicType = 1387;
  conf.asicNum = 32;
  Conf.AddrInterval = 4;
  conf.addrInterval = 4;
  if ( Conf.CoreNum == 1 || Conf.CoreNum == 2 )
  {
    CoreNum = Conf.CoreNum;
  }
  else if ( (unsigned int)(Conf.CoreNum - 3) > 1 )
  {
    if ( (unsigned int)(Conf.CoreNum - 5) > 3 )
    {
      if ( (unsigned int)(Conf.CoreNum - 9) > 7 )
      {
        if ( (unsigned int)(Conf.CoreNum - 17) > 0xF )
        {
          if ( (unsigned int)(Conf.CoreNum - 33) > 0x1F )
          {
            if ( (unsigned int)(Conf.CoreNum - 65) > 0x3F )
            {
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "actual_core_number = %d, but it is error\n", Conf.CoreNum);
                applog(7, tmp42, 0);
                CoreNum = -1;
              }
              else
              {
                CoreNum = -1;
              }
            }
            else
            {
              CoreNum = 128;
            }
          }
          else
          {
            CoreNum = 64;
          }
        }
        else
        {
          CoreNum = 32;
        }
      }
      else
      {
        CoreNum = 16;
      }
    }
    else
    {
      CoreNum = 8;
    }
  }
  conf.IICPic = Conf.IICPic;
  conf.dac = Conf.dac;
  conf.ValidNonce1 = Conf.ValidNonce1;
  conf.Voltage1 = Conf.Voltage1;
  conf.testMode = Conf.TestMode;
  conf.Voltage2 = Conf.Voltage2;
  conf.ValidNonce2 = Conf.ValidNonce2;
  conf.Voltage3 = Conf.Voltage3;
  conf.ValidNonce3 = Conf.ValidNonce3;
  conf.Pic = Conf.Pic;
  conf.OpenCoreGap = Conf.OpenCoreGap;
  conf.month = Conf.month;
  conf.date = Conf.date;
  conf.checktemp = Conf.checktemp;
  conf.freq = Conf.Freq;
  conf.year = Conf.year;
  conf.hour = Conf.hour;
  Timeout = Conf.Timeout;
  conf.minute = Conf.minute;
  conf.second = Conf.second;
  if ( Conf.Timeout <= 0 )
  {
    Timeout = 95 * (conf.addrInterval * (0x1000000 / CoreNum) / Conf.Freq) / 100;
    conf.timeout = Timeout;
  }
  else
  {
    conf.timeout = Conf.Timeout;
  }
  v2 = (unsigned int)&asic_core_nonce_num[0][121][229] / ((1666666 / Timeout) << 9) - 1;
  conf.baud = v2;
  if ( v2 > 26 )
  {
    conf.baud = 26;
    goto LABEL_29;
  }
  if ( v2 <= 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "$$$$Config argument Baudrate:%d err\n", v2);
      applog(3, tmp42, 0);
      return -1;
    }
    return -1;
  }
LABEL_29:
  DataCount = Conf.DataCount;
  if ( (unsigned int)(Conf.DataCount - 1) > 0x1387 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "$$$$Config argument DataCount:%d err\n", Conf.DataCount);
      applog(3, tmp42, 0);
    }
    DataCount = conf.dataCount;
  }
  else
  {
    conf.dataCount = Conf.DataCount;
  }
  if ( Conf.PassCount1 <= DataCount && Conf.PassCount1 >= 0 )
  {
    conf.passCount1 = Conf.PassCount1;
    goto LABEL_39;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
  {
LABEL_39:
    PassCount2 = Conf.PassCount2;
    if ( Conf.PassCount2 > DataCount )
      goto LABEL_51;
    goto LABEL_40;
  }
  snprintf((char *)tmp42, 0x800u, "$$$$Config argument DataCount:%d err\n", Conf.DataCount);
  applog(3, tmp42, 0);
  DataCount = conf.dataCount;
  PassCount2 = Conf.PassCount2;
  if ( Conf.PassCount2 > conf.dataCount )
    goto LABEL_51;
LABEL_40:
  if ( PassCount2 >= 0 )
  {
    conf.passCount2 = PassCount2;
    goto LABEL_43;
  }
LABEL_51:
  if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
  {
LABEL_43:
    PassCount3 = Conf.PassCount3;
    if ( Conf.PassCount3 <= DataCount )
      goto LABEL_44;
    goto LABEL_54;
  }
  snprintf((char *)tmp42, 0x800u, "$$$$Config argument DataCount:%d err\n", Conf.DataCount);
  applog(3, tmp42, 0);
  PassCount3 = Conf.PassCount3;
  if ( Conf.PassCount3 <= conf.dataCount )
  {
LABEL_44:
    if ( PassCount3 >= 0 )
    {
      conf.passCount3 = PassCount3;
      return 0;
    }
  }
LABEL_54:
  if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "$$$$Config argument DataCount:%d err\n", Conf.DataCount);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00017630) --------------------------------------------------------
int get_works()
{
  FILE *v0; // r4
  char *v1; // r10
  int v2; // r5
  void *v3; // r4
  int v4; // r0
  testpatten_work *v5; // r0
  int v6; // r11
  int v7; // lr
  unsigned int v8; // r8
  unsigned int v9; // r12
  unsigned int v10; // r0
  char *v11; // r4
  unsigned int v12; // r7
  testpatten_work *v13; // r5
  char *v14; // r7
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r0
  int v20; // r1
  int v21; // r2
  unsigned int v22; // r3
  bool v23; // cf
  int v24; // r0
  int v25; // r1
  int v26; // r2
  FILE *v27; // r0
  int v28; // r5
  int v29; // r3
  int v30; // r2
  int *subid; // r0
  int v32; // r1
  int min_work_subid; // r4
  int v34; // t1
  testpatten_work *j; // [sp+Ch] [bp-88Ch]
  testpatten_cgpu_info *v37; // [sp+14h] [bp-884h]
  int v38; // [sp+18h] [bp-880h]
  int i; // [sp+1Ch] [bp-87Ch]
  int loop; // [sp+24h] [bp-874h]
  unsigned int v41; // [sp+2Ch] [bp-86Ch] BYREF
  unsigned __int8 strFilePath[64]; // [sp+30h] [bp-868h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+70h] [bp-828h] BYREF

  memset(strFilePath, 0, sizeof(strFilePath));
  loop = conf.asicNum;
  if ( conf.asicNum <= 0 )
  {
    v29 = 0;
    min_work_subid = cgpu.subid[0];
    cgpu.min_work_subid = cgpu.subid[0];
LABEL_21:
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "min work minertest[%d]:%d\n\n\n", v29, min_work_subid);
      applog(7, tmp42, 0);
      min_work_subid = cgpu.min_work_subid;
    }
    if ( conf.dataCount <= min_work_subid )
      return 0;
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "$$$$dataCount=%d, but min work subid=%d\n", conf.dataCount, min_work_subid);
LABEL_42:
      applog(3, tmp42, 0);
    }
  }
  else
  {
    v38 = 0;
    i = 0;
    v37 = &cgpu;
    while ( 1 )
    {
      sprintf((char *)strFilePath, "%s%02i.bin", (const char *)cgpu.workdataPathPrefix, ++i);
      v0 = fopen((const char *)strFilePath, "rb");
      cgpu.fps[v38] = v0;
      if ( !v0 )
        break;
      v41 = (unsigned int)&loc_3A97E + 2;
      v1 = (char *)malloc((size_t)&loc_3A97E + 2);
      fseek(v0, 0, 2);
      v2 = ftell(cgpu.fps[v38]);
      fseek(cgpu.fps[v38], 0, 0);
      v3 = malloc(v2);
      v4 = fread(v3, 1u, v2, cgpu.fps[v38]);
      uncompress((int)v1, (int *)&v41, (unsigned int)v3, v4);
      free(v3);
      v5 = (testpatten_work *)malloc(0x3F7A0u);
      v37->works[0] = v5;
      if ( v5 )
      {
        v6 = v41;
        if ( v41 )
        {
          v7 = 0;
          v8 = 48;
          v9 = 0;
          v6 = 0;
          for ( j = v5; ; j = v37->works[0] )
          {
            v10 = *(_DWORD *)&v1[v9 + 44];
            v11 = &v1[v9];
            v12 = v9 + 32;
            v9 = v8;
            v13 = &j[v7];
            v13->nonce = v10;
            v14 = &v1[v12];
            v13->nonce = bswap32(j[v7].nonce);
            v15 = *(_DWORD *)v11;
            v16 = *((_DWORD *)v11 + 1);
            v17 = *((_DWORD *)v11 + 2);
            v18 = *((_DWORD *)v11 + 3);
            v11 += 16;
            *(_DWORD *)v13->midstate = v15;
            *(_DWORD *)&v13->midstate[4] = v16;
            *(_DWORD *)&v13->midstate[8] = v17;
            *(_DWORD *)&v13->midstate[12] = v18;
            v19 = *(_DWORD *)v11;
            v20 = *((_DWORD *)v11 + 1);
            v21 = *((_DWORD *)v11 + 2);
            *(_DWORD *)&v13->midstate[28] = *((_DWORD *)v11 + 3);
            v22 = v41;
            *(_DWORD *)&v13->midstate[16] = v19;
            *(_DWORD *)&v13->midstate[20] = v20;
            *(_DWORD *)&v13->midstate[24] = v21;
            v23 = v8 >= v22;
            v24 = *(_DWORD *)v14;
            v25 = *((_DWORD *)v14 + 1);
            v26 = *((_DWORD *)v14 + 2);
            v8 += 48;
            j[v7].id = v6++;
            *(_DWORD *)v13->data = v24;
            ++v7;
            *(_DWORD *)&v13->data[4] = v25;
            *(_DWORD *)&v13->data[8] = v26;
            if ( v23 || v6 == 5000 )
              break;
          }
        }
        free(v1);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        v6 = 0;
        strcpy((char *)tmp42, "malloc struct testpatten_work err\n");
        applog(3, tmp42, 0);
      }
      else
      {
        v6 = opt_log_output;
      }
      *(int *)((char *)&cgpu.result_array[-100914] + (_DWORD)&cgpu + v38 * 4) = v6;
      v37 = (testpatten_cgpu_info *)((char *)v37 + 4);
      v27 = cgpu.fps[v38++];
      fclose(v27);
      if ( i == loop )
      {
        v28 = cgpu.subid[0];
        v29 = 0;
        v30 = 0;
        subid = cgpu.subid;
        cgpu.min_work_subid = cgpu.subid[0];
        v32 = cgpu.subid[0];
        min_work_subid = cgpu.subid[0];
        while ( 1 )
        {
          if ( v32 < min_work_subid )
          {
            v28 = v32;
            v29 = v30;
          }
          ++v30;
          if ( v32 < min_work_subid )
            min_work_subid = v28;
          if ( v30 == loop )
            break;
          v34 = subid[1];
          ++subid;
          v32 = v34;
        }
        cgpu.min_work_subid = v28;
        goto LABEL_21;
      }
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Open test file %s error\n", (const char *)strFilePath);
      goto LABEL_42;
    }
  }
  return -1;
}

//----- (00017970) --------------------------------------------------------
int configMiner()
{
  read_config();
  puts("\n\nRead Config.ini");
  printf("DataCount:%d\n", Conf.DataCount);
  printf("PassCount1:%d\n", Conf.PassCount1);
  printf("PassCount2:%d\n", Conf.PassCount2);
  printf("PassCount3:%d\n", Conf.PassCount3);
  printf("Freq:%d\n", Conf.Freq);
  printf("Timeout:%d\n", Conf.Timeout);
  printf("OpenCoreGap:%d\n", Conf.OpenCoreGap);
  printf("CheckTemp:%d\n", Conf.checktemp);
  printf("CoreNum:%d\n", Conf.CoreNum);
  printf("freq_e:%d\n", Conf.freq_e);
  printf("AsicNum:%d\n", Conf.AsicNum);
  printf("TestMode:%d\n", Conf.TestMode);
  printf("CheckChain:%d\n", Conf.CheckChain);
  printf("CommandMode:%d\n", Conf.CommandMode);
  printf("AsicType:%d\n", Conf.AsicType);
  printf("ValidNonce1:%d\n", Conf.ValidNonce1);
  printf("ValidNonce2:%d\n", Conf.ValidNonce2);
  printf("ValidNonce3:%d\n", Conf.ValidNonce3);
  printf("Pic:%ud\n", Conf.Pic);
  printf("IICPic:%ud\n", Conf.IICPic);
  printf("dac = %ud\n", Conf.dac);
  printf("Voltage1:%ud\n", Conf.Voltage1);
  printf("Voltage2:%ud\n", Conf.Voltage2);
  printf("Voltage3:%ud\n", Conf.Voltage3);
  printf("OpenCoreNum1 = %ud = 0x%x\n", Conf.OpenCoreNum1, Conf.OpenCoreNum1);
  printf("OpenCoreNum2 = %ud = 0x%x\n", Conf.OpenCoreNum2, Conf.OpenCoreNum2);
  printf("OpenCoreNum3 = %ud = 0x%x\n", Conf.OpenCoreNum3, Conf.OpenCoreNum3);
  printf("OpenCoreNum4 = %ud = 0x%x\n", Conf.OpenCoreNum4, Conf.OpenCoreNum4);
  printf("GetTempFrom:%d\n", Conf.GetTempFrom);
  printf("TempSel:%d\n", Conf.TempSel);
  printf("TempSensor1:%d\n", Conf.TempSensor1);
  printf("TempSensor2:%d\n", Conf.TempSensor2);
  printf("TempSensor3:%d\n", Conf.TempSensor3);
  printf("TempSensor4:%d\n", Conf.TempSensor4);
  printf("DefaultTempOffset:%d\n", Conf.DefaultTempOffset);
  printf("StartSensor:%d\n", Conf.StartSensor);
  printf("StartTemp:%d\n", Conf.StartTemp);
  printf("year:%04d\n", Conf.year);
  printf("month:%02d\n", Conf.month);
  printf("date:%02d\n", Conf.date);
  printf("hour:%02d\n", Conf.hour);
  printf("minute:%02d\n", Conf.minute);
  printf("second:%02d\n", Conf.second);
  puts(ptr);
  if ( process_config() < 0 )
    return -14;
  puts("\n\nparameter processed after Reading Config.ini");
  printf("DataCount:%d\n", conf.dataCount);
  printf("PassCount1:%d\n", conf.passCount1);
  printf("PassCount2:%d\n", conf.passCount2);
  printf("PassCount3:%d\n", conf.passCount3);
  printf("Freq:%d\n", conf.freq);
  printf("Timeout:%d\n", conf.timeout);
  printf("OpenCoreGap:%d\n", conf.OpenCoreGap);
  printf("CheckTemp:%d\n", conf.checktemp);
  printf("CoreNum:%d\n", conf.core);
  printf("AsicNum:%d\n", conf.asicNum);
  printf("TestMode:%d\n", conf.testMode);
  printf("CommandMode:%d\n", conf.CommandMode);
  printf("AsicType:%d\n", conf.AsicType);
  printf("ValidNonce1:%d\n", conf.ValidNonce1);
  printf("ValidNonce2:%d\n", conf.ValidNonce2);
  printf("ValidNonce3:%d\n", conf.ValidNonce3);
  printf("Pic:%ud\n", conf.Pic);
  printf("IICPic:%ud\n", conf.IICPic);
  printf("dac:%ud\n", conf.dac);
  printf("Voltage1:%ud\n", conf.Voltage1);
  printf("Voltage2:%ud\n", conf.Voltage2);
  printf("Voltage3:%ud\n", conf.Voltage3);
  printf("OpenCoreNum1 = %ud = 0x%x\n", conf.OpenCoreNum1, conf.OpenCoreNum1);
  printf("OpenCoreNum2 = %ud = 0x%x\n", conf.OpenCoreNum2, conf.OpenCoreNum2);
  printf("OpenCoreNum3 = %ud = 0x%x\n", conf.OpenCoreNum3, conf.OpenCoreNum3);
  printf("OpenCoreNum4 = %ud = 0x%x\n", conf.OpenCoreNum4, conf.OpenCoreNum4);
  printf("GetTempFrom:%d\n", conf.GetTempFrom);
  printf("TempSel:%d\n", conf.TempSel);
  printf("TempSensor1:%d\n", conf.TempSensor1);
  printf("TempSensor2:%d\n", conf.TempSensor2);
  printf("TempSensor3:%d\n", conf.TempSensor3);
  printf("TempSensor4:%d\n", conf.TempSensor4);
  printf("DefaultTempOffset:%d\n", conf.DefaultTempOffset);
  printf("StartSensor:%d\n", conf.StartSensor);
  printf("StartTemp:%d\n", conf.StartTemp);
  printf("year:%04d\n", conf.year);
  printf("month:%02d\n", conf.month);
  printf("date:%02d\n", conf.date);
  printf("hour:%02d\n", conf.hour);
  printf("minute:%02d\n", conf.minute);
  printf("second:%02d\n", conf.second);
  puts(ptr);
  if ( get_works() < 0 )
    return -14;
  else
    return 0;
}

//----- (00017DE8) --------------------------------------------------------
bool __fastcall clement_doTestBoard(bool showlog)
{
  bool *v1; // r3
  int (*v2)[256]; // r0
  int v3; // lr
  int v4; // r12
  int (*v5)[256]; // r4
  int v6; // r3
  char *v7; // r12
  int v8; // r0
  int (*v9)[256]; // r1
  int (*v10)[256]; // r2
  int i; // r3
  int v12; // r0
  int v13; // r1
  int j; // r2
  testpatten_cgpu_info *p_CommandMode; // r1
  int (*v16)[256]; // r5
  FILE *v17; // t1
  int v18; // r3
  bool v20; // r4
  int k; // [sp+4h] [bp-134h]
  unsigned __int8 logstr[256]; // [sp+10h] [bp-128h] BYREF

  showLogToKernelLog = showlog;
  if ( init_once > 0 )
  {
    memset(&cgpu, 0, (size_t)&cgpu.results[107][4268]);
    if ( configMiner() < 0 )
    {
      v20 = 0;
      puts("configMiner Error!");
      return v20;
    }
    init_once = 0;
    puts("single board test start");
    conf.dataCount = 912;
    ExitFlag = 0;
    receiveExit = 0;
    conf.passCount1 = 912;
    conf.passCount2 = 912;
    conf.passCount3 = 912;
    Conf.DataCount = 912;
    Conf.PassCount1 = 912;
    Conf.PassCount2 = 912;
    Conf.PassCount3 = 912;
    conf.ValidNonce1 = 16416;
    Conf.ValidNonce1 = 16416;
    conf.ValidNonce2 = 16416;
    Conf.ValidNonce2 = 16416;
    conf.ValidNonce3 = 16416;
    Conf.ValidNonce3 = 16416;
    pthread_create(&cgpu.receive_id, 0, receive_func, &cgpu);
    v1 = &chain_need_opencore[15];
    do
      *++v1 = 0;
    while ( v1 != &StartSendFlag[15] );
  }
  v2 = last_result;
  v3 = 0;
  v4 = 0;
  v5 = last_result_opencore;
  do
  {
    v6 = 0;
    testModeOKCounter[v3] = 0;
    do
    {
      (*v2)[v6] = 0;
      (*v5)[v6++] = 0;
    }
    while ( v6 != 256 );
    ++v2;
    chain_DataCount[v3] = 912;
    ++v5;
    chain_PassCount[v3] = 912;
    search_freq_result[v4] = 1;
    chain_need_opencore[v4++] = 0;
    chain_vol_value[v3] = 0;
    chain_vol_final[v3] = 0;
    chain_vol_added[v3] = 0;
    chain_ValidNonce[v3++] = 16416;
  }
  while ( v4 != 16 );
  k = 0;
  do
  {
    sprintf((char *)logstr, "do heat board 8xPatten for %d times\n", ++k);
    writeLogFile(logstr);
    v7 = (char *)&result + 3;
    v8 = 0;
    v9 = last_result_opencore;
    v10 = last_result;
    do
    {
      for ( i = 0; i != 256; ++i )
      {
        (*v10)[i] = 0;
        (*v9)[i] = 0;
      }
      chain_DataCount[v8] = 912;
      ++v10;
      chain_ValidNonce[v8] = 16416;
      ++v9;
      chain_PassCount[v8++] = 912;
      *++v7 = 1;
    }
    while ( v8 != 16 );
    v12 = doTestBoard(64);
    v13 = 0;
    for ( j = 0; j != 16; ++j )
    {
      if ( *(int *)((char *)&cgpu.result_array[-100766] + (_DWORD)&cgpu + v13 * 4) && search_freq_result[j] )
        ++testModeOKCounter[v13];
      ++v13;
    }
  }
  while ( !v12 && k == 1 );
  p_CommandMode = (testpatten_cgpu_info *)&cgpu.CommandMode;
  v16 = last_result_opencore;
  while ( 1 )
  {
    v17 = p_CommandMode->fps[1];
    p_CommandMode = (testpatten_cgpu_info *)((char *)p_CommandMode + 4);
    if ( v17 )
      break;
LABEL_26:
    ++v16;
    if ( p_CommandMode == (testpatten_cgpu_info *)&cgpu.chain_exist[15] )
    {
      v20 = 1;
      someBoardUpVoltage = 0;
      goto LABEL_28;
    }
  }
  v18 = 0;
  while ( (*v16)[v18++] )
  {
    if ( v18 == 18 )
      goto LABEL_26;
  }
  v20 = 0;
  someBoardUpVoltage = 1;
LABEL_28:
  set_PWM(0x64u);
  return v20;
}

//----- (00018048) --------------------------------------------------------
bool __fastcall clement_doTestBoardOnce(bool showlog)
{
  bool *v1; // r3
  int (*v2)[256]; // r5
  int v3; // r7
  int v4; // lr
  int (*v5)[256]; // r6
  int v6; // r2
  int v7; // r4
  int i; // r2

  showLogToKernelLog = showlog;
  if ( init_once > 0 )
  {
    memset(&cgpu, 0, (size_t)&cgpu.results[107][4268]);
    if ( configMiner() < 0 )
    {
      puts("configMiner Error!");
      return 0;
    }
    init_once = 0;
    puts("single board test start");
    ExitFlag = 0;
    receiveExit = 0;
    conf.dataCount = 912;
    conf.passCount1 = 912;
    conf.passCount2 = 912;
    conf.passCount3 = 912;
    Conf.DataCount = 912;
    Conf.PassCount1 = 912;
    Conf.PassCount2 = 912;
    Conf.PassCount3 = 912;
    conf.ValidNonce1 = 16416;
    Conf.ValidNonce1 = 16416;
    conf.ValidNonce2 = 16416;
    Conf.ValidNonce2 = 16416;
    conf.ValidNonce3 = 16416;
    Conf.ValidNonce3 = 16416;
    pthread_create(&cgpu.receive_id, 0, receive_func, &cgpu);
    v1 = &chain_need_opencore[15];
    do
      *++v1 = 0;
    while ( v1 != &StartSendFlag[15] );
  }
  v2 = last_result;
  v3 = 0;
  v4 = 0;
  v5 = last_result_opencore;
  do
  {
    v6 = 0;
    testModeOKCounter[v3] = 0;
    do
    {
      (*v2)[v6] = 0;
      v7 = 0;
      (*v5)[v6++] = 0;
    }
    while ( v6 != 256 );
    ++v2;
    search_freq_result[v4] = 1;
    ++v5;
    chain_DataCount[v3] = 912;
    chain_need_opencore[v4++] = 0;
    chain_vol_value[v3] = 0;
    chain_vol_final[v3] = 0;
    chain_vol_added[v3] = 0;
    chain_ValidNonce[v3] = 16416;
    chain_PassCount[v3++] = 912;
  }
  while ( v4 != 16 );
  doTestBoard(16416);
  for ( i = 0; i != 16; ++i )
  {
    if ( *(int *)((char *)&cgpu.result_array[-100766] + (_DWORD)&cgpu + v7 * 4) )
    {
      if ( search_freq_result[i] )
        ++testModeOKCounter[v7];
    }
    ++v7;
  }
  set_PWM(0x64u);
  return 1;
}

//----- (000181E8) --------------------------------------------------------
unsigned __int8 *__fastcall escape_string(unsigned __int8 *str, bool isjson)
{
  unsigned __int8 *v2; // r7
  unsigned int v3; // r4
  _BOOL4 v4; // r6
  unsigned __int8 *v5; // r2
  unsigned int v6; // r3
  int v7; // r5
  unsigned int v8; // t1
  unsigned int v9; // t1
  size_t v11; // r8
  _BYTE *v12; // r5
  _BYTE *v13; // r3
  unsigned __int8 *v14; // r2
  unsigned int v15; // t1
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v2 = str;
  v3 = *str;
  v4 = isjson;
  if ( *str )
  {
    v5 = str;
    v6 = *str;
    v7 = 0;
    while ( 1 )
    {
      if ( v6 == 61 )
        goto LABEL_10;
      if ( v6 <= 0x3D )
      {
        if ( v6 == 34 )
        {
          if ( isjson )
            goto LABEL_11;
          goto LABEL_5;
        }
        if ( v6 != 44 )
          goto LABEL_5;
LABEL_10:
        if ( !isjson )
          goto LABEL_11;
LABEL_5:
        v8 = *++v5;
        v6 = v8;
        if ( !v8 )
          goto LABEL_12;
      }
      else
      {
        if ( v6 != 92 )
        {
          if ( v6 != 124 )
            goto LABEL_5;
          goto LABEL_10;
        }
LABEL_11:
        v9 = *++v5;
        v6 = v9;
        ++v7;
        if ( !v9 )
        {
LABEL_12:
          if ( !v7 )
            return v2;
          v11 = v7 + 1 + strlen((const char *)str);
          v12 = malloc(v11);
          v13 = v12;
          if ( !v12 )
          {
            snprintf((char *)tmp42, 0x800u, (const char *)&_func___11476.__size[4], v11, "api.c", _func___10238, 840);
            applog(3, tmp42, 1);
            quit(1);
          }
          v14 = v2 + 1;
          if ( !v3 )
          {
LABEL_24:
            v2 = v12;
            *v13 = v3;
            return v2;
          }
          while ( 2 )
          {
            if ( v3 == 61 )
              goto LABEL_27;
            if ( v3 > 0x3D )
            {
              if ( v3 != 92 )
              {
                if ( v3 == 124 )
                  goto LABEL_27;
                goto LABEL_22;
              }
              *v13 = 92;
              v13[1] = *(v14 - 1);
              v13 += 2;
            }
            else
            {
              if ( v3 == 34 )
              {
                if ( v4 )
                  goto LABEL_28;
              }
              else
              {
                if ( v3 != 44 )
                  goto LABEL_22;
LABEL_27:
                if ( !v4 )
                {
LABEL_28:
                  *v13++ = 92;
                  LOBYTE(v3) = *(v14 - 1);
                }
              }
LABEL_22:
              *v13++ = v3;
            }
            v15 = *v14++;
            v3 = v15;
            if ( !v15 )
              goto LABEL_24;
            continue;
          }
        }
      }
    }
  }
  return v2;
}

//----- (000182E0) --------------------------------------------------------
void __fastcall add_item_buf(K_ITEM *item, const unsigned __int8 *str)
{
  void **data; // r5
  size_t v5; // r0
  char *v6; // r9
  size_t v7; // r4
  unsigned int v8; // r1
  size_t v9; // r10
  char *v10; // r6
  int v11; // r11
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-828h] BYREF

  data = (void **)item->data;
  v5 = strlen((const char *)str);
  v6 = (char *)data[1];
  v7 = v5;
  v8 = (unsigned int)data[2];
  v9 = v5 + 1;
  v10 = (char *)*data;
  if ( (unsigned int)&v6[v5 + 1] > v8 )
  {
    v11 = v5 + 4097 - (v9 & 0xFFF);
    v10 = (char *)realloc(*data, v8 + v11);
    *data = v10;
    if ( !v10 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v7,
        *((_DWORD *)item->data + 2),
        v11,
        "api.c",
        (const char *)_func___10467,
        1179);
      applog(3, tmp42, 1);
      quit(1);
    }
    *((_DWORD *)item->data + 2) += v11;
  }
  memcpy(&v6[(_DWORD)v10], str, v9);
  *((_DWORD *)item->data + 1) += v7;
}

//----- (00018398) --------------------------------------------------------
bool __fastcall io_add(io_data *io_data, unsigned __int8 *buf)
{
  size_t v4; // r0
  unsigned __int8 *cur; // r3
  size_t v6; // r5
  unsigned __int8 *ptr; // r0
  int v8; // r8
  unsigned int v9; // r2
  size_t v10; // r7
  unsigned __int8 *v11; // r0
  bool result; // r0

  v4 = strlen((const char *)buf);
  cur = io_data->cur;
  v6 = v4;
  ptr = io_data->ptr;
  v8 = cur - ptr;
  v9 = cur - ptr + 12 + v6;
  if ( v9 > io_data->siz )
  {
    v10 = io_data->siz + 0x20000;
    if ( v9 > v10 )
      v10 = ((unsigned int)vcvts_n_f32_u32(v9, 0x10u) + 2) << 16;
    v11 = (unsigned __int8 *)realloc(ptr, v10);
    cur = &v11[v8];
    io_data->ptr = v11;
    io_data->cur = &v11[v8];
    io_data->siz = v10;
  }
  memcpy(cur, buf, v6 + 1);
  result = 1;
  io_data->cur += v6;
  return result;
}

//----- (00018400) --------------------------------------------------------
void __fastcall head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin)
{
  unsigned __int8 *v6; // r5

  if ( *firstjoin )
  {
    if ( !isjson )
    {
      *firstjoin = 0;
LABEL_4:
      v6 = escape_string(cmdptr, isjson);
      io_add(io_data, "CMD=");
      io_add(io_data, v6);
      io_add(io_data, "|");
      goto LABEL_5;
    }
    io_add(io_data, (unsigned __int8 *)"{");
    *firstjoin = 0;
    v6 = escape_string(cmdptr, 1);
  }
  else
  {
    if ( !isjson )
      goto LABEL_4;
    io_add(io_data, (unsigned __int8 *)",");
    v6 = escape_string(cmdptr, 1);
  }
  io_add(io_data, (unsigned __int8 *)"\"");
  io_add(io_data, v6);
  io_add(io_data, (unsigned __int8 *)"\":[");
LABEL_5:
  if ( v6 != cmdptr )
    j_free(v6);
}

//----- (000184A8) --------------------------------------------------------
bool __fastcall io_put(io_data *io_data, unsigned __int8 *buf)
{
  unsigned __int8 *ptr; // r4

  ptr = io_data->ptr;
  io_data->cur = ptr;
  *ptr = 0;
  io_data->close = 0;
  return io_add(io_data, buf);
}

//----- (000184BC) --------------------------------------------------------
void __fastcall dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"RESTART\"");
  else
    io_put(io_data, "RESTART");
  bye = 1;
  do_a_restart = 1;
}

//----- (000184E4) --------------------------------------------------------
void __fastcall doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"BYE\"");
  else
    io_put(io_data, "BYE");
  bye = 1;
  do_a_quit = 1;
}

//----- (0001850C) --------------------------------------------------------
bool __fastcall check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group)
{
  unsigned __int8 *v6; // r0
  int v7; // r12
  char *v8; // r2
  in6_addr_0 *v9; // r1
  char *v10; // r3
  int v11; // r5
  int v12; // r0
  int v13; // t1
  int v14; // t1
  bool result; // r0
  bool v16; // r5
  char v17; // [sp+Fh] [bp-51h] BYREF
  in6_addr_0 client_ip; // [sp+10h] [bp-50h] BYREF
  unsigned __int8 tmp[30]; // [sp+20h] [bp-40h] BYREF

  v6 = (unsigned __int8 *)malloc(0x2Eu);
  *connectaddr = v6;
  getnameinfo((const struct sockaddr *)cli, 0x80u, (char *)v6, 0x2Eu, 0, 0, 1u);
  if ( cli->ss_family == 2 )
  {
    sprintf((char *)tmp, "::ffff:%s", (const char *)*connectaddr);
    inet_pton(10, (const char *)tmp, &client_ip);
  }
  else
  {
    inet_pton(10, (const char *)*connectaddr, &client_ip);
  }
  *group = (*_ctype_toupper_loc())[82];
  if ( opt_api_allow )
  {
    if ( ips > 0 )
    {
      v7 = 0;
      v8 = (char *)(&ipaccess[-1].group + 3);
      do
      {
        v9 = (in6_addr_0 *)&v17;
        v10 = v8;
        while ( 1 )
        {
          v11 = (unsigned __int8)v10[17];
          v13 = v9->__u6_addr8[1];
          v9 = (in6_addr_0 *)((char *)v9 + 1);
          v12 = v13;
          v14 = (unsigned __int8)*++v10;
          if ( v14 != (v12 & v11) )
            break;
          if ( v9 == (in6_addr_0 *)((char *)&client_ip.__u6_addr32[3] + 3) )
          {
            result = 1;
            *group = v8[33];
            return result;
          }
        }
        ++v7;
        v8 += 36;
      }
      while ( v7 != ips );
    }
    return 0;
  }
  else
  {
    v16 = opt_api_network;
    if ( opt_api_network || !strcmp((const char *)*connectaddr, "127.0.0.1") )
    {
      return 1;
    }
    else
    {
      result = client_ip.__u6_addr8[0];
      if ( client_ip.__u6_addr32[0] )
      {
        return v16;
      }
      else if ( !client_ip.__u6_addr32[1] )
      {
        result = 0;
        if ( !client_ip.__u6_addr32[2] )
          return client_ip.__u6_addr32[3] == 0x1000000;
      }
    }
  }
  return result;
}

//----- (0001860C) --------------------------------------------------------
void __fastcall send_result(io_data *io_data, int c, bool isjson)
{
  unsigned __int8 *ptr; // r8
  signed int v5; // r4
  const char *v6; // r4
  signed int v7; // r4
  int v8; // r9
  int v9; // r5
  int v10; // r9
  int v11; // r10
  _BOOL4 v12; // r3
  fd_set *p_tv_usec; // r3
  int v14; // r0
  ssize_t v15; // r0
  ssize_t v16; // r7
  int v17; // r0
  char *v18; // r0
  _BOOL4 v19; // [sp+8h] [bp-8B8h]
  int tosend; // [sp+Ch] [bp-8B4h]
  timeval timeout; // [sp+10h] [bp-8B0h] BYREF
  fd_set wd; // [sp+18h] [bp-8A8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+98h] [bp-828h] BYREF

  ptr = io_data->ptr;
  if ( io_data->close )
  {
    v19 = isjson;
    *(_WORD *)&ptr[strlen((const char *)io_data->ptr)] = 93;
    if ( !v19 )
      goto LABEL_3;
  }
  else if ( !isjson )
  {
    goto LABEL_3;
  }
  strcat((char *)ptr, ",\"id\":1}");
LABEL_3:
  v5 = strlen((const char *)ptr);
  tosend = v5 + 1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( v5 > 10 )
      v6 = "...";
    else
      v6 = "";
    snprintf((char *)tmp42, 0x800u, "API: send reply: (%d) '%.10s%s'", tosend, ptr, v6);
    applog(7, tmp42, 0);
  }
  v7 = tosend;
  v8 = (c + 31) & (c >> 31);
  if ( c >= 0 )
    v8 = c;
  v9 = 0;
  v10 = v8 >> 5;
  v11 = 0;
  while ( 1 )
  {
    v12 = v7 > 0;
    if ( v11 > 4 )
      v12 = 0;
    if ( !v12 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( p_tv_usec != (fd_set *)&wd.fds_bits[31] );
    wd.fds_bits[v10] |= 1 << (c % 32);
    v14 = select(c + 1, 0, &wd, 0, &timeout);
    if ( v14 <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API: send select failed (%d)", v14);
        applog(4, tmp42, 0);
      }
      return;
    }
    v15 = send(c, ptr, v7, 0);
    v16 = v15;
    ++v9;
    if ( v15 < 0 )
    {
      v17 = *_errno_location();
      if ( v17 != 11 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          v18 = strerror(v17);
          snprintf((char *)tmp42, 0x800u, "API: send (%d:%d) failed: %s", tosend, tosend - v7, v18);
          applog(4, tmp42, 0);
        }
        return;
      }
LABEL_26:
      ++v11;
    }
    else if ( v9 == 1 )
    {
      if ( v15 != v7 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent %d of %d first go", v15, v7);
          applog(7, tmp42, 0);
        }
        goto LABEL_25;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "API: sent all of %d first go", v15);
        v7 -= v16;
        applog(7, tmp42, 0);
        ptr += v16;
      }
      else
      {
LABEL_42:
        v7 -= v16;
        ptr += v16;
      }
    }
    else
    {
      if ( v15 == v7 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent all of remaining %d (sendc=%d)", v15, v9);
          applog(7, tmp42, 0);
        }
        goto LABEL_42;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "API: sent %d of remaining %d (sendc=%d)", v15, v7, v9);
        applog(7, tmp42, 0);
      }
LABEL_25:
      v7 -= v16;
      ptr += v16;
      if ( !v16 )
        goto LABEL_26;
    }
  }
}

//----- (00018960) --------------------------------------------------------
void mcast()
{
  addrinfo *v0; // r4
  addrinfo *i; // r3
  int v2; // r0
  int v3; // r11
  time_t v4; // r5
  int ai_family; // r3
  size_t v6; // r0
  size_t v7; // r4
  char *v8; // r0
  int v9; // r6
  ssize_t v10; // r4
  _BOOL4 v11; // r12
  const char *v12; // lr
  int *v13; // r0
  char *v14; // r7
  struct addrinfo *v15; // r0
  int *v16; // r0
  char *v17; // r3
  int *v18; // r0
  char *v19; // r0
  const char *v20; // r4
  int v21; // r0
  addrinfo *v22; // r12
  int v23; // r0
  addrinfo *v24; // r4
  size_t v25; // r0
  ssize_t v26; // r4
  int *v27; // r0
  char *v28; // r0
  int *v29; // r0
  char *v30; // r3
  __int64 v31; // r0
  __int64 v32; // r2
  const char *v33; // [sp+10h] [bp-1130h]
  _BOOL4 v34; // [sp+10h] [bp-1130h]
  addrinfo *v35; // [sp+10h] [bp-1130h]
  addrinfo *v36; // [sp+10h] [bp-1130h]
  size_t expect_code_len; // [sp+18h] [bp-1128h]
  unsigned __int8 *expect_code; // [sp+1Ch] [bp-1124h]
  int reply_sock; // [sp+20h] [bp-1120h]
  unsigned __int8 group; // [sp+2Fh] [bp-1111h] BYREF
  socklen_t addr_len; // [sp+30h] [bp-1110h] BYREF
  unsigned __int8 *connectaddr; // [sp+34h] [bp-110Ch] BYREF
  addrinfo *res; // [sp+38h] [bp-1108h] BYREF
  int optval; // [sp+3Ch] [bp-1104h] BYREF
  unsigned __int8 expect[9]; // [sp+40h] [bp-1100h] BYREF
  unsigned __int8 port_s[10]; // [sp+4Ch] [bp-10F4h] BYREF
  unsigned __int8 came_from_port[10]; // [sp+58h] [bp-10E8h] BYREF
  ipv6_mreq grp_0; // [sp+64h] [bp-10DCh] BYREF
  addrinfo hints; // [sp+78h] [bp-10C8h] BYREF
  sockaddr_storage came_from; // [sp+98h] [bp-10A8h] BYREF
  unsigned __int8 buf[1024]; // [sp+118h] [bp-1028h] BYREF
  ip_mreq grp; // [sp+518h] [bp-C28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+918h] [bp-828h] BYREF

  strcpy((char *)expect, "bmminer-");
  sprintf((char *)port_s, "%d", opt_api_mcast_port);
  memset(&hints, 0, sizeof(hints));
  if ( getaddrinfo((const char *)opt_api_mcast_addr, (const char *)port_s, &hints, &res) )
  {
    strcpy((char *)tmp42, "Invalid API Multicast Address");
    applog(3, tmp42, 1);
    quit(1);
  }
  v0 = res;
  if ( !res )
  {
    v15 = 0;
LABEL_44:
    freeaddrinfo(v15);
    strcpy((char *)tmp42, "API mcast could not open socket");
    applog(3, tmp42, 1);
    quit(1);
  }
  for ( i = res; ; i = res )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      v3 = v2;
      goto LABEL_8;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  v3 = v2;
  if ( v2 == -1 )
  {
    v15 = res;
    goto LABEL_44;
  }
LABEL_8:
  optval = 1;
  if ( setsockopt(v3, 1, 2, &optval, 4u) < 0 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      goto die;
    v16 = _errno_location();
    v17 = strerror(*v16);
    snprintf(
      (char *)tmp42,
      0x800u,
      "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
      v17,
      " - API multicast listener will not be available");
LABEL_49:
    applog(3, tmp42, 0);
    goto die;
  }
  v4 = time(0);
  while ( 1 )
  {
    if ( bind(v3, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        grp.imr_multiaddr.s_addr = 0;
        grp.imr_interface.s_addr = 0;
        grp.imr_multiaddr.s_addr = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(v3, 0, 35, &grp, 8u) < 0 )
        {
LABEL_99:
          if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
            goto die;
          v29 = _errno_location();
          v30 = strerror(*v29);
          snprintf(
            (char *)tmp42,
            0x800u,
            "API mcast join failed (%s)%s",
            v30,
            " - API multicast listener will not be available");
          goto LABEL_49;
        }
      }
      else if ( ai_family == 10 )
      {
        v31 = *(_QWORD *)&v0->ai_addr->sa_data[6];
        v32 = *(_QWORD *)&v0->ai_addr[1].sa_family;
        grp_0.ipv6mr_interface = 0;
        *(_QWORD *)grp_0.ipv6mr_multiaddr.__u6_addr8 = v31;
        *(_QWORD *)&grp_0.ipv6mr_multiaddr.__u6_addr32[2] = v32;
        if ( setsockopt(v3, 41, 20, &grp_0, 0x14u) < 0 )
          goto LABEL_99;
      }
      freeaddrinfo(res);
      v33 = (const char *)opt_api_mcast_code;
      v6 = strlen((const char *)opt_api_mcast_code);
      v7 = v6 + 10;
      expect_code_len = v6 + 9;
      v8 = (char *)malloc(v6 + 10);
      expect_code = (unsigned __int8 *)v8;
      if ( !v8 )
      {
        strcpy((char *)tmp42, "Failed to malloc mcast expect_code");
        applog(3, tmp42, 1);
        quit(1);
      }
      v9 = 0;
      reply_sock = -1;
      snprintf(v8, v7, "%s%s-", (const char *)expect, v33);
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              do
              {
                while ( 1 )
                {
                  cgsleep_ms(1000);
                  addr_len = 128;
                  ++v9;
                  v10 = recvfrom(v3, buf, 0x3FFu, 0, (struct sockaddr *)&came_from, &addr_len);
                  if ( v10 >= 0 )
                    break;
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    v18 = _errno_location();
                    v19 = strerror(*v18);
                    snprintf((char *)tmp42, 0x800u, "API mcast failed count=%d (%s) (%d)", v9, v19, v3);
                    applog(7, tmp42, 0);
                  }
                }
                v11 = check_connect(&came_from, &connectaddr, &group);
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  v12 = "Ignored";
                  v34 = v11;
                  if ( v11 )
                    v12 = "Accepted";
                  snprintf((char *)tmp42, 0x800u, "API mcast from %s - %s", (const char *)connectaddr, v12);
                  applog(7, tmp42, 0);
                  v11 = v34;
                }
              }
              while ( !v11 );
              buf[v10] = 0;
              if ( v10 && buf[v10 - 1] == 10 )
                buf[--v10] = 0;
              getnameinfo((const struct sockaddr *)&came_from, addr_len, 0, 0, (char *)came_from_port, 0xAu, 1u);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  (char *)tmp42,
                  0x800u,
                  "API mcast request rep=%d (%s) from [%s]:%s",
                  v10,
                  (const char *)buf,
                  (const char *)connectaddr,
                  (const char *)came_from_port);
                applog(7, tmp42, 0);
              }
              if ( expect_code_len < v10 && !memcmp(buf, expect_code, expect_code_len) )
                break;
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "API mcast request was no good");
                applog(7, tmp42, 0);
              }
            }
            v20 = (const char *)&buf[expect_code_len];
            v21 = strtol((const char *)&buf[expect_code_len], 0, 10);
            if ( (unsigned int)(v21 - 1) <= 0xFFFE )
              break;
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42, 0x800u, "API mcast request ignored - invalid port (%s)", v20);
              applog(7, tmp42, 0);
            }
          }
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "API mcast request OK port %s=%d", v20, v21);
            applog(7, tmp42, 0);
          }
          if ( !getaddrinfo((const char *)connectaddr, v20, &hints, &res) )
            break;
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf((char *)tmp42, 0x800u, "Invalid client address %s", connectaddr);
            goto LABEL_72;
          }
        }
        v22 = res;
        if ( res )
        {
          v35 = res;
          v23 = socket(res->ai_family, 2, 0);
          reply_sock = v23;
          v22 = v35;
          if ( v3 <= 0 )
          {
            v24 = v35;
            while ( 1 )
            {
              v24 = v24->ai_next;
              if ( !v24 )
                break;
              v23 = socket(res->ai_family, 2, 0);
            }
            v22 = 0;
            reply_sock = v23;
          }
        }
        if ( reply_sock == -1 )
        {
          freeaddrinfo(res);
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf((char *)tmp42, 0x800u, "API mcast could not open socket to client %s", connectaddr);
LABEL_72:
            applog(3, tmp42, 0);
          }
        }
        else
        {
          v36 = v22;
          snprintf((char *)&grp, 0x400u, "cgm-FTW-%d-%s", opt_api_port, (const char *)opt_api_mcast_des);
          v25 = strlen((const char *)&grp);
          v26 = sendto(reply_sock, &grp, v25 + 1, 0, v36->ai_addr, v36->ai_addrlen);
          freeaddrinfo(res);
          if ( v26 < 0 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              v27 = _errno_location();
              v28 = strerror(*v27);
              snprintf((char *)tmp42, 0x800u, "API mcast send reply failed (%s) (%d)", v28, reply_sock);
              applog(7, tmp42, 0);
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "API mcast send reply (%s) succeeded (%d) (%d)",
              (const char *)&grp,
              v26,
              reply_sock);
            applog(7, tmp42, 0);
          }
          close(reply_sock);
        }
      }
    }
    v13 = _errno_location();
    v14 = strerror(*v13);
    if ( time(0) - v4 > 61 )
      break;
    cgsleep_ms(30000);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "API mcast bind to port %d failed (%s)%s",
      opt_api_mcast_port,
      v14,
      " - API multicast listener will not be available");
    applog(3, tmp42, 0);
  }
die:
  close(v3);
}

//----- (0001911C) --------------------------------------------------------
void *__fastcall mcast_thread(void *userdata)
{
  pthread_t v2; // r0
  void *result; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  RenameThread("APIMcast");
  mcast();
  result = 0;
  *((_DWORD *)userdata + 3) = 0;
  return result;
}

//----- (00019148) --------------------------------------------------------
api_data *__fastcall api_add_data_full(
        api_data *root,
        unsigned __int8 *name,
        api_data_type type,
        void *data,
        bool copy_data)
{
  api_data *v9; // r4
  char *v10; // r0
  api_data *prev; // r3
  _DWORD *v13; // r0
  int v14; // r3
  _QWORD *v15; // r0
  __int64 v16; // r2
  _WORD *v17; // r0
  __int16 v18; // r3
  _QWORD *v19; // r0
  __int64 v20; // d7
  _BYTE *v21; // r0
  char v22; // r3
  _DWORD *v23; // r0
  int v24; // r1
  _BYTE *v25; // r0
  size_t v26; // r0
  char *v27; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-820h] BYREF

  v9 = (api_data *)malloc(0x18u);
  v10 = _strdup((const char *)name);
  v9->type = type;
  v9->name = (unsigned __int8 *)v10;
  if ( root )
  {
    prev = root->prev;
    v9->next = root;
    v9->prev = prev;
    root->prev = v9;
    v9->prev->next = v9;
  }
  else
  {
    v9->prev = v9;
    root = v9;
    v9->next = v9;
  }
  v9->data_was_malloc = copy_data;
  if ( !data )
  {
    v9->data_was_malloc = 0;
    data = "(null)";
    v9->type = API_CONST;
    goto LABEL_7;
  }
  if ( !copy_data )
  {
LABEL_7:
    v9->data = data;
    return root;
  }
  switch ( type )
  {
    case API_ESCAPE:
    case API_STRING:
    case API_CONST:
      v26 = strlen((const char *)data);
      v27 = (char *)malloc(v26 + 1);
      v9->data = v27;
      strcpy(v27, (const char *)data);
      break;
    case API_UINT8:
      v25 = malloc(4u);
      v9->data = v25;
      *v25 = *(_BYTE *)data;
      break;
    case API_INT16:
    case API_UINT16:
      v17 = malloc(4u);
      v18 = *(_WORD *)data;
      v9->data = v17;
      *v17 = v18;
      break;
    case API_INT:
    case API_UINT:
    case API_UINT32:
    case API_HEX32:
    case API_TIME:
    case API_TEMP:
    case API_VOLTS:
    case API_AVG:
      v13 = malloc(4u);
      v14 = *(_DWORD *)data;
      v9->data = v13;
      *v13 = v14;
      break;
    case API_UINT64:
    case API_INT64:
      v15 = malloc(8u);
      v16 = *(_QWORD *)data;
      v9->data = v15;
      *v15 = v16;
      break;
    case API_DOUBLE:
    case API_ELAPSED:
    case API_MHS:
    case API_MHTOTAL:
    case API_UTILITY:
    case API_FREQ:
    case API_HS:
    case API_DIFF:
    case API_PERCENT:
      v19 = malloc(8u);
      v20 = *(_QWORD *)data;
      v9->data = v19;
      *v19 = v20;
      break;
    case API_BOOL:
      v21 = malloc(1u);
      v22 = *(_BYTE *)data;
      v9->data = v21;
      *v21 = v22;
      break;
    case API_TIMEVAL:
      v23 = malloc(8u);
      v9->data = v23;
      v24 = *((_DWORD *)data + 1);
      *v23 = *(_DWORD *)data;
      v23[1] = v24;
      break;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "API: unknown1 data type %d ignored", type);
        applog(3, tmp42, 0);
      }
      v9->type = API_STRING;
      v9->data_was_malloc = 0;
      v9->data = (void *)"Unknown";
      break;
  }
  return root;
}

//----- (000192B0) --------------------------------------------------------
void __fastcall tail_join(io_data *io_data, bool isjson)
{
  _BOOL4 v3; // r5

  v3 = isjson;
  if ( !io_data->close )
  {
    if ( !isjson )
      return;
LABEL_5:
    io_add(io_data, ",\"id\":1}");
    io_add(io_data, (unsigned __int8 *)&word_4D07C);
    return;
  }
  io_add(io_data, (unsigned __int8 *)&word_4D07C);
  io_data->close = 0;
  if ( v3 )
    goto LABEL_5;
}

//----- (000192E8) --------------------------------------------------------
void __fastcall copyadvanceafter(unsigned __int8 **ch, unsigned __int8 **param, unsigned __int8 **buf)
{
  unsigned __int8 *v3; // r3
  int v4; // r2
  unsigned __int8 *v5; // r4
  unsigned __int8 *v6; // r2
  unsigned __int8 *v7; // r3

  v3 = *ch;
  v4 = **ch;
  if ( **ch )
  {
    while ( v4 != 44 )
    {
      if ( v4 == 92 && (v5 = v3 + 1, v3[1]) )
        *ch = v5;
      else
        v5 = *ch;
      v6 = *param;
      v3 = v5 + 1;
      *v6 = *v5;
      *param = v6 + 1;
      *ch = v5 + 1;
      v4 = v5[1];
      if ( !v5[1] )
        goto LABEL_10;
    }
    *ch = v3 + 1;
  }
LABEL_10:
  v7 = *param;
  *v7 = 0;
  *param = v7 + 1;
}

//----- (00019330) --------------------------------------------------------
bool __fastcall pooldetails(
        unsigned __int8 *param,
        unsigned __int8 **url,
        unsigned __int8 **user,
        unsigned __int8 **pass)
{
  size_t v7; // r0
  unsigned __int8 *v8; // r0
  unsigned __int8 **v9; // r2
  unsigned __int8 *v10; // r4
  unsigned __int8 **v11; // r2
  unsigned __int8 **v12; // r2
  unsigned __int8 *parama[2]; // [sp+4h] [bp-824h] BYREF
  unsigned __int8 *buf; // [sp+Ch] [bp-81Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  parama[0] = param;
  v7 = strlen((const char *)param);
  v8 = (unsigned __int8 *)malloc(v7 + 1);
  v10 = v8;
  buf = v8;
  if ( !v8 )
  {
    strcpy((char *)tmp42, "Failed to malloc pooldetails buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  *url = v8;
  copyadvanceafter(parama, &buf, v9);
  if ( *parama[0] && (*user = buf, copyadvanceafter(parama, &buf, v11), *parama[0]) )
  {
    *pass = buf;
    copyadvanceafter(parama, &buf, v12);
    return 1;
  }
  else
  {
    free(v10);
    return 0;
  }
}
// 19358: variable 'v9' is possibly undefined
// 1936A: variable 'v11' is possibly undefined
// 1938C: variable 'v12' is possibly undefined

//----- (000193CC) --------------------------------------------------------
void __fastcall rd_lock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v6 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v6,
      "api.c",
      (const char *)file,
      func);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001941C) --------------------------------------------------------
void __fastcall mutex_unlock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *v6; // r2
  int v7; // r3

  if ( pthread_mutex_unlock(lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)file, func, v6, v7);
  selective_yield();
}
// 19434: variable 'v6' is possibly undefined
// 19434: variable 'v7' is possibly undefined

//----- (00019440) --------------------------------------------------------
void *__fastcall restart_thread(void *userdata)
{
  const unsigned __int8 *v1; // r2
  int v2; // r3
  const unsigned __int8 *v3; // r2
  int v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&quit_restart_lock) )
    mutex_lock_1((pthread_mutex_t *)&_func___11333, (const unsigned __int8 *)0x1363, v1, v2);
  if ( pthread_mutex_unlock(&quit_restart_lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11333, (const unsigned __int8 *)0x1364, v3, v4);
  selective_yield();
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "API: restarting bmminer");
    applog(7, tmp42, 0);
  }
  app_restart();
  return 0;
}
// 194AA: variable 'v1' is possibly undefined
// 194AA: variable 'v2' is possibly undefined
// 194B6: variable 'v3' is possibly undefined
// 194B6: variable 'v4' is possibly undefined

//----- (000194DC) --------------------------------------------------------
void *__fastcall __noreturn quit_thread(void *userdata)
{
  const unsigned __int8 *v1; // r2
  int v2; // r3
  const unsigned __int8 *v3; // r2
  int v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  if ( !pthread_mutex_lock(&quit_restart_lock) )
  {
    if ( !pthread_mutex_unlock(&quit_restart_lock) )
    {
      selective_yield();
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "API: killing bmminer");
        applog(7, tmp42, 0);
      }
      kill_work();
    }
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11333.__size[16], (const unsigned __int8 *)0x1356, v3, v4);
  }
  mutex_lock_1((pthread_mutex_t *)&_func___11333.__size[16], (const unsigned __int8 *)0x1355, v1, v2);
}
// 19548: variable 'v1' is possibly undefined
// 19548: variable 'v2' is possibly undefined
// 19554: variable 'v3' is possibly undefined
// 19554: variable 'v4' is possibly undefined

//----- (0001957C) --------------------------------------------------------
void __fastcall tidyup(void *arg)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  int v4; // r0
  bool v5; // zf
  io_list *v6; // r6
  io_list *v7; // r4
  io_list *next; // r5
  io_list *v9; // r0
  const unsigned __int8 *v10; // r2
  int v11; // r3

  if ( pthread_mutex_lock(&quit_restart_lock) )
    mutex_lock_1((pthread_mutex_t *)&_func___11145, (const unsigned __int8 *)0x1218, v2, v3);
  v4 = *(_DWORD *)arg;
  v5 = *(_DWORD *)arg == -1;
  bye = 1;
  if ( !v5 )
  {
    shutdown(v4, 2);
    close(*(_DWORD *)arg);
    *(_DWORD *)arg = -1;
  }
  if ( ipaccess )
  {
    free(ipaccess);
    ipaccess = 0;
  }
  v6 = io_head;
  if ( io_head )
  {
    v7 = io_head;
    do
    {
      next = v7->next;
      free(v7->io_data->ptr);
      free(v7->io_data);
      v9 = v7;
      v7 = next;
      free(v9);
    }
    while ( v6 != next );
    io_head = 0;
  }
  if ( pthread_mutex_unlock(&quit_restart_lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11145, (const unsigned __int8 *)0x122D, v10, v11);
  selective_yield();
}
// 195F2: variable 'v2' is possibly undefined
// 195F2: variable 'v3' is possibly undefined
// 195FE: variable 'v10' is possibly undefined
// 195FE: variable 'v11' is possibly undefined

//----- (00019614) --------------------------------------------------------
api_data *__fastcall print_data(io_data *io_data, api_data *root, bool isjson, bool precom)
{
  _BOOL4 v4; // r6
  _BOOL4 v7; // r7
  cglock_t *lock; // r5
  const unsigned __int8 *v9; // r2
  int v10; // r3
  K_ITEM *v11; // r5
  cglock_t *v12; // r9
  const unsigned __int8 *v13; // r2
  int v14; // r3
  const unsigned __int8 *v15; // r2
  int v16; // r3
  K_ITEM *v17; // r0
  api_data *next; // r3
  api_data *prev; // r2
  api_data *v20; // r0
  cglock_t *v21; // r4
  const unsigned __int8 *v22; // r2
  int v23; // r3
  cglock_t *v24; // r4
  const unsigned __int8 *v25; // r2
  int v26; // r3
  const unsigned __int8 *v27; // r2
  int v28; // r3
  const char *v30; // r3
  unsigned __int8 *data; // r6
  unsigned __int8 *v32; // r3
  int *v33; // r0
  int *v34; // r0
  unsigned __int8 *ptr; // [sp+18h] [bp-878h]
  unsigned __int8 buf[64]; // [sp+20h] [bp-870h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+60h] [bp-830h] BYREF

  v4 = precom;
  v7 = isjson;
  lock = strbufs->lock;
  if ( pthread_mutex_lock(&lock->mutex) )
    mutex_lock_1((pthread_mutex_t *)&_func___11145.__size[8], (const unsigned __int8 *)0x4AC, v9, v10);
  if ( pthread_rwlock_wrlock(&lock->rwlock) )
  {
    v34 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v34,
      "api.c",
      (const char *)&_func___11145.__size[8],
      1196);
    applog(3, tmp42, 1);
    quit(1);
  }
  v11 = k_unlink_head(strbufs, "api.c", &_func___11145.__size[8], 1197);
  v12 = strbufs->lock;
  if ( pthread_rwlock_unlock(&v12->rwlock) )
    rw_unlock_0((pthread_rwlock_t *)(&_func___11145.__align + 2), (const unsigned __int8 *)0x4AE, v13, v14);
  if ( pthread_mutex_unlock(&v12->mutex) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11145.__size[8], (const unsigned __int8 *)0x4AE, v15, v16);
  selective_yield();
  *((_DWORD *)v11->data + 1) = 0;
  if ( v4 )
  {
    add_item_buf(v11, (const unsigned __int8 *)",");
    if ( !v7 )
      goto LABEL_7;
    goto LABEL_59;
  }
  if ( v7 )
LABEL_59:
    add_item_buf(v11, (const unsigned __int8 *)"{");
LABEL_7:
  if ( !root )
    goto LABEL_19;
  v17 = v11;
  if ( v7 )
    goto LABEL_16;
LABEL_9:
  add_item_buf(v17, root->name);
  add_item_buf(v11, (const unsigned __int8 *)"=");
  while ( 1 )
  {
    switch ( root->type )
    {
      case API_ESCAPE:
        data = (unsigned __int8 *)root->data;
        v32 = escape_string(data, v7);
        ptr = v32;
        if ( v7 )
        {
          add_item_buf(v11, (const unsigned __int8 *)"\"");
          add_item_buf(v11, ptr);
          add_item_buf(v11, (const unsigned __int8 *)"\"");
        }
        else
        {
          add_item_buf(v11, v32);
        }
        if ( ptr != data )
          free(ptr);
        break;
      case API_STRING:
      case API_CONST:
        if ( v7 )
        {
          add_item_buf(v11, (const unsigned __int8 *)"\"");
          add_item_buf(v11, (const unsigned __int8 *)root->data);
          add_item_buf(v11, (const unsigned __int8 *)"\"");
        }
        else
        {
          add_item_buf(v11, (const unsigned __int8 *)root->data);
        }
        break;
      case API_UINT8:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int8 *)root->data);
        goto LABEL_12;
      case API_INT16:
        snprintf((char *)buf, 0x40u, "%d", *(__int16 *)root->data);
        goto LABEL_12;
      case API_UINT16:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int16 *)root->data);
        goto LABEL_12;
      case API_INT:
        snprintf((char *)buf, 0x40u, "%d", *(_DWORD *)root->data);
        goto LABEL_12;
      case API_UINT:
      case API_UINT32:
        snprintf((char *)buf, 0x40u, "%u", *(_DWORD *)root->data);
        goto LABEL_12;
      case API_HEX32:
        if ( v7 )
        {
          add_item_buf(v11, (const unsigned __int8 *)"\"");
          snprintf((char *)buf, 0x40u, "0x%08x", *(_DWORD *)root->data);
          add_item_buf(v11, buf);
          add_item_buf(v11, (const unsigned __int8 *)"\"");
        }
        else
        {
          snprintf((char *)buf, 0x40u, "0x%08x", *(_DWORD *)root->data);
          add_item_buf(v11, buf);
        }
        break;
      case API_UINT64:
        snprintf((char *)buf, 0x40u, "%llu", *(_QWORD *)root->data);
        goto LABEL_12;
      case API_INT64:
        snprintf((char *)buf, 0x40u, "%lld", *(_QWORD *)root->data);
        goto LABEL_12;
      case API_DOUBLE:
        snprintf((char *)buf, 0x40u, "%f", *(double *)root->data);
        goto LABEL_12;
      case API_ELAPSED:
        snprintf((char *)buf, 0x40u, "%.0f", *(double *)root->data);
        goto LABEL_12;
      case API_BOOL:
        v30 = "true";
        if ( !*(_BYTE *)root->data )
          v30 = "false";
        snprintf((char *)buf, 0x40u, "%s", v30);
        goto LABEL_12;
      case API_TIMEVAL:
        snprintf((char *)buf, 0x40u, "%ld.%06ld", *(_DWORD *)root->data, *((_DWORD *)root->data + 1));
        goto LABEL_12;
      case API_TIME:
        snprintf((char *)buf, 0x40u, "%lu", *(_DWORD *)root->data);
        goto LABEL_12;
      case API_MHS:
      case API_UTILITY:
      case API_FREQ:
        snprintf((char *)buf, 0x40u, "%.2f", *(double *)root->data);
        goto LABEL_12;
      case API_MHTOTAL:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data);
        goto LABEL_12;
      case API_TEMP:
        snprintf((char *)buf, 0x40u, "%.2f", *(float *)root->data);
        goto LABEL_12;
      case API_VOLTS:
      case API_AVG:
        snprintf((char *)buf, 0x40u, "%.3f", *(float *)root->data);
        goto LABEL_12;
      case API_HS:
        snprintf((char *)buf, 0x40u, "%.15f", *(double *)root->data);
        goto LABEL_12;
      case API_DIFF:
        snprintf((char *)buf, 0x40u, "%.8f", *(double *)root->data);
        goto LABEL_12;
      case API_PERCENT:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data * 100.0);
LABEL_12:
        add_item_buf(v11, buf);
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: unknown2 data type %d ignored", root->type);
          applog(3, tmp42, 0);
        }
        if ( v7 )
        {
          add_item_buf(v11, (const unsigned __int8 *)"\"");
          add_item_buf(v11, "Unknown");
          add_item_buf(v11, (const unsigned __int8 *)"\"");
        }
        else
        {
          add_item_buf(v11, "Unknown");
        }
        break;
    }
    free(root->name);
    if ( root->data_was_malloc )
      break;
    next = root->next;
    if ( next == root )
      goto LABEL_18;
LABEL_15:
    prev = root->prev;
    v20 = root;
    root = next;
    next->prev = prev;
    prev->next = next;
    free(v20);
    add_item_buf(v11, (const unsigned __int8 *)",");
    v17 = v11;
    if ( !v7 )
      goto LABEL_9;
LABEL_16:
    add_item_buf(v17, (const unsigned __int8 *)"\"");
    add_item_buf(v11, root->name);
    add_item_buf(v11, (const unsigned __int8 *)"\"");
    add_item_buf(v11, (const unsigned __int8 *)":");
  }
  free(root->data);
  next = root->next;
  if ( next != root )
    goto LABEL_15;
LABEL_18:
  free(root);
LABEL_19:
  if ( v7 )
    add_item_buf(v11, (const unsigned __int8 *)"}");
  else
    add_item_buf(v11, "|");
  io_add(io_data, *(unsigned __int8 **)v11->data);
  v21 = strbufs->lock;
  if ( pthread_mutex_lock(&v21->mutex) )
    mutex_lock_1((pthread_mutex_t *)&_func___11145.__size[8], (const unsigned __int8 *)0x558, v22, v23);
  if ( pthread_rwlock_wrlock(&v21->rwlock) )
  {
    v33 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v33,
      "api.c",
      (const char *)&_func___11145.__size[8],
      1368);
    applog(3, tmp42, 1);
    quit(1);
  }
  k_add_head(strbufs, v11, "api.c", &_func___11145.__size[8], 1369);
  v24 = strbufs->lock;
  if ( pthread_rwlock_unlock(&v24->rwlock) )
    rw_unlock_0((pthread_rwlock_t *)(&_func___11145.__align + 2), (const unsigned __int8 *)0x55A, v25, v26);
  if ( pthread_mutex_unlock(&v24->mutex) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11145.__size[8], (const unsigned __int8 *)0x55A, v27, v28);
  selective_yield();
  return 0;
}
// 19B44: variable 'v27' is possibly undefined
// 19B44: variable 'v28' is possibly undefined
// 19B82: variable 'v13' is possibly undefined
// 19B82: variable 'v14' is possibly undefined
// 19C1A: variable 'v9' is possibly undefined
// 19C1A: variable 'v10' is possibly undefined
// 19C26: variable 'v22' is possibly undefined
// 19C26: variable 'v23' is possibly undefined
// 19C32: variable 'v25' is possibly undefined
// 19C32: variable 'v26' is possibly undefined
// 19C3E: variable 'v15' is possibly undefined
// 19C3E: variable 'v16' is possibly undefined

//----- (00019C50) --------------------------------------------------------
api_data *__fastcall api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ESCAPE, data, copy_data);
}

//----- (00019C64) --------------------------------------------------------
api_data *__fastcall api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_STRING, data, copy_data);
}

//----- (00019C78) --------------------------------------------------------
api_data *__fastcall api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_CONST, (void *)data, copy_data);
}

//----- (00019C8C) --------------------------------------------------------
api_data *__fastcall api_add_uint8(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT8, data, copy_data);
}

//----- (00019CA0) --------------------------------------------------------
api_data *__fastcall api_add_int16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT16, data, copy_data);
}

//----- (00019CB4) --------------------------------------------------------
api_data *__fastcall api_add_uint16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT16, data, copy_data);
}

//----- (00019CC8) --------------------------------------------------------
api_data *__fastcall api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT, data, copy_data);
}

//----- (00019CDC) --------------------------------------------------------
api_data *__fastcall api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT, data, copy_data);
}

//----- (00019CF0) --------------------------------------------------------
api_data *__fastcall api_add_uint32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT32, data, copy_data);
}

//----- (00019D04) --------------------------------------------------------
api_data *__fastcall api_add_hex32(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_HEX32, data, copy_data);
}

//----- (00019D18) --------------------------------------------------------
api_data *__fastcall api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT64, data, copy_data);
}

//----- (00019D2C) --------------------------------------------------------
api_data *__fastcall api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT64, data, copy_data);
}

//----- (00019D40) --------------------------------------------------------
api_data *__fastcall api_add_double(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_DOUBLE, data, copy_data);
}

//----- (00019D54) --------------------------------------------------------
api_data *__fastcall api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ELAPSED, data, copy_data);
}

//----- (00019D68) --------------------------------------------------------
api_data *__fastcall api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data)
{
  return api_add_data_full(root, name, API_BOOL, data, copy_data);
}

//----- (00019D7C) --------------------------------------------------------
api_data *__fastcall api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIMEVAL, data, copy_data);
}

//----- (00019D90) --------------------------------------------------------
api_data *__fastcall api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIME, data, copy_data);
}

//----- (00019DA4) --------------------------------------------------------
void __fastcall message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson)
{
  code_severity v8; // r4
  CODES *v9; // r1
  int v10; // r5
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r4
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  int v17; // r5
  api_data *v18; // r0
  api_data *v19; // r0
  const char *v20; // r2
  int messageida; // [sp+4h] [bp-202Ch] BYREF
  unsigned __int8 severity[2]; // [sp+8h] [bp-2028h] BYREF
  int id; // [sp+Ch] [bp-2024h] BYREF
  unsigned __int8 buf[8192]; // [sp+10h] [bp-2020h] BYREF

  messageida = messageid;
  if ( isjson )
    io_add(io_data, "{\"STATUS\":[");
  v8 = codes[0].severity;
  if ( codes[0].severity == SEVERITY_FAIL )
  {
LABEL_9:
    v11 = api_add_string(0, "STATUS", "F", 0);
    v12 = api_add_time(v11, "When", &when, 0);
    id = -1;
    v13 = api_add_int(v12, "Code", &id, 0);
    sprintf((char *)buf, "%d", messageida);
    v14 = v13;
    goto LABEL_10;
  }
  if ( codes[0].code != messageida )
  {
    v9 = codes;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[1].severity;
      ++v10;
      ++v9;
      if ( v8 == SEVERITY_FAIL )
        goto LABEL_9;
      if ( v9->code == messageida )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case SEVERITY_INFO:
      severity[0] = 73;
      break;
    case SEVERITY_SUCC:
      severity[0] = 83;
      break;
    case SEVERITY_WARN:
      severity[0] = 87;
      break;
    default:
      severity[0] = 69;
      break;
  }
  v17 = v10;
  severity[1] = 0;
  switch ( codes[v17].params )
  {
    case PARAM_PGA:
    case PARAM_ASC:
    case PARAM_PID:
    case PARAM_INT:
      sprintf((char *)buf, (const char *)codes[v17].description, paramid);
      break;
    case PARAM_PMAX:
      sprintf((char *)buf, (const char *)codes[v17].description, total_pools);
      break;
    case PARAM_POOLMAX:
      sprintf((char *)buf, (const char *)codes[v17].description, paramid, total_pools - 1);
      break;
    case PARAM_DMAX:
      sprintf((char *)buf, (const char *)codes[v17].description);
      break;
    case PARAM_CMD:
      sprintf((char *)buf, (const char *)codes[v17].description, "command");
      break;
    case PARAM_POOL:
      sprintf((char *)buf, (const char *)codes[v17].description, paramid, pools[paramid]->rpc_url);
      break;
    case PARAM_STR:
      sprintf((char *)buf, (const char *)codes[v17].description, param2);
      break;
    case PARAM_BOTH:
      sprintf((char *)buf, (const char *)codes[v17].description, paramid, param2);
      break;
    case PARAM_BOOL:
      v20 = "false";
      if ( paramid )
        v20 = "true";
      sprintf((char *)buf, (const char *)codes[v17].description, v20, "true");
      break;
    case PARAM_SET:
      sprintf((char *)buf, (const char *)codes[v17].description, param2, paramid);
      break;
    default:
      strcpy((char *)buf, (const char *)codes[v17].description);
      break;
  }
  v18 = api_add_string(0, "STATUS", severity, 0);
  v19 = api_add_time(v18, "When", &when, 0);
  v14 = api_add_int(v19, "Code", &messageida, 0);
LABEL_10:
  v15 = api_add_escape(v14, "Msg", buf, 0);
  v16 = api_add_escape(v15, "Description", opt_api_description, 0);
  print_data(io_data, v16, isjson, 0);
  if ( isjson )
    io_add(io_data, (unsigned __int8 *)&word_4D07C);
}

//----- (00019FC8) --------------------------------------------------------
void __fastcall lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 124, 0, 0, isjson);
}

//----- (00019FD4) --------------------------------------------------------
void __fastcall asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v6; // r5
  _BOOL4 v7; // r5
  api_data *v8; // r0
  api_data *v9; // r0
  int count[5]; // [sp+Ch] [bp-14h] BYREF

  v6 = isjson;
  count[0] = 0;
  message(io_data, 104, 0, 0, isjson);
  if ( v6 )
  {
    v7 = io_add(io_data, ",\"ASCS\":[");
    v8 = api_add_int(0, "Count", count, 0);
    print_data(io_data, v8, 1, 0);
    if ( v7 )
      io_data->close = 1;
  }
  else
  {
    io_add(io_data, "ASCS,");
    v9 = api_add_int(0, "Count", count, 0);
    print_data(io_data, v9, 0, 0);
  }
}

//----- (0001A048) --------------------------------------------------------
void __fastcall dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 102, 0, 0, isjson);
}

//----- (0001A054) --------------------------------------------------------
void __fastcall dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v6; // r6
  char *v8; // r0
  char *v9; // r5
  int v10; // r8
  int v11; // r9
  int v12; // r10
  int v13; // r2
  bool v14; // zf
  _BOOL4 v15; // r4
  int v16; // r2
  char *v17; // r3
  int v18; // r1
  bool groupa; // [sp+20h] [bp+0h]

  v6 = io_data;
  if ( !param || !*param )
  {
    v16 = 0;
    groupa = isjson;
    v17 = 0;
    v18 = 94;
    goto LABEL_19;
  }
  v8 = strchr((const char *)param, 44);
  v9 = v8;
  if ( !v8 || (*v8 = 0, v8 == (char *)-1) || (v10 = (unsigned __int8)v8[1], !v8[1]) )
  {
    v16 = 0;
    groupa = isjson;
    io_data = v6;
    v17 = 0;
    v18 = 75;
    goto LABEL_19;
  }
  if ( !strcasecmp((const char *)param, "all") )
  {
    v12 = 0;
    v11 = 1;
  }
  else
  {
    if ( strcasecmp((const char *)param, "bestshare") )
    {
      groupa = isjson;
      io_data = v6;
      v16 = 0;
      v17 = (char *)param;
      v18 = 95;
      goto LABEL_19;
    }
    v11 = 0;
    v12 = 1;
  }
  v13 = LOBYTE((*_ctype_tolower_loc())[v10]);
  v14 = v13 == 102;
  if ( v13 != 102 )
    v14 = v13 == 116;
  v9[1] = v13;
  if ( !v14 )
  {
    v16 = 0;
    groupa = isjson;
    io_data = v6;
    v17 = 0;
    v18 = 76;
    goto LABEL_19;
  }
  v15 = v13 == 116;
  if ( v13 == 116 )
  {
    print_summary();
    if ( !v11 )
    {
LABEL_15:
      if ( !v12 )
        goto LABEL_16;
      goto LABEL_23;
    }
  }
  else if ( !v11 )
  {
    goto LABEL_15;
  }
  zero_stats();
  if ( !v12 )
  {
LABEL_16:
    if ( v15 )
      goto LABEL_17;
    goto LABEL_24;
  }
LABEL_23:
  zero_bestshare();
  if ( v15 )
  {
LABEL_17:
    v16 = 0;
    v17 = "All";
    io_data = v6;
    v18 = 96;
    groupa = isjson;
    if ( !v11 )
      v17 = "BestShare";
    goto LABEL_19;
  }
LABEL_24:
  io_data = v6;
  v17 = "All";
  v16 = v15;
  groupa = isjson;
  v18 = 97;
  if ( !v11 )
    v17 = "BestShare";
LABEL_19:
  message(io_data, v18, v16, (unsigned __int8 *)v17, groupa);
}

//----- (0001A194) --------------------------------------------------------
void __fastcall usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 88, 0, 0, isjson);
}

//----- (0001A1A0) --------------------------------------------------------
void __fastcall setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v6; // r6
  char *v8; // r0
  int v9; // r2
  unsigned int v10; // r5
  unsigned __int8 *v11; // r3
  int v12; // r1
  bool groupa; // [sp+18h] [bp+0h]

  v6 = io_data;
  if ( param && *param )
  {
    v8 = strchr((const char *)param, 44);
    v9 = (int)v8;
    if ( v8 )
    {
      *v8 = 0;
      v10 = strtol(v8 + 1, 0, 10);
      if ( v10 > 0x270F )
      {
        groupa = isjson;
        io_data = v6;
        v9 = v10;
        v11 = param;
        v12 = 84;
      }
      else
      {
        if ( !strcasecmp((const char *)param, "queue") )
        {
          opt_queue = v10;
        }
        else if ( !strcasecmp((const char *)param, "scantime") )
        {
          opt_scantime = v10;
        }
        else
        {
          if ( strcasecmp((const char *)param, "expiry") )
          {
            groupa = isjson;
            io_data = v6;
            v9 = 0;
            v11 = param;
            v12 = 83;
            goto LABEL_8;
          }
          opt_expiry = v10;
        }
        groupa = isjson;
        io_data = v6;
        v9 = v10;
        v11 = param;
        v12 = 82;
      }
    }
    else
    {
      groupa = isjson;
      io_data = v6;
      v11 = param;
      v12 = 86;
    }
  }
  else
  {
    v9 = 0;
    groupa = isjson;
    v11 = 0;
    v12 = 85;
  }
LABEL_8:
  message(io_data, v12, v9, v11, groupa);
}

//----- (0001A280) --------------------------------------------------------
void __fastcall debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v7; // r4
  int v8; // r2
  _BOOL4 v9; // r3
  _BOOL4 v10; // r4
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  api_data *v21; // r0
  api_data *v22; // r0
  api_data *v23; // r0
  api_data *v24; // r1
  _BOOL4 v25; // r3
  _BOOL4 v26; // r3

  v7 = isjson;
  if ( param )
  {
    v8 = LOBYTE((*_ctype_tolower_loc())[*param]);
    *param = v8;
    switch ( v8 )
    {
      case 'd':
        v9 = !opt_debug;
        opt_debug = v9;
        opt_log_output = v9;
        if ( v9 )
          goto LABEL_4;
        break;
      case 'n':
        opt_log_output = 0;
        opt_debug = 0;
        opt_quiet = 0;
        opt_protocol = 0;
        want_per_device_stats = 0;
        opt_worktime = 0;
        break;
      case 'p':
        want_per_device_stats ^= 1u;
        opt_log_output = want_per_device_stats;
        break;
      case 'q':
        opt_quiet ^= 1u;
        break;
      case 'r':
        v25 = !opt_protocol;
        opt_protocol ^= 1u;
        if ( v25 )
          goto LABEL_4;
        break;
      case 's':
        opt_realquiet = 1;
        break;
      case 'v':
        v26 = !opt_log_output;
        opt_log_output ^= 1u;
        if ( v26 )
LABEL_4:
          opt_quiet = 0;
        break;
      case 'w':
        opt_worktime ^= 1u;
        break;
      default:
        break;
    }
  }
  message(io_data, 79, 0, 0, v7);
  if ( v7 )
  {
    v10 = io_add(io_data, ",\"DEBUG\":[");
    v11 = api_add_bool(0, "Silent", &opt_realquiet, 0);
    v12 = api_add_bool(v11, "Quiet", &opt_quiet, 0);
    v13 = api_add_bool(v12, "Verbose", &opt_log_output, 0);
    v14 = api_add_bool(v13, "Debug", &opt_debug, 0);
    v15 = api_add_bool(v14, "RPCProto", &opt_protocol, 0);
    v16 = api_add_bool(v15, "PerDevice", &want_per_device_stats, 0);
    v17 = api_add_bool(v16, "WorkTime", &opt_worktime, 0);
    print_data(io_data, v17, 1, 0);
    if ( v10 )
      io_data->close = 1;
  }
  else
  {
    io_add(io_data, "DEBUG,");
    v18 = api_add_bool(0, "Silent", &opt_realquiet, 0);
    v19 = api_add_bool(v18, "Quiet", &opt_quiet, 0);
    v20 = api_add_bool(v19, "Verbose", &opt_log_output, 0);
    v21 = api_add_bool(v20, "Debug", &opt_debug, 0);
    v22 = api_add_bool(v21, "RPCProto", &opt_protocol, 0);
    v23 = api_add_bool(v22, "PerDevice", &want_per_device_stats, 0);
    v24 = api_add_bool(v23, "WorkTime", &opt_worktime, 0);
    print_data(io_data, v24, 0, 0);
  }
}

//----- (0001A474) --------------------------------------------------------
void __fastcall failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v6; // r6
  int v8; // r5
  int v9; // r1
  bool v10; // zf
  _BOOL4 v11; // r4
  int v12; // r1
  int v13; // r2
  bool groupa; // [sp+18h] [bp+0h]

  v6 = io_data;
  if ( param && *param )
  {
    v8 = *param;
    v9 = LOBYTE((*_ctype_tolower_loc())[v8]);
    v10 = v9 == 102;
    if ( v9 != 102 )
      v10 = v9 == 116;
    *param = v9;
    if ( v10 )
    {
      groupa = isjson;
      v11 = v9 == 116;
      v12 = 77;
      io_data = v6;
      v13 = v11;
      opt_fail_only = v11;
    }
    else
    {
      v13 = 0;
      groupa = isjson;
      io_data = v6;
      v12 = 76;
    }
  }
  else
  {
    v13 = 0;
    groupa = isjson;
    v12 = 75;
  }
  message(io_data, v12, v13, 0, groupa);
}

//----- (0001A4E8) --------------------------------------------------------
void __fastcall checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v7; // r6
  unsigned __int8 *name; // r0
  CMDS *v9; // r4
  unsigned __int8 *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r2
  int v13; // r10
  int v14; // r8
  unsigned __int8 *v15; // r1
  _BOOL4 v16; // r9
  const char *v17; // r2
  api_data *v18; // r0
  const char *v19; // r2
  api_data *v20; // r0
  char s[132]; // [sp+Ch] [bp-84h] BYREF

  v7 = isjson;
  if ( param && *param )
  {
    name = cmds[0].name;
    if ( cmds[0].name )
    {
      v9 = cmds;
      while ( strcmp((const char *)name, (const char *)param) )
      {
        v10 = v9[1].name;
        ++v9;
        name = v10;
        if ( !v10 )
          goto LABEL_22;
      }
      sprintf(s, "|%s|", (const char *)param);
      v11 = _ctype_toupper_loc();
      v12 = (*v11)[group];
      if ( v12 == (*v11)[87]
        || (v13 = 1, (v14 = (int)strstr((const char *)apigroups[v12 - (*v11)[65]].commands, s)) != 0) )
      {
        v14 = 1;
        v13 = 1;
      }
    }
    else
    {
LABEL_22:
      v14 = (int)name;
      v13 = (int)name;
    }
    message(io_data, 72, 0, 0, v7);
    v15 = "CHECK,";
    if ( v7 )
      v15 = ",\"CHECK\":[";
    v16 = io_add(io_data, v15);
    if ( v13 )
      v17 = "Y";
    else
      v17 = "N";
    v18 = api_add_const(0, "Exists", (const unsigned __int8 *)v17, 0);
    if ( v14 )
      v19 = "Y";
    else
      v19 = "N";
    v20 = api_add_const(v18, "Access", (const unsigned __int8 *)v19, 0);
    print_data(io_data, v20, v7, 0);
    if ( v16 && v7 )
      io_data->close = 1;
  }
  else
  {
    message(io_data, 71, 0, 0, isjson);
  }
}

//----- (0001A600) --------------------------------------------------------
void __fastcall devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r6
  _BOOL4 v7; // r9
  api_data *v8; // r10
  int v9; // r0
  cgpu_info *devices; // r4
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  const unsigned __int8 *kname; // r2
  api_data *v16; // r0
  const unsigned __int8 *name; // r2
  api_data *v18; // r0
  const unsigned __int8 *device_path; // r2
  api_data *v20; // r0
  bool v21; // r3
  int data[9]; // [sp+Ch] [bp-24h] BYREF

  v5 = isjson;
  if ( total_devices )
  {
    message(io_data, 69, 0, 0, isjson);
    v7 = v5;
    if ( v5 )
      v7 = io_add(io_data, ",\"DEVDETAILS\":[");
    data[0] = 0;
    if ( total_devices > 0 )
    {
      v8 = 0;
      v9 = 0;
      do
      {
        devices = get_devices(v9);
        v11 = api_add_int(v8, "DEVDETAILS", data, 0);
        v12 = api_add_string(v11, "Name", devices->drv->name, 0);
        v13 = api_add_int(v12, (unsigned __int8 *)"ID", &devices->device_id, 0);
        v14 = api_add_string(v13, "Driver", devices->drv->dname, 0);
        kname = devices->kname;
        if ( !kname )
          kname = (const unsigned __int8 *)"";
        v16 = api_add_const(v14, "Kernel", kname, 0);
        name = devices->name;
        if ( !name )
          name = (const unsigned __int8 *)"";
        v18 = api_add_const(v16, "Model", name, 0);
        device_path = devices->device_path;
        if ( !device_path )
          device_path = (const unsigned __int8 *)"";
        v20 = api_add_const(v18, "Device Path", device_path, 0);
        v21 = v5;
        if ( v5 )
          v21 = data[0] > 0;
        v8 = print_data(io_data, v20, v5, v21);
        v9 = ++data[0];
      }
      while ( data[0] < total_devices );
    }
    if ( v7 )
      io_data->close = 1;
  }
  else
  {
    message(io_data, 10, total_devices, (unsigned __int8 *)total_devices, isjson);
  }
}
// 1A600: using guessed type int data[9];

//----- (0001A718) --------------------------------------------------------
void __fastcall removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v6; // r7
  int v7; // r2
  unsigned __int8 *v8; // r3
  int v9; // r1
  int v10; // r0
  int v11; // r5
  pool *v12; // r4
  unsigned __int8 *rpc_url; // r0
  unsigned __int8 *v14; // r8
  bool groupa; // [sp+20h] [bp+0h]

  v6 = io_data;
  if ( !total_pools )
  {
    groupa = isjson;
    v7 = total_pools;
    v8 = (unsigned __int8 *)total_pools;
    v9 = 8;
    goto LABEL_5;
  }
  if ( !param || !*param )
  {
    v7 = 0;
    groupa = isjson;
    v8 = 0;
    v9 = 25;
LABEL_5:
    message(io_data, v9, v7, v8, groupa);
    return;
  }
  v10 = strtol((const char *)param, 0, 10);
  v11 = v10;
  if ( v10 < 0 || v10 >= total_pools )
  {
    groupa = isjson;
    io_data = v6;
    v7 = v11;
    v9 = 26;
    v8 = 0;
    goto LABEL_5;
  }
  if ( total_pools <= 1 )
  {
    groupa = isjson;
    io_data = v6;
    v7 = v11;
    v9 = 66;
    v8 = 0;
    goto LABEL_5;
  }
  v12 = pools[v10];
  if ( v12 == current_pool() )
    switch_pools(0);
  if ( v12 == current_pool() )
  {
    groupa = isjson;
    io_data = v6;
    v7 = v11;
    v9 = 67;
    v8 = 0;
    goto LABEL_5;
  }
  rpc_url = v12->rpc_url;
  v12->enabled = POOL_DISABLED;
  v14 = escape_string(rpc_url, isjson);
  if ( v14 == v12->rpc_url )
  {
    remove_pool(v12);
    groupa = isjson;
    io_data = v6;
    v7 = v11;
    v8 = v14;
    v9 = 68;
    goto LABEL_5;
  }
  remove_pool(v12);
  message(v6, 68, v11, v14, isjson);
  j_free(v14);
}

//----- (0001A824) --------------------------------------------------------
void __fastcall disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v6; // r6
  int v7; // r2
  unsigned __int8 *enabled; // r3
  int v9; // r1
  int v10; // r0
  int v11; // r7
  pool *v12; // r4
  bool groupa; // [sp+18h] [bp+0h]

  v6 = io_data;
  if ( total_pools )
  {
    if ( param && *param )
    {
      v10 = strtol((const char *)param, 0, 10);
      v11 = v10;
      if ( v10 < 0 || v10 >= total_pools )
      {
        groupa = isjson;
        io_data = v6;
        v7 = v11;
        v9 = 26;
        enabled = 0;
      }
      else
      {
        v12 = pools[v10];
        enabled = (unsigned __int8 *)v12->enabled;
        if ( enabled )
        {
          if ( enabled_pools <= 1 )
          {
            groupa = isjson;
            io_data = v6;
            v7 = v11;
            v9 = 51;
            enabled = 0;
          }
          else
          {
            v12->enabled = POOL_DISABLED;
            if ( v12 == current_pool() )
              switch_pools(0);
            groupa = isjson;
            io_data = v6;
            v7 = v11;
            v9 = 48;
            enabled = 0;
          }
        }
        else
        {
          groupa = isjson;
          io_data = v6;
          v7 = v11;
          v9 = 50;
        }
      }
    }
    else
    {
      v7 = 0;
      groupa = isjson;
      enabled = 0;
      v9 = 25;
    }
  }
  else
  {
    v7 = total_pools;
    groupa = isjson;
    enabled = (unsigned __int8 *)total_pools;
    v9 = 8;
  }
  message(io_data, v9, v7, enabled, groupa);
}

//----- (0001A8F0) --------------------------------------------------------
void __fastcall enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v6; // r6
  int v7; // r2
  unsigned __int8 *v8; // r3
  int v9; // r1
  int v10; // r0
  int v11; // r7
  pool *v12; // r4
  int prio; // r8
  bool groupa; // [sp+18h] [bp+0h]

  v6 = io_data;
  if ( total_pools )
  {
    if ( param && *param )
    {
      v10 = strtol((const char *)param, 0, 10);
      v11 = v10;
      if ( v10 < 0 || v10 >= total_pools )
      {
        groupa = isjson;
        io_data = v6;
        v7 = v11;
        v9 = 26;
        v8 = 0;
      }
      else
      {
        v12 = pools[v10];
        if ( v12->enabled == POOL_ENABLED )
        {
          groupa = isjson;
          io_data = v6;
          v7 = v11;
          v9 = 49;
          v8 = 0;
        }
        else
        {
          prio = v12->prio;
          v12->enabled = POOL_ENABLED;
          if ( prio < current_pool()->prio )
            switch_pools(v12);
          groupa = isjson;
          io_data = v6;
          v7 = v11;
          v9 = 47;
          v8 = 0;
        }
      }
    }
    else
    {
      v7 = 0;
      groupa = isjson;
      v8 = 0;
      v9 = 25;
    }
  }
  else
  {
    v7 = total_pools;
    groupa = isjson;
    v8 = (unsigned __int8 *)total_pools;
    v9 = 8;
  }
  message(io_data, v9, v7, v8, groupa);
}

//----- (0001A9A4) --------------------------------------------------------
void __fastcall poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v7; // r7
  int v8; // r2
  char *v9; // r8
  int v10; // r0
  int v11; // r1
  unsigned __int8 *rpc_url; // r3
  pool *v13; // r4
  int v14; // r0
  int v15; // r5
  bool groupa; // [sp+20h] [bp+0h]

  v7 = io_data;
  v8 = total_pools;
  if ( total_pools )
  {
    if ( param && *param )
    {
      v9 = strchr((const char *)param, 44);
      if ( v9 )
      {
        *v9 = 0;
        v10 = strtol((const char *)param, 0, 10);
        if ( v10 >= 0 && v10 < total_pools )
        {
          v13 = pools[v10];
          v14 = strtol(v9 + 1, 0, 10);
          v15 = v14;
          if ( v14 < 0 )
          {
            rpc_url = v13->rpc_url;
            io_data = v7;
            groupa = isjson;
            v8 = v15;
            v11 = 121;
          }
          else
          {
            v13->quota = v14;
            adjust_quota_gcd();
            rpc_url = v13->rpc_url;
            io_data = v7;
            groupa = isjson;
            v8 = v15;
            v11 = 122;
          }
        }
        else
        {
          v8 = v10;
          groupa = isjson;
          io_data = v7;
          v11 = 26;
          rpc_url = 0;
        }
      }
      else
      {
        groupa = isjson;
        io_data = v7;
        v8 = 0;
        rpc_url = param;
        v11 = 86;
      }
    }
    else
    {
      v8 = 0;
      groupa = isjson;
      rpc_url = 0;
      v11 = 25;
    }
  }
  else
  {
    groupa = isjson;
    v11 = 8;
    rpc_url = (unsigned __int8 *)total_pools;
  }
  message(io_data, v11, v8, rpc_url, groupa);
}

//----- (0001AA78) --------------------------------------------------------
void __fastcall poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  bool *v5; // r4
  io_data **p_io_dataa; // r1
  int v7; // r4
  unsigned __int8 *v8; // r10
  char *v9; // r8
  int v10; // r0
  int v11; // r1
  io_data **v12; // r5
  int v13; // r2
  pool **v14; // r12
  int v15; // t1
  pool **v16; // r3
  int v17; // r6
  int v18; // r2
  pool *v19; // r5
  io_data *io_dataa; // [sp+8h] [bp+0h] BYREF
  bool v21[4]; // [sp+Ch] [bp+4h]

  io_dataa = io_data;
  *(_DWORD *)v21 = isjson;
  if ( total_pools )
  {
    if ( param && *param )
    {
      if ( total_pools > 0 )
      {
        v5 = &v21[total_pools - 4];
        p_io_dataa = &io_dataa;
        do
        {
          *(_BYTE *)p_io_dataa = 0;
          p_io_dataa = (io_data **)((char *)p_io_dataa + 1);
        }
        while ( p_io_dataa != (io_data **)v5 );
      }
      v7 = 0;
      v8 = param;
      while ( 1 )
      {
        v9 = strchr((const char *)v8, 44);
        if ( v9 )
          *v9++ = 0;
        v10 = strtol((const char *)v8, 0, 10);
        v8 = (unsigned __int8 *)v9;
        if ( v10 < 0 || (v11 = total_pools, total_pools <= v10) )
        {
          message(io_dataa, 26, v10, 0, v21[0]);
          return;
        }
        if ( v21[v10 - 4] )
        {
          message(io_dataa, 74, v10, 0, v21[0]);
          return;
        }
        *(_DWORD *)&v21[4 * v10 - 4] = v7;
        v21[v10 - 4] = 1;
        ++v7;
        if ( !v9 )
          break;
        if ( !*v9 )
        {
          if ( v11 <= 0 )
            goto LABEL_27;
          break;
        }
      }
      v12 = &io_dataa;
      v13 = 0;
      v14 = pools;
      do
      {
        v15 = *(unsigned __int8 *)v12;
        v12 = (io_data **)((char *)v12 + 1);
        if ( v15 )
          v14[v13]->prio = *(_DWORD *)&v21[v13 * 4 - 4];
        ++v13;
      }
      while ( v12 != (io_data **)&v21[v11 - 4] );
      v16 = pools;
      v17 = 0;
LABEL_22:
      while ( 2 )
      {
        v18 = 0;
        while ( 1 )
        {
          if ( !v21[v18 - 4] )
          {
            v19 = v16[v18];
            if ( v19->prio == v17 )
              break;
          }
          if ( ++v18 == v11 )
          {
            if ( ++v17 != v11 )
              goto LABEL_22;
            goto LABEL_27;
          }
        }
        ++v17;
        v19->prio = v7++;
        v21[v18 - 4] = 1;
        if ( v17 != v11 )
          continue;
        break;
      }
LABEL_27:
      if ( current_pool()->prio )
        switch_pools(0);
      message(io_dataa, 73, 0, 0, v21[0]);
    }
    else
    {
      message(io_dataa, 25, 0, 0, v21[0]);
    }
  }
  else
  {
    message(io_data, 8, total_pools, (unsigned __int8 *)total_pools, isjson);
  }
}

//----- (0001ABF4) --------------------------------------------------------
void __fastcall addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v8; // r8
  pool *v9; // r7
  unsigned __int8 *v10; // r4
  unsigned __int8 *url; // [sp+Ch] [bp-24h] BYREF
  unsigned __int8 *user; // [sp+10h] [bp-20h] BYREF
  unsigned __int8 *pass; // [sp+14h] [bp-1Ch] BYREF

  if ( param && *param )
  {
    if ( pooldetails(param, &url, &user, &pass) )
    {
      v9 = add_pool();
      detect_stratum(v9, url);
      add_pool_details(v9, 1, url, user, pass);
      v10 = escape_string(url, isjson);
      message(io_data, 55, v9->pool_no, v10, isjson);
      if ( v10 != url )
        free(v10);
    }
    else
    {
      v8 = escape_string(param, isjson);
      message(io_data, 53, 0, v8, isjson);
      if ( v8 != param )
        free(v8);
    }
  }
  else
  {
    message(io_data, 52, 0, 0, isjson);
  }
}

//----- (0001AC90) --------------------------------------------------------
void __fastcall switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  io_data *v6; // r6
  int v7; // r2
  unsigned __int8 *v8; // r3
  int v9; // r1
  int v10; // r7
  const unsigned __int8 *v11; // r2
  int v12; // r3
  const unsigned __int8 *v13; // r2
  int v14; // r3
  const unsigned __int8 *v15; // r2
  int v16; // r3
  pool *v17; // r4
  const unsigned __int8 *v18; // r2
  int v19; // r3
  bool groupa; // [sp+18h] [bp+0h]

  v6 = io_data;
  if ( total_pools )
  {
    if ( param && *param )
    {
      v10 = strtol((const char *)param, 0, 10);
      if ( pthread_mutex_lock(&control_lock.mutex) )
        mutex_lock_1((pthread_mutex_t *)&_func___11145.__size[20], (const unsigned __int8 *)0xB63, v11, v12);
      rd_lock(&control_lock.rwlock, &_func___11145.__size[20], (const unsigned __int8 *)0xB63, v12);
      if ( pthread_mutex_unlock(&control_lock.mutex) )
        mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11145.__size[20], (const unsigned __int8 *)0xB63, v13, v14);
      if ( v10 >= 0 && v10 < total_pools )
      {
        v17 = pools[v10];
        v17->enabled = POOL_ENABLED;
        if ( pthread_rwlock_unlock(&control_lock.rwlock) )
          rw_unlock_0((pthread_rwlock_t *)(&_func___11145.__align + 5), (const unsigned __int8 *)0xB6D, v18, v19);
        selective_yield();
        switch_pools(v17);
        groupa = isjson;
        io_data = v6;
        v7 = v10;
        v9 = 27;
        v8 = 0;
      }
      else
      {
        if ( pthread_rwlock_unlock(&control_lock.rwlock) )
          rw_unlock_0((pthread_rwlock_t *)(&_func___11145.__align + 5), (const unsigned __int8 *)0xB66, v15, v16);
        selective_yield();
        groupa = isjson;
        io_data = v6;
        v7 = v10;
        v9 = 26;
        v8 = 0;
      }
    }
    else
    {
      v7 = 0;
      groupa = isjson;
      v8 = 0;
      v9 = 25;
    }
  }
  else
  {
    v7 = total_pools;
    groupa = isjson;
    v8 = (unsigned __int8 *)total_pools;
    v9 = 8;
  }
  message(io_data, v9, v7, v8, groupa);
}
// 1ACD6: variable 'v12' is possibly undefined
// 1AD58: variable 'v15' is possibly undefined
// 1AD58: variable 'v16' is possibly undefined
// 1AD64: variable 'v11' is possibly undefined
// 1AD70: variable 'v13' is possibly undefined
// 1AD70: variable 'v14' is possibly undefined
// 1AD7C: variable 'v18' is possibly undefined
// 1AD7C: variable 'v19' is possibly undefined

//----- (0001AD9C) --------------------------------------------------------
void __fastcall pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v6; // r5
  _BOOL4 v7; // r5
  api_data *v8; // r0
  api_data *v9; // r0
  int count[5]; // [sp+Ch] [bp-14h] BYREF

  v6 = isjson;
  count[0] = 0;
  message(io_data, 59, 0, 0, isjson);
  if ( v6 )
  {
    v7 = io_add(io_data, ",\"PGAS\":[");
    v8 = api_add_int(0, "Count", count, 0);
    print_data(io_data, v8, 1, 0);
    if ( v7 )
      io_data->close = 1;
  }
  else
  {
    io_add(io_data, "PGAS,");
    v9 = api_add_int(0, "Count", count, 0);
    print_data(io_data, v9, 0, 0);
  }
}

//----- (0001AE10) --------------------------------------------------------
void __fastcall noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v6; // r4
  _BOOL4 v7; // r4
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r1

  v6 = isjson;
  message(io_data, 16, 0, 0, isjson);
  if ( v6 )
  {
    v7 = io_add(io_data, ",\"NONCENUM\":[");
    v8 = api_add_string(0, "10min nonce", nonce_num10_string, 0);
    v9 = api_add_string(v8, "30min nonce", nonce_num30_string, 0);
    v10 = api_add_string(v9, "60min nonce", nonce_num60_string, 0);
    print_data(io_data, v10, 1, 0);
    if ( v7 )
      io_data->close = 1;
  }
  else
  {
    io_add(io_data, "NONCENUM,");
    v11 = api_add_string(0, "10min nonce", nonce_num10_string, 0);
    v12 = api_add_string(v11, "30min nonce", nonce_num30_string, 0);
    v13 = api_add_string(v12, "60min nonce", nonce_num60_string, 0);
    print_data(io_data, v13, 0, 0);
  }
}

//----- (0001AEC0) --------------------------------------------------------
void __fastcall edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 10, 0, 0, isjson);
}

//----- (0001AECC) --------------------------------------------------------
void __fastcall devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 10, 0, 0, isjson);
}

//----- (0001AED8) --------------------------------------------------------
void __fastcall minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r5
  unsigned __int8 *v7; // r1
  _BOOL4 v8; // r7
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  int asccount; // [sp+8h] [bp-20h] BYREF
  int pgacount[7]; // [sp+Ch] [bp-1Ch] BYREF

  v5 = isjson;
  asccount = 0;
  pgacount[0] = 0;
  message(io_data, 33, 0, 0, isjson);
  v7 = "CONFIG,";
  if ( v5 )
    v7 = ",\"CONFIG\":[";
  v8 = io_add(io_data, v7);
  v9 = api_add_int(0, "ASC Count", &asccount, 0);
  v10 = api_add_int(v9, (unsigned __int8 *)&byte_479F8, pgacount, 0);
  v11 = api_add_int(v10, "Pool Count", &total_pools, 0);
  v12 = api_add_const(v11, "Strategy", strategies_0[pool_strategy_0].s, 0);
  v13 = api_add_int(v12, "Log Interval", &opt_log_interval, 0);
  v14 = api_add_const(v13, "Device Code", (const unsigned __int8 *)"", 0);
  v15 = api_add_const(v14, "OS", "Linux", 0);
  v16 = api_add_bool(v15, "Failover-Only", &opt_fail_only, 0);
  v17 = api_add_int(v16, "ScanTime", &opt_scantime, 0);
  v18 = api_add_int(v17, "Queue", &opt_queue, 0);
  v19 = api_add_int(v18, "Expiry", &opt_expiry, 0);
  v20 = api_add_const(v19, "Hotplug", "None", 0);
  print_data(io_data, v20, v5, 0);
  if ( v8 && v5 )
    io_data->close = 1;
}
// 1AED8: using guessed type int pgacount[7];

//----- (0001B008) --------------------------------------------------------
void __fastcall apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v6; // r4
  _BOOL4 v7; // r4
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r1

  v6 = isjson;
  message(io_data, 22, 0, 0, isjson);
  if ( v6 )
  {
    v7 = io_add(io_data, ",\"VERSION\":[");
    v8 = api_add_string(0, "BMMiner", "2.0.0", 0);
    v9 = api_add_const(v8, "API", "3.1", 0);
    v10 = api_add_string(v9, "Miner", g_miner_version, 0);
    v11 = api_add_string(v10, "CompileTime", g_miner_compiletime, 0);
    v12 = api_add_string(v11, "Type", g_miner_type, 0);
    print_data(io_data, v12, 1, 0);
    if ( v7 )
      io_data->close = 1;
  }
  else
  {
    io_add(io_data, "VERSION,");
    v13 = api_add_string(0, "BMMiner", "2.0.0", 0);
    v14 = api_add_const(v13, "API", "3.1", 0);
    v15 = api_add_string(v14, "Miner", g_miner_version, 0);
    v16 = api_add_string(v15, "CompileTime", g_miner_compiletime, 0);
    v17 = api_add_string(v16, "Type", g_miner_type, 0);
    print_data(io_data, v17, 0, 0);
  }
}

//----- (0001B0F0) --------------------------------------------------------
void __fastcall dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r4
  FILE *v8; // r0
  FILE *v9; // r5
  unsigned __int8 *v10; // r5
  unsigned __int8 *v11; // r8
  unsigned __int8 filename[4096]; // [sp+8h] [bp-1018h] BYREF

  v5 = param;
  if ( !param || !*param )
  {
    v5 = filename;
    default_save_file(filename);
  }
  v8 = fopen((const char *)v5, "w");
  v9 = v8;
  if ( v8 )
  {
    write_config(v8);
    fclose(v9);
    v10 = escape_string(v5, isjson);
    message(io_data, 44, 0, v10, isjson);
    if ( v10 != v5 )
      free(v10);
  }
  else
  {
    v11 = escape_string(v5, isjson);
    message(io_data, 43, 0, v11, isjson);
    if ( v11 != v5 )
      free(v11);
  }
}

//----- (0001B17C) --------------------------------------------------------
void __fastcall privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 46, 0, 0, isjson);
}

//----- (0001B188) --------------------------------------------------------
api_data *__fastcall api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHS, data, copy_data);
}

//----- (0001B19C) --------------------------------------------------------
void __fastcall lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r5
  pool *v7; // r6
  _BOOL4 v8; // r4
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r8
  api_data *v12; // r8
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r1
  api_data *v16; // r0
  double ghs; // [sp+8h] [bp-C0h] BYREF
  unsigned __int8 szindex[32]; // [sp+10h] [bp-B8h] BYREF
  unsigned __int8 szfan[32]; // [sp+30h] [bp-98h] BYREF
  unsigned __int8 sztemp[32]; // [sp+50h] [bp-78h] BYREF
  unsigned __int8 szpool[32]; // [sp+70h] [bp-58h] BYREF
  unsigned __int8 szuser[32]; // [sp+90h] [bp-38h] BYREF

  v5 = isjson;
  memset(szindex, 0, sizeof(szindex));
  memset(szfan, 0, sizeof(szfan));
  memset(sztemp, 0, sizeof(sztemp));
  memset(szpool, 0, sizeof(szpool));
  memset(szuser, 0, sizeof(szuser));
  v7 = current_pool();
  message(io_data, 7, 0, 0, v5);
  v8 = v5;
  if ( v5 )
    v8 = io_add(io_data, ",\"POOLS\":[");
  strcpy((char *)szindex, "0");
  ghs = (total_mhashes_done - new_total_mhashes_done) / 1000.0 / (total_secs - new_total_secs);
  v9 = api_add_string(0, "LCD", szindex, 0);
  v10 = api_add_mhs(v9, "GHS5s", &g_displayed_rolling, 0);
  v11 = api_add_mhs(v10, "GHSavg", &ghs, 0);
  sprintf((char *)szfan, "%d", g_max_fan);
  v12 = api_add_string(v11, "fan", szfan, 0);
  sprintf((char *)sztemp, "%d", g_max_temp);
  v13 = api_add_string(v12, "temp", sztemp, 0);
  if ( v7 )
  {
    v14 = api_add_string(v13, "pool", v7->rpc_url, 0);
    v15 = api_add_string(v14, "user", v7->rpc_user, 0);
  }
  else
  {
    strcpy((char *)szpool, "no");
    strcpy((char *)szuser, "no");
    v16 = api_add_string(v13, "pool", szpool, 0);
    v15 = api_add_string(v16, "user", szuser, 0);
  }
  print_data(io_data, v15, v5, v5);
  if ( v8 )
    io_data->close = 1;
}

//----- (0001B364) --------------------------------------------------------
int __fastcall itemstats(
        io_data *io_data,
        int i,
        unsigned __int8 *id,
        cgminer_stats *stats,
        cgminer_pool_stats *pool_stats,
        api_data *extra,
        cgpu_info *cgpu,
        bool isjson)
{
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  cgminer_pool_stats *v20; // r1
  __time_t tv_sec; // r3
  api_data *prev; // r2
  char v23; // r3
  int ia; // [sp+4h] [bp-2Ch] BYREF
  double ghs[5]; // [sp+8h] [bp-28h] BYREF

  ia = i;
  ghs[0] = (total_mhashes_done - new_total_mhashes_done) / 1000.0 / (total_secs - new_total_secs);
  v11 = api_add_int(0, "STATS", &ia, 0);
  v12 = api_add_string(v11, (unsigned __int8 *)"ID", id, 0);
  v13 = api_add_elapsed(v12, "Elapsed", &total_secs, 0);
  v14 = api_add_uint32(v13, "Calls", &stats->getwork_calls, 0);
  v15 = api_add_timeval(v14, "Wait", &stats->getwork_wait, 0);
  v16 = api_add_timeval(v15, "Max", &stats->getwork_wait_max, 0);
  v17 = api_add_timeval(v16, "Min", &stats->getwork_wait_min, 0);
  v18 = api_add_string(v17, "GHS 5s", displayed_hash_rate, 0);
  v19 = api_add_mhs(v18, "GHS av", ghs, 0);
  v20 = (cgminer_pool_stats *)v19;
  if ( pool_stats )
  {
    if ( v19 )
    {
      tv_sec = pool_stats->getwork_wait_max.tv_sec;
      pool_stats->getwork_wait_max.tv_sec = (__time_t)v19->prev;
      prev = v19->prev;
      v19->prev = (api_data *)tv_sec;
      prev->next = (api_data *)pool_stats;
      *(_DWORD *)(tv_sec + 20) = v19;
    }
    else
    {
      v20 = pool_stats;
    }
  }
  v23 = (char)extra;
  if ( (_BYTE)extra )
    v23 = ia > 0;
  print_data(io_data, (api_data *)v20, (bool)extra, v23);
  return ia + 1;
}
// 1B364: using guessed type api_data *isjson;
// 1B364: using guessed type double ghs[5];

//----- (0001B480) --------------------------------------------------------
void __fastcall minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r9
  _BOOL4 v7; // r11
  int v8; // r4
  int v9; // r6
  cgpu_info *devices; // r0
  cgpu_info *v11; // r5
  device_drv *drv; // r3
  int (*pool_stats)(void); // r7
  int v14; // r0
  cgpu_info *v15; // [sp+8h] [bp-40h]
  unsigned __int8 id[20]; // [sp+Ch] [bp-3Ch] BYREF

  v5 = isjson;
  message(io_data, 70, 0, 0, isjson);
  v7 = v5;
  if ( v5 )
    v7 = io_add(io_data, ",\"STATS\":[");
  if ( total_devices > 0 )
  {
    v8 = 0;
    v9 = 0;
    do
    {
      devices = get_devices(v8);
      v11 = devices;
      if ( devices )
      {
        drv = devices->drv;
        if ( drv )
        {
          pool_stats = (int (*)(void))drv->get_api_stats;
          if ( pool_stats )
          {
            v14 = pool_stats();
            drv = v11->drv;
            pool_stats = (int (*)(void))v14;
          }
          sprintf((char *)id, "%s%d", (const char *)drv->name, v11->device_id);
          v9 = itemstats(
                 io_data,
                 v9,
                 id,
                 &v11->cgminer_stats,
                 (cgminer_pool_stats *)pool_stats,
                 (api_data *)v5,
                 v15,
                 id[0]);
        }
      }
      ++v8;
    }
    while ( total_devices > v8 );
  }
  if ( v7 )
    io_data->close = 1;
}
// 1B4E4: variable 'v15' is possibly undefined

//----- (0001B520) --------------------------------------------------------
void __fastcall minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r9
  _BOOL4 v7; // r11
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  int v12; // r4
  int v13; // r6
  cgpu_info *devices; // r0
  cgpu_info *v15; // r5
  device_drv *drv; // r3
  int (*pool_stats)(void); // r7
  int v18; // r0
  cgpu_info *v19; // [sp+8h] [bp-40h]
  unsigned __int8 id[20]; // [sp+Ch] [bp-3Ch] BYREF

  v5 = isjson;
  message(io_data, 70, 0, 0, isjson);
  v7 = v5;
  if ( v5 )
    v7 = io_add(io_data, ",\"STATS\":[");
  v8 = api_add_string(0, "BMMiner", "2.0.0", 0);
  v9 = api_add_string(v8, "Miner", g_miner_version, 0);
  v10 = api_add_string(v9, "CompileTime", g_miner_compiletime, 0);
  v11 = api_add_string(v10, "Type", g_miner_type, 0);
  print_data(io_data, v11, v5, 0);
  if ( total_devices > 0 )
  {
    v12 = 0;
    v13 = 0;
    do
    {
      devices = get_devices(v12);
      v15 = devices;
      if ( devices )
      {
        drv = devices->drv;
        if ( drv )
        {
          pool_stats = (int (*)(void))drv->get_api_stats;
          if ( pool_stats )
          {
            v18 = pool_stats();
            drv = v15->drv;
            pool_stats = (int (*)(void))v18;
          }
          sprintf((char *)id, "%s%d", (const char *)drv->name, v15->device_id);
          v13 = itemstats(
                  io_data,
                  v13,
                  id,
                  &v15->cgminer_stats,
                  (cgminer_pool_stats *)pool_stats,
                  (api_data *)v5,
                  v19,
                  id[0]);
        }
      }
      ++v12;
    }
    while ( total_devices > v12 );
  }
  if ( v7 )
    io_data->close = 1;
}
// 1B5BA: variable 'v19' is possibly undefined

//----- (0001B614) --------------------------------------------------------
api_data *__fastcall api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHTOTAL, data, copy_data);
}

//----- (0001B628) --------------------------------------------------------
api_data *__fastcall api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TEMP, data, copy_data);
}

//----- (0001B63C) --------------------------------------------------------
api_data *__fastcall api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UTILITY, data, copy_data);
}

//----- (0001B650) --------------------------------------------------------
api_data *__fastcall api_add_freq(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_FREQ, data, copy_data);
}

//----- (0001B664) --------------------------------------------------------
api_data *__fastcall api_add_volts(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_VOLTS, data, copy_data);
}

//----- (0001B678) --------------------------------------------------------
api_data *__fastcall api_add_hs(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_HS, data, copy_data);
}

//----- (0001B68C) --------------------------------------------------------
api_data *__fastcall api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_DIFF, data, copy_data);
}

//----- (0001B6A0) --------------------------------------------------------
void __fastcall minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r4
  unsigned __int8 *v7; // r1
  _BOOL4 v8; // r6
  api_data *v9; // r7
  const unsigned __int8 *v10; // r2
  int v11; // r3
  const unsigned __int8 *v12; // r2
  int v13; // r3
  api_data *v14; // r0
  api_data *v15; // r7
  const unsigned __int8 *v16; // r2
  int v17; // r3
  api_data *v18; // r0
  api_data *v19; // r0

  v5 = isjson;
  message(io_data, 78, 0, 0, isjson);
  v7 = "COIN,";
  if ( v5 )
    v7 = ",\"COIN\":[";
  v8 = io_add(io_data, v7);
  v9 = api_add_const(0, "Hash Method", "sha256", 0);
  if ( pthread_mutex_lock(&ch_lock.mutex) )
    mutex_lock_1((pthread_mutex_t *)&_func___10950, (const unsigned __int8 *)0xE7C, v10, v11);
  rd_lock(&ch_lock.rwlock, (const unsigned __int8 *)&_func___10950, (const unsigned __int8 *)0xE7C, v11);
  if ( pthread_mutex_unlock(&ch_lock.mutex) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___10950, (const unsigned __int8 *)0xE7C, v12, v13);
  v14 = api_add_timeval(v9, "Current Block Time", &block_timeval, 1);
  v15 = api_add_string(v14, "Current Block Hash", current_hash, 1);
  if ( pthread_rwlock_unlock(&ch_lock.rwlock) )
    rw_unlock_0((pthread_rwlock_t *)&_func___10950, (const unsigned __int8 *)0xE7F, v16, v17);
  selective_yield();
  v18 = api_add_bool(v15, "LP", &have_longpoll, 0);
  v19 = api_add_diff(v18, "Network Difficulty", &current_diff, 1);
  print_data(io_data, v19, v5, 0);
  if ( v8 && v5 )
    io_data->close = 1;
}
// 1B6E6: variable 'v11' is possibly undefined
// 1B750: variable 'v10' is possibly undefined
// 1B75C: variable 'v16' is possibly undefined
// 1B75C: variable 'v17' is possibly undefined
// 1B768: variable 'v12' is possibly undefined
// 1B768: variable 'v13' is possibly undefined

//----- (0001B7B0) --------------------------------------------------------
api_data *__fastcall api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_PERCENT, data, copy_data);
}

//----- (0001B7C4) --------------------------------------------------------
void __fastcall summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r4
  unsigned __int8 *v7; // r1
  const unsigned __int8 *v8; // r2
  int v9; // r3
  double v10; // d7
  double v11; // d8
  double v12; // d5
  double v13; // d6
  double v14; // d7
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  api_data *v21; // r0
  api_data *v22; // r0
  api_data *v23; // r0
  api_data *v24; // r0
  api_data *v25; // r0
  api_data *v26; // r0
  api_data *v27; // r0
  api_data *v28; // r0
  api_data *v29; // r0
  api_data *v30; // r0
  api_data *v31; // r0
  api_data *v32; // r0
  api_data *v33; // r0
  api_data *v34; // r0
  api_data *v35; // r12
  int64_t v36; // r2
  double v37; // d7
  api_data *v38; // r11
  double v39; // d7
  api_data *v40; // r0
  double v41; // d7
  double v42; // d7
  api_data *v43; // r0
  double v44; // d7
  double v45; // d7
  api_data *v46; // r0
  api_data *v47; // r5
  const unsigned __int8 *v48; // r2
  int v49; // r3
  _BOOL4 io_open; // [sp+Ch] [bp-74h]
  double utility; // [sp+18h] [bp-68h] BYREF
  double ghs; // [sp+20h] [bp-60h] BYREF
  double work_utility; // [sp+28h] [bp-58h] BYREF
  double v54; // [sp+30h] [bp-50h] BYREF
  double v55; // [sp+38h] [bp-48h] BYREF
  double v56; // [sp+40h] [bp-40h] BYREF
  double v57; // [sp+48h] [bp-38h] BYREF

  v5 = isjson;
  message(io_data, 11, 0, 0, isjson);
  v7 = "SUMMARY,";
  if ( v5 )
    v7 = ",\"SUMMARY\":[";
  io_open = io_add(io_data, v7);
  if ( pthread_mutex_lock(&hash_lock) )
    mutex_lock_1((pthread_mutex_t *)&_func___10950.__size[12], (const unsigned __int8 *)0xAF2, v8, v9);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  v10 = (double)total_accepted;
  v11 = total_secs;
  if ( total_secs == 0.0 )
  {
    v14 = v10 * 60.0;
    v12 = (total_mhashes_done - new_total_mhashes_done) / 1000.0;
    v13 = total_secs - new_total_secs;
    v11 = 1.0;
  }
  else
  {
    v12 = (total_mhashes_done - new_total_mhashes_done) / 1000.0;
    v13 = total_secs - new_total_secs;
    v14 = v10 / total_secs * 60.0;
  }
  utility = v14;
  ghs = v12 / v13;
  work_utility = (double)(__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale) / v11 * 60.0;
  v15 = api_add_elapsed(0, "Elapsed", &total_secs, 1);
  v16 = api_add_string(v15, "GHS 5s", displayed_hash_rate, 0);
  v17 = api_add_mhs(v16, "GHS av", &ghs, 0);
  v18 = api_add_uint(v17, "Found Blocks", &found_blocks, 1);
  v19 = api_add_int64(v18, "Getworks", &total_getworks, 1);
  v20 = api_add_int64(v19, "Accepted", &total_accepted, 1);
  v21 = api_add_int64(v20, "Rejected", &total_rejected, 1);
  v22 = api_add_int(v21, "Hardware Errors", &hw_errors, 1);
  v23 = api_add_utility(v22, "Utility", &utility, 0);
  v24 = api_add_int64(v23, "Discarded", &total_discarded, 1);
  v25 = api_add_int64(v24, "Stale", &total_stale, 1);
  v26 = api_add_uint(v25, "Get Failures", &total_go, 1);
  v27 = api_add_uint(v26, "Local Work", &local_work, 1);
  v28 = api_add_uint(v27, "Remote Failures", &total_ro, 1);
  v29 = api_add_uint(v28, "Network Blocks", &new_blocks, 1);
  v30 = api_add_mhtotal(v29, "Total MH", &total_mhashes_done, 1);
  v31 = api_add_utility(v30, "Work Utility", &work_utility, 0);
  v32 = api_add_diff(v31, "Difficulty Accepted", &total_diff_accepted, 1);
  v33 = api_add_diff(v32, "Difficulty Rejected", &total_diff_rejected, 1);
  v34 = api_add_diff(v33, "Difficulty Stale", &total_diff_stale, 1);
  v35 = api_add_uint64(v34, "Best Share", &best_diff, 1);
  v36 = total_diff1 + hw_errors;
  if ( v36 )
    v37 = (double)hw_errors / (double)v36;
  else
    v37 = 0.0;
  v54 = v37;
  v38 = api_add_percent(v35, "Device Hardware%", &v54, 0);
  if ( total_diff1 )
    v39 = total_diff_rejected / (double)total_diff1;
  else
    v39 = 0.0;
  v55 = v39;
  v40 = api_add_percent(v38, "Device Rejected%", &v55, 0);
  v41 = total_diff_rejected + total_diff_accepted + total_diff_stale;
  if ( v41 == 0.0 )
    v42 = 0.0;
  else
    v42 = total_diff_rejected / v41;
  v56 = v42;
  v43 = api_add_percent(v40, "Pool Rejected%", &v56, 0);
  v44 = total_diff_accepted + total_diff_rejected + total_diff_stale;
  if ( v44 == 0.0 )
    v45 = 0.0;
  else
    v45 = total_diff_stale / v44;
  v57 = v45;
  v46 = api_add_percent(v43, "Pool Stale%", &v57, 0);
  v47 = api_add_time(v46, "Last getwork", &last_getwork, 0);
  if ( pthread_mutex_unlock(&hash_lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___10950.__size[12], (const unsigned __int8 *)0xB24, v48, v49);
  selective_yield();
  print_data(io_data, v47, v5, 0);
  if ( io_open && v5 )
    io_data->close = 1;
}
// 1BBE4: variable 'v8' is possibly undefined
// 1BBE4: variable 'v9' is possibly undefined
// 1BBF0: variable 'v48' is possibly undefined
// 1BBF0: variable 'v49' is possibly undefined

//----- (0001BC20) --------------------------------------------------------
void __fastcall poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r7
  int v6; // r3
  api_data *v7; // r10
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  double diff_rejected; // d6
  double v12; // d7
  double v13; // d7
  api_data *v14; // r0
  double diff_stale; // d6
  double v16; // d7
  double v17; // d7
  api_data *v18; // r0
  bool v19; // r3
  pool *v21; // r4
  pool_enable enabled; // r3
  char *v23; // r11
  time_t v24; // r0
  int v25; // r3
  api_data *v26; // r0
  api_data *v27; // r0
  api_data *v28; // r0
  api_data *v29; // r0
  api_data *v30; // r0
  api_data *v31; // r0
  api_data *v32; // r0
  api_data *v33; // r0
  api_data *v34; // r0
  api_data *v35; // r0
  api_data *v36; // r0
  api_data *v37; // r0
  api_data *v38; // r0
  api_data *v39; // r0
  api_data *v40; // r0
  api_data *v41; // r0
  api_data *v42; // r0
  api_data *v43; // r6
  const unsigned __int8 *v44; // r0
  api_data *v45; // r0
  api_data *v46; // r0
  api_data *v47; // r0
  api_data *v48; // r0
  api_data *v49; // r0
  api_data *v50; // r0
  api_data *v51; // r0
  api_data *v52; // r0
  const char *v53; // r1
  const char *v54; // r2
  api_data *v55; // r0
  unsigned __int8 *status; // [sp+8h] [bp-150h]
  _BOOL4 io_open; // [sp+14h] [bp-144h]
  int i; // [sp+1Ch] [bp-13Ch] BYREF
  double v60; // [sp+20h] [bp-138h] BYREF
  double v61; // [sp+28h] [bp-130h] BYREF
  unsigned __int8 lasttime[256]; // [sp+30h] [bp-128h] BYREF

  v5 = isjson;
  memset(lasttime, 0, sizeof(lasttime));
  if ( total_pools )
  {
    message(io_data, 7, 0, 0, v5);
    io_open = v5 && io_add(io_data, ",\"POOLS\":[");
    v6 = 0;
    i = 0;
    if ( total_pools > 0 )
    {
      v7 = 0;
      do
      {
        v21 = pools[v6];
        if ( !v21->removed )
        {
          enabled = v21->enabled;
          if ( enabled == POOL_ENABLED )
          {
            v54 = "Alive";
            if ( v21->idle )
              v54 = "Dead";
            status = (unsigned __int8 *)v54;
          }
          else if ( enabled )
          {
            v53 = "Rejecting";
            if ( enabled != POOL_REJECTING )
              v53 = "Unknown";
            status = (unsigned __int8 *)v53;
          }
          else
          {
            status = "Disabled";
          }
          if ( v21->hdr_path )
            v23 = "Y";
          else
            v23 = "N";
          if ( v21->last_share_time > 0 )
          {
            v24 = time(0);
            v25 = (v24 - v21->last_share_time) & ~((v24 - v21->last_share_time) >> 31);
            sprintf((char *)lasttime, "%d:%02d:%02d", v25 / 3600, v25 % 3600 / 60, v25 % 3600 % 60);
          }
          else
          {
            strcpy((char *)lasttime, "0");
          }
          v26 = api_add_int(v7, "POOL", &i, 0);
          v27 = api_add_escape(v26, (unsigned __int8 *)"URL", v21->rpc_url, 0);
          v28 = api_add_string(v27, "Status", status, 0);
          v29 = api_add_int(v28, "Priority", &v21->prio, 0);
          v30 = api_add_int(v29, "Quota", &v21->quota, 0);
          v31 = api_add_string(v30, "Long Poll", (unsigned __int8 *)v23, 0);
          v32 = api_add_uint(v31, "Getworks", &v21->getwork_requested, 0);
          v33 = api_add_int64(v32, "Accepted", &v21->accepted, 0);
          v34 = api_add_int64(v33, "Rejected", &v21->rejected, 0);
          v35 = api_add_uint(v34, "Discarded", &v21->discarded_work, 0);
          v36 = api_add_uint(v35, "Stale", &v21->stale_shares, 0);
          v37 = api_add_uint(v36, "Get Failures", &v21->getfail_occasions, 0);
          v38 = api_add_uint(v37, "Remote Failures", &v21->remotefail_occasions, 0);
          v39 = api_add_escape(v38, "User", v21->rpc_user, 0);
          v40 = api_add_string(v39, "Last Share Time", lasttime, 0);
          v41 = api_add_string(v40, "Diff", v21->diff, 0);
          v42 = api_add_int64(v41, "Diff1 Shares", &v21->diff1, 0);
          v43 = v42;
          if ( v21->rpc_proxy )
          {
            v44 = proxytype(v21->rpc_proxytype);
            v45 = api_add_const(v43, "Proxy Type", v44, 0);
            v46 = api_add_escape(v45, "Proxy", v21->rpc_proxy, 0);
          }
          else
          {
            v55 = api_add_const(v42, "Proxy Type", (const unsigned __int8 *)"", 0);
            v46 = api_add_const(v55, "Proxy", (const unsigned __int8 *)"", 0);
          }
          v47 = api_add_diff(v46, "Difficulty Accepted", &v21->diff_accepted, 0);
          v48 = api_add_diff(v47, "Difficulty Rejected", &v21->diff_rejected, 0);
          v49 = api_add_diff(v48, "Difficulty Stale", &v21->diff_stale, 0);
          v50 = api_add_diff(v49, "Last Share Difficulty", &v21->last_share_diff, 0);
          v51 = api_add_bool(v50, "Has Stratum", &v21->has_stratum, 0);
          v52 = api_add_bool(v51, "Stratum Active", &v21->stratum_active, 0);
          if ( v21->stratum_active )
            v8 = api_add_escape(v52, "Stratum URL", v21->stratum_url, 0);
          else
            v8 = api_add_const(v52, "Stratum URL", (const unsigned __int8 *)"", 0);
          v9 = api_add_bool(v8, "Has GBT", &v21->has_gbt, 0);
          v10 = api_add_uint64(v9, "Best Share", &v21->best_diff, 1);
          diff_rejected = v21->diff_rejected;
          v12 = diff_rejected + v21->diff_accepted + v21->diff_stale;
          if ( v12 == 0.0 )
            v13 = 0.0;
          else
            v13 = diff_rejected / v12;
          v60 = v13;
          v14 = api_add_percent(v10, "Pool Rejected%", &v60, 0);
          diff_stale = v21->diff_stale;
          v16 = v21->diff_accepted + v21->diff_rejected + diff_stale;
          if ( v16 == 0.0 )
            v17 = 0.0;
          else
            v17 = diff_stale / v16;
          v61 = v17;
          v18 = api_add_percent(v14, "Pool Stale%", &v61, 0);
          v19 = v5;
          if ( v5 )
            v19 = i > 0;
          v7 = print_data(io_data, v18, v5, v19);
        }
        v6 = i + 1;
      }
      while ( total_pools > ++i );
    }
    if ( io_open )
      io_data->close = 1;
  }
  else
  {
    message(io_data, 8, 0, 0, v5);
  }
}

//----- (0001C02C) --------------------------------------------------------
api_data *__fastcall api_add_avg(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_AVG, data, copy_data);
}

//----- (0001C040) --------------------------------------------------------
void __fastcall notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group)
{
  time_t device_last_not_well; // r2
  _BOOL4 v8; // r5
  dev_reason device_not_well_reason; // r3
  unsigned __int8 *v10; // r7
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  api_data *v21; // r0
  api_data *v22; // r0
  api_data *v23; // r0
  api_data *v24; // r0
  api_data *v25; // r0
  api_data *v26; // r0
  bool v27; // r3
  int devicea[7]; // [sp+4h] [bp-1Ch] BYREF

  device_last_not_well = cgpu->device_last_not_well;
  v8 = isjson;
  devicea[0] = device;
  if ( device_last_not_well )
  {
    device_not_well_reason = cgpu->device_not_well_reason;
    if ( (unsigned int)device_not_well_reason <= REASON_DEV_COMMS_ERROR )
      v10 = *(unsigned __int8 **)&_func___10238[4 * device_not_well_reason + 112];
    else
      v10 = "Unknown reason - code bug";
  }
  else
  {
    v10 = "None";
  }
  v11 = api_add_int(0, "NOTIFY", devicea, 0);
  v12 = api_add_string(v11, "Name", cgpu->drv->name, 0);
  v13 = api_add_int(v12, (unsigned __int8 *)"ID", &cgpu->device_id, 0);
  v14 = api_add_time(v13, "Last Well", &cgpu->device_last_well, 0);
  v15 = api_add_time(v14, "Last Not Well", &cgpu->device_last_not_well, 0);
  v16 = api_add_string(v15, "Reason Not Well", v10, 0);
  v17 = api_add_int(v16, "*Thread Fail Init", &cgpu->thread_fail_init_count, 0);
  v18 = api_add_int(v17, "*Thread Zero Hash", &cgpu->thread_zero_hash_count, 0);
  v19 = api_add_int(v18, "*Thread Fail Queue", &cgpu->thread_fail_queue_count, 0);
  v20 = api_add_int(v19, "*Dev Sick Idle 60s", &cgpu->dev_sick_idle_60_count, 0);
  v21 = api_add_int(v20, "*Dev Dead Idle 600s", &cgpu->dev_dead_idle_600_count, 0);
  v22 = api_add_int(v21, "*Dev Nostart", &cgpu->dev_nostart_count, 0);
  v23 = api_add_int(v22, "*Dev Over Heat", &cgpu->dev_over_heat_count, 0);
  v24 = api_add_int(v23, "*Dev Thermal Cutoff", &cgpu->dev_thermal_cutoff_count, 0);
  v25 = api_add_int(v24, "*Dev Comms Error", &cgpu->dev_comms_error_count, 0);
  v26 = api_add_int(v25, "*Dev Throttle", &cgpu->dev_throttle_count, 0);
  v27 = v8;
  if ( v8 )
    v27 = devicea[0] > 0;
  print_data(io_data, v26, v8, v27);
}
// 1C040: using guessed type int device[7];

//----- (0001C194) --------------------------------------------------------
void __fastcall notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  _BOOL4 v5; // r5
  _BOOL4 v7; // r9
  int v8; // r4
  cgpu_info *devices; // r0
  int v10; // r1

  v5 = isjson;
  if ( total_devices )
  {
    message(io_data, 60, 0, 0, isjson);
    v7 = v5;
    if ( v5 )
      v7 = io_add(io_data, ",\"NOTIFY\":[");
    if ( total_devices > 0 )
    {
      v8 = 0;
      do
      {
        devices = get_devices(v8);
        v10 = v8++;
        notifystatus(io_data, v10, devices, v5, group);
      }
      while ( total_devices > v8 );
    }
    if ( v7 )
      io_data->close = 1;
  }
  else
  {
    message(io_data, 10, total_devices, (unsigned __int8 *)total_devices, isjson);
  }
}

//----- (0001C218) --------------------------------------------------------
void mcast_init()
{
  thr_info *v0; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  v0 = (thr_info *)calloc(1u, 0x40u);
  if ( !v0 )
  {
    strcpy((char *)tmp42, "Failed to calloc mcast thr");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( thr_info_create(v0, 0, mcast_thread, v0) )
  {
    strcpy((char *)tmp42, "API mcast thread create failed");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001C298) --------------------------------------------------------
void reCalculateAVG()
{
  new_total_mhashes_done = total_mhashes_done;
  if ( total_secs <= 0.0 )
    new_total_secs = total_secs;
  else
    new_total_secs = total_secs - 1.0;
}

//----- (0001C2DC) --------------------------------------------------------
void __fastcall api(int api_thr_id)
{
  int v1; // r6
  char *v2; // r9
  double v3; // d0
  _BOOL4 v4; // r3
  unsigned __int8 *v5; // r0
  io_list *v6; // r0
  io_list *v7; // r2
  io_list *prev; // r3
  const char *v9; // r6
  size_t v10; // r4
  char *v11; // r0
  unsigned __int8 *v12; // r4
  char *v13; // r0
  char *v14; // r0
  const __int32_t *v15; // r2
  int v16; // r9
  __int32_t v17; // r1
  unsigned __int8 *v18; // r6
  int v19; // r10
  char *v20; // r0
  char *v21; // r7
  int v22; // r4
  unsigned __int8 *name; // r5
  CMDS *v24; // r11
  unsigned __int8 *v25; // t1
  const char *v26; // r4
  char *v27; // r3
  unsigned __int8 *v28; // r2
  bool *p_iswritemode; // r6
  char *v30; // r8
  const char *v31; // r10
  size_t v32; // r0
  int v33; // r5
  size_t v34; // r0
  unsigned __int8 *v35; // r0
  unsigned __int8 *v36; // r5
  CMDS *v37; // r4
  char *v38; // r7
  unsigned __int8 *v39; // t1
  size_t v40; // r0
  unsigned __int8 *v41; // t1
  const __int32_t *v42; // r2
  __int32_t v43; // r3
  int v44; // r4
  size_t v45; // r0
  unsigned __int8 *v46; // r0
  const char *v47; // r4
  size_t v48; // r0
  char *v49; // r0
  char *v50; // r11
  char *v51; // r2
  size_t v52; // r0
  int v53; // r3
  int v54; // t1
  int v55; // r7
  int v56; // r3
  char *v57; // r6
  bool v58; // zf
  unsigned __int8 *v59; // r6
  int v60; // t1
  bool v61; // zf
  char *v62; // r0
  const unsigned __int16 **v63; // r0
  int v64; // r2
  const __int32_t *v65; // r3
  unsigned __int8 v66; // r1
  IPACCESS *v67; // r5
  int v68; // r10
  int v69; // r3
  char *v70; // r5
  unsigned __int8 v71; // r2
  char *v72; // r0
  int v73; // r10
  int j; // r3
  int k; // r3
  unsigned __int8 v76; // t1
  int v77; // r0
  int v78; // r3
  int v79; // r2
  int v80; // r3
  int v81; // r0
  unsigned __int8 *v82; // r1
  int v83; // r3
  __int32_t v84; // r0
  unsigned __int8 *v85; // r4
  int i; // r3
  unsigned __int8 *v87; // r2
  addrinfo *v88; // r5
  addrinfo *v89; // r4
  int v90; // r0
  time_t v91; // r10
  _BOOL4 v92; // r10
  json_t_0 *v93; // r11
  _BOOL4 v94; // r0
  _BOOL4 v95; // r5
  const char *v96; // r1
  const char *v97; // r3
  const unsigned __int8 *v98; // r2
  int v99; // r3
  const unsigned __int8 *v100; // r2
  int v101; // r3
  int *v102; // r0
  int *v103; // r0
  char *v104; // r0
  int *v105; // r0
  char *v106; // r0
  ssize_t v107; // r0
  size_t v108; // r6
  _BOOL4 v109; // r3
  _BOOL4 v110; // r5
  time_t v111; // r0
  unsigned __int8 *ptr; // r2
  int v113; // r3
  char *v114; // r0
  unsigned __int8 *v115; // r8
  const char *v116; // r7
  size_t v117; // r0
  int v118; // r10
  int v119; // r3
  char *v120; // r9
  char *v121; // r10
  _BOOL4 v122; // r7
  char *v123; // r0
  unsigned __int8 *v124; // r1
  CMDS *v125; // r8
  int v126; // r6
  unsigned __int8 *v127; // t1
  int v128; // r3
  int v129; // r6
  size_t refcount; // r3
  size_t v131; // r3
  io_data *v132; // r0
  int v133; // r12
  __int32_t v134; // r2
  char *v135; // r0
  size_t v136; // r0
  unsigned __int8 **v137; // r3
  int *v138; // r0
  char *v139; // r0
  json_t_0 *v140; // r0
  int *v141; // r0
  char *v142; // r0
  json_t_0 *v143; // r0
  int v144; // r3
  int v145; // r3
  int *v146; // r0
  int *v147; // r0
  char *v148; // r0
  json_t_0 *v149; // r0
  json_type type; // r3
  int v151; // r0
  int v152; // [sp+14h] [bp-4BFCh]
  unsigned __int8 *v153; // [sp+18h] [bp-4BF8h]
  const __int32_t **v154; // [sp+24h] [bp-4BECh]
  char *dest; // [sp+28h] [bp-4BE8h]
  _DWORD *__cancel_arg; // [sp+2Ch] [bp-4BE4h]
  int c; // [sp+38h] [bp-4BD8h]
  char *cmdsbuf; // [sp+3Ch] [bp-4BD4h]
  io_data *v159; // [sp+40h] [bp-4BD0h]
  __int16 port; // [sp+48h] [bp-4BC8h]
  char *s; // [sp+50h] [bp-4BC0h]
  unsigned __int8 *param; // [sp+6Ch] [bp-4BA4h]
  unsigned __int8 group; // [sp+72h] [bp-4B9Eh] BYREF
  bool firstjoin; // [sp+73h] [bp-4B9Dh] BYREF
  unsigned __int8 *connectaddr; // [sp+74h] [bp-4B9Ch] BYREF
  socklen_t clisiz; // [sp+78h] [bp-4B98h] BYREF
  addrinfo *res; // [sp+7Ch] [bp-4B94h] BYREF
  int optval; // [sp+80h] [bp-4B90h] BYREF
  unsigned __int8 port_s[10]; // [sp+84h] [bp-4B8Ch] BYREF
  addrinfo hints; // [sp+90h] [bp-4B80h] BYREF
  thr_info bye_thr; // [sp+B0h] [bp-4B60h] BYREF
  unsigned __int8 cmdbuf[100]; // [sp+F0h] [bp-4B20h] BYREF
  sockaddr_storage cli; // [sp+154h] [bp-4ABCh] BYREF
  json_error_t json_err; // [sp+1D4h] [bp-4A3Ch] BYREF
  __pthread_unwind_buf_t __cancel_buf; // [sp+2D0h] [bp-4940h] BYREF
  unsigned __int8 tmp42_0[2048]; // [sp+3E8h] [bp-4828h] BYREF
  unsigned __int8 buf[8192]; // [sp+BE8h] [bp-4028h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+2BE8h] [bp-2028h] BYREF

  port = opt_api_port;
  __cancel_arg = malloc(4u);
  v4 = opt_api_listen;
  *__cancel_arg = -1;
  if ( !v4 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "API not running%s", " - API will not be available");
      applog(7, tmp42, 0);
    }
    goto LABEL_6;
  }
  v159 = (io_data *)malloc(0x10u);
  v5 = (unsigned __int8 *)malloc(0x10000u);
  *v5 = 0;
  v159->ptr = v5;
  v159->cur = v5;
  v159->close = 0;
  v159->siz = 0x10000;
  v159->sock = 1;
  v6 = (io_list *)malloc(0xCu);
  v6->io_data = v159;
  v7 = io_head;
  if ( io_head )
  {
    prev = io_head->prev;
    v6->next = io_head;
    v6->prev = prev;
    v7->prev = v6;
    v6->prev->next = v6;
  }
  else
  {
    v6->prev = v6;
    v6->next = v6;
    io_head = v6;
  }
  if ( pthread_mutex_init(&quit_restart_lock, 0) )
  {
    v146 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v146,
      "api.c",
      (const char *)&_func___11476,
      5317);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( _sigsetjmp((struct __jmp_buf_tag *)&__cancel_buf, 0) )
  {
    tidyup(__cancel_arg);
    _pthread_unwind_next(&__cancel_buf);
LABEL_294:
    freeaddrinfo(res);
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      goto LABEL_6;
    snprintf((char *)tmp42, 0x800u, "API bind to port %d failed (%s)%s", v1, v2, " - API will not be available");
LABEL_108:
    applog(3, tmp42, 0);
    goto LABEL_6;
  }
  _pthread_register_cancel(&__cancel_buf);
  v9 = (const char *)opt_api_groups;
  my_thr_id = api_thr_id;
  if ( opt_api_groups )
  {
    v10 = strlen((const char *)opt_api_groups) + 1;
  }
  else
  {
    v9 = "";
    v10 = 1;
  }
  v11 = (char *)malloc(v10);
  s = v11;
  if ( !v11 )
  {
    strcpy((char *)tmp42, "Failed to malloc ipgroups buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  memcpy(v11, v9, v10);
  if ( !*s )
  {
    v154 = _ctype_toupper_loc();
    goto LABEL_61;
  }
  v12 = (unsigned __int8 *)s;
  v154 = _ctype_toupper_loc();
  while ( 2 )
  {
    v13 = strchr((const char *)v12, 44);
    v153 = (unsigned __int8 *)v13;
    if ( v13 )
    {
      *v13 = 0;
      v153 = (unsigned __int8 *)(v13 + 1);
    }
    if ( v12[1] != 58 )
    {
      v14 = strchr((const char *)v12, 58);
      if ( v14 )
        *v14 = 0;
      snprintf((char *)buf, 0x800u, "API invalid group name '%s'", v12);
      applog(3, buf, 1);
      quit(1);
    }
    v15 = *v154;
    v16 = LOBYTE((*v154)[*v12]);
    v17 = (*v154)[v16];
    if ( v17 < (*v154)[65] || v17 > v15[90] )
    {
      snprintf((char *)buf, 0x800u, "API invalid group name '%c'");
      applog(3, buf, 1);
      quit(1);
    }
    if ( v16 == v15[87] )
    {
      snprintf((char *)buf, 0x800u, "API group name can't be '%c'", v16);
      applog(3, buf, 1);
      quit(1);
    }
    if ( v16 == v15[82] )
    {
      snprintf((char *)buf, 0x800u, "API group name can't be '%c'", v16);
      applog(3, buf, 1);
      quit(1);
    }
    if ( apigroups[v15[v16] - v15[65]].commands )
    {
      snprintf((char *)buf, 0x800u, "API duplicate group name '%c'", *v12);
      applog(3, buf, 1);
      quit(1);
    }
    v18 = v12 + 2;
    v19 = 0;
    strcpy((char *)tmp42, "|");
    if ( v12 == (unsigned __int8 *)-2 || !v12[2] )
      goto LABEL_53;
    dest = (char *)&tmp42[1];
    while ( 1 )
    {
      v20 = strchr((const char *)v18, 58);
      v21 = v20;
      if ( v20 )
      {
        *v20 = 0;
        v21 = v20 + 1;
      }
      if ( *v18 == 42 && !v18[1] )
      {
        v19 = 1;
        goto LABEL_37;
      }
      if ( !cmds[0].name )
      {
LABEL_57:
        snprintf((char *)buf, 0x800u, "API unknown command '%s' in group '%c'", v18, v16);
        applog(3, buf, 1);
        quit(1);
      }
      v22 = 0;
      name = cmds[0].name;
      v24 = cmds;
      while ( strcasecmp((const char *)v18, (const char *)name) )
      {
        v25 = v24[1].name;
        ++v24;
        name = v25;
        ++v22;
        if ( !v25 )
          goto LABEL_57;
      }
      sprintf((char *)tmp42_0, "|%s|", name);
      if ( !strstr((const char *)tmp42, (const char *)tmp42_0) )
        break;
LABEL_37:
      if ( !v21 )
        goto LABEL_46;
LABEL_38:
      if ( !*v21 )
        goto LABEL_46;
      v18 = (unsigned __int8 *)v21;
    }
    v26 = (const char *)*((_DWORD *)&codes[68].severity + 3 * v22);
    strcpy(dest, v26);
    v27 = &dest[strlen(v26)];
    *v27 = 124;
    v27[1] = 0;
    dest = v27 + 1;
    if ( v21 )
      goto LABEL_38;
LABEL_46:
    if ( v19 )
    {
      v28 = cmds[0].name;
      if ( cmds[0].name )
      {
        p_iswritemode = &cmds[0].iswritemode;
        v30 = dest;
        do
        {
          while ( 1 )
          {
            if ( !*p_iswritemode )
            {
              sprintf((char *)tmp42_0, "|%s|", (const char *)v28);
              if ( !strstr((const char *)tmp42, (const char *)tmp42_0) )
                break;
            }
            p_iswritemode += 12;
            v28 = (unsigned __int8 *)*((_DWORD *)p_iswritemode - 2);
            if ( !v28 )
              goto LABEL_53;
          }
          v31 = (const char *)*((_DWORD *)p_iswritemode - 2);
          p_iswritemode += 12;
          strcpy(v30, v31);
          v32 = strlen(v31);
          v30[v32] = 124;
          v30[v32 + 1] = 0;
          v30 += v32 + 1;
          v28 = (unsigned __int8 *)*((_DWORD *)p_iswritemode - 2);
        }
        while ( v28 );
      }
    }
LABEL_53:
    v33 = (*v154)[v16] - (*v154)[65];
    v34 = strlen((const char *)tmp42);
    v35 = (unsigned __int8 *)malloc(v34 + 1);
    apigroups[v33].commands = v35;
    if ( !v35 )
    {
      strcpy((char *)buf, "Failed to malloc group commands buf");
      applog(3, buf, 1);
      quit(1);
    }
    strcpy((char *)v35, (const char *)tmp42);
    if ( v153 && *v153 )
    {
      v12 = v153;
      continue;
    }
    break;
  }
LABEL_61:
  v36 = cmds[0].name;
  strcpy((char *)tmp42, "|");
  v37 = cmds;
  v38 = (char *)&tmp42[1];
  if ( cmds[0].name )
  {
    do
    {
      while ( v37->iswritemode )
      {
        v39 = v37[1].name;
        ++v37;
        v36 = v39;
        if ( !v39 )
          goto LABEL_66;
      }
      strcpy(v38, (const char *)v36);
      v40 = strlen((const char *)v36);
      v38[v40] = 124;
      v38[v40 + 1] = 0;
      v38 += v40 + 1;
      v41 = v37[1].name;
      ++v37;
      v36 = v41;
    }
    while ( v41 );
  }
LABEL_66:
  v42 = *v154;
  v43 = (*v154)[82];
  if ( (unsigned int)(v43 + 128) < 0x180 )
    v43 = v42[v43];
  v44 = v43 - v42[65];
  v45 = strlen((const char *)tmp42);
  v46 = (unsigned __int8 *)malloc(v45 + 1);
  apigroups[v44].commands = v46;
  if ( !v46 )
  {
    strcpy((char *)buf, "Failed to malloc noprivgroup commands buf");
    applog(3, buf, 1);
    quit(1);
  }
  strcpy((char *)v46, (const char *)tmp42);
  free(s);
  v47 = (const char *)opt_api_allow;
  if ( opt_api_allow )
  {
    v48 = strlen((const char *)opt_api_allow);
    v49 = (char *)malloc(v48 + 1);
    v50 = v49;
    if ( !v49 )
    {
      strcpy((char *)tmp42, "Failed to malloc ipaccess buf");
      applog(3, tmp42, 1);
      quit(1);
    }
    strcpy(v49, v47);
    v51 = v50 - 1;
    v52 = 1;
    while ( 1 )
    {
      v54 = (unsigned __int8)*++v51;
      v53 = v54;
      if ( !v54 )
        break;
      if ( v53 == 44 )
        ++v52;
    }
    ipaccess = (IPACCESS *)calloc(v52, 0x24u);
    if ( !ipaccess )
    {
      strcpy((char *)tmp42, "Failed to calloc ipaccess");
      applog(3, tmp42, 1);
      quit(1);
    }
    v55 = 0;
    ips = 0;
    if ( !v50 || (v56 = (unsigned __int8)*v50, !*v50) )
    {
      free(v50);
      goto LABEL_144;
    }
    v57 = v50;
    while ( 1 )
    {
      v58 = v56 == 32;
      if ( v56 != 32 )
        v58 = v56 == 9;
      if ( v58 )
      {
        v59 = (unsigned __int8 *)(v57 + 1);
        do
        {
          v85 = v59;
          v60 = *v59++;
          v56 = v60;
          v61 = v60 == 32;
          if ( v60 != 32 )
            v61 = v56 == 9;
        }
        while ( v61 );
      }
      else
      {
        v85 = (unsigned __int8 *)v57;
      }
      if ( v56 == 44 )
      {
        v57 = (char *)(v85 + 1);
      }
      else
      {
        v62 = strchr((const char *)v85, 44);
        v57 = v62;
        if ( v62 )
        {
          *v62 = 0;
          v57 = v62 + 1;
        }
        v63 = _ctype_b_loc();
        v64 = *v85;
        v65 = *v154;
        v66 = *((_BYTE *)*v154 + 328);
        if ( ((*v63)[v64] & 0x400) != 0 && v85[1] == 58 )
        {
          v84 = v65[v64];
          if ( v84 == v65[87] || apigroups[v84 - v65[65]].commands )
            v66 = v65[v64];
          v85 += 2;
        }
        v67 = &ipaccess[v55];
        v67->group = v66;
        v68 = *v85;
        if ( v68 == 48 && v85[1] == 47 && v85[2] == 48 && (v69 = v85[3]) == 0 )
        {
          v70 = (char *)(&v67[-1].group + 3);
          v71 = v85[3];
          do
          {
            ++v69;
            *++v70 = v71;
            v70[16] = v71;
          }
          while ( v69 != 16 );
          ips = ++v55;
        }
        else
        {
          v72 = strchr((const char *)v85, 47);
          if ( !v72 )
          {
            for ( i = 0; i != 16; ++i )
            {
              v87 = &v67->ip.__u6_addr8[i];
              v87[16] = -1;
            }
            v68 = *v85;
            v72 = (char *)&v85[strlen((const char *)v85)];
          }
          if ( v68 == 91 && *(v72 - 1) == 93 )
          {
            v73 = 1;
            *v85++ = 0;
            *(v72 - 1) = 0;
          }
          else
          {
            v73 = 0;
          }
          if ( *v72 )
          {
            *v72 = 0;
            v77 = strtol(v72 + 1, 0, 10);
            if ( v77 <= 0 )
              goto LABEL_100;
            v78 = v73 ? 0 : 96;
            v79 = v77 + v78;
            if ( v77 + v78 > 128 )
              goto LABEL_100;
            v80 = 0;
            v81 = 0;
            do
            {
              v82 = &v67->ip.__u6_addr8[v80++];
              v82[16] = 0;
            }
            while ( v80 != 16 );
            v83 = 7;
            while ( v79 > 0 )
            {
              v67->mask.__u6_addr8[v81] |= 1 << v83;
              if ( v83 )
              {
                --v83;
              }
              else
              {
                ++v81;
                v83 = 7;
              }
              --v79;
            }
          }
          for ( j = 0; j != 16; ++j )
            v67->ip.__u6_addr8[j] = 0;
          if ( v73 )
          {
            if ( inet_pton(10, (const char *)v85, v67) == 1 )
              goto LABEL_117;
          }
          else
          {
            sprintf((char *)tmp42, "::ffff:%s", v85);
            v55 = ips;
            v67 = &ipaccess[ips];
            if ( inet_pton(10, (const char *)tmp42, v67) == 1 )
            {
LABEL_117:
              for ( k = 0; k != 16; ++k )
              {
                v76 = v67->ip.__u6_addr8[0];
                v67 = (IPACCESS *)((char *)v67 + 1);
                *(&v67[-1].group + 3) = v76 & v67->ip.__u6_addr8[15];
              }
              ips = ++v55;
            }
          }
        }
      }
LABEL_100:
      if ( v57 )
      {
        v56 = (unsigned __int8)*v57;
        if ( *v57 )
          continue;
      }
      free(v50);
      if ( v55 )
        break;
LABEL_144:
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API not running (no valid IPs specified)%s", " - API will not be available");
        applog(4, tmp42, 0);
      }
LABEL_6:
      free(__cancel_arg);
      return;
    }
  }
  v1 = port;
  cgsleep_ms(1000 * opt_log_interval);
  sprintf((char *)port_s, "%d", port);
  hints.ai_flags = 1;
  memset(&hints.ai_family, 0, 28);
  if ( getaddrinfo((const char *)opt_api_host, (const char *)port_s, &hints, &res) )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      goto LABEL_6;
    snprintf((char *)tmp42, 0x800u, "API failed to resolve %s", (const char *)opt_api_host);
    goto LABEL_108;
  }
  v88 = res;
  if ( res )
  {
    v89 = res;
    while ( 1 )
    {
      v90 = socket(v88->ai_family, 1, 0);
      *__cancel_arg = v90;
      if ( v90 > 0 )
        break;
      v89 = v89->ai_next;
      if ( !v89 )
        goto LABEL_202;
      v88 = res;
    }
  }
  else
  {
    v90 = *__cancel_arg;
LABEL_202:
    if ( v90 == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        v103 = _errno_location();
        v104 = strerror(*v103);
        snprintf((char *)tmp42, 0x800u, "API initialisation failed (%s)%s", v104, " - API will not be available");
        applog(3, tmp42, 0);
      }
      freeaddrinfo(res);
      free(__cancel_arg);
      return;
    }
    v89 = 0;
  }
  optval = 1;
  if ( setsockopt(v90, 1, 2, &optval, 4u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v105 = _errno_location();
    v106 = strerror(*v105);
    snprintf((char *)tmp42, 0x800u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v106);
    applog(7, tmp42, 0);
  }
  v91 = time(0);
  while ( bind(*__cancel_arg, v89->ai_addr, v89->ai_addrlen) < 0 )
  {
    v102 = _errno_location();
    v2 = strerror(*v102);
    if ( time(0) - v91 > 61 )
      goto LABEL_294;
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "API bind to port %d failed - trying again in 30sec", port);
      applog(4, tmp42, 0);
    }
    cgsleep_ms(30000);
  }
  freeaddrinfo(res);
  if ( listen(*__cancel_arg, 100) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v147 = _errno_location();
      v148 = strerror(*v147);
      snprintf((char *)tmp42, 0x800u, "API3 initialisation failed (%s)%s", v148, " - API will not be available");
      applog(3, tmp42, 0);
    }
    close(*__cancel_arg);
    goto LABEL_6;
  }
  if ( opt_api_allow )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      goto LABEL_166;
    snprintf((char *)tmp42, 0x800u, "API running in IP access mode on port %d (%d)", port, *__cancel_arg);
  }
  else if ( opt_api_network )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      goto LABEL_166;
    snprintf((char *)tmp42, 0x800u, "API running in UNRESTRICTED read access mode on port %d (%d)", port, *__cancel_arg);
  }
  else
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      goto LABEL_166;
    snprintf((char *)tmp42, 0x800u, "API running in local read access mode on port %d (%d)", port, *__cancel_arg);
  }
  applog(4, tmp42, 0);
LABEL_166:
  if ( opt_api_mcast )
    mcast_init();
  strbufs = k_new_list("StrBufs", 0xCu, 2, 0, 0, "api.c", (const unsigned __int8 *)&_func___11476, 5429);
  if ( bye )
    goto die;
  v92 = bye;
  v93 = (json_t_0 *)bye;
  do
  {
    clisiz = 128;
    c = accept(*__cancel_arg, (struct sockaddr *)&cli, &clisiz);
    if ( c < 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        v138 = _errno_location();
        v139 = strerror(*v138);
        snprintf((char *)tmp42_0, 0x800u, "API failed (%s)%s (%d)", v139, " - API will not be available", *__cancel_arg);
        applog(3, tmp42_0, 0);
      }
      break;
    }
    v94 = check_connect(&cli, &connectaddr, &group);
    v95 = v94;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      v96 = "Accepted";
      if ( !v94 )
        v96 = "Ignored";
      snprintf((char *)tmp42_0, 0x800u, "API: connection from %s - %s", (const char *)connectaddr, v96);
      applog(7, tmp42_0, 0);
    }
    if ( !v95 )
      goto LABEL_179;
    v107 = recv(c, buf, 0x1FFFu, 0);
    v108 = v107;
    if ( v107 < 0 )
    {
      buf[0] = 0;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        v141 = _errno_location();
        v142 = strerror(*v141);
        snprintf((char *)tmp42_0, 0x800u, "API: recv failed: %s", v142);
        applog(7, tmp42_0, 0);
      }
      goto LABEL_179;
    }
    v109 = opt_debug;
    buf[v107] = 0;
    if ( v109 && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42_0, 0x800u, "API: recv command: (%d) '%s'", v107, (const char *)buf);
      applog(7, tmp42_0, 0);
    }
    v110 = 0;
    v111 = time(0);
    ptr = v159->ptr;
    when = v111;
    v159->cur = ptr;
    *ptr = 0;
    v113 = buf[0];
    v159->close = 0;
    if ( v113 != 123 )
    {
      v114 = strchr((const char *)buf, 124);
      v115 = (unsigned __int8 *)v114;
      v116 = (const char *)buf;
      if ( v114 )
      {
        *v114 = 0;
        v115 = (unsigned __int8 *)(v114 + 1);
      }
      else
      {
        v110 = 0;
      }
      goto LABEL_224;
    }
    v140 = json_loadb(buf, v108, 0, &json_err);
    v93 = v140;
    if ( !v140 || v140->type )
    {
      message(v159, 23, 0, 0, 1);
      goto LABEL_279;
    }
    v143 = json_object_get(v140, "command");
    if ( !v143 )
    {
      message(v159, 24, 0, 0, 1);
LABEL_279:
      LOBYTE(v110) = 1;
      send_result(v159, c, 1);
      v129 = (int)v93;
      if ( v93 )
        v129 = 1;
      if ( v92 )
        goto LABEL_260;
      goto LABEL_245;
    }
    if ( v143->type != JSON_STRING )
    {
      message(v159, 14, 0, 0, 1);
      goto LABEL_279;
    }
    v116 = (const char *)json_string_value(v143);
    v149 = json_object_get(v93, "parameter");
    v115 = (unsigned __int8 *)v149;
    if ( !v149 )
      goto LABEL_330;
    type = v149->type;
    if ( v149->type == JSON_STRING )
    {
      v110 = 1;
      v115 = (unsigned __int8 *)json_string_value(v149);
      goto LABEL_224;
    }
    if ( type == JSON_INTEGER )
    {
      v151 = json_integer_value(v149);
      v110 = 1;
      v115 = tmp42;
      sprintf((char *)tmp42, "%d", v151);
      goto LABEL_224;
    }
    if ( type != JSON_REAL )
    {
      v115 = 0;
LABEL_330:
      v110 = 1;
      goto LABEL_224;
    }
    json_real_value(v149);
    v115 = tmp42;
    v110 = 1;
    sprintf((char *)tmp42, "%f", v3);
LABEL_224:
    if ( strchr(v116, 43) )
    {
      firstjoin = 1;
      v117 = strlen(v116);
      cmdsbuf = (char *)malloc(v117 + 3);
      if ( !cmdsbuf )
      {
        snprintf((char *)tmp42_0, 0x800u, "OOM cmdsbuf in %s %s():%d", "api.c", (const char *)&_func___11476, 5540);
        applog(3, tmp42_0, 1);
        quit(1);
      }
      v118 = 1;
      v115 = 0;
      *(_WORD *)cmdsbuf = 124;
    }
    else
    {
      cmdsbuf = 0;
      v118 = 0;
      firstjoin = 0;
    }
    v119 = v118;
    v120 = (char *)v116;
    v121 = (char *)v116;
    v122 = v119;
    param = v115;
    do
    {
      if ( v122 )
      {
        v123 = strchr(v120, 43);
        v121 = v123;
        if ( v123 )
        {
          *v123 = 0;
          v121 = v123 + 1;
        }
        if ( !*v120 )
          goto LABEL_239;
      }
      v124 = cmds[0].name;
      if ( cmds[0].name )
      {
        v125 = cmds;
        v126 = 0;
        while ( strcmp(v120, (const char *)v124) )
        {
          v127 = v125[1].name;
          ++v125;
          v124 = v127;
          ++v126;
          if ( !v127 )
            goto LABEL_250;
        }
        sprintf((char *)cmdbuf, "|%s|", v120);
        if ( v122 )
        {
          if ( strstr(cmdsbuf, (const char *)cmdbuf) )
            goto LABEL_239;
          v136 = strlen(cmdsbuf);
          strcpy((char *)stpcpy(&cmdsbuf[v136], v120), "|");
          head_join(v159, (unsigned __int8 *)v120, v110, &firstjoin);
          v137 = (unsigned __int8 **)codes + 3 * v126;
          if ( !*((_BYTE *)v137 + 1097) )
          {
            message(v159, 45, *((unsigned __int8 *)v137 + 1097), v137[272], v110);
            tail_join(v159, v110);
            goto LABEL_239;
          }
        }
        v133 = group;
        v134 = (*v154)[group];
        if ( v134 == (*v154)[87]
          || (v152 = group,
              v135 = strstr((const char *)apigroups[v134 - (*v154)[65]].commands, (const char *)cmdbuf),
              v133 = v152,
              v135) )
        {
          (*((void (__fastcall **)(io_data *, int, unsigned __int8 *, _BOOL4, int))&codes[68].code + 3 * v126))(
            v159,
            c,
            param,
            v110,
            v133);
        }
        else
        {
          message(v159, 45, 0, *((unsigned __int8 **)&codes[68].severity + 3 * v126), v110);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42_0,
              0x800u,
              "API: access denied to '%s' for '%s' command",
              (const char *)connectaddr,
              *((const char **)&codes[68].severity + 3 * v126));
            applog(7, tmp42_0, 0);
          }
        }
        v132 = v159;
        if ( v122 )
          goto LABEL_257;
      }
      else
      {
LABEL_250:
        if ( v122 )
        {
          head_join(v159, (unsigned __int8 *)v120, v110, &firstjoin);
          message(v159, 14, 0, 0, v110);
          v132 = v159;
LABEL_257:
          tail_join(v132, v110);
LABEL_239:
          v120 = v121;
          goto LABEL_240;
        }
        message(v159, 14, 0, 0, v110);
        v132 = v159;
      }
      send_result(v132, c, v110);
LABEL_240:
      if ( v120 )
        v128 = v122;
      else
        v128 = 0;
    }
    while ( v128 );
    v92 = v122;
    v129 = v110;
    if ( !v122 )
      goto LABEL_245;
LABEL_260:
    send_result(v159, c, v110);
LABEL_245:
    if ( v129 )
    {
      if ( v93->type == JSON_OBJECT )
      {
        refcount = v93->refcount;
        if ( refcount != -1 )
        {
          v131 = refcount - 1;
          v93->refcount = v131;
          if ( !v131 )
            json_delete(v93);
        }
      }
    }
LABEL_179:
    close(c);
  }
  while ( !bye );
die:
  _pthread_unregister_cancel(&__cancel_buf);
  tidyup(__cancel_arg);
  free(__cancel_arg);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( do_a_quit )
    {
      v97 = "QUIT";
    }
    else if ( do_a_restart )
    {
      v97 = "RESTART";
    }
    else if ( bye )
    {
      v97 = "BYE";
    }
    else
    {
      v97 = "UNKNOWN!";
    }
    snprintf((char *)tmp42_0, 0x800u, "API: terminating due to: %s", v97);
    applog(7, tmp42_0, 0);
  }
  if ( pthread_mutex_lock(&quit_restart_lock) )
    mutex_lock_1((pthread_mutex_t *)&_func___11476, (const unsigned __int8 *)0x1607, v98, v99);
  if ( do_a_restart )
  {
    if ( thr_info_create(&bye_thr, 0, restart_thread, &bye_thr) )
    {
      mutex_unlock(&quit_restart_lock, (const unsigned __int8 *)&_func___11476, (const unsigned __int8 *)0x160D, v145);
      strcpy((char *)tmp42_0, "API failed to initiate a restart - aborting");
      applog(3, tmp42_0, 1);
      quit(1);
    }
  }
  else
  {
    if ( !do_a_quit )
      goto LABEL_192;
    if ( thr_info_create(&bye_thr, (pthread_attr_t *)do_a_restart, quit_thread, &bye_thr) )
    {
      mutex_unlock(&quit_restart_lock, (const unsigned __int8 *)&_func___11476, (const unsigned __int8 *)0x1616, v144);
      strcpy((char *)tmp42_0, "API failed to initiate a clean quit - aborting");
      applog(3, tmp42_0, 1);
      quit(1);
    }
  }
  pthread_detach(bye_thr.pth);
LABEL_192:
  if ( pthread_mutex_unlock(&quit_restart_lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11476, (const unsigned __int8 *)0x161C, v100, v101);
  selective_yield();
}
// 1D55C: variable 'v1' is possibly undefined
// 1D55C: variable 'v2' is possibly undefined
// 1D62A: variable 'v100' is possibly undefined
// 1D62A: variable 'v101' is possibly undefined
// 1D656: variable 'v144' is possibly undefined
// 1D6B2: variable 'v145' is possibly undefined
// 1D6DE: variable 'v98' is possibly undefined
// 1D6DE: variable 'v99' is possibly undefined
// 1D874: variable 'v3' is possibly undefined
// A1A4: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);

//----- (0001D8B8) --------------------------------------------------------
unsigned __int8 *__fastcall set_balance(pool_strategy *strategy)
{
  *strategy = POOL_BALANCE;
  return 0;
}

//----- (0001D8C0) --------------------------------------------------------
unsigned __int8 *__fastcall set_loadbalance(pool_strategy *strategy)
{
  *strategy = POOL_LOADBALANCE;
  return 0;
}

//----- (0001D8C8) --------------------------------------------------------
unsigned __int8 *__fastcall set_rr(pool_strategy *strategy)
{
  *strategy = POOL_ROUNDROBIN;
  return 0;
}

//----- (0001D8D0) --------------------------------------------------------
unsigned __int8 *__fastcall enable_debug(bool *flag)
{
  unsigned __int8 *result; // r0

  *flag = 0;
  result = 0;
  opt_log_output = 0;
  return result;
}

//----- (0001D8E4) --------------------------------------------------------
unsigned __int8 *__fastcall set_null(const unsigned __int8 *arg)
{
  return 0;
}

//----- (0001D8F4) --------------------------------------------------------
bool __fastcall noop_get_stats(cgpu_info *cgpu)
{
  return 1;
}

//----- (0001D8F8) --------------------------------------------------------
bool __fastcall noop_thread_prepare(thr_info *thr)
{
  return 1;
}

//----- (0001D8FC) --------------------------------------------------------
uint64_t __fastcall noop_can_limit_work(thr_info *thr)
{
  return 0xFFFFFFFFLL;
}

//----- (0001D904) --------------------------------------------------------
bool __fastcall noop_thread_init(thr_info *thr)
{
  return 1;
}

//----- (0001D908) --------------------------------------------------------
bool __fastcall noop_prepare_work(thr_info *thr, work *work)
{
  return 1;
}

//----- (0001D91C) --------------------------------------------------------
api_data *__fastcall noop_get_api_stats(cgpu_info *cgpu)
{
  return 0;
}

//----- (0001D924) --------------------------------------------------------
void __fastcall generic_zero_stats(cgpu_info *cgpu)
{
  cgpu->diff_rejected = 0.0;
  cgpu->hw_errors = 0;
  cgpu->diff_accepted = 0.0;
}

//----- (0001D938) --------------------------------------------------------
bool __fastcall new_nonce(thr_info *thr, unsigned int nonce)
{
  cgpu_info *cgpu; // r3
  bool result; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  cgpu = thr->cgpu;
  if ( cgpu->last_nonce == nonce )
  {
    if ( use_syslog || (result = opt_log_output) || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s %d duplicate share detected as HW error",
        (const char *)cgpu->drv->name,
        cgpu->device_id);
      applog(6, tmp42, 0);
      return 0;
    }
  }
  else
  {
    cgpu->last_nonce = nonce;
    return 1;
  }
  return result;
}

//----- (0001D9A0) --------------------------------------------------------
unsigned __int8 *__fastcall json_escape(unsigned __int8 *str)
{
  size_t v2; // r0
  unsigned __int8 *v3; // r5
  JE *v4; // r0
  JE *v5; // r1
  int v6; // r3
  unsigned __int8 *v7; // r1
  unsigned __int8 *v8; // r2
  bool v9; // zf
  unsigned __int8 v10; // t1
  unsigned __int8 *result; // r0

  v2 = strlen((const char *)str);
  v3 = (unsigned __int8 *)cgmalloc(2 * v2 + 1, "cgminer.c", _func___14048, 5816);
  v4 = (JE *)cgmalloc(8u, "cgminer.c", _func___14048, 5817);
  v4->buf = v3;
  v5 = jedata;
  jedata = v4;
  v4->next = v5;
  v6 = *str;
  if ( *str )
  {
    v7 = str - 1;
    v8 = v3;
    do
    {
      v9 = v6 == 92;
      if ( v6 != 92 )
        v9 = v6 == 34;
      if ( v9 )
        *v8++ = 92;
      v10 = *++v7;
      *v8++ = v10;
      v6 = v7[1];
    }
    while ( v7[1] );
  }
  else
  {
    v8 = v3;
  }
  result = v3;
  *v8 = 0;
  return result;
}

//----- (0001DA10) --------------------------------------------------------
void __fastcall thread_reportin(thr_info *thr)
{
  cgpu_info *cgpu; // r5

  thr->getwork = 0;
  cgtime(&thr->last);
  cgpu = thr->cgpu;
  cgpu->status = LIFE_WELL;
  cgpu->device_last_well = time(0);
}

//----- (0001DA30) --------------------------------------------------------
void __fastcall thread_reportout(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 1;
  cgtime(&thr->last);
  cgpu = thr->cgpu;
  cgpu->status = LIFE_WELL;
  cgpu->device_last_well = time(0);
}

//----- (0001DA54) --------------------------------------------------------
unsigned __int8 *__fastcall set_default_config(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &default_config);
  return 0;
}

//----- (0001DA64) --------------------------------------------------------
unsigned __int8 *__fastcall set_logfile_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_path);
  return 0;
}

//----- (0001DA74) --------------------------------------------------------
unsigned __int8 *__fastcall set_logwork_asicnum(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_asicnum);
  return 0;
}

//----- (0001DA84) --------------------------------------------------------
unsigned __int8 *__fastcall set_logwork_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_path);
  return 0;
}

//----- (0001DA94) --------------------------------------------------------
unsigned __int8 *__fastcall set_logfile_openflag(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_openflag);
  return 0;
}

//----- (0001DAA4) --------------------------------------------------------
unsigned __int8 *__fastcall set_version_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_version_path);
  return 0;
}

//----- (0001DAB4) --------------------------------------------------------
void __fastcall __noreturn opt_verusage_and_exit(const unsigned __int8 *a1)
{
  unsigned __int8 *v2; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", (const char *)packagename);
  v2 = opt_usage(opt_argv0, a1);
  printf("%s", (const char *)v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 6298C: using guessed type int stdout;

//----- (0001DB00) --------------------------------------------------------
unsigned __int8 *__fastcall set_sharelog(unsigned __int8 *arg)
{
  int v2; // r0
  int v3; // r5
  unsigned __int8 *r; // [sp+4h] [bp-814h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  r = (unsigned __int8 *)"";
  v2 = strtol((const char *)arg, (char **)&r, 10);
  v3 = v2;
  if ( *r || v2 < 0 )
  {
    if ( *arg != 45 || arg[1] )
    {
      sharelog_file = fopen((const char *)arg, (const char *)"a");
      if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        snprintf((char *)tmp42, 0x800u, "Failed to open %s for share log", arg);
        goto LABEL_17;
      }
    }
    else
    {
      sharelog_file = (FILE *)stdout;
      if ( !stdout && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        strcpy((char *)tmp42, "Standard output missing for share log");
        applog(3, tmp42, 0);
      }
    }
  }
  else
  {
    sharelog_file = fdopen(v2, (const char *)"a");
    if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
    {
      snprintf((char *)tmp42, 0x800u, "Failed to open fd %u for share log", v3);
LABEL_17:
      applog(3, tmp42, 0);
    }
  }
  return 0;
}
// 6298C: using guessed type int stdout;

//----- (0001DC10) --------------------------------------------------------
void *__fastcall submit_work_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0001DC20) --------------------------------------------------------
void __fastcall get_benchmark_work(work *work)
{
  timeval *p_tv_getwork; // r5
  pool **v3; // r3

  p_tv_getwork = &work->tv_getwork;
  work->work_difficulty = 32.0;
  cg_memcpy(work->target, bench_target, 0x20u, "cgminer.c", _func___13488, 4165);
  v3 = pools;
  work->drv_rolllimit = 0;
  work->mandatory = 1;
  work->pool = *v3;
  cgtime(p_tv_getwork);
  copy_time(&work->tv_getwork_reply, p_tv_getwork);
  work->getwork_mode = 66;
}

//----- (0001DC94) --------------------------------------------------------
void __fastcall suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits)
{
  double v6; // r0
  double v7; // d8
  double v8; // d0
  double v9; // r0
  unsigned __int8 suffix[2]; // [sp+1Ch] [bp-34h] BYREF

  *(_WORD *)suffix = 0;
  if ( val > 0xDE0B6B3A763FFFFLL )
  {
    v6 = (double)(val / *(_QWORD *)sub_1DEA4);
    strcpy((char *)suffix, "E");
    v7 = v6 / 1000.0;
    goto LABEL_3;
  }
  if ( val > 0x38D7EA4C67FFFLL )
  {
    v6 = (double)(val / 0xE8D4A51000LL);
    strcpy((char *)suffix, "P");
    v7 = v6 / 1000.0;
    goto LABEL_3;
  }
  if ( val > 0xE8D4A50FFFLL )
  {
    v6 = (double)(val / 0x3B9ACA00);
    strcpy((char *)suffix, "T");
    v7 = v6 / 1000.0;
    goto LABEL_3;
  }
  if ( val > 0x3B9AC9FF )
  {
    v6 = (double)(val / (unsigned int)&cgpu.results[29][3663]);
    strcpy((char *)suffix, "G");
    v7 = v6 / 1000.0;
    goto LABEL_3;
  }
  if ( (unsigned int)&cgpu.results[29][3662] + 3 < val )
  {
    v6 = (double)(val / 0x3E8);
    strcpy((char *)suffix, "M");
    v7 = v6 / 1000.0;
    goto LABEL_3;
  }
  if ( val >= 0x3E8 )
  {
    v6 = (double)val;
    strcpy((char *)suffix, "K");
    v7 = v6 / 1000.0;
LABEL_3:
    if ( !sigdigits )
    {
      snprintf((char *)buf, bufsiz, "%.3g%s", v7, (const char *)suffix);
      return;
    }
    goto LABEL_7;
  }
  v6 = (double)val;
  v7 = v6;
  if ( !sigdigits )
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)v6, (const char *)suffix);
    return;
  }
LABEL_7:
  if ( v7 <= 0.0 )
  {
    v8 = 0.0;
  }
  else
  {
    v8 = v7;
    v9 = log10(v6);
    floor(v9);
  }
  snprintf((char *)buf, bufsiz, "%*.*f%s", sigdigits + 1, (int)((double)(sigdigits - 1) - v8), v7, (const char *)suffix);
}

//----- (0001DEA4) --------------------------------------------------------
void __fastcall sub_1DEA4(work *a1, double a2)
{
  *(_WORD *)a1->data = (_WORD)a1;
  HIDWORD(a2) = a1;
  calc_diff(a1, a2);
}

//----- (0001DEAC) --------------------------------------------------------
void __fastcall calc_diff(work *work, double known)
{
  double v3; // d0
  double v4; // d8
  pool *pool; // r4
  double v6; // d9
  double min_diff; // d7
  double max_diff; // d7

  v4 = v3;
  pool = work->pool;
  if ( v3 == 0.0 )
  {
    v6 = (double)*(unsigned __int64 *)&work->target[24] * 6.27710174e57
       + (double)*(unsigned __int64 *)&work->target[16] * 3.40282367e38
       + (double)*(unsigned __int64 *)&work->target[8] * 1.84467441e19
       + (double)*(unsigned __int64 *)work->target;
    if ( v6 == 0.0 )
      v6 = 1.0;
    v4 = 2.69595353e67 / v6;
  }
  work->work_difficulty = v4;
  pool->cgminer_pool_stats.last_diff = v4;
  round();
  suffix_string((unsigned __int64)v4, pool->diff, 8u, 0);
  min_diff = pool->cgminer_pool_stats.min_diff;
  if ( min_diff == v4 )
  {
    ++pool->cgminer_pool_stats.min_diff_count;
    goto LABEL_7;
  }
  if ( min_diff <= v4 )
  {
    if ( min_diff != 0.0 )
    {
LABEL_7:
      max_diff = pool->cgminer_pool_stats.max_diff;
      if ( max_diff != v4 )
        goto LABEL_8;
LABEL_14:
      ++pool->cgminer_pool_stats.max_diff_count;
      return;
    }
    pool->cgminer_pool_stats.min_diff = v4;
    pool->cgminer_pool_stats.min_diff_count = 1;
  }
  else
  {
    pool->cgminer_pool_stats.min_diff = v4;
    pool->cgminer_pool_stats.min_diff_count = 1;
  }
  max_diff = pool->cgminer_pool_stats.max_diff;
  if ( max_diff == v4 )
    goto LABEL_14;
LABEL_8:
  if ( max_diff < v4 )
  {
    pool->cgminer_pool_stats.max_diff = v4;
    pool->cgminer_pool_stats.max_diff_count = 1;
  }
}
// 1DEBE: variable 'v3' is possibly undefined
// A2CC: using guessed type int round(void);

//----- (0001E000) --------------------------------------------------------
void __fastcall benchfile_dspwork(work *work, unsigned int nonce)
{
  int v2; // r2
  int v3; // r4
  int v4; // r3
  unsigned __int8 buf[1024]; // [sp+8h] [bp-C08h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+408h] [bp-808h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    v4 = (unsigned __int8)nonce;
    --v2;
    nonce >>= 8;
    v3 = v4 + (v3 << 8);
  }
  while ( v2 );
  _bin2hex(buf, work->data, 0x80u);
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, (const char *)buf);
    applog(3, tmp42, 0);
  }
}

//----- (0001E074) --------------------------------------------------------
bool should_run()
{
  struct tm *v0; // r0
  int v1; // r5
  _BOOL4 result; // r0
  int v3; // r2
  int tm_hour; // r2
  int v5; // r2
  time_t tv_sec; // [sp+4h] [bp-24h] BYREF
  timeval tv; // [sp+8h] [bp-20h] BYREF

  if ( !schedstart.enable && !schedstop.enable )
    return 1;
  cgtime(&tv);
  tv_sec = tv.tv_sec;
  v0 = localtime(&tv_sec);
  if ( !schedstart.enable )
  {
    tm_hour = v0->tm_hour;
    return tm_hour < schedstop.tm.tm_hour || tm_hour == schedstop.tm.tm_hour && v0->tm_min < schedstop.tm.tm_min;
  }
  if ( !schedstop.enable )
  {
    v1 = v0->tm_hour;
    if ( v1 >= schedstart.tm.tm_hour && (v1 != schedstart.tm.tm_hour || v0->tm_min >= schedstart.tm.tm_min) )
    {
      result = 1;
      schedstart.enable = 0;
      return result;
    }
    return 0;
  }
  if ( schedstart.tm.tm_hour >= schedstop.tm.tm_hour
    && (schedstart.tm.tm_hour != schedstop.tm.tm_hour || schedstart.tm.tm_min >= schedstop.tm.tm_min) )
  {
    v3 = v0->tm_hour;
    if ( schedstart.tm.tm_hour <= v3 )
    {
      if ( schedstart.tm.tm_hour != v3 || v0->tm_min >= schedstart.tm.tm_min )
        return 1;
    }
    else if ( schedstop.tm.tm_hour > v3 )
    {
      return 1;
    }
    return schedstop.tm.tm_hour == v3 && v0->tm_min < schedstop.tm.tm_min;
  }
  v5 = v0->tm_hour;
  return (schedstop.tm.tm_hour > v5 || schedstop.tm.tm_hour == v5 && v0->tm_min < schedstop.tm.tm_min)
      && schedstart.tm.tm_hour <= v5
      && (schedstart.tm.tm_hour != v5 || v0->tm_min >= schedstart.tm.tm_min);
}

//----- (0001E13C) --------------------------------------------------------
void __fastcall regen_hash(work *work)
{
  int i; // r1
  unsigned __int8 hash1[32]; // [sp+0h] [bp-78h] BYREF
  unsigned __int8 swap[80]; // [sp+20h] [bp-58h] BYREF

  for ( i = 0; i != 80; i += 4 )
    *(_DWORD *)&swap[i] = bswap32(*(_DWORD *)&work->data[i]);
  sha256(swap, 0x50u, hash1);
  sha256(hash1, 0x20u, work->hash);
}

//----- (0001E168) --------------------------------------------------------
void __fastcall calc_midstate(work *work)
{
  int i; // r4
  unsigned __int8 data[64]; // [sp+8h] [bp-F8h] BYREF
  sha256_ctx ctx; // [sp+48h] [bp-B8h] BYREF

  for ( i = 0; i != 64; i += 4 )
    *(_DWORD *)&data[i] = bswap32(*(_DWORD *)&work->data[i]);
  sha256_init(&ctx);
  sha256_update(&ctx, data, 0x40u);
  cg_memcpy(work->midstate, ctx.h, 0x20u, "cgminer.c", _func___13261, 2173);
}

//----- (0001E1B4) --------------------------------------------------------
void *__fastcall __noreturn killall_thread(void *arg)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (0001E1D4) --------------------------------------------------------
void __noreturn errlog(const char *a1, ...)
{
  va_list varg_r1; // [sp+1Ch] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  vsnprintf((char *)exit_buf, 0x200u, a1, varg_r1);
  applog(3, exit_buf, 1);
  exit(1);
}

//----- (0001E204) --------------------------------------------------------
void __fastcall mt_disable(thr_info *mythr, const int thr_id, device_drv *drv)
{
  _BOOL4 v6; // r2
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-820h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being disabled", thr_id);
    applog(4, tmp42, 0);
  }
  v6 = opt_debug;
  mythr->cgpu->rolling = 0.0;
  if ( v6 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Waiting on sem in miner thread");
    applog(7, tmp42, 0);
  }
  cgsem_wait(&mythr->sem, "cgminer.c", _func___14730, 9016);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being re-enabled", thr_id);
    applog(4, tmp42, 0);
  }
  drv->thread_enable(mythr);
}

//----- (0001E300) --------------------------------------------------------
void *__fastcall start(void *userdata)
{
  cgpu_info *v2; // r8
  device_drv *drv; // r7
  time_t v4; // r0
  void (*hash_work)(thr_info *); // r3
  unsigned __int8 threadname[16]; // [sp+0h] [bp-828h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v2 = (cgpu_info *)*((_DWORD *)userdata + 9);
  drv = v2->drv;
  snprintf((char *)threadname, 0x10u, "%d/Miner", *(_DWORD *)userdata);
  RenameThread(threadname);
  thread_reportout((thr_info *)userdata);
  if ( ((int (__fastcall *)(void *))drv->thread_init)(userdata) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Waiting on sem in miner thread");
      applog(7, tmp42, 0);
    }
    cgsem_wait((cgsem_t *)userdata + 1, "cgminer.c", _func___14971, 9656);
    v4 = time(0);
    hash_work = drv->hash_work;
    v2->last_device_valid_work = v4;
    hash_work((thr_info *)userdata);
    drv->thread_shutdown((thr_info *)userdata);
  }
  else
  {
    dev_error(v2, REASON_THREAD_FAIL_INIT);
  }
  return 0;
}

//----- (0001E3CC) --------------------------------------------------------
bool __fastcall pool_unusable(pool *pool)
{
  if ( pool->idle || pool->enabled != POOL_ENABLED )
    return 1;
  if ( !pool->has_stratum )
    return pool->has_stratum;
  if ( !pool->stratum_active || !pool->stratum_notify )
    return 1;
  return pool->idle;
}

//----- (0001E3FC) --------------------------------------------------------
pool *__fastcall select_balanced(pool *cp)
{
  int shares; // r7
  pool *v2; // r8
  pool **v3; // r4
  pool **v4; // r6
  pool *v5; // r5
  pool *v6; // t1
  pool *result; // r0

  shares = cp->shares;
  if ( total_pools <= 0 )
  {
    v2 = cp;
  }
  else
  {
    v2 = cp;
    v3 = pools;
    v4 = &pools[total_pools];
    do
    {
      v6 = *v3++;
      v5 = v6;
      if ( !pool_unusable(v6) && v5->shares < shares )
      {
        v2 = v5;
        shares = v5->shares;
      }
    }
    while ( v3 != v4 );
    shares = v2->shares;
  }
  result = v2;
  v2->shares = shares + 1;
  return result;
}

//----- (0001E450) --------------------------------------------------------
pool *__fastcall priority_pool(int choice)
{
  pool **v1; // r2
  pool *v2; // r1
  int v3; // r3
  pool *v4; // t1

  if ( total_pools <= 0 )
    return priority_pool_0(choice);
  v1 = pools;
  v2 = *pools;
  if ( (*pools)->prio != choice )
  {
    v3 = 0;
    while ( ++v3 != total_pools )
    {
      v4 = v1[1];
      ++v1;
      v2 = v4;
      if ( v4->prio == choice )
        return v2;
    }
    return priority_pool_0(choice);
  }
  return v2;
}

//----- (0001E490) --------------------------------------------------------
unsigned __int8 *__fastcall load_config(const unsigned __int8 *arg, void *unused)
{
  bool v3; // nf
  char *v4; // r4
  json_t_0 *v6; // r0
  size_t v7; // r7
  unsigned int v8; // r7
  json_error_t error; // [sp+Ch] [bp-114h] BYREF

  if ( !cnfbuf )
    cnfbuf = (unsigned __int8 *)_strdup((const char *)arg);
  v3 = include_count - 9 < 0;
  ++include_count;
  if ( !(v3 ^ __OFSUB__(include_count, 10) | (include_count == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  v6 = json_load_file(arg, 0, &error);
  if ( v6 && v6->type == JSON_OBJECT )
  {
    config_loaded = 1;
    return parse_config(v6, 1);
  }
  else
  {
    v7 = strlen((const char *)arg);
    v8 = v7 + strlen((const char *)error.text) + 35;
    v4 = (char *)cgmalloc(v8, "cgminer.c", _func___13218, 2041);
    snprintf(v4, v8, "JSON decode of file '%s' failed\n %s", (const char *)arg, (const char *)error.text);
  }
  return (unsigned __int8 *)v4;
}

//----- (0001E52C) --------------------------------------------------------
unsigned __int8 *__fastcall parse_config(json_t_0 *config, bool fileconf)
{
  opt_table *v2; // r6
  const char *names; // r0
  char *v4; // r8
  char *v5; // r7
  json_t_0 *v6; // r0
  const json_t_0 *v7; // r5
  opt_type type; // r2
  const char *v9; // r2
  opt_type v10; // r3
  size_t v11; // r4
  json_t_0 *v12; // r0
  unsigned __int8 *result; // r0
  const unsigned __int8 *v14; // r7
  const unsigned __int8 *v15; // r4
  int v16; // r0
  const unsigned __int8 *v17; // r0
  const char *v18; // [sp+8h] [bp-838h]
  const char *v19; // [sp+8h] [bp-838h]
  _BOOL4 v20; // [sp+Ch] [bp-834h]
  unsigned __int8 *p; // [sp+10h] [bp-830h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-828h] BYREF

  if ( fileconf && !fileconf_load )
    fileconf_load = 1;
  if ( opt_config_table[0].type == OPT_END )
    goto LABEL_48;
  if ( (opt_config_table[0].type & 8) != 0 )
    goto LABEL_28;
  v2 = &opt_config_table[1];
  v20 = fileconf;
  while ( 2 )
  {
    names = (const char *)v2[-1].names;
    if ( !names )
      goto LABEL_26;
    v4 = _strdup(names);
    v5 = strtok(v4, "|");
    if ( !v5 )
      goto LABEL_25;
    while ( 2 )
    {
      if ( v5[1] != 45 )
        goto LABEL_10;
      v6 = json_object_get(config, (const unsigned __int8 *)v5 + 2);
      v7 = v6;
      if ( !v6 )
        goto LABEL_10;
      type = v2[-1].type;
      if ( (type & 6) == 0 )
        goto LABEL_17;
      if ( v6->type == JSON_STRING )
      {
        v15 = json_string_value(v6);
        v16 = (int)v2[-1].cb_arg(v15, v2[-1].u.arg);
        v9 = (const char *)v16;
        if ( v2[-1].type == OPT_PROCESSARG )
        {
          v19 = (const char *)v16;
          opt_set_charp(v15, (unsigned __int8 **)v2[-1].u.carg);
          v9 = v19;
          if ( !v19 )
            goto LABEL_10;
        }
        else if ( !v16 )
        {
          goto LABEL_10;
        }
LABEL_19:
        if ( !v20 )
          goto LABEL_38;
        goto LABEL_20;
      }
      if ( v6->type != JSON_ARRAY )
      {
LABEL_17:
        if ( (type & 1) != 0 && v6->type == JSON_TRUE )
        {
          v9 = (const char *)v2[-1].cb(v2[-1].u.tlen);
          if ( !v9 )
            goto LABEL_10;
        }
        else
        {
          v9 = "Invalid value";
        }
        goto LABEL_19;
      }
      v11 = 0;
      p = (unsigned __int8 *)v5;
      while ( 1 )
      {
        if ( v11 >= json_array_size(v7) )
          goto LABEL_10;
        v12 = json_array_get(v7, v11);
        if ( !v12 )
          goto LABEL_10;
        if ( v12->type != JSON_STRING )
        {
          if ( v12->type )
            goto LABEL_30;
          v9 = (const char *)parse_config(v12, 0);
          goto LABEL_36;
        }
        v14 = json_string_value(v12);
        v9 = (const char *)v2[-1].cb_arg(v14, v2[-1].u.arg);
        if ( v2[-1].type == OPT_PROCESSARG )
          break;
LABEL_36:
        if ( v9 )
          goto LABEL_37;
LABEL_30:
        ++v11;
      }
      v18 = v9;
      opt_set_charp(v14, (unsigned __int8 **)v2[-1].u.carg);
      v9 = v18;
      if ( !v18 )
        goto LABEL_30;
LABEL_37:
      v5 = (char *)p;
      if ( !v20 )
      {
LABEL_38:
        snprintf((char *)err_buf_13181, 0xC8u, "Parsing JSON option %s: %s", v5, v9);
        return err_buf_13181;
      }
LABEL_20:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Invalid config option %s: %s", v5, v9);
        applog(3, tmp42, 0);
      }
      fileconf_load = -1;
LABEL_10:
      v5 = strtok(0, "|");
      if ( v5 )
        continue;
      break;
    }
LABEL_25:
    free(v4);
LABEL_26:
    v10 = v2->type;
    if ( v10 != OPT_END )
    {
      ++v2;
      if ( (v10 & 8) != 0 )
LABEL_28:
        _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x75Fu, (const char *)_PRETTY_FUNCTION___13187);
      continue;
    }
    break;
  }
LABEL_48:
  result = (unsigned __int8 *)json_object_get(config, "include");
  if ( result )
  {
    if ( *(_DWORD *)result == 2 )
    {
      v17 = json_string_value((const json_t_0 *)result);
      return load_config(v17, 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0001E75C) --------------------------------------------------------
void set_lowprio_0()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  strcpy((char *)tmp42, "Unable to set thread to low priority");
  applog(6, tmp42, 0);
}

//----- (0001E790) --------------------------------------------------------
void set_lowprio()
{
  if ( !nice(10) && (use_syslog || opt_log_output || opt_log_level > 5) )
    set_lowprio_0();
}

//----- (0001E7C4) --------------------------------------------------------
void *__fastcall api_thread(void *userdata)
{
  pthread_t v2; // r0
  void *result; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  RenameThread("API");
  set_lowprio();
  api(api_thr_id);
  result = 0;
  *((_DWORD *)userdata + 3) = 0;
  return result;
}

//----- (0001E800) --------------------------------------------------------
unsigned __int8 *__fastcall set_float_100_to_250(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *result; // r0

  result = opt_set_floatval(arg, i);
  if ( !result && (*i < 100.0 || *i > 250.0) )
    return "Value out of range";
  return result;
}

//----- (0001E83C) --------------------------------------------------------
unsigned __int8 *__fastcall set_float_125_to_500(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *result; // r0

  result = opt_set_floatval(arg, i);
  if ( !result && (*i < 125.0 || *i > 500.0) )
    return "Value out of range";
  return result;
}

//----- (0001E878) --------------------------------------------------------
unsigned __int8 *__fastcall set_sched_stop(const unsigned __int8 *arg)
{
  unsigned __int8 *result; // r0

  if ( sscanf((const char *)arg, "%d:%d", &schedstop.tm.tm_hour, &schedstop.tm.tm_min) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( schedstop.tm.tm_hour > 23 || schedstop.tm.tm_min > 59 || schedstop.tm.tm_hour < 0 || schedstop.tm.tm_min < 0 )
    return "Invalid time set.";
  result = 0;
  schedstop.enable = 1;
  return result;
}

//----- (0001E8C4) --------------------------------------------------------
unsigned __int8 *__fastcall set_sched_start(const unsigned __int8 *arg)
{
  unsigned __int8 *result; // r0

  if ( sscanf((const char *)arg, "%d:%d", &schedstart.tm.tm_hour, &schedstart.tm.tm_min) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( schedstart.tm.tm_hour > 23 || schedstart.tm.tm_min > 59 || schedstart.tm.tm_hour < 0 || schedstart.tm.tm_min < 0 )
    return "Invalid time set.";
  result = 0;
  schedstart.enable = 1;
  return result;
}

//----- (0001E910) --------------------------------------------------------
void __fastcall get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv)
{
  __suseconds_t tv_usec; // r4
  struct tm *v6; // r0
  time_t tv_sec; // [sp+1Ch] [bp-1Ch] BYREF

  tv_usec = tv->tv_usec;
  tv_sec = tv->tv_sec;
  v6 = localtime(&tv_sec);
  snprintf(
    (char *)f,
    fsiz,
    "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
    v6->tm_year + 1900,
    v6->tm_mon + 1,
    v6->tm_mday,
    v6->tm_hour,
    v6->tm_min,
    v6->tm_sec,
    tv_usec / 1000);
}

//----- (0001E970) --------------------------------------------------------
void adjust_quota_gcd()
{
  int v0; // r7
  unsigned int v1; // r4
  pool **v2; // r6
  pool **v3; // r3
  pool **v4; // r8
  int v5; // t1
  unsigned int v6; // r2
  int v7; // t1
  unsigned int v8; // r5
  pool **v9; // r8
  int v10; // r6
  unsigned int v11; // r9
  pool *v12; // t1
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-820h] BYREF

  v0 = total_pools;
  if ( total_pools <= 0 )
  {
    v1 = 1;
  }
  else
  {
    v1 = -1;
    v2 = pools;
    v3 = pools;
    v4 = &pools[total_pools];
    do
    {
      v5 = (int)*v3++;
      v6 = *(_DWORD *)(v5 + 56);
      if ( v6 && v1 >= v6 )
        v1 = v6;
    }
    while ( v3 != v4 );
    if ( v1 == -1 )
    {
      v1 = 1;
    }
    else
    {
      do
      {
        while ( 1 )
        {
          v7 = (int)*v2++;
          v8 = *(_DWORD *)(v7 + 56);
          if ( v8 )
            break;
          if ( v2 == v4 )
            goto LABEL_13;
        }
        while ( v8 % v1 )
          --v1;
      }
      while ( v2 != v4 );
    }
LABEL_13:
    v9 = pools - 1;
    v10 = 0;
    v11 = global_quota_gcd;
    do
    {
      v12 = v9[1];
      ++v9;
      ++v10;
      v12->quota_used = v12->quota_used * v11 / v1;
      v12->quota_gcd = v12->quota / v1;
    }
    while ( v10 < v0 );
  }
  global_quota_gcd = v1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Global quota greatest common denominator set to %lu", v1);
    applog(7, tmp42, 0);
  }
}

//----- (0001EA68) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_range(const unsigned __int8 *arg, int *i, int min, int max)
{
  unsigned __int8 *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (*i < min || *i > max) )
    return "Value out of range";
  return result;
}

//----- (0001EA8C) --------------------------------------------------------
unsigned __int8 *__fastcall set_rotate(const unsigned __int8 *arg, unsigned __int8 *i)
{
  pool_strategy_0 = POOL_ROTATE;
  return set_int_range(arg, &opt_rotate_period, 0, 9999);
}

//----- (0001EAB0) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_0_to_9999(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 9999);
}

//----- (0001EABC) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_0_to_100(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 100);
}

//----- (0001EAC4) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_1_to_65535(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 0xFFFF);
}

//----- (0001EAD0) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_42_to_65(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 62);
}

//----- (0001EAD8) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_22_to_55(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 55);
}

//----- (0001EAE0) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_42_to_85(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 85);
}

//----- (0001EAE8) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_22_to_75(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 75);
}

//----- (0001EAF0) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_32_to_63(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 32, 63);
}

//----- (0001EAF8) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_0_to_4(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 4);
}

//----- (0001EB00) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_0_to_200(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 200);
}

//----- (0001EB08) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_0_to_7680(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 7680);
}

//----- (0001EB14) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_1_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 255);
}

//----- (0001EB1C) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_0_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 255);
}

//----- (0001EB24) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_1_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 10);
}

//----- (0001EB2C) --------------------------------------------------------
unsigned __int8 *__fastcall set_int_0_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 10);
}

//----- (0001EB34) --------------------------------------------------------
void __fastcall get_intrange(unsigned __int8 *arg, int *val1, int *val2)
{
  if ( sscanf((const char *)arg, "%d-%d", val1, val2) == 1 )
    *val2 = *val1;
}

//----- (0001EB54) --------------------------------------------------------
bool __fastcall detect_stratum(pool *pool, unsigned __int8 *url)
{
  char *sockaddr; // r0
  unsigned __int8 *sockaddr_url; // r2

  sockaddr = (char *)extract_sockaddr(url, &pool->sockaddr_url, &pool->stratum_port);
  if ( sockaddr )
  {
    if ( !strncasecmp((const char *)url, "stratum+tcp://", 0xEu) )
    {
      sockaddr = _strdup((const char *)url);
      sockaddr_url = pool->sockaddr_url;
      pool->rpc_url = (unsigned __int8 *)sockaddr;
      LOBYTE(sockaddr) = 1;
      pool->has_stratum = 1;
      pool->stratum_url = sockaddr_url;
    }
    else
    {
      LOBYTE(sockaddr) = 0;
    }
  }
  return (char)sockaddr;
}

//----- (0001EB9C) --------------------------------------------------------
unsigned __int8 *__fastcall setup_url(pool *pool, unsigned __int8 *arg)
{
  unsigned __int8 *proxy; // r5
  char *v5; // r6

  proxy = get_proxy(arg, pool);
  if ( !detect_stratum(pool, proxy) )
  {
    opt_set_charp(proxy, &pool->rpc_url);
    if ( strncmp((const char *)proxy, "http://", 7u) )
    {
      if ( strncmp((const char *)proxy, "https://", 8u) )
      {
        v5 = (char *)cgmalloc(0x100u, "cgminer.c", _func___12629, 1007);
        strcpy(v5, "stratum+tcp://");
        strncat(v5, (const char *)proxy, 0xF2u);
        detect_stratum(pool, (unsigned __int8 *)v5);
      }
    }
  }
  return pool->rpc_url;
}

//----- (0001EC2C) --------------------------------------------------------
unsigned __int8 *__fastcall set_temp_cutoff(unsigned __int8 *arg)
{
  unsigned __int8 *result; // r0

  if ( !arg || !*arg )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol((const char *)arg, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  result = 0;
  temp_cutoff_str = arg;
  return result;
}

//----- (0001EC60) --------------------------------------------------------
void __fastcall clean_work(work *work)
{
  free(work->job_id);
  free(work->ntime);
  free(work->coinbase);
  free(work->nonce1);
  sub_A1BC(work, 0, 0x1C0u);
}

//----- (0001EC94) --------------------------------------------------------
void __fastcall copy_work(work *work, const work *base_work, int noffset)
{
  unsigned int id; // r7
  unsigned __int8 *job_id; // r0
  unsigned __int8 *nonce1; // r0
  unsigned __int8 *ntime; // r1
  unsigned __int8 *coinbase; // r0
  unsigned __int8 p[4]; // [sp+Ch] [bp-1Ch] BYREF

  id = work->id;
  clean_work(work);
  cg_memcpy(work, base_work, 0x1C0u, "cgminer.c", _func___13623, 4851);
  job_id = base_work->job_id;
  work->id = id;
  if ( job_id )
    work->job_id = (unsigned __int8 *)_strdup((const char *)job_id);
  nonce1 = base_work->nonce1;
  if ( nonce1 )
    work->nonce1 = (unsigned __int8 *)_strdup((const char *)nonce1);
  ntime = base_work->ntime;
  if ( ntime )
  {
    if ( noffset )
    {
      *(_DWORD *)&work->data[68] = bswap32(bswap32(*(_DWORD *)&work->data[68]) + noffset);
      hex2bin(p, ntime, 4u);
      *(_DWORD *)p = bswap32(bswap32(*(unsigned int *)p) + noffset);
      work->ntime = bin2hex(p, 4u);
    }
    else
    {
      work->ntime = (unsigned __int8 *)_strdup((const char *)base_work->ntime);
    }
  }
  else if ( noffset )
  {
    *(_DWORD *)&work->data[68] = bswap32(bswap32(*(_DWORD *)&work->data[68]) + noffset);
  }
  coinbase = base_work->coinbase;
  if ( coinbase )
    work->coinbase = (unsigned __int8 *)_strdup((const char *)coinbase);
  work->version = base_work->version;
}

//----- (0001ED50) --------------------------------------------------------
void __fastcall free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  work *v5; // r4

  v5 = *workptr;
  if ( *workptr )
  {
    clean_work(*workptr);
    free(v5);
    *workptr = 0;
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    free_work_0((work **)file, func, (const unsigned __int8 *)line, line);
  }
}

//----- (0001ED98) --------------------------------------------------------
void __fastcall decay_time(double f, double fadd, double fsecs, double interval)
{
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double *v7; // r4

  v7 = (double *)LODWORD(f);
  if ( v5 > 0.0 )
  {
    exp(f);
    *v7 = (*v7 + (1.0 - 1.0 / (v5 / v6)) * (v4 / v5)) / (1.0 - 1.0 / (v5 / v6) + 1.0);
  }
}
// 1EDB0: variable 'v5' is possibly undefined
// 1EDB2: variable 'v6' is possibly undefined
// 1EDBE: variable 'v4' is possibly undefined

//----- (0001EDE4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall cgpu_runtime(cgpu_info *cgpu)
{
  cgpu_info *v1; // r4
  double result; // r0
  timeval now; // [sp+0h] [bp-10h] BYREF

  v1 = cgpu;
  if ( cgpu->dev_start_tv.tv_sec )
  {
    cgtime(&now);
    *(double *)&cgpu = tdiff(&now, &v1->dev_start_tv);
  }
  LODWORD(result) = cgpu;
  return result;
}
// 1EDE4: variables would overlap: r0.4 and r0.8
// 1EDE4: bad return variable

//----- (0001EE24) --------------------------------------------------------
double tsince_restart()
{
  timeval now; // [sp+0h] [bp-10h] BYREF

  cgtime(&now);
  return tdiff(&now, &restart_tv_start);
}

//----- (0001EE40) --------------------------------------------------------
double tsince_update()
{
  timeval now; // [sp+0h] [bp-10h] BYREF

  cgtime(&now);
  return tdiff(&now, &update_tv_start);
}

//----- (0001EE5C) --------------------------------------------------------
void __fastcall set_work_ntime(work *work, int ntime)
{
  unsigned __int8 *v3; // r0

  v3 = work->ntime;
  *(_DWORD *)&work->data[68] = bswap32(ntime);
  if ( v3 )
  {
    free(v3);
    work->ntime = bin2hex(&work->data[68], 4u);
  }
}

//----- (0001EE80) --------------------------------------------------------
uint64_t __fastcall share_ndiff(const work *work)
{
  double v1; // d8

  if ( !work )
    return 0LL;
  v1 = (double)*(unsigned __int64 *)&work->hash[24] * 6.27710174e57
     + (double)*(unsigned __int64 *)&work->hash[16] * 3.40282367e38
     + (double)*(unsigned __int64 *)&work->hash[8] * 1.84467441e19
     + (double)*(unsigned __int64 *)work->hash;
  if ( v1 == 0.0 )
    return 0LL;
  else
    return (unsigned __int64)(2.69595353e67 / v1);
}

//----- (0001EF28) --------------------------------------------------------
void __fastcall discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  work *v5; // r1
  pool *pool; // r3
  int works; // r2
  int v11; // r1
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-820h] BYREF

  v5 = *workptr;
  if ( *workptr )
  {
    if ( v5->clone || v5->rolls || v5->mined )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Discarded cloned or rolled work");
        applog(7, tmp42, 0);
      }
    }
    else
    {
      pool = v5->pool;
      if ( pool )
      {
        works = pool->works;
        v11 = pool->quota_used - 1;
        ++pool->discarded_work;
        pool->quota_used = v11;
        pool->works = works - 1;
      }
      ++total_discarded;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Discarded work");
        applog(7, tmp42, 0);
      }
    }
    free_work(workptr, file, func, line);
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Discard work called with NULL work from %s %s:%d",
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (0001F05C) --------------------------------------------------------
void __fastcall remove_pool(pool *pool)
{
  int v1; // r6
  int v2; // r7
  pool **v3; // r3
  pool **v4; // r5
  int v5; // r1
  int v6; // t1
  int v7; // r2
  bool v8; // cc
  int v9; // r2
  pool **v10; // r2
  pool *v11; // r1

  v1 = total_pools;
  v2 = total_pools - 1;
  if ( total_pools > 0 )
  {
    v3 = pools;
    v4 = &pools[total_pools];
    do
    {
      v6 = (int)*v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= pool->prio;
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != v4 );
  }
  if ( v2 > pool->pool_no )
  {
    v10 = pools;
    v11 = pools[v2];
    v11->pool_no = pool->pool_no;
    v10[pool->pool_no] = v11;
  }
  pool->pool_no = v1;
  pool->removed = 1;
  total_pools = v2;
}

//----- (0001F0BC) --------------------------------------------------------
void __fastcall write_config(FILE *fcfg)
{
  int v2; // r5
  unsigned __int8 *v3; // r0
  unsigned __int8 *v4; // r0
  pool *v5; // r0
  int quota; // r7
  pool *v7; // r4
  const char *v8; // r9
  unsigned __int8 *v9; // r0
  const char *v10; // r10
  unsigned __int8 *v11; // r0
  const char *v12; // r11
  unsigned __int8 *v13; // r0
  const char *v14; // r7
  unsigned __int8 *v15; // r0
  const char *v16; // r10
  unsigned __int8 *rpc_proxy; // r0
  const char *v18; // r9
  const char *v19; // r11
  unsigned __int8 *v20; // r0
  opt_table *v21; // r5
  char *v22; // r8
  char *v23; // r4
  opt_type type; // r2
  unsigned __int8 *(__fastcall *cb)(bool *); // r3
  unsigned __int8 *(__fastcall *cb_arg)(const unsigned __int8 *, float *); // r3
  unsigned __int8 **carg; // r3
  unsigned __int8 *v28; // r0
  pool_strategy v29; // r1
  JE *v30; // r4
  JE *next; // r5
  JE *v32; // r0
  const char *v33; // [sp+14h] [bp-2Ch]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, fcfg);
  if ( total_pools > 0 )
  {
    v2 = 0;
    while ( 1 )
    {
      v5 = priority_pool(v2);
      quota = v5->quota;
      v7 = v5;
      if ( quota == 1 )
      {
        v14 = ",";
        if ( !v2 )
          v14 = "";
        if ( v5->rpc_proxy )
        {
          v15 = (unsigned __int8 *)proxytype(v5->rpc_proxytype);
          v16 = (const char *)json_escape(v15);
          rpc_proxy = v7->rpc_proxy;
          if ( rpc_proxy )
          {
            v18 = (const char *)json_escape(rpc_proxy);
            v19 = "|";
            if ( v7->rpc_proxy )
            {
LABEL_21:
              v20 = json_escape(v7->rpc_url);
              fprintf(fcfg, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v14, v16, v18, v19, (const char *)v20);
              goto LABEL_14;
            }
LABEL_74:
            v19 = "";
            goto LABEL_21;
          }
        }
        else
        {
          v16 = "";
        }
        v18 = "";
        goto LABEL_74;
      }
      v8 = v2 ? "," : "";
      if ( !v5->rpc_proxy )
        break;
      v9 = (unsigned __int8 *)proxytype(v5->rpc_proxytype);
      v10 = (const char *)json_escape(v9);
      v11 = v7->rpc_proxy;
      if ( !v11 )
      {
        quota = v7->quota;
        goto LABEL_23;
      }
      v12 = (const char *)json_escape(v11);
      quota = v7->quota;
      if ( !v7->rpc_proxy )
        goto LABEL_24;
      v33 = "|";
LABEL_13:
      v13 = json_escape(v7->rpc_url);
      fprintf(fcfg, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v8, v10, v12, v33, quota, (const char *)v13);
LABEL_14:
      if ( v7->extranonce_subscribe )
        fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 0x21u, fcfg);
      ++v2;
      v3 = json_escape(v7->rpc_user);
      fprintf(fcfg, "\n\t\t\"user\" : \"%s\",", (const char *)v3);
      v4 = json_escape(v7->rpc_pass);
      fprintf(fcfg, "\n\t\t\"pass\" : \"%s\"\n\t}", (const char *)v4);
      if ( total_pools <= v2 )
        goto LABEL_25;
    }
    v10 = "";
LABEL_23:
    v12 = "";
LABEL_24:
    v33 = "";
    goto LABEL_13;
  }
LABEL_25:
  fwrite("\n]\n", 1u, 3u, fcfg);
  if ( opt_config_table[0].type != OPT_END )
  {
    v21 = &opt_config_table[1];
    while ( 1 )
    {
      v22 = _strdup((const char *)v21[-1].names);
      v23 = strtok(v22, "|");
      if ( v23 )
        break;
LABEL_59:
      ++v21;
      free(v22);
      if ( v21[-1].type == OPT_END )
        goto LABEL_60;
    }
    while ( 1 )
    {
      if ( v23[1] == 45 && v21[-1].desc != opt_hidden )
      {
        type = v21[-1].type;
        if ( (type & 1) != 0
          && ((cb = (unsigned __int8 *(__fastcall *)(bool *))v21[-1].cb, cb == opt_set_bool) || cb == opt_set_invbool)
          && *(_BYTE *)v21[-1].u.carg == (cb == opt_set_bool) )
        {
          fprintf(fcfg, ",\n\"%s\" : true", v23 + 2);
        }
        else
        {
          if ( (type & 2) == 0 )
            goto LABEL_54;
          cb_arg = (unsigned __int8 *(__fastcall *)(const unsigned __int8 *, float *))v21[-1].cb_arg;
          if ( (char *)cb_arg == (char *)opt_set_intval
            || (char *)cb_arg == (char *)set_int_0_to_9999
            || (char *)cb_arg == (char *)set_int_1_to_65535
            || (char *)cb_arg == (char *)set_int_0_to_10
            || (char *)cb_arg == (char *)set_int_1_to_10
            || (char *)cb_arg == (char *)set_int_0_to_100
            || (char *)cb_arg == (char *)set_int_0_to_255
            || (char *)cb_arg == (char *)set_int_1_to_255
            || (char *)cb_arg == (char *)set_int_0_to_7680
            || (char *)cb_arg == (char *)set_int_0_to_200
            || (char *)cb_arg == (char *)set_int_0_to_4
            || (char *)cb_arg == (char *)set_int_32_to_63
            || (char *)cb_arg == (char *)set_int_22_to_75
            || (char *)cb_arg == (char *)set_int_42_to_85
            || (char *)cb_arg == (char *)set_int_22_to_55
            || (char *)cb_arg == (char *)set_int_42_to_65 )
          {
            fprintf(fcfg, ",\n\"%s\" : \"%d\"", v23 + 2, *(_DWORD *)v21[-1].u.carg);
          }
          else
          {
            if ( cb_arg != set_float_125_to_500 && cb_arg != set_float_100_to_250 )
            {
LABEL_54:
              if ( (type & 6) != 0 )
              {
                carg = (unsigned __int8 **)v21[-1].u.carg;
                if ( carg != &opt_set_null )
                {
                  if ( *carg )
                  {
                    v28 = json_escape(*carg);
                    fprintf(fcfg, ",\n\"%s\" : \"%s\"", v23 + 2, (const char *)v28);
                  }
                }
              }
              goto LABEL_29;
            }
            fprintf(fcfg, ",\n\"%s\" : \"%.1f\"", v23 + 2, *(float *)v21[-1].u.carg);
          }
        }
      }
LABEL_29:
      v23 = strtok(0, "|");
      if ( !v23 )
        goto LABEL_59;
    }
  }
LABEL_60:
  v29 = pool_strategy_0;
  if ( pool_strategy_0 == POOL_BALANCE )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, fcfg);
    v29 = pool_strategy_0;
    if ( pool_strategy_0 != POOL_LOADBALANCE )
      goto LABEL_62;
  }
  else if ( pool_strategy_0 != POOL_LOADBALANCE )
  {
    goto LABEL_62;
  }
  fwrite(",\n\"load-balance\" : true", 1u, 0x17u, fcfg);
  v29 = pool_strategy_0;
LABEL_62:
  if ( v29 == POOL_ROUNDROBIN )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, fcfg);
    v29 = pool_strategy_0;
  }
  if ( v29 == POOL_ROTATE )
    fprintf(fcfg, ",\n\"rotate\" : \"%d\"", opt_rotate_period);
  fwrite("\n}\n", 1u, 3u, fcfg);
  v30 = jedata;
  jedata = 0;
  if ( v30 )
  {
    do
    {
      next = v30->next;
      free(v30->buf);
      v32 = v30;
      v30 = next;
      free(v32);
    }
    while ( next );
  }
}

//----- (0001F4C8) --------------------------------------------------------
void zero_bestshare()
{
  pool **v0; // r3
  pool **v1; // r1
  int v2; // t1

  *(_DWORD *)best_share = 0;
  *(_DWORD *)&best_share[4] = 0;
  best_diff = 0LL;
  suffix_string(0LL, best_share, 8u, 0);
  if ( total_pools > 0 )
  {
    v0 = pools;
    v1 = &pools[total_pools];
    do
    {
      v2 = (int)*v0++;
      *(_DWORD *)(v2 + 368) = 0;
      *(_DWORD *)(v2 + 372) = 0;
    }
    while ( v0 != v1 );
  }
}

//----- (0001F530) --------------------------------------------------------
void __fastcall default_save_file(unsigned __int8 *filename)
{
  char *v2; // r0

  if ( default_config && *default_config )
  {
    j_strcpy((char *)filename, (const char *)default_config);
  }
  else
  {
    if ( getenv("HOME") && *getenv("HOME") )
    {
      v2 = getenv("HOME");
      strcpy((char *)stpcpy(filename, v2), "/");
    }
    else
    {
      *filename = 0;
    }
    strcat((char *)filename, ".bmminer/");
    mkdir((const char *)filename, 0x1FFu);
    strcat((char *)filename, "bmminer.conf");
  }
}
// A1A4: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);

//----- (0001F5C4) --------------------------------------------------------
void __fastcall set_target(unsigned __int8 *dest_target, double diff)
{
  double v3; // d0
  double v5; // d8
  double v6; // d8
  unsigned __int8 *v7; // r6
  unsigned __int8 target[32]; // [sp+8h] [bp-838h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+28h] [bp-818h] BYREF

  if ( v3 == 0.0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "Diff zero passed to set_target");
      applog(3, tmp42, 0);
      v3 = 1.0;
    }
    else
    {
      v3 = 1.0;
    }
  }
  *(_QWORD *)&target[24] = (unsigned __int64)(2.69595353e67 / v3 * 1.59309191e-58);
  v5 = 2.69595353e67 / v3 - (double)*(unsigned __int64 *)&target[24] * 6.27710174e57;
  *(_QWORD *)&target[16] = (unsigned __int64)(v5 * 2.93873588e-39);
  v6 = v5 - (double)*(unsigned __int64 *)&target[16] * 3.40282367e38;
  *(_QWORD *)&target[8] = (unsigned __int64)(v6 * 5.42101086e-20);
  *(_QWORD *)target = (unsigned __int64)(v6 - (double)*(unsigned __int64 *)&target[8] * 1.84467441e19);
  if ( opt_debug )
  {
    v7 = bin2hex(target, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated target %s", (const char *)v7);
      applog(7, tmp42, 0);
    }
    free(v7);
  }
  cg_memcpy(dest_target, target, 0x20u, "cgminer.c", _func___14498, 8190);
}
// 1F5D8: variable 'v3' is possibly undefined

//----- (0001F760) --------------------------------------------------------
int __fastcall share_work_tdiff(cgpu_info *cgpu)
{
  return last_getwork - cgpu->last_device_valid_work;
}

//----- (0001F774) --------------------------------------------------------
bool __fastcall test_nonce(work *work, unsigned int nonce)
{
  *(_DWORD *)&work->data[76] = nonce;
  regen_hash(work);
  return *(_DWORD *)&work->hash[28] == 0;
}

//----- (0001F78C) --------------------------------------------------------
bool __fastcall test_nonce_diff(work *work, unsigned int nonce, double diff)
{
  double v3; // d0

  *(_DWORD *)&work->data[76] = nonce;
  regen_hash(work);
  return (unsigned __int64)(4294901760.0 / v3) >= *(_QWORD *)&work->hash[24];
}
// 1F7A6: variable 'v3' is possibly undefined

//----- (0001F7D0) --------------------------------------------------------
void __fastcall cg_savelogwork(work *work, unsigned __int8 *nonce_bin)
{
  int v4; // t1
  int v5; // r1
  int v6; // r7
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  size_t v12; // r4
  int v13; // r1
  int v14; // r2
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r2
  int v19; // r3
  int v20; // r1
  unsigned __int8 *v21; // r10
  unsigned __int8 *v22; // r9
  unsigned __int8 *v23; // r8
  unsigned __int8 *v24; // r11
  int v25; // r3
  unsigned int v26; // r1
  unsigned int v27; // r2
  char v28; // r0
  unsigned int v29; // r3
  bool v30; // nf
  char v31; // r3
  size_t v32; // r0
  unsigned __int8 *szworkdata; // [sp+8h] [bp-4A0h]
  unsigned __int8 *sznonce5; // [sp+Ch] [bp-49Ch]
  char v35[4]; // [sp+10h] [bp-498h]
  char v36[12]; // [sp+14h] [bp-494h] BYREF
  unsigned __int8 midstate_tmp[32]; // [sp+20h] [bp-488h] BYREF
  unsigned __int8 data_tmp[32]; // [sp+40h] [bp-468h] BYREF
  unsigned __int8 hash_tmp[32]; // [sp+60h] [bp-448h] BYREF
  unsigned __int8 szmsg[1024]; // [sp+80h] [bp-428h] BYREF

  if ( !fd_log )
    fd_log = fopen("/etc/config/worklog.txt", "wb");
  memset(szmsg, 0, sizeof(szmsg));
  v4 = *(_DWORD *)work->midstate;
  v5 = *(_DWORD *)&work->midstate[4];
  v6 = 0;
  v7 = *(_DWORD *)&work->midstate[8];
  v8 = *(_DWORD *)&work->midstate[12];
  memset(&data_tmp[12], 0, 20);
  *(_DWORD *)midstate_tmp = v4;
  *(_DWORD *)&midstate_tmp[4] = v5;
  *(_DWORD *)&midstate_tmp[8] = v7;
  *(_DWORD *)&midstate_tmp[12] = v8;
  v9 = *(_DWORD *)&work->midstate[20];
  v10 = *(_DWORD *)&work->midstate[24];
  v11 = *(_DWORD *)&work->midstate[28];
  v12 = 0;
  *(_DWORD *)&midstate_tmp[16] = *(_DWORD *)&work->midstate[16];
  *(_DWORD *)&midstate_tmp[20] = v9;
  *(_DWORD *)&midstate_tmp[24] = v10;
  *(_DWORD *)&midstate_tmp[28] = v11;
  v13 = *(_DWORD *)&work->data[68];
  v14 = *(_DWORD *)&work->data[72];
  *(_DWORD *)data_tmp = *(_DWORD *)&work->data[64];
  *(_DWORD *)&data_tmp[4] = v13;
  *(_DWORD *)&data_tmp[8] = v14;
  v15 = *(_DWORD *)&work->hash[4];
  v16 = *(_DWORD *)&work->hash[8];
  v17 = *(_DWORD *)&work->hash[12];
  *(_DWORD *)hash_tmp = *(_DWORD *)work->hash;
  *(_DWORD *)&hash_tmp[4] = v15;
  *(_DWORD *)&hash_tmp[8] = v16;
  *(_DWORD *)&hash_tmp[12] = v17;
  v18 = *(_DWORD *)&work->hash[24];
  v19 = *(_DWORD *)&work->hash[28];
  v20 = *(_DWORD *)&work->hash[20];
  *(_DWORD *)&hash_tmp[16] = *(_DWORD *)&work->hash[16];
  *(_DWORD *)&hash_tmp[20] = v20;
  *(_DWORD *)&hash_tmp[24] = v18;
  *(_DWORD *)&hash_tmp[28] = v19;
  rev(midstate_tmp, 0x20u);
  rev(data_tmp, 0xCu);
  rev(hash_tmp, 0x20u);
  szworkdata = bin2hex(work->data, 0x80u);
  v21 = bin2hex(midstate_tmp, 0x20u);
  v22 = bin2hex(data_tmp, 0xCu);
  v23 = bin2hex(nonce_bin, 4u);
  sznonce5 = bin2hex(nonce_bin, 5u);
  v24 = bin2hex(hash_tmp, 0x20u);
  while ( v12 < strlen(v36) )
  {
    v25 = (unsigned __int8)v36[v12];
    v26 = v25 - 97;
    v27 = (unsigned __int8)(v25 - 48);
    if ( v27 > 9 )
    {
      v28 = v25 - 87;
      LOBYTE(v27) = v25 - 55;
      v29 = v25 - 65;
      if ( v26 > 5 )
      {
        if ( v29 > 5 )
          break;
      }
      else
      {
        LOBYTE(v27) = v28;
      }
    }
    v30 = (v12 & 1) != 0;
    v31 = 16 * v27;
    if ( (v12 & 1) != 0 )
      v31 = v35[v6];
    ++v12;
    if ( v30 )
      v35[v6++] = v27 + v31;
    else
      v35[v6] = v31;
  }
  sprintf((char *)szmsg, "midstate %s data %s nonce %s \r\n", (const char *)v21, (const char *)v22, (const char *)v23);
  v32 = strlen((const char *)szmsg);
  fwrite(szmsg, v32, 1u, fd_log);
  fflush(fd_log);
  if ( szworkdata )
    free(szworkdata);
  if ( v21 )
    free(v21);
  if ( v22 )
    free(v22);
  if ( v23 )
    free(v23);
  if ( sznonce5 )
    free(sznonce5);
  if ( v24 )
    free(v24);
}
// 1F7D0: using guessed type char var_494[12];
// 1F7D0: using guessed type char var_498[4];

//----- (0001F9B4) --------------------------------------------------------
void __fastcall cg_savelogwork_uint32(work *work, unsigned int nonce)
{
  unsigned __int8 nonce_bin[5]; // [sp+0h] [bp-10h] BYREF

  *(_DWORD *)nonce_bin = nonce;
  nonce_bin[4] = 0;
  cg_savelogwork(work, nonce_bin);
}

//----- (0001F9D0) --------------------------------------------------------
bool __fastcall savelog_nonce(work *work, unsigned int nonce)
{
  bool result; // r0

  *(_DWORD *)&work->data[76] = nonce;
  regen_hash(work);
  if ( !*(_DWORD *)&work->hash[28] )
    cg_savelogwork_uint32(work, nonce);
  return result;
}

//----- (0001F9EC) --------------------------------------------------------
void __fastcall _add_queued(cgpu_info *cgpu, work *work)
{
  int v3; // r1
  work *queued_work; // r7
  int v5; // r0
  unsigned int v6; // r3
  unsigned int v7; // r2
  unsigned int v8; // r5
  int v9; // r4
  unsigned int v10; // r2
  unsigned int v11; // r3
  int v12; // r1
  unsigned int v13; // r5
  UT_hash_table *tbl; // r3
  UT_hash_handle_0 *p_hh; // r4
  UT_hash_table *v16; // r2
  UT_hash_handle *tail; // r1
  UT_hash_table *v18; // r3
  ptrdiff_t hho; // r0
  UT_hash_bucket_0 *buckets; // r2
  int v21; // r5
  int v22; // r3
  UT_hash_handle *hh_head; // r0
  unsigned int v24; // r5
  int v25; // r1
  UT_hash_table *v26; // r3
  size_t v27; // r4
  UT_hash_bucket_0 *v28; // r0
  UT_hash_bucket_0 *v29; // r7
  UT_hash_table *v30; // r11
  unsigned int num_buckets; // r3
  unsigned int num_items; // r0
  unsigned int log2_num_buckets; // r4
  unsigned int v34; // r4
  int v35; // r10
  unsigned int v36; // r9
  UT_hash_handle *v37; // r4
  UT_hash_handle *hh_next; // r8
  int v39; // r5
  UT_hash_bucket_0 *v40; // r6
  unsigned int v41; // r0
  UT_hash_handle *v42; // r3
  UT_hash_table *v43; // r3
  unsigned int nonideal_items; // r2
  unsigned int v45; // r1
  unsigned int v46; // r4
  unsigned int v47; // r0
  bool v48; // cc
  int v49; // r4
  unsigned int v50; // r0
  unsigned int v51; // r2
  UT_hash_table *v52; // r0
  work *v53; // r2
  UT_hash_table *v54; // r4
  UT_hash_bucket_0 *v55; // r0
  unsigned int v57; // [sp+Ch] [bp-34h]
  UT_hash_bucket_0 *ptr; // [sp+10h] [bp-30h]
  int v59; // [sp+14h] [bp-2Ch]

  ++cgpu->queued_count;
  v3 = BYTE1(work->id);
  queued_work = cgpu->queued_work;
  v5 = LOBYTE(work->id) + 17973517 + (HIBYTE(work->id) << 24) + (BYTE2(work->id) << 16);
  work->hh.key = &work->id;
  work->hh.keylen = 4;
  v6 = ((unsigned int)&::cgpu.results[5][4186] + 1) ^ (v5 + (v3 << 8));
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  v8 = (-17973517 - v6 - v7) ^ (v7 >> 13);
  v9 = (v6 - v7 - v8) ^ (v8 >> 12);
  v10 = (v7 - v8 - v9) ^ (v9 << 16);
  v11 = (v8 - v9 - v10) ^ (v10 >> 5);
  v12 = (v9 - v10 - v11) ^ (v11 >> 3);
  v13 = (v11 - v12 - ((v10 - v11 - v12) ^ (v12 << 10))) ^ (((v10 - v11 - v12) ^ (v12 << 10)) >> 15);
  work->hh.hashv = v13;
  if ( queued_work )
  {
    tbl = queued_work->hh.tbl;
    work->hh.next = 0;
    p_hh = &work->hh;
    work->hh.tbl = tbl;
    v16 = queued_work->hh.tbl;
    tail = v16->tail;
    v18 = v16;
    hho = v16->hho;
    tail->next = work;
    work->hh.prev = (char *)tail - hho;
    v16->tail = &work->hh;
  }
  else
  {
    work->hh.next = 0;
    work->hh.prev = 0;
    cgpu->queued_work = work;
    v52 = (UT_hash_table *)malloc(0x2Cu);
    work->hh.tbl = v52;
    if ( !v52 )
      goto LABEL_32;
    v53 = cgpu->queued_work;
    v52->buckets = 0;
    v52->num_buckets = 0;
    v52->log2_num_buckets = 0;
    v52->num_items = 0;
    v52->tail = 0;
    v52->hho = 0;
    v52->ideal_chain_maxlen = 0;
    v52->nonideal_items = 0;
    v52->ineff_expands = 0;
    v52->noexpand = 0;
    v52->signature = 0;
    v54 = v53->hh.tbl;
    v54->tail = &v53->hh;
    v54->num_buckets = 32;
    v54->log2_num_buckets = 5;
    v54->hho = 344;
    v55 = (UT_hash_bucket_0 *)malloc(0x180u);
    v54->buckets = v55;
    if ( !v55 )
      goto LABEL_32;
    memset(v55, 0, 0x180u);
    v18 = cgpu->queued_work->hh.tbl;
    p_hh = &work->hh;
    v18->signature = -1609490463;
  }
  buckets = v18->buckets;
  v21 = 3 * (v13 & (v18->num_buckets - 1));
  ++v18->num_items;
  v22 = 4 * v21;
  hh_head = buckets[v21 / 3u].hh_head;
  v24 = buckets[v21 / 3u].count + 1;
  *(unsigned int *)((char *)&buckets->count + v22) = v24;
  work->hh.hh_next = hh_head;
  work->hh.hh_prev = 0;
  if ( hh_head )
    hh_head->hh_prev = p_hh;
  v25 = *(unsigned int *)((char *)&buckets->expand_mult + v22);
  *(UT_hash_handle **)((char *)&buckets->hh_head + v22) = p_hh;
  if ( v24 >= 10 * (v25 + 1) )
  {
    v26 = work->hh.tbl;
    if ( v26->noexpand != 1 )
    {
      v27 = 24 * v26->num_buckets;
      v28 = (UT_hash_bucket_0 *)malloc(v27);
      v29 = v28;
      if ( v28 )
      {
        memset(v28, 0, v27);
        v30 = work->hh.tbl;
        num_buckets = v30->num_buckets;
        num_items = v30->num_items;
        log2_num_buckets = v30->log2_num_buckets;
        v30->nonideal_items = 0;
        v34 = num_items >> (log2_num_buckets + 1);
        v35 = 2 * num_buckets - 1;
        if ( (v35 & num_items) != 0 )
          v36 = v34 + 1;
        else
          v36 = v34;
        v30->ideal_chain_maxlen = v36;
        if ( num_buckets )
        {
          v57 = 0;
          ptr = v30->buckets;
          v59 = 12 * num_buckets;
          do
          {
            v37 = ptr[v57 / 0xC].hh_head;
            if ( v37 )
            {
              do
              {
                hh_next = v37->hh_next;
                v39 = v35 & v37->hashv;
                v40 = &v29[v35 & v37->hashv];
                v41 = v40->count + 1;
                v40->count = v41;
                if ( v36 < v41 )
                {
                  ++v30->nonideal_items;
                  v40->expand_mult = v41 / v36;
                }
                v42 = v29[v39].hh_head;
                v37->hh_prev = 0;
                v37->hh_next = v42;
                if ( v42 )
                  v42->hh_prev = v37;
                v29[v39].hh_head = v37;
                v37 = hh_next;
              }
              while ( hh_next );
            }
            v57 += 12;
          }
          while ( v57 != v59 );
          free(ptr);
        }
        else
        {
          free(v30->buckets);
        }
        v43 = work->hh.tbl;
        nonideal_items = v43->nonideal_items;
        v45 = v43->num_items;
        v46 = v43->num_buckets;
        v47 = v43->log2_num_buckets;
        v43->buckets = v29;
        v48 = nonideal_items > v45 >> 1;
        v49 = 2 * v46;
        v50 = v47 + 1;
        if ( nonideal_items <= v45 >> 1 )
          nonideal_items = 0;
        v43->log2_num_buckets = v50;
        v43->num_buckets = v49;
        if ( v48 )
        {
          v51 = v43->ineff_expands + 1;
          v43->ineff_expands = v51;
          if ( v51 > 1 )
            v43->noexpand = 1;
        }
        else
        {
          v43->ineff_expands = nonideal_items;
        }
        return;
      }
LABEL_32:
      exit(-1);
    }
  }
}

//----- (0001FCD4) --------------------------------------------------------
work *__fastcall _find_work_bymidstate(
        work *que,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  work *next; // r4
  work *v10; // r5

  if ( que )
  {
    next = (work *)que->hh.next;
    v10 = que;
    while ( memcmp(v10->midstate, midstate, midstatelen) || memcmp(&v10->data[offset], data, datalen) )
    {
      if ( !next )
        return 0;
      v10 = next;
      next = (work *)next->hh.next;
    }
    return v10;
  }
  return que;
}

//----- (0001FD20) --------------------------------------------------------
work *__fastcall _find_work_byid(work *que, unsigned int id)
{
  work *next; // r3
  void *v3; // r0

  if ( que )
  {
    next = (work *)que->hh.next;
    if ( que->id != id )
    {
      if ( next )
      {
        do
        {
          v3 = next->hh.next;
          if ( next->id == id )
            break;
          next = (work *)next->hh.next;
        }
        while ( v3 );
      }
      return next;
    }
  }
  return que;
}

//----- (0001FD48) --------------------------------------------------------
void __fastcall _work_completed(cgpu_info *cgpu, work *work)
{
  char *prev; // r2
  work *next; // r5
  work *queued_work; // r0
  UT_hash_table *tbl; // r3
  ptrdiff_t hho; // r12
  ptrdiff_t v8; // r4
  work *v9; // r3
  char *v10; // r0
  UT_hash_table *v11; // r3
  UT_hash_bucket_0 *buckets; // r4
  unsigned int v13; // r0
  work *hh_head; // r5
  UT_hash_handle *hh_next; // r2
  UT_hash_handle *hh_prev; // r0

  prev = (char *)work->hh.prev;
  next = (work *)work->hh.next;
  --cgpu->queued_count;
  if ( prev || next )
  {
    queued_work = cgpu->queued_work;
    tbl = queued_work->hh.tbl;
    hho = tbl->hho;
    if ( work == (work *)((char *)tbl->tail - hho) )
      tbl->tail = (UT_hash_handle *)&prev[hho];
    if ( prev )
    {
      v8 = tbl->hho;
      v9 = queued_work;
      *(_DWORD *)&prev[v8 + 8] = next;
    }
    else
    {
      v9 = next;
      cgpu->queued_work = next;
    }
    v10 = (char *)work->hh.next;
    v11 = v9->hh.tbl;
    if ( v10 )
      *(_DWORD *)&v10[v11->hho + 4] = prev;
    buckets = v11->buckets;
    v13 = (v11->num_buckets - 1) & work->hh.hashv;
    hh_head = (work *)v11->buckets[v13].hh_head;
    --v11->buckets[v13].count;
    hh_next = work->hh.hh_next;
    if ( hh_head == (work *)&work->hh )
      buckets[v13].hh_head = hh_next;
    hh_prev = work->hh.hh_prev;
    if ( hh_prev )
    {
      hh_prev->hh_next = hh_next;
      hh_next = work->hh.hh_next;
    }
    if ( hh_next )
      hh_next->hh_prev = hh_prev;
    --v11->num_items;
  }
  else
  {
    free(cgpu->queued_work->hh.tbl->buckets);
    free(cgpu->queued_work->hh.tbl);
    cgpu->queued_work = 0;
  }
}

//----- (0001FE0C) --------------------------------------------------------
void __fastcall reinit_device(cgpu_info *cgpu)
{
  if ( cgpu->deven != DEV_DISABLED )
    ((void (*)(void))cgpu->drv->reinit_device)();
}

//----- (0001FE1C) --------------------------------------------------------
void __fastcall __noreturn quit(int status)
{
  _quit(status, 1);
}

//----- (0001FE24) --------------------------------------------------------
void restart_threads()
{
  pthread_t rthread; // [sp+4h] [bp-Ch] BYREF

  cgtime(&restart_tv_start);
  if ( pthread_create(&rthread, 0, restart_thread_0, 0) )
    restart_threads_0();
}

//----- (0001FE50) --------------------------------------------------------
bool __fastcall benchfile_get_work(work *work)
{
  unsigned __int8 *v2; // r0
  bool v3; // zf
  bool result; // r0
  unsigned __int8 **v5; // r6
  int v6; // r8
  int v7; // r9
  char *v8; // r0
  int length; // lr
  unsigned __int8 *v10; // r2
  const char *v11; // r8
  signed int v12; // r2
  size_t v13; // r9
  size_t v14; // r6
  const char *v15; // r7
  char *v16; // r0
  const char *v17; // r7
  char *v18; // r0
  int v19; // r0
  unsigned __int8 *commas[5]; // [sp+14h] [bp-C3Ch] BYREF
  unsigned __int8 buf[1024]; // [sp+28h] [bp-C28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+428h] [bp-828h] BYREF

  if ( benchfile_in )
  {
    if ( fgets((char *)buf, 1024, benchfile_in) )
      goto LABEL_3;
    if ( !benchfile_work )
      goto LABEL_22;
LABEL_9:
    fclose(benchfile_in);
    benchfile_in = 0;
    return benchfile_get_work(work);
  }
  else
  {
    if ( !opt_benchfile )
    {
      strcpy((char *)tmp42, "BENCHFILE Invalid benchfile NULL");
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_in = fopen((const char *)opt_benchfile, (const char *)"r");
    if ( !benchfile_in )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to open benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_line = 0;
    if ( !fgets((char *)buf, 1024, benchfile_in) )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to read benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_work = 0;
    while ( 1 )
    {
LABEL_3:
      v2 = buf;
      v3 = buf[0] == 35;
      if ( buf[0] != 35 )
        v3 = buf[0] == 0;
      ++benchfile_line;
      if ( !v3 && buf[0] != 47 )
        break;
      if ( !fgets((char *)buf, 1024, benchfile_in) )
      {
        if ( benchfile_work )
          goto LABEL_9;
LABEL_22:
        snprintf((char *)tmp42, 0x800u, "BENCHFILE No work in benchfile '%s'", opt_benchfile);
        applog(3, tmp42, 1);
        quit(1);
      }
    }
    v5 = commas;
    v6 = 0;
    v7 = 1;
    commas[0] = buf;
    do
    {
      v8 = strchr((const char *)v2, 44);
      v5[1] = (unsigned __int8 *)v8;
      if ( !v8 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
          benchfile_line,
          v7,
          5);
        applog(3, tmp42, 1);
        quit(1);
      }
      length = benchfile_data[v6].length;
      v10 = *v5;
      if ( length && v8 - (char *)v10 != length )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
          benchfile_line,
          v7,
          (const char *)benchfile_data[v6].name,
          v8 - (char *)v10,
          length);
        applog(3, tmp42, 1);
        quit(1);
      }
      ++v7;
      *v8 = 0;
      ++v6;
      v5[1] = (unsigned __int8 *)(v8 + 1);
      v2 = (unsigned __int8 *)(v8 + 1);
      ++v5;
    }
    while ( v7 != 5 );
    v11 = (const char *)commas[4];
    v12 = strlen((const char *)commas[4]);
    if ( v12 <= 9 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
        benchfile_line,
        5,
        "NonceTime",
        v12,
        10);
      applog(3, tmp42, 1);
      quit(1);
    }
    sprintf((char *)tmp42, "0000000%c", *commas[0]);
    v13 = strlen((const char *)tmp42);
    v14 = v13;
    v15 = (const char *)(commas[2] + 56);
    do
    {
      v16 = (char *)&tmp42[v14];
      v14 += 8;
      sprintf(v16, "%.8s", v15);
      v15 -= 8;
    }
    while ( v14 != v13 + 64 );
    v17 = (const char *)(commas[1] + 56);
    do
    {
      v18 = (char *)&tmp42[v14];
      v14 += 8;
      sprintf(v18, "%.8s", v17);
      v17 -= 8;
    }
    while ( v14 != v13 + 128 );
    v19 = strtol(v11, 0, 10);
    sprintf((char *)&tmp42[v14], "%08lx", v19);
    strcpy((char *)&tmp42[v13 + 136], (const char *)commas[3]);
    memset(work, 0, sizeof(work));
    hex2bin(work->data, tmp42, (int)(v13 + 144) >> 1);
    calc_midstate(work);
    result = 1;
    ++benchfile_work;
  }
  return result;
}

//----- (00020188) --------------------------------------------------------
void __fastcall get_benchfile_work(work *work)
{
  pool **v2; // r3
  double v3; // r2
  int v4; // [sp+0h] [bp-10h]

  benchfile_get_work(work);
  v2 = pools;
  work->mandatory = 1;
  work->pool = *v2;
  cgtime(&work->tv_getwork);
  copy_time(&work->tv_getwork_reply, &work->tv_getwork);
  work->getwork_mode = 66;
  HIDWORD(v3) = v4;
  calc_diff(work, v3);
}
// 201C6: variable 'v4' is possibly undefined
// 201CA: variable 'v3' is possibly undefined

//----- (000201D8) --------------------------------------------------------
void __fastcall get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  double v3; // d0
  double v7; // d10
  uint64_t v8; // kr00_8
  size_t v9; // r7
  unsigned __int8 displayed_hashes[16]; // [sp+28h] [bp-8A0h] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+38h] [bp-890h] BYREF
  unsigned __int8 tmp13[64]; // [sp+48h] [bp-880h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+88h] [bp-840h] BYREF

  cgpu_runtime(cgpu);
  v7 = (double)cgpu->diff1 / v3 * 60.0;
  v8 = (unsigned __int64)(cgpu->rolling * 1000000.0);
  suffix_string((unsigned __int64)(cgpu->total_mhashes / v3 * 1000000.0), displayed_hashes, 0x10u, 4);
  suffix_string(v8, displayed_rolling, 0x10u, 4);
  snprintf((char *)buf, bufsiz, "%s%d ", (const char *)cgpu->drv->name, cgpu->device_id);
  cgpu->drv->get_statline_before(buf, bufsiz, cgpu);
  v9 = strlen((const char *)buf);
  snprintf(
    (char *)tmp13,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    opt_log_interval,
    (const char *)displayed_rolling,
    (const char *)displayed_hashes,
    cgpu->diff_accepted,
    cgpu->diff_rejected,
    cgpu->hw_errors,
    v7);
  if ( bufsiz <= strlen((const char *)tmp13) + v9 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "tailsprintf buffer overflow in %s %s line %d",
      "cgminer.c",
      (const char *)_func___13364,
      3034);
    applog(3, tmp42, 1);
    quit(1);
  }
  strcat((char *)buf, (const char *)tmp13);
  cgpu->drv->get_statline(buf, bufsiz, cgpu);
}
// 20212: variable 'v3' is possibly undefined

//----- (00020330) --------------------------------------------------------
void __noreturn kill_work()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  cg_completion_timeout(_kill_work, 0, 5000);
  strcpy((char *)tmp42, "Shutdown signal received.");
  applog(3, tmp42, 1);
  quit(0);
}

//----- (00020378) --------------------------------------------------------
void __fastcall __noreturn sighandler(int sig)
{
  sigaction_0(15, &termhandler, 0);
  sigaction_0(2, &inthandler, 0);
  sigaction_0(6, &abrthandler, 0);
  kill_work();
}

//----- (000203B4) --------------------------------------------------------
int __fastcall restart_wait(thr_info *thr, unsigned int mstime)
{
  __time_t v5; // r4
  signed int v6; // r1
  const unsigned __int8 *v7; // r2
  int v8; // r3
  int v9; // r4
  const unsigned __int8 *v10; // r2
  int v11; // r3
  timeval now; // [sp+0h] [bp-28h] BYREF
  timespec abstime; // [sp+8h] [bp-20h] BYREF

  cgtime(&now);
  v5 = mstime / 0x3E8 + now.tv_sec;
  v6 = 1000 * mstime - 1000000 * (mstime / 0x3E8) + now.tv_usec;
  if ( v6 > (int)&cgpu.results[29][3662] + 3 )
  {
    ++v5;
    v6 -= 1000000;
  }
  abstime.tv_sec = v5;
  abstime.tv_nsec = 1000 * v6;
  if ( pthread_mutex_lock(&restart_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13787, (const unsigned __int8 *)0x14C9, v7, v8);
  v9 = 0;
  if ( !thr->work_restart )
    v9 = pthread_cond_timedwait(&restart_cond, &restart_lock, &abstime);
  if ( pthread_mutex_unlock(&restart_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13787, (const unsigned __int8 *)0x14D3, v10, v11);
  selective_yield();
  return v9;
}
// 20444: variable 'v7' is possibly undefined
// 20444: variable 'v8' is possibly undefined
// 20450: variable 'v10' is possibly undefined
// 20450: variable 'v11' is possibly undefined

//----- (00020468) --------------------------------------------------------
work *__fastcall hash_pop(bool blocking)
{
  work *v1; // r4
  const unsigned __int8 *v2; // r2
  int v3; // r3
  work *v4; // r2
  UT_hash_table *tbl; // r5
  char *prev; // r1
  work *v7; // r8
  ptrdiff_t hho; // r0
  char *v9; // r0
  UT_hash_table *v10; // r3
  UT_hash_bucket_0 *buckets; // r0
  int v12; // r1
  bool v13; // zf
  UT_hash_handle *hh_next; // r2
  UT_hash_handle *hh_prev; // r1
  const unsigned __int8 *v16; // r2
  int v17; // r3
  void *next; // r0
  int v20; // r1
  timespec then; // [sp+0h] [bp-838h] BYREF
  timeval now; // [sp+8h] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-828h] BYREF

  v1 = (work *)blocking;
  if ( pthread_mutex_lock(stgd_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13787.__size[16], (const unsigned __int8 *)0x1F78, v2, v3);
  if ( staged_work && staged_work->hh.tbl->num_items )
  {
    if ( !no_work )
      goto LABEL_17;
    goto LABEL_13;
  }
  work_emptied = 1;
  if ( !v1 )
    goto out_unlock;
  do
  {
    cgtime(&now);
    then.tv_sec = now.tv_sec + 10;
    then.tv_nsec = 1000 * now.tv_usec;
    pthread_cond_signal(&gws_cond);
    if ( pthread_cond_timedwait(&getq->cond, stgd_lock, &then) )
    {
      if ( !no_work )
      {
        no_work = 1;
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          strcpy((char *)tmp42, "Waiting for work to be available from pools.");
          applog(4, tmp42, 0);
        }
      }
    }
  }
  while ( !staged_work || !staged_work->hh.tbl->num_items );
  if ( no_work )
  {
LABEL_13:
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Work available from pools, resuming.");
      applog(4, tmp42, 0);
    }
    no_work = 0;
  }
LABEL_17:
  v4 = staged_work;
  if ( staged_work )
  {
    tbl = staged_work->hh.tbl;
    if ( (signed int)tbl->num_items > staged_rollable )
    {
      next = staged_work->hh.next;
      if ( !staged_work->clone )
      {
        if ( staged_work->rolltime )
        {
          if ( next )
          {
            do
            {
              v20 = *((_DWORD *)next + 88);
              if ( *((_BYTE *)next + 273) )
                break;
              if ( !*((_DWORD *)next + 69) )
                break;
              next = (void *)*((_DWORD *)next + 88);
            }
            while ( v20 );
          }
          v1 = (work *)next;
          prev = (char *)*((_DWORD *)next + 87);
          v7 = (work *)*((_DWORD *)next + 88);
          if ( prev )
            goto LABEL_21;
          goto LABEL_50;
        }
      }
    }
    v1 = staged_work;
  }
  else
  {
    tbl = (UT_hash_table *)MEMORY[0x158];
    v1 = 0;
  }
  prev = (char *)v1->hh.prev;
  v7 = (work *)v1->hh.next;
  if ( prev )
  {
LABEL_21:
    hho = tbl->hho;
    if ( v1 == (work *)((char *)tbl->tail - hho) )
      tbl->tail = (UT_hash_handle *)&prev[hho];
    if ( prev )
    {
      *(_DWORD *)&prev[hho + 8] = v7;
      v9 = (char *)v1->hh.next;
    }
    else
    {
      v4 = v7;
      v9 = (char *)v7;
      staged_work = v7;
    }
    v10 = v4->hh.tbl;
    if ( v9 )
      *(_DWORD *)&v9[v10->hho + 4] = prev;
    buckets = v10->buckets;
    v12 = (v10->num_buckets - 1) & v1->hh.hashv;
    v13 = v10->buckets[v12].hh_head == &v1->hh;
    hh_next = v1->hh.hh_next;
    --v10->buckets[v12].count;
    if ( v13 )
      buckets[v12].hh_head = hh_next;
    hh_prev = v1->hh.hh_prev;
    if ( hh_prev )
    {
      hh_prev->hh_next = hh_next;
      hh_next = v1->hh.hh_next;
    }
    if ( hh_next )
      hh_next->hh_prev = hh_prev;
    --v10->num_items;
    goto LABEL_34;
  }
LABEL_50:
  if ( v7 )
    goto LABEL_21;
  free(tbl->buckets);
  free(staged_work->hh.tbl);
  staged_work = 0;
LABEL_34:
  if ( !v1->clone && v1->rolltime )
    --staged_rollable;
  pthread_cond_signal(&gws_cond);
  pthread_cond_signal(&getq->cond);
  last_getwork = time(0);
out_unlock:
  if ( pthread_mutex_unlock(stgd_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13787.__size[16], (const unsigned __int8 *)0x1FC0, v16, v17);
  selective_yield();
  return v1;
}
// 206F0: variable 'v2' is possibly undefined
// 206F0: variable 'v3' is possibly undefined
// 206FC: variable 'v16' is possibly undefined
// 206FC: variable 'v17' is possibly undefined

//----- (00020738) --------------------------------------------------------
void __fastcall inc_hw_errors(thr_info *thr)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  int v4; // r1
  const unsigned __int8 *v5; // r2
  int v6; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s %d: invalid nonce - HW error",
      (const char *)thr->cgpu->drv->name,
      thr->cgpu->device_id);
    applog(6, tmp42, 0);
  }
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___14582, (const unsigned __int8 *)0x21BA, v2, v3);
  v4 = hw_errors + 1;
  ++thr->cgpu->hw_errors;
  hw_errors = v4;
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14582, (const unsigned __int8 *)0x21BD, v5, v6);
  selective_yield();
  thr->cgpu->drv->hw_error(thr);
}
// 207B8: variable 'v5' is possibly undefined
// 207B8: variable 'v6' is possibly undefined
// 207C4: variable 'v2' is possibly undefined
// 207C4: variable 'v3' is possibly undefined

//----- (000207EC) --------------------------------------------------------
void __fastcall inc_hw_errors_with_diff(thr_info *thr, int diff)
{
  const unsigned __int8 *v4; // r2
  int v5; // r3
  int v6; // r1
  const unsigned __int8 *v7; // r2
  int v8; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-818h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s%d: invalid nonce - HW error",
      (const char *)thr->cgpu->drv->name,
      thr->cgpu->device_id);
    applog(3, tmp42, 0);
  }
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___14582.__size[16], (const unsigned __int8 *)0x21C7, v4, v5);
  v6 = hw_errors;
  thr->cgpu->hw_errors += diff;
  hw_errors = v6 + diff;
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14582.__size[16], (const unsigned __int8 *)0x21CA, v7, v8);
  selective_yield();
  thr->cgpu->drv->hw_error(thr);
}
// 2086E: variable 'v7' is possibly undefined
// 2086E: variable 'v8' is possibly undefined
// 2087A: variable 'v4' is possibly undefined
// 2087A: variable 'v5' is possibly undefined

//----- (000208A0) --------------------------------------------------------
void wake_gws()
{
  const unsigned __int8 *v0; // r2
  int v1; // r3
  const unsigned __int8 *v2; // r2
  int v3; // r3

  if ( pthread_mutex_lock(stgd_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13764, (const unsigned __int8 *)0x1494, v0, v1);
  pthread_cond_signal(&gws_cond);
  if ( pthread_mutex_unlock(stgd_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13764, (const unsigned __int8 *)0x1496, v2, v3);
  selective_yield();
}
// 208CC: variable 'v0' is possibly undefined
// 208CC: variable 'v1' is possibly undefined
// 208D8: variable 'v2' is possibly undefined
// 208D8: variable 'v3' is possibly undefined

//----- (000208F0) --------------------------------------------------------
void __fastcall inc_dev_status(int max_fan, int max_temp)
{
  const unsigned __int8 *v4; // r2
  int v5; // r3
  const unsigned __int8 *v6; // r2
  int v7; // r3

  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13764.__size[12], (const unsigned __int8 *)0x21D3, v4, v5);
  g_max_fan = max_fan;
  g_max_temp = max_temp;
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13764.__size[12], (const unsigned __int8 *)0x21D6, v6, v7);
  selective_yield();
}
// 2091C: variable 'v4' is possibly undefined
// 2091C: variable 'v5' is possibly undefined
// 20928: variable 'v6' is possibly undefined
// 20928: variable 'v7' is possibly undefined

//----- (00020944) --------------------------------------------------------
bool __fastcall pool_tset(pool *pool, bool *var)
{
  pthread_mutex_t *p_pool_lock; // r5
  const unsigned __int8 *v4; // r2
  int v5; // r3
  pthread_mutex_t *v6; // r0
  bool v7; // r5
  const unsigned __int8 *v8; // r2
  int v9; // r3

  p_pool_lock = &pool->pool_lock;
  if ( pthread_mutex_lock(&pool->pool_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___12498, (const unsigned __int8 *)0x305, v4, v5);
  v6 = p_pool_lock;
  v7 = *var;
  *var = 1;
  if ( pthread_mutex_unlock(v6) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___12498, (const unsigned __int8 *)0x30A, v8, v9);
  selective_yield();
  return v7;
}
// 20972: variable 'v4' is possibly undefined
// 20972: variable 'v5' is possibly undefined
// 2097E: variable 'v8' is possibly undefined
// 2097E: variable 'v9' is possibly undefined

//----- (0002098C) --------------------------------------------------------
bool __fastcall pool_tclear(pool *pool, bool *var)
{
  pthread_mutex_t *p_pool_lock; // r5
  const unsigned __int8 *v4; // r2
  int v5; // r3
  pthread_mutex_t *v6; // r0
  bool v7; // r5
  const unsigned __int8 *v8; // r2
  int v9; // r3

  p_pool_lock = &pool->pool_lock;
  if ( pthread_mutex_lock(&pool->pool_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___12498.__size[12], (const unsigned __int8 *)0x314, v4, v5);
  v6 = p_pool_lock;
  v7 = *var;
  *var = 0;
  if ( pthread_mutex_unlock(v6) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___12498.__size[12], (const unsigned __int8 *)0x319, v8, v9);
  selective_yield();
  return v7;
}
// 209BA: variable 'v4' is possibly undefined
// 209BA: variable 'v5' is possibly undefined
// 209C6: variable 'v8' is possibly undefined
// 209C6: variable 'v9' is possibly undefined

//----- (000209D4) --------------------------------------------------------
bool __fastcall pool_active(pool *pool, bool pinging)
{
  _BOOL4 v3; // r7
  unsigned __int8 *stratum_url; // r0
  _BOOL4 v6; // r2
  _BOOL4 has_gbt; // r2
  _BOOL4 v8; // r3
  const char *v9; // r1
  size_t v10; // r2
  timeval tv_getwork; // [sp+8h] [bp-828h] BYREF
  timeval tv_getwork_reply; // [sp+10h] [bp-820h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-818h] BYREF

  v3 = pinging;
  if ( pool->has_gbt )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Retrieving block template from pool %s", (const char *)pool->rpc_url);
      applog(7, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %s", (const char *)pool->rpc_url);
    applog(6, tmp42, 0);
  }
  if ( pool->has_stratum )
    goto LABEL_41;
  if ( !curly )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "CURL initialisation failed");
      applog(3, tmp42, 0);
      return 0;
    }
    return 0;
  }
  if ( pool->probed )
    goto LABEL_8;
  if ( !opt_debug )
  {
    pool->probed = opt_debug;
    goto LABEL_8;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 6 )
  {
    strcpy((char *)tmp42, "Probing for GBT support");
    applog(7, tmp42, 0);
    has_gbt = pool->has_gbt;
    v8 = opt_debug;
    pool->probed = 0;
    if ( !has_gbt )
    {
      if ( !pool->gbt_solo )
      {
        if ( !v8 )
          goto LABEL_8;
        goto LABEL_62;
      }
      if ( !v8 )
        goto LABEL_8;
LABEL_57:
      if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_8;
      v9 = "GBT coinbase without append found, switching to GBT solo protocol";
      v10 = 66;
      goto LABEL_60;
    }
    if ( !v8 )
      goto LABEL_8;
LABEL_51:
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy((char *)tmp42, "GBT coinbase + append support found, switching to GBT protocol");
      applog(7, tmp42, 0);
    }
    goto LABEL_8;
  }
  v6 = pool->has_gbt;
  pool->probed = opt_log_output;
  if ( v6 )
    goto LABEL_51;
  if ( pool->gbt_solo )
    goto LABEL_57;
LABEL_62:
  if ( use_syslog || opt_log_output )
  {
    v9 = "No GBT coinbase + append support found, pool unusable if it has no stratum";
    v10 = 75;
LABEL_60:
    memcpy(tmp42, v9, v10);
    applog(7, tmp42, 0);
    goto LABEL_8;
  }
  if ( opt_log_level > 6 )
  {
    v9 = "No GBT coinbase + append support found, pool unusable if it has no stratum";
    v10 = 75;
    goto LABEL_60;
  }
LABEL_8:
  cgtime(&tv_getwork);
  cgtime(&tv_getwork_reply);
  stratum_url = pool->stratum_url;
  if ( !stratum_url || opt_fix_protocol )
    goto LABEL_97;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %d stratum %s", pool->pool_no, (const char *)pool->stratum_url);
    applog(6, tmp42, 0);
    stratum_url = pool->stratum_url;
  }
  if ( !extract_sockaddr(stratum_url, &pool->sockaddr_url, &pool->stratum_port) || !initiate_stratum(pool) )
  {
LABEL_97:
    if ( pool->has_stratum || pool->gbt_solo || pool->has_gbt )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "FAILED to retrieve work from pool %u %s",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(7, tmp42, 0);
      }
      if ( v3 || pool->idle || !use_syslog && !opt_log_output && opt_log_level <= 3 )
        return 0;
      snprintf((char *)tmp42, 0x800u, "Pool %u slow/down or URL or credentials invalid", pool->pool_no);
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
        return 0;
      snprintf(
        (char *)tmp42,
        0x800u,
        "No Stratum, GBT or Solo support in pool %d %s unable to use",
        pool->pool_no,
        (const char *)pool->rpc_url);
    }
    applog(4, tmp42, 0);
    return 0;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Switching pool %d %s to %s",
      pool->pool_no,
      (const char *)pool->rpc_url,
      (const char *)pool->stratum_url);
    applog(5, tmp42, 0);
  }
  if ( !pool->rpc_url )
    pool->rpc_url = (unsigned __int8 *)_strdup((const char *)pool->stratum_url);
  pool->has_stratum = 1;
LABEL_41:
  if ( pool_tset(pool, &pool->stratum_init) )
    return pool->stratum_active;
  if ( initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool) )
  {
    have_longpoll = 1;
    if ( pthread_create(&pool->stratum_sthread, 0, stratum_sthread, pool) )
    {
      strcpy((char *)tmp42, "Failed to create stratum sthread");
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_create(&pool->stratum_rthread, 0, stratum_rthread, pool) )
    {
      strcpy((char *)tmp42, "Failed to create stratum rthread");
      applog(3, tmp42, 1);
      quit(1);
    }
    return 1;
  }
  else
  {
    pool_tclear(pool, &pool->stratum_init);
    return 0;
  }
}

//----- (00020E70) --------------------------------------------------------
void __fastcall clear_stratum_shares(pool *pool)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  stratum_share *v4; // r4
  work *work; // r2
  stratum_share *v6; // r6
  stratum_share *next; // r5
  double v8; // d8
  char *prev; // r1
  stratum_share *v10; // r9
  stratum_share *v11; // r3
  ptrdiff_t hho; // r12
  char *v13; // lr
  UT_hash_table *tbl; // r3
  UT_hash_bucket_0 *buckets; // lr
  int v16; // r12
  stratum_share **v17; // r9
  bool v18; // zf
  UT_hash_handle *hh_next; // r1
  UT_hash_handle *hh_prev; // r0
  const unsigned __int8 *v21; // r2
  int v22; // r3
  double v23; // d7
  double v24; // d6
  int64_t v25; // r2
  stratum_share *v26; // r10
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-828h] BYREF

  if ( pthread_mutex_lock(&sshare_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___14230, (const unsigned __int8 *)0x1C55, v2, v3);
  v4 = stratum_shares;
  if ( stratum_shares )
  {
    work = stratum_shares->work;
    v6 = 0;
    next = (stratum_share *)stratum_shares->hh.next;
    v8 = 0.0;
    if ( work->pool == pool )
      goto LABEL_6;
    while ( next )
    {
      while ( 1 )
      {
        v4 = next;
        next = (stratum_share *)next->hh.next;
        work = v4->work;
        if ( work->pool != pool )
          break;
LABEL_6:
        prev = (char *)v4->hh.prev;
        v10 = (stratum_share *)v4->hh.next;
        if ( prev || v10 )
        {
          v11 = stratum_shares;
          hho = stratum_shares->hh.tbl->hho;
          if ( v4 == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - hho) )
            stratum_shares->hh.tbl->tail = (UT_hash_handle *)&prev[hho];
          if ( prev )
          {
            *(_DWORD *)&prev[hho + 8] = v10;
            v13 = (char *)v4->hh.next;
          }
          else
          {
            v11 = v10;
            v13 = (char *)v10;
            stratum_shares = v10;
          }
          tbl = v11->hh.tbl;
          if ( v13 )
            *(_DWORD *)&v13[tbl->hho + 4] = prev;
          buckets = tbl->buckets;
          v16 = (tbl->num_buckets - 1) & v4->hh.hashv;
          v17 = (stratum_share **)&tbl->buckets[(tbl->num_buckets - 1) & v4->hh.hashv];
          v18 = *v17 == v4;
          hh_next = v4->hh.hh_next;
          v17[1] = (stratum_share *)((char *)v17[1] - 1);
          hh_prev = v4->hh.hh_prev;
          if ( v18 )
            buckets[v16].hh_head = hh_next;
          if ( hh_prev )
          {
            hh_prev->hh_next = hh_next;
            hh_next = v4->hh.hh_next;
          }
          if ( hh_next )
            hh_next->hh_prev = hh_prev;
          --tbl->num_items;
        }
        else
        {
          v26 = stratum_shares;
          free(stratum_shares->hh.tbl->buckets);
          free(v26->hh.tbl);
          stratum_shares = 0;
          work = v4->work;
        }
        v6 = (stratum_share *)((char *)v6 + 1);
        v8 = v8 + work->work_difficulty;
        free_work(&v4->work, "cgminer.c", (const unsigned __int8 *)&_func___14230, 7261);
        --pool->sshares;
        free(v4);
        if ( !next )
          goto LABEL_21;
      }
    }
  }
  else
  {
    v8 = 0.0;
    v6 = stratum_shares;
  }
LABEL_21:
  if ( pthread_mutex_unlock(&sshare_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14230, (const unsigned __int8 *)0x1C63, v21, v22);
  selective_yield();
  if ( v6 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", v6, pool->pool_no);
      applog(4, tmp42, 0);
    }
    v23 = pool->diff_stale + v8;
    v24 = total_diff_stale;
    v25 = total_stale;
    pool->stale_shares += (unsigned int)v6;
    pool->diff_stale = v23;
    total_stale = (int64_t)v6 + v25;
    total_diff_stale = v24 + v8;
  }
}
// 2103A: variable 'v21' is possibly undefined
// 2103A: variable 'v22' is possibly undefined
// 21046: variable 'v2' is possibly undefined
// 21046: variable 'v3' is possibly undefined

//----- (00021084) --------------------------------------------------------
void __fastcall clear_pool_work(pool *pool)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  work *v4; // r2
  work *next; // r4
  int v6; // r6
  work *v7; // r1
  const unsigned __int8 *v8; // r2
  int v9; // r3
  char *prev; // r0
  work *v11; // r8
  work *v12; // r1
  UT_hash_table *tbl; // r12
  ptrdiff_t hho; // r9
  char *v15; // r12
  UT_hash_table *v16; // r1
  UT_hash_bucket_0 *buckets; // r12
  int v18; // r8
  UT_hash_handle_0 **p_hh_head; // r9
  bool v20; // zf
  UT_hash_handle *hh_next; // r3
  UT_hash_handle *hh_prev; // r0
  work *work; // [sp+Ch] [bp-824h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-820h] BYREF

  if ( pthread_mutex_lock(stgd_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___14243, (const unsigned __int8 *)0x1C74, v2, v3);
  v4 = staged_work;
  work = staged_work;
  next = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  v6 = 0;
  if ( staged_work )
  {
    do
    {
      if ( v4->pool == pool )
      {
        prev = (char *)v4->hh.prev;
        v11 = (work *)v4->hh.next;
        if ( prev || v11 )
        {
          v12 = staged_work;
          tbl = staged_work->hh.tbl;
          hho = tbl->hho;
          if ( v4 == (work *)((char *)tbl->tail - hho) )
            tbl->tail = (UT_hash_handle *)&prev[hho];
          if ( prev )
          {
            *(_DWORD *)&prev[staged_work->hh.tbl->hho + 8] = v11;
            v15 = (char *)v4->hh.next;
          }
          else
          {
            v12 = v11;
            v15 = (char *)v11;
            staged_work = v11;
          }
          v16 = v12->hh.tbl;
          if ( v15 )
            *(_DWORD *)&v15[v16->hho + 4] = prev;
          buckets = v16->buckets;
          v18 = (v16->num_buckets - 1) & v4->hh.hashv;
          p_hh_head = &v16->buckets[(v16->num_buckets - 1) & v4->hh.hashv].hh_head;
          v20 = *p_hh_head == &v4->hh;
          hh_next = v4->hh.hh_next;
          p_hh_head[1] = (UT_hash_handle_0 *)((char *)p_hh_head[1] - 1);
          hh_prev = v4->hh.hh_prev;
          if ( v20 )
            buckets[v18].hh_head = hh_next;
          if ( hh_prev )
          {
            hh_prev->hh_next = hh_next;
            hh_next = v4->hh.hh_next;
          }
          if ( hh_next )
            hh_next->hh_prev = hh_prev;
          --v16->num_items;
        }
        else
        {
          free(staged_work->hh.tbl->buckets);
          free(staged_work->hh.tbl);
          staged_work = 0;
        }
        ++v6;
        free_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___14243, 7290);
      }
      work = next;
      v7 = next;
      if ( next )
        v7 = (work *)next->hh.next;
      v4 = next;
      next = v7;
    }
    while ( v4 );
  }
  if ( pthread_mutex_unlock(stgd_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14243, (const unsigned __int8 *)0x1C7E, v8, v9);
  selective_yield();
  if ( v6 && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "Cleared %d work items due to stratum disconnect on pool %d", v6, pool->pool_no);
    applog(6, tmp42, 0);
  }
}
// 21208: variable 'v2' is possibly undefined
// 21208: variable 'v3' is possibly undefined
// 21214: variable 'v8' is possibly undefined
// 21214: variable 'v9' is possibly undefined

//----- (0002123C) --------------------------------------------------------
void __fastcall mutex_init_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *v6; // r2

  if ( pthread_mutex_init(lock, 0) )
    mutex_init((pthread_mutex_t *)file, func, v6, line);
}
// 21254: variable 'v6' is possibly undefined

//----- (00021258) --------------------------------------------------------
void __fastcall rwlock_init_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *v6; // r2

  if ( pthread_rwlock_init(lock, 0) )
    rwlock_init((pthread_rwlock_t *)file, func, v6, line);
}
// 21270: variable 'v6' is possibly undefined

//----- (00021274) --------------------------------------------------------
void __fastcall cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  const unsigned __int8 *v7; // r2
  int v8; // r3
  const unsigned __int8 *v9; // r2
  int v10; // r3

  if ( pthread_mutex_init(&lock->mutex, 0) )
    mutex_init((pthread_mutex_t *)file, func, v7, v8);
  if ( pthread_rwlock_init(&lock->rwlock, 0) )
    rwlock_init((pthread_rwlock_t *)file, func, v9, v10);
}
// 21296: variable 'v7' is possibly undefined
// 21296: variable 'v8' is possibly undefined
// 212A4: variable 'v9' is possibly undefined
// 212A4: variable 'v10' is possibly undefined

//----- (000212A8) --------------------------------------------------------
pool *add_pool()
{
  pool *v0; // r0
  int v1; // r3
  pool *v2; // r4
  pool **v3; // r0
  pool **v4; // r0
  int v5; // r2
  const unsigned __int8 *v6; // r2
  int v7; // r3
  const unsigned __int8 *v8; // r2
  int v9; // r3
  const unsigned __int8 *v10; // r2
  int v11; // r3
  const unsigned __int8 *v12; // r2
  int v13; // r3
  const unsigned __int8 *v14; // r2
  int v15; // r3
  const unsigned __int8 *v16; // r2
  int v17; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-818h] BYREF

  v0 = (pool *)cgcalloc(1848, 1u, "cgminer.c", &_func___14243.__size[16], 727);
  v1 = total_pools;
  v2 = v0;
  v0->support_vil = 0;
  v0->prio = v1;
  v3 = pools;
  v2->pool_no = v1;
  v4 = (pool **)cgrealloc(v3, 4 * (v1 + 2), "cgminer.c", &_func___14243.__size[16], 739);
  v5 = total_pools;
  pools = v4;
  v4[total_pools] = v2;
  total_pools = v5 + 1;
  if ( pthread_mutex_init(&v2->pool_lock, 0) )
    mutex_init((pthread_mutex_t *)&_func___14243.__size[16], (const unsigned __int8 *)0x2E6, v6, v7);
  if ( pthread_cond_init(&v2->cr_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init in add_pool");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_init(&v2->data_lock.mutex, 0) )
    mutex_init((pthread_mutex_t *)&_func___14243.__size[16], (const unsigned __int8 *)0x2ED, v8, v9);
  if ( pthread_rwlock_init(&v2->data_lock.rwlock, 0) )
    rwlock_init((pthread_rwlock_t *)(&_func___14243.__align + 4), (const unsigned __int8 *)0x2ED, v10, v11);
  if ( pthread_mutex_init(&v2->stratum_lock, 0) )
    mutex_init((pthread_mutex_t *)&_func___14243.__size[16], (const unsigned __int8 *)0x2EE, v12, v13);
  if ( pthread_mutex_init(&v2->gbt_lock.mutex, 0) )
    mutex_init((pthread_mutex_t *)&_func___14243.__size[16], (const unsigned __int8 *)0x2EF, v14, v15);
  if ( pthread_rwlock_init(&v2->gbt_lock.rwlock, 0) )
    rwlock_init((pthread_rwlock_t *)(&_func___14243.__align + 4), (const unsigned __int8 *)0x2EF, v16, v17);
  v2->curlring.next = &v2->curlring;
  v2->rpc_req = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  v2->curlring.prev = &v2->curlring;
  v2->tv_idle.tv_sec = -1;
  v2->rpc_proxy = 0;
  v2->quota = 1;
  adjust_quota_gcd();
  v2->extranonce_subscribe = 0;
  return v2;
}
// 21392: variable 'v6' is possibly undefined
// 21392: variable 'v7' is possibly undefined
// 2139E: variable 'v16' is possibly undefined
// 2139E: variable 'v17' is possibly undefined
// 213AA: variable 'v14' is possibly undefined
// 213AA: variable 'v15' is possibly undefined
// 213B6: variable 'v12' is possibly undefined
// 213B6: variable 'v13' is possibly undefined
// 213C2: variable 'v10' is possibly undefined
// 213C2: variable 'v11' is possibly undefined
// 213CE: variable 'v8' is possibly undefined
// 213CE: variable 'v9' is possibly undefined

//----- (00021414) --------------------------------------------------------
unsigned __int8 *__fastcall set_userpass(const unsigned __int8 *arg)
{
  int v2; // r3
  pool *v3; // r4
  char *v4; // r6
  char *v5; // r0
  char *v6; // r0
  unsigned __int8 *v7; // r3
  unsigned __int8 *v8; // r0

  if ( total_users || total_passes )
    return "Use only user + pass or userpass, but not both";
  v2 = total_userpasses + 1;
  total_userpasses = v2;
  if ( v2 > total_pools )
  {
    add_pool();
    v2 = total_userpasses;
  }
  v3 = pools[v2 - 1];
  v4 = _strdup((const char *)arg);
  opt_set_charp(arg, &v3->rpc_userpass);
  v5 = strtok(v4, ":");
  v3->rpc_user = (unsigned __int8 *)v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v7 = 0;
  v3->rpc_pass = (unsigned __int8 *)v6;
  if ( !v6 )
  {
    v8 = (unsigned __int8 *)calloc(1u, 1u);
    v7 = 0;
    v3->rpc_pass = v8;
  }
  return v7;
}

//----- (000214B0) --------------------------------------------------------
unsigned __int8 *__fastcall set_user(const unsigned __int8 *arg)
{
  int v3; // r3

  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  v3 = total_users + 1;
  total_users = v3;
  if ( v3 > total_pools )
  {
    add_pool();
    v3 = total_users;
  }
  opt_set_charp(arg, &pools[v3 - 1]->rpc_user);
  return 0;
}

//----- (00021504) --------------------------------------------------------
pool *add_url()
{
  int v0; // r3

  v0 = ++total_urls;
  if ( total_urls > total_pools )
  {
    add_pool();
    v0 = total_urls;
  }
  return pools[v0 - 1];
}

//----- (0002153C) --------------------------------------------------------
unsigned __int8 *__fastcall set_url(unsigned __int8 *arg)
{
  pool *v2; // r4
  const char *rpc_url; // r5
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  v2 = add_url();
  setup_url(v2, arg);
  rpc_url = (const char *)v2->rpc_url;
  if ( strstr(rpc_url, ".nicehash.com") || strstr(rpc_url, "#xnsub") )
  {
    v2->extranonce_subscribe = 1;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d extranonce subscribing enabled.", v2->pool_no);
      applog(7, tmp42, 0);
    }
  }
  return 0;
}

//----- (000215CC) --------------------------------------------------------
unsigned __int8 *__fastcall set_quota(unsigned __int8 *arg)
{
  char *v2; // r5
  size_t v3; // r0
  size_t v4; // r7
  size_t v5; // r0
  size_t v6; // r5
  int v7; // r6
  pool *v9; // r7
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-818h] BYREF

  v2 = strchr((const char *)arg, 59);
  if ( !v2 )
    return "No semicolon separated quota;URL pair found";
  v3 = strlen((const char *)arg);
  *v2 = 0;
  v4 = v3;
  v5 = strlen((const char *)arg);
  v6 = v5;
  if ( !v5 )
    return "No parameter for quota found";
  if ( (int)(~v5 + v4) <= 0 )
    return "No parameter for URL found";
  v7 = strtol((const char *)arg, 0, 10);
  if ( v7 < 0 )
    return "Invalid negative parameter for quota set";
  v9 = add_url();
  setup_url(v9, &arg[v6 + 1]);
  v9->quota = v7;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Setting pool %d to quota %d", v9->pool_no, v7);
    applog(6, tmp42, 0);
  }
  adjust_quota_gcd();
  return 0;
}

//----- (0002168C) --------------------------------------------------------
unsigned __int8 *__fastcall set_pass(const unsigned __int8 *arg)
{
  int v3; // r3

  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  v3 = total_passes + 1;
  total_passes = v3;
  if ( v3 > total_pools )
  {
    add_pool();
    v3 = total_passes;
  }
  opt_set_charp(arg, &pools[v3 - 1]->rpc_pass);
  return 0;
}

//----- (000216E0) --------------------------------------------------------
unsigned __int8 *__fastcall set_extranonce_subscribe(unsigned __int8 *arg)
{
  int v1; // r3
  pool *v2; // r4
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-808h] BYREF

  v1 = ++total_extranonce;
  if ( total_extranonce > total_pools )
  {
    add_pool();
    v1 = total_extranonce;
  }
  v2 = pools[v1 - 1];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Enable extranonce subscribe on %d", v2->pool_no);
    applog(7, tmp42, 0);
  }
  opt_set_bool(&v2->extranonce_subscribe);
  return 0;
}

//----- (00021770) --------------------------------------------------------
void __fastcall rd_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  const unsigned __int8 *v6; // r2
  int v7; // r3

  if ( pthread_rwlock_unlock(lock) )
    rw_unlock_1((pthread_rwlock_t *)file, func, v6, v7);
  selective_yield();
}
// 21788: variable 'v6' is possibly undefined
// 21788: variable 'v7' is possibly undefined

//----- (00021794) --------------------------------------------------------
void __fastcall flush_queue(cgpu_info *cgpu)
{
  pthread_rwlock_t *p_qlock; // r5
  work *unqueued_work; // r2
  const unsigned __int8 *v4; // r2
  int v5; // r3
  work *work; // [sp+4h] [bp-814h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  work = 0;
  if ( cgpu )
  {
    p_qlock = &cgpu->qlock;
    if ( !pthread_rwlock_trywrlock(&cgpu->qlock) )
    {
      unqueued_work = cgpu->unqueued_work;
      cgpu->unqueued_work = 0;
      work = unqueued_work;
      if ( pthread_rwlock_unlock(p_qlock) )
        rw_unlock_1((pthread_rwlock_t *)&_func___14928, (const unsigned __int8 *)0x2520, v4, v5);
      selective_yield();
      if ( work )
      {
        free_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___14928, 9508);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Discarded queued work item");
          applog(7, tmp42, 0);
        }
      }
    }
  }
}
// 2182C: variable 'v4' is possibly undefined
// 2182C: variable 'v5' is possibly undefined

//----- (00021854) --------------------------------------------------------
int __fastcall age_queued_work(cgpu_info *cgpu, double secs)
{
  const unsigned __int8 *v4; // r2
  int v5; // r3
  work *queued_work; // r3
  work *next; // r4
  work *v8; // r2
  const unsigned __int8 *v9; // r2
  int v10; // r3
  timeval tv_now; // [sp+8h] [bp-28h] BYREF

  cgtime(&tv_now);
  if ( pthread_rwlock_wrlock(&cgpu->qlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___14928.__size[12], (const unsigned __int8 *)0x24E3, v4, v5);
  queued_work = cgpu->queued_work;
  next = queued_work;
  if ( queued_work )
    next = (work *)queued_work->hh.next;
  while ( queued_work )
  {
    tdiff(&tv_now, &queued_work->tv_work_start);
    v8 = next;
    if ( next )
      v8 = (work *)next->hh.next;
    queued_work = next;
    next = v8;
  }
  if ( pthread_rwlock_unlock(&cgpu->qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14928.__size[12], (const unsigned __int8 *)0x24EE, v9, v10);
  selective_yield();
  return 0;
}
// 218E4: variable 'v4' is possibly undefined
// 218E4: variable 'v5' is possibly undefined
// 218F0: variable 'v9' is possibly undefined
// 218F0: variable 'v10' is possibly undefined

//----- (00021904) --------------------------------------------------------
void __fastcall work_completed(cgpu_info *cgpu, work *work)
{
  pthread_rwlock_t *p_qlock; // r4
  const unsigned __int8 *v4; // r2
  int v5; // r3
  const unsigned __int8 *v6; // r2
  int v7; // r3
  work *worka; // [sp+4h] [bp-14h] BYREF

  p_qlock = &cgpu->qlock;
  worka = work;
  if ( pthread_rwlock_wrlock(&cgpu->qlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___14928.__size[28], (const unsigned __int8 *)0x24F8, v4, v5);
  _work_completed(cgpu, worka);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14928.__size[28], (const unsigned __int8 *)0x24FA, v6, v7);
  selective_yield();
  free_work(&worka, "cgminer.c", &_func___14928.__size[28], 9468);
}
// 21946: variable 'v4' is possibly undefined
// 21946: variable 'v5' is possibly undefined
// 21952: variable 'v6' is possibly undefined
// 21952: variable 'v7' is possibly undefined

//----- (00021964) --------------------------------------------------------
void __fastcall add_queued(cgpu_info *cgpu, work *work)
{
  pthread_rwlock_t *p_qlock; // r4
  const unsigned __int8 *v5; // r2
  int v6; // r3
  const unsigned __int8 *v7; // r2
  int v8; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_wrlock(&cgpu->qlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___14826, (const unsigned __int8 *)0x2460, v5, v6);
  _add_queued(cgpu, work);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14826, (const unsigned __int8 *)0x2462, v7, v8);
  selective_yield();
}
// 21994: variable 'v5' is possibly undefined
// 21994: variable 'v6' is possibly undefined
// 219A0: variable 'v7' is possibly undefined
// 219A0: variable 'v8' is possibly undefined

//----- (000219B0) --------------------------------------------------------
work *__fastcall take_queued_work_bymidstate(
        cgpu_info *cgpu,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  pthread_rwlock_t *p_qlock; // r6
  const unsigned __int8 *v11; // r2
  int v12; // r3
  work *work_bymidstate; // r4
  const unsigned __int8 *v14; // r2
  int v15; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_wrlock(&cgpu->qlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___14826.__size[12], (const unsigned __int8 *)0x2505, v11, v12);
  work_bymidstate = _find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);
  if ( work_bymidstate )
    _work_completed(cgpu, work_bymidstate);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14826.__size[12], (const unsigned __int8 *)0x2509, v14, v15);
  selective_yield();
  return work_bymidstate;
}
// 21A08: variable 'v11' is possibly undefined
// 21A08: variable 'v12' is possibly undefined
// 21A14: variable 'v14' is possibly undefined
// 21A14: variable 'v15' is possibly undefined

//----- (00021A24) --------------------------------------------------------
void __fastcall switch_pools(pool *selected)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  const unsigned __int8 *v4; // r2
  int v5; // r3
  pool *v6; // r7
  int pool_no; // r8
  int prio; // r4
  pool **v9; // r3
  pool **v10; // r0
  int v11; // r1
  int v12; // t1
  int v13; // r2
  bool v14; // cc
  int v15; // r2
  char v16; // r3
  int v17; // r3
  int v18; // r4
  int v19; // r0
  pool *v20; // r10
  pool *v21; // r4
  const unsigned __int8 *v22; // r2
  int v23; // r3
  const unsigned __int8 *v24; // r2
  int v25; // r3
  const unsigned __int8 *v26; // r2
  int v27; // r3
  const unsigned __int8 *v28; // r2
  int v29; // r3
  int v30; // r10
  pool **v31; // r11
  int v32; // r5
  int v33; // r9
  int v34; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-828h] BYREF

  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock_2((pthread_mutex_t *)&_func___13731, (const unsigned __int8 *)0x1417, v2, v3);
  if ( pthread_rwlock_wrlock(&control_lock.rwlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___13731, (const unsigned __int8 *)0x1417, v4, v5);
  v6 = currentpool;
  pool_no = currentpool->pool_no;
  if ( selected && (prio = selected->prio) != 0 )
  {
    if ( total_pools > 0 )
    {
      v9 = pools;
      v10 = &pools[total_pools];
      while ( 1 )
      {
        v12 = (int)*v9++;
        v11 = v12;
        v13 = *(_DWORD *)(v12 + 4);
        v14 = v13 < prio;
        v15 = v13 + 1;
        if ( v14 )
          *(_DWORD *)(v11 + 4) = v15;
        if ( v9 == v10 )
          break;
        prio = selected->prio;
      }
    }
    selected->prio = 0;
    v16 = pool_strategy_0;
    if ( (unsigned int)pool_strategy_0 > POOL_BALANCE )
      goto LABEL_21;
  }
  else
  {
    v16 = pool_strategy_0;
    if ( (unsigned int)pool_strategy_0 > POOL_BALANCE )
      goto LABEL_21;
  }
  v17 = 1 << v16;
  if ( (v17 & 0x19) != 0 )
  {
    if ( total_pools > 0 )
    {
      v18 = 0;
      while ( 1 )
      {
        v19 = v18++;
        v20 = priority_pool(v19);
        if ( !pool_unusable(v20) )
          break;
        if ( total_pools <= v18 )
          goto LABEL_21;
      }
      v21 = pools[v20->pool_no];
      goto LABEL_22;
    }
LABEL_21:
    v21 = pools[pool_no];
    goto LABEL_22;
  }
  if ( (v17 & 6) == 0 )
    goto LABEL_21;
  if ( selected && !selected->idle )
  {
    v21 = pools[selected->pool_no];
    goto LABEL_22;
  }
  v30 = total_pools;
  if ( total_pools <= 1 )
    goto LABEL_21;
  v31 = pools;
  v32 = pool_no;
  v33 = 1;
  while ( 1 )
  {
    ++v32;
    ++v33;
    v34 = v32;
    if ( v32 >= v30 )
    {
      v32 = 0;
      v34 = 0;
    }
    v21 = v31[v34];
    if ( !pool_unusable(v21) )
      break;
    if ( v33 == v30 )
    {
      v21 = v31[pool_no];
      break;
    }
  }
LABEL_22:
  currentpool = v21;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___13731, (const unsigned __int8 *)0x1468, v22, v23);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13731, (const unsigned __int8 *)0x1468, v24, v25);
  selective_yield();
  if ( v6 != v21 && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Switching to pool %d %s", v21->pool_no, (const char *)v21->rpc_url);
      applog(4, tmp42, 0);
    }
    clear_pool_work(v6);
  }
  if ( pthread_mutex_lock(&lp_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13731, (const unsigned __int8 *)0x1470, v26, v27);
  pthread_cond_broadcast(&lp_cond);
  if ( pthread_mutex_unlock(&lp_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13731, (const unsigned __int8 *)0x1472, v28, v29);
  selective_yield();
}
// 21BD6: variable 'v22' is possibly undefined
// 21BD6: variable 'v23' is possibly undefined
// 21BE2: variable 'v4' is possibly undefined
// 21BE2: variable 'v5' is possibly undefined
// 21BEE: variable 'v24' is possibly undefined
// 21BEE: variable 'v25' is possibly undefined
// 21BFA: variable 'v26' is possibly undefined
// 21BFA: variable 'v27' is possibly undefined
// 21C06: variable 'v2' is possibly undefined
// 21C06: variable 'v3' is possibly undefined
// 21C12: variable 'v28' is possibly undefined
// 21C12: variable 'v29' is possibly undefined

//----- (00021C4C) --------------------------------------------------------
unsigned int total_work_inc()
{
  const unsigned __int8 *v0; // r2
  int v1; // r3
  const unsigned __int8 *v2; // r2
  int v3; // r3
  unsigned int v4; // r4
  const unsigned __int8 *v5; // r2
  int v6; // r3
  const unsigned __int8 *v7; // r2
  int v8; // r3

  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock_2((pthread_mutex_t *)(&_func___13731.__align + 4), (const unsigned __int8 *)0x886, v0, v1);
  if ( pthread_rwlock_wrlock(&control_lock.rwlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___13731.__size[16], (const unsigned __int8 *)0x886, v2, v3);
  v4 = total_work++;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___13731.__size[16], (const unsigned __int8 *)0x888, v5, v6);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)(&_func___13731.__align + 4), (const unsigned __int8 *)0x888, v7, v8);
  selective_yield();
  return v4;
}
// 21C8A: variable 'v0' is possibly undefined
// 21C8A: variable 'v1' is possibly undefined
// 21C96: variable 'v7' is possibly undefined
// 21C96: variable 'v8' is possibly undefined
// 21CA2: variable 'v5' is possibly undefined
// 21CA2: variable 'v6' is possibly undefined
// 21CAE: variable 'v2' is possibly undefined
// 21CAE: variable 'v3' is possibly undefined

//----- (00021CC8) --------------------------------------------------------
void __fastcall roll_work(work *work)
{
  _BOOL4 v2; // r5
  int v3; // r1
  unsigned int v4; // r2
  unsigned __int8 *ntime; // r5
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  v2 = opt_debug;
  v3 = work->rolls + 1;
  v4 = local_work + 1;
  *(_DWORD *)&work->data[68] = bswap32(bswap32(*(_DWORD *)&work->data[68]) + 1);
  work->rolls = v3;
  work->nonce = 0;
  local_work = v4;
  if ( v2 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Successfully rolled work");
    applog(7, tmp42, 0);
  }
  ntime = work->ntime;
  if ( ntime )
  {
    hex2bin(tmp42, work->ntime, 4u);
    *(_DWORD *)tmp42 = bswap32(bswap32(*(unsigned int *)tmp42) + 1);
    _bin2hex(ntime, tmp42, 4u);
  }
  work->id = total_work_inc();
}

//----- (00021D74) --------------------------------------------------------
work *make_work()
{
  _DWORD *v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  v0 = cgcalloc(1, 0x1C0u, "cgminer.c", _func___13271, 2191);
  if ( !v0 )
  {
    strcpy((char *)tmp42, "Failed to calloc work in make_work");
    applog(3, tmp42, 1);
    quit(1);
  }
  v0[85] = total_work_inc();
  return (work *)v0;
}

//----- (00021DD8) --------------------------------------------------------
work *__fastcall copy_work_noffset(work *base_work, int noffset)
{
  work *work; // r4

  work = make_work();
  copy_work(work, base_work, noffset);
  return work;
}

//----- (00021DF0) --------------------------------------------------------
work *__fastcall make_clone(work *work)
{
  work *v1; // r4
  __time_t tv_sec; // r2
  work *result; // r0

  v1 = copy_work_noffset(work, 0);
  v1->clone = 1;
  cgtime(&v1->tv_cloned);
  tv_sec = v1->tv_staged.tv_sec;
  v1->longpoll = 0;
  result = v1;
  v1->mandatory = 0;
  v1->tv_staged.tv_sec = tv_sec - 1;
  return result;
}

//----- (00021E20) --------------------------------------------------------
uint64_t __fastcall share_diff(const work *work)
{
  double v2; // d8
  uint64_t v3; // r4
  const unsigned __int8 *v4; // r2
  int v5; // r3
  const unsigned __int8 *v6; // r2
  int v7; // r3
  int v8; // r8
  pool *pool; // r1
  uint64_t *p_best_diff; // r1
  uint64_t best_diff; // t1
  const unsigned __int8 *v12; // r2
  int v13; // r3
  const unsigned __int8 *v14; // r2
  int v15; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-820h] BYREF

  v2 = (double)*(unsigned __int64 *)&work->hash[24] * 6.27710174e57
     + (double)*(unsigned __int64 *)&work->hash[16] * 3.40282367e38
     + (double)*(unsigned __int64 *)&work->hash[8] * 1.84467441e19
     + (double)*(unsigned __int64 *)work->hash;
  if ( v2 == 0.0 )
    v2 = 0.0;
  round();
  v3 = (unsigned __int64)(2.69595353e67 / v2);
  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock_2((pthread_mutex_t *)&_func___13696, (const unsigned __int8 *)0x13BA, v4, v5);
  if ( pthread_rwlock_wrlock(&control_lock.rwlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___13696, (const unsigned __int8 *)0x13BA, v6, v7);
  if ( ::best_diff < v3 )
  {
    ::best_diff = (unsigned __int64)(2.69595353e67 / v2);
    v8 = 1;
    suffix_string(v3, best_share, 8u, 0);
  }
  else
  {
    v8 = 0;
  }
  pool = work->pool;
  best_diff = pool->best_diff;
  p_best_diff = &pool->best_diff;
  if ( best_diff < v3 )
    *p_best_diff = v3;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___13696, (const unsigned __int8 *)0x13C8, v12, v13);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13696, (const unsigned __int8 *)0x13C8, v14, v15);
  selective_yield();
  if ( v8 && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "New best share: %s", (const char *)best_share);
    applog(6, tmp42, 0);
  }
  return (unsigned __int64)(2.69595353e67 / v2);
}
// 21F14: variable 'v4' is possibly undefined
// 21F14: variable 'v5' is possibly undefined
// 21F4E: variable 'v14' is possibly undefined
// 21F4E: variable 'v15' is possibly undefined
// 21F5A: variable 'v12' is possibly undefined
// 21F5A: variable 'v13' is possibly undefined
// 21F86: variable 'v6' is possibly undefined
// 21F86: variable 'v7' is possibly undefined
// A2CC: using guessed type int round(void);

//----- (00021FE0) --------------------------------------------------------
void __fastcall update_work_stats(thr_info *thr, work *work)
{
  double v4; // d8
  unsigned __int64 v5; // r0
  const unsigned __int8 *v6; // r2
  int v7; // r3
  double device_diff; // d8
  cgpu_info *cgpu; // r5
  pool *v10; // r4
  const unsigned __int8 *v11; // r2
  int v12; // r3
  pool *pool; // r3
  unsigned int v14; // r0
  _BOOL4 v15; // r7
  int v16; // r6
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-820h] BYREF

  v4 = current_diff;
  v5 = share_diff(work);
  work->share_diff = v5;
  if ( v4 <= (double)v5 )
  {
    pool = work->pool;
    v14 = found_blocks;
    v15 = use_syslog;
    v16 = pool->solved + 1;
    work->block = 1;
    pool->solved = v16;
    found_blocks = v14 + 1;
    work->mandatory = 1;
    if ( v15 || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Found block for pool %d!", pool->pool_no);
      applog(5, tmp42, 0);
    }
  }
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13696.__size[12], (const unsigned __int8 *)0x2208, v6, v7);
  device_diff = work->device_diff;
  cgpu = thr->cgpu;
  total_diff1 = (__int64)((double)total_diff1 + device_diff);
  v10 = work->pool;
  cgpu->diff1 = (__int64)(device_diff + (double)cgpu->diff1);
  v10->diff1 = (__int64)(device_diff + (double)v10->diff1);
  cgpu->last_device_valid_work = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13696.__size[12], (const unsigned __int8 *)0x220D, v11, v12);
  selective_yield();
}
// 220F0: variable 'v11' is possibly undefined
// 220F0: variable 'v12' is possibly undefined
// 220FC: variable 'v6' is possibly undefined
// 220FC: variable 'v7' is possibly undefined

//----- (0002212C) --------------------------------------------------------
bool __fastcall submit_nonce_1(thr_info *thr, work *work, unsigned int nonce, int *nofull)
{
  bool result; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  if ( nofull )
    *nofull = 0;
  *(_DWORD *)&work->data[76] = nonce;
  regen_hash(work);
  if ( *(_DWORD *)&work->hash[28] )
  {
    inc_hw_errors(thr);
    return 0;
  }
  else
  {
    update_work_stats(thr, work);
    if ( fulltest(work->hash, work->target) )
    {
      return 1;
    }
    else
    {
      if ( nofull )
        *nofull = 1;
      if ( use_syslog || (result = opt_log_output) || opt_log_level > 5 )
      {
        strcpy((char *)tmp42, "Share above target");
        applog(6, tmp42, 0);
        return 0;
      }
    }
  }
  return result;
}

//----- (000221C0) --------------------------------------------------------
work *__fastcall clone_queued_work_bymidstate(
        cgpu_info *cgpu,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  pthread_rwlock_t *p_qlock; // r4
  const unsigned __int8 *v11; // r2
  int v12; // r3
  work *work_bymidstate; // r0
  work *v14; // r5
  const unsigned __int8 *v15; // r2
  int v16; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_rdlock(&cgpu->qlock) )
    rd_lock_0((pthread_rwlock_t *)&_func___14867, (const unsigned __int8 *)0x249A, v11, v12);
  work_bymidstate = _find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);
  v14 = work_bymidstate;
  if ( work_bymidstate )
    v14 = copy_work_noffset(work_bymidstate, 0);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14867, (const unsigned __int8 *)0x249E, v15, v16);
  selective_yield();
  return v14;
}
// 22218: variable 'v11' is possibly undefined
// 22218: variable 'v12' is possibly undefined
// 22224: variable 'v15' is possibly undefined
// 22224: variable 'v16' is possibly undefined

//----- (00022234) --------------------------------------------------------
void __fastcall gen_stratum_work(pool *pool, work *work)
{
  cglock_t *p_data_lock; // r9
  const unsigned __int8 *v5; // r2
  int v6; // r3
  const unsigned __int8 *v7; // r2
  int v8; // r3
  int nonce2_offset; // r5
  unsigned __int8 *coinbase; // r0
  unsigned int n2size; // r1
  uint64_t v12; // r4
  const unsigned __int8 *v13; // r2
  int v14; // r3
  const unsigned __int8 *v15; // r2
  int v16; // r3
  const unsigned __int8 *v17; // r2
  int v18; // r3
  int v19; // r11
  unsigned __int8 *v20; // r1
  int i; // r9
  unsigned __int8 *job_id; // r0
  const unsigned __int8 *v23; // r2
  int v24; // r3
  double v25; // r2
  double v26; // r2
  unsigned __int8 *v27; // r7
  unsigned __int8 *v28; // r0
  unsigned __int8 *v29; // r9
  pthread_rwlock_t *rwlock; // [sp+10h] [bp-898h]
  uint64_t nonce2le; // [sp+18h] [bp-890h] BYREF
  unsigned __int8 merkle_root[32]; // [sp+20h] [bp-888h] BYREF
  unsigned __int8 merkle_sha[64]; // [sp+40h] [bp-868h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+80h] [bp-828h] BYREF

  p_data_lock = &pool->data_lock;
  if ( pthread_mutex_lock(&pool->data_lock.mutex) )
    mutex_lock_2((pthread_mutex_t *)&_func___14522, (const unsigned __int8 *)0x202E, v5, v6);
  rwlock = &pool->data_lock.rwlock;
  if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___14522, (const unsigned __int8 *)0x202E, v7, v8);
  nonce2_offset = pool->nonce2_offset;
  coinbase = pool->coinbase;
  nonce2le = pool->nonce2;
  cg_memcpy(
    &coinbase[nonce2_offset],
    &nonce2le,
    pool->n2size,
    "cgminer.c",
    (const unsigned __int8 *)&_func___14522,
    8243);
  n2size = pool->n2size;
  v12 = pool->nonce2 + 1;
  work->nonce2 = pool->nonce2;
  pool->nonce2 = v12;
  work->nonce2_len = n2size;
  if ( pthread_rwlock_unlock(rwlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14522, (const unsigned __int8 *)0x2039, v13, v14);
  if ( pthread_rwlock_rdlock(rwlock) )
    rd_lock_0((pthread_rwlock_t *)&_func___14522, (const unsigned __int8 *)0x2039, v15, v16);
  if ( pthread_mutex_unlock(&p_data_lock->mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14522, (const unsigned __int8 *)0x2039, v17, v18);
  sha256(pool->coinbase, pool->coinbase_len, tmp42);
  sha256(tmp42, 0x20u, merkle_root);
  cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", (const unsigned __int8 *)&_func___14522, 8253);
  if ( pool->merkles > 0 )
  {
    v19 = 0;
    do
    {
      v20 = pool->swork.merkle_bin[v19++];
      cg_memcpy(&merkle_sha[32], v20, 0x20u, "cgminer.c", (const unsigned __int8 *)&_func___14522, 8257);
      sha256(merkle_sha, 0x40u, tmp42);
      sha256(tmp42, 0x20u, merkle_root);
      cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", (const unsigned __int8 *)&_func___14522, 8259);
    }
    while ( pool->merkles > v19 );
  }
  for ( i = 0; i != 32; i += 4 )
    *(_DWORD *)&merkle_root[i] = bswap32(*(_DWORD *)&merkle_sha[i]);
  cg_memcpy(work, pool->header_bin, 0x70u, "cgminer.c", (const unsigned __int8 *)&_func___14522, 8268);
  cg_memcpy(&work->data[36], merkle_root, 0x20u, "cgminer.c", (const unsigned __int8 *)&_func___14522, 8269);
  job_id = pool->swork.job_id;
  work->sdiff = pool->sdiff;
  work->job_id = (unsigned __int8 *)_strdup((const char *)job_id);
  work->nonce1 = (unsigned __int8 *)_strdup((const char *)pool->nonce1);
  work->ntime = (unsigned __int8 *)_strdup((const char *)pool->ntime);
  if ( pthread_rwlock_unlock(rwlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14522, (const unsigned __int8 *)0x2058, v23, v24);
  selective_yield();
  if ( opt_debug )
  {
    v27 = bin2hex(work->data, 0x70u);
    v28 = bin2hex(merkle_root, 0x20u);
    v29 = v28;
    if ( opt_debug )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_28;
      snprintf((char *)tmp42, 0x800u, "Generated stratum merkle %s", (const char *)v28);
      applog(7, tmp42, 0);
      if ( !opt_debug )
        goto LABEL_27;
      if ( !use_syslog && !opt_log_output )
      {
LABEL_28:
        if ( opt_log_level <= 6 )
          goto LABEL_29;
      }
      snprintf((char *)tmp42, 0x800u, "Generated stratum header %s", (const char *)v27);
      applog(7, tmp42, 0);
      if ( opt_debug )
      {
        if ( use_syslog || opt_log_output )
        {
LABEL_26:
          snprintf(
            (char *)tmp42,
            0x800u,
            "Work job_id %s nonce2 %llu ntime %s",
            (const char *)work->job_id,
            work->nonce2,
            (const char *)work->ntime);
          applog(7, tmp42, 0);
          goto LABEL_27;
        }
LABEL_29:
        if ( opt_log_level <= 6 )
          goto LABEL_27;
        goto LABEL_26;
      }
    }
LABEL_27:
    free(v27);
    free(v29);
  }
  calc_midstate(work);
  set_target(work->target, v25);
  ++local_work;
  if ( time(0) - local_work_lasttime > 5 )
  {
    local_work_lasttime = time(0);
    local_work_last = local_work;
  }
  *(_QWORD *)&v26 = work_block;
  work->pool = pool;
  work->work_block = LODWORD(v26);
  work->stratum = 1;
  work->nonce = 0;
  work->longpoll = 0;
  work->getwork_mode = 83;
  work->drv_rolllimit = 60;
  calc_diff(work, v26);
  cgtime(&work->tv_staged);
}
// 22400: variable 'v25' is possibly undefined
// 22576: variable 'v17' is possibly undefined
// 22576: variable 'v18' is possibly undefined
// 22582: variable 'v15' is possibly undefined
// 22582: variable 'v16' is possibly undefined
// 2258E: variable 'v23' is possibly undefined
// 2258E: variable 'v24' is possibly undefined
// 2259A: variable 'v5' is possibly undefined
// 2259A: variable 'v6' is possibly undefined
// 225A6: variable 'v13' is possibly undefined
// 225A6: variable 'v14' is possibly undefined
// 225B2: variable 'v7' is possibly undefined
// 225B2: variable 'v8' is possibly undefined

//----- (000225C0) --------------------------------------------------------
void __fastcall get_work_by_nonce2(
        thr_info *thr,
        work **work,
        pool *pool,
        pool *real_pool,
        uint64_t nonce2,
        unsigned int ntime,
        unsigned int version)
{
  cglock_t *p_data_lock; // r6
  int id; // r9
  const unsigned __int8 *v13; // r2
  int v14; // r3
  const unsigned __int8 *v15; // r2
  int v16; // r3
  const unsigned __int8 *v17; // r2
  int v18; // r3
  const unsigned __int8 *v19; // r2
  int v20; // r3
  unsigned int v21; // r1
  work *v22; // r3
  pool *v23; // r2

  p_data_lock = &pool->data_lock;
  *work = make_work();
  id = thr->id;
  if ( pthread_mutex_lock(&p_data_lock->mutex) )
    mutex_lock_2((pthread_mutex_t *)&_func___14522.__size[20], (const unsigned __int8 *)0x200F, v13, v14);
  if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
    wr_lock_0((pthread_rwlock_t *)(&_func___14522.__align + 5), (const unsigned __int8 *)0x200F, v15, v16);
  pool->nonce2 = nonce2;
  version = bswap32(version);
  cg_memcpy(pool->header_bin, &version, 4u, "cgminer.c", &_func___14522.__size[20], 8211);
  if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
    rw_unlock_1((pthread_rwlock_t *)(&_func___14522.__align + 5), (const unsigned __int8 *)0x2014, v17, v18);
  if ( pthread_mutex_unlock(&p_data_lock->mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14522.__size[20], (const unsigned __int8 *)0x2014, v19, v20);
  selective_yield();
  gen_stratum_work(pool, *work);
  v21 = version;
  (*work)->pool = real_pool;
  v22 = *work;
  v23 = (*work)->pool;
  v22->work_block = work_block;
  v22->thr_id = id;
  ++v23->works;
  v22->mined = 1;
  v22->version = v21;
}
// 22680: variable 'v13' is possibly undefined
// 22680: variable 'v14' is possibly undefined
// 2268C: variable 'v19' is possibly undefined
// 2268C: variable 'v20' is possibly undefined
// 22698: variable 'v17' is possibly undefined
// 22698: variable 'v18' is possibly undefined
// 226A4: variable 'v15' is possibly undefined
// 226A4: variable 'v16' is possibly undefined

//----- (000226BC) --------------------------------------------------------
work *__fastcall clone_queued_work_byid(cgpu_info *cgpu, unsigned int id)
{
  pthread_rwlock_t *p_qlock; // r6
  const unsigned __int8 *v5; // r2
  int v6; // r3
  work *queued_work; // r4
  work *next; // r0
  void *v9; // r4
  const unsigned __int8 *v10; // r2
  int v11; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_rdlock(&cgpu->qlock) )
    rd_lock_0((pthread_rwlock_t *)&_func___14890, (const unsigned __int8 *)0x24C9, v5, v6);
  queued_work = cgpu->queued_work;
  if ( queued_work )
  {
    next = (work *)queued_work->hh.next;
    if ( id == queued_work->id )
    {
      next = queued_work;
    }
    else
    {
      if ( !next )
      {
LABEL_7:
        queued_work = next;
        goto LABEL_8;
      }
      while ( 1 )
      {
        v9 = next->hh.next;
        if ( id == next->id )
          break;
        next = (work *)next->hh.next;
        if ( !v9 )
          goto LABEL_7;
      }
    }
    queued_work = copy_work_noffset(next, 0);
  }
LABEL_8:
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14890, (const unsigned __int8 *)0x24CD, v10, v11);
  selective_yield();
  return queued_work;
}
// 2271A: variable 'v5' is possibly undefined
// 2271A: variable 'v6' is possibly undefined
// 22726: variable 'v10' is possibly undefined
// 22726: variable 'v11' is possibly undefined

//----- (00022734) --------------------------------------------------------
thr_info *__fastcall get_thread(int thr_id)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  thr_info *v4; // r4
  const unsigned __int8 *v5; // r2
  int v6; // r3

  if ( pthread_rwlock_rdlock(&mining_thr_lock) )
    rd_lock_0((pthread_rwlock_t *)&_func___14890.__size[24], (const unsigned __int8 *)0x23E, v2, v3);
  v4 = mining_thr[thr_id];
  if ( pthread_rwlock_unlock(&mining_thr_lock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14890.__size[24], (const unsigned __int8 *)0x240, v5, v6);
  selective_yield();
  return v4;
}
// 22760: variable 'v2' is possibly undefined
// 22760: variable 'v3' is possibly undefined
// 2276C: variable 'v5' is possibly undefined
// 2276C: variable 'v6' is possibly undefined

//----- (00022784) --------------------------------------------------------
void _kill_work_0()
{
  int v0; // r4
  int v1; // r0
  thr_info *thread; // r0
  int v3; // r2
  cgpu_info *cgpu; // r3
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-820h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    strcpy((char *)tmp42, "Received kill message");
    applog(6, tmp42, 1);
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Killing off watchpool thread");
    applog(7, tmp42, 1);
  }
  cg_completion_timeout(thr_info_cancel, &control_thr[watchpool_thr_id], 1000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Killing off watchdog thread");
    applog(7, tmp42, 1);
  }
  cg_completion_timeout(thr_info_cancel, &control_thr[watchdog_thr_id], 1000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Shutting down mining threads");
    applog(7, tmp42, 1);
  }
  if ( mining_threads > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      thread = get_thread(v1);
      v3 = mining_threads;
      if ( thread )
      {
        cgpu = thread->cgpu;
        if ( cgpu )
          cgpu->shutdown = 1;
      }
    }
    while ( v0 < v3 );
  }
  sleep(1u);
  cg_completion_timeout(kill_mining, 0, 3000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Killing off API thread");
    applog(7, tmp42, 1);
  }
  cg_completion_timeout(thr_info_cancel, &control_thr[api_thr_id], 1000);
}

//----- (00022970) --------------------------------------------------------
void _kill_work()
{
  if ( successful_connect )
    _kill_work_0();
}

//----- (00022980) --------------------------------------------------------
void kill_mining()
{
  int v0; // r4
  pthread_t pth; // r0
  thr_info *thread; // r0
  thr_info *v3; // r5
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Killing off mining threads");
    applog(7, tmp42, 1);
  }
  if ( mining_threads > 0 )
  {
    v0 = 0;
    do
    {
      while ( 1 )
      {
        thread = get_thread(v0);
        v3 = thread;
        if ( thread )
        {
          if ( thread->pth )
            break;
        }
        ++v0;
        thr_info_cancel(thread);
        if ( mining_threads <= v0 )
          return;
      }
      thr_info_cancel(thread);
      pth = v3->pth;
      if ( pth )
        pthread_join(pth, 0);
      ++v0;
    }
    while ( mining_threads > v0 );
  }
}

//----- (00022A24) --------------------------------------------------------
int __fastcall dev_from_id(int thr_id)
{
  return get_thread(thr_id)->cgpu->device_id;
}

//----- (00022A30) --------------------------------------------------------
void __fastcall sharelog(const unsigned __int8 *disposition, const work *work)
{
  int thr_id; // r9
  cgpu_info *cgpu; // r10
  unsigned __int8 *v6; // r7
  unsigned __int8 *v7; // r6
  unsigned __int8 *v8; // r8
  int v9; // r4
  const unsigned __int8 *v10; // r2
  int v11; // r3
  size_t v12; // r4
  const unsigned __int8 *v13; // r2
  int v14; // r3
  const char *v15; // r5
  int v16; // r0
  int v17; // r1
  int v18; // r2
  int v19; // r3
  _DWORD *v20; // r5
  int v21; // r1
  __time_t tv_sec; // [sp+20h] [bp-C30h]
  pool *pool; // [sp+24h] [bp-C2Ch]
  unsigned __int8 s[1024]; // [sp+28h] [bp-C28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+428h] [bp-828h] BYREF

  if ( !sharelog_file )
    return;
  thr_id = work->thr_id;
  cgpu = get_thread(thr_id)->cgpu;
  pool = work->pool;
  tv_sec = work->tv_work_found.tv_sec;
  v6 = bin2hex(work->target, 0x20u);
  v7 = bin2hex(work->hash, 0x20u);
  v8 = bin2hex(work->data, 0x80u);
  v9 = snprintf(
         (char *)s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         tv_sec,
         (const char *)disposition,
         (const char *)v6,
         (const char *)pool->rpc_url,
         (const char *)cgpu->drv->name,
         cgpu->device_id,
         thr_id,
         (const char *)v7,
         (const char *)v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 < 1024 )
  {
    if ( v9 < 0 )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        return;
      v15 = "sharelog printf error";
LABEL_11:
      v16 = *(_DWORD *)v15;
      v17 = *((_DWORD *)v15 + 1);
      v18 = *((_DWORD *)v15 + 2);
      v19 = *((_DWORD *)v15 + 3);
      v20 = v15 + 16;
      *(_DWORD *)tmp42 = v16;
      *(_DWORD *)&tmp42[4] = v17;
      *(_DWORD *)&tmp42[8] = v18;
      *(_DWORD *)&tmp42[12] = v19;
      v21 = v20[1];
      *(_DWORD *)&tmp42[16] = *v20;
      *(_WORD *)&tmp42[20] = v21;
      applog(3, tmp42, 0);
      return;
    }
  }
  else
  {
    s[1023] = 0;
  }
  if ( pthread_mutex_lock(&sharelog_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___12458, (const unsigned __int8 *)0x282, v10, v11);
  v12 = fwrite(s, v9, 1u, sharelog_file);
  fflush(sharelog_file);
  if ( pthread_mutex_unlock(&sharelog_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___12458, (const unsigned __int8 *)0x285, v13, v14);
  selective_yield();
  if ( v12 != 1 && (use_syslog || opt_log_output || opt_log_level > 2) )
  {
    v15 = "sharelog fwrite error";
    goto LABEL_11;
  }
}
// 22B72: variable 'v13' is possibly undefined
// 22B72: variable 'v14' is possibly undefined
// 22B7E: variable 'v10' is possibly undefined
// 22B7E: variable 'v11' is possibly undefined

//----- (00022BAC) --------------------------------------------------------
cgpu_info *__fastcall get_devices(int id)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  cgpu_info *v4; // r4
  const unsigned __int8 *v5; // r2
  int v6; // r3

  if ( pthread_rwlock_rdlock(&devices_lock) )
    rd_lock_0((pthread_rwlock_t *)(&_func___12458.__align + 3), (const unsigned __int8 *)0x252, v2, v3);
  v4 = devices[id];
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock_1((pthread_rwlock_t *)(&_func___12458.__align + 3), (const unsigned __int8 *)0x254, v5, v6);
  selective_yield();
  return v4;
}
// 22BD8: variable 'v2' is possibly undefined
// 22BD8: variable 'v3' is possibly undefined
// 22BE4: variable 'v5' is possibly undefined
// 22BE4: variable 'v6' is possibly undefined

//----- (00022BFC) --------------------------------------------------------
void zero_stats()
{
  int v0; // r4
  char *v1; // r0
  int *v2; // r3
  pool **v3; // r2
  pool **v4; // r5
  int v5; // t1
  int v6; // r7
  int v7; // r0
  cgpu_info *devices; // r6
  const unsigned __int8 *v9; // r2
  int v10; // r3
  const unsigned __int8 *v11; // r2
  int v12; // r3
  sysinfo sInfo; // [sp+8h] [bp-868h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+48h] [bp-828h] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v0 = *_errno_location();
      v1 = strerror(v0);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
      applog(6, tmp42, 0);
    }
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
  }
  cgtime(&total_tv_start);
  copy_time(&tv_hashmeter, &total_tv_start);
  v2 = (int *)g_local_mhashes_dones;
  rolling5 = 0.0;
  total_rolling = 0.0;
  rolling1 = 0.0;
  rolling15 = 0.0;
  total_mhashes_done = 0.0;
  new_total_mhashes_done = 0.0;
  do
  {
    *(_QWORD *)v2 = 0LL;
    v2 += 2;
  }
  while ( v2 != &g_local_mhashes_index );
  total_secs = 1.0;
  new_total_secs = 1.0;
  last_total_secs = 1.0;
  g_max_fan = 0;
  total_diff_accepted = 0.0;
  total_diff_rejected = 0.0;
  total_diff_stale = 0.0;
  g_max_temp = 0;
  g_local_mhashes_index = 0;
  hw_errors = 0;
  local_work = 0;
  total_go = 0;
  total_ro = 0;
  found_blocks = 0;
  total_getworks = 0LL;
  total_accepted = 0LL;
  total_rejected = 0LL;
  total_stale = 0LL;
  total_discarded = 0LL;
  total_diff1 = 0LL;
  if ( total_pools > 0 )
  {
    v3 = pools;
    v4 = &pools[total_pools];
    do
    {
      v5 = (int)*v3++;
      *(_DWORD *)(v5 + 116) = 0;
      *(_DWORD *)(v5 + 8) = 0;
      *(_DWORD *)(v5 + 12) = 0;
      *(_DWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v5 + 20) = 0;
      *(_DWORD *)(v5 + 120) = 0;
      *(_DWORD *)(v5 + 124) = 0;
      *(_DWORD *)(v5 + 128) = 0;
      *(_DWORD *)(v5 + 132) = 0;
      *(_DWORD *)(v5 + 352) = 0;
      *(_DWORD *)(v5 + 40) = 0;
      *(_DWORD *)(v5 + 44) = 0;
      *(_QWORD *)(v5 + 72) = 0LL;
      *(_QWORD *)(v5 + 80) = 0LL;
      *(_QWORD *)(v5 + 88) = 0LL;
      *(_QWORD *)(v5 + 360) = 0LL;
    }
    while ( v3 != v4 );
  }
  zero_bestshare();
  if ( total_devices > 0 )
  {
    v6 = 0;
    do
    {
      v7 = v6++;
      devices = get_devices(v7);
      copy_time(&devices->dev_start_tv, &total_tv_start);
      if ( pthread_mutex_lock(&hash_lock) )
        mutex_lock_2((pthread_mutex_t *)&_func___14098, (const unsigned __int8 *)0x17B6, v9, v10);
      devices->accepted = 0;
      devices->rejected = 0;
      devices->total_mhashes = 0.0;
      devices->hw_errors = 0;
      devices->utility = 0.0;
      devices->last_share_pool_time = 0;
      devices->diff1 = 0LL;
      devices->diff_accepted = 0.0;
      devices->diff_rejected = 0.0;
      devices->last_share_diff = 0.0;
      if ( pthread_mutex_unlock(&hash_lock) )
        mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14098, (const unsigned __int8 *)0x17C3, v11, v12);
      selective_yield();
      devices->drv->zero_stats(devices);
    }
    while ( total_devices > v6 );
  }
}
// 22E50: variable 'v9' is possibly undefined
// 22E50: variable 'v10' is possibly undefined
// 22E5C: variable 'v11' is possibly undefined
// 22E5C: variable 'v12' is possibly undefined

//----- (00022EF0) --------------------------------------------------------
void __fastcall hashmeter(int thr_id, int a2, uint64_t hashes_done)
{
  double v3; // d0
  int v5; // r4
  char *v6; // r0
  __time_t tv_sec; // r10
  thr_info *thread; // r0
  cgpu_info *cgpu; // r5
  unsigned __int64 v10; // kr00_8
  double v11; // r2
  double v12; // r0
  double v13; // r0
  double v14; // r2
  double v15; // r0
  double v16; // r2
  double v17; // r0
  double v18; // r2
  const unsigned __int8 *v19; // r2
  int v20; // r3
  const unsigned __int8 *v21; // r2
  int v22; // r3
  int v23; // r3
  int v24; // r5
  unsigned __int64 v25; // r8
  double v26; // r2
  int *v27; // r11
  double v28; // d8
  unsigned __int64 v29; // r0
  double v30; // r0
  double v31; // r0
  double v32; // r2
  double v33; // r0
  double v34; // r2
  double v35; // r0
  double v36; // r2
  double v37; // d6
  int v38; // r3
  double v39; // d9
  double v40; // d6
  double v41; // d7
  double v42; // d4
  double v43; // d7
  int v44; // r3
  const unsigned __int8 *v45; // r2
  int v46; // r3
  const unsigned __int8 *v47; // r2
  int v48; // r3
  const unsigned __int8 *v49; // r2
  int v50; // r3
  const unsigned __int8 *v52; // r2
  int v53; // r3
  int v54; // r7
  int v55; // r0
  cgpu_info *v56; // r5
  double v57; // r0
  double v58; // r2
  double v59; // r0
  double v60; // r2
  double v61; // r0
  double v62; // r2
  double v63; // r0
  double v64; // r2
  const unsigned __int8 *v65; // r2
  int v66; // r3
  double sigdigits; // [sp+0h] [bp-8F8h]
  double sigdigitsa; // [sp+0h] [bp-8F8h]
  double sigdigitsb; // [sp+0h] [bp-8F8h]
  double sigdigitsc; // [sp+0h] [bp-8F8h]
  double sigdigitsd; // [sp+0h] [bp-8F8h]
  double sigdigitse; // [sp+0h] [bp-8F8h]
  double sigdigitsf; // [sp+0h] [bp-8F8h]
  double sigdigitsg; // [sp+0h] [bp-8F8h]
  double sigdigitsh; // [sp+0h] [bp-8F8h]
  double sigdigitsi; // [sp+0h] [bp-8F8h]
  double v77; // [sp+8h] [bp-8F0h]
  double v78; // [sp+8h] [bp-8F0h]
  double v79; // [sp+8h] [bp-8F0h]
  double v80; // [sp+8h] [bp-8F0h]
  double v81; // [sp+8h] [bp-8F0h]
  double v82; // [sp+8h] [bp-8F0h]
  double v83; // [sp+8h] [bp-8F0h]
  double v84; // [sp+8h] [bp-8F0h]
  double v85; // [sp+8h] [bp-8F0h]
  double v86; // [sp+8h] [bp-8F0h]
  int v87; // [sp+24h] [bp-8D4h]
  unsigned __int8 displayed_hashes[16]; // [sp+38h] [bp-8C0h] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+48h] [bp-8B0h] BYREF
  unsigned __int8 displayed_r1[16]; // [sp+58h] [bp-8A0h] BYREF
  unsigned __int8 displayed_r5[16]; // [sp+68h] [bp-890h] BYREF
  sysinfo sInfo; // [sp+78h] [bp-880h] BYREF
  unsigned __int8 displayed_r15[16]; // [sp+B8h] [bp-840h] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v5 = *_errno_location();
      v6 = strerror(v5);
      snprintf((char *)displayed_r15, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v5, v6);
      applog(6, displayed_r15, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
  }
  cgtime(&total_tv_end);
  tdiff(&total_tv_end, &tv_hashmeter);
  tv_sec = total_tv_end.tv_sec;
  if ( total_tv_end.tv_sec - hashdisplay_t < opt_log_interval )
  {
    if ( thr_id < 0 )
      return;
    copy_time(&tv_hashmeter, &total_tv_end);
    v87 = 0;
    goto LABEL_11;
  }
  hashdisplay_t = total_tv_end.tv_sec;
  copy_time(&tv_hashmeter, &total_tv_end);
  if ( thr_id >= 0 )
  {
    v87 = 1;
LABEL_11:
    thread = get_thread(thr_id);
    cgpu = thread->cgpu;
    copy_time(&thread->last, &total_tv_end);
    cgpu->device_last_well = tv_sec;
    tdiff(&total_tv_end, &cgpu->last_message_tv);
    copy_time(&cgpu->last_message_tv, &total_tv_end);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)displayed_r15,
        0x800u,
        "[thread %d: %llu hashes, %.1f mhash/sec]",
        thr_id,
        hashes_done,
        (double)hashes_done / v3 / 1000000.0);
      applog(7, displayed_r15, 0);
    }
    v10 = hashes_done / (unsigned int)&::cgpu.results[29][3663];
    hashes_done = v10;
    if ( pthread_mutex_lock(&hash_lock) )
      mutex_lock_2(
        (pthread_mutex_t *)&_func___14098.__size[12],
        (const unsigned __int8 *)0x1B2D,
        (const unsigned __int8 *)LODWORD(v11),
        SHIDWORD(v11));
    LODWORD(v12) = &cgpu->rolling;
    HIDWORD(v12) = opt_log_interval;
    cgpu->total_mhashes = cgpu->total_mhashes + (double)v10;
    decay_time(v12, v11, sigdigits, v77);
    LODWORD(v13) = &cgpu->rolling1;
    decay_time(v13, v14, sigdigitsa, v78);
    LODWORD(v15) = &cgpu->rolling5;
    decay_time(v15, v16, sigdigitsb, v79);
    LODWORD(v17) = &cgpu->rolling15;
    decay_time(v17, v18, sigdigitsc, v80);
    if ( pthread_mutex_unlock(&hash_lock) )
      mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14098.__size[12], (const unsigned __int8 *)0x1B34, v19, v20);
    selective_yield();
    if ( want_per_device_stats && v87 )
    {
      get_statline(displayed_r15, 0x100u, cgpu);
      printf("%s          \r", (const char *)displayed_r15);
      fflush((FILE *)stdout);
    }
    goto LABEL_15;
  }
  if ( pthread_mutex_lock(&hash_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___14098.__size[12], (const unsigned __int8 *)0x1B4A, v52, v53);
  if ( mining_threads > 0 )
  {
    v54 = 0;
    do
    {
      v55 = v54++;
      v56 = get_thread(v55)->cgpu;
      tdiff(&total_tv_end, &v56->last_message_tv);
      copy_time(&v56->last_message_tv, &total_tv_end);
      HIDWORD(v57) = opt_log_interval;
      LODWORD(v57) = &v56->rolling;
      decay_time(v57, v58, sigdigits, v77);
      LODWORD(v59) = &v56->rolling1;
      decay_time(v59, v60, sigdigitsg, v84);
      LODWORD(v61) = &v56->rolling5;
      decay_time(v61, v62, sigdigitsh, v85);
      LODWORD(v63) = &v56->rolling15;
      decay_time(v63, v64, sigdigitsi, v86);
    }
    while ( mining_threads > v54 );
  }
  if ( pthread_mutex_unlock(&hash_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14098.__size[12], (const unsigned __int8 *)0x1B59, v65, v66);
  v87 = 1;
  selective_yield();
LABEL_15:
  if ( pthread_mutex_lock(&hash_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___14098.__size[12], (const unsigned __int8 *)0x1B5C, v21, v22);
  total_mhashes_done = (double)hashes_done + total_mhashes_done;
  if ( v87 )
  {
    v23 = g_local_mhashes_index + 1;
    v24 = 0;
    if ( g_local_mhashes_index + 1 > 11 )
      v23 = 0;
    v25 = 0LL;
    g_local_mhashes_index = v23;
    HIDWORD(v26) = g_local_mhashes_dones;
    v27 = (int *)g_local_mhashes_dones;
    do
    {
      v28 = *(double *)v27;
      v27 += 2;
      if ( v28 >= 0.0 )
      {
        ++v24;
        v25 = (unsigned __int64)(v28 + (double)v25);
      }
    }
    while ( v27 != &g_local_mhashes_index );
    if ( v24 )
    {
      *(_QWORD *)&v26 = v25 % v24;
      v29 = v25 / v24;
    }
    else
    {
      v29 = hashes_done;
    }
    LODWORD(v26) = opt_log_interval;
    v30 = (double)v29;
    LODWORD(v30) = &total_rolling;
    decay_time(v30, v26, sigdigits, v77);
    LODWORD(v31) = &rolling1;
    decay_time(v31, v32, sigdigitsd, v81);
    LODWORD(v33) = &rolling5;
    decay_time(v33, v34, sigdigitse, v82);
    LODWORD(v35) = &rolling15;
    decay_time(v35, v36, sigdigitsf, v83);
    global_hashrate = (unsigned __int64)(total_rolling * 1000000.0);
    v37 = 0.0;
    v38 = g_local_mhashes_index;
    g_local_mhashes_dones[g_local_mhashes_index] = 0.0;
  }
  else
  {
    v38 = g_local_mhashes_index;
    v37 = g_local_mhashes_dones[g_local_mhashes_index];
  }
  v39 = (double)hashes_done + v37;
  v40 = last_total_secs;
  v41 = (double)total_tv_start_sys;
  v42 = (double)total_tv_end_sys;
  g_local_mhashes_dones[v38] = v39;
  v43 = v42 - v41;
  total_secs = v43;
  if ( v43 - v40 > 86400.0 )
  {
    v44 = use_syslog;
    if ( use_syslog || (v44 = opt_log_output) != 0 || (v44 = opt_log_level, opt_log_level > 2) )
    {
      snprintf(
        (char *)displayed_r15,
        0x800u,
        "cgminer time error total_secs = %d last_total_secs = %d",
        v44,
        LODWORD(v43));
      applog(3, displayed_r15, 0);
    }
    if ( pthread_mutex_unlock(&hash_lock) )
      mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14098.__size[12], (const unsigned __int8 *)0x1B8C, v45, v46);
    selective_yield();
    zero_stats();
    if ( pthread_mutex_lock(&hash_lock) )
      mutex_lock_2((pthread_mutex_t *)&_func___14098.__size[12], (const unsigned __int8 *)0x1B8E, v47, v48);
    if ( !v87 )
      goto LABEL_36;
    goto LABEL_53;
  }
  last_total_secs = v43;
  if ( v87 )
  {
LABEL_53:
    suffix_string((unsigned __int64)(total_mhashes_done / total_secs * 1000000.0), displayed_hashes, 0x10u, 4);
    g_displayed_rolling = (double)((int)total_rolling / 10) / 100.0;
    suffix_string((unsigned __int64)(total_rolling * 1000000.0), displayed_rolling, 0x10u, 4);
    suffix_string((unsigned __int64)(rolling1 * 1000000.0), displayed_r1, 0x10u, 4);
    suffix_string((unsigned __int64)(rolling5 * 1000000.0), displayed_r5, 0x10u, 4);
    suffix_string((unsigned __int64)(rolling15 * 1000000.0), displayed_r15, 0x10u, 4);
    snprintf(
      (char *)statusline,
      0x100u,
      "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
      opt_log_interval,
      (const char *)displayed_rolling,
      (const char *)displayed_r1,
      (const char *)displayed_r5,
      (const char *)displayed_r15,
      (const char *)displayed_hashes);
  }
LABEL_36:
  if ( pthread_mutex_unlock(&hash_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14098.__size[12], (const unsigned __int8 *)0x1BB7, v49, v50);
  selective_yield();
  if ( v87 )
  {
    printf("%s          \r", (const char *)statusline);
    fflush((FILE *)stdout);
  }
}
// 23034: variable 'v11' is possibly undefined
// 23034: variable 'sigdigits' is possibly undefined
// 23034: variable 'v77' is possibly undefined
// 23048: variable 'v13' is possibly undefined
// 23048: variable 'v14' is possibly undefined
// 23048: variable 'sigdigitsa' is possibly undefined
// 23048: variable 'v78' is possibly undefined
// 2305C: variable 'v15' is possibly undefined
// 2305C: variable 'v16' is possibly undefined
// 2305C: variable 'sigdigitsb' is possibly undefined
// 2305C: variable 'v79' is possibly undefined
// 23070: variable 'v17' is possibly undefined
// 23070: variable 'v18' is possibly undefined
// 23070: variable 'sigdigitsc' is possibly undefined
// 23070: variable 'v80' is possibly undefined
// 23166: variable 'v31' is possibly undefined
// 23166: variable 'v32' is possibly undefined
// 23166: variable 'sigdigitsd' is possibly undefined
// 23166: variable 'v81' is possibly undefined
// 23178: variable 'v33' is possibly undefined
// 23178: variable 'v34' is possibly undefined
// 23178: variable 'sigdigitse' is possibly undefined
// 23178: variable 'v82' is possibly undefined
// 2318A: variable 'v35' is possibly undefined
// 2318A: variable 'v36' is possibly undefined
// 2318A: variable 'sigdigitsf' is possibly undefined
// 2318A: variable 'v83' is possibly undefined
// 23370: variable 'v3' is possibly undefined
// 233E8: variable 'v58' is possibly undefined
// 233FC: variable 'v59' is possibly undefined
// 233FC: variable 'v60' is possibly undefined
// 233FC: variable 'sigdigitsg' is possibly undefined
// 233FC: variable 'v84' is possibly undefined
// 23410: variable 'v61' is possibly undefined
// 23410: variable 'v62' is possibly undefined
// 23410: variable 'sigdigitsh' is possibly undefined
// 23410: variable 'v85' is possibly undefined
// 23424: variable 'v63' is possibly undefined
// 23424: variable 'v64' is possibly undefined
// 23424: variable 'sigdigitsi' is possibly undefined
// 23424: variable 'v86' is possibly undefined
// 235F6: variable 'v21' is possibly undefined
// 235F6: variable 'v22' is possibly undefined
// 23602: variable 'v49' is possibly undefined
// 23602: variable 'v50' is possibly undefined
// 2360E: variable 'v65' is possibly undefined
// 2360E: variable 'v66' is possibly undefined
// 2361A: variable 'v19' is possibly undefined
// 2361A: variable 'v20' is possibly undefined
// 23626: variable 'v52' is possibly undefined
// 23626: variable 'v53' is possibly undefined
// 23632: variable 'v47' is possibly undefined
// 23632: variable 'v48' is possibly undefined
// 2364A: variable 'v45' is possibly undefined
// 2364A: variable 'v46' is possibly undefined
// 6298C: using guessed type int stdout;

//----- (00023680) --------------------------------------------------------
void __fastcall hash_driver_work(thr_info *mythr)
{
  int id; // r10
  uint64_t v3; // r4
  cgpu_info *cgpu; // r7
  device_drv *drv; // r8
  bool i; // r11
  int64_t (*scanwork)(thr_info *); // r2
  __int64 v8; // r0
  bool v9; // zf
  int v10; // r3
  int v11; // r1
  uint64_t v12; // r2
  const unsigned __int8 *v13; // r2
  int v14; // r3
  const unsigned __int8 *v15; // r2
  int v16; // r3
  timeval tv_start; // [sp+10h] [bp-838h] BYREF
  timeval tv_end; // [sp+18h] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-828h] BYREF

  id = mythr->id;
  v3 = 0LL;
  cgpu = mythr->cgpu;
  tv_start.tv_sec = 0;
  drv = cgpu->drv;
  tv_start.tv_usec = 0;
LABEL_2:
  for ( i = cgpu->shutdown; !i; i = cgpu->shutdown )
  {
    scanwork = drv->scanwork;
    mythr->work_update = i;
    v8 = scanwork(mythr);
    v9 = HIDWORD(v8) == -1;
    if ( HIDWORD(v8) == -1 )
      v9 = (_DWORD)v8 == -1;
    mythr->work_restart = i;
    if ( v9 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = DEV_DISABLED;
      dev_error(cgpu, REASON_THREAD_ZERO_HASH);
      break;
    }
    v3 += v8;
    cgtime(&tv_end);
    v10 = tv_end.tv_usec - tv_start.tv_usec + (tv_end.tv_usec - tv_start.tv_usec < 0 ? 0xF4000 : 0);
    v11 = tv_end.tv_sec - tv_start.tv_sec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      v10 += 576;
      --v11;
    }
    if ( v3 && (v11 > 0 || v10 > (int)&off_30D40) || opt_log_interval <= v11 )
    {
      v12 = v3;
      v3 = 0LL;
      hashmeter(id, v11, v12);
      copy_time(&tv_start, &tv_end);
      if ( mythr->pause )
        goto LABEL_20;
    }
    else if ( mythr->pause )
    {
LABEL_20:
      mt_disable(mythr, id, drv);
      goto LABEL_12;
    }
    if ( cgpu->deven )
      goto LABEL_20;
LABEL_12:
    if ( !mythr->work_update )
      goto LABEL_2;
    if ( pthread_mutex_lock(&update_job_lock) )
      mutex_lock_2((pthread_mutex_t *)&_func___14958, (const unsigned __int8 *)0x259B, v13, v14);
    drv->update_work(cgpu);
    if ( pthread_mutex_unlock(&update_job_lock) )
      mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14958, (const unsigned __int8 *)0x259D, v15, v16);
    selective_yield();
  }
  cgpu->deven = DEV_DISABLED;
}
// 237DC: variable 'v15' is possibly undefined
// 237DC: variable 'v16' is possibly undefined
// 237E8: variable 'v13' is possibly undefined
// 237E8: variable 'v14' is possibly undefined
// 30D40: using guessed type char (*off_30D40)[16];

//----- (0002380C) --------------------------------------------------------
void print_summary()
{
  int v0; // r3
  int v1; // r5
  int v2; // r4
  int v3; // r7
  double v4; // d10
  double v5; // d9
  int v6; // r11
  pool *v7; // r7
  int solved; // r4
  _BOOL4 v9; // r2
  int64_t accepted; // r2
  int v11; // r11
  int v12; // r0
  cgpu_info *devices; // r0
  device_drv *drv; // r3
  int v15; // r2
  double v16; // d7
  _BOOL4 v17; // r3
  int v18; // r3
  const char *v19; // r4
  unsigned __int8 buf[256]; // [sp+20h] [bp-940h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+120h] [bp-840h] BYREF

  v0 = total_tv_end.tv_sec - total_tv_start.tv_sec;
  if ( total_tv_end.tv_usec - total_tv_start.tv_usec < 0 )
    --v0;
  v1 = v0 / 3600;
  v2 = v0 % 60;
  v3 = v0 % 3600 / 60;
  v4 = (double)total_accepted / total_secs * 60.0;
  v5 = (double)total_diff1 / total_secs * 60.0;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "\nSummary of runtime statistics:\n");
    applog(4, tmp42, 0);
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Started at %s", (const char *)datestamp);
      applog(4, tmp42, 0);
    }
    if ( total_pools != 1 )
      goto LABEL_9;
  }
  else if ( total_pools != 1 )
  {
    goto LABEL_9;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
    goto LABEL_28;
  snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)(*pools)->rpc_url);
  applog(4, tmp42, 0);
LABEL_9:
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Runtime: %d hrs : %d mins : %d secs", v1, v3, v2);
    applog(4, tmp42, 0);
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Average hashrate: %.1f Mhash/s", total_mhashes_done / total_secs);
      applog(4, tmp42, 0);
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Solved blocks: %d", found_blocks);
        applog(4, tmp42, 0);
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf((char *)tmp42, 0x800u, "Best share difficulty: %s", (const char *)best_share);
          applog(4, tmp42, 0);
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf((char *)tmp42, 0x800u, "Share submissions: %lld", total_rejected + total_accepted);
            applog(4, tmp42, 0);
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf((char *)tmp42, 0x800u, "Accepted shares: %lld", total_accepted);
              applog(4, tmp42, 0);
              if ( use_syslog || opt_log_output || opt_log_level > 3 )
              {
                snprintf((char *)tmp42, 0x800u, "Rejected shares: %lld", total_rejected);
                applog(4, tmp42, 0);
                if ( use_syslog || opt_log_output || opt_log_level > 3 )
                {
                  snprintf((char *)tmp42, 0x800u, "Accepted difficulty shares: %1.f", total_diff_accepted);
                  applog(4, tmp42, 0);
                  if ( use_syslog || opt_log_output || opt_log_level > 3 )
                  {
                    snprintf((char *)tmp42, 0x800u, "Rejected difficulty shares: %1.f", total_diff_rejected);
                    applog(4, tmp42, 0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_28:
  if ( total_accepted || total_rejected )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      goto LABEL_50;
    snprintf(
      (char *)tmp42,
      0x800u,
      "Reject ratio: %.1f%%",
      (double)(100 * total_rejected) / (double)(total_accepted + total_rejected));
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Hardware errors: %d", hw_errors);
    applog(4, tmp42, 0);
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Utility (accepted shares / min): %.2f/min", v4);
      applog(4, tmp42, 0);
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v5);
        applog(4, tmp42, 0);
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf((char *)tmp42, 0x800u, "Stale submissions discarded due to new blocks: %lld", total_stale);
          applog(4, tmp42, 0);
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf((char *)tmp42, 0x800u, "Unable to get work from server occasions: %d", total_go);
            applog(4, tmp42, 0);
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf((char *)tmp42, 0x800u, "Work items generated locally: %d", local_work);
              applog(4, tmp42, 0);
              if ( use_syslog || opt_log_output || opt_log_level > 3 )
              {
                snprintf((char *)tmp42, 0x800u, "Submitting work remotely delay occasions: %d", total_ro);
                applog(4, tmp42, 0);
                if ( use_syslog || opt_log_output || opt_log_level > 3 )
                {
                  snprintf((char *)tmp42, 0x800u, "New blocks detected on network: %d\n", new_blocks);
                  applog(4, tmp42, 0);
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_50:
  if ( total_pools > 1 )
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = pools[v6];
      if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
        break;
      snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)v7->rpc_url);
      applog(4, tmp42, 0);
      solved = v7->solved;
      v9 = use_syslog;
      if ( !solved )
        goto LABEL_104;
      if ( !use_syslog )
        goto LABEL_59;
LABEL_100:
      v18 = solved;
      if ( solved > 1 )
        v19 = (const char *)"S";
      else
        v19 = "";
      snprintf((char *)tmp42, 0x800u, "SOLVED %d BLOCK%s!", v18, v19);
      applog(4, tmp42, 0);
      v9 = use_syslog;
LABEL_104:
      if ( !v9 )
      {
LABEL_105:
        if ( !opt_log_output && opt_log_level <= 3 )
          goto LABEL_61;
      }
      snprintf((char *)tmp42, 0x800u, " Share submissions: %lld", v7->accepted + v7->rejected);
      applog(4, tmp42, 0);
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Accepted shares: %lld", v7->accepted);
        applog(4, tmp42, 0);
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf((char *)tmp42, 0x800u, " Rejected shares: %lld", v7->rejected);
          applog(4, tmp42, 0);
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf((char *)tmp42, 0x800u, " Accepted difficulty shares: %1.f", v7->diff_accepted);
            applog(4, tmp42, 0);
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf((char *)tmp42, 0x800u, " Rejected difficulty shares: %1.f", v7->diff_rejected);
              applog(4, tmp42, 0);
            }
          }
        }
      }
LABEL_61:
      accepted = v7->accepted;
      if ( !accepted && !v7->rejected )
        goto LABEL_67;
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          " Reject ratio: %.1f%%",
          (double)(100 * v7->rejected) / (double)(accepted + v7->rejected));
        applog(4, tmp42, 0);
LABEL_67:
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf((char *)tmp42, 0x800u, " Items worked on: %d", v7->works);
          applog(4, tmp42, 0);
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf((char *)tmp42, 0x800u, " Stale submissions discarded due to new blocks: %d", v7->stale_shares);
            applog(4, tmp42, 0);
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf((char *)tmp42, 0x800u, " Unable to get work from server occasions: %d", v7->getfail_occasions);
              applog(4, tmp42, 0);
              if ( use_syslog || opt_log_output || opt_log_level > 3 )
              {
                snprintf(
                  (char *)tmp42,
                  0x800u,
                  " Submitting work remotely delay occasions: %d\n",
                  v7->remotefail_occasions);
                applog(4, tmp42, 0);
              }
            }
          }
        }
      }
      if ( total_pools <= ++v6 )
        goto LABEL_77;
    }
    solved = v7->solved;
    if ( !solved )
      goto LABEL_105;
LABEL_59:
    if ( !opt_log_output && opt_log_level <= 3 )
      goto LABEL_61;
    goto LABEL_100;
  }
LABEL_77:
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Summary of per device statistics:\n");
    applog(4, tmp42, 0);
  }
  if ( total_devices > 0 )
  {
    v11 = 0;
    do
    {
      v12 = v11++;
      devices = get_devices(v12);
      drv = devices->drv;
      drv->get_statline_before = blank_get_statline_before;
      drv->get_statline = noop_get_statline;
      get_statline(buf, 0xFFu, devices);
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "%s", buf);
        applog(4, tmp42, 0);
      }
    }
    while ( total_devices > v11 );
  }
  v15 = opt_shares;
  if ( !opt_shares )
    goto LABEL_95;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Mined %.0f accepted shares of %d requested\n", total_diff_accepted, opt_shares);
    applog(4, tmp42, 0);
    v16 = total_diff_accepted;
    v17 = use_syslog;
    v15 = opt_shares;
    if ( (double)opt_shares <= total_diff_accepted )
      goto LABEL_96;
    if ( use_syslog )
      goto LABEL_94;
  }
  else
  {
    v16 = total_diff_accepted;
    if ( (double)opt_shares <= total_diff_accepted )
    {
LABEL_97:
      if ( !opt_log_output && opt_log_level <= 3 )
        goto LABEL_99;
LABEL_98:
      strcpy((char *)tmp42, " ");
      applog(4, tmp42, 0);
      goto LABEL_99;
    }
  }
  if ( opt_log_output || opt_log_level > 3 )
  {
LABEL_94:
    snprintf((char *)tmp42, 0x800u, "WARNING - Mined only %.0f shares of %d requested.", v16, v15);
    applog(4, tmp42, 0);
LABEL_95:
    v17 = use_syslog;
LABEL_96:
    if ( v17 )
      goto LABEL_98;
    goto LABEL_97;
  }
LABEL_99:
  fflush((FILE *)stderr);
  fflush((FILE *)stdout);
}
// 6298C: using guessed type int stdout;
// 62990: using guessed type int stderr;

//----- (0002441C) --------------------------------------------------------
void __fastcall clean_up(bool restarting)
{
  _BOOL4 v1; // r4
  int v2; // r5
  char *v3; // r0
  sysinfo sInfo; // [sp+8h] [bp-850h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+48h] [bp-810h] BYREF

  v1 = restarting;
  if ( !sysinfo_0(&sInfo) )
  {
    total_tv_end_sys = sInfo.uptime;
    cgtime(&total_tv_end);
    if ( v1 )
      return;
    goto LABEL_8;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    v2 = *_errno_location();
    v3 = strerror(v2);
    snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v2, v3);
    applog(6, tmp42, 0);
  }
  total_tv_end_sys = time(0);
  cgtime(&total_tv_end);
  if ( !v1 )
  {
LABEL_8:
    if ( !opt_realquiet && successful_connect )
      print_summary();
  }
}

//----- (000244CC) --------------------------------------------------------
void __fastcall __noreturn _quit(int a1, int a2)
{
  pthread_t newthread; // [sp+4h] [bp-14h] BYREF

  if ( !pthread_create(&newthread, 0, killall_thread, 0) )
  {
    if ( a2 )
      clean_up(0);
    if ( forkpid > 0 )
    {
      kill(forkpid, 15);
      forkpid = 0;
    }
    pthread_cancel(newthread);
    exit(a1);
  }
  exit(1);
}

//----- (0002451C) --------------------------------------------------------
void app_restart()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-810h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Attempting to restart %s", (const char *)packagename);
    applog(4, tmp42, 0);
  }
  cg_completion_timeout(_kill_work, 0, 5000);
  clean_up(1);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  execv((const char *)*initial_args, (char *const *)initial_args);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Failed to restart application");
    applog(4, tmp42, 0);
  }
}

//----- (000245DC) --------------------------------------------------------
work *__fastcall find_queued_work_bymidstate(
        cgpu_info *cgpu,
        unsigned __int8 *midstate,
        size_t midstatelen,
        unsigned __int8 *data,
        int offset,
        size_t datalen)
{
  pthread_rwlock_t *p_qlock; // r4
  const unsigned __int8 *v11; // r2
  int v12; // r3
  work *work_bymidstate; // r5
  const unsigned __int8 *v14; // r2
  int v15; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_rdlock(&cgpu->qlock) )
    rd_lock_0((pthread_rwlock_t *)(&_func___14958.__align + 5), (const unsigned __int8 *)0x248E, v11, v12);
  work_bymidstate = _find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)(&_func___14958.__align + 5), (const unsigned __int8 *)0x2490, v14, v15);
  selective_yield();
  return work_bymidstate;
}
// 2462A: variable 'v11' is possibly undefined
// 2462A: variable 'v12' is possibly undefined
// 24636: variable 'v14' is possibly undefined
// 24636: variable 'v15' is possibly undefined

//----- (00024644) --------------------------------------------------------
work *__fastcall find_queued_work_byid(cgpu_info *cgpu, unsigned int id)
{
  pthread_rwlock_t *p_qlock; // r6
  const unsigned __int8 *v5; // r2
  int v6; // r3
  work *queued_work; // r3
  work *v8; // r4
  void *next; // r2
  const unsigned __int8 *v10; // r2
  int v11; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_rdlock(&cgpu->qlock) )
    rd_lock_0((pthread_rwlock_t *)&_func___14883, (const unsigned __int8 *)0x24BD, v5, v6);
  queued_work = cgpu->queued_work;
  if ( !queued_work || (v8 = (work *)queued_work->hh.next, id == queued_work->id) )
  {
    v8 = queued_work;
  }
  else if ( v8 )
  {
    do
    {
      next = v8->hh.next;
      if ( id == v8->id )
        break;
      v8 = (work *)v8->hh.next;
    }
    while ( next );
  }
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14883, (const unsigned __int8 *)0x24BF, v10, v11);
  selective_yield();
  return v8;
}
// 24698: variable 'v10' is possibly undefined
// 24698: variable 'v11' is possibly undefined
// 246A4: variable 'v5' is possibly undefined
// 246A4: variable 'v6' is possibly undefined

//----- (000246B4) --------------------------------------------------------
int cp_prio()
{
  const unsigned __int8 *v0; // r2
  int v1; // r3
  const unsigned __int8 *v2; // r2
  int v3; // r3
  const unsigned __int8 *v4; // r2
  int v5; // r3
  int prio; // r4
  const unsigned __int8 *v7; // r2
  int v8; // r3

  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock_2((pthread_mutex_t *)&_func___14883.__align + 1, (const unsigned __int8 *)0x1C88, v0, v1);
  if ( pthread_rwlock_rdlock(&control_lock.rwlock) )
    rd_lock_0((pthread_rwlock_t *)&_func___14883.__size[24], (const unsigned __int8 *)0x1C88, v2, v3);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14883.__align + 1, (const unsigned __int8 *)0x1C88, v4, v5);
  prio = currentpool->prio;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14883.__size[24], (const unsigned __int8 *)0x1C8A, v7, v8);
  selective_yield();
  return prio;
}
// 246EE: variable 'v0' is possibly undefined
// 246EE: variable 'v1' is possibly undefined
// 246FA: variable 'v7' is possibly undefined
// 246FA: variable 'v8' is possibly undefined
// 24706: variable 'v4' is possibly undefined
// 24706: variable 'v5' is possibly undefined
// 24712: variable 'v2' is possibly undefined
// 24712: variable 'v3' is possibly undefined

//----- (0002472C) --------------------------------------------------------
void __fastcall pool_resus(pool *pool)
{
  int prio; // r5
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  pool->seq_getfails = 0;
  if ( pool_strategy_0 || (prio = pool->prio, prio >= cp_prio()) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s alive", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d %s alive, testing stability", pool->pool_no, (const char *)pool->rpc_url);
    applog(4, tmp42, 0);
  }
}

//----- (000247D4) --------------------------------------------------------
void __fastcall stratum_resumed(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-808h] BYREF

  if ( pool_tclear(pool, &pool->idle) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d resumed", pool->pool_no);
      applog(6, tmp42, 0);
    }
    pool_resus(pool);
  }
}

//----- (00024830) --------------------------------------------------------
pool *current_pool()
{
  const unsigned __int8 *v0; // r2
  int v1; // r3
  const unsigned __int8 *v2; // r2
  int v3; // r3
  const unsigned __int8 *v4; // r2
  int v5; // r3
  pool *v6; // r4
  const unsigned __int8 *v7; // r2
  int v8; // r3

  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock_2((pthread_mutex_t *)&_func___12509, (const unsigned __int8 *)0x323, v0, v1);
  if ( pthread_rwlock_rdlock(&control_lock.rwlock) )
    rd_lock_0((pthread_rwlock_t *)&_func___12509, (const unsigned __int8 *)0x323, v2, v3);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___12509, (const unsigned __int8 *)0x323, v4, v5);
  v6 = currentpool;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___12509, (const unsigned __int8 *)0x327, v7, v8);
  selective_yield();
  return v6;
}
// 24868: variable 'v0' is possibly undefined
// 24868: variable 'v1' is possibly undefined
// 24874: variable 'v7' is possibly undefined
// 24874: variable 'v8' is possibly undefined
// 24880: variable 'v4' is possibly undefined
// 24880: variable 'v5' is possibly undefined
// 2488C: variable 'v2' is possibly undefined
// 2488C: variable 'v3' is possibly undefined

//----- (000248A8) --------------------------------------------------------
bool __fastcall cnx_needed(pool *pool)
{
  int prio; // r4

  if ( pool->enabled != POOL_ENABLED )
    return 0;
  if ( pool_strategy_0 == POOL_BALANCE || pool_strategy_0 == POOL_LOADBALANCE || pool->has_stratum && pool->idle )
    return 1;
  if ( pool == current_pool() )
    return 1;
  if ( pool->sshares )
    return 1;
  if ( pool_strategy_0 == POOL_FAILOVER )
  {
    prio = pool->prio;
    if ( prio < cp_prio() )
      return 1;
  }
  return no_work;
}

//----- (000248FC) --------------------------------------------------------
bool __fastcall test_work_current(work *work)
{
  work *v1; // r7
  _BOOL4 v2; // r5
  _BOOL4 mandatory; // r3
  unsigned __int8 *coinbase; // r4
  unsigned int v5; // r9
  int v7; // r3
  int v8; // r6
  int v9; // r5
  int v10; // r3
  int v11; // r3
  int v12; // r5
  const unsigned __int8 *v13; // r2
  int v14; // r3
  const unsigned __int8 *v15; // r2
  int v16; // r3
  const unsigned __int8 *v17; // r2
  int v18; // r3
  const unsigned __int8 *v19; // r2
  int v20; // r3
  const unsigned __int8 *v21; // r2
  int v22; // r3
  unsigned int v23; // r4
  int v24; // r6
  size_t v25; // r9
  int v26; // r1
  unsigned int v27; // r5
  unsigned __int8 *i; // r3
  int v29; // r8
  int v30; // r0
  int v31; // lr
  int v32; // r12
  int v33; // r2
  unsigned int v34; // r4
  unsigned int v35; // r2
  int v36; // r1
  unsigned int v37; // r0
  unsigned int v38; // r2
  int v39; // r1
  unsigned int v40; // r0
  unsigned int v41; // r2
  size_t v42; // r6
  int v43; // r1
  unsigned int v44; // r2
  unsigned int v45; // r3
  int v46; // r1
  unsigned int v47; // r2
  unsigned int v48; // r3
  int v49; // r1
  unsigned int v50; // r5
  UT_hash_table *tbl; // r6
  UT_hash_handle *hh_head; // r4
  char *key; // r3
  block *v54; // r10
  unsigned int v55; // r1
  UT_hash_table *v56; // lr
  work *v57; // r12
  int v58; // r2
  UT_hash_handle_0 *p_hh; // r7
  UT_hash_handle_0 *v60; // r4
  UT_hash_handle *v61; // r5
  unsigned int v62; // r6
  UT_hash_handle_0 *next; // r3
  int v64; // r1
  ptrdiff_t hho; // r0
  UT_hash_handle_0 *v66; // r0
  int v67; // r8
  bool v68; // zf
  UT_hash_handle_0 *v69; // r10
  ptrdiff_t v70; // r3
  char *v71; // r9
  char *v72; // r3
  bool v73; // zf
  UT_hash_handle_0 *v74; // r10
  ptrdiff_t v75; // r4
  block *v76; // r4
  int block_no; // r5
  char *prev; // r2
  block *v79; // r5
  UT_hash_table *v80; // r6
  ptrdiff_t v81; // r1
  UT_hash_table *v82; // r1
  UT_hash_bucket_0 *buckets; // r5
  int v84; // r6
  UT_hash_handle *hh_next; // r3
  UT_hash_handle *hh_prev; // r2
  int v87; // r5
  unsigned int v88; // r0
  unsigned int v89; // r4
  int v90; // r2
  unsigned __int8 *j; // r3
  int v92; // r9
  int v93; // r1
  int v94; // lr
  int v95; // r12
  int v96; // r6
  unsigned int v97; // r0
  unsigned int v98; // r1
  int v99; // r2
  unsigned int v100; // r0
  unsigned int v101; // r1
  int v102; // r2
  unsigned int v103; // r0
  unsigned int v104; // r1
  size_t v105; // r5
  int v106; // r1
  unsigned int v107; // r2
  unsigned int v108; // r3
  int v109; // r1
  unsigned int v110; // r2
  unsigned int v111; // r3
  int v112; // r1
  unsigned int v113; // r4
  UT_hash_table *v114; // r3
  UT_hash_handle_0 *v115; // r5
  UT_hash_table *v116; // r2
  UT_hash_handle *tail; // r0
  UT_hash_table *v118; // r3
  ptrdiff_t v119; // r1
  UT_hash_bucket_0 *v120; // r0
  int v121; // r4
  int v122; // r2
  UT_hash_handle *v123; // r4
  unsigned int v124; // r3
  int v125; // r1
  UT_hash_table *v126; // r3
  size_t v127; // r4
  UT_hash_bucket_0 *v128; // r0
  UT_hash_bucket_0 *v129; // r8
  UT_hash_table *v130; // r11
  unsigned int num_buckets; // r3
  unsigned int num_items; // r4
  unsigned int log2_num_buckets; // r2
  unsigned int v134; // r2
  int v135; // r12
  unsigned int v136; // r10
  UT_hash_handle *v137; // r4
  UT_hash_handle *v138; // r7
  int v139; // r5
  UT_hash_bucket_0 *v140; // r6
  unsigned int v141; // r0
  UT_hash_handle *v142; // r3
  UT_hash_table *v143; // r4
  unsigned int nonideal_items; // r3
  unsigned int v145; // r0
  unsigned int v146; // r1
  unsigned int v147; // r2
  bool v148; // cc
  int v149; // r0
  unsigned int v150; // r3
  int v151; // r0
  int v152; // r1
  unsigned int v153; // r3
  unsigned __int64 v154; // r0
  double v155; // d6
  double v156; // d8
  const unsigned __int8 *v157; // r2
  int v158; // r3
  pool *v159; // r4
  void *v160; // r9
  int v161; // r9
  ptrdiff_t v162; // r3
  _BOOL4 longpoll; // r2
  const char *v164; // r2
  const char *pool_no; // r3
  const unsigned __int8 *v166; // r2
  int v167; // r3
  const unsigned __int8 *v168; // r2
  int v169; // r3
  int v170; // r8
  struct tm *v171; // r0
  const unsigned __int8 *v172; // r2
  int v173; // r3
  const unsigned __int8 *v174; // r2
  int v175; // r3
  int k; // r3
  const char *v177; // r3
  UT_hash_table *v178; // r0
  UT_hash_table *v179; // r6
  UT_hash_bucket_0 *v180; // r0
  int line; // [sp+0h] [bp-8D0h]
  size_t v182; // [sp+14h] [bp-8BCh]
  unsigned int v183; // [sp+14h] [bp-8BCh]
  pool *pool; // [sp+18h] [bp-8B8h]
  block *dest; // [sp+1Ch] [bp-8B4h]
  int v186; // [sp+20h] [bp-8B0h]
  UT_hash_bucket_0 *ptr; // [sp+24h] [bp-8ACh]
  int v188; // [sp+28h] [bp-8A8h]
  work *worka; // [sp+2Ch] [bp-8A4h]
  unsigned int height; // [sp+34h] [bp-89Ch] BYREF
  time_t timer; // [sp+38h] [bp-898h] BYREF
  unsigned __int8 bedata[32]; // [sp+3Ch] [bp-894h] BYREF
  unsigned __int8 hexstr[68]; // [sp+5Ch] [bp-874h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+A0h] [bp-830h] BYREF

  v1 = work;
  LOBYTE(v2) = 1;
  pool = work->pool;
  mandatory = work->mandatory;
  coinbase = pool->coinbase;
  height = 0;
  v5 = coinbase[42];
  if ( mandatory )
    return v2;
  v7 = *(_DWORD *)&work->data[28];
  v8 = *(_DWORD *)&work->data[20];
  *(_DWORD *)bedata = *(_DWORD *)&work->data[32];
  *(_DWORD *)&bedata[4] = v7;
  v9 = *(_DWORD *)&work->data[12];
  v10 = *(_DWORD *)&work->data[24];
  *(_DWORD *)&bedata[12] = v8;
  *(_DWORD *)&bedata[20] = v9;
  *(_DWORD *)&bedata[8] = v10;
  v11 = *(_DWORD *)&work->data[4];
  v12 = *(_DWORD *)&work->data[8];
  *(_DWORD *)&bedata[16] = *(_DWORD *)&work->data[16];
  *(_DWORD *)&bedata[28] = v11;
  *(_DWORD *)&bedata[24] = v12;
  _bin2hex(hexstr, bedata, 0x20u);
  if ( v5 <= 4 )
  {
    cg_memcpy(&height, coinbase + 43, v5, "cgminer.c", &_func___12509.__size[16], 5545);
    --height;
  }
  if ( pthread_mutex_lock(&pool->data_lock.mutex) )
    mutex_lock_2((pthread_mutex_t *)&_func___12509.__size[16], (const unsigned __int8 *)0x15AE, v13, v14);
  if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
    wr_lock_0((pthread_rwlock_t *)(&_func___12509.__align + 4), (const unsigned __int8 *)0x15AE, v15, v16);
  if ( pool->swork.clean )
  {
    pool->swork.clean = 0;
    v1->longpoll = 1;
  }
  if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
    rw_unlock_1((pthread_rwlock_t *)(&_func___12509.__align + 4), (const unsigned __int8 *)0x15B6, v17, v18);
  if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___12509.__size[16], (const unsigned __int8 *)0x15B6, v19, v20);
  selective_yield();
  if ( pthread_rwlock_wrlock(&blk_lock) )
    wr_lock_0((pthread_rwlock_t *)&_func___13846, (const unsigned __int8 *)0x155F, v21, v22);
  v23 = -1640531527;
  v24 = -17973521;
  v25 = strlen((const char *)hexstr);
  v26 = -1640531527;
  v27 = v25;
  for ( i = hexstr; v27 > 0xB; v24 = (v41 - v26 - v23) ^ (v23 >> 15) )
  {
    v27 -= 12;
    v29 = i[3];
    v30 = (i[2] << 16) + (i[1] << 8) + *i;
    v31 = i[11];
    v32 = (i[6] << 16) + (i[5] << 8) + i[4] + (i[7] << 24);
    v33 = (i[10] << 16) + (i[9] << 8) + i[8];
    i += 12;
    v34 = v23 + v32;
    v35 = v33 + (v31 << 24) + v24;
    v36 = (v26 + v30 + (v29 << 24) - v34 - v35) ^ (v35 >> 13);
    v37 = (v34 - v35 - v36) ^ (v36 << 8);
    v38 = (v35 - v36 - v37) ^ (v37 >> 13);
    v39 = (v36 - v37 - v38) ^ (v38 >> 12);
    v40 = (v37 - v38 - v39) ^ (v39 << 16);
    v41 = (v38 - v39 - v40) ^ (v40 >> 5);
    v26 = (v39 - v40 - v41) ^ (v41 >> 3);
    v23 = (v40 - v41 - v26) ^ (v26 << 10);
  }
  v42 = v24 + v25;
  switch ( v27 )
  {
    case 1u:
      goto LABEL_25;
    case 2u:
      goto LABEL_24;
    case 3u:
      goto LABEL_23;
    case 4u:
      goto LABEL_22;
    case 5u:
      goto LABEL_21;
    case 6u:
      goto LABEL_20;
    case 7u:
      goto LABEL_19;
    case 8u:
      goto LABEL_18;
    case 9u:
      goto LABEL_17;
    case 0xAu:
      goto LABEL_16;
    case 0xBu:
      v42 += i[10] << 24;
LABEL_16:
      v42 += i[9] << 16;
LABEL_17:
      v42 += i[8] << 8;
LABEL_18:
      v23 += i[7] << 24;
LABEL_19:
      v23 += i[6] << 16;
LABEL_20:
      v23 += i[5] << 8;
LABEL_21:
      v23 += i[4];
LABEL_22:
      v26 += i[3] << 24;
LABEL_23:
      v26 += i[2] << 16;
LABEL_24:
      v26 += i[1] << 8;
LABEL_25:
      v26 += *i;
      break;
    default:
      break;
  }
  v43 = (v26 - v23 - v42) ^ (v42 >> 13);
  v44 = (v23 - v42 - v43) ^ (v43 << 8);
  v45 = (v42 - v43 - v44) ^ (v44 >> 13);
  v46 = (v43 - v44 - v45) ^ (v45 >> 12);
  v47 = (v44 - v45 - v46) ^ (v46 << 16);
  v48 = (v45 - v46 - v47) ^ (v47 >> 5);
  v49 = (v46 - v47 - v48) ^ (v48 >> 3);
  v50 = (v48 - v49 - ((v47 - v48 - v49) ^ (v49 << 10))) ^ (((v47 - v48 - v49) ^ (v49 << 10)) >> 15);
  if ( blocks )
  {
    tbl = blocks->hh.tbl;
    hh_head = tbl->buckets[(tbl->num_buckets - 1) & v50].hh_head;
    if ( hh_head )
      hh_head = (UT_hash_handle *)((char *)hh_head - tbl->hho);
    while ( hh_head )
    {
      if ( (UT_hash_table *)v50 == hh_head[3].tbl
        && v25 == hh_head[2].hashv
        && !memcmp((const void *)hh_head[2].keylen, hexstr, v25) )
      {
        v186 = 0;
        v2 = 1;
        goto LABEL_136;
      }
      key = (char *)hh_head[2].key;
      if ( !key )
        break;
      hh_head = (UT_hash_handle *)&key[-tbl->hho];
    }
  }
  dest = (block *)cgcalloc(104, 1u, "cgminer.c", (const unsigned __int8 *)&_func___13846, 5475);
  if ( !dest )
  {
    strcpy((char *)tmp42, "block_exists OOM");
    applog(3, tmp42, 1);
    quit(1);
  }
  strcpy((char *)dest, (const char *)hexstr);
  v54 = blocks;
  v55 = new_blocks + 1;
  dest->block_no = new_blocks;
  new_blocks = v55;
  if ( !v54 )
  {
    v186 = 0;
    goto LABEL_83;
  }
  v56 = v54->hh.tbl;
  if ( v56->num_items <= 3 )
  {
    v186 = 0;
    goto LABEL_83;
  }
  v57 = v1;
  v58 = 1;
  p_hh = &v54->hh;
  do
  {
    v60 = p_hh;
    p_hh = 0;
    v61 = 0;
    v62 = 0;
    do
    {
      ++v62;
      if ( v58 )
      {
        next = (UT_hash_handle_0 *)v60->next;
        v64 = 1;
        if ( next )
        {
          hho = v56->hho;
          v64 = 1;
          for ( next = (UT_hash_handle_0 *)((char *)next + hho); next; next = (UT_hash_handle_0 *)((char *)next + hho) )
          {
            if ( v64 == v58 )
              break;
            next = (UT_hash_handle_0 *)next->next;
            ++v64;
            if ( !next )
              break;
          }
        }
        v66 = v60;
        v67 = v58;
        v60 = next;
      }
      else
      {
        v66 = v60;
        v64 = 0;
        v67 = 0;
      }
LABEL_46:
      while ( v64 )
      {
LABEL_47:
        v68 = v67 == 0;
        if ( v67 )
          v68 = v60 == 0;
        if ( v68 )
        {
          if ( !v66 )
            goto LABEL_174;
          v69 = (UT_hash_handle_0 *)v66->next;
          if ( v69 )
            v69 = (UT_hash_handle_0 *)((char *)v69 + v56->hho);
        }
        else
        {
          v162 = v56->hho;
          if ( *(void **)((char *)&v66[3].prev - v162) - *(void **)((char *)&v60[3].prev - v162) > 0 )
          {
            v161 = (int)v60->next;
            if ( !v161 )
              goto LABEL_163;
            v161 += v162;
            --v67;
            if ( v61 )
              goto LABEL_164;
LABEL_169:
            v61 = v60;
            v72 = 0;
            v60 = (UT_hash_handle_0 *)v161;
            p_hh = v61;
            goto LABEL_57;
          }
          if ( !v66 )
          {
LABEL_174:
            v69 = v66;
            goto LABEL_54;
          }
          v69 = (UT_hash_handle_0 *)v66->next;
          if ( v69 )
            v69 = (UT_hash_handle_0 *)((char *)v69 + v162);
        }
LABEL_54:
        --v64;
        if ( v61 )
        {
          if ( !v66 )
            goto LABEL_165;
          goto LABEL_56;
        }
        if ( v66 )
        {
          v61 = v66;
          v72 = 0;
          v66 = v69;
          p_hh = v61;
          goto LABEL_57;
        }
        p_hh = 0;
        v66 = v69;
        v61 = 0;
      }
      while ( 1 )
      {
        v73 = v60 == 0;
        if ( v60 )
          v73 = v67 == 0;
        if ( v73 )
          break;
        v160 = v60->next;
        if ( v160 )
          v161 = (int)v160 + v56->hho;
        else
          v161 = v64;
LABEL_163:
        --v67;
        if ( !v61 )
          goto LABEL_169;
LABEL_164:
        v69 = v66;
        v66 = v60;
        v60 = (UT_hash_handle_0 *)v161;
        if ( !v66 )
        {
LABEL_165:
          v61->next = v66;
          v61 = v66;
          v66 = v69;
          goto LABEL_46;
        }
LABEL_56:
        v70 = v56->hho;
        v71 = (char *)v66 - v70;
        v72 = (char *)v61 - v70;
        v61->next = v71;
        v61 = v66;
        v66 = v69;
LABEL_57:
        v61->prev = v72;
        if ( v64 )
          goto LABEL_47;
      }
    }
    while ( v60 );
    if ( v61 )
      v61->next = 0;
    if ( v62 <= 1 )
    {
      v74 = p_hh;
      v1 = v57;
      goto LABEL_68;
    }
    v58 *= 2;
  }
  while ( p_hh );
  v74 = 0;
  v1 = v57;
  v61 = 0;
LABEL_68:
  v75 = v56->hho;
  v56->tail = v61;
  v76 = (block *)((char *)v74 - v75);
  block_no = v76->block_no;
  prev = (char *)v76->hh.prev;
  blocks = v76;
  v186 = block_no;
  v79 = (block *)v76->hh.next;
  if ( prev || v79 )
  {
    v80 = v76->hh.tbl;
    v81 = v80->hho;
    if ( v76 == (block *)((char *)v80->tail - v81) )
      v80->tail = (UT_hash_handle *)&prev[v81];
    if ( prev )
    {
      v54 = v76;
      *(_DWORD *)&prev[v81 + 8] = v79;
      v79 = (block *)v76->hh.next;
    }
    else
    {
      v54 = v79;
      blocks = v79;
    }
    v82 = v54->hh.tbl;
    if ( v79 )
      *(_DWORD *)&v79->hash[v82->hho + 4] = prev;
    buckets = v82->buckets;
    v84 = v76->hh.hashv & (v82->num_buckets - 1);
    v68 = &v76->hh == v82->buckets[v84].hh_head;
    hh_next = v76->hh.hh_next;
    --v82->buckets[v84].count;
    hh_prev = v76->hh.hh_prev;
    if ( v68 )
      buckets[v84].hh_head = hh_next;
    if ( hh_prev )
    {
      hh_prev->hh_next = hh_next;
      hh_next = v76->hh.hh_next;
    }
    if ( hh_next )
      hh_next->hh_prev = hh_prev;
    --v82->num_items;
  }
  else
  {
    v54 = 0;
    free(v76->hh.tbl->buckets);
    free(v76->hh.tbl);
    blocks = 0;
  }
  free(v76);
LABEL_83:
  v87 = -17973521;
  v182 = strlen((const char *)dest);
  v88 = -1640531527;
  v89 = v182;
  v90 = -1640531527;
  for ( j = (unsigned __int8 *)dest; v89 > 0xB; v87 = (v104 - v90 - v88) ^ (v88 >> 15) )
  {
    v89 -= 12;
    v92 = (j[10] << 16) + (j[9] << 8);
    v93 = j[8];
    v94 = j[11];
    v95 = j[4] + (j[6] << 16) + (j[5] << 8) + (j[7] << 24);
    v96 = *j + (j[2] << 16) + (j[1] << 8) + (j[3] << 24);
    j += 12;
    v97 = v88 + v95;
    v98 = v93 + v92 + (v94 << 24) + v87;
    v99 = (v90 + v96 - v97 - v98) ^ (v98 >> 13);
    v100 = (v97 - v98 - v99) ^ (v99 << 8);
    v101 = (v98 - v99 - v100) ^ (v100 >> 13);
    v102 = (v99 - v100 - v101) ^ (v101 >> 12);
    v103 = (v100 - v101 - v102) ^ (v102 << 16);
    v104 = (v101 - v102 - v103) ^ (v103 >> 5);
    v90 = (v102 - v103 - v104) ^ (v104 >> 3);
    v88 = (v103 - v104 - v90) ^ (v90 << 10);
  }
  v105 = v87 + v182;
  switch ( v89 )
  {
    case 1u:
      goto LABEL_100;
    case 2u:
      goto LABEL_99;
    case 3u:
      goto LABEL_98;
    case 4u:
      goto LABEL_97;
    case 5u:
      goto LABEL_96;
    case 6u:
      goto LABEL_95;
    case 7u:
      goto LABEL_94;
    case 8u:
      goto LABEL_93;
    case 9u:
      goto LABEL_92;
    case 0xAu:
      goto LABEL_91;
    case 0xBu:
      v105 += j[10] << 24;
LABEL_91:
      v105 += j[9] << 16;
LABEL_92:
      v105 += j[8] << 8;
LABEL_93:
      v88 += j[7] << 24;
LABEL_94:
      v88 += j[6] << 16;
LABEL_95:
      v88 += j[5] << 8;
LABEL_96:
      v88 += j[4];
LABEL_97:
      v90 += j[3] << 24;
LABEL_98:
      v90 += j[2] << 16;
LABEL_99:
      v90 += j[1] << 8;
LABEL_100:
      v90 += *j;
      break;
    default:
      break;
  }
  v106 = (v90 - v88 - v105) ^ (v105 >> 13);
  v107 = (v88 - v105 - v106) ^ (v106 << 8);
  dest->hh.key = dest;
  v108 = (v105 - v106 - v107) ^ (v107 >> 13);
  v109 = (v106 - v107 - v108) ^ (v108 >> 12);
  v110 = (v107 - v108 - v109) ^ (v109 << 16);
  v111 = (v108 - v109 - v110) ^ (v110 >> 5);
  v112 = (v109 - v110 - v111) ^ (v111 >> 3);
  v113 = (v111 - v112 - ((v110 - v111 - v112) ^ (v112 << 10))) ^ (((v110 - v111 - v112) ^ (v112 << 10)) >> 15);
  dest->hh.hashv = v113;
  dest->hh.keylen = strlen((const char *)dest);
  if ( v54 )
  {
    v114 = v54->hh.tbl;
    dest->hh.next = 0;
    dest->hh.tbl = v114;
    v115 = &dest->hh;
    v116 = v54->hh.tbl;
    tail = v116->tail;
    v118 = v116;
    v119 = v116->hho;
    tail->next = dest;
    dest->hh.prev = (char *)tail - v119;
    v116->tail = &dest->hh;
    goto LABEL_103;
  }
  dest->hh.next = 0;
  dest->hh.prev = 0;
  blocks = dest;
  v178 = (UT_hash_table *)malloc(0x2Cu);
  dest->hh.tbl = v178;
  if ( !v178 )
    goto LABEL_239;
  v178->buckets = 0;
  v178->num_buckets = 0;
  v178->log2_num_buckets = 0;
  v178->num_items = 0;
  v178->tail = 0;
  v178->hho = 0;
  v178->ideal_chain_maxlen = 0;
  v178->nonideal_items = 0;
  v178->ineff_expands = 0;
  v178->noexpand = 0;
  v178->signature = 0;
  v115 = &dest->hh;
  v179 = dest->hh.tbl;
  v179->tail = &dest->hh;
  v179->num_buckets = 32;
  v179->log2_num_buckets = 5;
  v179->hho = 68;
  v180 = (UT_hash_bucket_0 *)malloc(0x180u);
  v179->buckets = v180;
  if ( !v180 )
    goto LABEL_239;
  memset(v180, 0, 0x180u);
  v118 = dest->hh.tbl;
  v118->signature = -1609490463;
LABEL_103:
  v120 = v118->buckets;
  v121 = 3 * (v113 & (v118->num_buckets - 1));
  ++v118->num_items;
  v122 = 4 * v121;
  v123 = v120[v121 / 3u].hh_head;
  v124 = *(unsigned int *)((char *)&v120->count + v122) + 1;
  *(unsigned int *)((char *)&v120->count + v122) = v124;
  dest->hh.hh_next = v123;
  dest->hh.hh_prev = 0;
  if ( v123 )
    v123->hh_prev = v115;
  v125 = *(unsigned int *)((char *)&v120->expand_mult + v122);
  *(UT_hash_handle **)((char *)&v120->hh_head + v122) = v115;
  if ( v124 >= 10 * (v125 + 1) )
  {
    v126 = dest->hh.tbl;
    if ( v126->noexpand != 1 )
    {
      v127 = 24 * v126->num_buckets;
      v128 = (UT_hash_bucket_0 *)malloc(v127);
      v129 = v128;
      if ( v128 )
      {
        memset(v128, 0, v127);
        v130 = dest->hh.tbl;
        num_buckets = v130->num_buckets;
        num_items = v130->num_items;
        log2_num_buckets = v130->log2_num_buckets;
        v130->nonideal_items = 0;
        v134 = num_items >> (log2_num_buckets + 1);
        v135 = 2 * num_buckets - 1;
        if ( (v135 & num_items) != 0 )
          v136 = v134 + 1;
        else
          v136 = v134;
        v130->ideal_chain_maxlen = v136;
        if ( num_buckets )
        {
          v183 = 0;
          ptr = v130->buckets;
          v188 = 12 * num_buckets;
          worka = v1;
          do
          {
            v137 = ptr[v183 / 0xC].hh_head;
            if ( v137 )
            {
              do
              {
                v138 = v137->hh_next;
                v139 = v135 & v137->hashv;
                v140 = &v129[v135 & v137->hashv];
                v141 = v140->count + 1;
                v140->count = v141;
                if ( v136 < v141 )
                {
                  ++v130->nonideal_items;
                  v140->expand_mult = v141 / v136;
                }
                v142 = v129[v139].hh_head;
                v137->hh_prev = 0;
                v137->hh_next = v142;
                if ( v142 )
                  v142->hh_prev = v137;
                v129[v139].hh_head = v137;
                v137 = v138;
              }
              while ( v138 );
            }
            v183 += 12;
          }
          while ( v183 != v188 );
          v1 = worka;
          free(ptr);
        }
        else
        {
          free(v130->buckets);
        }
        v143 = dest->hh.tbl;
        nonideal_items = v143->nonideal_items;
        v145 = v143->num_buckets;
        v146 = v143->log2_num_buckets;
        v147 = v143->num_items;
        v143->buckets = v129;
        v148 = nonideal_items > v147 >> 1;
        v149 = 2 * v145;
        v143->log2_num_buckets = v146 + 1;
        if ( nonideal_items <= v147 >> 1 )
          nonideal_items = 0;
        v143->num_buckets = v149;
        if ( v148 )
        {
          v150 = v143->ineff_expands + 1;
          v143->ineff_expands = v150;
          if ( v150 > 1 )
            v143->noexpand = 1;
        }
        else
        {
          v143->ineff_expands = nonideal_items;
        }
        goto LABEL_127;
      }
LABEL_239:
      exit(-1);
    }
  }
LABEL_127:
  v151 = 8 * (29 - v1->data[72]);
  if ( v151 <= 7 )
  {
    v155 = 16776960.0;
  }
  else
  {
    v152 = 0xFFFF << (v151 - 32);
    v153 = 0xFFFFu >> (32 - v151);
    LODWORD(v154) = 0xFFFF << v151;
    HIDWORD(v154) = v152 | v153;
    v155 = (double)v154;
  }
  v156 = v155 / (double)(bswap32(*(_DWORD *)&v1->data[72]) & 0xFFFFFF);
  if ( v156 != current_diff )
  {
    suffix_string((unsigned __int64)v156, block_diff, 8u, 0);
    current_diff = v156;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Network diff set to %s", (const char *)block_diff);
      applog(5, tmp42, 0);
    }
  }
  if ( v186 )
  {
    v2 = opt_debug;
    if ( opt_debug && (use_syslog || (v2 = opt_log_output) || opt_log_level > 6) )
    {
      v2 = 0;
      snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", v186);
      applog(7, tmp42, 0);
    }
  }
  else
  {
    v2 = 0;
  }
LABEL_136:
  if ( pthread_rwlock_unlock(&blk_lock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___13846, (const unsigned __int8 *)0x1585, v157, v158);
  selective_yield();
  if ( !v2 )
  {
    if ( pthread_mutex_lock(&ch_lock.mutex) )
      mutex_lock_2((pthread_mutex_t *)(&_func___13846.__align + 4), (const unsigned __int8 *)0x1528, v166, v167);
    if ( pthread_rwlock_wrlock(&ch_lock.rwlock) )
      wr_lock_0((pthread_rwlock_t *)&_func___13846.__size[16], (const unsigned __int8 *)0x1528, v168, v169);
    cgtime(&block_timeval);
    strcpy((char *)current_hash, (const char *)hexstr);
    cg_memcpy(current_block, bedata, 0x20u, "cgminer.c", &_func___13846.__size[16], 5419);
    timer = block_timeval.tv_sec;
    v170 = block_timeval.tv_usec / 1000;
    v171 = localtime(&timer);
    snprintf((char *)blocktime, 0x20u, a02d02d02d03d, v171->tm_hour, v171->tm_min, v171->tm_sec, v170);
    if ( pthread_rwlock_unlock(&ch_lock.rwlock) )
      rw_unlock_1((pthread_rwlock_t *)&_func___13846.__size[16], (const unsigned __int8 *)0x152D, v172, v173);
    if ( pthread_mutex_unlock(&ch_lock.mutex) )
      mutex_unlock_noyield_2(
        (pthread_mutex_t *)(&_func___13846.__align + 4),
        (const unsigned __int8 *)0x152D,
        v174,
        v175);
    selective_yield();
    for ( k = 0; k != 57; ++k )
    {
      if ( current_hash[k] != 48 )
        break;
    }
    strncpy((char *)prev_block, (const char *)&current_hash[k], 8u);
    prev_block[8] = 0;
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "New block: %s... diff %s", (const char *)current_hash, (const char *)block_diff);
      applog(6, tmp42, 0);
    }
  }
  if ( v186 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", v186);
    applog(7, tmp42, 0);
  }
  if ( !v2 )
  {
    cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", &_func___12509.__size[16], 5566);
    if ( new_blocks == 1 )
      goto out;
    longpoll = v1->longpoll;
    v1->work_block = ++work_block;
    if ( !longpoll )
    {
      if ( have_longpoll )
      {
        if ( !pool->gbt_solo && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          strcpy((char *)tmp42, "New block detected on network before pool notification");
          applog(5, tmp42, 0);
        }
      }
      else if ( !pool->gbt_solo && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        strcpy((char *)tmp42, "New block detected on network");
        applog(5, tmp42, 0);
      }
      goto LABEL_183;
    }
    if ( v1->stratum )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
        goto LABEL_183;
      v164 = "Stratum from pool %d detected new block at height %d";
      pool_no = (const char *)pool->pool_no;
      line = height;
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
        goto LABEL_183;
      pool_no = "";
      v164 = "%sLONGPOLL from pool %d detected new block";
      line = v1->pool->pool_no;
      if ( v1->gbt )
        pool_no = "GBT ";
    }
    snprintf((char *)tmp42, 0x800u, v164, pool_no, line);
    applog(5, tmp42, 0);
LABEL_183:
    restart_threads();
    LOBYTE(v2) = 1;
    goto out;
  }
  LOBYTE(v2) = 1;
  if ( memcmp(pool->prev_block, bedata, 0x20u) )
  {
    if ( !memcmp(bedata, current_block, 0x20u) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d now up to date at height %d", pool->pool_no, height);
        applog(6, tmp42, 0);
      }
      LOBYTE(v2) = 1;
      cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", &_func___12509.__size[16], 5616);
    }
    else
    {
      LOBYTE(v2) = opt_debug;
      if ( opt_debug && (use_syslog || (LOBYTE(v2) = opt_log_output) != 0 || opt_log_level > 6) )
      {
        LOBYTE(v2) = 0;
        snprintf((char *)tmp42, 0x800u, "Stale data from pool %d at height %d", pool->pool_no, height);
        applog(7, tmp42, 0);
      }
    }
  }
  if ( v1->longpoll )
  {
    v148 = (unsigned int)(pool_strategy_0 - 3) > 1;
    v1->work_block = ++work_block;
    if ( !v148 || (v159 = v1->pool, v159 == current_pool()) )
    {
      if ( v1->stratum )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Stratum from pool %d requested work restart", pool->pool_no);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        v177 = "";
        if ( v1->gbt )
          v177 = "GBT ";
        snprintf((char *)tmp42, 0x800u, "%sLONGPOLL from pool %d requested work restart", v177, v1->pool->pool_no);
        applog(5, tmp42, 0);
      }
      restart_threads();
    }
  }
out:
  v1->longpoll = 0;
  return v2;
}
// 257C4: variable 'v17' is possibly undefined
// 257C4: variable 'v18' is possibly undefined
// 257D2: variable 'v19' is possibly undefined
// 257D2: variable 'v20' is possibly undefined
// 25800: variable 'v21' is possibly undefined
// 25800: variable 'v22' is possibly undefined
// 2580E: variable 'v157' is possibly undefined
// 2580E: variable 'v158' is possibly undefined
// 2581A: variable 'v174' is possibly undefined
// 2581A: variable 'v175' is possibly undefined
// 25826: variable 'v172' is possibly undefined
// 25826: variable 'v173' is possibly undefined
// 25832: variable 'v168' is possibly undefined
// 25832: variable 'v169' is possibly undefined
// 2583E: variable 'v166' is possibly undefined
// 2583E: variable 'v167' is possibly undefined
// 2584A: variable 'v13' is possibly undefined
// 2584A: variable 'v14' is possibly undefined
// 25858: variable 'v15' is possibly undefined
// 25858: variable 'v16' is possibly undefined

//----- (00025898) --------------------------------------------------------
void __fastcall stage_work(work *work)
{
  pthread_mutex_t *v2; // r0
  const unsigned __int8 *v3; // r2
  int v4; // r3
  thread_q *v5; // r0
  _BOOL4 frozen; // r5
  int v7; // r7
  work *v8; // r4
  unsigned int v9; // r2
  unsigned int v10; // r0
  unsigned int v11; // r1
  unsigned int v12; // r2
  unsigned int v13; // r3
  int v14; // r1
  unsigned int v15; // r7
  UT_hash_table *tbl; // r3
  UT_hash_handle_0 *p_hh; // r8
  UT_hash_table *v18; // r2
  UT_hash_handle *tail; // r0
  UT_hash_table *v20; // r1
  ptrdiff_t hho; // r3
  UT_hash_bucket_0 *buckets; // r0
  int v23; // r7
  UT_hash_handle *hh_head; // r6
  unsigned int v25; // r2
  unsigned int expand_mult; // r1
  UT_hash_table *v27; // r3
  size_t v28; // r4
  UT_hash_bucket_0 *v29; // r0
  UT_hash_bucket_0 *v30; // r7
  UT_hash_table *v31; // r11
  unsigned int num_buckets; // r3
  unsigned int num_items; // r4
  unsigned int log2_num_buckets; // r1
  unsigned int v35; // r1
  int v36; // r12
  unsigned int v37; // r9
  UT_hash_handle *v38; // r4
  UT_hash_handle *hh_next; // r8
  int v40; // r5
  UT_hash_bucket_0 *v41; // r6
  unsigned int v42; // r0
  UT_hash_handle *v43; // r3
  UT_hash_table *v44; // r3
  unsigned int v45; // r1
  unsigned int nonideal_items; // r2
  unsigned int v47; // r4
  unsigned int v48; // r0
  unsigned int v49; // r2
  bool v50; // cc
  UT_hash_table *v51; // r6
  UT_hash_handle_0 *v52; // lr
  int v53; // r0
  UT_hash_handle_0 *v54; // r4
  UT_hash_handle *v55; // r5
  unsigned int v56; // r12
  UT_hash_handle_0 *next; // r3
  int v58; // r2
  ptrdiff_t v59; // r1
  UT_hash_handle_0 *v60; // r1
  int v61; // r7
  bool v62; // zf
  UT_hash_handle_0 *v63; // r9
  ptrdiff_t v64; // r3
  char *v65; // r8
  char *v66; // r3
  bool v67; // zf
  work *v68; // r3
  const unsigned __int8 *v69; // r2
  int v70; // r3
  void *v71; // r8
  int v72; // r8
  ptrdiff_t v73; // r3
  UT_hash_table *v74; // r0
  UT_hash_table *v75; // r5
  UT_hash_bucket_0 *v76; // r0
  unsigned int v77; // [sp+8h] [bp-838h]
  UT_hash_bucket_0 *ptr; // [sp+Ch] [bp-834h]
  int v79; // [sp+10h] [bp-830h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-828h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Pushing work from pool %d to hash queue", work->pool->pool_no);
    applog(7, tmp42, 0);
  }
  work->work_block = work_block;
  test_work_current(work);
  v2 = stgd_lock;
  ++work->pool->works;
  if ( pthread_mutex_lock(v2) )
    mutex_lock_2((pthread_mutex_t *)&_func___13962, (const unsigned __int8 *)0x1628, v3, v4);
  if ( !work->clone && work->rolltime )
    ++staged_rollable;
  v5 = getq;
  frozen = getq->frozen;
  if ( getq->frozen )
    goto LABEL_76;
  v7 = LOBYTE(work->id) + 17973517 + (HIBYTE(work->id) << 24) + (BYTE2(work->id) << 16) + (BYTE1(work->id) << 8);
  work->hh.keylen = 4;
  v8 = staged_work;
  v9 = (-1622558010 - (((unsigned int)&cgpu.results[5][4186] + 1) ^ v7)) ^ ((((unsigned int)&cgpu.results[5][4186] + 1) ^ v7) << 8);
  work->hh.key = &work->id;
  v10 = (-17973517 - (((unsigned int)&cgpu.results[5][4186] + 1) ^ v7) - v9) ^ (v9 >> 13);
  v11 = ((((unsigned int)&cgpu.results[5][4186] + 1) ^ v7) - v9 - v10) ^ (v10 >> 12);
  v12 = (v9 - v10 - v11) ^ (v11 << 16);
  v13 = (v10 - v11 - v12) ^ (v12 >> 5);
  v14 = (v11 - v12 - v13) ^ (v13 >> 3);
  v15 = (v13 - v14 - ((v12 - v13 - v14) ^ (v14 << 10))) ^ (((v12 - v13 - v14) ^ (v14 << 10)) >> 15);
  work->hh.hashv = v15;
  if ( v8 )
  {
    tbl = v8->hh.tbl;
    p_hh = &work->hh;
    work->hh.next = (void *)frozen;
    work->hh.tbl = tbl;
    v18 = v8->hh.tbl;
    tail = v18->tail;
    v20 = v18;
    hho = v18->hho;
    tail->next = work;
    work->hh.prev = (char *)tail - hho;
    v18->tail = &work->hh;
  }
  else
  {
    work->hh.next = 0;
    work->hh.prev = 0;
    staged_work = work;
    v74 = (UT_hash_table *)malloc(0x2Cu);
    v75 = v74;
    work->hh.tbl = v74;
    if ( !v74 )
      goto LABEL_100;
    v74->buckets = 0;
    p_hh = &work->hh;
    v74->num_items = 0;
    v74->tail = 0;
    v74->hho = 0;
    v74->ideal_chain_maxlen = 0;
    v74->nonideal_items = 0;
    v74->ineff_expands = 0;
    v74->noexpand = 0;
    v74->signature = 0;
    v74->tail = &work->hh;
    v74->num_buckets = 32;
    v74->log2_num_buckets = 5;
    v74->hho = 344;
    v76 = (UT_hash_bucket_0 *)malloc(0x180u);
    v75->buckets = v76;
    if ( !v76 )
      goto LABEL_100;
    memset(v76, 0, 0x180u);
    v8 = staged_work;
    v20 = staged_work->hh.tbl;
    v20->signature = -1609490463;
  }
  buckets = v20->buckets;
  v23 = v15 & (v20->num_buckets - 1);
  ++v20->num_items;
  hh_head = buckets[v23].hh_head;
  v25 = buckets[v23].count + 1;
  buckets[v23].count = v25;
  work->hh.hh_next = hh_head;
  work->hh.hh_prev = 0;
  if ( hh_head )
    hh_head->hh_prev = p_hh;
  expand_mult = buckets[v23].expand_mult;
  buckets[v23].hh_head = p_hh;
  if ( v25 >= 10 * (expand_mult + 1) )
  {
    v27 = work->hh.tbl;
    if ( v27->noexpand != 1 )
    {
      v28 = 24 * v27->num_buckets;
      v29 = (UT_hash_bucket_0 *)malloc(v28);
      v30 = v29;
      if ( v29 )
      {
        memset(v29, 0, v28);
        v31 = work->hh.tbl;
        num_buckets = v31->num_buckets;
        num_items = v31->num_items;
        log2_num_buckets = v31->log2_num_buckets;
        v31->nonideal_items = 0;
        v35 = num_items >> (log2_num_buckets + 1);
        v36 = 2 * num_buckets - 1;
        if ( (v36 & num_items) != 0 )
          v37 = v35 + 1;
        else
          v37 = v35;
        v31->ideal_chain_maxlen = v37;
        if ( num_buckets )
        {
          v77 = 0;
          ptr = v31->buckets;
          v79 = 12 * num_buckets;
          do
          {
            v38 = ptr[v77 / 0xC].hh_head;
            if ( v38 )
            {
              do
              {
                hh_next = v38->hh_next;
                v40 = v36 & v38->hashv;
                v41 = &v30[v36 & v38->hashv];
                v42 = v41->count + 1;
                v41->count = v42;
                if ( v37 < v42 )
                {
                  ++v31->nonideal_items;
                  v41->expand_mult = v42 / v37;
                }
                v43 = v30[v40].hh_head;
                v38->hh_prev = 0;
                v38->hh_next = v43;
                if ( v43 )
                  v43->hh_prev = v38;
                v30[v40].hh_head = v38;
                v38 = hh_next;
              }
              while ( hh_next );
            }
            v77 += 12;
          }
          while ( v77 != v79 );
          free(ptr);
        }
        else
        {
          free(v31->buckets);
        }
        v44 = work->hh.tbl;
        v45 = v44->num_items;
        nonideal_items = v44->nonideal_items;
        v47 = v44->num_buckets;
        v48 = v44->log2_num_buckets;
        v44->buckets = v30;
        v44->log2_num_buckets = v48 + 1;
        v44->num_buckets = 2 * v47;
        if ( nonideal_items <= v45 >> 1 )
        {
          v44->ineff_expands = 0;
          v8 = staged_work;
        }
        else
        {
          v49 = v44->ineff_expands + 1;
          v50 = v49 > 1;
          v44->ineff_expands = v49;
          if ( v49 > 1 )
            v49 = (unsigned __int16)&jedata;
          else
            v45 = (unsigned __int16)&jedata;
          if ( v50 )
            HIWORD(v49) = (unsigned int)&jedata >> 16;
          else
            HIWORD(v45) = (unsigned int)&jedata >> 16;
          if ( v50 )
          {
            v8 = *(work **)(v49 + 0x458);
            v44->noexpand = 1;
          }
          else
          {
            v8 = *(work **)(v45 + 0x458);
          }
        }
        if ( !v8 )
        {
          v5 = getq;
          goto LABEL_76;
        }
        goto LABEL_43;
      }
LABEL_100:
      exit(-1);
    }
  }
LABEL_43:
  v51 = v8->hh.tbl;
  v52 = &v8->hh;
  v53 = 1;
  do
  {
    v54 = v52;
    v52 = 0;
    v55 = 0;
    v56 = 0;
    do
    {
      ++v56;
      if ( v53 )
      {
        next = (UT_hash_handle_0 *)v54->next;
        v58 = 1;
        if ( next )
        {
          v59 = v51->hho;
          v58 = 1;
          for ( next = (UT_hash_handle_0 *)((char *)next + v59); next; next = (UT_hash_handle_0 *)((char *)next + v59) )
          {
            if ( v58 == v53 )
              break;
            next = (UT_hash_handle_0 *)next->next;
            ++v58;
            if ( !next )
              break;
          }
        }
        v60 = v54;
        v61 = v53;
        v54 = next;
      }
      else
      {
        v60 = v54;
        v58 = 0;
        v61 = 0;
      }
LABEL_53:
      while ( v58 )
      {
LABEL_54:
        v62 = v61 == 0;
        if ( v61 )
          v62 = v54 == 0;
        if ( v62 )
        {
          if ( v60 )
          {
            v63 = (UT_hash_handle_0 *)v60->next;
            if ( v63 )
              v63 = (UT_hash_handle_0 *)((char *)v63 + v51->hho);
          }
          else
          {
LABEL_93:
            v63 = v60;
          }
LABEL_61:
          --v58;
          if ( !v55 )
            goto LABEL_91;
LABEL_62:
          if ( !v60 )
            goto LABEL_82;
          goto LABEL_63;
        }
        v73 = v51->hho;
        if ( *(void **)((char *)&v60[8].next - v73) - *(void **)((char *)&v54[8].next - v73) > 0 )
        {
          v72 = (int)v54->next;
          if ( !v72 )
            goto LABEL_80;
          v72 += v73;
          --v61;
          if ( v55 )
            goto LABEL_81;
LABEL_86:
          v55 = v54;
          v66 = 0;
          v54 = (UT_hash_handle_0 *)v72;
          v52 = v55;
          goto LABEL_64;
        }
        if ( !v60 )
          goto LABEL_93;
        v63 = (UT_hash_handle_0 *)v60->next;
        if ( !v63 )
          goto LABEL_61;
        v63 = (UT_hash_handle_0 *)((char *)v63 + v73);
        --v58;
        if ( v55 )
          goto LABEL_62;
LABEL_91:
        if ( v60 )
        {
          v55 = v60;
          v66 = 0;
          v60 = v63;
          v52 = v55;
          goto LABEL_64;
        }
        v52 = 0;
        v60 = v63;
        v55 = 0;
      }
      while ( 1 )
      {
        v67 = v54 == 0;
        if ( v54 )
          v67 = v61 == 0;
        if ( v67 )
          break;
        v71 = v54->next;
        if ( v71 )
          v72 = (int)v71 + v51->hho;
        else
          v72 = v58;
LABEL_80:
        --v61;
        if ( !v55 )
          goto LABEL_86;
LABEL_81:
        v63 = v60;
        v60 = v54;
        v54 = (UT_hash_handle_0 *)v72;
        if ( !v60 )
        {
LABEL_82:
          v55->next = v60;
          v55 = v60;
          v60 = v63;
          goto LABEL_53;
        }
LABEL_63:
        v64 = v51->hho;
        v65 = (char *)v60 - v64;
        v66 = (char *)v55 - v64;
        v55->next = v65;
        v55 = v60;
        v60 = v63;
LABEL_64:
        v55->prev = v66;
        if ( v58 )
          goto LABEL_54;
      }
    }
    while ( v54 );
    if ( v55 )
      v55->next = 0;
    if ( v56 <= 1 )
      goto LABEL_75;
    v53 *= 2;
  }
  while ( v52 );
  v55 = 0;
LABEL_75:
  v5 = getq;
  v68 = (work *)((char *)v52 - v51->hho);
  v51->tail = v55;
  staged_work = v68;
LABEL_76:
  pthread_cond_broadcast(&v5->cond);
  if ( pthread_mutex_unlock(stgd_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13962, (const unsigned __int8 *)0x163A, v69, v70);
  selective_yield();
}
// 25DDE: variable 'v3' is possibly undefined
// 25DDE: variable 'v4' is possibly undefined
// 25DEA: variable 'v69' is possibly undefined
// 25DEA: variable 'v70' is possibly undefined

//----- (00025DF8) --------------------------------------------------------
void __fastcall inc_work_stats(thr_info *thr, pool *pool, int diff1)
{
  const unsigned __int8 *v6; // r2
  int v7; // r3
  cgpu_info *cgpu; // r10
  int64_t v9; // r2
  const unsigned __int8 *v10; // r2
  int v11; // r3
  pool *v12; // r0

  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13962.__size[12], (const unsigned __int8 *)0x2212, v6, v7);
  cgpu = thr->cgpu;
  v9 = cgpu->diff1 + diff1;
  total_diff1 += diff1;
  cgpu->diff1 = v9;
  if ( pool )
  {
    pool->diff1 += diff1;
  }
  else
  {
    v12 = current_pool();
    cgpu = thr->cgpu;
    v12->diff1 += diff1;
  }
  cgpu->last_device_valid_work = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13962.__size[12], (const unsigned __int8 *)0x2220, v10, v11);
  selective_yield();
}
// 25E80: variable 'v10' is possibly undefined
// 25E80: variable 'v11' is possibly undefined
// 25E8C: variable 'v6' is possibly undefined
// 25E8C: variable 'v7' is possibly undefined

//----- (00025EA4) --------------------------------------------------------
void __fastcall pool_died(pool *pool)
{
  pool *v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  if ( !pool_tset(pool, &pool->idle) )
  {
    cgtime(&pool->tv_idle);
    v2 = current_pool();
    if ( v2 == pool )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d %s not responding!", v2->pool_no, (const char *)v2->rpc_url);
        applog(4, tmp42, 0);
      }
      switch_pools(0);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s failed to return work", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
}

//----- (00025F50) --------------------------------------------------------
void *__fastcall start_routine(void *arg)
{
  const unsigned __int8 *v3; // r2
  int v4; // r3
  const unsigned __int8 *v5; // r2
  int v6; // r3
  _BOOL4 v7; // r5
  int v8; // r5
  const unsigned __int8 *v9; // r2
  int v10; // r3
  const unsigned __int8 *v11; // r2
  int v12; // r3
  pthread_t v13; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  if ( !*((_BYTE *)arg + 107) )
  {
    v13 = pthread_self();
    pthread_detach(v13);
  }
  while ( !*((_BYTE *)arg + 105) )
  {
    if ( pool_active((pool *)arg, 0) )
    {
      pool_tclear((pool *)arg, (bool *)arg + 97);
      if ( pthread_mutex_lock(&control_lock.mutex) )
        mutex_lock_2((pthread_mutex_t *)&_func___15166, (const unsigned __int8 *)0x2982, v3, v4);
      if ( pthread_rwlock_wrlock(&control_lock.rwlock) )
        wr_lock_0((pthread_rwlock_t *)&_func___15166, (const unsigned __int8 *)0x2982, v5, v6);
      v7 = 0;
      if ( !pools_active )
      {
        v8 = *(_DWORD *)arg;
        currentpool = (pool *)arg;
        pools_active = 1;
        v7 = v8 != 0;
      }
      if ( pthread_rwlock_unlock(&control_lock.rwlock) )
        rw_unlock_1((pthread_rwlock_t *)&_func___15166, (const unsigned __int8 *)0x2990, v9, v10);
      if ( pthread_mutex_unlock(&control_lock.mutex) )
        mutex_unlock_noyield_2((pthread_mutex_t *)&_func___15166, (const unsigned __int8 *)0x2990, v11, v12);
      selective_yield();
      if ( v7 && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Switching to pool %d %s - first alive pool",
          *(_DWORD *)arg,
          *((const char **)arg + 41));
        applog(5, tmp42, 0);
      }
      pool_resus((pool *)arg);
      switch_pools(0);
LABEL_16:
      *((_BYTE *)arg + 284) = 0;
      return 0;
    }
    pool_died((pool *)arg);
    if ( *((_BYTE *)arg + 107) )
      goto LABEL_16;
    sleep(0x1Eu);
  }
  return 0;
}
// 26004: variable 'v5' is possibly undefined
// 26004: variable 'v6' is possibly undefined
// 26010: variable 'v9' is possibly undefined
// 26010: variable 'v10' is possibly undefined
// 2601C: variable 'v11' is possibly undefined
// 2601C: variable 'v12' is possibly undefined
// 2605C: variable 'v3' is possibly undefined
// 2605C: variable 'v4' is possibly undefined

//----- (00026088) --------------------------------------------------------
void *__fastcall __noreturn watchpool_thread(void *userdata)
{
  int v1; // r0
  int v2; // r6
  pool *v3; // r4
  int64_t diff1; // r10
  double v5; // r0
  double utility; // d7
  double v7; // d7
  int prio; // r5
  const unsigned __int8 *v9; // r2
  int v10; // r3
  list_head *next; // r3
  list_head **p_prev; // lr
  int v13; // r5
  int curls; // r0
  int v15; // r11
  list_head *v16; // r3
  pool *v17; // r2
  list_head *v18; // r2
  list_head *v19; // r1
  const unsigned __int8 *v20; // r2
  int v21; // r3
  const char *v22; // r5
  const unsigned __int8 *v23; // r2
  int v24; // r3
  stratum_share *v25; // r11
  stratum_share *v26; // r10
  stratum_share *v27; // r5
  char *prev; // r2
  stratum_share *v29; // r1
  stratum_share *v30; // r3
  ptrdiff_t hho; // r12
  UT_hash_table *tbl; // r3
  stratum_share **v33; // r12
  UT_hash_handle *hh_next; // r1
  int v35; // r0
  UT_hash_handle *hh_prev; // r2
  const unsigned __int8 *v37; // r2
  int v38; // r3
  int64_t v39; // r2
  list_head *v40; // [sp+8h] [bp-860h]
  stratum_share *v41; // [sp+8h] [bp-860h]
  int intervals; // [sp+10h] [bp-858h]
  pthread_mutex_t *mutex; // [sp+14h] [bp-854h]
  cgtimer_t cgt; // [sp+18h] [bp-850h] BYREF
  timeval now; // [sp+20h] [bp-848h] BYREF
  timeval tv; // [sp+28h] [bp-840h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp-838h] BYREF

  intervals = 0;
  pthread_setcanceltype(1, 0);
  RenameThread("Watchpool");
  set_lowprio();
  cgtimer_time(&cgt);
  while ( 1 )
  {
    cgtime(&now);
    v1 = intervals + 1;
    if ( intervals + 1 > 120 )
      v1 = 0;
    intervals = v1;
    if ( total_pools > 0 )
    {
      v2 = 0;
      while ( 1 )
      {
        v3 = pools[v2];
        if ( !opt_benchmark && !opt_benchfile )
          break;
LABEL_14:
        if ( intervals == 120 )
        {
          diff1 = v3->diff1;
          v5 = (double)(diff1 - v3->last_shares);
          utility = v3->utility;
          v3->last_shares = diff1;
          v7 = (utility + v5 * 0.63) / 1.63;
          v3->utility = v7;
          v3->shares = (int)v7;
        }
        if ( v3->enabled && !v3->testing )
        {
          if ( pool_active(v3, 1) )
          {
            if ( pool_tclear(v3, &v3->idle) )
              pool_resus(v3);
          }
          else
          {
            cgtime(&v3->tv_idle);
          }
          if ( !v3->idle && pool_strategy_0 == POOL_FAILOVER )
          {
            prio = v3->prio;
            if ( prio < cp_prio() && now.tv_sec - v3->tv_idle.tv_sec > opt_pool_fallback )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 3 )
              {
                snprintf(
                  (char *)tmp42,
                  0x800u,
                  "Pool %d %s stable for >%d seconds",
                  v3->pool_no,
                  (const char *)v3->rpc_url,
                  opt_pool_fallback);
                applog(4, tmp42, 0);
              }
              switch_pools(0);
            }
          }
        }
        if ( total_pools <= ++v2 )
          goto LABEL_20;
      }
      cgtime(&tv);
      if ( pthread_mutex_lock(&v3->pool_lock) )
        mutex_lock_2((pthread_mutex_t *)(&_func___15166.__align + 5), (const unsigned __int8 *)0x271D, v9, v10);
      next = v3->curlring.next;
      p_prev = &next[-1].prev;
      v13 = (int)&next->next[-1].prev;
      if ( &v3->curlring != next )
      {
        curls = v3->curls;
        if ( curls > 1 )
        {
          v15 = 0;
          v16 = 0;
          while ( 1 )
          {
            if ( tv.tv_sec - (int)p_prev[3] > 300 )
            {
              v18 = p_prev[2];
              v19 = p_prev[1];
              ++v15;
              v3->curls = curls - 1;
              v19->prev = v18;
              v18->next = v19;
              p_prev[2] = v16;
              p_prev[1] = v16;
              v40 = v16;
              free(p_prev);
              v16 = v40;
            }
            p_prev = (list_head **)v13;
            v17 = (pool *)(v13 + 4);
            v13 = *(_DWORD *)(v13 + 4) - 4;
            if ( &v3->curlring == (list_head *)v17 )
              break;
            curls = v3->curls;
            if ( curls <= 1 )
              goto LABEL_48;
          }
LABEL_39:
          if ( pthread_mutex_unlock(&v3->pool_lock) )
            mutex_unlock_noyield_2(
              (pthread_mutex_t *)(&_func___15166.__align + 5),
              (const unsigned __int8 *)0x272F,
              v20,
              v21);
          selective_yield();
          if ( v15 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            v22 = "";
            if ( v15 != 1 )
              v22 = "s";
            snprintf((char *)tmp42, 0x800u, "Reaped %d curl%s from pool %d", v15, v22, v3->pool_no);
            applog(7, tmp42, 0);
          }
        }
LABEL_48:
        mutex = (pthread_mutex_t *)time(0);
        if ( pthread_mutex_lock(&sshare_lock) )
          mutex_lock_2((pthread_mutex_t *)&_func___15009, (const unsigned __int8 *)0x2741, v23, v24);
        v25 = stratum_shares;
        v26 = stratum_shares;
        if ( stratum_shares )
        {
          v26 = 0;
          v27 = (stratum_share *)stratum_shares->hh.next;
          if ( v3 == stratum_shares->work->pool )
            goto LABEL_53;
LABEL_51:
          while ( v27 )
          {
            while ( 1 )
            {
              v25 = v27;
              v27 = (stratum_share *)v27->hh.next;
              if ( v3 != v25->work->pool )
                break;
LABEL_53:
              if ( (int)mutex <= v25->sshare_time + 120 )
                goto LABEL_51;
              prev = (char *)v25->hh.prev;
              v29 = (stratum_share *)v25->hh.next;
              if ( prev || v29 )
              {
                v30 = stratum_shares;
                hho = stratum_shares->hh.tbl->hho;
                if ( v25 == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - hho) )
                  stratum_shares->hh.tbl->tail = (UT_hash_handle *)&prev[hho];
                if ( prev )
                {
                  *(_DWORD *)&prev[hho + 8] = v29;
                  v29 = (stratum_share *)v25->hh.next;
                }
                else
                {
                  v30 = v29;
                  stratum_shares = v29;
                }
                tbl = v30->hh.tbl;
                if ( v29 )
                  *(void **)((char *)&v29->hh.prev + tbl->hho) = prev;
                v33 = (stratum_share **)&tbl->buckets[(tbl->num_buckets - 1) & v25->hh.hashv];
                hh_next = v25->hh.hh_next;
                v35 = (int)&v33[1][-1].sshare_sent + 3;
                if ( v25 == *v33 )
                  tbl->buckets[(tbl->num_buckets - 1) & v25->hh.hashv].hh_head = hh_next;
                hh_prev = v25->hh.hh_prev;
                v33[1] = (stratum_share *)v35;
                if ( hh_prev )
                {
                  hh_prev->hh_next = hh_next;
                  hh_next = v25->hh.hh_next;
                }
                if ( hh_next )
                  hh_next->hh_prev = hh_prev;
                --tbl->num_items;
              }
              else
              {
                v41 = stratum_shares;
                free(stratum_shares->hh.tbl->buckets);
                free(v41->hh.tbl);
                stratum_shares = 0;
              }
              free_work(&v25->work, "cgminer.c", (const unsigned __int8 *)&_func___15009, 10056);
              v26 = (stratum_share *)((char *)v26 + 1);
              free(v25);
              if ( !v27 )
                goto LABEL_69;
            }
          }
        }
LABEL_69:
        if ( pthread_mutex_unlock(&sshare_lock) )
          mutex_unlock_noyield_2((pthread_mutex_t *)&_func___15009, (const unsigned __int8 *)0x274E, v37, v38);
        selective_yield();
        if ( v26 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Lost %d shares due to no stratum share response from pool %d",
              v26,
              v3->pool_no);
            applog(4, tmp42, 0);
          }
          v39 = total_stale;
          v3->stale_shares += (unsigned int)v26;
          total_stale = (int64_t)v26 + v39;
        }
        goto LABEL_14;
      }
      v15 = 0;
      goto LABEL_39;
    }
LABEL_20:
    if ( current_pool()->idle )
    {
      switch_pools(0);
      if ( pool_strategy_0 != POOL_ROTATE )
        goto LABEL_22;
    }
    else if ( pool_strategy_0 != POOL_ROTATE )
    {
      goto LABEL_22;
    }
    if ( now.tv_sec - rotate_tv.tv_sec > 60 * opt_rotate_period )
    {
      cgtime(&rotate_tv);
      switch_pools(0);
    }
LABEL_22:
    cgsleep_ms_r(&cgt, 5000);
    cgtimer_time(&cgt);
  }
}
// 2655E: variable 'v20' is possibly undefined
// 2655E: variable 'v21' is possibly undefined
// 2656A: variable 'v23' is possibly undefined
// 2656A: variable 'v24' is possibly undefined
// 26576: variable 'v37' is possibly undefined
// 26576: variable 'v38' is possibly undefined
// 26582: variable 'v9' is possibly undefined
// 26582: variable 'v10' is possibly undefined

//----- (000265AC) --------------------------------------------------------
void *__fastcall stratum_rthread(void *userdata)
{
  pthread_t v2; // r0
  fd_set *v3; // r3
  int v4; // r3
  int v5; // r2
  int v6; // r0
  unsigned __int8 *v7; // r5
  const unsigned __int8 *v8; // r2
  int v9; // r3
  const unsigned __int8 *v10; // r2
  int v11; // r3
  _BOOL4 v13; // r3
  unsigned int v14; // r2
  const unsigned __int8 *v15; // r2
  int v16; // r3
  const unsigned __int8 *v17; // r2
  int v18; // r3
  const unsigned __int8 *v19; // r2
  int v20; // r3
  int v21; // r4
  const unsigned __int8 *v22; // r2
  int v23; // r3
  json_t_0 *v24; // r0
  json_t_0 *v25; // r0
  const unsigned __int8 *v26; // r2
  int v27; // r3
  stratum_share *v28; // r10
  unsigned int v29; // r2
  unsigned int v30; // r1
  unsigned int v31; // r4
  int v32; // r0
  unsigned int v33; // r2
  unsigned int v34; // r1
  stratum_share *hh_head; // r4
  unsigned int v36; // r2
  int v37; // r0
  unsigned int v38; // r6
  UT_hash_table *tbl; // r8
  UT_hash_bucket_0 *buckets; // r7
  const unsigned __int8 *v41; // r2
  int v42; // r3
  int v43; // lr
  int v44; // r3
  double work_difficulty; // d0
  unsigned int v46; // r8
  const char *v47; // r2
  pool *pool; // r8
  cgpu_info *cgpu; // r10
  const unsigned __int8 *v50; // r2
  int v51; // r3
  double diff_rejected; // d5
  double v53; // d7
  double v54; // d6
  int64_t rejected; // r2
  double v56; // d4
  int seq_rejects; // r0
  int64_t v58; // r2
  const unsigned __int8 *v59; // r2
  int v60; // r3
  const unsigned __int8 *v61; // r7
  unsigned int v62; // r0
  char *v63; // lr
  int v64; // r10
  stratum_share *v65; // r0
  int v66; // r4
  size_t refcount; // r3
  _BOOL4 v68; // r3
  char *prev; // r1
  stratum_share *next; // r3
  ptrdiff_t hho; // r7
  char *v72; // r0
  UT_hash_table *v73; // r3
  int v74; // r6
  stratum_share **v75; // r7
  UT_hash_handle *hh_next; // r2
  int v77; // r0
  UT_hash_handle *hh_prev; // r1
  work *v79; // r0
  work *v80; // r0
  unsigned __int8 *v81; // r7
  size_t v82; // r3
  const unsigned __int8 *v83; // r2
  int v84; // r3
  const unsigned __int8 *v85; // r2
  int v86; // r3
  const unsigned __int8 *v87; // r2
  int v88; // r3
  double v89; // d8
  const unsigned __int8 *v90; // r2
  int v91; // r3
  const unsigned __int8 *v92; // r2
  int v93; // r3
  int64_t v94; // r0
  double v95; // d7
  double v96; // d8
  const unsigned __int8 *v97; // r2
  int v98; // r3
  const unsigned __int8 *v99; // r2
  int v100; // r3
  double v101; // d7
  double diff_accepted; // d6
  __int64 v103; // r2
  double v104; // d4
  double v105; // d5
  int64_t v106; // r2
  const unsigned __int8 *v107; // r2
  int v108; // r3
  int pool_no; // r3
  time_t v110; // r0
  _BOOL4 v111; // r1
  double v112; // r2
  char *v113; // r0
  json_t_0 *v114; // r0
  const unsigned __int8 *v115; // r0
  const unsigned __int8 *v116; // r2
  int v117; // r3
  int64_t v118; // r0
  double v119; // d7
  double v120; // d8
  const unsigned __int8 *v121; // r2
  int v122; // r3
  work *v123; // [sp+18h] [bp-A90h]
  const json_t_0 *v124; // [sp+28h] [bp-A80h]
  unsigned int v125; // [sp+28h] [bp-A80h]
  json_t_0 *json; // [sp+2Ch] [bp-A7Ch]
  const json_t_0 *v127; // [sp+30h] [bp-A78h]
  work *work; // [sp+3Ch] [bp-A6Ch] BYREF
  int s2; // [sp+40h] [bp-A68h] BYREF
  timeval timeout; // [sp+44h] [bp-A64h] BYREF
  unsigned __int8 threadname[16]; // [sp+4Ch] [bp-A5Ch] BYREF
  char v132[20]; // [sp+5Ch] [bp-A4Ch] BYREF
  char v133[2]; // [sp+70h] [bp-A38h] BYREF
  char dest[30]; // [sp+72h] [bp-A36h] BYREF
  unsigned __int8 buf[7]; // [sp+90h] [bp-A18h] BYREF
  char v136[29]; // [sp+97h] [bp-A11h] BYREF
  char v137[60]; // [sp+B4h] [bp-9F4h] BYREF
  char v138; // [sp+F0h] [bp-9B8h] BYREF
  fd_set rd; // [sp+F4h] [bp-9B4h] BYREF
  json_error_t error; // [sp+174h] [bp-934h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+270h] [bp-838h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf((char *)threadname, 0x10u, "%d/RStratum", *(_DWORD *)userdata);
  RenameThread(threadname);
  while ( !*((_BYTE *)userdata + 105) )
  {
    if ( !sock_full((pool *)userdata) && !cnx_needed((pool *)userdata) )
    {
      suspend_stratum((pool *)userdata);
      clear_stratum_shares((pool *)userdata);
      clear_pool_work((pool *)userdata);
      while ( !cnx_needed((pool *)userdata)
           && (!*((_DWORD *)userdata + 25)
            || userdata != current_pool() && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE) )
      {
        if ( pthread_mutex_lock(&lp_lock) )
          mutex_lock_2((pthread_mutex_t *)&_func___14979, (const unsigned __int8 *)0x2628, v8, v9);
        pthread_cond_wait(&lp_cond, &lp_lock);
        if ( pthread_mutex_unlock(&lp_lock) )
          mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14979, (const unsigned __int8 *)0x262A, v10, v11);
        selective_yield();
      }
      while ( !restart_stratum((pool *)userdata) )
      {
        pool_died((pool *)userdata);
        if ( *((_BYTE *)userdata + 105) )
          return 0;
        cgsleep_ms(5000);
      }
    }
    v3 = (fd_set *)&v138;
    do
    {
      v3->fds_bits[1] = 0;
      v3 = (fd_set *)((char *)v3 + 4);
    }
    while ( v3 != (fd_set *)&rd.fds_bits[31] );
    v4 = *((_DWORD *)userdata + 147);
    timeout.tv_usec = 0;
    timeout.tv_sec = 90;
    if ( v4 < 0 )
      v5 = v4 + 31;
    else
      v5 = v4;
    rd.fds_bits[v5 >> 5] |= 1 << (v4 % 32);
    if ( sock_full((pool *)userdata) || (v6 = select(*((_DWORD *)userdata + 147) + 1, &rd, 0, 0, &timeout), v6 > 0) )
    {
      v7 = recv_line((pool *)userdata);
      if ( !v7 )
        goto LABEL_31;
      stratum_resumed((pool *)userdata);
      if ( parse_method((pool *)userdata, v7) )
        goto LABEL_13;
      v24 = json_loads(v7, 0, &error);
      json = v24;
      if ( v24 )
      {
        v124 = json_object_get(v24, "result");
        v127 = json_object_get(json, (const unsigned __int8 *)"error");
        v25 = json_object_get(json, "id");
        if ( !v25 || v25->type == JSON_NULL )
        {
          if ( v127 )
          {
            v81 = json_dumps(v127, 3u);
          }
          else
          {
            v113 = (char *)malloc(0x11u);
            v81 = (unsigned __int8 *)v113;
            if ( v113 )
              strcpy(v113, "(unknown reason)");
          }
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "JSON-RPC non method decode failed: %s", (const char *)v81);
            applog(6, tmp42, 0);
          }
          v66 = 0;
          free(v81);
        }
        else
        {
          s2 = json_integer_value(v25);
          if ( pthread_mutex_lock(&sshare_lock) )
            mutex_lock_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C0A, v26, v27);
          v28 = stratum_shares;
          v29 = ((unsigned int)&::cgpu.results[5][4186] + 1) ^ ((unsigned __int8)s2
                                                              + 17973517
                                                              + (HIBYTE(s2) << 24)
                                                              + (BYTE2(s2) << 16)
                                                              + (BYTE1(s2) << 8));
          v30 = (-1622558010 - v29) ^ (v29 << 8);
          v31 = (-17973517 - v29 - v30) ^ (v30 >> 13);
          v32 = (v29 - v30 - v31) ^ (v31 >> 12);
          v33 = v31 - v32;
          v34 = (v30 - v31 - v32) ^ (v32 << 16);
          hh_head = stratum_shares;
          v36 = (v33 - v34) ^ (v34 >> 5);
          v37 = (v32 - v34 - v36) ^ (v36 >> 3);
          v38 = (v36 - v37 - ((v34 - v36 - v37) ^ (v37 << 10))) ^ (((v34 - v36 - v37) ^ (v37 << 10)) >> 15);
          if ( stratum_shares )
          {
            tbl = stratum_shares->hh.tbl;
            buckets = stratum_shares->hh.tbl->buckets;
            hh_head = (stratum_share *)buckets[(stratum_shares->hh.tbl->num_buckets - 1) & v38].hh_head;
            if ( hh_head )
              hh_head = (stratum_share *)((char *)hh_head - tbl->hho);
            while ( hh_head )
            {
              if ( v38 == hh_head->hh.hashv && hh_head->hh.keylen == 4 && !memcmp(hh_head->hh.key, &s2, 4u) )
              {
                prev = (char *)hh_head->hh.prev;
                next = (stratum_share *)hh_head->hh.next;
                if ( prev || next )
                {
                  hho = tbl->hho;
                  if ( hh_head == (stratum_share *)((char *)tbl->tail - hho) )
                    tbl->tail = (UT_hash_handle *)&prev[hho];
                  if ( prev )
                  {
                    *(_DWORD *)&prev[hho + 8] = next;
                    v72 = (char *)hh_head->hh.next;
                  }
                  else
                  {
                    v28 = next;
                    v72 = (char *)next;
                    stratum_shares = next;
                  }
                  v73 = v28->hh.tbl;
                  if ( v72 )
                    *(_DWORD *)&v72[v73->hho + 4] = prev;
                  v74 = v38 & (v73->num_buckets - 1);
                  v75 = (stratum_share **)&v73->buckets[v74];
                  hh_next = hh_head->hh.hh_next;
                  v77 = (int)&v75[1][-1].sshare_sent + 3;
                  if ( hh_head == *v75 )
                    v73->buckets[v74].hh_head = hh_next;
                  hh_prev = hh_head->hh.hh_prev;
                  v75[1] = (stratum_share *)v77;
                  if ( hh_prev )
                  {
                    hh_prev->hh_next = hh_next;
                    hh_next = hh_head->hh.hh_next;
                  }
                  if ( hh_next )
                    hh_next->hh_prev = hh_prev;
                  --v73->num_items;
                }
                else
                {
                  free(buckets);
                  free(v28->hh.tbl);
                  stratum_shares = 0;
                }
                --*((_DWORD *)userdata + 183);
                break;
              }
              hh_head = (stratum_share *)hh_head->hh.hh_next;
              if ( !hh_head )
                break;
              hh_head = (stratum_share *)((char *)hh_head - tbl->hho);
            }
          }
          if ( pthread_mutex_unlock(&sshare_lock) )
            mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C12, v41, v42);
          selective_yield();
          if ( hh_head )
          {
            v123 = hh_head->work;
            v43 = time(0) - hh_head->sshare_sent;
            if ( (opt_debug || v43 > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Pool %d stratum share result lag time %d seconds",
                v123->pool->pool_no,
                v43);
              applog(6, tmp42, 0);
            }
            v44 = 0;
            *(_DWORD *)tmp42 = bswap32(*(_DWORD *)&v123->hash[28]);
            *(_DWORD *)&tmp42[4] = bswap32(*(_DWORD *)&v123->hash[24]);
            *(_DWORD *)&tmp42[8] = bswap32(*(_DWORD *)&v123->hash[20]);
            *(_DWORD *)&tmp42[12] = bswap32(*(_DWORD *)&v123->hash[16]);
            *(_DWORD *)&tmp42[16] = bswap32(*(_DWORD *)&v123->hash[12]);
            *(_DWORD *)&tmp42[20] = bswap32(*(_DWORD *)&v123->hash[8]);
            *(_DWORD *)&tmp42[24] = bswap32(*(_DWORD *)&v123->hash[4]);
            *(_DWORD *)&tmp42[28] = bswap32(*(_DWORD *)v123->hash);
            do
            {
              if ( tmp42[v44] )
                break;
              ++v44;
            }
            while ( v44 != 29 );
            work_difficulty = v123->work_difficulty;
            v46 = bswap32(*(_DWORD *)&tmp42[v44]);
            round();
            suffix_string(v123->share_diff, buf, 0x10u, 0);
            if ( v123->block )
              v47 = " BLOCK!";
            else
              v47 = "";
            snprintf(
              v137,
              0x40u,
              "%08lx Diff %s/%llu%s",
              v46,
              (const char *)buf,
              (unsigned __int64)work_difficulty,
              v47);
            pool = v123->pool;
            cgpu = get_thread(v123->thr_id)->cgpu;
            if ( v124 && (v124->type == JSON_TRUE || v123->gbt && v124->type == JSON_NULL) )
            {
              if ( pthread_mutex_lock(&stats_lock) )
                mutex_lock_2((pthread_mutex_t *)&_func___13387, (const unsigned __int8 *)0xD74, v99, v100);
              v101 = v123->work_difficulty;
              diff_accepted = pool->diff_accepted;
              v103 = pool->accepted + 1;
              v104 = total_diff_accepted;
              v105 = cgpu->diff_accepted + v101;
              ++cgpu->accepted;
              pool->accepted = v103;
              v106 = total_accepted;
              cgpu->diff_accepted = v105;
              pool->diff_accepted = diff_accepted + v101;
              total_diff_accepted = v101 + v104;
              total_accepted = v106 + 1;
              if ( pthread_mutex_unlock(&stats_lock) )
                mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13387, (const unsigned __int8 *)0xD7E, v107, v108);
              selective_yield();
              pool_no = pool->pool_no;
              pool->seq_rejects = 0;
              cgpu->last_share_pool = pool_no;
              v110 = time(0);
              v111 = opt_debug;
              v112 = v123->work_difficulty;
              cgpu->last_share_pool_time = v110;
              cgpu->last_share_diff = v112;
              pool->last_share_time = v110;
              pool->last_share_diff = v112;
              if ( v111 && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "PROOF OF WORK RESULT: true (yay!!!)");
                applog(7, tmp42, 0);
              }
              if ( !opt_quiet && !opt_realquiet )
              {
                if ( total_pools <= 1 )
                {
                  if ( use_syslog || opt_log_output || opt_log_level > 4 )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "Accepted %s %s %d %s%s",
                      v137,
                      (const char *)cgpu->drv->name,
                      cgpu->device_id,
                      "",
                      "");
                    applog(5, tmp42, 0);
                  }
                }
                else if ( use_syslog || opt_log_output || opt_log_level > 4 )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "Accepted %s %s %d pool %d %s%s",
                    v137,
                    (const char *)cgpu->drv->name,
                    cgpu->device_id,
                    v123->pool->pool_no,
                    "",
                    "");
                  applog(5, tmp42, 0);
                }
              }
              sharelog("accept", v123);
              if ( opt_shares && (double)opt_shares <= total_diff_accepted )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 3 )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "Successfully mined %d accepted shares as requested and exiting.",
                    opt_shares);
                  applog(4, tmp42, 0);
                }
                kill_work();
              }
              if ( pool->enabled == POOL_REJECTING )
              {
                if ( !use_syslog && !opt_log_output && opt_log_level <= 3
                  || (snprintf(
                        (char *)tmp42,
                        0x800u,
                        "Rejecting pool %d now accepting shares, re-enabling!",
                        pool->pool_no),
                      applog(4, tmp42, 0),
                      pool->enabled != POOL_ENABLED) )
                {
                  pool->enabled = POOL_ENABLED;
                  ++enabled_pools;
                }
                switch_pools(0);
              }
              if ( v123->block )
                restart_threads();
            }
            else
            {
              if ( pthread_mutex_lock(&stats_lock) )
                mutex_lock_2((pthread_mutex_t *)&_func___13387, (const unsigned __int8 *)0xDB3, v50, v51);
              diff_rejected = cgpu->diff_rejected;
              v53 = v123->work_difficulty;
              v54 = pool->diff_rejected;
              rejected = pool->rejected;
              v56 = total_diff_rejected;
              seq_rejects = pool->seq_rejects;
              ++cgpu->rejected;
              pool->rejected = rejected + 1;
              v58 = total_rejected;
              cgpu->diff_rejected = diff_rejected + v53;
              pool->seq_rejects = seq_rejects + 1;
              pool->diff_rejected = v54 + v53;
              total_diff_rejected = v53 + v56;
              total_rejected = v58 + 1;
              if ( pthread_mutex_unlock(&stats_lock) )
                mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13387, (const unsigned __int8 *)0xDBB, v59, v60);
              selective_yield();
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "PROOF OF WORK RESULT: false (booooo)");
                applog(7, tmp42, 0);
              }
              if ( !opt_quiet && !opt_realquiet )
              {
                strcpy((char *)buf, "reject");
                memset(v136, opt_realquiet, sizeof(v136));
                v133[0] = opt_realquiet;
                if ( total_pools <= 1 )
                  v132[0] = opt_realquiet;
                else
                  snprintf(v132, 0x14u, "pool %d", v123->pool->pool_no);
                if ( !v123->gbt )
                  v124 = json_object_get(json, "reject-reason");
                if ( v124 )
                {
                  v61 = json_string_value(v124);
                  v62 = strlen((const char *)v61);
                  if ( v62 >= 0x1C )
                    v62 = 28;
                  v125 = v62;
                  qmemcpy(v133, " (", sizeof(v133));
                  cg_memcpy(dest, v61, v62, "cgminer.c", (const unsigned __int8 *)&_func___13387, 3555);
                  v63 = &v133[v125];
                  v63[2] = 41;
                  v63[3] = 0;
                  cg_memcpy(v136, v61, v125, "cgminer.c", (const unsigned __int8 *)&_func___13387, 3560);
                  buf[6] = 58;
                  buf[v125 + 7] = 0;
                }
                else if ( v123->stratum && v127 )
                {
                  if ( v127->type == JSON_ARRAY )
                  {
                    v114 = json_array_get(v127, 1u);
                    if ( !v114 || v114->type != JSON_STRING )
                      goto LABEL_91;
                  }
                  else
                  {
                    if ( v127->type != JSON_STRING )
                      goto LABEL_91;
                    v114 = (json_t_0 *)v127;
                  }
                  v115 = json_string_value(v114);
                  snprintf(v133, 0x1Fu, " (%s)", (const char *)v115);
                }
LABEL_91:
                if ( use_syslog || opt_log_output || opt_log_level > 4 )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "Rejected %s %s %d %s%s %s%s",
                    v137,
                    (const char *)cgpu->drv->name,
                    cgpu->device_id,
                    v132,
                    v133,
                    "",
                    "");
                  applog(5, tmp42, 0);
                }
                sharelog(buf, v123);
              }
              v64 = pool->seq_rejects;
              if ( v64 > 10
                && !v123->stale
                && opt_disable_pool
                && enabled_pools > 1
                && (double)v64 > (double)total_accepted / total_secs * 60.0 * 3.0 )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 3 )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "Pool %d rejected %d sequential shares, disabling!",
                    pool->pool_no,
                    pool->seq_rejects);
                  applog(4, tmp42, 0);
                }
                if ( pool->enabled == POOL_ENABLED )
                  --enabled_pools;
                pool->enabled = POOL_REJECTING;
                if ( pool == current_pool() )
                  switch_pools(0);
                pool->seq_rejects = 0;
              }
            }
            free_work(&hh_head->work, "cgminer.c", (const unsigned __int8 *)&_func___14194, 7231);
            v65 = hh_head;
            v66 = 1;
            free(v65);
            refcount = json->refcount;
            if ( refcount == -1 )
            {
LABEL_111:
              if ( v66 )
                goto LABEL_13;
              goto LABEL_112;
            }
LABEL_147:
            v82 = refcount - 1;
            json->refcount = v82;
            if ( v82 )
              goto LABEL_111;
            json_delete(json);
            if ( v66 )
            {
LABEL_13:
              if ( *((_BYTE *)userdata + 680) )
              {
                v79 = make_work();
                *((_BYTE *)userdata + 680) = 0;
                work = v79;
                gen_stratum_work((pool *)userdata, v79);
                v80 = work;
                work->longpoll = 1;
                test_work_current(v80);
                free_work(&work, "cgminer.c", _func___14302, 7483);
              }
              goto LABEL_15;
            }
LABEL_112:
            v68 = use_syslog;
            goto LABEL_113;
          }
          if ( v124 )
          {
            if ( pthread_mutex_lock((pthread_mutex_t *)((char *)userdata + 212)) )
              mutex_lock_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C1E, v83, v84);
            if ( pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)userdata + 236)) )
              rd_lock_0((pthread_rwlock_t *)&_func___14194, (const unsigned __int8 *)0x1C1E, v85, v86);
            if ( pthread_mutex_unlock((pthread_mutex_t *)((char *)userdata + 212)) )
              mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C1E, v87, v88);
            v89 = *((double *)userdata + 228);
            if ( pthread_rwlock_unlock((pthread_rwlock_t *)((char *)userdata + 236)) )
              rw_unlock_1((pthread_rwlock_t *)&_func___14194, (const unsigned __int8 *)0x1C20, v90, v91);
            selective_yield();
            if ( v124->type == JSON_TRUE )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)tmp42, 0x800u, "Accepted untracked stratum share from pool %d", *(_DWORD *)userdata);
                applog(5, tmp42, 0);
              }
              if ( pthread_mutex_lock(&stats_lock) )
                mutex_lock_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C28, v116, v117);
              v118 = total_accepted;
              v119 = *((double *)userdata + 9) + v89;
              v120 = v89 + total_diff_accepted;
              ++*((_QWORD *)userdata + 1);
              *((double *)userdata + 9) = v119;
              total_diff_accepted = v120;
              total_accepted = v118 + 1;
              if ( pthread_mutex_unlock(&stats_lock) )
                mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C2D, v121, v122);
            }
            else
            {
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)tmp42, 0x800u, "Rejected untracked stratum share from pool %d", *(_DWORD *)userdata);
                applog(5, tmp42, 0);
              }
              if ( pthread_mutex_lock(&stats_lock) )
                mutex_lock_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C33, v92, v93);
              v94 = total_rejected;
              v95 = *((double *)userdata + 10) + v89;
              v96 = v89 + total_diff_rejected;
              ++*((_QWORD *)userdata + 2);
              *((double *)userdata + 10) = v95;
              total_diff_rejected = v96;
              total_rejected = v94 + 1;
              if ( pthread_mutex_unlock(&stats_lock) )
                mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14194, (const unsigned __int8 *)0x1C38, v97, v98);
            }
            v66 = 0;
            selective_yield();
          }
          else
          {
            v66 = 0;
          }
        }
        refcount = json->refcount;
        if ( refcount == -1 )
          goto LABEL_111;
        goto LABEL_147;
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 5 )
        goto LABEL_114;
      snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", error.line, (const char *)error.text);
      applog(6, tmp42, 0);
      v68 = use_syslog;
LABEL_113:
      if ( v68 )
        goto LABEL_116;
LABEL_114:
      if ( opt_log_output || opt_log_level > 5 )
      {
LABEL_116:
        snprintf((char *)tmp42, 0x800u, "Unknown stratum msg: %s", (const char *)v7);
        applog(6, tmp42, 0);
      }
LABEL_15:
      free(v7);
    }
    else
    {
      if ( !opt_debug )
      {
LABEL_31:
        v13 = use_syslog;
        goto LABEL_32;
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
      {
LABEL_33:
        if ( !opt_log_output && opt_log_level <= 4 )
          goto LABEL_36;
        goto LABEL_35;
      }
      snprintf((char *)tmp42, 0x800u, "Stratum select failed on pool %d with value %d", *(_DWORD *)userdata, v6);
      applog(7, tmp42, 0);
      v13 = use_syslog;
LABEL_32:
      if ( !v13 )
        goto LABEL_33;
LABEL_35:
      snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d interrupted", *(_DWORD *)userdata);
      applog(5, tmp42, 0);
LABEL_36:
      v14 = total_go;
      ++*((_DWORD *)userdata + 32);
      total_go = v14 + 1;
      if ( pthread_mutex_lock((pthread_mutex_t *)((char *)userdata + 212)) )
        mutex_lock_2((pthread_mutex_t *)&_func___14979.__size[16], (const unsigned __int8 *)0x1CC9, v15, v16);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)userdata + 236)) )
        rd_lock_0((pthread_rwlock_t *)(&_func___14979.__align + 4), (const unsigned __int8 *)0x1CC9, v17, v18);
      if ( pthread_mutex_unlock((pthread_mutex_t *)((char *)userdata + 212)) )
        mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14979.__size[16], (const unsigned __int8 *)0x1CC9, v19, v20);
      v21 = *((_DWORD *)userdata + 159);
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)((char *)userdata + 236)) )
        rw_unlock_1((pthread_rwlock_t *)(&_func___14979.__align + 4), (const unsigned __int8 *)0x1CCB, v22, v23);
      selective_yield();
      if ( !v21 || opt_lowmem )
        clear_stratum_shares((pool *)userdata);
      clear_pool_work((pool *)userdata);
      if ( userdata == current_pool() )
        restart_threads();
      while ( !restart_stratum((pool *)userdata) )
      {
        pool_died((pool *)userdata);
        if ( *((_BYTE *)userdata + 105) )
          return 0;
        cgsleep_ms(5000);
      }
    }
  }
  suspend_stratum((pool *)userdata);
  return 0;
}
// 2745C: variable 'v121' is possibly undefined
// 2745C: variable 'v122' is possibly undefined
// 27470: variable 'v116' is possibly undefined
// 27470: variable 'v117' is possibly undefined
// 2747C: variable 'v97' is possibly undefined
// 2747C: variable 'v98' is possibly undefined
// 27488: variable 'v92' is possibly undefined
// 27488: variable 'v93' is possibly undefined
// 27494: variable 'v107' is possibly undefined
// 27494: variable 'v108' is possibly undefined
// 274A0: variable 'v99' is possibly undefined
// 274A0: variable 'v100' is possibly undefined
// 27540: variable 'v59' is possibly undefined
// 27540: variable 'v60' is possibly undefined
// 2754E: variable 'v10' is possibly undefined
// 2754E: variable 'v11' is possibly undefined
// 2755C: variable 'v15' is possibly undefined
// 2755C: variable 'v16' is possibly undefined
// 2756A: variable 'v17' is possibly undefined
// 2756A: variable 'v18' is possibly undefined
// 27578: variable 'v19' is possibly undefined
// 27578: variable 'v20' is possibly undefined
// 2758E: variable 'v8' is possibly undefined
// 2758E: variable 'v9' is possibly undefined
// 2759C: variable 'v50' is possibly undefined
// 2759C: variable 'v51' is possibly undefined
// 275AA: variable 'v83' is possibly undefined
// 275AA: variable 'v84' is possibly undefined
// 275B6: variable 'v26' is possibly undefined
// 275B6: variable 'v27' is possibly undefined
// 275C4: variable 'v41' is possibly undefined
// 275C4: variable 'v42' is possibly undefined
// 275D2: variable 'v22' is possibly undefined
// 275D2: variable 'v23' is possibly undefined
// 275E0: variable 'v87' is possibly undefined
// 275E0: variable 'v88' is possibly undefined
// 275EC: variable 'v85' is possibly undefined
// 275EC: variable 'v86' is possibly undefined
// 275F8: variable 'v90' is possibly undefined
// 275F8: variable 'v91' is possibly undefined
// A2CC: using guessed type int round(void);
// 265AC: using guessed type char dest[30];

//----- (00027654) --------------------------------------------------------
void *__fastcall stratum_sthread(void *userdata)
{
  pthread_t v1; // r0
  thread_q *v2; // r0
  unsigned int v3; // r6
  uint64_t v4; // r4
  thread_q **v5; // r7
  const timespec *v6; // r1
  void *v7; // r0
  unsigned int v8; // r2
  uint64_t v9; // r0
  work *v10; // r4
  time_t v11; // r0
  work *v12; // r3
  const unsigned __int8 *v13; // r2
  int v14; // r3
  int v15; // r3
  const unsigned __int8 *v16; // r2
  int v17; // r3
  time_t v18; // r5
  size_t v19; // r0
  const unsigned __int8 *v20; // r2
  int v21; // r3
  int v22; // r3
  unsigned int v23; // r2
  stratum_share *v24; // r4
  unsigned int v25; // r5
  int v26; // r0
  unsigned int v27; // r2
  unsigned int v28; // r3
  int v29; // r0
  unsigned int v30; // r5
  UT_hash_table *tbl; // r3
  UT_hash_handle *tail; // r0
  UT_hash_table *v33; // r3
  ptrdiff_t hho; // r1
  UT_hash_bucket_0 *buckets; // r0
  int v36; // r5
  UT_hash_handle **p_hh_head; // r2
  UT_hash_handle *v38; // r1
  unsigned int v39; // r3
  int v40; // r2
  size_t v41; // r4
  UT_hash_bucket_0 *v42; // r0
  UT_hash_bucket_0 *v43; // r7
  UT_hash_table *v44; // r11
  unsigned int num_buckets; // r3
  unsigned int num_items; // r4
  unsigned int log2_num_buckets; // r2
  unsigned int v48; // r2
  int v49; // r10
  unsigned int v50; // r9
  UT_hash_handle *hh_head; // r4
  UT_hash_handle *hh_next; // r8
  int v53; // r5
  UT_hash_bucket_0 *v54; // r6
  unsigned int v55; // r0
  UT_hash_handle *v56; // r3
  UT_hash_table *v57; // r4
  unsigned int nonideal_items; // r3
  unsigned int v59; // r0
  unsigned int v60; // r1
  unsigned int v61; // r2
  bool v62; // cc
  int v63; // r0
  unsigned int v64; // r3
  const unsigned __int8 *v65; // r2
  int v66; // r3
  time_t v67; // r0
  _BOOL4 v68; // r3
  time_t sshare_time; // r2
  int v70; // r0
  UT_hash_table *v72; // r0
  UT_hash_table *v73; // r6
  UT_hash_bucket_0 *v74; // r0
  int64_t v75; // r2
  const unsigned __int8 *v76; // r2
  int v77; // r3
  const unsigned __int8 *v78; // r2
  int v79; // r3
  const unsigned __int8 *v80; // r2
  int v81; // r3
  const char *v82; // r1
  _BOOL4 v83; // r5
  const unsigned __int8 *v84; // r2
  int v85; // r3
  int v86; // r3
  stratum_share *sshare; // [sp+20h] [bp-C90h]
  unsigned int v88; // [sp+24h] [bp-C8Ch]
  UT_hash_bucket_0 *ptr; // [sp+2Ch] [bp-C84h]
  unsigned int last_nonce; // [sp+34h] [bp-C7Ch]
  uint64_t last_nonce2; // [sp+38h] [bp-C78h]
  int v93; // [sp+40h] [bp-C70h]
  unsigned int nonce; // [sp+48h] [bp-C68h] BYREF
  work *work; // [sp+4Ch] [bp-C64h] BYREF
  unsigned __int8 nonce2[8]; // [sp+50h] [bp-C60h] BYREF
  unsigned __int8 noncehex[12]; // [sp+58h] [bp-C58h] BYREF
  unsigned __int8 threadname[16]; // [sp+64h] [bp-C4Ch] BYREF
  unsigned __int8 nonce2hex[20]; // [sp+74h] [bp-C3Ch] BYREF
  unsigned __int8 s[1024]; // [sp+88h] [bp-C28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+488h] [bp-828h] BYREF

  v1 = pthread_self();
  pthread_detach(v1);
  snprintf((char *)threadname, 0x10u, "%d/SStratum", *(_DWORD *)userdata);
  RenameThread(threadname);
  v2 = tq_new();
  *((_DWORD *)userdata + 182) = v2;
  if ( !v2 )
  {
    strcpy((char *)tmp42, "Failed to create stratum_q in stratum_sthread");
    applog(3, tmp42, 1);
    quit(1);
  }
  v3 = 0;
  v4 = 0LL;
LABEL_4:
  v5 = (thread_q **)userdata;
  v6 = (const timespec *)*((unsigned __int8 *)userdata + 105);
  if ( *((_BYTE *)userdata + 105) )
    goto LABEL_63;
  do
  {
    v7 = tq_pop(v5[182], v6);
    work = (work *)v7;
    if ( !v7 )
    {
      strcpy((char *)tmp42, "Stratum q returned empty work");
      applog(3, tmp42, 1);
      quit(1);
    }
    v8 = *((_DWORD *)v7 + 76);
    if ( v8 > 8 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d asking for inappropriately long nonce2 length %d",
          *(_DWORD *)userdata,
          v8);
        applog(3, tmp42, 0);
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "Not attempting to submit shares");
          applog(3, tmp42, 0);
        }
      }
      free_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___14326, 7538);
      goto LABEL_4;
    }
    last_nonce = *((_DWORD *)v7 + 19);
    v9 = *((_QWORD *)v7 + 37);
    nonce = last_nonce;
    last_nonce2 = v9;
    *(_QWORD *)nonce2 = v9;
    if ( v3 == last_nonce && v4 == v9 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "Filtering duplicate share to pool %d", *(_DWORD *)userdata);
        applog(6, tmp42, 0);
      }
      free_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___14326, 7550);
      goto LABEL_4;
    }
    _bin2hex(noncehex, (const unsigned __int8 *)&nonce, 4u);
    _bin2hex(nonce2hex, nonce2, work->nonce2_len);
    sshare = (stratum_share *)cgcalloc(52, 1u, "cgminer.c", (const unsigned __int8 *)&_func___14326, 7559);
    v10 = work;
    v11 = time(0);
    v12 = work;
    sshare->sshare_time = v11;
    sshare->work = v12;
    memset(s, 0, sizeof(s));
    if ( pthread_mutex_lock(&sshare_lock) )
      mutex_lock_2((pthread_mutex_t *)&_func___14326, (const unsigned __int8 *)0x1D90, v13, v14);
    v15 = swork_id;
    sshare->id = swork_id;
    swork_id = v15 + 1;
    if ( pthread_mutex_unlock(&sshare_lock) )
      mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14326, (const unsigned __int8 *)0x1D93, v16, v17);
    selective_yield();
    if ( *((_BYTE *)userdata + 644) )
      snprintf(
        (char *)s,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
        *((const char **)userdata + 43),
        (const char *)work->job_id,
        (const char *)nonce2hex,
        (const char *)work->ntime,
        (const char *)noncehex,
        bswap32(work->version),
        sshare->id);
    else
      snprintf(
        (char *)s,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
        *((const char **)userdata + 43),
        (const char *)work->job_id,
        (const char *)nonce2hex,
        (const char *)work->ntime,
        (const char *)noncehex,
        sshare->id);
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Submitting share %08lx to pool %d",
        *(_DWORD *)&v10->hash[24],
        *(_DWORD *)userdata);
      applog(6, tmp42, 0);
    }
    while ( 1 )
    {
      v18 = sshare->sshare_time + 119;
      if ( v18 < time(0) )
        goto LABEL_69;
      v19 = strlen((const char *)s);
      if ( stratum_send((pool *)userdata, s, v19) )
      {
        if ( pthread_mutex_lock(&sshare_lock) )
          mutex_lock_2((pthread_mutex_t *)&_func___14326, (const unsigned __int8 *)0x1DB7, v20, v21);
        v22 = (LOBYTE(sshare->id)
             + 17973517
             + (HIBYTE(sshare->id) << 24)
             + (BYTE2(sshare->id) << 16)
             + (BYTE1(sshare->id) << 8)) ^ 0x7F76D;
        v23 = (-1622558010 - v22) ^ (v22 << 8);
        sshare->hh.key = &sshare->id;
        v24 = stratum_shares;
        v25 = (-17973517 - v22 - v23) ^ (v23 >> 13);
        sshare->hh.keylen = 4;
        v26 = (v22 - v23 - v25) ^ (v25 >> 12);
        v27 = (v23 - v25 - v26) ^ (v26 << 16);
        v28 = (v25 - v26 - v27) ^ (v27 >> 5);
        v29 = (v26 - v27 - v28) ^ (v28 >> 3);
        v30 = (v28 - v29 - ((v27 - v28 - v29) ^ (v29 << 10))) ^ (((v27 - v28 - v29) ^ (v29 << 10)) >> 15);
        sshare->hh.hashv = v30;
        if ( v24 )
        {
          tbl = v24->hh.tbl;
          sshare->hh.next = 0;
          sshare->hh.tbl = tbl;
          tail = v24->hh.tbl->tail;
          v33 = v24->hh.tbl;
          hho = v24->hh.tbl->hho;
          tail->next = sshare;
          sshare->hh.prev = (char *)tail - hho;
          v33->tail = &sshare->hh;
        }
        else
        {
          sshare->hh.next = 0;
          sshare->hh.prev = 0;
          stratum_shares = sshare;
          v72 = (UT_hash_table *)malloc(0x2Cu);
          sshare->hh.tbl = v72;
          if ( !v72 )
            goto LABEL_106;
          v72->buckets = 0;
          v72->num_buckets = 0;
          v72->log2_num_buckets = 0;
          v72->num_items = 0;
          v72->tail = 0;
          v72->hho = 0;
          v72->ideal_chain_maxlen = 0;
          v72->nonideal_items = 0;
          v72->ineff_expands = 0;
          v72->noexpand = 0;
          v72->signature = 0;
          v73 = sshare->hh.tbl;
          v73->tail = &sshare->hh;
          v73->hho = 0;
          v73->num_buckets = 32;
          v73->log2_num_buckets = 5;
          v74 = (UT_hash_bucket_0 *)malloc(0x180u);
          v73->buckets = v74;
          if ( !v74 )
            goto LABEL_106;
          memset(v74, 0, 0x180u);
          v33 = sshare->hh.tbl;
          sshare->hh.tbl->signature = -1609490463;
        }
        buckets = v33->buckets;
        v36 = v30 & (v33->num_buckets - 1);
        ++v33->num_items;
        p_hh_head = &buckets[v36].hh_head;
        v38 = *p_hh_head;
        v39 = (unsigned int)&p_hh_head[1]->tbl + 1;
        p_hh_head[1] = (UT_hash_handle *)v39;
        sshare->hh.hh_next = v38;
        sshare->hh.hh_prev = 0;
        if ( v38 )
          v38->hh_prev = &sshare->hh;
        v40 = 5 * ((_DWORD)&p_hh_head[2]->tbl + 1);
        buckets[v36].hh_head = &sshare->hh;
        if ( v39 < 2 * v40 || sshare->hh.tbl->noexpand == 1 )
          goto LABEL_45;
        v41 = 24 * sshare->hh.tbl->num_buckets;
        v42 = (UT_hash_bucket_0 *)malloc(v41);
        v43 = v42;
        if ( v42 )
        {
          memset(v42, 0, v41);
          v44 = sshare->hh.tbl;
          num_buckets = sshare->hh.tbl->num_buckets;
          num_items = sshare->hh.tbl->num_items;
          log2_num_buckets = sshare->hh.tbl->log2_num_buckets;
          sshare->hh.tbl->nonideal_items = 0;
          v48 = num_items >> (log2_num_buckets + 1);
          v49 = 2 * num_buckets - 1;
          if ( (v49 & num_items) != 0 )
            v50 = v48 + 1;
          else
            v50 = v48;
          v44->ideal_chain_maxlen = v50;
          if ( num_buckets )
          {
            v88 = 0;
            ptr = v44->buckets;
            v93 = 12 * num_buckets;
            do
            {
              hh_head = ptr[v88 / 0xC].hh_head;
              if ( hh_head )
              {
                do
                {
                  hh_next = hh_head->hh_next;
                  v53 = v49 & hh_head->hashv;
                  v54 = &v43[v49 & hh_head->hashv];
                  v55 = v54->count + 1;
                  v54->count = v55;
                  if ( v50 < v55 )
                  {
                    ++v44->nonideal_items;
                    v54->expand_mult = v55 / v50;
                  }
                  v56 = v43[v53].hh_head;
                  hh_head->hh_prev = 0;
                  hh_head->hh_next = v56;
                  if ( v56 )
                    v56->hh_prev = hh_head;
                  v43[v53].hh_head = hh_head;
                  hh_head = hh_next;
                }
                while ( hh_next );
              }
              v88 += 12;
            }
            while ( v88 != v93 );
            free(ptr);
          }
          else
          {
            free(v44->buckets);
          }
          v57 = sshare->hh.tbl;
          nonideal_items = sshare->hh.tbl->nonideal_items;
          v59 = sshare->hh.tbl->num_buckets;
          v60 = sshare->hh.tbl->log2_num_buckets;
          v61 = sshare->hh.tbl->num_items;
          v57->buckets = v43;
          v62 = nonideal_items > v61 >> 1;
          v63 = 2 * v59;
          v57->log2_num_buckets = v60 + 1;
          if ( nonideal_items <= v61 >> 1 )
            nonideal_items = 0;
          v57->num_buckets = v63;
          if ( v62 )
          {
            v64 = v57->ineff_expands + 1;
            v57->ineff_expands = v64;
            if ( v64 > 1 )
              v57->noexpand = 1;
          }
          else
          {
            v57->ineff_expands = nonideal_items;
          }
LABEL_45:
          ++*((_DWORD *)userdata + 183);
          if ( pthread_mutex_unlock(&sshare_lock) )
            mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14326, (const unsigned __int8 *)0x1DBA, v65, v66);
          selective_yield();
          if ( pool_tclear((pool *)userdata, (bool *)userdata + 96)
            && (use_syslog || opt_log_output || opt_log_level > 3) )
          {
            snprintf((char *)tmp42, 0x800u, "Pool %d communication resumed, submitting work", *(_DWORD *)userdata);
            applog(4, tmp42, 0);
          }
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Successfully submitted, adding to stratum_shares db");
            applog(7, tmp42, 0);
          }
          v67 = time(0);
          v68 = opt_debug;
          sshare_time = sshare->sshare_time;
          sshare->sshare_sent = v67;
          v70 = v67 - sshare_time;
          if ( (v68 || v70 > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Pool %d stratum share submission lag time %d seconds",
              *(_DWORD *)userdata,
              v70);
            applog(6, tmp42, 0);
          }
          goto LABEL_62;
        }
LABEL_106:
        exit(-1);
      }
      if ( !pool_tset((pool *)userdata, (bool *)userdata + 96) && cnx_needed((pool *)userdata) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf((char *)tmp42, 0x800u, "Pool %d stratum share submission failure", *(_DWORD *)userdata);
          applog(4, tmp42, 0);
        }
        v86 = *((_DWORD *)userdata + 33);
        ++total_ro;
        *((_DWORD *)userdata + 33) = v86 + 1;
      }
      if ( opt_lowmem )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)((char *)userdata + 212)) )
        mutex_lock_2((pthread_mutex_t *)&_func___14326, (const unsigned __int8 *)0x1DD0, v76, v77);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)userdata + 236)) )
        rd_lock_0((pthread_rwlock_t *)&_func___14326, (const unsigned __int8 *)0x1DD0, v78, v79);
      if ( pthread_mutex_unlock((pthread_mutex_t *)((char *)userdata + 212)) )
        mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14326, (const unsigned __int8 *)0x1DD0, v80, v81);
      v82 = (const char *)*((_DWORD *)userdata + 153);
      v83 = (_BOOL4)v82;
      if ( v82 )
        v83 = strcmp((const char *)work->nonce1, v82) == 0;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)((char *)userdata + 236)) )
        rw_unlock_1((pthread_rwlock_t *)&_func___14326, (const unsigned __int8 *)0x1DD2, v84, v85);
      selective_yield();
      if ( !v83 )
      {
        if ( opt_debug )
        {
          if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
            goto LABEL_72;
          strcpy((char *)tmp42, "No matching session id for resubmitting stratum share");
          applog(7, tmp42, 0);
LABEL_69:
          if ( opt_debug )
          {
            if ( !use_syslog )
              goto LABEL_72;
            goto LABEL_74;
          }
        }
        goto LABEL_70;
      }
      sleep(2u);
    }
    if ( opt_debug )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        strcpy((char *)tmp42, "Lowmem option prevents resubmitting stratum share");
        applog(7, tmp42, 0);
        goto LABEL_69;
      }
LABEL_72:
      if ( opt_log_output || opt_log_level > 6 )
      {
LABEL_74:
        strcpy((char *)tmp42, "Failed to submit stratum share, discarding");
        applog(7, tmp42, 0);
      }
    }
LABEL_70:
    free_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___14326, 7649);
    free(sshare);
    v75 = total_stale + 1;
    ++*((_DWORD *)userdata + 30);
    total_stale = v75;
LABEL_62:
    v5 = (thread_q **)userdata;
    v3 = last_nonce;
    v4 = last_nonce2;
    v6 = (const timespec *)*((unsigned __int8 *)userdata + 105);
  }
  while ( !*((_BYTE *)userdata + 105) );
LABEL_63:
  tq_freeze(*((thread_q **)userdata + 182));
  return 0;
}
// 27C9E: variable 'v20' is possibly undefined
// 27C9E: variable 'v21' is possibly undefined
// 27CFC: variable 'v76' is possibly undefined
// 27CFC: variable 'v77' is possibly undefined
// 27D14: variable 'v78' is possibly undefined
// 27D14: variable 'v79' is possibly undefined
// 27D26: variable 'v80' is possibly undefined
// 27D26: variable 'v81' is possibly undefined
// 27D54: variable 'v84' is possibly undefined
// 27D54: variable 'v85' is possibly undefined
// 27F06: variable 'v16' is possibly undefined
// 27F06: variable 'v17' is possibly undefined
// 27F12: variable 'v65' is possibly undefined
// 27F12: variable 'v66' is possibly undefined
// 27F1E: variable 'v13' is possibly undefined
// 27F1E: variable 'v14' is possibly undefined

//----- (00027FA8) --------------------------------------------------------
bool __fastcall stale_work(work *work, bool share)
{
  _BOOL4 v3; // r6
  int rolltime; // r7
  pool *pool; // r8
  int v7; // r7
  const char *v8; // r5
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // r5
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  const unsigned __int8 *v20; // r2
  int v21; // r3
  const unsigned __int8 *v22; // r2
  int v23; // r3
  const unsigned __int8 *v24; // r2
  int v25; // r3
  int v26; // r10
  const unsigned __int8 *v27; // r2
  int v28; // r3
  timeval v29; // [sp+0h] [bp-828h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-820h] BYREF

  v3 = share;
  if ( opt_benchmark || opt_benchfile )
    return 0;
  if ( work->work_block != work_block )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to block mismatch");
      applog(7, tmp42, 0);
      return 1;
    }
    return 1;
  }
  rolltime = work->rolltime;
  pool = work->pool;
  if ( rolltime <= opt_scantime )
    rolltime = opt_expiry;
  if ( !share && pool->has_stratum )
  {
    if ( !pool->stratum_active || !pool->stratum_notify )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Work stale due to stratum inactive");
        applog(7, tmp42, 0);
        return 1;
      }
      return 1;
    }
    if ( pthread_mutex_lock(&pool->data_lock.mutex) )
      mutex_lock_2((pthread_mutex_t *)&_func___14326.__size[16], (const unsigned __int8 *)0x137D, v20, v21);
    if ( pthread_rwlock_rdlock(&pool->data_lock.rwlock) )
      rd_lock_0((pthread_rwlock_t *)(&_func___14326.__align + 4), (const unsigned __int8 *)0x137D, v22, v23);
    if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
      mutex_unlock_noyield_2((pthread_mutex_t *)&_func___14326.__size[16], (const unsigned __int8 *)0x137D, v24, v25);
    v26 = strcmp((const char *)work->job_id, (const char *)pool->swork.job_id);
    if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
      rw_unlock_1((pthread_rwlock_t *)(&_func___14326.__align + 4), (const unsigned __int8 *)0x1384, v27, v28);
    selective_yield();
    if ( v26 )
    {
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return 1;
      v8 = "Work stale due to stratum job_id mismatch";
LABEL_42:
      v9 = *(_DWORD *)v8;
      v10 = *((_DWORD *)v8 + 1);
      v11 = *((_DWORD *)v8 + 2);
      v12 = *((_DWORD *)v8 + 3);
      v13 = (int *)(v8 + 16);
      *(_DWORD *)tmp42 = v9;
      *(_DWORD *)&tmp42[4] = v10;
      *(_DWORD *)&tmp42[8] = v11;
      *(_DWORD *)&tmp42[12] = v12;
      v14 = *v13;
      v15 = v13[1];
      v16 = v13[2];
      v17 = v13[3];
      v13 += 4;
      *(_DWORD *)&tmp42[16] = v14;
      *(_DWORD *)&tmp42[20] = v15;
      *(_DWORD *)&tmp42[24] = v16;
      *(_DWORD *)&tmp42[28] = v17;
      v18 = v13[1];
      v19 = v13[2];
      *(_DWORD *)&tmp42[32] = *v13;
      *(_DWORD *)&tmp42[36] = v18;
      *(_WORD *)&tmp42[40] = v19;
      applog(7, tmp42, 0);
      return 1;
    }
  }
  v7 = rolltime - (int)(pool->cgminer_pool_stats.getwork_wait_rolling * 5.0 + 1.0);
  cgtime(&v29);
  if ( v7 < 5 )
    v7 = 5;
  if ( v29.tv_sec - work->tv_staged.tv_sec >= v7 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to expiry");
      applog(7, tmp42, 0);
      return 1;
    }
    return 1;
  }
  if ( opt_fail_only
    && !v3
    && pool != current_pool()
    && !work->mandatory
    && pool_strategy_0 != POOL_LOADBALANCE
    && pool_strategy_0 != POOL_BALANCE )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return 1;
    v8 = "Work stale due to fail only pool mismatch";
    goto LABEL_42;
  }
  return 0;
}
// 281D8: variable 'v27' is possibly undefined
// 281D8: variable 'v28' is possibly undefined
// 281E4: variable 'v24' is possibly undefined
// 281E4: variable 'v25' is possibly undefined
// 281F0: variable 'v22' is possibly undefined
// 281F0: variable 'v23' is possibly undefined
// 281FC: variable 'v20' is possibly undefined
// 281FC: variable 'v21' is possibly undefined

//----- (0002823C) --------------------------------------------------------
void discard_stale()
{
  const unsigned __int8 *v0; // r2
  int v1; // r3
  work *v2; // r0
  work *next; // r4
  int v4; // r5
  work *v5; // r2
  char *prev; // r0
  work *v7; // r8
  work *v8; // r3
  UT_hash_handle_0 *p_hh; // r12
  UT_hash_table *tbl; // r7
  ptrdiff_t hho; // lr
  char *v12; // r7
  UT_hash_table *v13; // r1
  UT_hash_handle_0 **p_hh_head; // r8
  UT_hash_handle *hh_next; // r0
  int v16; // r7
  UT_hash_handle *hh_prev; // r3
  work *v18; // r3
  const unsigned __int8 *v19; // r2
  int v20; // r3
  work *work; // [sp+4h] [bp-81Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-818h] BYREF

  if ( pthread_mutex_lock(stgd_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13771, (const unsigned __int8 *)0x149E, v0, v1);
  v2 = staged_work;
  work = staged_work;
  next = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  v4 = 0;
  if ( staged_work )
  {
    do
    {
      if ( stale_work(v2, 0) )
      {
        v5 = work;
        prev = (char *)work->hh.prev;
        v7 = (work *)work->hh.next;
        if ( prev || v7 )
        {
          v8 = staged_work;
          p_hh = &work->hh;
          tbl = staged_work->hh.tbl;
          hho = tbl->hho;
          if ( work == (work *)((char *)tbl->tail - hho) )
            tbl->tail = (UT_hash_handle *)&prev[hho];
          if ( prev )
          {
            *(_DWORD *)&prev[hho + 8] = v7;
            v12 = (char *)v5->hh.next;
          }
          else
          {
            v8 = v7;
            v12 = (char *)v7;
            staged_work = v7;
          }
          v13 = v8->hh.tbl;
          if ( v12 )
            *(_DWORD *)&v12[v13->hho + 4] = prev;
          p_hh_head = &v13->buckets[(v13->num_buckets - 1) & v5->hh.hashv].hh_head;
          hh_next = v5->hh.hh_next;
          v16 = (int)&p_hh_head[1][-1].hashv + 3;
          if ( *p_hh_head == p_hh )
            v13->buckets[(v13->num_buckets - 1) & v5->hh.hashv].hh_head = hh_next;
          hh_prev = v5->hh.hh_prev;
          p_hh_head[1] = (UT_hash_handle_0 *)v16;
          if ( hh_prev )
          {
            hh_prev->hh_next = hh_next;
            hh_next = v5->hh.hh_next;
          }
          if ( hh_next )
            hh_next->hh_prev = hh_prev;
          --v13->num_items;
        }
        else
        {
          free(staged_work->hh.tbl->buckets);
          free(staged_work->hh.tbl);
          staged_work = 0;
        }
        ++v4;
        discard_work(&work, "cgminer.c", (const unsigned __int8 *)&_func___13771, 5285);
      }
      work = next;
      v18 = next;
      if ( next )
        v18 = (work *)next->hh.next;
      v2 = next;
      next = v18;
    }
    while ( v2 );
  }
  pthread_cond_signal(&gws_cond);
  if ( pthread_mutex_unlock(stgd_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13771, (const unsigned __int8 *)0x14AB, v19, v20);
  selective_yield();
  if ( v4 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Discarded %d stales that didn't match current hash", v4);
    applog(7, tmp42, 0);
  }
}
// 283B6: variable 'v0' is possibly undefined
// 283B6: variable 'v1' is possibly undefined
// 283C2: variable 'v19' is possibly undefined
// 283C2: variable 'v20' is possibly undefined

//----- (000283F0) --------------------------------------------------------
void *__fastcall restart_thread_0(void *arg)
{
  pthread_t v1; // r0
  const unsigned __int8 *v2; // r2
  int v3; // r3
  int v4; // r6
  const unsigned __int8 *v5; // r2
  int v6; // r3
  int v7; // r4
  thr_info *v8; // r3
  cgpu_info *cgpu; // r5
  const unsigned __int8 *v10; // r2
  int v11; // r3
  const unsigned __int8 *v12; // r2
  int v13; // r3

  v1 = pthread_self();
  pthread_detach(v1);
  discard_stale();
  if ( pthread_rwlock_rdlock(&mining_thr_lock) )
    rd_lock_0((pthread_rwlock_t *)(&_func___13771.__align + 4), (const unsigned __int8 *)0x14E0, v2, v3);
  v4 = mining_threads;
  if ( pthread_rwlock_unlock(&mining_thr_lock) )
    rw_unlock_1((pthread_rwlock_t *)(&_func___13771.__align + 4), (const unsigned __int8 *)0x14E2, v5, v6);
  selective_yield();
  if ( v4 > 0 )
  {
    v7 = 0;
    do
    {
      while ( 1 )
      {
        v8 = mining_thr[v7++];
        cgpu = v8->cgpu;
        if ( cgpu )
        {
          if ( cgpu->deven == DEV_ENABLED )
            break;
        }
        if ( v7 == v4 )
          goto LABEL_9;
      }
      v8->work_restart = 1;
      flush_queue(cgpu);
      cgpu->drv->flush_work(cgpu);
    }
    while ( v7 != v4 );
  }
LABEL_9:
  if ( pthread_mutex_lock(&restart_lock) )
    mutex_lock_2((pthread_mutex_t *)&_func___13771.__size[16], (const unsigned __int8 *)0x14F7, v10, v11);
  pthread_cond_broadcast(&restart_cond);
  if ( pthread_mutex_unlock(&restart_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)&_func___13771.__size[16], (const unsigned __int8 *)0x14F9, v12, v13);
  selective_yield();
  return 0;
}
// 28488: variable 'v2' is possibly undefined
// 28488: variable 'v3' is possibly undefined
// 28494: variable 'v12' is possibly undefined
// 28494: variable 'v13' is possibly undefined
// 284A0: variable 'v10' is possibly undefined
// 284A0: variable 'v11' is possibly undefined
// 284AC: variable 'v5' is possibly undefined
// 284AC: variable 'v6' is possibly undefined

//----- (000284D0) --------------------------------------------------------
void *__fastcall __noreturn watchdog_thread(void *userdata)
{
  int v1; // r1
  int v2; // r4
  int v3; // r0
  thr_info *thread; // r0
  cgsem_t *v5; // r5
  _BOOL4 v6; // r3
  int v7; // r5
  _BOOL4 v8; // r3
  cgpu_info *devices; // r0
  cgpu_info *v10; // r4
  thr_info *v11; // r6
  alive status; // r3
  int v13; // r1
  _BOOL4 v14; // r3
  int enable; // r4
  const unsigned __int8 *v16; // r2
  int v17; // r3
  thr_info **v18; // r3
  thr_info **v19; // r1
  int v20; // t1
  const unsigned __int8 *v21; // r2
  int v22; // r3
  timeval now; // [sp+10h] [bp-838h] BYREF
  unsigned __int8 dev_str[8]; // [sp+18h] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-828h] BYREF

  pthread_setcanceltype(1, 0);
  RenameThread("Watchdog");
  set_lowprio();
  cgtime(&rotate_tv);
  while ( 1 )
  {
LABEL_2:
    sleep(2u);
    discard_stale();
    hashmeter(-1, v1, 0LL);
    cgtime(&now);
    if ( sched_paused )
      goto LABEL_81;
    if ( !should_run() )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pausing execution as per stop time %02d:%02d scheduled",
          schedstop.tm.tm_hour,
          schedstop.tm.tm_min);
        applog(4, tmp42, 0);
      }
      enable = schedstart.enable;
      if ( !schedstart.enable )
      {
        strcpy((char *)tmp42, "Terminating execution as planned");
        applog(3, tmp42, 1);
        quit(enable);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Will restart execution as scheduled at %02d:%02d",
          schedstart.tm.tm_hour,
          schedstart.tm.tm_min);
        applog(4, tmp42, 0);
      }
      sched_paused = 1;
      if ( pthread_rwlock_rdlock(&mining_thr_lock) )
        rd_lock_0((pthread_rwlock_t *)&_func___15042, (const unsigned __int8 *)0x2828, v16, v17);
      if ( mining_threads > 0 )
      {
        v18 = mining_thr;
        v19 = &mining_thr[mining_threads];
        do
        {
          v20 = (int)*v18++;
          *(_BYTE *)(v20 + 60) = 1;
        }
        while ( v18 != v19 );
      }
      if ( pthread_rwlock_unlock(&mining_thr_lock) )
        rw_unlock_1((pthread_rwlock_t *)&_func___15042, (const unsigned __int8 *)0x282F, v21, v22);
      selective_yield();
      goto LABEL_21;
    }
    if ( sched_paused )
    {
LABEL_81:
      if ( should_run() )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Restarting execution as per start time %02d:%02d scheduled",
            schedstart.tm.tm_hour,
            schedstart.tm.tm_min);
          applog(4, tmp42, 0);
        }
        if ( schedstop.enable && (use_syslog || opt_log_output || opt_log_level > 3) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Will pause execution as scheduled at %02d:%02d",
            schedstop.tm.tm_hour,
            schedstop.tm.tm_min);
          applog(4, tmp42, 0);
        }
        v2 = 0;
        sched_paused = 0;
        while ( mining_threads > v2 )
        {
          v3 = v2++;
          thread = get_thread(v3);
          v5 = (cgsem_t *)thread;
          if ( thread->cgpu->deven != DEV_DISABLED )
          {
            v6 = opt_debug;
            thread->pause = 0;
            if ( v6 && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42, 0x800u, "Pushing sem post to thread %d", thread->id);
              applog(7, tmp42, 0);
            }
            cgsem_post(v5 + 1, "cgminer.c", (const unsigned __int8 *)&_func___15042, 10314);
          }
        }
      }
    }
LABEL_21:
    if ( total_devices > 0 )
    {
      v7 = 0;
      while ( 1 )
      {
        devices = get_devices(v7);
        v10 = devices;
        v11 = *devices->thr;
        if ( !v11 )
          goto LABEL_34;
        ((void (*)(void))devices->drv->get_stats)();
        snprintf((char *)dev_str, 8u, "%s %d", (const char *)v10->drv->name, v10->device_id);
        if ( v11->getwork || v10->deven == DEV_DISABLED )
          goto LABEL_34;
        status = v10->status;
        v13 = now.tv_sec - v11->last.tv_sec;
        if ( status )
          break;
        if ( v13 <= 120 )
          goto LABEL_47;
        v8 = use_syslog;
        v10->status = LIFE_SICK;
        v10->rolling = 0.0;
        if ( v8 || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "%s: Idle for more than 60 seconds, declaring SICK!", (const char *)dev_str);
          applog(3, tmp42, 0);
        }
        cgtime(&v11->sick);
        dev_error(v10, REASON_DEV_SICK_IDLE_60);
        if ( !opt_restart )
          goto LABEL_34;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "%s: Attempting to restart", (const char *)dev_str);
          applog(3, tmp42, 0);
        }
LABEL_33:
        reinit_device(v10);
LABEL_34:
        if ( total_devices <= ++v7 )
          goto LABEL_2;
      }
      if ( v13 <= 119 )
      {
        if ( status != LIFE_INIT && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf((char *)tmp42, 0x800u, "%s: Recovered, declaring WELL!", (const char *)dev_str);
          applog(3, tmp42, 0);
        }
        v10->status = LIFE_WELL;
        v10->device_last_well = time(0);
        goto LABEL_34;
      }
      if ( status == LIFE_SICK && v13 > 600 )
      {
        v14 = use_syslog;
        v10->status = LIFE_DEAD;
        if ( v14 || opt_log_output || opt_log_level > 2 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: Not responded for more than 10 minutes, declaring DEAD!",
            (const char *)dev_str);
          applog(3, tmp42, 0);
        }
        cgtime(&v11->sick);
        dev_error(v10, REASON_DEV_DEAD_IDLE_600);
        goto LABEL_34;
      }
LABEL_47:
      if ( now.tv_sec - v11->sick.tv_sec <= 60 )
        goto LABEL_34;
      if ( (unsigned int)(status - 1) > 1 )
        goto LABEL_34;
      cgtime(&v11->sick);
      if ( !opt_restart )
        goto LABEL_34;
      goto LABEL_33;
    }
  }
}
// 2850C: variable 'v1' is possibly undefined
// 28970: variable 'v16' is possibly undefined
// 28970: variable 'v17' is possibly undefined
// 2897C: variable 'v21' is possibly undefined
// 2897C: variable 'v22' is possibly undefined

//----- (000289A8) --------------------------------------------------------
work *__fastcall _get_queued(cgpu_info *cgpu)
{
  work *unqueued_work; // r3
  work *result; // r0
  work *work; // [sp+4h] [bp-Ch] BYREF

  unqueued_work = cgpu->unqueued_work;
  result = unqueued_work;
  if ( unqueued_work )
  {
    work = unqueued_work;
    if ( stale_work(unqueued_work, 0) )
    {
      discard_work(&work, "cgminer.c", &_func___15042.__size[16], 9282);
      wake_gws();
    }
    else
    {
      _add_queued(cgpu, work);
    }
    result = work;
    cgpu->unqueued_work = 0;
  }
  return result;
}

//----- (000289F0) --------------------------------------------------------
work *__fastcall get_queued(cgpu_info *cgpu)
{
  pthread_rwlock_t *p_qlock; // r4
  const unsigned __int8 *v3; // r2
  int v4; // r3
  work *queued; // r5
  const unsigned __int8 *v6; // r2
  int v7; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_wrlock(&cgpu->qlock) )
    wr_lock_0((pthread_rwlock_t *)&_func___14821, (const unsigned __int8 *)0x2457, v3, v4);
  queued = _get_queued(cgpu);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___14821, (const unsigned __int8 *)0x2459, v6, v7);
  selective_yield();
  return queued;
}
// 28A20: variable 'v3' is possibly undefined
// 28A20: variable 'v4' is possibly undefined
// 28A2C: variable 'v6' is possibly undefined
// 28A2C: variable 'v7' is possibly undefined

//----- (00028A3C) --------------------------------------------------------
work *__fastcall get_work(thr_info *thr, const int thr_id)
{
  cgpu_info *cgpu; // r6
  time_t v5; // r5
  char v6; // r4
  time_t v7; // r0
  int v8; // r4
  _BOOL4 v9; // r3
  work *v10; // r0
  _BOOL4 v11; // r3
  work *v12; // r3
  device_drv *drv; // r2
  double work_difficulty; // d5
  work *result; // r0
  double max_diff; // d7
  double min_diff; // d6
  int v18; // r3
  int hidiff; // r3
  int v20; // r2
  unsigned __int8 (*v21)[160]; // r1
  int v22; // r3
  int v23; // r5
  int line; // r3
  work *work; // [sp+Ch] [bp-824h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-820h] BYREF

  work = 0;
  cgpu = thr->cgpu;
  thread_reportout(thr);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Popping work from get queue to get work");
    applog(7, tmp42, 0);
  }
  v5 = time(0);
  while ( 1 )
  {
    v6 = (char)work;
    if ( work )
      break;
    while ( 1 )
    {
      work = hash_pop(1);
      if ( !stale_work(work, v6) )
        break;
      discard_work(&work, "cgminer.c", &_func___14821.__size[12], 8524);
      wake_gws();
      v6 = (char)work;
      if ( work )
        goto LABEL_9;
    }
  }
LABEL_9:
  v7 = time(0);
  v8 = v7 - v5;
  v9 = opt_debug;
  if ( v7 - v5 > 0 )
  {
    if ( opt_debug )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        snprintf((char *)tmp42, 0x800u, "Get work blocked for %d seconds", v7 - v5);
        applog(7, tmp42, 0);
        v9 = opt_debug;
      }
      else
      {
        v9 = 1;
      }
    }
    cgpu->last_device_valid_work += v8;
  }
  if ( v9 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Got work from get queue to get work for thread %d", thr_id);
    applog(7, tmp42, 0);
  }
  v10 = work;
  v11 = opt_benchmark;
  work->thr_id = thr_id;
  if ( v11 )
  {
    v18 = cgpu->lodiff + cgpu->direction;
    cgpu->lodiff = v18;
    if ( v18 > 0 )
    {
      if ( v18 > 15 )
      {
        hidiff = cgpu->hidiff;
        v20 = -1;
        cgpu->direction = -1;
        v21 = bench_hidiff_bins;
        v22 = hidiff + 1;
        if ( v22 <= 15 )
          cgpu->hidiff = v22;
        else
          v20 = 0;
        if ( v22 > 15 )
        {
          v22 = v20;
          cgpu->hidiff = v20;
        }
        v23 = v22;
        line = 8501;
        goto LABEL_34;
      }
    }
    else
    {
      cgpu->direction = 1;
    }
    v23 = v18;
    v21 = bench_lodiff_bins;
    line = 8505;
LABEL_34:
    cg_memcpy(v10, v21[v23], 0xA0u, "cgminer.c", &_func___14821.__flags, line);
  }
  thread_reportin(thr);
  v12 = work;
  drv = cgpu->drv;
  work_difficulty = work->work_difficulty;
  result = work;
  max_diff = drv->max_diff;
  min_diff = drv->min_diff;
  work->mined = 1;
  if ( max_diff > work_difficulty )
    max_diff = work_difficulty;
  if ( max_diff < min_diff )
    max_diff = min_diff;
  v12->device_diff = max_diff;
  return result;
}

//----- (00028C44) --------------------------------------------------------
void __fastcall hash_queued_work(thr_info *mythr)
{
  int id; // r9
  cgpu_info *cgpu; // r4
  device_drv *drv; // r5
  const unsigned __int8 *v5; // r2
  int v6; // r3
  int v7; // r8
  const unsigned __int8 *v8; // r2
  int v9; // r3
  __int64 v10; // r0
  bool v11; // zf
  int v12; // r1
  int v13; // r0
  int64_t hashes_done; // [sp+8h] [bp-850h]
  work *workptr; // [sp+1Ch] [bp-83Ch] BYREF
  timeval tv_start; // [sp+20h] [bp-838h] BYREF
  timeval tv_end; // [sp+28h] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp-828h] BYREF

  id = mythr->id;
  cgpu = mythr->cgpu;
  tv_start.tv_sec = 0;
  drv = cgpu->drv;
  hashes_done = 0LL;
  tv_start.tv_usec = 0;
  while ( !cgpu->shutdown )
  {
    mythr->work_update = 0;
    do
    {
      while ( 1 )
      {
        if ( !cgpu->unqueued_work )
        {
          workptr = get_work(mythr, id);
          if ( pthread_rwlock_wrlock(&cgpu->qlock) )
            wr_lock_0((pthread_rwlock_t *)&_func___14773, (const unsigned __int8 *)0x2417, v5, v6);
          if ( cgpu->unqueued_work )
          {
            v7 = 0;
          }
          else
          {
            v7 = 1;
            cgpu->unqueued_work = workptr;
          }
          if ( pthread_rwlock_unlock(&cgpu->qlock) )
            rw_unlock_1((pthread_rwlock_t *)&_func___14773, (const unsigned __int8 *)0x2422, v8, v9);
          selective_yield();
          if ( !v7 )
            break;
        }
        if ( ((int (__fastcall *)(cgpu_info *))drv->queue_full)(cgpu) )
          goto LABEL_12;
      }
      discard_work(&workptr, "cgminer.c", (const unsigned __int8 *)&_func___14773, 9254);
    }
    while ( !((int (__fastcall *)(cgpu_info *))drv->queue_full)(cgpu) );
LABEL_12:
    LODWORD(v10) = drv->scanwork(mythr);
    v11 = HIDWORD(v10) == -1;
    if ( HIDWORD(v10) == -1 )
      v11 = (_DWORD)v10 == -1;
    mythr->work_restart = 0;
    if ( v11 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = DEV_DISABLED;
      dev_error(cgpu, REASON_THREAD_ZERO_HASH);
      break;
    }
    hashes_done += v10;
    cgtime(&tv_end);
    v12 = tv_end.tv_sec - tv_start.tv_sec;
    v13 = tv_end.tv_usec - tv_start.tv_usec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --v12;
      v13 += 1000000;
    }
    if ( hashes_done && (v12 > 0 || v13 > (int)&off_30D40) || opt_log_interval <= v12 )
    {
      hashmeter(id, v12, hashes_done);
      hashes_done = 0LL;
      copy_time(&tv_start, &tv_end);
      if ( mythr->pause )
        goto LABEL_26;
    }
    else if ( mythr->pause )
    {
LABEL_26:
      mt_disable(mythr, id, drv);
      goto LABEL_21;
    }
    if ( cgpu->deven )
      goto LABEL_26;
LABEL_21:
    if ( mythr->work_update )
      drv->update_work(cgpu);
  }
  cgpu->deven = DEV_DISABLED;
}
// 28CFC: variable 'v10' is possibly undefined
// 28DF0: variable 'v8' is possibly undefined
// 28DF0: variable 'v9' is possibly undefined
// 28E02: variable 'v5' is possibly undefined
// 28E02: variable 'v6' is possibly undefined
// 30D40: using guessed type char (*off_30D40)[16];

//----- (00028E28) --------------------------------------------------------
work *__fastcall get_queue_work(thr_info *thr, cgpu_info *cgpu, int thr_id)
{
  work *work; // r4

  work = get_work(thr, thr_id);
  add_queued(cgpu, work);
  return work;
}

//----- (00028E40) --------------------------------------------------------
void __fastcall hash_sole_work(thr_info *mythr)
{
  cgpu_info *cgpu; // r4
  int v3; // r2
  int shutdown; // r8
  int deven; // r9
  uint64_t v6; // r10
  int v7; // r3
  uint64_t v8; // r2
  bool (*prepare_work)(thr_info *, work *); // r6
  double max_diff; // d7
  pool *pool; // r6
  work *v12; // r0
  __int64 v13; // kr00_8
  bool v14; // zf
  __time_t tv_sec; // r3
  int v16; // r1
  int v17; // r2
  bool v18; // cc
  int v19; // r6
  char (**v20)[16]; // r1
  int v21; // r5
  int v22; // r3
  int v23; // r1
  int device_thread; // r3
  unsigned int v25; // [sp+Ch] [bp-88Ch]
  device_drv *drv; // [sp+10h] [bp-888h]
  timeval *dest; // [sp+14h] [bp-884h]
  timeval *p_getwork_wait_min; // [sp+18h] [bp-880h]
  int cycle; // [sp+28h] [bp-870h]
  unsigned int max_nonce; // [sp+2Ch] [bp-86Ch]
  int thr_id; // [sp+30h] [bp-868h]
  _BOOL4 primary; // [sp+40h] [bp-858h]
  int v33; // [sp+44h] [bp-854h]
  work *work; // [sp+4Ch] [bp-84Ch] BYREF
  timeval getwork_start; // [sp+50h] [bp-848h] BYREF
  timeval tv_start; // [sp+58h] [bp-840h] BYREF
  timeval tv_workstart; // [sp+60h] [bp-838h] BYREF
  timeval tv_lastupdate; // [sp+68h] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+70h] [bp-828h] BYREF

  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  thr_id = mythr->id;
  v3 = opt_log_interval / 5;
  if ( (int)((unsigned __int64)(1717986919LL * opt_log_interval) >> 32) >> 1 == opt_log_interval >> 31 )
    v3 = 1;
  cycle = v3;
  if ( mythr->device_thread )
    primary = mythr->primary_thread;
  else
    primary = 1;
  max_nonce = drv->can_limit_work(mythr);
  cgtime(&getwork_start);
  cgtime(&tv_lastupdate);
  if ( !cgpu->shutdown )
  {
    shutdown = cgpu->shutdown;
    deven = shutdown;
    v6 = 0LL;
    v7 = ((_DWORD)&::cgpu.results[29][3663] * cycle + 1023) & (((int)&::cgpu.results[29][3663] * cycle) >> 31);
    if ( (int)&::cgpu.results[29][3663] * cycle >= 0 )
      v7 = (_DWORD)&::cgpu.results[29][3663] * cycle;
    v33 = v7 >> 10;
    do
    {
      work = get_work(mythr, thr_id);
      mythr->work_restart = 0;
      cgpu->new_work = 1;
      cgtime(&tv_workstart);
      prepare_work = drv->prepare_work;
      work->nonce = 0;
      cgpu->max_hashes = 0LL;
      if ( !((int (__fastcall *)(thr_info *))prepare_work)(mythr) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "work prepare failed, exiting mining thread %d", thr_id);
          applog(3, tmp42, 0);
        }
        break;
      }
      max_diff = drv->max_diff;
      if ( max_diff > work->work_difficulty )
        max_diff = work->work_difficulty;
      if ( max_diff < drv->min_diff )
        max_diff = drv->min_diff;
      dest = &cgpu->cgminer_stats.getwork_wait_max;
      p_getwork_wait_min = &cgpu->cgminer_stats.getwork_wait_min;
      work->device_diff = max_diff;
      while ( 1 )
      {
        cgtime(&tv_start);
        subtime(&tv_start, &getwork_start);
        addtime(&getwork_start, &cgpu->cgminer_stats.getwork_wait);
        if ( time_more(&getwork_start, dest) )
        {
          copy_time(dest, &getwork_start);
          if ( !time_less(&getwork_start, p_getwork_wait_min) )
            goto LABEL_25;
        }
        else if ( !time_less(&getwork_start, p_getwork_wait_min) )
        {
          goto LABEL_25;
        }
        copy_time(p_getwork_wait_min, &getwork_start);
LABEL_25:
        pool = work->pool;
        ++cgpu->cgminer_stats.getwork_calls;
        addtime(&getwork_start, &pool->cgminer_stats.getwork_wait);
        if ( time_more(&getwork_start, &pool->cgminer_stats.getwork_wait_max) )
          copy_time(&pool->cgminer_stats.getwork_wait_max, &getwork_start);
        if ( time_less(&getwork_start, &pool->cgminer_stats.getwork_wait_min) )
          copy_time(&pool->cgminer_stats.getwork_wait_min, &getwork_start);
        v12 = work;
        ++pool->cgminer_stats.getwork_calls;
        cgtime(&v12->tv_work_start);
        pthread_setcancelstate(1, 0);
        thread_reportin(mythr);
        v13 = ((__int64 (__fastcall *)(thr_info *, work *, unsigned int, _DWORD))drv->scanhash)(
                mythr,
                work,
                max_nonce + work->nonce,
                0);
        thread_reportout(mythr);
        pthread_setcancelstate(0, 0);
        pthread_testcancel();
        cgtime(&getwork_start);
        v14 = HIDWORD(v13) == -1;
        if ( HIDWORD(v13) == -1 )
          v14 = (_DWORD)v13 == -1;
        if ( v14 )
          break;
        v6 += v13;
        if ( cgpu->max_hashes < v13 )
          cgpu->max_hashes = v13;
        tv_sec = getwork_start.tv_sec;
        v16 = getwork_start.tv_sec - tv_start.tv_sec;
        v17 = getwork_start.tv_usec - tv_start.tv_usec;
        if ( getwork_start.tv_usec - tv_start.tv_usec < 0 )
        {
          --v16;
          v17 += 1000000;
        }
        deven += v16;
        shutdown += v17;
        v18 = shutdown <= 1000000;
        if ( shutdown > 1000000 )
        {
          shutdown -= 999424;
          ++deven;
        }
        if ( !v18 )
          shutdown -= 576;
        v19 = getwork_start.tv_sec - tv_workstart.tv_sec;
        if ( getwork_start.tv_usec - tv_workstart.tv_usec < 0 )
          --v19;
        if ( cycle > deven )
        {
          if ( max_nonce == -1 )
            goto LABEL_14;
          v23 = shutdown + 2047;
          if ( shutdown + 1024 >= 0 )
            v23 = shutdown + 1024;
          v25 = ((int)&::cgpu.results[29][3663] / (v23 >> 10) + 16) * cycle;
          tv_sec = getwork_start.tv_sec;
          if ( max_nonce <= 0xFFFFFC00 / v25 )
            max_nonce = (max_nonce * v25) >> 10;
          else
            max_nonce = -1;
        }
        else if ( cycle < deven )
        {
          tv_sec = getwork_start.tv_sec;
          max_nonce = cycle * max_nonce / deven;
        }
        else if ( shutdown > (int)&loc_186A0 )
        {
          tv_sec = getwork_start.tv_sec;
          max_nonce = (max_nonce << 10) / (((int)&::cgpu.results[29][3663] * cycle + shutdown) / v33);
        }
        v20 = (char (**)[16])tv_lastupdate.tv_sec;
        v21 = getwork_start.tv_usec
            - tv_lastupdate.tv_usec
            + (getwork_start.tv_usec - tv_lastupdate.tv_usec < 0 ? 0xF4000 : 0);
        v22 = tv_sec - tv_lastupdate.tv_sec;
        if ( getwork_start.tv_usec - tv_lastupdate.tv_usec < 0 )
        {
          --v22;
          v21 += 576;
        }
        if ( v6 )
        {
          if ( v22 <= 0 )
          {
            v20 = &off_30D40;
            if ( v21 <= (int)&off_30D40 && opt_log_interval > v22 )
              goto LABEL_11;
          }
        }
        else if ( opt_log_interval > v22 )
        {
          goto LABEL_11;
        }
        v8 = v6;
        v6 = 0LL;
        hashmeter(thr_id, (int)v20, v8);
        copy_time(&tv_lastupdate, &getwork_start);
LABEL_11:
        if ( mythr->work_restart )
        {
          if ( !primary )
          {
            device_thread = mythr->device_thread;
            *(_DWORD *)tmp42 = 0;
            *(_DWORD *)&tmp42[4] = 250000000 * device_thread;
            nanosleep((const struct timespec *)tmp42, 0);
          }
          goto LABEL_16;
        }
        if ( mythr->pause || (deven = cgpu->deven, (shutdown = deven) != 0) )
        {
          deven = 0;
          mt_disable(mythr, thr_id, drv);
          shutdown = 0;
        }
LABEL_14:
        if ( v19 > opt_scantime || cgpu->max_hashes > 0xFFFFFFFDuLL || stale_work(work, 0) )
          goto LABEL_16;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = DEV_DISABLED;
      dev_error(cgpu, REASON_THREAD_ZERO_HASH);
      cgpu->shutdown = 1;
LABEL_16:
      free_work(&work, "cgminer.c", &_func___14773.__size[12], 9214);
    }
    while ( !cgpu->shutdown );
  }
  cgpu->deven = DEV_DISABLED;
}
// 30D40: using guessed type char (*off_30D40)[16];

//----- (00029350) --------------------------------------------------------
void __fastcall submit_work_async(work *work)
{
  pool *pool; // r6
  cgpu_info *cgpu; // r7
  const unsigned __int8 *v3; // r2
  int v4; // r3
  double work_difficulty; // d7
  double v6; // d5
  double diff_accepted; // d4
  int64_t v8; // r8
  __int64 v9; // r4
  double v10; // d6
  double v11; // d4
  const unsigned __int8 *v12; // r2
  int v13; // r3
  work *v14; // r3
  thread_q *stratum_q; // r0
  const unsigned __int8 *v16; // r2
  int v17; // r3
  double v18; // d7
  unsigned int v19; // r3
  double v20; // d6
  double v21; // d7
  unsigned int v22; // kr00_4
  const unsigned __int8 *v23; // r2
  int v24; // r3
  work *worka[2]; // [sp+Ch] [bp-82Ch] BYREF
  pthread_t submit_thread; // [sp+14h] [bp-824h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-820h] BYREF

  worka[0] = work;
  pool = work->pool;
  cgtime(&work->tv_work_found);
  if ( opt_benchmark )
  {
    cgpu = get_thread(worka[0]->thr_id)->cgpu;
    if ( pthread_mutex_lock(&stats_lock) )
      mutex_lock_2((pthread_mutex_t *)(&_func___14773.__align + 7), (const unsigned __int8 *)0x2178, v3, v4);
    work_difficulty = worka[0]->work_difficulty;
    v6 = cgpu->diff_accepted + work_difficulty;
    diff_accepted = pool->diff_accepted;
    v8 = total_accepted;
    v9 = pool->accepted + 1;
    ++cgpu->accepted;
    v10 = diff_accepted + work_difficulty;
    v11 = total_diff_accepted;
    pool->accepted = v9;
    cgpu->diff_accepted = v6;
    pool->diff_accepted = v10;
    total_accepted = v8 + 1;
    total_diff_accepted = work_difficulty + v11;
    if ( pthread_mutex_unlock(&stats_lock) )
      mutex_unlock_noyield_2((pthread_mutex_t *)(&_func___14773.__align + 7), (const unsigned __int8 *)0x217F, v12, v13);
    selective_yield();
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Accepted %s %d benchmark share nonce %08x",
        (const char *)cgpu->drv->name,
        cgpu->device_id,
        *(_DWORD *)&worka[0]->data[76]);
      applog(5, tmp42, 0);
    }
    return;
  }
  if ( !stale_work(worka[0], 1) )
  {
    v14 = worka[0];
    if ( worka[0]->stratum )
      goto LABEL_10;
LABEL_28:
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Pushing submit work to work thread");
      applog(7, tmp42, 0);
      v14 = worka[0];
    }
    if ( pthread_create(&submit_thread, 0, submit_work_thread, v14) )
    {
      strcpy((char *)tmp42, "Failed to create submit_work_thread");
      applog(3, tmp42, 1);
      quit(1);
    }
    return;
  }
  if ( opt_submit_stale )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as user requested", pool->pool_no);
LABEL_26:
      applog(5, tmp42, 0);
      goto LABEL_27;
    }
    goto LABEL_27;
  }
  if ( pool->submit_old )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as pool requested", pool->pool_no);
      goto LABEL_26;
    }
LABEL_27:
    v14 = worka[0];
    worka[0]->stale = 1;
    if ( v14->stratum )
    {
LABEL_10:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Pushing pool %d work to stratum queue", pool->pool_no);
        applog(7, tmp42, 0);
      }
      stratum_q = pool->stratum_q;
      if ( !stratum_q || !tq_push(stratum_q, worka[0]) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Discarding work from removed pool");
          applog(7, tmp42, 0);
        }
        free_work(worka, "cgminer.c", &_func___14773.__size[28], 8617);
      }
      return;
    }
    goto LABEL_28;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, discarding", pool->pool_no);
    applog(5, tmp42, 0);
  }
  sharelog("discard", worka[0]);
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_2((pthread_mutex_t *)(&_func___14773.__align + 7), (const unsigned __int8 *)0x2194, v16, v17);
  v18 = worka[0]->work_difficulty;
  v19 = HIDWORD(total_stale);
  v20 = pool->diff_stale + v18;
  v21 = v18 + total_diff_stale;
  v22 = total_stale;
  ++pool->stale_shares;
  pool->diff_stale = v20;
  total_diff_stale = v21;
  total_stale = __PAIR64__(v19, v22) + 1;
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)(&_func___14773.__align + 7), (const unsigned __int8 *)0x219B, v23, v24);
  selective_yield();
  free_work(worka, "cgminer.c", &_func___14773.__size[28], 8605);
}
// 296B0: variable 'v12' is possibly undefined
// 296B0: variable 'v13' is possibly undefined
// 296BC: variable 'v3' is possibly undefined
// 296BC: variable 'v4' is possibly undefined
// 296C8: variable 'v23' is possibly undefined
// 296C8: variable 'v24' is possibly undefined
// 296D4: variable 'v16' is possibly undefined
// 296D4: variable 'v17' is possibly undefined

//----- (00029708) --------------------------------------------------------
bool __fastcall submit_noffset_nonce(thr_info *thr, work *work_in, unsigned int nonce, int noffset)
{
  work *v8; // r4
  work *work; // [sp+Ch] [bp-81Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  work = make_work();
  copy_work(work, work_in, noffset);
  v8 = work;
  *(_DWORD *)&work->data[76] = nonce;
  regen_hash(v8);
  if ( *(_DWORD *)&v8->hash[28] )
  {
    free_work(&work, "cgminer.c", _func___14715, 8974);
    inc_hw_errors(thr);
    return 0;
  }
  else
  {
    update_work_stats(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
      benchfile_dspwork(work, nonce);
    if ( fulltest(work->hash, work->target) )
    {
      submit_work_async(work);
      return 1;
    }
    else
    {
      free_work(&work, "cgminer.c", _func___14715, 8990);
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s %d: Share above target",
          (const char *)thr->cgpu->drv->name,
          thr->cgpu->device_id);
        applog(6, tmp42, 0);
        return 1;
      }
      else
      {
        return 1;
      }
    }
  }
}

//----- (000297FC) --------------------------------------------------------
bool __fastcall submit_nonce_direct(thr_info *thr, work *work, unsigned int nonce)
{
  work *v3; // r0

  *(_DWORD *)&work->data[76] = nonce;
  v3 = copy_work_noffset(work, 0);
  submit_work_async(v3);
  return 1;
}

//----- (00029810) --------------------------------------------------------
void __fastcall submit_nonce_2(work *work)
{
  work *v1; // r0

  v1 = copy_work_noffset(work, 0);
  submit_work_async(v1);
}

//----- (00029820) --------------------------------------------------------
bool __fastcall submit_tested_work(thr_info *thr, work *work)
{
  bool result; // r0
  work *v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  update_work_stats(thr, work);
  if ( fulltest(work->hash, work->target) )
  {
    v5 = copy_work_noffset(work, 0);
    submit_work_async(v5);
    return 1;
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 5 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s %s %d: Share above target",
      (const char *)_FUNCTION___14630,
      (const char *)thr->cgpu->drv->name,
      thr->cgpu->device_id);
    applog(6, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (000298A4) --------------------------------------------------------
bool __fastcall submit_nonce(thr_info *thr, work *work, unsigned int nonce)
{
  if ( new_nonce(thr, nonce) && (*(_DWORD *)&work->data[76] = nonce, regen_hash(work), !*(_DWORD *)&work->hash[28]) )
  {
    submit_tested_work(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
    {
      benchfile_dspwork(work, nonce);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    inc_hw_errors(thr);
    return 0;
  }
}

//----- (000298FC) --------------------------------------------------------
bool __fastcall add_pool_details(
        pool *pool,
        bool live,
        unsigned __int8 *url,
        unsigned __int8 *user,
        unsigned __int8 *pass)
{
  _BOOL4 v7; // r5
  unsigned __int8 *proxy; // r0
  size_t v9; // r7
  unsigned int v10; // r6
  unsigned __int8 *v11; // r0
  size_t v12; // r1
  unsigned __int8 *rpc_pass; // r6
  unsigned __int8 *rpc_user; // r3
  int *enabled; // r2
  bool v16; // zf
  bool result; // r0

  v7 = live;
  proxy = get_proxy(url, pool);
  pool->rpc_user = user;
  pool->rpc_url = proxy;
  pool->rpc_pass = pass;
  v9 = strlen((const char *)user);
  v10 = v9 + strlen((const char *)pass) + 2;
  v11 = (unsigned __int8 *)cgmalloc(v10, "cgminer.c", _func___15176, 10679);
  v12 = v10;
  rpc_pass = pool->rpc_pass;
  rpc_user = pool->rpc_user;
  pool->rpc_userpass = v11;
  snprintf((char *)v11, v12, "%s:%s", (const char *)rpc_user, (const char *)rpc_pass);
  enabled = (int *)pool->enabled;
  pool->testing = 1;
  pool->idle = 1;
  v16 = enabled == (int *)1;
  pool->blocking = !v7;
  if ( enabled != (int *)1 )
    enabled = &enabled_pools;
  if ( !v16 )
  {
    pool->enabled = POOL_ENABLED;
    ++*enabled;
  }
  pthread_create(&pool->test_thread, 0, start_routine, pool);
  result = 1;
  if ( !v7 )
  {
    pthread_join(pool->test_thread, 0);
    return pools_active;
  }
  return result;
}

//----- (000299B8) --------------------------------------------------------
void __fastcall fill_device_drv(device_drv *drv)
{
  if ( drv->drv_detect )
  {
    if ( drv->reinit_device )
      goto LABEL_3;
  }
  else
  {
    drv->drv_detect = noop_detect;
    if ( drv->reinit_device )
    {
LABEL_3:
      if ( drv->get_statline_before )
        goto LABEL_4;
      goto LABEL_22;
    }
  }
  drv->reinit_device = noop_reinit_device;
  if ( drv->get_statline_before )
  {
LABEL_4:
    if ( drv->get_statline )
      goto LABEL_5;
    goto LABEL_23;
  }
LABEL_22:
  drv->get_statline_before = blank_get_statline_before;
  if ( drv->get_statline )
  {
LABEL_5:
    if ( drv->get_stats )
      goto LABEL_6;
    goto LABEL_24;
  }
LABEL_23:
  drv->get_statline = noop_get_statline;
  if ( drv->get_stats )
  {
LABEL_6:
    if ( drv->thread_prepare )
      goto LABEL_7;
    goto LABEL_25;
  }
LABEL_24:
  drv->get_stats = noop_get_stats;
  if ( drv->thread_prepare )
  {
LABEL_7:
    if ( drv->thread_init )
      goto LABEL_8;
    goto LABEL_26;
  }
LABEL_25:
  drv->thread_prepare = noop_thread_prepare;
  if ( drv->thread_init )
  {
LABEL_8:
    if ( drv->prepare_work )
      goto LABEL_9;
    goto LABEL_27;
  }
LABEL_26:
  drv->thread_init = noop_thread_init;
  if ( drv->prepare_work )
  {
LABEL_9:
    if ( drv->hw_error )
      goto LABEL_10;
    goto LABEL_28;
  }
LABEL_27:
  drv->prepare_work = noop_prepare_work;
  if ( drv->hw_error )
  {
LABEL_10:
    if ( drv->thread_shutdown )
      goto LABEL_11;
    goto LABEL_29;
  }
LABEL_28:
  drv->hw_error = noop_hw_error;
  if ( drv->thread_shutdown )
  {
LABEL_11:
    if ( drv->thread_enable )
      goto LABEL_12;
    goto LABEL_30;
  }
LABEL_29:
  drv->thread_shutdown = noop_thread_shutdown;
  if ( drv->thread_enable )
  {
LABEL_12:
    if ( drv->hash_work )
      goto LABEL_13;
    goto LABEL_31;
  }
LABEL_30:
  drv->thread_enable = noop_thread_enable;
  if ( drv->hash_work )
  {
LABEL_13:
    if ( drv->flush_work )
      goto LABEL_14;
    goto LABEL_32;
  }
LABEL_31:
  drv->hash_work = hash_sole_work;
  if ( drv->flush_work )
  {
LABEL_14:
    if ( drv->update_work )
      goto LABEL_15;
    goto LABEL_33;
  }
LABEL_32:
  drv->flush_work = noop_reinit_device;
  if ( drv->update_work )
  {
LABEL_15:
    if ( drv->queue_full )
      goto LABEL_16;
LABEL_34:
    drv->queue_full = noop_get_stats;
    if ( drv->zero_stats )
      goto LABEL_17;
    goto LABEL_35;
  }
LABEL_33:
  drv->update_work = noop_reinit_device;
  if ( !drv->queue_full )
    goto LABEL_34;
LABEL_16:
  if ( drv->zero_stats )
    goto LABEL_17;
LABEL_35:
  drv->zero_stats = generic_zero_stats;
LABEL_17:
  if ( drv->max_diff == 0.0 )
    drv->max_diff = 1.0;
}

//----- (00029B08) --------------------------------------------------------
void __fastcall null_device_drv(device_drv *drv)
{
  drv->drv_detect = noop_detect;
  drv->hw_error = noop_hw_error;
  drv->thread_shutdown = noop_thread_shutdown;
  drv->zero_stats = generic_zero_stats;
  drv->hash_work = noop_hash_work;
  drv->thread_enable = noop_thread_enable;
  drv->get_statline_before = blank_get_statline_before;
  drv->get_statline = noop_get_statline;
  drv->get_api_stats = noop_get_api_stats;
  drv->thread_prepare = noop_thread_prepare;
  drv->can_limit_work = (unsigned int (*)(thr_info *))noop_can_limit_work;
  drv->thread_init = noop_thread_init;
  drv->prepare_work = noop_prepare_work;
  drv->set_device = 0;
  drv->reinit_device = noop_reinit_device;
  drv->identify_device = noop_reinit_device;
  drv->flush_work = noop_reinit_device;
  drv->update_work = noop_reinit_device;
  drv->get_stats = noop_get_stats;
  drv->queue_full = noop_get_stats;
  drv->max_diff = 1.0;
  drv->min_diff = 1.0;
}

//----- (00029BD0) --------------------------------------------------------
void __fastcall enable_device(cgpu_info *cgpu)
{
  const unsigned __int8 *v2; // r2
  int v3; // r3
  cgpu_info **v4; // r1
  int v5; // r3
  const unsigned __int8 *v6; // r2
  int v7; // r3
  const unsigned __int8 *v8; // r2
  int v9; // r3

  cgpu->deven = DEV_ENABLED;
  if ( pthread_rwlock_wrlock(&devices_lock) )
    wr_lock_0((pthread_rwlock_t *)&_func___15270, (const unsigned __int8 *)0x2B51, v2, v3);
  v4 = devices;
  v5 = cgminer_id_count;
  cgpu->cgminer_id = cgminer_id_count;
  v4[v5] = cgpu;
  cgminer_id_count = v5 + 1;
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___15270, (const unsigned __int8 *)0x2B53, v6, v7);
  selective_yield();
  if ( hotplug_mode )
    new_threads += cgpu->threads;
  else
    mining_threads += cgpu->threads;
  if ( pthread_rwlock_init(&cgpu->qlock, 0) )
    rwlock_init((pthread_rwlock_t *)&_func___15270, (const unsigned __int8 *)0x2B5E, v8, v9);
  cgpu->queued_work = 0;
}
// 29C42: variable 'v6' is possibly undefined
// 29C42: variable 'v7' is possibly undefined
// 29C4E: variable 'v2' is possibly undefined
// 29C4E: variable 'v3' is possibly undefined
// 29C5A: variable 'v8' is possibly undefined
// 29C5A: variable 'v9' is possibly undefined

//----- (00029C7C) --------------------------------------------------------
bool __fastcall add_cgpu(cgpu_info *cgpu)
{
  unsigned int v1; // r5
  int v2; // r7
  unsigned __int8 *name; // r8
  int v4; // r4
  size_t v5; // r9
  unsigned __int8 *v6; // r3
  unsigned int i; // r6
  int v8; // r0
  int v9; // r12
  int v10; // r10
  int v11; // lr
  int v12; // r1
  unsigned int v13; // r2
  unsigned int v14; // r5
  int v15; // r4
  unsigned int v16; // r1
  unsigned int v17; // r2
  int v18; // r4
  unsigned int v19; // r1
  unsigned int v20; // r2
  size_t v21; // r7
  int v22; // r1
  unsigned int v23; // r2
  unsigned int v24; // r3
  int v25; // r1
  unsigned int v26; // r2
  unsigned int v27; // r3
  int v28; // r1
  unsigned int v29; // r5
  UT_hash_table *v30; // r6
  UT_hash_handle *v31; // r4
  unsigned int keylen; // r3
  int v33; // r4
  size_t v34; // r0
  unsigned int v35; // r2
  unsigned __int8 *v36; // r3
  int v37; // r1
  unsigned int j; // r5
  int v39; // r9
  int v40; // r7
  int v41; // lr
  int v42; // r6
  int v43; // r12
  unsigned int v44; // r6
  unsigned int v45; // r2
  int v46; // r1
  unsigned int v47; // r4
  unsigned int v48; // r2
  int v49; // r1
  unsigned int v50; // r4
  unsigned int v51; // r2
  unsigned int v52; // r6
  unsigned int v53; // r4
  size_t v54; // r4
  int v55; // r3
  const unsigned __int8 *v56; // r2
  int v57; // r3
  const unsigned __int8 *v58; // r2
  int v59; // r3
  const unsigned __int8 *v60; // r2
  int v61; // r3
  const unsigned __int8 *v62; // r2
  int v63; // r3
  int v64; // r3
  int v65; // r0
  int v66; // r3
  int v68; // r1
  unsigned int v69; // r2
  unsigned int v70; // r3
  int v71; // r1
  unsigned int v72; // r2
  unsigned int v73; // r3
  int v74; // r1
  unsigned int v75; // r6
  _cgpu_devid_counter *v76; // r4
  UT_hash_handle_0 *p_hh; // r5
  UT_hash_table *tbl; // r2
  UT_hash_handle *tail; // r0
  UT_hash_table *v80; // r3
  ptrdiff_t hho; // r1
  UT_hash_bucket_0 *buckets; // r0
  int v83; // r6
  UT_hash_handle *hh_head; // r4
  unsigned int v85; // r1
  unsigned int expand_mult; // r2
  UT_hash_table *v87; // r3
  size_t v88; // r4
  UT_hash_bucket_0 *v89; // r0
  UT_hash_bucket_0 *v90; // r7
  UT_hash_table *v91; // r10
  unsigned int num_buckets; // r3
  unsigned int num_items; // r4
  unsigned int log2_num_buckets; // r2
  unsigned int v95; // r5
  int v96; // r2
  unsigned int v97; // r9
  UT_hash_bucket_0 *v98; // r4
  unsigned int v99; // r3
  UT_hash_table *v100; // r9
  unsigned int v101; // r10
  UT_hash_handle *v102; // r4
  UT_hash_handle *hh_next; // r8
  int v104; // r5
  UT_hash_bucket_0 *v105; // r6
  unsigned int v106; // r0
  UT_hash_handle *v107; // r3
  UT_hash_table *v108; // r3
  unsigned int nonideal_items; // r2
  unsigned int v110; // r1
  unsigned int v111; // r4
  unsigned int v112; // r0
  bool v113; // cc
  int v114; // r4
  unsigned int v115; // r0
  unsigned int v116; // r2
  UT_hash_table *v117; // r0
  UT_hash_table *v118; // r7
  UT_hash_bucket_0 *v119; // r0
  _cgpu_devid_counter *d; // [sp+10h] [bp-38h]
  unsigned int v122; // [sp+14h] [bp-34h]
  UT_hash_bucket_0 *ptr; // [sp+18h] [bp-30h]
  int v124; // [sp+1Ch] [bp-2Ch]

  v1 = -1640531527;
  v2 = -17973521;
  name = cgpu->drv->name;
  v4 = -1640531527;
  v5 = strlen((const char *)name);
  v6 = name;
  for ( i = v5; i > 0xB; v2 = (v20 - v4 - v1) ^ (v1 >> 15) )
  {
    i -= 12;
    v8 = (v6[6] << 16) + (v6[5] << 8);
    v9 = v6[3];
    v10 = v6[4];
    v11 = v6[7];
    v12 = (v6[2] << 16) + (v6[1] << 8) + *v6;
    v13 = (v6[10] << 16) + (v6[9] << 8) + v6[8] + (v6[11] << 24) + v2;
    v6 += 12;
    v14 = v1 + v8 + v10 + (v11 << 24);
    v15 = (v4 + v12 + (v9 << 24) - v13 - v14) ^ (v13 >> 13);
    v16 = (v14 - v13 - v15) ^ (v15 << 8);
    v17 = (v13 - v15 - v16) ^ (v16 >> 13);
    v18 = (v15 - v16 - v17) ^ (v17 >> 12);
    v19 = (v16 - v17 - v18) ^ (v18 << 16);
    v20 = (v17 - v18 - v19) ^ (v19 >> 5);
    v4 = (v18 - v19 - v20) ^ (v20 >> 3);
    v1 = (v19 - v20 - v4) ^ (v4 << 10);
  }
  v21 = v2 + v5;
  switch ( i )
  {
    case 1u:
      goto LABEL_14;
    case 2u:
      goto LABEL_13;
    case 3u:
      goto LABEL_12;
    case 4u:
      goto LABEL_11;
    case 5u:
      goto LABEL_10;
    case 6u:
      goto LABEL_9;
    case 7u:
      goto LABEL_8;
    case 8u:
      goto LABEL_7;
    case 9u:
      goto LABEL_6;
    case 0xAu:
      goto LABEL_5;
    case 0xBu:
      v21 += v6[10] << 24;
LABEL_5:
      v21 += v6[9] << 16;
LABEL_6:
      v21 += v6[8] << 8;
LABEL_7:
      v1 += v6[7] << 24;
LABEL_8:
      v1 += v6[6] << 16;
LABEL_9:
      v1 += v6[5] << 8;
LABEL_10:
      v1 += v6[4];
LABEL_11:
      v4 += v6[3] << 24;
LABEL_12:
      v4 += v6[2] << 16;
LABEL_13:
      v4 += v6[1] << 8;
LABEL_14:
      v4 += *v6;
      break;
    default:
      break;
  }
  v22 = (v4 - v1 - v21) ^ (v21 >> 13);
  v23 = (v1 - v21 - v22) ^ (v22 << 8);
  v24 = (v21 - v22 - v23) ^ (v23 >> 13);
  v25 = (v22 - v23 - v24) ^ (v24 >> 12);
  v26 = (v23 - v24 - v25) ^ (v25 << 16);
  v27 = (v24 - v25 - v26) ^ (v26 >> 5);
  v28 = (v25 - v26 - v27) ^ (v27 >> 3);
  v29 = (v27 - v28 - ((v26 - v27 - v28) ^ (v28 << 10))) ^ (((v26 - v27 - v28) ^ (v28 << 10)) >> 15);
  if ( !devids_15281 )
  {
LABEL_21:
    d = (_cgpu_devid_counter *)cgmalloc(0x28u, "cgminer.c", &_func___15270.__size[16], 11136);
    v33 = -17973521;
    cg_memcpy(d, cgpu->drv->name, 4u, "cgminer.c", &_func___15270.__size[16], 11137);
    d->lastid = 0;
    cgpu->device_id = 0;
    v34 = strlen((const char *)d);
    v35 = -1640531527;
    v36 = (unsigned __int8 *)d;
    v37 = -1640531527;
    for ( j = v34; j > 0xB; v33 = (v53 - v35) ^ (v35 >> 15) )
    {
      j -= 12;
      v39 = (v36[6] << 16) + (v36[5] << 8);
      v40 = v36[4];
      v41 = v36[7];
      v42 = v36[8] + (v36[10] << 16) + (v36[9] << 8) + (v36[11] << 24);
      v43 = (v36[2] << 16) + (v36[1] << 8) + *v36 + (v36[3] << 24);
      v36 += 12;
      v44 = v42 + v33;
      v45 = v35 + v40 + v39 + (v41 << 24);
      v46 = (v37 + v43 - v44 - v45) ^ (v44 >> 13);
      v47 = (v45 - v44 - v46) ^ (v46 << 8);
      v48 = (v44 - v46 - v47) ^ (v47 >> 13);
      v49 = (v46 - v47 - v48) ^ (v48 >> 12);
      v50 = (v47 - v48 - v49) ^ (v49 << 16);
      v51 = (v48 - v49 - v50) ^ (v50 >> 5);
      v37 = (v49 - v50 - v51) ^ (v51 >> 3);
      v52 = v50 - v51 - v37;
      v53 = v51 - v37;
      v35 = v52 ^ (v37 << 10);
    }
    v54 = v33 + v34;
    switch ( j )
    {
      case 1u:
        goto LABEL_47;
      case 2u:
        goto LABEL_46;
      case 3u:
        goto LABEL_45;
      case 4u:
        goto LABEL_44;
      case 5u:
        goto LABEL_43;
      case 6u:
        goto LABEL_42;
      case 7u:
        goto LABEL_41;
      case 8u:
        goto LABEL_40;
      case 9u:
        goto LABEL_39;
      case 0xAu:
        goto LABEL_38;
      case 0xBu:
        v54 += v36[10] << 24;
LABEL_38:
        v54 += v36[9] << 16;
LABEL_39:
        v54 += v36[8] << 8;
LABEL_40:
        v35 += v36[7] << 24;
LABEL_41:
        v35 += v36[6] << 16;
LABEL_42:
        v35 += v36[5] << 8;
LABEL_43:
        v35 += v36[4];
LABEL_44:
        v37 += v36[3] << 24;
LABEL_45:
        v37 += v36[2] << 16;
LABEL_46:
        v37 += v36[1] << 8;
LABEL_47:
        v37 += *v36;
        break;
      default:
        break;
    }
    v68 = (v37 - v35 - v54) ^ (v54 >> 13);
    v69 = (v35 - v54 - v68) ^ (v68 << 8);
    d->hh.key = d;
    v70 = (v54 - v68 - v69) ^ (v69 >> 13);
    v71 = (v68 - v69 - v70) ^ (v70 >> 12);
    v72 = (v69 - v70 - v71) ^ (v71 << 16);
    v73 = (v70 - v71 - v72) ^ (v72 >> 5);
    v74 = (v71 - v72 - v73) ^ (v73 >> 3);
    v75 = (v73 - v74 - ((v72 - v73 - v74) ^ (v74 << 10))) ^ (((v72 - v73 - v74) ^ (v74 << 10)) >> 15);
    d->hh.hashv = v75;
    v76 = devids_15281;
    d->hh.keylen = strlen((const char *)d);
    if ( v76 )
    {
      d->hh.tbl = v76->hh.tbl;
      p_hh = &d->hh;
      d->hh.next = 0;
      tbl = v76->hh.tbl;
      tail = tbl->tail;
      v80 = tbl;
      hho = tbl->hho;
      tail->next = d;
      d->hh.prev = (char *)tail - hho;
      tbl->tail = &d->hh;
    }
    else
    {
      d->hh.next = 0;
      d->hh.prev = 0;
      devids_15281 = d;
      v117 = (UT_hash_table *)malloc(0x2Cu);
      d->hh.tbl = v117;
      if ( !v117 )
        goto LABEL_80;
      v117->buckets = 0;
      v117->num_buckets = 0;
      v117->log2_num_buckets = 0;
      v117->num_items = 0;
      v117->tail = 0;
      v117->hho = 0;
      v117->ideal_chain_maxlen = 0;
      v117->nonideal_items = 0;
      v117->ineff_expands = 0;
      v117->noexpand = 0;
      v117->signature = 0;
      p_hh = &d->hh;
      v118 = d->hh.tbl;
      v118->tail = &d->hh;
      v118->num_buckets = 32;
      v118->log2_num_buckets = 5;
      v118->hho = 8;
      v119 = (UT_hash_bucket_0 *)malloc(0x180u);
      v118->buckets = v119;
      if ( !v119 )
        goto LABEL_80;
      memset(v119, 0, 0x180u);
      v80 = d->hh.tbl;
      v80->signature = -1609490463;
    }
    buckets = v80->buckets;
    v83 = v75 & (v80->num_buckets - 1);
    ++v80->num_items;
    hh_head = buckets[v83].hh_head;
    v85 = buckets[v83].count + 1;
    buckets[v83].count = v85;
    d->hh.hh_next = hh_head;
    d->hh.hh_prev = 0;
    if ( hh_head )
      hh_head->hh_prev = p_hh;
    expand_mult = buckets[v83].expand_mult;
    buckets[v83].hh_head = p_hh;
    if ( v85 < 10 * (expand_mult + 1) )
      goto LABEL_27;
    v87 = d->hh.tbl;
    if ( v87->noexpand == 1 )
      goto LABEL_27;
    v88 = 24 * v87->num_buckets;
    v89 = (UT_hash_bucket_0 *)malloc(v88);
    v90 = v89;
    if ( v89 )
    {
      memset(v89, 0, v88);
      v91 = d->hh.tbl;
      num_buckets = v91->num_buckets;
      num_items = v91->num_items;
      log2_num_buckets = v91->log2_num_buckets;
      v91->nonideal_items = 0;
      v95 = num_items >> (log2_num_buckets + 1);
      v96 = 2 * num_buckets - 1;
      if ( (num_items & v96) != 0 )
        v97 = v95 + 1;
      else
        v97 = v95;
      v91->ideal_chain_maxlen = v97;
      if ( num_buckets )
      {
        v98 = v91->buckets;
        v122 = 0;
        v124 = 12 * num_buckets;
        v99 = v97;
        v100 = v91;
        v101 = v99;
        ptr = v98;
        do
        {
          v102 = ptr[v122 / 0xC].hh_head;
          if ( v102 )
          {
            do
            {
              hh_next = v102->hh_next;
              v104 = v102->hashv & v96;
              v105 = &v90[v102->hashv & v96];
              v106 = v105->count + 1;
              v105->count = v106;
              if ( v101 < v106 )
              {
                ++v100->nonideal_items;
                v105->expand_mult = v106 / v101;
              }
              v107 = v90[v104].hh_head;
              v102->hh_prev = 0;
              v102->hh_next = v107;
              if ( v107 )
                v107->hh_prev = v102;
              v90[v104].hh_head = v102;
              v102 = hh_next;
            }
            while ( hh_next );
          }
          v122 += 12;
        }
        while ( v122 != v124 );
        free(ptr);
      }
      else
      {
        free(v91->buckets);
      }
      v108 = d->hh.tbl;
      nonideal_items = v108->nonideal_items;
      v110 = v108->num_items;
      v111 = v108->num_buckets;
      v112 = v108->log2_num_buckets;
      v108->buckets = v90;
      v113 = nonideal_items > v110 >> 1;
      v114 = 2 * v111;
      v115 = v112 + 1;
      if ( nonideal_items <= v110 >> 1 )
        nonideal_items = 0;
      v108->log2_num_buckets = v115;
      v108->num_buckets = v114;
      if ( v113 )
      {
        v116 = v108->ineff_expands + 1;
        v108->ineff_expands = v116;
        if ( v116 > 1 )
          v108->noexpand = 1;
      }
      else
      {
        v108->ineff_expands = nonideal_items;
      }
      goto LABEL_27;
    }
LABEL_80:
    exit(-1);
  }
  v30 = devids_15281->hh.tbl;
  v31 = v30->buckets[(v30->num_buckets - 1) & v29].hh_head;
  if ( v31 )
    v31 = (UT_hash_handle *)((char *)v31 - v30->hho);
  while ( 1 )
  {
    if ( !v31 )
      goto LABEL_21;
    if ( v31[1].prev == (void *)v29 && (UT_hash_table *)v5 == v31[1].tbl && !memcmp((const void *)v31->hashv, name, v5) )
      break;
    keylen = v31->keylen;
    if ( !keylen )
      goto LABEL_21;
    v31 = (UT_hash_handle *)(keylen - v30->hho);
  }
  v55 = (int)v31->prev + 1;
  v31->prev = (void *)v55;
  cgpu->device_id = v55;
LABEL_27:
  if ( pthread_rwlock_wrlock(&devices_lock) )
    wr_lock_0((pthread_rwlock_t *)&_func___15270.__size[16], (const unsigned __int8 *)0x2B86, v56, v57);
  devices = (cgpu_info **)cgrealloc(
                            devices,
                            4 * (total_devices + new_devices + 2),
                            "cgminer.c",
                            &_func___15270.__size[16],
                            11143);
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock_1((pthread_rwlock_t *)&_func___15270.__size[16], (const unsigned __int8 *)0x2B88, v58, v59);
  selective_yield();
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_2((pthread_mutex_t *)(&_func___15270.__align + 4), (const unsigned __int8 *)0x2B8A, v60, v61);
  cgpu->last_device_valid_work = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_2((pthread_mutex_t *)(&_func___15270.__align + 4), (const unsigned __int8 *)0x2B8C, v62, v63);
  selective_yield();
  if ( hotplug_mode )
  {
    v64 = total_devices;
    v65 = new_devices + total_devices;
    ++new_devices;
    devices[v65] = cgpu;
  }
  else
  {
    v64 = total_devices + 1;
    devices[total_devices] = cgpu;
    total_devices = v64;
  }
  v66 = v64 - zombie_devs;
  if ( v66 > most_devices )
    most_devices = v66;
  return 1;
}
// 2A32E: variable 'v62' is possibly undefined
// 2A32E: variable 'v63' is possibly undefined
// 2A33A: variable 'v60' is possibly undefined
// 2A33A: variable 'v61' is possibly undefined
// 2A346: variable 'v58' is possibly undefined
// 2A346: variable 'v59' is possibly undefined
// 2A352: variable 'v56' is possibly undefined
// 2A352: variable 'v57' is possibly undefined

//----- (0002A360) --------------------------------------------------------
device_drv *__fastcall copy_drv(device_drv *drv)
{
  device_drv *v2; // r5
  device_drv *result; // r0

  v2 = (device_drv *)cgmalloc(0x78u, "cgminer.c", &_func___15270.__size[28], 11172);
  cg_memcpy(v2, drv, 0x78u, "cgminer.c", &_func___15270.__size[28], 11173);
  result = v2;
  v2->copy = 1;
  return result;
}

//----- (0002A3A4) --------------------------------------------------------
void setStartTimePoint()
{
  int v0; // r4
  char *v1; // r0
  sysinfo sInfo; // [sp+0h] [bp-158h] BYREF
  unsigned __int8 logstr[256]; // [sp+40h] [bp-118h] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    v0 = *_errno_location();
    v1 = strerror(v0);
    sprintf((char *)logstr, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
    writeInitLogFile(logstr);
    total_tv_start_sys = time(0);
    total_tv_end_sys = total_tv_start_sys + 1;
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
    total_tv_end_sys = sInfo.uptime + 1;
    sprintf(
      (char *)logstr,
      "setStartTimePoint total_tv_start_sys=%d total_tv_end_sys=%d\n",
      sInfo.uptime,
      sInfo.uptime + 1);
    writeInitLogFile(logstr);
  }
}

//----- (0002A41C) --------------------------------------------------------
int64_t __fastcall bitmain_c5_scanhash(thr_info *thr)
{
  pthread_t send_id; // [sp+4h] [bp-14h] BYREF

  h = 0LL;
  pthread_create(&send_id, 0, bitmain_scanhash, thr);
  pthread_join(send_id, 0);
  return h;
}

//----- (0002A454) --------------------------------------------------------
void __fastcall bitmain_c5_reinit_device(cgpu_info *bitmain)
{
  if ( !status_error )
    sub_A11C((const char *)&_func___14527.__size[20]);
}

//----- (0002A46C) --------------------------------------------------------
void __fastcall bitmain_c5_detect(bool hotplug)
{
  cgpu_info *v1; // r0
  cgpu_info *v2; // r4
  _DWORD *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-818h] BYREF

  v1 = (cgpu_info *)calloc(1u, 0x188u);
  v2 = v1;
  if ( !v1 )
    _assert_fail("cgpu", "driver-btm-c5.c", 0x2DF4u, (const char *)_PRETTY_FUNCTION___14401);
  v1->deven = DEV_ENABLED;
  v1->threads = 1;
  v1->drv = &bitmain_c5_drv;
  v3 = calloc(0x1798u, 1u);
  v2->device_data = v3;
  if ( !v3 )
  {
    strcpy((char *)tmp42, "Failed to calloc cgpu_info data");
    applog(3, tmp42, 1);
    quit(1);
  }
  v3[1506] = 0;
  v3[1507] = 1;
  v3[1508] = 2;
  if ( !add_cgpu(v2) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-c5.c", 0x2E00u, (const char *)_PRETTY_FUNCTION___14401);
}

//----- (0002A514) --------------------------------------------------------
void __fastcall block_socket_0(int fd)
{
  unsigned int v2; // r2

  v2 = fcntl(fd, 3, 0) & 0xFFFFF7FF;
  j_fcntl(fd, 4, v2);
}

//----- (0002A530) --------------------------------------------------------
void __fastcall set_nonce2_and_job_id_store_address_0(unsigned int value)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  snprintf(
    (char *)tmp42,
    0x800u,
    "%s: set NONCE2_AND_JOBID_STORE_ADDRESS is 0x%x\n",
    (const char *)_FUNCTION___12561,
    value);
  applog(7, tmp42, 0);
}

//----- (0002A564) --------------------------------------------------------
void __fastcall check_chain_0(int a1, int a2, int a3, const char *a4)
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-808h] BYREF

  snprintf((char *)tmp42, 0x800u, "%s: get_hash_on_plug functions error\n", a4);
  applog(7, tmp42, 0);
}

//----- (0002A590) --------------------------------------------------------
int __fastcall calculate_core_number_0(unsigned int actual_core_number)
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-808h] BYREF

  snprintf((char *)tmp42, 0x800u, "actual_core_number = %d, but it is error\n", actual_core_number);
  applog(7, tmp42, 0);
  return -1;
}

//----- (0002A5C0) --------------------------------------------------------
void *send_mac()
{
  int v0; // r0
  int v1; // r4
  char *v2; // r6
  int i; // r5
  int v4; // t1
  char *v5; // r0
  struct addrinfo *v6; // r4
  int v7; // r0
  int v8; // r0
  int v9; // r5
  int v10; // r0
  int *v11; // r10
  int v12; // r7
  int v13; // r7
  unsigned int j; // r6
  size_t v15; // r0
  _BOOL4 v16; // r4
  unsigned int v17; // r0
  int v18; // r0
  struct addrinfo *v19; // r0
  struct addrinfo *v21; // [sp+4Ch] [bp-C7Ch] BYREF
  socklen_t optlen; // [sp+50h] [bp-C78h] BYREF
  int v23; // [sp+54h] [bp-C74h] BYREF
  struct timeval timeout; // [sp+58h] [bp-C70h] BYREF
  char v25[17]; // [sp+60h] [bp-C68h] BYREF
  char v26; // [sp+71h] [bp-C57h] BYREF
  struct addrinfo v27; // [sp+80h] [bp-C48h] BYREF
  unsigned __int8 s[1024]; // [sp+A0h] [bp-C28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+4A0h] [bp-828h] BYREF

  mac = (unsigned __int8 *)malloc(0x20u);
  v0 = socket(2, 1, 0);
  v1 = v0;
  if ( v0 < 0 )
  {
    perror("error sock");
  }
  else
  {
    strcpy(v25, "eth0");
    if ( ioctl(v0, 0x8927u, v25) < 0 )
    {
      perror("error ioctl");
      close(v1);
    }
    else
    {
      v2 = &v26;
      for ( i = 0; i != 18; i += 3 )
      {
        v4 = (unsigned __int8)*++v2;
        v5 = (char *)&mac[i];
        sprintf(v5, "%02X:", v4);
      }
      mac[strlen((const char *)mac) - 1] = 0;
      close(v1);
    }
  }
  while ( 2 )
  {
    snprintf(
      (char *)s,
      0x400u,
      "{\"ctrl_board\":\"%s\",\"id\":\"%d\",\"hashboard\":[%s]}",
      (const char *)mac,
      ++id_14377,
      (const char *)hash_board_id_string);
    memset(&v27.ai_protocol, 0, 20);
    v27.ai_family = 0;
    v27.ai_flags = 0;
    v27.ai_socktype = 1;
    if ( getaddrinfo("auth.minerlink.com", "7000", &v27, &v21) )
    {
LABEL_32:
      stop_mining = 0;
      goto LABEL_29;
    }
    v6 = v21;
    if ( !v21 )
    {
      v19 = 0;
LABEL_31:
      freeaddrinfo(v19);
      goto LABEL_32;
    }
    while ( 1 )
    {
      v8 = socket(v6->ai_family, v6->ai_socktype, v6->ai_protocol);
      v9 = v8;
      if ( v8 == -1 )
        goto LABEL_13;
      v10 = fcntl(v8, 3, 0, v8 + 1);
      fcntl(v9, 4, v10 | 0x800);
      if ( connect(v9, v6->ai_addr, v6->ai_addrlen) != -1 )
        break;
      timeout.tv_sec = 10;
      timeout.tv_usec = 0;
      v11 = _errno_location();
      if ( *v11 == 115 )
      {
        v12 = (v9 + 31) & (v9 >> 31);
        if ( v9 >= 0 )
          v12 = v9;
        v13 = v12 >> 5;
        for ( j = 0; ; j = 1 )
        {
          while ( j <= 0x1F )
            *(_DWORD *)&tmp42[4 * j++] = 0;
          *(_DWORD *)&tmp42[4 * v13] |= 1 << (v9 % 32);
          v7 = select(v9 + 1, 0, (fd_set *)tmp42, 0, &timeout);
          if ( v7 > 0 )
            break;
          if ( !v7 || *v11 != 4 )
            goto LABEL_12;
          *(_DWORD *)tmp42 = 0;
        }
        if ( ((*(int *)&tmp42[4 * v13] >> (v9 % 32)) & 1) != 0 )
        {
          optlen = 4;
          if ( !getsockopt(v9, 1, 4, &v23, &optlen) && !v23 )
            break;
        }
      }
LABEL_12:
      close(v9);
LABEL_13:
      v6 = v6->ai_next;
      if ( !v6 )
      {
        v19 = v21;
        goto LABEL_31;
      }
    }
    block_socket_0(v9);
    block_socket_0(v9);
    v23 = 10;
    setsockopt(v9, 1, 21, &v23, 4u);
    setsockopt(v9, 1, 20, &v23, 4u);
    v15 = strlen((const char *)s);
    send(v9, s, v15, 0);
    memset(tmp42, 0, 0x400u);
    if ( recv(v9, tmp42, 0x400u, 0) <= 0 )
    {
      freeaddrinfo(v21);
      close(v9);
      stop_mining = 0;
      goto LABEL_29;
    }
    v16 = strstr((const char *)tmp42, "false") != 0;
    freeaddrinfo(v21);
    close(v9);
    stop_mining = v16;
    if ( !v16 )
    {
LABEL_29:
      v17 = time(0);
      srand(v17);
      v18 = rand();
      sleep(v18 % 600 + 60);
      continue;
    }
    break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "Stop mining!!!");
    applog(5, tmp42, 0);
  }
  free(mac);
  return 0;
}

//----- (0002A9BC) --------------------------------------------------------
void __fastcall suffix_string_c5(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display)
{
  double v7; // r0
  double v8; // d8
  double v9; // d0
  double v10; // r0
  unsigned __int8 suffix[2]; // [sp+14h] [bp-34h] BYREF

  *(_WORD *)suffix = 0;
  if ( val > 0x3B9AC9FF )
  {
    v7 = (double)(val / (unsigned int)&cgpu.results[29][3663]);
    strcpy((char *)suffix, "G");
    v8 = v7 / 1000.0;
    goto LABEL_3;
  }
  if ( (unsigned int)&cgpu.results[29][3662] + 3 < val )
  {
    v7 = (double)(val / 0x3E8);
    strcpy((char *)suffix, "M");
    v8 = v7 / 1000.0;
    goto LABEL_3;
  }
  if ( val >= 0x3E8 )
  {
    v7 = (double)val;
    strcpy((char *)suffix, "K");
    v8 = v7 / 1000.0;
LABEL_3:
    if ( !sigdigits )
    {
      snprintf((char *)buf, bufsiz, "%.3g%s", v8, (const char *)suffix);
      return;
    }
    goto LABEL_7;
  }
  v7 = (double)val;
  v8 = v7;
  if ( !sigdigits )
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)v7, (const char *)suffix);
    return;
  }
LABEL_7:
  if ( v8 <= 0.0 )
  {
    v9 = 0.0;
  }
  else
  {
    v9 = v8;
    v10 = log10(v7);
    floor(v10);
  }
  snprintf((char *)buf, bufsiz, "%*.*f", sigdigits + 1, (int)((double)(sigdigits - 1) - v9), v8);
}

//----- (0002AB14) --------------------------------------------------------
int __fastcall get_macBytes(unsigned __int8 *device, unsigned __int8 *mac)
{
  int v3; // r0
  int v4; // r5
  int i; // r3
  ifreq ifreq; // [sp+0h] [bp-30h] BYREF

  v3 = socket(2, 1, 0);
  v4 = v3;
  if ( v3 < 0 )
  {
    perror("error sock");
    return 2;
  }
  else
  {
    strcpy((char *)&ifreq, "eth0");
    if ( ioctl(v3, 0x8927u, &ifreq) < 0 )
    {
      perror("error ioctl");
      close(v4);
      return 3;
    }
    else
    {
      for ( i = 0; i != 6; ++i )
        device[i] = ifreq.ifr_ifru.ifru_addr.sa_data[i];
      close(v4);
      return 0;
    }
  }
}

//----- (0002AB88) --------------------------------------------------------
void __fastcall get_plldata(int type, int freq, unsigned int *reg_data, uint16_t *reg_data2, unsigned int *vil_data)
{
  int v8; // r4
  int v9; // r5
  const unsigned __int8 *v10; // r0
  const unsigned __int8 *v11; // r5
  int v12; // r10
  int v13; // r6
  int v14; // r4
  unsigned __int8 freq_str[10]; // [sp+4h] [bp-8Ch] BYREF
  unsigned __int8 plldivider1[32]; // [sp+10h] [bp-80h] BYREF
  unsigned __int8 plldivider2[32]; // [sp+30h] [bp-60h] BYREF
  unsigned __int8 vildivider[32]; // [sp+50h] [bp-40h] BYREF

  sprintf((char *)freq_str, "%d", type);
  v8 = 0;
  memset(plldivider1, 0, sizeof(plldivider1));
  memset(plldivider2, 0, sizeof(plldivider2));
  memset(vildivider, 0, sizeof(vildivider));
  while ( 1 )
  {
    v9 = 16 * v8;
    v10 = freq_pll_1385[v8++].freq;
    if ( !memcmp(v10, freq_str, 4u) )
      break;
    if ( v8 == 114 )
    {
      v9 = 64;
      break;
    }
  }
  v11 = &_PRETTY_FUNCTION___14401[v9];
  v12 = *((_DWORD *)v11 + 15);
  sprintf((char *)plldivider1, "%08x", v12);
  v13 = *((_DWORD *)v11 + 16);
  sprintf((char *)plldivider2, "%04x", v13);
  v14 = *((_DWORD *)v11 + 17);
  sprintf((char *)vildivider, "%04x", v14);
  *(_DWORD *)freq = v12;
  *(_WORD *)reg_data = v13;
  *(_DWORD *)reg_data2 = v14;
}

//----- (0002AC40) --------------------------------------------------------
void __fastcall copy_pool_stratum(pool *pool_stratum, pool *pool)
{
  int merkles; // r9
  unsigned int coinbase_len; // r7
  cglock_t *p_data_lock; // r5
  const unsigned __int8 *v7; // r2
  int v8; // r3
  unsigned __int8 *v9; // r0
  int v10; // r7
  unsigned __int8 *v11; // r0
  int nonce2_offset; // r1
  unsigned int n2size; // r2
  double sdiff; // d7
  unsigned int v15; // r7
  int v16; // r3
  unsigned __int8 *v17; // r0
  int v18; // lr
  int v19; // r3
  unsigned __int8 *header_bin; // r1
  int v21; // r4
  const unsigned __int8 *v22; // r2
  int v23; // r3
  const unsigned __int8 *v24; // r2
  int v25; // r3
  unsigned __int8 **merkle_bin; // r11
  int v27; // r7
  unsigned __int8 *v28; // r2
  int v29; // lr
  int v30; // r0
  int v31; // r1
  int v32; // lr
  int v33; // r0
  int v34; // r1
  int v35; // r10
  unsigned __int8 *v36; // r3
  int *v37; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-828h] BYREF

  merkles = pool->merkles;
  coinbase_len = pool->coinbase_len;
  if ( pool->swork.job_id )
  {
    p_data_lock = &pool_stratum->data_lock;
    if ( pthread_mutex_lock(&pool_stratum->data_lock.mutex) )
      mutex_lock_3((pthread_mutex_t *)&_func___14299, (const unsigned __int8 *)0x2CC2, v7, v8);
    if ( pthread_rwlock_wrlock(&pool_stratum->data_lock.rwlock) )
    {
      v37 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v37,
        "driver-btm-c5.c",
        (const char *)&_func___14299,
        11458);
      applog(3, tmp42, 1);
      quit(1);
    }
    free(pool_stratum->swork.job_id);
    free(pool_stratum->nonce1);
    free(pool_stratum->coinbase);
    if ( coinbase_len << 30 )
      coinbase_len = (coinbase_len & 0xFFFFFFFC) + 4;
    v9 = (unsigned __int8 *)calloc(coinbase_len, 1u);
    pool_stratum->coinbase = v9;
    if ( !v9 )
    {
      strcpy((char *)tmp42, "Failed to calloc pool_stratum coinbase in c5");
      applog(3, tmp42, 1);
      quit(1);
    }
    memcpy(v9, pool->coinbase, coinbase_len);
    if ( pool_stratum->merkles > 0 )
    {
      v10 = 0;
      do
      {
        v11 = pool_stratum->swork.merkle_bin[v10++];
        free(v11);
      }
      while ( pool_stratum->merkles > v10 );
    }
    if ( merkles )
    {
      merkle_bin = (unsigned __int8 **)realloc(pool_stratum->swork.merkle_bin, 4 * merkles + 1);
      pool_stratum->swork.merkle_bin = merkle_bin;
      if ( merkles > 0 )
      {
        v27 = 0;
        while ( 1 )
        {
          v35 = v27;
          merkle_bin[v27] = (unsigned __int8 *)malloc(0x20u);
          v36 = pool_stratum->swork.merkle_bin[v27];
          if ( !v36 )
          {
            strcpy((char *)tmp42, "Failed to malloc pool_stratum swork merkle_bin");
            applog(3, tmp42, 1);
            quit(1);
          }
          ++v27;
          v28 = pool->swork.merkle_bin[v35];
          v29 = *((_DWORD *)v28 + 1);
          v30 = *((_DWORD *)v28 + 2);
          v31 = *((_DWORD *)v28 + 3);
          *(_DWORD *)v36 = *(_DWORD *)v28;
          *((_DWORD *)v36 + 1) = v29;
          *((_DWORD *)v36 + 2) = v30;
          *((_DWORD *)v36 + 3) = v31;
          v32 = *((_DWORD *)v28 + 5);
          v33 = *((_DWORD *)v28 + 6);
          v34 = *((_DWORD *)v28 + 7);
          *((_DWORD *)v36 + 4) = *((_DWORD *)v28 + 4);
          *((_DWORD *)v36 + 5) = v32;
          *((_DWORD *)v36 + 6) = v33;
          *((_DWORD *)v36 + 7) = v34;
          if ( v27 == merkles )
            break;
          merkle_bin = pool_stratum->swork.merkle_bin;
        }
      }
    }
    nonce2_offset = pool->nonce2_offset;
    n2size = pool->n2size;
    sdiff = pool->sdiff;
    v15 = pool->coinbase_len;
    pool_stratum->pool_no = pool->pool_no;
    v16 = pool->merkles;
    pool_stratum->sdiff = sdiff;
    pool_stratum->nonce2_offset = nonce2_offset;
    pool_stratum->n2size = n2size;
    pool_stratum->merkles = v16;
    pool_stratum->coinbase_len = v15;
    pool_stratum->swork.job_id = (unsigned __int8 *)_strdup((const char *)pool->swork.job_id);
    v17 = (unsigned __int8 *)_strdup((const char *)pool->nonce1);
    v18 = *(_DWORD *)pool->ntime;
    v19 = *(_DWORD *)&pool->ntime[8];
    header_bin = pool->header_bin;
    v21 = *(_DWORD *)&pool->ntime[4];
    pool_stratum->nonce1 = v17;
    *(_DWORD *)pool_stratum->ntime = v18;
    *(_DWORD *)&pool_stratum->ntime[4] = v21;
    *(_DWORD *)&pool_stratum->ntime[8] = v19;
    memcpy(pool_stratum->header_bin, header_bin, sizeof(pool_stratum->header_bin));
    if ( pthread_rwlock_unlock(&pool_stratum->data_lock.rwlock) )
      rw_unlock_2((pthread_rwlock_t *)&_func___14299, (const unsigned __int8 *)0x2CE8, v22, v23);
    if ( pthread_mutex_unlock(&p_data_lock->mutex) )
      mutex_unlock_noyield_3((pthread_mutex_t *)&_func___14299, (const unsigned __int8 *)0x2CE8, v24, v25);
    selective_yield();
  }
}
// 2AEBC: variable 'v7' is possibly undefined
// 2AEBC: variable 'v8' is possibly undefined
// 2AEC8: variable 'v24' is possibly undefined
// 2AEC8: variable 'v25' is possibly undefined
// 2AED4: variable 'v22' is possibly undefined
// 2AED4: variable 'v23' is possibly undefined

//----- (0002AEF4) --------------------------------------------------------
void *__fastcall bitmain_scanhash(void *arg)
{
  bitmain_c5_info *v1; // r1
  const unsigned __int8 *v2; // r2
  int v3; // r3
  const unsigned __int8 *v4; // r2
  int v5; // r3
  int v6; // r3
  unsigned int nonce3; // r10
  unsigned int job_id; // r4
  unsigned int *v9; // r2
  unsigned int v10; // r7
  unsigned int v11; // r6
  unsigned int v12; // r12
  unsigned int v13; // r5
  unsigned int p_rd; // r3
  _BOOL4 v15; // r2
  unsigned int v16; // r3
  const unsigned __int8 *v17; // r2
  int v18; // r3
  void *result; // r0
  uint64_t v20; // r4
  __int64 v21; // r2
  unsigned int v22; // r3
  pool *p_pool0; // r2
  unsigned __int64 v24; // r6
  unsigned __int64 v25; // r2
  __int64 i; // r0
  __int64 v27; // r2
  unsigned __int64 v28; // r6
  unsigned __int64 v29; // r2
  __int64 j; // r0
  __int64 v31; // r2
  unsigned int v32; // r1
  unsigned int v33; // r2
  unsigned int v34; // r3
  unsigned int v35; // r1
  unsigned int v36; // r2
  unsigned int v37; // r3
  unsigned int v38; // t1
  unsigned int v39; // r1
  unsigned int v40; // r2
  int v41; // r7
  int v42; // r1
  __int64 v43; // r6
  int *v44; // r3
  unsigned int v45; // t1
  unsigned __int64 v46; // r2
  char v47; // r6
  all_parameters *v48; // r2
  unsigned int v49; // r5
  char *v50; // r1
  int *v51; // r0
  unsigned int work_id; // [sp+1Ch] [bp-984h]
  unsigned int chain_id; // [sp+20h] [bp-980h]
  double sdiff; // [sp+28h] [bp-978h]
  __int64 v55; // [sp+30h] [bp-970h]
  work *v56; // [sp+38h] [bp-968h]
  bitmain_c5_info *info; // [sp+3Ch] [bp-964h]
  work *work; // [sp+4Ch] [bp-954h] BYREF
  unsigned __int8 output[4]; // [sp+50h] [bp-950h] BYREF
  unsigned int v61; // [sp+54h] [bp-94Ch]
  unsigned int v62; // [sp+58h] [bp-948h]
  unsigned int v63; // [sp+68h] [bp-938h]
  int v64; // [sp+6Ch] [bp-934h] BYREF
  unsigned __int8 v65[32]; // [sp+70h] [bp-930h] BYREF
  sha2_context ctx; // [sp+90h] [bp-910h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+178h] [bp-828h] BYREF

  v1 = *(bitmain_c5_info **)(*((_DWORD *)arg + 9) + 20);
  h = 0LL;
  info = v1;
  pthread_mutex_lock(&nonce_mutex);
  if ( pthread_mutex_lock(&info->update_lock.mutex) )
    mutex_lock_3((pthread_mutex_t *)&_func___14299.__size[20], (const unsigned __int8 *)0x2E94, v2, v3);
  if ( pthread_rwlock_rdlock(&info->update_lock.rwlock) )
  {
    v51 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v51,
      "driver-btm-c5.c",
      (const char *)&_func___14299.__size[20],
      11924);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(&info->update_lock.mutex) )
    mutex_unlock_noyield_3((pthread_mutex_t *)&_func___14299.__size[20], (const unsigned __int8 *)0x2E94, v4, v5);
LABEL_4:
  while ( nonce_read_out.nonce_num )
  {
    while ( 1 )
    {
      v6 = 0;
      nonce3 = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce3;
      job_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].job_id;
      v9 = &nonce_read_out.p_wr + 15 * nonce_read_out.p_rd;
      v10 = v9[6];
      v11 = v9[7];
      chain_id = v9[9];
      v12 = v9[4];
      v13 = HIBYTE(v9[5]) | (v9[5] << 24) | ((v9[5] & 0xFF0000) >> 8) | ((v9[5] & 0xFF00) << 8);
      do
        ++v6;
      while ( v6 != 32 );
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        work_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].work_id;
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: job_id:0x%x   work_id:0x%x   nonce2:0x%llx   nonce3:0x%x   version:0x%x\n",
          (const char *)_FUNCTION___14492,
          job_id,
          v12,
          __PAIR64__(v11, v10),
          nonce3,
          v13);
        applog(7, tmp42, 0);
        v12 = work_id;
      }
      if ( nonce_read_out.p_rd > 0x1FE )
        p_rd = 0;
      else
        p_rd = nonce_read_out.p_rd;
      if ( nonce_read_out.p_rd <= 0x1FE )
        ++p_rd;
      nonce_read_out.p_rd = p_rd;
      --nonce_read_out.nonce_num;
      if ( nonce3 == last_nonce3_14475 && v12 == last_workid_14476 )
        goto LABEL_31;
      last_nonce3_14475 = nonce3;
      last_workid_14476 = v12;
      v15 = opt_debug;
      if ( opt_debug )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 6 )
        {
          snprintf((char *)tmp42, 0x800u, "%s: Chain ID J%d ...\n", (const char *)_FUNCTION___14492, chain_id + 1);
          applog(7, tmp42, 0);
          v15 = opt_debug;
        }
        else
        {
          v15 = 1;
        }
      }
      v16 = given_id;
      if ( job_id < given_id - 2 && job_id > given_id )
      {
        if ( !v15 || !use_syslog && !opt_log_output && opt_log_level <= 6 )
          goto LABEL_31;
        snprintf((char *)tmp42, 0x800u, "%s: job_id error ...\n", _FUNCTION___14492);
        goto LABEL_30;
      }
      if ( v15 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: given_id:%d job_id:%d switch:%d  ...\n",
          (const char *)_FUNCTION___14492,
          given_id,
          job_id,
          given_id - job_id);
        applog(7, tmp42, 0);
        v16 = given_id;
      }
      v22 = v16 - job_id;
      if ( v22 == 1 )
        break;
      if ( !v22 )
      {
        p_pool0 = &info->pool0;
        goto LABEL_48;
      }
      if ( v22 == 2 )
      {
        p_pool0 = &info->pool2;
        goto LABEL_48;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s: job_id non't found ...\n", _FUNCTION___14492);
LABEL_30:
        applog(7, tmp42, 0);
      }
LABEL_31:
      if ( dev->chain_exist[chain_id] != 1 )
        goto LABEL_4;
      inc_hw_errors((thr_info *)arg);
      ++dev->chain_hw[chain_id];
      if ( !nonce_read_out.nonce_num )
        goto LABEL_33;
    }
    p_pool0 = &info->pool1;
LABEL_48:
    get_work_by_nonce2(
      (thr_info *)arg,
      &work,
      p_pool0,
      pools[p_pool0->pool_no],
      __PAIR64__(v11, v10),
      (unsigned int)p_pool0->ntime,
      v13);
    v56 = work;
    sdiff = work->sdiff;
    v24 = (unsigned __int64)sdiff;
    if ( (unsigned __int64)sdiff != pool_diff_14430 )
    {
      pool_diff_14430 = (unsigned __int64)sdiff;
      if ( v24 )
      {
        v25 = (unsigned __int64)sdiff;
        for ( i = 1LL; ; ++i )
        {
          v25 >>= 1;
          if ( !v25 )
            break;
        }
        v27 = i - 1;
      }
      else
      {
        v27 = -1LL;
      }
      *(_QWORD *)&pool_diff_bit_14432 = v27;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: pool_diff:%d work_diff:%d pool_diff_bit:%d ...\n",
          "hashtest_submit",
          (_DWORD)v24,
          HIDWORD(v24),
          LODWORD(sdiff));
        applog(7, tmp42, 0);
      }
    }
    v28 = (unsigned __int64)current_diff;
    if ( (unsigned __int64)current_diff != net_diff_14431 )
    {
      net_diff_14431 = (unsigned __int64)current_diff;
      if ( v28 )
      {
        v29 = (unsigned __int64)current_diff;
        for ( j = 1LL; ; ++j )
        {
          v29 >>= 1;
          if ( !v29 )
            break;
        }
        v31 = j - 1;
      }
      else
      {
        v31 = -1LL;
      }
      net_diff_bit_14433 = v31;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s:net_diff:%d current_diff:%d net_diff_bit %d ...\n",
          "hashtest_submit",
          (_DWORD)v28,
          HIDWORD(v28),
          LODWORD(current_diff));
        applog(7, tmp42, 0);
      }
    }
    v32 = *(_DWORD *)&v56->midstate[4];
    v33 = *(_DWORD *)&v56->midstate[8];
    v34 = *(_DWORD *)&v56->midstate[12];
    ctx.state[0] = *(_DWORD *)v56->midstate;
    ctx.state[1] = v32;
    ctx.state[2] = v33;
    ctx.state[3] = v34;
    v35 = *(_DWORD *)&v56->midstate[20];
    v36 = *(_DWORD *)&v56->midstate[24];
    v37 = *(_DWORD *)&v56->midstate[28];
    ctx.state[4] = *(_DWORD *)&v56->midstate[16];
    ctx.state[5] = v35;
    ctx.state[6] = v36;
    ctx.state[7] = v37;
    v38 = *(_DWORD *)&v56->data[64];
    ctx.total[0] = 80;
    v39 = *(_DWORD *)&v56->data[68];
    v40 = *(_DWORD *)&v56->data[72];
    v41 = 0;
    *(_DWORD *)&ctx.buffer[12] = bswap32(nonce3);
    ctx.total[1] = 0;
    v61 = v39;
    v62 = v40;
    *(_DWORD *)output = nonce3;
    *(_DWORD *)ctx.buffer = bswap32(v38);
    *(_DWORD *)&ctx.buffer[4] = bswap32(v39);
    *(_DWORD *)&ctx.buffer[8] = bswap32(v40);
    sha2_finish(&ctx, output);
    memset(&ctx, 0, sizeof(ctx));
    sha2(output, 32, v65);
    do
    {
      *(_DWORD *)&output[v41] = bswap32(*(_DWORD *)&v65[v41]);
      v41 += 4;
    }
    while ( v41 != 32 );
    v42 = v64;
    if ( v64 )
    {
      if ( dev->chain_exist[chain_id] == 1 )
      {
        inc_hw_errors((thr_info *)arg);
        ++dev->chain_hw[chain_id];
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s: HASH2_32[7] != 0", "hashtest_submit");
        applog(7, tmp42, 0);
      }
      goto LABEL_77;
    }
    v44 = &v64;
    while ( 1 )
    {
      v45 = *--v44;
      if ( bswap32(v45) )
        break;
      if ( ++v42 == 7 )
      {
        v46 = 7LL;
        goto LABEL_88;
      }
    }
    v46 = v42;
LABEL_88:
    v47 = pool_diff_bit_14432;
    v55 = *(_QWORD *)&pool_diff_bit_14432 >> 5;
    if ( v46 < *(_QWORD *)&pool_diff_bit_14432 >> 5 )
    {
LABEL_77:
      v43 = 0LL;
    }
    else
    {
      v48 = dev;
      v49 = nonce3 >> (dev->check_bit + 24);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        v49 = (unsigned __int8)v49;
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: chain %d which_asic_nonce %d which_core_nonce %d",
          "hashtest_submit",
          chain_id,
          (unsigned __int8)v49,
          nonce3 & 0x7F);
        applog(5, tmp42, 0);
        v47 = pool_diff_bit_14432;
        v48 = dev;
        v55 = *(_QWORD *)&pool_diff_bit_14432 >> 5;
      }
      else
      {
        v49 = (unsigned __int8)v49;
      }
      v50 = (char *)&v48->chain_hw[128 * chain_id + 15 + 2 * v49] + 2;
      ++*(_QWORD *)(v50 + 2);
      if ( bswap32(*(&v63 - v55)) >= 0xFFFFFFFF >> (v47 & 0x1F) )
      {
        if ( bswap32(v63) > 0xFFFFFE )
          goto LABEL_77;
        v43 = 256LL;
      }
      else
      {
        v43 = 256LL;
        submit_nonce((thr_info *)arg, v56, nonce3);
      }
    }
    h += v43;
    free_work(&work, "driver-btm-c5.c", &_func___14299.__size[20], 12011);
  }
LABEL_33:
  if ( pthread_rwlock_unlock(&info->update_lock.rwlock) )
    rw_unlock_2((pthread_rwlock_t *)(&_func___14299.__align + 5), (const unsigned __int8 *)0x2EED, v17, v18);
  selective_yield();
  pthread_mutex_unlock(&nonce_mutex);
  cgsleep_ms(1);
  v20 = h;
  if ( h && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: hashes %u ...\n", (const char *)_FUNCTION___14492, -(int)h);
    applog(7, tmp42, 0);
    v20 = h;
  }
  v21 = 0xFFFFFFFFLL * (unsigned int)v20;
  HIDWORD(v21) -= HIDWORD(v20);
  h = v21;
  return result;
}
// 2B750: variable 'v2' is possibly undefined
// 2B750: variable 'v3' is possibly undefined
// 2B75E: variable 'v17' is possibly undefined
// 2B75E: variable 'v18' is possibly undefined
// 2B76A: variable 'v4' is possibly undefined
// 2B76A: variable 'v5' is possibly undefined
// 6E6B70: using guessed type __int64 pool_diff_14430;
// 6E6B78: using guessed type int pool_diff_bit_14432;
// 6E6B80: using guessed type __int64 net_diff_14431;

//----- (0002B7C8) --------------------------------------------------------
char __fastcall getMeddleOffsetForTestPatten(int chainIndex)
{
  return *((_BYTE *)&h + 8 * chainIndex + 80);
}

//----- (0002B7DC) --------------------------------------------------------
bool isFixedFreqMode()
{
  return opt_fixed_freq;
}

//----- (0002B7EC) --------------------------------------------------------
bool isC5_Board()
{
  FILE *v0; // r0
  FILE *v1; // r5
  _BOOL4 result; // r0
  unsigned __int8 board_type[32]; // [sp+0h] [bp-30h] BYREF

  memset(board_type, 0, sizeof(board_type));
  v0 = fopen("/usr/bin/ctrl_bd", "rb");
  v1 = v0;
  result = 1;
  if ( v0 )
  {
    fread(board_type, 1u, 0x20u, v0);
    fclose(v1);
    if ( strstr((const char *)board_type, "XILINX") )
      return 0;
  }
  return result;
}

//----- (0002B840) --------------------------------------------------------
uint16_t __fastcall CRC16(const unsigned __int8 *p_data, uint16_t w_len)
{
  int v2; // r3
  int v3; // r1
  int v4; // r4
  int v5; // t1
  const unsigned __int8 *v6; // r2

  LOWORD(v2) = w_len - 1;
  if ( !w_len )
    return -1;
  v3 = 255;
  v4 = 255;
  do
  {
    v5 = *p_data++;
    v2 = (unsigned __int16)(v2 - 1);
    v6 = &_PRETTY_FUNCTION___14401[v5 ^ v3];
    v3 = v4 ^ v6[1976];
    v4 = v6[2232];
  }
  while ( v2 != 0xFFFF );
  return v3 | ((_WORD)v4 << 8);
}

//----- (0002B880) --------------------------------------------------------
unsigned __int8 __fastcall CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  int v2; // r6
  int v3; // r3
  char v4; // r8
  int v5; // r9
  int v6; // r7
  char v7; // r12
  int v8; // r4
  unsigned int v9; // r2
  int v10; // r11
  unsigned int v11; // r5
  int v12; // r5
  int v13; // r10
  int v14; // r3
  unsigned __int8 result; // r0

  if ( !len )
  {
    v12 = 1;
    v2 = 1;
    v13 = 1;
    v14 = 1;
LABEL_21:
    result = 16;
    goto LABEL_11;
  }
  v2 = 1;
  LOBYTE(v3) = 0;
  v4 = 1;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  LOBYTE(v8) = 0;
  v9 = 128;
  while ( 1 )
  {
    v3 = (unsigned __int8)(v3 + 1);
    v8 = (unsigned __int8)(v8 + 1);
    v10 = v5;
    v11 = *ptr & v9;
    v9 >>= 1;
    if ( v11 )
      LOBYTE(v12) = v7 ^ 1;
    else
      LOBYTE(v12) = v7;
    v12 = (unsigned __int8)v12;
    if ( v3 == 8 )
    {
      ++ptr;
      LOBYTE(v3) = 0;
      v9 = 128;
    }
    v13 = (unsigned __int8)(v4 ^ v12);
    v7 = v6;
    v4 = v2;
    if ( v8 == len )
      break;
    v2 = (unsigned __int8)v12;
    v5 = v13;
    v6 = v10;
  }
  v14 = v5;
  result = v6;
  if ( v6 )
    goto LABEL_21;
LABEL_11:
  if ( v14 )
    result |= 8u;
  if ( v13 )
    result |= 4u;
  if ( v2 )
    result |= 2u;
  if ( v12 )
    result |= 1u;
  return result;
}

//----- (0002B914) --------------------------------------------------------
unsigned __int8 __fastcall getPICvoltageFromValue(int vol_value)
{
  return (unsigned int)(364.0704 / ((double)vol_value * 4.75 / 100.0 - 32.79) - 30.72);
}

//----- (0002B970) --------------------------------------------------------
int __fastcall getVolValueFromPICvoltage(unsigned __int8 vol_pic)
{
  return 10 * ((int)((364.0704 / ((double)vol_pic + 30.72) + 32.79) * 100.0 / 4.75) / 10);
}

//----- (0002B9E8) --------------------------------------------------------
int __fastcall getVoltageLimitedFromHashrate(int hashrate_GHz)
{
  if ( hashrate_GHz > 11999 )
    return 810;
  if ( hashrate_GHz > 11499 )
    return 830;
  if ( hashrate_GHz > 10999 )
    return 850;
  if ( hashrate_GHz > 10499 )
    return 870;
  if ( hashrate_GHz > 9999 )
    return 890;
  if ( hashrate_GHz > 9499 )
    return 920;
  return 930;
}

//----- (0002BA44) --------------------------------------------------------
int __fastcall getFixedFreqVoltageValue(int freq)
{
  if ( freq > 649 )
    return 810;
  if ( freq > 624 )
    return 830;
  if ( freq >= 600 )
    return 850;
  if ( freq > 574 )
    return 870;
  if ( freq > 542 )
    return 890;
  if ( freq >= 516 )
    return 920;
  return 930;
}

//----- (0002BA98) --------------------------------------------------------
void __fastcall getPICChainIndexOffset(int chainIndex, int *pChain, int *pOffset)
{
  unsigned int v3; // r0
  const unsigned __int8 *v4; // r3
  int v5; // r4
  const unsigned __int8 *v6; // r0

  v3 = chainIndex - 1;
  if ( v3 <= 0xC )
    v4 = _PRETTY_FUNCTION___14401;
  else
    v4 = 0;
  if ( v3 <= 0xC )
  {
    v6 = &v4[4 * v3];
    v5 = *((_DWORD *)v6 + 622);
    v4 = (const unsigned __int8 *)*((_DWORD *)v6 + 635);
  }
  else
  {
    v5 = (int)v4;
  }
  *pChain = v5;
  *pOffset = (int)v4;
}

//----- (0002BAC0) --------------------------------------------------------
int __fastcall getChainAsicFreqIndex(int chainIndex, int asicIndex)
{
  int v2; // r2
  const unsigned __int8 *v3; // r3
  unsigned int v4; // r0
  bool v5; // cc
  int v6; // r2

  v3 = (const unsigned __int8 *)fpga_version;
  if ( fpga_version <= 13 )
    return *((unsigned __int8 *)&h + 384 * (chainIndex / 3) + 31 * (chainIndex % 3) + asicIndex + 223);
  v4 = chainIndex - 1;
  v5 = v4 > 0xC;
  if ( v4 > 0xC )
  {
    v4 = 0;
    v2 = 11;
  }
  else
  {
    v3 = _PRETTY_FUNCTION___14401;
  }
  if ( !v5 )
    v4 = (unsigned int)&v3[4 * v4];
  if ( !v5 )
  {
    v6 = *(_DWORD *)(v4 + 0x9EC);
    v4 = *(_DWORD *)(v4 + 0x9B8);
    v2 = 31 * v6;
  }
  if ( !v5 )
    v2 += 11;
  return *((unsigned __int8 *)&h + 128 * v4 + v2 + asicIndex + 212);
}
// 2BAF0: variable 'v2' is possibly undefined

//----- (0002BB34) --------------------------------------------------------
unsigned int get_pic_iic()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[12];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: IIC_COMMAND is 0x%x\n", (const char *)_FUNCTION___12110, axi_fpga_addr[12]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002BB9C) --------------------------------------------------------
unsigned __int8 __fastcall set_pic_iic(unsigned int data)
{
  unsigned int v1; // r0
  _BOOL4 v2; // r3
  int pic_iic; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-818h] BYREF

  v1 = data & 0x7FFFFFFF;
  v2 = opt_debug;
  axi_fpga_addr[12] = v1;
  if ( v2 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set IIC_COMMAND is 0x%x\n", (const char *)_FUNCTION___12117, v1);
    applog(7, tmp42, 0);
  }
  while ( 1 )
  {
    pic_iic = get_pic_iic();
    if ( pic_iic < 0 )
      break;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: waiting write pic iic\n", _FUNCTION___12117);
      applog(7, tmp42, 0);
    }
    cgsleep_us(1000LL);
  }
  return pic_iic;
}

//----- (0002BC5C) --------------------------------------------------------
unsigned __int8 __fastcall write_pic_iic(
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 chain,
        unsigned __int8 data)
{
  int v5; // r0

  if ( read )
    v5 = 0x2000000;
  else
    v5 = 0;
  if ( reg_addr_valid )
    v5 |= (reg_addr << 8) | 0x1000000;
  return set_pic_iic(v5 | data | 0x400000 | ((chain & 0xF) << 16));
}

//----- (0002BC8C) --------------------------------------------------------
void __fastcall send_pic_command(unsigned __int8 chain)
{
  write_pic_iic(0, 0, 0, chain, 0x55u);
  write_pic_iic(0, 0, 0, chain, 0xAAu);
}

//----- (0002BCB8) --------------------------------------------------------
void __fastcall send_data_to_pic_iic(
        unsigned __int8 chain,
        unsigned __int8 command,
        unsigned __int8 *buf,
        unsigned __int8 length)
{
  int v5; // r7
  int v7; // r4
  unsigned __int8 data; // r5

  v5 = length;
  write_pic_iic(0, 0, 0, chain, command);
  if ( v5 )
  {
    v7 = 0;
    do
    {
      data = buf[v7++];
      write_pic_iic(0, 0, 0, chain, data);
    }
    while ( v7 < v5 );
  }
}

//----- (0002BCF4) --------------------------------------------------------
void __fastcall get_data_from_pic_iic(
        unsigned __int8 chain,
        unsigned __int8 command,
        unsigned __int8 *buf,
        unsigned __int8 length)
{
  int v5; // r6
  int v7; // r4

  v5 = length;
  write_pic_iic(0, 0, 0, chain, command);
  if ( v5 )
  {
    v7 = 0;
    do
      buf[v7++] = write_pic_iic(1, 0, 0, chain, 0);
    while ( v7 < v5 );
  }
}

//----- (0002BD34) --------------------------------------------------------
void __fastcall send_data_to_pic_flash(unsigned __int8 chain, unsigned __int8 *buf)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 2u, buf, 0x10u);
}

//----- (0002BD50) --------------------------------------------------------
void __fastcall get_data_from_pic_flash(unsigned __int8 chain, unsigned __int8 *buf)
{
  send_pic_command(chain);
  get_data_from_pic_iic(chain, 3u, buf, 0x10u);
}

//----- (0002BD6C) --------------------------------------------------------
unsigned __int8 __fastcall erase_pic_flash(unsigned __int8 chain)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 4u);
  usleep(0x186A0u);
  return 0;
}

//----- (0002BD98) --------------------------------------------------------
void __fastcall set_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x22u, value, 8u);
  cgsleep_ms(100000);
}

//----- (0002BDC0) --------------------------------------------------------
unsigned __int8 __fastcall write_data_into_pic_flash(unsigned __int8 chain)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 5u);
  usleep(0x186A0u);
  return 0;
}

//----- (0002BDEC) --------------------------------------------------------
void __fastcall get_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 *addr_H, unsigned __int8 *addr_L)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 8u);
  *addr_H = write_pic_iic(1, 0, 0, chain, 0);
  *addr_L = write_pic_iic(1, 0, 0, chain, 0);
}

//----- (0002BE30) --------------------------------------------------------
unsigned __int8 __fastcall getHighestVoltagePIC(int chainIndex)
{
  unsigned int v1; // r0
  unsigned int v2; // r1
  unsigned __int8 *v3; // r3
  unsigned int v4; // r2
  unsigned int v5; // r3
  int v6; // r0

  if ( fpga_version <= 13 )
  {
    v2 = *((unsigned __int8 *)&bitmain_c5_drv + chainIndex + 124);
    v3 = (unsigned __int8 *)&bitmain_c5_drv + 3 * (chainIndex / 3);
    v1 = v3[124];
    v4 = v3[125];
    v5 = v3[126];
    if ( v1 >= v2 )
      v1 = v2;
    if ( v1 >= v4 )
      v1 = v4;
    if ( v1 >= v5 )
      LOBYTE(v1) = v5;
  }
  else
  {
    if ( (unsigned int)chainIndex > 0xD )
    {
LABEL_3:
      LOBYTE(v1) = 0;
      return v1;
    }
    v6 = 1 << chainIndex;
    if ( (v6 & 0x3008) != 0 )
    {
      v1 = chain_voltage_pic[12];
      if ( chain_voltage_pic[12] >= (unsigned int)chain_voltage_pic[3] )
        v1 = chain_voltage_pic[3];
      if ( v1 >= chain_voltage_pic[13] )
        LOBYTE(v1) = chain_voltage_pic[13];
    }
    else if ( (v6 & 0xC04) != 0 )
    {
      v1 = chain_voltage_pic[10];
      if ( chain_voltage_pic[10] >= (unsigned int)chain_voltage_pic[2] )
        v1 = chain_voltage_pic[2];
      if ( v1 >= chain_voltage_pic[11] )
        LOBYTE(v1) = chain_voltage_pic[11];
    }
    else
    {
      if ( (v6 & 0x302) == 0 )
        goto LABEL_3;
      v1 = chain_voltage_pic[8];
      if ( chain_voltage_pic[8] >= (unsigned int)chain_voltage_pic[1] )
        v1 = chain_voltage_pic[1];
      if ( v1 >= chain_voltage_pic[9] )
        LOBYTE(v1) = chain_voltage_pic[9];
    }
  }
  return v1;
}

//----- (0002BEFC) --------------------------------------------------------
void __fastcall set_voltage_setting_time(unsigned __int8 chain, unsigned __int8 *time)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x11u, time, 6u);
  cgsleep_us((unsigned int)&loc_186A0);
}

//----- (0002BF24) --------------------------------------------------------
void __fastcall set_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x12u, id, 0xCu);
  cgsleep_us((unsigned int)&loc_186A0);
}

//----- (0002BF4C) --------------------------------------------------------
void __fastcall write_host_MAC_and_time(unsigned __int8 chain, unsigned __int8 *buf)
{
  send_pic_command(chain);
  send_data_to_pic_iic(chain, 0x14u, buf, 0xCu);
  cgsleep_us((unsigned int)&loc_186A0);
}

//----- (0002BF74) --------------------------------------------------------
void __fastcall enable_pic_dc_dc(unsigned __int8 chain)
{
  send_pic_command(chain);
  write_pic_iic(0, 0, 0, chain, 0x15u);
  write_pic_iic(0, 0, 0, chain, 1u);
}

//----- (0002BFA4) --------------------------------------------------------
void enable_pic_dc_dc_all()
{
  int i; // r4
  unsigned __int8 v1; // r0

  for ( i = 0; i != 16; ++i )
  {
    while ( dev->chain_exist[i] != 1 )
    {
      if ( ++i == 16 )
        return;
    }
    v1 = i;
    enable_pic_dc_dc(v1);
    cgsleep_ms(1);
  }
}

//----- (0002BFD8) --------------------------------------------------------
int __fastcall getChainPICMagicNumber(int chainIndex)
{
  int v1; // r2
  const unsigned __int8 *v2; // r3
  unsigned int v3; // r0
  bool v4; // cc

  v2 = (const unsigned __int8 *)fpga_version;
  if ( fpga_version <= 13 )
    return *((unsigned __int8 *)&h + 384 * (chainIndex / 3) + 212);
  v3 = chainIndex - 1;
  v4 = v3 > 0xC;
  if ( v3 > 0xC )
    v1 = 0;
  else
    v2 = _PRETTY_FUNCTION___14401;
  if ( v3 <= 0xC )
    v3 = (unsigned int)&v2[4 * v3];
  if ( !v4 )
    v1 = *(_DWORD *)(v3 + 2488);
  return *((unsigned __int8 *)&h + 128 * v1 + 212);
}
// 2BFF6: variable 'v1' is possibly undefined

//----- (0002C02C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
api_data *__fastcall bitmain_api_stats(cgpu_info *cgpu)
{
  double v1; // d0
  int v2; // r4
  api_data *v3; // r0
  api_data *v4; // r0
  api_data *v5; // r7
  unsigned int **v6; // r2
  api_data *v7; // r0
  int v8; // r4
  api_data *v9; // r7
  int v10; // lr
  int i; // r4
  api_data *v12; // r0
  int j; // r4
  api_data *v14; // r0
  int v15; // r10
  int *v16; // r11
  int v17; // r4
  int v18; // r6
  unsigned int v19; // r8
  int v20; // r1
  int v21; // r3
  int v22; // r2
  int v23; // r3
  int v24; // r0
  int v25; // r2
  api_data *v26; // r0
  double v27; // d7
  int *v28; // r10
  int v29; // r6
  int (*v30)[256]; // r11
  all_parameters *v31; // r4
  unsigned __int8 (*v32)[128]; // lr
  int v33; // r8
  int *v34; // r3
  int (*v35)[256]; // r10
  int *v36; // r11
  int v37; // r4
  int v38; // r0
  int v39; // r2
  const unsigned __int8 *v40; // r0
  int v41; // r0
  int v42; // r2
  double v43; // d7
  int *v44; // r3
  int v45; // r10
  int v46; // r4
  int *v47; // r8
  int *v48; // r11
  all_parameters *v49; // r6
  int v50; // r3
  unsigned int v51; // r7
  int v52; // r10
  int v53; // r6
  int v54; // r3
  int v55; // r2
  int v56; // r3
  int v57; // r0
  int (*v58)[256]; // r8
  api_data *v59; // r10
  int16_t v60; // r6
  int v61; // r3
  all_parameters *v62; // r4
  char *v63; // r2
  bool v64; // zf
  int v65; // r4
  api_data *v66; // r6
  const char *v67; // r0
  api_data *v68; // r0
  int v69; // r6
  all_parameters *v70; // r7
  int v71; // r10
  int v72; // r4
  int v73; // r0
  int v74; // r2
  int v75; // r0
  int v76; // r0
  int v77; // r2
  api_data *v78; // r0
  double v79; // d7
  api_data *v80; // r4
  int64_t v81; // r2
  double v82; // d7
  api_data *v83; // r0
  int v84; // r4
  api_data *v85; // r0
  api_data *v86; // r8
  unsigned __int8 *v87; // r2
  int k; // r4
  int v89; // r7
  int m; // r4
  unsigned int **v91; // r2
  int n; // r4
  unsigned __int8 *v93; // r2
  all_parameters *v94; // r1
  int v95; // r4
  int v96; // r10
  int v97; // r7
  int v98; // lr
  int v99; // r3
  int v100; // r4
  int *v101; // r11
  int v102; // r6
  int v103; // t1
  const char *v104; // r1
  int v105; // r2
  int v106; // r3
  int v107; // r6
  int v108; // r4
  int v109; // r2
  int v110; // r2
  int v111; // r10
  int v112; // r4
  int v113; // r2
  __int16 v115; // lr
  pthread_mutex_t *v116; // r4
  all_parameters *v117; // r5
  uint64_t v118; // r0
  unsigned int v119; // r3
  __int64 v120; // r2
  bool v122; // [sp+4h] [bp-89Ch]
  all_parameters *v123; // [sp+Ch] [bp-894h]
  int *v124; // [sp+10h] [bp-890h]
  unsigned int v125; // [sp+10h] [bp-890h]
  unsigned __int8 *v126; // [sp+14h] [bp-88Ch]
  int *v127; // [sp+14h] [bp-88Ch]
  int *v128; // [sp+18h] [bp-888h]
  int *v129; // [sp+1Ch] [bp-884h]
  api_data *root; // [sp+20h] [bp-880h]
  api_data *roota; // [sp+20h] [bp-880h]
  api_data *rootb; // [sp+20h] [bp-880h]
  api_data *v133; // [sp+24h] [bp-87Ch]
  int16_t asic_num_total; // [sp+36h] [bp-86Ah] BYREF
  double dev_sum_freq; // [sp+38h] [bp-868h] BYREF
  unsigned __int8 chain_xtime[16]; // [sp+44h] [bp-85Ch] BYREF
  unsigned __int8 chain_opencore[20]; // [sp+54h] [bp-84Ch] BYREF
  _BYTE param_name[2048]; // [sp+68h] [bp-838h] OVERLAPPED BYREF

  v2 = 0;
  v3 = api_add_uint8(0, "miner_count", &dev->chain_num, 1);
  v4 = api_add_string(v3, "frequency", dev->frequency_t, 1);
  v5 = api_add_uint8(v4, "fan_num", &dev->fan_num, 1);
  do
  {
    sprintf(param_name, "fan%d", v2 + 1);
    v6 = &dev->current_job_start_address + v2++;
    v7 = api_add_uint(v5, param_name, (unsigned int *)((char *)v6 + 12106), 1);
    v5 = v7;
  }
  while ( v2 != 8 );
  v8 = 0;
  v9 = api_add_uint8(v7, "temp_num", &dev->chain_num, 1);
  do
  {
    sprintf(param_name, "temp%d", v8 + 1);
    v10 = v8 + 301;
    ++v8;
    v9 = api_add_int16(v9, param_name, (uint16_t *)dev + 4 * v10, 1);
  }
  while ( v8 != 16 );
  for ( i = 0; i != 16; ++i )
  {
    sprintf(param_name, "temp2_%d", i + 1);
    v12 = api_add_int16(v9, param_name, (uint16_t *)&dev->chain_asic_temp[i][0][1], 1);
    v9 = v12;
  }
  for ( j = 0; j != 16; ++j )
  {
    sprintf(param_name, "temp3_%d", j + 1);
    v14 = api_add_int16(v9, param_name, (uint16_t *)&dev->chain_asic_temp[j][1][1], 1);
    v9 = v14;
  }
  v15 = 0;
  root = v14;
  v128 = &CSWTCH_824;
  v16 = &CSWTCH_825;
  v129 = &CSWTCH_825;
  v124 = &CSWTCH_824;
  do
  {
    v17 = v15 + 1;
    dev_sum_freq = 0.0;
    sprintf(param_name, "freq_avg%d", v15 + 1);
    if ( dev->chain_exist[v15] == 1 )
    {
      v123 = dev;
      if ( getChainPICMagicNumber(v15) == 125 )
      {
        if ( !v123->chain_asic_num[v15] )
          goto LABEL_46;
        v18 = 0;
        v19 = v15 - 1;
        v20 = 31 * (v15 % 3);
        v126 = &chain_pic_buf[3 * (v15 / 3)][v20];
        do
        {
          if ( fpga_version > 13 )
          {
            v21 = 11;
            if ( v19 <= 0xC )
              v20 = (int)v124;
            v22 = 0;
            if ( v19 <= 0xC )
            {
              v21 = *(v16 - 1);
              v22 = *(_DWORD *)(v20 - 4);
            }
            if ( v19 <= 0xC )
              v21 *= 31;
            if ( v19 <= 0xC )
              v21 += 11;
            v23 = *((unsigned __int8 *)&h + 128 * v22 + v18 + v21 + 212);
          }
          else
          {
            v23 = v126[v18 + 11];
          }
          ++v18;
          v24 = strtol(*(const char **)&_PRETTY_FUNCTION___14401[16 * v23 + 56], 0, 10);
          dev_sum_freq = (double)v24 + dev_sum_freq;
          v25 = dev->chain_asic_num[v15];
        }
        while ( v25 > v18 );
        v17 = v15 + 1;
        if ( dev->chain_asic_num[v15] )
          v43 = dev_sum_freq / (double)v25;
        else
LABEL_46:
          v43 = dev_sum_freq;
        v27 = v43 * 100.0;
        v26 = root;
      }
      else
      {
        v26 = root;
        v27 = dev_sum_freq * 100.0;
      }
    }
    else
    {
      v26 = root;
      v27 = dev_sum_freq * 100.0;
    }
    v15 = v17;
    ++v16;
    dev_sum_freq = (double)(int)v27 / 100.0;
    root = api_add_mhs(v26, param_name, &dev_sum_freq, 1);
    ++v124;
  }
  while ( v17 != 16 );
  v28 = &CSWTCH_825;
  v29 = 0;
  v127 = &CSWTCH_824;
  v30 = chain_badcore_num;
  dev_sum_freq = 0.0;
  strcpy(param_name, "total_rateideal");
  do
  {
    v31 = dev;
    if ( dev->chain_exist[v29] == 1 && getChainPICMagicNumber(v29) == 125 && v31->chain_asic_num[v29] )
    {
      v32 = chain_pic_buf;
      v33 = 0;
      v125 = v29 - 1;
      v34 = v28;
      v35 = v30;
      v36 = v34;
      v37 = 0;
      do
      {
        if ( fpga_version > 13 )
        {
          v38 = 11;
          v39 = 0;
          if ( v125 <= 0xC )
            v32 = (unsigned __int8 (*)[128])v127;
          if ( v125 <= 0xC )
          {
            v39 = *(_DWORD *)&(*v32)[-4];
            v38 = 31 * *(v36 - 1);
          }
          if ( v125 <= 0xC )
            v38 += 11;
          v32 = (unsigned __int8 (*)[128])((char *)&h + 128 * v39 + v37);
          v40 = &_PRETTY_FUNCTION___14401[16 * (*v32)[v38 + 212]];
        }
        else
        {
          v32 = (unsigned __int8 (*)[128])_PRETTY_FUNCTION___14401;
          v40 = &_PRETTY_FUNCTION___14401[16 * chain_pic_buf[3 * (v29 / 3)][31 * (v29 % 3) + 11 + v37]];
        }
        ++v37;
        v41 = strtol(*((const char **)v40 + 14), 0, 10);
        v42 = (*v35)[v33++];
        dev_sum_freq = (double)(v41 * (114 - v42)) + dev_sum_freq;
      }
      while ( dev->chain_asic_num[v29] > v37 );
      v44 = v36;
      v30 = v35;
      v28 = v44;
    }
    ++v29;
    ++v30;
    ++v28;
    ++v127;
  }
  while ( v29 != 16 );
  v45 = 0;
  v46 = 0;
  dev_sum_freq = (double)(int)(dev_sum_freq / 1000.0 * 100.0) / 100.0;
  roota = api_add_mhs(root, param_name, &dev_sum_freq, 1);
  v47 = &CSWTCH_824;
  v48 = &CSWTCH_825;
  dev_sum_freq = 0.0;
  strcpy(param_name, "total_freqavg");
  do
  {
    while ( 1 )
    {
      v49 = dev;
      if ( dev->chain_exist[v46] == 1 && getChainPICMagicNumber(v46) == 125 && v49->chain_asic_num[v46] )
        break;
      ++v46;
      ++v47;
      ++v48;
      if ( v46 == 16 )
        goto LABEL_67;
    }
    v50 = v45;
    v51 = v46 - 1;
    v52 = 0;
    v53 = v50;
    do
    {
      if ( fpga_version > 13 )
      {
        v54 = 11;
        v55 = 0;
        if ( v51 <= 0xC )
        {
          v54 = *(v48 - 1);
          v55 = *(v47 - 1);
        }
        if ( v51 <= 0xC )
          v54 *= 31;
        if ( v51 <= 0xC )
          v54 += 11;
        v56 = *((unsigned __int8 *)&h + 128 * v55 + v52 + v54 + 212);
      }
      else
      {
        v56 = chain_pic_buf[3 * (v46 / 3)][31 * (v46 % 3) + 11 + v52];
      }
      ++v52;
      ++v53;
      v57 = strtol(*(const char **)&_PRETTY_FUNCTION___14401[16 * v56 + 56], 0, 10);
      dev_sum_freq = (double)v57 + dev_sum_freq;
    }
    while ( dev->chain_asic_num[v46] > v52 );
    ++v46;
    v45 = v53;
    ++v47;
    ++v48;
  }
  while ( v46 != 16 );
LABEL_67:
  v58 = chain_badcore_num;
  dev_sum_freq = (double)(int)(dev_sum_freq / (double)v45 * 100.0) / 100.0;
  v59 = api_add_mhs(roota, param_name, &dev_sum_freq, 1);
  v60 = 0;
  v61 = 0;
  asic_num_total = 0;
  v62 = dev;
  strcpy(param_name, "total_acn");
  do
  {
    v63 = (char *)v62->chain_exist[0];
    v62 = (all_parameters *)((char *)v62 + 4);
    v64 = v63 == (char *)1;
    if ( v63 == (char *)1 )
      v63 = (char *)dev + v61;
    ++v61;
    if ( v64 )
      v60 += (unsigned __int8)v63[12202];
  }
  while ( v61 != 16 );
  asic_num_total = v60;
  v65 = 0;
  v66 = api_add_int16(v59, param_name, (uint16_t *)&asic_num_total, 1);
  dev_sum_freq = 0.0;
  strcpy(param_name, "total_rate");
  do
  {
    while ( 1 )
    {
      if ( dev->chain_exist[v65] == 1 )
      {
        v67 = (const char *)displayed_rate[v65];
        if ( *v67 )
          break;
      }
      if ( ++v65 == 16 )
        goto LABEL_78;
    }
    ++v65;
    strtod(v67, 0);
    v1 = dev_sum_freq + v1;
    dev_sum_freq = v1;
  }
  while ( v65 != 16 );
LABEL_78:
  v68 = v66;
  v69 = 0;
  dev_sum_freq = (double)(int)(dev_sum_freq * 100.0) / 100.0;
  v133 = api_add_mhs(v68, param_name, &dev_sum_freq, 1);
  do
  {
    rootb = (api_data *)(v69 + 1);
    dev_sum_freq = 0.0;
    sprintf(param_name, "chain_rateideal%d", v69 + 1);
    v70 = dev;
    if ( dev->chain_exist[v69] != 1 )
      goto LABEL_89;
    if ( getChainPICMagicNumber(v69) == 125 )
    {
      if ( v70->chain_asic_num[v69] )
      {
        v71 = 0;
        v72 = 0;
        do
        {
          if ( fpga_version > 13 )
          {
            v73 = 11;
            v74 = 0;
            if ( (unsigned int)(v69 - 1) <= 0xC )
            {
              v74 = *(v128 - 1);
              v73 = 31 * *(v129 - 1) + 11;
            }
            v75 = *((unsigned __int8 *)&h + 128 * v74 + v72 + v73 + 212);
          }
          else
          {
            v75 = chain_pic_buf[3 * (v69 / 3)][31 * (v69 % 3) + 11 + v72];
          }
          ++v72;
          v76 = strtol(*(const char **)&_PRETTY_FUNCTION___14401[16 * v75 + 56], 0, 10);
          v77 = (*v58)[v71++];
          dev_sum_freq = (double)(v76 * (114 - v77)) + dev_sum_freq;
        }
        while ( dev->chain_asic_num[v69] > v72 );
      }
LABEL_89:
      v78 = v133;
      v79 = dev_sum_freq / 1000.0;
      goto LABEL_90;
    }
    v78 = v133;
    v79 = dev_sum_freq / 1000.0;
LABEL_90:
    ++v58;
    dev_sum_freq = (double)(int)(v79 * 100.0) / 100.0;
    ++v69;
    v133 = api_add_mhs(v78, param_name, &dev_sum_freq, 1);
    ++v128;
    ++v129;
  }
  while ( rootb != (api_data *)16 );
  v80 = api_add_int(v133, "temp_max", &dev->temp_top1[1], 1);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  v81 = total_diff1 + hw_errors;
  if ( v81 )
    v82 = (double)hw_errors / (double)v81;
  else
    v82 = 0.0;
  v83 = v80;
  dev_sum_freq = v82;
  v84 = 0;
  v85 = api_add_percent(v83, "Device Hardware%", &dev_sum_freq, 1);
  v86 = api_add_int(v85, "no_matching_work", &hw_errors, 1);
  do
  {
    sprintf(param_name, "chain_acn%d", v84 + 1);
    v87 = (unsigned __int8 *)dev + v84++;
    v86 = api_add_uint8(v86, param_name, v87 + 12202, 1);
  }
  while ( v84 != 16 );
  for ( k = 0; k != 16; ++k )
  {
    sprintf(param_name, "chain_acs%d", k + 1);
    v89 = k;
    v86 = api_add_string(v86, param_name, dev->chain_asic_status_string[v89], 1);
  }
  for ( m = 0; m != 16; ++m )
  {
    sprintf(param_name, "chain_hw%d", m + 1);
    v91 = &dev->current_job_start_address + m;
    v86 = api_add_uint32(v86, param_name, (unsigned int *)((char *)v91 + 2682), 1);
  }
  for ( n = 0; n != 16; ++n )
  {
    sprintf(param_name, "chain_rate%d", n + 1);
    v93 = displayed_rate[n];
    v86 = api_add_string(v86, param_name, v93, 1);
  }
  v94 = dev;
  v95 = 1;
  do
  {
    while ( 1 )
    {
      v96 = v95 + 1;
      v97 = v95 - 1;
      if ( *(&v94->pwm_value + v95) == 1 )
        break;
      ++v95;
      if ( v96 == 17 )
        goto LABEL_114;
    }
    *(_DWORD *)param_name = 123;
    memset(&param_name[4], 0, 0x7FCu);
    memset(chain_opencore, 0, sizeof(chain_opencore));
    sprintf((char *)chain_xtime, "chain_xtime%d", v95);
    v98 = 1;
    v99 = x_time[v95 - 1][0];
    if ( v99 )
    {
      sprintf((char *)chain_opencore, "X%d=%d", 0, v99);
      strcat(param_name, (const char *)chain_opencore);
      v98 = 0;
    }
    if ( dev->chain_asic_num[v97] > 1u )
    {
      v100 = 1;
      v101 = x_time[v97];
      do
      {
        v103 = v101[1];
        ++v101;
        v102 = v103;
        if ( v103 )
        {
          v104 = "X%d=%d";
          v105 = v100;
          v106 = v102;
          if ( !v98 )
          {
            v104 = ",X%d=%d";
            v105 = v100;
            v106 = v102;
          }
          sprintf((char *)chain_opencore, v104, v105, v106);
          strcat(param_name, (const char *)chain_opencore);
          v98 = 0;
        }
        ++v100;
      }
      while ( dev->chain_asic_num[v97] > v100 );
    }
    strcat(param_name, "}");
    v95 = v96;
    v86 = api_add_string(v86, chain_xtime, param_name, 1);
    v94 = dev;
  }
  while ( v96 != 17 );
LABEL_114:
  v107 = 1;
  v108 = 0;
  do
  {
    while ( v94->chain_exist[v108] != 1 )
    {
      ++v108;
      ++v107;
      if ( v108 == 16 )
        goto LABEL_118;
    }
    v109 = v107++;
    sprintf((char *)chain_opencore, "chain_offside_%d", v109);
    v110 = temp_offside[v108++];
    sprintf(param_name, "%d", v110);
    v86 = api_add_string(v86, chain_opencore, param_name, 1);
    v94 = dev;
  }
  while ( v108 != 16 );
LABEL_118:
  v111 = 1;
  v112 = 0;
  do
  {
    while ( v94->chain_exist[v112] != 1 )
    {
      ++v112;
      ++v111;
      if ( v112 == 16 )
        goto LABEL_125;
    }
    v113 = v111++;
    sprintf((char *)chain_opencore, "chain_opencore_%d", v113);
    if ( isChainAllCoresOpened[v112++] )
      v115 = 49;
    else
      v115 = 48;
    *(_WORD *)param_name = v115;
    v86 = api_add_string(v86, chain_opencore, param_name, 1);
    v94 = dev;
  }
  while ( v112 != 16 );
LABEL_125:
  v116 = (pthread_mutex_t *)rate;
  v117 = v94;
  v118 = 0LL;
  do
  {
    while ( 1 )
    {
      v119 = v117->chain_exist[0];
      v117 = (all_parameters *)((char *)v117 + 4);
      if ( v119 == 1 )
        break;
      v116 = (pthread_mutex_t *)((char *)v116 + 8);
      if ( v116 == &iic_mutex )
        goto LABEL_129;
    }
    v120 = *(_QWORD *)&v116->__data.__lock;
    v116 = (pthread_mutex_t *)((char *)v116 + 8);
    v118 += v120;
  }
  while ( v116 != &iic_mutex );
LABEL_129:
  suffix_string_c5(v118, displayed_hash_rate, 0x10u, 7, v122);
  strcpy(param_name, "miner_version");
  return api_add_string(v86, param_name, g_miner_version, 1);
}
// 2C02C: variables would overlap: ^68.2048 and stkvar "param_name" ^68.32(has user info)
// 50464: using guessed type int CSWTCH_824;
// 50498: using guessed type int CSWTCH_825;

//----- (0002CC40) --------------------------------------------------------
unsigned int get_iic()
{
  return axi_fpga_addr[12];
}

//----- (0002CC50) --------------------------------------------------------
unsigned __int8 __fastcall set_iic(unsigned int data)
{
  int v1; // r0

  axi_fpga_addr[12] = data & 0x7FFFFFFF;
  do
  {
    usleep(0x3E8u);
    v1 = axi_fpga_addr[12];
  }
  while ( v1 >= 0 );
  return v1;
}

//----- (0002CC78) --------------------------------------------------------
unsigned __int8 __fastcall write_EEPROM_iic(
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 which_iic,
        unsigned __int8 data)
{
  _BOOL4 v5; // r6
  int v6; // r8
  int v8; // r4
  int v9; // r4

  v5 = reg_addr_valid;
  v6 = reg_addr;
  if ( read )
    v8 = 0x2000000;
  else
    v8 = 0;
  usleep(0x3E8u);
  usleep(0x3E8u);
  usleep(0x3E8u);
  usleep(0x3E8u);
  if ( v5 )
    v8 |= (v6 << 8) | 0x1000000;
  v9 = v8 | data | 0xA00000;
  if ( (unsigned int)(fpga_version - 14) <= 1 )
    --which_iic;
  return set_iic(v9 | ((which_iic & 3) << 26));
}

//----- (0002CCE8) --------------------------------------------------------
unsigned __int8 __fastcall AT24C02_read_one_byte(unsigned __int8 address, unsigned __int8 which_iic)
{
  return write_EEPROM_iic(1, 1, address, which_iic, 0);
}

//----- (0002CD00) --------------------------------------------------------
unsigned __int8 __fastcall AT24C02_read_voltage(unsigned __int8 which_iic)
{
  return AT24C02_read_one_byte(0x90u, which_iic);
}

//----- (0002CD08) --------------------------------------------------------
unsigned __int8 __fastcall get_pic_voltage(unsigned __int8 chain)
{
  const unsigned __int8 *v1; // r3
  unsigned int v2; // r0
  bool v3; // cc

  v1 = (const unsigned __int8 *)fpga_version;
  if ( fpga_version <= 13 )
    return AT24C02_read_voltage(chain / 3u);
  v2 = chain - 1;
  v3 = v2 > 0xC;
  if ( v2 > 0xC )
    v2 = 0;
  else
    v1 = _PRETTY_FUNCTION___14401;
  if ( !v3 )
    LOBYTE(v2) = v1[4 * v2 + 2488];
  return AT24C02_read_voltage(v2);
}

//----- (0002CD40) --------------------------------------------------------
void __fastcall AT24C02_read_bytes(
        unsigned __int8 address,
        unsigned __int8 *buf,
        unsigned __int8 which_iic,
        unsigned __int8 length)
{
  int v4; // r4
  int v5; // r7
  int v8; // r2
  int v9; // r7
  unsigned __int8 *v10; // r5
  unsigned __int8 v11; // r0

  v4 = address;
  v5 = length;
  printf("--- %s\n", (const char *)_FUNCTION___12317);
  v8 = v4 + v5;
  if ( v4 + v5 > 256 )
  {
    j_printf("\n--- %s: address + length = %d > EEPROM_LENGTH(%d)\n", (const char *)_FUNCTION___12317, v8, 256);
  }
  else if ( v5 )
  {
    v9 = (unsigned __int8)v8;
    v10 = buf - 1;
    do
    {
      v11 = v4;
      LOBYTE(v4) = v4 + 1;
      *++v10 = AT24C02_read_one_byte(v11, which_iic);
    }
    while ( (unsigned __int8)v4 != v9 );
  }
}

//----- (0002CD9C) --------------------------------------------------------
void __fastcall get_hash_board_id_number(unsigned __int8 chain, unsigned __int8 *id)
{
  const unsigned __int8 *v2; // r3
  unsigned int v3; // r2

  v2 = (const unsigned __int8 *)fpga_version;
  if ( fpga_version <= 13 )
  {
    v3 = chain / 3u;
  }
  else
  {
    v3 = chain - 1;
    if ( (unsigned int)(chain - 1) > 0xC )
      v3 = 0;
    else
      v2 = _PRETTY_FUNCTION___14401;
    if ( (unsigned int)(chain - 1) <= 0xC )
      v3 = (unsigned int)&v2[4 * v3];
    if ( (unsigned int)(chain - 1) <= 0xC )
      LOBYTE(v3) = *(_BYTE *)(v3 + 0x9B8);
  }
  AT24C02_read_bytes(0x80u, id, v3, 0xCu);
}

//----- (0002CDE8) --------------------------------------------------------
unsigned __int8 __fastcall read_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf)
{
  if ( fpga_version <= 13 )
  {
    if ( chain % 3u )
      return 0;
    AT24C02_read_bytes(0, buf, chain / 3u, 0x80u);
    return 0x80;
  }
  else
  {
    if ( (unsigned int)(chain - 1) > 2 )
      return 0;
    AT24C02_read_bytes(0, buf, chain, 0x80u);
    return 0x80;
  }
}

//----- (0002CE34) --------------------------------------------------------
void __fastcall get_temperature_offset_value(unsigned __int8 chain, unsigned __int8 *value)
{
  const unsigned __int8 *v2; // r3
  unsigned int v3; // r2

  v2 = (const unsigned __int8 *)fpga_version;
  if ( fpga_version <= 13 )
  {
    v3 = chain / 3u;
  }
  else
  {
    v3 = chain - 1;
    if ( (unsigned int)(chain - 1) > 0xC )
      v3 = 0;
    else
      v2 = _PRETTY_FUNCTION___14401;
    if ( (unsigned int)(chain - 1) <= 0xC )
      v3 = (unsigned int)&v2[4 * v3];
    if ( (unsigned int)(chain - 1) <= 0xC )
      LOBYTE(v3) = *(_BYTE *)(v3 + 0x9B8);
  }
  AT24C02_read_bytes(0x98u, value, v3, 8u);
}

//----- (0002CE80) --------------------------------------------------------
void __fastcall AT24C02_write_one_byte(unsigned __int8 address, unsigned __int8 data, unsigned __int8 which_iic)
{
  write_EEPROM_iic(0, 1, address, which_iic, data);
}

//----- (0002CE98) --------------------------------------------------------
void __fastcall AT24C02_save_voltage(unsigned __int8 which_iic, unsigned __int8 voltage)
{
  int v3; // r4

  v3 = voltage;
  printf("\n--- %s\n", (const char *)_FUNCTION___12333);
  AT24C02_write_one_byte(0x90u, v3, which_iic);
  j_printf("%s: voltage = 0x%02x\n", (const char *)_FUNCTION___12333, v3);
}

//----- (0002CED4) --------------------------------------------------------
void __fastcall AT24C02_write_bytes(
        unsigned __int8 address,
        unsigned __int8 *buf,
        unsigned __int8 which_iic,
        unsigned __int8 length)
{
  int v4; // r4
  int v5; // r7
  int v8; // r2
  int v9; // r7
  unsigned __int8 *v10; // r5
  unsigned __int8 v11; // r0
  unsigned __int8 v12; // t1

  v4 = address;
  v5 = length;
  printf("--- %s\n", (const char *)_FUNCTION___12306);
  v8 = v4 + v5;
  if ( v4 + v5 > 256 )
  {
    j_printf("\n--- %s: address + length = %d > EEPROM_LENGTH(%d)\n", (const char *)_FUNCTION___12306, v8, 256);
  }
  else if ( v5 )
  {
    v9 = (unsigned __int8)v8;
    v10 = buf - 1;
    do
    {
      v11 = v4;
      LOBYTE(v4) = v4 + 1;
      v12 = *++v10;
      AT24C02_write_one_byte(v11, v12, which_iic);
    }
    while ( (unsigned __int8)v4 != v9 );
  }
}

//----- (0002CF30) --------------------------------------------------------
unsigned __int8 __fastcall save_freq_badcores(unsigned __int8 chain, unsigned __int8 *buf)
{
  if ( fpga_version <= 13 )
  {
    if ( chain % 3u )
      return 0;
    AT24C02_write_bytes(0, buf, chain / 3u, 0x80u);
    return 0x80;
  }
  else
  {
    if ( (unsigned int)(chain - 1) > 2 )
      return 0;
    AT24C02_write_bytes(0, buf, chain, 0x80u);
    return 0x80;
  }
}

//----- (0002CF7C) --------------------------------------------------------
unsigned __int8 __fastcall T9_plus_write_pic_iic(
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 which_iic,
        unsigned __int8 data)
{
  _BOOL4 v6; // r10
  _BOOL4 v7; // r8
  int v8; // r9
  int v9; // r4
  int v10; // r4

  v6 = read;
  v7 = reg_addr_valid;
  v8 = reg_addr;
  while ( (axi_fpga_addr[12] & 0x80000000) == 0 )
    usleep(0x3E8u);
  if ( v6 )
    v9 = 0x2000000;
  else
    v9 = 0;
  if ( v7 )
    v9 |= (v8 << 8) | 0x1000000;
  v10 = v9 | data | 0x400000;
  if ( (unsigned int)(fpga_version - 14) <= 1 )
    --which_iic;
  return set_iic(v10 | ((which_iic & 3) << 26));
}

//----- (0002CFF4) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_pic_heart_beat(unsigned __int8 which_iic)
{
  int v2; // r6
  int v3; // r8
  int v4; // r7

  v2 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 4u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x16u);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0);
    T9_plus_write_pic_iic(0, 0, 0, which_iic, 0x1Au);
    usleep((__useconds_t)&cgpu.results[4][3663]);
    T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    v3 = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    v4 = T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    T9_plus_write_pic_iic(1, 0, 0, which_iic, 0);
    if ( v3 == 22 && v4 == 1 )
      break;
    sleep(1u);
    if ( !--v2 )
      return 0;
  }
  return 1;
}

//----- (0002D0F0) --------------------------------------------------------
void __fastcall pic_heart_beat_each_chain(unsigned __int8 chain)
{
  unsigned int v1; // r3

  v1 = chain;
  if ( fpga_version > 13 )
  {
    if ( (unsigned int)(chain - 1) > 2 )
      return;
LABEL_5:
    dsPIC33EP16GS202_pic_heart_beat(chain);
    return;
  }
  *(_DWORD *)&chain = chain / 3u;
  if ( !(v1 % 3) )
    goto LABEL_5;
}

//----- (0002D124) --------------------------------------------------------
void __noreturn pic_heart_beat_func()
{
  int i; // r4

  for ( i = 0; ; ++i )
  {
    if ( i > 15 )
    {
      i = 0;
      sleep(0xAu);
    }
    if ( dev->chain_exist[i] )
    {
      pthread_mutex_lock(&iic_mutex);
      pic_heart_beat_each_chain(i);
      pthread_mutex_unlock(&iic_mutex);
      cgsleep_ms(10);
    }
  }
}

//----- (0002D16C) --------------------------------------------------------
unsigned int get_nonce2_and_job_id_store_address()
{
  return axi_fpga_addr[68];
}

//----- (0002D180) --------------------------------------------------------
void __fastcall set_nonce2_and_job_id_store_address(unsigned int value)
{
  _BOOL4 v1; // r3

  v1 = opt_debug;
  axi_fpga_addr[68] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
    set_nonce2_and_job_id_store_address_0(value);
}

//----- (0002D1C0) --------------------------------------------------------
unsigned int get_job_start_address()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[70];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: JOB_START_ADDRESS is 0x%x\n",
      (const char *)_FUNCTION___12567,
      axi_fpga_addr[70]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002D22C) --------------------------------------------------------
void __fastcall set_job_start_address(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[70] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set JOB_START_ADDRESS is 0x%x\n", (const char *)_FUNCTION___12572, value);
    applog(7, tmp42, 0);
  }
  get_job_start_address();
}

//----- (0002D298) --------------------------------------------------------
void __fastcall set_bmc_counter(unsigned int value)
{
  axi_fpga_addr[14] = value;
}

//----- (0002D2A8) --------------------------------------------------------
unsigned int read_bmc_counter()
{
  return axi_fpga_addr[14];
}

//----- (0002D2B8) --------------------------------------------------------
unsigned int get_QN_write_data_command()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[32];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: QN_WRITE_DATA_COMMAND is 0x%x\n",
      (const char *)_FUNCTION___12584,
      axi_fpga_addr[32]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002D324) --------------------------------------------------------
void __fastcall set_QN_write_data_command(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[32] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set QN_WRITE_DATA_COMMAND is 0x%x\n", (const char *)_FUNCTION___12589, value);
    applog(7, tmp42, 0);
  }
  get_QN_write_data_command();
}

//----- (0002D390) --------------------------------------------------------
int bitmain_axi_init()
{
  int fd; // r0
  unsigned int *v1; // r0
  int v2; // r0
  unsigned int *v3; // r0
  all_parameters *v4; // r0
  _BOOL4 v5; // r3
  int result; // r0
  _BOOL4 v7; // r2
  unsigned int v8; // r5
  unsigned int *v9; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-818h] BYREF

  fd = open("/dev/axi_fpga_dev", 2);
  ::fd = fd;
  if ( fd < 0 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      goto LABEL_70;
    snprintf((char *)tmp42, 0x800u, "/dev/axi_fpga_dev open failed. fd = %d\n", fd);
    goto LABEL_69;
  }
  v1 = (unsigned int *)mmap(0, 0x160u, 3, 1, fd, 0);
  axi_fpga_addr = v1;
  if ( !v1 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -1;
    snprintf((char *)tmp42, 0x800u, "mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", 0);
LABEL_52:
    applog(7, tmp42, 0);
    return -1;
  }
  if ( opt_debug )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      snprintf((char *)tmp42, 0x800u, "mmap axi_fpga_addr = 0x%x\n", v1);
      applog(7, tmp42, 0);
      v7 = opt_debug;
      v8 = *axi_fpga_addr;
      if ( (unsigned __int16)*axi_fpga_addr == 50433 )
        goto LABEL_34;
      if ( !opt_debug )
        goto LABEL_4;
      if ( use_syslog )
      {
LABEL_33:
        snprintf((char *)tmp42, 0x800u, "data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n", v8, 50433);
        applog(7, tmp42, 0);
        v7 = opt_debug;
LABEL_34:
        if ( !v7 )
          goto LABEL_4;
LABEL_35:
        if ( use_syslog || opt_log_output )
        {
LABEL_22:
          snprintf((char *)tmp42, 0x800u, "axi_fpga_addr data = 0x%x\n", v8);
          applog(7, tmp42, 0);
          goto LABEL_4;
        }
LABEL_21:
        if ( opt_log_level <= 6 )
          goto LABEL_4;
        goto LABEL_22;
      }
    }
    else
    {
      v8 = *v1;
      if ( (unsigned __int16)*v1 == 50433 )
        goto LABEL_35;
    }
    if ( !opt_log_output && opt_log_level <= 6 )
      goto LABEL_21;
    goto LABEL_33;
  }
LABEL_4:
  v2 = open("/dev/fpga_mem", 2);
  fd_fpga_mem = v2;
  if ( v2 < 0 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      goto LABEL_70;
    snprintf((char *)tmp42, 0x800u, "/dev/fpga_mem open failed. fd_fpga_mem = %d\n", v2);
LABEL_69:
    applog(7, tmp42, 0);
LABEL_70:
    perror("open");
    return -1;
  }
  v3 = (unsigned int *)mmap(0, 0x1000000u, 3, 1, v2, 0);
  fpga_mem_addr = v3;
  if ( !v3 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -1;
    snprintf((char *)tmp42, 0x800u, "mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n", 0);
    goto LABEL_52;
  }
  if ( !opt_debug )
  {
    nonce2_jobid_address = v3;
    job_start_address_1 = v3 + 0x80000;
    job_start_address_2 = v3 + 540672;
    goto LABEL_8;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 6 )
  {
    snprintf((char *)tmp42, 0x800u, "mmap fpga_mem_addr = 0x%x\n", v3);
    applog(7, tmp42, 0);
    v9 = fpga_mem_addr + 0x80000;
    nonce2_jobid_address = fpga_mem_addr;
    job_start_address_1 = fpga_mem_addr + 0x80000;
    job_start_address_2 = fpga_mem_addr + 540672;
    if ( !opt_debug )
      goto LABEL_8;
  }
  else
  {
    v9 = v3 + 0x80000;
    nonce2_jobid_address = v3;
    job_start_address_1 = v3 + 0x80000;
    job_start_address_2 = v3 + 540672;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 6 )
  {
    snprintf((char *)tmp42, 0x800u, "job_start_address_1 = 0x%x\n", v9);
    applog(7, tmp42, 0);
    if ( !opt_debug )
      goto LABEL_8;
    if ( use_syslog || opt_log_output )
      goto LABEL_32;
  }
  if ( opt_log_level > 6 )
  {
LABEL_32:
    snprintf((char *)tmp42, 0x800u, "job_start_address_2 = 0x%x\n", job_start_address_2);
    applog(7, tmp42, 0);
  }
LABEL_8:
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  v4 = (all_parameters *)calloc(0x301Cu, 1u);
  dev = v4;
  if ( !v4 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "kmalloc for dev failed.\n");
      applog(7, tmp42, 0);
      return -1;
    }
    return -1;
  }
  v5 = opt_debug;
  v4->current_job_start_address = job_start_address_1;
  if ( !v5 )
    return 0;
  if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 6 )
  {
    strcpy((char *)tmp42, "kmalloc for dev success.\n");
    applog(7, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (0002D7A0) --------------------------------------------------------
int bitmain_axi_close()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-808h] BYREF

  if ( munmap(axi_fpga_addr, 0x160u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(7, tmp42, 0);
  }
  if ( munmap(fpga_mem_addr, 0x1000000u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "munmap failed!\n");
    applog(7, tmp42, 0);
  }
  close(fd);
  return close(fd_fpga_mem);
}

//----- (0002D86C) --------------------------------------------------------
unsigned int get_fan_control()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[33];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: FAN_CONTROL is 0x%x\n", (const char *)_FUNCTION___12633, axi_fpga_addr[33]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002D8D8) --------------------------------------------------------
void __fastcall set_fan_control(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[33] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set FAN_CONTROL is 0x%x\n", (const char *)_FUNCTION___12638, value);
    applog(7, tmp42, 0);
  }
  get_fan_control();
}

//----- (0002D944) --------------------------------------------------------
unsigned int get_hash_on_plug()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[2];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: HASH_ON_PLUG is 0x%x\n", (const char *)_FUNCTION___12644, axi_fpga_addr[2]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002D9AC) --------------------------------------------------------
unsigned int get_crc_count()
{
  return *((unsigned __int16 *)axi_fpga_addr + 124);
}

//----- (0002D9C0) --------------------------------------------------------
int get_hardware_version()
{
  int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = *axi_fpga_addr;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: HARDWARE_VERSION is 0x%x\n", (const char *)_FUNCTION___12653, *axi_fpga_addr);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002DA28) --------------------------------------------------------
void __fastcall set_Hardware_version(unsigned int value)
{
  *axi_fpga_addr = value;
}

//----- (0002DA38) --------------------------------------------------------
int __fastcall get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed)
{
  unsigned int v2; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v2 = axi_fpga_addr[1];
  *fan_speed = (unsigned __int8)v2;
  *fan_id = BYTE1(v2) & 7;
  if ( *fan_speed && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: fan_id is 0x%x, fan_speed is 0x%x\n",
      (const char *)_FUNCTION___12663,
      (v2 >> 8) & 7,
      *fan_speed);
    applog(7, tmp42, 0);
  }
  return v2;
}

//----- (0002DAB4) --------------------------------------------------------
unsigned int get_temperature_0_3()
{
  return axi_fpga_addr[8];
}

//----- (0002DAC4) --------------------------------------------------------
unsigned int get_temperature_4_7()
{
  return axi_fpga_addr[9];
}

//----- (0002DAD4) --------------------------------------------------------
unsigned int get_temperature_8_11()
{
  return axi_fpga_addr[10];
}

//----- (0002DAE4) --------------------------------------------------------
unsigned int get_temperature_12_15()
{
  return axi_fpga_addr[11];
}

//----- (0002DAF4) --------------------------------------------------------
unsigned int get_time_out_control()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[34];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: TIME_OUT_CONTROL is 0x%x\n",
      (const char *)_FUNCTION___12685,
      axi_fpga_addr[34]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002DB60) --------------------------------------------------------
void __fastcall set_time_out_control(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[34] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set FAN_CONTROL is 0x%x\n", (const char *)_FUNCTION___12690, value);
    applog(7, tmp42, 0);
  }
  get_time_out_control();
}

//----- (0002DBCC) --------------------------------------------------------
int __fastcall get_BC_command_buffer(unsigned int *buf)
{
  unsigned int *v2; // r2
  _BOOL4 v3; // r5
  unsigned int v4; // r0
  unsigned int v5; // r1
  int v6; // r4
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-810h] BYREF

  v2 = axi_fpga_addr;
  v3 = opt_debug;
  v4 = axi_fpga_addr[49];
  *buf = v4;
  v5 = v2[50];
  buf[1] = v5;
  v6 = v2[51];
  buf[2] = v6;
  if ( v3 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: BC_COMMAND_BUFFER buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x\n",
      (const char *)_FUNCTION___12696,
      v4,
      v5,
      v6);
    applog(7, tmp42, 0);
  }
  return v6;
}

//----- (0002DC4C) --------------------------------------------------------
void __fastcall set_BC_command_buffer(unsigned int *value)
{
  unsigned int v2; // r4
  unsigned int *v3; // r0
  unsigned int v4; // r4
  _BOOL4 v5; // r5
  unsigned int v6; // r3
  unsigned int buf[4]; // [sp+10h] [bp-820h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-810h] BYREF

  v2 = *value;
  v3 = axi_fpga_addr;
  buf[1] = 0;
  axi_fpga_addr[49] = v2;
  v4 = value[1];
  v5 = opt_debug;
  buf[2] = 0;
  v3[50] = v4;
  v6 = value[2];
  buf[3] = 0;
  buf[0] = 0;
  v3[51] = v6;
  if ( v5 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set BC_COMMAND_BUFFER value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x\n",
      (const char *)_FUNCTION___12702,
      *value,
      value[1],
      value[2]);
    applog(7, tmp42, 0);
  }
  get_BC_command_buffer(buf);
}

//----- (0002DCDC) --------------------------------------------------------
unsigned int get_nonce_number_in_fifo()
{
  return axi_fpga_addr[6];
}

//----- (0002DCEC) --------------------------------------------------------
int __fastcall get_return_nonce(unsigned int *buf)
{
  unsigned int *v1; // r3
  int v2; // r3

  v1 = axi_fpga_addr;
  *buf = axi_fpga_addr[4];
  v2 = v1[5];
  buf[1] = v2;
  return v2;
}

//----- (0002DD04) --------------------------------------------------------
unsigned int get_BC_write_command()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[48];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: BC_WRITE_COMMAND is 0x%x\n",
      (const char *)_FUNCTION___12716,
      axi_fpga_addr[48]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002DD70) --------------------------------------------------------
unsigned int get_ticket_mask()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[35];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: TICKET_MASK_FPGA is 0x%x\n",
      (const char *)_FUNCTION___12730,
      axi_fpga_addr[35]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002DDDC) --------------------------------------------------------
void __fastcall set_ticket_mask(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[35] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set TICKET_MASK_FPGA is 0x%x\n", (const char *)_FUNCTION___12735, value);
    applog(7, tmp42, 0);
  }
  get_ticket_mask();
}

//----- (0002DE48) --------------------------------------------------------
unsigned int get_job_id()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[73];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: JOB_ID is 0x%x\n", (const char *)_FUNCTION___12741, axi_fpga_addr[73]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002DEB4) --------------------------------------------------------
void __fastcall set_job_id(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[73] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set JOB_ID is 0x%x\n", (const char *)_FUNCTION___12746, value);
    applog(7, tmp42, 0);
  }
  get_job_id();
}

//----- (0002DF20) --------------------------------------------------------
unsigned int get_job_length()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[71];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: JOB_LENGTH is 0x%x\n", (const char *)_FUNCTION___12752, axi_fpga_addr[71]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002DF8C) --------------------------------------------------------
void __fastcall set_job_length(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[71] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set JOB_LENGTH is 0x%x\n", (const char *)_FUNCTION___12757, value);
    applog(7, tmp42, 0);
  }
  get_job_id();
}

//----- (0002DFF8) --------------------------------------------------------
unsigned int get_block_header_version()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[76];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: BLOCK_HEADER_VERSION is 0x%x\n",
      (const char *)_FUNCTION___12763,
      axi_fpga_addr[76]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E064) --------------------------------------------------------
void __fastcall set_block_header_version(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[76] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set BLOCK_HEADER_VERSION is 0x%x\n", (const char *)_FUNCTION___12768, value);
    applog(7, tmp42, 0);
  }
  get_block_header_version();
}

//----- (0002E0D0) --------------------------------------------------------
unsigned int get_time_stamp()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[77];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: TIME_STAMP is 0x%x\n", (const char *)_FUNCTION___12773, axi_fpga_addr[77]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E13C) --------------------------------------------------------
void __fastcall set_time_stamp(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[77] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set TIME_STAMP is 0x%x\n", (const char *)_FUNCTION___12778, value);
    applog(7, tmp42, 0);
  }
  get_time_stamp();
}

//----- (0002E1A8) --------------------------------------------------------
unsigned int get_target_bits()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[78];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: TARGET_BITS is 0x%x\n", (const char *)_FUNCTION___12784, axi_fpga_addr[78]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E214) --------------------------------------------------------
void __fastcall set_target_bits(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[78] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set TARGET_BITS is 0x%x\n", (const char *)_FUNCTION___12789, value);
    applog(7, tmp42, 0);
  }
  get_target_bits();
}

//----- (0002E280) --------------------------------------------------------
int __fastcall get_pre_header_hash(unsigned int *buf)
{
  unsigned int *v2; // r3
  _BOOL4 v3; // r8
  unsigned int v4; // r12
  unsigned int v5; // r0
  unsigned int v6; // r1
  unsigned int v7; // r7
  unsigned int v8; // r6
  unsigned int v9; // r5
  unsigned int v10; // r2
  int v11; // r3
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  v2 = axi_fpga_addr;
  v3 = opt_debug;
  v4 = axi_fpga_addr[80];
  *buf = v4;
  v5 = v2[81];
  buf[1] = v5;
  v6 = v2[82];
  buf[2] = v6;
  v7 = v2[83];
  buf[3] = v7;
  v8 = v2[84];
  buf[4] = v8;
  v9 = v2[85];
  buf[5] = v9;
  v10 = v2[86];
  buf[6] = v10;
  v11 = v2[87];
  buf[7] = v11;
  if ( v3 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: PRE_HEADER_HASH buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x, buf[3]: 0x%x, buf[4]: 0x%x, buf[5]: 0x%x, buf[6]: 0x"
      "%x, buf[7]: 0x%x\n",
      (const char *)_FUNCTION___12795,
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11);
    applog(7, tmp42, 0);
    return buf[7];
  }
  return v11;
}

//----- (0002E34C) --------------------------------------------------------
void __fastcall set_pre_header_hash(unsigned int *value)
{
  unsigned int *v2; // r2
  _BOOL4 v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-818h] BYREF

  v2 = axi_fpga_addr;
  axi_fpga_addr[80] = *value;
  v3 = opt_debug;
  v2[81] = value[1];
  v2[82] = value[2];
  v2[83] = value[3];
  v2[84] = value[4];
  v2[85] = value[5];
  v2[86] = value[6];
  v2[87] = value[7];
  if ( v3 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set PRE_HEADER_HASH value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x, value[3]: 0x%x, value[4]: 0x%x, value[5]: "
      "0x%x, value[6]: 0x%x, value[7]: 0x%x\n",
      (const char *)_FUNCTION___12801,
      *value,
      value[1],
      value[2],
      value[3],
      value[4],
      value[5],
      value[6],
      value[7]);
    applog(7, tmp42, 0);
  }
}

//----- (0002E400) --------------------------------------------------------
unsigned int get_coinbase_length_and_nonce2_length()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[65];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
      (const char *)_FUNCTION___12807,
      axi_fpga_addr[65]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E46C) --------------------------------------------------------
void __fastcall set_coinbase_length_and_nonce2_length(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[65] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
      (const char *)_FUNCTION___12812,
      value);
    applog(7, tmp42, 0);
  }
  get_coinbase_length_and_nonce2_length();
}

//----- (0002E4D8) --------------------------------------------------------
int __fastcall get_work_nonce2(unsigned int *buf)
{
  unsigned int *v1; // r3
  _BOOL4 v2; // r1
  unsigned int v3; // r2
  unsigned int v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = axi_fpga_addr;
  v2 = opt_debug;
  v3 = axi_fpga_addr[66];
  *buf = v3;
  v4 = v1[67];
  buf[1] = v4;
  if ( v2 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: WORK_NONCE_2 buf[0]: 0x%x, buf[1]: 0x%x\n",
      (const char *)_FUNCTION___12818,
      v3,
      v4);
    applog(7, tmp42, 0);
  }
  return -1;
}

//----- (0002E550) --------------------------------------------------------
void __fastcall set_work_nonce2(unsigned int *value)
{
  unsigned int v1; // r1
  unsigned int *v2; // r3
  _BOOL4 v3; // r4
  unsigned int v4; // r1
  unsigned int buf[2]; // [sp+8h] [bp-810h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-808h] BYREF

  v1 = *value;
  v2 = axi_fpga_addr;
  buf[0] = 0;
  axi_fpga_addr[66] = v1;
  v3 = opt_debug;
  v4 = value[1];
  buf[1] = 0;
  v2[67] = v4;
  if ( v3 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set WORK_NONCE_2 value[0]: 0x%x, value[1]: 0x%x\n",
      (const char *)_FUNCTION___12824,
      *value,
      value[1]);
    applog(7, tmp42, 0);
  }
  get_work_nonce2(buf);
}

//----- (0002E5D0) --------------------------------------------------------
int get_merkle_bin_number()
{
  int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = *((unsigned __int16 *)axi_fpga_addr + 138);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: MERKLE_BIN_NUMBER is 0x%x\n",
      (const char *)_FUNCTION___12830,
      *((unsigned __int16 *)axi_fpga_addr + 138));
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E63C) --------------------------------------------------------
void __fastcall set_merkle_bin_number(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[69] = (unsigned __int16)value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: set MERKLE_BIN_NUMBER is 0x%x\n",
      (const char *)_FUNCTION___12835,
      (unsigned __int16)value);
    applog(7, tmp42, 0);
  }
  get_merkle_bin_number();
}

//----- (0002E6AC) --------------------------------------------------------
unsigned int get_nonce_fifo_interrupt()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[7];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: NONCE_FIFO_INTERRUPT is 0x%x\n",
      (const char *)_FUNCTION___12841,
      axi_fpga_addr[7]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E714) --------------------------------------------------------
void __fastcall set_nonce_fifo_interrupt(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[7] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set NONCE_FIFO_INTERRUPT is 0x%x\n", (const char *)_FUNCTION___12846, value);
    applog(7, tmp42, 0);
  }
  get_nonce_fifo_interrupt();
}

//----- (0002E780) --------------------------------------------------------
unsigned int get_dhash_acc_control()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[64];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: DHASH_ACC_CONTROL is 0x%x\n",
      (const char *)_FUNCTION___12852,
      axi_fpga_addr[64]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E7EC) --------------------------------------------------------
void __fastcall set_dhash_acc_control(unsigned int value)
{
  _BOOL4 v2; // r2
  int v3; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-818h] BYREF

  v2 = opt_debug;
  axi_fpga_addr[64] = value;
  if ( v2 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set DHASH_ACC_CONTROL is 0x%x\n", (const char *)_FUNCTION___12858, value);
    applog(7, tmp42, 0);
  }
  v3 = 10;
  while ( (value | 0x80) != (get_dhash_acc_control() | 0x80) )
  {
    axi_fpga_addr[64] = value;
    cgsleep_ms(2);
    if ( !--v3 )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s set DHASH_ACC_CONTROL failed!", (const char *)_FUNCTION___12858);
        applog(7, tmp42, 0);
      }
      return;
    }
  }
}

//----- (0002E8C0) --------------------------------------------------------
void __fastcall set_TW_write_command(unsigned int *value)
{
  int v1; // r3
  unsigned int *v2; // r4
  unsigned int v3; // r1
  unsigned int *v4; // r2

  v1 = 0;
  v2 = axi_fpga_addr;
  do
  {
    v3 = value[v1];
    v4 = &v2[v1++];
    v4[16] = v3;
  }
  while ( v1 != 13 );
}

//----- (0002E8E0) --------------------------------------------------------
void __fastcall set_TW_write_command_vil(unsigned int *value)
{
  int v2; // r3
  unsigned int *v3; // r1

  pthread_mutex_lock(&fpga_mutex);
  v2 = 1;
  v3 = axi_fpga_addr;
  while ( 1 )
  {
    if ( v2 == 1 )
    {
      v3[16] = *value;
      goto LABEL_3;
    }
    v3[17] = value[v2 - 1];
    if ( v2 == 13 )
      break;
LABEL_3:
    ++v2;
  }
  j_pthread_mutex_unlock(&fpga_mutex);
}

//----- (0002E920) --------------------------------------------------------
unsigned int get_buffer_space()
{
  return axi_fpga_addr[3];
}

//----- (0002E930) --------------------------------------------------------
unsigned int get_hash_counting_number()
{
  unsigned int v0; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v0 = axi_fpga_addr[36];
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: DHASH_ACC_CONTROL is 0x%x\n",
      (const char *)_FUNCTION___12886,
      axi_fpga_addr[36]);
    applog(7, tmp42, 0);
  }
  return v0;
}

//----- (0002E99C) --------------------------------------------------------
void __fastcall set_hash_counting_number(unsigned int value)
{
  _BOOL4 v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-808h] BYREF

  v1 = opt_debug;
  axi_fpga_addr[36] = value;
  if ( v1 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: set DHASH_ACC_CONTROL is 0x%x\n", (const char *)_FUNCTION___12891, value);
    applog(7, tmp42, 0);
  }
  get_hash_counting_number();
}

//----- (0002EA08) --------------------------------------------------------
void check_chain()
{
  int hash_on_plug; // r0
  int v1; // r1
  int v2; // r2
  all_parameters *v3; // r1
  int v4; // r3
  all_parameters *v5; // r4
  char *v6; // r5
  int v7; // r2
  bool v8; // zf
  int v9; // r2
  int v10; // r3

  dev->chain_num = 0;
  hash_on_plug = get_hash_on_plug();
  if ( hash_on_plug < 0 )
  {
    if ( opt_debug )
    {
      v10 = use_syslog;
      if ( use_syslog || (v10 = opt_log_output) != 0 || (v10 = opt_log_level, opt_log_level > 6) )
        check_chain_0(hash_on_plug, v1, v2, (const char *)v10);
    }
  }
  else
  {
    v3 = dev;
    v4 = 0;
    v5 = dev;
    v6 = (char *)&dev->temp[5] + 2;
    do
    {
      v7 = hash_on_plug >> v4++;
      v9 = v7 & 1;
      v8 = v9 == 0;
      if ( v9 )
        v3->chain_exist[0] = 1;
      v3 = (all_parameters *)((char *)v3 + 4);
      if ( v9 )
        LOBYTE(v9) = v6[60];
      else
        v5->chain_exist[0] = 0;
      v5 = (all_parameters *)((char *)v5 + 4);
      if ( !v8 )
        v6[60] = v9 + 1;
    }
    while ( v4 != 16 );
  }
}
// 2EA78: variable 'v1' is possibly undefined
// 2EA78: variable 'v2' is possibly undefined

//----- (0002EA90) --------------------------------------------------------
void check_fan()
{
  int v0; // r7
  int v1; // r4
  char *v2; // r9
  unsigned int v3; // r2
  int v4; // r12
  all_parameters *v5; // r3
  unsigned int v6; // r0
  unsigned int fan_exist_map; // r2
  unsigned __int8 fan_num; // r10
  unsigned int v9; // r1
  unsigned __int8 v10; // r11
  int v11; // r1
  unsigned __int8 fan_id; // [sp+3h] [bp-2Dh] BYREF
  unsigned int fan_speed; // [sp+4h] [bp-2Ch] BYREF

  v0 = 2;
  fan_id = 0;
  do
  {
    v1 = 8;
    do
    {
      if ( get_fan_speed(&fan_id, &fan_speed) != -1 )
      {
        v3 = fan_speed;
        v4 = fan_id;
        v5 = dev;
        v6 = 120 * fan_speed;
        dev->fan_speed_value[fan_id] = 120 * fan_speed;
        if ( v3 )
        {
          v2 = (char *)&v5->temp[5] + 2;
          if ( !v5->fan_exist[v4] )
          {
            fan_exist_map = v5->fan_exist_map;
            fan_num = v5->fan_num;
            v5->fan_exist[v4] = 1;
            v5->fan_exist_map = fan_exist_map | (1 << v4);
            v5->fan_num = fan_num + 1;
          }
        }
        else
        {
          v2 = (char *)&v5->temp[5] + 2;
          if ( v5->fan_exist[v4] == 1 )
          {
            v9 = v5->fan_exist_map;
            v10 = v5->fan_num;
            v5->fan_exist[v4] = 0;
            if ( 1 << v4 )
              v11 = 0;
            else
              v11 = v9 & 1;
            v5->fan_exist_map = v11;
            v5->fan_num = v10 - 1;
          }
        }
        if ( v6 > *(_DWORD *)(v2 + 63) )
          *(_DWORD *)(v2 + 63) = v6;
      }
      --v1;
    }
    while ( v1 );
    --v0;
  }
  while ( v0 );
}

//----- (0002EB60) --------------------------------------------------------
void __fastcall set_PWM(unsigned __int8 pwm_percent)
{
  all_parameters *v1; // r2
  int v2; // r0

  if ( (int)pwm_percent >= 100 )
    *(_DWORD *)&pwm_percent = 100;
  v1 = dev;
  dev->pwm_percent = pwm_percent;
  v2 = ((-50 * pwm_percent + 5000) / 100) | ((int)pwm_percent >> 1 << 16);
  v1->pwm_value = v2;
  set_fan_control(v2);
}

//----- (0002EBA8) --------------------------------------------------------
void CheckChainTempTooLowFlag()
{
  int v0; // r3
  int v1; // r0
  all_parameters *v2; // r1
  int i; // r3

  v0 = 0;
  v1 = 0;
  v2 = dev;
  do
  {
    while ( dev->chain_exist[v0] != 1 )
    {
      if ( ++v0 == 16 )
        goto LABEL_7;
    }
    if ( !chain_temp_toolow[v0++] )
      v1 = 1;
  }
  while ( v0 != 16 );
LABEL_7:
  if ( !v1 )
  {
    for ( i = 0; i != 16; ++i )
    {
      if ( v2->chain_exist[i] == 1 )
        chain_temp_toolow[i] = 0;
    }
  }
}

//----- (0002EBF4) --------------------------------------------------------
int __fastcall get_pll_index(int freq)
{
  int v1; // r4
  unsigned __int8 freq_str[10]; // [sp+4h] [bp-1Ch] BYREF

  v1 = 0;
  sprintf((char *)freq_str, "%d", freq);
  while ( memcmp(freq_pll_1385[v1].freq, freq_str, 4u) )
  {
    if ( ++v1 == 114 )
      return -1;
  }
  return v1;
}

//----- (0002EC34) --------------------------------------------------------
int __fastcall get_freqvalue_by_index(int index)
{
  return j_strtol(*(const char **)&_PRETTY_FUNCTION___14401[16 * index + 56], 0, 10);
}

//----- (0002EC4C) --------------------------------------------------------
int GetTotalRate()
{
  int (*v0)[256]; // r9
  int v1; // r7
  int v2; // r10
  int *v3; // r6
  int v4; // r5
  int v5; // r4
  int *v6; // r3
  int v7; // r2
  int v8; // r1
  int *v9; // r7
  unsigned int v10; // r6
  int v11; // r0
  int v12; // r2
  int v13; // r0
  int v14; // r0
  int v15; // r2
  int *v17; // [sp+0h] [bp-38h]
  unsigned __int8 *v18; // [sp+4h] [bp-34h]
  int v19; // [sp+8h] [bp-30h]

  v0 = chain_badcore_num;
  v1 = 0;
  v17 = &CSWTCH_824;
  v2 = 0;
  v3 = &CSWTCH_825;
  do
  {
    if ( dev->chain_exist[v1] == 1 )
    {
      v4 = 0;
      v19 = v1;
      v5 = 0;
      v6 = (int *)(v1 - 1);
      v7 = 3 * (v1 / 3);
      v8 = v1 % 3;
      v9 = v3;
      v10 = (unsigned int)v6;
      v18 = &chain_pic_buf[v7][31 * v8];
      do
      {
        if ( fpga_version > 13 )
        {
          v11 = 11;
          if ( v10 <= 0xC )
            v6 = v17;
          v12 = 0;
          if ( v10 <= 0xC )
            v11 = *(v9 - 1);
          if ( v10 <= 0xC )
          {
            v12 = *(v6 - 1);
            v11 *= 31;
          }
          if ( v10 <= 0xC )
            v11 += 11;
          v13 = *((unsigned __int8 *)&h + 128 * v12 + v5 + v11 + 212);
        }
        else
        {
          v13 = v18[v5 + 11];
        }
        ++v5;
        v14 = strtol(*(const char **)&_PRETTY_FUNCTION___14401[16 * v13 + 56], 0, 10);
        v15 = (*v0)[v4++];
        v2 += v14 * (114 - v15);
      }
      while ( v5 != 18 );
      v3 = v9;
      v1 = v19;
    }
    ++v1;
    ++v0;
    ++v3;
    ++v17;
  }
  while ( v1 != 16 );
  return v2 / 1000;
}
// 2ECF2: variable 'v6' is possibly undefined
// 50464: using guessed type int CSWTCH_824;
// 50498: using guessed type int CSWTCH_825;

//----- (0002ED74) --------------------------------------------------------
int __fastcall GetBoardRate(int chainIndex)
{
  unsigned int v2; // r8
  int v3; // r5
  int *v4; // r11
  const unsigned __int8 *v5; // r10
  int v6; // r6
  int v7; // r4
  int v8; // r0
  int v9; // r2
  int v10; // r0
  int v11; // r0
  int v12; // r2
  unsigned __int8 *v13; // [sp+4h] [bp-2Ch]

  if ( dev->chain_exist[chainIndex] != 1 )
    return 0;
  v2 = chainIndex - 1;
  v3 = 0;
  v4 = chain_badcore_num[chainIndex];
  v5 = &_PRETTY_FUNCTION___14401[4 * chainIndex - 4];
  v6 = 0;
  v7 = 0;
  v13 = &chain_pic_buf[3 * (chainIndex / 3)][31 * (chainIndex % 3)];
  do
  {
    if ( fpga_version > 13 )
    {
      v8 = 11;
      v9 = 0;
      if ( v2 <= 0xC )
      {
        v8 = *((_DWORD *)v5 + 635);
        v9 = *((_DWORD *)v5 + 622);
      }
      if ( v2 <= 0xC )
        v8 *= 31;
      if ( v2 <= 0xC )
        v8 += 11;
      v10 = *((unsigned __int8 *)&h + 128 * v9 + v7 + v8 + 212);
    }
    else
    {
      v10 = v13[v7 + 11];
    }
    ++v7;
    v11 = strtol(*(const char **)&_PRETTY_FUNCTION___14401[16 * v10 + 56], 0, 10);
    v12 = v4[v3++];
    v6 += v11 * (114 - v12);
  }
  while ( v7 != 18 );
  return v6 / 1000;
}

//----- (0002EE68) --------------------------------------------------------
bool isChainEnough()
{
  int v0; // r3
  int v1; // r0
  char *v2; // r2

  v0 = 0;
  v1 = 0;
  do
  {
    v2 = (char *)dev + v0;
    v0 += 4;
    if ( *((_DWORD *)v2 + 2) == 1 )
      ++v1;
  }
  while ( v0 != 64 );
  return v1 > 8;
}

//----- (0002EE90) --------------------------------------------------------
void __fastcall writeInitLogFile(unsigned __int8 *logstr)
{
  FILE *v2; // r4
  size_t v3; // r0

  pthread_mutex_lock(&init_log_mutex);
  v2 = fopen("/tmp/freq", "a+");
  if ( v2 )
  {
    v3 = strlen((const char *)logstr);
    fwrite(logstr, 1u, v3, v2);
    fclose(v2);
  }
  j_pthread_mutex_unlock(&init_log_mutex);
}

//----- (0002EED4) --------------------------------------------------------
int DownOneChipFreqOneStep()
{
  int BoardRate; // r7
  int v1; // r4
  int v2; // r5
  int v3; // r0
  const unsigned __int8 *v4; // r3
  const unsigned __int8 *v5; // r0
  int v6; // r6
  unsigned int v7; // r12
  int v8; // r1
  const unsigned __int8 *v9; // r10
  int v10; // r2
  int v11; // r11
  int v12; // r7
  int v13; // r8
  int v14; // r7
  char *v15; // r8
  uint64_t *v16; // r7
  int v17; // r0
  int result; // r0
  unsigned int v19; // r5
  bool v20; // cc
  int v21; // r2
  int v22; // [sp+4h] [bp-12Ch]
  unsigned __int8 logstr[256]; // [sp+8h] [bp-128h] BYREF

  BoardRate = 0;
  v1 = 0;
  v2 = -1;
  do
  {
    while ( 1 )
    {
      if ( dev->chain_exist[v1] == 1 )
      {
        if ( dev->chain_asic_num[v1] != 18 )
          return 0;
        if ( !BoardRate || GetBoardRate(v1) > BoardRate )
          break;
      }
      if ( ++v1 == 16 )
        goto LABEL_8;
    }
    v3 = v1;
    v2 = v1++;
    BoardRate = GetBoardRate(v3);
  }
  while ( v1 != 16 );
LABEL_8:
  if ( v2 == -1 )
  {
    sprintf((char *)logstr, "Fatal Error: DownOneChipFreqOneStep has Wrong chain index=%d\n", -1);
    writeInitLogFile(logstr);
    return 0;
  }
  v4 = (const unsigned __int8 *)&dev->temp[5] + v2 + 2;
  v5 = (const unsigned __int8 *)dev->chain_asic_num[v2];
  if ( !dev->chain_asic_num[v2] )
    goto LABEL_49;
  v6 = (int)chain_pic_buf;
  v7 = v2 - 1;
  v8 = 0;
  v9 = &_PRETTY_FUNCTION___14401[4 * v2 - 4];
  v10 = -1;
  v4 = 0;
  v11 = 384 * (v2 / 3);
  v12 = 31 * (v2 % 3);
  v13 = v11 + v12;
  v14 = v12 + 11;
  v22 = v14;
  v15 = (char *)chain_pic_buf + v13;
  do
  {
    while ( fpga_version > 13 )
    {
      if ( v7 > 0xC )
        v14 = 0;
      else
        v6 = *((_DWORD *)v9 + 635);
      if ( v7 > 0xC )
        v6 = 11;
      else
        v14 = *((_DWORD *)v9 + 622);
      if ( v7 <= 0xC )
        v6 *= 31;
      v16 = &h + 16 * v14;
      if ( v7 <= 0xC )
        v6 += 11;
      v14 = (int)&v4[(_DWORD)v16];
      v6 += v14;
      if ( v8 )
      {
        v6 = *(unsigned __int8 *)(v6 + 212);
        if ( v6 <= v8 )
          goto LABEL_24;
LABEL_29:
        v8 = v6;
        goto LABEL_23;
      }
      v8 = *(unsigned __int8 *)(v6 + 212);
LABEL_23:
      v10 = (int)v4;
LABEL_24:
      if ( v5 == ++v4 )
        goto LABEL_32;
    }
    if ( !v8 )
    {
      v8 = v4[(_DWORD)v15 + 11];
      goto LABEL_23;
    }
    v6 = v4[(_DWORD)v15 + 11];
    if ( v6 > v8 )
      goto LABEL_29;
    ++v4;
  }
  while ( v5 != v4 );
LABEL_32:
  v17 = v10 + 1;
  if ( v10 == -1 )
  {
LABEL_49:
    sprintf((char *)logstr, "Fatal Error: DownOneChipFreqOneStep Chain[%d] has Wrong chip index=%d\n", -1, v4);
    writeInitLogFile(logstr);
    return 0;
  }
  if ( v8 <= 4 )
  {
    sprintf((char *)logstr, "Fatal Error: DownOneChipFreqOneStep Chain[%d] has no chip can down freq!!!\n", v2);
    writeInitLogFile(logstr);
    return 0;
  }
  else if ( fpga_version > 13 )
  {
    v19 = v2 - 1;
    v20 = v19 > 0xC;
    if ( v19 > 0xC )
    {
      v8 = 0;
      v17 = 11;
    }
    else
    {
      v4 = _PRETTY_FUNCTION___14401;
    }
    if ( v19 <= 0xC )
      v19 = (unsigned int)&v4[4 * v19];
    if ( !v20 )
    {
      v8 = *(_DWORD *)(v19 + 2488);
      v17 = 31 * *(_DWORD *)(v19 + 2540);
    }
    if ( !v20 )
      v17 += 11;
    v21 = v10 + v17;
    result = 1;
    --*((_BYTE *)&h + 128 * v8 + v21 + 212);
  }
  else
  {
    result = 1;
    --*((_BYTE *)&h + v11 + v10 + v22 + 212);
  }
  return result;
}

//----- (0002F0A4) --------------------------------------------------------
void __fastcall set_BC_write_command(unsigned int value)
{
  int v1; // r4
  char v2[272]; // [sp+0h] [bp-110h] BYREF

  axi_fpga_addr[48] = value;
  if ( (value & 0x80000000) != 0 )
  {
    v1 = 3001;
    while ( (get_BC_write_command() & 0x80000000) != 0 )
    {
      cgsleep_ms(1);
      if ( !--v1 )
      {
        strcpy(v2, "Error: set_BC_write_command wait buffer ready timeout!\n");
        writeInitLogFile((unsigned __int8 *)v2);
        return;
      }
    }
  }
  else
  {
    get_BC_write_command();
  }
}

//----- (0002F100) --------------------------------------------------------
void __fastcall bitmain_c5_shutdown(thr_info *thr)
{
  unsigned int v1; // r0
  unsigned int dhash_acc_control; // r0

  thr_info_cancel(check_system_work_id);
  thr_info_cancel(read_nonce_reg_id);
  thr_info_cancel(read_temp_id);
  thr_info_cancel(pic_heart_beat);
  thr_info_cancel(send_mac_thr);
  v1 = get_BC_write_command();
  set_BC_write_command(v1 & 0xFFBFFFFF);
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
}

//----- (0002F164) --------------------------------------------------------
void __fastcall set_frequency_with_addr_plldatai(
        int pllindex,
        unsigned __int8 mode,
        unsigned __int8 addr,
        unsigned __int8 chain)
{
  int v4; // r7
  int v5; // r8
  unsigned int v6; // r4
  unsigned int v7; // r5
  int v8; // r6
  int v9; // r0
  signed int v10; // r4
  unsigned int v11; // r5
  int v12; // r0
  unsigned int v13; // r0
  int v14; // r0
  unsigned int v15; // r0
  unsigned __int8 buf[9]; // [sp+0h] [bp-38h] BYREF
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-2Ch] BYREF

  v4 = addr;
  v5 = chain;
  v6 = opt_multi_version;
  v7 = *(_DWORD *)&_PRETTY_FUNCTION___14401[16 * pllindex + 68];
  if ( opt_multi_version )
  {
    buf[8] = 0;
    memset(cmd_buf, 0, sizeof(cmd_buf));
    if ( mode )
    {
      v8 = 1476984844;
      buf[0] = 88;
    }
    else
    {
      v8 = 1208549388;
      buf[0] = 72;
    }
    buf[7] = v7;
    buf[5] = BYTE2(v7);
    buf[4] = HIBYTE(v7);
    buf[6] = BYTE1(v7);
    buf[2] = addr;
    buf[3] = 12;
    buf[1] = 9;
    v9 = CRC5(buf, 0x40u);
    buf[8] = v9;
    cmd_buf[0] = v8 | (v4 << 8);
    cmd_buf[2] = v9 << 24;
    cmd_buf[1] = (BYTE2(v7) << 16) | (HIBYTE(v7) << 24) | (unsigned __int8)v7 | (BYTE1(v7) << 8);
    while ( 1 )
    {
      v10 = get_BC_write_command();
      if ( v10 >= 0 )
        break;
      cgsleep_us(500LL);
    }
    set_BC_command_buffer(cmd_buf);
    set_BC_write_command((v5 << 16) | 0x80800000 | v10 & 0xFFF0FFFF);
    cgsleep_us(10000LL);
  }
  else
  {
    *(_DWORD *)buf = opt_multi_version;
    *(_DWORD *)&buf[4] = opt_multi_version;
    buf[0] = 7;
    v11 = (chain << 16) | 0x80800000;
    buf[8] = opt_multi_version;
    cmd_buf[0] = opt_multi_version;
    cmd_buf[1] = opt_multi_version;
    cmd_buf[2] = opt_multi_version;
    v12 = CRC5(buf, 0x1Bu);
    buf[3] = v12;
    cmd_buf[0] = v12 | 0x7000000;
    set_BC_command_buffer(cmd_buf);
    v13 = get_BC_write_command();
    set_BC_write_command(v13 & 0xFFF0FFFF | v11);
    cgsleep_us(3000LL);
    *(_DWORD *)buf = v6;
    *(_DWORD *)&buf[4] = v6;
    buf[0] = -126;
    buf[8] = v6;
    cmd_buf[0] = v6;
    cmd_buf[1] = v6;
    cmd_buf[2] = v6;
    v14 = CRC5(buf, 0x1Bu);
    buf[3] = v14;
    cmd_buf[0] = v14 | 0x82000000;
    set_BC_command_buffer(cmd_buf);
    v15 = get_BC_write_command();
    set_BC_write_command(v15 & 0xFFF0FFFF | v11);
    cgsleep_us(5000LL);
  }
}

//----- (0002F2E8) --------------------------------------------------------
int bitmain_axi_Reinit()
{
  int v0; // r5
  unsigned __int8 logstr[256]; // [sp+0h] [bp-110h] BYREF

  v0 = *axi_fpga_addr;
  if ( (unsigned __int16)*axi_fpga_addr != 50433 )
  {
    sprintf((char *)logstr, "data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n", *axi_fpga_addr, 50433);
    writeInitLogFile(logstr);
  }
  sprintf((char *)logstr, "axi_fpga_addr data = 0x%x\n", v0);
  writeInitLogFile(logstr);
  nonce2_jobid_address = fpga_mem_addr;
  job_start_address_1 = fpga_mem_addr + 0x80000;
  job_start_address_2 = fpga_mem_addr + 540672;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  return 0;
}

//----- (0002F368) --------------------------------------------------------
void __fastcall set_reset_allhashboard(int resetBit)
{
  unsigned int v1; // r4
  unsigned int v2; // r4
  int v3; // r4
  unsigned __int8 logstr[256]; // [sp+0h] [bp-110h] BYREF

  v1 = axi_fpga_addr[13];
  if ( resetBit <= 0 )
    v2 = HIWORD(v1);
  else
    v2 = ~HIWORD(v1);
  if ( resetBit <= 0 )
    v3 = v2 << 16;
  else
    v3 = ~(v2 << 16);
  sprintf((char *)logstr, "set_reset_allhashboard = 0x%08x\n", v3);
  writeInitLogFile(logstr);
  axi_fpga_addr[13] = v3;
}

//----- (0002F3A8) --------------------------------------------------------
void __fastcall set_reset_hashboard(int chainIndex, int resetBit)
{
  int v2; // r0
  unsigned int v3; // r3
  int v4; // r5
  unsigned __int8 logstr[256]; // [sp+0h] [bp-110h] BYREF

  v2 = 1 << chainIndex;
  v3 = axi_fpga_addr[13];
  if ( resetBit <= 0 )
    v4 = v3 & ~v2;
  else
    v4 = v2 | v3;
  sprintf((char *)logstr, "set_reset_hashboard = 0x%08x\n", v4);
  writeInitLogFile(logstr);
  axi_fpga_addr[13] = v4;
}

//----- (0002F3E8) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_send_data_to_pic(unsigned __int8 which_iic, unsigned __int8 *buf)
{
  int v2; // r3
  int v3; // r4
  unsigned int v5; // r2
  __int16 v6; // r1
  unsigned int data; // r10
  unsigned __int8 v8; // r11
  int v9; // r7
  int v10; // r8
  int v11; // r6
  unsigned __int8 logstr[256]; // [sp+8h] [bp-128h] BYREF

  v2 = 0;
  v3 = which_iic;
  LOWORD(v5) = 22;
  do
  {
    v6 = buf[v2++];
    v5 = (unsigned __int16)(v5 + v6);
  }
  while ( v2 != 16 );
  data = v5 >> 8;
  v8 = v5;
  v9 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, v3, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, v3, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, v3, 0x14u);
    T9_plus_write_pic_iic(0, 0, 0, v3, 2u);
    T9_plus_write_pic_iic(0, 0, 0, v3, *buf);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[1]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[2]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[3]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[4]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[5]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[6]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[7]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[8]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[9]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[10]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[11]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[12]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[13]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[14]);
    T9_plus_write_pic_iic(0, 0, 0, v3, buf[15]);
    T9_plus_write_pic_iic(0, 0, 0, v3, data);
    T9_plus_write_pic_iic(0, 0, 0, v3, v8);
    usleep((__useconds_t)&off_30D40);
    v10 = T9_plus_write_pic_iic(1, 0, 0, v3, 0);
    v11 = T9_plus_write_pic_iic(1, 0, 0, v3, 0);
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n", (const char *)_FUNCTION___12508, v10, v11);
    usleep(0x186A0u);
    if ( v10 == 2 && v11 == 1 )
      break;
    sprintf((char *)logstr, "%s failed on Chain[%d]!\n", (const char *)_FUNCTION___12508, v3);
    writeInitLogFile(logstr);
    sleep(1u);
    if ( !--v9 )
      return 0;
  }
  printf("\n--- %s ok\n\n", (const char *)_FUNCTION___12508);
  return 1;
}
// 30D40: using guessed type char (*off_30D40)[16];

//----- (0002F644) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_erase_pic_app_program(unsigned __int8 which_iic)
{
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // r4
  unsigned __int8 logstr[256]; // [sp+8h] [bp-118h] BYREF

  v1 = which_iic;
  v2 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, v1, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, v1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 9u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0xDu);
    usleep(0x186A0u);
    v3 = T9_plus_write_pic_iic(1, 0, 0, v1, 0);
    v4 = T9_plus_write_pic_iic(1, 0, 0, v1, 0);
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n", (const char *)_FUNCTION___12490, v3, v4);
    usleep((__useconds_t)&off_30D40);
    if ( v3 == 9 && v4 == 1 )
      break;
    sprintf((char *)logstr, "%s failed on Chain[%d]!\n", _FUNCTION___12490, v1);
    writeInitLogFile(logstr);
    sleep(1u);
    if ( !--v2 )
      return 0;
  }
  printf("\n--- %s ok\n\n", (const char *)_FUNCTION___12490);
  return 1;
}
// 30D40: using guessed type char (*off_30D40)[16];

//----- (0002F740) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_enable_pic_dc_dc(unsigned __int8 which_iic, unsigned __int8 enable)
{
  unsigned int v2; // r11
  unsigned __int8 v3; // r10
  int v5; // r4
  int v6; // r5
  int v7; // r7
  int v8; // r12
  unsigned __int8 logstr[256]; // [sp+10h] [bp-128h] BYREF

  v2 = (unsigned int)(enable + 26) >> 8;
  v3 = enable + 26;
  v5 = which_iic;
  v6 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, v5, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, v5, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, v5, 5u);
    T9_plus_write_pic_iic(0, 0, 0, v5, 0x15u);
    T9_plus_write_pic_iic(0, 0, 0, v5, enable);
    T9_plus_write_pic_iic(0, 0, 0, v5, v2);
    T9_plus_write_pic_iic(0, 0, 0, v5, v3);
    usleep(0x2710u);
    v7 = T9_plus_write_pic_iic(1, 0, 0, v5, 0);
    v8 = T9_plus_write_pic_iic(1, 0, 0, v5, 0);
    if ( v7 == 21 && v8 == 1 )
      break;
    sprintf((char *)logstr, "%s failed on Chain[%d]!\n", _FUNCTION___12447, v5);
    writeInitLogFile(logstr);
    sleep(1u);
    if ( !--v6 )
      return 0;
  }
  printf("\n--- %s ok\n\n", (const char *)_FUNCTION___12447);
  return 1;
}

//----- (0002F844) --------------------------------------------------------
void __fastcall disable_pic_dac(unsigned __int8 chain)
{
  const unsigned __int8 *v1; // r2

  if ( fpga_version <= 13 )
  {
    if ( chain % 3u == 2 )
      dsPIC33EP16GS202_enable_pic_dc_dc(chain / 3u, 0);
  }
  else
  {
    if ( (unsigned int)(chain - 1) > 0xC )
      v1 = 0;
    else
      v1 = _PRETTY_FUNCTION___14401;
    if ( (unsigned int)(chain - 1) <= 0xC )
      v1 = *(const unsigned __int8 **)&v1[4 * chain + 2484];
    if ( (chain & 0xFD) == 9 || chain == 13 )
      dsPIC33EP16GS202_enable_pic_dc_dc((unsigned __int8)v1, 0);
  }
}

//----- (0002F8A0) --------------------------------------------------------
void __fastcall enable_pic_dac(unsigned __int8 chain)
{
  unsigned int v1; // r3

  v1 = chain;
  if ( fpga_version > 13 )
  {
    if ( (unsigned int)(chain - 1) > 2 )
      return;
LABEL_5:
    dsPIC33EP16GS202_enable_pic_dc_dc(chain, 1u);
    return;
  }
  *(_DWORD *)&chain = chain / 3u;
  if ( !(v1 % 3) )
    goto LABEL_5;
}

//----- (0002F8D8) --------------------------------------------------------
int __fastcall set_Voltage_S9_plus_plus_BM1387_54(unsigned __int8 which_iic, unsigned __int8 pic_voltage)
{
  int data; // r7
  int v3; // r4
  int v4; // r6
  int v5; // r8
  int v6; // r12
  unsigned __int8 logstr[256]; // [sp+10h] [bp-128h] BYREF

  data = pic_voltage;
  v3 = which_iic;
  printf("voltage1 = %d\n", pic_voltage);
  if ( (data & 0x80) != 0 )
  {
    printf(aSVoltage1D127, _FUNCTION___12352, data);
    return 0;
  }
  else
  {
    v4 = 3;
    while ( 1 )
    {
      T9_plus_write_pic_iic(0, 0, 0, v3, 0x55u);
      T9_plus_write_pic_iic(0, 0, 0, v3, 0xAAu);
      T9_plus_write_pic_iic(0, 0, 0, v3, 7u);
      T9_plus_write_pic_iic(0, 0, 0, v3, 0x10u);
      T9_plus_write_pic_iic(0, 0, 0, v3, data);
      T9_plus_write_pic_iic(0, 0, 0, v3, 0);
      T9_plus_write_pic_iic(0, 0, 0, v3, 0);
      T9_plus_write_pic_iic(0, 0, 0, v3, (unsigned __int16)(data + 23) >> 8);
      T9_plus_write_pic_iic(0, 0, 0, v3, data + 23);
      usleep(0x186A0u);
      v5 = T9_plus_write_pic_iic(1, 0, 0, v3, 0);
      v6 = T9_plus_write_pic_iic(1, 0, 0, v3, 0);
      if ( v5 == 16 && v6 == 1 )
        break;
      sprintf((char *)logstr, "%s failed on Chain[%d]!\n\n", _FUNCTION___12352, v3);
      writeInitLogFile(logstr);
      sleep(1u);
      if ( !--v4 )
        return 0;
    }
    printf("\n--- %s ok!\n\n", (const char *)_FUNCTION___12352);
    AT24C02_save_voltage(v3, data);
    return 1;
  }
}

//----- (0002FA24) --------------------------------------------------------
void __fastcall set_voltage_T9_18_into_PIC(unsigned __int8 chain, unsigned __int8 voltage)
{
  const unsigned __int8 *v2; // r3
  unsigned int v3; // r0
  bool v4; // cf
  bool v5; // zf

  v2 = (const unsigned __int8 *)fpga_version;
  if ( fpga_version <= 13 )
  {
    v3 = chain / 3u;
  }
  else
  {
    v3 = chain - 1;
    v4 = v3 >= 0xC;
    v5 = v3 == 12;
    if ( v3 > 0xC )
      v3 = 0;
    else
      v2 = _PRETTY_FUNCTION___14401;
    if ( v5 || !v4 )
      LOBYTE(v3) = v2[4 * v3 + 2488];
  }
  set_Voltage_S9_plus_plus_BM1387_54(v3, voltage);
}

//----- (0002FA5C) --------------------------------------------------------
void __fastcall set_pic_voltage_T9_18(unsigned __int8 chain)
{
  int v1; // r4
  int HighestVoltagePIC; // r0
  unsigned __int8 v3; // r6
  unsigned __int8 logstr[256]; // [sp+8h] [bp-118h] BYREF

  v1 = chain;
  HighestVoltagePIC = getHighestVoltagePIC(chain);
  v3 = HighestVoltagePIC;
  sprintf(
    (char *)logstr,
    "set voltage=%d on chain[%d], the real voltage=%d\n",
    10
  * ((int)((364.0704 / ((double)*((unsigned __int8 *)&bitmain_c5_drv + v1 + 124) + 30.72) + 32.79) * 100.0 / 4.75)
   / 10),
    v1,
    10 * ((int)((364.0704 / ((double)HighestVoltagePIC + 30.72) + 32.79) * 100.0 / 4.75) / 10));
  writeInitLogFile(logstr);
  set_voltage_T9_18_into_PIC(v1, v3);
}

//----- (0002FB40) --------------------------------------------------------
void __fastcall set_pic_voltage(unsigned __int8 chain, unsigned __int8 voltage)
{
  if ( fpga_version > 13 )
  {
    if ( (unsigned int)(chain - 1) > 2 )
      return;
LABEL_5:
    set_pic_voltage_T9_18(chain);
    return;
  }
  if ( !(chain % 3u) )
    goto LABEL_5;
}

//----- (0002FB74) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_reset_pic(unsigned __int8 which_iic)
{
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // r4
  unsigned __int8 logstr[256]; // [sp+8h] [bp-118h] BYREF

  v1 = which_iic;
  v2 = 3;
  printf("\n--- %s\n", (const char *)_FUNCTION___12251);
  printf("--- %s: which_iic=%d crc_data[0] = 0x%x, crc_data[1] = 0x%x\n", (const char *)_FUNCTION___12251, v1, 0, 11);
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, v1, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, v1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 7u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0xBu);
    usleep((__useconds_t)&last_job_buffer[4384]);
    v3 = T9_plus_write_pic_iic(1, 0, 0, v1, 0);
    v4 = T9_plus_write_pic_iic(1, 0, 0, v1, 0);
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n", (const char *)_FUNCTION___12251, v3, v4);
    usleep(0x186A0u);
    if ( v3 == 7 && v4 == 1 )
      break;
    sprintf((char *)logstr, "%s failed on Chain[%d]!\n", _FUNCTION___12251, v1);
    writeInitLogFile(logstr);
    sleep(1u);
    if ( !--v2 )
      return 0;
  }
  printf("\n--- %s ok\n\n", (const char *)_FUNCTION___12251);
  sleep(1u);
  return 1;
}

//----- (0002FC94) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_update_pic_app_program(unsigned __int8 which_iic)
{
  FILE *v2; // r0
  FILE *v3; // r7
  unsigned __int8 *v4; // r4
  unsigned int v5; // r0
  int i; // r8
  unsigned __int8 *v7; // r3
  int v8; // r4
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r1
  int v14; // r2
  unsigned __int8 data_read[7]; // [sp+0h] [bp-3730h] BYREF
  unsigned __int8 buf[16]; // [sp+8h] [bp-3728h] BYREF
  unsigned __int8 program_data[14080]; // [sp+18h] [bp-3718h] BYREF
  int v19; // [sp+3718h] [bp-18h] BYREF

  memset(program_data, 0, sizeof(program_data));
  data_read[1] = 0;
  data_read[2] = 0;
  data_read[3] = 0;
  data_read[4] = 0;
  data_read[5] = 0;
  data_read[6] = 0;
  data_read[0] = 0;
  memset(buf, 0, sizeof(buf));
  puts("\n--- update pic program");
  v2 = fopen("/etc/config/dsPIC33EP16GS202_app.txt", (const char *)"r");
  v3 = v2;
  if ( !v2 )
    return printf("\n%s: open hash_s8_app.txt failed\n", (const char *)_FUNCTION___12528);
  fseek(v2, 0, 0);
  v4 = program_data;
  memset(program_data, 0, sizeof(program_data));
  do
  {
    fgets((char *)data_read, 1023, v3);
    v5 = strtoul((const char *)data_read, 0, 16);
    v4[3] = v5;
    *v4 = HIBYTE(v5);
    v4[1] = BYTE2(v5);
    v4[2] = BYTE1(v5);
    v4 += 4;
  }
  while ( v4 != (unsigned __int8 *)&v19 );
  fclose(v3);
  if ( dsPIC33EP16GS202_reset_pic(which_iic) )
  {
    if ( dsPIC33EP16GS202_erase_pic_app_program(which_iic) )
    {
      for ( i = 0; i != 880; ++i )
      {
        v7 = &program_data[16 * i];
        v8 = 0;
        v9 = *(_DWORD *)v7;
        v10 = *((_DWORD *)v7 + 1);
        v11 = *((_DWORD *)v7 + 2);
        v12 = *((_DWORD *)v7 + 3);
        *(_DWORD *)buf = v9;
        *(_DWORD *)&buf[4] = v10;
        *(_DWORD *)&buf[8] = v11;
        *(_DWORD *)&buf[12] = v12;
        printf("send pic program time: %d\n", i);
        do
        {
          v13 = v8;
          v14 = buf[v8++];
          printf("buf[%d] = 0x%02x\n", v13, v14);
        }
        while ( v8 != 16 );
        putchar(10);
        if ( !dsPIC33EP16GS202_send_data_to_pic(which_iic, buf) )
        {
          printf("!!! %s: send flash data error!\n\n", (const char *)_FUNCTION___12528);
          return 0;
        }
      }
      if ( !dsPIC33EP16GS202_reset_pic(which_iic) )
        goto LABEL_13;
      return 1;
    }
    else
    {
      printf("!!! %s: erase flash error!\n\n", (const char *)_FUNCTION___12528);
      return 0;
    }
  }
  else
  {
LABEL_13:
    printf(aSResetPicError, _FUNCTION___12528);
    return 0;
  }
}

//----- (0002FE04) --------------------------------------------------------
unsigned __int8 __fastcall reset_iic_pic(unsigned __int8 chain)
{
  unsigned int v1; // r3

  v1 = chain;
  if ( fpga_version <= 13 )
  {
    *(_DWORD *)&chain = chain / 3u;
    if ( v1 % 3 )
      return 1;
  }
  else if ( (unsigned int)(chain - 1) > 2 )
  {
    return 1;
  }
  return dsPIC33EP16GS202_reset_pic(chain);
}

//----- (0002FE40) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_jump_to_app_from_loader(unsigned __int8 which_iic)
{
  int v1; // r4
  int v2; // r5
  int v3; // r7
  int v4; // r8
  unsigned __int8 logstr[256]; // [sp+8h] [bp-120h] BYREF

  v1 = which_iic;
  v2 = 3;
  printf("\n--- %s\n", (const char *)_FUNCTION___12238);
  printf("--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n", (const char *)_FUNCTION___12238, 0, 10);
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, v1, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, v1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 6u);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0);
    T9_plus_write_pic_iic(0, 0, 0, v1, 0xAu);
    usleep(0x186A0u);
    v3 = T9_plus_write_pic_iic(1, 0, 0, v1, 0);
    v4 = T9_plus_write_pic_iic(1, 0, 0, v1, 0);
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n", (const char *)_FUNCTION___12238, v3, v4);
    if ( v3 == 6 && v4 == 1 )
      break;
    sprintf((char *)logstr, "%s failed on Chain[%d]!\n", _FUNCTION___12238, v1);
    writeInitLogFile(logstr);
    sleep(1u);
    if ( !--v2 )
      return 0;
  }
  sleep(1u);
  printf("\n--- %s ok\n\n", (const char *)_FUNCTION___12238);
  return 1;
}

//----- (0002FF54) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_get_pic_sw_version(unsigned __int8 which_iic, unsigned __int8 *version)
{
  int v2; // r4
  int v3; // r5
  int v4; // r7
  int v5; // r6
  __int16 v6; // r9
  int v7; // r10
  int v8; // r11
  unsigned __int8 logstr[256]; // [sp+10h] [bp-128h] BYREF

  v2 = which_iic;
  v3 = 3;
  printf("\n--- %s\n", (const char *)_FUNCTION___12219);
  *version = -1;
  printf("--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n", (const char *)_FUNCTION___12219, 0, 27);
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, v2, 0x55u);
    T9_plus_write_pic_iic(0, 0, 0, v2, 0xAAu);
    T9_plus_write_pic_iic(0, 0, 0, v2, 4u);
    T9_plus_write_pic_iic(0, 0, 0, v2, 0x17u);
    T9_plus_write_pic_iic(0, 0, 0, v2, 0);
    T9_plus_write_pic_iic(0, 0, 0, v2, 0x1Bu);
    usleep(0x186A0u);
    v4 = T9_plus_write_pic_iic(1, 0, 0, v2, 0);
    v5 = T9_plus_write_pic_iic(1, 0, 0, v2, 0);
    v6 = T9_plus_write_pic_iic(1, 0, 0, v2, 0);
    v7 = T9_plus_write_pic_iic(1, 0, 0, v2, 0);
    v8 = T9_plus_write_pic_iic(1, 0, 0, v2, 0);
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n", (const char *)_FUNCTION___12219, v4, v5);
    usleep(0x186A0u);
    if ( v5 == 23 && v4 == 5 )
      break;
    sprintf((char *)logstr, "%s failed on Chain[%d]!\n", (const char *)_FUNCTION___12219, v2);
    writeInitLogFile(logstr);
    sleep(1u);
LABEL_5:
    if ( !--v3 )
      return 0;
  }
  if ( v7 != (unsigned __int16)(v6 + 28) >> 8 || v8 != (unsigned __int8)(v6 + 28) )
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___12219);
    sleep(1u);
    goto LABEL_5;
  }
  *version = v6;
  printf("\n--- %s ok\n\n", (const char *)_FUNCTION___12219);
  return 1;
}

//----- (000300DC) --------------------------------------------------------
void __fastcall get_pic_software_version(unsigned __int8 chain, unsigned __int8 *version)
{
  const unsigned __int8 *v2; // r3
  unsigned int v3; // r0
  bool v4; // cf
  bool v5; // zf

  v2 = (const unsigned __int8 *)fpga_version;
  if ( fpga_version <= 13 )
  {
    v3 = chain / 3u;
  }
  else
  {
    v3 = chain - 1;
    v4 = v3 >= 0xC;
    v5 = v3 == 12;
    if ( v3 > 0xC )
      v3 = 0;
    else
      v2 = _PRETTY_FUNCTION___14401;
    if ( v5 || !v4 )
      LOBYTE(v3) = v2[4 * v3 + 2488];
  }
  dsPIC33EP16GS202_get_pic_sw_version(v3, version);
}

//----- (00030114) --------------------------------------------------------
void __fastcall jump_to_app_CheckAndRestorePIC_T9_18(int chainIndex)
{
  int v2; // r0
  unsigned __int8 v3; // r8
  int v4; // r7
  int v5; // r8
  unsigned __int8 v6; // [sp+7h] [bp-121h] BYREF
  unsigned __int8 logstr[256]; // [sp+8h] [bp-120h] BYREF

  if ( fpga_version <= 13 )
  {
    v2 = chainIndex / 3;
    if ( chainIndex == 3 * (chainIndex / 3) )
    {
      v3 = v2;
      sprintf((char *)logstr, "chain[%d] PIC jump to app\n", chainIndex);
      writeInitLogFile(logstr);
      dsPIC33EP16GS202_jump_to_app_from_loader(v3);
      get_pic_software_version(chainIndex, &v6);
      sprintf((char *)logstr, "Check chain[%d] PIC fw version=0x%02x\n", chainIndex, v6);
      writeInitLogFile(logstr);
      if ( v6 != 3 )
      {
        v4 = 2;
        do
        {
          sprintf((char *)logstr, "chain[%d] PIC need restore ...\n", chainIndex);
          writeInitLogFile(logstr);
          dsPIC33EP16GS202_update_pic_app_program(v3);
          dsPIC33EP16GS202_jump_to_app_from_loader(v3);
          get_pic_software_version(chainIndex, &v6);
          sprintf((char *)logstr, "After restore: chain[%d] PIC fw version=0x%02x\n", chainIndex, v6);
          writeInitLogFile(logstr);
          if ( v6 == 3 )
            break;
          --v4;
        }
        while ( v4 );
      }
    }
  }
  else if ( (unsigned int)(chainIndex - 1) <= 2 )
  {
    sprintf((char *)logstr, "chain[%d] PIC jump to app\n", chainIndex);
    writeInitLogFile(logstr);
    dsPIC33EP16GS202_jump_to_app_from_loader(chainIndex);
    get_pic_software_version(chainIndex, &v6);
    sprintf((char *)logstr, "Check chain[%d] PIC fw version=0x%02x\n", chainIndex, v6);
    writeInitLogFile(logstr);
    if ( v6 != 3 )
    {
      v5 = 2;
      do
      {
        sprintf((char *)logstr, "chain[%d] PIC need restore ...\n", chainIndex);
        writeInitLogFile(logstr);
        dsPIC33EP16GS202_update_pic_app_program(chainIndex);
        dsPIC33EP16GS202_jump_to_app_from_loader(chainIndex);
        get_pic_software_version(chainIndex, &v6);
        sprintf((char *)logstr, "After restore: chain[%d] PIC fw version=0x%02x\n", chainIndex, v6);
        writeInitLogFile(logstr);
        if ( v6 == 3 )
          break;
        --v5;
      }
      while ( v5 );
    }
  }
}

//----- (0003026C) --------------------------------------------------------
void __fastcall set_pic_iic_flash_addr_pointer(unsigned __int8 chain, unsigned __int8 addr_H, unsigned __int8 addr_L)
{
  int v3; // r4
  int data; // r5
  int v5; // r7
  int v6; // r6
  unsigned __int8 check_addr_H; // [sp+16h] [bp-11Ah] BYREF
  unsigned __int8 check_addr_L; // [sp+17h] [bp-119h] BYREF
  unsigned __int8 logstr[256]; // [sp+18h] [bp-118h] BYREF

  v3 = chain;
  data = addr_H;
  v5 = addr_L;
  v6 = 4;
  while ( 1 )
  {
    send_pic_command(v3);
    write_pic_iic(0, 0, 0, v3, 1u);
    write_pic_iic(0, 0, 0, v3, data);
    write_pic_iic(0, 0, 0, v3, v5);
    get_pic_iic_flash_addr_pointer(v3, &check_addr_H, &check_addr_L);
    if ( check_addr_H == data && check_addr_L == v5 )
      break;
    sprintf(
      (char *)logstr,
      "Error of set PIC FLASH addr: addr_H=%x(%x) addr_L=%x(%x) on Chain[%d]\n",
      data,
      check_addr_H,
      v5,
      check_addr_L,
      v3);
    writeInitLogFile(logstr);
    if ( !--v6 )
      break;
    reset_iic_pic(v3);
    sleep(5u);
  }
}

//----- (00030300) --------------------------------------------------------
unsigned __int8 __fastcall erase_pic_flash_all(unsigned __int8 chain)
{
  int v1; // r4
  unsigned __int8 result; // r0

  v1 = 100;
  set_pic_iic_flash_addr_pointer(chain, 3u, 0);
  do
  {
    result = erase_pic_flash(chain);
    --v1;
  }
  while ( v1 );
  return result;
}

//----- (0003031C) --------------------------------------------------------
void clearInitLogFile()
{
  FILE *v0; // r0
  FILE *v1; // r0
  FILE *v2; // r0
  FILE *v3; // r0

  pthread_mutex_lock(&init_log_mutex);
  v0 = fopen("/tmp/freq", "w");
  if ( v0 )
    fclose(v0);
  if ( opt_fixed_freq )
  {
    v1 = fopen("/tmp/search", "w");
    if ( v1 )
      fclose(v1);
    v2 = fopen("/tmp/freq", "w");
    if ( v2 )
      fclose(v2);
    v3 = fopen("/tmp/lasttemp", "w");
    if ( v3 )
      fclose(v3);
  }
  j_pthread_mutex_unlock(&init_log_mutex);
}

//----- (0003038C) --------------------------------------------------------
void __fastcall set_frequency(unsigned __int16 frequency)
{
  int (*v1)[256]; // r4
  unsigned int v2; // r7
  int v3; // r5
  int *v4; // r9
  int *v5; // r12
  int v6; // r6
  int v7; // r8
  int ChainPICMagicNumber; // r0
  int v9; // r3
  unsigned __int8 *v10; // r1
  unsigned __int8 *v11; // lr
  int j; // r3
  unsigned __int8 *v13; // r2
  int v14; // r3
  uint64_t *v15; // r3
  int m; // r3
  int k; // r3
  int v18; // r5
  int v19; // r3
  all_parameters *v20; // r4
  int v21; // r1
  char *v22; // r2
  all_parameters *v23; // r8
  unsigned __int8 *jj; // r7
  unsigned int v25; // r3
  unsigned __int8 *v26; // r0
  unsigned __int8 *v27; // r1
  int v28; // r9
  unsigned int v29; // r5
  int v30; // s13
  int v31; // r4
  int v32; // r6
  int v33; // r2
  int v34; // r6
  int v35; // r4
  int v36; // r7
  int v37; // r5
  int v38; // r9
  int v39; // lr
  char *v40; // r3
  unsigned int v41; // r2
  char *v42; // r8
  int v43; // lr
  int v44; // r0
  int v45; // r8
  int v46; // r5
  int v47; // r4
  char *v48; // r3
  unsigned int v49; // r2
  char *v50; // r9
  int v51; // lr
  int v52; // r0
  unsigned __int16 v53; // r0
  int v54; // r4
  all_parameters *v55; // r11
  int mm; // r4
  unsigned int v57; // r3
  unsigned __int8 *v58; // r0
  unsigned __int8 *v59; // r1
  int v60; // lr
  int i; // r3
  unsigned __int8 *v62; // r2
  unsigned __int8 *v63; // r1
  int v64; // r3
  uint64_t *v65; // r3
  unsigned __int8 v66; // r2
  unsigned __int8 v67; // r0
  unsigned __int8 v68; // r1
  unsigned __int8 v69; // r2
  unsigned __int8 v70; // r3
  int v71; // r3
  int v72; // r9
  all_parameters **v73; // r6
  int v74; // s13
  int v75; // r4
  int v76; // r5
  int v77; // r3
  int v78; // r7
  uint64_t *v79; // r3
  unsigned __int8 *v80; // r1
  int v81; // r3
  uint64_t *v82; // r3
  unsigned __int8 v83; // r2
  unsigned __int8 v84; // r0
  unsigned __int8 v85; // r1
  unsigned __int8 v86; // r2
  unsigned __int8 v87; // r3
  int *v88; // r6
  int *v89; // r5
  int v90; // r4
  int v91; // r3
  int v92; // r5
  int v93; // r7
  int v94; // r6
  int v95; // r8
  int v96; // r4
  char *v97; // r3
  unsigned int v98; // r2
  int v99; // lr
  int v100; // r3
  int v101; // r0
  int v102; // r3
  int v103; // r8
  int n; // r1
  unsigned int v105; // lr
  const unsigned __int8 *v106; // r12
  int v107; // r7
  int v108; // r2
  int *v109; // r6
  int ii; // r3
  int v111; // r0
  int v112; // r4
  uint64_t *v113; // r4
  int v114; // r3
  int v115; // r4
  int v116; // r7
  int v117; // r9
  int v118; // r7
  char *v119; // r3
  unsigned int v120; // r2
  int v121; // lr
  int TotalRate; // r7
  int v123; // r0
  int v124; // r0
  int v125; // r4
  int v126; // r1
  unsigned int v127; // r12
  int v128; // r2
  const unsigned __int8 *v129; // r8
  int v130; // lr
  int *v131; // r7
  int kk; // r3
  int v133; // r0
  int v134; // r5
  uint64_t *v135; // r5
  int v136; // r2
  int v137; // r8
  int v138; // r7
  int (*v139)[256]; // r6
  int v140; // r4
  int v141; // r5
  unsigned int v142; // r3
  int v143; // r3
  int v144; // r3
  int v145; // r8
  int (*v146)[256]; // r6
  int v147; // r4
  int v148; // r7
  char *v149; // r5
  unsigned int v150; // r3
  int v151; // r3
  int v152; // r12
  int (*v153)[256]; // r1
  int v154; // r7
  int v155; // r6
  unsigned int v156; // r8
  int v157; // r2
  int v158; // r3
  unsigned __int8 *v159; // r5
  int v160; // r4
  int v161; // r0
  int v162; // r7
  uint64_t *v163; // r4
  char *v164; // r4
  unsigned __int8 *v165; // r4
  int v166; // r0
  int v167; // r8
  int v168; // r9
  int v169; // r7
  int (*v170)[256]; // r1
  int v171; // r2
  int v172; // r3
  int v173; // r0
  int v174; // r4
  uint64_t *v175; // r4
  unsigned int *v176; // [sp+0h] [bp-9C8h]
  int *v177; // [sp+30h] [bp-998h]
  int *v178; // [sp+30h] [bp-998h]
  int *v179; // [sp+30h] [bp-998h]
  int *v180; // [sp+30h] [bp-998h]
  int *v181; // [sp+30h] [bp-998h]
  int *v182; // [sp+30h] [bp-998h]
  uint64_t *v183; // [sp+34h] [bp-994h]
  int max_freq_index; // [sp+38h] [bp-990h]
  int *max_freq_indexa; // [sp+38h] [bp-990h]
  int max_freq_indexb; // [sp+38h] [bp-990h]
  unsigned int max_freq_indexc; // [sp+38h] [bp-990h]
  uint64_t *v188; // [sp+3Ch] [bp-98Ch]
  _BOOL4 v189; // [sp+3Ch] [bp-98Ch]
  all_parameters *v190; // [sp+3Ch] [bp-98Ch]
  int type; // [sp+40h] [bp-988h]
  unsigned __int8 typea; // [sp+40h] [bp-988h]
  int typeb; // [sp+40h] [bp-988h]
  all_parameters *typec; // [sp+40h] [bp-988h]
  int v195; // [sp+44h] [bp-984h]
  int v196; // [sp+44h] [bp-984h]
  unsigned int v197; // [sp+44h] [bp-984h]
  _BOOL4 v198; // [sp+44h] [bp-984h]
  int v199; // [sp+48h] [bp-980h]
  int *v200; // [sp+48h] [bp-980h]
  unsigned int v201; // [sp+48h] [bp-980h]
  unsigned int v202; // [sp+48h] [bp-980h]
  unsigned __int8 *v203; // [sp+4Ch] [bp-97Ch]
  int v204; // [sp+4Ch] [bp-97Ch]
  int v205; // [sp+4Ch] [bp-97Ch]
  int v206; // [sp+4Ch] [bp-97Ch]
  int *v207; // [sp+50h] [bp-978h]
  int *v208; // [sp+54h] [bp-974h]
  unsigned __int8 default_freq_index; // [sp+58h] [bp-970h]
  unsigned __int8 *v210; // [sp+5Ch] [bp-96Ch]
  uint16_t reg_data_pll2; // [sp+66h] [bp-962h] BYREF
  unsigned int reg_data_pll; // [sp+68h] [bp-960h] BYREF
  unsigned int reg_data_vil; // [sp+6Ch] [bp-95Ch] BYREF
  unsigned __int8 minerMAC[6]; // [sp+70h] [bp-958h] BYREF
  unsigned __int8 hashMAC[6]; // [sp+78h] [bp-950h] BYREF
  unsigned __int8 logstr[256]; // [sp+80h] [bp-948h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+180h] [bp-848h] BYREF

  reg_data_pll = 0;
  reg_data_pll2 = 0;
  reg_data_vil = 0;
  type = frequency;
  default_freq_index = get_pll_index(frequency);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "\n--- %s\n", (const char *)_FUNCTION___13127);
    applog(7, tmp42, 0);
  }
  get_plldata(type, (int)&reg_data_pll, (unsigned int *)&reg_data_pll2, (uint16_t *)&reg_data_vil, v176);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: frequency = %d\n", (const char *)_FUNCTION___13127, type);
    applog(7, tmp42, 0);
  }
  v1 = chain_badcore_num;
  v2 = -1;
  v207 = CSWTCH_824;
  v208 = CSWTCH_825;
  v3 = 1;
  v4 = CSWTCH_824;
  v5 = CSWTCH_825;
  do
  {
    v6 = v3 + 1;
    v7 = v3 - 1;
    if ( *(&dev->pwm_value + v3) == 1 && dev->chain_asic_num[v7] )
    {
      if ( opt_fixed_freq
        || (v177 = v5, ChainPICMagicNumber = getChainPICMagicNumber(v3 - 1), v5 = v177, ChainPICMagicNumber != 125) )
      {
        isUseDefaultFreq = 1;
        if ( fpga_version <= 13 )
        {
          v60 = v3 - 1;
          *((_BYTE *)&h + 384 * (v7 / 3) + 212) = 125;
          do
          {
            for ( i = 0; i != 18; ++i )
            {
              v62 = &chain_pic_buf[3 * (v60 / 3)][31 * (v60 % 3) + i];
              v62[11] = default_freq_index;
            }
            ++v60;
          }
          while ( v60 != v3 + 2 );
        }
        else
        {
          if ( v2 > 0xC )
            v9 = 0;
          else
            v9 = *(v4 - 1);
          chain_pic_buf[v9][0] = 125;
          v10 = chain_pic_buf[v9];
          v11 = &chain_pic_buf[v9][93];
          do
          {
            for ( j = 0; j != 18; ++j )
            {
              v13 = &v10[j];
              v13[11] = default_freq_index;
            }
            v10 += 31;
          }
          while ( v10 != v11 );
        }
        v178 = v5;
        sprintf((char *)logstr, "Chain[J%d] has no freq in PIC, set default freq=%dM\n", v3, type);
        writeInitLogFile(logstr);
        v5 = v178;
      }
      if ( fpga_version <= 13 )
      {
        v188 = &h + 48 * (v7 / 3);
        if ( *((_BYTE *)v188 + 212) == 125 && !isUseDefaultFreq )
        {
          v182 = v5;
          v198 = isUseDefaultFreq;
          sprintf((char *)logstr, "Chain[J%d] has core num in PIC\n", v3);
          writeInitLogFile(logstr);
          v144 = v7 % 3;
          v145 = v198;
          v202 = v2;
          v206 = v3 + 1;
          v146 = v1;
          v147 = v3;
          v148 = v198;
          v149 = (char *)v188 + 31 * v144 + 29;
          do
          {
            v150 = (unsigned __int8)v149[(v145 >> 1) + 212];
            if ( (v145 & 1) != 0 )
              v151 = v150 & 0xF;
            else
              v151 = v150 >> 4;
            *(_DWORD *)((char *)v146 + v148) = v151;
            if ( v151 )
            {
              sprintf((char *)logstr, "Chain[J%d] ASIC[%d] has core num=%d\n", v147, v145, v151);
              writeInitLogFile(logstr);
            }
            ++v145;
            v148 += 4;
          }
          while ( v145 != 18 );
          v1 = v146;
          v2 = v202;
          v5 = v182;
          v6 = v206;
        }
        else
        {
          v180 = v5;
          sprintf((char *)logstr, "Chain[J%d] has no core num in PIC\n", v3);
          writeInitLogFile(logstr);
          v5 = v180;
          for ( k = 0; k != 18; ++k )
            (*v1)[k] = 0;
        }
      }
      else
      {
        if ( v2 > 0xC )
        {
          v7 = 0;
          v14 = 0;
        }
        else
        {
          v14 = *(v4 - 1);
        }
        if ( v2 <= 0xC )
          v7 = *(v5 - 1);
        v15 = &h + 16 * v14;
        if ( *((_BYTE *)v15 + 212) == 125 && !isUseDefaultFreq )
        {
          v183 = v15;
          v181 = v5;
          v189 = isUseDefaultFreq;
          sprintf((char *)logstr, "Chain[J%d] has core num in PIC\n", v3);
          writeInitLogFile(logstr);
          v136 = 31 * v7;
          v137 = v189;
          v201 = v2;
          v205 = v3 + 1;
          v138 = v189;
          v139 = v1;
          v140 = v3;
          v141 = (int)v183 + v136 + 29;
          do
          {
            v142 = *(unsigned __int8 *)(v141 + (v137 >> 1) + 212);
            if ( (v137 & 1) != 0 )
              v143 = v142 & 0xF;
            else
              v143 = v142 >> 4;
            *(_DWORD *)((char *)v139 + v138) = v143;
            if ( v143 )
            {
              sprintf((char *)logstr, "Chain[J%d] ASIC[%d] has core num=%d\n", v140, v137, v143);
              writeInitLogFile(logstr);
            }
            ++v137;
            v138 += 4;
          }
          while ( v137 != 18 );
          v1 = v139;
          v2 = v201;
          v5 = v181;
          v6 = v205;
        }
        else
        {
          v179 = v5;
          sprintf((char *)logstr, "Chain[J%d] has no core num in PIC\n", v3);
          writeInitLogFile(logstr);
          v5 = v179;
          for ( m = 0; m != 18; ++m )
            (*v1)[m] = 0;
        }
      }
    }
    v3 = v6;
    ++v1;
    ++v2;
    ++v4;
    ++v5;
  }
  while ( v6 != 17 );
  v18 = isUseDefaultFreq;
  if ( !isUseDefaultFreq )
  {
    TotalRate = GetTotalRate();
    v123 = GetTotalRate();
    if ( v123 % 1000 > 500 )
      v18 = 500;
    sprintf((char *)logstr, "miner total rate=%dGH/s fixed rate=%dGH/s\n", TotalRate, v18 + 1000 * (v123 / 1000));
    writeInitLogFile(logstr);
  }
  if ( !opt_fixed_freq )
  {
    v72 = opt_fixed_freq;
    v197 = -1;
    max_freq_indexa = CSWTCH_825;
    typeb = 1;
    v200 = CSWTCH_824;
    do
    {
      if ( dev->chain_exist[v72] != 1 || !dev->chain_asic_num[v72] )
        goto LABEL_143;
      v73 = &dev;
      v74 = (int)((364.0704 / ((double)get_pic_voltage(v72) + 30.72) + 32.79) * 100.0 / 4.75);
      v75 = (unsigned __int64)(1717986919LL * v74) >> 32;
      v76 = 1717986919 * v74;
      sprintf((char *)logstr, "read PIC voltage=%d on chain[%d]\n", 10 * (v74 / 10), v72);
      writeInitLogFile(logstr);
      sprintf((char *)logstr, "Chain:%d chipnum=%d\n", v72, dev->chain_asic_num[v72]);
      writeInitLogFile(logstr);
      v77 = fpga_version;
      if ( fpga_version <= 13 )
      {
        v78 = 1431655766 * v72;
        sprintf(
          (char *)logstr,
          "Chain[J%d] voltage added=0.%dV\n",
          typeb,
          *((unsigned __int8 *)&h + 384 * (v72 / 3) + 31 * (v72 % 3) + 221));
      }
      else
      {
        v78 = v197;
        if ( v197 > 0xC )
          v77 = 0;
        else
          v76 = (int)max_freq_indexa;
        if ( v197 > 0xC )
          v75 = 9;
        else
          v73 = (all_parameters **)v200;
        if ( v197 <= 0xC )
        {
          v77 = (int)*(v73 - 1);
          v75 = 31 * *(_DWORD *)(v76 - 4);
        }
        v79 = &h + 16 * v77;
        if ( v197 <= 0xC )
          v75 += 9;
        sprintf((char *)logstr, "Chain[J%d] voltage added=0.%dV\n", typeb, *((unsigned __int8 *)v79 + v75 + 212));
      }
      writeInitLogFile(logstr);
      get_macBytes(minerMAC, v80);
      v81 = fpga_version;
      if ( fpga_version <= 13 )
      {
        v78 = 1431655766 * v72;
        v82 = &h + 48 * (v72 / 3);
      }
      else
      {
        if ( v197 > 0xC )
          v81 = 0;
        else
          v73 = (all_parameters **)v200;
        if ( v197 <= 0xC )
          v81 = (int)*(v73 - 1);
        v82 = &h + 16 * v81;
      }
      v83 = *((_BYTE *)v82 + 214);
      v84 = *((_BYTE *)v82 + 215);
      hashMAC[0] = *((_BYTE *)v82 + 213);
      hashMAC[1] = v83;
      v85 = *((_BYTE *)v82 + 216);
      v86 = *((_BYTE *)v82 + 217);
      v87 = *((_BYTE *)v82 + 218);
      hashMAC[2] = v84;
      hashMAC[3] = v85;
      hashMAC[4] = v86;
      hashMAC[5] = v87;
      if ( !memcmp(hashMAC, minerMAC, 6u) )
      {
        v88 = (int *)minerMAC[1];
        v89 = (int *)minerMAC[5];
        sprintf(
          (char *)logstr,
          "OK: Chain[J%d] is for this machine! [minerMAC: %02x:%02x:%02x:%02x:%02x:%02x]\n",
          typeb,
          minerMAC[0],
          minerMAC[1],
          minerMAC[2],
          minerMAC[3],
          minerMAC[4],
          minerMAC[5]);
      }
      else
      {
        v78 = minerMAC[1];
        v88 = (int *)minerMAC[4];
        v89 = (int *)hashMAC[3];
        sprintf(
          (char *)logstr,
          "Chain[J%d] [minerMAC: %02x:%02x:%02x:%02x:%02x:%02x hashMAC: %02x:%02x:%02x:%02x:%02x:%02x]\n",
          typeb,
          minerMAC[0],
          minerMAC[1],
          minerMAC[2],
          minerMAC[3],
          minerMAC[4],
          minerMAC[5],
          hashMAC[0],
          hashMAC[1],
          hashMAC[2],
          hashMAC[3],
          hashMAC[4],
          hashMAC[5]);
      }
      writeInitLogFile(logstr);
      if ( fpga_version <= 13 )
      {
        if ( isUseDefaultFreq )
        {
          v114 = default_freq_index;
          base_freq_index[v72] = default_freq_index;
        }
        else
        {
          v114 = *((unsigned __int8 *)&h + 384 * (v72 / 3) + 31 * (v72 % 3) + 219);
          base_freq_index[v72] = v114;
        }
        sprintf(
          (char *)logstr,
          "Chain:%d base freq=%s\n",
          v72,
          *(const char **)&_PRETTY_FUNCTION___14401[16 * v114 + 56]);
        writeInitLogFile(logstr);
        v92 = dev->chain_asic_num[v72];
        if ( dev->chain_asic_num[v72] )
        {
          v92 = 0;
          v204 = v72;
          v115 = 0;
          v94 = 100;
          v116 = 3 * (v72 / 3);
          v210 = chain_pic_buf[3 * (v72 / 3)];
          v117 = 31 * (v72 % 3) + 11;
          v118 = v116 << 7;
          do
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42, 0x800u, "%s: freq index=%d\n", (const char *)_FUNCTION___13127, v210[v117]);
              applog(7, tmp42, 0);
            }
            v119 = (char *)&h + v118 + v117;
            v120 = (unsigned __int8)v119[212];
            if ( v120 > 3 )
            {
              if ( v120 > 0x64 )
                v119[212] = 100;
            }
            else
            {
              v119[212] = 4;
            }
            v121 = *((unsigned __int8 *)&h + v118 + v117 + 212);
            if ( v92 < v121 )
              v92 = *((unsigned __int8 *)&h + v118 + v117 + 212);
            if ( v94 >= v121 )
              v94 = *((unsigned __int8 *)&h + v118 + v117 + 212);
            sprintf((char *)logstr, "Asic[%2d]:%s ", v115, *(_DWORD *)&_PRETTY_FUNCTION___14401[16 * v121 + 56]);
            writeInitLogFile(logstr);
            if ( !(v115 << 29) )
            {
              strcpy((char *)logstr, "\n");
              writeInitLogFile(logstr);
            }
            ++v115;
            ++v117;
          }
          while ( dev->chain_asic_num[v204] > v115 );
          v72 = v204;
          goto LABEL_294;
        }
      }
      else
      {
        v90 = v197;
        if ( v197 > 0xC )
          v90 = 0;
        else
          v89 = v200;
        if ( v197 > 0xC )
          v78 = v90;
        else
          v88 = max_freq_indexa;
        if ( v197 <= 0xC )
        {
          v78 = *(v89 - 1);
          v90 = *(v88 - 1);
        }
        if ( isUseDefaultFreq )
        {
          v91 = default_freq_index;
          base_freq_index[v72] = default_freq_index;
        }
        else
        {
          v91 = *((unsigned __int8 *)&h + 128 * v78 + 31 * v90 + 219);
          base_freq_index[v72] = v91;
        }
        sprintf(
          (char *)logstr,
          "Chain:%d base freq=%s\n",
          v72,
          *(const char **)&_PRETTY_FUNCTION___14401[16 * v91 + 56]);
        writeInitLogFile(logstr);
        v92 = dev->chain_asic_num[v72];
        if ( dev->chain_asic_num[v72] )
        {
          v93 = v78 << 7;
          v92 = 0;
          v94 = 100;
          v95 = 31 * v90 + 11;
          v96 = 0;
          do
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: freq index=%d\n",
                (const char *)_FUNCTION___13127,
                chain_pic_buf[0][v93 + v95]);
              applog(7, tmp42, 0);
            }
            v97 = (char *)&h + v93 + v95;
            v98 = (unsigned __int8)v97[212];
            if ( v98 > 3 )
            {
              if ( v98 > 0x64 )
                v97[212] = 100;
            }
            else
            {
              v97[212] = 4;
            }
            v99 = *((unsigned __int8 *)&h + v93 + v95 + 212);
            if ( v92 < v99 )
              v92 = *((unsigned __int8 *)&h + v93 + v95 + 212);
            if ( v94 >= v99 )
              v94 = *((unsigned __int8 *)&h + v93 + v95 + 212);
            sprintf((char *)logstr, "Asic[%2d]:%s ", v96, *(_DWORD *)&_PRETTY_FUNCTION___14401[16 * v99 + 56]);
            writeInitLogFile(logstr);
            if ( !(v96 << 29) )
            {
              strcpy((char *)logstr, "\n");
              writeInitLogFile(logstr);
            }
            ++v96;
            ++v95;
          }
          while ( dev->chain_asic_num[v72] > v96 );
          goto LABEL_294;
        }
      }
      v94 = 100;
LABEL_294:
      sprintf((char *)logstr, "\nChain:%d max freq=%s\n", v72, *(const char **)&_PRETTY_FUNCTION___14401[16 * v92 + 56]);
      writeInitLogFile(logstr);
      sprintf((char *)logstr, "Chain:%d min freq=%s\n", v72, *(const char **)&_PRETTY_FUNCTION___14401[16 * v94 + 56]);
      writeInitLogFile(logstr);
      strcpy((char *)logstr, "\n");
      writeInitLogFile(logstr);
LABEL_143:
      ++v72;
      ++typeb;
      ++v197;
      ++v200;
      ++max_freq_indexa;
    }
    while ( v72 != 16 );
  }
  strcpy((char *)logstr, "\nMiner fix freq ...\n");
  writeInitLogFile(logstr);
  v19 = isUseDefaultFreq;
  v20 = dev;
  if ( isUseDefaultFreq )
    goto LABEL_48;
  v21 = isUseDefaultFreq;
  do
  {
    v22 = (char *)dev + v19;
    v19 += 4;
    if ( *((_DWORD *)v22 + 2) == 1 )
      ++v21;
  }
  while ( v19 != 64 );
  if ( v21 <= 8 )
    goto LABEL_48;
  v101 = GetTotalRate();
  if ( v101 % 1000 <= 500 )
    v102 = 0;
  else
    v102 = 500;
  v103 = 102 * (v102 + 1000 * (v101 / 1000)) / 100;
  if ( v103 < GetTotalRate() )
  {
    for ( n = 0; ; n = 0 )
    {
      if ( dev->chain_exist[0] == 1 )
      {
LABEL_210:
        v105 = n - 1;
        v106 = &_PRETTY_FUNCTION___14401[4 * n - 4];
        v107 = fpga_version;
        v108 = 0;
        v109 = last_record_freq[n];
        for ( ii = 0; ii != 18; ++ii )
        {
          if ( v107 > 13 )
          {
            v111 = 11;
            v112 = 0;
            if ( v105 <= 0xC )
            {
              v112 = *((_DWORD *)v106 + 622);
              v111 = 31 * *((_DWORD *)v106 + 635);
            }
            v113 = &h + 16 * v112;
            if ( v105 <= 0xC )
              v111 += 11;
            v109[v108] = *((unsigned __int8 *)v113 + ii + v111 + 212);
          }
          else
          {
            v109[v108] = chain_pic_buf[3 * (n / 3)][31 * (n % 3) + 11 + ii];
          }
          ++v108;
        }
      }
      while ( ++n <= 15 )
      {
        if ( dev->chain_exist[n] == 1 )
          goto LABEL_210;
      }
      if ( !DownOneChipFreqOneStep() || v103 >= GetTotalRate() )
      {
        v167 = 0;
        v168 = 0;
        v169 = fpga_version;
        v170 = last_record_freq;
        typec = dev;
        do
        {
          if ( typec->chain_exist[v167] == 1 )
          {
            v171 = 0;
            v172 = 0;
            max_freq_indexc = v168 - 1;
            do
            {
              if ( v169 > 13 )
              {
                v173 = 11;
                v174 = 0;
                if ( max_freq_indexc <= 0xC )
                {
                  v174 = CSWTCH_824[v167 - 1];
                  v173 = 31 * CSWTCH_825[v167 - 1];
                }
                v175 = &h + 16 * v174;
                if ( max_freq_indexc <= 0xC )
                  v173 += 11;
                *((_BYTE *)v175 + v172 + v173 + 212) = (*v170)[v171];
              }
              else
              {
                chain_pic_buf[3 * (v168 / 3)][31 * (v168 % 3) + 11 + v172] = (*v170)[v171];
              }
              ++v172;
              ++v171;
            }
            while ( v172 != 18 );
          }
          ++v168;
          ++v167;
          ++v170;
        }
        while ( v168 != 16 );
        v20 = typec;
        goto LABEL_48;
      }
    }
  }
  v20 = dev;
LABEL_48:
  v23 = v20;
  for ( jj = 0; jj != (unsigned __int8 *)16; ++jj )
  {
    while ( 1 )
    {
      v25 = v23->chain_exist[0];
      v23 = (all_parameters *)((char *)v23 + 4);
      if ( v25 == 1 )
        break;
      if ( ++jj == (unsigned __int8 *)16 )
        goto LABEL_52;
    }
    v26 = chip_last_freq[(_DWORD)jj];
    v27 = chain_pic_buf[(_DWORD)jj];
    memcpy(v26, v27, 0x80u);
  }
LABEL_52:
  v28 = 0;
  max_freq_index = 0;
  v199 = 1;
  while ( 1 )
  {
    v29 = v20->chain_exist[v28];
    if ( v29 == 1 && v20->chain_asic_num[v28] )
    {
      typea = v28;
      v30 = (int)((364.0704 / ((double)get_pic_voltage(v28) + 30.72) + 32.79) * 100.0 / 4.75);
      v31 = (unsigned __int64)(1717986919LL * v30) >> 32;
      v32 = 1717986919 * v30;
      sprintf((char *)logstr, "read PIC voltage=%d on chain[%d]\n", 10 * (v30 / 10), v28);
      writeInitLogFile(logstr);
      sprintf((char *)logstr, "Chain:%d chipnum=%d\n", v28, dev->chain_asic_num[v28]);
      writeInitLogFile(logstr);
      v33 = opt_fixed_freq;
      if ( opt_fixed_freq )
      {
        if ( fpga_version <= 13 )
          goto LABEL_59;
      }
      else
      {
        if ( fpga_version <= 13 )
        {
          v32 = 1431655766 * v28;
          v31 = 31 * (v28 % 3) + 384 * (v28 / 3);
          sprintf((char *)logstr, "Chain[J%d] voltage added=0.%dV\n", v199, *((unsigned __int8 *)&h + v31 + 221));
        }
        else
        {
          if ( (unsigned int)(v28 - 1) > 0xC )
            v31 = 9;
          else
            jj = (unsigned __int8 *)v208;
          if ( (unsigned int)(v28 - 1) <= 0xC )
          {
            v33 = *(v207 - 1);
            v31 = 31 * *((_DWORD *)jj - 1);
          }
          if ( (unsigned int)(v28 - 1) <= 0xC )
            v31 += 9;
          sprintf(
            (char *)logstr,
            "Chain[J%d] voltage added=0.%dV\n",
            v199,
            *((unsigned __int8 *)&h + 128 * v33 + v31 + 212));
        }
        jj = minerMAC;
        writeInitLogFile(logstr);
        get_macBytes(minerMAC, v63);
        if ( fpga_version <= 13 )
        {
          v65 = &h + 48 * (v28 / 3);
        }
        else
        {
          v64 = v28 - 1;
          if ( (unsigned int)(v28 - 1) > 0xC )
            v64 = 0;
          else
            v31 = (int)v207;
          if ( (unsigned int)(v28 - 1) <= 0xC )
            v64 = *(_DWORD *)(v31 - 4);
          v65 = &h + 16 * v64;
        }
        v66 = *((_BYTE *)v65 + 214);
        v67 = *((_BYTE *)v65 + 215);
        hashMAC[0] = *((_BYTE *)v65 + 213);
        hashMAC[1] = v66;
        v68 = *((_BYTE *)v65 + 216);
        v69 = *((_BYTE *)v65 + 217);
        v70 = *((_BYTE *)v65 + 218);
        hashMAC[2] = v67;
        hashMAC[3] = v68;
        hashMAC[4] = v69;
        hashMAC[5] = v70;
        if ( !memcmp(hashMAC, minerMAC, 6u) )
        {
          v31 = minerMAC[4];
          sprintf(
            (char *)logstr,
            "OK: Chain[J%d] is for this machine! [minerMAC: %02x:%02x:%02x:%02x:%02x:%02x]\n",
            v199,
            minerMAC[0],
            minerMAC[1],
            minerMAC[2],
            minerMAC[3],
            minerMAC[4],
            minerMAC[5]);
        }
        else
        {
          v32 = minerMAC[5];
          v31 = hashMAC[5];
          sprintf(
            (char *)logstr,
            "Chain[J%d] [minerMAC: %02x:%02x:%02x:%02x:%02x:%02x hashMAC: %02x:%02x:%02x:%02x:%02x:%02x]\n",
            v199,
            minerMAC[0],
            minerMAC[1],
            minerMAC[2],
            minerMAC[3],
            minerMAC[4],
            minerMAC[5],
            hashMAC[0],
            hashMAC[1],
            hashMAC[2],
            hashMAC[3],
            hashMAC[4],
            hashMAC[5]);
        }
        writeInitLogFile(logstr);
        v29 = opt_fixed_freq;
        if ( fpga_version <= 13 )
        {
          if ( !opt_fixed_freq )
          {
            if ( isUseDefaultFreq )
            {
              v71 = default_freq_index;
              base_freq_index[v28] = default_freq_index;
            }
            else
            {
              v71 = *((unsigned __int8 *)&h + 384 * (v28 / 3) + 31 * (v28 % 3) + 219);
              base_freq_index[v28] = v71;
            }
            sprintf(
              (char *)logstr,
              "Chain:%d base freq=%s\n",
              v28,
              *(const char **)&_PRETTY_FUNCTION___14401[16 * v71 + 56]);
            writeInitLogFile(logstr);
          }
LABEL_59:
          v34 = dev->chain_asic_num[v28];
          if ( dev->chain_asic_num[v28] )
          {
            v34 = 0;
            v195 = v28;
            v35 = 0;
            v36 = 100;
            v203 = chain_pic_buf[3 * (v28 / 3)];
            v37 = 31 * (v28 % 3) + 11;
            v38 = 384 * (v28 / 3);
            do
            {
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "%s: freq index=%d\n", (const char *)_FUNCTION___13127, v203[v37]);
                applog(7, tmp42, 0);
              }
              v40 = (char *)&h + v38 + v37;
              v41 = (unsigned __int8)v40[212];
              if ( v41 > 3 )
              {
                if ( v41 > 0x64 )
                  v40[212] = 100;
              }
              else
              {
                v40[212] = 4;
              }
              v42 = (char *)&h + v38 + v37;
              v43 = max_freq_index;
              v44 = (unsigned __int8)v42[212];
              if ( max_freq_index < v44 )
                v43 = (unsigned __int8)v42[212];
              if ( v34 < v44 )
                v34 = (unsigned __int8)v42[212];
              if ( v36 >= v44 )
                v36 = (unsigned __int8)v42[212];
              max_freq_index = v43;
              set_frequency_with_addr_plldatai(v44, 0, v35 * dev->addrInterval, typea);
              sprintf(
                (char *)logstr,
                "Asic[%2d]:%s ",
                v35,
                *(const char **)&_PRETTY_FUNCTION___14401[16 * (unsigned __int8)v42[212] + 56]);
              writeInitLogFile(logstr);
              if ( !(v35 << 29) )
              {
                strcpy((char *)logstr, "\n");
                writeInitLogFile(logstr);
              }
              ++v35;
              v39 = v195;
              ++v37;
            }
            while ( dev->chain_asic_num[v195] > v35 );
LABEL_105:
            v28 = v39;
LABEL_106:
            sprintf(
              (char *)logstr,
              "\nChain:%d max freq=%s\n",
              v28,
              *(const char **)&_PRETTY_FUNCTION___14401[16 * v34 + 56]);
            writeInitLogFile(logstr);
            sprintf(
              (char *)logstr,
              "Chain:%d min freq=%s\n",
              v28,
              *(const char **)&_PRETTY_FUNCTION___14401[16 * v36 + 56]);
            writeInitLogFile(logstr);
            strcpy((char *)logstr, "\n");
            writeInitLogFile(logstr);
            goto LABEL_53;
          }
          goto LABEL_325;
        }
      }
      if ( (unsigned int)(v28 - 1) > 0xC )
      {
        v31 = 0;
        jj = 0;
      }
      else
      {
        v32 = (int)v207;
      }
      if ( (unsigned int)(v28 - 1) <= 0xC )
      {
        jj = *(unsigned __int8 **)(v32 - 4);
        v31 = *(v208 - 1);
      }
      if ( !v29 )
      {
        if ( isUseDefaultFreq )
        {
          v100 = default_freq_index;
          base_freq_index[v28] = default_freq_index;
        }
        else
        {
          v100 = *((unsigned __int8 *)&h + 128 * (_DWORD)jj + 31 * v31 + 219);
          base_freq_index[v28] = v100;
        }
        sprintf(
          (char *)logstr,
          "Chain:%d base freq=%s\n",
          v28,
          *(const char **)&_PRETTY_FUNCTION___14401[16 * v100 + 56]);
        writeInitLogFile(logstr);
      }
      v34 = dev->chain_asic_num[v28];
      if ( dev->chain_asic_num[v28] )
      {
        v45 = (_DWORD)jj << 7;
        v34 = 0;
        v36 = 100;
        v196 = v28;
        v46 = 31 * v31 + 11;
        v47 = 0;
        do
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: freq index=%d\n",
              (const char *)_FUNCTION___13127,
              chain_pic_buf[0][v45 + v46]);
            applog(7, tmp42, 0);
          }
          v48 = (char *)&h + v45 + v46;
          v49 = (unsigned __int8)v48[212];
          if ( v49 > 3 )
          {
            if ( v49 > 0x64 )
              v48[212] = 100;
          }
          else
          {
            v48[212] = 4;
          }
          v50 = (char *)&h + v45 + v46;
          v51 = max_freq_index;
          v52 = (unsigned __int8)v50[212];
          if ( max_freq_index < v52 )
            v51 = (unsigned __int8)v50[212];
          if ( v34 < v52 )
            v34 = (unsigned __int8)v50[212];
          if ( v36 >= v52 )
            v36 = (unsigned __int8)v50[212];
          max_freq_index = v51;
          set_frequency_with_addr_plldatai(v52, 0, v47 * dev->addrInterval, typea);
          sprintf(
            (char *)logstr,
            "Asic[%2d]:%s ",
            v47,
            *(const char **)&_PRETTY_FUNCTION___14401[16 * (unsigned __int8)v50[212] + 56]);
          writeInitLogFile(logstr);
          if ( !(v47 << 29) )
          {
            strcpy((char *)logstr, "\n");
            writeInitLogFile(logstr);
          }
          ++v47;
          v39 = v196;
          ++v46;
        }
        while ( dev->chain_asic_num[v196] > v47 );
        goto LABEL_105;
      }
LABEL_325:
      v36 = 100;
      goto LABEL_106;
    }
LABEL_53:
    ++v28;
    ++v199;
    jj = (unsigned __int8 *)(v208 + 1);
    ++v207;
    ++v208;
    if ( v28 == 16 )
      break;
    v20 = dev;
  }
  v53 = strtol(*(const char **)&_PRETTY_FUNCTION___14401[16 * max_freq_index + 56], 0, 10);
  dev->frequency = v53;
  sprintf((char *)logstr, "max freq = %d\n", v53);
  writeInitLogFile(logstr);
  v54 = isUseDefaultFreq;
  if ( isUseDefaultFreq )
  {
    v55 = dev;
    goto LABEL_109;
  }
  v124 = GetTotalRate();
  if ( v124 % 1000 > 500 )
    v54 = 500;
  v125 = v54 + 1000 * (v124 / 1000);
  if ( v125 >= GetTotalRate() )
  {
    v55 = dev;
    goto LABEL_109;
  }
  v126 = 0;
  while ( 2 )
  {
    if ( dev->chain_exist[0] == 1 )
      goto LABEL_257;
    while ( ++v126 <= 15 )
    {
      if ( dev->chain_exist[v126] == 1 )
      {
LABEL_257:
        v127 = v126 - 1;
        v128 = 0;
        v129 = &_PRETTY_FUNCTION___14401[4 * v126 - 4];
        v130 = fpga_version;
        v131 = last_record_freq[v126];
        for ( kk = 0; kk != 18; ++kk )
        {
          if ( v130 > 13 )
          {
            v133 = 11;
            v134 = 0;
            if ( v127 <= 0xC )
            {
              v134 = *((_DWORD *)v129 + 622);
              v133 = 31 * *((_DWORD *)v129 + 635);
            }
            v135 = &h + 16 * v134;
            if ( v127 <= 0xC )
              v133 += 11;
            v131[v128] = *((unsigned __int8 *)v135 + kk + v133 + 212);
          }
          else
          {
            v131[v128] = chain_pic_buf[3 * (v126 / 3)][31 * (v126 % 3) + 11 + kk];
          }
          ++v128;
        }
      }
    }
    if ( DownOneChipFreqOneStep() && v125 < GetTotalRate() )
    {
      v126 = 0;
      continue;
    }
    break;
  }
  v152 = 0;
  v153 = last_record_freq;
  v154 = 0;
  v155 = fpga_version;
  v190 = dev;
  do
  {
    while ( v190->chain_exist[v152] != 1 )
    {
      ++v154;
      ++v152;
      ++v153;
      if ( v154 == 16 )
        goto LABEL_311;
    }
    v156 = v154 - 1;
    max_freq_indexb = v154;
    v157 = 0;
    v158 = 0;
    v159 = &chain_pic_buf[3 * (v154 / 3)][31 * (v154 % 3)];
    do
    {
      while ( 1 )
      {
        v165 = &v159[v158];
        if ( v155 > 13 )
          break;
        v166 = (*v153)[v157];
        ++v158;
        ++v157;
        v165[11] = v166;
        if ( v158 == 18 )
          goto LABEL_310;
      }
      v160 = 0;
      if ( v156 <= 0xC )
        v160 = CSWTCH_824[v152 - 1];
      v161 = 11;
      if ( v156 <= 0xC )
        v161 = CSWTCH_825[v152 - 1];
      v162 = (*v153)[v157++];
      v163 = &h + 16 * v160;
      if ( v156 <= 0xC )
        v161 *= 31;
      v164 = (char *)v163 + v158++;
      if ( v156 <= 0xC )
        v161 += 11;
      v164[v161 + 212] = v162;
    }
    while ( v158 != 18 );
LABEL_310:
    ++v152;
    ++v153;
    v154 = max_freq_indexb + 1;
  }
  while ( max_freq_indexb != 15 );
LABEL_311:
  v55 = v190;
LABEL_109:
  for ( mm = 0; mm != 16; ++mm )
  {
    while ( 1 )
    {
      v57 = v55->chain_exist[0];
      v55 = (all_parameters *)((char *)v55 + 4);
      if ( v57 == 1 )
        break;
      if ( ++mm == 16 )
        return;
    }
    v58 = show_last_freq[mm];
    v59 = chain_pic_buf[mm];
    memcpy(v58, v59, 0x80u);
  }
}
// 303E8: variable 'v176' is possibly undefined
// 30BFC: variable 'v63' is possibly undefined
// 30E5E: variable 'v80' is possibly undefined
// 30D40: using guessed type char (*off_30D40)[16];
// 50464: using guessed type int CSWTCH_824[];
// 50498: using guessed type int CSWTCH_825[];

//----- (000319A4) --------------------------------------------------------
void __fastcall set_frequency_with_addr(
        unsigned __int16 frequency,
        unsigned __int8 mode,
        unsigned __int8 addr,
        unsigned __int8 chain)
{
  int v4; // r5
  int v5; // r9
  int v6; // r8
  int v7; // r6
  unsigned int v8; // r4
  unsigned int v9; // r7
  int v10; // r4
  int v11; // r9
  int v12; // r10
  int v13; // r0
  unsigned int v14; // r0
  int v15; // r3
  int v16; // r6
  int v17; // r0
  char v18; // r9
  int v19; // r10
  int v20; // r11
  int v21; // r9
  unsigned int v22; // r9
  unsigned int v23; // r0
  int v24; // r8
  unsigned int v25; // r0
  unsigned int *v26; // [sp+0h] [bp-858h]
  uint16_t reg_data_pll2; // [sp+Eh] [bp-84Ah] BYREF
  unsigned int reg_data_pll; // [sp+10h] [bp-848h] BYREF
  unsigned int reg_data_vil; // [sp+14h] [bp-844h] BYREF
  unsigned __int8 buf[9]; // [sp+18h] [bp-840h] BYREF
  unsigned int cmd_buf[3]; // [sp+24h] [bp-834h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp-828h] BYREF

  v4 = frequency;
  v5 = mode;
  v6 = addr;
  v7 = chain;
  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  reg_data_pll = 0;
  reg_data_pll2 = 0;
  reg_data_vil = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "\n--- %s\n", (const char *)_FUNCTION___13215);
    applog(7, tmp42, 0);
  }
  get_plldata(v4, (int)&reg_data_pll, (unsigned int *)&reg_data_pll2, (uint16_t *)&reg_data_vil, v26);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: frequency = %d\n", (const char *)_FUNCTION___13215, v4);
    applog(7, tmp42, 0);
  }
  v8 = opt_multi_version;
  if ( opt_multi_version )
  {
    memset(cmd_buf, 0, sizeof(cmd_buf));
    buf[8] = 0;
    if ( v5 )
      buf[0] = 88;
    else
      buf[0] = 72;
    buf[1] = 9;
    buf[7] = reg_data_vil;
    v9 = HIBYTE(reg_data_vil);
    buf[3] = 12;
    buf[4] = HIBYTE(reg_data_vil);
    v10 = (unsigned __int8)reg_data_vil;
    buf[5] = BYTE2(reg_data_vil);
    buf[6] = BYTE1(reg_data_vil);
    v11 = BYTE1(reg_data_vil);
    buf[2] = v6;
    v12 = BYTE2(reg_data_vil) << 16;
    v13 = CRC5(buf, 0x40u);
    buf[8] = v13;
    cmd_buf[2] = v13 << 24;
    cmd_buf[1] = v10 | v12 | (v9 << 24) | (v11 << 8);
    cmd_buf[0] = (buf[0] << 24) | 0x9000C | (v6 << 8);
    set_BC_command_buffer(cmd_buf);
    v14 = get_BC_write_command();
    v15 = v7 << 16;
    v16 = v7 + 6140;
    set_BC_write_command(v14 & 0xFFF0FFFF | v15 | 0x80800000);
    v17 = 10000;
  }
  else
  {
    buf[0] = 7;
    *(_DWORD *)&buf[4] = opt_multi_version;
    v18 = reg_data_pll;
    cmd_buf[1] = opt_multi_version;
    buf[1] = BYTE2(reg_data_pll);
    buf[2] = BYTE1(reg_data_pll);
    v19 = BYTE2(reg_data_pll);
    v20 = BYTE1(reg_data_pll) << 8;
    buf[3] = reg_data_pll;
    cmd_buf[0] = opt_multi_version;
    buf[8] = opt_multi_version;
    cmd_buf[2] = opt_multi_version;
    v21 = (unsigned __int8)(CRC5(buf, 0x1Bu) | v18);
    buf[3] = v21;
    cmd_buf[0] = v20 | (v19 << 16) | 0x7000000 | v21;
    v22 = (v7 << 16) | 0x80000000;
    v16 = v7 + 6140;
    set_BC_command_buffer(cmd_buf);
    v22 |= 0x800000u;
    v23 = get_BC_write_command();
    set_BC_write_command(v23 & 0xFFF0FFFF | v22);
    cgsleep_us(3000LL);
    buf[1] = BYTE1(v8);
    buf[8] = v8;
    cmd_buf[2] = v8;
    v24 = HIBYTE(reg_data_pll2);
    LOBYTE(v19) = reg_data_pll2;
    buf[0] = -126;
    buf[2] = HIBYTE(reg_data_pll2);
    buf[3] = reg_data_pll2;
    cmd_buf[0] = v8;
    *(_DWORD *)&buf[4] = v8;
    cmd_buf[1] = v8;
    buf[3] = CRC5(buf, 0x1Bu) | v19;
    cmd_buf[0] = buf[3] | (v24 << 8) | 0x82000000;
    set_BC_command_buffer(cmd_buf);
    v25 = get_BC_write_command();
    set_BC_write_command(v25 & 0xFFF0FFFF | v22);
    v17 = 5000;
  }
  *((_WORD *)&dev->current_job_start_address + v16 + 1) = v4;
  cgsleep_us((unsigned int)v17);
}
// 31A26: variable 'v26' is possibly undefined

//----- (00031C60) --------------------------------------------------------
void clear_nonce_fifo()
{
  pthread_mutex_lock(&nonce_mutex);
  nonce_read_out.p_wr = 0;
  nonce_read_out.p_rd = 0;
  nonce_read_out.nonce_num = 0;
  j_pthread_mutex_unlock(&nonce_mutex);
}

//----- (00031C88) --------------------------------------------------------
void clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  reg_value_buf.p_wr = 0;
  reg_value_buf.p_rd = 0;
  reg_value_buf.reg_value_num = 0;
  j_pthread_mutex_unlock(&reg_mutex);
}

//----- (00031CB0) --------------------------------------------------------
void __noreturn get_nonce_and_register()
{
  unsigned int *v0; // r3
  unsigned int v1; // r5
  int v2; // r11
  int v3; // r9
  unsigned int v4; // r3
  int v5; // r0
  unsigned int *v6; // r1
  unsigned int *v7; // r0
  unsigned int v8; // r3
  char *v9; // lr
  int v10; // r1
  int v11; // r2
  char *v12; // r3
  pthread_mutex_t *v13; // r0
  unsigned int p_wr; // r3
  bool v15; // cc
  unsigned int v16; // r3
  bool v17; // cc
  unsigned int reg_value_num; // r3
  bool v19; // cc
  unsigned int v20; // [sp+Ch] [bp-834h]
  unsigned int v21; // [sp+Ch] [bp-834h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-828h] BYREF

  do
  {
LABEL_1:
    while ( 1 )
    {
      cgsleep_ms(1);
      if ( !doTestPatten )
        break;
      cgsleep_ms(100);
    }
    v0 = axi_fpga_addr;
    v1 = axi_fpga_addr[6] & 0x1FF;
  }
  while ( !v1 );
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: read_loop = %d\n", (const char *)_FUNCTION___14025, v1);
    applog(7, tmp42, 0);
    v0 = axi_fpga_addr;
  }
  v2 = 0;
  while ( 1 )
  {
    v3 = v0[4];
    v4 = v0[5];
    if ( v3 >= 0 )
      break;
    if ( gBegin_get_nonce_0 && (v3 & 0x80) != 0 )
    {
      v20 = v4;
      pthread_mutex_lock(&nonce_mutex);
      v5 = HIWORD(v3) & 0x7FFF;
      v6 = nonce2_jobid_address;
      nonce_read_out.nonce_buffer[nonce_read_out.p_wr].work_id = v5;
      v7 = &v6[16 * v5];
      nonce_read_out.nonce_buffer[nonce_read_out.p_wr].nonce3 = v20;
      nonce_read_out.nonce_buffer[nonce_read_out.p_wr].chain_num = v3 & 0xF;
      nonce_read_out.nonce_buffer[nonce_read_out.p_wr].job_id = *v7;
      nonce_read_out.nonce_buffer[nonce_read_out.p_wr].header_version = v7[1];
      v8 = v7[3];
      v9 = (char *)&nonce_read_out + 60 * nonce_read_out.p_wr;
      v10 = 0;
      *((_DWORD *)v9 + 6) = v7[2];
      *((_DWORD *)v9 + 7) = v8;
      do
      {
        v11 = *((unsigned __int8 *)v7 + v10 + 32);
        v12 = (char *)&nonce_read_out + 60 * nonce_read_out.p_wr + v10++;
        v12[40] = v11;
      }
      while ( v10 != 32 );
      v13 = &nonce_mutex;
      if ( nonce_read_out.p_wr > 0x1FE )
        p_wr = 0;
      else
        p_wr = nonce_read_out.p_wr;
      if ( nonce_read_out.p_wr <= 0x1FE )
        ++p_wr;
      nonce_read_out.p_wr = p_wr;
      LOWORD(p_wr) = nonce_read_out.nonce_num;
      v15 = nonce_read_out.nonce_num > 0x1FE;
      if ( nonce_read_out.nonce_num > 0x1FE )
        LOWORD(p_wr) = 6012;
      else
        v10 = (unsigned __int16)&nonce_read_out;
      if ( nonce_read_out.nonce_num > 0x1FE )
        v11 = 511;
      else
        HIWORD(v10) = (unsigned int)&nonce_read_out >> 16;
      if ( nonce_read_out.nonce_num > 0x1FE )
      {
        HIWORD(p_wr) = 119;
        *(_DWORD *)(p_wr + 8) = v11;
      }
      else
      {
        p_wr = *(_DWORD *)(v10 + 8);
      }
      if ( !v15 )
        *(_DWORD *)(v10 + 8) = p_wr + 1;
LABEL_35:
      pthread_mutex_unlock(v13);
    }
LABEL_12:
    if ( ++v2 == v1 )
      goto LABEL_1;
    v0 = axi_fpga_addr;
  }
  if ( reg_value_buf.reg_value_num > 0x1FE || reg_value_buf.p_wr > 0x1FE )
  {
    clear_register_value_buf();
    goto LABEL_12;
  }
  v21 = v4;
  pthread_mutex_lock(&reg_mutex);
  v13 = &reg_mutex;
  reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = v21;
  reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = HIBYTE(v3) & 0x1F;
  reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = v3 & 0xF;
  v16 = reg_value_buf.p_wr;
  v17 = reg_value_buf.p_wr > 0x1FE;
  if ( reg_value_buf.p_wr > 0x1FE )
    reg_value_buf.p_wr = 0;
  else
    v16 = reg_value_buf.p_wr;
  if ( !v17 )
    reg_value_buf.p_wr = v16 + 1;
  reg_value_num = reg_value_buf.reg_value_num;
  v19 = reg_value_buf.reg_value_num > 0x1FE;
  if ( reg_value_buf.reg_value_num > 0x1FE )
    reg_value_buf.reg_value_num = 511;
  else
    reg_value_num = reg_value_buf.reg_value_num;
  if ( !v19 )
    reg_value_buf.reg_value_num = reg_value_num + 1;
  goto LABEL_35;
}

//----- (00031F08) --------------------------------------------------------
void __fastcall read_asic_register(
        unsigned __int8 chain,
        unsigned __int8 mode,
        unsigned __int8 chip_addr,
        unsigned __int8 reg_addr)
{
  int v4; // r8
  int v5; // r6
  int v6; // r5
  int v7; // r3
  unsigned int v8; // r0
  int v9; // r3
  int v10; // r1
  int v11; // r4
  unsigned int hash_on_plug; // r0
  unsigned __int8 buf[5]; // [sp+1Ch] [bp-82Ch] BYREF
  unsigned int cmd_buf[3]; // [sp+24h] [bp-824h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp-818h] BYREF

  v4 = chain;
  v5 = reg_addr;
  buf[3] = 0;
  v6 = chip_addr;
  buf[4] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    if ( mode )
      buf[0] = 84;
    else
      buf[0] = 68;
    buf[1] = 5;
    buf[2] = chip_addr;
    buf[3] = reg_addr;
    v9 = CRC5(buf, 0x20u);
    buf[4] = v9;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s:VIL buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x",
        (const char *)_FUNCTION___13236,
        buf[0],
        5,
        v6,
        v5,
        v9);
      applog(7, tmp42, 0);
      v6 = buf[2];
      v5 = buf[3];
      v9 = buf[4];
      v10 = buf[1] << 16;
    }
    else
    {
      v10 = 327680;
    }
    v11 = 3001;
    cmd_buf[1] = v9 << 24;
    cmd_buf[0] = v5 | v10 | (buf[0] << 24) | (v6 << 8);
    while ( (get_BC_write_command() & 0x80000000) != 0 )
    {
      cgsleep_ms(1);
      if ( !--v11 )
      {
        hash_on_plug = get_hash_on_plug();
        sprintf((char *)tmp42, "Error: clement debug: wait BC ready timeout, PLUG ON=0x%08x..\n", hash_on_plug);
        writeInitLogFile(tmp42);
        break;
      }
    }
  }
  else
  {
    buf[1] = chip_addr;
    buf[2] = reg_addr;
    buf[0] = 4;
    if ( mode )
      buf[0] = -124;
    v7 = CRC5(buf, 0x1Bu);
    buf[3] = v7;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13236,
        buf[0],
        v6,
        v5,
        v7);
      applog(7, tmp42, 0);
      v6 = buf[1];
      v5 = buf[2];
      v7 = buf[3];
    }
    cmd_buf[0] = v7 | (buf[0] << 24) | (v6 << 16) | (v5 << 8);
  }
  set_BC_command_buffer(cmd_buf);
  v8 = get_BC_write_command();
  set_BC_write_command((v4 << 16) | 0x80800000 | v8 & 0xFFF0FFFF);
}

//----- (000320D8) --------------------------------------------------------
void __fastcall read_temp(
        unsigned __int8 device,
        unsigned int reg,
        unsigned __int8 data,
        unsigned __int8 write,
        unsigned __int8 chip_addr,
        int chain)
{
  int v6; // r7
  int v7; // r0
  signed int v8; // r4
  unsigned __int8 buf[9]; // [sp+0h] [bp-30h] BYREF
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-24h] BYREF

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    buf[6] = reg;
    buf[7] = data;
    buf[5] = write | device;
    buf[2] = chip_addr;
    v6 = data | 0x1000000 | ((unsigned __int8)reg << 8) | ((write | device) << 16);
    buf[3] = 32;
    buf[4] = 1;
    qmemcpy(buf, "H\t", 2);
    v7 = CRC5(buf, 0x40u);
    buf[8] = v7;
    cmd_buf[2] = v7 << 24;
    cmd_buf[1] = v6;
    cmd_buf[0] = (chip_addr << 8) | 0x48090020;
    while ( 1 )
    {
      v8 = get_BC_write_command();
      if ( v8 >= 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    set_BC_write_command((chain << 16) | 0x80800000 | v8 & 0xFFF0FFFF);
  }
  else
  {
    printf("fil mode do not support temp reading");
  }
}

//----- (000321B8) --------------------------------------------------------
void __fastcall reset_one_hashboard(int chainIndex)
{
  set_QN_write_data_command((chainIndex << 16) | 0x8000000F);
  while ( (get_QN_write_data_command() & 0x80000000) != 0 )
    usleep(0x2710u);
  j_sleep(1u);
}

//----- (000321E4) --------------------------------------------------------
bool __fastcall check_asic_reg_oneChain(int chainIndex, unsigned int reg)
{
  int v4; // r8
  unsigned int v5; // r12
  unsigned int reg_value_num; // r8
  int v7; // r11
  unsigned int v8; // r3
  unsigned int v9; // r2
  int i; // r9
  char *v11; // r0
  int v12; // r0
  unsigned int v13; // r3
  unsigned __int8 *v14; // r2
  int v15; // r3
  bool v16; // nf
  _BOOL4 v18; // r3
  bool v19; // [sp+4h] [bp-86Ch]
  int reg_processed_counter; // [sp+1Ch] [bp-854h]
  uint64_t tmp_rate; // [sp+20h] [bp-850h]
  int read_num; // [sp+28h] [bp-848h]
  int v23; // [sp+2Ch] [bp-844h]
  unsigned __int8 reg_buf[5]; // [sp+34h] [bp-83Ch]
  unsigned __int8 rate_buf[10]; // [sp+3Ch] [bp-834h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+48h] [bp-828h] BYREF

  v23 = chainIndex + 2;
  v4 = 0;
  reg_buf[0] = 0;
  reg_buf[1] = 0;
  reg_buf[2] = 0;
  reg_buf[3] = 0;
  reg_buf[4] = 0;
  while ( 1 )
  {
    clear_register_value_buf();
    if ( *((_DWORD *)&dev->current_job_start_address + v23) != 1 )
      return 1;
    read_asic_register(chainIndex, 1u, 0, reg);
    if ( !reg )
      dev->chain_asic_num[chainIndex] = 0;
    if ( v4 > 2 )
    {
      tmp_rate = 0LL;
      read_num = 0;
      goto LABEL_41;
    }
    reg_processed_counter = 0;
    tmp_rate = 0LL;
    read_num = 0;
LABEL_8:
    cgsleep_ms(300);
    pthread_mutex_lock(&reg_mutex);
    if ( reg_value_buf.reg_value_num <= 0x1FE && reg_value_buf.p_rd <= 0x1FE )
      break;
    ++v4;
    pthread_mutex_unlock(&reg_mutex);
  }
  if ( !reg_value_buf.reg_value_num )
  {
    ++v4;
    cgsleep_ms(100);
    pthread_mutex_unlock(&reg_mutex);
    if ( v4 != 3 )
      goto LABEL_8;
LABEL_41:
    if ( !reg )
      goto LABEL_52;
    v13 = dev->chain_asic_num[chainIndex];
LABEL_43:
    if ( v13 == read_num )
    {
      rate[chainIndex] = tmp_rate;
      suffix_string_c5(tmp_rate, displayed_rate[chainIndex], 0x20u, 6, v19);
      v18 = opt_debug;
      *(_DWORD *)&show_last_freq[16][4 * chainIndex + 28] = 0;
      if ( v18 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: chain %d hashrate is %s\n",
          (const char *)_FUNCTION___13343,
          chainIndex,
          (const char *)displayed_rate[chainIndex]);
        applog(7, tmp42, 0);
      }
    }
    if ( !read_num || status_error )
    {
      v14 = &show_last_freq[2][4 * chainIndex + 68];
      v15 = *((_DWORD *)v14 + 886) + 1;
      v16 = *((_DWORD *)v14 + 886) - 2 < 0;
      *((_DWORD *)v14 + 886) = v15;
      if ( !(v16 ^ __OFSUB__(v15, 3) | (v15 == 3)) || status_error )
      {
        rate[chainIndex] = 0LL;
        suffix_string_c5(0LL, displayed_rate[chainIndex], 0x20u, 6, v19);
      }
    }
    clear_register_value_buf();
    return 1;
  }
  reg_processed_counter += reg_value_buf.reg_value_num;
  if ( reg_processed_counter <= 600 )
  {
    v5 = reg;
    reg_value_num = reg_value_buf.reg_value_num;
    v7 = 0;
    while ( 1 )
    {
      v8 = reg_value_buf.p_rd + 1;
      if ( chainIndex != reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number )
        break;
      reg_buf[3] = *(&reg_value_buf.p_rd + 2 * v8);
      reg_buf[2] = BYTE1(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
      reg_buf[1] = BYTE2(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
      v9 = HIBYTE(*(&reg_value_buf.p_rd + 2 * ++reg_value_buf.p_rd));
      reg_buf[0] = v9;
      --reg_value_buf.reg_value_num;
      if ( reg_value_buf.p_rd > 0x1FE )
        reg_value_buf.p_rd = 0;
      if ( v5 )
      {
        if ( v5 == 12 )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: the asic freq is 0x%x\n",
              (const char *)_FUNCTION___13343,
              reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            applog(7, tmp42, 0);
            v5 = 12;
          }
        }
        else if ( v5 == 8 )
        {
          for ( i = 0; ; v9 = reg_buf[i] )
          {
            v11 = (char *)&rate_buf[2 * i++];
            sprintf(v11, "%02x", v9);
            if ( i == 4 )
              break;
          }
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: hashrate is %s\n",
              (const char *)_FUNCTION___13343,
              (const char *)rate_buf);
            applog(7, tmp42, 0);
          }
          ++read_num;
          v12 = strtol((const char *)rate_buf, 0, 16);
          v5 = 8;
          tmp_rate += (__int64)v12 << 24;
        }
LABEL_15:
        if ( ++v7 == reg_value_num )
          goto LABEL_21;
      }
      else
      {
        ++v7;
        ++dev->chain_asic_num[chainIndex];
        if ( v7 == reg_value_num )
        {
LABEL_21:
          reg = v5;
          if ( v5 || dev->chain_asic_num[chainIndex] != 18 )
          {
            v4 = 0;
            pthread_mutex_unlock(&reg_mutex);
            goto LABEL_8;
          }
          pthread_mutex_unlock(&reg_mutex);
LABEL_52:
          v13 = dev->chain_asic_num[chainIndex];
          if ( dev->max_asic_num_in_one_chain < v13 )
            dev->max_asic_num_in_one_chain = v13;
          goto LABEL_43;
        }
      }
    }
    ++reg_value_buf.p_rd;
    --reg_value_buf.reg_value_num;
    if ( v8 > 0x1FE )
      reg_value_buf.p_rd = 0;
    goto LABEL_15;
  }
  pthread_mutex_unlock(&reg_mutex);
  return 0;
}
// 32532: variable 'v19' is possibly undefined

//----- (00032614) --------------------------------------------------------
unsigned int __fastcall check_asic_reg_with_addr(
        unsigned int reg,
        unsigned int chip_addr,
        unsigned int chain,
        int check_num)
{
  int v4; // r5
  unsigned int reg_value_num; // r8
  unsigned int reg_value; // r11
  unsigned __int8 v10; // [sp+14h] [bp-834h]
  unsigned __int8 reg_addr; // [sp+18h] [bp-830h]
  int v12; // [sp+1Ch] [bp-82Ch]
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-828h] BYREF

  LOBYTE(v4) = chain;
  v10 = chip_addr;
  reg_addr = reg;
  v12 = 0;
  clear_register_value_buf();
  read_asic_register(v4, 0, v10, reg_addr);
  cgsleep_ms(80);
  while ( 1 )
  {
LABEL_2:
    pthread_mutex_lock(&reg_mutex);
    reg_value_num = reg_value_buf.reg_value_num;
    pthread_mutex_unlock(&reg_mutex);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: reg_value_num %d", (const char *)_FUNCTION___13373, reg_value_num);
      applog(7, tmp42, 0);
    }
    if ( reg_value_num <= 0x1FE && reg_value_buf.p_rd <= 0x1FE && reg_value_num )
      break;
    clear_register_value_buf();
    ++v12;
    read_asic_register(v4, 0, v10, reg_addr);
    cgsleep_ms(80);
    if ( v12 == 5 )
    {
      clear_register_value_buf();
      return 0;
    }
  }
  v4 = 0;
  pthread_mutex_lock(&reg_mutex);
  while ( 1 )
  {
    ++v4;
    reg_value = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: chip %x reg %x reg_buff %x", _FUNCTION___13373, chip_addr, reg, reg_value);
      applog(7, tmp42, 0);
    }
    ++reg_value_buf.p_rd;
    --reg_value_buf.reg_value_num;
    if ( reg_value_buf.p_rd <= 0x1FE )
      reg_value_buf.p_rd = 0;
    if ( reg == 32 )
      break;
    if ( v4 == reg_value_num )
    {
      pthread_mutex_unlock(&reg_mutex);
      goto LABEL_2;
    }
  }
  if ( (reg_value & 0xC0000000) != 0 )
    reg_value = 0;
  pthread_mutex_unlock(&reg_mutex);
  clear_register_value_buf();
  return reg_value;
}

//----- (000327B4) --------------------------------------------------------
unsigned int __fastcall wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update)
{
  unsigned int v5; // r4

  v5 = check_asic_reg_with_addr(0x20u, chip_addr, chain, 1);
  if ( !v5 )
  {
    cgsleep_ms(1);
    v5 = check_asic_reg_with_addr(0x20u, chip_addr, chain, 1);
    if ( !v5 )
      cgsleep_ms(1);
  }
  return v5;
}

//----- (000327EC) --------------------------------------------------------
unsigned int __fastcall check_reg_temp(
        unsigned __int8 device,
        unsigned int reg,
        unsigned __int8 data,
        unsigned __int8 write,
        unsigned __int8 chip_addr,
        int chain)
{
  int v9; // r10
  int v10; // r7
  unsigned int v11; // r6

  v9 = data;
  if ( write )
  {
    v10 = 0;
    while ( 1 )
    {
      ++v10;
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, v9, write, chip_addr, chain);
      wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, 0, 0, chip_addr, chain);
      v11 = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      if ( BYTE1(v11) == reg || (unsigned __int8)v11 == v9 )
        break;
      if ( v10 != 1 )
        return 0;
    }
  }
  else
  {
    v10 = 0;
    while ( 1 )
    {
      ++v10;
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, v9, 0, chip_addr, chain);
      cgsleep_ms(1);
      v11 = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      if ( BYTE1(v11) == reg && (unsigned __int8)v11 != 255 && (unsigned __int8)v11 != 127 )
        break;
      if ( v10 != 1 )
        return 0;
    }
  }
  if ( v10 == 2 )
    return 0;
  return v11;
}

//----- (000328D0) --------------------------------------------------------
int8_t __fastcall calc_offset(int remote, int local)
{
  float v2; // s14

  v2 = (double)remote - ((double)local + 273.15) * 0.101190476 - (double)local;
  return (int)(float)(0.0 - v2);
}

//----- (00032924) --------------------------------------------------------
int16_t __fastcall get_remote(int16_t remote)
{
  int v1; // r3
  float v2; // s16
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-810h] BYREF

  v1 = (__int16)(remote - 64);
  v2 = ((double)v1 * 1.008 - 27.8613) / 1.11;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "remote : %d temp : %f", v1, v2);
    applog(7, tmp42, 0);
  }
  return (int)v2;
}

//----- (000329CC) --------------------------------------------------------
int16_t __fastcall get_local(int16_t local)
{
  return local - 64;
}

//----- (000329D4) --------------------------------------------------------
int8_t __fastcall do_calibration_sensor_offset(
        unsigned __int8 device,
        unsigned __int8 chip_addr,
        int chain,
        int temp_chip_index)
{
  int v5; // r5
  unsigned __int8 v8; // r0
  char v9; // r2
  unsigned __int8 *v10; // r3
  unsigned __int8 *v11; // r7
  int v12; // r8
  int v13; // r7
  float v14; // s14
  int v15; // s14
  unsigned __int8 logstr[256]; // [sp+10h] [bp-118h] BYREF

  v5 = chip_addr;
  v8 = check_reg_temp(device, 0xFEu, 0, 0, chip_addr, chain);
  if ( v8 == 26 )
    v9 = 1;
  v10 = (unsigned __int8 *)dev + 8 * chain;
  v11 = &v10[temp_chip_index];
  if ( v8 == 26 )
    v10 = &show_last_freq[2][68];
  v11[1128] = v8;
  if ( v8 == 26 )
    v10[3608] = v9;
  check_reg_temp(device, 9u, 4u, 1u, v5, chain);
  check_reg_temp(device, 0x11u, 0, 1u, v5, chain);
  v12 = (char)(check_reg_temp(device, 0, 0, 0, v5, chain) - 64);
  v13 = (char)(check_reg_temp(device, 1u, 0, 0, v5, chain) & 0xBF);
  v14 = (double)v13 - ((double)v12 + 273.15) * 0.101190476 - (double)v12;
  v15 = (int)(float)(0.0 - v14);
  check_reg_temp(device, 0x11u, v15, 1u, v5, chain);
  sprintf(
    (char *)logstr,
    "New offset Chain[%d] chip[%d] local:%hhd remote:%hhd offset:%hhd \n",
    chain,
    v5,
    v12,
    v13,
    (char)v15);
  writeInitLogFile(logstr);
  return v15;
}
// 32A10: variable 'v9' is possibly undefined

//----- (00032AF0) --------------------------------------------------------
void __fastcall set_baud_with_addr(
        unsigned __int8 bauddiv,
        int mode,
        unsigned __int8 chip_addr,
        int chain,
        int iic,
        int open_core,
        int bottom_or_mid)
{
  int v7; // r6
  int v9; // r4
  int v10; // r0
  int v11; // r3
  int v12; // r7
  int v13; // r4
  int v14; // r0
  signed int v15; // r4
  unsigned int v16; // r0
  unsigned __int8 buf[9]; // [sp+10h] [bp-830h] BYREF
  unsigned int cmd_buf[3]; // [sp+1Ch] [bp-824h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+28h] [bp-818h] BYREF

  v7 = chip_addr;
  buf[3] = 0;
  buf[4] = 0;
  buf[5] = 0;
  buf[6] = 0;
  buf[7] = 0;
  buf[8] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    if ( mode )
      buf[0] = 88;
    else
      buf[0] = 72;
    buf[4] = 64;
    buf[2] = chip_addr;
    buf[1] = 9;
    buf[3] = 28;
    if ( bottom_or_mid )
      buf[5] = 32;
    else
      buf[5] = 33;
    if ( iic )
    {
      v12 = 96;
      v13 = bauddiv & 0x1F | 0x40;
      buf[7] = 96;
      buf[6] = bauddiv & 0x1F | 0x40;
    }
    else
    {
      v13 = bauddiv & 0x1F;
      v12 = 0;
      buf[6] = bauddiv & 0x1F;
    }
    if ( open_core )
    {
      v13 |= 0x80u;
      buf[6] = v13;
    }
    buf[8] = 0;
    v14 = CRC5(buf, 0x40u);
    buf[8] = v14;
    cmd_buf[2] = v14 << 24;
    cmd_buf[0] = (buf[0] << 24) | 0x9001C | (v7 << 8);
    cmd_buf[1] = v12 | (buf[5] << 16) | 0x40000000 | (v13 << 8);
    while ( 1 )
    {
      v15 = get_BC_write_command();
      if ( v15 >= 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    set_BC_write_command((chain << 16) | 0x80800000 | v15 & 0xFFF0FFFF);
  }
  else
  {
    v9 = bauddiv & 0x1F;
    buf[0] = -122;
    buf[2] = bauddiv & 0x1F;
    buf[1] = 16;
    v10 = CRC5(buf, 0x1Bu);
    buf[3] = v10;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13448,
        134,
        16,
        v9,
        v10);
      applog(7, tmp42, 0);
      v9 = buf[2];
      v10 = buf[3];
      v11 = (buf[0] << 24) | (buf[1] << 16);
    }
    else
    {
      v11 = -2045771776;
    }
    cmd_buf[0] = v11 | v10 | (v9 << 8);
    set_BC_command_buffer(cmd_buf);
    v16 = get_BC_write_command();
    set_BC_write_command(v16 & 0xFFF0FFFF | (chain << 16) | 0x80800000);
  }
}

//----- (00032CD4) --------------------------------------------------------
int8_t __fastcall calibration_sensor_offset_0(unsigned __int8 device, int chain)
{
  char *v3; // r7
  all_parameters *v4; // r0
  char v5; // r3
  int v6; // r8
  uint64_t *v7; // r10
  char *v8; // r2
  int v9; // r1
  int v10; // r6
  unsigned __int8 v11; // r0
  int v12; // r12
  char *v13; // r3
  unsigned __int8 *v14; // r12
  all_parameters *v15; // r3
  int v16; // r11
  int v17; // r2
  bool v18; // zf
  int8_t v19; // r0
  all_parameters *v20; // r6
  all_parameters *v22; // r3
  int v23; // r10
  int v24; // r0
  all_parameters *v25; // r1
  int v26; // r1
  unsigned int v27; // [sp+24h] [bp-13Ch]
  int v29; // [sp+2Ch] [bp-134h]
  char temp_offset[8]; // [sp+30h] [bp-130h] BYREF
  unsigned __int8 logstr[256]; // [sp+38h] [bp-128h] BYREF

  v29 = chain + 1;
  get_temperature_offset_value(chain, (unsigned __int8 *)temp_offset);
  v27 = chain;
  v3 = temp_offset;
  sprintf(
    (char *)logstr,
    "Chain[J%d] PIC temp offset=%d,%d,%d,%d,%d,%d,%d,%d\n",
    v29,
    temp_offset[0],
    temp_offset[1],
    temp_offset[2],
    temp_offset[3],
    temp_offset[4],
    temp_offset[5],
    temp_offset[6],
    temp_offset[7]);
  writeInitLogFile(logstr);
  v4 = dev;
  v5 = 0;
  v6 = 0;
  v7 = &h + chain;
  v8 = (char *)dev + chain;
  dev->chain_asic_temp_num[chain] = 0;
  do
  {
    v9 = *v3;
    if ( v9 > 0 )
    {
      v10 = 8 * chain;
      v4->TempChipAddr[v27][v5] = 4 * (v9 - 1);
      *((_BYTE *)v7 + dev->chain_asic_temp_num[chain] + 80) = v3[1];
      set_baud_with_addr(v4->baud, 0, v4->TempChipAddr[v27][v8[1112]], chain, 1, 0, 1);
      check_asic_reg_with_addr(0x1Cu, dev->TempChipAddr[v27][dev->chain_asic_temp_num[chain]], chain, 1);
      v11 = check_reg_temp(device, 0xFEu, 0, 0, dev->TempChipAddr[v27][dev->chain_asic_temp_num[chain]], chain);
      v12 = dev->chain_asic_temp_num[chain];
      v13 = (char *)dev + v27 * 8 + v12;
      v13[1128] = v11;
      sprintf(
        (char *)logstr,
        "Chain[J%d] chip[%d] use PIC middle temp offset=%d typeID=%02x\n",
        v29,
        (unsigned __int8)v13[1256],
        *((char *)v7 + v12 + 80),
        v11);
      writeInitLogFile(logstr);
      v15 = dev;
      v16 = dev->chain_asic_temp_num[chain];
      v17 = dev->TempChipType[v27][v16];
      v18 = v17 == 85;
      if ( v17 != 85 )
        v18 = v17 == 26;
      if ( !v18 )
      {
        dev->chain_asic_temp_num[chain] = 0;
        goto LABEL_16;
      }
      if ( v17 == 26 )
      {
        v14 = &show_last_freq[2][68];
        LOBYTE(v10) = 1;
      }
      if ( v17 == 26 )
        v14[3608] = v10;
      v19 = do_calibration_sensor_offset(device, v15->TempChipAddr[v27][v16], chain, v16);
      v20 = dev;
      *((_BYTE *)v7 + v16 + 80) = v19;
      sprintf(
        (char *)logstr,
        "Chain[J%d] chip[%d] get middle temp offset=%d typeID=%02x\n",
        v29,
        v20->TempChipAddr[v27][v6],
        *((char *)v7 + v20->chain_asic_temp_num[chain] + 80),
        v20->TempChipType[v27][v20->chain_asic_temp_num[chain]]);
      writeInitLogFile(logstr);
      v4 = dev;
      v8 = (char *)dev + chain;
      v5 = dev->chain_asic_temp_num[chain] + 1;
      dev->chain_asic_temp_num[chain] = v5;
    }
    ++v6;
    v3 += 2;
  }
  while ( v6 != 4 );
  if ( v5 > 0 )
    return 0;
  v10 = 8 * chain;
LABEL_16:
  sprintf((char *)logstr, "Warning: Chain[J%d] has no temp offset in PIC! will fix it\n", v29);
  writeInitLogFile(logstr);
  v22 = dev;
  v23 = 0;
  dev->TempChipAddr[chain][0] = 0;
  v22->chain_asic_temp_num[chain] = 2;
  v22->TempChipAddr[0][v10 + 1] = 32;
  do
  {
    set_baud_with_addr(v22->baud, 0, v22->TempChipAddr[0][v10 + v23], chain, 1, 0, 1);
    check_asic_reg_with_addr(0x1Cu, dev->TempChipAddr[0][v10 + v23], chain, 1);
    v24 = do_calibration_sensor_offset(device, dev->TempChipAddr[0][v10 + v23], chain, v23);
    v25 = dev;
    middle_Offset[v10 + v23] = v24;
    v26 = (int)v25 + v10 + v23++;
    sprintf(
      (char *)logstr,
      "Chain[J%d] chip[%d] get middle temp offset=%d typeID=%02x\n",
      v29,
      *(unsigned __int8 *)(v26 + 1256),
      v24,
      *(unsigned __int8 *)(v26 + 1128));
    writeInitLogFile(logstr);
    v22 = dev;
  }
  while ( v23 < dev->chain_asic_temp_num[chain] );
  return 0;
}
// 32E4E: variable 'v14' is possibly undefined

//----- (00032FB8) --------------------------------------------------------
int8_t __fastcall calibration_sensor_offset(unsigned __int8 device, int chain)
{
  if ( fpga_version <= 13 )
  {
    if ( chain % 3 != 1 )
      return 0;
LABEL_3:
    calibration_sensor_offset_0(device, chain);
    return 0;
  }
  if ( (chain & 0xFFFFFFFD) == 8 || chain == 12 )
    goto LABEL_3;
  return 0;
}

//----- (00032FFC) --------------------------------------------------------
void clearTempLogFile()
{
  FILE *v0; // r0

  v0 = fopen("/tmp/temp", "w");
  if ( v0 )
    sub_A0DC(v0);
}

//----- (0003301C) --------------------------------------------------------
void __fastcall writeLogFile_0(unsigned __int8 *logstr)
{
  FILE *v2; // r4
  size_t v3; // r0

  v2 = fopen("/tmp/temp", "a+");
  if ( v2 )
  {
    v3 = strlen((const char *)logstr);
    fwrite(logstr, 1u, v3, v2);
    sub_A0DC(v2);
  }
}

//----- (00033054) --------------------------------------------------------
bool __fastcall check_asic_reg(unsigned int reg)
{
  double v1; // d0
  int v3; // r4
  int v4; // r11
  unsigned int reg_value_num; // r5
  int v6; // r4
  int v7; // r12
  unsigned int v8; // r3
  unsigned int v9; // r2
  int v10; // r8
  int v11; // r10
  int v12; // r11
  int i; // r4
  char *v14; // r0
  uint64_t v15; // r0
  unsigned int v16; // r3
  int v17; // r3
  bool v18; // nf
  unsigned int p_rd; // r3
  const char *v20; // r1
  bool v22; // [sp+4h] [bp-194h]
  int v23; // [sp+8h] [bp-190h]
  unsigned int v24; // [sp+Ch] [bp-18Ch]
  int reg_processed_counter; // [sp+18h] [bp-180h]
  int read_num; // [sp+1Ch] [bp-17Ch]
  int v27; // [sp+20h] [bp-178h]
  uint64_t *v28; // [sp+24h] [bp-174h]
  uint64_t tmp_rate; // [sp+28h] [bp-170h]
  int v30; // [sp+30h] [bp-168h]
  unsigned __int8 reg_buf[5]; // [sp+3Ch] [bp-15Ch]
  unsigned __int8 rate_buf[10]; // [sp+44h] [bp-154h] BYREF
  unsigned __int8 displayed_rate_asic[32]; // [sp+50h] [bp-148h] BYREF
  unsigned __int8 logstr[256]; // [sp+70h] [bp-128h] BYREF

  v3 = 0;
  reg_buf[0] = 0;
  reg_buf[1] = 0;
  reg_buf[2] = 0;
  reg_buf[3] = 0;
  reg_buf[4] = 0;
  while ( 2 )
  {
    v27 = 0;
    v4 = 0;
    v28 = rate;
    clear_register_value_buf();
    while ( dev->chain_exist[v4] != 1 )
    {
LABEL_3:
      ++v4;
      ++v28;
      ++v27;
      if ( v4 == 16 )
        return 1;
    }
    read_asic_register(v4, 1u, 0, reg);
    if ( reg )
    {
      if ( reg == 8 )
      {
        sprintf((char *)logstr, "\nget RT hashrate from Chain[%d]: (asic index start from 1-%d)\n", v4, 18);
        writeLogFile_0(logstr);
      }
    }
    else
    {
      dev->chain_asic_num[v4] = 0;
    }
    if ( v3 > 2 )
    {
      tmp_rate = 0LL;
      read_num = 0;
      goto LABEL_38;
    }
    reg_processed_counter = 0;
    read_num = 0;
    tmp_rate = 0LL;
LABEL_9:
    cgsleep_ms(300);
    pthread_mutex_lock(&reg_mutex);
    reg_value_num = reg_value_buf.reg_value_num;
    if ( reg_value_buf.reg_value_num > 0x1FE || reg_value_buf.p_rd > 0x1FE )
    {
      ++v3;
      pthread_mutex_unlock(&reg_mutex);
      continue;
    }
    break;
  }
  if ( !reg_value_buf.reg_value_num )
  {
    ++v3;
    cgsleep_ms(100);
    pthread_mutex_unlock(&reg_mutex);
    if ( v3 != 3 )
      goto LABEL_9;
LABEL_38:
    if ( !reg )
      goto LABEL_56;
    v16 = dev->chain_asic_num[v4];
LABEL_40:
    if ( v16 == read_num )
    {
      *v28 = tmp_rate;
      suffix_string_c5(tmp_rate, displayed_rate[v4], 0x20u, 6, v22);
      rate_error[v27] = 0;
    }
    if ( !read_num || status_error )
    {
      v17 = rate_error[v27] + 1;
      v18 = rate_error[v27] - 2 < 0;
      rate_error[v27] = v17;
      if ( !(v18 ^ __OFSUB__(v17, 3) | (v17 == 3)) || status_error )
      {
        *v28 = 0LL;
        suffix_string_c5(0LL, displayed_rate[v4], 0x20u, 6, v22);
      }
    }
    v3 = 0;
    clear_register_value_buf();
    goto LABEL_3;
  }
  reg_processed_counter += reg_value_buf.reg_value_num;
  if ( reg_processed_counter <= 600 )
  {
    v6 = 0;
    v7 = v4;
    v24 = reg;
    v30 = v4;
    while ( 1 )
    {
      while ( 1 )
      {
        v8 = reg_value_buf.p_rd + 1;
        if ( reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number != v7 )
        {
          ++reg_value_buf.p_rd;
          --reg_value_buf.reg_value_num;
          if ( v8 > 0x1FE )
            reg_value_buf.p_rd = 0;
          goto LABEL_17;
        }
        reg_buf[3] = *(&reg_value_buf.p_rd + 2 * v8);
        reg_buf[2] = BYTE1(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
        reg_buf[1] = BYTE2(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
        v9 = HIBYTE(*(&reg_value_buf.p_rd + 2 * ++reg_value_buf.p_rd));
        reg_buf[0] = v9;
        --reg_value_buf.reg_value_num;
        if ( reg_value_buf.p_rd > 0x1FE )
          reg_value_buf.p_rd = 0;
        if ( v24 )
          break;
        ++v6;
        ++dev->chain_asic_num[v7];
        if ( v6 == reg_value_num )
        {
LABEL_23:
          reg = v24;
          v4 = v7;
          if ( v24 || dev->chain_asic_num[v7] != 18 )
          {
            v3 = 0;
            pthread_mutex_unlock(&reg_mutex);
            goto LABEL_9;
          }
          pthread_mutex_unlock(&reg_mutex);
LABEL_56:
          v16 = dev->chain_asic_num[v4];
          if ( dev->max_asic_num_in_one_chain < v16 )
            dev->max_asic_num_in_one_chain = v16;
          goto LABEL_40;
        }
      }
      if ( v24 == 12 )
      {
        p_rd = reg_value_buf.p_rd;
        v20 = "chain[%d]: the asic freq is 0x%x\n";
      }
      else
      {
        if ( v24 != 24 )
        {
          if ( v24 == 8 )
          {
            v10 = read_num + 1;
            if ( read_num + 1 <= 18 )
            {
              v11 = v6;
              v12 = v7;
              for ( i = 0; ; v9 = reg_buf[i] )
              {
                v14 = (char *)&rate_buf[2 * i++];
                sprintf(v14, "%02x", v9);
                if ( i == 4 )
                  break;
              }
              v24 = 8;
              v6 = v11;
              v15 = (__int64)strtol((const char *)rate_buf, 0, 16) << 24;
              tmp_rate += v15;
              suffix_string_c5(v15, displayed_rate_asic, 0x20u, 6, v22);
              sprintf((char *)logstr, "Asic[%02d]=%s ", v10, (const char *)displayed_rate_asic);
              writeLogFile_0(logstr);
              strtod((const char *)displayed_rate_asic, 0);
              v7 = v12;
              chain_asic_RT[v30][read_num] = v1;
              if ( (v10 & 7) == 0 || read_num == 17 )
              {
                strcpy((char *)logstr, "\n");
                writeLogFile_0(logstr);
                v7 = v12;
              }
            }
            ++read_num;
          }
          goto LABEL_17;
        }
        p_rd = reg_value_buf.p_rd;
        v20 = "chain[%d]: the asic TICKET_MASK is 0x%x\n";
      }
      v23 = v7;
      sprintf((char *)logstr, v20, v7, reg_value_buf.reg_buffer[p_rd].reg_value);
      writeInitLogFile(logstr);
      v7 = v23;
LABEL_17:
      if ( ++v6 == reg_value_num )
        goto LABEL_23;
    }
  }
  pthread_mutex_unlock(&reg_mutex);
  return 0;
}
// 332BA: variable 'v22' is possibly undefined
// 332F0: variable 'v1' is possibly undefined

//----- (00033498) --------------------------------------------------------
void showAllBadRTInfo()
{
  int v0; // r2
  int v1; // r6
  int v2; // r4
  int v3; // r5
  double *v4; // r5
  double v5; // d7
  unsigned __int8 logstr[256]; // [sp+8h] [bp-120h] BYREF

  v0 = 1;
  do
  {
    v1 = v0 + 1;
    v2 = *(&dev->pwm_value + v0);
    if ( v2 == 1 )
    {
      v3 = v0 - 1;
      sprintf((char *)logstr, "Check Chain[J%d] ASIC RT error: (asic index start from 1-%d)\n", v0, 18);
      v4 = chain_asic_RT[v3];
      writeLogFile_0(logstr);
      do
      {
        v5 = *v4++;
        if ( v5 > 100.0 )
        {
          sprintf((char *)logstr, "Asic[%02d]=%f\n", v2, v5);
          writeLogFile_0(logstr);
        }
        ++v2;
      }
      while ( v2 != 19 );
    }
    v0 = v1;
  }
  while ( v1 != 17 );
}

//----- (00033530) --------------------------------------------------------
void set_PWM_according_to_temperature()
{
  int fan_pwm; // r9
  int v1; // r5
  int v2; // r2
  int v3; // r5
  int v4; // r8
  int v5; // r8
  int v6; // r3
  int v7; // r2
  int v8; // r3
  bool v9; // nf
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r3
  _BOOL4 v15; // r2
  int v16; // r1
  int v17; // r3
  unsigned __int8 v18; // r5
  _BOOL4 v19; // r2
  unsigned __int8 logstr[256]; // [sp+10h] [bp-920h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+110h] [bp-820h] BYREF

  fan_pwm = dev->fan_pwm;
  if ( is218_Temp )
    v1 = dev->temp_top1[0];
  else
    v1 = dev->temp_top1[1];
  temp_highest = v1;
  v2 = v1;
  v3 = v1 - last_temperature;
  sprintf(
    (char *)logstr,
    "set FAN speed according to: temp_highest=%d temp_top1[PWM_T]=%d temp_top1[TEMP_POS_LOCAL]=%d temp_change=%d fix_fan_steps=%d\n",
    v2,
    dev->temp_top1[1],
    dev->temp_top1[0],
    v3,
    fix_fan_steps_12944);
  writeLogFile_0(logstr);
  if ( is218_Temp )
  {
    v4 = temp_highest > 74;
    if ( !temp_highest )
      v4 = 1;
    if ( !v4 )
    {
      if ( (unsigned int)(v3 + 1) <= 2 )
        return;
      strcpy((char *)logstr, "set normal FAN speed...\n");
      writeLogFile_0(logstr);
      v14 = 2 * (temp_highest - 25);
      if ( ((temp_highest - 25) & 0x40000000) == 0 )
      {
        if ( v14 <= 100 )
        {
          LOBYTE(v4) = 2 * (temp_highest - 25);
          goto LABEL_37;
        }
        v4 = 100;
      }
      v14 = v4;
LABEL_37:
      last_temperature = temp_highest;
      v15 = opt_debug;
      dev->fan_pwm = v4;
      if ( v15 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "%s: Set PWM percent : %d\n", (const char *)_FUNCTION___12949, v14);
        applog(7, tmp42, 0);
      }
      set_PWM(v4);
      return;
    }
    set_PWM(0x64u);
    v10 = *(_DWORD *)"set full FAN speed...\n";
    v11 = *(_DWORD *)"full FAN speed...\n";
    v12 = *(_DWORD *)" FAN speed...\n";
    v13 = *(_DWORD *)" speed...\n";
    dev->fan_pwm = 100;
LABEL_30:
    *(_DWORD *)logstr = v10;
    *(_DWORD *)&logstr[4] = v11;
    *(_DWORD *)&logstr[8] = v12;
    *(_DWORD *)&logstr[12] = v13;
    strcpy((char *)&logstr[16], "ed...\n");
    writeLogFile_0(logstr);
    return;
  }
  v5 = temp_highest > 89;
  if ( !temp_highest )
    v5 = 1;
  if ( v5 || dev->temp_top1[1] > 89 || dev->temp_top1[0] > 74 )
  {
    set_PWM(0x64u);
    v8 = fix_fan_steps_12944;
    v9 = fix_fan_steps_12944 < 0;
    if ( fix_fan_steps_12944 < 0 )
      v8 = 0;
    dev->fan_pwm = 100;
    if ( v9 )
      fix_fan_steps_12944 = v8;
    v10 = *(_DWORD *)"set full FAN speed...\n";
    v11 = *(_DWORD *)"full FAN speed...\n";
    v12 = *(_DWORD *)" FAN speed...\n";
    v13 = *(_DWORD *)" speed...\n";
    goto LABEL_30;
  }
  if ( (unsigned int)(v3 + 1) > 2 )
  {
    sprintf((char *)logstr, "set normal FAN speed...with fix_fan_steps=%d\n", fix_fan_steps_12944);
    writeLogFile_0(logstr);
    v16 = temp_highest - 40;
    v17 = 2 * (temp_highest - 40 + fix_fan_steps_12944);
    if ( ((temp_highest - 40 + fix_fan_steps_12944) & 0x40000000) != 0 )
    {
      v17 = 0;
    }
    else if ( v17 > 100 )
    {
      if ( temp_highest <= 84 )
      {
        v17 = 100;
LABEL_50:
        v18 = v17;
        goto LABEL_51;
      }
      goto LABEL_62;
    }
    if ( temp_highest <= 84 )
      goto LABEL_50;
    if ( v17 != 100 )
    {
      ++fix_fan_steps_12944;
      v17 = 2 * (v16 + fix_fan_steps_12944);
      if ( ((v16 + fix_fan_steps_12944) & 0x40000000) != 0 )
      {
        v17 = 0;
        v18 = 0;
LABEL_51:
        last_temperature = temp_highest;
        v19 = opt_debug;
        dev->fan_pwm = v18;
        if ( v19 && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "%s: Set PWM percent : %d\n", (const char *)_FUNCTION___12949, v17);
          applog(7, tmp42, 0);
        }
        set_PWM(v18);
        return;
      }
      if ( v17 <= 100 )
        goto LABEL_50;
    }
LABEL_62:
    v18 = 100;
    v17 = 100;
    goto LABEL_51;
  }
  if ( temp_highest > 80 )
  {
    if ( temp_highest <= 84 || fan_pwm > 99 )
      return;
    v6 = fix_fan_steps_12944 + 1;
    v7 = fix_fan_steps_12944 + 1;
  }
  else
  {
    if ( fix_fan_steps_12944 < -39 || !fan_pwm )
      return;
    v6 = fix_fan_steps_12944 - 1;
    v7 = fix_fan_steps_12944 - 1;
  }
  fix_fan_steps_12944 = v6;
  sprintf((char *)logstr, "set normal FAN speed... with fix_fan_steps=%d\n", v7);
  writeLogFile_0(logstr);
  if ( ((temp_highest - 40 + fix_fan_steps_12944) & 0x40000000) == 0 )
  {
    if ( 2 * (temp_highest - 40 + fix_fan_steps_12944) > 100 )
      LOBYTE(v5) = 100;
    else
      LOBYTE(v5) = 2 * (temp_highest - 40 + fix_fan_steps_12944);
  }
  dev->fan_pwm = v5;
  set_PWM(v5);
}

//----- (00033830) --------------------------------------------------------
void setChainTempTooLowFlag()
{
  int v0; // r4
  int *v1; // r5
  all_parameters *v2; // r3
  int v3; // r3
  int v4; // r2
  unsigned __int8 logstr[256]; // [sp+8h] [bp-120h] BYREF

  v0 = 0;
  v1 = chain_temp_toolow;
  do
  {
    while ( 1 )
    {
      v2 = dev;
      *v1++ = 0;
      if ( v2->chain_exist[v0] == 1 )
      {
        v3 = v2->chain_asic_maxtemp[v0][1];
        if ( v3 > 0 )
        {
          v4 = lowest_testOK_temp[v0];
          if ( v4 <= 0 )
          {
            if ( v3 <= 79 )
            {
              sprintf((char *)logstr, "Detect Chain[%d] temp too low, will ignore: temp=%d\n", v0, v3);
              writeLogFile_0(logstr);
              *(v1 - 1) = 1;
            }
            goto LABEL_2;
          }
          if ( v4 > v3 )
            break;
        }
      }
LABEL_2:
      if ( ++v0 == 16 )
        goto LABEL_8;
    }
    sprintf(
      (char *)logstr,
      "Detect Chain[%d] temp too low, will ignore: temp=%d < %d\n",
      v0,
      v3,
      lowest_testOK_temp[v0]);
    ++v0;
    writeLogFile_0(logstr);
    *(v1 - 1) = 1;
  }
  while ( v0 != 16 );
LABEL_8:
  CheckChainTempTooLowFlag();
}

//----- (000338CC) --------------------------------------------------------
int isTempTooLow()
{
  int v0; // r1
  int v1; // r2
  all_parameters *i; // r4
  int v3; // r6
  int v4; // r3
  unsigned __int8 logstr[256]; // [sp+8h] [bp-118h] BYREF

  v0 = 0;
  v1 = 0;
  for ( i = dev; ; i = (all_parameters *)((char *)i + 64) )
  {
    if ( dev->chain_exist[v0] == 1 && !chain_temp_toolow[v0] )
    {
      v3 = i->chain_asic_temp[0][1][1];
      if ( v3 > 0 )
      {
        v4 = lowest_testOK_temp[v0];
        if ( v4 > 0 )
        {
          if ( v4 > v3 )
          {
            sprintf(
              (char *)logstr,
              "Detect temp too low: Chain[%d] lowest_testOK_temp=%d curtemp=%d\n",
              v1,
              v4,
              i->chain_asic_temp[0][1][1]);
            writeLogFile_0(logstr);
            return 1;
          }
          goto LABEL_2;
        }
        if ( v3 <= 79 )
          break;
      }
    }
LABEL_2:
    ++v0;
    ++v1;
    if ( v0 == 16 )
      return 0;
  }
  sprintf((char *)logstr, "Detect temp too low: Chain[%d] curtemp=%d\n", v1, i->chain_asic_temp[0][1][1]);
  writeLogFile_0(logstr);
  return 1;
}

//----- (00033958) --------------------------------------------------------
void updateLogFile()
{
  sub_A11C("cp /tmp/temp /tmp/lasttemp");
}

//----- (00033964) --------------------------------------------------------
void __fastcall saveTestID(int testID)
{
  FILE *v2; // r5
  unsigned __int8 testnumStr[32]; // [sp+0h] [bp-30h] BYREF

  v2 = fopen("/etc/config/testID", "wb");
  if ( v2 )
  {
    memset(testnumStr, 0, sizeof(testnumStr));
    sprintf((char *)testnumStr, "%d", testID);
    fwrite(testnumStr, 1u, 0x20u, v2);
    fclose(v2);
  }
}

//----- (000339B4) --------------------------------------------------------
FILE *readTestID()
{
  FILE *result; // r0
  FILE *v1; // r5
  unsigned __int8 testnumStr[32]; // [sp+0h] [bp-30h] BYREF

  result = fopen("/etc/config/testID", "rb");
  v1 = result;
  if ( result )
  {
    memset(testnumStr, 0, sizeof(testnumStr));
    fread(testnumStr, 1u, 0x20u, result);
    fclose(v1);
    return (FILE *)strtol((const char *)testnumStr, 0, 10);
  }
  return result;
}

//----- (00033A00) --------------------------------------------------------
int __fastcall fakeMiddleTempFromPCB(int local_temp)
{
  if ( local_temp <= 0 )
    return 0;
  if ( local_temp <= 50 )
    return local_temp + 25;
  if ( local_temp > 60 )
    return local_temp + 35;
  return local_temp + 30;
}

//----- (00033A1C) --------------------------------------------------------
void __fastcall chain_inactive(unsigned __int8 chain)
{
  int v1; // r5
  int v2; // r0
  int v3; // r3
  int v4; // r2
  int v5; // r1
  int v6; // r0
  unsigned int v7; // r3
  signed int v8; // r4
  unsigned int v9; // r0
  unsigned __int8 buf[5]; // [sp+1Ch] [bp-824h] BYREF
  unsigned int cmd_buf[3]; // [sp+24h] [bp-81Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp-810h] BYREF

  v1 = chain;
  buf[1] = 0;
  buf[2] = 0;
  buf[3] = 0;
  buf[4] = 5;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    buf[0] = 85;
    buf[1] = 5;
    v6 = CRC5(buf, 0x20u);
    buf[4] = v6;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x\n",
        (const char *)_FUNCTION___13640,
        85,
        5,
        0,
        0,
        v6);
      applog(7, tmp42, 0);
      v6 = buf[4];
      v7 = _byteswap_ulong(*(unsigned int *)buf);
    }
    else
    {
      v7 = 1426391040;
    }
    cmd_buf[0] = v7;
    cmd_buf[1] = v6 << 24;
    while ( 1 )
    {
      v8 = get_BC_write_command();
      if ( v8 >= 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    set_BC_write_command((v1 << 16) | 0x80800000 | v8 & 0xFFF0FFFF);
  }
  else
  {
    buf[0] = -123;
    v2 = CRC5(buf, 0x1Bu);
    v3 = v2;
    buf[3] = v2;
    v4 = opt_debug;
    if ( opt_debug && (use_syslog || (v4 = opt_log_output) != 0 || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13640,
        133,
        0,
        0,
        v2);
      applog(7, tmp42, 0);
      v3 = buf[3];
      v4 = buf[2] << 8;
      v5 = (buf[0] << 24) | (buf[1] << 16);
    }
    else
    {
      v5 = -2063597568;
    }
    cmd_buf[0] = v3 | v4 | v5;
    set_BC_command_buffer(cmd_buf);
    v9 = get_BC_write_command();
    set_BC_write_command(v9 & 0xFFF0FFFF | (v1 << 16) | 0x80800000);
  }
}

//----- (00033BC0) --------------------------------------------------------
void __fastcall set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address)
{
  int v3; // r6
  int v4; // r5
  int v5; // r0
  int v6; // r3
  int v7; // r2
  unsigned int v8; // r0
  int v9; // r0
  signed int v10; // r4
  unsigned __int8 buf[9]; // [sp+10h] [bp-830h] BYREF
  unsigned int cmd_buf[3]; // [sp+1Ch] [bp-824h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+28h] [bp-818h] BYREF

  v3 = chain;
  v4 = address;
  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    buf[2] = address;
    buf[1] = 5;
    buf[0] = 65;
    v9 = CRC5(buf, 0x20u);
    buf[4] = v9;
    cmd_buf[1] = v9 << 24;
    cmd_buf[0] = (v4 << 8) | 0x41050000;
    while ( 1 )
    {
      v10 = get_BC_write_command();
      if ( v10 >= 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    set_BC_write_command((v3 << 16) | 0x80800000 | v10 & 0xFFF0FFFF);
  }
  else
  {
    buf[1] = address;
    buf[0] = 1;
    if ( mode )
      buf[0] = -127;
    v5 = CRC5(buf, 0x1Bu);
    v6 = v5;
    buf[3] = v5;
    v7 = opt_debug;
    if ( opt_debug && (use_syslog || (v7 = opt_log_output) != 0 || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        (const char *)_FUNCTION___13654,
        buf[0],
        v4,
        0,
        v5);
      applog(7, tmp42, 0);
      v4 = buf[1];
      v6 = buf[3];
      v7 = buf[2] << 8;
    }
    cmd_buf[0] = v6 | v7 | (buf[0] << 24) | (v4 << 16);
    set_BC_command_buffer(cmd_buf);
    v8 = get_BC_write_command();
    set_BC_write_command(v8 & 0xFFF0FFFF | (v3 << 16) | 0x80800000);
  }
}

//----- (00033D04) --------------------------------------------------------
int __fastcall calculate_asic_number(int actual_asic_number)
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-808h] BYREF

  if ( actual_asic_number != 1 && actual_asic_number != 2 )
  {
    if ( (unsigned int)(actual_asic_number - 3) > 1 )
    {
      if ( (unsigned int)(actual_asic_number - 5) > 3 )
      {
        if ( (unsigned int)(actual_asic_number - 9) > 7 )
        {
          if ( (unsigned int)(actual_asic_number - 17) > 0xF )
          {
            if ( (unsigned int)(actual_asic_number - 33) > 0x1F )
            {
              if ( (unsigned int)(actual_asic_number - 65) > 0x3F )
              {
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf((char *)tmp42, 0x800u, "actual_asic_number = %d, but it is error\n", actual_asic_number);
                  applog(7, tmp42, 0);
                  return -1;
                }
                else
                {
                  return -1;
                }
              }
              else
              {
                return 128;
              }
            }
            else
            {
              return 64;
            }
          }
          else
          {
            return 32;
          }
        }
        else
        {
          return 16;
        }
      }
      else
      {
        return 8;
      }
    }
    else
    {
      return 4;
    }
  }
  return actual_asic_number;
}

//----- (00033DB0) --------------------------------------------------------
int __fastcall calculate_core_number(int actual_core_number)
{
  if ( actual_core_number != 1 && actual_core_number != 2 )
  {
    if ( (unsigned int)(actual_core_number - 3) <= 1 )
    {
      return 4;
    }
    else if ( (unsigned int)(actual_core_number - 5) <= 3 )
    {
      return 8;
    }
    else if ( (unsigned int)(actual_core_number - 9) <= 7 )
    {
      return 16;
    }
    else if ( (unsigned int)(actual_core_number - 17) <= 0xF )
    {
      return 32;
    }
    else if ( (unsigned int)(actual_core_number - 33) <= 0x1F )
    {
      return 64;
    }
    else if ( (unsigned int)(actual_core_number - 65) <= 0x3F )
    {
      return 128;
    }
    else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      return calculate_core_number_0(actual_core_number);
    }
    else
    {
      return -1;
    }
  }
  return actual_core_number;
}

//----- (00033E30) --------------------------------------------------------
void __fastcall software_set_address_onChain(int chainIndex)
{
  unsigned __int8 v1; // r7
  all_parameters *v2; // r2
  int v3; // r1
  char *v4; // r3
  unsigned __int8 v5; // r4
  unsigned int v6; // r5
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-818h] BYREF

  v1 = chainIndex;
  v2 = dev;
  v3 = opt_debug;
  v4 = (char *)&dev->temp[5] + 2;
  dev->check_bit = 0;
  if ( v3 )
  {
    if ( use_syslog || (LOBYTE(v3) = opt_log_output) != 0 || opt_log_level > 6 )
    {
      snprintf((char *)tmp42, 0x800u, "--- %s\n", (const char *)_FUNCTION___13675);
      applog(7, tmp42, 0);
      v2 = dev;
      v4 = (char *)&dev->temp[5] + 2;
      LOBYTE(v3) = dev->check_bit;
    }
  }
  v4[58] = v3 + 2;
  v2->addrInterval = 4;
  chain_inactive(v1);
  cgsleep_ms(30);
  chain_inactive(v1);
  cgsleep_ms(30);
  chain_inactive(v1);
  cgsleep_ms(30);
  if ( 256 / dev->addrInterval )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      ++v6;
      set_address(v1, 0, v5);
      v5 += dev->addrInterval;
      cgsleep_ms(30);
    }
    while ( 256 / dev->addrInterval > v6 );
  }
}

//----- (00033F30) --------------------------------------------------------
void software_set_address()
{
  all_parameters *v0; // r3
  int v1; // r1
  char *v2; // r2
  int v3; // r4
  unsigned __int8 v4; // r6
  unsigned int v5; // r7
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-818h] BYREF

  v0 = dev;
  v1 = opt_debug;
  v2 = (char *)&dev->temp[5] + 2;
  dev->check_bit = 0;
  if ( v1 )
  {
    if ( use_syslog || (LOBYTE(v1) = opt_log_output) != 0 || opt_log_level > 6 )
    {
      snprintf((char *)tmp42, 0x800u, "--- %s\n", (const char *)_FUNCTION___13689);
      applog(7, tmp42, 0);
      v0 = dev;
      v2 = (char *)&dev->temp[5] + 2;
      LOBYTE(v1) = dev->check_bit;
    }
  }
  v3 = 0;
  v2[58] = v1 + 2;
  v0->addrInterval = 4;
  while ( 1 )
  {
    if ( v0->chain_exist[v3] == 1 )
    {
      if ( v0->chain_asic_num[v3] )
      {
        chain_inactive(v3);
        cgsleep_ms(30);
        chain_inactive(v3);
        cgsleep_ms(30);
        chain_inactive(v3);
        cgsleep_ms(30);
        if ( 256 / dev->addrInterval )
          break;
      }
    }
    if ( ++v3 == 16 )
      return;
LABEL_7:
    v0 = dev;
  }
  v4 = 0;
  v5 = 0;
  do
  {
    ++v5;
    set_address(v3, 0, v4);
    v4 += dev->addrInterval;
    cgsleep_ms(30);
  }
  while ( 256 / dev->addrInterval > v5 );
  if ( ++v3 != 16 )
    goto LABEL_7;
}

//----- (0003405C) --------------------------------------------------------
void __fastcall set_asic_ticket_mask(unsigned int ticket_mask)
{
  unsigned int v1; // r5
  char v2; // r7
  int v3; // r4
  int v4; // r8
  int v5; // r0
  int v6; // r2
  unsigned int v7; // r0
  int v8; // r3
  int v9; // r0
  unsigned int v10; // [sp+1Ch] [bp-844h]
  unsigned __int8 buf[9]; // [sp+20h] [bp-840h] BYREF
  unsigned int cmd_buf[3]; // [sp+2Ch] [bp-834h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+38h] [bp-828h] BYREF

  v1 = bswap32(ticket_mask);
  v2 = ticket_mask;
  v3 = 0;
  v10 = bswap32(v1);
  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  do
  {
    while ( dev->chain_exist[v3] != 1 )
    {
      if ( ++v3 == 16 )
        return;
    }
    if ( opt_multi_version )
    {
      strcpy((char *)buf, "X\t");
      *(_DWORD *)&buf[4] = v1;
      buf[3] = 24;
      v9 = CRC5(buf, 0x40u);
      buf[8] = v9;
      cmd_buf[0] = 1476984856;
      cmd_buf[2] = v9 << 24;
      cmd_buf[1] = v10;
    }
    else
    {
      v4 = v2 & 0x1F;
      buf[1] = 16;
      buf[2] = v2 & 0x1F;
      buf[0] = -122;
      v5 = CRC5(buf, 0x1Bu);
      buf[3] = v5;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
          (const char *)_FUNCTION___13709,
          134,
          16,
          v2 & 0x1F,
          v5);
        applog(7, tmp42, 0);
        v4 = buf[2];
        v5 = buf[3];
        v6 = (buf[0] << 24) | (buf[1] << 16);
      }
      else
      {
        v6 = -2045771776;
      }
      cmd_buf[0] = v6 | v5 | (v4 << 8);
    }
    set_BC_command_buffer(cmd_buf);
    v7 = get_BC_write_command();
    v8 = v3++ << 16;
    set_BC_write_command(v7 & 0xFFF0FFFF | v8 | 0x80800000);
  }
  while ( v3 != 16 );
}

//----- (000341E8) --------------------------------------------------------
void __fastcall set_hcnt(unsigned int hcnt)
{
  unsigned int v1; // r10
  unsigned __int8 v2; // r6
  unsigned __int8 v3; // r9
  int v4; // r8
  unsigned __int8 v5; // r4
  int v6; // r0
  unsigned int v7; // r0
  int v8; // r2
  unsigned int v9; // [sp+0h] [bp-48h]
  unsigned __int8 buf[9]; // [sp+8h] [bp-40h] BYREF
  unsigned int cmd_buf[3]; // [sp+14h] [bp-34h] BYREF

  v1 = HIBYTE(hcnt);
  v2 = hcnt;
  v3 = BYTE1(hcnt);
  v9 = (BYTE2(hcnt) << 16) | (HIBYTE(hcnt) << 24) | (unsigned __int8)hcnt | (BYTE1(hcnt) << 8);
  v4 = 0;
  memset(buf, 0, sizeof(buf));
  v5 = BYTE2(hcnt);
  memset(cmd_buf, 0, sizeof(cmd_buf));
  do
  {
    while ( dev->chain_exist[v4] != 1 || !opt_multi_version )
    {
      if ( ++v4 == 16 )
        return;
    }
    strcpy((char *)buf, "X\t");
    buf[3] = 20;
    buf[4] = v1;
    buf[5] = v5;
    buf[6] = v3;
    buf[7] = v2;
    v6 = CRC5(buf, 0x40u);
    buf[8] = v6;
    cmd_buf[0] = 1476984852;
    cmd_buf[2] = v6 << 24;
    cmd_buf[1] = v9;
    set_BC_command_buffer(cmd_buf);
    v7 = get_BC_write_command();
    v8 = v4++ << 16;
    set_BC_write_command(v7 & 0xFFF0FFFF | v8 | 0x80800000);
  }
  while ( v4 != 16 );
}

//----- (000342D8) --------------------------------------------------------
void __fastcall set_baud(unsigned __int8 bauddiv, int no_use)
{
  all_parameters *v3; // r3
  int baud; // r1
  int v5; // r5
  int v6; // r11
  int v7; // r0
  int v8; // r2
  int v9; // r3
  unsigned int v10; // r0
  int v11; // r3
  unsigned int v12; // r0
  int v13; // r0
  unsigned __int8 buf[9]; // [sp+10h] [bp-840h] BYREF
  unsigned int cmd_buf[3]; // [sp+1Ch] [bp-834h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+28h] [bp-828h] BYREF

  v3 = dev;
  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  baud = dev->baud;
  if ( baud != bauddiv )
  {
    v5 = bauddiv & 0x1F;
    v6 = 0;
    while ( 1 )
    {
      if ( v3->chain_exist[v6] == 1 )
      {
        if ( opt_multi_version )
        {
          strcpy((char *)buf, "X\t");
          buf[4] = 0;
          buf[7] = 0;
          buf[5] = 32;
          buf[6] = v5;
          buf[3] = 28;
          v13 = CRC5(buf, 0x40u);
          buf[8] = v13;
          cmd_buf[2] = v13 << 24;
          cmd_buf[0] = 1476984860;
          cmd_buf[1] = (v5 << 8) | 0x200000;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: cmd_buf[0]=0x%x, cmd_buf[1]=0x%x, cmd_buf[2]=0x%x\n",
              (const char *)_FUNCTION___13734,
              1476984860,
              (v5 << 8) | 0x200000,
              v13 << 24);
            applog(7, tmp42, 0);
          }
        }
        else
        {
          buf[0] = -122;
          buf[2] = v5;
          buf[1] = 16;
          v7 = CRC5(buf, 0x1Bu);
          buf[3] = v7;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
              (const char *)_FUNCTION___13734,
              134,
              16,
              v5,
              v7);
            applog(7, tmp42, 0);
            v8 = buf[2];
            v7 = buf[3];
            v9 = (buf[0] << 24) | (buf[1] << 16);
          }
          else
          {
            v9 = -2045771776;
            v8 = v5;
          }
          cmd_buf[0] = v9 | v7 | (v8 << 8);
        }
        set_BC_command_buffer(cmd_buf);
        v10 = get_BC_write_command();
        v11 = v6++ << 16;
        set_BC_write_command(v10 & 0xFFF0FFFF | v11 | 0x80800000);
        if ( v6 == 16 )
        {
LABEL_13:
          cgsleep_us(50000LL);
          v12 = get_BC_write_command();
          set_BC_write_command(v12 & 0xFFFFFFE0 | v5 & 0x1F);
          dev->baud = bauddiv;
          return;
        }
      }
      else if ( ++v6 == 16 )
      {
        goto LABEL_13;
      }
      v3 = dev;
    }
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: the setting bauddiv(%d) is the same as before\n",
      (const char *)_FUNCTION___13734,
      baud);
    applog(7, tmp42, 0);
  }
}

//----- (0003450C) --------------------------------------------------------
void init_uart_baud()
{
  unsigned __int8 v0; // r4
  unsigned int v1; // r0
  unsigned int v2; // r2
  unsigned __int8 logstr[256]; // [sp+0h] [bp-108h] BYREF

  v1 = (unsigned int)&asic_core_nonce_num[0][121][229]
     / (432
      * (((unsigned int)&cgpu.results[63][329] + 2)
       / dev->timeout))
     - 1;
  if ( v1 > 0x1A )
  {
    v2 = 26;
  }
  else
  {
    v0 = (unsigned int)&asic_core_nonce_num[0][121][229]
       / (432
        * (((unsigned int)&cgpu.results[63][329] + 2)
         / dev->timeout))
       - 1;
    v2 = (unsigned int)&asic_core_nonce_num[0][121][229]
       / (432
        * (((unsigned int)&cgpu.results[63][329] + 2)
         / dev->timeout))
       - 1;
  }
  if ( v1 > 0x1A )
    v0 = v2;
  sprintf((char *)logstr, "set baud=%d\n", v2, dev);
  writeInitLogFile(logstr);
  set_baud(v0, 1);
}
// 34558: variable 'v0' is possibly undefined

//----- (00034568) --------------------------------------------------------
void __fastcall set_led(bool stop)
{
  unsigned __int8 cmd[100]; // [sp+4h] [bp-6Ch] BYREF

  blink_13750 ^= 1u;
  if ( isC5_CtrlBoard )
  {
    if ( stop )
    {
      sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/leds/hps_led0/brightness");
      system((const char *)cmd);
      sprintf((char *)cmd, "echo %d > %s", blink_13750, "/sys/class/leds/hps_led2/brightness");
    }
    else
    {
      sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/leds/hps_led2/brightness");
      system((const char *)cmd);
      sprintf((char *)cmd, "echo %d > %s", blink_13750, "/sys/class/leds/hps_led0/brightness");
    }
  }
  else if ( stop )
  {
    sprintf((char *)cmd, "echo %d > %s", isC5_CtrlBoard, "/sys/class/gpio/gpio38/value");
    system((const char *)cmd);
    sprintf((char *)cmd, "echo %d > %s", blink_13750, "/sys/class/gpio/gpio37/value");
  }
  else
  {
    sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/gpio/gpio37/value");
    system((const char *)cmd);
    sprintf((char *)cmd, "echo %d > %s", blink_13750, "/sys/class/gpio/gpio38/value");
  }
  system((const char *)cmd);
}

//----- (00034648) --------------------------------------------------------
void change_pic_voltage_old()
{
  int v0; // r5
  unsigned int v1; // r4
  unsigned int v2; // r3

  v0 = 0;
  sleep(0x12Cu);
  do
  {
    LOBYTE(v1) = de_voltage;
    if ( dev->chain_exist[v0] )
    {
      v2 = chain_voltage_pic[v0];
      if ( de_voltage <= v2 )
      {
        do
        {
          v1 = (unsigned __int8)(v1 + 5);
          if ( v2 < v1 )
            v1 = v2;
          pthread_mutex_lock(&iic_mutex);
          set_pic_voltage(v0, v1);
          pthread_mutex_unlock(&iic_mutex);
          pthread_mutex_lock(&iic_mutex);
          get_pic_voltage(v0);
          pthread_mutex_unlock(&iic_mutex);
          if ( chain_voltage_pic[v0] == v1 )
            break;
          cgsleep_ms(100);
          v2 = chain_voltage_pic[v0];
        }
        while ( v1 <= v2 );
      }
    }
    ++v0;
  }
  while ( v0 != 16 );
}

//----- (000346D4) --------------------------------------------------------
int __fastcall get_asic_nonce_num(int chain, int asic, int timeslice)
{
  int v3; // r4
  int result; // r0
  int v5; // r1
  int v6; // r3
  int v7; // r4
  int v8; // r2

  if ( timeslice <= 0 )
    return 0;
  v3 = 3840 * chain;
  result = 0;
  v5 = v3 + 60 * asic;
  v6 = nonce_times % 60 - 1;
  v7 = v6 - timeslice;
  do
  {
    v8 = v6 + (v6 < 0 ? 0x3C : 0);
    --v6;
    result += LODWORD(nonce_num[0][0][v5 + v8]);
  }
  while ( v6 != v7 );
  return result;
}

//----- (00034738) --------------------------------------------------------
void __fastcall get_lastn_nonce_num(unsigned __int8 *dest, int n)
{
  int v3; // r5
  int v4; // r9
  size_t v5; // r0
  char *v6; // r5
  int v7; // r3
  int v8; // r2
  int v9; // r0
  int v10; // r1
  int v11; // r10
  int v12; // r9
  int v13; // r3
  int v14; // r1
  int v15; // r5
  int v16; // r2
  int v17; // r2
  int v18; // [sp+0h] [bp-848h]
  unsigned __int8 tmp[20]; // [sp+Ch] [bp-83Ch] BYREF
  unsigned __int8 xtime[2048]; // [sp+20h] [bp-828h] BYREF

  v3 = 1;
  do
  {
    while ( 1 )
    {
      v18 = v3 + 1;
      v4 = v3 - 1;
      if ( *(&dev->pwm_value + v3) )
        break;
      ++v3;
      if ( v18 == 17 )
        goto LABEL_15;
    }
    *(_DWORD *)xtime = 123;
    memset(&xtime[4], 0, 0x7FCu);
    memset(tmp, 0, sizeof(tmp));
    sprintf((char *)tmp, "Chain%d:{", v3);
    v5 = strlen((const char *)xtime);
    v6 = (char *)stpcpy(&xtime[v5], tmp);
    if ( n <= 0 )
    {
      v7 = 0;
    }
    else
    {
      v7 = 0;
      v8 = nonce_times % 60 - 1;
      v9 = v8 - n;
      do
      {
        v10 = v8 + (v8 < 0 ? 0x3C : 0);
        --v8;
        v7 += LODWORD(nonce_num[v4][0][v10]);
      }
      while ( v8 != v9 );
    }
    sprintf((char *)tmp, "N%d=%d", 0, v7);
    strcpy(v6, (const char *)tmp);
    if ( dev->max_asic_num_in_one_chain > 1u )
    {
      v11 = 1;
      v12 = 3840 * v4;
      do
      {
        if ( n <= 0 )
        {
          v13 = 0;
        }
        else
        {
          v13 = 0;
          v14 = nonce_times % 60 - 1;
          v15 = v14 - n;
          do
          {
            v16 = v14 + (v14 < 0 ? 0x3C : 0);
            --v14;
            v13 += LODWORD(nonce_num[0][v11][v16 + v12]);
          }
          while ( v14 != v15 );
        }
        v17 = v11++;
        sprintf((char *)tmp, ",N%d=%d", v17, v13);
        strcat((char *)xtime, (const char *)tmp);
      }
      while ( dev->max_asic_num_in_one_chain > v11 );
    }
    strcat((char *)xtime, "},");
    strcat((char *)dest, (const char *)xtime);
    v3 = v18;
  }
  while ( v18 != 17 );
LABEL_15:
  dest[strlen((const char *)dest) - 1] = 0;
}
// A1A4: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);

//----- (00034904) --------------------------------------------------------
void __noreturn check_system_work()
{
  int v0; // r3
  int v1; // r10
  int v2; // r6
  all_parameters *v3; // r12
  char *v4; // r8
  int v5; // r4
  char *v6; // r5
  int v7; // r7
  int v8; // lr
  int v9; // r7
  all_parameters *v10; // r7
  int v11; // r3
  int v12; // r3
  int v13; // r4
  int v14; // r1
  int *v15; // r0
  char *v16; // r5
  int v17; // r3
  int v18; // r6
  _WORD *v19; // r6
  int v20; // r6
  int v21; // r6
  bool v22; // zf
  int (*v23)[256]; // [sp+10h] [bp-960h]
  _BOOL4 v24; // [sp+14h] [bp-95Ch]
  int v25; // [sp+18h] [bp-958h]
  int i; // [sp+1Ch] [bp-954h]
  all_parameters *ia; // [sp+1Ch] [bp-954h]
  int asic_num; // [sp+20h] [bp-950h]
  int asic_numa; // [sp+20h] [bp-950h]
  int v30; // [sp+24h] [bp-94Ch]
  timeval tv_start; // [sp+28h] [bp-948h] BYREF
  timeval tv_end; // [sp+30h] [bp-940h] BYREF
  timeval tv_reboot; // [sp+38h] [bp-938h] BYREF
  timeval tv_reboot_start; // [sp+40h] [bp-930h] BYREF
  unsigned __int8 logstr[256]; // [sp+48h] [bp-928h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+148h] [bp-828h] BYREF

  cgtime(&tv_end);
  cgtime(&tv_reboot);
  copy_time(&tv_start, &tv_end);
  copy_time(&tv_reboot_start, &tv_reboot);
  sprintf((char *)logstr, "restartNum = %d , auto-reinit enabled...\n", 2);
  writeInitLogFile(logstr);
  while ( 1 )
  {
    while ( 1 )
    {
      set_led(global_stop);
      if ( !doTestPatten )
        break;
      cgsleep_ms(100);
    }
    cgtime(&tv_end);
    cgtime(&tv_reboot);
    v0 = tv_end.tv_sec - tv_start.tv_sec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
      --v0;
    if ( v0 <= 300 )
    {
      if ( v0 <= 60 && (!global_stop || v0 <= 30) )
        goto LABEL_44;
    }
    else
    {
      check_temp_offside = 1;
    }
    v1 = 0;
    asic_num = 0;
    v2 = nonce_times;
    for ( i = 0; i != 16; ++i )
    {
      v3 = dev;
      if ( dev->chain_exist[i] )
      {
        v4 = (char *)dev + i;
        asic_num += dev->chain_asic_num[i];
        if ( dev->chain_asic_num[i] )
        {
          v5 = 0;
          do
          {
            v6 = (char *)&v3->chain_hw[128 * i + 15 + 2 * v5] + 2;
            v7 = 3840 * i + 60 * v5 + v2 % 60;
            v8 = *(_DWORD *)(v6 + 6);
            LODWORD(nonce_num[0][0][v7]) = *(_DWORD *)(v6 + 2);
            HIDWORD(nonce_num[0][0][v7]) = v8;
            v9 = *(_DWORD *)(v6 + 2);
            v1 += v9;
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: chain %d asic %d asic_nonce_num %d",
                _FUNCTION___13835,
                i,
                v5,
                v9,
                *(_DWORD *)(v6 + 6));
              applog(7, tmp42, 0);
              v3 = dev;
              v2 = nonce_times;
              v4 = (char *)dev + i;
            }
            ++v5;
          }
          while ( (unsigned __int8)v4[12202] > v5 );
        }
      }
    }
    nonce_times = v2 + 1;
    memset(nonce_num10_string, 0, sizeof(nonce_num10_string));
    memset(nonce_num30_string, 0, sizeof(nonce_num30_string));
    memset(nonce_num60_string, 0, sizeof(nonce_num60_string));
    get_lastn_nonce_num(nonce_num10_string, 10);
    get_lastn_nonce_num(nonce_num30_string, 30);
    get_lastn_nonce_num(nonce_num60_string, 60);
    if ( asic_num && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: avg_num %d asic_num %d", (const char *)_FUNCTION___13835, v1, asic_num);
      applog(7, tmp42, 0);
    }
    v10 = dev;
    v24 = status_error;
    ia = dev;
    v23 = x_time;
    v25 = 0;
    v11 = nonce_times % 60 - 1;
    if ( v11 < 0 )
      v11 = nonce_times % 60 + 59;
    v30 = v11;
    do
    {
      if ( ia->chain_exist[0] )
      {
        v12 = v10->chain_asic_num[v25];
        if ( v10->chain_asic_num[v25] )
        {
          v13 = 0;
          asic_numa = 8 * v25;
          v14 = 0;
          v15 = (int *)((char *)nonce_num[v25] + 8 * v30);
          v16 = (char *)v10 + 72 * v25;
          v17 = 0;
          do
          {
            v20 = (int)&v16[v14 + v17];
            if ( (v17 & 7) == 0 )
              ++v14;
            v21 = v20 + 10880;
            if ( (v17 & 7) == 0 )
              *(_BYTE *)(v21 + 58) = 32;
            if ( *v15 <= 1 )
            {
              v16[v14 + 10938 + v17] = 111;
              if ( !v24 )
                ++(*v23)[v13];
            }
            else
            {
              v16[v14 + 10938 + v17] = 111;
            }
            v18 = (v25 << 6) + v17++;
            ++v13;
            v19 = (_WORD *)&v10->chain_hw[2 * v18 + 15] + 1;
            v15 += 120;
            v19[1] = 0;
            v19[2] = 0;
            v19[3] = 0;
            v19[4] = 0;
          }
          while ( v10->chain_asic_num[v25] > v17 );
          v12 = v14 + v17;
        }
        else
        {
          asic_numa = 8 * v25;
        }
        v10->chain_asic_status_string[0][8 * asic_numa + 8 * v25 + v12] = 0;
      }
      v22 = v25++ == 15;
      ia = (all_parameters *)((char *)ia + 4);
      ++v23;
    }
    while ( !v22 );
    copy_time(&tv_start, &tv_end);
LABEL_44:
    cgsleep_ms(1000);
  }
}

//----- (00034D4C) --------------------------------------------------------
bool if_hashrate_ok()
{
  double v0; // d8

  v0 = total_mhashes_done / 1000.0 / total_secs;
  return v0 > (double)GetTotalRate() * 0.98;
}

//----- (00034DB0) --------------------------------------------------------
bool __fastcall check_hashrate_maybe_ok(double level)
{
  double v1; // d0
  double v2; // d8

  v2 = total_mhashes_done / 1000.0 / total_secs;
  return v2 > (double)GetTotalRate() * v1;
}
// 34DEA: variable 'v1' is possibly undefined

//----- (00034E10) --------------------------------------------------------
void __fastcall saveRebootTestNum(int num)
{
  FILE *v2; // r5
  unsigned __int8 testnumStr[32]; // [sp+0h] [bp-30h] BYREF

  v2 = fopen("/etc/config/rebootTest", "wb");
  if ( v2 )
  {
    memset(testnumStr, 0, sizeof(testnumStr));
    sprintf((char *)testnumStr, "%d", num);
    fwrite(testnumStr, 1u, 0x20u, v2);
    fclose(v2);
  }
}

//----- (00034E60) --------------------------------------------------------
int readRebootTestNum()
{
  return 0;
}

//----- (00034E64) --------------------------------------------------------
void __fastcall saveRestartNum(int num)
{
  FILE *v2; // r5
  unsigned __int8 testnumStr[32]; // [sp+0h] [bp-30h] BYREF

  v2 = fopen("/etc/config/restartTest", "wb");
  if ( v2 )
  {
    memset(testnumStr, 0, sizeof(testnumStr));
    sprintf((char *)testnumStr, "%d", num);
    fwrite(testnumStr, 1u, 0x20u, v2);
    fclose(v2);
  }
}

//----- (00034EB4) --------------------------------------------------------
int readRestartNum()
{
  return 2;
}

//----- (00034EB8) --------------------------------------------------------
void __fastcall open_core(bool nullwork_enable)
{
  unsigned int v1; // r8
  unsigned int dhash_acc_control; // r0
  all_parameters *v3; // r6
  int v4; // r7
  int v5; // r0
  int v6; // r1
  int v7; // r2
  unsigned int v8; // r7
  int v9; // r6
  int v10; // r8
  unsigned int v11; // r0
  unsigned int *v12; // r0
  unsigned int v13; // r0
  int v14; // r11
  int v15; // r0
  unsigned __int8 *v16; // r3
  unsigned int *v17; // r1
  int j; // r2
  int k; // r3
  unsigned int v20; // r1
  unsigned int *v21; // r2
  unsigned int v22; // r0
  unsigned int v23; // r0
  unsigned int v24; // r0
  int v25; // r10
  all_parameters *v26; // r6
  unsigned __int8 baud; // r8
  int v28; // r8
  int v29; // r0
  unsigned int v30; // r0
  int v31; // r6
  unsigned int v32; // r0
  int v33; // r11
  int v34; // r0
  vil_work_1387 *p_work_vil_1387; // r3
  unsigned int *v36; // r2
  int v37; // r1
  int v38; // r11
  int v39; // lr
  int v40; // r0
  unsigned int v41; // r0
  unsigned int v42; // r0
  unsigned int i; // [sp+18h] [bp-928h]
  _BOOL4 v44; // [sp+1Ch] [bp-924h]
  unsigned __int8 gateblk[4]; // [sp+2Ch] [bp-914h] BYREF
  unsigned __int8 buf_vil[9]; // [sp+30h] [bp-910h] BYREF
  unsigned int cmd_buf[3]; // [sp+3Ch] [bp-904h] BYREF
  unsigned int buf[13]; // [sp+48h] [bp-8F8h] BYREF
  unsigned int buf_vil_tw[13]; // [sp+7Ch] [bp-8C4h] BYREF
  unsigned __int8 data[52]; // [sp+B0h] [bp-890h] BYREF
  vil_work_1387 work_vil_1387; // [sp+E4h] [bp-85Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+118h] [bp-828h] BYREF

  gateblk[0] = 0;
  gateblk[1] = 0;
  gateblk[2] = 0;
  gateblk[3] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  memset(buf, 0, sizeof(buf));
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  v44 = nullwork_enable;
  *(_DWORD *)data = 255;
  v1 = opt_multi_version;
  memset(&data[4], 0, 48);
  memset(buf_vil, 0, sizeof(buf_vil));
  if ( !opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFFFFDF);
    set_hash_counting_number(v1);
    gateblk[0] = -122;
    v3 = dev;
    gateblk[3] = 0x80;
    gateblk[1] = v1;
    v4 = dev->baud | 0x80;
    gateblk[2] = dev->baud | 0x80;
    v5 = CRC5(gateblk, 0x1Bu) & 0x1F;
    v6 = v5 | 0x80;
    gateblk[3] = v5 | 0x80;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: gateblk[0]=0x%x, gateblk[1]=0x%x, gateblk[2]=0x%x, gateblk[3]=0x%x\n",
        (const char *)_FUNCTION___13874,
        134,
        0,
        v4,
        v6);
      applog(7, tmp42, 0);
      v4 = gateblk[2];
      v6 = gateblk[3];
      v3 = dev;
      v7 = (gateblk[0] << 24) | (gateblk[1] << 16);
    }
    else
    {
      v7 = -2046820352;
    }
    cmd_buf[0] = v7 | v6 | (v4 << 8);
    *(_DWORD *)&data[48] = -16777216;
    v8 = 0;
    i = 0;
    memset(data, 0, 40);
    *(_DWORD *)&data[44] = 0;
    *(_DWORD *)&data[40] = 255;
    while ( 1 )
    {
      if ( v3->chain_exist[i] != 1 )
      {
        if ( ++i == 16 )
          goto LABEL_22;
        goto LABEL_6;
      }
      v9 = 1 << i;
      v10 = 0;
      set_BC_command_buffer(cmd_buf);
      v11 = get_BC_write_command();
      set_BC_write_command((i << 16) | 0x80800000 | v11 & 0xFFF0FFFF);
      cgsleep_us(10000LL);
      v12 = axi_fpga_addr;
      do
      {
        if ( (v9 & v12[3]) == 0 )
        {
          do
            cgsleep_us(1000LL);
          while ( (v9 & axi_fpga_addr[3]) == 0 );
        }
        if ( v10 )
        {
          data[0] = 1;
          v15 = (unsigned __int8)i | 0x80;
          data[1] = i | 0x80;
          if ( v10 == 113 && v44 )
          {
            v23 = get_BC_write_command();
            set_BC_write_command(v23 & ((i << 16) | 0xC00000));
            v14 = data[0];
            v15 = data[1];
          }
          else
          {
            v14 = 1;
          }
        }
        else
        {
          data[0] = 17;
          data[1] = i | 0x80;
          v13 = get_BC_write_command();
          set_BC_write_command(v13 & 0xFFBFFFFF);
          v14 = data[0];
          v15 = data[1];
        }
        memset(buf, 0, 13);
        v16 = data;
        v17 = &cmd_buf[2];
        for ( j = 1; ; ++j )
        {
          v17[1] = (v14 << 24) | (v15 << 16) | v16[3] | (v16[2] << 8);
          ++v17;
          if ( j == 10 )
          {
            buf[9] = v8++;
            goto LABEL_14;
          }
          if ( j == 13 )
            break;
LABEL_14:
          v14 = v16[4];
          v15 = v16[5];
          v16 += 4;
        }
        v12 = axi_fpga_addr;
        for ( k = 0; k != 13; ++k )
        {
          v20 = buf[k];
          v21 = &v12[k];
          v21[16] = v20;
        }
        ++v10;
      }
      while ( v10 != 114 );
      if ( ++i == 16 )
      {
LABEL_22:
        v22 = get_dhash_acc_control();
        set_dhash_acc_control(v22 | 0x20);
        return;
      }
LABEL_6:
      v3 = dev;
    }
  }
  v24 = get_dhash_acc_control();
  v25 = 0;
  set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | 0x8000 | v24 & 0xFFFF7FDF);
  set_hash_counting_number(0);
  qmemcpy(&buf_vil[4], "@ ", 2);
  strcpy((char *)buf_vil, "X\t");
  v26 = dev;
  baud = dev->baud;
  buf_vil[3] = 28;
  v28 = baud & 0x1F | 0x80;
  buf_vil[6] = v28;
  buf_vil[7] = 0x80;
  v29 = CRC5(buf_vil, 0x40u);
  buf_vil[8] = v29;
  memset(buf_vil_tw, 0, 13);
  cmd_buf[2] = v29 << 24;
  cmd_buf[1] = (v28 << 8) | 0x40200080;
  cmd_buf[0] = 1476984860;
  memset(&work_vil_1387, 255, sizeof(work_vil_1387));
  while ( 1 )
  {
    if ( v26->chain_exist[v25] == 1 )
    {
      v30 = get_BC_write_command() & 0xFFF0FFFF | (v25 << 16);
      set_BC_write_command(v30 & 0xFF3FFFFF | 0x800000);
      cgsleep_us(1000LL);
      work_vil_1387.data[0] = -1;
      work_vil_1387.data[11] = -1;
      work_vil_1387.work_type = 1;
      v31 = 0;
      work_vil_1387.chain_id = v25 | 0x80;
      work_vil_1387.reserved1[0] = 0;
      work_vil_1387.reserved1[1] = 0;
      work_vil_1387.work_count = 0;
      set_BC_command_buffer(cmd_buf);
      v32 = get_BC_write_command();
      set_BC_write_command((v25 << 16) | 0x80800000 | v32 & 0xFFF0FFFF);
      cgsleep_us(10000LL);
      while ( 2 )
      {
        v33 = 3001;
        while ( ((1 << v25) & axi_fpga_addr[3]) == 0 )
        {
          cgsleep_us(1000LL);
          if ( !--v33 )
          {
            sprintf((char *)tmp42, "Error: send open core work Failed on Chain[%d]!\n", v25);
            writeInitLogFile(tmp42);
            goto LABEL_28;
          }
        }
        if ( v31 )
        {
          v34 = 0x1000000;
          work_vil_1387.work_type = 1;
        }
        else
        {
          v34 = 285212672;
          work_vil_1387.work_type = 17;
        }
        p_work_vil_1387 = &work_vil_1387;
        v36 = &buf_vil_tw[1];
        work_vil_1387.chain_id = v25 | 0x80;
        buf_vil_tw[1] = work_vil_1387.work_count;
        buf_vil_tw[0] = work_vil_1387.reserved1[1] | (work_vil_1387.reserved1[0] << 8) | ((v25 | 0x80) << 16) | v34;
        do
        {
          v37 = p_work_vil_1387->data[1];
          v38 = p_work_vil_1387->data[0];
          v39 = p_work_vil_1387->data[3];
          v40 = p_work_vil_1387->data[2];
          p_work_vil_1387 = (vil_work_1387 *)((char *)p_work_vil_1387 + 4);
          v36[1] = (v37 << 16) | (v38 << 24) | v39 | (v40 << 8);
          ++v36;
        }
        while ( p_work_vil_1387 != (vil_work_1387 *)&work_vil_1387.data[4] );
        memset(&buf_vil_tw[5], 0, 32);
        set_TW_write_command_vil(buf_vil_tw);
        if ( v31 != 113 )
        {
          ++v31;
          continue;
        }
        break;
      }
      if ( v44 )
        break;
    }
LABEL_28:
    if ( ++v25 == 16 )
      goto LABEL_44;
LABEL_29:
    v26 = dev;
  }
  v41 = get_BC_write_command();
  ++v25;
  set_BC_write_command(v41 | 0x400000);
  if ( v25 != 16 )
    goto LABEL_29;
LABEL_44:
  v42 = get_dhash_acc_control();
  set_dhash_acc_control(v42 | ((opt_multi_version & 0xF) << 8) | 0x8000);
}

//----- (00035420) --------------------------------------------------------
void __fastcall open_core_one_chain(int chainIndex, bool nullwork_enable)
{
  int v2; // r6
  unsigned int v4; // r5
  unsigned int dhash_acc_control; // r0
  all_parameters *v6; // r6
  int baud; // r5
  int v8; // r5
  int v9; // r0
  int v10; // r3
  int v11; // r2
  unsigned int v12; // r7
  unsigned int v13; // r11
  unsigned int v14; // r0
  unsigned int v15; // r0
  all_parameters *v16; // r4
  unsigned __int8 v17; // r5
  int v18; // r5
  int v19; // r0
  unsigned int v20; // r0
  unsigned int v21; // r0
  unsigned int v22; // r0
  int v23; // r9
  int v24; // r0
  vil_work_1387 *p_work_vil_1387; // r3
  unsigned int *v26; // r2
  int v27; // r1
  int v28; // r9
  int v29; // r12
  int v30; // r0
  unsigned int v31; // r0
  unsigned int v32; // r0
  int v33; // r6
  int v34; // r8
  unsigned int *v35; // r0
  int v36; // r3
  int v37; // r10
  unsigned int v38; // r0
  int v39; // r11
  int v40; // r0
  unsigned __int8 *v41; // r3
  unsigned int *v42; // r1
  int i; // r2
  int j; // r3
  unsigned int v45; // r1
  unsigned int *v46; // r2
  unsigned int v47; // r0
  unsigned __int8 v48; // [sp+14h] [bp-924h]
  _BOOL4 v49; // [sp+18h] [bp-920h]
  int v50; // [sp+1Ch] [bp-91Ch]
  unsigned __int8 gateblk[4]; // [sp+24h] [bp-914h] BYREF
  unsigned __int8 buf_vil[9]; // [sp+28h] [bp-910h] BYREF
  unsigned int cmd_buf[3]; // [sp+34h] [bp-904h] BYREF
  unsigned int buf[13]; // [sp+40h] [bp-8F8h] BYREF
  unsigned int buf_vil_tw[13]; // [sp+74h] [bp-8C4h] BYREF
  unsigned __int8 data[52]; // [sp+A8h] [bp-890h] BYREF
  vil_work_1387 work_vil_1387; // [sp+DCh] [bp-85Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+110h] [bp-828h] BYREF

  v2 = 0;
  gateblk[0] = 0;
  gateblk[1] = 0;
  gateblk[2] = 0;
  gateblk[3] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  memset(buf, 0, sizeof(buf));
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  v4 = opt_multi_version;
  *(_DWORD *)data = 255;
  v49 = nullwork_enable;
  memset(&data[4], 0, 48);
  memset(buf_vil, 0, sizeof(buf_vil));
  if ( !opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFFFFDF);
    set_hash_counting_number(v4);
    v6 = dev;
    gateblk[1] = v4;
    gateblk[0] = -122;
    baud = dev->baud;
    gateblk[3] = 0x80;
    v8 = baud | 0x80;
    gateblk[2] = v8;
    v9 = CRC5(gateblk, 0x1Bu) & 0x1F;
    v10 = v9 | 0x80;
    gateblk[3] = v9 | 0x80;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: gateblk[0]=0x%x, gateblk[1]=0x%x, gateblk[2]=0x%x, gateblk[3]=0x%x\n",
        (const char *)_FUNCTION___13924,
        134,
        0,
        v8,
        v9 | 0x80);
      applog(7, tmp42, 0);
      v6 = dev;
      v8 = gateblk[2];
      v10 = gateblk[3];
      v11 = (gateblk[0] << 24) | (gateblk[1] << 16);
    }
    else
    {
      v11 = -2046820352;
    }
    v12 = 0;
    *(_DWORD *)&data[48] = -16777216;
    memset(data, 0, 40);
    *(_DWORD *)&data[44] = 0;
    *(_DWORD *)&data[40] = 255;
    v13 = v6->chain_exist[chainIndex];
    cmd_buf[0] = v10 | v11 | (v8 << 8);
    if ( v13 != 1 )
    {
LABEL_5:
      v14 = get_dhash_acc_control();
      set_dhash_acc_control(v14 | 0x20);
      return;
    }
    set_BC_command_buffer(cmd_buf);
    v32 = get_BC_write_command();
    v33 = 1 << chainIndex;
    v48 = chainIndex | 0x80;
    v34 = 0;
    set_BC_write_command(v32 & 0xFFF0FFFF | (chainIndex << 16) | 0x80800000);
    cgsleep_us(10000LL);
    v35 = axi_fpga_addr;
    v36 = ((chainIndex & 0xF) << 16) | 0xC00000;
    v37 = (unsigned __int8)chainIndex | 0x80;
    v50 = v36;
LABEL_27:
    if ( (v33 & v35[3]) == 0 )
    {
      do
        cgsleep_us(1000LL);
      while ( (v33 & axi_fpga_addr[3]) == 0 );
    }
    if ( v34 )
    {
      data[0] = 1;
      v40 = v37;
      data[1] = v37;
      if ( v34 == 113 && v49 )
      {
        v47 = get_BC_write_command();
        set_BC_write_command(v47 & v50);
        v39 = data[0];
        v40 = data[1];
      }
      else
      {
        v39 = 1;
      }
    }
    else
    {
      data[0] = 17;
      data[1] = v48;
      v38 = get_BC_write_command();
      set_BC_write_command(v38 & 0xFFBFFFFF);
      v39 = data[0];
      v40 = data[1];
    }
    memset(buf, 0, 13);
    v41 = data;
    v42 = &cmd_buf[2];
    for ( i = 1; ; ++i )
    {
      v42[1] = (v39 << 24) | (v40 << 16) | v41[3] | (v41[2] << 8);
      ++v42;
      if ( i == 10 )
      {
        buf[9] = v12++;
      }
      else if ( i == 13 )
      {
        v35 = axi_fpga_addr;
        for ( j = 0; j != 13; ++j )
        {
          v45 = buf[j];
          v46 = &v35[j];
          v46[16] = v45;
        }
        if ( ++v34 == 114 )
          goto LABEL_5;
        goto LABEL_27;
      }
      v39 = v41[4];
      v40 = v41[5];
      v41 += 4;
    }
  }
  v15 = get_dhash_acc_control();
  set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | 0x8000 | v15 & 0xFFFF7FDF);
  set_hash_counting_number(0);
  qmemcpy(&buf_vil[4], "@ ", 2);
  v16 = dev;
  strcpy((char *)buf_vil, "X\t");
  buf_vil[3] = 28;
  v17 = dev->baud;
  buf_vil[7] = 0x80;
  v18 = v17 & 0x1F | 0x80;
  buf_vil[6] = v18;
  v19 = CRC5(buf_vil, 0x40u);
  buf_vil[8] = v19;
  cmd_buf[1] = (v18 << 8) | 0x40200080;
  cmd_buf[2] = v19 << 24;
  memset(buf_vil_tw, 0, 13);
  cmd_buf[0] = 1476984860;
  memset(&work_vil_1387, 255, sizeof(work_vil_1387));
  if ( v16->chain_exist[chainIndex] == 1 )
  {
    v21 = get_BC_write_command() & 0xFFB0FFFF | (chainIndex << 16) & 0xFFBFFFFF | 0x800000;
    set_BC_write_command(v21);
    cgsleep_us(1000LL);
    work_vil_1387.data[0] = -1;
    work_vil_1387.data[11] = -1;
    work_vil_1387.work_type = 1;
    work_vil_1387.reserved1[0] = 0;
    work_vil_1387.reserved1[1] = 0;
    work_vil_1387.work_count = 0;
    work_vil_1387.chain_id = chainIndex | 0x80;
    set_BC_command_buffer(cmd_buf);
    v22 = get_BC_write_command();
    set_BC_write_command((chainIndex << 16) | 0x80800000 | v22 & 0xFFF0FFFF);
    cgsleep_us(10000LL);
    while ( 2 )
    {
      v23 = 3001;
      while ( ((1 << chainIndex) & axi_fpga_addr[3]) == 0 )
      {
        cgsleep_us(1000LL);
        if ( !--v23 )
        {
          sprintf((char *)tmp42, "Error: send open core work Failed on Chain[%d]!\n", chainIndex);
          writeInitLogFile(tmp42);
          goto LABEL_7;
        }
      }
      if ( v2 )
      {
        v24 = 0x1000000;
        work_vil_1387.work_type = 1;
      }
      else
      {
        v24 = 285212672;
        work_vil_1387.work_type = 17;
      }
      p_work_vil_1387 = &work_vil_1387;
      v26 = &buf_vil_tw[1];
      work_vil_1387.chain_id = chainIndex | 0x80;
      buf_vil_tw[1] = work_vil_1387.work_count;
      buf_vil_tw[0] = work_vil_1387.reserved1[1] | (work_vil_1387.reserved1[0] << 8) | (((unsigned __int8)chainIndex | 0x80) << 16) | v24;
      do
      {
        v27 = p_work_vil_1387->data[1];
        v28 = p_work_vil_1387->data[0];
        v29 = p_work_vil_1387->data[3];
        v30 = p_work_vil_1387->data[2];
        p_work_vil_1387 = (vil_work_1387 *)((char *)p_work_vil_1387 + 4);
        v26[1] = (v27 << 16) | (v28 << 24) | v29 | (v30 << 8);
        ++v26;
      }
      while ( p_work_vil_1387 != (vil_work_1387 *)&work_vil_1387.data[4] );
      memset(&buf_vil_tw[5], 0, 32);
      set_TW_write_command_vil(buf_vil_tw);
      if ( v2 != 113 )
      {
        ++v2;
        continue;
      }
      break;
    }
    if ( v49 )
    {
      v31 = get_BC_write_command();
      set_BC_write_command(v31 | 0x400000);
    }
  }
LABEL_7:
  v20 = get_dhash_acc_control();
  set_dhash_acc_control(v20 | ((opt_multi_version & 0xF) << 8) | 0x8000);
}

//----- (0003593C) --------------------------------------------------------
void bitmain_reinit_test()
{
  int v0; // r4
  int v1; // r0
  int v2; // r4
  unsigned __int8 pic_voltage; // r0
  int v4; // r3
  int v5; // r7
  all_parameters *v6; // r3
  int i; // r4
  int v8; // r9
  int v9; // r4
  unsigned __int8 v10; // r7
  int v11; // r4
  int v12; // r7
  int v13; // r10
  char *v14; // r10
  int fan_pwm_percent; // r1
  _BOOL4 v16; // r0
  int v17; // r2
  char *v18; // r3
  all_parameters *v19; // r4
  unsigned int timeout; // r3
  int v21; // r4
  all_parameters *v22; // r7
  int v23; // r9
  all_parameters *v24; // r2
  all_parameters *v25; // r1
  all_parameters *v26; // r0
  signed int v27; // r3
  int v28; // lr
  int v29; // r9
  all_parameters *v30; // r2
  int v31; // r4
  unsigned int v32; // r0
  int v33; // r4
  int v34; // r3
  int v35; // r9
  int v36; // r2
  double v37; // d7
  unsigned __int16 frequency; // r0
  unsigned int dhash_acc_control; // r0
  int v40; // r0
  _BOOL4 v41; // r2
  int v42; // [sp+0h] [bp-950h]
  unsigned __int8 logstr[256]; // [sp+8h] [bp-948h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+108h] [bp-848h] BYREF

  v0 = 0;
  pthread_mutex_lock(&iic_mutex);
  memset(dev, 0, sizeof(all_parameters));
  dev->current_job_start_address = job_start_address_1;
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  set_reset_allhashboard(1);
  set_QN_write_data_command(0x8080800F);
  sleep(2u);
  set_PWM(0x64u);
  *axi_fpga_addr = 0x80000000;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  check_chain();
  set_reset_allhashboard(1);
  do
  {
    while ( dev->chain_exist[v0] != 1 )
    {
      if ( ++v0 == 16 )
        goto LABEL_5;
    }
    reset_iic_pic(v0);
    v1 = v0++;
    jump_to_app_CheckAndRestorePIC_T9_18(v1);
  }
  while ( v0 != 16 );
LABEL_5:
  v2 = 0;
  sleep(1u);
  do
  {
    while ( 1 )
    {
      if ( dev->chain_exist[v2] != 1 )
        goto LABEL_6;
      pic_voltage = get_pic_voltage(v2);
      v4 = fpga_version;
      chain_voltage_pic[v2] = pic_voltage;
      if ( v4 <= 13 )
        break;
      if ( (unsigned int)(v2 - 1) <= 2 )
        goto LABEL_10;
LABEL_6:
      if ( ++v2 == 16 )
        goto LABEL_11;
    }
    if ( v2 != 3 * (v2 / 3) )
      goto LABEL_6;
LABEL_10:
    set_voltage_T9_18_into_PIC(v2++, 1u);
  }
  while ( v2 != 16 );
LABEL_11:
  cgsleep_ms(1000);
  v5 = 1;
  v6 = dev;
  for ( i = 0; i != 16; ++i )
  {
    while ( v6->chain_exist[i] != 1 )
    {
      ++i;
      ++v5;
      if ( i == 16 )
        goto LABEL_16;
    }
    v8 = 10 * ((int)((364.0704 / ((double)chain_voltage_pic[i] + 30.72) + 32.79) * 100.0 / 4.75) / 10);
    sprintf((char *)logstr, "Chain[J%d] working voltage=%d value=%d\n", v5, chain_voltage_pic[i], v8);
    writeInitLogFile(logstr);
    if ( getChainPICMagicNumber(i) == 125 )
    {
      v34 = chain_voltage_value[i];
      if ( v34 > v8 )
      {
        v35 = (unsigned __int8)(unsigned int)(364.0704 / ((double)v34 * 4.75 / 100.0 - 32.79) - 30.72);
        sprintf((char *)logstr, "Chain[J%d] will use backup chain_voltage_pic=%d [%d]\n", v5, v34, v35);
        writeInitLogFile(logstr);
        chain_voltage_pic[i] = v35;
        sprintf((char *)logstr, "Chain[J%d] get working voltage=%d\n", v5, v35);
        writeInitLogFile(logstr);
      }
    }
    v6 = dev;
    ++v5;
  }
LABEL_16:
  v9 = 0;
  while ( 2 )
  {
    if ( v6->chain_exist[v9] != 1 )
    {
      if ( ++v9 == 16 )
        break;
      goto LABEL_18;
    }
    v10 = v9++;
    set_pic_voltage(v10, 0);
    enable_pic_dac(v10);
    if ( v9 != 16 )
    {
LABEL_18:
      v6 = dev;
      continue;
    }
    break;
  }
  sleep(5u);
  pthread_mutex_unlock(&iic_mutex);
  cgsleep_ms(2000);
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | 0x8000 | dhash_acc_control & 0xFFFF7FDF);
  }
  cgsleep_ms(10);
  v11 = 1;
  dev->corenum = 114;
  check_asic_reg(0);
  cgsleep_ms(10);
  do
  {
    while ( 1 )
    {
      v12 = v11 + 1;
      v13 = v11 - 1;
      if ( *(&dev->pwm_value + v11) == 1 )
        break;
      ++v11;
      if ( v12 == 17 )
        goto LABEL_29;
    }
    sprintf((char *)logstr, "Chain[J%d] has %d asic\n", v11, dev->chain_asic_num[v13]);
    writeInitLogFile(logstr);
    v14 = (char *)&dev->temp[5] + v13 + 2;
    if ( !v14[42] )
      *((_DWORD *)&dev->current_job_start_address + v12) = (unsigned __int8)v14[42];
    sprintf((char *)logstr, "retry Chain[J%d] has %d asic\n", v11++);
    writeInitLogFile(logstr);
  }
  while ( v12 != 17 );
LABEL_29:
  software_set_address();
  cgsleep_ms(10);
  if ( (*((_BYTE *)&config_parameter + 4) & 8) != 0 )
  {
    frequency = config_parameter.frequency;
    dev->frequency = config_parameter.frequency;
    set_frequency(frequency);
    sprintf((char *)dev->frequency_t, "%u", dev->frequency);
  }
  cgsleep_ms(10);
  fan_pwm_percent = config_parameter.fan_pwm_percent;
  v16 = opt_debug;
  v17 = (*((unsigned __int8 *)&config_parameter + 4) >> 1) & 1;
  v18 = (char *)&dev->fan_speed_top1 + 1;
  dev->fan_eft = (*((_BYTE *)&config_parameter + 4) & 2) != 0;
  v18[45] = fan_pwm_percent;
  if ( v16 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: fan_eft : %d\tfan_pwm : %d\n",
      (const char *)_FUNCTION___13527,
      (unsigned __int8)v17,
      fan_pwm_percent);
    applog(7, tmp42, 0);
  }
  if ( (*((_BYTE *)&config_parameter + 4) & 2) != 0 && config_parameter.fan_pwm_percent <= 0x64u )
    set_PWM(config_parameter.fan_pwm_percent);
  else
    set_PWM_according_to_temperature();
  if ( (*((_BYTE *)&config_parameter + 4) & 4) != 0 )
  {
    if ( *(_WORD *)&config_parameter.timeout_data_integer )
    {
      v19 = dev;
      timeout = config_parameter.timeout_data_fractions + 1000 * config_parameter.timeout_data_integer;
      dev->timeout = timeout;
    }
    else
    {
      v40 = calculate_core_number(dev->corenum);
      v19 = dev;
      v41 = opt_debug;
      timeout = 90 * (dev->addrInterval * (0x1000000 / v40) / dev->frequency) / 100;
      dev->timeout = timeout;
      if ( v41 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "dev->timeout = %d\n", timeout);
        applog(7, tmp42, 0);
        v19 = dev;
        timeout = dev->timeout;
      }
    }
    if ( timeout > 0x1FFFF )
      v19->timeout = 0x1FFFF;
  }
  init_uart_baud();
  v21 = 0;
  cgsleep_ms(10);
  v22 = dev;
  do
  {
    while ( v22->chain_exist[v21] != 1 || v22->chain_asic_num[v21] != 18 )
    {
      if ( ++v21 == 16 )
        goto LABEL_48;
    }
    calibration_sensor_offset(0x98u, v21++);
    cgsleep_ms(10);
    v22 = dev;
  }
  while ( v21 != 16 );
LABEL_48:
  v23 = fpga_version;
  v24 = v22;
  v25 = v22;
  v26 = v22;
  v27 = 0;
  do
  {
    if ( v24->chain_exist[0] == 1 && v22->chain_asic_num[v27] == 18 )
    {
      if ( v23 <= 13 )
      {
        v33 = 3 * (v27 / 3);
        if ( v27 % 3 != 1 )
        {
          v26->chain_asic_temp_num[0] = v22->chain_asic_temp_num[v33 + 1];
          v25->TempChipAddr[0][0] = v22->TempChipAddr[v33 + 1][0];
          v25->TempChipAddr[0][1] = v22->TempChipAddr[v33 + 1][1];
        }
      }
      else if ( (unsigned int)v27 <= 0xD )
      {
        v28 = 1 << v27;
        if ( ((1 << v27) & 0x2008) != 0 )
        {
          v26->chain_asic_temp_num[0] = v22->chain_asic_temp_num[12];
          v25->TempChipAddr[0][0] = v22->TempChipAddr[12][0];
          v25->TempChipAddr[0][1] = v22->TempChipAddr[12][1];
        }
        else if ( (v28 & 0x804) != 0 )
        {
          v26->chain_asic_temp_num[0] = v22->chain_asic_temp_num[10];
          v25->TempChipAddr[0][0] = v22->TempChipAddr[10][0];
          v25->TempChipAddr[0][1] = v22->TempChipAddr[10][1];
        }
        else if ( (v28 & 0x202) != 0 )
        {
          v26->chain_asic_temp_num[0] = v22->chain_asic_temp_num[8];
          v25->TempChipAddr[0][0] = v22->TempChipAddr[8][0];
          v25->TempChipAddr[0][1] = v22->TempChipAddr[8][1];
        }
      }
    }
    ++v27;
    v24 = (all_parameters *)((char *)v24 + 4);
    v26 = (all_parameters *)((char *)v26 + 1);
    v25 = (all_parameters *)((char *)v25 + 8);
  }
  while ( v27 != 16 );
  set_time_out_control(0x8000C350);
  v29 = 1;
  v30 = dev;
  v31 = 0;
  while ( 2 )
  {
    if ( v30->chain_exist[v31] != 1 )
    {
LABEL_61:
      ++v31;
      ++v29;
      if ( v31 == 16 )
        goto LABEL_68;
      continue;
    }
    break;
  }
  open_core_one_chain(v31, 1);
  sleep(1u);
  if ( fpga_version <= 13 )
  {
    if ( v31 % 3 == 2 )
    {
      pthread_mutex_lock(&iic_mutex);
      set_pic_voltage(v31, chain_voltage_pic[v31]);
      pthread_mutex_unlock(&iic_mutex);
    }
    v36 = v29;
    v42 = chain_voltage_pic[v31];
    v37 = (364.0704 / ((double)v42 + 30.72) + 32.79) * 100.0 / 4.75;
    goto LABEL_77;
  }
  switch ( v31 )
  {
    case 1:
      open_core_one_chain(8, 1);
      sleep(1u);
      open_core_one_chain(9, 1);
      sleep(1u);
      goto LABEL_88;
    case 2:
      open_core_one_chain(10, 1);
      sleep(1u);
      open_core_one_chain(11, 1);
      sleep(1u);
LABEL_88:
      pthread_mutex_lock(&iic_mutex);
      set_pic_voltage(v31, chain_voltage_pic[v31]);
      pthread_mutex_unlock(&iic_mutex);
      v42 = chain_voltage_pic[v31];
      v36 = v29;
      v37 = (364.0704 / ((double)v42 + 30.72) + 32.79) * 100.0 / 4.75;
LABEL_77:
      sprintf((char *)logstr, "Chain[J%d] set working voltage=%d [%d]\n", v36, 10 * ((int)v37 / 10), v42);
      writeInitLogFile(logstr);
      v30 = dev;
      goto LABEL_61;
    case 3:
      open_core_one_chain(12, 1);
      sleep(1u);
      open_core_one_chain(13, 1);
      sleep(1u);
      goto LABEL_88;
  }
  v30 = dev;
LABEL_68:
  v32 = v30->timeout;
  if ( opt_multi_version )
    set_time_out_control((v32 * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(v32 & 0x1FFFF | 0x80000000);
}

//----- (000361AC) --------------------------------------------------------
void __fastcall open_core_onChain(int chainIndex, int coreNum, int opencore_num, bool nullwork_enable)
{
  unsigned int v4; // r7
  unsigned int v7; // r4
  unsigned int v8; // r0
  all_parameters *v9; // r7
  int v10; // r4
  int v11; // r4
  int v12; // r0
  int v13; // r3
  int v14; // r2
  unsigned int v15; // r6
  int v16; // r3
  unsigned int v17; // r2
  unsigned int v18; // r0
  unsigned int dhash_acc_control; // r0
  all_parameters *v20; // r4
  unsigned __int8 baud; // r5
  int v22; // r5
  int v23; // r0
  unsigned int v24; // r0
  unsigned int v25; // r0
  unsigned int v26; // r0
  unsigned __int8 v27; // r12
  int v28; // r11
  int v29; // lr
  vil_work_1387 *p_work_vil_1387; // r3
  unsigned int *v31; // r2
  int v32; // r1
  int v33; // r12
  int v34; // lr
  int v35; // r0
  unsigned int v36; // r0
  unsigned int v37; // r0
  int v38; // r8
  int v39; // r7
  unsigned int *v40; // r0
  unsigned int v41; // r0
  unsigned __int8 *v42; // r3
  unsigned int *v43; // r1
  int i; // r2
  int j; // r3
  unsigned int v46; // r1
  unsigned int *v47; // r2
  unsigned int v48; // r0
  _BOOL4 v50; // [sp+1Ch] [bp-924h]
  unsigned __int8 gateblk[4]; // [sp+2Ch] [bp-914h] BYREF
  unsigned __int8 buf_vil[9]; // [sp+30h] [bp-910h] BYREF
  unsigned int cmd_buf[3]; // [sp+3Ch] [bp-904h] BYREF
  unsigned int buf[13]; // [sp+48h] [bp-8F8h] BYREF
  unsigned int buf_vil_tw[13]; // [sp+7Ch] [bp-8C4h] BYREF
  unsigned __int8 data[52]; // [sp+B0h] [bp-890h] BYREF
  vil_work_1387 work_vil_1387; // [sp+E4h] [bp-85Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+118h] [bp-828h] BYREF

  v4 = 0;
  gateblk[0] = 0;
  gateblk[1] = 0;
  gateblk[2] = 0;
  gateblk[3] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  memset(buf, 0, sizeof(buf));
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  v7 = opt_multi_version;
  *(_DWORD *)data = 255;
  v50 = nullwork_enable;
  memset(&data[4], 0, 48);
  memset(buf_vil, 0, sizeof(buf_vil));
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | 0x8000 | dhash_acc_control & 0xFFFF7FDF);
    set_hash_counting_number(0);
    qmemcpy(&buf_vil[4], "@ ", 2);
    v20 = dev;
    strcpy((char *)buf_vil, "X\t");
    buf_vil[3] = 28;
    baud = dev->baud;
    buf_vil[7] = 0x80;
    v22 = baud & 0x1F | 0x80;
    buf_vil[6] = v22;
    v23 = CRC5(buf_vil, 0x40u);
    buf_vil[8] = v23;
    cmd_buf[1] = (v22 << 8) | 0x40200080;
    cmd_buf[2] = v23 << 24;
    memset(buf_vil_tw, 0, 13);
    cmd_buf[0] = 1476984860;
    memset(&work_vil_1387, 255, sizeof(work_vil_1387));
    if ( v20->chain_exist[chainIndex] == 1 )
    {
      v25 = get_BC_write_command() & 0xFFF0FFFF | (chainIndex << 16);
      set_BC_write_command(v25 & 0xFF3FFFFF | 0x800000);
      cgsleep_us(1000LL);
      work_vil_1387.work_type = 1;
      work_vil_1387.reserved1[0] = 0;
      work_vil_1387.chain_id = chainIndex | 0x80;
      work_vil_1387.reserved1[1] = 0;
      work_vil_1387.work_count = 0;
      work_vil_1387.data[0] = -1;
      work_vil_1387.data[11] = -1;
      set_BC_command_buffer(cmd_buf);
      v26 = get_BC_write_command();
      set_BC_write_command(v26 & 0xFFF0FFFF | (chainIndex << 16) | 0x80800000);
      cgsleep_us(10000LL);
      if ( coreNum )
      {
        do
        {
          v28 = 3001;
          if ( v4 >= opencore_num )
          {
            work_vil_1387.data[0] = 0;
            work_vil_1387.data[11] = 0;
          }
          else
          {
            v27 = -1;
          }
          if ( v4 < opencore_num )
          {
            work_vil_1387.data[0] = v27;
            work_vil_1387.data[11] = v27;
          }
          while ( ((1 << chainIndex) & axi_fpga_addr[3]) == 0 )
          {
            cgsleep_us(1000LL);
            if ( !--v28 )
            {
              sprintf((char *)tmp42, "Error: send open core work Failed on Chain[%d]!\n", chainIndex);
              writeInitLogFile(tmp42);
              goto LABEL_7;
            }
          }
          if ( v4 )
          {
            v29 = 0x1000000;
            work_vil_1387.work_type = 1;
          }
          else
          {
            v29 = 285212672;
            work_vil_1387.work_type = 17;
          }
          p_work_vil_1387 = &work_vil_1387;
          v31 = &buf_vil_tw[1];
          work_vil_1387.chain_id = chainIndex | 0x80;
          buf_vil_tw[1] = work_vil_1387.work_count;
          buf_vil_tw[0] = work_vil_1387.reserved1[1] | (work_vil_1387.reserved1[0] << 8) | (((unsigned __int8)chainIndex | 0x80) << 16) | v29;
          do
          {
            v32 = p_work_vil_1387->data[1];
            v33 = p_work_vil_1387->data[0];
            v34 = p_work_vil_1387->data[3];
            v35 = p_work_vil_1387->data[2];
            p_work_vil_1387 = (vil_work_1387 *)((char *)p_work_vil_1387 + 4);
            v31[1] = (v32 << 16) | (v33 << 24) | v34 | (v35 << 8);
            ++v31;
          }
          while ( p_work_vil_1387 != (vil_work_1387 *)&work_vil_1387.data[4] );
          memset(&buf_vil_tw[5], 0, 32);
          set_TW_write_command_vil(buf_vil_tw);
          if ( coreNum - 1 == v4 && v50 )
          {
            v36 = get_BC_write_command();
            set_BC_write_command(v36 | 0x400000);
          }
          ++v4;
        }
        while ( coreNum != v4 );
      }
    }
LABEL_7:
    v24 = get_dhash_acc_control();
    set_dhash_acc_control(v24 | ((opt_multi_version & 0xF) << 8) | 0x8000);
  }
  else
  {
    v8 = get_dhash_acc_control();
    set_dhash_acc_control(v8 & 0xFFFFFFDF);
    set_hash_counting_number(v7);
    v9 = dev;
    gateblk[1] = v7;
    gateblk[0] = -122;
    v10 = dev->baud;
    gateblk[3] = 0x80;
    v11 = v10 | 0x80;
    gateblk[2] = v11;
    v12 = CRC5(gateblk, 0x1Bu) & 0x1F;
    v13 = v12 | 0x80;
    gateblk[3] = v12 | 0x80;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: gateblk[0]=0x%x, gateblk[1]=0x%x, gateblk[2]=0x%x, gateblk[3]=0x%x\n",
        (const char *)_FUNCTION___13970,
        134,
        0,
        v11,
        v12 | 0x80);
      applog(7, tmp42, 0);
      v9 = dev;
      v11 = gateblk[2];
      v13 = gateblk[3];
      v14 = (gateblk[0] << 24) | (gateblk[1] << 16);
    }
    else
    {
      v14 = -2046820352;
    }
    v15 = 0;
    v16 = v13 | v14;
    *(_DWORD *)&data[48] = -16777216;
    memset(data, 0, 40);
    *(_DWORD *)&data[44] = 0;
    *(_DWORD *)&data[40] = 255;
    v17 = v9->chain_exist[chainIndex];
    cmd_buf[0] = v16 | (v11 << 8);
    if ( v17 == 1 )
    {
      set_BC_command_buffer(cmd_buf);
      v37 = get_BC_write_command();
      set_BC_write_command(v37 & 0xFFF0FFFF | (chainIndex << 16) | 0x80800000);
      cgsleep_us(10000LL);
      if ( coreNum )
      {
        v38 = 0;
        v39 = 1 << chainIndex;
        v40 = axi_fpga_addr;
        do
        {
          if ( (v39 & v40[3]) == 0 )
          {
            do
              cgsleep_us(1000LL);
            while ( (v39 & axi_fpga_addr[3]) == 0 );
          }
          if ( v38 )
          {
            data[0] = 1;
            data[1] = chainIndex | 0x80;
            if ( v38 == coreNum - 1 )
            {
LABEL_48:
              if ( v50 )
              {
                v48 = get_BC_write_command();
                set_BC_write_command(v48 & (((chainIndex & 0xF) << 16) | 0xC00000));
              }
            }
          }
          else
          {
            data[0] = 17;
            data[1] = chainIndex | 0x80;
            v41 = get_BC_write_command();
            set_BC_write_command(v41 & 0xFFBFFFFF);
            if ( coreNum == 1 )
              goto LABEL_48;
          }
          memset(buf, 0, 13);
          v42 = data;
          v43 = &cmd_buf[2];
          for ( i = 1; ; ++i )
          {
            v43[1] = _byteswap_ulong(*(_DWORD *)v42);
            ++v43;
            if ( i == 10 )
            {
              buf[9] = v15++;
              goto LABEL_39;
            }
            if ( i == 13 )
              break;
LABEL_39:
            v42 += 4;
          }
          v40 = axi_fpga_addr;
          for ( j = 0; j != 13; ++j )
          {
            v46 = buf[j];
            v47 = &v40[j];
            v47[16] = v46;
          }
          ++v38;
        }
        while ( coreNum != v38 );
      }
    }
    v18 = get_dhash_acc_control();
    set_dhash_acc_control(v18 | 0x20);
  }
}
// 364BE: variable 'v27' is possibly undefined

//----- (00036700) --------------------------------------------------------
void __fastcall opencore_onebyone_onChain(int chainIndex)
{
  int v2; // r4

  v2 = 0;
  do
  {
    open_core_onChain(chainIndex, 114, ++v2, 1);
    usleep(0x186A0u);
  }
  while ( v2 != 114 );
}

//----- (00036728) --------------------------------------------------------
void __fastcall insert_reg_data(unsigned int *buf)
{
  unsigned int p_wr; // r3
  unsigned int reg_value_num; // r2

  if ( reg_value_buf.reg_value_num <= 0x1FE && reg_value_buf.p_wr <= 0x1FE )
  {
    pthread_mutex_lock(&reg_mutex);
    reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = buf[1];
    reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = *((_BYTE *)buf + 3) & 0x1F;
    reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = *(_BYTE *)buf & 0xF;
    if ( reg_value_buf.p_wr > 0x1FE )
      p_wr = 0;
    else
      p_wr = reg_value_buf.p_wr;
    if ( reg_value_buf.p_wr <= 0x1FE )
      ++p_wr;
    reg_value_buf.p_wr = p_wr;
    if ( reg_value_buf.reg_value_num > 0x1FE )
      reg_value_num = 511;
    else
      reg_value_num = reg_value_buf.reg_value_num;
    if ( reg_value_buf.reg_value_num <= 0x1FE )
      ++reg_value_num;
    reg_value_buf.reg_value_num = reg_value_num;
    j_pthread_mutex_unlock(&reg_mutex);
  }
  else
  {
    clear_register_value_buf();
  }
}

//----- (000367B0) --------------------------------------------------------
int __fastcall getChainAsicNum(int chainIndex)
{
  return dev->chain_asic_num[chainIndex];
}

//----- (000367C8) --------------------------------------------------------
int __fastcall getChainExistFlag(int chainIndex)
{
  return dev->chain_exist[chainIndex];
}

//----- (000367DC) --------------------------------------------------------
void bitmain_reinit()
{
  int v0; // r5
  char *v1; // r3
  int v2; // r0
  int v3; // r5
  unsigned __int8 pic_voltage; // r0
  int v5; // r3
  unsigned __int8 v6; // r0
  int v7; // r7
  all_parameters *v8; // r3
  int i; // r5
  int v10; // r9
  int v11; // r5
  unsigned __int8 v12; // r0
  int v13; // r2
  int v14; // r5
  int v15; // r9
  char *v16; // r9
  int fan_pwm_percent; // r1
  _BOOL4 v18; // r0
  int v19; // r2
  char *v20; // r3
  all_parameters *v21; // r5
  unsigned int timeout; // r3
  int v23; // r5
  all_parameters *v24; // lr
  int v25; // r9
  all_parameters *v26; // r2
  all_parameters *v27; // r1
  all_parameters *v28; // r0
  signed int v29; // r3
  int v30; // r12
  unsigned int v31; // r0
  int v32; // r8
  int v33; // r5
  int v34; // r5
  int v35; // r3
  int v36; // r9
  int v37; // r2
  double v38; // d7
  unsigned __int16 frequency; // r0
  unsigned int dhash_acc_control; // r0
  int v41; // r0
  _BOOL4 v42; // r2
  int v43; // [sp+0h] [bp-950h]
  unsigned __int8 logstr[256]; // [sp+8h] [bp-948h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+108h] [bp-848h] BYREF

  v0 = 0;
  pthread_mutex_lock(&iic_mutex);
  memset(dev, 0, sizeof(all_parameters));
  dev->current_job_start_address = job_start_address_1;
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  set_reset_allhashboard(1);
  set_QN_write_data_command(0x8080800F);
  sleep(2u);
  set_PWM(0x64u);
  v1 = (char *)&dev->fan_speed_top1 + 1;
  *axi_fpga_addr = 0x80000000;
  v1[42] = 26;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  check_chain();
  set_reset_allhashboard(1);
  do
  {
    while ( dev->chain_exist[v0] != 1 )
    {
      if ( ++v0 == 16 )
        goto LABEL_5;
    }
    reset_iic_pic(v0);
    v2 = v0++;
    jump_to_app_CheckAndRestorePIC_T9_18(v2);
  }
  while ( v0 != 16 );
LABEL_5:
  v3 = 0;
  sleep(1u);
  do
  {
    while ( dev->chain_exist[v3] != 1 )
    {
      if ( ++v3 == 16 )
        goto LABEL_11;
    }
    pic_voltage = get_pic_voltage(v3);
    v5 = fpga_version;
    chain_voltage_pic[v3] = pic_voltage;
    if ( v5 <= 13 )
    {
      if ( v3 != 3 * (v3 / 3) )
        goto LABEL_10;
    }
    else if ( (unsigned int)(v3 - 1) > 2 )
    {
      goto LABEL_10;
    }
    set_voltage_T9_18_into_PIC(v3, 1u);
LABEL_10:
    v6 = v3++;
    disable_pic_dac(v6);
  }
  while ( v3 != 16 );
LABEL_11:
  cgsleep_ms(1000);
  v7 = 1;
  v8 = dev;
  for ( i = 0; i != 16; ++i )
  {
    while ( v8->chain_exist[i] != 1 )
    {
      ++i;
      ++v7;
      if ( i == 16 )
        goto LABEL_16;
    }
    v10 = 10 * ((int)((364.0704 / ((double)chain_voltage_pic[i] + 30.72) + 32.79) * 100.0 / 4.75) / 10);
    sprintf((char *)logstr, "Chain[J%d] working voltage=%d value=%d\n", v7, chain_voltage_pic[i], v10);
    writeInitLogFile(logstr);
    if ( getChainPICMagicNumber(i) == 125 )
    {
      v35 = chain_voltage_value[i];
      if ( v35 > v10 )
      {
        v36 = (unsigned __int8)(unsigned int)(364.0704 / ((double)v35 * 4.75 / 100.0 - 32.79) - 30.72);
        sprintf((char *)logstr, "Chain[J%d] will use backup chain_voltage_pic=%d [%d]\n", v7, v35, v36);
        writeInitLogFile(logstr);
        chain_voltage_pic[i] = v36;
        sprintf((char *)logstr, "Chain[J%d] get working voltage=%d\n", v7, v36);
        writeInitLogFile(logstr);
      }
    }
    v8 = dev;
    ++v7;
  }
LABEL_16:
  v11 = 0;
  while ( 2 )
  {
    if ( v8->chain_exist[v11] != 1 )
    {
      if ( ++v11 == 16 )
        break;
      goto LABEL_18;
    }
    v12 = v11++;
    enable_pic_dac(v12);
    if ( v11 != 16 )
    {
LABEL_18:
      v8 = dev;
      continue;
    }
    break;
  }
  sleep(5u);
  pthread_mutex_unlock(&iic_mutex);
  cgsleep_ms(2000);
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(((opt_multi_version & 0xF) << 8) | 0x8000 | dhash_acc_control & 0xFFFF7FDF);
  }
  cgsleep_ms(10);
  dev->corenum = 114;
  check_asic_reg(0);
  cgsleep_ms(10);
  v13 = 1;
  do
  {
    while ( 1 )
    {
      v14 = v13 + 1;
      v15 = v13 - 1;
      if ( *(&dev->pwm_value + v13) == 1 )
      {
        sprintf((char *)logstr, "Chain[J%d] has %d asic\n", v13, dev->chain_asic_num[v15]);
        writeInitLogFile(logstr);
        v16 = (char *)&dev->temp[5] + v15 + 2;
        if ( !v16[42] )
          break;
      }
      v13 = v14;
      if ( v14 == 17 )
        goto LABEL_28;
    }
    *((_DWORD *)&dev->current_job_start_address + v14) = (unsigned __int8)v16[42];
    v13 = v14;
  }
  while ( v14 != 17 );
LABEL_28:
  software_set_address();
  cgsleep_ms(10);
  if ( (*((_BYTE *)&config_parameter + 4) & 8) != 0 )
  {
    frequency = config_parameter.frequency;
    dev->frequency = config_parameter.frequency;
    set_frequency(frequency);
    sprintf((char *)dev->frequency_t, "%u", dev->frequency);
  }
  cgsleep_ms(10);
  fan_pwm_percent = config_parameter.fan_pwm_percent;
  v18 = opt_debug;
  v19 = (*((unsigned __int8 *)&config_parameter + 4) >> 1) & 1;
  v20 = (char *)&dev->fan_speed_top1 + 1;
  dev->fan_eft = (*((_BYTE *)&config_parameter + 4) & 2) != 0;
  v20[45] = fan_pwm_percent;
  if ( v18 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: fan_eft : %d\tfan_pwm : %d\n",
      (const char *)_FUNCTION___14073,
      (unsigned __int8)v19,
      fan_pwm_percent);
    applog(7, tmp42, 0);
  }
  if ( (*((_BYTE *)&config_parameter + 4) & 2) != 0 && config_parameter.fan_pwm_percent <= 0x64u )
    set_PWM(config_parameter.fan_pwm_percent);
  else
    set_PWM_according_to_temperature();
  if ( (*((_BYTE *)&config_parameter + 4) & 4) != 0 )
  {
    if ( *(_WORD *)&config_parameter.timeout_data_integer )
    {
      v21 = dev;
      timeout = config_parameter.timeout_data_fractions + 1000 * config_parameter.timeout_data_integer;
      dev->timeout = timeout;
    }
    else
    {
      v41 = calculate_core_number(dev->corenum);
      v21 = dev;
      v42 = opt_debug;
      timeout = 90 * (v21->addrInterval * (0x1000000 / v41) / v21->frequency) / 100;
      dev->timeout = timeout;
      if ( v42 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "dev->timeout = %d\n", timeout);
        applog(7, tmp42, 0);
        v21 = dev;
        timeout = dev->timeout;
      }
    }
    if ( timeout > 0x1FFFF )
      v21->timeout = 0x1FFFF;
  }
  init_uart_baud();
  v23 = 0;
  cgsleep_ms(10);
  v24 = dev;
  do
  {
    while ( v24->chain_exist[v23] != 1 || v24->chain_asic_num[v23] != 18 )
    {
      if ( ++v23 == 16 )
        goto LABEL_47;
    }
    calibration_sensor_offset(0x98u, v23++);
    cgsleep_ms(10);
    v24 = dev;
  }
  while ( v23 != 16 );
LABEL_47:
  v25 = fpga_version;
  v26 = v24;
  v27 = v24;
  v28 = v24;
  v29 = 0;
  do
  {
    if ( v26->chain_exist[0] == 1 && v24->chain_asic_num[v29] == 18 )
    {
      if ( v25 <= 13 )
      {
        v34 = 3 * (v29 / 3);
        if ( v29 % 3 != 1 )
        {
          v28->chain_asic_temp_num[0] = v24->chain_asic_temp_num[v34 + 1];
          v27->TempChipAddr[0][0] = v24->TempChipAddr[v34 + 1][0];
          v27->TempChipAddr[0][1] = v24->TempChipAddr[v34 + 1][1];
        }
      }
      else if ( (unsigned int)v29 <= 0xD )
      {
        v30 = 1 << v29;
        if ( ((1 << v29) & 0x2008) != 0 )
        {
          v28->chain_asic_temp_num[0] = v24->chain_asic_temp_num[12];
          v27->TempChipAddr[0][0] = v24->TempChipAddr[12][0];
          v27->TempChipAddr[0][1] = v24->TempChipAddr[12][1];
        }
        else if ( (v30 & 0x804) != 0 )
        {
          v28->chain_asic_temp_num[0] = v24->chain_asic_temp_num[10];
          v27->TempChipAddr[0][0] = v24->TempChipAddr[10][0];
          v27->TempChipAddr[0][1] = v24->TempChipAddr[10][1];
        }
        else if ( (v30 & 0x202) != 0 )
        {
          v28->chain_asic_temp_num[0] = v24->chain_asic_temp_num[8];
          v27->TempChipAddr[0][0] = v24->TempChipAddr[8][0];
          v27->TempChipAddr[0][1] = v24->TempChipAddr[8][1];
        }
      }
    }
    ++v29;
    v26 = (all_parameters *)((char *)v26 + 4);
    v28 = (all_parameters *)((char *)v28 + 1);
    v27 = (all_parameters *)((char *)v27 + 8);
  }
  while ( v29 != 16 );
  v31 = v24->timeout;
  if ( opt_multi_version )
    set_time_out_control((v31 * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(v31 & 0x1FFFF | 0x80000000);
  v32 = 1;
  v33 = 0;
  set_PWM(0x64u);
  while ( 2 )
  {
    if ( dev->chain_exist[v33] != 1 )
    {
LABEL_62:
      ++v33;
      ++v32;
      if ( v33 == 16 )
        return;
      continue;
    }
    break;
  }
  open_core_one_chain(v33, 1);
  sleep(1u);
  if ( fpga_version <= 13 )
  {
    if ( v33 % 3 == 2 )
    {
      pthread_mutex_lock(&iic_mutex);
      set_pic_voltage(v33, chain_voltage_pic[v33]);
      pthread_mutex_unlock(&iic_mutex);
    }
    v37 = v32;
    v43 = chain_voltage_pic[v33];
    v38 = (364.0704 / ((double)v43 + 30.72) + 32.79) * 100.0 / 4.75;
    goto LABEL_76;
  }
  switch ( v33 )
  {
    case 1:
      open_core_one_chain(8, 1);
      sleep(1u);
      open_core_one_chain(9, 1);
      sleep(1u);
      goto LABEL_87;
    case 2:
      open_core_one_chain(10, 1);
      sleep(1u);
      open_core_one_chain(11, 1);
      sleep(1u);
LABEL_87:
      pthread_mutex_lock(&iic_mutex);
      set_pic_voltage(v33, chain_voltage_pic[v33]);
      pthread_mutex_unlock(&iic_mutex);
      v43 = chain_voltage_pic[v33];
      v37 = v32;
      v38 = (364.0704 / ((double)v43 + 30.72) + 32.79) * 100.0 / 4.75;
LABEL_76:
      sprintf((char *)logstr, "Chain[J%d] set working voltage=%d [%d]\n", v37, 10 * ((int)v38 / 10), v43);
      writeInitLogFile(logstr);
      goto LABEL_62;
    case 3:
      open_core_one_chain(12, 1);
      sleep(1u);
      open_core_one_chain(13, 1);
      sleep(1u);
      goto LABEL_87;
  }
}

//----- (0003703C) --------------------------------------------------------
void __fastcall saveSearchFailedFlagInfo(unsigned __int8 *search_failed_info)
{
  FILE *v2; // r4
  size_t v3; // r0

  v2 = fopen("/tmp/searcherror", "wb");
  if ( v2 )
  {
    v3 = strlen((const char *)search_failed_info);
    fwrite(search_failed_info, 1u, v3 + 1, v2);
    fclose(v2);
  }
  system("cp /tmp/search /tmp/err1.log -f");
  system("cp /tmp/freq /tmp/err2.log -f");
  sub_A11C("cp /tmp/lasttemp /tmp/err3.log -f");
}

//----- (00037090) --------------------------------------------------------
int __cdecl bitmain_c5_init(init_config config)
{
  _BOOL4 v1; // r0
  const char *v3; // r7
  unsigned int v4; // lr
  int v5; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int *v9; // r7
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r1
  int v15; // r1
  int v16; // r3
  int v17; // r0
  init_config *i; // r2
  int version; // t1
  const unsigned __int8 *v20; // r3
  int v21; // r1
  int v22; // r9
  int v23; // r8
  unsigned int hardware_version; // r0
  unsigned int v25; // r0
  unsigned __int8 *v26; // r11
  char *v27; // r0
  int v28; // r11
  int v29; // r8
  unsigned int v30; // r10
  int v31; // r6
  _BOOL4 v32; // r9
  uint64_t *v33; // r12
  int v34; // r3
  int v35; // r8
  int v36; // r9
  uint64_t *v37; // r6
  uint64_t *v38; // r3
  int v39; // lr
  int v40; // r2
  int v41; // r12
  int v42; // r9
  int v43; // r8
  int v44; // r10
  int v45; // r9
  int v46; // r8
  int v47; // r11
  int v48; // r3
  int j; // r10
  int frequency; // r2
  int v51; // r1
  int k; // r8
  int v53; // r2
  int v54; // r8
  int v55; // r10
  int fan_pwm_percent; // r3
  _BOOL4 v57; // r0
  int v58; // r1
  char *v59; // r2
  all_parameters *v60; // r8
  unsigned int timeout; // r3
  int v62; // r8
  all_parameters *v63; // r3
  int v64; // r11
  all_parameters *v65; // r0
  all_parameters *v66; // r1
  all_parameters *v67; // lr
  signed int v68; // r2
  int v69; // r4
  int v70; // r10
  all_parameters *v71; // r3
  int v72; // r8
  int v73; // r12
  unsigned __int16 v74; // r0
  int v75; // r0
  _BOOL4 v76; // r2
  unsigned int dhash_acc_control; // r0
  int v78; // lr
  double v79; // d7
  int v80; // r3
  unsigned __int8 v81; // r1
  unsigned __int8 v82; // r0
  int v83; // r9
  all_parameters *v84; // r7
  all_parameters *v85; // r11
  int v86; // lr
  int v87; // r4
  int v88; // r3
  char *v89; // r6
  char *v90; // r0
  char *v91; // r0
  int v92; // r2
  int v93; // r0
  _WORD *v94; // r2
  int v95; // r10
  all_parameters *v96; // r11
  unsigned int v97; // r3
  int v98; // r4
  all_parameters *v99; // r11
  unsigned int v100; // r3
  int new_T9_PLUS_chainIndex; // [sp+4h] [bp-9D0h]
  unsigned int seconds; // [sp+1Ch] [bp-9B8h]
  int v103; // [sp+20h] [bp-9B4h]
  int v104; // [sp+20h] [bp-9B4h]
  int v105; // [sp+24h] [bp-9B0h]
  int v106; // [sp+30h] [bp-9A4h]
  sysinfo si; // [sp+34h] [bp-9A0h] BYREF
  unsigned __int8 logstr[256]; // [sp+74h] [bp-960h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+174h] [bp-860h] BYREF

  saveRestartNum(2);
  saveRebootTestNum(0);
  clearInitLogFile();
  v1 = isC5_Board();
  isC5_CtrlBoard = v1;
  if ( v1 )
  {
    PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
    strcpy((char *)logstr, "This is C5 board.\n");
  }
  else
  {
    sysinfo_0(&si);
    if ( si.totalram > 0x3B9ACA00 )
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
      strcpy((char *)logstr, "Detect 1GB control board of XILINX\n");
    }
    else
    {
      if ( si.totalram <= 0x1DCD6500 )
        v3 = "Detect 256MB control board of XILINX\n";
      else
        v3 = "Detect 512MB control board of XILINX\n";
      if ( si.totalram <= 0x1DCD6500 )
        v4 = 251658240;
      else
        v4 = 520093696;
      v5 = *(_DWORD *)v3;
      v6 = *((_DWORD *)v3 + 1);
      v7 = *((_DWORD *)v3 + 2);
      v8 = *((_DWORD *)v3 + 3);
      v9 = (int *)(v3 + 16);
      PHY_MEM_NONCE2_JOBID_ADDRESS = v4;
      *(_DWORD *)logstr = v5;
      *(_DWORD *)&logstr[4] = v6;
      *(_DWORD *)&logstr[8] = v7;
      *(_DWORD *)&logstr[12] = v8;
      v10 = *v9;
      v11 = v9[1];
      v12 = v9[2];
      v13 = v9[3];
      v9 += 4;
      *(_DWORD *)&logstr[16] = v10;
      *(_DWORD *)&logstr[20] = v11;
      *(_DWORD *)&logstr[24] = v12;
      *(_DWORD *)&logstr[28] = v13;
      v14 = v9[1];
      *(_DWORD *)&logstr[32] = *v9;
      *(_WORD *)&logstr[36] = v14;
    }
  }
  writeInitLogFile(logstr);
  strcpy((char *)logstr, "Miner Type = T9+\n");
  writeInitLogFile(logstr);
  config_parameter = config;
  if ( config.token_type != 81 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -1;
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: config_parameter.token_type != 0x%x, it is 0x%x\n",
      (const char *)_FUNCTION___14112,
      81,
      config.token_type);
    applog(7, tmp42, 0);
    return -1;
  }
  v15 = 255;
  v16 = 81;
  v17 = 255;
  for ( i = &config_parameter; ; i = (init_config *)((char *)i + 1) )
  {
    v20 = &_PRETTY_FUNCTION___14401[v16 ^ v17];
    v17 = v15 ^ v20[1976];
    v15 = v20[2232];
    if ( i == (init_config *)((char *)&config_parameter.chain_max_freq + 1) )
      break;
    version = i->version;
    v16 = version;
  }
  v21 = v17 | (v15 << 8);
  if ( config_parameter.crc != v21 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -2;
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
      (const char *)_FUNCTION___14112,
      config_parameter.crc,
      v21);
    applog(7, tmp42, 0);
    return -2;
  }
  read_nonce_reg_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_nonce_reg_id, 0, (void *(*)(void *))get_nonce_and_register, read_nonce_reg_id) )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -5;
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: create thread for get nonce and register from FPGA failed\n",
      (const char *)_FUNCTION___14112);
    applog(7, tmp42, 0);
    return -5;
  }
  pthread_detach(read_nonce_reg_id->pth);
  bitmain_axi_init();
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  set_reset_allhashboard(1);
  if ( (*((_BYTE *)&config_parameter + 4) & 1) != 0 )
  {
    set_QN_write_data_command(0x8080800F);
    sleep(2u);
    set_PWM(0x64u);
  }
  v22 = 0;
  v23 = 0;
  *axi_fpga_addr = 0x80000000;
  hardware_version = get_hardware_version();
  fpga_version = (unsigned __int8)hardware_version;
  pcb_version = HIWORD(hardware_version) & 0x7FFF;
  sprintf((char *)g_miner_version, "%d.%d.%d.%d", (unsigned __int8)hardware_version, pcb_version, 1, 3);
  set_reset_allhashboard(1);
  v25 = PHY_MEM_NONCE2_JOBID_ADDRESS;
  dev->baud = 26;
  set_nonce2_and_job_id_store_address(v25);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  check_chain();
  do
  {
    if ( dev->chain_exist[v23] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      get_hash_board_id_number(v23, hash_board_id[v23]);
      v26 = bin2hex(hash_board_id[v23], 0xCu);
      v27 = (char *)&hash_board_id_string[34 * v22++];
      sprintf(v27, "{\"ID\":\"%s\"},", (const char *)v26);
      free(v26);
      pthread_mutex_unlock(&iic_mutex);
    }
    ++v23;
  }
  while ( v23 != 16 );
  v28 = 0;
  v29 = 0;
  v30 = -1;
  hash_board_id_string[34 * v22 - 1] = 0;
  v31 = 1;
  do
  {
    if ( dev->chain_exist[v29] != 1 )
      goto LABEL_43;
    if ( fpga_version <= 13 )
    {
      seconds = dev->chain_exist[v29];
      pthread_mutex_lock(&iic_mutex);
      v40 = v29 % 3;
      if ( v29 == 3 * (v29 / 3) )
      {
        reset_iic_pic(v29);
        sleep(seconds);
        jump_to_app_CheckAndRestorePIC_T9_18(v29);
        if ( opt_fixed_freq )
          goto LABEL_49;
        read_freq_badcores(v29, chain_pic_buf[3 * (v29 / 3)]);
        v40 = v29 % 3;
      }
      if ( !opt_fixed_freq )
      {
        v41 = 384 * (v29 / 3);
        v42 = 31 * v40;
        if ( *((_BYTE *)&h + v41 + 212) == 125 )
        {
          v80 = 10 * *((unsigned __int8 *)&h + v41 + v42 + 220);
          chain_voltage_value[v28] = v80;
          sprintf((char *)logstr, "Chain[J%d] has backup chain_voltage=%d\n", v31, v80);
          writeInitLogFile(logstr);
          v41 = 384 * (v29 / 3);
        }
        v39 = *((char *)&h + v41 + v42 + 222);
        goto LABEL_57;
      }
    }
    else
    {
      if ( v30 > 0xC )
      {
        v103 = 0;
        pthread_mutex_lock(&iic_mutex);
        v105 = 0;
      }
      else
      {
        v105 = CSWTCH_824[v28 - 1];
        v103 = CSWTCH_825[v28 - 1];
        pthread_mutex_lock(&iic_mutex);
        if ( v30 <= 2 )
        {
          reset_iic_pic(v29);
          jump_to_app_CheckAndRestorePIC_T9_18(v29);
          if ( opt_fixed_freq )
            goto LABEL_49;
          v32 = opt_fixed_freq;
          read_freq_badcores(v29, chain_pic_buf[v29]);
          sprintf((char *)logstr, "Chain[%d] read_freq_badcores : ", v29);
          writeInitLogFile(logstr);
          v33 = &h + 16 * v29;
          v34 = v29;
          v106 = v31;
          v35 = v32;
          v36 = v34;
          v37 = v33;
          do
          {
            sprintf((char *)logstr, "0x%02x ", *((unsigned __int8 *)v37 + v35 + 212));
            writeInitLogFile(logstr);
            v35 = (unsigned __int8)(v35 + 1);
          }
          while ( v35 != 128 );
          v31 = v106;
          v29 = v36;
          strcpy((char *)logstr, "\n");
          writeInitLogFile(logstr);
        }
      }
      if ( !opt_fixed_freq )
      {
        v38 = &h + 16 * v105;
        if ( *((_BYTE *)v38 + 212) == 125 )
        {
          v48 = 10 * *((unsigned __int8 *)v38 + 31 * v103 + 220);
          chain_voltage_value[v28] = v48;
          sprintf((char *)logstr, "Chain[J%d] has backup chain_voltage=%d\n", v31, v48);
          writeInitLogFile(logstr);
        }
        v39 = *((char *)&h + 128 * v105 + 31 * v103 + 222);
LABEL_57:
        lowest_testOK_temp[v28] = v39;
        sprintf((char *)logstr, "Chain[J%d] test patten OK temp=%d\n", v31, v39);
        writeInitLogFile(logstr);
      }
    }
LABEL_49:
    pthread_mutex_unlock(&iic_mutex);
LABEL_43:
    ++v29;
    ++v31;
    ++v28;
    ++v30;
  }
  while ( v29 != 16 );
  pic_heart_beat = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(pic_heart_beat, 0, (void *(*)(void *))pic_heart_beat_func, pic_heart_beat) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: create thread error for pic_heart_beat_func\n", _FUNCTION___14112);
      goto LABEL_70;
    }
    return -6;
  }
  v43 = 0;
  v44 = 1;
  pthread_detach(pic_heart_beat->pth);
  while ( 2 )
  {
    if ( dev->chain_exist[v43] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      chain_voltage_pic[v43] = get_pic_voltage(v43);
      sprintf((char *)logstr, "Chain[J%d] will use voltage=%d [%d] to open core\n", v44, 930, 1);
      writeInitLogFile(logstr);
      if ( fpga_version <= 13 )
      {
        if ( v43 == 3 * (v43 / 3) )
          goto LABEL_87;
      }
      else
      {
        if ( (unsigned int)(v43 - 1) > 2 )
          goto LABEL_79;
LABEL_87:
        set_voltage_T9_18_into_PIC(v43, 1u);
      }
LABEL_79:
      pthread_mutex_unlock(&iic_mutex);
    }
    ++v43;
    ++v44;
    if ( v43 != 16 )
      continue;
    break;
  }
  if ( !opt_fixed_freq )
    goto LABEL_81;
  for ( j = 0; j != 16; ++j )
  {
    if ( dev->chain_exist[j] == 1 )
    {
      frequency = config_parameter.frequency;
      if ( config_parameter.frequency <= 0x289u )
      {
        if ( config_parameter.frequency <= 0x270u )
        {
          if ( config_parameter.frequency < 0x258u )
          {
            if ( config_parameter.frequency <= 0x23Eu )
            {
              if ( config_parameter.frequency <= 0x21Eu )
              {
                v51 = 930;
                if ( config_parameter.frequency >= 0x204u )
                  v51 = 920;
              }
              else
              {
                v51 = 890;
              }
            }
            else
            {
              v51 = 870;
            }
          }
          else
          {
            v51 = 850;
          }
        }
        else
        {
          v51 = 830;
        }
      }
      else
      {
        v51 = 810;
      }
      chain_voltage_value[j] = v51;
      new_T9_PLUS_chainIndex = (unsigned __int8)(unsigned int)(364.0704 / ((double)v51 * 4.75 / 100.0 - 32.79) - 30.72);
      chain_voltage_pic[j] = new_T9_PLUS_chainIndex;
      sprintf(
        (char *)logstr,
        "Fix freq=%d Chain[%d] voltage_pic=%d value=%d\n",
        frequency,
        j,
        new_T9_PLUS_chainIndex,
        v51);
      writeInitLogFile(logstr);
    }
  }
  if ( !opt_fixed_freq )
  {
LABEL_81:
    v45 = 1;
    v46 = 0;
    cgsleep_ms(100);
    do
    {
      if ( dev->chain_exist[v46] == 1 )
      {
        pthread_mutex_lock(&iic_mutex);
        v47 = 10 * ((int)((364.0704 / ((double)chain_voltage_pic[v46] + 30.72) + 32.79) * 100.0 / 4.75) / 10);
        sprintf((char *)logstr, "Chain[J%d] orignal chain_voltage_pic=%d value=%d\n", v45, chain_voltage_pic[v46], v47);
        writeInitLogFile(logstr);
        if ( getChainPICMagicNumber(v46) == 125 )
        {
          v78 = chain_voltage_value[v46];
          if ( v78 != v47 )
          {
            v79 = 364.0704 / ((double)v78 * 4.75 / 100.0 - 32.79) - 30.72;
            sprintf(
              (char *)logstr,
              "Chain[J%d] will use backup chain_voltage_pic=%d [%d]\n",
              v45,
              chain_voltage_value[v46],
              (unsigned __int8)(unsigned int)v79);
            writeInitLogFile(logstr);
            chain_voltage_pic[v46] = (unsigned int)v79;
            sprintf(
              (char *)logstr,
              "Chain[J%d] get working chain_voltage_pic=%d\n",
              v45,
              (unsigned __int8)(unsigned int)v79);
            writeInitLogFile(logstr);
          }
        }
        pthread_mutex_unlock(&iic_mutex);
      }
      ++v46;
      ++v45;
    }
    while ( v46 != 16 );
    cgsleep_ms(1000);
  }
  for ( k = 0; k != 16; ++k )
  {
    if ( dev->chain_exist[k] == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      enable_pic_dac(k);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  sleep(5u);
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
  }
  cgsleep_ms(10);
  dev->corenum = 114;
  check_asic_reg(0);
  cgsleep_ms(10);
  v53 = 1;
  do
  {
    v54 = v53 + 1;
    v55 = v53 - 1;
    if ( *(&dev->pwm_value + v53) == 1 )
    {
      sprintf((char *)logstr, "Chain[J%d] has %d asic\n", v53, dev->chain_asic_num[v55]);
      writeInitLogFile(logstr);
      if ( !dev->chain_asic_num[v55] )
        *((_DWORD *)&dev->current_job_start_address + v54) = dev->chain_asic_num[v55];
    }
    v53 = v54;
  }
  while ( v54 != 17 );
  software_set_address();
  cgsleep_ms(10);
  if ( (*((_BYTE *)&config_parameter + 4) & 8) != 0 )
  {
    v74 = config_parameter.frequency;
    dev->frequency = config_parameter.frequency;
    set_frequency(v74);
    sprintf((char *)dev->frequency_t, "%u", dev->frequency);
  }
  cgsleep_ms(10);
  fan_pwm_percent = config_parameter.fan_pwm_percent;
  v57 = opt_debug;
  v58 = (*((unsigned __int8 *)&config_parameter + 4) >> 1) & 1;
  v59 = (char *)&dev->fan_speed_top1 + 1;
  dev->fan_eft = (*((_BYTE *)&config_parameter + 4) & 2) != 0;
  v59[45] = fan_pwm_percent;
  if ( v57 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s: fan_eft : %d  fan_pwm : %d\n",
      (const char *)_FUNCTION___14112,
      (unsigned __int8)v58,
      fan_pwm_percent);
    applog(7, tmp42, 0);
  }
  if ( (*((_BYTE *)&config_parameter + 4) & 2) != 0 && config_parameter.fan_pwm_percent <= 0x64u )
    set_PWM(config_parameter.fan_pwm_percent);
  else
    set_PWM_according_to_temperature();
  if ( (*((_BYTE *)&config_parameter + 4) & 4) != 0 )
  {
    if ( *(_WORD *)&config_parameter.timeout_data_integer )
    {
      v60 = dev;
      timeout = config_parameter.timeout_data_fractions + 1000 * config_parameter.timeout_data_integer;
      dev->timeout = timeout;
    }
    else
    {
      v75 = calculate_core_number(dev->corenum);
      v60 = dev;
      v76 = opt_debug;
      timeout = 90 * (dev->addrInterval * (0x1000000 / v75) / dev->frequency) / 100;
      dev->timeout = timeout;
      if ( v76 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "dev->timeout = %d\n", timeout);
        applog(7, tmp42, 0);
        v60 = dev;
        timeout = dev->timeout;
      }
    }
    if ( timeout > 0x1FFFF )
      v60->timeout = 0x1FFFF;
  }
  init_uart_baud();
  v62 = 0;
  cgsleep_ms(10);
  v63 = dev;
  do
  {
    if ( v63->chain_exist[v62] == 1 && v63->chain_asic_num[v62] == 18 )
    {
      calibration_sensor_offset(0x98u, v62);
      cgsleep_ms(10);
      v63 = dev;
    }
    ++v62;
  }
  while ( v62 != 16 );
  v64 = fpga_version;
  v65 = v63;
  v66 = v63;
  v67 = v63;
  v68 = 0;
  do
  {
    if ( v65->chain_exist[0] == 1 && v63->chain_asic_num[v68] == 18 )
    {
      if ( v64 <= 13 )
      {
        v73 = 3 * (v68 / 3);
        if ( v68 % 3 != 1 )
        {
          v67->chain_asic_temp_num[0] = v63->chain_asic_temp_num[v73 + 1];
          v66->TempChipAddr[0][0] = v63->TempChipAddr[v73 + 1][0];
          v66->TempChipAddr[0][1] = v63->TempChipAddr[v73 + 1][1];
        }
      }
      else if ( (unsigned int)v68 <= 0xD )
      {
        v69 = 1 << v68;
        if ( ((1 << v68) & 0x2008) != 0 )
        {
          v67->chain_asic_temp_num[0] = v63->chain_asic_temp_num[12];
          v66->TempChipAddr[0][0] = v63->TempChipAddr[12][0];
          v66->TempChipAddr[0][1] = v63->TempChipAddr[12][1];
        }
        else if ( (v69 & 0x804) != 0 )
        {
          v67->chain_asic_temp_num[0] = v63->chain_asic_temp_num[10];
          v66->TempChipAddr[0][0] = v63->TempChipAddr[10][0];
          v66->TempChipAddr[0][1] = v63->TempChipAddr[10][1];
        }
        else if ( (v69 & 0x202) != 0 )
        {
          v67->chain_asic_temp_num[0] = v63->chain_asic_temp_num[8];
          v66->TempChipAddr[0][0] = v63->TempChipAddr[8][0];
          v66->TempChipAddr[0][1] = v63->TempChipAddr[8][1];
        }
      }
    }
    ++v68;
    v65 = (all_parameters *)((char *)v65 + 4);
    v67 = (all_parameters *)((char *)v67 + 1);
    v66 = (all_parameters *)((char *)v66 + 8);
  }
  while ( v68 != 16 );
  set_time_out_control((v63->timeout / 0xA) & 0x1FFFF | 0x80000000);
  set_PWM(0x64u);
  v70 = 1;
  v71 = dev;
  v72 = 0;
  while ( 2 )
  {
    if ( v71->chain_exist[v72] != 1 )
    {
LABEL_147:
      ++v72;
      ++v70;
      if ( v72 == 16 )
        goto LABEL_154;
      continue;
    }
    break;
  }
  open_core_one_chain(v72, 1);
  sleep(1u);
  if ( fpga_version <= 13 )
  {
    if ( v72 % 3 != 2 )
    {
LABEL_161:
      sprintf(
        (char *)logstr,
        "Chain[J%d] set working voltage=%d [%d]\n",
        v70,
        10 * ((int)((364.0704 / ((double)chain_voltage_pic[v72] + 30.72) + 32.79) * 100.0 / 4.75) / 10),
        chain_voltage_pic[v72]);
      writeInitLogFile(logstr);
      v71 = dev;
      goto LABEL_147;
    }
    pthread_mutex_lock(&iic_mutex);
    v81 = chain_voltage_pic[v72];
    v82 = 3 * ((char)v72 / 3);
LABEL_189:
    set_pic_voltage(v82, v81);
    pthread_mutex_unlock(&iic_mutex);
    goto LABEL_161;
  }
  switch ( v72 )
  {
    case 1:
      strcpy((char *)logstr, "open core on chain[1] [8] [9]...\n");
      writeInitLogFile(logstr);
      open_core_one_chain(8, 1);
      sleep(1u);
      open_core_one_chain(9, 1);
      sleep(1u);
LABEL_188:
      pthread_mutex_lock(&iic_mutex);
      v81 = chain_voltage_pic[v72];
      v82 = v72;
      goto LABEL_189;
    case 2:
      strcpy((char *)logstr, "open core on chain[2] [10] [11]...\n");
      writeInitLogFile(logstr);
      open_core_one_chain(10, 1);
      sleep(1u);
      open_core_one_chain(11, 1);
      sleep(1u);
      goto LABEL_188;
    case 3:
      strcpy((char *)logstr, "open core on chain[3] [12] [13]...\n");
      writeInitLogFile(logstr);
      open_core_one_chain(12, 1);
      sleep(1u);
      open_core_one_chain(13, 1);
      sleep(1u);
      goto LABEL_188;
  }
  v71 = dev;
LABEL_154:
  set_time_out_control((v71->timeout / 0xA) & 0x1FFFF | 0x80000000);
  read_temp_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_temp_id, 0, (void *(*)(void *))read_temp_func, read_temp_id) )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -7;
    snprintf((char *)tmp42, 0x800u, "%s: create thread for read temp\n", (const char *)_FUNCTION___14112);
    applog(7, tmp42, 0);
    return -7;
  }
  pthread_detach(read_temp_id->pth);
  if ( !opt_fixed_freq && opt_pre_heat )
  {
    v95 = opt_fixed_freq;
    doTestPatten = 1;
    sleep(3u);
    v96 = dev;
    do
    {
      v97 = v96->chain_exist[0];
      v96 = (all_parameters *)((char *)v96 + 4);
      if ( v97 == 1 )
        memcpy(chain_pic_buf[v95], chip_last_freq[v95], sizeof(unsigned __int8[128]));
      ++v95;
    }
    while ( v95 != 16 );
    v98 = 0;
    someBoardUpVoltage = 0;
    clement_doTestBoard(1);
    v99 = dev;
    do
    {
      v100 = v99->chain_exist[0];
      v99 = (all_parameters *)((char *)v99 + 4);
      if ( v100 == 1 )
        memcpy(chain_pic_buf[v98], show_last_freq[v98], sizeof(unsigned __int8[128]));
      ++v98;
    }
    while ( v98 != 16 );
    set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
    set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
    doTestPatten = 0;
  }
  set_asic_ticket_mask(0x3Fu);
  set_hcnt(0);
  cgsleep_ms(10);
  if ( opt_multi_version )
    set_time_out_control((dev->timeout * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
  check_system_work_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(check_system_work_id, 0, (void *(*)(void *))check_system_work, check_system_work_id) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: create thread for check system\n", _FUNCTION___14112);
LABEL_70:
      applog(7, tmp42, 0);
    }
    return -6;
  }
  v83 = 0;
  pthread_detach(check_system_work_id->pth);
  v84 = dev;
  v85 = dev;
  do
  {
    if ( v85->chain_exist[0] )
    {
      v86 = v84->chain_asic_num[v83];
      if ( v84->chain_asic_num[v83] )
      {
        v87 = 0;
        v88 = 0;
        v104 = 8 * v83;
        v89 = (char *)v84 + 72 * v83;
        do
        {
          v90 = &v89[v87 + v88];
          if ( (v88 & 7) == 0 )
            ++v87;
          v91 = v90 + 10936;
          v92 = (v83 << 6) + v88 + 343;
          if ( (v88 & 7) == 0 )
            v91[2] = 32;
          v93 = (int)&v89[v87 + v88++];
          v94 = (_WORD *)((char *)v84 + 8 * v92);
          *(_BYTE *)(v93 + 10938) = 111;
          v94[1] = 0;
          v94[2] = 0;
          v94[3] = 0;
          v94[4] = 0;
        }
        while ( v86 != v88 );
      }
      else
      {
        v87 = v84->chain_asic_num[v83];
        v104 = 8 * v83;
      }
      v84->chain_asic_status_string[0][8 * v104 + 8 * v83 + v87 + v86] = 0;
    }
    ++v83;
    v85 = (all_parameters *)((char *)v85 + 4);
  }
  while ( v83 != 16 );
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  startCheckNetworkJob = 1;
  setStartTimePoint();
  return 0;
}
// 50464: using guessed type int CSWTCH_824[];
// 50498: using guessed type int CSWTCH_825[];

//----- (000383FC) --------------------------------------------------------
bool __fastcall bitmain_c5_prepare(thr_info *thr)
{
  char *device_data; // r4
  const unsigned __int8 *v2; // r1
  const unsigned __int8 *v3; // r2
  int v4; // r3
  const unsigned __int8 *v5; // r1
  const unsigned __int8 *v6; // r2
  int v7; // r3
  const unsigned __int8 *v8; // r1
  const unsigned __int8 *v9; // r2
  int v10; // r3
  const unsigned __int8 *v11; // r1
  const unsigned __int8 *v12; // r2
  int v13; // r3
  char *v14; // r4
  const unsigned __int8 *v15; // r1
  const unsigned __int8 *v16; // r2
  int v17; // r3
  int v18; // r1
  init_config *p_c5_config; // r2
  int v20; // r3
  int v21; // r0
  int version; // t1
  const unsigned __int8 *v23; // r3
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  int *v28; // r0
  init_config c5_config; // [sp+10h] [bp-848h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp-828h] BYREF

  device_data = (char *)thr->cgpu->device_data;
  *((_DWORD *)device_data + 103) = thr;
  if ( pthread_mutex_init((pthread_mutex_t *)(device_data + 420), 0) )
    mutex_init_1((pthread_mutex_t *)0x2DB1, v2, v3, v4);
  if ( pthread_mutex_init((pthread_mutex_t *)device_data, 0) )
    mutex_init_1((pthread_mutex_t *)0x2DB2, v5, v6, v7);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(device_data + 24), 0) )
  {
    v28 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v28,
      "driver-btm-c5.c",
      (const char *)_func___14388,
      11698);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(device_data + 692), 0) )
    mutex_init_1((pthread_mutex_t *)0x2DB3, v8, v9, v10);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(device_data + 716), 0) )
  {
    v27 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v27,
      "driver-btm-c5.c",
      (const char *)_func___14388,
      11699);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(device_data + 2540), 0) )
    mutex_init_1((pthread_mutex_t *)0x2DB4, v11, v12, v13);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(device_data + 2564), 0) )
  {
    v26 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v26,
      "driver-btm-c5.c",
      (const char *)_func___14388,
      11700);
    applog(3, tmp42, 1);
    quit(1);
  }
  v14 = device_data + 4384;
  if ( pthread_mutex_init((pthread_mutex_t *)(v14 + 4), 0) )
    mutex_init_1((pthread_mutex_t *)0x2DB5, v15, v16, v17);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v14 + 28), 0) )
  {
    v25 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v25,
      "driver-btm-c5.c",
      (const char *)_func___14388,
      11701);
    applog(3, tmp42, 1);
    quit(1);
  }
  v18 = 255;
  *(_DWORD *)&c5_config.chip_address = 26214404;
  *(_DWORD *)&c5_config.chain_max_freq = 600;
  p_c5_config = &c5_config;
  c5_config.reg_data = 0;
  v20 = 81;
  *(_DWORD *)&c5_config.token_type = 1704017;
  v21 = 255;
  *((_DWORD *)&c5_config + 1) = (unsigned __int8)(2 * opt_bitmain_fan_ctrl) | 0xFD;
  *(_DWORD *)&c5_config.chain_check_time_integer = 2570;
  c5_config.fan_pwm_percent = opt_bitmain_fan_pwm;
  *((_BYTE *)&c5_config + 5) = 7;
  c5_config.chain_num = 9;
  c5_config.asic_num = 54;
  c5_config.temperature = 80;
  c5_config.frequency = opt_bitmain_c5_freq;
  c5_config.voltage[0] = 7;
  c5_config.voltage[1] = 37;
  while ( 1 )
  {
    v23 = &_PRETTY_FUNCTION___14401[v20 ^ v21];
    v21 = v18 ^ v23[1976];
    v18 = v23[2232];
    if ( p_c5_config == (init_config *)((char *)&c5_config.chain_max_freq + 1) )
      break;
    version = p_c5_config->version;
    p_c5_config = (init_config *)((char *)p_c5_config + 1);
    v20 = version;
  }
  c5_config.crc = v21 | ((_WORD)v18 << 8);
  bitmain_c5_init(c5_config);
  send_mac_thr = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(send_mac_thr, 0, (void *(*)(void *))send_mac, send_mac_thr)
    && opt_debug
    && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: create thread for send mac\n", (const char *)_FUNCTION___14391);
    applog(7, tmp42, 0);
  }
  return 1;
}
// 385D8: variable 'v2' is possibly undefined
// 385D8: variable 'v3' is possibly undefined
// 385D8: variable 'v4' is possibly undefined
// 38614: variable 'v15' is possibly undefined
// 38614: variable 'v16' is possibly undefined
// 38614: variable 'v17' is possibly undefined
// 38650: variable 'v11' is possibly undefined
// 38650: variable 'v12' is possibly undefined
// 38650: variable 'v13' is possibly undefined
// 3868C: variable 'v8' is possibly undefined
// 3868C: variable 'v9' is possibly undefined
// 3868C: variable 'v10' is possibly undefined
// 386C8: variable 'v5' is possibly undefined
// 386C8: variable 'v6' is possibly undefined
// 386C8: variable 'v7' is possibly undefined

//----- (00038708) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall parse_job_to_c5(unsigned __int8 **buf, pool *pool, unsigned int id)
{
  bool clean; // r3
  int nonce2_offset; // r2
  unsigned __int8 *coinbase; // r11
  unsigned int n2size; // r0
  unsigned int coinbase_len; // r10
  unsigned __int8 *v9; // r1
  size_t v10; // r2
  int v11; // r0
  int v12; // r1
  int merkles; // r5
  unsigned int v14; // r4
  size_t v15; // r8
  unsigned __int8 *v16; // r0
  int v17; // r9
  unsigned __int8 *v18; // r6
  unsigned __int8 *v19; // r10
  int v20; // r12
  unsigned __int8 **v21; // r11
  unsigned __int8 *v22; // t1
  int v23; // r0
  int v24; // r1
  int v25; // r2
  int v26; // r0
  int v27; // r1
  int v28; // r2
  int v29; // r1
  int v30; // r0
  unsigned __int8 *v31; // r3
  int v32; // t1
  const unsigned __int8 *v33; // r2
  __int16 v34; // r1
  unsigned __int8 *v35; // r0
  uint64_t nonce2; // [sp+10h] [bp-880h] BYREF
  _BYTE src[80]; // [sp+18h] [bp-878h] OVERLAPPED BYREF
  unsigned __int8 tmp42[2048]; // [sp+68h] [bp-828h] BYREF

  clean = pool->swork.clean;
  *(_DWORD *)&src[12] = id;
  src[0] = 82;
  src[1] = 0;
  src[9] = src[9] & 0xFE | clean | 2;
  src[8] = pool_send_nu_14203;
  src[10] = 15;
  hex2bin(&src[16], pool->bbversion, 4u);
  hex2bin(&src[20], pool->prev_hash, 0x20u);
  hex2bin(&src[56], pool->nbit, 4u);
  hex2bin(&src[52], pool->ntime, 4u);
  nonce2_offset = pool->nonce2_offset;
  coinbase = pool->coinbase;
  n2size = pool->n2size;
  coinbase_len = pool->coinbase_len;
  v9 = &coinbase[nonce2_offset];
  nonce2 = pool->nonce2;
  *(_WORD *)&src[62] = nonce2_offset;
  v10 = n2size;
  *(_WORD *)&src[60] = coinbase_len;
  *(_WORD *)&src[64] = n2size;
  v11 = *(_DWORD *)v9;
  v12 = *((_DWORD *)v9 + 1);
  *(_DWORD *)&src[72] = v11;
  *(_DWORD *)&src[76] = v12;
  memcpy(&src[72], &nonce2, v10);
  merkles = pool->merkles;
  *(_WORD *)&src[66] = merkles;
  v14 = coinbase_len + 32 * merkles;
  v15 = v14 + 82;
  v16 = (unsigned __int8 *)malloc(v14 + 82);
  v17 = 1 - (_DWORD)v16;
  v18 = v16;
  if ( (unsigned int)v16 > 1 )
    v17 = 0;
  if ( v17 )
  {
    strcpy((char *)tmp42, "Failed to malloc tmp_buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  *(_DWORD *)&src[4] = v14 + 74;
  memset(v16, 0, v14 + 82);
  memcpy(v18, src, 0x50u);
  memcpy(v18 + 80, coinbase, coinbase_len);
  if ( merkles > 0 )
  {
    v19 = &v18[coinbase_len + 80];
    v20 = 0;
    v21 = pool->swork.merkle_bin - 1;
    do
    {
      v22 = v21[1];
      ++v21;
      ++v20;
      v23 = *((_DWORD *)v22 + 1);
      v24 = *((_DWORD *)v22 + 2);
      v25 = *((_DWORD *)v22 + 3);
      *(_DWORD *)v19 = *(_DWORD *)v22;
      *((_DWORD *)v19 + 1) = v23;
      *((_DWORD *)v19 + 2) = v24;
      *((_DWORD *)v19 + 3) = v25;
      v26 = *((_DWORD *)v22 + 5);
      v27 = *((_DWORD *)v22 + 6);
      v28 = *((_DWORD *)v22 + 7);
      *((_DWORD *)v19 + 4) = *((_DWORD *)v22 + 4);
      *((_DWORD *)v19 + 5) = v26;
      *((_DWORD *)v19 + 6) = v27;
      *((_DWORD *)v19 + 7) = v28;
      v19 += 32;
    }
    while ( v20 != merkles );
  }
  if ( (unsigned __int16)v15 == 2 )
  {
    v34 = -1;
  }
  else
  {
    v29 = 255;
    v30 = 255;
    v31 = v18;
    do
    {
      v32 = *v31++;
      v33 = &_PRETTY_FUNCTION___14401[v32 ^ v30];
      v30 = v29 ^ v33[1976];
      v29 = v33[2232];
    }
    while ( v31 != &v18[(unsigned __int16)(v14 + 79) + 1] );
    v34 = v30 | ((_WORD)v29 << 8);
  }
  *(_WORD *)&v18[v14 + 80] = v34;
  ++pool_send_nu_14203;
  v35 = (unsigned __int8 *)malloc(v14 + 82);
  *buf = v35;
  memcpy(v35, v18, v15);
  memcpy(last_job_buffer, v18, v15);
  free(v18);
  return v14 + 82;
}
// 388C8: conditional instruction was optimized away because r9.4==0
// 38708: variables would overlap: ^18.80 and stkvar "id" ^24.4(has user info)

//----- (00038968) --------------------------------------------------------
int __fastcall send_job(unsigned __int8 *buf)
{
  int result; // r0
  int v3; // r3
  _BOOL4 v4; // r7
  size_t v5; // r8
  part_of_job *v6; // r9
  size_t coinbase_len; // r11
  size_t v8; // r8
  bool v9; // cc
  unsigned int merkles_num; // r7
  unsigned __int8 *v11; // r0
  unsigned int v12; // r2
  size_t v13; // r3
  size_t v14; // r11
  int v15; // lr
  int v16; // r12
  part_of_job *v17; // r9
  unsigned int v18; // r3
  int i; // r3
  int j; // r10
  int v21; // lr
  int v22; // r12
  unsigned int dhash_acc_control; // r0
  char v24; // r7
  unsigned __int8 *p_token_type; // r3
  unsigned int *p_part_job; // r2
  int v27; // r1
  int v28; // lr
  int v29; // r5
  int v30; // r0
  unsigned int nonce2_start_value; // r2
  unsigned int v32; // r0
  unsigned int v33; // r0
  unsigned int v34; // r0
  unsigned int nonce_fifo_interrupt; // r0
  unsigned __int8 asic_diff; // r10
  unsigned int v37; // r0
  unsigned __int8 *coinbase_padding; // [sp+18h] [bp-8C0h]
  size_t n; // [sp+1Ch] [bp-8BCh]
  unsigned __int8 *merkles_bin; // [sp+20h] [bp-8B8h]
  unsigned int value; // [sp+24h] [bp-8B4h]
  int v42; // [sp+28h] [bp-8B0h]
  part_of_job *part_job; // [sp+2Ch] [bp-8ACh] BYREF
  unsigned int buf2[32]; // [sp+30h] [bp-8A8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+B0h] [bp-828h] BYREF

  memset(buf2, 0, sizeof(buf2));
  result = 0;
  if ( doTestPatten )
    return result;
  if ( *buf != 82 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -1;
    snprintf((char *)tmp42, 0x800u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", (const char *)_FUNCTION___14261, *buf);
    applog(7, tmp42, 0);
    return -1;
  }
  v3 = *((_DWORD *)buf + 1);
  v4 = opt_debug;
  if ( !opt_debug )
  {
    v5 = v3 + 8;
    v6 = (part_of_job *)malloc(v3 + 8);
    if ( v6 )
      goto LABEL_12;
    return -2;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
  {
    v5 = v3 + 8;
    v6 = (part_of_job *)malloc(v3 + 8);
    if ( v6 )
    {
      v4 = 1;
      goto LABEL_12;
    }
LABEL_27:
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      snprintf((char *)tmp42, 0x800u, "%s: malloc buffer failed.\n", (const char *)_FUNCTION___14261);
      applog(7, tmp42, 0);
      return -2;
    }
    return -2;
  }
  v5 = v3 + 8;
  snprintf((char *)tmp42, 0x800u, "%s: len = 0x%x\n", (const char *)_FUNCTION___14261, *((_DWORD *)buf + 1));
  applog(7, tmp42, 0);
  v4 = opt_debug;
  v6 = (part_of_job *)malloc(v5);
  if ( !v6 )
  {
    if ( !v4 )
      return -2;
    goto LABEL_27;
  }
LABEL_12:
  memset(v6, 0, v5);
  memcpy(v6, buf, v5);
  if ( dev->current_job_start_address == job_start_address_1 )
  {
    dev->current_job_start_address = job_start_address_2;
  }
  else
  {
    if ( dev->current_job_start_address != job_start_address_2 )
    {
      if ( !v4 || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return -3;
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: dev->current_job_start_address = 0x%x, but job_start_address_1 = 0x%x, job_start_address_2 = 0x%x\n",
        (const char *)_FUNCTION___14261,
        dev->current_job_start_address,
        job_start_address_1,
        job_start_address_2);
      applog(7, tmp42, 0);
      return -3;
    }
    dev->current_job_start_address = job_start_address_1;
  }
  coinbase_len = v6->coinbase_len;
  v8 = 65472;
  n = coinbase_len;
  v9 = (coinbase_len & 0x3F) > 0x37;
  if ( (coinbase_len & 0x3F) > 0x37 )
    v8 = (coinbase_len & 0xFFC0) + 128;
  else
    coinbase_len = v6->coinbase_len;
  if ( !v9 )
    v8 = (coinbase_len & v8) + 64;
  coinbase_padding = (unsigned __int8 *)malloc(v8);
  if ( !coinbase_padding )
  {
    if ( !v4 || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -4;
    snprintf((char *)tmp42, 0x800u, "%s: malloc coinbase_padding failed.\n", (const char *)_FUNCTION___14261);
    applog(7, tmp42, 0);
    return -4;
  }
  if ( v4 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s: coinbase_padding = 0x%x", (const char *)_FUNCTION___14261, coinbase_padding);
    applog(7, tmp42, 0);
  }
  merkles_num = v6->merkles_num;
  value = merkles_num;
  if ( v6->merkles_num )
  {
    v42 = 32 * merkles_num;
    v11 = (unsigned __int8 *)malloc(32 * merkles_num);
    merkles_bin = v11;
    if ( !v11 )
    {
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return -5;
      snprintf((char *)tmp42, 0x800u, "%s: malloc merkles_bin failed.\n", (const char *)_FUNCTION___14261);
      applog(7, tmp42, 0);
      return -5;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: merkles_bin = 0x%x", (const char *)_FUNCTION___14261, v11);
      applog(7, tmp42, 0);
    }
  }
  else
  {
    merkles_bin = 0;
    v42 = 0;
  }
  memset(coinbase_padding, 0, v8);
  memcpy(coinbase_padding, buf + 80, n);
  v12 = c_coinbase_padding;
  c_coinbase_padding = v8;
  l_coinbase_padding = v12;
  coinbase_padding[n] = 0x80;
  *(_DWORD *)&coinbase_padding[v8 - 4] = (((8 * n) & 0xFF00) << 8) | (((8 * n) & 0xFF0000) >> 8) | (n << 27);
  v13 = 0;
  *(_DWORD *)&coinbase_padding[4 * ((v8 - 8) >> 2)] = 0;
  do
  {
    *((_BYTE *)dev->current_job_start_address + v13) = coinbase_padding[v13];
    ++v13;
  }
  while ( v8 > v13 );
  part_job = v6;
  v14 = 0;
  do
  {
    v15 = coinbase_padding[v14];
    v16 = *((unsigned __int8 *)dev->current_job_start_address + v14);
    if ( v16 != v15 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
        _FUNCTION___14261,
        v14,
        v16,
        v14,
        v15);
      applog(7, tmp42, 0);
    }
    ++v14;
  }
  while ( v8 > v14 );
  v17 = part_job;
  v18 = c_merkles_num;
  c_merkles_num = merkles_num;
  l_merkles_num = v18;
  if ( merkles_num )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s: copy merkle bin into memory ...\n", (const char *)_FUNCTION___14261);
      applog(7, tmp42, 0);
    }
    memset(merkles_bin, 0, v42);
    memcpy(merkles_bin, &buf[n + 80], v42);
    if ( v42 )
    {
      for ( i = 0; i != v42; ++i )
        *((_BYTE *)dev->current_job_start_address + v8 + i) = merkles_bin[i];
      for ( j = 0; j != v42; ++j )
      {
        v21 = merkles_bin[j];
        v22 = *((unsigned __int8 *)dev->current_job_start_address + v8 + j);
        if ( v22 != v21 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "%s: merkles_in_ddr[%d] = 0x%x, but *(merkles_bin + %d) =0x%x",
            _FUNCTION___14261,
            j,
            v22,
            j,
            v21);
          applog(7, tmp42, 0);
        }
      }
    }
  }
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  while ( (get_dhash_acc_control() & 0x40) != 0 )
  {
    while ( 1 )
    {
      cgsleep_ms(1);
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        break;
      snprintf((char *)tmp42, 0x800u, "%s: run bit is 1 after set it to 0\n", _FUNCTION___14261);
      applog(7, tmp42, 0);
      if ( (get_dhash_acc_control() & 0x40) == 0 )
        goto LABEL_86;
    }
  }
LABEL_86:
  cgsleep_ms(1);
  if ( dev->current_job_start_address == job_start_address_1 )
  {
    set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  }
  else if ( dev->current_job_start_address == job_start_address_2 )
  {
    set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2162688);
  }
  v24 = *((_BYTE *)v17 + 9);
  if ( (v24 & 2) != 0 )
  {
    asic_diff = v17->asic_diff;
    set_ticket_mask(asic_diff);
    dev->diff = asic_diff;
  }
  set_job_id(v17->job_id);
  set_block_header_version(v17->bbversion);
  memset(buf2, 0, sizeof(buf2));
  p_token_type = &v17->token_type;
  p_part_job = (unsigned int *)&part_job;
  do
  {
    v27 = p_token_type[22];
    v28 = p_token_type[23];
    v29 = p_token_type[20];
    v30 = p_token_type[21];
    p_token_type += 4;
    p_part_job[1] = (v27 << 16) | (v28 << 24) | v29 | (v30 << 8);
    ++p_part_job;
  }
  while ( p_part_job != &buf2[7] );
  set_pre_header_hash(buf2);
  set_time_stamp(v17->ntime);
  set_target_bits(v17->nbit);
  set_coinbase_length_and_nonce2_length((v17->nonce2_offset << 16) | (LOBYTE(v17->nonce2_bytes_num) << 8) | (unsigned __int8)(v8 >> 6));
  nonce2_start_value = v17->nonce2_start_value;
  buf2[1] = HIDWORD(v17->nonce2_start_value);
  buf2[0] = nonce2_start_value;
  set_work_nonce2(buf2);
  set_merkle_bin_number(value);
  set_job_length((unsigned __int16)(v8 + v42));
  cgsleep_ms(1);
  if ( !gBegin_get_nonce_0 )
  {
    nonce_fifo_interrupt = get_nonce_fifo_interrupt();
    set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
    gBegin_get_nonce_0 = 1;
  }
  if ( (v24 & 1) == 0 )
  {
    if ( !opt_multi_version )
      goto LABEL_98;
LABEL_109:
    v34 = get_dhash_acc_control();
    set_dhash_acc_control(v34 & 0xFFFFF0FF | ((opt_multi_version & 0xF) << 8) | 0x8060);
    goto LABEL_99;
  }
  if ( opt_multi_version )
  {
    v37 = get_dhash_acc_control();
    set_dhash_acc_control(v37 | 0x80);
    goto LABEL_109;
  }
  v32 = get_dhash_acc_control();
  set_dhash_acc_control(v32 | 0x80);
LABEL_98:
  v33 = get_dhash_acc_control();
  set_dhash_acc_control(v33 & 0xFFFFF0FF | ((opt_multi_version & 0xF) << 8) | 0x60);
LABEL_99:
  free(v17);
  free(coinbase_padding);
  if ( v17->merkles_num )
    free(merkles_bin);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "--- %s end\n", (const char *)_FUNCTION___14261);
    applog(7, tmp42, 0);
  }
  cgtime(&tv_send_job);
  return 0;
}

//----- (00039104) --------------------------------------------------------
void __fastcall bitmain_c5_update(cgpu_info *bitmain_c5)
{
  char *device_data; // r4
  thr_info *v2; // r5
  const unsigned __int8 *v3; // r2
  int v4; // r3
  int id; // r1
  pool *v6; // r5
  const unsigned __int8 *v7; // r2
  int v8; // r3
  const unsigned __int8 *v9; // r2
  int v10; // r3
  const unsigned __int8 *v11; // r2
  int v12; // r3
  unsigned int v13; // r3
  const unsigned __int8 *v14; // r2
  int v15; // r3
  const unsigned __int8 *v16; // r2
  int v17; // r3
  const unsigned __int8 *v18; // r2
  int v19; // r3
  const unsigned __int8 *v20; // r2
  int v21; // r3
  int *v22; // r0
  int *v23; // r0
  work *work; // [sp+10h] [bp-830h] BYREF
  unsigned __int8 *buf; // [sp+14h] [bp-82Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-828h] BYREF

  device_data = (char *)bitmain_c5->device_data;
  v2 = *bitmain_c5->thr;
  if ( pthread_mutex_lock((pthread_mutex_t *)(device_data + 420)) )
    mutex_lock_3((pthread_mutex_t *)&_func___14527, (const unsigned __int8 *)0x2F07, v3, v4);
  id = v2->id;
  v2->work_update = 0;
  v2->work_restart = 0;
  buf = 0;
  work = get_work(v2, id);
  discard_work(&work, "driver-btm-c5.c", (const unsigned __int8 *)&_func___14527, 12047);
  v6 = current_pool();
  if ( !v6->has_stratum )
  {
    strcpy((char *)tmp42, "Bitmain S9 has to use stratum pools");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)device_data) )
    mutex_lock_3((pthread_mutex_t *)&_func___14527, (const unsigned __int8 *)0x2F16, v7, v8);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(device_data + 24)) )
  {
    v23 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v23,
      "driver-btm-c5.c",
      (const char *)&_func___14527,
      12054);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_lock(&v6->data_lock.mutex) )
    mutex_lock_3((pthread_mutex_t *)&_func___14527, (const unsigned __int8 *)0x2F17, v9, v10);
  if ( pthread_rwlock_rdlock(&v6->data_lock.rwlock) )
  {
    v22 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v22,
      "driver-btm-c5.c",
      (const char *)&_func___14527,
      12055);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(&v6->data_lock.mutex) )
    mutex_unlock_noyield_3((pthread_mutex_t *)&_func___14527, (const unsigned __int8 *)0x2F17, v11, v12);
  *((_DWORD *)device_data + 119) = v6->pool_no;
  copy_pool_stratum((pool *)(device_data + 4176), (pool *)(device_data + 2328));
  *((_DWORD *)device_data + 1508) = *((_DWORD *)device_data + 1507);
  copy_pool_stratum((pool *)(device_data + 2328), (pool *)(device_data + 480));
  *((_DWORD *)device_data + 1507) = *((_DWORD *)device_data + 1506);
  copy_pool_stratum((pool *)(device_data + 480), v6);
  v13 = given_id + 1;
  *((_DWORD *)device_data + 1506) = given_id + 1;
  given_id = v13;
  parse_job_to_c5(&buf, v6, v13);
  if ( !status_error )
  {
    pthread_mutex_lock(&reinit_mutex);
    send_job(buf);
    pthread_mutex_unlock(&reinit_mutex);
  }
  if ( pthread_rwlock_unlock(&v6->data_lock.rwlock) )
    rw_unlock_2((pthread_rwlock_t *)&_func___14527, (const unsigned __int8 *)0x2F29, v14, v15);
  selective_yield();
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(device_data + 24)) )
    rw_unlock_2((pthread_rwlock_t *)&_func___14527, (const unsigned __int8 *)0x2F2A, v16, v17);
  if ( pthread_mutex_unlock((pthread_mutex_t *)device_data) )
    mutex_unlock_noyield_3((pthread_mutex_t *)&_func___14527, (const unsigned __int8 *)0x2F2A, v18, v19);
  selective_yield();
  free(buf);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(device_data + 420)) )
    mutex_unlock_noyield_3((pthread_mutex_t *)&_func___14527, (const unsigned __int8 *)0x2F2C, v20, v21);
  selective_yield();
}
// 392A8: variable 'v9' is possibly undefined
// 392A8: variable 'v10' is possibly undefined
// 392B4: variable 'v11' is possibly undefined
// 392B4: variable 'v12' is possibly undefined
// 392C0: variable 'v3' is possibly undefined
// 392C0: variable 'v4' is possibly undefined
// 39300: variable 'v7' is possibly undefined
// 39300: variable 'v8' is possibly undefined
// 3930C: variable 'v20' is possibly undefined
// 3930C: variable 'v21' is possibly undefined
// 39318: variable 'v18' is possibly undefined
// 39318: variable 'v19' is possibly undefined
// 39324: variable 'v16' is possibly undefined
// 39324: variable 'v17' is possibly undefined
// 39330: variable 'v14' is possibly undefined
// 39330: variable 'v15' is possibly undefined

//----- (0003935C) --------------------------------------------------------
void re_send_last_job()
{
  if ( last_job_buffer[0] != 23 )
  {
    pthread_mutex_lock(&reinit_mutex);
    send_job(last_job_buffer);
    j_pthread_mutex_unlock(&reinit_mutex);
  }
}

//----- (0003938C) --------------------------------------------------------
void bitmain_core_reInit()
{
  unsigned int dhash_acc_control; // r0
  unsigned int v1; // r0
  unsigned int nonce_fifo_interrupt; // r0
  unsigned __int8 logstr[256]; // [sp+0h] [bp-128h] BYREF

  doTestPatten = 1;
  pthread_mutex_lock(&reinit_mutex);
  startCheckNetworkJob = 0;
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  sleep(3u);
  v1 = get_dhash_acc_control();
  set_dhash_acc_control(v1 & 0xFFFFFFBF);
  sleep(2u);
  open_core(1);
  strcpy((char *)logstr, "bitmain_core_reInit open_core over\n");
  writeInitLogFile(logstr);
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  set_asic_ticket_mask(0x3Fu);
  set_hcnt(0);
  cgsleep_ms(10);
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  doTestPatten = 0;
  pthread_mutex_unlock(&reinit_mutex);
  re_send_last_job();
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  startCheckNetworkJob = 1;
}

//----- (00039464) --------------------------------------------------------
void doReInitTest()
{
  int v0; // r4
  unsigned int dhash_acc_control; // r0
  unsigned int v2; // r0
  all_parameters *v3; // r5
  unsigned int v4; // r3
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r1
  unsigned int nonce_fifo_interrupt; // r0

  v0 = 0;
  startCheckNetworkJob = 0;
  doTestPatten = 1;
  pthread_mutex_lock(&reinit_mutex);
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  sleep(3u);
  v2 = get_dhash_acc_control();
  set_dhash_acc_control(v2 & 0xFFFFFFBF);
  sleep(2u);
  v3 = dev;
  do
  {
    while ( 1 )
    {
      v4 = v3->chain_exist[0];
      v3 = (all_parameters *)((char *)v3 + 4);
      if ( v4 == 1 )
        break;
      if ( ++v0 == 16 )
        goto LABEL_5;
    }
    v5 = chain_pic_buf[v0];
    v6 = show_last_freq[v0++];
    memcpy(v5, v6, 0x80u);
  }
  while ( v0 != 16 );
LABEL_5:
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  doTestPatten = 0;
  bitmain_reinit_test();
  doTestPatten = 1;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  set_asic_ticket_mask(0x3Fu);
  cgsleep_ms(10);
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  clear_nonce_fifo();
  if ( opt_multi_version )
    set_time_out_control((dev->timeout * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
  doTestPatten = 0;
  pthread_mutex_unlock(&reinit_mutex);
  re_send_last_job();
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  startCheckNetworkJob = 1;
}

//----- (000395B0) --------------------------------------------------------
void do8xPattenTest()
{
  int v0; // r4
  unsigned int dhash_acc_control; // r0
  unsigned int v2; // r0
  all_parameters *v3; // r5
  unsigned int v4; // r3
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r1
  int v7; // r4
  all_parameters *v8; // r5
  unsigned int v9; // r3
  unsigned __int8 *v10; // r0
  unsigned __int8 *v11; // r1
  unsigned int nonce_fifo_interrupt; // r0

  v0 = 0;
  startCheckNetworkJob = 0;
  doTestPatten = 1;
  pthread_mutex_lock(&reinit_mutex);
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  sleep(3u);
  v2 = get_dhash_acc_control();
  set_dhash_acc_control(v2 & 0xFFFFFFBF);
  sleep(2u);
  v3 = dev;
  do
  {
    while ( 1 )
    {
      v4 = v3->chain_exist[0];
      v3 = (all_parameters *)((char *)v3 + 4);
      if ( v4 == 1 )
        break;
      if ( ++v0 == 16 )
        goto LABEL_5;
    }
    v5 = chain_pic_buf[v0];
    v6 = chip_last_freq[v0++];
    memcpy(v5, v6, 0x80u);
  }
  while ( v0 != 16 );
LABEL_5:
  set_asic_ticket_mask(0);
  clement_doTestBoardOnce(1);
  v7 = 0;
  v8 = dev;
  do
  {
    while ( 1 )
    {
      v9 = v8->chain_exist[0];
      v8 = (all_parameters *)((char *)v8 + 4);
      if ( v9 == 1 )
        break;
      if ( ++v7 == 16 )
        goto LABEL_9;
    }
    v10 = chain_pic_buf[v7];
    v11 = show_last_freq[v7++];
    memcpy(v10, v11, 0x80u);
  }
  while ( v7 != 16 );
LABEL_9:
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  set_asic_ticket_mask(0x3Fu);
  cgsleep_ms(10);
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  clear_nonce_fifo();
  if ( opt_multi_version )
    set_time_out_control((dev->timeout * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
  doTestPatten = 0;
  pthread_mutex_unlock(&reinit_mutex);
  re_send_last_job();
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  startCheckNetworkJob = 1;
}

//----- (00039710) --------------------------------------------------------
void processTEST()
{
  FILE *TestID; // r0
  FILE *v1; // r4
  int v2; // r5
  FILE *v3; // r2
  unsigned __int8 v4; // r4
  double v5; // d7
  int v6; // r7
  int v7; // r8
  double v8; // d7
  int v9; // r5
  int v10; // r4
  int v11; // r10
  int v12; // r2
  double v13; // d7
  int v14; // r4
  int v15; // r8
  double v16; // d7
  unsigned __int8 logstr[256]; // [sp+8h] [bp-120h] BYREF

  TestID = readTestID();
  v1 = TestID;
  if ( TestID == (FILE *)11 )
  {
    saveTestID(0);
    sprintf((char *)logstr, "get TEST ID=%d do 8xPatten test\n", 11);
    writeInitLogFile(logstr);
    do8xPattenTest();
    return;
  }
  if ( TestID == (FILE *)12 )
  {
    saveTestID(0);
    sprintf((char *)logstr, "get TEST ID=%d do bitmain_core_reInit test\n", v1);
    writeInitLogFile(logstr);
    bitmain_core_reInit();
    reCalculateAVG();
    strcpy((char *)logstr, "Done bitmain_core_reInit test\n");
    writeInitLogFile(logstr);
    return;
  }
  if ( TestID == (FILE *)13 )
  {
    saveTestID(0);
    sprintf((char *)logstr, "get TEST ID=%d do doReInitTest test\n", v1);
    writeInitLogFile(logstr);
    doReInitTest();
    reCalculateAVG();
    strcpy((char *)logstr, "Done doReInitTest test\n");
    writeInitLogFile(logstr);
    return;
  }
  if ( TestID == (FILE *)14 )
  {
    v9 = 1;
    saveTestID(0);
    sprintf((char *)logstr, "get TEST ID=%d do do get asicnum\n", v1);
    writeInitLogFile(logstr);
    do
    {
      while ( 1 )
      {
        v10 = v9 + 1;
        v11 = v9 - 1;
        if ( *(&dev->pwm_value + v9) == 1 )
          break;
        ++v9;
        if ( v10 == 17 )
          goto LABEL_19;
      }
      dev->chain_asic_num[v11] = 0;
      check_asic_reg_oneChain(v9 - 1, 0);
      v12 = v9++;
      sprintf((char *)logstr, "Chain[J%d] has %d asic\n", v12, dev->chain_asic_num[v11]);
      writeInitLogFile(logstr);
    }
    while ( v10 != 17 );
LABEL_19:
    strcpy((char *)logstr, "Done do get asicnum\n");
    writeInitLogFile(logstr);
  }
  else
  {
    if ( (unsigned int)&TestID[-1]._markers + 3 > 0xF )
    {
      if ( (unsigned int)&TestID[-2].__pad4 + 3 > 0xF )
        return;
      saveTestID(0);
      v3 = v1;
      v2 = (int)v1 % 100;
      v4 = (int)v1 % 100 - 1;
      sprintf((char *)logstr, "get TEST ID=%d down voltage 0.1V on Chain[J%d]\n", v3, v2);
      writeInitLogFile(logstr);
      if ( *(&dev->pwm_value + v2) == 1 )
      {
        v5 = (364.0704 / ((double)get_pic_voltage(v4) + 30.72) + 32.79) * 100.0 / 4.75;
        v6 = 10 * ((int)v5 / 10);
        if ( v6 <= 869 )
        {
          sprintf((char *)logstr, "Chain[J%d] current vol=%d , too low! will set to 860\n", v2, 10 * ((int)v5 / 10));
          v7 = 860;
          writeInitLogFile(logstr);
        }
        else
        {
          v7 = v6 - 10;
        }
        sprintf((char *)logstr, "Try to down 0.1V on chain[J%d] from vol=%d to %d...\n", v2, v6, v7);
        writeInitLogFile(logstr);
        v8 = 364.0704 / ((double)v7 * 4.75 / 100.0 - 32.79) - 30.72;
        sprintf((char *)logstr, "now set pic voltage=%d on chain[J%d]\n", (unsigned __int8)(unsigned int)v8, v2);
        writeInitLogFile(logstr);
        set_pic_voltage(v4, (unsigned int)v8);
        return;
      }
LABEL_9:
      sprintf((char *)logstr, "There is hashboard on Chain[J%d]\n", v2);
      writeInitLogFile(logstr);
      return;
    }
    saveTestID(0);
    v2 = (int)v1 % 100;
    sprintf((char *)logstr, "get TEST ID=%d up voltage 0.1V on Chain[J%d]\n", v1, (int)v1 % 100);
    writeInitLogFile(logstr);
    if ( *(&dev->pwm_value + (int)v1 % 100) != 1 )
      goto LABEL_9;
    v13 = (364.0704 / ((double)get_pic_voltage(v2 - 1) + 30.72) + 32.79) * 100.0 / 4.75;
    v14 = 10 * ((int)v13 / 10);
    if ( v14 > 930 )
    {
      sprintf((char *)logstr, "Chain[J%d] current vol=%d , too high! will set to 940\n", v2, 10 * ((int)v13 / 10));
      v15 = 940;
      writeInitLogFile(logstr);
    }
    else
    {
      v15 = v14 + 10;
    }
    sprintf((char *)logstr, "Try to up 0.1V on chain[J%d] from vol=%d to %d...\n", v2, v14, v15);
    writeInitLogFile(logstr);
    v16 = 364.0704 / ((double)v15 * 4.75 / 100.0 - 32.79) - 30.72;
    sprintf((char *)logstr, "now set pic voltage=%d on chain[J%d]\n", (unsigned __int8)(unsigned int)v16, v2);
    writeInitLogFile(logstr);
    set_pic_voltage(v2 - 1, (unsigned int)v16);
  }
}

//----- (00039B68) --------------------------------------------------------
void __noreturn read_temp_func()
{
  int8_t *v0; // r9
  all_parameters *v1; // r6
  signed int v2; // r5
  all_parameters *v3; // r3
  int v4; // r4
  signed int v5; // r6
  int16_t v6; // r0
  char *v7; // r3
  unsigned int v8; // r0
  all_parameters *v9; // r7
  int16_t remote; // r0
  int v11; // r3
  char *v12; // r7
  char *v13; // r3
  unsigned int v14; // lr
  int v15; // r1
  int v16; // r2
  bool v17; // cc
  unsigned int v18; // r7
  int v19; // r2
  int v20; // r1
  int v21; // r12
  int v22; // r0
  char *v23; // r2
  int v24; // r1
  int v25; // r12
  int v26; // r2
  int v27; // r12
  int v28; // r12
  int v29; // r12
  int v30; // r12
  unsigned int v31; // r0
  __int16 v32; // r2
  int16_t v33; // r1
  __int16 v34; // r4
  __int16 v35; // r7
  __int16 v36; // lr
  __int16 v37; // r11
  _BOOL4 v38; // r12
  _WORD *v39; // r7
  int v40; // r7
  int16_t v41; // r0
  int16_t v42; // r3
  int v43; // r5
  int v44; // lr
  signed int v45; // r1
  all_parameters *v46; // r0
  all_parameters *v47; // r7
  all_parameters *v48; // r4
  int v49; // r3
  int v50; // r9
  int v51; // r2
  int16_t *v52; // r9
  all_parameters *v53; // r3
  int16_t v54; // r12
  int v55; // r8
  int v56; // r9
  int v57; // r11
  int16_t *v58; // r3
  int16_t *v59; // r8
  int16_t *v60; // r2
  int16_t v61; // r12
  _WORD *v62; // r11
  int fan_num; // r4
  all_parameters *v64; // r3
  int v65; // r3
  unsigned int dhash_acc_control; // r0
  const char *v67; // r5
  int v68; // r0
  int v69; // r1
  int v70; // r2
  int v71; // r3
  int *v72; // r5
  int v73; // r0
  int v74; // r1
  int v75; // r2
  int v76; // r3
  int v77; // r1
  int v78; // r9
  all_parameters *v79; // r3
  int v80; // r2
  int16_t *v81; // r9
  int16_t v82; // r12
  int v83; // r9
  int v84; // r2
  int16_t *v85; // r9
  all_parameters *v86; // r3
  int16_t v87; // r12
  int v88; // r2
  int v89; // r4
  int maxtemp; // [sp+18h] [bp-160h]
  int maxtempa; // [sp+18h] [bp-160h]
  int maxtemp_4; // [sp+1Ch] [bp-15Ch]
  int maxtemp_8; // [sp+20h] [bp-158h]
  int16_t (*maxtemp_8a)[8][4]; // [sp+20h] [bp-158h]
  int maxtemp_12; // [sp+24h] [bp-154h]
  int v96; // [sp+28h] [bp-150h]
  int v97; // [sp+2Ch] [bp-14Ch]
  int v98; // [sp+30h] [bp-148h]
  int fatal_error_counter; // [sp+38h] [bp-140h]
  int already_offside; // [sp+3Ch] [bp-13Ch]
  int temp_top; // [sp+40h] [bp-138h]
  __int16 temp_top_4; // [sp+44h] [bp-134h]
  int temp_low; // [sp+48h] [bp-130h]
  __int16 temp_low_4; // [sp+4Ch] [bp-12Ch]
  unsigned __int8 logstr[256]; // [sp+50h] [bp-128h] BYREF

  fatal_error_counter = 0;
  already_offside = 0;
  clearTempLogFile();
  while ( 1 )
  {
    clearTempLogFile();
    strcpy((char *)logstr, "do read_temp_func once...\n");
    writeLogFile_0(logstr);
    pthread_mutex_lock(&opencore_readtemp_mutex);
    strcpy((char *)logstr, "do check_asic_reg 0x08\n");
    writeLogFile_0(logstr);
    if ( doTestPatten )
    {
      usleep(0x186A0u);
    }
    else if ( check_asic_reg(8u) )
    {
      showAllBadRTInfo();
    }
    else
    {
      strcpy((char *)logstr, "Error: check_asic_reg 0x08 timeout\n");
      writeInitLogFile(logstr);
    }
    v0 = middle_Offset;
    strcpy((char *)logstr, "Done check_asic_reg\n");
    writeLogFile_0(logstr);
    v1 = dev;
    maxtemp_8 = 0;
    v2 = 0;
    temp_top = 0;
    temp_top_4 = 0;
    temp_low = 0;
    temp_low_4 = 0;
    do
    {
      if ( v1->chain_exist[v2] != 1 )
        goto LABEL_5;
      if ( fpga_version <= 13 )
      {
        if ( v2 % 3 != 1 )
          goto LABEL_5;
      }
      else if ( (v2 & 0xFFFFFFFD) != 8 && v2 != 12 )
      {
        goto LABEL_5;
      }
      sprintf((char *)logstr, "do read temp on Chain[%d]\n", v2);
      writeLogFile_0(logstr);
      v3 = dev;
      if ( dev->chain_asic_temp_num[v2] <= 0 )
      {
        v37 = 1000;
        v32 = 0;
        v5 = v2;
        v36 = 1000;
        v35 = 1000;
        v34 = 0;
        v33 = 0;
      }
      else
      {
        v4 = 0;
        maxtemp = 0;
        v5 = v2;
        maxtemp_4 = 1000;
        v98 = 0;
        maxtemp_12 = 0;
        v97 = 1000;
        v96 = 1000;
        do
        {
          sprintf(
            (char *)logstr,
            "Chain[%d] Chip[%d] TempTypeID=%02x middle offset=%d\n",
            v2,
            (v3->TempChipAddr[v5][v4] >> 2) + 1,
            v3->TempChipType[v5][v4],
            v0[v4]);
          writeLogFile_0(logstr);
          v31 = check_reg_temp(0x98u, 0, 0, 0, dev->TempChipAddr[v5][v4], v2);
          if ( v31 )
          {
            v6 = (unsigned __int8)v31 - 64;
            v7 = (char *)dev + v5 * 8 + v4;
            dev->chain_asic_temp[v5][v4][0] = v6;
            sprintf((char *)logstr, "Chain[%d] Chip[%d] local Temp=%d\n", v2, ((unsigned __int8)v7[1256] >> 2) + 1, v6);
          }
          else
          {
            sprintf(
              (char *)logstr,
              "read failed, old value: Chain[%d] Chip[%d] local Temp=%d\n",
              v2,
              (dev->TempChipAddr[v5][v4] >> 2) + 1,
              dev->chain_asic_temp[v5][v4][0]);
          }
          writeLogFile_0(logstr);
          set_baud_with_addr(dev->baud, 0, dev->TempChipAddr[v5][v4], v2, 1, 0, 1);
          check_asic_reg_with_addr(0x1Cu, dev->TempChipAddr[v5][v4], v2, 1);
          v8 = check_reg_temp(0x98u, 1u, 0, 0, dev->TempChipAddr[v5][v4], v2);
          if ( v8 )
          {
            v9 = dev;
            remote = get_remote((unsigned __int8)v8);
            v11 = 8 * (v5 * 8 + v4);
            v12 = (char *)v9 + v11;
            v13 = (char *)dev + v11;
            v14 = dev->TempChipAddr[v5][v4];
            *((_WORD *)v12 + 693) = remote;
            sprintf((char *)logstr, "Chain[%d] Chip[%d] middle Temp=%d\n", v2, (v14 >> 2) + 1, *((__int16 *)v13 + 693));
          }
          else
          {
            sprintf(
              (char *)logstr,
              "read failed on Chain[%d] Chip[%d] middle Temp old value:%d\n",
              v2,
              (dev->TempChipAddr[v5][v4] >> 2) + 1,
              dev->chain_asic_temp[v5][v4][1]);
          }
          writeLogFile_0(logstr);
          if ( is218_Temp )
          {
            v16 = dev->chain_asic_temp[v5][v4][0];
            if ( v16 <= 0 )
            {
              v15 = 0;
              LOWORD(v16) = 0;
            }
            else if ( v16 > 50 )
            {
              v17 = v16 <= 60;
              if ( v16 <= 60 )
                v15 = v16 + 30;
              else
                LOWORD(v16) = v16 + 35;
              if ( v17 )
                LOWORD(v16) = v15;
              if ( !v17 )
                v15 = (__int16)v16;
            }
            else
            {
              v15 = v16 + 25;
              LOWORD(v16) = v16 + 25;
            }
            v18 = dev->TempChipAddr[v5][v4];
            dev->chain_asic_temp[v5][v4][1] = v16;
            sprintf((char *)logstr, "218 fix Chain[%d] Chip[%d] middle Temp = %d\n", v2, (v18 >> 2) + 1, v15);
            writeLogFile_0(logstr);
          }
          v3 = dev;
          v19 = v5 * 8 + v4;
          v20 = v5 * 8 + v4 + 173;
          v21 = maxtemp;
          ++v4;
          v22 = *((__int16 *)&dev->current_job_start_address + 4 * v20);
          v23 = (char *)dev + 8 * v19;
          if ( maxtemp < v22 )
            v21 = *((__int16 *)&dev->current_job_start_address + 4 * v20);
          v24 = *((__int16 *)v23 + 693);
          maxtemp = v21;
          v25 = maxtemp_4;
          v26 = *((__int16 *)v23 + 694);
          if ( maxtemp_4 >= v22 )
            v25 = v22;
          maxtemp_4 = v25;
          v27 = v98;
          if ( v98 < v24 )
            v27 = v24;
          v98 = v27;
          v28 = v97;
          if ( v97 >= v24 )
            v28 = v24;
          v97 = v28;
          v29 = maxtemp_12;
          if ( maxtemp_12 < v26 )
            v29 = v26;
          maxtemp_12 = v29;
          v30 = v96;
          if ( v96 >= v26 )
            v30 = v26;
          v96 = v30;
        }
        while ( dev->chain_asic_temp_num[v2] > v4 );
        v32 = maxtemp_12;
        v33 = maxtemp;
        v34 = v98;
        v35 = maxtemp_4;
        v36 = v97;
        v37 = v30;
      }
      v38 = check_temp_offside;
      v3->chain_asic_maxtemp[v2][0] = v33;
      v3->chain_asic_mintemp[v2][0] = v35;
      v39 = (_WORD *)((char *)v3 + v5 * 8);
      v39[1205] = v34;
      v39[1206] = v32;
      v39[1269] = v36;
      v39[1270] = v37;
      if ( v38 )
      {
        v40 = (unsigned __int16)v39[1205];
        if ( (unsigned int)(v40 - 75) > 0x32 )
        {
          if ( !already_offside )
          {
            already_offside = 1;
            ++temp_offside[maxtemp_8];
          }
        }
        else
        {
          already_offside = 0;
        }
      }
      else
      {
        LOWORD(v40) = v34;
      }
      if ( (__int16)temp_top < v3->chain_asic_maxtemp[v2][0] )
        LOWORD(temp_top) = v3->chain_asic_maxtemp[v2][0];
      if ( SHIWORD(temp_top) < (__int16)v40 )
        HIWORD(temp_top) = v40;
      v41 = v3->chain_asic_mintemp[v2][0];
      if ( temp_top_4 < v32 )
        temp_top_4 = v32;
      if ( v41 < (__int16)temp_low && v41 > 0 && !chain_temp_toolow[maxtemp_8] || !(_WORD)temp_low )
        LOWORD(temp_low) = v3->chain_asic_mintemp[v2][0];
      v42 = v3->chain_asic_mintemp[v5][1];
      if ( v42 < SHIWORD(temp_low) && v42 > 0 && !chain_temp_toolow[maxtemp_8] || !HIWORD(temp_low) )
        HIWORD(temp_low) = v42;
      if ( temp_low_4 > v37 && v37 > 0 && !chain_temp_toolow[maxtemp_8] || !temp_low_4 )
        temp_low_4 = v37;
      sprintf((char *)logstr, "Done read temp on Chain[%d]\n", v2);
      writeLogFile_0(logstr);
      v1 = dev;
LABEL_5:
      ++v2;
      v0 += 8;
      ++maxtemp_8;
    }
    while ( v2 != 16 );
    v43 = 0;
    v1->temp_top1[0] = (__int16)temp_top;
    v44 = 0;
    v45 = 0;
    v46 = v1;
    maxtemp_8a = v1->chain_asic_temp;
    v47 = v1;
    v1->temp_top1[1] = SHIWORD(temp_top);
    v48 = v1;
    v1->temp_top1[2] = temp_top_4;
    v1->temp_low1[0] = (__int16)temp_low;
    v1->temp_low1[1] = SHIWORD(temp_low);
    v1->temp_low1[2] = temp_low_4;
    maxtempa = fpga_version;
    do
    {
      if ( v48->chain_exist[0] == 1 )
      {
        if ( maxtempa <= 13 )
        {
          if ( v45 % 3 != 1 )
          {
            v55 = v47->chain_asic_temp_num[0];
            v56 = 3 * (v45 / 3) + 1;
            if ( v55 > 0 )
            {
              v57 = 8 * v56;
              v58 = v1->chain_asic_temp[v56][0];
              v59 = maxtemp_8a[v56][v55];
              v60 = &v1->chain_asic_temp[v45][0][1];
              do
              {
                *(v60 - 1) = *v58;
                *v60 = v58[1];
                v61 = v58[2];
                v58 += 4;
                v60[1] = v61;
                v60 += 4;
              }
              while ( v58 != v59 );
            }
            else
            {
              v57 = 8 * v56;
            }
            v62 = (_WORD *)((char *)v1 + v57);
            v46->chain_asic_maxtemp[0][0] = v1->chain_asic_maxtemp[3 * (v45 / 3) + 1][0];
            v46->chain_asic_maxtemp[0][1] = v62[1205];
            v46->chain_asic_maxtemp[0][2] = v62[1206];
            v46->chain_asic_mintemp[0][0] = v1->chain_asic_mintemp[3 * (v45 / 3) + 1][0];
            v46->chain_asic_mintemp[0][1] = v62[1269];
            v46->chain_asic_mintemp[0][2] = v62[1270];
          }
        }
        else if ( (unsigned int)v45 <= 0xD )
        {
          v49 = 1 << v45;
          if ( ((1 << v45) & 0x2008) != 0 )
          {
            v83 = v47->chain_asic_temp_num[0];
            if ( v83 > 0 )
            {
              v84 = (int)v1->chain_asic_temp[v45];
              v85 = &(*maxtemp_8a)[v83][4 * v44];
              v86 = v1;
              do
              {
                v86->chain_asic_temp[v43][0][0] = v86->chain_asic_temp[12][0][0];
                *(_WORD *)(v84 + 2) = v86->chain_asic_temp[12][0][1];
                v87 = v86->chain_asic_temp[12][0][2];
                v86 = (all_parameters *)((char *)v86 + 8);
                *(_WORD *)(v84 + 4) = v87;
                v84 += 8;
              }
              while ( (int16_t *)v84 != v85 );
            }
            v46->chain_asic_maxtemp[0][0] = v1->chain_asic_maxtemp[12][0];
            v46->chain_asic_maxtemp[0][1] = v1->chain_asic_maxtemp[12][1];
            v46->chain_asic_maxtemp[0][2] = v1->chain_asic_maxtemp[12][2];
            v46->chain_asic_mintemp[0][0] = v1->chain_asic_mintemp[12][0];
            v46->chain_asic_mintemp[0][1] = v1->chain_asic_mintemp[12][1];
            v46->chain_asic_mintemp[0][2] = v1->chain_asic_mintemp[12][2];
          }
          else if ( (v49 & 0x804) != 0 )
          {
            v78 = v47->chain_asic_temp_num[0];
            if ( v78 > 0 )
            {
              v79 = v1;
              v80 = (int)v1->chain_asic_temp[v45];
              v81 = &(*maxtemp_8a)[v78][4 * v44];
              do
              {
                v79->chain_asic_temp[v43][0][0] = v79->chain_asic_temp[10][0][0];
                *(_WORD *)(v80 + 2) = v79->chain_asic_temp[10][0][1];
                v82 = v79->chain_asic_temp[10][0][2];
                v79 = (all_parameters *)((char *)v79 + 8);
                *(_WORD *)(v80 + 4) = v82;
                v80 += 8;
              }
              while ( (int16_t *)v80 != v81 );
            }
            v46->chain_asic_maxtemp[0][0] = v1->chain_asic_maxtemp[10][0];
            v46->chain_asic_maxtemp[0][1] = v1->chain_asic_maxtemp[10][1];
            v46->chain_asic_maxtemp[0][2] = v1->chain_asic_maxtemp[10][2];
            v46->chain_asic_mintemp[0][0] = v1->chain_asic_mintemp[10][0];
            v46->chain_asic_mintemp[0][1] = v1->chain_asic_mintemp[10][1];
            v46->chain_asic_mintemp[0][2] = v1->chain_asic_mintemp[10][2];
          }
          else if ( (v49 & 0x202) != 0 )
          {
            v50 = v47->chain_asic_temp_num[0];
            if ( v50 > 0 )
            {
              v51 = (int)v1->chain_asic_temp[v45];
              v52 = &(*maxtemp_8a)[v50][4 * v44];
              v53 = v1;
              do
              {
                v53->chain_asic_temp[v43][0][0] = v53->chain_asic_temp[8][0][0];
                *(_WORD *)(v51 + 2) = v53->chain_asic_temp[8][0][1];
                v54 = v53->chain_asic_temp[8][0][2];
                v53 = (all_parameters *)((char *)v53 + 8);
                *(_WORD *)(v51 + 4) = v54;
                v51 += 8;
              }
              while ( (int16_t *)v51 != v52 );
            }
            v46->chain_asic_maxtemp[0][0] = v1->chain_asic_maxtemp[8][0];
            v46->chain_asic_maxtemp[0][1] = v1->chain_asic_maxtemp[8][1];
            v46->chain_asic_maxtemp[0][2] = v1->chain_asic_maxtemp[8][2];
            v46->chain_asic_mintemp[0][0] = v1->chain_asic_mintemp[8][0];
            v46->chain_asic_mintemp[0][1] = v1->chain_asic_mintemp[8][1];
            v46->chain_asic_mintemp[0][2] = v1->chain_asic_mintemp[8][2];
          }
        }
      }
      ++v45;
      v48 = (all_parameters *)((char *)v48 + 4);
      v44 += 8;
      v46 = (all_parameters *)((char *)v46 + 8);
      v47 = (all_parameters *)((char *)v47 + 1);
      ++v43;
    }
    while ( v45 != 16 );
    check_fan();
    set_PWM_according_to_temperature();
    if ( startCheckNetworkJob )
    {
      cgtime(&tv_send);
      v88 = tv_send.tv_sec - tv_send_job.tv_sec;
      if ( tv_send.tv_usec - tv_send_job.tv_usec < 0 )
        --v88;
      fan_num = dev->fan_num;
      if ( v88 > 120 )
      {
        strcpy((char *)logstr, "Fatal Error: network connection lost!\n");
        writeInitLogFile(logstr);
      }
      else if ( dev->temp_top1[0] <= 90 && dev->fan_num > 1u )
      {
        goto LABEL_142;
      }
LABEL_100:
      if ( ++fatal_error_counter <= 2 )
      {
        global_stop = 0;
        if ( !once_error )
          status_error = once_error;
        goto LABEL_110;
      }
      v64 = dev;
      global_stop = 1;
      if ( dev->temp_top1[0] <= 90 )
      {
        if ( fan_num <= 1 )
        {
          FatalErrorValue = 2;
          goto LABEL_144;
        }
        if ( dev->fan_speed_top1 >= 40 * fan_num )
          v65 = 4;
        else
          v65 = 3;
        FatalErrorValue = v65;
      }
      else
      {
        FatalErrorValue = 1;
LABEL_144:
        v89 = 0;
        status_error = 1;
        once_error = 1;
        while ( 1 )
        {
          if ( v64->chain_exist[v89] == 1 )
          {
            pthread_mutex_lock(&iic_mutex);
            disable_pic_dac(v89);
            pthread_mutex_unlock(&iic_mutex);
          }
          if ( ++v89 == 16 )
            break;
          v64 = dev;
        }
      }
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
      goto LABEL_110;
    }
    if ( dev->temp_top1[0] > 90 )
    {
      fan_num = 2;
      goto LABEL_100;
    }
LABEL_142:
    global_stop = 0;
    if ( once_error )
    {
      fatal_error_counter = 0;
    }
    else
    {
      fatal_error_counter = once_error;
      status_error = once_error;
    }
LABEL_110:
    if ( stop_mining )
    {
      status_error = 1;
      goto LABEL_112;
    }
    if ( status_error )
    {
LABEL_112:
      switch ( FatalErrorValue )
      {
        case 1:
          v67 = "Fatal Error: Temperature is too high!\n";
          goto LABEL_114;
        case 2:
          strcpy((char *)logstr, "Fatal Error: Fan lost!\n");
          break;
        case 3:
          strcpy((char *)logstr, "Fatal Error: Fan speed too low!\n");
          break;
        case 4:
          v67 = "Fatal Error: network connection lost!\n";
LABEL_114:
          v68 = *(_DWORD *)v67;
          v69 = *((_DWORD *)v67 + 1);
          v70 = *((_DWORD *)v67 + 2);
          v71 = *((_DWORD *)v67 + 3);
          v72 = (int *)(v67 + 16);
          *(_DWORD *)logstr = v68;
          *(_DWORD *)&logstr[4] = v69;
          *(_DWORD *)&logstr[8] = v70;
          *(_DWORD *)&logstr[12] = v71;
          v73 = *v72;
          v74 = v72[1];
          v75 = v72[2];
          v76 = v72[3];
          v72 += 4;
          *(_DWORD *)&logstr[16] = v73;
          *(_DWORD *)&logstr[20] = v74;
          *(_DWORD *)&logstr[24] = v75;
          *(_DWORD *)&logstr[28] = v76;
          v77 = v72[1];
          *(_DWORD *)&logstr[32] = *v72;
          *(_WORD *)&logstr[36] = v77;
          logstr[38] = BYTE2(v77);
          break;
        default:
          strcpy((char *)logstr, "Fatal Error: unkown status.\n");
          break;
      }
      writeInitLogFile(logstr);
    }
    processTEST();
    sprintf((char *)logstr, "FAN PWM: %d\n", dev->fan_pwm);
    writeLogFile_0(logstr);
    pthread_mutex_unlock(&opencore_readtemp_mutex);
    strcpy((char *)logstr, "read_temp_func Done!\n");
    writeLogFile_0(logstr);
    sprintf((char *)logstr, "CRC error counter=%d\n", *((unsigned __int16 *)axi_fpga_addr + 124));
    writeLogFile_0(logstr);
    updateLogFile();
    if ( doTestPatten )
      sleep(3u);
    else
      sleep(1u);
  }
}
// 39DB6: variable 'v15' is possibly undefined

//----- (0003A678) --------------------------------------------------------
void __fastcall remove_dot_char(unsigned __int8 *number)
{
  int v1; // r5
  size_t v3; // r4
  size_t v4; // r2
  char *v5; // r1
  unsigned __int8 *v6; // r0
  int v7; // r3
  unsigned __int8 tempStr[64]; // [sp+0h] [bp-50h] BYREF
  char v9[16]; // [sp+40h] [bp-10h] BYREF

  v1 = 0;
  v3 = 0;
  v4 = strlen((const char *)number);
  while ( 1 )
  {
    v5 = &v9[v1];
    v6 = number;
    if ( v3 >= v4 )
      break;
    while ( 1 )
    {
      v7 = number[v3++];
      if ( v7 == 44 )
        break;
      *(v5 - 64) = v7;
      ++v1;
      v4 = strlen((const char *)v6);
      v5 = &v9[v1];
      v6 = number;
      if ( v3 >= v4 )
        goto LABEL_5;
    }
  }
LABEL_5:
  *(v5 - 64) = 0;
  strcpy((char *)v6, (const char *)tempStr);
}

//----- (0003A6C8) --------------------------------------------------------
void __fastcall add_dot_number(unsigned __int8 *number)
{
  char *v2; // r0
  int v3; // r5
  unsigned __int8 tempStr[32]; // [sp+0h] [bp-30h] BYREF

  remove_dot_char(number);
  strcpy((char *)tempStr, (const char *)number);
  v2 = strchr((const char *)number, 46);
  if ( v2 )
  {
    v3 = v2 - (char *)number;
    if ( (unsigned int)(v2 - (char *)number) > 3 )
    {
      memcpy(tempStr, number, v3 - 3);
      tempStr[v3 - 3] = 44;
      strcpy((char *)&tempStr[v3 - 2], (const char *)&number[v3 - 3]);
    }
  }
  strcpy((char *)number, (const char *)tempStr);
}

//----- (0003A718) --------------------------------------------------------
void __fastcall dupalloc(cgpu_info *cgpu, int timelimit)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  K_LIST *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-818h] BYREF

  v4 = calloc(1u, 0x20u);
  v5 = v4;
  if ( !v4 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc dupdata in %s %s():%d",
      "noncedup.c",
      (const char *)_func___9335,
      36);
    applog(3, tmp42, 1);
    quit(1);
  }
  *v4 = timelimit;
  v6 = k_new_list("Nonces", 0x10u, 1024, 0, 1, "noncedup.c", _func___9335, 39);
  v5[1] = v6;
  v5[2] = k_new_store(v6);
  cgpu->dup_data = v5;
}

//----- (0003A7A0) --------------------------------------------------------
void __fastcall dupcounters(cgpu_info *cgpu, uint64_t *checked, uint64_t *dups)
{
  _QWORD *dup_data; // r3

  dup_data = cgpu->dup_data;
  if ( dup_data )
  {
    *checked = dup_data[2];
    *dups = dup_data[3];
  }
  else
  {
    *checked = 0LL;
    *dups = 0LL;
  }
}

//----- (0003A7C8) --------------------------------------------------------
bool __fastcall isdupnonce(cgpu_info *cgpu, work *work, unsigned int nonce)
{
  double v3; // d0
  void *dup_data; // r4
  bool result; // r0
  int v9; // r5
  _BOOL4 v10; // r6
  int v11; // r5
  _DWORD *v13; // r3
  int i; // r3
  K_ITEM *v15; // r0
  int v16; // r5
  K_ITEM *v17; // r0
  _DWORD *data; // r5
  __suseconds_t tv_usec; // r1
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  int *v23; // r0
  timeval now; // [sp+18h] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-828h] BYREF

  dup_data = cgpu->dup_data;
  result = (char)dup_data;
  if ( dup_data )
  {
    cgtime(&now);
    v9 = *(_DWORD *)(*((_DWORD *)dup_data + 1) + 8);
    ++*((_QWORD *)dup_data + 2);
    if ( pthread_mutex_lock((pthread_mutex_t *)v9) )
    {
      v23 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v23,
        "noncedup.c",
        (const char *)_func___9351,
        70);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v9 + 24)) )
    {
      v22 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v22,
        "noncedup.c",
        (const char *)_func___9351,
        70);
      applog(3, tmp42, 1);
      quit(1);
    }
    v10 = 1;
    v11 = *(_DWORD *)(*((_DWORD *)dup_data + 2) + 16);
    while ( v11 && v10 )
    {
      v13 = *(_DWORD **)(v11 + 12);
      if ( *v13 == work->id && v13[1] == nonce )
      {
        v10 = 0;
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf((char *)tmp42, 0x800u, "%s%d: Duplicate nonce %08x", cgpu->drv->name, cgpu->device_id, nonce);
          applog(4, tmp42, 0);
          break;
        }
        v10 = opt_log_output;
      }
      else
      {
        v11 = *(_DWORD *)(v11 + 4);
      }
    }
    if ( v10 )
    {
      v17 = k_unlink_head(*((K_LIST **)dup_data + 1), "noncedup.c", _func___9351, 81);
      data = v17->data;
      *data = work->id;
      data[1] = nonce;
      tv_usec = now.tv_usec;
      data[2] = now.tv_sec;
      data[3] = tv_usec;
      k_add_head(*((K_LIST **)dup_data + 2), v17, "noncedup.c", _func___9351, 85);
    }
    for ( i = *(_DWORD *)(*((_DWORD *)dup_data + 2) + 16); i; i = *(_DWORD *)(*((_DWORD *)dup_data + 2) + 16) )
    {
      tdiff((timeval *)(*(_DWORD *)(i + 12) + 8), &now);
      if ( v3 <= (double)*(int *)dup_data )
        break;
      v15 = k_unlink_tail(*((K_LIST **)dup_data + 2), "noncedup.c", _func___9351, 89);
      k_add_head(*((K_LIST **)dup_data + 1), v15, "noncedup.c", _func___9351, 90);
    }
    v16 = *(_DWORD *)(*((_DWORD *)dup_data + 1) + 8);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v16 + 24)) )
    {
      v21 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v21,
        "noncedup.c",
        (const char *)_func___9351,
        93);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)v16) )
    {
      v20 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v20,
        "noncedup.c",
        (const char *)_func___9351,
        93);
      applog(3, tmp42, 1);
      quit(1);
    }
    selective_yield();
    if ( !v10 )
      ++*((_QWORD *)dup_data + 3);
    return !v10;
  }
  return result;
}
// 3A8A6: conditional instruction was optimized away because r3.4==0
// 3A8F0: variable 'v3' is possibly undefined

//----- (0003AA5C) --------------------------------------------------------
unsigned __int8 *__fastcall arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen((const char *)fmt);
  v5 = strlen((const char *)arg);
  v6 = (char *)malloc(v5 + v4);
  sprintf(v6, (const char *)fmt, arg);
  return (unsigned __int8 *)v6;
}

//----- (0003AA84) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_bool(bool *b)
{
  *b = 1;
  return 0;
}

//----- (0003AA8C) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_false(bool *b)
{
  *b = 0;
  return 0;
}

//----- (0003AA94) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_invbool(bool *b)
{
  *b = 0;
  return 0;
}

//----- (0003AA9C) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_bool_arg(const unsigned __int8 *arg, bool *b)
{
  unsigned __int8 *result; // r0

  if ( !strcasecmp((const char *)arg, "yes") || !strcasecmp((const char *)arg, "true") )
  {
    result = 0;
    *b = 1;
  }
  else if ( !strcasecmp((const char *)arg, "no") || !strcasecmp((const char *)arg, "false") )
  {
    result = 0;
    *b = 0;
  }
  else
  {
    return opt_invalid_argument(arg);
  }
  return result;
}

//----- (0003AAF4) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_invbool_arg(const unsigned __int8 *arg, bool *b)
{
  unsigned __int8 *result; // r0

  result = opt_set_bool_arg(arg, b);
  if ( !result )
    *b ^= 1u;
  return result;
}

//----- (0003AB0C) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p)
{
  *p = (unsigned __int8 *)arg;
  return 0;
}

//----- (0003AB14) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_floatval(const unsigned __int8 *arg, float *f)
{
  int v2; // s0
  unsigned __int8 **v5; // r5
  unsigned __int8 *v6; // r3
  unsigned __int8 *result; // r0
  unsigned __int8 *endp; // [sp+4h] [bp-14h] BYREF

  v5 = (unsigned __int8 **)_errno_location();
  *v5 = 0;
  strtof(arg, &endp);
  v6 = endp;
  *(_DWORD *)f = v2;
  if ( *v6 || !*arg )
    return arg_bad("'%s' is not a number", arg);
  result = *v5;
  if ( *v5 )
    return arg_bad("'%s' is out of range", arg);
  return result;
}
// 3AB30: variable 'v2' is possibly undefined
// A43C: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (0003AB60) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_longval(const unsigned __int8 *arg, int *l)
{
  unsigned __int8 **v4; // r5
  int v5; // r0
  unsigned __int8 *v6; // r3
  unsigned __int8 *result; // r0
  unsigned __int8 *endp; // [sp+4h] [bp-14h] BYREF

  v4 = (unsigned __int8 **)_errno_location();
  *v4 = 0;
  v5 = strtol((const char *)arg, (char **)&endp, 0);
  v6 = endp;
  *l = v5;
  if ( *v6 || !*arg )
    return arg_bad("'%s' is not a number", arg);
  result = *v4;
  if ( *v4 )
    return arg_bad("'%s' is out of range", arg);
  return result;
}

//----- (0003ABA8) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_intval(const unsigned __int8 *arg, int *i)
{
  unsigned __int8 *result; // r0
  int l; // [sp+4h] [bp-Ch] BYREF

  result = opt_set_longval(arg, &l);
  if ( !result )
    *i = l;
  return result;
}

//----- (0003ABC0) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_uintval(const unsigned __int8 *arg, unsigned int *ui)
{
  unsigned __int8 *result; // r0
  int i; // [sp+4h] [bp-14h] BYREF

  result = opt_set_intval(arg, &i);
  if ( !result )
  {
    if ( i < 0 )
      return arg_bad("'%s' is negative", arg);
    else
      *ui = i;
  }
  return result;
}

//----- (0003ABEC) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_ulongval(const unsigned __int8 *arg, unsigned int *ul)
{
  unsigned __int8 *result; // r0
  bool v5; // nf
  int l; // [sp+4h] [bp-14h] BYREF

  result = opt_set_longval(arg, &l);
  if ( !result )
  {
    v5 = l < 0;
    *ul = l;
    if ( v5 )
      return arg_bad("'%s' is negative", arg);
  }
  return result;
}

//----- (0003AC18) --------------------------------------------------------
unsigned __int8 *__fastcall opt_inc_intval(int *i)
{
  unsigned __int8 *result; // r0

  result = 0;
  ++*i;
  return result;
}

//----- (0003AC24) --------------------------------------------------------
unsigned __int8 *__fastcall __noreturn opt_version_and_exit(const unsigned __int8 *version)
{
  puts((const char *)version);
  fflush((FILE *)stdout);
  exit(0);
}
// 6298C: using guessed type int stdout;

//----- (0003AC40) --------------------------------------------------------
unsigned __int8 *__fastcall __noreturn opt_usage_and_exit(const unsigned __int8 *extra)
{
  unsigned __int8 *v1; // r0

  v1 = opt_usage(opt_argv0, extra);
  printf("%s", (const char *)v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 6298C: using guessed type int stdout;

//----- (0003AC74) --------------------------------------------------------
void __fastcall opt_show_bool(unsigned __int8 *buf, const bool *b)
{
  int v2; // r4
  const char *v3; // r1

  v2 = *(unsigned __int8 *)b;
  v3 = "false";
  if ( v2 )
    v3 = "true";
  sub_A0CC((char *)buf, v3, 0x50u);
}

//----- (0003AC98) --------------------------------------------------------
void __fastcall opt_show_invbool(unsigned __int8 *buf, const bool *b)
{
  int v2; // r4
  const char *v3; // r1

  v2 = *(unsigned __int8 *)b;
  v3 = "true";
  if ( v2 )
    v3 = "false";
  sub_A0CC((char *)buf, v3, 0x50u);
}

//----- (0003ACBC) --------------------------------------------------------
void __fastcall opt_show_charp(unsigned __int8 *buf, unsigned __int8 *const *p)
{
  size_t v4; // r5
  const char *v5; // r1
  char *v6; // r0
  unsigned __int8 *v7; // r4

  v4 = strlen(*(const char **)p);
  *buf = 34;
  v5 = (const char *)*p;
  v6 = (char *)(buf + 1);
  if ( v4 > 0x4E )
  {
    strncpy(v6, v5, 0x4Eu);
    buf[79] = 34;
  }
  else
  {
    v7 = &buf[v4];
    strncpy(v6, v5, v4);
    v7[1] = 34;
    if ( v4 != 78 )
      v7[2] = 0;
  }
}

//----- (0003ACF8) --------------------------------------------------------
void __fastcall opt_show_intval(unsigned __int8 *buf, const int *i)
{
  j_snprintf((char *)buf, 0x50u, "%i", *i);
}

//----- (0003AD08) --------------------------------------------------------
void __fastcall opt_show_floatval(unsigned __int8 *buf, const float *f)
{
  snprintf((char *)buf, 0x50u, "%.1f", *f);
}

//----- (0003AD2C) --------------------------------------------------------
void __fastcall opt_show_uintval(unsigned __int8 *buf, const unsigned int *ui)
{
  j_snprintf((char *)buf, 0x50u, "%u", *ui);
}

//----- (0003AD3C) --------------------------------------------------------
void __fastcall opt_show_longval(unsigned __int8 *buf, const int *l)
{
  j_snprintf((char *)buf, 0x50u, "%li", *l);
}

//----- (0003AD4C) --------------------------------------------------------
void __fastcall opt_show_ulongval(unsigned __int8 *buf, const unsigned int *ul)
{
  j_snprintf((char *)buf, 0x50u, "%lu", *ul);
}

//----- (0003AD5C) --------------------------------------------------------
const unsigned __int8 *__fastcall next_name(const unsigned __int8 *names, unsigned int *len)
{
  int v2; // r3
  const unsigned __int8 *v3; // r0
  bool v4; // zf
  unsigned int v5; // r2
  int v6; // r4
  const unsigned __int8 *v7; // r4
  int v8; // r3
  int v9; // t1
  const unsigned __int8 *result; // r0

  v2 = names[*len];
  v3 = &names[*len];
  v4 = v2 == 32;
  if ( v2 != 32 )
    v4 = v2 == 61;
  if ( v4 )
    return 0;
  v5 = 0;
  if ( !v2 )
    return 0;
  v6 = v3[2];
  result = v3 + 2;
  if ( v6 )
  {
    if ( v6 != 124 && v6 != 61 && v6 != 32 )
    {
      v7 = result;
      do
      {
        v9 = *++v7;
        v8 = v9;
        ++v5;
      }
      while ( v9 && v8 != 124 && v8 != 61 && v8 != 32 );
    }
  }
  else
  {
    v5 = 0;
  }
  *len = v5;
  return result;
}

//----- (0003ADB4) --------------------------------------------------------
const unsigned __int8 *__fastcall first_opt(unsigned int *i, unsigned int *len)
{
  opt_table *v2; // r3
  opt_table *v3; // r5
  unsigned int v4; // r4
  const unsigned __int8 *names; // r0
  unsigned int v6; // r2
  bool v7; // zf
  int v8; // r3
  const unsigned __int8 *result; // r0

  *i = 0;
  if ( !opt_count )
    return 0;
  v2 = opt_table_0;
  if ( opt_table_0->type == OPT_SUBTABLE )
  {
    v3 = opt_table_0 + 1;
    v4 = 1;
    do
    {
      *i = v4;
      v2 = v3++;
      if ( opt_count <= v4++ )
        return 0;
    }
    while ( v2->type == OPT_SUBTABLE );
  }
  names = v2->names;
  v6 = *((unsigned __int8 *)v2->names + 1);
  if ( *((_BYTE *)v2->names + 1) )
  {
    if ( v6 == 124 || v6 == 61 )
    {
      v6 = 0;
    }
    else
    {
      v7 = v6 == 32;
      v6 = 0;
      if ( !v7 )
      {
        do
          v8 = names[++v6 + 1];
        while ( names[v6 + 1] && v8 != 124 && v8 != 61 && v8 != 32 );
      }
    }
  }
  result = names + 1;
  *len = v6;
  return result;
}

//----- (0003AE34) --------------------------------------------------------
const unsigned __int8 *__fastcall next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  unsigned int j; // r3
  opt_table *v7; // r5
  const unsigned __int8 *names; // r2
  int v10; // r3

  for ( j = *i; opt_count > j; *i = ++j )
  {
    v7 = &opt_table_0[j];
    if ( v7->type != OPT_SUBTABLE )
    {
      if ( !p )
      {
        names = v7->names;
        v10 = *((unsigned __int8 *)v7->names + 1);
        if ( *((_BYTE *)v7->names + 1) )
        {
          do
          {
            if ( v10 == 124 )
              break;
            if ( v10 == 61 )
              break;
            if ( v10 == 32 )
              break;
            v10 = (++p)[(_DWORD)names + 1];
          }
          while ( p[(_DWORD)names + 1] );
        }
        *len = (unsigned int)p;
        return names + 1;
      }
      p = next_name(p, len);
      if ( p )
        return p;
      j = *i;
    }
  }
  return 0;
}

//----- (0003AEB8) --------------------------------------------------------
const unsigned __int8 *__fastcall check_opt(const unsigned __int8 *result)
{
  unsigned int v1; // r1
  const char **v2; // r5
  bool v3; // cc
  unsigned int v4; // r3
  int v5; // r2
  int v6; // r1
  const unsigned __int8 *v7; // r4
  const unsigned __int8 *v8; // r2
  bool v9; // zf
  int v10; // r1
  bool v11; // zf
  unsigned int i; // [sp+Ch] [bp-24h] BYREF

  v1 = *((_DWORD *)result + 1);
  v2 = (const char **)result;
  v3 = v1 > 4;
  if ( v1 != 4 )
    v3 = v1 - 1 > 1;
  if ( v3 )
    errx(1, "Option %s: unknown entry type %u", *(const char **)result, *((_DWORD *)result + 1));
  v4 = 0;
  if ( !*((_DWORD *)result + 6) )
    errx(1, "Option %s: description cannot be NULL", *(const char **)result);
  v5 = *(_DWORD *)result;
  if ( **(_BYTE **)result != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v5);
  v6 = *(unsigned __int8 *)(v5 + 1);
  if ( *(_BYTE *)(v5 + 1) )
  {
    do
    {
      if ( v6 == 124 )
        break;
      if ( v6 == 61 )
        break;
      if ( v6 == 32 )
        break;
      ++v4;
      v6 = *(unsigned __int8 *)(v5 + v4 + 1);
    }
    while ( *(_BYTE *)(v5 + v4 + 1) );
  }
  else
  {
    v4 = *(unsigned __int8 *)(v5 + 1);
  }
  v7 = (const unsigned __int8 *)(v5 + 1);
  for ( i = v4; ; v4 = i )
  {
    if ( *v7 == 45 )
    {
      if ( v4 == 1 )
        errx(1, "Option %s: invalid long option '--'", *v2);
      result = (const unsigned __int8 *)v2[1];
      ++opt_num_long;
    }
    else
    {
      if ( v4 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *v2, v4 + 1, (const char *)v7 - 1);
      v8 = (const unsigned __int8 *)v2[1];
      v9 = v8 == (const unsigned __int8 *)2;
      if ( v8 != (const unsigned __int8 *)2 )
        v9 = v8 == (const unsigned __int8 *)4;
      if ( v9 )
        result = (const unsigned __int8 *)v2[1];
      ++opt_num_short;
      if ( v9 )
        ++opt_num_short_arg;
      else
        result = v8;
    }
    if ( result == (const unsigned __int8 *)1 )
    {
      v10 = v7[v4];
      v11 = v10 == 32;
      if ( v10 != 32 )
        v11 = v10 == 61;
      if ( v11 )
        errx(1, "Option %s: does not take arguments '%s'", *v2, (const char *)&v7[v4 + 1]);
    }
    result = next_name(v7, &i);
    v7 = result;
    if ( !result )
      break;
  }
  return result;
}

//----- (0003AFDC) --------------------------------------------------------
void __fastcall add_opt(const opt_table *entry)
{
  opt_table *v2; // r12
  const unsigned __int8 *names; // r0
  opt_type type; // r1
  unsigned __int8 *(*cb)(void *); // r2
  unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *); // r3
  unsigned int v7; // r7
  opt_table *v8; // r4
  opt_type v9; // r1
  unsigned __int8 *(*v10)(void *); // r2

  v2 = (opt_table *)realloc(opt_table_0, 28 * (opt_count + 1));
  names = entry->names;
  type = entry->type;
  cb = entry->cb;
  cb_arg = entry->cb_arg;
  entry = (const opt_table *)((char *)entry + 16);
  opt_table_0 = v2;
  v7 = opt_count + 1;
  v8 = &v2[opt_count];
  v8->names = names;
  v8->type = type;
  v8->cb = cb;
  v8->cb_arg = cb_arg;
  v8 = (opt_table *)((char *)v8 + 16);
  opt_count = v7;
  v9 = entry->type;
  v10 = entry->cb;
  v8->names = entry->names;
  v8->type = v9;
  v8->cb = v10;
}

//----- (0003B024) --------------------------------------------------------
const unsigned __int8 *__fastcall first_lopt(unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *opt; // r0
  const unsigned __int8 *result; // r0

  opt = first_opt(i, len);
  if ( !opt )
    return 0;
  while ( *opt != 45 )
  {
    opt = next_opt(opt, i, len);
    if ( !opt )
      return 0;
  }
  result = opt + 1;
  --*len;
  return result;
}

//----- (0003B050) --------------------------------------------------------
const unsigned __int8 *__fastcall next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *opt; // r0
  const unsigned __int8 *result; // r0

  opt = next_opt(p, i, len);
  if ( !opt )
    return 0;
  while ( *opt != 45 )
  {
    opt = next_opt(opt, i, len);
    if ( !opt )
      return 0;
  }
  result = opt + 1;
  --*len;
  return result;
}

//----- (0003B07C) --------------------------------------------------------
const unsigned __int8 *__fastcall first_sopt(unsigned int *i)
{
  const unsigned __int8 *result; // r0
  unsigned int v3; // [sp+4h] [bp-14h] BYREF

  v3 = 0;
  result = first_opt(i, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = next_opt(result, i, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0003B0AC) --------------------------------------------------------
const unsigned __int8 *__fastcall next_sopt(const unsigned __int8 *p, unsigned int *i)
{
  const unsigned __int8 *result; // r0
  unsigned int v4; // [sp+4h] [bp-14h] BYREF

  v4 = 1;
  result = next_opt(p, i, &v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = next_opt(result, i, &v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0003B0DC) --------------------------------------------------------
void __fastcall opt_register(
        const unsigned __int8 *names,
        opt_type type,
        unsigned __int8 *(*cb)(void *),
        unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *),
        void (*show)(unsigned __int8 *, const void *),
        const void *arg,
        const unsigned __int8 *desc)
{
  opt_table opt; // [sp+4h] [bp-2Ch] BYREF

  opt.names = names;
  opt.type = type;
  opt.cb = cb;
  opt.cb_arg = cb_arg;
  opt.show = show;
  opt.u.tlen = (size_t)arg;
  opt.desc = desc;
  check_opt((const unsigned __int8 *)&opt);
  add_opt(&opt);
}

//----- (0003B104) --------------------------------------------------------
void __fastcall opt_register_table(const opt_table *entry, const unsigned __int8 *desc)
{
  unsigned int v4; // r7
  opt_type type; // r3
  const opt_table *v6; // r4
  const opt_table *v7; // r0
  const unsigned __int8 *names; // r0
  const unsigned __int8 *v9; // r1
  opt_table heading; // [sp+4h] [bp-34h] BYREF

  v4 = opt_count;
  if ( desc )
  {
    heading.desc = desc;
    heading.names = 0;
    memset(&heading.cb, 0, 16);
    heading.type = OPT_SUBTABLE;
    add_opt(&heading);
  }
  type = entry->type;
  if ( type != OPT_END )
  {
    v6 = entry + 1;
    do
    {
      while ( type != OPT_SUBTABLE )
      {
        check_opt((const unsigned __int8 *)entry);
        v7 = entry;
        entry = v6++;
        add_opt(v7);
        type = v6[-1].type;
        if ( type == OPT_END )
          goto LABEL_9;
      }
      names = entry->names;
      v9 = entry->desc;
      entry = v6++;
      opt_register_table((const opt_table *)names, v9);
      type = v6[-1].type;
    }
    while ( type != OPT_END );
  }
LABEL_9:
  if ( desc )
    opt_table_0[v4].u.tlen = opt_count - v4;
}

//----- (0003B194) --------------------------------------------------------
bool __fastcall opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...))
{
  unsigned __int8 *v4; // r3
  int v7; // r0
  int v9; // [sp+4h] [bp-1Ch] BYREF

  v4 = *argv;
  v9 = 0;
  opt_argv0 = v4;
  do
    v7 = parse_one(argc, (const char **)argv, &v9, (void (*)(const char *, ...))errlog);
  while ( v7 == 1 );
  return v7 == 0;
}

//----- (0003B1CC) --------------------------------------------------------
void opt_free_table()
{
  free(opt_table_0);
  opt_table_0 = 0;
}

//----- (0003B1E4) --------------------------------------------------------
void opt_log_stderr(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, fmt);
  vfprintf((FILE *)stderr, (const char *)fmt, varg_r1);
  fputc(10, (FILE *)stderr);
}
// 62990: using guessed type int stderr;

//----- (0003B214) --------------------------------------------------------
void __noreturn opt_log_stderr_exit(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, fmt);
  vfprintf((FILE *)stderr, (const char *)fmt, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 62990: using guessed type int stderr;

//----- (0003B240) --------------------------------------------------------
unsigned __int8 *__fastcall opt_invalid_argument(const unsigned __int8 *arg)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen((const char *)arg);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", arg);
  return (unsigned __int8 *)v3;
}

//----- (0003B264) --------------------------------------------------------
unsigned __int8 *__fastcall opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra)
{
  size_t v2; // r4
  unsigned int v3; // r10
  size_t v4; // r7
  opt_table *v5; // r4
  unsigned int v6; // r6
  const char *desc; // r5
  size_t v8; // r7
  size_t v9; // r0
  size_t v10; // r7
  size_t v11; // r8
  char *v12; // r0
  char *v13; // r4
  char *v14; // r7
  const unsigned __int8 *v15; // r3
  int v16; // r10
  int v17; // r0
  char *v18; // r5
  int v19; // r4
  unsigned int v20; // r7
  unsigned int v21; // r11
  int v22; // r2
  unsigned int v23; // r11
  unsigned int v24; // r11
  opt_table *v25; // r3
  const unsigned __int8 *v26; // r2
  char *v28; // r3
  int v29; // r2
  opt_table *v30; // r3
  size_t v31; // r6
  char *s; // [sp+0h] [bp-90h]
  unsigned __int8 *p; // [sp+4h] [bp-8Ch]
  const char *extraa; // [sp+8h] [bp-88h]
  unsigned int v36; // [sp+10h] [bp-80h] BYREF
  unsigned __int8 buf[84]; // [sp+14h] [bp-7Ch] BYREF

  extraa = (const char *)extra;
  if ( extra )
  {
    v2 = strlen((const char *)argv0);
    v3 = opt_count;
    v4 = opt_num_short + 20 + v2 + strlen(extraa);
    if ( !opt_count )
      goto LABEL_12;
    v5 = opt_table_0;
  }
  else
  {
    v3 = opt_count;
    if ( !opt_count )
    {
      extraa = "";
      v4 = opt_num_short + 20 + strlen((const char *)argv0);
      goto LABEL_12;
    }
    v29 = 0;
    v5 = opt_table_0;
    v30 = opt_table_0;
    do
    {
      ++v29;
      if ( (unsigned __int8 *(__fastcall *)(const unsigned __int8 *))v30->cb == opt_usage_and_exit && v30->u.tlen )
      {
        extraa = (const char *)v30->u.carg;
        v31 = strlen(extraa);
        goto LABEL_45;
      }
      ++v30;
    }
    while ( v29 != opt_count );
    v31 = 0;
    extraa = "";
LABEL_45:
    v4 = opt_num_short + 20 + strlen((const char *)argv0) + v31;
  }
  v6 = 0;
  do
  {
    while ( 1 )
    {
      v11 = v4 + 6;
      if ( v5->type != OPT_SUBTABLE )
        break;
      ++v6;
      v4 += 3 + strlen((const char *)v5->desc);
      ++v5;
      if ( v3 <= v6 )
        goto LABEL_12;
    }
    desc = (const char *)v5->desc;
    if ( desc != (const char *)opt_hidden )
    {
      v8 = strlen((const char *)v5->names);
      v9 = strlen(desc) + v11 + v8;
      v10 = v9 + 21;
      if ( v5->show )
        v10 = v9 + 118;
      v4 = v10 + 1;
    }
    ++v6;
    ++v5;
  }
  while ( v3 > v6 );
LABEL_12:
  v12 = (char *)malloc(v4);
  p = (unsigned __int8 *)v12;
  if ( v12 )
  {
    v13 = &v12[sprintf(v12, "Usage: %s", (const char *)argv0)];
    v14 = v13 + 3;
    *(_DWORD *)v13 = &repeated_nonce_id[5][126];
    v15 = first_sopt(&v36);
    if ( v15 )
    {
      v16 = 0;
      do
      {
        if ( opt_table_0[v36].desc != opt_hidden )
          v14[v16++] = *v15;
        v15 = next_sopt(v15, &v36);
      }
      while ( v15 );
      if ( v16 )
      {
        v13 = &v14[v16 + 1];
        *(_WORD *)&v14[v16] = 93;
      }
    }
    v17 = sprintf(v13, " %s", extraa);
    v18 = &v13[v17 + 1];
    *(_WORD *)&v13[v17] = 10;
    if ( opt_count )
    {
      v19 = 0;
      v20 = 0;
      do
      {
        while ( 1 )
        {
          v25 = &opt_table_0[v19];
          v26 = opt_table_0[v19].desc;
          if ( v26 != opt_hidden )
            break;
LABEL_29:
          ++v20;
          ++v19;
          if ( opt_count <= v20 )
            goto LABEL_33;
        }
        if ( v25->type != OPT_SUBTABLE )
        {
          v21 = sprintf(v18, "%s", (const char *)v25->names);
          if ( opt_table_0[v19].type == OPT_HASARG )
          {
            s = (char *)opt_table_0[v19].names;
            if ( !strchr(s, 32) && !strchr(s, 61) )
            {
              v28 = &v18[v21];
              *(_DWORD *)&v18[v21] = *(_DWORD *)" <arg>";
              v21 += 6;
              strcpy(v28 + 4, "g>");
            }
          }
          if ( v21 > 0x13 )
            v22 = 1;
          else
            v22 = 20 - v21;
          v23 = v21 + sprintf(&v18[v21], "%.*s", v22, "                    ");
          v24 = v23 + sprintf(&v18[v23], "%s", (const char *)opt_table_0[v19].desc);
          if ( opt_table_0[v19].show )
          {
            *(_DWORD *)&buf[80] = (char *)&asic_core_nonce_num[0][25][174] + 2;
            opt_table_0[v19].show(buf, (const void *)opt_table_0[v19].u.tlen);
            v24 += sprintf(&v18[v24], " (default: %s)", (const char *)buf);
          }
          *(_WORD *)&v18[v24] = 10;
          v18 += v24 + 1;
          goto LABEL_29;
        }
        ++v20;
        v18 += sprintf(v18, "%s:\n", (const char *)v26);
        ++v19;
      }
      while ( opt_count > v20 );
    }
LABEL_33:
    *v18 = 0;
  }
  return p;
}

//----- (0003B540) --------------------------------------------------------
void __fastcall consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum)
{
  memmove(&argv[optnum], &argv[optnum + 1], 4 * (*argc - optnum));
  --*argc;
}

//----- (0003B560) --------------------------------------------------------
int __fastcall parse_one(int *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  int result; // r0
  const char **v9; // r5
  unsigned int v10; // r4
  const unsigned __int8 *v11; // r0
  const char *v12; // r3
  int v13; // lr
  size_t v14; // r0
  int v15; // r8
  const unsigned __int8 *j; // r8
  int v17; // r0
  unsigned int v18; // r1
  const char *v19; // r8
  opt_table *v20; // r12
  opt_type type; // r0
  const unsigned __int8 *v22; // r11
  const char *v23; // r12
  int *v24; // r3
  int v25; // t1
  opt_table *v26; // r0
  _BYTE *ptr; // [sp+8h] [bp-38h]
  char *ptra; // [sp+8h] [bp-38h]
  const char *v29; // [sp+Ch] [bp-34h]
  unsigned int i; // [sp+10h] [bp-30h] BYREF
  unsigned int len[11]; // [sp+14h] [bp-2Ch] BYREF

  if ( getenv("POSIXLY_CORRECT") )
  {
    result = (int)a2[1];
    v9 = a2 + 1;
    if ( result )
    {
      if ( *(_BYTE *)result != 45 )
        return 0;
      v10 = 1;
LABEL_7:
      if ( *(_BYTE *)(result + 1) == 45 )
      {
        v15 = *(unsigned __int8 *)(result + 2);
        if ( !*(_BYTE *)(result + 2) )
        {
          consume_option(a1, (unsigned __int8 **)a2, v10);
          return v15;
        }
        if ( *a3 )
          _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, "parse_one");
        for ( j = first_lopt(&i, len); j; j = next_lopt(j, &i, len) )
        {
          v29 = *v9;
          ptr = (_BYTE *)len[0];
          v17 = strncmp(*v9 + 2, (const char *)j, len[0]);
          v12 = v29;
          if ( !v17 )
          {
            if ( ptr[(_DWORD)v29 + 2] == 61 )
            {
              v18 = i;
              v22 = &ptr[(_DWORD)v29 + 3];
              v19 = (const char *)(j - 2);
              len[0] = (unsigned int)(ptr + 2);
              v20 = &opt_table_0[i];
              type = v20->type;
              if ( type != OPT_NOARG )
              {
                if ( v22 )
                  goto LABEL_41;
                goto LABEL_49;
              }
              if ( v22 )
              {
                a4("%s: %.*s: %s", *a2, (int)(ptr + 2), v19, "doesn't allow an argument");
                return -1;
              }
LABEL_19:
              v22 = 0;
              v23 = (const char *)v20->cb(v20->u.tlen);
LABEL_20:
              if ( v23 )
              {
                ptra = (char *)v23;
                a4("%s: %.*s: %s", *a2, len[0], v19, v23);
                free(ptra);
                return -1;
              }
              if ( *a3 )
              {
                if ( !(*v9)[*a3 + 1] )
                {
                  *a3 = 0;
                  goto LABEL_24;
                }
              }
              else
              {
LABEL_24:
                consume_option(a1, (unsigned __int8 **)a2, v10);
                if ( v22 )
                {
                  if ( *v9 == (const char *)v22 )
                    consume_option(a1, (unsigned __int8 **)a2, v10);
                }
              }
              return 1;
            }
            if ( !ptr[(_DWORD)v29 + 2] )
            {
              v18 = i;
              v19 = (const char *)(j - 2);
              len[0] = (unsigned int)(ptr + 2);
              v20 = &opt_table_0[i];
              type = v20->type;
              if ( type == OPT_NOARG )
                goto LABEL_19;
LABEL_49:
              v13 = *a3;
              goto LABEL_38;
            }
          }
        }
      }
      else
      {
        v11 = first_sopt(&i);
        if ( v11 )
        {
          while ( 1 )
          {
            v12 = *v9;
            v13 = *a3 + 1;
            if ( (unsigned __int8)(*v9)[v13] == *v11 )
              break;
            v11 = next_sopt(v11, &i);
            if ( !v11 )
              goto LABEL_11;
          }
          v19 = (const char *)(v11 - 1);
          v18 = i;
          len[0] = 2;
          v26 = opt_table_0;
          *a3 = v13;
          v20 = &v26[v18];
          type = v20->type;
          if ( type == OPT_NOARG )
            goto LABEL_19;
LABEL_38:
          if ( v13 && (v22 = (const unsigned __int8 *)&v12[v13 + 1], *v22) )
          {
            *a3 = 0;
          }
          else
          {
            v22 = (const unsigned __int8 *)a2[v10 + 1];
            if ( !v22 )
            {
              a4("%s: %.*s: %s", *a2, len[0], v19, "requires an argument");
              return -1;
            }
          }
LABEL_41:
          if ( type == OPT_PROCESSARG )
          {
            opt_set_charp(v22, (unsigned __int8 **)v20->u.carg);
            v18 = i;
          }
          v23 = (const char *)opt_table_0[v18].cb_arg(v22, opt_table_0[v18].u.tlen);
          goto LABEL_20;
        }
      }
LABEL_11:
      v14 = strlen(*v9);
      a4("%s: %.*s: %s", *a2, v14, *v9, "unrecognized option");
      return -1;
    }
  }
  else
  {
    result = (int)a2[1];
    if ( result )
    {
      if ( *(_BYTE *)result == 45 )
      {
        v9 = a2 + 1;
        v10 = 1;
        goto LABEL_7;
      }
      v24 = (int *)(a2 + 2);
      v10 = 1;
      while ( 1 )
      {
        v9 = (const char **)v24;
        v25 = *v24++;
        result = v25;
        ++v10;
        if ( !v25 )
          break;
        if ( *(_BYTE *)result == 45 )
          goto LABEL_7;
      }
    }
  }
  return result;
}

//----- (0003B820) --------------------------------------------------------
void set_error(scanner_t *s, const unsigned __int8 *source, const unsigned __int8 *msg, ...)
{
  va_list varg_r3; // [sp+2Ch] [bp-4h] BYREF

  va_start(varg_r3, msg);
  jsonp_error_vset(s->error, s->token.line, s->token.column, s->token.pos, msg, varg_r3);
  jsonp_error_set_source(s->error, source);
}

//----- (0003B858) --------------------------------------------------------
void __fastcall next_token(scanner_t *s)
{
  token_t *p_token; // r5
  int line; // r7
  int column; // r1
  size_t pos; // r2
  int v6; // r3
  const unsigned __int8 *fmt; // r2
  int v8; // r5
  size_t v9; // r1
  const unsigned __int8 *v10; // r0
  int v11; // r3
  int v12; // t1
  bool v13; // zf
  int v14; // r2
  int v15; // r0
  int v16; // r1
  size_t v17; // r2
  int v18; // r3

  p_token = &s->token;
  line = s->next_token.line;
  column = s->token.column;
  pos = s->token.pos;
  v6 = *(_DWORD *)&s->token.token;
  s->prev_token.line = s->token.line;
  s->prev_token.column = column;
  s->prev_token.pos = pos;
  *(_DWORD *)&s->prev_token.token = v6;
  if ( !line )
  {
    fmt = s->fmt;
    v8 = s->line;
    v9 = s->pos + 1;
    ++s->column;
    for ( s->pos = v9; ; s->pos = v9 )
    {
      v10 = fmt;
      v12 = *fmt++;
      v11 = v12;
      v13 = v12 == 32;
      if ( v12 != 32 )
        v13 = v11 == 9;
      if ( v13 )
      {
        if ( v11 != 10 )
          goto LABEL_6;
      }
      else if ( v11 != 10 )
      {
        if ( v11 != 44 && v11 != 58 )
        {
          v14 = s->column;
          s->fmt = v10 + 1;
          s->token.token = v11;
          s->token.line = v8;
          s->token.pos = v9;
          s->token.column = v14;
          return;
        }
LABEL_6:
        ++s->column;
        goto LABEL_7;
      }
      ++v8;
      s->column = 1;
      s->line = v8;
LABEL_7:
      ++v9;
    }
  }
  v15 = s->next_token.line;
  v16 = s->next_token.column;
  v17 = s->next_token.pos;
  v18 = *(_DWORD *)&s->next_token.token;
  s->next_token.line = 0;
  p_token->line = v15;
  p_token->column = v16;
  p_token->pos = v17;
  *(_DWORD *)&p_token->token = v18;
}

//----- (0003B8DC) --------------------------------------------------------
int __fastcall unpack(scanner_t *s, json_t_0 *root, va_list *ap)
{
  __int64 v3; // d0
  int v7; // r5
  unsigned __int8 *v8; // r3
  bool v9; // zf
  bool v10; // r3
  int v11; // r3
  int v12; // r5
  _QWORD **v14; // r3
  _QWORD *v15; // r4
  json_type type; // r3
  json_int_t **v17; // r3
  json_int_t *v18; // r4
  size_t refcount; // r3
  json_t_0 ***v20; // r2
  json_t_0 **v21; // r3
  int v22; // r8
  size_t v23; // r9
  int token; // r5
  bool v25; // zf
  bool v26; // r3
  int v27; // r3
  size_t v28; // r0
  _DWORD **v29; // r3
  _DWORD *v30; // r3
  _DWORD **v31; // r3
  _DWORD *v32; // r4
  _QWORD **v33; // r3
  _QWORD *v34; // r4
  size_t v35; // r3
  json_t_0 ***v36; // r3
  const unsigned __int8 ***v37; // r3
  const unsigned __int8 **v38; // r7
  json_t_0 *v39; // r1
  const unsigned __int8 **v40; // r3
  const unsigned __int8 *v41; // r8
  char v42; // r9
  char v43; // r9
  json_t_0 *v44; // r0
  int v45; // r3
  json_t_0 *v46; // r1
  json_t_0 *v47; // r0
  int v48; // r3
  int v49; // r3
  int v50; // r3
  json_t_0 ***v51; // r3
  size_t size; // r5
  size_t v53; // r0
  unsigned __int8 *fmt; // [sp+0h] [bp-40h]
  unsigned __int8 *fmta; // [sp+0h] [bp-40h]
  hashtable_t hashtable; // [sp+Ch] [bp-34h] BYREF

  switch ( s->token.token )
  {
    case 'F':
      if ( root && (unsigned int)(root->type - 3) > 1 )
      {
        v12 = -1;
        set_error(s, "<validation>", "Expected real or integer, got %s", (const char *)type_names[root->type]);
      }
      else
      {
        v12 = s->flags & 1;
        if ( v12 )
          return 0;
        v14 = (_QWORD **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v15 = *v14;
        if ( !root )
          return 0;
        json_number_value(root);
        *v15 = v3;
      }
      return v12;
    case 'I':
      if ( root )
      {
        type = root->type;
        if ( root->type != JSON_INTEGER )
          goto LABEL_131;
      }
      v12 = s->flags & 1;
      if ( v12 )
        return 0;
      v17 = (json_int_t **)ap->__ap;
      ap->__ap = (char *)ap->__ap + 4;
      if ( !root )
        return 0;
      v18 = *v17;
      *v18 = json_integer_value(root);
      return v12;
    case 'O':
      if ( !root )
      {
        v35 = s->flags & 1;
        goto LABEL_82;
      }
      if ( (s->flags & 1) != 0 )
        return 0;
      refcount = root->refcount;
      if ( refcount == -1 )
      {
        v51 = (json_t_0 ***)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v21 = *v51;
      }
      else
      {
        v20 = (json_t_0 ***)ap->__ap;
        root->refcount = refcount + 1;
        ap->__ap = v20 + 1;
        v21 = *v20;
      }
      goto LABEL_84;
    case '[':
      if ( root && root->type != JSON_ARRAY )
      {
        v12 = -1;
        set_error(s, "<validation>", "Expected array, got %s", (const char *)type_names[root->type]);
        return v12;
      }
      v22 = 0;
      v23 = 0;
      next_token(s);
LABEL_44:
      token = s->token.token;
      if ( token == 93 )
        goto LABEL_55;
      do
      {
        if ( v22 )
        {
          fmt = (unsigned __int8 *)token;
          if ( v22 == 1 )
            v48 = 33;
          else
            v48 = 42;
          v12 = -1;
          set_error(s, "<format>", "Expected ']' after '%c', got '%c'", v48, fmt);
          return v12;
        }
        if ( !token )
        {
          v12 = -1;
          set_error(s, "<format>", "Unexpected end of format string");
          return v12;
        }
        v25 = token == 33;
        if ( token != 33 )
          v25 = token == 42;
        if ( !v25 )
        {
          if ( !strchr((const char *)unpack_value_starters, token) )
          {
            v50 = token;
            v12 = -1;
            set_error(s, "<format>", "Unexpected format character '%c'", v50);
            return v12;
          }
          if ( root )
          {
            v39 = json_array_get(root, v23);
            if ( !v39 )
            {
              v12 = -1;
              set_error(s, "<validation>", "Array index %lu out of range", v23);
              return v12;
            }
          }
          else
          {
            v39 = 0;
          }
          if ( unpack(s, v39, ap) )
            return -1;
          ++v23;
          next_token(s);
          goto LABEL_44;
        }
        if ( token == 33 )
          v22 = 1;
        else
          v22 = -1;
        next_token(s);
        token = s->token.token;
      }
      while ( token != 93 );
LABEL_55:
      if ( v22 )
      {
        v26 = v22 == 1;
      }
      else
      {
        if ( (s->flags & 2) == 0 )
          return 0;
        v26 = 1;
      }
      if ( root )
        v27 = v26;
      else
        v27 = 0;
      if ( v27 && v23 != json_array_size(root) )
      {
        v12 = -1;
        v28 = json_array_size(root);
        set_error(s, "<validation>", "%li array item(s) left unpacked", v28 - v23);
        return v12;
      }
      return 0;
    case 'b':
      if ( root && (unsigned int)(root->type - 5) > 1 )
      {
        v12 = -1;
        set_error(s, "<validation>", "Expected true or false, got %s", (const char *)type_names[root->type]);
        return v12;
      }
      v12 = s->flags & 1;
      if ( !v12 )
      {
        v29 = (_DWORD **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v30 = *v29;
        if ( root )
        {
          *v30 = root->type == JSON_TRUE;
          return v12;
        }
      }
      return 0;
    case 'f':
      if ( root && root->type != JSON_REAL )
      {
        v12 = -1;
        set_error(s, "<validation>", "Expected real, got %s", (const char *)type_names[root->type]);
        return v12;
      }
      v12 = s->flags & 1;
      if ( !v12 )
      {
        v33 = (_QWORD **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v34 = *v33;
        if ( root )
        {
          json_real_value(root);
          *v34 = v3;
          return v12;
        }
      }
      return 0;
    case 'i':
      if ( root )
      {
        type = root->type;
        if ( root->type != JSON_INTEGER )
        {
LABEL_131:
          v12 = -1;
          set_error(s, "<validation>", "Expected integer, got %s", (const char *)type_names[type]);
          return v12;
        }
      }
      v12 = s->flags & 1;
      if ( !v12 )
      {
        v31 = (_DWORD **)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        if ( root )
        {
          v32 = *v31;
          *v32 = json_integer_value(root);
          return v12;
        }
      }
      return 0;
    case 'n':
      if ( !root || root->type == JSON_NULL )
        return 0;
      v12 = -1;
      set_error(s, "<validation>", "Expected null, got %s", (const char *)type_names[root->type]);
      return v12;
    case 'o':
      v35 = s->flags & 1;
LABEL_82:
      if ( !v35 )
      {
        v36 = (json_t_0 ***)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        v21 = *v36;
        if ( root )
LABEL_84:
          *v21 = root;
      }
      return 0;
    case 's':
      if ( root && root->type != JSON_STRING )
      {
        v12 = -1;
        set_error(s, "<validation>", "Expected string, got %s", (const char *)type_names[root->type]);
      }
      else
      {
        v12 = s->flags & 1;
        if ( v12 )
          return 0;
        v37 = (const unsigned __int8 ***)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
        if ( *v37 )
        {
          if ( !root )
            return 0;
          v38 = *v37;
          *v38 = json_string_value(root);
        }
        else
        {
          v12 = -1;
          set_error(s, "<args>", "NULL string argument");
        }
      }
      return v12;
    case '{':
      if ( !hashtable_init(&hashtable) )
      {
        if ( root && root->type )
        {
          v12 = -1;
          set_error(s, "<validation>", "Expected object, got %s", (const char *)type_names[root->type]);
          goto LABEL_24;
        }
        v7 = 0;
        next_token(s);
        while ( 1 )
        {
          v8 = (unsigned __int8 *)s->token.token;
          if ( v8 == (unsigned __int8 *)125 )
            break;
          while ( 1 )
          {
            if ( v7 )
            {
              fmta = v8;
              if ( v7 == 1 )
                v49 = 33;
              else
                v49 = 42;
              v12 = -1;
              set_error(s, "<format>", "Expected '}' after '%c', got '%c'", v49, fmta);
              goto LABEL_24;
            }
            if ( !v8 )
            {
              v12 = -1;
              set_error(s, "<format>", "Unexpected end of format string");
              goto LABEL_24;
            }
            v9 = v8 == (unsigned __int8 *)33;
            if ( v8 != (unsigned __int8 *)33 )
              v9 = v8 == (unsigned __int8 *)42;
            if ( !v9 )
              break;
            if ( v8 == (unsigned __int8 *)33 )
              v7 = 1;
            else
              v7 = -1;
            next_token(s);
            v8 = (unsigned __int8 *)s->token.token;
            if ( v8 == (unsigned __int8 *)125 )
              goto LABEL_17;
          }
          if ( v8 != (unsigned __int8 *)115 )
          {
            v12 = -1;
            set_error(s, "<format>", "Expected format 's', got '%c'", v8);
            goto LABEL_24;
          }
          v40 = (const unsigned __int8 **)ap->__ap;
          ap->__ap = (char *)ap->__ap + 4;
          v41 = *v40;
          if ( !*v40 )
          {
            v12 = -1;
            set_error(s, "<args>", "NULL object key");
            goto LABEL_24;
          }
          next_token(s);
          if ( s->token.token == 63 )
          {
            v42 = 1;
            next_token(s);
          }
          else
          {
            v42 = 0;
          }
          if ( !root )
          {
            v46 = 0;
            goto LABEL_106;
          }
          v43 = v42 ^ 1;
          v44 = json_object_get(root, v41);
          if ( v44 )
            v45 = 0;
          else
            v45 = v43 & 1;
          v46 = v44;
          if ( v45 )
          {
            v12 = -1;
            set_error(s, "<validation>", "Object item not found: %s", (const char *)v41);
            goto LABEL_24;
          }
LABEL_106:
          if ( unpack(s, v46, ap) )
          {
            v12 = -1;
            goto LABEL_24;
          }
          v47 = json_null();
          hashtable_set(&hashtable, v41, 0, v47);
          next_token(s);
        }
LABEL_17:
        if ( v7 )
        {
          v10 = v7 == 1;
        }
        else
        {
          if ( (s->flags & 2) == 0 )
          {
LABEL_23:
            v12 = 0;
LABEL_24:
            hashtable_close(&hashtable);
            return v12;
          }
          v10 = 1;
        }
        if ( root )
          v11 = v10;
        else
          v11 = 0;
        if ( v11 )
        {
          size = hashtable.size;
          if ( size != json_object_size(root) )
          {
            v12 = -1;
            v53 = json_object_size(root);
            set_error(s, "<validation>", "%li object item(s) left unpacked", v53 - hashtable.size);
            goto LABEL_24;
          }
        }
        goto LABEL_23;
      }
      v12 = -1;
      set_error(s, "<internal>", "Out of memory");
      return v12;
    default:
      v12 = -1;
      set_error(s, "<format>", "Unexpected format character '%c'", s->token.token);
      return v12;
  }
}
// 3BA24: variable 'v3' is possibly undefined

//----- (0003BEEC) --------------------------------------------------------
unsigned __int8 *__fastcall read_string(scanner_t *s, va_list *ap, const unsigned __int8 *purpose, int *ours)
{
  token_t *p_token; // r4
  token_t *p_next_token; // r7
  int column; // r1
  size_t pos; // r2
  int v12; // r3
  token_t *p_prev_token; // r6
  unsigned __int8 token; // lr
  int v15; // r1
  size_t v16; // r2
  int v17; // r3
  const unsigned __int8 **v18; // r3
  unsigned __int8 *v19; // r8
  int v21; // r1
  size_t v22; // r2
  int v23; // r3
  int v24; // r1
  size_t v25; // r2
  int v26; // r3
  size_t v27; // r2
  unsigned __int8 **v28; // r3
  int v29; // r1
  size_t v30; // r2
  int v31; // r3
  int v32; // r1
  size_t v33; // r2
  int v34; // r3
  strbuffer_t strbuff; // [sp+4h] [bp-34h] BYREF

  p_token = &s->token;
  p_next_token = &s->next_token;
  next_token(s);
  column = p_token->column;
  pos = p_token->pos;
  v12 = *(_DWORD *)&p_token->token;
  p_prev_token = &s->prev_token;
  token = s->token.token;
  p_next_token->line = p_token->line;
  p_next_token->column = column;
  p_next_token->pos = pos;
  *(_DWORD *)&p_next_token->token = v12;
  v15 = s->prev_token.column;
  v16 = s->prev_token.pos;
  v17 = *(_DWORD *)&s->prev_token.token;
  p_token->line = s->prev_token.line;
  p_token->column = v15;
  p_token->pos = v16;
  *(_DWORD *)&p_token->token = v17;
  if ( (token & 0xF7) == 35 )
  {
    strbuffer_init(&strbuff);
    do
    {
      v28 = (unsigned __int8 **)ap->__ap;
      ap->__ap = (char *)ap->__ap + 4;
      v19 = *v28;
      if ( !*v28 )
      {
        set_error(s, "<args>", "NULL string argument");
        strbuffer_close(&strbuff);
        return v19;
      }
      next_token(s);
      if ( s->token.token == 35 )
      {
        v27 = *(_DWORD *)ap->__ap;
        ap->__ap = (char *)ap->__ap + 4;
      }
      else
      {
        v21 = p_token->column;
        v22 = p_token->pos;
        v23 = *(_DWORD *)&p_token->token;
        p_next_token->line = p_token->line;
        p_next_token->column = v21;
        p_next_token->pos = v22;
        *(_DWORD *)&p_next_token->token = v23;
        v24 = s->prev_token.column;
        v25 = s->prev_token.pos;
        v26 = *(_DWORD *)&s->prev_token.token;
        p_token->line = p_prev_token->line;
        p_token->column = v24;
        p_token->pos = v25;
        *(_DWORD *)&p_token->token = v26;
        v27 = strlen((const char *)v19);
      }
      if ( strbuffer_append_bytes(&strbuff, v19, v27) == -1 )
      {
        v19 = 0;
        set_error(s, "<internal>", "Out of memory");
        strbuffer_close(&strbuff);
        return v19;
      }
      next_token(s);
    }
    while ( s->token.token == 43 );
    v29 = p_token->column;
    v30 = p_token->pos;
    v31 = *(_DWORD *)&p_token->token;
    p_next_token->line = p_token->line;
    p_next_token->column = v29;
    p_next_token->pos = v30;
    *(_DWORD *)&p_next_token->token = v31;
    v32 = s->prev_token.column;
    v33 = s->prev_token.pos;
    v34 = *(_DWORD *)&s->prev_token.token;
    p_token->line = p_prev_token->line;
    p_token->column = v32;
    p_token->pos = v33;
    *(_DWORD *)&p_token->token = v34;
    v19 = strbuffer_steal_value(&strbuff);
    if ( !utf8_check_string(v19, -1) )
      goto LABEL_15;
    *ours = 1;
  }
  else
  {
    v18 = (const unsigned __int8 **)ap->__ap;
    ap->__ap = (char *)ap->__ap + 4;
    v19 = (unsigned __int8 *)*v18;
    if ( *v18 )
    {
      if ( utf8_check_string(*v18, -1) )
      {
        *ours = 0;
      }
      else
      {
LABEL_15:
        v19 = 0;
        set_error(s, "<args>", "Invalid UTF-8 %s", (const char *)purpose);
      }
    }
    else
    {
      set_error(s, "<args>", "NULL string argument");
    }
  }
  return v19;
}

//----- (0003C044) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__fastcall pack(scanner_t *s, va_list *ap)
{
  va_list *v3; // r1
  va_list *v4; // r5
  json_t_0 *v5; // r6
  int token; // r3
  scanner_t *v7; // r0
  json_t_0 *v8; // r3
  _DWORD *v10; // r1
  json_int_t *v11; // r3
  json_int_t v12; // r0
  json_t_0 ***v13; // r1
  json_t_0 **v14; // r3
  size_t refcount; // r3
  json_t_0 *v16; // r3
  size_t v17; // r3
  size_t v18; // r3
  _DWORD **v19; // r1
  _DWORD *v21; // r1
  _DWORD **v22; // r1
  int v23; // r2
  json_t_0 ***v24; // r1
  json_t_0 **v25; // r3
  va_list *v26; // r1
  unsigned __int8 *string; // r0
  json_t_0 *v28; // r0
  unsigned __int8 *str; // [sp+0h] [bp-18h] BYREF
  int ours[5]; // [sp+4h] [bp-14h] BYREF

  v4 = v3;
  switch ( s->token.token )
  {
    case 'I':
      v11 = (json_int_t *)((*v10 + 7) & 0xFFFFFFF8);
      v12 = *v11;
      v4->__ap = v11 + 1;
      return json_integer(v12);
    case 'O':
      v14 = (*v13)++;
      v5 = *v14;
      if ( *v14 )
      {
        refcount = v5->refcount;
        if ( refcount != -1 )
          v5->refcount = refcount + 1;
      }
      return v5;
    case '[':
      v5 = (json_t_0 *)json_array();
      while ( 1 )
      {
        next_token(s);
        if ( s->token.token == 93 )
          return v5;
        v7 = s;
        if ( !s->token.token )
          goto LABEL_22;
        v16 = pack(s, v4);
        if ( !v16 )
          goto LABEL_23;
        if ( json_array_append_new(v5, v16) )
        {
          set_error(s, "<internal>", "Unable to append to array");
          goto LABEL_23;
        }
      }
    case 'b':
      if ( *(*v19)++ )
        return json_true();
      else
        return json_false();
    case 'f':
      *v21 = ((*v21 + 7) & 0xFFFFFFF8) + 8;
      return json_real(*(double *)&s);
    case 'i':
      v23 = *(*v22)++;
      return json_integer(v23);
    case 'n':
      return json_null();
    case 'o':
      v25 = (*v24)++;
      return *v25;
    case 's':
      string = read_string(s, v26, "string", ours);
      v5 = (json_t_0 *)string;
      str = string;
      if ( string )
      {
        v5 = json_string_nocheck(string);
        if ( ours[0] )
          jsonp_free((void **)&str);
      }
      return v5;
    case '{':
      v5 = (json_t_0 *)json_object();
      break;
    default:
      v5 = 0;
      set_error(s, "<format>", "Unexpected format character '%c'", s->token.token);
      return v5;
  }
  while ( 1 )
  {
    next_token(s);
    token = s->token.token;
    if ( token == 125 )
      return v5;
    v7 = s;
    if ( !s->token.token )
    {
LABEL_22:
      set_error(v7, "<format>", "Unexpected end of format string");
LABEL_23:
      if ( !v5 )
        return 0;
      v17 = v5->refcount;
      if ( v17 == -1 )
        return 0;
      v18 = v17 - 1;
      v5->refcount = v18;
      if ( v18 )
        return 0;
      v28 = v5;
      v5 = 0;
      json_delete(v28);
      return v5;
    }
    if ( token != 115 )
    {
      set_error(s, "<format>", "Expected format 's', got '%c'", token);
      goto LABEL_23;
    }
    str = read_string(s, v4, "object key", ours);
    if ( !str )
      goto LABEL_23;
    next_token(s);
    v8 = pack(s, v4);
    if ( !v8 )
      goto LABEL_23;
    if ( json_object_set_new_nocheck(v5, str, v8) )
    {
      if ( ours[0] )
        jsonp_free((void **)&str);
      set_error(s, "<internal>", "Unable to add key \"%s\"", (const char *)str);
      goto LABEL_23;
    }
    if ( ours[0] )
      jsonp_free((void **)&str);
  }
}
// 3C044: variables would overlap: r0.4 and r0.8

//----- (0003C294) --------------------------------------------------------
json_t_0 *__fastcall json_vpack_ex(json_error_t *error, size_t flags, const unsigned __int8 *fmt, va_list ap)
{
  json_t_0 *v8; // r4
  size_t refcount; // r3
  size_t v11; // r3
  va_list ap_copy; // [sp+8h] [bp-68h] BYREF
  scanner_t s; // [sp+Ch] [bp-64h] BYREF

  if ( fmt && *fmt )
  {
    jsonp_error_init(error, 0);
    memset(&s.prev_token, 0, 48);
    s.column = 0;
    s.pos = 0;
    s.line = 1;
    s.error = error;
    s.flags = flags;
    s.start = fmt;
    s.fmt = fmt;
    next_token(&s);
    ap_copy.__ap = ap.__ap;
    v8 = pack(&s, &ap_copy);
    if ( v8 )
    {
      next_token(&s);
      if ( s.token.token )
      {
        refcount = v8->refcount;
        if ( refcount != -1 )
        {
          v11 = refcount - 1;
          v8->refcount = v11;
          if ( !v11 )
            json_delete(v8);
        }
        v8 = 0;
        set_error(&s, "<format>", "Garbage after format string");
      }
    }
  }
  else
  {
    jsonp_error_init(error, "<format>");
    v8 = 0;
    jsonp_error_set(error, -1, -1, 0, "NULL or empty format string");
  }
  return v8;
}

//----- (0003C350) --------------------------------------------------------
json_t_0 *json_pack_ex(json_error_t *error, size_t flags, const unsigned __int8 *a3, ...)
{
  va_list varg_r3; // [sp+14h] [bp-4h] BYREF

  va_start(varg_r3, a3);
  return json_vpack_ex(error, flags, a3, varg_r3);
}

//----- (0003C370) --------------------------------------------------------
json_t_0 *json_pack(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, fmt);
  return json_vpack_ex(0, 0, fmt, varg_r1);
}

//----- (0003C394) --------------------------------------------------------
int __fastcall json_vunpack_ex(
        json_t_0 *root,
        json_error_t *error,
        size_t flags,
        const unsigned __int8 *fmt,
        va_list ap)
{
  int result; // r0
  va_list ap_copy; // [sp+8h] [bp-68h] BYREF
  scanner_t s; // [sp+Ch] [bp-64h] BYREF

  if ( !root )
  {
    jsonp_error_init(error, "<root>");
    jsonp_error_set(error, -1, -1, 0, "NULL root value");
    return -1;
  }
  if ( !fmt || !*fmt )
  {
    jsonp_error_init(error, "<format>");
    jsonp_error_set(error, -1, -1, 0, "NULL or empty format string");
    return -1;
  }
  jsonp_error_init(error, 0);
  s.line = 1;
  s.error = error;
  s.flags = flags;
  s.start = fmt;
  s.fmt = fmt;
  memset(&s.prev_token, 0, 48);
  s.column = 0;
  s.pos = 0;
  next_token(&s);
  ap_copy.__ap = ap.__ap;
  if ( unpack(&s, root, &ap_copy) )
    return -1;
  next_token(&s);
  result = s.token.token;
  if ( s.token.token )
  {
    set_error(&s, "<format>", "Garbage after format string");
    return -1;
  }
  return result;
}

//----- (0003C470) --------------------------------------------------------
int json_unpack_ex(json_t_0 *root, json_error_t *error, size_t flags, const unsigned __int8 *a4, ...)
{
  va_list va; // [sp+20h] [bp+0h] BYREF

  va_start(va, a4);
  return json_vunpack_ex(root, error, flags, a4, va);
}

//----- (0003C490) --------------------------------------------------------
int json_unpack(json_t_0 *root, const unsigned __int8 *a2, ...)
{
  va_list varg_r2; // [sp+20h] [bp-8h] BYREF

  va_start(varg_r2, a2);
  return json_vunpack_ex(root, 0, 0, a2, varg_r2);
}

//----- (0003C4B4) --------------------------------------------------------
int __fastcall strbuffer_init(strbuffer_t *strbuff)
{
  unsigned __int8 *v2; // r0

  strbuff->size = 4096;
  strbuff->length = 0;
  v2 = (unsigned __int8 *)jsonp_malloc(0x1000u);
  strbuff->value = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (0003C4D8) --------------------------------------------------------
void __fastcall strbuffer_close(strbuffer_t *strbuff)
{
  if ( strbuff->value )
    jsonp_free((void **)&strbuff->value);
  strbuff->size = 0;
  strbuff->length = 0;
  strbuff->value = 0;
}

//----- (0003C4F0) --------------------------------------------------------
void __fastcall strbuffer_clear(strbuffer_t *strbuff)
{
  unsigned __int8 *value; // r2

  value = strbuff->value;
  strbuff->length = 0;
  *value = 0;
}

//----- (0003C4FC) --------------------------------------------------------
const unsigned __int8 *__fastcall strbuffer_value(const strbuffer_t *strbuff)
{
  return strbuff->value;
}

//----- (0003C500) --------------------------------------------------------
unsigned __int8 *__fastcall strbuffer_steal_value(strbuffer_t *strbuff)
{
  unsigned __int8 *result; // r0

  result = strbuff->value;
  strbuff->value = 0;
  return result;
}

//----- (0003C50C) --------------------------------------------------------
int __fastcall strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size)
{
  signed int v5; // r2
  size_t length; // r0
  unsigned __int8 *value; // r3
  unsigned int v9; // r2
  size_t v10; // r6
  int i; // r4
  __useconds_t v12; // r0
  unsigned __int8 *v13; // r1
  int result; // r0
  size_t v15; // r3

  v5 = strbuff->size;
  length = strbuff->length;
  if ( size + 2 <= v5 - length )
  {
    value = strbuff->value;
LABEL_12:
    memcpy(&value[length], data, size);
    v13 = strbuff->value;
    result = 0;
    v15 = strbuff->length + size;
    strbuff->length = v15;
    v13[v15] = 0;
    return result;
  }
  if ( v5 >= 0 && size != -1 && length <= -2 - size )
  {
    v9 = 2 * v5;
    v10 = length + 1 + size;
    if ( v10 < v9 )
      v10 = v9;
    for ( i = 1; ; i *= 2 )
    {
      value = (unsigned __int8 *)realloc(strbuff->value, v10);
      v12 = 1000 * i;
      if ( value )
        break;
      usleep(v12);
    }
    length = strbuff->length;
    strbuff->value = value;
    strbuff->size = v10;
    goto LABEL_12;
  }
  return -1;
}

//----- (0003C598) --------------------------------------------------------
int __fastcall strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte)
{
  unsigned __int8 v3; // [sp+7h] [bp-9h] BYREF

  v3 = byte;
  return strbuffer_append_bytes(strbuff, &v3, 1u);
}

//----- (0003C5B0) --------------------------------------------------------
int __fastcall strbuffer_append(strbuffer_t *strbuff, const unsigned __int8 *string)
{
  size_t v4; // r0

  v4 = strlen((const char *)string);
  return strbuffer_append_bytes(strbuff, string, v4);
}

//----- (0003C5CC) --------------------------------------------------------
unsigned __int8 __fastcall strbuffer_pop(strbuffer_t *strbuff)
{
  size_t length; // r3
  unsigned __int8 *value; // r1
  unsigned __int8 result; // r0

  length = strbuff->length;
  if ( !length )
    return 0;
  value = strbuff->value;
  strbuff->length = length - 1;
  result = value[length - 1];
  value[length - 1] = 0;
  return result;
}

//----- (0003C5E4) --------------------------------------------------------
void __fastcall jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source)
{
  bool v2; // zf
  size_t v5; // r0

  v2 = error == 0;
  if ( error )
    v2 = source == 0;
  if ( !v2 )
  {
    v5 = strlen((const char *)source);
    if ( v5 <= 0x4F )
    {
      j_memcpy(error->source, source, v5 + 1);
    }
    else
    {
      strcpy((char *)error->source, "...");
      j_strcpy((char *)&error->source[3], (const char *)&source[v5 - 76]);
    }
  }
}

//----- (0003C62C) --------------------------------------------------------
void __fastcall jsonp_error_init(json_error_t *error, const unsigned __int8 *source)
{
  if ( error )
  {
    error->text[0] = 0;
    error->position = 0;
    error->line = -1;
    error->column = -1;
    if ( source )
      jsonp_error_set_source(error, source);
    else
      error->source[0] = 0;
  }
}

//----- (0003C654) --------------------------------------------------------
void __fastcall jsonp_error_vset(
        json_error_t *error,
        int line,
        int column,
        size_t position,
        const unsigned __int8 *msg,
        va_list ap)
{
  if ( error )
  {
    if ( !error->text[0] )
    {
      error->line = line;
      error->column = column;
      error->position = position;
      vsnprintf((char *)error->text, 0xA0u, (const char *)msg, ap);
      error->text[159] = 0;
    }
  }
}

//----- (0003C678) --------------------------------------------------------
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...)
{
  va_list va; // [sp+24h] [bp+4h] BYREF

  va_start(va, msg);
  jsonp_error_vset(error, line, column, position, msg, va);
}

//----- (0003C690) --------------------------------------------------------
int __fastcall jsonp_strtod(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-1Ch] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail(
      "end == strbuffer->value + strbuffer->length",
      "compat/jansson-2.6/src/strconv.c",
      0x45u,
      "jsonp_strtod");
  if ( (v2 > 1.79769313e308 || v2 < -1.79769313e308) && *v9 == 34 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 3C6DE: variable 'v2' is possibly undefined

//----- (0003C734) --------------------------------------------------------
int __fastcall jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value)
{
  double v3; // d0
  int v6; // r0
  int v7; // r4
  int v8; // r6
  int v9; // r1
  char *v10; // r0
  char *v11; // r0
  char *v12; // r4
  char *v13; // r7
  char *v14; // r3
  unsigned __int8 *v15; // r2

  v6 = snprintf((char *)buffer, size, "%.17g", v3);
  v7 = v6;
  if ( v6 >= 0 )
  {
    v8 = v6;
    if ( size > v6 )
    {
      v9 = *localeconv()->decimal_point;
      if ( v9 != 46 )
      {
        v10 = strchr((const char *)buffer, v9);
        if ( v10 )
          *v10 = 46;
      }
      if ( strchr((const char *)buffer, 46) )
      {
LABEL_7:
        v11 = strchr((const char *)buffer, 101);
        if ( !v11 )
          return v8;
LABEL_8:
        v12 = v11 + 2;
        if ( v11[1] == 45 )
          v13 = v11 + 2;
        else
          v13 = v11 + 1;
        if ( v11[2] == 48 )
        {
          v14 = v11 + 3;
          do
            v12 = v14++;
          while ( *v12 == 48 );
        }
        if ( v12 != v13 )
        {
          v15 = (unsigned __int8 *)(buffer - (unsigned __int8 *)v12 + v8);
          v8 += v13 - v12;
          memmove(v13, v12, (size_t)v15);
        }
        return v8;
      }
      v11 = strchr((const char *)buffer, 101);
      if ( v11 )
        goto LABEL_8;
      if ( size > v7 + 3 )
      {
        v8 = v7 + 2;
        buffer[v7] = 46;
        buffer[v7 + 1] = 48;
        buffer[v7 + 2] = 0;
        goto LABEL_7;
      }
    }
  }
  return -1;
}
// 3C742: variable 'v3' is possibly undefined

//----- (0003C7E0) --------------------------------------------------------
void __fastcall json_object_seed(size_t seed)
{
  if ( !hashtable_seed )
  {
    if ( !seed )
    {
      seed = time(0);
      if ( !seed )
        seed = 1;
    }
    hashtable_seed = seed;
  }
}

//----- (0003C800) --------------------------------------------------------
int __fastcall get(void *data)
{
  int v1; // r2
  int result; // r0

  v1 = *((_DWORD *)data + 1);
  result = *(unsigned __int8 *)(*(_DWORD *)data + v1);
  if ( !result )
    return -1;
  *((_DWORD *)data + 1) = v1 + 1;
  return result;
}

//----- (0003C818) --------------------------------------------------------
int __fastcall buffer_get(void *data)
{
  unsigned int v1; // r3
  unsigned int v2; // r1
  int v3; // r3

  v1 = *((_DWORD *)data + 2);
  if ( v1 >= *((_DWORD *)data + 1) )
    return -1;
  v2 = v1 + 1;
  v3 = *(unsigned __int8 *)(*(_DWORD *)data + v1);
  *((_DWORD *)data + 2) = v2;
  return v3;
}

//----- (0003C834) --------------------------------------------------------
int __fastcall callback_get(void *data)
{
  unsigned int v1; // r3
  int result; // r0
  int (__fastcall *v4)(void *, int, _DWORD); // r3
  int v5; // r0

  v1 = *((_DWORD *)data + 257);
  if ( v1 < *((_DWORD *)data + 256) )
    goto LABEL_2;
  v4 = (int (__fastcall *)(void *, int, _DWORD))*((_DWORD *)data + 258);
  *((_DWORD *)data + 257) = 0;
  v5 = v4(data, 1024, *((_DWORD *)data + 259));
  *((_DWORD *)data + 256) = v5;
  if ( (unsigned int)(v5 - 1) <= 0xFFFFFFFD )
  {
    v1 = *((_DWORD *)data + 257);
LABEL_2:
    result = *((unsigned __int8 *)data + v1);
    *((_DWORD *)data + 257) = v1 + 1;
    return result;
  }
  return -1;
}

//----- (0003C878) --------------------------------------------------------
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *a3, ...)
{
  const unsigned __int8 *v5; // r0
  int line; // r9
  int column; // r6
  size_t position; // r8
  unsigned __int8 *v9; // r3
  unsigned __int8 msg_text[160]; // [sp+1Ch] [bp-168h] BYREF
  unsigned __int8 msg_with_context[160]; // [sp+BCh] [bp-C8h] BYREF
  const unsigned __int8 *msga; // [sp+17Ch] [bp-8h]
  va_list varg_r3; // [sp+180h] [bp-4h] BYREF

  va_start(varg_r3, a3);
  msga = a3;
  if ( error )
  {
    vsnprintf((char *)msg_text, 0xA0u, (const char *)msga, varg_r3);
    msg_text[159] = 0;
    if ( lex )
    {
      v5 = strbuffer_value(&lex->saved_text);
      line = lex->stream.line;
      column = lex->stream.column;
      position = lex->stream.position;
      if ( v5 && *v5 )
      {
        if ( lex->saved_text.length <= 0x14 )
        {
          snprintf((char *)msg_with_context, 0xA0u, "%s near '%s'", (const char *)msg_text, (const char *)v5);
          v9 = msg_with_context;
          msg_with_context[159] = 0;
        }
        else
        {
          v9 = msg_text;
        }
      }
      else
      {
        v9 = msg_text;
        if ( lex->stream.state != -2 )
        {
          snprintf((char *)msg_with_context, 0xA0u, "%s near end of file", (const char *)msg_text);
          v9 = msg_with_context;
          msg_with_context[159] = 0;
        }
      }
    }
    else
    {
      column = -1;
      v9 = msg_text;
      position = 0;
      line = -1;
    }
    jsonp_error_set(error, line, column, position, (const unsigned __int8 *)"%s", (const char *)v9);
  }
}

//----- (0003C928) --------------------------------------------------------
int __fastcall lex_init(lex_t *lex, get_func get, void *data)
{
  int result; // r0

  lex->stream.get = get;
  lex->stream.data = data;
  lex->stream.line = 1;
  lex->stream.buffer[0] = 0;
  lex->stream.buffer_pos = 0;
  lex->stream.state = 0;
  lex->stream.column = 0;
  lex->stream.position = 0;
  result = strbuffer_init(&lex->saved_text);
  if ( result )
    return -1;
  lex->token = -1;
  return result;
}

//----- (0003C958) --------------------------------------------------------
void __fastcall lex_close(lex_t *lex)
{
  if ( lex->token == 256 )
    jsonp_free((void **)&lex->value.string);
  strbuffer_close(&lex->saved_text);
}

//----- (0003C978) --------------------------------------------------------
int __fastcall decode_unicode_escape(_BYTE *a1)
{
  int v1; // r1
  int i; // r3
  int v3; // r2
  int v4; // r5
  int v5; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "compat/jansson-2.6/src/load.c", 0x120u, "decode_unicode_escape");
  v1 = 0;
  for ( i = 1; i != 5; ++i )
  {
    v3 = (unsigned __int8)a1[i];
    v4 = 16 * v1;
    v5 = v3 - 48;
    if ( (unsigned __int8)(v3 - 48) <= 9u )
      goto LABEL_7;
    if ( (unsigned int)(v3 - 97) <= 0x19 )
    {
      v5 = v3 - 87;
LABEL_7:
      v1 = v5 + v4;
      continue;
    }
    if ( (unsigned int)(v3 - 65) > 0x19 )
      _assert_fail(word_4E82C, "compat/jansson-2.6/src/load.c", 0x12Cu, "decode_unicode_escape");
    v1 = v3 - 55 + v4;
  }
  return v1;
}

//----- (0003C9E8) --------------------------------------------------------
_DWORD *__fastcall stream_unget(_DWORD *result, int a2)
{
  _DWORD *v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r3

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      v6 = result[8];
      --result[6];
      result[7] = v6;
    }
    else
    {
      result = (_DWORD *)utf8_check_first(a2);
      if ( result )
        --v3[7];
    }
    v4 = v3[4];
    if ( !v4 )
      _assert_fail("stream->buffer_pos > 0", "compat/jansson-2.6/src/load.c", 0xE0u, "stream_unget");
    v5 = v4 - 1;
    v3[4] = v5;
    if ( *((unsigned __int8 *)v3 + v5 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "compat/jansson-2.6/src/load.c", 0xE2u, "stream_unget");
  }
  return result;
}

//----- (0003CA54) --------------------------------------------------------
int __fastcall stream_get(const lex_t *a1, json_error_t *a2)
{
  int state; // r5
  size_t buffer_pos; // r3
  char *v6; // r2
  int v7; // r3
  int v8; // r0
  size_t position; // r1
  int result; // r0
  int line; // r2
  int column; // r3
  int v13; // r7
  int v14; // r0
  int v15; // r8
  const lex_t *v16; // r5
  const lex_t *v17; // r9
  size_t v18; // r3
  char *v19; // r2

  state = a1->stream.state;
  if ( state )
    return state;
  buffer_pos = a1->stream.buffer_pos;
  v6 = (char *)a1 + buffer_pos;
  v7 = buffer_pos + 1;
  v8 = (unsigned __int8)v6[8];
  if ( !v6[8] )
  {
    v8 = a1->stream.get(a1->stream.data);
    v13 = v8;
    if ( v8 == -1 )
    {
      a1->stream.state = -1;
      return -1;
    }
    else
    {
      v8 = (unsigned __int8)v8;
      a1->stream.buffer_pos = 0;
      a1->stream.buffer[0] = v8;
      if ( (unsigned int)(v13 - 128) > 0x7F )
      {
        v7 = 1;
        a1->stream.buffer[1] = 0;
        goto LABEL_3;
      }
      v14 = utf8_check_first(v8);
      v15 = v14;
      if ( v14 )
      {
        if ( v14 <= 1 )
          _assert_fail("count >= 2", "compat/jansson-2.6/src/load.c", 0xAFu, "stream_get");
        v16 = a1;
        v17 = (const lex_t *)((char *)&a1->value.real + v14 - 57);
        do
        {
          v16->stream.buffer[1] = a1->stream.get(a1->stream.data);
          v16 = (const lex_t *)((char *)v16 + 1);
        }
        while ( v16 != v17 );
        if ( utf8_check_full(a1->stream.buffer, v15, 0) )
        {
          v18 = a1->stream.buffer_pos;
          a1->stream.buffer[v15] = 0;
          v19 = (char *)a1 + v18;
          v7 = v18 + 1;
          v8 = (unsigned __int8)v19[8];
          goto LABEL_3;
        }
      }
      state = -2;
      a1->stream.state = -2;
      error_set(a2, a1, "unable to decode byte 0x%x", v13);
    }
    return state;
  }
LABEL_3:
  position = a1->stream.position;
  state = v8;
  a1->stream.buffer_pos = v7;
  a1->stream.position = position + 1;
  if ( v8 != 10 )
  {
    if ( utf8_check_first(v8) )
      ++a1->stream.column;
    return state;
  }
  line = a1->stream.line;
  column = a1->stream.column;
  result = 10;
  a1->stream.column = 0;
  a1->stream.line = line + 1;
  a1->stream.last_column = column;
  return result;
}

//----- (0003CB3C) --------------------------------------------------------
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2)
{
  _DWORD *v3; // r5

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    stream_unget(result, a2);
    result = (_DWORD *)strbuffer_pop((strbuffer_t *)(v3 + 10));
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "compat/jansson-2.6/src/load.c", 0x10Cu, "lex_unget_unsave");
  }
  return result;
}

//----- (0003CB74) --------------------------------------------------------
int __fastcall lex_get_save(lex_t *lex, json_error_t *error)
{
  int v3; // r4

  v3 = stream_get(lex, error);
  if ( (unsigned int)(v3 + 2) > 1 )
    strbuffer_append_byte(&lex->saved_text, v3);
  return v3;
}

//----- (0003CB94) --------------------------------------------------------
int __fastcall lex_scan(lex_t *lex, json_error_t *error)
{
  strbuffer_t *p_saved_text; // r7
  int v5; // r0
  bool v6; // zf
  unsigned int save; // r4
  bool v8; // zf
  bool v9; // zf
  bool v10; // zf
  bool v11; // zf
  bool v12; // cc
  int v13; // r1
  size_t v14; // r3
  size_t v15; // r2
  int v17; // r0
  const unsigned __int8 *v18; // r4
  int v19; // r0
  bool v20; // zf
  const unsigned __int8 *v21; // r4
  int *v22; // r7
  __int64 v23; // r2
  lex_t *v24; // r0
  json_error_t *v25; // r1
  unsigned int v26; // r4
  int v27; // r0
  bool v28; // zf
  bool v29; // zf
  bool v30; // zf
  json_int_t v31; // d7
  bool v32; // zf
  int v33; // r8
  bool v34; // cc
  unsigned __int8 *v35; // r8
  const unsigned __int8 *i; // r7
  int v37; // r2
  unsigned int v38; // r2
  int v39; // r0
  int v40; // r1
  int32_t v41; // r2
  _BYTE *v42; // r0
  int v43; // r0
  int v44; // r0
  int v45; // [sp+8h] [bp-48h]
  int32_t v46; // [sp+Ch] [bp-44h]
  unsigned __int8 buffer[4]; // [sp+14h] [bp-3Ch] BYREF
  int size; // [sp+18h] [bp-38h] BYREF
  char *endptr; // [sp+1Ch] [bp-34h] BYREF
  json_int_t v50; // [sp+20h] [bp-30h] BYREF

  p_saved_text = &lex->saved_text;
  strbuffer_clear(&lex->saved_text);
  if ( lex->token == 256 )
  {
    jsonp_free((void **)&lex->value.string);
    lex->value.string = 0;
  }
  while ( 1 )
  {
    v5 = stream_get(lex, error);
    v6 = v5 == 32;
    if ( v5 != 32 )
      v6 = v5 == 9;
    save = v5;
    if ( !v6 )
    {
      v8 = v5 == 10;
      if ( v5 != 10 )
        v8 = v5 == 13;
      if ( !v8 )
        break;
    }
  }
  if ( v5 == -1 )
  {
    lex->token = 0;
    return 0;
  }
  if ( v5 == -2 )
  {
LABEL_33:
    save = -1;
LABEL_34:
    lex->token = save;
    return save;
  }
  strbuffer_append_byte(p_saved_text, v5);
  v9 = save == 123;
  if ( save != 123 )
    v9 = save == 125;
  if ( v9 )
    goto LABEL_34;
  v10 = save == 91;
  if ( save != 91 )
    v10 = save == 93;
  if ( v10 )
    goto LABEL_34;
  v11 = save == 58;
  if ( save != 58 )
    v11 = save == 44;
  if ( v11 )
    goto LABEL_34;
  if ( save != 34 )
  {
    v12 = save > 0x2D;
    if ( save != 45 )
      v12 = save - 48 > 9;
    if ( !v12 )
    {
      lex->token = -1;
      if ( save == 45 )
        save = lex_get_save(lex, error);
      if ( save == 48 )
      {
        v19 = lex_get_save(lex, error);
        if ( (unsigned int)(v19 - 48) <= 9 )
          goto LABEL_96;
      }
      else
      {
        if ( save - 48 > 9 )
        {
          lex_unget_unsave(lex, save);
          return lex->token;
        }
        do
          v19 = lex_get_save(lex, error);
        while ( (unsigned int)(v19 - 48) <= 9 );
      }
      v20 = v19 == 69;
      if ( v19 != 69 )
        v20 = v19 == 46;
      if ( v20 )
      {
        if ( v19 == 46 )
        {
          v44 = stream_get(lex, error);
          if ( (unsigned int)(v44 - 48) > 9 )
          {
            stream_unget(lex, v44);
            return lex->token;
          }
          strbuffer_append_byte(p_saved_text, v44);
          do
            v19 = lex_get_save(lex, error);
          while ( (unsigned int)(v19 - 48) <= 9 );
        }
        if ( (v19 & 0xFFFFFFDF) != 69 )
          goto LABEL_77;
      }
      else if ( v19 != 101 )
      {
        lex_unget_unsave(lex, v19);
        v21 = strbuffer_value(p_saved_text);
        v22 = _errno_location();
        *v22 = 0;
        v23 = strtoll((const char *)v21, &endptr, 10);
        if ( *v22 == 34 )
        {
          if ( v23 >= 0 )
            error_set(error, lex, "too big integer");
          else
            error_set(error, lex, "too big negative integer");
          return lex->token;
        }
        else
        {
          if ( endptr != (char *)&v21[lex->saved_text.length] )
            _assert_fail(
              "end == saved_text + lex->saved_text.length",
              "compat/jansson-2.6/src/load.c",
              0x206u,
              "lex_scan_number");
          save = 257;
          lex->value.integer = v23;
          lex->token = 257;
        }
        return save;
      }
      v19 = lex_get_save(lex, error);
      v32 = v19 == 43;
      if ( v19 != 43 )
        v32 = v19 == 45;
      if ( v32 )
        v19 = lex_get_save(lex, error);
      if ( (unsigned int)(v19 - 48) <= 9 )
      {
        do
          v19 = lex_get_save(lex, error);
        while ( (unsigned int)(v19 - 48) <= 9 );
LABEL_77:
        lex_unget_unsave(lex, v19);
        if ( jsonp_strtod((int)p_saved_text, (double *)&v50) )
        {
          error_set(error, lex, "real number overflow");
          return lex->token;
        }
        else
        {
          v31 = v50;
          save = 258;
          lex->token = 258;
          lex->value.integer = v31;
        }
        return save;
      }
LABEL_96:
      lex_unget_unsave(lex, v19);
      return lex->token;
    }
    if ( (save & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v17 = lex_get_save(lex, error);
      while ( (v17 & 0xFFFFFFDF) - 65 <= 0x19 );
      lex_unget_unsave(lex, v17);
      v18 = strbuffer_value(p_saved_text);
      if ( !strcmp((const char *)v18, "true") )
      {
        save = 259;
        lex->token = 259;
        return save;
      }
      if ( !strcmp((const char *)v18, "false") )
      {
        save = 260;
        lex->token = 260;
        return save;
      }
      if ( !strcmp((const char *)v18, "null") )
      {
        save = 261;
        lex->token = 261;
        return save;
      }
    }
    else
    {
      LOBYTE(v13) = lex->stream.buffer[lex->stream.buffer_pos];
      if ( (_BYTE)v13 )
      {
        do
        {
          strbuffer_append_byte(p_saved_text, v13);
          v14 = lex->stream.buffer_pos + 1;
          v15 = lex->stream.position + 1;
          v13 = lex->stream.buffer[v14];
          lex->stream.buffer_pos = v14;
          lex->stream.position = v15;
        }
        while ( v13 );
      }
    }
    goto LABEL_33;
  }
  lex->value.string = 0;
  lex->token = -1;
LABEL_55:
  v24 = lex;
  v25 = error;
  while ( 1 )
  {
    v26 = lex_get_save(v24, v25);
LABEL_57:
    if ( v26 == 34 )
    {
      v35 = (unsigned __int8 *)jsonp_malloc(lex->saved_text.length + 1);
      lex->value.string = v35;
      if ( !v35 )
        goto LABEL_74;
      for ( i = strbuffer_value(p_saved_text) + 1; ; i += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v37 = *i;
            if ( v37 == 34 )
            {
              *v35 = 0;
              save = 256;
              lex->token = 256;
              return save;
            }
            if ( v37 == 92 )
              break;
            ++i;
            *v35++ = v37;
          }
          v38 = i[1];
          if ( v38 != 117 )
            break;
          v39 = decode_unicode_escape((_BYTE *)i + 1);
          v40 = v39 - 55296;
          v41 = v39;
          if ( (unsigned int)(v39 - 55296) > 0x3FF )
          {
            if ( (unsigned int)(v39 - 56320) <= 0x3FF )
              goto LABEL_143;
            if ( !v39 )
            {
              error_set(error, lex, "\\u0000 is not allowed");
              goto LABEL_74;
            }
            i += 6;
          }
          else
          {
            if ( i[6] != 92 || i[7] != 117 )
            {
LABEL_143:
              error_set(error, lex, "invalid Unicode '\\u%04X'", v39);
              goto LABEL_74;
            }
            v42 = i + 7;
            v45 = v40;
            v46 = v41;
            i += 12;
            v43 = decode_unicode_escape(v42);
            if ( (unsigned int)(v43 - 56320) > 0x3FF )
            {
              error_set(error, lex, "invalid Unicode '\\u%04X\\u%04X'", v46, v43);
              goto LABEL_74;
            }
            v41 = v43 - 56320 + (v45 << 10) + 0x10000;
          }
          if ( utf8_encode(v41, buffer, &size) )
            _assert_fail(word_4E82C, "compat/jansson-2.6/src/load.c", 0x1AEu, "lex_scan_string");
          memcpy(v35, buffer, size);
          v35 += size;
        }
        if ( v38 == 102 )
        {
          *v35 = 12;
          goto LABEL_122;
        }
        if ( v38 > 0x66 )
        {
          switch ( v38 )
          {
            case 'r':
              *v35 = 13;
              break;
            case 't':
              *v35 = 9;
              break;
            case 'n':
              *v35 = 10;
              break;
            default:
              goto LABEL_117;
          }
        }
        else
        {
          if ( v38 == 92 )
            goto LABEL_135;
          if ( v38 <= 0x5C )
          {
            if ( v38 != 34 && v38 != 47 )
LABEL_117:
              _assert_fail(word_4E82C, "compat/jansson-2.6/src/load.c", 0x1BCu, "lex_scan_string");
LABEL_135:
            *v35 = v38;
            goto LABEL_122;
          }
          if ( v38 != 98 )
            goto LABEL_117;
          *v35 = 8;
        }
LABEL_122:
        ++v35;
      }
    }
    if ( v26 == -2 )
      goto LABEL_74;
    if ( v26 == -1 )
    {
      error_set(error, lex, "premature end of input", 1);
      goto LABEL_74;
    }
    v24 = lex;
    if ( v26 <= 0x1F )
      break;
    v25 = error;
    if ( v26 == 92 )
    {
      v27 = lex_get_save(lex, error);
      if ( v27 == 117 )
      {
        v33 = 4;
        v26 = lex_get_save(lex, error);
        while ( 1 )
        {
          v34 = v26 - 65 > 5;
          if ( v26 - 65 > 5 )
            v34 = v26 - 48 > 9;
          if ( v34 && v26 - 97 > 5 )
            break;
          --v33;
          v26 = lex_get_save(lex, error);
          if ( !v33 )
            goto LABEL_57;
        }
LABEL_73:
        error_set(error, lex, "invalid escape");
        goto LABEL_74;
      }
      v28 = v27 == 34;
      if ( v27 != 34 )
        v28 = v27 == 92;
      if ( !v28 )
      {
        v29 = v27 == 47;
        if ( v27 != 47 )
          v29 = v27 == 98;
        if ( !v29 && (v27 & 0xFFFFFFF7) != 102 )
        {
          v30 = v27 == 114;
          if ( v27 != 114 )
            v30 = v27 == 116;
          if ( !v30 )
            goto LABEL_73;
        }
      }
      goto LABEL_55;
    }
  }
  lex_unget_unsave(lex, v26);
  if ( v26 == 10 )
    error_set(error, lex, "unexpected newline");
  else
    error_set(error, lex, "control character 0x%x", v26);
LABEL_74:
  jsonp_free((void **)&lex->value.string);
  return lex->token;
}
// 3CB94: using guessed type unsigned __int8 buffer[4];

//----- (0003D0C4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__fastcall parse_value(lex_t *lex, size_t flags, json_error_t *error)
{
  lex_t *v3; // r4
  int token; // r3
  size_t v5; // r1
  size_t v6; // r8
  json_t_0 *v8; // r7
  int v10; // r3
  unsigned __int8 *string; // r1
  json_t_0 *v12; // r0
  json_t_0 *v13; // r6
  size_t v14; // r3
  unsigned __int8 *v15; // r1
  size_t v16; // r3
  size_t v17; // r3
  int v18; // r3
  int v19; // r3
  size_t v20; // r3
  int v21; // r3
  json_t_0 *v22; // r0
  size_t v23; // r3
  size_t v24; // r3
  json_t_0 *v25; // r0
  char v26; // r1
  double v27; // r0
  size_t refcount; // r3
  size_t v29; // r3
  unsigned __int8 *key; // [sp+4h] [bp-2Ch] BYREF
  double value; // [sp+8h] [bp-28h] BYREF

  v3 = lex;
  token = lex->token;
  lex = (lex_t *)257;
  v6 = v5;
  if ( token != 257 )
  {
    if ( token > 257 )
    {
      if ( token == 259 )
        return json_true();
      if ( token < 259 )
        return json_real(*(double *)&lex);
      if ( token == 260 )
        return json_false();
      if ( token == 261 )
        return json_null();
LABEL_7:
      v8 = 0;
      error_set(error, v3, "unexpected token");
      return v8;
    }
    if ( token == 91 )
    {
      v8 = (json_t_0 *)json_array();
      if ( v8 )
      {
        lex_scan(v3, error);
        v19 = v3->token;
        if ( v19 == 93 )
          return v8;
        if ( v19 )
        {
          while ( 1 )
          {
            v22 = parse_value(v3, v6, error);
            v13 = v22;
            if ( !v22 )
              break;
            if ( v22->refcount != -1 )
              ++v22->refcount;
            if ( json_array_append_new(v8, v22) )
            {
              refcount = v13->refcount;
              if ( refcount != -1 )
              {
LABEL_60:
                v29 = refcount - 1;
                v13->refcount = v29;
                if ( !v29 )
                  json_delete(v13);
              }
              goto LABEL_49;
            }
            v20 = v13->refcount;
            if ( v20 != -1 )
            {
              v13->refcount = v20 - 1;
              if ( v20 == 1 )
                json_delete(v13);
            }
            lex_scan(v3, error);
            v21 = v3->token;
            if ( v21 != 44 )
            {
              if ( v21 == 93 )
                return v8;
              goto LABEL_63;
            }
            lex_scan(v3, error);
            if ( !v3->token )
              goto LABEL_63;
          }
        }
        else
        {
LABEL_63:
          error_set(error, v3, "']' expected");
        }
        goto LABEL_49;
      }
    }
    else
    {
      if ( token <= 91 )
      {
        if ( token == -1 )
        {
          v8 = 0;
          error_set(error, v3, "invalid token");
          return v8;
        }
        goto LABEL_7;
      }
      if ( token != 123 )
      {
        if ( token == 256 )
          return json_string_nocheck(v3->value.string);
        goto LABEL_7;
      }
      v8 = (json_t_0 *)json_object();
      if ( v8 )
      {
        lex_scan(v3, error);
        v10 = v3->token;
        if ( v10 == 125 )
          return v8;
        if ( v10 != 256 )
        {
LABEL_64:
          error_set(error, v3, "string or '}' expected");
          goto LABEL_49;
        }
        string = v3->value.string;
        v3->value.string = 0;
        key = string;
        if ( string )
        {
          while ( 1 )
          {
            if ( (v6 & 1) != 0 && json_object_get(v8, string) )
            {
              jsonp_free((void **)&key);
              error_set(error, v3, "duplicate object key");
              goto LABEL_49;
            }
            lex_scan(v3, error);
            if ( v3->token != 58 )
            {
              jsonp_free((void **)&key);
              error_set(error, v3, "':' expected");
              goto LABEL_49;
            }
            lex_scan(v3, error);
            v12 = parse_value(v3, v6, error);
            v13 = v12;
            if ( !v12 )
            {
              jsonp_free((void **)&key);
              goto LABEL_49;
            }
            v14 = v12->refcount;
            v15 = key;
            if ( v14 != -1 )
              v12->refcount = v14 + 1;
            if ( json_object_set_new_nocheck(v8, v15, v12) )
            {
              jsonp_free((void **)&key);
              refcount = v13->refcount;
              if ( refcount != -1 )
                goto LABEL_60;
              goto LABEL_49;
            }
            v16 = v13->refcount;
            if ( v16 != -1 )
            {
              v17 = v16 - 1;
              v13->refcount = v17;
              if ( !v17 )
                json_delete(v13);
            }
            jsonp_free((void **)&key);
            lex_scan(v3, error);
            v18 = v3->token;
            if ( v18 != 44 )
              break;
            lex_scan(v3, error);
            if ( v3->token != 256 )
              goto LABEL_64;
            string = v3->value.string;
            v3->value.string = 0;
            key = string;
            if ( !string )
              return 0;
          }
          if ( v18 == 125 )
            return v8;
          error_set(error, v3, "'}' expected");
LABEL_49:
          v23 = v8->refcount;
          if ( v23 != -1 )
          {
            v24 = v23 - 1;
            v8->refcount = v24;
            if ( !v24 )
            {
              v25 = v8;
              v8 = 0;
              json_delete(v25);
              return v8;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( (v26 & 8) == 0 )
    return json_integer(v3->value.integer);
  LODWORD(v27) = jsonp_strtod((int)&v3->saved_text, &value);
  if ( !LODWORD(v27) )
    return json_real(v27);
  v8 = 0;
  error_set(error, v3, "real number overflow");
  return v8;
}
// 3D0C4: variables would overlap: r0.4 and r0.8

//----- (0003D394) --------------------------------------------------------
json_t_0 *__fastcall parse_json(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t_0 *v6; // r7
  size_t refcount; // r3
  size_t v9; // r3
  json_t_0 *v10; // r0

  lex_scan(lex, error);
  v6 = (json_t_0 *)(flags & 4);
  if ( (flags & 4) == 0 && (lex->token & 0xFFFFFFDF) != 91 )
  {
    error_set(error, lex, "'[' or '{' expected");
    return v6;
  }
  v6 = parse_value(lex, flags, error);
  if ( !v6 )
    return 0;
  if ( (flags & 2) == 0 )
  {
    lex_scan(lex, error);
    if ( lex->token )
    {
      error_set(error, lex, "end of file expected");
      refcount = v6->refcount;
      if ( refcount != -1 )
      {
        v9 = refcount - 1;
        v6->refcount = v9;
        if ( !v9 )
        {
          v10 = v6;
          v6 = 0;
          json_delete(v10);
          return v6;
        }
      }
      return 0;
    }
  }
  if ( error )
    error->position = lex->stream.position;
  return v6;
}

//----- (0003D414) --------------------------------------------------------
json_t_0 *__fastcall json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error)
{
  json_t_0 *v6; // r6
  string_data_t stream_data; // [sp+0h] [bp-60h] BYREF
  lex_t lex; // [sp+8h] [bp-58h] BYREF

  jsonp_error_init(error, "<string>");
  if ( string )
  {
    v6 = 0;
    stream_data.data = string;
    stream_data.pos = 0;
    if ( !lex_init(&lex, get, &stream_data) )
    {
      v6 = parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    v6 = 0;
    error_set(error, 0, "wrong arguments");
  }
  return v6;
}

//----- (0003D46C) --------------------------------------------------------
json_t_0 *__fastcall json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error)
{
  json_t_0 *v8; // r6
  buffer_data_t stream_data; // [sp+4h] [bp-64h] BYREF
  lex_t lex; // [sp+10h] [bp-58h] BYREF

  jsonp_error_init(error, "<buffer>");
  if ( buffer )
  {
    v8 = 0;
    stream_data.data = buffer;
    stream_data.len = buflen;
    stream_data.pos = 0;
    if ( !lex_init(&lex, buffer_get, &stream_data) )
    {
      v8 = parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    v8 = 0;
    error_set(error, 0, "wrong arguments");
  }
  return v8;
}

//----- (0003D4CC) --------------------------------------------------------
json_t_0 *__fastcall json_loadf(FILE *input, size_t flags, json_error_t *error)
{
  json_t_0 *v5; // r4
  const unsigned __int8 *v6; // r1
  json_t_0 *v7; // r2
  lex_t lex; // [sp+0h] [bp-58h] BYREF

  v5 = (json_t_0 *)input;
  if ( input == (FILE *)stdin )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  jsonp_error_init(error, v6);
  if ( v5 )
  {
    v7 = v5;
    v5 = 0;
    if ( !lex_init(&lex, (get_func)fgetc, v7) )
    {
      v5 = parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
  }
  return v5;
}
// 62988: using guessed type int stdin;

//----- (0003D534) --------------------------------------------------------
json_t_0 *__fastcall json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error)
{
  FILE *v6; // r0
  FILE *v7; // r7
  json_t_0 *v8; // r6
  int *v10; // r0
  char *v11; // r0

  jsonp_error_init(error, path);
  if ( path )
  {
    v6 = fopen((const char *)path, "rb");
    v7 = v6;
    if ( v6 )
    {
      v8 = json_loadf(v6, flags, error);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      error_set(error, 0, "unable to open %s: %s", (const char *)path, v11);
    }
  }
  else
  {
    v8 = 0;
    error_set(error, 0, "wrong arguments");
  }
  return v8;
}

//----- (0003D5A0) --------------------------------------------------------
json_t_0 *__fastcall json_load_callback(json_load_callback_t callback, void *arg, size_t flags, json_error_t *error)
{
  lex_t lex; // [sp+0h] [bp-468h] BYREF
  callback_data_t stream_data; // [sp+40h] [bp-428h] BYREF

  memset(&stream_data, 0, sizeof(stream_data));
  stream_data.arg = arg;
  stream_data.callback = callback;
  jsonp_error_init(error, "<callback>");
  if ( callback )
  {
    callback = 0;
    if ( !lex_init(&lex, callback_get, &stream_data) )
    {
      callback = (json_load_callback_t)parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
  }
  return (json_t_0 *)callback;
}

//----- (0003D610) --------------------------------------------------------
int __fastcall compar(const void *key1, const void *key2)
{
  if ( *(_DWORD *)key1 < *(_DWORD *)key2 )
    return -1;
  else
    return *(_DWORD *)key1 != *(_DWORD *)key2;
}

//----- (0003D628) --------------------------------------------------------
int __fastcall dump_string(const unsigned __int8 *str, json_dump_callback_t dump, void *data, size_t flags)
{
  __int16 v6; // r9
  const unsigned __int8 *v8; // r4
  const unsigned __int8 *v9; // r5
  const char *v10; // r0
  size_t v11; // r1
  bool v12; // zf
  unsigned int v14; // r2
  int v15; // r3
  int32_t codepoint; // [sp+4h] [bp-34h] BYREF
  unsigned __int8 seq[13]; // [sp+8h] [bp-30h] BYREF

  v6 = flags;
  if ( ((int (__fastcall *)(const char *, int))dump)("\"", 1) )
    return -1;
  v8 = str;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( !*v8 )
      {
        v9 = v8;
        break;
      }
      if ( (v6 & 0x800) != 0 )
      {
        v9 = v8 + 1;
        codepoint = *v8;
      }
      else
      {
        v9 = utf8_iterate(v8, &codepoint);
      }
      if ( !v9 )
        return -1;
      v12 = codepoint == 92;
      if ( codepoint != 92 )
        v12 = codepoint == 34;
      if ( v12 || codepoint <= 31 || (v6 & 0x400) != 0 && codepoint == 47 || (v6 & 0x40) != 0 && codepoint > 127 )
        break;
      v8 = v9;
    }
    if ( v8 != str && dump(str, v8 - str, data) )
      return -1;
    if ( v9 == v8 )
      return dump((const unsigned __int8 *)"\"", 1, data);
    if ( codepoint == 12 )
    {
      v11 = 2;
      v10 = "\\f";
      goto LABEL_14;
    }
    if ( codepoint <= 12 )
    {
      switch ( codepoint )
      {
        case 9:
          v11 = 2;
          v10 = "\\t";
          break;
        case 10:
          v11 = 2;
          v10 = "\\n";
          break;
        case 8:
          v11 = 2;
          v10 = "\\b";
          break;
        default:
LABEL_12:
          if ( codepoint >= 0x10000 )
          {
            v14 = ((unsigned int)(codepoint - 0x10000) >> 10) & 0x3FF | 0xD800;
            v15 = (codepoint - 0x10000) & 0x3FF | 0xDC00;
            codepoint -= 0x10000;
            sprintf((char *)seq, "\\u%04x\\u%04x", v14, v15);
            v10 = (const char *)seq;
            v11 = 12;
          }
          else
          {
            sprintf((char *)seq, "\\u%04x", codepoint);
            v10 = (const char *)seq;
            v11 = 6;
          }
          break;
      }
LABEL_14:
      if ( dump((const unsigned __int8 *)v10, v11, data) )
        return -1;
      goto LABEL_15;
    }
    if ( codepoint == 34 )
    {
      v10 = "\\\"";
      v11 = 2;
      goto LABEL_14;
    }
    if ( codepoint > 34 )
    {
      if ( codepoint == 47 )
      {
        v11 = 2;
        v10 = "\\/";
        goto LABEL_14;
      }
      if ( codepoint == 92 )
      {
        v11 = 2;
        v10 = "\\\\";
        goto LABEL_14;
      }
      goto LABEL_12;
    }
    if ( codepoint != 13 )
      goto LABEL_12;
    if ( dump("\\r", 2, data) )
      return -1;
LABEL_15:
    v8 = v9;
    str = v9;
  }
}

//----- (0003D77C) --------------------------------------------------------
int __fastcall object_key_compare_keys(const void *key1, const void *key2)
{
  return j_strcmp(*((const char **)key1 + 1), *((const char **)key2 + 1));
}

//----- (0003D784) --------------------------------------------------------
int __fastcall dump_to_file(const unsigned __int8 *buffer, size_t size, void *data)
{
  if ( fwrite(buffer, size, 1u, (FILE *)data) == 1 )
    return 0;
  else
    return -1;
}

//----- (0003D79C) --------------------------------------------------------
int __fastcall callback(const unsigned __int8 *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
}

//----- (0003D7B0) --------------------------------------------------------
int __fastcall dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data)
{
  size_t v5; // r8
  int v9; // r4

  v5 = flags & 0x1F;
  if ( (flags & 0x1F) != 0 )
  {
    if ( !dump((const unsigned __int8 *)ptr, 1, data) )
    {
      if ( depth <= 0 )
        return 0;
      v9 = 0;
      while ( 1 )
      {
        ++v9;
        if ( dump(whitespace, v5, data) )
          break;
        if ( v9 == depth )
          return 0;
      }
    }
    return -1;
  }
  else
  {
    if ( !space || (flags & 0x20) != 0 )
      return 0;
    return ((int (__fastcall *)(const char *, int, void *, size_t))dump)(" ", 1, data, flags << 26);
  }
}

//----- (0003D814) --------------------------------------------------------
int __fastcall do_dump(int a1, size_t a2, int a3, int (*a4)(const unsigned __int8 *, size_t, void *), void *data)
{
  json_t_0 *v5; // r6
  int (*v7)(const unsigned __int8 *, size_t, void *); // r4
  void *v8; // r5
  json_int_t v9; // r0
  int v10; // r1
  int result; // r0
  const char *v12; // r2
  int v13; // r11
  void *v14; // r8
  int v15; // r10
  int v16; // r9
  json_t_0 *v17; // r9
  void *v18; // r6
  const unsigned __int8 *v19; // r0
  json_t_0 *v20; // r0
  signed int v21; // r10
  int v22; // r9
  signed int i; // r8
  json_t_0 *v24; // r0
  const unsigned __int8 *v25; // r0
  double v26; // r2
  void *v27; // r0
  int (*v28)(const unsigned __int8 *, size_t, void *); // r2
  void *v29; // r4
  _DWORD *v30; // r5
  int (*v31)(const unsigned __int8 *, size_t, void *); // r8
  size_t v32; // r0
  _DWORD *v33; // r2
  unsigned int v34; // r8
  int (*v35)(const void *, const void *); // r3
  const unsigned __int8 *v36; // r9
  json_t_0 *v37; // r6
  const char *v39; // [sp+10h] [bp-A0h]
  size_t nmemb; // [sp+14h] [bp-9Ch]
  json_t_0 *json; // [sp+18h] [bp-98h]
  unsigned int v42; // [sp+1Ch] [bp-94h]
  void *base; // [sp+20h] [bp-90h] BYREF
  char s[140]; // [sp+24h] [bp-8Ch] BYREF

  v5 = (json_t_0 *)a1;
  v7 = a4;
  v8 = data;
  if ( !a1 )
    return -1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v39 = v12;
      if ( *(_DWORD *)(a1 + 32) )
        goto object_error;
      *(_DWORD *)(a1 + 32) = 1;
      v14 = json_object_iter((json_t_0 *)a1);
      if ( v7((const unsigned __int8 *)"{", 1, data) )
        goto object_error;
      if ( v14 )
      {
        v15 = a3 + 1;
        v16 = dump_indent(a2, a3 + 1, 0, v7, data);
        if ( v16 )
          goto object_error;
        if ( (a2 & 0x180) == 0 )
        {
          v17 = v5;
          while ( 1 )
          {
            v18 = json_object_iter_next(v17, v14);
            v19 = json_object_iter_key(v14);
            dump_string(v19, v7, data, a2);
            if ( v7((const unsigned __int8 *)v39, v13, data)
              || (v20 = json_object_iter_value(v14), do_dump(v20, a2, v15, v7, data)) )
            {
LABEL_24:
              v5 = v17;
              goto object_error;
            }
            if ( !v18 )
              break;
            if ( !v7((const unsigned __int8 *)",", 1, data) )
            {
              v14 = v18;
              if ( !dump_indent(a2, v15, 1, v7, data) )
                continue;
            }
            goto LABEL_24;
          }
          v5 = v17;
          if ( !dump_indent(a2, a3, 0, v7, data) )
            goto LABEL_46;
object_error:
          result = -1;
          v5[4].type = JSON_OBJECT;
          return result;
        }
        nmemb = json_object_size(v5);
        v27 = jsonp_malloc(8 * nmemb);
        base = v27;
        if ( !v27 )
          goto object_error;
        v28 = v7;
        v29 = v14;
        v30 = v27;
        v31 = v28;
        while ( 1 )
        {
          v32 = hashtable_iter_serial(v29);
          v33 = base;
          v30[2 * v16] = v32;
          v33[2 * v16 + 1] = json_object_iter_key(v29);
          v29 = json_object_iter_next(v5, v29);
          if ( !v29 )
            break;
          v30 = base;
          ++v16;
        }
        v7 = v31;
        v34 = 0;
        v8 = data;
        if ( nmemb != v16 + 1 )
          _assert_fail("i == size", "compat/jansson-2.6/src/dump.c", 0x154u, "do_dump");
        v35 = object_key_compare_keys;
        if ( (a2 & 0x80) == 0 )
          v35 = compar;
        qsort(base, nmemb, 8u, v35);
        if ( nmemb )
        {
          v42 = v16;
          json = v5;
          do
          {
            v36 = (const unsigned __int8 *)*((_DWORD *)base + 2 * v34 + 1);
            v37 = json_object_get(json, v36);
            if ( !v37 )
              _assert_fail("value", "compat/jansson-2.6/src/dump.c", 0x164u, "do_dump");
            dump_string(v36, v7, data, a2);
            if ( v7((const unsigned __int8 *)v39, v13, data) || do_dump(v37, a2, v15, v7, data) )
            {
LABEL_65:
              v5 = json;
              jsonp_free(&base);
              goto object_error;
            }
            if ( v42 > v34 )
            {
              if ( v7((const unsigned __int8 *)",", 1, data) || dump_indent(a2, v15, 1, v7, data) )
                goto LABEL_65;
            }
            else if ( dump_indent(a2, a3, 0, v7, data) )
            {
              goto LABEL_65;
            }
            ++v34;
          }
          while ( nmemb != v34 );
          v5 = json;
        }
        jsonp_free(&base);
LABEL_46:
        v5[4].type = JSON_OBJECT;
        result = v7((const unsigned __int8 *)"}", 1, v8);
      }
      else
      {
        v5[4].type = JSON_OBJECT;
        result = v7((const unsigned __int8 *)"}", 1, data);
      }
      break;
    case 1:
      if ( *(_DWORD *)(a1 + 20) )
        goto array_error;
      *(_DWORD *)(a1 + 20) = 1;
      v21 = json_array_size((const json_t_0 *)a1);
      if ( v7((const unsigned __int8 *)"[", 1, data) )
        goto array_error;
      if ( !v21 )
        goto LABEL_47;
      v22 = a3 + 1;
      if ( dump_indent(a2, a3 + 1, 0, v7, data) )
        goto array_error;
      if ( v21 <= 0 )
        goto LABEL_47;
      for ( i = 0; i != v21; ++i )
      {
        v24 = json_array_get(v5, i);
        if ( do_dump(v24, a2, v22, v7, data) )
        {
array_error:
          result = -1;
          v5[2].refcount = 0;
          return result;
        }
        if ( v21 - 1 > i )
        {
          if ( v7((const unsigned __int8 *)",", 1, data) || dump_indent(a2, v22, 1, v7, data) )
            goto array_error;
        }
        else if ( dump_indent(a2, a3, 0, v7, data) )
        {
          goto array_error;
        }
      }
LABEL_47:
      v5[2].refcount = 0;
      return v7(&word_4D07C, 1, data);
    case 2:
      v25 = json_string_value((const json_t_0 *)a1);
      return dump_string(v25, v7, data, a2);
    case 3:
      v9 = json_integer_value((const json_t_0 *)a1);
      v10 = snprintf(s, 0x64u, "%lld", v9);
      if ( (unsigned int)v10 > 0x63 )
        return -1;
      return v7((const unsigned __int8 *)s, v10, data);
    case 4:
      json_real_value((const json_t_0 *)a1);
      v10 = jsonp_dtostr((unsigned __int8 *)s, 0x64u, v26);
      if ( v10 < 0 )
        return -1;
      return v7((const unsigned __int8 *)s, v10, data);
    case 5:
      return a4("true", 4, data);
    case 6:
      return a4("false", 5, data);
    case 7:
      return a4("null", 4, data);
    default:
      return -1;
  }
  return result;
}
// 3D9FE: variable 'v26' is possibly undefined

//----- (0003DC04) --------------------------------------------------------
int __fastcall json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags)
{
  if ( (flags & 0x200) != 0 || json && json->type <= (unsigned int)JSON_ARRAY )
    return do_dump((int)json, (unsigned __int16)flags, 0, callback, data);
  else
    return -1;
}

//----- (0003DC2C) --------------------------------------------------------
int __fastcall json_dumpf(const json_t_0 *json, FILE *output, size_t flags)
{
  return json_dump_callback(json, dump_to_file, output, flags);
}

//----- (0003DC44) --------------------------------------------------------
int __fastcall json_dump_file(const json_t_0 *json, const unsigned __int8 *path, size_t flags)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = fopen((const char *)path, "w");
  if ( !v5 )
    return -1;
  v6 = json_dumpf(json, v5, flags);
  fclose(v5);
  return v6;
}

//----- (0003DC78) --------------------------------------------------------
unsigned __int8 *__fastcall json_dumps(const json_t_0 *json, size_t flags)
{
  strbuffer_t strbuff; // [sp+4h] [bp-1Ch] BYREF

  if ( strbuffer_init(&strbuff) || json_dump_callback(json, callback, &strbuff, flags) )
    return 0;
  if ( (flags & 0x1000) != 0 )
    return jsonp_eolstrsteal(&strbuff);
  return jsonp_strsteal(&strbuff);
}

//----- (0003DCB4) --------------------------------------------------------
void *__fastcall jsonp_malloc(void *size)
{
  if ( size )
    return do_malloc((size_t)size);
  return size;
}

//----- (0003DCC8) --------------------------------------------------------
void __fastcall jsonp_free(void **ptr)
{
  void *v2; // r0

  v2 = *ptr;
  if ( v2 )
  {
    do_free(v2);
    *ptr = 0;
  }
}

//----- (0003DCE0) --------------------------------------------------------
unsigned __int8 *__fastcall jsonp_strdup(const unsigned __int8 *str)
{
  size_t v2; // r0
  size_t v3; // r4
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r5

  v2 = strlen((const char *)str);
  if ( v2 == -1 )
    return 0;
  v3 = v2 + 1;
  v5 = (unsigned __int8 *)do_malloc(v2 + 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  memcpy(v5, str, v3);
  return v6;
}
// 3DCEE: conditional instruction was optimized away because r0.4!=FFFFFFFF

//----- (0003DD14) --------------------------------------------------------
unsigned __int8 *__fastcall jsonp_strsteal(strbuffer_t *strbuff)
{
  return (unsigned __int8 *)j_realloc(strbuff->value, strbuff->length + 1);
}

//----- (0003DD1C) --------------------------------------------------------
unsigned __int8 *__fastcall jsonp_eolstrsteal(strbuffer_t *strbuff)
{
  unsigned __int8 *result; // r0

  result = (unsigned __int8 *)realloc(strbuff->value, strbuff->length + 2);
  result[strbuff->length] = 10;
  result[strbuff->length + 1] = 0;
  return result;
}

//----- (0003DD38) --------------------------------------------------------
void __fastcall json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn)
{
  do_malloc = malloc_fn;
  do_free = free_fn;
}

//----- (0003DD48) --------------------------------------------------------
int __fastcall utf8_encode(int32_t codepoint, unsigned __int8 *buffer, int *size)
{
  unsigned int v3; // r7
  unsigned int v4; // r6
  unsigned int v5; // r5
  unsigned __int8 v6; // r4
  int result; // r0
  unsigned __int8 v8; // r4

  if ( codepoint >= 0 )
  {
    if ( codepoint <= 127 )
    {
      *buffer = codepoint;
      result = 0;
      *size = 1;
      return result;
    }
    if ( codepoint < 2048 )
    {
      buffer[1] = (codepoint & 0x3F) + 0x80;
      *buffer = (((unsigned int)codepoint >> 6) & 0x1F) - 64;
      result = 0;
      *size = 2;
      return result;
    }
    if ( codepoint < 0x10000 )
    {
      v8 = (codepoint & 0x3F) + 0x80;
      *buffer = ((unsigned __int16)codepoint >> 12) - 32;
      buffer[1] = (((unsigned int)codepoint >> 6) & 0x3F) + 0x80;
      result = 0;
      buffer[2] = v8;
      *size = 3;
      return result;
    }
    if ( codepoint < 1114112 )
    {
      v3 = ((unsigned int)codepoint >> 18) & 7;
      v4 = ((unsigned int)codepoint >> 12) & 0x3F;
      v5 = ((unsigned int)codepoint >> 6) & 0x3F;
      v6 = (codepoint & 0x3F) + 0x80;
      result = 0;
      *buffer = v3 - 16;
      buffer[1] = v4 + 0x80;
      buffer[2] = v5 + 0x80;
      buffer[3] = v6;
      *size = 4;
      return result;
    }
  }
  return -1;
}

//----- (0003DDDC) --------------------------------------------------------
int __fastcall utf8_check_first(unsigned __int8 byte)
{
  if ( (byte & 0x80) == 0 )
    return 1;
  if ( (byte ^ 0x80u) <= 0x3F || (unsigned __int8)(byte + 64) <= 1u )
    return 0;
  if ( (unsigned __int8)(byte + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(byte + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(byte + 16) > 4u )
    return 0;
  return 4;
}

//----- (0003DE24) --------------------------------------------------------
int __fastcall utf8_check_full(const unsigned __int8 *buffer, int size, int32_t *codepoint)
{
  unsigned __int8 v3; // r5
  int v4; // r5
  int result; // r0
  int v6; // r4
  int v7; // r3
  bool v8; // zf
  bool v9; // zf
  _BOOL4 v10; // r0

  v3 = *buffer;
  switch ( size )
  {
    case 2:
      v4 = v3 & 0x1F;
      break;
    case 3:
      v4 = v3 & 0xF;
      break;
    case 4:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = buffer[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = 1;
  while ( 1 )
  {
    ++v7;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( size <= v7 )
      break;
    v6 = buffer[v7];
    if ( (v6 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) <= 0x7FF )
    return 0;
  v8 = v4 == 127;
  if ( v4 <= 127 )
    v8 = size == 2;
  if ( v8 )
    return 0;
  result = 0;
  v9 = v4 == 2047;
  if ( v4 <= 2047 )
    v9 = size == 3;
  if ( !v9 )
  {
    v10 = v4 < 0x10000;
    if ( size != 4 )
      v10 = 0;
    if ( !v10 )
    {
      if ( codepoint )
        *codepoint = v4;
      return 1;
    }
    return 0;
  }
  return result;
}

//----- (0003DEBC) --------------------------------------------------------
const unsigned __int8 *__fastcall utf8_iterate(const unsigned __int8 *buffer, int32_t *codepoint)
{
  const unsigned __int8 *v2; // r4
  int32_t v3; // r5
  int v5; // r0
  int v6; // r6
  int32_t value; // [sp+4h] [bp-1Ch] BYREF

  v2 = buffer;
  v3 = *buffer;
  if ( !*buffer )
    return v2;
  v5 = utf8_check_first(*buffer);
  v6 = v5;
  if ( v5 <= 0 )
    return 0;
  if ( v5 != 1 )
  {
    if ( utf8_check_full(v2, v5, &value) )
      goto LABEL_6;
    return 0;
  }
  value = v3;
LABEL_6:
  if ( codepoint )
    *codepoint = value;
  v2 += v6;
  return v2;
}

//----- (0003DEF8) --------------------------------------------------------
int __fastcall utf8_check_string(const unsigned __int8 *string, int length)
{
  int v2; // r8
  int v4; // r4
  int v5; // r5
  int v6; // r5
  int v7; // r1

  v2 = length;
  if ( length == -1 )
    v2 = strlen((const char *)string);
  if ( v2 <= 0 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v6 = utf8_check_first(string[v4]);
    v7 = v6;
    if ( !v6 )
      break;
    if ( v6 > 1 )
    {
      if ( v2 < v4 + v6 )
        return 0;
      v5 = v6 - 1;
      if ( !utf8_check_full(&string[v4], v7, 0) )
        return 0;
      v4 += v5;
    }
    if ( v2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (0003DF54) --------------------------------------------------------
uint32_t __fastcall hashlittle(const void *key, size_t length, uint32_t initval)
{
  unsigned __int8 *v3; // r3
  int v4; // r2
  int v5; // r4
  int i; // r7
  int v7; // r5
  int v8; // r0
  int v9; // t1
  int v10; // r2
  int v11; // r4
  int v12; // r0
  int v13; // r2
  int v14; // r6
  int v15; // r7
  int v16; // r5
  int v17; // r6
  int v18; // r4
  int v19; // r0
  int v20; // r0
  int k; // r6
  int v22; // r7
  int v23; // r3
  int v24; // r7
  int v25; // r4
  int v26; // r3
  int v27; // r7
  int v28; // r4
  int j; // r7
  int v31; // r9
  int v32; // r8
  int v33; // r12
  int v34; // r5
  int v35; // r6
  int v36; // t1
  int v37; // r2
  int v38; // r4
  int v39; // r0
  int v40; // r2
  int v41; // r6
  int v42; // r7
  int v43; // r5
  int v44; // r6
  int v45; // r4
  int v46; // r0
  int v47; // r0
  int v48; // r2
  int v49; // r7
  int v50; // r4
  int v51; // r2
  int v52; // r6
  int v53; // r7
  int v54; // r8
  int v55; // r5
  int v56; // r7
  int v57; // t2
  int v58; // r0

  v3 = (unsigned __int8 *)key;
  v4 = initval + length - 559038737;
  v5 = v4;
  if ( ((unsigned __int8)key & 3) == 0 )
  {
    for ( i = v4; length > 0xC; v4 = (v17 - v20) ^ __ROR4__(v20, 28) )
    {
      v7 = *((_DWORD *)v3 + 2);
      length -= 12;
      v8 = *((_DWORD *)v3 + 1);
      v9 = *(_DWORD *)v3;
      v3 += 12;
      v10 = v4 + v7;
      v11 = v5 + v8;
      v12 = v10 + v11;
      v13 = (i + v9 - v10) ^ __ROR4__(v10, 28);
      v14 = (v11 - v13) ^ __ROR4__(v13, 26);
      v15 = v14 + v13 + v12;
      v16 = (v12 - v14) ^ __ROR4__(v14, 24);
      v17 = v16 + v15;
      v18 = (v13 + v12 - v16) ^ __ROR4__(v16, 16);
      v19 = v15 - v18;
      i = v18 + v17;
      v20 = v19 ^ __ROR4__(v18, 13);
      v5 = v20 + v18 + v17;
    }
    switch ( length )
    {
      case 1u:
        goto LABEL_36;
      case 2u:
        goto LABEL_35;
      case 3u:
        i += v3[2] << 16;
LABEL_35:
        i += v3[1] << 8;
LABEL_36:
        v22 = i + *v3;
        goto LABEL_17;
      case 4u:
        goto LABEL_33;
      case 5u:
        goto LABEL_32;
      case 6u:
        goto LABEL_31;
      case 7u:
        v5 += v3[6] << 16;
LABEL_31:
        v5 += v3[5] << 8;
LABEL_32:
        v5 += v3[4];
LABEL_33:
        v22 = i + *(_DWORD *)v3;
        goto LABEL_17;
      case 8u:
        goto LABEL_29;
      case 9u:
        goto LABEL_28;
      case 0xAu:
        goto LABEL_27;
      case 0xBu:
        v4 += v3[10] << 16;
LABEL_27:
        v4 += v3[9] << 8;
LABEL_28:
        v4 += v3[8];
LABEL_29:
        v5 += *((_DWORD *)v3 + 1);
        v22 = i + *(_DWORD *)v3;
        goto LABEL_17;
      case 0xCu:
        v4 += *((_DWORD *)v3 + 2);
        v5 += *((_DWORD *)v3 + 1);
        v22 = i + *(_DWORD *)v3;
        goto LABEL_17;
      default:
        return v4;
    }
  }
  if ( ((unsigned __int8)key & 1) == 0 )
  {
    for ( j = v4; length > 0xC; v4 = (v44 - v47) ^ __ROR4__(v47, 28) )
    {
      v31 = *((unsigned __int16 *)v3 + 5);
      length -= 12;
      v32 = *((unsigned __int16 *)v3 + 4);
      v33 = *((unsigned __int16 *)v3 + 2);
      v34 = *((unsigned __int16 *)v3 + 3);
      v35 = *((unsigned __int16 *)v3 + 1);
      v36 = *(unsigned __int16 *)v3;
      v3 += 12;
      v37 = v4 + v32 + (v31 << 16);
      v38 = v5 + v33 + (v34 << 16);
      v39 = v37 + v38;
      v40 = (j + v36 + (v35 << 16) - v37) ^ __ROR4__(v37, 28);
      v41 = (v38 - v40) ^ __ROR4__(v40, 26);
      v42 = v41 + v40 + v39;
      v43 = (v39 - v41) ^ __ROR4__(v41, 24);
      v44 = v43 + v42;
      v45 = (v40 + v39 - v43) ^ __ROR4__(v43, 16);
      v46 = v42 - v45;
      j = v45 + v44;
      v47 = v46 ^ __ROR4__(v45, 13);
      v5 = v47 + v45 + v44;
    }
    switch ( length )
    {
      case 1u:
        v22 = *v3 + j;
        goto LABEL_17;
      case 2u:
        goto LABEL_43;
      case 3u:
        j += v3[2] << 16;
LABEL_43:
        v22 = j + *(unsigned __int16 *)v3;
        goto LABEL_17;
      case 4u:
        goto LABEL_45;
      case 5u:
        v5 += v3[4];
LABEL_45:
        v22 = *(unsigned __int16 *)v3 + j + (*((unsigned __int16 *)v3 + 1) << 16);
        goto LABEL_17;
      case 6u:
        goto LABEL_47;
      case 7u:
        v5 += v3[6] << 16;
LABEL_47:
        v22 = *(unsigned __int16 *)v3 + j + (*((unsigned __int16 *)v3 + 1) << 16);
        v5 += *((unsigned __int16 *)v3 + 2);
        goto LABEL_17;
      case 8u:
        goto LABEL_39;
      case 9u:
        v4 += v3[8];
LABEL_39:
        v5 += *((unsigned __int16 *)v3 + 2) + (*((unsigned __int16 *)v3 + 3) << 16);
        v22 = *(unsigned __int16 *)v3 + j + (*((unsigned __int16 *)v3 + 1) << 16);
        goto LABEL_17;
      case 0xAu:
        goto LABEL_41;
      case 0xBu:
        v4 += v3[10] << 16;
LABEL_41:
        v5 += *((unsigned __int16 *)v3 + 2) + (*((unsigned __int16 *)v3 + 3) << 16);
        v22 = *(unsigned __int16 *)v3 + j + (*((unsigned __int16 *)v3 + 1) << 16);
        v4 += *((unsigned __int16 *)v3 + 4);
        goto LABEL_17;
      case 0xCu:
        v4 += *((unsigned __int16 *)v3 + 4) + (*((unsigned __int16 *)v3 + 5) << 16);
        v5 += *((unsigned __int16 *)v3 + 2) + (*((unsigned __int16 *)v3 + 3) << 16);
        v22 = *(unsigned __int16 *)v3 + j + (*((unsigned __int16 *)v3 + 1) << 16);
        goto LABEL_17;
      default:
        return v4;
    }
  }
  for ( k = v4; length > 0xC; v4 = (v55 + v54 - v58) ^ __ROR4__(v58, 28) )
  {
    length -= 12;
    v48 = v4 + (v3[10] << 16) + (v3[9] << 8) + v3[8] + (v3[11] << 24);
    v49 = ((v3[2] << 16) + (v3[1] << 8) + *v3 + (v3[3] << 24) - v48 + k) ^ __ROR4__(v48, 28);
    v50 = v5 + (v3[6] << 16) + (v3[5] << 8) + v3[4] + (v3[7] << 24);
    v3 += 12;
    v51 = v48 + v50;
    v52 = (v50 - v49) ^ __ROR4__(v49, 26);
    v53 = v49 + v51;
    v54 = v52 + v53;
    v55 = (v51 - v52) ^ __ROR4__(v52, 24);
    v56 = v53 - v55;
    v57 = __ROR4__(v55, 16);
    k = (v56 ^ v57) + v55 + v54;
    v58 = (v54 - (v56 ^ v57)) ^ __ROR4__(v56 ^ v57, 13);
    v5 = v58 + k;
  }
  switch ( length )
  {
    case 1u:
      goto LABEL_16;
    case 2u:
      goto LABEL_15;
    case 3u:
      goto LABEL_14;
    case 4u:
      goto LABEL_13;
    case 5u:
      goto LABEL_12;
    case 6u:
      goto LABEL_11;
    case 7u:
      goto LABEL_10;
    case 8u:
      goto LABEL_9;
    case 9u:
      goto LABEL_8;
    case 0xAu:
      goto LABEL_7;
    case 0xBu:
      goto LABEL_6;
    case 0xCu:
      v4 += v3[11] << 24;
LABEL_6:
      v4 += v3[10] << 16;
LABEL_7:
      v4 += v3[9] << 8;
LABEL_8:
      v4 += v3[8];
LABEL_9:
      v5 += v3[7] << 24;
LABEL_10:
      v5 += v3[6] << 16;
LABEL_11:
      v5 += v3[5] << 8;
LABEL_12:
      v5 += v3[4];
LABEL_13:
      k += v3[3] << 24;
LABEL_14:
      k += v3[2] << 16;
LABEL_15:
      k += v3[1] << 8;
LABEL_16:
      v22 = k + *v3;
LABEL_17:
      v23 = (v4 ^ v5) - __ROR4__(v5, 18);
      v24 = (v22 ^ v23) - __ROR4__(v23, 21);
      v25 = (v5 ^ v24) - __ROR4__(v24, 7);
      v26 = (v23 ^ v25) - __ROR4__(v25, 16);
      v27 = (v24 ^ v26) - __ROR4__(v26, 28);
      v28 = (v25 ^ v27) - __ROR4__(v27, 18);
      v4 = (v28 ^ v26) - __ROR4__(v28, 8);
      break;
    default:
      return v4;
  }
  return v4;
}

//----- (0003E2D8) --------------------------------------------------------
void __fastcall insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list)
{
  hashtable_list *first; // r3
  hashtable_list *v4; // r0
  hashtable_list *prev; // r4
  hashtable_list *v6; // r3

  first = bucket->first;
  if ( bucket->first == &hashtable->list && first == bucket->last )
  {
    prev = hashtable->list.prev;
    list->next = first;
    list->prev = prev;
    v6 = hashtable->list.prev;
    hashtable->list.prev = list;
    v6->next = list;
    bucket->last = list;
    bucket->first = list;
  }
  else
  {
    list->prev = first->prev;
    list->next = first;
    v4 = first->prev;
    first->prev = list;
    v4->next = list;
    bucket->first = list;
  }
}

//----- (0003E310) --------------------------------------------------------
pair_t *__fastcall hashtable_find_pair(
        hashtable_t *hashtable,
        bucket_t *bucket,
        const unsigned __int8 *key,
        size_t hash)
{
  hashtable_list *first; // r4

  first = bucket->first;
  if ( bucket->first == &hashtable->list && first == bucket->last )
    return 0;
  while ( first[-1].next != (hashtable_list *)hash || strcmp((const char *)&first[2], (const char *)key) )
  {
    if ( bucket->last == first )
      return 0;
    first = first->next;
  }
  return (pair_t *)&first[-1].next;
}

//----- (0003E358) --------------------------------------------------------
void __fastcall hashtable_do_clear(hashtable_t *hashtable)
{
  hashtable_t *next; // r3
  hashtable_list *p_list; // r5
  json_t_0 *order; // r0
  hashtable_bucket *buckets; // r4
  size_t refcount; // r2
  pair_t *pair; // [sp+4h] [bp-14h] BYREF

  next = (hashtable_t *)hashtable->list.next;
  p_list = &hashtable->list;
  if ( next != (hashtable_t *)&hashtable->list )
  {
    do
    {
      order = (json_t_0 *)next->order;
      pair = (pair_t *)&next[-1].list.next;
      buckets = next->buckets;
      if ( order )
      {
        refcount = order->refcount;
        if ( refcount != -1 )
        {
          order->refcount = refcount - 1;
          if ( refcount == 1 )
            json_delete(order);
        }
      }
      jsonp_free((void **)&pair);
      next = (hashtable_t *)buckets;
    }
    while ( buckets != (hashtable_bucket *)p_list );
  }
}

//----- (0003E390) --------------------------------------------------------
int __fastcall hashtable_init(hashtable_t *hashtable)
{
  hashtable_bucket *v2; // r2
  size_t order; // r0
  hashtable_list *p_list; // r1
  int v5; // r3

  hashtable->order = 3;
  hashtable->size = 0;
  v2 = (hashtable_bucket *)jsonp_malloc(0x40u);
  hashtable->buckets = v2;
  if ( !v2 )
    return -1;
  order = hashtable->order;
  p_list = &hashtable->list;
  hashtable->list.next = &hashtable->list;
  hashtable->list.prev = &hashtable->list;
  if ( 1 << order )
  {
    v5 = 0;
    do
    {
      v2[v5].last = p_list;
      v2[v5++].first = p_list;
    }
    while ( v5 != 1 << order );
  }
  return 0;
}

//----- (0003E3D4) --------------------------------------------------------
void __fastcall hashtable_close(hashtable_t *hashtable)
{
  hashtable_do_clear(hashtable);
  jsonp_free((void **)&hashtable->buckets);
}

//----- (0003E3E8) --------------------------------------------------------
int __fastcall hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, size_t serial, json_t_0 *value)
{
  size_t order; // r1
  hashtable_bucket *buckets; // r5
  int v9; // r11
  size_t v10; // r10
  size_t v11; // r7
  bucket_t *v12; // r5
  pair_t *pair; // r0
  pair_t *v14; // r4
  json_t_0 *v15; // r0
  size_t refcount; // r3
  size_t v17; // r3
  int result; // r0
  size_t v19; // r3
  unsigned int v20; // r7
  hashtable_bucket *v21; // r0
  int v22; // r4
  hashtable_list *p_list; // r10
  hashtable_list *next; // r4
  int v25; // r1
  list_t *v26; // r2
  char *v27; // r0
  char *v28; // r11

  order = hashtable->order;
  if ( hashtable->size >> order )
  {
    jsonp_free((void **)&hashtable->buckets);
    v19 = hashtable->order + 1;
    v20 = 1 << v19;
    hashtable->order = v19;
    v21 = (hashtable_bucket *)jsonp_malloc(8 * (1 << v19));
    buckets = v21;
    hashtable->buckets = v21;
    if ( !v21 )
      return -1;
    v9 = 1 << hashtable->order;
    if ( v9 )
    {
      v22 = 0;
      p_list = &hashtable->list;
      do
      {
        v21[v22].last = p_list;
        v21[v22++].first = p_list;
      }
      while ( v22 != v9 );
    }
    else
    {
      p_list = &hashtable->list;
    }
    next = hashtable->list.next;
    hashtable->list.prev = p_list;
    hashtable->list.next = p_list;
    if ( next != p_list )
    {
      while ( 1 )
      {
        v25 = (unsigned int)next[-1].next % v20;
        v26 = next;
        next = next->next;
        insert_to_bucket(hashtable, &buckets[v25], v26);
        if ( p_list == next )
          break;
        buckets = hashtable->buckets;
      }
      buckets = hashtable->buckets;
      v9 = 1 << hashtable->order;
    }
  }
  else
  {
    buckets = hashtable->buckets;
    v9 = 1 << order;
  }
  v10 = strlen((const char *)key);
  v11 = hashlittle(key, v10, hashtable_seed);
  v12 = &buckets[(v9 - 1) & v11];
  pair = hashtable_find_pair(hashtable, v12, key, v11);
  v14 = pair;
  if ( !pair )
  {
    v27 = (char *)jsonp_malloc(v10 + 21);
    v28 = v27;
    if ( v27 )
    {
      *(_DWORD *)v27 = v11;
      *((_DWORD *)v27 + 4) = serial;
      strcpy(v27 + 20, (const char *)key);
      *((_DWORD *)v28 + 3) = value;
      *((_DWORD *)v28 + 2) = v28 + 4;
      *((_DWORD *)v28 + 1) = v28 + 4;
      insert_to_bucket(hashtable, v12, (list_t *)(v28 + 4));
      result = 0;
      ++hashtable->size;
      return result;
    }
    return -1;
  }
  v15 = pair->value;
  if ( v15 )
  {
    refcount = v15->refcount;
    if ( refcount != -1 )
    {
      v17 = refcount - 1;
      v15->refcount = v17;
      if ( !v17 )
        json_delete(v15);
    }
  }
  result = 0;
  v14->value = value;
  return result;
}

//----- (0003E534) --------------------------------------------------------
void *__fastcall hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v4; // r0
  size_t v5; // r0
  void *result; // r0

  v4 = strlen((const char *)key);
  v5 = hashlittle(key, v4, hashtable_seed);
  result = hashtable_find_pair(hashtable, &hashtable->buckets[((1 << hashtable->order) - 1) & v5], key, v5);
  if ( result )
    return (void *)*((_DWORD *)result + 3);
  return result;
}

//----- (0003E574) --------------------------------------------------------
int __fastcall hashtable_del(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v4; // r0
  size_t v5; // r0
  const unsigned __int8 *v6; // r2
  hashtable_bucket *buckets; // r6
  int v8; // r5
  bucket_t *v9; // r7
  pair_t *pair; // r0
  pair_t *v11; // r2
  hashtable_list *p_list; // r3
  hashtable_list *last; // r1
  hashtable_list *prev; // r3
  hashtable_list *v15; // r1
  json_t_0 *value; // r0
  size_t refcount; // r3
  size_t v18; // r3
  int result; // r0
  hashtable_list *next; // r3
  void *ptr; // [sp+4h] [bp-1Ch] BYREF

  v4 = strlen((const char *)key);
  v5 = hashlittle(key, v4, hashtable_seed);
  v6 = key;
  buckets = hashtable->buckets;
  v8 = ((1 << hashtable->order) - 1) & v5;
  v9 = &buckets[v8];
  pair = hashtable_find_pair(hashtable, v9, v6, v5);
  v11 = pair;
  ptr = pair;
  if ( !pair )
    return -1;
  p_list = &pair->list;
  last = v9->last;
  if ( &pair->list == buckets[v8].first )
  {
    if ( p_list == last )
    {
      next = &hashtable->list;
      v9->last = &hashtable->list;
    }
    else
    {
      next = pair->list.next;
    }
    buckets[v8].first = next;
  }
  else if ( p_list == last )
  {
    v9->last = pair->list.prev;
  }
  prev = pair->list.prev;
  v15 = pair->list.next;
  value = pair->value;
  prev->next = v15;
  v11->list.next->prev = prev;
  if ( value )
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v18 = refcount - 1;
      value->refcount = v18;
      if ( !v18 )
        json_delete(value);
    }
  }
  jsonp_free(&ptr);
  result = 0;
  --hashtable->size;
  return result;
}

//----- (0003E61C) --------------------------------------------------------
void __fastcall hashtable_clear(hashtable_t *hashtable)
{
  int v2; // r5
  hashtable_list *p_list; // r2
  hashtable_bucket *buckets; // r1
  int v5; // r5
  unsigned int v6; // r3

  hashtable_do_clear(hashtable);
  v2 = 1 << hashtable->order;
  if ( v2 )
  {
    buckets = hashtable->buckets;
    v5 = 8 * v2;
    v6 = 0;
    p_list = &hashtable->list;
    do
    {
      buckets[v6 / 8].last = p_list;
      buckets[v6 / 8].first = p_list;
      v6 += 8;
    }
    while ( v6 != v5 );
  }
  else
  {
    p_list = &hashtable->list;
  }
  hashtable->list.next = p_list;
  hashtable->list.prev = p_list;
  hashtable->size = 0;
}

//----- (0003E654) --------------------------------------------------------
void *__fastcall hashtable_iter(hashtable_t *hashtable)
{
  if ( hashtable->list.next == &hashtable->list )
    return 0;
  else
    return hashtable->list.next;
}

//----- (0003E664) --------------------------------------------------------
void *__fastcall hashtable_iter_at(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v4; // r0
  size_t v5; // r0
  void *result; // r0

  v4 = strlen((const char *)key);
  v5 = hashlittle(key, v4, hashtable_seed);
  result = hashtable_find_pair(hashtable, &hashtable->buckets[((1 << hashtable->order) - 1) & v5], key, v5);
  if ( result )
    return (char *)result + 4;
  return result;
}

//----- (0003E6A4) --------------------------------------------------------
void *__fastcall hashtable_iter_next(hashtable_t *hashtable, void *iter)
{
  if ( *((hashtable_t **)iter + 1) == (hashtable_t *)&hashtable->list )
    return 0;
  else
    return (void *)*((_DWORD *)iter + 1);
}

//----- (0003E6B4) --------------------------------------------------------
void *__fastcall hashtable_iter_key(void *iter)
{
  return (char *)iter + 16;
}

//----- (0003E6B8) --------------------------------------------------------
size_t __fastcall hashtable_iter_serial(void *iter)
{
  return *((_DWORD *)iter + 3);
}

//----- (0003E6BC) --------------------------------------------------------
void *__fastcall hashtable_iter_value(void *iter)
{
  return (void *)*((_DWORD *)iter + 2);
}

//----- (0003E6C0) --------------------------------------------------------
void __fastcall hashtable_iter_set(void *iter, json_t_0 *value)
{
  json_t_0 *v3; // r0
  size_t refcount; // r2
  size_t v6; // r2

  v3 = (json_t_0 *)*((_DWORD *)iter + 2);
  if ( !v3 || (refcount = v3->refcount, refcount == -1) || (v6 = refcount - 1, (v3->refcount = v6) != 0) )
  {
    *((_DWORD *)iter + 2) = value;
  }
  else
  {
    json_delete(v3);
    *((_DWORD *)iter + 2) = value;
  }
}

//----- (0003E6E8) --------------------------------------------------------
json_t_0 **__fastcall json_array_grow(json_array_t *array, size_t amount, int copy)
{
  size_t size; // r3
  json_t_0 **result; // r0
  unsigned int v7; // r0
  unsigned int v8; // r3
  size_t v9; // r6
  json_t_0 **old_table; // [sp+4h] [bp-14h] BYREF

  size = array->size;
  if ( amount + array->entries <= size )
    return array->table;
  v7 = 2 * size;
  v8 = amount + size;
  if ( v8 < v7 )
    v9 = v7;
  else
    v9 = v8;
  old_table = array->table;
  result = (json_t_0 **)jsonp_malloc(4 * v9);
  if ( result )
  {
    array->size = v9;
    array->table = result;
    if ( !copy )
      return old_table;
    memcpy(result, old_table, 4 * array->entries);
    jsonp_free((void **)&old_table);
    return array->table;
  }
  return result;
}

//----- (0003E73C) --------------------------------------------------------
json_object_t *json_object()
{
  json_object_t *result; // r0
  json_object_t *v1; // r3
  json_object_t *v2; // r1
  json_object_t *object; // [sp+4h] [bp-Ch] BYREF

  result = (json_object_t *)jsonp_malloc(0x24u);
  v1 = result;
  object = result;
  if ( result )
  {
    if ( !hashtable_seed )
    {
      json_object_seed(hashtable_seed);
      v1 = object;
    }
    v1->json.refcount = 1;
    v1->json.type = JSON_OBJECT;
    if ( hashtable_init(&v1->hashtable) )
    {
      jsonp_free((void **)&object);
      return 0;
    }
    else
    {
      v2 = object;
      object->serial = 0;
      result = v2;
      v2->visited = 0;
    }
  }
  return result;
}

//----- (0003E788) --------------------------------------------------------
size_t __fastcall json_object_size(size_t json)
{
  if ( json )
  {
    if ( *(_DWORD *)json )
      return 0;
    else
      return *(_DWORD *)(json + 8);
  }
  return json;
}

//----- (0003E798) --------------------------------------------------------
json_t_0 *__fastcall json_object_get(const json_t_0 *json, const unsigned __int8 *key)
{
  if ( !json || json->type )
    return 0;
  else
    return (json_t_0 *)hashtable_get((hashtable_t *)&json[1], key);
}

//----- (0003E7A8) --------------------------------------------------------
int __fastcall json_object_del(json_t_0 *json, const unsigned __int8 *key)
{
  if ( !json || json->type )
    return -1;
  else
    return hashtable_del((hashtable_t *)&json[1], key);
}

//----- (0003E7BC) --------------------------------------------------------
int __fastcall json_object_clear(json_t_0 *json)
{
  if ( !json || json->type )
    return -1;
  hashtable_clear((hashtable_t *)&json[1]);
  json[3].refcount = 0;
  return 0;
}

//----- (0003E7D8) --------------------------------------------------------
void *__fastcall json_object_iter(json_t_0 *json)
{
  if ( !json || json->type )
    return 0;
  else
    return hashtable_iter((hashtable_t *)&json[1]);
}

//----- (0003E7E8) --------------------------------------------------------
void *__fastcall json_object_iter_at(json_t_0 *json, const unsigned __int8 *key)
{
  bool v2; // zf

  v2 = json == 0;
  if ( json )
    v2 = key == 0;
  if ( v2 || json->type )
    return 0;
  else
    return hashtable_iter_at((hashtable_t *)&json[1], key);
}

//----- (0003E800) --------------------------------------------------------
void *__fastcall json_object_iter_next(json_t_0 *json, void *iter)
{
  if ( json && json->type == JSON_OBJECT && iter )
    return hashtable_iter_next((hashtable_t *)&json[1], iter);
  else
    return 0;
}

//----- (0003E814) --------------------------------------------------------
const unsigned __int8 *__fastcall json_object_iter_key(const unsigned __int8 *iter)
{
  if ( iter )
    return (const unsigned __int8 *)hashtable_iter_key((void *)iter);
  return iter;
}

//----- (0003E81C) --------------------------------------------------------
json_t_0 *__fastcall json_object_iter_value(json_t_0 *iter)
{
  if ( iter )
    return (json_t_0 *)hashtable_iter_value(iter);
  return iter;
}

//----- (0003E824) --------------------------------------------------------
int __fastcall json_object_iter_set_new(json_t_0 *json, void *iter, json_t_0 *value)
{
  bool v3; // zf

  if ( !json || json->type )
    return -1;
  v3 = iter == 0;
  if ( iter )
    v3 = value == 0;
  if ( v3 )
    return -1;
  hashtable_iter_set(iter, value);
  return 0;
}

//----- (0003E84C) --------------------------------------------------------
void *__fastcall json_object_key_to_iter(void *key)
{
  if ( key )
    return (char *)key - 16;
  return key;
}

//----- (0003E854) --------------------------------------------------------
json_array_t *json_array()
{
  json_array_t *result; // r0
  json_array_t *v1; // r4
  json_t_0 **v2; // r0
  json_array_t *v3; // r3
  json_array_t *array; // [sp+4h] [bp-14h] BYREF

  result = (json_array_t *)jsonp_malloc(0x18u);
  v1 = result;
  array = result;
  if ( result )
  {
    result->json.type = JSON_ARRAY;
    result->json.refcount = 1;
    result->entries = 0;
    result->size = 8;
    v2 = (json_t_0 **)jsonp_malloc(0x20u);
    v3 = array;
    v1->table = v2;
    if ( v3->table )
    {
      result = v3;
      v3->visited = 0;
    }
    else
    {
      jsonp_free((void **)&array);
      return 0;
    }
  }
  return result;
}

//----- (0003E894) --------------------------------------------------------
size_t __fastcall json_array_size(size_t json)
{
  if ( json )
  {
    if ( *(_DWORD *)json == 1 )
      return *(_DWORD *)(json + 12);
    else
      return 0;
  }
  return json;
}

//----- (0003E8A8) --------------------------------------------------------
json_t_0 *__fastcall json_array_get(json_t_0 *json, size_t index)
{
  if ( json )
  {
    if ( json->type == JSON_ARRAY && json[1].refcount > index )
      return *(json_t_0 **)(json[2].type + 4 * index);
    else
      return 0;
  }
  return json;
}

//----- (0003E8C4) --------------------------------------------------------
int __fastcall json_array_extend(json_t_0 *json, json_t_0 *other_json)
{
  size_t refcount; // r2
  char *type; // r1
  char *v6; // r4
  int v7; // r3
  int v8; // t1
  int result; // r0

  if ( !json
    || json->type != JSON_ARRAY
    || !other_json
    || other_json->type != JSON_ARRAY
    || !json_array_grow((json_array_t *)json, other_json[1].refcount, 1) )
  {
    return -1;
  }
  refcount = other_json[1].refcount;
  type = (char *)other_json[2].type;
  if ( refcount )
  {
    refcount *= 4;
    v6 = (char *)other_json[2].type;
    do
    {
      v8 = *(_DWORD *)v6;
      v6 += 4;
      v7 = v8;
      if ( v8 )
      {
        if ( *(_DWORD *)(v7 + 4) != -1 )
          ++*(_DWORD *)(v7 + 4);
      }
    }
    while ( v6 != &type[refcount] );
  }
  memcpy((void *)(json[2].type + 4 * json[1].refcount), type, refcount);
  result = 0;
  json[1].refcount += other_json[1].refcount;
  return result;
}

//----- (0003E930) --------------------------------------------------------
json_t_0 *__fastcall json_string_nocheck(const unsigned __int8 *value)
{
  json_string_t *v2; // r0
  json_string_t *v3; // r4
  unsigned __int8 *v4; // r0
  json_string_t *v5; // r3
  json_t_0 *result; // r0
  json_string_t *string; // [sp+4h] [bp-14h] BYREF

  if ( !value )
    return 0;
  v2 = (json_string_t *)jsonp_malloc(0xCu);
  v3 = v2;
  string = v2;
  if ( !v2 )
    return 0;
  v2->json.type = JSON_STRING;
  v2->json.refcount = 1;
  v4 = jsonp_strdup(value);
  v5 = string;
  v3->value = v4;
  result = &v5->json;
  if ( !v5->value )
  {
    jsonp_free((void **)&string);
    return 0;
  }
  return result;
}

//----- (0003E970) --------------------------------------------------------
json_t_0 *__fastcall json_string(const unsigned __int8 *value)
{
  if ( value && utf8_check_string(value, -1) )
    return json_string_nocheck(value);
  else
    return 0;
}

//----- (0003E990) --------------------------------------------------------
const unsigned __int8 *__fastcall json_string_value(const unsigned __int8 *json)
{
  if ( json )
  {
    if ( *(_DWORD *)json == 2 )
      return (const unsigned __int8 *)*((_DWORD *)json + 2);
    else
      return 0;
  }
  return json;
}

//----- (0003E9A0) --------------------------------------------------------
int __fastcall json_string_set_nocheck(json_t_0 *json, const unsigned __int8 *value)
{
  unsigned __int8 *v3; // r5
  int result; // r0

  if ( !json )
    return -1;
  if ( json->type != JSON_STRING )
    return -1;
  if ( !value )
    return -1;
  v3 = jsonp_strdup(value);
  if ( !v3 )
    return -1;
  jsonp_free((void **)&json[1]);
  result = 0;
  json[1].type = (json_type)v3;
  return result;
}

//----- (0003E9CC) --------------------------------------------------------
int __fastcall json_string_set(json_t_0 *json, const unsigned __int8 *value)
{
  if ( value && utf8_check_string(value, -1) )
    return json_string_set_nocheck(json, value);
  else
    return -1;
}

//----- (0003E9F4) --------------------------------------------------------
json_t_0 *__fastcall json_integer(json_int_t value)
{
  json_t_0 *result; // r0

  result = (json_t_0 *)jsonp_malloc(0x10u);
  if ( result )
  {
    result[1] = (json_t_0)value;
    result->type = JSON_INTEGER;
    result->refcount = 1;
  }
  return result;
}

//----- (0003EA10) --------------------------------------------------------
json_int_t __fastcall json_integer_value(const json_t_0 *json)
{
  if ( json && json->type == JSON_INTEGER )
    return (json_int_t)json[1];
  else
    return 0LL;
}

//----- (0003EA28) --------------------------------------------------------
int __fastcall json_integer_set(json_t_0 *json, int a2, json_int_t value)
{
  if ( !json || json->type != JSON_INTEGER )
    return -1;
  json[1] = (json_t_0)value;
  return 0;
}

//----- (0003EA40) --------------------------------------------------------
json_t_0 *__fastcall json_real(double value)
{
  json_t_0 v1; // d0
  double v2; // r0
  json_t_0 *result; // r0

  LODWORD(v2) = _isnan(value);
  if ( LODWORD(v2) )
    return 0;
  if ( _isinf(v2) )
    return 0;
  result = (json_t_0 *)jsonp_malloc(0x10u);
  if ( !result )
    return 0;
  result[1] = v1;
  result->type = JSON_REAL;
  result->refcount = 1;
  return result;
}
// 3EA54: variable 'v2' is possibly undefined
// 3EA68: variable 'v1' is possibly undefined

//----- (0003EA7C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall json_real_value(const json_t_0 *json)
{
  double result; // r0

  LODWORD(result) = json;
  return result;
}
// 3EA7C: variables would overlap: r0.4 and r0.8
// 3EA7C: bad return variable

//----- (0003EA98) --------------------------------------------------------
int __fastcall json_real_set(double json, double value)
{
  __int64 v2; // d0
  int v3; // r4
  double v4; // r0
  int result; // r0

  v3 = LODWORD(json);
  if ( !LODWORD(json) )
    return -1;
  if ( *(_DWORD *)LODWORD(json) != 4 )
    return -1;
  LODWORD(v4) = _isnan(json);
  if ( LODWORD(v4) )
    return -1;
  result = _isinf(v4);
  if ( result )
    return -1;
  *(_QWORD *)(v3 + 8) = v2;
  return result;
}
// 3EAB6: variable 'v4' is possibly undefined
// 3EABC: variable 'v2' is possibly undefined

//----- (0003EACC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall json_number_value(const json_t_0 *json)
{
  double result; // r0

  if ( json && json->type == JSON_INTEGER )
    *(double *)&json = (double)(__int64)json[1];
  LODWORD(result) = json;
  return result;
}
// 3EACC: variables would overlap: r0.4 and r0.8
// 3EACC: bad return variable

//----- (0003EB00) --------------------------------------------------------
json_t_0 *json_true()
{
  return &the_true_7530;
}

//----- (0003EB0C) --------------------------------------------------------
json_t_0 *json_false()
{
  return &the_false_7534;
}

//----- (0003EB14) --------------------------------------------------------
json_t_0 *json_null()
{
  return &the_null_7538;
}

//----- (0003EB1C) --------------------------------------------------------
void __fastcall json_delete(json_t_0 *json)
{
  void *v1; // r3
  json_type type; // r2
  size_t refcount; // r2
  unsigned int v4; // r4
  json_t_0 *v5; // r0
  size_t v6; // r3
  json_t_0 *v7; // [sp+4h] [bp-1Ch] BYREF
  json_t_0 *v8; // [sp+8h] [bp-18h] BYREF
  json_t_0 *v9; // [sp+Ch] [bp-14h] BYREF
  void *ptr; // [sp+10h] [bp-10h] BYREF
  json_t_0 *v11; // [sp+14h] [bp-Ch] BYREF

  v1 = json;
  if ( json )
  {
    type = json->type;
    if ( json->type )
    {
      switch ( type )
      {
        case JSON_ARRAY:
          refcount = json[1].refcount;
          ptr = json;
          if ( refcount )
          {
            v4 = 0;
            do
            {
              v5 = *(json_t_0 **)(*((_DWORD *)v1 + 4) + 4 * v4++);
              if ( v5 )
              {
                v6 = v5->refcount;
                if ( v6 != -1 )
                {
                  v5->refcount = v6 - 1;
                  if ( v6 == 1 )
                    json_delete(v5);
                }
              }
              v1 = ptr;
            }
            while ( v4 < *((_DWORD *)ptr + 3) );
          }
          jsonp_free((void **)v1 + 4);
          jsonp_free(&ptr);
          break;
        case JSON_STRING:
          v11 = json;
          jsonp_free((void **)&json[1]);
          jsonp_free((void **)&v11);
          break;
        case JSON_INTEGER:
          v7 = json;
          jsonp_free((void **)&v7);
          break;
        case JSON_REAL:
          v8 = json;
          jsonp_free((void **)&v8);
          break;
      }
    }
    else
    {
      v9 = json;
      hashtable_close((hashtable_t *)&json[1]);
      jsonp_free((void **)&v9);
    }
  }
}

//----- (0003EBB8) --------------------------------------------------------
int __fastcall json_array_clear(json_t_0 *json)
{
  size_t refcount; // r1
  size_t i; // r4
  json_t_0 *v4; // r0
  size_t v5; // r3
  int result; // r0

  if ( !json || json->type != JSON_ARRAY )
    return -1;
  refcount = json[1].refcount;
  if ( refcount )
  {
    for ( i = 0; i < refcount; ++i )
    {
      v4 = *(json_t_0 **)(json[2].type + 4 * i);
      if ( v4 )
      {
        v5 = v4->refcount;
        if ( v5 != -1 )
        {
          v4->refcount = v5 - 1;
          if ( v5 == 1 )
          {
            json_delete(v4);
            refcount = json[1].refcount;
          }
        }
      }
    }
  }
  result = 0;
  json[1].refcount = 0;
  return result;
}

//----- (0003EBF8) --------------------------------------------------------
int __fastcall json_array_remove(json_t_0 *json, size_t index)
{
  size_t refcount; // r3
  size_t v5; // r6
  json_t_0 *v6; // r0
  size_t v7; // r2
  size_t v8; // r2
  size_t v9; // r3

  if ( json )
  {
    if ( json->type == JSON_ARRAY )
    {
      refcount = json[1].refcount;
      if ( refcount > index )
      {
        v5 = 4 * index;
        v6 = *(json_t_0 **)(json[2].type + 4 * index);
        if ( !v6 || (v7 = v6->refcount, v7 == -1) || (v8 = v7 - 1, (v6->refcount = v8) != 0) )
        {
          v9 = refcount - 1;
          if ( index >= v9 )
          {
LABEL_8:
            json[1].refcount = v9;
            return 0;
          }
        }
        else
        {
          json_delete(v6);
          v9 = json[1].refcount - 1;
          if ( index >= v9 )
            goto LABEL_8;
        }
        memmove((void *)(json[2].type + v5), (const void *)(json[2].type + 4 * (index + 1)), 4 * (v9 - index));
        v9 = json[1].refcount - 1;
        goto LABEL_8;
      }
    }
  }
  return -1;
}

//----- (0003EC58) --------------------------------------------------------
int __fastcall json_array_insert_new(json_t_0 *json, size_t index, json_t_0 *value)
{
  json_t_0 **v6; // r1
  json_t_0 **type; // r0
  int result; // r0
  size_t v9; // r2
  size_t refcount; // r3
  size_t v11; // r3
  json_t_0 **old_table; // [sp+4h] [bp-1Ch] BYREF

  if ( !value )
    return -1;
  if ( !json
    || json->type != JSON_ARRAY
    || json == value
    || json[1].refcount < index
    || (v6 = json_array_grow((json_array_t *)json, 1u, 0), (old_table = v6) == 0) )
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v11 = refcount - 1;
      value->refcount = v11;
      if ( !v11 )
        json_delete(value);
    }
    return -1;
  }
  type = (json_t_0 **)json[2].type;
  if ( v6 == type )
  {
    memmove(&v6[index + 1], &v6[index], 4 * (json[1].refcount - index));
  }
  else
  {
    memcpy(type, v6, 4 * index);
    memcpy((void *)(json[2].type + 4 * (index + 1)), &old_table[index], 4 * (json[1].refcount - index));
    jsonp_free((void **)&old_table);
  }
  result = 0;
  v9 = json[1].refcount + 1;
  *(_DWORD *)(json[2].type + 4 * index) = value;
  json[1].refcount = v9;
  return result;
}

//----- (0003ECF8) --------------------------------------------------------
int __fastcall json_array_append_new(json_t_0 *json, json_t_0 *value)
{
  size_t refcount; // r3
  int result; // r0
  size_t v6; // r3
  size_t v7; // r3

  if ( value )
  {
    if ( json && json->type == JSON_ARRAY && json != value && json_array_grow((json_array_t *)json, 1u, json->type) )
    {
      refcount = json[1].refcount;
      result = 0;
      *(_DWORD *)(json[2].type + 4 * refcount) = value;
      json[1].refcount = refcount + 1;
      return result;
    }
    v6 = value->refcount;
    if ( v6 != -1 )
    {
      v7 = v6 - 1;
      value->refcount = v7;
      if ( !v7 )
        json_delete(value);
    }
  }
  return -1;
}

//----- (0003ED3C) --------------------------------------------------------
int __fastcall json_array_set_new(json_t_0 *json, size_t index, json_t_0 *value)
{
  json_type type; // r3
  size_t v6; // r6
  json_t_0 *v7; // r0
  json_t_0 **v8; // r3
  size_t v9; // r2
  size_t v10; // r2
  int result; // r0
  size_t refcount; // r3
  size_t v13; // r3

  if ( !value )
    return -1;
  if ( !json || json->type != JSON_ARRAY || json == value || json[1].refcount <= index )
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v13 = refcount - 1;
      value->refcount = v13;
      if ( !v13 )
        json_delete(value);
    }
    return -1;
  }
  type = json[2].type;
  v6 = 4 * index;
  v7 = *(json_t_0 **)(type + 4 * index);
  v8 = (json_t_0 **)(type + 4 * index);
  if ( v7 )
  {
    v9 = v7->refcount;
    if ( v9 != -1 )
    {
      v10 = v9 - 1;
      v7->refcount = v10;
      if ( !v10 )
      {
        json_delete(v7);
        v8 = (json_t_0 **)(json[2].type + v6);
      }
    }
  }
  result = 0;
  *v8 = value;
  return result;
}

//----- (0003ED98) --------------------------------------------------------
int __fastcall json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value)
{
  bool v4; // zf
  size_t v5; // r2
  int result; // r0
  size_t refcount; // r3
  size_t v8; // r3

  if ( !value )
    return -1;
  v4 = json == 0;
  if ( json )
    v4 = key == 0;
  if ( v4
    || json->type
    || json == value
    || (v5 = json[3].refcount,
        json[3].refcount = v5 + 1,
        (result = hashtable_set((hashtable_t *)&json[1], key, v5, value)) != 0) )
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v8 = refcount - 1;
      value->refcount = v8;
      if ( !v8 )
        json_delete(value);
    }
    return -1;
  }
  return result;
}

//----- (0003EDDC) --------------------------------------------------------
int __fastcall json_object_update_missing(json_t_0 *object, json_t_0 *other)
{
  void *v4; // r0
  const unsigned __int8 *i; // r4
  void *v6; // r0
  json_t_0 *v7; // r6

  if ( !object || object->type || !other || other->type )
    return -1;
  v4 = json_object_iter(other);
  for ( i = json_object_iter_key(v4); i; i = json_object_iter_key(v6) )
  {
    v7 = json_object_iter_value((void *)(i - 16));
    if ( !v7 )
      break;
    if ( !json_object_get(object, i) )
    {
      if ( v7->refcount != -1 )
        ++v7->refcount;
      json_object_set_new_nocheck(object, i, v7);
    }
    v6 = json_object_iter_next(other, (void *)(i - 16));
  }
  return 0;
}

//----- (0003EE58) --------------------------------------------------------
int __fastcall json_object_set_new(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value)
{
  size_t refcount; // r3
  size_t v8; // r3

  if ( key && utf8_check_string(key, -1) )
    return json_object_set_new_nocheck(json, key, value);
  if ( value )
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v8 = refcount - 1;
      value->refcount = v8;
      if ( !v8 )
        json_delete(value);
    }
  }
  return -1;
}

//----- (0003EE98) --------------------------------------------------------
int __fastcall json_object_update(json_t_0 *object, json_t_0 *other)
{
  void *v4; // r0
  const unsigned __int8 *i; // r4
  void *v6; // r0
  json_t_0 *v7; // r0

  if ( !object || object->type || !other || other->type )
    return -1;
  v4 = json_object_iter(other);
  for ( i = json_object_iter_key(v4); i; i = json_object_iter_key(v6) )
  {
    v7 = json_object_iter_value((void *)(i - 16));
    if ( !v7 )
      break;
    if ( v7->refcount != -1 )
      ++v7->refcount;
    if ( json_object_set_new_nocheck(object, i, v7) )
      return -1;
    v6 = json_object_iter_next(other, (void *)(i - 16));
  }
  return 0;
}

//----- (0003EF00) --------------------------------------------------------
int __fastcall json_object_update_existing(json_t_0 *object, json_t_0 *other)
{
  void *v4; // r0
  const unsigned __int8 *i; // r4
  json_t_0 *v6; // r5
  void *v7; // r0

  if ( !object || object->type || !other || other->type )
    return -1;
  v4 = json_object_iter(other);
  for ( i = json_object_iter_key(v4); i; i = json_object_iter_key(v7) )
  {
    v6 = json_object_iter_value((void *)(i - 16));
    if ( !v6 )
      break;
    if ( json_object_get(object, i) )
    {
      if ( v6->refcount != -1 )
        ++v6->refcount;
      json_object_set_new_nocheck(object, i, v6);
    }
    v7 = json_object_iter_next(other, (void *)(i - 16));
  }
  return 0;
}

//----- (0003EF78) --------------------------------------------------------
int __fastcall json_equal(json_t_0 *json1, json_t_0 *json2)
{
  bool v2; // zf
  int v3; // r2
  json_type type; // r3
  void *v8; // r0
  const unsigned __int8 *v9; // r5
  void *v10; // r0
  json_t_0 *v11; // r8
  json_t_0 *v12; // r0
  size_t refcount; // r7
  size_t v14; // r5
  json_type v15; // r2
  json_t_0 *v16; // r1
  json_t_0 *v17; // r0

  v2 = json1 == 0;
  if ( json1 )
    v2 = json2 == 0;
  v3 = v2;
  if ( v2 )
    return 0;
  type = json1->type;
  if ( json1->type != json2->type )
    return v3;
  if ( json1 == json2 )
    return 1;
  switch ( type )
  {
    case JSON_OBJECT:
      if ( json1[1].type == json2[1].type )
      {
        v8 = json_object_iter(json1);
        v9 = json_object_iter_key(v8);
        if ( v9 )
        {
          while ( 1 )
          {
            v11 = json_object_iter_value((void *)(v9 - 16));
            if ( !v11 )
              break;
            v12 = json_object_get(json2, v9);
            if ( !json_equal(v11, v12) )
              return 0;
            v10 = json_object_iter_next(json1, (void *)(v9 - 16));
            v9 = json_object_iter_key(v10);
            if ( !v9 )
              return 1;
          }
        }
        return 1;
      }
      return 0;
    case JSON_ARRAY:
      refcount = json1[1].refcount;
      if ( refcount == json2[1].refcount )
      {
        if ( refcount )
        {
          v14 = v3;
          v15 = json1->type;
          while ( 1 )
          {
            v17 = v15 == JSON_ARRAY && json1[1].refcount > v14 ? *(json_t_0 **)(json1[2].type + 4 * v14) : 0;
            v16 = type == JSON_ARRAY && json2[1].refcount > v14 ? *(json_t_0 **)(json2[2].type + 4 * v14) : 0;
            if ( !json_equal(v17, v16) )
              break;
            if ( ++v14 == refcount )
              return 1;
            v15 = json1->type;
            type = json2->type;
          }
          return 0;
        }
        return 1;
      }
      return 0;
    case JSON_STRING:
      return strcmp((const char *)json1[1].type, (const char *)json2[1].type) == 0;
    case JSON_INTEGER:
      return *(_QWORD *)&json1[1] == *(_QWORD *)&json2[1];
  }
  if ( type != JSON_REAL )
    return v3;
  return *(double *)&json1[1] == *(double *)&json2[1];
}

//----- (0003F09C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__fastcall json_copy(json_t_0 *json)
{
  json_t_0 *v1; // r4
  json_type type; // r3
  json_object_t *v4; // r7
  void *v5; // r0
  const unsigned __int8 *j; // r5
  json_t_0 *v7; // r3
  void *v8; // r0
  json_array_t *v9; // r6
  size_t refcount; // r3
  size_t i; // r5
  json_t_0 *v12; // r1

  v1 = json;
  if ( !json )
    return 0;
  type = json->type;
  if ( json->type )
  {
    switch ( type )
    {
      case JSON_ARRAY:
        v9 = json_array();
        if ( v9 )
        {
          if ( v1->type == JSON_ARRAY )
          {
            refcount = v1[1].refcount;
            if ( refcount )
            {
              for ( i = 0; i < refcount; ++i )
              {
                v12 = 0;
                if ( refcount > i )
                {
                  v12 = *(json_t_0 **)(v1[2].type + 4 * i);
                  if ( v12 )
                  {
                    if ( v12->refcount != -1 )
                      ++v12->refcount;
                  }
                }
                json_array_append_new(&v9->json, v12);
                if ( v1->type != JSON_ARRAY )
                  break;
                refcount = v1[1].refcount;
              }
            }
          }
        }
        return &v9->json;
      case JSON_STRING:
        return json_string_nocheck((const unsigned __int8 *)json[1].type);
      case JSON_INTEGER:
        return json_integer(*(_QWORD *)&json[1]);
      case JSON_REAL:
        return json_real(*(double *)&json);
      default:
        if ( (unsigned int)(type - 5) <= 2 )
          return v1;
        return 0;
    }
  }
  else
  {
    v4 = json_object();
    if ( v4 )
    {
      v5 = json_object_iter(v1);
      for ( j = json_object_iter_key(v5); j; j = json_object_iter_key(v8) )
      {
        v7 = json_object_iter_value((void *)(j - 16));
        if ( !v7 )
          break;
        if ( v7->refcount != -1 )
          ++v7->refcount;
        json_object_set_new_nocheck(&v4->json, j, v7);
        v8 = json_object_iter_next(v1, (void *)(j - 16));
      }
    }
    return &v4->json;
  }
}
// 3F09C: variables would overlap: r0.4 and r0.8

//----- (0003F188) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__fastcall json_deep_copy(const json_t_0 *json)
{
  json_t_0 *v1; // r5
  json_type type; // r3
  json_object_t *v4; // r7
  void *j; // r4
  const unsigned __int8 *v6; // r6
  json_t_0 *v7; // r0
  json_t_0 *v8; // r0
  json_array_t *v9; // r6
  size_t refcount; // r3
  size_t i; // r4
  const json_t_0 *v12; // r0
  json_t_0 *v13; // r0

  v1 = (json_t_0 *)json;
  if ( !json )
    return v1;
  type = json->type;
  if ( json->type )
  {
    switch ( type )
    {
      case JSON_ARRAY:
        v9 = json_array();
        if ( v9 )
        {
          if ( v1->type == JSON_ARRAY )
          {
            refcount = v1[1].refcount;
            if ( refcount )
            {
              for ( i = 0; i < refcount; ++i )
              {
                v12 = 0;
                if ( i < refcount )
                  v12 = *(const json_t_0 **)(v1[2].type + 4 * i);
                v13 = json_deep_copy(v12);
                json_array_append_new(&v9->json, v13);
                if ( v1->type != JSON_ARRAY )
                  break;
                refcount = v1[1].refcount;
              }
            }
          }
        }
        return &v9->json;
      case JSON_STRING:
        return json_string_nocheck((const unsigned __int8 *)json[1].type);
      case JSON_INTEGER:
        return json_integer(*(_QWORD *)&json[1]);
      case JSON_REAL:
        return json_real(*(double *)&json);
      default:
        if ( (unsigned int)(type - 5) > 2 )
          return 0;
        return v1;
    }
  }
  else
  {
    v4 = json_object();
    if ( v4 )
    {
      for ( j = json_object_iter(v1); j; j = json_object_iter_next(v1, j) )
      {
        v6 = json_object_iter_key(j);
        v7 = json_object_iter_value(j);
        v8 = json_deep_copy(v7);
        json_object_set_new_nocheck(&v4->json, v6, v8);
      }
    }
    return &v4->json;
  }
}
// 3F188: variables would overlap: r0.4 and r0.8

//----- (0003F258) --------------------------------------------------------
void *__fastcall rpl_memchr(void *s, int c_in, size_t n)
{
  char *v3; // r3
  int v5; // r6
  _DWORD *v6; // r4
  char *v7; // r2
  char *v8; // r3

  if ( !n )
    return (void *)n;
  if ( (_DWORD)s << 30 )
  {
    if ( *(unsigned __int8 *)s == (unsigned __int8)c_in )
      return s;
    v3 = (char *)s + 1;
    while ( 1 )
    {
      --n;
      s = v3;
      if ( !n )
        return (void *)n;
      if ( ((unsigned __int8)v3++ & 3) == 0 )
        break;
      if ( *(unsigned __int8 *)s == (unsigned __int8)c_in )
        return s;
    }
  }
  v5 = (unsigned __int8)c_in | ((unsigned __int8)c_in << 8) | (((unsigned __int8)c_in | ((unsigned __int8)c_in << 8)) << 16);
  if ( n > 3 && (((*(_DWORD *)s ^ v5) - 16843009) & ~(*(_DWORD *)s ^ v5) & 0x80808080) == 0 )
  {
    s = (char *)s + 4;
    while ( 1 )
    {
      n -= 4;
      v6 = s;
      if ( n <= 3 )
        break;
      s = (char *)s + 4;
      if ( (((*v6 ^ v5) - 16843009) & ~(*v6 ^ v5) & 0x80808080) != 0 )
      {
        s = v6;
        goto LABEL_17;
      }
    }
    if ( !n )
      return (void *)n;
  }
LABEL_17:
  if ( *(unsigned __int8 *)s != (unsigned __int8)c_in )
  {
    v7 = (char *)s + n;
    v8 = (char *)s + 1;
    while ( 1 )
    {
      s = v8++;
      if ( s == v7 )
        break;
      if ( *(unsigned __int8 *)s == (unsigned __int8)c_in )
        return s;
    }
    return 0;
  }
  return s;
}

//----- (0003F2F0) --------------------------------------------------------
size_t __fastcall critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period)
{
  size_t v3; // r7
  int v4; // r4
  int v5; // r5
  int v6; // r6
  size_t v7; // r3
  const unsigned __int8 *v8; // r12
  unsigned int v9; // r12
  unsigned int v10; // r8
  size_t v11; // r10
  int v12; // r5
  int v13; // r4
  int v14; // r12
  size_t v15; // r3
  const unsigned __int8 *v16; // r8
  unsigned int v17; // r8
  unsigned int v18; // r9
  size_t result; // r0
  size_t v20; // r6

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v5 + v4;
    v8 = &needle[v6];
    if ( v5 + v4 >= needle_len )
      break;
    while ( 1 )
    {
      v9 = v8[v4];
      v10 = needle[v7];
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = &needle[v6];
      if ( v7 >= needle_len )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      if ( v4 == v3 )
      {
        v3 = v4;
        v5 = v7;
        v4 = 1;
      }
      else
      {
        ++v4;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *period = v3;
  while ( 1 )
  {
    v15 = v12 + v13;
    v16 = &needle[v14];
    if ( needle_len <= v12 + v13 )
      break;
    while ( 1 )
    {
      v17 = v16[v13];
      v18 = needle[v15];
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = &needle[v14];
      if ( needle_len <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      if ( v13 == v11 )
      {
        v11 = v13;
        v12 = v15;
        v13 = 1;
      }
      else
      {
        ++v13;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  result = v14 + 1;
  v20 = v6 + 1;
  if ( v14 + 1 < v20 )
  {
    v11 = v3;
    result = v20;
  }
  *period = v11;
  return result;
}

//----- (0003F3AC) --------------------------------------------------------
void *__fastcall two_way_long_needle(
        const unsigned __int8 *haystack,
        size_t haystack_len,
        const unsigned __int8 *needle,
        size_t needle_len)
{
  size_t v7; // r10
  size_t v8; // r4
  size_t *p_period; // r3
  int v10; // r3
  int v11; // r2
  size_t v12; // r1
  unsigned int v13; // r0
  unsigned int v14; // r5
  size_t v15; // r3
  size_t v16; // r3
  const unsigned __int8 *v17; // r2
  int v18; // t1
  unsigned int v19; // r1
  const unsigned __int8 *v20; // r3
  int v21; // t1
  size_t v23; // r3
  size_t v24; // r2
  size_t v25; // r3
  const unsigned __int8 *v26; // r1
  int v27; // t1
  size_t v28; // r3
  size_t v30; // [sp+8h] [bp-450h]
  size_t v32; // [sp+14h] [bp-444h]
  size_t v33; // [sp+18h] [bp-440h]
  size_t period; // [sp+2Ch] [bp-42Ch] BYREF
  size_t shift_table[256]; // [sp+30h] [bp-428h] BYREF

  if ( needle_len <= 2 )
  {
    v8 = needle_len - 1;
    v33 = 1;
    v7 = needle_len - 1;
    period = 1;
  }
  else
  {
    v7 = critical_factorization(needle, needle_len, &period);
    v8 = needle_len - 1;
    v33 = period;
  }
  p_period = &period;
  do
  {
    p_period[1] = needle_len;
    ++p_period;
  }
  while ( p_period != &shift_table[255] );
  v10 = 0;
  if ( needle_len )
  {
    do
    {
      v11 = needle[v10];
      v12 = v8 - v10++;
      shift_table[v11] = v12;
    }
    while ( v10 != needle_len );
  }
  v13 = memcmp(needle, &needle[v33], v7);
  if ( v13 )
  {
    v23 = needle_len - v7;
    if ( needle_len - v7 < v7 )
      v23 = v7;
    v32 = v23 + 1;
    v24 = 0;
    while ( 1 )
    {
      v25 = shift_table[haystack[v8 + v24]];
      if ( v25 )
        goto LABEL_50;
      if ( v7 < v8 )
      {
        if ( needle[v7] != haystack[v24 + v7] )
        {
          v25 = v7;
LABEL_49:
          v24 += 1 - v7;
LABEL_50:
          v24 += v25;
          goto LABEL_51;
        }
        v26 = &needle[v7];
        v25 = v7;
        while ( ++v25 < v8 )
        {
          v27 = *++v26;
          if ( haystack[v24 + v25] != v27 )
            goto LABEL_49;
        }
      }
      v28 = v7 - 1;
      if ( !v7 )
        return (void *)&haystack[v24];
      if ( needle[v7 - 1] == haystack[v7 - 1 + v24] )
      {
        do
        {
          if ( v28-- == 0 )
            return (void *)&haystack[v24];
        }
        while ( needle[v28] == haystack[v24 + v28] );
      }
      v24 += v32;
LABEL_51:
      if ( haystack_len - needle_len < v24 )
        return 0;
    }
  }
  v30 = haystack_len - needle_len;
  v14 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v15 = shift_table[haystack[v8 + v14]];
      if ( v15 )
      {
        if ( v13 && v33 > v15 )
          v15 = needle_len - v33;
        v14 += v15;
        v13 = 0;
        goto LABEL_13;
      }
      v16 = v7;
      if ( v13 >= v7 )
        v16 = v13;
      if ( v16 >= v8 )
        goto LABEL_22;
      v17 = &needle[v16];
      if ( needle[v16] == haystack[v16 + v14] )
        break;
LABEL_32:
      v13 = 0;
      v14 += 1 - v7 + v16;
LABEL_13:
      if ( v30 < v14 )
        return 0;
    }
    while ( ++v16 < v8 )
    {
      v18 = *++v17;
      if ( haystack[v14 + v16] != v18 )
        goto LABEL_32;
    }
LABEL_22:
    v19 = v7 - 1;
    if ( v7 > v13 )
    {
      if ( needle[v7 - 1] == haystack[v14 - 1 + v7] )
      {
        v20 = &needle[v7 - 1];
        while ( v20 != &needle[v13] )
        {
          v21 = *--v20;
          if ( v21 != haystack[v14 - 1 + v19] )
            break;
          --v19;
        }
      }
      else
      {
        v19 = v7;
      }
    }
    else
    {
      v19 = v7;
    }
    if ( v13 + 1 > v19 )
      return (void *)&haystack[v14];
    v13 = needle_len - v33;
    v14 += v33;
    if ( v30 < v14 )
      return 0;
  }
}

//----- (0003F5C8) --------------------------------------------------------
void *__fastcall memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len)
{
  void *v8; // r9
  _BYTE *v9; // r0
  bool v10; // zf
  char *v11; // r5
  size_t v12; // r10
  unsigned int v13; // r0
  size_t v14; // r11
  size_t v15; // r3
  char *v16; // r2
  int v17; // t1
  unsigned int v18; // r1
  char *v19; // r3
  int v20; // t1
  size_t v22; // r3
  char *v23; // r11
  char *v24; // r6
  char *v25; // r2
  size_t v26; // r3
  int v27; // t1
  size_t v28; // r3
  char *v29; // r5
  size_t v31; // [sp+8h] [bp-40h]
  size_t v32; // [sp+8h] [bp-40h]
  size_t period; // [sp+1Ch] [bp-2Ch] BYREF

  v8 = (void *)haystack_start;
  if ( needle_len )
  {
    if ( needle_len > haystack_len )
      return 0;
    if ( needle_len > 0x1F )
      return two_way_long_needle(
               (const unsigned __int8 *)haystack_start,
               haystack_len,
               (const unsigned __int8 *)needle_start,
               needle_len);
    v9 = rpl_memchr(haystack_start, *(unsigned __int8 *)needle_start, haystack_len);
    v10 = needle_len == 1;
    if ( needle_len != 1 )
      v10 = v9 == 0;
    v8 = v9;
    if ( !v10 )
    {
      v11 = (char *)((_BYTE *)haystack_start - v9 + haystack_len);
      if ( needle_len > (unsigned int)v11 )
        return 0;
      if ( needle_len <= 2 )
      {
        v12 = needle_len - 1;
        v31 = 1;
        period = 1;
      }
      else
      {
        v12 = critical_factorization((const unsigned __int8 *)needle_start, needle_len, &period);
        v31 = period;
      }
      v13 = memcmp(needle_start, (char *)needle_start + v31, v12);
      if ( !v13 )
      {
        v14 = 0;
        while ( 1 )
        {
          if ( v14 < v12 )
            v15 = v12;
          else
            v15 = v14;
          if ( needle_len > v15 )
          {
            v16 = (char *)needle_start + v15;
            if ( *((unsigned __int8 *)needle_start + v15) != *((unsigned __int8 *)v8 + v15 + v13) )
            {
LABEL_35:
              v14 = 0;
              v13 += 1 - v12 + v15;
              goto LABEL_31;
            }
            while ( needle_len > ++v15 )
            {
              v17 = (unsigned __int8)*++v16;
              if ( *((unsigned __int8 *)v8 + v13 + v15) != v17 )
                goto LABEL_35;
            }
          }
          v18 = v12 - 1;
          if ( v12 > v14 && *((unsigned __int8 *)needle_start + v12 - 1) == *((unsigned __int8 *)v8 + v13 + v12 - 1) )
          {
            v19 = (char *)needle_start + v12 - 1;
            while ( v19 != (char *)needle_start + v14 )
            {
              v20 = (unsigned __int8)*--v19;
              if ( v20 != *((unsigned __int8 *)v8 + v13 + v18 - 1) )
                break;
              --v18;
            }
          }
          else
          {
            v18 = v12;
          }
          if ( v14 + 1 > v18 )
            return (char *)v8 + v13;
          v14 = needle_len - v31;
          v13 += v31;
LABEL_31:
          if ( (unsigned int)&v11[-needle_len] < v13 )
            return 0;
        }
      }
      v22 = needle_len - v12;
      if ( needle_len - v12 < v12 )
        v22 = v12;
      v23 = &v11[-needle_len];
      v24 = 0;
      v32 = v22 + 1;
      period = v22 + 1;
      while ( 1 )
      {
        if ( needle_len > v12 )
        {
          if ( *((unsigned __int8 *)needle_start + v12) != (unsigned __int8)v24[(_DWORD)v8 + v12] )
          {
            v26 = v12;
LABEL_51:
            v24 += 1 - v12 + v26;
            goto LABEL_52;
          }
          v25 = (char *)needle_start + v12;
          v26 = v12;
          while ( needle_len > ++v26 )
          {
            v27 = (unsigned __int8)*++v25;
            if ( (unsigned __int8)v24[(_DWORD)v8 + v26] != v27 )
              goto LABEL_51;
          }
        }
        v28 = v12 - 1;
        if ( !v12 )
          return &v24[(_DWORD)v8];
        if ( *((unsigned __int8 *)needle_start + v12 - 1) == (unsigned __int8)v24[(_DWORD)v8 + v12 - 1] )
        {
          v29 = &v24[(_DWORD)v8];
          while ( v28-- != 0 )
          {
            if ( *((unsigned __int8 *)needle_start + v28) != (unsigned __int8)v29[v28] )
              goto LABEL_54;
          }
          return v29;
        }
LABEL_54:
        v24 += v32;
LABEL_52:
        if ( v23 < v24 )
          return 0;
      }
    }
  }
  return v8;
}

//----- (0003F798) --------------------------------------------------------
int __fastcall uncompress(int a1, int *a2, unsigned int a3, int a4)
{
  int v4; // r6
  int v6; // r4
  unsigned int v8; // [sp+0h] [bp-48h] BYREF
  int v9; // [sp+4h] [bp-44h]
  int v10; // [sp+Ch] [bp-3Ch]
  int v11; // [sp+10h] [bp-38h]
  int v12; // [sp+14h] [bp-34h]
  int v13; // [sp+20h] [bp-28h]
  int v14; // [sp+24h] [bp-24h]

  v4 = *a2;
  v8 = a3;
  v10 = a1;
  v13 = 0;
  v14 = 0;
  v9 = a4;
  v11 = v4;
  v6 = inflateInit_(&v8, "1.2.8", 56);
  if ( !v6 )
  {
    v6 = inflate(&v8, 4);
    if ( v6 == 1 )
    {
      *a2 = v12;
      return inflateEnd(&v8);
    }
    else
    {
      inflateEnd(&v8);
      if ( v6 == 2 )
      {
        return -3;
      }
      else if ( v6 == -5 && !v9 )
      {
        return -3;
      }
    }
  }
  return v6;
}

//----- (0003F804) --------------------------------------------------------
int __fastcall updatewindow(int a1, int a2, size_t n)
{
  int v4; // r4
  char *v6; // r2
  unsigned int v7; // r3
  int v8; // r0
  size_t v9; // r3
  char *v10; // r0
  size_t v11; // r6
  size_t v12; // r5
  unsigned int v13; // r1
  size_t v14; // r3
  bool v15; // zf
  unsigned int v16; // r3
  int result; // r0
  int v18; // r3
  int v19; // r3
  int v20; // r3
  int v21; // r0

  v4 = *(_DWORD *)(a1 + 28);
  v6 = *(char **)(v4 + 52);
  if ( !v6 )
  {
    v21 = (*(int (__fastcall **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1 << *(_DWORD *)(v4 + 36), 1);
    *(_DWORD *)(v4 + 52) = v21;
    if ( !v21 )
      return 1;
    v6 = (char *)v21;
  }
  v7 = *(_DWORD *)(v4 + 40);
  if ( v7 )
  {
    if ( v7 > n )
      goto LABEL_4;
LABEL_13:
    memcpy(v6, (const void *)(a2 - v7), v7);
    v19 = *(_DWORD *)(v4 + 40);
    result = 0;
    *(_DWORD *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 44) = v19;
    return result;
  }
  v18 = *(_DWORD *)(v4 + 36);
  *(_DWORD *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  v7 = 1 << v18;
  *(_DWORD *)(v4 + 40) = v7;
  if ( v7 <= n )
    goto LABEL_13;
LABEL_4:
  v8 = *(_DWORD *)(v4 + 48);
  v9 = v7 - v8;
  v10 = &v6[v8];
  if ( v9 >= n )
    v11 = n;
  else
    v11 = v9;
  memcpy(v10, (const void *)(a2 - n), v11);
  v12 = n - v11;
  if ( v12 )
  {
    memcpy(*(void **)(v4 + 52), (const void *)(a2 - v12), v12);
    v20 = *(_DWORD *)(v4 + 40);
    result = 0;
    *(_DWORD *)(v4 + 48) = v12;
    *(_DWORD *)(v4 + 44) = v20;
  }
  else
  {
    v13 = *(_DWORD *)(v4 + 40);
    v14 = v11 + *(_DWORD *)(v4 + 48);
    v15 = v14 == v13;
    *(_DWORD *)(v4 + 48) = v14;
    v16 = *(_DWORD *)(v4 + 44);
    if ( v15 )
      *(_DWORD *)(v4 + 48) = 0;
    result = 0;
    if ( v13 > v16 )
      *(_DWORD *)(v4 + 44) = v11 + v16;
  }
  return result;
}

//----- (0003F8AC) --------------------------------------------------------
int __fastcall inflateResetKeep(_DWORD *a1)
{
  _DWORD *v1; // r3
  int v2; // r1
  int result; // r0

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  v2 = v1[2];
  v1[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( v2 )
    a1[12] = v2 & 1;
  result = 0;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[8] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[5] = 0x8000;
  v1[27] = v1 + 332;
  v1[20] = v1 + 332;
  v1[19] = v1 + 332;
  v1[1776] = 1;
  v1[1777] = -1;
  return result;
}

//----- (0003F908) --------------------------------------------------------
int __fastcall inflateReset(_DWORD *a1)
{
  _DWORD *v1; // r3
  int v2; // r1
  int result; // r0

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  v2 = v1[2];
  v1[10] = 0;
  v1[11] = 0;
  v1[12] = 0;
  v1[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( v2 )
    a1[12] = v2 & 1;
  result = 0;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[8] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[5] = 0x8000;
  v1[27] = v1 + 332;
  v1[20] = v1 + 332;
  v1[19] = v1 + 332;
  v1[1776] = 1;
  v1[1777] = -1;
  return result;
}

//----- (0003F968) --------------------------------------------------------
int __fastcall inflateReset2(int a1, int a2)
{
  int v3; // r4
  _DWORD *v4; // r6
  int v5; // r7
  bool v6; // cc
  _DWORD *v7; // r3
  int result; // r0
  int v9; // r1

  v3 = a2;
  if ( !a1 )
    return -2;
  v4 = *(_DWORD **)(a1 + 28);
  if ( !v4 )
    return -2;
  if ( a2 >= 0 )
  {
    if ( a2 <= 47 )
      v3 = a2 & 0xF;
    v5 = (a2 >> 4) + 1;
  }
  else
  {
    v3 = -a2;
    v5 = 0;
  }
  v6 = v3 != 0;
  if ( v3 )
    v6 = (unsigned int)(v3 - 8) > 7;
  if ( v6 )
    return -2;
  if ( !v4[13] || v3 == v4[9] )
  {
    v7 = *(_DWORD **)(a1 + 28);
    v4[2] = v5;
    v4[9] = v3;
  }
  else
  {
    (*(void (__fastcall **)(_DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40));
    v7 = *(_DWORD **)(a1 + 28);
    v4[13] = 0;
    v4[2] = v5;
    v4[9] = v3;
    if ( !v7 )
      return -2;
  }
  v9 = v7[2];
  v7[10] = 0;
  v7[11] = 0;
  v7[12] = 0;
  v7[7] = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if ( v9 )
    *(_DWORD *)(a1 + 48) = v9 & 1;
  *v7 = 0;
  result = 0;
  v7[1] = 0;
  v7[3] = 0;
  v7[8] = 0;
  v7[14] = 0;
  v7[15] = 0;
  v7[5] = 0x8000;
  v7[27] = v7 + 332;
  v7[20] = v7 + 332;
  v7[19] = v7 + 332;
  v7[1776] = 1;
  v7[1777] = -1;
  return result;
}

//----- (0003FA18) --------------------------------------------------------
int __fastcall inflateInit2_(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  void *(__fastcall *v6)(int, int, int); // r3
  _DWORD *v7; // r0
  _DWORD *v8; // r5
  int v9; // r6

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v6 = (void *(__fastcall *)(int, int, int))a1[8];
  a1[6] = 0;
  if ( !v6 )
  {
    a1[10] = 0;
    a1[8] = zcalloc;
    v6 = zcalloc;
    if ( a1[9] )
      goto LABEL_7;
LABEL_13:
    a1[9] = zcfree;
    goto LABEL_7;
  }
  if ( !a1[9] )
    goto LABEL_13;
LABEL_7:
  v7 = v6(a1[10], 1, 7116);
  v8 = v7;
  if ( !v7 )
    return -4;
  a1[7] = v7;
  v7[13] = 0;
  v9 = inflateReset2((int)a1, a2);
  if ( !v9 )
    return v9;
  ((void (__fastcall *)(_DWORD, _DWORD *))a1[9])(a1[10], v8);
  a1[7] = 0;
  return v9;
}

//----- (0003FAA4) --------------------------------------------------------
int __fastcall inflateInit_(_DWORD *a1, _BYTE *a2, int a3)
{
  void *(__fastcall *v4)(int, int, int); // r3
  _DWORD *v5; // r0
  _DWORD *v6; // r5
  int v7; // r6

  if ( !a2 || *a2 != 49 || a3 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v4 = (void *(__fastcall *)(int, int, int))a1[8];
  a1[6] = 0;
  if ( !v4 )
  {
    a1[10] = 0;
    a1[8] = zcalloc;
    v4 = zcalloc;
    if ( a1[9] )
      goto LABEL_7;
LABEL_13:
    a1[9] = zcfree;
    goto LABEL_7;
  }
  if ( !a1[9] )
    goto LABEL_13;
LABEL_7:
  v5 = v4(a1[10], 1, 7116);
  v6 = v5;
  if ( !v5 )
    return -4;
  a1[7] = v5;
  v5[13] = 0;
  v7 = inflateReset2((int)a1, 15);
  if ( !v7 )
    return v7;
  ((void (__fastcall *)(_DWORD, _DWORD *))a1[9])(a1[10], v6);
  a1[7] = 0;
  return v7;
}

//----- (0003FB30) --------------------------------------------------------
int __fastcall inflatePrime(int a1, int a2, int a3)
{
  int v3; // r3
  int v4; // r4
  int v5; // r5
  int result; // r0

  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 28);
    if ( v3 )
    {
      if ( a2 < 0 )
      {
        *(_DWORD *)(v3 + 56) = 0;
        result = 0;
        *(_DWORD *)(v3 + 60) = 0;
        return result;
      }
      if ( a2 <= 16 )
      {
        v4 = *(_DWORD *)(v3 + 60);
        if ( (unsigned int)(a2 + v4) <= 0x20 )
        {
          v5 = *(_DWORD *)(v3 + 56);
          *(_DWORD *)(v3 + 60) = a2 + v4;
          result = 0;
          *(_DWORD *)(v3 + 56) = v5 + ((a3 & ((1 << a2) - 1)) << v4);
          return result;
        }
      }
    }
  }
  return -2;
}

//----- (0003FB74) --------------------------------------------------------
int __fastcall inflate(unsigned int *a1, int a2)
{
  unsigned int v2; // r9
  int v3; // r2
  unsigned int v4; // r8
  unsigned int v5; // r4
  unsigned __int8 *v6; // r11
  unsigned int *v7; // r12
  unsigned int v8; // r10
  unsigned int v9; // r7
  unsigned __int8 *v10; // r3
  int v11; // t1
  int v12; // r2
  int v13; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r3
  int v17; // r0
  int v18; // t1
  int v19; // r3
  int v20; // r3
  unsigned int v21; // r1
  unsigned __int8 *v22; // r3
  int v23; // t1
  int v24; // r2
  int v25; // r0
  unsigned int v26; // r3
  unsigned int v27; // r2
  unsigned int v28; // r3
  bool v29; // cc
  int v30; // r3
  int v31; // r2
  int v32; // r5
  unsigned __int8 *v33; // r0
  int v34; // r1
  unsigned int v35; // r3
  int v36; // r0
  unsigned __int8 *v37; // r4
  int v38; // t1
  int v39; // r3
  unsigned __int8 *v40; // r0
  unsigned int v41; // r1
  int v42; // r2
  unsigned int v43; // r5
  int v44; // r2
  int v45; // r6
  char *v46; // r0
  char v47; // r1
  unsigned int v48; // r3
  int v49; // r0
  unsigned int v50; // r4
  unsigned __int8 *v51; // r5
  int v52; // t1
  int v53; // r3
  char *v54; // r0
  unsigned int v55; // r6
  char *v56; // r0
  unsigned __int8 *v57; // r5
  int v58; // r9
  int v59; // t1
  int v60; // r3
  char *v61; // r0
  _DWORD *v62; // r4
  unsigned int v63; // r2
  int v64; // r11
  unsigned __int8 *v66; // r3
  int v67; // t1
  int v68; // r2
  int v69; // r3
  unsigned __int8 *v70; // r3
  int v71; // t1
  int v72; // r2
  int v73; // r3
  unsigned int v74; // r4
  unsigned int v75; // r1
  unsigned __int8 *v76; // r3
  int v77; // t1
  int v78; // r2
  int v79; // r3
  int v80; // r3
  unsigned int v81; // r3
  unsigned int v82; // r4
  _DWORD *v83; // r2
  int v84; // r0
  int v85; // r1
  unsigned int v86; // r2
  int v87; // r3
  void *v88; // r0
  size_t v89; // r2
  int v90; // r2
  int v91; // r3
  int v92; // r3
  unsigned int v93; // r4
  int v94; // r3
  int v95; // r5
  int v96; // r2
  unsigned int v97; // r1
  unsigned int v98; // r3
  bool v99; // cf
  unsigned __int8 *v100; // r3
  int v101; // t1
  int v102; // r2
  int v103; // r1
  unsigned __int8 *v104; // r3
  int v105; // t1
  int v106; // r2
  int v107; // r3
  unsigned int v108; // r2
  unsigned int v109; // r3
  int v110; // r0
  unsigned __int8 *v111; // r3
  int v112; // t1
  int v113; // r2
  unsigned int v114; // r6
  unsigned int v115; // r7
  unsigned int *v116; // r10
  unsigned __int8 *v117; // r12
  int v118; // r3
  unsigned int v119; // r4
  unsigned int v120; // r0
  unsigned int v121; // r6
  int v122; // r1
  unsigned int v123; // r5
  unsigned int v124; // r0
  char *v125; // r1
  unsigned int v126; // r0
  int v127; // r3
  int v128; // r2
  int v129; // r2
  bool v130; // zf
  int v131; // r3
  char v132; // r3
  unsigned __int8 *v133; // r3
  int v134; // t1
  int v135; // r2
  size_t v136; // r4
  unsigned __int8 *v137; // r3
  int v138; // t1
  int v139; // r2
  unsigned int v140; // r3
  unsigned int v141; // r1
  unsigned int v142; // r2
  unsigned int v143; // r3
  __int16 *v144; // r0
  int v145; // t1
  int v146; // r1
  int v147; // t1
  __int16 v148; // r4
  __int16 *v149; // r3
  int v150; // t1
  int v151; // r0
  unsigned int v152; // r6
  unsigned int v153; // r1
  int v154; // r4
  int v155; // r3
  int v156; // r2
  unsigned int v157; // r0
  unsigned int v158; // r1
  unsigned __int8 *v159; // r2
  int v160; // t1
  int v161; // r1
  int v162; // r1
  unsigned __int8 *v163; // r3
  int v164; // t1
  int v165; // r2
  unsigned int v166; // r10
  int v167; // r5
  unsigned int v168; // r5
  unsigned __int16 v169; // r3
  unsigned int v170; // r12
  unsigned int v171; // r4
  unsigned int v172; // r0
  unsigned int v173; // r2
  int v174; // r1
  unsigned int v175; // r2
  int *v176; // r5
  int *v177; // r2
  int v178; // r6
  unsigned int v179; // r4
  unsigned int v180; // r1
  unsigned __int16 *v181; // r2
  unsigned int v182; // r2
  int v183; // r3
  unsigned __int8 *v184; // r3
  int v185; // t1
  int v186; // r2
  unsigned int v187; // r2
  int v188; // r3
  unsigned int v189; // r0
  unsigned int v190; // r0
  int v191; // r2
  unsigned __int8 *v192; // r3
  int v193; // t1
  int v194; // r2
  unsigned int v195; // r4
  int v196; // r3
  int v197; // r5
  int v198; // r2
  unsigned int v199; // r1
  unsigned int v200; // r3
  bool v201; // cf
  int v202; // r2
  int v203; // r2
  int v204; // r3
  unsigned int v205; // r0
  _BYTE *v206; // r5
  unsigned int v207; // r2
  unsigned int v208; // r1
  unsigned int v209; // r5
  bool v210; // cf
  char v211; // r4
  unsigned int v212; // r5
  int v213; // r4
  int v214; // r4
  unsigned int v215; // r7
  _DWORD *v216; // r2
  unsigned int v217; // r3
  int v218; // r0
  unsigned int v219; // r1
  unsigned int v220; // r11
  _DWORD *v221; // r0
  int v222; // r5
  unsigned int v223; // r2
  unsigned int v224; // r2
  int v225; // t1
  _BYTE *v226; // r3
  unsigned int v227; // r1
  _BYTE *v228; // r1
  unsigned int v229; // r0
  char v230; // t1
  unsigned __int8 *v231; // r3
  int v232; // t1
  int v233; // r2
  int v234; // r0
  unsigned int v235; // r3
  unsigned int v236; // r2
  bool v237; // cc
  int v238; // r1
  unsigned int v239; // r2
  unsigned int v240; // r1
  unsigned int v241; // r3
  unsigned int v242; // r0
  int v243; // r3
  unsigned int v244; // r5
  unsigned int v245; // r0
  int v246; // r0
  unsigned int v247; // r0
  unsigned __int8 *v248; // r4
  int v249; // r5
  int v250; // r4
  unsigned int v251; // r6
  unsigned __int8 *v252; // r4
  int v253; // t1
  int v254; // r1
  unsigned __int8 *v255; // r6
  int v256; // r9
  unsigned int v257; // r0
  int v258; // r0
  unsigned int v259; // r0
  int v260; // r0
  unsigned int v261; // r0
  unsigned __int8 *v262; // r3
  int v263; // t1
  int v264; // r2
  unsigned __int8 *v265; // r3
  int v266; // t1
  int v267; // r2
  unsigned int v268; // r10
  int *v269; // r3
  unsigned int v270; // r6
  unsigned int v271; // r7
  unsigned int *v272; // r10
  unsigned __int8 *v273; // r12
  int v274; // r0
  unsigned int v275; // r0
  int v276; // r0
  unsigned int v277; // r0
  int v278; // r0
  int v279; // r1
  int v280; // r2
  int v281; // r0
  unsigned int *v282; // [sp+8h] [bp-78h]
  unsigned int *v283; // [sp+8h] [bp-78h]
  unsigned int *v284; // [sp+8h] [bp-78h]
  unsigned int *v285; // [sp+8h] [bp-78h]
  unsigned int *v286; // [sp+8h] [bp-78h]
  unsigned int *v287; // [sp+8h] [bp-78h]
  unsigned int *v288; // [sp+8h] [bp-78h]
  unsigned int *v289; // [sp+8h] [bp-78h]
  unsigned int *v290; // [sp+8h] [bp-78h]
  unsigned int *v291; // [sp+8h] [bp-78h]
  unsigned int *v292; // [sp+8h] [bp-78h]
  unsigned int *v293; // [sp+8h] [bp-78h]
  unsigned int *v294; // [sp+8h] [bp-78h]
  unsigned int *v295; // [sp+8h] [bp-78h]
  unsigned int *v296; // [sp+8h] [bp-78h]
  unsigned int *v297; // [sp+8h] [bp-78h]
  unsigned int *v298; // [sp+Ch] [bp-74h]
  int v299; // [sp+Ch] [bp-74h]
  unsigned int v300; // [sp+Ch] [bp-74h]
  size_t n; // [sp+10h] [bp-70h]
  _BYTE *dest; // [sp+14h] [bp-6Ch]
  int v303; // [sp+18h] [bp-68h]
  unsigned int v304; // [sp+1Ch] [bp-64h]
  int v306; // [sp+24h] [bp-5Ch]
  int v307; // [sp+28h] [bp-58h]
  unsigned int *v308; // [sp+28h] [bp-58h]
  unsigned int *v309; // [sp+28h] [bp-58h]
  unsigned int v310; // [sp+28h] [bp-58h]
  int v311; // [sp+28h] [bp-58h]
  unsigned int v312; // [sp+2Ch] [bp-54h]
  unsigned int v313; // [sp+30h] [bp-50h]
  int v314; // [sp+34h] [bp-4Ch]
  unsigned int *v315; // [sp+34h] [bp-4Ch]
  unsigned int v316; // [sp+38h] [bp-48h]
  unsigned __int8 *v317; // [sp+38h] [bp-48h]
  unsigned int v318; // [sp+3Ch] [bp-44h]
  unsigned int v319; // [sp+3Ch] [bp-44h]
  int v320; // [sp+44h] [bp-3Ch]
  unsigned int v321; // [sp+48h] [bp-38h]
  _DWORD v322[11]; // [sp+54h] [bp-2Ch] BYREF

  if ( !a1 )
    return -2;
  v2 = a1[7];
  if ( !v2 )
    return -2;
  dest = (_BYTE *)a1[3];
  if ( !dest )
    return -2;
  if ( !*a1 )
  {
    if ( !a1[1] )
    {
      v304 = *a1;
      goto LABEL_6;
    }
    return -2;
  }
  v304 = a1[1];
LABEL_6:
  v3 = *(_DWORD *)v2;
  v4 = *(_DWORD *)(v2 + 60);
  if ( *(_DWORD *)v2 == 11 )
    v3 = 12;
  v5 = a1[4];
  v306 = 0;
  v6 = (unsigned __int8 *)*a1;
  v7 = a1;
  v8 = *(_DWORD *)(v2 + 56);
  v9 = v304;
  if ( *(_DWORD *)v2 == 11 )
    *(_DWORD *)v2 = v3;
  n = v5;
  v312 = a2 - 5;
  v303 = v5;
LABEL_11:
  while ( 2 )
  {
    switch ( v3 )
    {
      case 0:
        v103 = *(_DWORD *)(v2 + 8);
        if ( !v103 )
        {
          v3 = 12;
          *(_DWORD *)v2 = 12;
          continue;
        }
        if ( v4 > 0xF )
          goto LABEL_158;
        if ( !v9 )
          goto LABEL_336;
        v104 = v6;
        while ( 1 )
        {
          v105 = *v104++;
          --v9;
          v6 = v104;
          v106 = v105 << v4;
          v4 += 8;
          v8 += v106;
          if ( v4 > 0xF )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_158:
        if ( (v103 & 2) != 0 && v8 == 35615 )
        {
          v297 = v7;
          v4 = 0;
          v276 = crc32(0, 0, 0);
          LOBYTE(v322[0]) = 31;
          *(_DWORD *)(v2 + 24) = v276;
          BYTE1(v322[0]) = -117;
          v8 = 0;
          v277 = crc32(v276, (char *)v322, 2u);
          v3 = 1;
          *(_DWORD *)(v2 + 24) = v277;
          *(_DWORD *)v2 = 1;
          v7 = v297;
          continue;
        }
        v107 = *(_DWORD *)(v2 + 32);
        *(_DWORD *)(v2 + 16) = 0;
        if ( v107 )
          *(_DWORD *)(v107 + 48) = -1;
        if ( (v103 & 1) == 0
          || (unsigned __int16)((_WORD)v8 << 8) + (v8 >> 8) != 31
                                                             * (((unsigned __int16)((_WORD)v8 << 8) + (v8 >> 8))
                                                              / 0x1F) )
        {
          v3 = 29;
          v7[6] = (unsigned int)"incorrect header check";
          *(_DWORD *)v2 = 29;
          continue;
        }
        if ( (v8 & 0xF) != 8 )
        {
LABEL_177:
          v3 = 29;
          v7[6] = (unsigned int)&unk_54B88;
          *(_DWORD *)v2 = 29;
          continue;
        }
        v8 >>= 4;
        v108 = *(_DWORD *)(v2 + 36);
        v109 = (v8 & 0xF) + 8;
        if ( v108 )
        {
          if ( v109 > v108 )
          {
            v4 -= 4;
            v3 = 29;
            v7[6] = (unsigned int)"invalid window size";
            *(_DWORD *)v2 = 29;
            continue;
          }
        }
        else
        {
          *(_DWORD *)(v2 + 36) = v109;
        }
        *(_DWORD *)(v2 + 20) = 1 << v109;
        v284 = v7;
        v110 = adler32(0, 0, 0);
        v7 = v284;
        if ( (v8 & 0x200) != 0 )
          v3 = 9;
        else
          v3 = 11;
        v8 = 0;
        *(_DWORD *)(v2 + 24) = v110;
        v4 = 0;
        v284[12] = v110;
        *(_DWORD *)v2 = v3;
        continue;
      case 1:
        if ( v4 > 0xF )
          goto LABEL_176;
        if ( !v9 )
          goto LABEL_336;
        v111 = v6;
        while ( 1 )
        {
          v112 = *v111++;
          --v9;
          v6 = v111;
          v113 = v112 << v4;
          v4 += 8;
          v8 += v113;
          if ( v4 > 0xF )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_176:
        *(_DWORD *)(v2 + 16) = v8;
        if ( (unsigned __int8)v8 != 8 )
          goto LABEL_177;
        if ( (v8 & 0xE000) != 0 )
        {
          v3 = 29;
          v7[6] = 347064;
          *(_DWORD *)v2 = 29;
          continue;
        }
        v269 = *(int **)(v2 + 32);
        if ( v269 )
          *v269 = (v8 >> 8) & 1;
        if ( (v8 & 0x200) != 0 )
        {
          v274 = *(_DWORD *)(v2 + 24);
          v296 = v7;
          LOWORD(v322[0]) = v8;
          v275 = crc32(v274, (char *)v322, 2u);
          v7 = v296;
          *(_DWORD *)(v2 + 24) = v275;
        }
        v4 = 0;
        *(_DWORD *)v2 = 2;
        v8 = 0;
LABEL_78:
        if ( !v9 )
          goto LABEL_336;
        v66 = v6;
        while ( 1 )
        {
          v67 = *v66++;
          --v9;
          v6 = v66;
          v68 = v67 << v4;
          v4 += 8;
          v8 += v68;
          if ( v4 > 0x1F )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_82:
        v69 = *(_DWORD *)(v2 + 32);
        if ( v69 )
          *(_DWORD *)(v69 + 4) = v8;
        if ( (*(_DWORD *)(v2 + 16) & 0x200) != 0 )
        {
          v258 = *(_DWORD *)(v2 + 24);
          v294 = v7;
          v322[0] = v8;
          v259 = crc32(v258, (char *)v322, 4u);
          v7 = v294;
          *(_DWORD *)(v2 + 24) = v259;
        }
        v8 = 0;
        v4 = 0;
        *(_DWORD *)v2 = 3;
LABEL_87:
        if ( !v9 )
          goto LABEL_336;
        v70 = v6;
        while ( 1 )
        {
          v71 = *v70++;
          --v9;
          v6 = v70;
          v72 = v71 << v4;
          v4 += 8;
          v8 += v72;
          if ( v4 > 0xF )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_91:
        v73 = *(_DWORD *)(v2 + 32);
        if ( v73 )
        {
          *(_DWORD *)(v73 + 8) = (unsigned __int8)v8;
          *(_DWORD *)(v73 + 12) = v8 >> 8;
        }
        v74 = *(_DWORD *)(v2 + 16);
        v75 = v74;
        if ( (v74 & 0x200) != 0 )
        {
          v246 = *(_DWORD *)(v2 + 24);
          v292 = v7;
          LOWORD(v322[0]) = v8;
          v247 = crc32(v246, (char *)v322, 2u);
          v74 = *(_DWORD *)(v2 + 16);
          *(_DWORD *)(v2 + 24) = v247;
          v7 = v292;
          v75 = v74;
        }
        *(_DWORD *)v2 = 4;
        if ( (v74 & 0x400) != 0 )
        {
          v4 = 0;
          v8 = 0;
LABEL_98:
          if ( !v9 )
            goto LABEL_336;
          v76 = v6;
          while ( 1 )
          {
            v77 = *v76++;
            --v9;
            v6 = v76;
            v78 = v77 << v4;
            v4 += 8;
            v8 += v78;
            if ( v4 > 0xF )
              break;
            if ( !v9 )
              goto LABEL_336;
          }
LABEL_102:
          v79 = *(_DWORD *)(v2 + 32);
          *(_DWORD *)(v2 + 64) = v8;
          if ( v79 )
            *(_DWORD *)(v79 + 20) = v8;
          if ( (v74 & 0x200) != 0 )
          {
            v260 = *(_DWORD *)(v2 + 24);
            LOWORD(v322[0]) = v8;
            v295 = v7;
            v8 = 0;
            v261 = crc32(v260, (char *)v322, 2u);
            v75 = *(_DWORD *)(v2 + 16);
            v4 = 0;
            *(_DWORD *)(v2 + 24) = v261;
            v7 = v295;
            v80 = v75 & 0x400;
          }
          else
          {
            v8 = 0;
            v75 = v74;
            v80 = v74 & 0x400;
            v4 = 0;
          }
        }
        else
        {
          v4 = 0;
          v8 = 0;
LABEL_334:
          v203 = *(_DWORD *)(v2 + 32);
          v80 = v203;
          if ( v203 )
          {
            v80 = 0;
            *(_DWORD *)(v203 + 16) = 0;
          }
        }
        *(_DWORD *)v2 = 5;
LABEL_107:
        if ( v80 )
        {
          v81 = *(_DWORD *)(v2 + 64);
          if ( v9 >= v81 )
            v82 = *(_DWORD *)(v2 + 64);
          else
            v82 = v9;
          if ( v82 )
          {
            v83 = *(_DWORD **)(v2 + 32);
            if ( v83 )
            {
              v84 = v83[4];
              if ( v84 )
              {
                v85 = v83[5];
                v86 = v83[6];
                v283 = v7;
                v87 = v85 - v81;
                v88 = (void *)(v84 + v87);
                if ( v82 + v87 <= v86 )
                  v89 = v82;
                else
                  v89 = v86 - v87;
                memcpy(v88, v6, v89);
                v75 = *(_DWORD *)(v2 + 16);
                v7 = v283;
              }
            }
            if ( (v75 & 0x200) != 0 )
            {
              v293 = v7;
              v257 = crc32(*(_DWORD *)(v2 + 24), (char *)v6, v82);
              v7 = v293;
              *(_DWORD *)(v2 + 24) = v257;
            }
            v9 -= v82;
            v6 += v82;
            v81 = *(_DWORD *)(v2 + 64) - v82;
            *(_DWORD *)(v2 + 64) = v81;
          }
          if ( v81 )
            goto LABEL_336;
          v75 = *(_DWORD *)(v2 + 16);
        }
        *(_DWORD *)(v2 + 64) = 0;
        v90 = v75 & 0x800;
        *(_DWORD *)v2 = 6;
        if ( (v75 & 0x800) != 0 )
        {
LABEL_317:
          if ( !v9 )
            goto LABEL_336;
          v195 = 0;
          do
          {
            v196 = *(_DWORD *)(v2 + 32);
            v197 = v6[v195++];
            if ( v196 )
            {
              v198 = *(_DWORD *)(v196 + 28);
              if ( v198 )
              {
                v199 = *(_DWORD *)(v196 + 32);
                v200 = *(_DWORD *)(v2 + 64);
                if ( v200 < v199 )
                {
                  *(_BYTE *)(v198 + v200) = v197;
                  *(_DWORD *)(v2 + 64) = v200 + 1;
                }
              }
            }
            v201 = 1;
            if ( v197 )
              v201 = v195 >= v9;
          }
          while ( !v201 );
          if ( (*(_DWORD *)(v2 + 16) & 0x200) != 0 )
          {
            v291 = v7;
            v245 = crc32(*(_DWORD *)(v2 + 24), (char *)v6, v195);
            v7 = v291;
            *(_DWORD *)(v2 + 24) = v245;
          }
          v9 -= v195;
          v6 += v195;
          if ( v197 )
            goto LABEL_336;
          v75 = *(_DWORD *)(v2 + 16);
        }
        else
        {
LABEL_124:
          v91 = *(_DWORD *)(v2 + 32);
          if ( v91 )
            *(_DWORD *)(v91 + 28) = v90;
        }
        *(_DWORD *)v2 = 7;
        v92 = v75 & 0x1000;
        *(_DWORD *)(v2 + 64) = 0;
        if ( (v75 & 0x1000) != 0 )
        {
LABEL_129:
          if ( !v9 )
            goto LABEL_336;
          v93 = 0;
          do
          {
            v94 = *(_DWORD *)(v2 + 32);
            v95 = v6[v93++];
            if ( v94 )
            {
              v96 = *(_DWORD *)(v94 + 36);
              if ( v96 )
              {
                v97 = *(_DWORD *)(v94 + 40);
                v98 = *(_DWORD *)(v2 + 64);
                if ( v98 < v97 )
                {
                  *(_BYTE *)(v96 + v98) = v95;
                  *(_DWORD *)(v2 + 64) = v98 + 1;
                }
              }
            }
            v99 = 1;
            if ( v95 )
              v99 = v93 >= v9;
          }
          while ( !v99 );
          if ( (*(_DWORD *)(v2 + 16) & 0x200) != 0 )
          {
            v289 = v7;
            v242 = crc32(*(_DWORD *)(v2 + 24), (char *)v6, v93);
            v7 = v289;
            *(_DWORD *)(v2 + 24) = v242;
          }
          v9 -= v93;
          v6 += v93;
          if ( v95 )
            goto LABEL_336;
          v75 = *(_DWORD *)(v2 + 16);
        }
        else
        {
LABEL_332:
          v202 = *(_DWORD *)(v2 + 32);
          if ( v202 )
            *(_DWORD *)(v202 + 36) = v92;
        }
        *(_DWORD *)v2 = 8;
LABEL_144:
        if ( (v75 & 0x200) != 0 )
        {
          if ( v4 <= 0xF )
          {
            if ( !v9 )
              goto LABEL_336;
            v100 = v6;
            while ( 1 )
            {
              v101 = *v100++;
              --v9;
              v6 = v100;
              v102 = v101 << v4;
              v4 += 8;
              v8 += v102;
              if ( v4 > 0xF )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( *(unsigned __int16 *)(v2 + 24) != v8 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"header crc mismatch";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v4 = 0;
          v8 = 0;
        }
        v204 = *(_DWORD *)(v2 + 32);
        if ( v204 )
        {
          *(_DWORD *)(v204 + 44) = (v75 >> 9) & 1;
          *(_DWORD *)(v204 + 48) = 1;
        }
        v288 = v7;
        v205 = crc32(0, 0, 0);
        v7 = v288;
        *(_DWORD *)(v2 + 24) = v205;
        v3 = 11;
        v288[12] = v205;
        *(_DWORD *)v2 = 11;
        continue;
      case 2:
        if ( v4 <= 0x1F )
          goto LABEL_78;
        goto LABEL_82;
      case 3:
        if ( v4 > 0xF )
          goto LABEL_91;
        goto LABEL_87;
      case 4:
        v74 = *(_DWORD *)(v2 + 16);
        v75 = v74;
        if ( (v74 & 0x400) == 0 )
          goto LABEL_334;
        if ( v4 > 0xF )
          goto LABEL_102;
        goto LABEL_98;
      case 5:
        v75 = *(_DWORD *)(v2 + 16);
        v80 = v75 & 0x400;
        goto LABEL_107;
      case 6:
        v75 = *(_DWORD *)(v2 + 16);
        v90 = v75 & 0x800;
        if ( (v75 & 0x800) != 0 )
          goto LABEL_317;
        goto LABEL_124;
      case 7:
        v75 = *(_DWORD *)(v2 + 16);
        v92 = v75 & 0x1000;
        if ( (v75 & 0x1000) != 0 )
          goto LABEL_129;
        goto LABEL_332;
      case 8:
        v75 = *(_DWORD *)(v2 + 16);
        goto LABEL_144;
      case 9:
        if ( v4 > 0x1F )
          goto LABEL_17;
        if ( !v9 )
          goto LABEL_336;
        v10 = v6;
        while ( 1 )
        {
          v11 = *v10++;
          --v9;
          v6 = v10;
          v12 = v11 << v4;
          v4 += 8;
          v8 += v12;
          if ( v4 > 0x1F )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_17:
        v13 = HIBYTE(v8) + (v8 << 24);
        v14 = (v8 >> 8) & 0xFF00;
        v15 = v8 & 0xFF00;
        v8 = 0;
        v16 = v13 + v14 + (v15 << 8);
        v4 = 0;
        *(_DWORD *)(v2 + 24) = v16;
        v7[12] = v16;
        *(_DWORD *)v2 = 10;
LABEL_18:
        if ( !*(_DWORD *)(v2 + 12) )
        {
          v270 = v9;
          v271 = v8;
          v272 = v7;
          v273 = v6;
          v272[3] = (unsigned int)dest;
          v64 = 2;
          v272[4] = n;
          *v272 = (unsigned int)v273;
          v272[1] = v270;
          *(_DWORD *)(v2 + 56) = v271;
          *(_DWORD *)(v2 + 60) = v4;
          return v64;
        }
        v282 = v7;
        v17 = adler32(0, 0, 0);
        v7 = v282;
        *(_DWORD *)(v2 + 24) = v17;
        v282[12] = v17;
        *(_DWORD *)v2 = 11;
LABEL_20:
        if ( v312 <= 1 )
          goto LABEL_336;
LABEL_21:
        if ( *(_DWORD *)(v2 + 4) )
        {
          v3 = 26;
          v8 >>= v4 & 7;
          v4 &= 0xFFFFFFF8;
          *(_DWORD *)v2 = 26;
          continue;
        }
        if ( v4 <= 2 )
        {
          if ( !v9 )
            goto LABEL_336;
          v18 = *v6++;
          --v9;
          v19 = v18 << v4;
          v4 += 8;
          v8 += v19;
        }
        *(_DWORD *)(v2 + 4) = v8 & 1;
        v20 = (v8 >> 1) & 3;
        switch ( v20 )
        {
          case 2:
            v3 = 16;
            *(_DWORD *)v2 = 16;
            break;
          case 3:
            v3 = 29;
            v7[6] = (unsigned int)"invalid block type";
            *(_DWORD *)v2 = 29;
            break;
          case 1:
            *(_DWORD *)(v2 + 76) = 344776;
            v3 = 19;
            *(_DWORD *)(v2 + 80) = &distfix_6142;
            *(_DWORD *)(v2 + 84) = 9;
            *(_DWORD *)(v2 + 88) = 5;
            *(_DWORD *)v2 = 19;
            if ( a2 == 6 )
            {
              v114 = v9;
              v115 = v8 >> 3;
              v116 = v7;
              v4 -= 3;
              v117 = v6;
              v64 = v306;
              goto LABEL_184;
            }
            break;
          default:
            v3 = 13;
            *(_DWORD *)v2 = 13;
            break;
        }
        v8 >>= 3;
        v4 -= 3;
        continue;
      case 10:
        goto LABEL_18;
      case 11:
        goto LABEL_20;
      case 12:
        goto LABEL_21;
      case 13:
        v132 = v4 & 7;
        v4 &= 0xFFFFFFF8;
        v8 >>= v132;
        if ( v4 > 0x1F )
          goto LABEL_214;
        if ( !v9 )
          goto LABEL_336;
        v133 = v6;
        while ( 1 )
        {
          v134 = *v133++;
          --v9;
          v6 = v133;
          v135 = v134 << v4;
          v4 += 8;
          v8 += v135;
          if ( v4 > 0x1F )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_214:
        v136 = (unsigned __int16)v8;
        if ( (unsigned __int16)v8 != (HIWORD(v8) ^ 0xFFFF) )
        {
          v3 = 29;
          v7[6] = (unsigned int)"invalid stored block lengths";
          *(_DWORD *)v2 = 29;
          continue;
        }
        *(_DWORD *)(v2 + 64) = (unsigned __int16)v8;
        *(_DWORD *)v2 = 14;
        if ( a2 != 6 )
        {
          v4 = 0;
          v8 = 0;
LABEL_217:
          *(_DWORD *)v2 = 15;
LABEL_218:
          if ( !v136 )
          {
            v3 = 11;
            *(_DWORD *)v2 = 11;
            continue;
          }
          if ( v9 < v136 )
            v136 = v9;
          if ( v136 >= n )
            v136 = n;
          if ( v136 )
          {
            v285 = v7;
            v9 -= v136;
            memcpy(dest, v6, v136);
            v6 += v136;
            n -= v136;
            v3 = *(_DWORD *)v2;
            *(_DWORD *)(v2 + 64) -= v136;
            v7 = v285;
            dest += v136;
            continue;
          }
LABEL_336:
          v114 = v9;
          v115 = v8;
          v116 = v7;
          v117 = v6;
          v64 = v306;
          goto LABEL_184;
        }
        v4 = 0;
        v114 = v9;
        v116 = v7;
        v115 = 0;
        v117 = v6;
        v64 = v306;
        break;
      case 14:
        v136 = *(_DWORD *)(v2 + 64);
        goto LABEL_217;
      case 15:
        v136 = *(_DWORD *)(v2 + 64);
        goto LABEL_218;
      case 16:
        if ( v4 > 0xD )
          goto LABEL_231;
        if ( !v9 )
          goto LABEL_336;
        v137 = v6;
        while ( 1 )
        {
          v138 = *v137++;
          --v9;
          v6 = v137;
          v139 = v138 << v4;
          v4 += 8;
          v8 += v139;
          if ( v4 > 0xD )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_231:
        v140 = (v8 & 0x1F) + 257;
        v141 = ((v8 >> 5) & 0x1F) + 1;
        v142 = ((v8 >> 10) & 0xF) + 4;
        v4 -= 14;
        *(_DWORD *)(v2 + 96) = v140;
        v8 >>= 14;
        *(_DWORD *)(v2 + 100) = v141;
        *(_DWORD *)(v2 + 92) = v142;
        if ( v140 > 0x11E || v141 > 0x1E )
        {
          v3 = 29;
          v7[6] = 347164;
          *(_DWORD *)v2 = 29;
          continue;
        }
        v143 = 0;
        *(_DWORD *)(v2 + 104) = 0;
        *(_DWORD *)v2 = 17;
LABEL_235:
        v144 = &order_6170[v143 - 1];
        do
        {
          ++v143;
          if ( v4 <= 2 )
          {
            if ( !v9 )
              goto LABEL_336;
            v145 = *v6++;
            --v9;
            v146 = v145 << v4;
            v4 += 8;
            v8 += v146;
          }
          v147 = (unsigned __int16)v144[1];
          ++v144;
          v148 = v8 & 7;
          v4 -= 3;
          *(_DWORD *)(v2 + 104) = v143;
          v8 >>= 3;
          *(_WORD *)(v2 + 2 * (v147 + 56)) = v148;
        }
        while ( v143 < v142 );
LABEL_240:
        if ( v143 <= 0x12 )
        {
          v149 = &order_6170[v143 - 1];
          do
          {
            v150 = (unsigned __int16)v149[1];
            ++v149;
            *(_WORD *)(v2 + 2 * (v150 + 56)) = 0;
          }
          while ( v149 != (__int16 *)&unk_54B6C );
          *(_DWORD *)(v2 + 104) = 19;
        }
        *(_DWORD *)(v2 + 108) = v2 + 1328;
        *(_DWORD *)(v2 + 76) = v2 + 1328;
        *(_DWORD *)(v2 + 84) = 7;
        v286 = v7;
        v151 = inflate_table(0, v2 + 112, 0x13u, (int *)(v2 + 108), (unsigned int *)(v2 + 84), (void **)(v2 + 752));
        v7 = v286;
        v306 = v151;
        if ( v151 )
        {
          v3 = 29;
          v286[6] = (unsigned int)"invalid code lengths set";
          *(_DWORD *)v2 = 29;
          continue;
        }
        v152 = 0;
        *(_DWORD *)(v2 + 104) = 0;
        *(_DWORD *)v2 = 18;
LABEL_247:
        v313 = *(_DWORD *)(v2 + 96);
        v309 = v7;
        v153 = *(_DWORD *)(v2 + 100) + v313;
        v300 = v153;
        while ( v152 < v153 )
        {
          v154 = *(_DWORD *)(v2 + 76);
          v155 = (1 << *(_DWORD *)(v2 + 84)) - 1;
          v156 = v154 + 4 * (v8 & v155);
          v157 = *(unsigned __int8 *)(v156 + 1);
          v158 = *(unsigned __int16 *)(v156 + 2);
          if ( v4 < v157 )
          {
            if ( !v9 )
              goto LABEL_347;
            v159 = v6;
            while ( 1 )
            {
              v160 = *v159++;
              --v9;
              v6 = v159;
              v161 = v160 << v4;
              v4 += 8;
              v8 += v161;
              v162 = v154 + 4 * (v8 & v155);
              v157 = *(unsigned __int8 *)(v162 + 1);
              v158 = *(unsigned __int16 *)(v162 + 2);
              if ( v157 <= v4 )
                break;
              if ( !v9 )
                goto LABEL_347;
            }
          }
          if ( v158 <= 0xF )
          {
            v241 = v152 + 56;
            ++v152;
            *(_WORD *)(v2 + 2 * v241) = v158;
            v8 >>= v157;
            v4 -= v157;
            *(_DWORD *)(v2 + 104) = v152;
            v153 = v300;
          }
          else
          {
            if ( v158 == 16 )
            {
              if ( v4 < v157 + 2 )
              {
                if ( !v9 )
                  goto LABEL_347;
                v262 = v6;
                while ( 1 )
                {
                  v263 = *v262++;
                  --v9;
                  v6 = v262;
                  v264 = v263 << v4;
                  v4 += 8;
                  v8 += v264;
                  if ( v4 >= v157 + 2 )
                    break;
                  if ( !v9 )
                    goto LABEL_347;
                }
              }
              v8 >>= v157;
              v4 -= v157;
              if ( !v152 )
              {
LABEL_471:
                v7 = v309;
                v309[6] = (unsigned int)"invalid bit length repeat";
                v3 = 29;
                *(_DWORD *)v2 = 29;
                goto LABEL_11;
              }
              v4 -= 2;
              v169 = *(_WORD *)(v2 + 2 * (v152 + 55));
              v168 = (v8 & 3) + 3;
              v8 >>= 2;
            }
            else if ( v158 == 17 )
            {
              if ( v4 < v157 + 3 )
              {
                if ( !v9 )
                {
LABEL_347:
                  v117 = v6;
                  v114 = v9;
                  v64 = v306;
                  v115 = v8;
                  v116 = v309;
                  goto LABEL_184;
                }
                v265 = v6;
                while ( 1 )
                {
                  v266 = *v265++;
                  --v9;
                  v6 = v265;
                  v267 = v266 << v4;
                  v4 += 8;
                  v8 += v267;
                  if ( v4 >= v157 + 3 )
                    break;
                  if ( !v9 )
                    goto LABEL_347;
                }
              }
              v268 = v8 >> v157;
              v4 += -3 - v157;
              v168 = (v268 & 7) + 3;
              v8 = v268 >> 3;
              v169 = 0;
            }
            else
            {
              if ( v4 < v157 + 7 )
              {
                if ( !v9 )
                  goto LABEL_347;
                v163 = v6;
                while ( 1 )
                {
                  v164 = *v163++;
                  --v9;
                  v6 = v163;
                  v165 = v164 << v4;
                  v4 += 8;
                  v8 += v165;
                  if ( v4 >= v157 + 7 )
                    break;
                  if ( !v9 )
                    goto LABEL_347;
                }
              }
              v166 = v8 >> v157;
              v167 = v166 & 0x7F;
              v8 = v166 >> 7;
              v4 += -7 - v157;
              v168 = v167 + 11;
              v169 = 0;
            }
            v318 = v168 + v152;
            if ( v168 + v152 > v300 )
              goto LABEL_471;
            v170 = v168 - 1;
            v171 = ((v2 + 2 * (v152 + 56)) >> 1) & 1;
            if ( v168 < v171 )
              v171 = v168;
            if ( (v171 & 1) != 0 )
            {
              v172 = v152;
              v173 = v2 + 2 * (v152 + 55);
              do
              {
                ++v172;
                *(_WORD *)(v173 + 2) = v169;
                v173 += 2;
                --v170;
              }
              while ( v171 > v172 - v152 );
            }
            else
            {
              v172 = v152;
            }
            v321 = v168 - v171;
            v316 = (v168 - v171) >> 1;
            v320 = 2 * v316;
            if ( !v316 )
              goto LABEL_278;
            v174 = v169 | (v169 << 16);
            v175 = (v168 - v171) >> 1;
            v176 = (int *)(v2 + 2 * (v152 + 56 + v171));
            if ( v316 <= 8 )
            {
              v179 = 0;
            }
            else
            {
              v177 = v176 + 8;
              v178 = 0;
              do
              {
                v179 = v178 + 8;
                v99 = v178 + 9 >= v316 - 7;
                __pld(v177 + 32);
                *(v177 - 8) = v174;
                v176 = v177;
                *(v177 - 7) = v174;
                v178 += 8;
                *(v177 - 6) = v174;
                *(v177 - 5) = v174;
                *(v177 - 4) = v174;
                *(v177 - 3) = v174;
                *(v177 - 2) = v174;
                *(v177 - 1) = v174;
                v177 += 8;
              }
              while ( !v99 );
              v175 = v316;
            }
            do
            {
              ++v179;
              *v176++ = v174;
            }
            while ( v175 > v179 );
            v170 -= v320;
            v172 += v320;
            if ( v321 != v320 )
            {
LABEL_278:
              if ( v170 > 0xF )
              {
                v180 = v172 + 56;
                v181 = (unsigned __int16 *)(v2 + 2 * (v172 + 56));
                do
                {
                  v170 -= 16;
                  *v181 = v169;
                  v172 += 16;
                  __pld((void *)(v2 + 2 * v180 + 80));
                  v181[1] = v169;
                  v180 = v172 + 56;
                  v181[2] = v169;
                  v181[3] = v169;
                  v181[4] = v169;
                  v181[5] = v169;
                  v181[6] = v169;
                  v181[7] = v169;
                  v181[8] = v169;
                  v181[9] = v169;
                  v181[10] = v169;
                  v181[11] = v169;
                  v181[12] = v169;
                  v181[13] = v169;
                  v181[14] = v169;
                  v181[15] = v169;
                  v181 += 16;
                }
                while ( v170 > 0xF );
              }
              v182 = v2 + 2 * (v172 + 55);
              do
              {
                *(_WORD *)(v182 + 2) = v169;
                v182 += 2;
              }
              while ( v182 != v2 + 112 + 2 * (v172 + v170) );
            }
            v152 = v318;
            v153 = v300;
            *(_DWORD *)(v2 + 104) = v318;
          }
        }
        v7 = v309;
        if ( !*(_WORD *)(v2 + 624) )
        {
          v3 = 29;
          v309[6] = (unsigned int)"invalid code -- missing end-of-block";
          *(_DWORD *)v2 = 29;
          continue;
        }
        *(_DWORD *)(v2 + 108) = v2 + 1328;
        *(_DWORD *)(v2 + 76) = v2 + 1328;
        *(_DWORD *)(v2 + 84) = 9;
        v278 = inflate_table(1, v2 + 112, v313, (int *)(v2 + 108), (unsigned int *)(v2 + 84), (void **)(v2 + 752));
        v7 = v309;
        v306 = v278;
        if ( v278 )
        {
          v3 = 29;
          v309[6] = (unsigned int)"invalid literal/lengths set";
          *(_DWORD *)v2 = 29;
          continue;
        }
        v279 = *(_DWORD *)(v2 + 96);
        v280 = *(_DWORD *)(v2 + 108);
        *(_DWORD *)(v2 + 88) = 6;
        *(_DWORD *)(v2 + 80) = v280;
        v281 = inflate_table(
                 2,
                 v2 + 2 * (v279 + 56),
                 *(_DWORD *)(v2 + 100),
                 (int *)(v2 + 108),
                 (unsigned int *)(v2 + 88),
                 (void **)(v2 + 752));
        v7 = v309;
        v306 = v281;
        if ( v281 )
        {
          v3 = 29;
          v309[6] = (unsigned int)"invalid distances set";
          *(_DWORD *)v2 = 29;
          continue;
        }
        *(_DWORD *)v2 = 19;
        if ( a2 == 6 )
          goto LABEL_336;
LABEL_45:
        *(_DWORD *)v2 = 20;
LABEL_46:
        v29 = n > 0x102;
        if ( n >= 0x102 )
          v29 = v9 > 5;
        if ( !v29 )
        {
          v30 = *(_DWORD *)(v2 + 84);
          v31 = *(_DWORD *)(v2 + 76);
          *(_DWORD *)(v2 + 7108) = 0;
          v298 = (unsigned int *)(v2 + 7108);
          v32 = (1 << v30) - 1;
          v33 = (unsigned __int8 *)(v31 + 4 * (v8 & v32));
          v34 = *v33;
          v35 = v33[1];
          v36 = *((unsigned __int16 *)v33 + 1);
          if ( v4 < v35 )
          {
            if ( !v9 )
              goto LABEL_336;
            v37 = v6;
            while ( 1 )
            {
              v38 = *v37++;
              --v9;
              v6 = v37;
              v39 = v38 << v4;
              v4 += 8;
              v8 += v39;
              v40 = (unsigned __int8 *)(v31 + 4 * (v8 & v32));
              v34 = *v40;
              v35 = v40[1];
              v36 = *((unsigned __int16 *)v40 + 1);
              if ( v35 <= v4 )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( !v34 )
          {
            v8 >>= v35;
            v4 -= v35;
            *(_DWORD *)(v2 + 64) = v36;
            *v298 = v35;
LABEL_58:
            v3 = 25;
            *(_DWORD *)v2 = 25;
            continue;
          }
          if ( (v34 & 0xF0) != 0 )
          {
            v8 >>= v35;
            v4 -= v35;
            *(_DWORD *)(v2 + 64) = v36;
            *v298 = v35;
          }
          else
          {
            v311 = (1 << (v35 + v34)) - 1;
            v248 = (unsigned __int8 *)(v31 + 4 * (((v311 & v8) >> v35) + v36));
            v34 = *v248;
            v249 = v248[1];
            v250 = *((unsigned __int16 *)v248 + 1);
            v251 = v35 + v249;
            if ( v4 < v35 + v249 )
            {
              if ( !v9 )
                goto LABEL_336;
              v315 = v7;
              v252 = v6;
              v313 = v2;
              while ( 1 )
              {
                v253 = *v252++;
                --v9;
                v6 = v252;
                v254 = v253 << v4;
                v4 += 8;
                v8 += v254;
                v255 = (unsigned __int8 *)(v31 + 4 * (((v8 & v311) >> v35) + v36));
                v34 = *v255;
                v249 = v255[1];
                v256 = *((unsigned __int16 *)v255 + 1);
                v251 = v249 + v35;
                if ( v249 + v35 <= v4 )
                  break;
                if ( !v9 )
                {
                  v117 = v252;
                  v114 = 0;
                  v64 = v306;
                  v115 = v8;
                  v2 = v313;
                  v116 = v315;
                  goto LABEL_184;
                }
              }
              v250 = v256;
              v2 = v313;
            }
            v4 = v4 - v35 - v249;
            v8 = v8 >> v35 >> v249;
            *(_DWORD *)(v2 + 64) = v250;
            *v298 = v251;
            if ( !v34 )
              goto LABEL_58;
          }
          if ( (v34 & 0x20) != 0 )
          {
            *(_DWORD *)v2 = 11;
            *v298 = -1;
            v3 = 11;
            continue;
          }
          if ( (v34 & 0x40) != 0 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"invalid literal/length code";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v41 = v34 & 0xF;
          *(_DWORD *)(v2 + 72) = v41;
          *(_DWORD *)v2 = 21;
          if ( v41 )
          {
LABEL_376:
            if ( v4 < v41 )
            {
              if ( !v9 )
                goto LABEL_336;
              v231 = v6;
              while ( 1 )
              {
                v232 = *v231++;
                --v9;
                v6 = v231;
                v233 = v232 << v4;
                v4 += 8;
                v8 += v233;
                if ( v4 >= v41 )
                  break;
                if ( !v9 )
                  goto LABEL_336;
              }
            }
            v43 = v2 + 7104;
            v4 -= v41;
            v234 = v8 & ((1 << v41) - 1);
            v8 >>= v41;
            v42 = v234 + *(_DWORD *)(v2 + 64);
            v235 = v41 + *(_DWORD *)(v2 + 7108);
            *(_DWORD *)(v2 + 64) = v42;
            *(_DWORD *)(v2 + 7108) = v235;
          }
          else
          {
LABEL_60:
            v42 = *(_DWORD *)(v2 + 64);
            v43 = v2 + 7104;
          }
          *(_DWORD *)(v43 + 8) = v42;
          *(_DWORD *)v2 = 22;
LABEL_62:
          v44 = *(_DWORD *)(v2 + 80);
          v45 = (1 << *(_DWORD *)(v2 + 88)) - 1;
          v46 = (char *)(v44 + 4 * (v8 & v45));
          v47 = *v46;
          v48 = (unsigned __int8)v46[1];
          v49 = *((unsigned __int16 *)v46 + 1);
          v50 = v48;
          if ( v4 < v48 )
          {
            if ( !v9 )
              goto LABEL_336;
            v51 = v6;
            while ( 1 )
            {
              v52 = *v51++;
              --v9;
              v6 = v51;
              v53 = v52 << v4;
              v4 += 8;
              v8 += v53;
              v54 = (char *)(v44 + 4 * (v8 & v45));
              v47 = *v54;
              v48 = (unsigned __int8)v54[1];
              v49 = *((unsigned __int16 *)v54 + 1);
              v50 = v48;
              if ( v48 <= v4 )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( (v47 & 0xF0) != 0 )
          {
            v62 = (_DWORD *)(v2 + 7108);
            v63 = *(_DWORD *)(v2 + 7108);
          }
          else
          {
            v55 = v48;
            v307 = v49;
            v299 = (1 << (v48 + v47)) - 1;
            v56 = (char *)(v44 + 4 * (((v299 & v8) >> v48) + v49));
            v47 = *v56;
            v48 = (unsigned __int8)v56[1];
            v49 = *((unsigned __int16 *)v56 + 1);
            if ( v4 < v55 + v48 )
            {
              if ( !v9 )
                goto LABEL_336;
              v313 = v2;
              v57 = v6;
              v58 = v307;
              v308 = v7;
              while ( 1 )
              {
                v59 = *v57++;
                --v9;
                v6 = v57;
                v60 = v59 << v4;
                v4 += 8;
                v8 += v60;
                v61 = (char *)(v44 + 4 * (((v8 & v299) >> v55) + v58));
                v47 = *v61;
                v48 = (unsigned __int8)v61[1];
                v49 = *((unsigned __int16 *)v61 + 1);
                if ( v48 + v55 <= v4 )
                  break;
                if ( !v9 )
                {
                  v117 = v57;
                  v114 = 0;
                  v64 = v306;
                  v115 = v8;
                  v2 = v313;
                  v116 = v308;
                  goto LABEL_184;
                }
              }
              v2 = v313;
            }
            v4 -= v50;
            v8 >>= v55;
            v62 = (_DWORD *)(v2 + 7108);
            v63 = v55 + *(_DWORD *)(v2 + 7108);
          }
          v8 >>= v48;
          v4 -= v48;
          *v62 = v63 + v48;
          if ( (v47 & 0x40) != 0 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"invalid distance code";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v21 = v47 & 0xF;
          *(_DWORD *)(v2 + 72) = v21;
          *(_DWORD *)(v2 + 68) = v49;
          *(_DWORD *)v2 = 23;
          if ( v21 )
          {
LABEL_32:
            if ( v4 < v21 )
            {
              if ( !v9 )
                goto LABEL_336;
              v22 = v6;
              while ( 1 )
              {
                v23 = *v22++;
                --v9;
                v6 = v22;
                v24 = v23 << v4;
                v4 += 8;
                v8 += v24;
                if ( v4 >= v21 )
                  break;
                if ( !v9 )
                  goto LABEL_336;
              }
            }
            v4 -= v21;
            v25 = v8 & ((1 << v21) - 1);
            v8 >>= v21;
            v26 = v21 + *(_DWORD *)(v2 + 7108);
            *(_DWORD *)(v2 + 68) += v25;
            *(_DWORD *)(v2 + 7108) = v26;
          }
LABEL_38:
          *(_DWORD *)v2 = 24;
LABEL_39:
          if ( !n )
            goto LABEL_336;
          v27 = *(_DWORD *)(v2 + 68);
          if ( v303 - n >= v27 )
          {
            v206 = dest;
            v28 = *(_DWORD *)(v2 + 64);
            v313 = (unsigned int)&dest[-v27];
            v207 = v28;
          }
          else
          {
            v28 = v27 - (v303 - n);
            if ( v28 > *(_DWORD *)(v2 + 44) && *(_DWORD *)(v2 + 7104) )
            {
              v3 = 29;
              v7[6] = (unsigned int)"invalid distance too far back";
              *(_DWORD *)v2 = 29;
              continue;
            }
            v236 = *(_DWORD *)(v2 + 48);
            v206 = dest;
            v237 = v28 > v236;
            if ( v28 <= v236 )
            {
              v239 = v236 - v28;
              v238 = *(_DWORD *)(v2 + 52);
            }
            else
            {
              v238 = *(_DWORD *)(v2 + 40);
              v28 -= v236;
              v239 = *(_DWORD *)(v2 + 52);
            }
            if ( v237 )
            {
              v240 = v238 - v28;
              v239 += v240;
            }
            else
            {
              v240 = v238 + v239;
            }
            if ( v237 )
              v313 = v239;
            v207 = *(_DWORD *)(v2 + 64);
            if ( !v237 )
              v313 = v240;
            if ( v28 >= v207 )
              v28 = *(_DWORD *)(v2 + 64);
          }
          v208 = (unsigned int)(v206 + 4);
          v209 = n;
          if ( v28 < n )
            v209 = v28;
          v310 = v209;
          v210 = v313 >= v208;
          if ( v313 < v208 )
            v210 = (unsigned int)dest >= v313 + 4;
          v211 = v210;
          if ( v209 <= 3 )
            v211 = 0;
          v212 = v209 >> 2;
          if ( (((unsigned __int8)v313 | (unsigned __int8)dest) & 3) != 0 )
            v213 = 0;
          else
            v213 = v211 & 1;
          v214 = v213 ^ 1;
          *(_DWORD *)(v2 + 64) = v207 - v310;
          if ( !v212 )
            v214 |= 1u;
          n -= v310;
          v314 = 4 * v212;
          if ( !v214 )
          {
            if ( v212 <= 8 )
            {
              v219 = 0;
              v221 = dest;
              v223 = v313;
            }
            else
            {
              v319 = v9;
              v215 = v212 - 7;
              v216 = dest + 32;
              v317 = v6;
              v217 = v313 + 32;
              do
              {
                v218 = *(_DWORD *)(v217 - 32);
                v29 = v215 > v214 + 9;
                v219 = v214 + 8;
                __pld((void *)(v217 + 84));
                v220 = v217;
                *(v216 - 8) = v218;
                v214 += 8;
                v221 = v216;
                *(v216 - 7) = *(_DWORD *)(v217 - 28);
                *(v216 - 6) = *(_DWORD *)(v217 - 24);
                *(v216 - 5) = *(_DWORD *)(v217 - 20);
                *(v216 - 4) = *(_DWORD *)(v217 - 16);
                *(v216 - 3) = *(_DWORD *)(v217 - 12);
                *(v216 - 2) = *(_DWORD *)(v217 - 8);
                v222 = *(_DWORD *)(v217 - 4);
                v217 += 32;
                *(v216 - 1) = v222;
                v216 += 8;
              }
              while ( v29 );
              v223 = v220;
              v9 = v319;
              v212 = v310 >> 2;
              v6 = v317;
            }
            v224 = v223 - 4;
            do
            {
              v225 = *(_DWORD *)(v224 + 4);
              v224 += 4;
              ++v219;
              *v221++ = v225;
            }
            while ( v212 > v219 );
            v313 += v314;
            v226 = &dest[v314];
            v227 = v310 - v314;
            if ( v314 != v310 )
            {
LABEL_371:
              v228 = &v226[v227];
              v229 = v313 - 1;
              do
              {
                v230 = *(_BYTE *)++v229;
                *v226++ = v230;
              }
              while ( v226 != v228 );
            }
            dest += v310;
            if ( *(_DWORD *)(v2 + 64) )
            {
              v3 = *(_DWORD *)v2;
            }
            else
            {
              v3 = 20;
              *(_DWORD *)v2 = 20;
            }
            continue;
          }
          v227 = v310;
          v226 = dest;
          goto LABEL_371;
        }
        v7[4] = n;
        *v7 = (unsigned int)v6;
        v7[3] = (unsigned int)dest;
        v7[1] = v9;
        *(_DWORD *)(v2 + 56) = v8;
        *(_DWORD *)(v2 + 60) = v4;
        v290 = v7;
        inflate_fast(v7, v303);
        v7 = v290;
        v3 = *(_DWORD *)v2;
        v8 = *(_DWORD *)(v2 + 56);
        v244 = v290[3];
        if ( *(_DWORD *)v2 == 11 )
          v243 = -1;
        v6 = (unsigned __int8 *)*v290;
        dest = (_BYTE *)v290[3];
        if ( *(_DWORD *)v2 == 11 )
          v244 = v2 + 7104;
        v9 = v290[1];
        n = v290[4];
        v4 = *(_DWORD *)(v2 + 60);
        if ( *(_DWORD *)v2 == 11 )
          *(_DWORD *)(v244 + 4) = v243;
        continue;
      case 17:
        v142 = *(_DWORD *)(v2 + 92);
        v143 = *(_DWORD *)(v2 + 104);
        if ( v142 > v143 )
          goto LABEL_235;
        goto LABEL_240;
      case 18:
        v152 = *(_DWORD *)(v2 + 104);
        goto LABEL_247;
      case 19:
        goto LABEL_45;
      case 20:
        goto LABEL_46;
      case 21:
        v41 = *(_DWORD *)(v2 + 72);
        if ( !v41 )
          goto LABEL_60;
        goto LABEL_376;
      case 22:
        goto LABEL_62;
      case 23:
        v21 = *(_DWORD *)(v2 + 72);
        if ( v21 )
          goto LABEL_32;
        goto LABEL_38;
      case 24:
        goto LABEL_39;
      case 25:
        if ( !n )
          goto LABEL_336;
        --n;
        v3 = 20;
        *dest = *(_DWORD *)(v2 + 64);
        *(_DWORD *)v2 = 20;
        ++dest;
        continue;
      case 26:
        v183 = *(_DWORD *)(v2 + 8);
        if ( !v183 )
          goto LABEL_383;
        if ( v4 > 0x1F )
          goto LABEL_293;
        if ( !v9 )
          goto LABEL_336;
        v184 = v6;
        while ( 1 )
        {
          v185 = *v184++;
          --v9;
          v6 = v184;
          v186 = v185 << v4;
          v4 += 8;
          v8 += v186;
          if ( v4 > 0x1F )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_293:
        v187 = v303 - n;
        v188 = *(_DWORD *)(v2 + 28) + v303 - n;
        v7[5] += v303 - n;
        *(_DWORD *)(v2 + 28) = v188;
        if ( v303 != n )
        {
          v189 = *(_DWORD *)(v2 + 24);
          v287 = v7;
          if ( *(_DWORD *)(v2 + 16) )
            v190 = crc32(v189, &dest[-v187], v187);
          else
            v190 = adler32(v189, &dest[-v187], v187);
          v7 = v287;
          *(_DWORD *)(v2 + 24) = v190;
          v287[12] = v190;
        }
        v191 = v8;
        if ( !*(_DWORD *)(v2 + 16) )
          v191 = HIBYTE(v8) + (v8 << 24) + ((v8 >> 8) & 0xFF00) + ((v8 & 0xFF00) << 8);
        if ( v191 != *(_DWORD *)(v2 + 24) )
        {
          v3 = 29;
          v7[6] = (unsigned int)"incorrect data check";
          v303 = n;
          *(_DWORD *)v2 = 29;
          continue;
        }
        v183 = *(_DWORD *)(v2 + 8);
        v4 = 0;
        v8 = 0;
        v303 = n;
LABEL_383:
        *(_DWORD *)v2 = 27;
LABEL_302:
        if ( v183 && *(_DWORD *)(v2 + 16) )
        {
          if ( v4 <= 0x1F )
          {
            if ( !v9 )
              goto LABEL_336;
            v192 = v6;
            while ( 1 )
            {
              v193 = *v192++;
              --v9;
              v6 = v192;
              v194 = v193 << v4;
              v4 += 8;
              v8 += v194;
              if ( v4 > 0x1F )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( *(_DWORD *)(v2 + 28) != v8 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"incorrect length check";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v4 = 0;
          v114 = v9;
          v116 = v7;
          v115 = 0;
          v117 = v6;
        }
        else
        {
          v114 = v9;
          v115 = v8;
          v116 = v7;
          v117 = v6;
        }
        v64 = 1;
        *(_DWORD *)v2 = 28;
        break;
      case 27:
        v183 = *(_DWORD *)(v2 + 8);
        goto LABEL_302;
      case 28:
        v114 = v9;
        v115 = v8;
        v116 = v7;
        v117 = v6;
        v64 = 1;
        goto LABEL_184;
      case 29:
        v114 = v9;
        v115 = v8;
        v116 = v7;
        v117 = v6;
        v64 = -3;
        goto LABEL_184;
      case 30:
        return -4;
      default:
        return -2;
    }
    break;
  }
LABEL_184:
  v118 = *(_DWORD *)(v2 + 40);
  *v116 = (unsigned int)v117;
  v116[3] = (unsigned int)dest;
  v116[4] = n;
  v116[1] = v114;
  *(_DWORD *)(v2 + 56) = v115;
  *(_DWORD *)(v2 + 60) = v4;
  if ( (v118 || n != v303 && *(_DWORD *)v2 <= 0x1Cu && (*(_DWORD *)v2 <= 0x19u || a2 != 4))
    && updatewindow((int)v116, (int)dest, v303 - n) )
  {
    v64 = -4;
    *(_DWORD *)v2 = 30;
    return v64;
  }
  v119 = v304 - v116[1];
  v120 = v116[5];
  v121 = v303 - v116[4];
  v122 = *(_DWORD *)(v2 + 8);
  v123 = *(_DWORD *)(v2 + 28) + v121;
  v116[2] += v119;
  v116[5] = v120 + v121;
  *(_DWORD *)(v2 + 28) = v123;
  if ( v122 && v121 )
  {
    v124 = *(_DWORD *)(v2 + 24);
    v125 = (char *)(v116[3] - v121);
    if ( *(_DWORD *)(v2 + 16) )
      v126 = crc32(v124, v125, v121);
    else
      v126 = adler32(v124, (unsigned __int8 *)v125, v121);
    *(_DWORD *)(v2 + 24) = v126;
    v116[12] = v126;
  }
  v127 = *(_DWORD *)v2;
  if ( *(_DWORD *)(v2 + 4) )
    v128 = 64;
  else
    v128 = 0;
  v129 = v128 + *(_DWORD *)(v2 + 60);
  if ( v127 == 11 )
  {
    v129 += 128;
  }
  else
  {
    v130 = v127 == 19;
    if ( v127 != 19 )
      v130 = v127 == 14;
    if ( v130 )
    {
      v131 = 256;
      goto LABEL_204;
    }
  }
  v131 = 0;
LABEL_204:
  v116[11] = v129 + v131;
  if ( (!(v121 | v119) || a2 == 4) && !v64 )
    return -5;
  return v64;
}
// 40B06: masking with 0x1 was optimized away because r4.1 <= 0x1
// 40AEC: variable 'v313' is possibly undefined
// 40D9E: variable 'v243' is possibly undefined
// 54B48: using guessed type __int16 order_6170[7];

//----- (00041324) --------------------------------------------------------
int __fastcall inflateEnd(_DWORD *a1)
{
  int v2; // r1
  void (__fastcall *v3)(_DWORD, int); // r3
  int result; // r0

  if ( !a1 )
    return -2;
  v2 = a1[7];
  if ( !v2 )
    return -2;
  v3 = (void (__fastcall *)(_DWORD, int))a1[9];
  if ( !v3 )
    return -2;
  if ( *(_DWORD *)(v2 + 52) )
  {
    v3(a1[10], *(_DWORD *)(v2 + 52));
    v3 = (void (__fastcall *)(_DWORD, int))a1[9];
    v2 = a1[7];
  }
  v3(a1[10], v2);
  result = 0;
  a1[7] = 0;
  return result;
}

//----- (00041350) --------------------------------------------------------
int __fastcall inflateGetDictionary(int a1, void *dest, _DWORD *a3)
{
  int v5; // r4
  int v6; // r2
  int result; // r0

  if ( !a1 )
    return -2;
  v5 = *(_DWORD *)(a1 + 28);
  if ( !v5 )
    return -2;
  v6 = *(_DWORD *)(v5 + 44);
  if ( v6 && dest )
  {
    memcpy(dest, (const void *)(*(_DWORD *)(v5 + 52) + *(_DWORD *)(v5 + 48)), v6 - *(_DWORD *)(v5 + 48));
    memcpy((char *)dest + *(_DWORD *)(v5 + 44) - *(_DWORD *)(v5 + 48), *(const void **)(v5 + 52), *(_DWORD *)(v5 + 48));
  }
  result = 0;
  if ( a3 )
    *a3 = *(_DWORD *)(v5 + 44);
  return result;
}

//----- (00041394) --------------------------------------------------------
int __fastcall inflateSetDictionary(int a1, unsigned __int8 *a2, size_t n)
{
  _DWORD *v6; // r4
  int result; // r0
  unsigned int v8; // r0

  if ( !a1 )
    return -2;
  v6 = *(_DWORD **)(a1 + 28);
  if ( !v6 )
    return -2;
  if ( v6[2] )
  {
    if ( *v6 == 10 )
    {
LABEL_8:
      v8 = adler32(0, 0, 0);
      if ( v6[6] != adler32(v8, a2, n) )
        return -3;
      goto LABEL_5;
    }
    return -2;
  }
  if ( *v6 == 10 )
    goto LABEL_8;
LABEL_5:
  result = updatewindow(a1, (int)&a2[n], n);
  if ( result )
  {
    result = -4;
    *v6 = 30;
  }
  else
  {
    v6[3] = 1;
  }
  return result;
}

//----- (000413F4) --------------------------------------------------------
int __fastcall inflateGetHeader(int a1, int a2)
{
  int v2; // r3
  int result; // r0

  if ( !a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 28);
  if ( !v2 || (*(_DWORD *)(v2 + 8) & 2) == 0 )
    return -2;
  *(_DWORD *)(v2 + 32) = a2;
  result = 0;
  *(_DWORD *)(a2 + 48) = 0;
  return result;
}

//----- (00041410) --------------------------------------------------------
int __fastcall inflateSync(int *a1)
{
  _DWORD *v2; // r4
  unsigned int v3; // r0
  int v4; // r3
  int v5; // r2
  char v6; // r1
  unsigned int v7; // r3
  int v8; // r1
  unsigned int v9; // r7
  unsigned int v10; // r2
  char *v11; // r3
  unsigned int v12; // r7
  unsigned int v13; // r3
  int v14; // r1
  bool v15; // r2
  int v17; // r0
  int v18; // r2
  int v19; // r7
  bool v20; // r1
  int v22; // r5
  int v23; // r0
  int v24; // r1
  int v25; // r0
  int v26; // r2
  int result; // r0
  int v28; // r1
  int v29; // r7
  char v30[37]; // [sp+3h] [bp-25h] BYREF

  if ( !a1 )
    return -2;
  v2 = (_DWORD *)a1[7];
  if ( !v2 )
    return -2;
  v3 = a1[1];
  if ( !v3 && v2[15] <= 7u )
    return -5;
  if ( *v2 == 31 )
  {
    v13 = v2[26];
    v15 = v13 <= 3;
  }
  else
  {
    v4 = v2[15];
    v5 = v2[14];
    *v2 = 31;
    v6 = v4 & 7;
    v7 = v4 & 0xFFFFFFF8;
    v2[15] = v7;
    v8 = v5 << v6;
    v2[14] = v8;
    if ( v7 <= 7 )
    {
      v15 = 1;
      v13 = 0;
      v2[26] = 0;
    }
    else
    {
      v9 = (v7 - 8) >> 3;
      v10 = v8;
      v11 = v30;
      do
      {
        *++v11 = v8;
        v10 >>= 8;
        LOBYTE(v8) = v10;
      }
      while ( v11 != &v30[v9 + 1] );
      v12 = v9 + 1;
      v13 = 0;
      v2[14] = v10;
      v14 = 0;
      v2[15] = 0;
      v2[26] = 0;
      do
      {
        if ( v13 <= 1 )
          v17 = 0;
        else
          v17 = 255;
        if ( (unsigned __int8)v30[v14 + 1] == v17 )
        {
          v15 = ++v13 <= 3;
        }
        else
        {
          v13 = 4 - v13;
          if ( v30[v14 + 1] )
          {
            v15 = 1;
            v13 = 0;
          }
          else
          {
            v15 = v13 <= 3;
          }
        }
      }
      while ( ++v14 < v12 && v15 );
    }
    v2[26] = v13;
    v3 = a1[1];
  }
  if ( v3 )
    v18 = v15;
  else
    v18 = 0;
  v19 = *a1;
  if ( v18 )
  {
    v18 = 0;
    do
    {
      if ( v13 <= 1 )
        v22 = 0;
      else
        v22 = 255;
      if ( *(unsigned __int8 *)(v19 + v18) == v22 )
      {
        v20 = ++v13 <= 3;
      }
      else
      {
        v13 = 4 - v13;
        if ( *(_BYTE *)(v19 + v18) )
        {
          v20 = 1;
          v13 = 0;
        }
        else
        {
          v20 = v13 <= 3;
        }
      }
    }
    while ( v3 > ++v18 && v20 );
  }
  v2[26] = v13;
  v23 = a1[1];
  v24 = a1[2];
  *a1 = v19 + v18;
  v25 = v23 - v18;
  v26 = v18 + v24;
  a1[1] = v25;
  a1[2] = v26;
  if ( v13 != 4 )
    return -3;
  v28 = v2[2];
  v29 = a1[5];
  v2[10] = 0;
  v2[11] = 0;
  v2[12] = 0;
  v2[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( v28 )
    a1[12] = v28 & 1;
  result = 0;
  v2[1] = 0;
  v2[3] = 0;
  v2[8] = 0;
  v2[14] = 0;
  v2[15] = 0;
  v2[5] = 0x8000;
  v2[27] = v2 + 332;
  v2[20] = v2 + 332;
  v2[19] = v2 + 332;
  v2[1776] = 1;
  v2[1777] = -1;
  a1[2] = v26;
  a1[5] = v29;
  *v2 = 11;
  return result;
}

//----- (000415BC) --------------------------------------------------------
int __fastcall inflateSyncPoint(int a1)
{
  _DWORD *v1; // r3

  if ( !a1 )
    return -2;
  v1 = *(_DWORD **)(a1 + 28);
  if ( !v1 )
    return -2;
  if ( *v1 == 13 )
    return v1[15] == 0;
  return 0;
}

//----- (000415E0) --------------------------------------------------------
int __fastcall inflateCopy(_DWORD *a1, int *a2)
{
  bool v2; // zf
  int v5; // r5
  int (__fastcall *v6)(int, int, int); // r3
  _DWORD *v7; // r6
  void *v8; // r7
  int *v9; // r3
  _DWORD *v10; // r4
  int *v11; // r2
  int v12; // r12
  int v13; // lr
  int v14; // r0
  int v15; // r1
  int v16; // lr
  int v17; // r3
  unsigned int v18; // r1
  int v19; // r3
  int result; // r0
  unsigned int v21; // r2

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 )
    return -2;
  v5 = a2[7];
  if ( !v5 )
    return -2;
  v6 = (int (__fastcall *)(int, int, int))a2[8];
  if ( !v6 || !a2[9] )
    return -2;
  v7 = (_DWORD *)v6(a2[10], 1, 7116);
  if ( !v7 )
    return -4;
  v8 = *(void **)(v5 + 52);
  if ( v8 && (v8 = (void *)((int (__fastcall *)(int, int, int))a2[8])(a2[10], 1 << *(_DWORD *)(v5 + 36), 1)) == 0 )
  {
    ((void (__fastcall *)(int, _DWORD *))a2[9])(a2[10], v7);
    return -4;
  }
  else
  {
    v9 = a2;
    v10 = a1;
    v11 = v9 + 12;
    do
    {
      v12 = *v9;
      v13 = v9[1];
      v14 = v9[2];
      v15 = v9[3];
      v9 += 4;
      *v10 = v12;
      v10[1] = v13;
      v10[2] = v14;
      v10[3] = v15;
      v10 += 4;
    }
    while ( v9 != v11 );
    v16 = *v9;
    v17 = v9[1];
    *v10 = v16;
    v10[1] = v17;
    memcpy(v7, (const void *)v5, 0x1BCCu);
    v18 = *(_DWORD *)(v5 + 76);
    v19 = v5 + 1328;
    if ( v18 >= v5 + 1328 && v18 <= v5 + 7100 )
    {
      v21 = (*(_DWORD *)(v5 + 80) - v19) & 0xFFFFFFFC;
      v7[19] = (char *)v7 + ((v18 - v19) & 0xFFFFFFFC) + 1328;
      v7[20] = (char *)v7 + v21 + 1328;
    }
    v7[27] = (char *)v7 + ((*(_DWORD *)(v5 + 108) - v19) & 0xFFFFFFFC) + 1328;
    if ( v8 )
      memcpy(v8, *(const void **)(v5 + 52), 1 << *(_DWORD *)(v5 + 36));
    v7[13] = v8;
    result = 0;
    a1[7] = v7;
  }
  return result;
}

//----- (000416F0) --------------------------------------------------------
int __fastcall inflateUndermine(int a1)
{
  int v1; // r3

  if ( !a1 )
    return -2;
  v1 = *(_DWORD *)(a1 + 28);
  if ( !v1 )
    return -2;
  *(_DWORD *)(v1 + 7104) = 1;
  return -3;
}

//----- (0004170C) --------------------------------------------------------
int __fastcall inflateMark(int a1)
{
  int *v1; // r3
  _DWORD *v2; // r1
  int v3; // r2
  int v4; // r0
  bool v5; // zf
  int v6; // r0
  bool v7; // zf

  if ( !a1 )
    return -65536;
  v1 = *(int **)(a1 + 28);
  if ( !v1 )
    return -65536;
  v2 = v1 + 1776;
  v3 = *v1;
  v4 = v1[1777];
  v5 = *v1 == 15;
  if ( *v1 == 15 )
    v1 = (int *)v1[16];
  v6 = v4 << 16;
  if ( !v5 )
  {
    v7 = v3 == 24;
    if ( v3 == 24 )
      v3 = v2[2];
    else
      v1 = 0;
    if ( v7 )
      v1 = (int *)(v3 - v1[16]);
  }
  return (int)v1 + v6;
}

//----- (00041740) --------------------------------------------------------
int __fastcall inflate_table(int a1, int a2, unsigned int a3, int *a4, unsigned int *a5, void **a6)
{
  int v6; // r5
  unsigned __int16 *v7; // r3
  int v8; // r6
  unsigned int v9; // r4
  _WORD *v10; // r6
  _WORD *v11; // r6
  _WORD *v12; // r6
  _WORD *v13; // r6
  _WORD *v14; // r6
  _WORD *v15; // r6
  _WORD *v16; // r6
  _WORD *v17; // r6
  _WORD *v18; // r6
  _WORD *v19; // r6
  _WORD *v20; // r6
  _WORD *v21; // r6
  _WORD *v22; // r6
  _WORD *v23; // r6
  int v24; // r6
  int v25; // r5
  int v26; // t1
  unsigned int v27; // r5
  int v28; // r6
  int result; // r0
  int v30; // r3
  int v31; // r4
  unsigned int v32; // r9
  int v33; // r3
  unsigned int v34; // r10
  int v35; // r3
  int v36; // r3
  int v37; // r3
  int v38; // r3
  int v39; // r3
  int v40; // r3
  int v41; // r3
  int v42; // r3
  int v43; // r3
  int v44; // r4
  int v45; // r3
  int v46; // r3
  int v47; // r3
  _BOOL4 v48; // r3
  int v49; // r3
  int v50; // r4
  int v51; // r6
  int v52; // t1
  _WORD *v53; // r6
  int v54; // r7
  int v55; // r3
  unsigned int v56; // r2
  bool v58; // r0
  unsigned int v59; // r0
  unsigned int v60; // r4
  unsigned int v61; // r8
  char v62; // r1
  char v63; // r6
  int v64; // r5
  bool v65; // cc
  char v66; // r12
  int v67; // r2
  int v68; // r1
  int v69; // r3
  int v70; // r2
  unsigned int i; // r3
  _WORD *v72; // r2
  int v73; // r2
  int v74; // r3
  char *v75; // r6
  int v76; // t1
  int v77; // r3
  unsigned int v78; // r5
  int v81; // r2
  char *v82; // r3
  int v83; // t1
  char *v84; // [sp+Ch] [bp-94h]
  int v85; // [sp+10h] [bp-90h]
  unsigned int v86; // [sp+14h] [bp-8Ch]
  int v88; // [sp+1Ch] [bp-84h]
  int v90; // [sp+24h] [bp-7Ch]
  int v91; // [sp+28h] [bp-78h]
  bool v92; // [sp+2Ch] [bp-74h]
  unsigned int v93; // [sp+30h] [bp-70h]
  bool v94; // [sp+34h] [bp-6Ch]
  void **v95; // [sp+38h] [bp-68h]
  void **v96; // [sp+3Ch] [bp-64h]
  int v97; // [sp+40h] [bp-60h] BYREF
  int v98; // [sp+44h] [bp-5Ch]
  int v99; // [sp+48h] [bp-58h]
  int v100; // [sp+4Ch] [bp-54h]
  int v101; // [sp+50h] [bp-50h]
  int v102; // [sp+54h] [bp-4Ch]
  int v103; // [sp+58h] [bp-48h]
  int v104; // [sp+5Ch] [bp-44h]
  __int16 v105; // [sp+62h] [bp-3Eh]
  __int16 v106; // [sp+64h] [bp-3Ch]
  __int16 v107; // [sp+66h] [bp-3Ah]
  __int16 v108; // [sp+68h] [bp-38h]
  __int16 v109; // [sp+6Ah] [bp-36h]
  __int16 v110; // [sp+6Ch] [bp-34h]
  __int16 v111; // [sp+6Eh] [bp-32h]
  __int16 v112; // [sp+70h] [bp-30h]
  __int16 v113; // [sp+72h] [bp-2Eh]
  __int16 v114; // [sp+74h] [bp-2Ch]
  __int16 v115; // [sp+76h] [bp-2Ah]
  __int16 v116; // [sp+78h] [bp-28h]
  __int16 v117; // [sp+7Ah] [bp-26h]
  __int16 v118; // [sp+7Ch] [bp-24h]
  __int16 v119; // [sp+7Eh] [bp-22h]
  _WORD v120[16]; // [sp+80h] [bp-20h] BYREF

  v6 = 0;
  v97 = 0;
  v98 = 0;
  v99 = 0;
  v100 = 0;
  v101 = 0;
  v102 = 0;
  v103 = 0;
  v104 = 0;
  if ( a3 )
  {
    if ( a3 <= 0x10 )
    {
      v9 = 0;
    }
    else
    {
      v7 = (unsigned __int16 *)(a2 + 46);
      do
      {
        v8 = *(v7 - 23);
        v9 = v6 + 16;
        v65 = a3 - 15 > v6 + 17;
        __pld(v7);
        v6 += 16;
        ++*((_WORD *)&v97 + v8);
        v10 = &v120[*(v7 - 22)];
        ++*(v10 - 32);
        v11 = &v120[*(v7 - 21)];
        ++*(v11 - 32);
        v12 = &v120[*(v7 - 20)];
        ++*(v12 - 32);
        v13 = &v120[*(v7 - 19)];
        ++*(v13 - 32);
        v14 = &v120[*(v7 - 18)];
        ++*(v14 - 32);
        v15 = &v120[*(v7 - 17)];
        ++*(v15 - 32);
        v16 = &v120[*(v7 - 16)];
        ++*(v16 - 32);
        v17 = &v120[*(v7 - 15)];
        ++*(v17 - 32);
        v18 = &v120[*(v7 - 14)];
        ++*(v18 - 32);
        v19 = &v120[*(v7 - 13)];
        ++*(v19 - 32);
        v20 = &v120[*(v7 - 12)];
        ++*(v20 - 32);
        v21 = &v120[*(v7 - 11)];
        ++*(v21 - 32);
        v22 = &v120[*(v7 - 10)];
        ++*(v22 - 32);
        v23 = &v120[*(v7 - 9)];
        ++*(v23 - 32);
        v24 = *(v7 - 8);
        v7 += 16;
        ++*((_WORD *)&v97 + v24);
      }
      while ( v65 );
    }
    v25 = a2 + 2 * (v9 - 1);
    do
    {
      v26 = *(unsigned __int16 *)(v25 + 2);
      v25 += 2;
      ++v9;
      ++*((_WORD *)&v97 + v26);
    }
    while ( a3 > v9 );
  }
  v27 = *a5;
  if ( HIWORD(v104) )
  {
    v32 = 15;
  }
  else if ( (_WORD)v104 )
  {
    v32 = 14;
  }
  else if ( HIWORD(v103) )
  {
    v32 = 13;
  }
  else if ( (_WORD)v103 )
  {
    v32 = 12;
  }
  else if ( HIWORD(v102) )
  {
    v32 = 11;
  }
  else if ( (_WORD)v102 )
  {
    v32 = 10;
  }
  else if ( HIWORD(v101) )
  {
    v32 = 9;
  }
  else if ( (_WORD)v101 )
  {
    v32 = 8;
  }
  else if ( HIWORD(v100) )
  {
    v32 = 7;
  }
  else if ( (_WORD)v100 )
  {
    v32 = 6;
  }
  else if ( HIWORD(v99) )
  {
    v32 = 5;
  }
  else if ( (_WORD)v99 )
  {
    v32 = 4;
  }
  else if ( HIWORD(v98) )
  {
    v32 = 3;
  }
  else
  {
    if ( !(_WORD)v98 )
    {
      v28 = HIWORD(v97);
      if ( !HIWORD(v97) )
      {
        result = HIWORD(v97);
        v30 = *a4;
        v31 = *a4 + 8;
        *(_WORD *)(v30 + 2) = HIWORD(v97);
        *(_WORD *)(v30 + 6) = v28;
        *(_BYTE *)v30 = 64;
        *(_BYTE *)(v30 + 4) = 64;
        *(_BYTE *)(v30 + 1) = 1;
        *(_BYTE *)(v30 + 5) = 1;
        *a4 = v31;
        *a5 = 1;
        return result;
      }
      v27 = v27 != 0;
      v32 = 1;
      goto LABEL_25;
    }
    v32 = 2;
  }
  v28 = HIWORD(v97);
  if ( v32 < v27 )
    v27 = v32;
  if ( !HIWORD(v97) )
  {
    v82 = (char *)&v97 + 2;
    v34 = 1;
    do
    {
      if ( ++v34 == v32 )
        break;
      v83 = *((unsigned __int16 *)v82 + 1);
      v82 += 2;
    }
    while ( !v83 );
    v33 = 2;
    goto LABEL_27;
  }
LABEL_25:
  v33 = 2 - v28;
  if ( 2 - v28 < 0 )
    return -1;
  v34 = 1;
LABEL_27:
  v35 = 2 * v33 - (unsigned __int16)v98;
  if ( v35 < 0 )
    return -1;
  v36 = 2 * v35 - HIWORD(v98);
  if ( v36 < 0 )
    return -1;
  v37 = 2 * v36 - (unsigned __int16)v99;
  if ( v37 < 0 )
    return -1;
  v38 = 2 * v37 - HIWORD(v99);
  if ( v38 < 0 )
    return -1;
  v39 = 2 * v38 - (unsigned __int16)v100;
  if ( v39 < 0 )
    return -1;
  v40 = 2 * v39 - HIWORD(v100);
  if ( v40 < 0 )
    return -1;
  v41 = 2 * v40 - (unsigned __int16)v101;
  if ( v41 < 0 )
    return -1;
  v42 = 2 * v41 - HIWORD(v101);
  if ( v42 < 0 )
    return -1;
  v43 = 2 * v42 - (unsigned __int16)v102;
  if ( v43 < 0 )
    return -1;
  v44 = 2 * v43 - HIWORD(v102);
  if ( v44 < 0 )
    return -1;
  if ( 2 * v44 - (unsigned __int16)v103 < 0 )
    return -1;
  v45 = 2 * (2 * v44 - (unsigned __int16)v103) - HIWORD(v103);
  if ( v45 < 0 )
    return -1;
  v46 = 2 * v45 - (unsigned __int16)v104;
  if ( v46 < 0 )
    return -1;
  v47 = 2 * v46 - HIWORD(v104);
  if ( v47 < 0 )
    return -1;
  if ( v47 )
  {
    v48 = a1 == 0;
    if ( v32 != 1 )
      v48 = 1;
    if ( v48 )
      return -1;
  }
  v49 = 0;
  v106 = v28;
  v105 = 0;
  v107 = v28 + v98;
  v108 = v28 + v98 + HIWORD(v98);
  v109 = v108 + v99;
  v110 = v108 + v99 + HIWORD(v99);
  v111 = v110 + v100;
  v112 = v110 + v100 + HIWORD(v100);
  v113 = v112 + v101;
  v114 = v113 + HIWORD(v101);
  v115 = v113 + HIWORD(v101) + v102;
  v116 = v115 + HIWORD(v102);
  v117 = v115 + HIWORD(v102) + v103;
  v118 = v117 + HIWORD(v103);
  v119 = v118 + v104;
  if ( a3 )
  {
    v50 = a2 - 2;
    do
    {
      v52 = *(unsigned __int16 *)(v50 + 2);
      v50 += 2;
      v51 = v52;
      if ( v52 )
      {
        v53 = &v120[v51];
        v54 = (unsigned __int16)*(v53 - 16);
        *((_WORD *)a6 + v54) = v49;
        *(v53 - 16) = v54 + 1;
      }
      ++v49;
    }
    while ( v49 != a3 );
  }
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v90 = 256;
      v95 = (void **)&unk_54B56;
      v96 = (void **)&unk_54B96;
    }
    else
    {
      v90 = -1;
      v95 = &dext_6056;
      v96 = (void **)&dbase_6055;
    }
  }
  else
  {
    v95 = a6;
    v96 = a6;
    v90 = 19;
  }
  v55 = 1;
  if ( v34 >= v27 )
    v27 = v34;
  v56 = 1 << v27;
  v86 = v27;
  v92 = a1 == 1;
  v85 = *a4;
  if ( (unsigned int)(1 << v27) > 0x354 && a1 == 1 )
    return 1;
  v58 = a1 == 2;
  v94 = v58;
  v59 = v56 > 0x250 && v58;
  if ( v59 )
    return 1;
  LOBYTE(v60) = v27;
  v84 = (char *)a6 - 2;
  v61 = 0;
  v62 = v34;
  v88 = 1 << v27;
  v93 = v56 - 1;
  v91 = -1;
  while ( 1 )
  {
    v63 = v62;
    v64 = *((unsigned __int16 *)v84 + 1);
    v65 = v90 < v64;
    v84 += 2;
    if ( v90 <= v64 )
    {
      if ( v90 >= v64 )
        v67 = 96;
      else
        v67 = (int)v95;
      if ( v90 >= v64 )
        v64 = 0;
      else
        v55 = (int)v96;
      if ( v65 )
      {
        LOBYTE(v67) = *(_BYTE *)(v67 + 2 * v64);
        LOWORD(v64) = *(_WORD *)(v55 + 2 * v64);
      }
      v66 = v67;
    }
    else
    {
      v66 = 0;
    }
    v68 = 1 << v62;
    v69 = v85 + 4 * ((v59 >> v61) + (1 << v60) - v68);
    v70 = 1 << v60;
    do
    {
      v70 -= v68;
      *(_BYTE *)v69 = v66;
      *(_BYTE *)(v69 + 1) = v63;
      *(_WORD *)(v69 + 2) = v64;
      v69 -= 4 * v68;
    }
    while ( v70 );
    for ( i = 1 << (v34 - 1); (v59 & i) != 0; i >>= 1 )
      ;
    if ( i )
      v59 = (v59 & (i - 1)) + i;
    else
      v59 = 0;
    v72 = &v120[v34];
    v55 = (unsigned __int16)(*(v72 - 32) - 1);
    *(v72 - 32) = v55;
    if ( (_WORD)v55 )
      goto LABEL_83;
    if ( v34 == v32 )
      break;
    v55 = *((unsigned __int16 *)v84 + 1);
    v34 = *(unsigned __int16 *)(a2 + 2 * v55);
LABEL_83:
    if ( v86 >= v34 || (v73 = v59 & v93, (v59 & v93) == v91) )
    {
      v62 = v34 - v61;
    }
    else
    {
      if ( !v61 )
        v61 = v86;
      v85 += 4 * (1 << v60);
      v60 = v34 - v61;
      v62 = v34 - v61;
      if ( v34 < v32 )
      {
        v74 = (1 << (v34 - v61)) - *((unsigned __int16 *)&v97 + v34);
        if ( v74 > 0 )
        {
          v75 = (char *)&v97 + 2 * v34;
          do
          {
            ++v60;
            v77 = 2 * v74;
            if ( v32 <= v61 + v60 )
              break;
            v76 = *((unsigned __int16 *)v75 + 1);
            v75 += 2;
            v74 = v77 - v76;
          }
          while ( v74 > 0 );
        }
      }
      v78 = v88 + (1 << v60);
      v88 = v78;
      if ( v78 > 0x354 && v92 )
        return 1;
      if ( v78 > 0x250 && v94 )
        return 1;
      v91 = v59 & v93;
      *(_BYTE *)(*a4 + 4 * v73) = v60;
      *(_BYTE *)(*a4 + 4 * v73 + 1) = v86;
      v55 = *a4 + 4 * v73;
      *(_WORD *)(v55 + 2) = (v85 - *a4) >> 2;
    }
  }
  if ( v59 )
  {
    *(_BYTE *)(v85 + 4 * v59) = 64;
    v81 = v85 + 4 * v59;
    *(_BYTE *)(v81 + 1) = v63;
    *(_WORD *)(v81 + 2) = 0;
  }
  result = 0;
  *a4 += 4 * v88;
  *a5 = v86;
  return result;
}
// 54DD8: using guessed type void *dext_6056;

//----- (00041E60) --------------------------------------------------------
const char *zlibVersion()
{
  return "1.2.8";
}

//----- (00041E6C) --------------------------------------------------------
int zlibCompileFlags()
{
  return 85;
}

//----- (00041E70) --------------------------------------------------------
char *__fastcall zError(int a1)
{
  return z_errmsg[2 - a1];
}
// 54E88: using guessed type char *z_errmsg[2];

//----- (00041E84) --------------------------------------------------------
void *__fastcall zcalloc(int a1, int a2, int a3)
{
  return j_malloc(a2 * a3);
}

//----- (00041E8C) --------------------------------------------------------
void __fastcall zcfree(int a1, void *ptr)
{
  j_free(ptr);
}

//----- (00041E94) --------------------------------------------------------
int __fastcall adler32(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // r3
  unsigned int v4; // r6
  unsigned __int8 *v5; // r2
  int v6; // t1
  bool v7; // cc
  unsigned __int8 *v9; // r7
  unsigned int v10; // r0
  unsigned int v11; // r5
  unsigned int v12; // r4
  unsigned int v13; // r10
  unsigned int v14; // r4
  unsigned int v15; // r1
  unsigned int v16; // r10
  unsigned int v17; // r1
  unsigned int v18; // r0
  unsigned int v19; // r10
  unsigned int v20; // r0
  unsigned int v21; // r5
  unsigned int v22; // r10
  unsigned int v23; // r5
  int v24; // r4
  int v25; // r5
  int v26; // r4
  int v27; // r1
  int v28; // r5
  int v29; // r4
  int v30; // r5
  int v31; // r1
  int v32; // r0
  int v33; // r1
  unsigned int v34; // r0
  unsigned int v35; // r6
  unsigned int v36; // r1
  unsigned __int8 *v37; // r4
  unsigned int v38; // r0
  unsigned int v39; // r7
  unsigned int v40; // r5
  unsigned int v41; // r12
  unsigned int v42; // r5
  unsigned int v43; // r0
  unsigned int v44; // r12
  unsigned int v45; // r0
  unsigned int v46; // r7
  unsigned int v47; // r5
  unsigned int v48; // r12
  unsigned int v49; // r5
  unsigned int v50; // r0
  int v51; // r12
  int v52; // r0
  int v53; // r7
  int v54; // r5
  int v55; // r12
  int v56; // r5
  int v57; // r0
  int v58; // r5
  unsigned int v59; // r1
  unsigned int v60; // r4
  unsigned int v61; // r2
  unsigned __int8 *v62; // r1
  int v63; // t1

  v3 = a2;
  v4 = HIWORD(a1);
  a1 = (unsigned __int16)a1;
  if ( a3 != 1 )
  {
    if ( !a2 )
      return 1;
    if ( a3 <= 0xF )
    {
      if ( a3 )
      {
        v5 = &a2[a3];
        do
        {
          v6 = *v3++;
          a1 += v6;
          v4 += a1;
        }
        while ( v3 != v5 );
      }
      v7 = a1 > 0xFFF0;
      if ( a1 > 0xFFF0 )
        a1 -= 65280;
      if ( v7 )
        a1 -= 241;
      return a1 | ((v4 % 0xFFF1) << 16);
    }
    if ( a3 <= 0x15AF )
      goto LABEL_24;
    do
    {
      a3 -= 5552;
      v9 = v3 + 5552;
      do
      {
        v10 = a1 + *v3;
        v11 = v10 + v3[1];
        v12 = v11 + v3[2];
        v13 = v11 + v10 + v12;
        v14 = v12 + v3[3];
        v15 = v14 + v3[4];
        v16 = v13 + v14 + v15;
        v17 = v15 + v3[5];
        v18 = v17 + v3[6];
        v19 = v16 + v17 + v18;
        v20 = v18 + v3[7];
        v21 = v20 + v3[8];
        v22 = v19 + v20 + v21;
        v23 = v21 + v3[9];
        v24 = v23 + v3[10];
        v25 = v22 + v23 + v24;
        v26 = v24 + v3[11];
        v27 = v26 + v3[12];
        v28 = v25 + v26;
        v29 = v3[15];
        v30 = v28 + v27;
        v31 = v27 + v3[13];
        v32 = v31 + v3[14];
        v3 += 16;
        v33 = v30 + v31 + v32;
        a1 = v32 + v29;
        v4 += v33 + a1;
      }
      while ( v3 != v9 );
      a1 %= 0xFFF1u;
      v4 %= 0xFFF1u;
    }
    while ( a3 > 0x15AF );
    if ( !a3 )
      return a1 | (v4 << 16);
    if ( a3 <= 0xF )
    {
      v61 = a3 - 1;
    }
    else
    {
LABEL_24:
      v36 = a3;
      v37 = v3;
      do
      {
        v36 -= 16;
        v38 = a1 + *v37;
        v39 = v37[1] + v38;
        v40 = v37[2] + v39;
        v41 = v38 + v39 + v40;
        v42 = v40 + v37[3];
        v43 = v42 + v37[4];
        v44 = v41 + v42 + v43;
        v45 = v43 + v37[5];
        v46 = v37[6] + v45;
        v47 = v37[7] + v46;
        v48 = v44 + v45 + v46 + v47;
        v49 = v47 + v37[8];
        v50 = v37[9] + v49;
        v51 = v48 + v49 + v50;
        v52 = v50 + v37[10];
        v53 = v37[11] + v52;
        v54 = v37[12] + v53;
        v55 = v51 + v52 + v53 + v54;
        v56 = v54 + v37[13];
        v57 = v37[14] + v56;
        v58 = v55 + v56 + v57;
        a1 = v57 + v37[15];
        v37 += 16;
        v4 += v58 + a1;
      }
      while ( v36 > 0xF );
      v59 = a3 & 0xF;
      v60 = (a3 - 16) & 0xFFFFFFF0;
      v61 = v59 - 1;
      v3 += v60 + 16;
      if ( !v59 )
        return (a1 % 0xFFF1) | ((v4 % 0xFFF1) << 16);
    }
    v62 = &v3[v61 + 1];
    do
    {
      v63 = *v3++;
      a1 += v63;
      v4 += a1;
    }
    while ( v3 != v62 );
    return (a1 % 0xFFF1) | ((v4 % 0xFFF1) << 16);
  }
  v34 = *a2 + (unsigned __int16)a1;
  if ( v34 > 0xFFF0 )
    v34 -= 65521;
  v35 = v34 + v4;
  if ( v35 > 0xFFF0 )
    v35 -= 65521;
  return v34 | (v35 << 16);
}
// 41E94: too many cbuild loops

//----- (000420BC) --------------------------------------------------------
unsigned int __fastcall adler32_combine(unsigned int a1, unsigned int a2, int a3)
{
  int v4; // r2
  unsigned int v5; // r4
  int v6; // r0
  int v7; // r5
  unsigned int v8; // r4
  unsigned int v9; // r3

  if ( a3 >> 31 == -1 )
    return -1;
  v4 = a3 % 65521;
  v5 = (unsigned __int16)a1 * v4;
  v6 = (unsigned __int16)a1 + (unsigned __int16)a2;
  v7 = 65520;
  v8 = HIWORD(a1) + HIWORD(a2) - v4 + v5 % 0xFFF1;
  v9 = v8 + 65521;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( (unsigned int)(v6 - 1) > 0xFFF0 )
      v7 = v6 - 65522;
  }
  if ( v9 > 0x1FFE1 )
    v9 = v8 - 65521;
  if ( v9 > 0xFFF0 )
    v9 -= 65521;
  return v7 | (v9 << 16);
}

//----- (00042154) --------------------------------------------------------
unsigned int __fastcall adler32_combine64(unsigned int a1, unsigned int a2, __int64 a3)
{
  __int64 v4; // r2
  unsigned int v5; // r6
  int v6; // r0
  int v7; // r7
  int v8; // r6
  unsigned int v9; // r3

  if ( a3 < 0 )
    return -1;
  v4 = a3 % 65521;
  v5 = (unsigned __int16)a1 * (_DWORD)v4;
  v6 = (unsigned __int16)a1 + (unsigned __int16)a2;
  v7 = 65520;
  v8 = HIWORD(a1) + HIWORD(a2) - v4 + v5 % 0xFFF1;
  v9 = v8 + 65521;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( (unsigned int)(v6 - 1) > 0xFFF0 )
      v7 = v6 - 65522;
  }
  if ( v9 > 0x1FFE1 )
    v9 = v8 - 65521;
  if ( v9 > 0xFFF0 )
    v9 -= 65521;
  return v7 | (v9 << 16);
}

//----- (000421E8) --------------------------------------------------------
int __fastcall crc32_combine_(int result, int a2, __int64 a3)
{
  unsigned int v4; // r6
  int v5; // r5
  int *v6; // r4
  int i; // r8
  unsigned int v8; // r4
  char *v9; // r5
  int v10; // r7
  int j; // r8
  unsigned int v12; // r4
  char *v13; // r5
  int v14; // r7
  int v15; // r6
  int k; // r10
  unsigned int v17; // r7
  char *v18; // r8
  int v19; // r6
  int v20; // r1
  int v21; // r6
  unsigned int v22; // r7
  char *v23; // r8
  __int64 v24; // r2
  int m; // r10
  unsigned int v26; // r7
  char *v27; // r8
  int v28; // r6
  int v29; // r1
  int v30; // r6
  unsigned int v31; // r7
  char *v32; // r8
  _BYTE v33[4]; // [sp+0h] [bp-120h]
  char v34[124]; // [sp+4h] [bp-11Ch] BYREF
  int v35; // [sp+80h] [bp-A0h] BYREF
  char v36[120]; // [sp+84h] [bp-9Ch] BYREF
  char v37; // [sp+FCh] [bp-24h] BYREF

  if ( a3 >= 1 )
  {
    v4 = (unsigned int)&v37;
    v35 = -306674912;
    v5 = 1;
    v6 = &v35;
    do
    {
      v6[1] = v5;
      ++v6;
      v5 *= 2;
    }
    while ( v6 != (int *)&v37 );
    for ( i = 0; i != 128; i += 4 )
    {
      while ( 1 )
      {
        v8 = *(_DWORD *)&v36[i - 4];
        if ( v8 )
          break;
        *(_DWORD *)&v33[i] = 0;
        i += 4;
        if ( i == 128 )
          goto LABEL_13;
      }
      v9 = v36;
      v10 = 0;
      do
      {
        if ( (v8 & 1) != 0 )
          v4 = *((_DWORD *)v9 - 1);
        v9 += 4;
        if ( (v8 & 1) != 0 )
          v10 ^= v4;
        v8 >>= 1;
      }
      while ( v8 );
      *(_DWORD *)&v33[i] = v10;
    }
LABEL_13:
    for ( j = 0; j != 128; j += 4 )
    {
      while ( 1 )
      {
        v12 = *(_DWORD *)&v33[j];
        if ( v12 )
          break;
        *(_DWORD *)&v36[j - 4] = 0;
        j += 4;
        if ( j == 128 )
          goto LABEL_22;
      }
      v13 = v34;
      v14 = 0;
      do
      {
        v15 = v12 << 31;
        if ( (v12 & 1) != 0 )
          v15 = *((_DWORD *)v13 - 1);
        v13 += 4;
        if ( (v12 & 1) != 0 )
          v14 ^= v15;
        v12 >>= 1;
      }
      while ( v12 );
      *(_DWORD *)&v36[j - 4] = v14;
    }
    do
    {
LABEL_22:
      for ( k = 0; k != 128; k += 4 )
      {
        while ( 1 )
        {
          v17 = *(_DWORD *)&v36[k - 4];
          if ( v17 )
            break;
          *(_DWORD *)&v33[k] = 0;
          k += 4;
          if ( k == 128 )
            goto LABEL_31;
        }
        v18 = v36;
        v19 = 0;
        do
        {
          v20 = v17 << 31;
          if ( (v17 & 1) != 0 )
            v20 = *((_DWORD *)v18 - 1);
          v18 += 4;
          if ( (v17 & 1) != 0 )
            v19 ^= v20;
          v17 >>= 1;
        }
        while ( v17 );
        *(_DWORD *)&v33[k] = v19;
      }
LABEL_31:
      v21 = a3 & 1;
      if ( (a3 & 1) != 0 && result )
      {
        v22 = result;
        v23 = v34;
        result = 0;
        do
        {
          if ( (v22 & 1) != 0 )
            v21 = *((_DWORD *)v23 - 1);
          v23 += 4;
          if ( (v22 & 1) != 0 )
            result ^= v21;
          v22 >>= 1;
        }
        while ( v22 );
      }
      v24 = a3 >> 1;
      if ( !v24 )
        break;
      for ( m = 0; m != 128; m += 4 )
      {
        while ( 1 )
        {
          v26 = *(_DWORD *)&v33[m];
          if ( v26 )
            break;
          *(_DWORD *)&v36[m - 4] = 0;
          m += 4;
          if ( m == 128 )
            goto LABEL_49;
        }
        v27 = v34;
        v28 = 0;
        do
        {
          v29 = v26 << 31;
          if ( (v26 & 1) != 0 )
            v29 = *((_DWORD *)v27 - 1);
          v27 += 4;
          if ( (v26 & 1) != 0 )
            v28 ^= v29;
          v26 >>= 1;
        }
        while ( v26 );
        *(_DWORD *)&v36[m - 4] = v28;
      }
LABEL_49:
      v30 = v24 & 1;
      if ( (v24 & 1) != 0 && result )
      {
        v31 = result;
        v32 = v36;
        result = 0;
        do
        {
          if ( (v31 & 1) != 0 )
            v30 = *((_DWORD *)v32 - 1);
          v32 += 4;
          if ( (v31 & 1) != 0 )
            result ^= v30;
          v31 >>= 1;
        }
        while ( v31 );
      }
      a3 = v24 >> 1;
    }
    while ( a3 );
    return result ^ a2;
  }
  return result;
}

//----- (000423B8) --------------------------------------------------------
void *get_crc_table()
{
  return &crc_table;
}

//----- (000423C4) --------------------------------------------------------
unsigned int __fastcall crc32(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // r6
  char *v4; // r0
  char v5; // t1
  char *v7; // r7
  unsigned int v8; // r5
  char *v9; // r4
  unsigned int v10; // r9
  int v11; // r1
  int v12; // r12
  unsigned int v13; // r8
  int v14; // r2
  unsigned int v15; // r0
  int v16; // r10
  int v17; // r8
  int v18; // r1
  int v19; // r0
  unsigned int v20; // r1
  unsigned int v21; // r11
  unsigned int v22; // r2
  unsigned int v23; // r6
  unsigned int v24; // r0
  unsigned int v25; // r8
  char *v26; // r0
  int v27; // r4
  char *v28; // r2
  char v29; // t1
  int v30; // [sp+0h] [bp-30h]
  int v31; // [sp+4h] [bp-2Ch]
  int v32; // [sp+8h] [bp-28h]
  char *v33; // [sp+Ch] [bp-24h]

  if ( !a2 )
    return 0;
  v3 = ~a1;
  if ( a3 )
  {
    if ( (_DWORD)a2 << 30 )
    {
      v4 = a2;
      while ( 1 )
      {
        v5 = *v4++;
        --a3;
        a2 = v4;
        v3 = crc_table[(unsigned __int8)(v5 ^ v3)] ^ (v3 >> 8);
        if ( !a3 )
          break;
        if ( ((unsigned __int8)v4 & 3) == 0 )
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      if ( a3 > 0x1F )
      {
        v7 = a2 + 64;
        v8 = a3;
        v9 = a2;
        v10 = a3;
        v33 = a2;
        do
        {
          v11 = *((_DWORD *)v7 - 16);
          v8 -= 32;
          v12 = *((_DWORD *)v9 + 4);
          __pld(v7);
          __pld(v9 + 68);
          v7 += 32;
          v13 = crc_table[(unsigned __int8)(v3 ^ v11) + 768] ^ crc_table[(v3 ^ v11) >> 24] ^ *((_DWORD *)v9 + 1) ^ crc_table[(unsigned __int8)((unsigned __int16)(v3 ^ v11) >> 8) + 512] ^ crc_table[(unsigned __int8)((v3 ^ v11) >> 16) + 256];
          v32 = *((_DWORD *)v9 + 5);
          v14 = *((_DWORD *)v9 + 7);
          v15 = crc_table[(unsigned __int8)v13 + 768] ^ crc_table[HIBYTE(v13)] ^ *((_DWORD *)v9 + 2) ^ crc_table[BYTE1(v13) + 512] ^ crc_table[BYTE2(v13) + 256];
          v31 = *((_DWORD *)v9 + 6);
          v16 = crc_table[BYTE1(v15) + 512];
          v17 = crc_table[(unsigned __int8)v15 + 768] ^ crc_table[HIBYTE(v15)];
          v18 = crc_table[BYTE2(v15) + 256];
          v19 = *((_DWORD *)v9 + 3);
          v9 += 32;
          v30 = v14;
          v20 = v17 ^ v19 ^ v16 ^ v18;
          v21 = crc_table[(unsigned __int8)v20 + 768] ^ crc_table[HIBYTE(v20)] ^ v12 ^ crc_table[BYTE1(v20) + 512] ^ crc_table[BYTE2(v20) + 256];
          v22 = crc_table[(unsigned __int8)v21 + 768] ^ crc_table[HIBYTE(v21)] ^ v32 ^ crc_table[BYTE1(v21) + 512] ^ crc_table[BYTE2(v21) + 256];
          v23 = crc_table[(unsigned __int8)v22 + 768] ^ crc_table[HIBYTE(v22)] ^ v31 ^ crc_table[BYTE1(v22) + 512] ^ crc_table[BYTE2(v22) + 256];
          v24 = crc_table[(unsigned __int8)v23 + 768] ^ crc_table[HIBYTE(v23)] ^ v30 ^ crc_table[BYTE1(v23) + 512] ^ crc_table[BYTE2(v23) + 256];
          v3 = crc_table[HIBYTE(v24)] ^ crc_table[(unsigned __int8)v24 + 768] ^ crc_table[BYTE1(v24) + 512] ^ crc_table[BYTE2(v24) + 256];
        }
        while ( v8 > 0x1F );
        a3 = v10 & 0x1F;
        a2 = &v33[((v10 - 32) & 0xFFFFFFE0) + 32];
      }
      if ( a3 > 3 )
      {
        v25 = (a3 - 4) >> 2;
        v26 = a2 + 4;
        do
        {
          v27 = *((_DWORD *)v26 - 1);
          v26 += 4;
          v3 = crc_table[(v3 ^ v27) >> 24] ^ crc_table[(unsigned __int8)(v3 ^ v27) + 768] ^ crc_table[(unsigned __int8)((unsigned __int16)(v3 ^ v27) >> 8) + 512] ^ crc_table[(unsigned __int8)((v3 ^ v27) >> 16) + 256];
        }
        while ( v26 != &a2[4 * v25 + 8] );
        a3 &= 3u;
        a2 += 4 * v25 + 4;
      }
      if ( a3 )
      {
        v28 = &a2[a3];
        do
        {
          v29 = *a2++;
          v3 = crc_table[(unsigned __int8)(v29 ^ v3)] ^ (v3 >> 8);
        }
        while ( a2 != v28 );
      }
    }
  }
  return ~v3;
}
// 54F30: using guessed type _DWORD crc_table[2048];

//----- (000426CC) --------------------------------------------------------
int __fastcall crc32_combine(int a1, int a2, int a3)
{
  return crc32_combine_(a1, a2, a3);
}

//----- (000426D8) --------------------------------------------------------
unsigned int __fastcall inflate_fast(unsigned int *a1, int a2)
{
  _DWORD *v2; // r11
  unsigned int v3; // r2
  _BYTE *v4; // r12
  int v5; // r1
  _BYTE *v6; // r2
  int v7; // r4
  unsigned int v8; // r10
  unsigned int v9; // r6
  int v10; // r4
  int v11; // r5
  int v12; // r9
  unsigned int v13; // r8
  unsigned int v14; // r11
  int v15; // r2
  char v16; // r1
  int v17; // r3
  int v18; // r2
  unsigned __int8 *v19; // r1
  int v20; // r3
  int v21; // r2
  unsigned int v22; // r1
  const char *v23; // r2
  unsigned __int8 *v24; // r0
  int v25; // r2
  unsigned int v26; // r3
  unsigned int v27; // r2
  bool v28; // cc
  int v29; // r2
  int v30; // r2
  char *v31; // r1
  char v32; // r3
  int v33; // r0
  int v34; // r1
  char *v35; // r4
  int v36; // r0
  unsigned int v37; // r3
  int v38; // r4
  char v39; // r0
  bool v40; // cc
  int v41; // r4
  int v42; // r4
  int v43; // r1
  _BYTE *v44; // r0
  unsigned int v45; // r1
  unsigned int v46; // r4
  unsigned int v47; // r1
  unsigned int v48; // r0
  unsigned int v49; // r1
  bool v50; // cf
  char v51; // r3
  char v52; // r0
  char v53; // r1
  int v54; // r1
  int v55; // r1
  _BYTE *v56; // r0
  unsigned int v57; // r1
  int v58; // r2
  int v59; // r3
  unsigned int v60; // r4
  unsigned int v61; // r11
  _DWORD *v62; // r8
  int v63; // r3
  _DWORD *v64; // r0
  unsigned int v65; // r1
  int v66; // t1
  _BYTE *v67; // r1
  _BYTE *v68; // r3
  char v69; // t1
  _BYTE *v70; // r3
  char v71; // t1
  bool v72; // cf
  _DWORD *v73; // r11
  unsigned int *v74; // r8
  int v75; // r3
  int v76; // r3
  unsigned int v77; // r1
  unsigned int v78; // r3
  _BYTE *v79; // r4
  unsigned int v80; // r2
  unsigned int v81; // r3
  unsigned int result; // r0
  int v83; // r3
  char v84; // r1
  int v85; // r0
  int v86; // r3
  _BYTE *v87; // r3
  _BYTE *v88; // r4
  char v89; // t1
  unsigned int v90; // r0
  bool v91; // cf
  char v92; // r3
  char v93; // r0
  int v94; // r0
  int v95; // r4
  _BYTE *v96; // r4
  int v97; // r2
  unsigned int v98; // r0
  int v99; // r1
  int v100; // r3
  unsigned int v101; // r11
  unsigned int v102; // r12
  int v103; // r3
  unsigned int v104; // r0
  _DWORD *v105; // r4
  unsigned int v106; // r2
  int v107; // t1
  unsigned int v108; // r1
  _BYTE *v109; // r4
  _BYTE *v110; // r3
  _BYTE *v111; // r0
  char v112; // t1
  _DWORD *v113; // r12
  _DWORD *v114; // r0
  bool v115; // cf
  unsigned int v116; // r4
  char v117; // r3
  int v118; // r3
  int v119; // r1
  _DWORD *v120; // r2
  unsigned int v121; // r0
  int v122; // r5
  unsigned int v123; // r3
  unsigned int v124; // r11
  unsigned int v125; // r4
  int v126; // r5
  unsigned int v127; // r3
  int v128; // t1
  _BYTE *v129; // r1
  int v130; // r3
  unsigned int v131; // r4
  char v132; // t1
  unsigned int v133; // r1
  unsigned int v134; // r0
  unsigned int v135; // r1
  bool v136; // cf
  char v137; // r3
  char v138; // r0
  char v139; // r1
  int v140; // r1
  unsigned int v141; // r4
  _BYTE *v142; // r0
  int v143; // r12
  unsigned int v144; // r1
  int v145; // r3
  unsigned int v146; // r11
  int v147; // r3
  unsigned int v148; // r1
  _DWORD *v149; // r0
  int v150; // t1
  _BYTE *v151; // r1
  _BYTE *v152; // r3
  char v153; // t1
  int v154; // [sp+0h] [bp-B0h]
  _BYTE *v155; // [sp+4h] [bp-ACh]
  unsigned int v156; // [sp+8h] [bp-A8h]
  unsigned int v157; // [sp+8h] [bp-A8h]
  int v158; // [sp+Ch] [bp-A4h]
  unsigned int v159; // [sp+Ch] [bp-A4h]
  unsigned int v160; // [sp+Ch] [bp-A4h]
  unsigned int v161; // [sp+Ch] [bp-A4h]
  unsigned int v162; // [sp+Ch] [bp-A4h]
  unsigned int v163; // [sp+10h] [bp-A0h]
  unsigned int v164; // [sp+14h] [bp-9Ch]
  unsigned int v165; // [sp+18h] [bp-98h]
  unsigned int v166; // [sp+1Ch] [bp-94h]
  int v167; // [sp+20h] [bp-90h]
  unsigned int v168; // [sp+24h] [bp-8Ch]
  int v169; // [sp+28h] [bp-88h]
  unsigned int v170; // [sp+2Ch] [bp-84h]
  unsigned int v171; // [sp+2Ch] [bp-84h]
  int v172; // [sp+2Ch] [bp-84h]
  unsigned int v173; // [sp+30h] [bp-80h]
  int v174; // [sp+34h] [bp-7Ch]
  int v176; // [sp+3Ch] [bp-74h]
  int v177; // [sp+40h] [bp-70h]
  unsigned int v178; // [sp+40h] [bp-70h]
  unsigned int v179; // [sp+40h] [bp-70h]
  unsigned int v180; // [sp+40h] [bp-70h]
  _BYTE *v181; // [sp+44h] [bp-6Ch]
  unsigned int v182; // [sp+48h] [bp-68h]
  int v183; // [sp+50h] [bp-60h]
  _DWORD *v184; // [sp+54h] [bp-5Ch]
  int v185; // [sp+58h] [bp-58h]
  int v186; // [sp+5Ch] [bp-54h]
  unsigned int v187; // [sp+60h] [bp-50h]
  int v188; // [sp+64h] [bp-4Ch]
  unsigned int v189; // [sp+68h] [bp-48h]
  unsigned int v190; // [sp+6Ch] [bp-44h]
  _DWORD *v191; // [sp+6Ch] [bp-44h]
  _BYTE *v192; // [sp+6Ch] [bp-44h]
  unsigned int v193; // [sp+6Ch] [bp-44h]
  _DWORD *v194; // [sp+70h] [bp-40h]
  unsigned int v195; // [sp+70h] [bp-40h]
  unsigned int v196; // [sp+70h] [bp-40h]
  _DWORD *v197; // [sp+70h] [bp-40h]
  unsigned int v198; // [sp+74h] [bp-3Ch]
  int v199; // [sp+74h] [bp-3Ch]
  unsigned int v200; // [sp+78h] [bp-38h]
  unsigned int v201; // [sp+78h] [bp-38h]
  int v202; // [sp+78h] [bp-38h]
  unsigned int v203; // [sp+7Ch] [bp-34h]
  unsigned int v204; // [sp+7Ch] [bp-34h]
  unsigned int v205; // [sp+7Ch] [bp-34h]
  unsigned int v206; // [sp+80h] [bp-30h]
  int v207; // [sp+80h] [bp-30h]
  _BYTE *v208; // [sp+80h] [bp-30h]
  unsigned int v209; // [sp+84h] [bp-2Ch]
  unsigned int v210; // [sp+84h] [bp-2Ch]
  _BYTE *v211; // [sp+88h] [bp-28h]
  unsigned int v212; // [sp+8Ch] [bp-24h]

  v2 = (_DWORD *)a1[7];
  v184 = v2 + 1776;
  v163 = v2[12];
  v168 = *a1 - 1 + a1[1] - 5;
  v174 = v2[10];
  v164 = v163 >> 2;
  v3 = a1[4];
  v4 = (_BYTE *)(a1[3] - 1);
  v5 = v3 - a2;
  v6 = &v4[v3 - 257];
  v7 = 4 * (v163 >> 2);
  v166 = v2[13];
  v173 = v166 - 1;
  v187 = v163 - v7;
  v167 = v7;
  v8 = v2[14];
  v188 = v166 - 1 + v7;
  v182 = v2[11];
  v9 = v2[15];
  v10 = 1 - (v163 >> 2);
  v11 = v2[19];
  if ( v163 >> 2 > 1 )
    v10 = 0;
  v12 = v2[20];
  v185 = v10;
  v176 = (1 << v2[22]) - 1;
  v169 = (1 << v2[21]) - 1;
  v13 = a1[7];
  v14 = *a1 - 1;
  v186 = v163 + v174;
  v189 = v166 + 4;
  v183 = a1[3] + v5;
  v181 = &v4[v5];
  v165 = (unsigned int)v6;
  while ( 1 )
  {
    if ( v9 <= 0xE )
    {
      v15 = *(unsigned __int8 *)(v14 + 1);
      v16 = v9 + 8;
      v17 = *(unsigned __int8 *)(v14 + 2);
      v14 += 2;
      v18 = v15 << v9;
      v9 += 16;
      v8 += v18 + (v17 << v16);
    }
    v19 = (unsigned __int8 *)(v11 + 4 * (v8 & v169));
    v20 = *v19;
    v21 = v19[1];
    v22 = *((unsigned __int16 *)v19 + 1);
    v9 -= v21;
    v8 >>= v21;
    if ( v20 )
      break;
LABEL_72:
    *++v4 = v22;
LABEL_73:
    v72 = (unsigned int)v4 >= v165;
    if ( (unsigned int)v4 < v165 )
      v72 = v14 >= v168;
    if ( v72 )
    {
      v157 = v14;
      v73 = (_DWORD *)v13;
      v74 = a1;
      goto LABEL_84;
    }
  }
  while ( 1 )
  {
    if ( (v20 & 0x10) != 0 )
    {
      v26 = v20 & 0xF;
      v27 = v22;
      if ( v26 )
      {
        v28 = v26 > v9;
        if ( v26 > v9 )
        {
          v29 = *(unsigned __int8 *)++v14;
          v27 = v29 << v9;
          v9 += 8;
        }
        v9 -= v26;
        if ( v28 )
          v8 += v27;
        v30 = v8 & ((1 << v26) - 1);
        v8 >>= v26;
        v27 = v22 + v30;
      }
      if ( v9 <= 0xE )
      {
        v83 = *(unsigned __int8 *)(v14 + 1);
        v84 = v9 + 8;
        v85 = *(unsigned __int8 *)(v14 + 2);
        v14 += 2;
        v86 = v83 << v9;
        v9 += 16;
        v8 += v86 + (v85 << v84);
      }
      v31 = (char *)(v12 + 4 * (v8 & v176));
      v32 = *v31;
      v33 = (unsigned __int8)v31[1];
      v9 -= v33;
      v8 >>= v33;
      v154 = *((unsigned __int16 *)v31 + 1);
      if ( (*v31 & 0x10) == 0 )
      {
        if ( (*v31 & 0x40) != 0 )
        {
LABEL_90:
          v157 = v14;
          v73 = (_DWORD *)v13;
          v74 = a1;
          a1[6] = (unsigned int)"invalid distance code";
          *v73 = 29;
          goto LABEL_84;
        }
        v34 = *((unsigned __int16 *)v31 + 1);
        while ( 1 )
        {
          v35 = (char *)(v12 + 4 * ((v8 & ((1 << v32) - 1)) + v34));
          v32 = *v35;
          v36 = (unsigned __int8)v35[1];
          v34 = *((unsigned __int16 *)v35 + 1);
          v9 -= v36;
          v8 >>= v36;
          if ( (*v35 & 0x10) != 0 )
            break;
          if ( (*v35 & 0x40) != 0 )
            goto LABEL_90;
        }
        v154 = *((unsigned __int16 *)v35 + 1);
      }
      v37 = v32 & 0xF;
      if ( v37 > v9 )
      {
        v38 = *(unsigned __int8 *)(v14 + 1);
        v39 = v9 + 8;
        v40 = v37 > v9 + 8;
        if ( v37 <= v9 + 8 )
          ++v14;
        v41 = v38 << v9;
        if ( v37 > v9 + 8 )
          v9 += 16;
        else
          v9 += 8;
        v8 += v41;
        if ( v40 )
        {
          v42 = *(unsigned __int8 *)(v14 + 2);
          v14 += 2;
          v8 += v42 << v39;
        }
      }
      v9 -= v37;
      v43 = v8 & ((1 << v37) - 1);
      v8 >>= v37;
      v44 = (_BYTE *)(v4 - v181);
      v158 = v43;
      v45 = v43 + v154;
      v156 = v45;
      if ( v45 <= v4 - v181 )
      {
        v87 = &v4[-v45];
        while ( 1 )
        {
          v88 = v87;
          v27 -= 3;
          v4[1] = v87[1];
          v4[2] = v87[2];
          v89 = v87[3];
          v87 += 3;
          v4[3] = v89;
          if ( v27 <= 2 )
            break;
          v4 += 3;
        }
        if ( v27 )
        {
          v4[4] = v88[4];
          if ( v27 == 2 )
          {
            v4[5] = v88[5];
            v4 += 5;
          }
          else
          {
            v4 += 4;
          }
        }
        else
        {
          v4 += 3;
        }
        goto LABEL_73;
      }
      v170 = v45 - (_DWORD)v44;
      if ( v182 < v45 - (unsigned int)v44 && *v184 )
      {
        v157 = v14;
        v73 = (_DWORD *)v13;
        v74 = a1;
        a1[6] = (unsigned int)"invalid distance too far back";
        *v73 = 29;
        goto LABEL_84;
      }
      if ( !v163 )
      {
        v46 = v166 - 1;
        v155 = (_BYTE *)(v174 - v170 + v173);
        if ( v27 <= v170 )
        {
LABEL_61:
          if ( v27 > 2 )
          {
            v70 = v155;
            do
            {
              v27 -= 3;
              v4[1] = v70[1];
              v4[2] = v70[2];
              v71 = v70[3];
              v70 += 3;
              v4[3] = v71;
              v4 += 3;
            }
            while ( v27 > 2 );
            v155 = v70;
          }
          if ( v27 )
          {
            if ( v27 == 2 )
              v46 = (unsigned int)v155;
            v4[1] = v155[1];
            if ( v27 == 2 )
            {
              v4[2] = *(_BYTE *)(v46 + 2);
              v4 += 2;
            }
            else
            {
              ++v4;
            }
          }
          goto LABEL_73;
        }
        v194 = v4 + 1;
        v190 = v170 >> 2;
        v47 = v166 + v174 - (v183 - (_DWORD)v4) - v154 - v158;
        v48 = v47 + 1;
        v200 = v47;
        v49 = v47 + 5;
        v27 -= v170;
        v159 = v48;
        v50 = v48 >= (unsigned int)(v4 + 5);
        if ( v48 < (unsigned int)(v4 + 5) )
          v50 = (unsigned int)(v4 + 1) >= v49;
        v51 = v50;
        v52 = v48 | (unsigned __int8)v194;
        v53 = v51;
        if ( v170 <= 3 )
          v53 = 0;
        if ( (v52 & 3) != 0 )
          v54 = 0;
        else
          v54 = v53 & 1;
        v55 = v54 ^ 1;
        v177 = 4 * v190;
        if ( !v190 )
          v55 |= 1u;
        if ( v55 )
        {
          v160 = v170;
          v67 = v4;
        }
        else
        {
          if ( v190 <= 8 )
          {
            v60 = 0;
          }
          else
          {
            v56 = v4 + 33;
            v57 = v200 + 33;
            v203 = v27;
            v58 = 0;
            v201 = v14;
            v206 = v13;
            do
            {
              v59 = *(_DWORD *)(v57 - 32);
              v28 = v190 - 7 > v58 + 9;
              v60 = v58 + 8;
              __pld((void *)(v57 + 84));
              v61 = v57;
              *((_DWORD *)v56 - 8) = v59;
              v62 = v56;
              v58 += 8;
              *((_DWORD *)v56 - 7) = *(_DWORD *)(v57 - 28);
              *((_DWORD *)v56 - 6) = *(_DWORD *)(v57 - 24);
              *((_DWORD *)v56 - 5) = *(_DWORD *)(v57 - 20);
              *((_DWORD *)v56 - 4) = *(_DWORD *)(v57 - 16);
              *((_DWORD *)v56 - 3) = *(_DWORD *)(v57 - 12);
              *((_DWORD *)v56 - 2) = *(_DWORD *)(v57 - 8);
              v63 = *(_DWORD *)(v57 - 4);
              v57 += 32;
              *((_DWORD *)v56 - 1) = v63;
              v56 += 32;
            }
            while ( v28 );
            v159 = v61;
            v194 = v62;
            v27 = v203;
            v13 = v206;
            v14 = v201;
          }
          v64 = v194;
          v65 = v159 - 4;
          do
          {
            v66 = *(_DWORD *)(v65 + 4);
            v65 += 4;
            ++v60;
            *v64++ = v66;
          }
          while ( v190 > v60 );
          v155 += v177;
          v160 = v170 - v177;
          v67 = &v4[v177];
          if ( v170 == v177 )
            goto LABEL_60;
        }
        v68 = v155;
        do
        {
          v69 = *++v68;
          *++v67 = v69;
        }
        while ( v68 != &v155[v160] );
LABEL_60:
        v46 = v170;
        v4 += v170;
        v155 = &v4[-v156];
        goto LABEL_61;
      }
      v90 = v45 - (_DWORD)v44;
      if ( v163 >= v170 )
      {
        v46 = v166 - 1;
        v155 = (_BYTE *)(v163 - v170 + v173);
        if ( v27 <= v170 )
          goto LABEL_61;
        v197 = v4 + 1;
        v180 = v170 >> 2;
        v133 = v166 + v163 - (v183 - (_DWORD)v4) - v154 - v158;
        v134 = v133 + 1;
        v204 = v133;
        v135 = v133 + 5;
        v27 -= v170;
        v193 = v134;
        v136 = v134 >= (unsigned int)(v4 + 5);
        if ( v134 < (unsigned int)(v4 + 5) )
          v136 = (unsigned int)(v4 + 1) >= v135;
        v137 = v136;
        v138 = v134 | (unsigned __int8)v197;
        v139 = v137;
        if ( v170 <= 3 )
          v139 = 0;
        if ( (v138 & 3) != 0 )
          v140 = 0;
        else
          v140 = v139 & 1;
        v199 = 4 * v180;
        v141 = v140 ^ 1;
        if ( !v180 )
          v141 |= 1u;
        if ( v141 )
        {
          v162 = v170;
          v151 = v4;
        }
        else
        {
          if ( v180 > 8 )
          {
            v142 = v4 + 33;
            v208 = v4;
            v143 = 0;
            v144 = v204 + 33;
            v205 = v14;
            do
            {
              v145 = *(_DWORD *)(v144 - 32);
              v146 = v143 + 9;
              v141 = v143 + 8;
              __pld((void *)(v144 + 84));
              v193 = v144;
              v143 += 8;
              *((_DWORD *)v142 - 8) = v145;
              v197 = v142;
              *((_DWORD *)v142 - 7) = *(_DWORD *)(v144 - 28);
              *((_DWORD *)v142 - 6) = *(_DWORD *)(v144 - 24);
              *((_DWORD *)v142 - 5) = *(_DWORD *)(v144 - 20);
              *((_DWORD *)v142 - 4) = *(_DWORD *)(v144 - 16);
              *((_DWORD *)v142 - 3) = *(_DWORD *)(v144 - 12);
              *((_DWORD *)v142 - 2) = *(_DWORD *)(v144 - 8);
              v147 = *(_DWORD *)(v144 - 4);
              v144 += 32;
              *((_DWORD *)v142 - 1) = v147;
              v142 += 32;
            }
            while ( v146 < v180 - 7 );
            v14 = v205;
            v4 = v208;
          }
          v148 = v193 - 4;
          v149 = v197;
          do
          {
            v150 = *(_DWORD *)(v148 + 4);
            v148 += 4;
            ++v141;
            *v149++ = v150;
          }
          while ( v180 > v141 );
          v155 += v199;
          v162 = v170 - v199;
          v151 = &v4[v199];
          if ( v170 == v199 )
            goto LABEL_60;
        }
        v152 = v155;
        do
        {
          v153 = *++v152;
          *++v151 = v153;
        }
        while ( v152 != &v155[v162] );
        goto LABEL_60;
      }
      v46 = v170 - v163;
      v171 = v46;
      v155 = (_BYTE *)(v186 - v90 + v173);
      if ( v27 <= v46 )
        goto LABEL_61;
      v191 = v4 + 1;
      v207 = v183 - (_DWORD)v4;
      v198 = v46 >> 2;
      v178 = v166 + v186 - (v183 - (_DWORD)v4) - v154 - v158;
      v27 -= v46;
      v195 = v178 + 1;
      v91 = v178 + 1 >= (unsigned int)(v4 + 5);
      if ( v178 + 1 < (unsigned int)(v4 + 5) )
        v91 = (unsigned int)(v4 + 1) >= v166 + v186 - (v183 - (_DWORD)v4) - v154 - v158 + 5;
      v92 = v91;
      v93 = v92;
      if ( v46 <= 3 )
        v93 = 0;
      if ( (((unsigned __int8)(v178 + 1) | (unsigned __int8)v191) & 3) != 0 )
        v94 = 0;
      else
        v94 = v93 & 1;
      v95 = v94 ^ 1;
      v202 = 4 * v198;
      if ( !v198 )
        v95 |= 1u;
      if ( v95 )
      {
        v109 = v4;
        v108 = v171;
      }
      else
      {
        if ( v198 <= 8 )
        {
          v179 = 0;
          v99 = v154;
        }
        else
        {
          v212 = v27;
          v96 = v4 + 33;
          v97 = 0;
          v209 = v14;
          v211 = v4;
          v98 = v178 + 33;
          v99 = v154;
          do
          {
            v100 = *(_DWORD *)(v98 - 32);
            v101 = v97 + 9;
            v102 = v97 + 8;
            __pld((void *)(v98 + 84));
            v195 = v98;
            v97 += 8;
            *((_DWORD *)v96 - 8) = v100;
            v191 = v96;
            *((_DWORD *)v96 - 7) = *(_DWORD *)(v98 - 28);
            *((_DWORD *)v96 - 6) = *(_DWORD *)(v98 - 24);
            *((_DWORD *)v96 - 5) = *(_DWORD *)(v98 - 20);
            *((_DWORD *)v96 - 4) = *(_DWORD *)(v98 - 16);
            *((_DWORD *)v96 - 3) = *(_DWORD *)(v98 - 12);
            *((_DWORD *)v96 - 2) = *(_DWORD *)(v98 - 8);
            v103 = *(_DWORD *)(v98 - 4);
            v98 += 32;
            *((_DWORD *)v96 - 1) = v103;
            v96 += 32;
          }
          while ( v198 - 7 > v101 );
          v179 = v102;
          v14 = v209;
          v27 = v212;
          v4 = v211;
        }
        v210 = v27;
        v104 = v195 - 4;
        v105 = v191;
        v106 = v179;
        do
        {
          v107 = *(_DWORD *)(v104 + 4);
          v104 += 4;
          ++v106;
          *v105++ = v107;
        }
        while ( v198 > v106 );
        v154 = v99;
        v108 = v171 - v202;
        v27 = v210;
        v155 += v202;
        v109 = &v4[v202];
        if ( v171 == v202 )
        {
LABEL_123:
          v46 = (unsigned int)&v4[v171];
          v192 = &v4[v171];
          if ( v163 >= v27 )
          {
            v4 += v171;
            v155 = (_BYTE *)(v166 - 1);
            goto LABEL_61;
          }
          v27 -= v163;
          v113 = &v4[v207 - v163 + v154 + v158];
          v114 = v113 + 1;
          v115 = (unsigned int)v113 >= v189;
          if ( (unsigned int)v113 < v189 )
            v115 = v166 >= (unsigned int)v114;
          v116 = v163;
          v117 = v115;
          if ( v163 <= 3 )
            v117 = 0;
          if ( (((unsigned __int8)v113 | (unsigned __int8)v166) & 3) != 0 )
            v118 = 0;
          else
            v118 = v117 & 1;
          v119 = v118 ^ 1 | v185;
          if ( v119 )
          {
            v130 = v166 - 1;
            v129 = v192;
          }
          else
          {
            if ( v164 <= 8 )
            {
              v125 = 0;
              v123 = v166;
            }
            else
            {
              v196 = v27;
              v120 = v113 + 8;
              v161 = v14;
              v121 = v166 + 32;
              v172 = v11;
              do
              {
                v122 = *(_DWORD *)(v121 - 32);
                v113 = v120;
                v123 = v121;
                v124 = v119 + 9;
                v125 = v119 + 8;
                __pld((void *)(v121 + 84));
                *(v120 - 8) = v122;
                v120 += 8;
                v126 = *(_DWORD *)(v121 - 28);
                v121 += 32;
                v119 += 8;
                *(v113 - 7) = v126;
                *(v113 - 6) = *(_DWORD *)(v123 - 24);
                *(v113 - 5) = *(_DWORD *)(v123 - 20);
                *(v113 - 4) = *(_DWORD *)(v123 - 16);
                *(v113 - 3) = *(_DWORD *)(v123 - 12);
                *(v113 - 2) = *(_DWORD *)(v123 - 8);
                *(v113 - 1) = *(_DWORD *)(v123 - 4);
              }
              while ( v164 - 7 > v124 );
              v14 = v161;
              v114 = v113 + 1;
              v27 = v196;
              v11 = v172;
            }
            v127 = v123 - 4;
            do
            {
              v128 = *(_DWORD *)(v127 + 4);
              v127 += 4;
              ++v125;
              *v113 = v128;
              v113 = v114++;
            }
            while ( v164 > v125 );
            v129 = &v192[v167];
            if ( v163 == v167 )
              goto LABEL_145;
            v130 = v188;
            v116 = v187;
          }
          v131 = v130 + v116;
          do
          {
            v132 = *(_BYTE *)++v130;
            *++v129 = v132;
          }
          while ( v130 != v131 );
LABEL_145:
          v46 = (unsigned int)v192;
          v4 = &v192[v163];
          v155 = &v192[v163 - v156];
          goto LABEL_61;
        }
      }
      v110 = v155;
      v111 = v109;
      do
      {
        v112 = *++v110;
        *++v111 = v112;
      }
      while ( v110 != &v155[v108] );
      goto LABEL_123;
    }
    v23 = (const char *)(v20 << 25);
    if ( (v20 & 0x40) != 0 )
      break;
    v24 = (unsigned __int8 *)(v11 + 4 * ((v8 & ((1 << v20) - 1)) + v22));
    v20 = *v24;
    v25 = v24[1];
    v22 = *((unsigned __int16 *)v24 + 1);
    v9 -= v25;
    v8 >>= v25;
    if ( !*v24 )
      goto LABEL_72;
  }
  v75 = v20 << 26;
  v157 = v14;
  if ( v75 >= 0 )
    v23 = "invalid literal/length code";
  v73 = (_DWORD *)v13;
  v74 = a1;
  if ( v75 >= 0 )
  {
    v76 = 29;
    a1[6] = (unsigned int)v23;
  }
  else
  {
    v76 = 11;
  }
  *v73 = v76;
LABEL_84:
  v77 = v9 - 8 * (v9 >> 3);
  v78 = v157 - (v9 >> 3);
  v79 = v4 + 1;
  v80 = v168 - v78;
  v74[3] = (unsigned int)(v4 + 1);
  v81 = v78 + 1;
  v74[1] = v80 + 5;
  result = ((1 << v77) - 1) & v8;
  *v74 = v81;
  if ( (unsigned int)v4 < v165 )
    v81 = v165 - (_DWORD)v4;
  else
    v79 = (_BYTE *)v165;
  if ( (unsigned int)v4 >= v165 )
    v81 = v79 - v4;
  v74[4] = v81 + 257;
  v73[14] = result;
  v73[15] = v77;
  return result;
}
// 42976: masking with 0x1 was optimized away because r1.1 <= 0x1
// 42C8E: masking with 0x1 was optimized away because r0.1 <= 0x1
// 42DFC: masking with 0x1 was optimized away because r3.1 <= 0x1
// 42F4E: masking with 0x1 was optimized away because r1.1 <= 0x1

//----- (0004332E) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_43370 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 43332: variable 'v2' is possibly undefined

//----- (000439AC) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00043A28) --------------------------------------------------------
__int64 __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // r0

  result = a1 / a2;
  *a3 = a1 - result * a2;
  return result;
}

//----- (00043A58) --------------------------------------------------------
unsigned __int64 __fastcall _gnu_uldivmod_helper(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  unsigned __int64 result; // r0

  result = a1 / a2;
  *a3 = a1 - result * a2;
  return result;
}

//----- (000440D0) --------------------------------------------------------
__int64 init()
{
  unsigned int v0; // r5
  int i; // r4
  __int64 (__fastcall *v2)(); // t1
  __int64 result; // r0

  init_proc();
  v0 = 0x5EFFCu;
  for ( i = 0; i != 1; ++i )
  {
    v2 = *(__int64 (__fastcall **)())(v0 + 4);
    v0 += 4;
    result = v2();
  }
  return result;
}

//----- (00044118) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1271 queued=906 decompiled=906 lumina nreq=0 worse=0 better=0
// ALL OK, 906 function(s) have been successfully decompiled
