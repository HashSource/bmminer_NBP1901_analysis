/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <fcntl.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>

//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_1047C();
// int printf(const char *format, ...);
// unsigned int sleep(unsigned int seconds);
// void perror(const char *s);
// int usleep(__useconds_t useconds);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int system(const char *command);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int munmap(void *addr, size_t len);
// void abort(void);
// int close(int fd);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_weak_fn();
int deregister_tm_clones();
int register_tm_clones();
int _do_global_dtors_aux();
int check_chain_num();
unsigned int get_iic(); // idb
int __fastcall set_iic(int a1);
uint8_t __cdecl zynq_set_iic(unsigned __int8 dev_addr, unsigned __int8 which_iic, bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 data);
int __fastcall write_pic_iic(char a1, unsigned __int8 a2);
int __fastcall read_pic_iic(char a1);
int __fastcall send_pic_cmd(char a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5);
int __fastcall dsPIC33EP16GS202_enable_pic_dc_dc(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall enable_pic_dac(unsigned __int8 a1);
int __fastcall disable_pic_dac(unsigned __int8 a1);
int get_fan_control();
int __fastcall set_fan_control(int a1);
int __fastcall set_PWM(unsigned __int8 a1);
int __cdecl main(int argc, const char **argv, const char **envp);
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

void *_frame_dummy_init_array_entry = (void *)0x105DD; // weak
char _bss_start; // weak
int chain_num; // weak
int axi_fpga_addr; // weak
_DWORD chain_list[16]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00010470) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (0001047C) --------------------------------------------------------
void sub_1047C()
{
  JUMPOUT(0);
}
// 10488: control flows out of bounds to 0

//----- (00010520) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    _libc_csu_fini,
    a1,
    va);
  abort();
}
// 1052A: positive sp value 4 has been found
// 1053C: variable 'v4' is possibly undefined

//----- (00010550) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 104D8: using guessed type int _gmon_start__(void);

//----- (00010574) --------------------------------------------------------
int deregister_tm_clones()
{
  return 135240;
}

//----- (00010598) --------------------------------------------------------
int register_tm_clones()
{
  return 135240;
}

//----- (000105C4) --------------------------------------------------------
int _do_global_dtors_aux()
{
  int result; // r0

  if ( !_bss_start )
  {
    result = deregister_tm_clones();
    _bss_start = 1;
  }
  return result;
}
// 21048: using guessed type char _bss_start;

//----- (000105E0) --------------------------------------------------------
int check_chain_num()
{
  int v2; // [sp+4h] [bp+4h]
  int v3; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v3 = 0;
  v2 = *(_DWORD *)(axi_fpga_addr + 8);
  if ( v2 < 0 )
    return 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( ((v2 >> i) & 1) != 0 )
    {
      chain_list[i] = 1;
      printf("chain[%d] ", i);
      ++v3;
    }
    else
    {
      chain_list[i] = 0;
    }
  }
  printf("found, %d chain total\n", v3);
  return v3;
}
// 21050: using guessed type int axi_fpga_addr;
// 21054: using guessed type _DWORD chain_list[16];

//----- (0001067A) --------------------------------------------------------
unsigned int get_iic()
{
  return *(_DWORD *)(axi_fpga_addr + 48);
}
// 21050: using guessed type int axi_fpga_addr;

//----- (000106A4) --------------------------------------------------------
int __fastcall set_iic(int a1)
{
  int v2; // r3
  int iic; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]

  v5 = 0;
  *(_DWORD *)(axi_fpga_addr + 48) = a1 & 0x3FFFFFFF;
  while ( 1 )
  {
    iic = get_iic();
    if ( iic < 0 )
      return (unsigned __int8)iic;
    v2 = v5++;
    if ( v2 > 100 )
      break;
    usleep(0x1388u);
  }
  printf("could not get iic, ret = 0x%08x\n", iic);
  return 0;
}
// 21050: using guessed type int axi_fpga_addr;

//----- (0001070E) --------------------------------------------------------
uint8_t __cdecl zynq_set_iic(
        unsigned __int8 dev_addr,
        unsigned __int8 which_iic,
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 data)
{
  int v7; // [sp+Ch] [bp+Ch]

  v7 = 0;
  if ( read )
    v7 = 0x2000000;
  if ( reg_addr_valid )
    v7 |= (reg_addr << 8) | 0x1000000;
  return set_iic(data | (dev_addr << 16) & 0x70000 | (dev_addr >> 3 << 20) & 0xF00000 | (which_iic << 26) & 0xC000000 | v7);
}

//----- (000107A2) --------------------------------------------------------
int __fastcall write_pic_iic(char a1, unsigned __int8 a2)
{
  char v3; // [sp+Fh] [bp+7h]

  v3 = a1;
  if ( a1 == 1 )
  {
    v3 = 2;
  }
  else if ( a1 == 2 )
  {
    v3 = 1;
  }
  return zynq_set_iic(v3 & 7 | 0x20, 0, 0, 0, 0, a2);
}

//----- (0001080A) --------------------------------------------------------
int __fastcall read_pic_iic(char a1)
{
  char v2; // [sp+Fh] [bp+7h]

  v2 = a1;
  if ( a1 == 1 )
  {
    v2 = 2;
  }
  else if ( a1 == 2 )
  {
    v2 = 1;
  }
  return zynq_set_iic(v2 & 7 | 0x20, 0, 1, 0, 0, 0);
}

//----- (0001086C) --------------------------------------------------------
int __fastcall send_pic_cmd(char a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5)
{
  int result; // r0
  __int16 v10; // [sp+12h] [bp+12h]
  int i; // [sp+14h] [bp+14h]
  int j; // [sp+14h] [bp+14h]
  int k; // [sp+14h] [bp+14h]

  v10 = a3 + 3;
  for ( i = 0; i < a3; ++i )
    v10 += *(unsigned __int8 *)(i + a2);
  write_pic_iic(a1, 0x55u);
  write_pic_iic(a1, 0xAAu);
  write_pic_iic(a1, a3 + 3);
  for ( j = 0; j < a3; ++j )
    write_pic_iic(a1, *(_BYTE *)(j + a2));
  write_pic_iic(a1, HIBYTE(v10));
  write_pic_iic(a1, v10);
  result = usleep(0x86470u);
  for ( k = 0; k < a5; ++k )
  {
    result = read_pic_iic(a1);
    *(_BYTE *)(a4 + k) = result;
  }
  return result;
}

//----- (00010972) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_enable_pic_dc_dc(unsigned __int8 a1, unsigned __int8 a2)
{
  char v6[4]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 v7; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 v8; // [sp+19h] [bp+11h]
  int v9; // [sp+1Ch] [bp+14h]

  v9 = 0;
  v6[0] = 21;
  v6[1] = a2;
  while ( 1 )
  {
    ++v9;
    send_pic_cmd(a1, (int)v6, 2u, (int)&v7, 2u);
    if ( v7 == 21 && v8 == 1 )
    {
      printf("set chain[%d] dc power to [%d] ok!\n", a1, a2);
      return 0;
    }
    if ( v9 > 2 )
      break;
    sleep(1u);
  }
  printf("ERROR! failed on chain[%d] after %d times try!\n", a1, v9);
  printf("DEBUG! 0x%08x, 0x%08x\n", v7, v8);
  return -1;
}

//----- (00010A0E) --------------------------------------------------------
int __fastcall enable_pic_dac(unsigned __int8 a1)
{
  return dsPIC33EP16GS202_enable_pic_dc_dc(a1, 1u);
}

//----- (00010A2A) --------------------------------------------------------
int __fastcall disable_pic_dac(unsigned __int8 a1)
{
  return dsPIC33EP16GS202_enable_pic_dc_dc(a1, 0);
}

//----- (00010A46) --------------------------------------------------------
int get_fan_control()
{
  return *(_DWORD *)(axi_fpga_addr + 132);
}
// 21050: using guessed type int axi_fpga_addr;

//----- (00010A70) --------------------------------------------------------
int __fastcall set_fan_control(int a1)
{
  *(_DWORD *)(axi_fpga_addr + 132) = a1;
  return get_fan_control();
}
// 21050: using guessed type int axi_fpga_addr;

//----- (00010A94) --------------------------------------------------------
int __fastcall set_PWM(unsigned __int8 a1)
{
  return set_fan_control((unsigned __int16)((__int16)(50 * (100 - a1)) / 100) | ((unsigned __int16)((__int16)(50 * a1)
                                                                                                  / 100) << 16));
}
// 10A70: using guessed type int __fastcall set_fan_control(_DWORD);

//----- (00010B02) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int fd; // [sp+10h] [bp+8h]
  unsigned __int8 i; // [sp+17h] [bp+Fh]

  fd = open("/dev/axi_fpga_dev", 2, envp);
  if ( fd >= 0 )
  {
    axi_fpga_addr = (int)mmap(0, 0x160u, 3, 1, fd, 0);
    if ( axi_fpga_addr )
    {
      system("killall cgminer");
      chain_num = check_chain_num();
      for ( i = 0; i < chain_num; ++i )
      {
        if ( chain_list[i] )
          disable_pic_dac(i);
      }
      set_PWM(0x64u);
      munmap((void *)axi_fpga_addr, 0x160u);
      close(fd);
      return 0;
    }
    else
    {
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%lsx\n", (const wchar_t *)axi_fpga_addr);
      return -1;
    }
  }
  else
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", fd);
    perror("open");
    return -1;
  }
}
// 2104C: using guessed type int chain_num;
// 21050: using guessed type int axi_fpga_addr;
// 21054: using guessed type _DWORD chain_list[16];

//----- (00010C10) --------------------------------------------------------
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp)
{
  void **v6; // r5
  int i; // r4
  void (__fastcall *v8)(int, unsigned __int8 **, unsigned __int8 **); // t1

  init_proc();
  v6 = &_frame_dummy_init_array_entry;
  for ( i = 0; i != 1; ++i )
  {
    v8 = (void (__fastcall *)(int, unsigned __int8 **, unsigned __int8 **))*v6++;
    v8(argc, argv, envp);
  }
}
// 102D4: using guessed type Elf32_Sym;
// 20F08: using guessed type void *_frame_dummy_init_array_entry;

//----- (00010C50) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=49 queued=23 decompiled=23 lumina nreq=0 worse=0 better=0
// ALL OK, 23 function(s) have been successfully decompiled
