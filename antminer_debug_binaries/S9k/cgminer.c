/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>
#include <pthread.h>
#include <stdint.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_11F14();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// FILE *fdopen(int fd, const char *modes);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int sem_wait(sem_t *sem);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int sem_post(sem_t *sem);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strcspn(const char *s, const char *reject);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int inet_pton(int af, const char *cp, void *buf);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int tolower(int c);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int setlogmask(int mask);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int memcmp(const void *s1, const void *s2, size_t n);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// char *ctime(const time_t *timer);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// char *strdup(const char *s);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// uint16_t htons(uint16_t hostshort);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int sysconf(int name);
// int dup2(int fd, int fd2);
// void *realloc(void *ptr, size_t size);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int sigaction_0(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// double floor(double x);
// int __fastcall strtof(_DWORD, _DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo_0(struct sysinfo *info);
// void *malloc(size_t size);
// double log10(double x);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// struct tm *localtime(const time_t *timer);
// char *dirname(char *path);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// int kill(__pid_t pid, int sig);
// uint32_t ntohl(uint32_t netlong);
// const unsigned __int16 **_ctype_b_loc(void);
// void exit(int status);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// size_t strlen(const char *s);
// int __fastcall round(_DWORD, _DWORD); weak
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int atol(const char *nptr);
// int nice(int inc);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int putchar(int c);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// int fileno(FILE *stream);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int access(const char *name, int type);
// int fclose(FILE *stream);
// int pipe(int pipedes[2]);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int shutdown(int fd, int how);
// int sigemptyset(sigset_t *set);
// FILE *popen(const char *command, const char *modes);
// __pid_t fork(void);
// void errx(int status, const char *format, ...);
// uint32_t htonl(uint32_t hostlong);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int execl(const char *path, const char *arg, ...);
// int toupper(int c);
// int listen(int fd, int n);
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int fputc(int c, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
// int sscanf(const char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// int __fastcall roundf(_DWORD, _DWORD); weak
// void openlog(const char *ident, int option, int facility);
// double exp(double x);
// int remove(const char *filename);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// double atof(const char *nptr);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// char *strncat(char *dest, const char *src, size_t n);
// int sem_destroy(sem_t *sem);
// int isatty(int fd);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int pclose(FILE *stream);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_weak_fn();
void *deregister_tm_clones();
__int64 register_tm_clones();
void *_do_global_dtors_aux();
int __cdecl get_index_from_pll_B1393(int pll);
void __cdecl get_plldata_from_index(int index, uint8_t *vil_pll);
int __cdecl get_pllparam_divider(float freq, uint32_t *pll_param, uint8_t *divider, float *pll_freq);
int is_T11();
int is_T11a();
int is_T11b();
int is_special_mode();
void __cdecl chain_inactive(unsigned __int8 chain);
void __cdecl set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address);
int __cdecl calculate_core_number(unsigned int actual_core_number);
void __cdecl set_core_number_BM1390(unsigned __int8 which_chain, unsigned __int8 chip_addr);
void __cdecl set_addr_one_chain(const uint8_t chain);
void init_address_info(); // idb
void __cdecl enable_core_clock_BM1393(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 chain);
void __cdecl set_core_cmd_BM1393(core_cmd *core);
void __cdecl set_config_BM1393_t(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 mode, unsigned __int8 reg, unsigned int reg_data);
void __cdecl set_config_BM1393(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 mode, unsigned __int8 reg, unsigned int reg_data);
void __cdecl read_asic_register(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 chip_addr, unsigned __int8 reg_addr);
void __cdecl read_temp(unsigned __int8 device, unsigned int reg, unsigned __int8 data, unsigned __int8 write, unsigned __int8 chip_addr, int chain);
void __cdecl set_baud_one_chain(unsigned __int8 bauddiv, int change_fpga_baud, const uint8_t chain);
void __cdecl set_baud(unsigned __int8 bauddiv, int no_use);
void __cdecl set_baud_by_chain(unsigned __int8 bauddiv, int chain);
void set_working_uart_baud(); // idb
void set_default_uart_baud(); // idb
void __cdecl set_asic_ticket_mask(unsigned int ticket_mask);
void __cdecl set_misc_control(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 addr, int i2c);
unsigned int __cdecl check_asic_reg_with_addr(unsigned int reg, unsigned __int8 chip_addr, unsigned int chain, int check_num);
unsigned int __cdecl wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update);
unsigned int __cdecl check_reg_temp(unsigned __int8 device, unsigned int reg, unsigned __int8 data, unsigned __int8 write, unsigned __int8 chip_addr, int chain);
int8_t __cdecl calc_offset_simple(int remote, int local);
int16_t __cdecl get_remote(int16_t remote);
int16_t __cdecl get_local(int16_t local);
void __cdecl do_calibration_sensor_offset_by_eeprom(unsigned __int8 device, unsigned __int8 chip_addr, int chain, int temp_chip_index);
int8_t __cdecl do_calibration_sensor_offset(unsigned __int8 device, unsigned __int8 chip_addr, int chain, int temp_chip_index);
bool __cdecl is_tempsensor_data_correct(temp_info_t temp_info);
void __cdecl get_temp_info_from_eeprom_by_chain(uint32_t chain);
bool __cdecl is_eeprom_tempsensor_data_correct(uint8_t chain);
int8_t __cdecl re_calibrate_sensor_offset(unsigned __int8 device, int chain);
void __cdecl check_eeprom_calibration_data(int chain);
int8_t __cdecl calibration_sensor_offset(unsigned __int8 device, int chain);
void read_temp_and_get_statistics(); // idb
void set_pwm_by_temp(); // idb
bool __cdecl disable_hash_board(STATUS_CODE status_value);
void __cdecl check_status_value(bool fatal_flag);
bool process_status_value(); // idb
void __cdecl read_temp_func_clean_up(void *arg);
void __cdecl set_iic_for_temperature_by_chain(int chain);
void set_iic_for_temperature(); // idb
int __cdecl temp_get_local_temp(float *p_temp);
void get_env_temperature();
void __noreturn read_temp_func();
void __cdecl set_PWM(unsigned __int8 pwm_percent);
int __cdecl get_target_chip_temp_t11a(bool is_low_temp_env, int min_entrance_pcb_temp);
int __cdecl get_target_chip_temp_t11(bool is_low_temp_env, int min_entrance_pcb_temp);
int __cdecl get_target_chip_temp(int min_entrance_pcb_temp);
int set_pwm_by_pid_method(); // idb
int __cdecl set_PWM_according_to_temperature(int avg_temp);
STATUS_CODE get_error_type(); // idb
bool is_in_error(); // idb
void __cdecl set_status(STATUS_CODE err);
void detect_environment_temperature(); // idb
void get_env_temperature();
void store_max_min_temperature(); // idb
int get_max_temperature(); // idb
int get_min_temperature(); // idb
int get_max_chip_temperature(); // idb
int get_min_chip_temperature(); // idb
unsigned int __cdecl _bswap_32(unsigned int __bsx);
__uint64_t __cdecl _uint64_identity(__uint64_t __x);
uint32_t __cdecl swab32(uint32_t v);
void __cdecl flip32(void *dest_p, const void *src_p);
void __cdecl mutex_lock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length);
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len);
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len);
void __noreturn get_hash_rate();
int eeprom_date_check(); // idb
void slowly_set_iic_power_to_working_voltage(); // idb
int set_iic_power_to_highest_voltage(); // idb
void __cdecl set_working_voltage(double volt);
int check_chain(); // idb
int check_hashboard_hardware_info(); // idb
int check_fan(); // idb
int __cdecl get_index_from_high_pll(int freq);
int GetTotalRate(); // idb
unsigned int do_get_ideal_max_hash_rate();
int get_ideal_hash_rate_max(); // idb
int __cdecl fix_hash_rate(int hashrateGH);
int get_fixed_total_hash_rate(); // idb
int get_eeprom_total_hash_rate(); // idb
void get_ideal_hash_rate(); // idb
int __cdecl ConvirtTotalRate(int totalRate);
void clear_register_value_buf(); // idb
void __cdecl suffix_string_soc(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display);
bool __cdecl check_asic_reg_oneChain(int chainIndex, unsigned int reg, bool core_response);
void __cdecl led_on(const unsigned __int8 *led);
void __cdecl led_off(const unsigned __int8 *led);
void __cdecl led_blink(const unsigned __int8 *led);
void set_led(); // idb
void *__cdecl pic_heart_beat_func(void *arg);
int __cdecl get_asic_nonce_num(int chain, int asic, int timeslice);
void __cdecl get_lastn_nonce_num(unsigned __int8 *dest, int n);
void __cdecl saveTestID(int testID);
void clear_test_ID(); // idb
int __cdecl read_test_ID(uint32_t *testID, uint32_t *data);
void process_test(); // idb
uint32_t __cdecl get_domain_nounce_number(uint32_t chain, uint32_t domain);
void dump_nonce_info_all_domain(); // idb
void __cdecl get_imbalance_domain_count(unsigned __int8 *infoStr);
void __cdecl get_domain_nonce_data(uint32_t *buf, uint32_t *len);
void save_base_domain_nonce_data(); // idb
void aging_get_finish_avg_hashrate();
uint32_t aging_get_last_stable_time();
void aging_save_info(); // idb
void aging_get_info(); // idb
void aging_start(); // idb
void aging_stop(); // idb
uint32_t aging_get_total_inbalance_times();
int aging_get_sweep_temp(); // idb
void __cdecl aging_update_time(int aging_time_increase);
uint32_t aging_get_time();
bool aging_is_ongoing(); // idb
bool aging_is_bad_machine(); // idb
void __cdecl aging_get_update_hashrate_info(unsigned __int8 *infoStr);
void __cdecl getAginginfo(unsigned __int8 *infoStr);
int *get_hw_errors();
void low_temp_process_parm_init(); // idb
int get_reopen_pwm(); // idb
void switch_to_mode0(); // idb
void check_asic_status(); // idb
void __cdecl volt_decrease_for_mode0(double lower_limit_volt, double delta_volt, bool *increased_flag);
void __cdecl volt_increase_for_mode0(double upper_limit_volt, double delta_volt, bool *increased_flag, bool *outer_reopen_flag);
void reopen_once(); // idb
void __cdecl hash_rate_guard(bool enable, float env_temp, double real_rate, bool high_chip_temp_flag);
void __cdecl decrease_voltage_at_high_temp(bool *high_chip_temp_flag);
void __noreturn check_system_work();
void __cdecl pre_open_core_one_chain(uint8_t num, const uint8_t chain);
bool __cdecl check_asic_num_without_power_off(int chain, unsigned __int8 set);
bool __cdecl check_asic_num_by_pre_open_core(int chain);
int __cdecl check_asic_num(int chain);
void __cdecl open_core_BM1393_pre_open(int chain, unsigned __int8 num, unsigned __int8 set);
void __cdecl set_clock_delay_control(const uint8_t chain, uint8_t pulse_mode);
void __cdecl open_core_bm1393(bool set, uint8_t chain_mode);
int __cdecl check_hw(SCAN_FREQ_WORK *work, unsigned int nonce, bool print);
void __cdecl nonce_calc(int chain, unsigned int buf);
void __noreturn get_nonce_and_register();
void dump_nonce_info_all_asic(); // idb
void set_unused_pll(); // idb
int __cdecl change_high_pll_test(uint8_t chain, float freq, int index);
void __cdecl change_high_pll_by_aisc(uint32_t chain, uint32_t asic, float freq, int index);
void __cdecl set_pll(float pll_value);
int __cdecl set_freq_by_chain(float freq, int chain);
void __cdecl set_pll_adjust(float low_freq, float final_freq);
float __cdecl screen_freq_from_array(float *array, bool is_high_freq);
void __cdecl increase_freq_slowly(float init_freq, float final_freq, float freq_step, uint8_t chain);
void __cdecl increase_freq_slowly_by_index(float init_freq, float low_freq, float high_freq);
unsigned __int8 __cdecl c2hex(unsigned __int8 value);
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __cdecl s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen);
void get_working_voltage_from_eeprom(); // idb
int init_pic(); // idb
void __cdecl set_timeout(int final_freq, int percent);
void __fastcall set_target_freq(int a1, float a2, float a3);
void set_adjust_freq();
void __cdecl scan_freq_set_freq_by_chip(uint8_t chain, uint8_t chip_addr, float freq);
int __cdecl get_physical_chip_no(int logical_row, int logical_col);
int __cdecl get_logical_column_by_chip_no(int chip);
float get_max_freq(); // idb
uint16_t __cdecl increase_freq_by_eeprom_slowly(int init_freq, int freq_step);
uint16_t __cdecl increase_freq_by_eeprom_slowly_new(int init_freq, int freq_step);
bool is_env_temperature_high(); // idb
void low_temperature_freq_handler(); // idb
bool is_fixed_mode(); // idb
bool is_force_mode(); // idb
bool is_user_mode(); // idb
bool is_economic_mode(); // idb
void init_working_voltage(); // idb
void update_highest_voltage(); // idb
void init_read_temp_thread_in_force(); // idb
void shutdown_read_temp_thread_in_force(); // idb
int get_current_total_rate(); // idb
void print_chip_freq(); // idb
void fix_chip_freq(); // idb
void get_freq_result_from_eeprom(); // idb
bool read_freq_result(); // idb
void __cdecl get_freq_result(int default_freq);
void show_mode(); // idb
void __cdecl set_freq_default(int default_freq);
void init_sweep_config(); // idb
int __fastcall sub_27310(int a1);
int __fastcall sub_27318(int a1, int a2, int a3, int a4);
int __fastcall sub_27320(int a1, int a2, int a3, int a4);
int __fastcall sub_27328(int a1, int a2);
int sub_27330();
void init_miner_version(); // idb
void __cdecl power_on_chain(int chain);
void __cdecl hash_board_reset(int chain);
int __cdecl bring_up_chain(int chain, bool poweron);
int bring_up_all_chain(); // idb
int check_pool_worker(); // idb
int check_pool_for_validation(); // idb
int check_fan_num(); // idb
void init_pulse_mode(); // idb
bool need_mode2_startup(); // idb
int __cdecl bitmain_soc_init(init_config config);
int __cdecl re_open_core(int fan_pwm);
int __cdecl re_open_core_by_chain(int fan_pwm, int chain, bool is_low_temp);
bool is_re_open_core_now(); // idb
int __cdecl parse_job_to_soc(unsigned __int8 **buf, pool *pool, uint32_t id);
int __cdecl send_job(unsigned __int8 *buf, pool *pool);
void re_send_last_job(); // idb
void __cdecl copy_pool_stratum(pool *pool_stratum, pool *pool);
bool __cdecl bitmain_soc_prepare(thr_info *thr);
void __cdecl bitmain_soc_reinit_device(cgpu_info *bitmain);
void __cdecl bitmain_soc_detect(bool hotplug);
uint64_t __cdecl hashtest_submit(thr_info *thr, work *work, uint32_t nonce, uint8_t *midstate, pool *pool, uint64_t nonce2, uint32_t chain_id);
void *__cdecl bitmain_scanhash(void *arg);
int64_t __cdecl bitmain_soc_scanhash(thr_info *thr);
void __cdecl bitmain_soc_update(cgpu_info *bitmain_soc);
void __cdecl get_bitmain_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *bitmain_soc);
void __cdecl restore_syslog_file(LOG_FILE_BACKUP *backlog);
void __cdecl backup_syslog_file(LOG_FILE_BACKUP *backlog);
void __cdecl set_privite_log_file(unsigned __int8 *logfile_name, LOG_FILE_BACKUP *backlog);
void __cdecl getMinerInfo(unsigned __int8 *infoStr);
void __cdecl getReopenInfo(unsigned __int8 *infoStr);
void __cdecl getAgingInbalanceTimes(unsigned __int8 *infoStr);
void __cdecl get_reopen_time_record_info(unsigned __int8 *infoStr);
void __cdecl getDiffFreqInfo(unsigned __int8 *infoStr);
void __cdecl get_avg_freq_info(unsigned __int8 *infoStr);
void __cdecl increase_to_base_freq(float init_freq, float freq_step);
bool is_column_sweep(); // idb
bool is_board_sweep(); // idb
void __cdecl scan_freq_init_highest_voltage(working_mode_e working_mode);
int __cdecl scan_freq_board_init(working_mode_e working_mode);
int __cdecl scan_freq_board_fast_init(working_mode_e working_mode);
api_data *__cdecl bitmain_api_stats(cgpu_info *cgpu);
void __cdecl bitmain_soc_shutdown(thr_info *thr);
void __cdecl freq_scan_error_code_set(int err_code, int chain);
int freq_scan_get_sale_hash_rate(); // idb
void freq_scan_set_state(); // idb
void __cdecl scanfreq_nonce_calc(int chain, unsigned int buf);
int __cdecl scan_freq_get_work_of_core_one_file(int which_asic, int which_core, FILE **stream, int count);
int scanfreq_get_works(); // idb
void __cdecl Nonce_Match_1(int chain, unsigned int buf, unsigned int which_pattern);
void *__cdecl scanfreq_receive_nonce_register(void *arg);
void scan_freq_init_info(); // idb
int scan_freq_get_min_base_freq(); // idb
int scan_freq_prepare(); // idb
void __cdecl san_freq_clear_nonce_return_back_flag(int chain);
void scan_freq_reset_result(); // idb
void scan_freq_send_work(); // idb
bool __cdecl scan_freq_check_result(int chain);
void scan_freq_send_work_and_check_result(); // idb
void __cdecl scan_freq_print_nonce_zero_chip(int chain);
void scan_freq_print_noncerate_badchips(); // idb
void __cdecl scan_freq_print_inbalance_region(int freq_scan_times);
void __cdecl scan_freq_print_inbalance_region_by_chain(int chain, int freq_scan_times);
void __cdecl adjust_freq_by_chain(int chain, int freq_scan_times, working_mode_e working_mode);
uint32_t __cdecl get_vol_region_nonce_number(uint32_t chain, uint32_t vol_region);
void __cdecl print_calculation_ability(int freq_scan_times);
void __cdecl choose_best_freq_array(int freq_scan_times);
void print_freq_adjust_index(); // idb
void __cdecl adjust_freq_according_result(int freq_scan_times, working_mode_e working_mode);
bool scan_freq_is_all_chain_finished(); // idb
void force_scan_freq_is_all_chain_finished(); // idb
void __cdecl force_scan_freq_is_finished_by_chain(int chain);
void __cdecl scan_freq_save_result_with_new_format(working_mode_e working_mode);
void __cdecl scan_freq_save_more_result(working_mode_e working_mode);
void scan_freq_done_mark(); // idb
int scan_freq_already_done();
void scan_freq_prepare_log(); // idb
void __cdecl init_freq_adjust_index(int base_freq);
void __cdecl scan_freq_get_next_base_freq(working_mode_e *working_mode);
void __cdecl scan_freq_find_base_freq(working_mode_e working_mode);
void scan_freq_reset_scan_info(); // idb
void scan_freq_reset_scan_mark(); // idb
void scan_freq_start(); // idb
void scan_freq_mark_success(); // idb
void scan_freq_scan_by_column(); // idb
void scan_freq_stop_hash_board(); // idb
void __cdecl stop_scan(int error_num, uint8_t chain);
float __cdecl get_max_scanfreq(bool is_economic_mode);
void sweep_freq_print_current_column(); // idb
bool __cdecl sweep_freq_all_chip_failed(int chain, int column);
void __cdecl sweep_freq_get_next_freq(working_mode_e working_mode);
void __cdecl sweep_freq_set_column_freq_from_minfreq(int chain, int column);
void sweep_freq_set_next_freq_from_minfreq(); // idb
void __cdecl sweep_freq_set_column_freq_directly(int chain, int column);
void sweep_freq_set_next_freq_directly(); // idb
void sweep_freq_send_work_and_check_result(); // idb
void sweep_freq_print_chip_max_freq(); // idb
void __cdecl sweep_freq_set_base_freq(working_mode_e working_mode);
int __cdecl sweep_freq_get_chip_max_freq(working_mode_e working_mode);
void __cdecl sweep_freq_sort_array(int row, int *src, int *rate, unsigned int len);
int __cdecl sweep_freq_get_rate_min_freq(int chain, int rate);
void __cdecl sweep_freq_set_rate_freq(int chain, int rate, int freq);
void sweep_freq_balance_domain_freq(); // idb
void __cdecl sweep_freq_save_result(working_mode_e working_mode);
void __cdecl sweep_freq_decrease_freq(working_mode_e working_mode);
int __cdecl sweep_freq_get_ideal_hashrate(working_mode_e working_mode);
void sweep_update_ideal_hash_rate(); // idb
int sweep_get_current_ideal_hash_rate(); // idb
void sweep_fix_ideal_rate(); // idb
void __cdecl sweep_set_current_chain(int chain_count);
void asic_sweep_stat_start(); // idb
void __cdecl asic_sweep_stat(int chain, int chip, int level, bool failed);
void __cdecl get_asic_sweep_stat(unsigned __int8 *infoStr);
int asic_sweep_stat_end(); // idb
int __cdecl sweep_freq_for_mode(working_mode_e working_mode);
int sweep_freq_by_column(); // idb
bool is_scan_freq_trigged_and_succeeded(); // idb
void boardsweep_print_bad_cores(); // idb
void boardsweep_send_work_and_check_result(); // idb
void __cdecl boardsweep_get_next_freq(working_mode_e working_mode);
int __cdecl boardsweep_get_chip_max_freq(working_mode_e working_mode);
void __cdecl boardsweep_get_ideal_hashrate(working_mode_e working_mode);
int __cdecl boardsweep_start(working_mode_e working_mode);
int boardsweep_task(); // idb
void __cdecl stop_mining(const unsigned __int8 *str);
void power_on(); // idb
void power_check_protocal_type(); // idb
void power_init(); // idb
void __cdecl set_working_voltage(double working_voltage);
void __cdecl set_working_voltage_by_chain(uint8_t chain, double working_voltage);
void __cdecl set_higher_voltage_by_chain(uint8_t chain, double higher_voltage);
void __cdecl set_highest_voltage_by_chain(uint8_t chain, double highest_voltage);
void get_working_voltage();
double __cdecl get_working_voltage_by_chain(uint8_t chain);
void get_current_voltage();
double __cdecl get_current_voltage_by_chain(uint8_t chain);
void get_higher_voltage();
double __cdecl get_higher_voltage_by_chain(uint8_t chain);
bool power_is_support_cmd_package(); // idb
bool __cdecl power_check_reply(uint8_t *cmd, uint8_t *reply_buf, uint8_t reply_len);
bool __cdecl power_send_cmd(uint8_t *cmd, uint8_t len, uint8_t *reply_buf, uint8_t reply_len);
void __cdecl power_set_da_value(uint8_t da_value);
uint8_t __cdecl power_set_da_value_simple(uint8_t data);
uint8_t __cdecl power_set_voltage(power_info_t *power, uint8_t da_value);
uint8_t __cdecl get_power_iic_value_from_voltage(double voltage);
double __cdecl get_power_voltage_from_iic_value(uint8_t data);
bool __cdecl set_iic_power_by_voltage(double target_vol, power_info_t *power);
bool __cdecl set_iic_power_by_iic_data(uint8_t target_data, power_info_t *power);
int __fastcall set_iic_power_to_highest_voltage(double a1, power_info_t *a2);
bool __cdecl set_iic_power_to_highest_voltage_by_chain(int8_t chain);
bool __cdecl slowly_adapt_voltage(power_info_t *power, double target_vol, uint32_t ms_delay);
bool __cdecl slowly_set_iic_power_to_custom_voltage(double custom_voltage);
bool __cdecl slowly_set_iic_power_to_custom_voltage_by_chain(uint8_t chain, double custom_voltage);
int slowly_set_iic_power_to_working_voltage();
bool __cdecl slowly_set_iic_power_to_working_voltage_by_chain(uint8_t chain);
bool __cdecl slowly_set_iic_power_to_higher_voltage_by_chain(uint8_t chain);
void get_average_voltage();
void __cdecl calc_power_iic_data_by_chain(power_info_t *power, double target_vol);
void __cdecl slowly_set_iic_power_voltage_t11(int voltage_flag);
void __cdecl slowly_set_working_power_t11(const uint8_t chain);
__uint32_t __cdecl _uint32_identity(__uint32_t __x);
void __cdecl json_decref(json_t_0 *json);
void __cdecl _list_add(list_head *new, list_head *prev, list_head *next);
void __cdecl list_add_tail(list_head *new, list_head *head);
void __cdecl _list_del(list_head *prev, list_head *next);
void __cdecl list_del(list_head *entry);
int __cdecl list_empty(list_head *head);
int sock_blocks();
bool sock_timeout(); // idb
bool interrupted(); // idb
void __cdecl align_len(size_t *len);
uint32_t __cdecl swab32_0(uint32_t v);
void __cdecl swab256(void *dest_p, const void *src_p);
void __cdecl mutex_lock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl mutex_trylock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int no_yield(); // idb
void __cdecl keep_sockalive(int fd);
void *__cdecl cgmalloc(uint32_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__cdecl cgcalloc(int memb, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__cdecl cgrealloc(void *ptr, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
const unsigned __int8 *__cdecl proxytype(proxytypes_t proxytype);
unsigned __int8 *__cdecl get_proxy(unsigned __int8 *url, pool *pool);
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len);
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len);
bool __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len);
bool __cdecl valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl valid_ascii(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl fulltest(const unsigned __int8 *hash, const unsigned __int8 *target);
thread_q *tq_new(); // idb
void __cdecl tq_freezethaw(thread_q *tq, bool frozen);
void __cdecl tq_freeze(thread_q *tq);
bool __cdecl tq_push(thread_q *tq, void *data);
void *__cdecl tq_pop(thread_q *tq, const timespec *abstime);
int __cdecl thr_info_create(thr_info *thr, pthread_attr_t_0 *attr, void *(*start)(void *), void *arg);
void __cdecl thr_info_cancel(thr_info *thr);
void __cdecl subtime(timeval *a, timeval *b);
void __cdecl addtime(timeval *a, timeval *b);
bool __cdecl time_more(timeval *a, timeval *b);
bool __cdecl time_less(timeval *a, timeval *b);
void __cdecl copy_time(timeval *dest, const timeval *src);
void __cdecl timeval_to_spec(timespec *spec, const timeval *val);
void __cdecl us_to_timespec(timespec *spec, int64_t us);
void __cdecl ms_to_timespec(timespec *spec, int64_t ms);
void __cdecl spec_nscheck(timespec *ts);
void __cdecl timeraddspec(timespec *a, const timespec *b);
void __cdecl cgtime(timeval *tv);
void __cdecl cgtimer_time(cgtimer_t *ts_start);
void __cdecl nanosleep_abstime(timespec *ts_end);
void __cdecl cgsleep_ms_r(cgtimer_t *ts_start, int ms);
void __cdecl cgsleep_us_r(cgtimer_t *ts_start, int64_t us);
void __cdecl cgsleep_ms(int ms);
void __cdecl cgsleep_us(int64_t us);
double __cdecl tdiff(timeval *end, timeval *start);
bool __cdecl extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port);
send_ret __cdecl _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
bool __cdecl stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
bool __cdecl socket_full(pool *pool, int wait);
bool __cdecl sock_full(pool *pool);
void __cdecl clear_sockbuf(pool *pool);
void __cdecl clear_sock(pool *pool);
void __cdecl recalloc_sock(pool *pool, size_t len);
unsigned __int8 *__cdecl recv_line(pool *pool);
unsigned __int8 *__cdecl _json_array_string(json_t_0 *val, unsigned int entry);
unsigned __int8 *__cdecl json_array_string(json_t_0 *val, unsigned int entry);
bool __cdecl parse_notify(pool *pool, json_t_0 *val);
uint32_t __cdecl real_mask(uint32_t mask, int need_bit);
void __cdecl process_version_mask(pool *pool, unsigned __int8 *mask);
bool __cdecl parse_version_mask(pool *pool, json_t_0 *val);
bool __cdecl parse_version_rolling_mask(pool *pool, unsigned __int8 *sret);
bool __cdecl parse_version(pool *pool, json_t_0 *val);
bool __cdecl parse_diff(pool *pool, json_t_0 *val);
bool __cdecl parse_extranonce(pool *pool, json_t_0 *val);
void __cdecl _suspend_stratum(pool *pool);
bool __cdecl parse_reconnect(pool *pool, json_t_0 *val);
bool __cdecl send_version(pool *pool, json_t_0 *val);
bool __cdecl send_pong(pool *pool, json_t_0 *val);
bool __cdecl show_message(pool *pool, json_t_0 *val);
bool __cdecl parse_method(pool *pool, unsigned __int8 *s);
bool __cdecl subscribe_extranonce(pool *pool);
bool __cdecl auth_stratum(pool *pool);
int __cdecl recv_byte(int sockd);
bool __cdecl http_negotiate(pool *pool, int sockd, bool http0);
bool __cdecl socks5_negotiate(pool *pool, int sockd);
bool __cdecl socks4_negotiate(pool *pool, int sockd, bool socks4a);
void __cdecl noblock_socket(int fd);
void __cdecl block_socket(int fd);
bool sock_connecting(); // idb
bool __cdecl setup_stratum_socket(pool *pool);
unsigned __int8 *__cdecl get_sessionid(json_t_0 *val);
void __cdecl suspend_stratum(pool *pool);
bool __cdecl initiate_stratum(pool *pool);
bool __cdecl restart_stratum(pool *pool);
void __cdecl dev_error(cgpu_info *dev, dev_reason reason);
void __cdecl RenameThread(const unsigned __int8 *name);
void __cdecl cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl cgsem_mswait(cgsem_t *cgsem, int ms, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_destroy(cgsem_t *cgsem);
void *__cdecl completion_thread(void *arg);
bool __cdecl cg_completion_timeout(void *fn, void *fnarg, int timeout);
void __cdecl cg_memcpy(void *dest, const void *src, unsigned int n, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rev(unsigned __int8 *s, size_t l);
unsigned int get_iic(); // idb
unsigned __int8 __cdecl set_iic(unsigned int data);
uint8_t __cdecl zynq_set_iic(unsigned __int8 dev_addr, unsigned __int8 which_iic, bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 data);
void __cdecl read_fpga_id(unsigned __int8 *pFpgaID);
unsigned int get_nonce2_and_job_id_store_address();
void __cdecl set_nonce2_and_job_id_store_address(unsigned int value);
int get_job_start_address(); // idb
void __cdecl set_job_start_address(unsigned int value);
int get_QN_write_data_command(); // idb
void __cdecl set_QN_write_data_command(unsigned int value);
void __cdecl set_reset_hashboard(int chainIndex, int resetBit);
int get_fan_control(); // idb
void __cdecl set_fan_control(unsigned int value);
int get_hash_on_plug(); // idb
unsigned int get_crc_count(); // idb
int get_hardware_version(); // idb
void __cdecl set_Hardware_version(unsigned int value);
int __cdecl get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed);
int get_time_out_control(); // idb
void __cdecl set_time_out_control(unsigned int value);
int __cdecl get_BC_command_buffer(unsigned int *buf);
void __cdecl set_BC_command_buffer(unsigned int *value);
int get_BC_write_command(); // idb
void __cdecl set_BC_command_buffer_t(unsigned int *value);
unsigned int get_nonce_number_in_fifo();
int __cdecl get_return_nonce(unsigned int *buf);
void __cdecl set_BC_write_command_t(unsigned int value);
void __cdecl set_BC_write_command(unsigned int value);
int get_ticket_mask(); // idb
void __cdecl set_ticket_mask(unsigned int value);
int get_job_id(); // idb
void __cdecl set_job_id(unsigned int value);
void __cdecl set_job_length(unsigned int value);
int get_block_header_version(); // idb
int get_block_header_version_1(); // idb
void __cdecl set_block_header_version(unsigned int value);
void __cdecl set_block_header_version_1(uint32_t value);
int get_time_stamp(); // idb
void __cdecl set_time_stamp(unsigned int value);
int get_target_bits(); // idb
void __cdecl set_target_bits(unsigned int value);
void __cdecl set_pre_header_hash(unsigned int *value);
int get_coinbase_length_and_nonce2_length(); // idb
void __cdecl set_coinbase_length_and_nonce2_length(unsigned int value);
int __cdecl get_work_nonce2(unsigned int *buf);
void __cdecl set_work_nonce2(unsigned int *value);
int get_merkle_bin_number(); // idb
void __cdecl set_merkle_bin_number(unsigned int value);
int get_nonce_fifo_interrupt(); // idb
void __cdecl set_nonce_fifo_interrupt(unsigned int value);
int get_dhash_acc_control(); // idb
void __cdecl set_dhash_acc_control(unsigned int value);
void __cdecl set_TW_write_command_vil(unsigned int *value);
unsigned int get_buffer_space();
int get_hash_counting_number(); // idb
void __cdecl set_hash_counting_number(unsigned int value);
int bitmain_axi_init(); // idb
unsigned int __cdecl _bswap_32_0(unsigned int __bsx);
__uint32_t __cdecl _uint32_identity_0(__uint32_t __x);
__uint64_t __cdecl _uint64_identity_0(__uint64_t __x);
void __cdecl json_decref_0(json_t_0 *json);
void __cdecl _list_del_0(list_head *prev, list_head *next);
void __cdecl list_del_0(list_head *entry);
uint32_t __cdecl swab32_1(uint32_t v);
void __cdecl swap256(void *dest_p, const void *src_p);
void __cdecl swab256_0(void *dest_p, const void *src_p);
void __cdecl flip32_0(void *dest_p, const void *src_p);
void __cdecl flip64(void *dest_p, const void *src_p);
void __cdecl flip80(void *dest_p, const void *src_p);
void __cdecl endian_flip32(void *dest_p, const void *src_p);
void __cdecl mutex_lock_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl wr_trylock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_dwlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl time_before(tm *tm1, tm *tm2);
bool should_run(); // idb
void __cdecl get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv);
void __cdecl get_timestamp(unsigned __int8 *f, size_t fsiz, timeval *tv);
void applog_and_exit(const unsigned __int8 *fmt, ...);
thr_info *__cdecl _get_thread(int thr_id);
thr_info *__cdecl get_thread(int thr_id);
cgpu_info *__cdecl get_thr_cgpu(int thr_id);
cgpu_info *__cdecl get_devices(int id);
void __cdecl sharelog(const unsigned __int8 *disposition, const work *work);
void adjust_quota_gcd(); // idb
pool *add_pool(); // idb
bool __cdecl pool_tset(pool *pool, bool *var);
bool __cdecl pool_tclear(pool *pool, bool *var);
pool *current_pool(); // idb
unsigned __int8 *__cdecl set_int_range(const unsigned __int8 *arg, int *i, int min, int max);
unsigned __int8 *__cdecl set_int_0_to_9999(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_65535(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_10(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_100(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_7680(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_200(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_32_to_63(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_22_to_75(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_42_to_85(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_22_to_55(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_42_to_65(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_10(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_4(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_balance(pool_strategy *strategy);
unsigned __int8 *__cdecl set_loadbalance(pool_strategy *strategy);
unsigned __int8 *__cdecl set_rotate(const unsigned __int8 *arg, unsigned __int8 *i);
unsigned __int8 *__cdecl set_rr(pool_strategy *strategy);
bool __cdecl detect_stratum(pool *pool, unsigned __int8 *url);
pool *add_url(); // idb
unsigned __int8 *__cdecl setup_url(pool *pool, unsigned __int8 *arg);
unsigned __int8 *__cdecl set_url(unsigned __int8 *arg);
unsigned __int8 *__cdecl set_quota(unsigned __int8 *arg);
unsigned __int8 *__cdecl set_user(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_pass(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_userpass(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_extranonce_subscribe(unsigned __int8 *arg);
unsigned __int8 *__cdecl enable_debug(bool *flag);
unsigned __int8 *__cdecl set_schedtime(const unsigned __int8 *arg, schedtime *st);
unsigned __int8 *__cdecl set_sched_start(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_sched_stop(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_sharelog(unsigned __int8 *arg);
void load_temp_cutoffs(); // idb
unsigned __int8 *__cdecl set_logfile_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logfile_openflag(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logwork_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logwork_asicnum(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_float_125_to_500(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_float_100_to_250(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_float_0_to_500(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_null(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_version_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl parse_config(json_t_0 *config, bool fileconf);
unsigned __int8 *__cdecl load_config(const unsigned __int8 *arg, void *unused);
unsigned __int8 *__cdecl set_default_config(const unsigned __int8 *arg);
void load_default_config(); // idb
unsigned __int8 *__cdecl opt_verusage_and_exit(const unsigned __int8 *extra);
void __cdecl calc_midstate(work *work);
int total_work_inc(); // idb
work *make_work(); // idb
void __cdecl clean_work(work *work);
void __cdecl free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl decay_time(double *f, double fadd, double fsecs, double interval);
unsigned int _total_staged();
void __cdecl suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits);
double __cdecl cgpu_runtime(cgpu_info *cgpu);
void __cdecl get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
int shared_strategy();
void __cdecl enable_pool(pool *pool);
void __cdecl reject_pool(pool *pool);
void __cdecl share_result(json_t_0 *val, json_t_0 *res, json_t_0 *err, const work *work, unsigned __int8 *hashshow, bool resubmit, unsigned __int8 *worktime);
void __cdecl show_hash(work *work, unsigned __int8 *hashshow);
bool __cdecl pool_unusable(pool *pool);
pool *__cdecl select_balanced(pool *cp);
pool *select_pool(); // idb
double __cdecl le256todouble(const void *target);
double __cdecl diff_from_target(void *target);
void __cdecl calc_diff(work *work, double known);
void __cdecl get_benchmark_work(work *work);
void __cdecl benchfile_dspwork(work *work, uint32_t nonce);
bool __cdecl benchfile_get_work(work *work);
void __cdecl get_benchfile_work(work *work);
void __cdecl kill_timeout(thr_info *thr);
void kill_mining(); // idb
void _kill_work(); // idb
void __noreturn kill_work();
void app_restart(); // idb
void __cdecl sighandler(int sig);
void *__cdecl submit_work_thread(void *userdata);
unsigned __int8 *__cdecl offset_ntime(const unsigned __int8 *ntime, int noffset);
void __cdecl copy_work(work *work, const work *base_work, int noffset);
work *__cdecl copy_work_noffset(work *base_work, int noffset);
void __cdecl pool_died(pool *pool);
bool __cdecl stale_work(work *work, bool share);
uint64_t __cdecl share_diff(const work *work);
void __cdecl regen_hash(work *work);
pool *__cdecl priority_pool(int choice);
void __cdecl switch_pools(pool *selected);
void __cdecl discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void wake_gws(); // idb
void discard_stale(); // idb
void *__cdecl restart_thread(void *arg);
void restart_threads(); // idb
void signal_work_update(); // idb
void __cdecl set_curblock(const unsigned __int8 *hexstr, const unsigned __int8 *bedata);
int __cdecl block_sort(block *blocka, block *blockb);
void __cdecl set_blockdiff(const work *work);
bool __cdecl block_exists(const unsigned __int8 *hexstr, const unsigned __int8 *bedata, const work *work);
bool __cdecl test_work_current(work *work);
int __cdecl tv_sort(work *worka, work *workb);
bool __cdecl work_rollable(work *work);
bool __cdecl hash_push(work *work);
void __cdecl stage_work(work *work);
void __cdecl remove_pool(pool *pool);
void json_escape_free(); // idb
unsigned __int8 *__cdecl json_escape(unsigned __int8 *str);
void __cdecl write_config(FILE *fcfg);
void zero_bestshare(); // idb
void zero_stats(); // idb
void set_highprio(); // idb
void set_lowprio(); // idb
void __cdecl default_save_file(unsigned __int8 *filename);
void *__cdecl api_thread(void *userdata);
void __cdecl thread_reportin(thr_info *thr);
void __cdecl thread_reportout(thr_info *thr);
void __cdecl hashmeter(int thr_id, uint64_t hashes_done);
void __cdecl stratum_share_result(json_t_0 *val, json_t_0 *res_val, json_t_0 *err_val, stratum_share *sshare);
bool __cdecl parse_stratum_response(pool *pool, unsigned __int8 *s);
void __cdecl clear_stratum_shares(pool *pool);
void __cdecl clear_pool_work(pool *pool);
int cp_prio(); // idb
bool __cdecl cnx_needed(pool *pool);
void __cdecl stratum_resumed(pool *pool);
bool __cdecl supports_resume(pool *pool);
void *__cdecl stratum_rthread(void *userdata);
void *__cdecl stratum_sthread(void *userdata);
void __cdecl init_stratum_threads(pool *pool);
bool __cdecl stratum_works(pool *pool);
bool __cdecl setup_gbt_solo(CURL *curl, pool *pool);
void __cdecl pool_start_lp(pool *pool);
bool __cdecl pool_active(pool *pool, bool pinging);
void __cdecl pool_resus(pool *pool);
work *__cdecl hash_pop(bool blocking);
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len);
void __cdecl set_target(unsigned __int8 *dest_target, double diff);
void __cdecl get_work_by_nonce2(thr_info *thr, work **work, pool *pool, pool *real_pool, uint64_t nonce2, uint32_t version);
void __cdecl gen_stratum_work(pool *pool, work *work);
void __cdecl set_benchmark_work(cgpu_info *cgpu, work *work);
work *__cdecl get_work(thr_info *thr, const int thr_id);
void __cdecl submit_work_async(work *work);
void __cdecl inc_hw_errors(thr_info *thr);
void __cdecl rebuild_nonce(work *work, uint32_t nonce);
bool __cdecl test_nonce(work *work, uint32_t nonce);
void __cdecl update_work_stats(thr_info *thr, work *work);
bool __cdecl submit_tested_work(thr_info *thr, work *work);
bool __cdecl new_nonce(thr_info *thr, uint32_t nonce);
bool __cdecl submit_nonce(thr_info *thr, work *work, uint32_t nonce);
bool __cdecl abandon_work(work *work, timeval *wdiff, uint64_t hashes);
void __cdecl mt_disable(thr_info *mythr, const int thr_id, device_drv *drv);
void __cdecl hash_sole_work(thr_info *mythr);
void __cdecl flush_queue(cgpu_info *cgpu);
void __cdecl hash_driver_work(thr_info *mythr);
void *__cdecl miner_thread(void *userdata);
void __cdecl wait_lpcurrent(pool *pool);
void *__cdecl longpoll_thread(void *userdata);
void __cdecl reinit_device(cgpu_info *cgpu);
void __cdecl reap_curl(pool *pool);
void __cdecl prune_stratum_shares(pool *pool);
void *__cdecl watchpool_thread(void *userdata);
void *__cdecl watchdog_thread(void *userdata);
void __cdecl log_print_status(cgpu_info *cgpu);
void print_summary(); // idb
void __cdecl clean_up(bool restarting);
void *__cdecl killall_thread(void *arg);
void __cdecl _quit(int status, bool clean);
void __cdecl quit(int status);
void *__cdecl test_pool_thread(void *arg);
bool __cdecl add_pool_details(pool *pool, bool live, unsigned __int8 *url, unsigned __int8 *user, unsigned __int8 *pass);
void fork_monitor(); // idb
void __cdecl noop_reinit_device(cgpu_info *cgpu);
void __cdecl blank_get_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
void __cdecl noop_get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
bool __cdecl noop_get_stats(cgpu_info *cgpu);
bool __cdecl noop_thread_prepare(thr_info *thr);
bool __cdecl noop_thread_init(thr_info *thr);
bool __cdecl noop_prepare_work(thr_info *thr, work *work);
void __cdecl noop_hw_error(thr_info *thr);
void __cdecl noop_thread_shutdown(thr_info *thr);
void __cdecl noop_thread_enable(thr_info *thr);
void __cdecl noop_detect(bool hotplug);
void __cdecl generic_zero_stats(cgpu_info *cgpu);
void __cdecl fill_device_drv(device_drv *drv);
void __cdecl enable_device(cgpu_info *cgpu);
void adjust_mostdevs(); // idb
bool __cdecl add_cgpu(cgpu_info *cgpu);
void probe_pools(); // idb
void setStartTimePoint(); // idb
int __cdecl cnt_of_proc(const unsigned __int8 *app_name);
bool is_cgminer_already_started(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
void clear_probability_file(); // idb
void __cdecl store_mhashrate_history(double thash);
void clear_queue(); // idb
void recalc_hashrate(); // idb
void show_hashrate_history(); // idb
void __noreturn store_hash_rate();
double __cdecl get_average_hashrate(uint32_t minutes);
double get_30minutes_hashrate(); // idb
void __cdecl json_decref_1(json_t_0 *json);
int sock_blocks_0();
void __cdecl mutex_lock_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl io_reinit(io_data *io_data);
io_data *__cdecl io_new(size_t initial, bool socket_buf);
bool __cdecl io_add(io_data *io_data, unsigned __int8 *buf);
bool __cdecl io_put(io_data *io_data, unsigned __int8 *buf);
void __cdecl io_close(io_data *io_data);
void io_free(); // idb
unsigned __int8 *__cdecl escape_string(unsigned __int8 *str, bool isjson);
api_data *__cdecl api_add_extra(api_data *root, api_data *extra);
api_data *__cdecl api_add_data_full(api_data *root, unsigned __int8 *name, api_data_type type, void *data, bool copy_data);
api_data *__cdecl api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_uint8(api_data *root, unsigned __int8 *name, uint8_t *data, bool copy_data);
api_data *__cdecl api_add_int16(api_data *root, unsigned __int8 *name, int16_t *data, bool copy_data);
api_data *__cdecl api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data);
api_data *__cdecl api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__cdecl api_add_uint32(api_data *root, unsigned __int8 *name, uint32_t *data, bool copy_data);
api_data *__cdecl api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data);
api_data *__cdecl api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data);
api_data *__cdecl api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data);
api_data *__cdecl api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data);
api_data *__cdecl api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data);
api_data *__cdecl api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
api_data *__cdecl api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
void __cdecl add_item_buf(K_ITEM *item, const unsigned __int8 *str);
api_data *__cdecl print_data(io_data *io_data, api_data *root, bool isjson, bool precom);
int numascs(); // idb
int __cdecl ascdevice(int ascid);
void __cdecl message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson);
void __cdecl lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
const unsigned __int8 *__cdecl status2str(alive status);
void __cdecl ascstatus(io_data *io_data, int asc, bool isjson, bool precom);
void __cdecl devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void getAVGhashrate();
void get_total_hashs();
void get_total_secs();
void __cdecl lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl copyadvanceafter(unsigned __int8 ch, unsigned __int8 **param, unsigned __int8 **buf);
bool __cdecl pooldetails(unsigned __int8 *param, unsigned __int8 **url, unsigned __int8 **user, unsigned __int8 **pass);
void __cdecl addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group);
void __cdecl notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
int __cdecl itemstats(io_data *io_data, int i, unsigned __int8 *id, cgminer_stats *stats, cgminer_pool_stats *pool_stats, api_data *extra, cgpu_info *cgpu, bool isjson);
void __cdecl minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascdev(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascenable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascdisable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascidentify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascset(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin);
void __cdecl tail_join(io_data *io_data, bool isjson);
void __cdecl send_result(io_data *io_data, int c, bool isjson);
void __cdecl tidyup(void *arg);
void setup_groups(); // idb
void setup_ipaccess(); // idb
void *__cdecl quit_thread(void *userdata);
void *__cdecl restart_thread_0(void *userdata);
bool __cdecl check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group);
void mcast(); // idb
void *__cdecl mcast_thread(void *userdata);
void mcast_init(); // idb
void reCalculateAVG(); // idb
void __cdecl api(int api_thr_id);
void __cdecl mutex_lock_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl mutex_trylock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force);
void __cdecl applog(int prio, const unsigned __int8 *str, bool force);
int __cdecl my_system(const unsigned __int8 *cmd);
int __cdecl log_update_name(const _log_ctx *ctx, const unsigned __int8 *prefix, const unsigned __int8 *path, const unsigned __int8 *ts);
int __cdecl log_rotate(const _log_ctx *ctx);
int __cdecl log_generate_symbol_link(const _log_ctx *ctx, const unsigned __int8 *prefix, const unsigned __int8 *path);
void *__cdecl log_thread_routine(void *arg);
void log_init(); // idb
void __cdecl clear_log(unsigned __int8 *file);
void __cdecl copy_log_to_latest(unsigned __int8 *file);
void __cdecl print_crt_time_to_file(const unsigned __int8 *file, unsigned int level);
void __cdecl dump_mem(unsigned __int8 *desc, void *addr, int len);
bool __cdecl is_chain_existed(uint8_t chain);
bool __cdecl is_eeprom_chain_load_succeeded(uint8_t chain);
bool __cdecl is_eeprom_address_valid(uint32_t address, uint32_t len);
bool __cdecl is_eeprom_write_buf_valid(uint8_t *buf);
bool __cdecl is_eeprom_read_buf_valid(uint8_t *buf);
uint8_t __cdecl write_eeprom_iic(uint8_t chain, uint8_t reg_addr, uint8_t data);
uint8_t __cdecl read_eeprom_iic(uint8_t chain, uint8_t reg_addr);
void __cdecl eeprom_write_one_byte(uint8_t address, uint8_t data, uint8_t chain);
void __cdecl array_write_one_byte(uint8_t address, uint8_t data, uint8_t chain);
uint8_t __cdecl eeprom_read_one_byte(uint8_t address, uint8_t chain);
uint8_t __cdecl array_read_one_byte(uint8_t address, uint8_t chain);
void __cdecl eeprom_write_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length);
void __cdecl array_write_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length);
void __cdecl eeprom_read_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length);
void __cdecl array_read_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length);
bool __cdecl array_update_crc(uint8_t chain);
bool __cdecl array_check_crc(uint8_t chain);
eeprom_store_t *__cdecl read_eeprom_store_from_at24c02(eeprom_store_t *eeprom_store, uint8_t chain);
bool __cdecl eeprom_set_freq(uint8_t chain, uint32_t *buf, uint8_t mode);
bool __cdecl eeprom_set_freq(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_set_freq_mode1(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_set_freq_mode2(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_get_freq(uint8_t chain, uint32_t *buf, uint8_t mode);
bool __cdecl eeprom_get_freq(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_get_freq_mode1(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_get_freq_mode2(uint8_t chain, uint32_t *buf);
bool __cdecl eeprom_set_voltage(uint8_t chain, double voltage, uint8_t mode);
bool __cdecl eeprom_set_voltage(uint8_t chain, double voltage);
bool __cdecl eeprom_set_voltage_mode1(uint8_t chain, double voltage);
bool __cdecl eeprom_set_voltage_mode2(uint8_t chain, double voltage);
bool __cdecl eeprom_get_voltage(uint8_t chain, double *voltage, uint8_t mode);
bool __cdecl eeprom_get_voltage(uint8_t chain, double *voltage);
bool __cdecl eeprom_get_voltage_mode1(uint8_t chain, double *voltage);
bool __cdecl eeprom_get_voltage_mode2(uint8_t chain, double *voltage);
bool __cdecl eeprom_set_hashrate(uint8_t chain, uint32_t hash, uint8_t mode);
bool __cdecl eeprom_set_hashrate(uint8_t chain, uint32_t hash);
bool __cdecl eeprom_set_hashrate_mode1(uint8_t chain, uint32_t hash);
bool __cdecl eeprom_set_hashrate_mode2(uint8_t chain, uint32_t hash);
bool __cdecl eeprom_get_hashrate(uint8_t chain, uint32_t *hash, uint8_t mode);
bool __cdecl eeprom_get_hashrate(uint8_t chain, uint32_t *hash);
bool __cdecl eeprom_get_hashrate_mode1(uint8_t chain, uint32_t *hash);
bool __cdecl eeprom_get_hashrate_mode2(uint8_t chain, uint32_t *hash);
void __cdecl dump_freq_data(uint8_t chain, uint32_t *freq);
void __cdecl travel_eeprom_store(uint8_t chain, bool debug);
void eeprom_dump(); // idb
void eeprom_dump_for_debug(); // idb
bool __cdecl eeprom_write_full_length(uint8_t chain, uint8_t *buf);
bool __cdecl eeprom_read(uint8_t chain, uint32_t addr, uint8_t *buf, uint32_t len);
bool __cdecl eeprom_set_inbalance_info(uint8_t chain, uint8_t *buf, uint32_t len);
bool __cdecl eeprom_get_pcb_version(uint8_t chain, uint8_t *pcb_version);
bool __cdecl eeprom_get_pcb_version(uint8_t chain, uint8_t *pcb_version);
bool __cdecl eeprom_get_bom_version(uint8_t chain, uint8_t *bom_version);
bool __cdecl eeprom_get_bom_version(uint8_t chain, uint8_t *bom_version);
bool __cdecl eeprom_get_chip_major_type(uint8_t chain, CHIP_MAJOR_TYPE *type);
bool __cdecl eeprom_get_chip_minor_type(uint8_t chain, CHIP_MINOR_TYPE *type);
bool __cdecl eeprom_get_chip_level(uint8_t chain, CHIP_LEVEL *level);
bool __cdecl eeprom_get_temp_sensor_type(uint8_t chain, TEMP_SENSOR_TYPE *type);
bool __cdecl eeprom_get_temp_sensor_type(uint8_t chain, TEMP_SENSOR_TYPE *type);
bool __cdecl eeprom_set_temp_sensor_type(uint8_t chain, TEMP_SENSOR_TYPE type);
bool __cdecl eeprom_set_temp_sensor_num(uint8_t chain, uint8_t num);
bool __cdecl eeprom_set_temp_sensor_data(uint8_t chain, uint8_t *buf, uint32_t len);
bool __cdecl eeprom_get_temp_sensor_data(uint8_t chain, uint8_t *buf, uint32_t *len);
bool __cdecl eeprom_get_temp_sensor_data(uint8_t chain, uint8_t *buf, uint32_t *len);
bool __cdecl eeprom_set_temp_sensor_pos(uint8_t chain, uint8_t *buf, uint32_t len);
bool __cdecl eeprom_get_temp_sensor_pos(uint8_t chain, uint8_t *buf, uint32_t *len);
bool __cdecl eeprom_get_temp_sensor_pos(uint8_t chain, uint8_t *buf, uint32_t *len);
int eeprom_load();
int eeprom_save();
bool __cdecl check_freq_valid_single(uint32_t freq, uint32_t valid_max_freq);
int eeprom_target_eeprom_version();
bool __cdecl check_freq_valid(uint32_t *freq_buf, uint32_t len, uint32_t valid_max_freq);
void __cdecl mutex_init_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__cdecl k_new_list(const unsigned __int8 *name, size_t siz, int allocate, int limit, bool do_tail, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__cdecl k_unlink_head(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_add_head(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
uint8_t __cdecl write_pic_iic(uint8_t chain, uint8_t data);
uint8_t __cdecl read_pic_iic(uint8_t chain);
void __cdecl send_pic_cmd(uint8_t chain, uint8_t *cmd, uint8_t cmd_len, uint8_t *reply_buf, uint8_t reply_len);
int __cdecl dsPIC33EP16GS202_reset_pic(uint8_t chain);
int __cdecl dsPIC33EP16GS202_jump_to_app_from_loader(uint32_t chain);
int __cdecl dsPIC33EP16GS202_pic_heart_beat(uint8_t chain);
int __cdecl dsPIC33EP16GS202_enable_pic_dc_dc(uint8_t chain, uint8_t enable);
int __cdecl dsPIC33EP16GS202_set_pic_voltage(uint8_t chain, uint8_t pic_voltage);
void __cdecl enable_pic_dac(uint8_t chain);
void __cdecl disable_pic_dac(uint8_t chain);
void __cdecl pic_heart_beat_each_chain(uint8_t chain);
int __cdecl dsPIC33EP16GS202_get_software_version(uint8_t chain, uint8_t *version);
void get_pic_software_version_all_chain(); // idb
int __cdecl dsPIC33EP16GS202_crab_circuit_control(uint8_t chain, unsigned __int8 enable);
int __cdecl set_pic_da_value(uint8_t chain, uint8_t da_value);
void enable_crab_circuit(); // idb
void disable_crab_circuit(); // idb
bool __cdecl check_crc(unsigned __int8 *buf);
double __cdecl decode_an_voltage_buf(unsigned __int8 *buf);
double __cdecl dsPIC33EP16GS202_pic_get_an_voltage2(uint8_t chain);
double __cdecl get_pic_an_voltage2(uint8_t chain);
int __cdecl init_pic_one_chain(uint8_t chain);
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __cdecl register_parse_clock_delay_ctrl(core_reg_status_t *core_reg_status);
void __cdecl register_parse_process_monitor_ctrl(core_reg_status_t *core_reg_status);
void __cdecl register_parse_process_monitor_data(core_reg_status_t *core_reg_status);
void __cdecl register_parse_core_error(core_reg_status_t *core_reg_status);
void __cdecl register_parse_core_enable(core_reg_status_t *core_reg_status);
void __cdecl register_parse_hash_clock_ctrl(core_reg_status_t *core_reg_status);
void __cdecl register_parse_hash_clock_counter(core_reg_status_t *core_reg_status);
void __cdecl register_parse_sweep_freq_ctrl(core_reg_status_t *core_reg_status);
void __cdecl register_build_core_command_read_one(core_command_t *core_cmd, uint8_t core_id, uint8_t reg);
void __cdecl register_build_core_command_write_all(core_command_t *core_cmd, uint8_t reg, uint8_t reg_data);
void __cdecl register_build_set_config_command(set_config_t *set_cfg, uint8_t asic, core_command_t *core_cmd);
void __cdecl register_build_bc_command(uint32_t *bc_cmd, set_config_t *set_cfg);
bool __cdecl register_process_core_response(int chain, uint8_t asic, core_reg_status_t *core_reg_status);
void __cdecl register_receive_core_response(int chain, uint8_t asic, core_reg_status_t *core_reg_status);
void __cdecl register_send_cmd_read_one(int chain, uint8_t asic, uint8_t core_id, uint8_t core_reg);
void __cdecl register_send_core_cmd_write_all(int chain, uint8_t asic, uint8_t core_reg, uint8_t core_reg_data);
void __cdecl register_dump_core_reg(uint8_t core_reg, core_reg_status_t *core_reg_status);
bool __cdecl register_is_param_valid(int chain, uint8_t asic, uint8_t core);
void __cdecl do_dump_core_hash_clock_counter(int chain, uint8_t asic, uint32_t core);
void get_higher_voltage();
void *__cdecl statusServiceThread(void *param);
void *__cdecl httpListenThread(void *param);
void StartHttpThread(); // idb
void __cdecl sha2_starts(sha2_context *ctx);
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
unsigned __int8 *__cdecl arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg);
unsigned __int8 *__cdecl opt_set_bool(bool *b);
unsigned __int8 *__cdecl opt_set_false(bool *b);
unsigned __int8 *__cdecl opt_set_invbool(bool *b);
unsigned __int8 *__cdecl opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p);
unsigned __int8 *__cdecl opt_set_intval(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl opt_set_floatval(const unsigned __int8 *arg, float *f);
unsigned __int8 *__cdecl opt_set_longval(const unsigned __int8 *arg, int *l);
unsigned __int8 *__cdecl opt_version_and_exit(const unsigned __int8 *version);
unsigned __int8 *__cdecl opt_usage_and_exit(const unsigned __int8 *extra);
void __cdecl opt_show_intval(unsigned __int8 *buf, const int *i);
void __cdecl opt_show_floatval(unsigned __int8 *buf, const float *f);
const unsigned __int8 *__cdecl first_name(const unsigned __int8 *names, unsigned int *len);
const unsigned __int8 *__cdecl next_name(const unsigned __int8 *names, unsigned int *len);
const unsigned __int8 *__cdecl first_opt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl first_lopt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl first_sopt(unsigned int *i);
const unsigned __int8 *__cdecl next_sopt(const unsigned __int8 *p, unsigned int *i);
void __cdecl check_opt(const opt_table *entry);
void __cdecl add_opt(const opt_table *entry);
void __cdecl opt_register_table(const opt_table *entry, const unsigned __int8 *desc);
bool __cdecl opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...));
unsigned int __cdecl write_short_options(unsigned __int8 *str);
unsigned __int8 *__cdecl opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra);
int __cdecl parse_err(void (*errlog)(const unsigned __int8 *, ...), const unsigned __int8 *argv0, const unsigned __int8 *arg, unsigned int len, const unsigned __int8 *problem);
void __cdecl consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum);
int __cdecl parse_one(int *argc, unsigned __int8 **argv, unsigned int *offset, void (*errlog)(const unsigned __int8 *, ...));
int __cdecl strbuffer_init(strbuffer_t *strbuff);
void __cdecl strbuffer_close(strbuffer_t *strbuff);
void __cdecl strbuffer_clear(strbuffer_t *strbuff);
const unsigned __int8 *__cdecl strbuffer_value(const strbuffer_t *strbuff);
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte);
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size);
unsigned __int8 __cdecl strbuffer_pop(strbuffer_t *strbuff);
void __cdecl jsonp_error_init(json_error_t *error, const unsigned __int8 *source);
void __cdecl jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source);
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...);
void __cdecl jsonp_error_vset(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, va_list ap);
void __cdecl to_locale(strbuffer_t *strbuffer);
void __cdecl from_locale(unsigned __int8 *buffer);
int __cdecl jsonp_strtod(strbuffer_t *strbuffer, double *out);
int __cdecl jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value, int precision);
void __cdecl json_decref_2(json_t_0 *json);
void __cdecl json_init(json_t_0 *json, json_type type);
json_object_t *json_object();
void __cdecl json_delete_object(json_object_t *object);
size_t __cdecl json_object_size(const json_t_0 *json);
json_t_0 *__cdecl json_object_get(const json_t_0 *json, const unsigned __int8 *key);
int __cdecl json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value);
void *__cdecl json_object_iter(json_t_0 *json);
void *__cdecl json_object_iter_next(json_t_0 *json, void *iter);
const unsigned __int8 *__cdecl json_object_iter_key(void *iter);
json_t_0 *__cdecl json_object_iter_value(void *iter);
void *__cdecl json_object_key_to_iter(const unsigned __int8 *key);
json_array_t *json_array();
void __cdecl json_delete_array(json_array_t *array);
size_t __cdecl json_array_size(const json_t_0 *json);
json_t_0 *__cdecl json_array_get(const json_t_0 *json, size_t index);
void __cdecl array_copy(json_t_0 **dest, size_t dpos, json_t_0 **src, size_t spos, size_t count);
json_t_0 **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy);
int __cdecl json_array_append_new(json_t_0 *json, json_t_0 *value);
json_t_0 *__cdecl string_create(const unsigned __int8 *value, size_t len, int own);
json_t_0 *__cdecl jsonp_stringn_nocheck_own(const unsigned __int8 *value, size_t len);
const unsigned __int8 *__cdecl json_string_value(const json_t_0 *json);
size_t __cdecl json_string_length(const json_t_0 *json);
void __cdecl json_delete_string(json_string_t *string);
json_t_0 *__cdecl json_integer(json_int_t value);
json_int_t __cdecl json_integer_value(const json_t_0 *json);
void __cdecl json_delete_integer(json_integer_t *integer);
json_t_0 *__cdecl json_real(double value);
double __cdecl json_real_value(const json_t_0 *json);
void __cdecl json_delete_real(json_real_t *real);
double __cdecl json_number_value(const json_t_0 *json);
json_t_0 *json_true(); // idb
json_t_0 *json_false(); // idb
json_t_0 *json_null(); // idb
void __cdecl json_delete(json_t_0 *json);
int __cdecl seed_from_timestamp_and_pid(uint32_t *seed);
uint32_t generate_seed(); // idb
void __cdecl json_object_seed(size_t seed);
json_t_0 *__cdecl json_incref(json_t_0 *json);
void __cdecl json_decref_3(json_t_0 *json);
int __cdecl json_object_set_nocheck(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value);
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value);
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *msg, ...);
void __cdecl stream_init(stream_t *stream, get_func get, void *data);
int __cdecl stream_get(stream_t *stream, json_error_t *error);
void __cdecl stream_unget(stream_t *stream, int c);
int __cdecl lex_get(lex_t *lex, json_error_t *error);
void __cdecl lex_save(lex_t *lex, int c);
int __cdecl lex_get_save(lex_t *lex, json_error_t *error);
void __cdecl lex_unget(lex_t *lex, int c);
void __cdecl lex_unget_unsave(lex_t *lex, int c);
void __cdecl lex_save_cached(lex_t *lex);
void __cdecl lex_free_string(lex_t *lex);
int32_t __cdecl decode_unicode_escape(const unsigned __int8 *str);
void __cdecl lex_scan_string(lex_t *lex, json_error_t *error);
int __cdecl lex_scan_number(lex_t *lex, int c, json_error_t *error);
int __cdecl lex_scan(lex_t *lex, json_error_t *error);
unsigned __int8 *__cdecl lex_steal_string(lex_t *lex, size_t *out_len);
int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data);
void __cdecl lex_close(lex_t *lex);
json_t_0 *__cdecl parse_object(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_array(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_value(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_json(lex_t *lex, size_t flags, json_error_t *error);
int __cdecl string_get(void *data);
json_t_0 *__cdecl json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error);
int __cdecl buffer_get(void *data);
json_t_0 *__cdecl json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error);
json_t_0 *__cdecl json_loadf(FILE *input, size_t flags, json_error_t *error);
json_t_0 *__cdecl json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error);
int __cdecl dump_to_strbuffer(const unsigned __int8 *buffer, size_t size, void *data);
int __cdecl dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data);
int __cdecl dump_string(const unsigned __int8 *str, size_t len, json_dump_callback_t dump, void *data, size_t flags);
int __cdecl compare_keys(const void *key1, const void *key2);
int __cdecl do_dump(const json_t_0 *json, size_t flags, int depth, json_dump_callback_t dump, void *data);
unsigned __int8 *__cdecl json_dumps(const json_t_0 *json, size_t flags);
int __cdecl json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags);
void *__cdecl jsonp_malloc(size_t size);
void __cdecl jsonp_free(void *ptr);
unsigned __int8 *__cdecl jsonp_strdup(const unsigned __int8 *str);
unsigned __int8 *__cdecl jsonp_strndup(const unsigned __int8 *str, size_t len);
int __cdecl utf8_encode(int32_t codepoint, unsigned __int8 *buffer, size_t *size);
size_t __cdecl utf8_check_first(unsigned __int8 byte);
size_t __cdecl utf8_check_full(const unsigned __int8 *buffer, size_t size, int32_t *codepoint);
const unsigned __int8 *__cdecl utf8_iterate(const unsigned __int8 *buffer, size_t bufsize, int32_t *codepoint);
void __cdecl json_decref_4(json_t_0 *json);
uint32_t __cdecl hashlittle(const void *key, size_t length, uint32_t initval);
void __cdecl list_init(list_t *list);
void __cdecl list_insert(list_t *list, list_t *node);
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket);
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list);
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const unsigned __int8 *key, size_t hash);
void __cdecl hashtable_do_clear(hashtable_t *hashtable);
int __cdecl hashtable_do_rehash(hashtable_t *hashtable);
int __cdecl hashtable_init(hashtable_t *hashtable);
void __cdecl hashtable_close(hashtable_t *hashtable);
int __cdecl hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, json_t_0 *value);
void *__cdecl hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key);
void *__cdecl hashtable_iter(hashtable_t *hashtable);
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter);
void *__cdecl hashtable_iter_key(void *iter);
void *__cdecl hashtable_iter_value(void *iter);
void *__cdecl rpl_memchr(const void *s, int c_in, size_t n);
size_t __cdecl critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period);
void *__cdecl two_way_short_needle(const unsigned __int8 *haystack, size_t haystack_len, const unsigned __int8 *needle, size_t needle_len);
void *__cdecl two_way_long_needle(const unsigned __int8 *haystack, size_t haystack_len, const unsigned __int8 *needle, size_t needle_len);
void *__cdecl memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len);
int __fastcall divsi3_skip_div0_test(int result, unsigned int); // idb
int _aeabi_ldiv0();
UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp);
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_27324; // weak
_UNKNOWN loc_2732C; // weak
_UNKNOWN loc_27338; // weak
_UNKNOWN loc_27340; // weak
_UNKNOWN loc_27348; // weak
_UNKNOWN loc_27350; // weak
_UNKNOWN loc_27358; // weak
_UNKNOWN loc_27360; // weak
_UNKNOWN loc_27368; // weak
_UNKNOWN loc_27370; // weak
_UNKNOWN loc_27378; // weak
_UNKNOWN loc_27380; // weak
_UNKNOWN loc_27388; // weak
_UNKNOWN loc_27390; // weak
_UNKNOWN loc_7F038; // weak
const unsigned __int8 _FUNCTION___11356[23] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  108u,
  108u,
  100u,
  97u,
  116u,
  97u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  105u,
  110u,
  100u,
  101u,
  120u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11424[15] =
{
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  105u,
  110u,
  97u,
  99u,
  116u,
  105u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11438[12] = { 115u, 101u, 116u, 95u, 97u, 100u, 100u, 114u, 101u, 115u, 115u, 0u }; // idb
const unsigned __int8 _FUNCTION___11452[22] =
{
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11467[19] =
{
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11548[19] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11588[19] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11600[9] = { 115u, 101u, 116u, 95u, 98u, 97u, 117u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___11612[18] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11639[21] =
{
  115u,
  101u,
  116u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11677[17] =
{
  115u,
  101u,
  116u,
  95u,
  109u,
  105u,
  115u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11638[25] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11695[39] =
{
  100u,
  111u,
  95u,
  99u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  98u,
  121u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11709[29] =
{
  100u,
  111u,
  95u,
  99u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11719[27] =
{
  105u,
  115u,
  95u,
  116u,
  101u,
  109u,
  112u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  114u,
  114u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11731[35] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11756[34] =
{
  105u,
  115u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  116u,
  101u,
  109u,
  112u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  114u,
  114u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11784[27] =
{
  114u,
  101u,
  95u,
  99u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  101u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11800[30] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  99u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11810[26] =
{
  99u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11849[29] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  97u,
  110u,
  100u,
  95u,
  103u,
  101u,
  116u,
  95u,
  115u,
  116u,
  97u,
  116u,
  105u,
  115u,
  116u,
  105u,
  99u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11864[16] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  119u,
  109u,
  95u,
  98u,
  121u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11873[19] =
{
  100u,
  105u,
  115u,
  97u,
  98u,
  108u,
  101u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11887[19] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11900[21] =
{
  112u,
  114u,
  111u,
  99u,
  101u,
  115u,
  115u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11945[21] =
{
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  108u,
  111u,
  99u,
  97u,
  108u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11962[21] =
{
  95u,
  103u,
  101u,
  116u,
  95u,
  101u,
  110u,
  118u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11977[15] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11991[8] = { 115u, 101u, 116u, 95u, 80u, 87u, 77u, 0u }; // idb
const unsigned __int8 _FUNCTION___12033[26] =
{
  95u,
  103u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  99u,
  104u,
  105u,
  112u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  116u,
  49u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12047[21] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  99u,
  104u,
  105u,
  112u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12062[22] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  119u,
  109u,
  95u,
  98u,
  121u,
  95u,
  112u,
  105u,
  100u,
  95u,
  109u,
  101u,
  116u,
  104u,
  111u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12081[31] =
{
  100u,
  101u,
  116u,
  101u,
  99u,
  116u,
  95u,
  101u,
  110u,
  118u,
  105u,
  114u,
  111u,
  110u,
  109u,
  101u,
  110u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  0u
}; // idb
__int16 word_81B34 = 119; // weak
_UNKNOWN unk_81B38; // weak
_UNKNOWN unk_81B3C; // weak
const uint8_t chCRCHTalbe[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // idb
const uint8_t chCRCLTalbe[256] =
{
  0u,
  192u,
  193u,
  1u,
  195u,
  3u,
  2u,
  194u,
  198u,
  6u,
  7u,
  199u,
  5u,
  197u,
  196u,
  4u,
  204u,
  12u,
  13u,
  205u,
  15u,
  207u,
  206u,
  14u,
  10u,
  202u,
  203u,
  11u,
  201u,
  9u,
  8u,
  200u,
  216u,
  24u,
  25u,
  217u,
  27u,
  219u,
  218u,
  26u,
  30u,
  222u,
  223u,
  31u,
  221u,
  29u,
  28u,
  220u,
  20u,
  212u,
  213u,
  21u,
  215u,
  23u,
  22u,
  214u,
  210u,
  18u,
  19u,
  211u,
  17u,
  209u,
  208u,
  16u,
  240u,
  48u,
  49u,
  241u,
  51u,
  243u,
  242u,
  50u,
  54u,
  246u,
  247u,
  55u,
  245u,
  53u,
  52u,
  244u,
  60u,
  252u,
  253u,
  61u,
  255u,
  63u,
  62u,
  254u,
  250u,
  58u,
  59u,
  251u,
  57u,
  249u,
  248u,
  56u,
  40u,
  232u,
  233u,
  41u,
  235u,
  43u,
  42u,
  234u,
  238u,
  46u,
  47u,
  239u,
  45u,
  237u,
  236u,
  44u,
  228u,
  36u,
  37u,
  229u,
  39u,
  231u,
  230u,
  38u,
  34u,
  226u,
  227u,
  35u,
  225u,
  33u,
  32u,
  224u,
  160u,
  96u,
  97u,
  161u,
  99u,
  163u,
  162u,
  98u,
  102u,
  166u,
  167u,
  103u,
  165u,
  101u,
  100u,
  164u,
  108u,
  172u,
  173u,
  109u,
  175u,
  111u,
  110u,
  174u,
  170u,
  106u,
  107u,
  171u,
  105u,
  169u,
  168u,
  104u,
  120u,
  184u,
  185u,
  121u,
  187u,
  123u,
  122u,
  186u,
  190u,
  126u,
  127u,
  191u,
  125u,
  189u,
  188u,
  124u,
  180u,
  116u,
  117u,
  181u,
  119u,
  183u,
  182u,
  118u,
  114u,
  178u,
  179u,
  115u,
  177u,
  113u,
  112u,
  176u,
  80u,
  144u,
  145u,
  81u,
  147u,
  83u,
  82u,
  146u,
  150u,
  86u,
  87u,
  151u,
  85u,
  149u,
  148u,
  84u,
  156u,
  92u,
  93u,
  157u,
  95u,
  159u,
  158u,
  94u,
  90u,
  154u,
  155u,
  91u,
  153u,
  89u,
  88u,
  152u,
  136u,
  72u,
  73u,
  137u,
  75u,
  139u,
  138u,
  74u,
  78u,
  142u,
  143u,
  79u,
  141u,
  77u,
  76u,
  140u,
  68u,
  132u,
  133u,
  69u,
  135u,
  71u,
  70u,
  134u,
  130u,
  66u,
  67u,
  131u,
  65u,
  129u,
  128u,
  64u
}; // idb
const unsigned __int8 _FUNCTION___14720[18] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  100u,
  97u,
  116u,
  101u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14755[12] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 104u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___14784[30] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  104u,
  97u,
  115u,
  104u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  104u,
  97u,
  114u,
  100u,
  119u,
  97u,
  114u,
  101u,
  95u,
  105u,
  110u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14803[10] = { 99u, 104u, 101u, 99u, 107u, 95u, 102u, 97u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___14830[24] =
{
  103u,
  101u,
  116u,
  95u,
  105u,
  110u,
  100u,
  101u,
  120u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  112u,
  108u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14875[27] =
{
  103u,
  101u,
  116u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14883[20] =
{
  103u,
  101u,
  116u,
  95u,
  105u,
  100u,
  101u,
  97u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15022[24] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  111u,
  110u,
  101u,
  67u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15142[13] = { 114u, 101u, 97u, 100u, 95u, 116u, 101u, 115u, 116u, 95u, 73u, 68u, 0u }; // idb
const unsigned __int8 _FUNCTION___15153[13] = { 112u, 114u, 111u, 99u, 101u, 115u, 115u, 95u, 116u, 101u, 115u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___15215[27] =
{
  100u,
  117u,
  109u,
  112u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  97u,
  108u,
  108u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15419[27] =
{
  108u,
  111u,
  119u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  112u,
  114u,
  111u,
  99u,
  101u,
  115u,
  115u,
  95u,
  112u,
  97u,
  114u,
  109u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15465[15] =
{
  103u,
  101u,
  116u,
  95u,
  114u,
  101u,
  111u,
  112u,
  101u,
  110u,
  95u,
  112u,
  119u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15474[16] =
{
  115u,
  119u,
  105u,
  116u,
  99u,
  104u,
  95u,
  116u,
  111u,
  95u,
  109u,
  111u,
  100u,
  101u,
  48u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15485[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15510[24] =
{
  118u,
  111u,
  108u,
  116u,
  95u,
  100u,
  101u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  111u,
  114u,
  95u,
  109u,
  111u,
  100u,
  101u,
  48u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15527[24] =
{
  118u,
  111u,
  108u,
  116u,
  95u,
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  111u,
  114u,
  95u,
  109u,
  111u,
  100u,
  101u,
  48u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15538[12] = { 114u, 101u, 111u, 112u, 101u, 110u, 95u, 111u, 110u, 99u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___15553[16] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  95u,
  103u,
  117u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15566[30] =
{
  100u,
  101u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  97u,
  116u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15588[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  115u,
  121u,
  115u,
  116u,
  101u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15604[24] =
{
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15617[33] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  110u,
  117u,
  109u,
  95u,
  119u,
  105u,
  116u,
  104u,
  111u,
  117u,
  116u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  111u,
  102u,
  102u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15628[32] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  110u,
  117u,
  109u,
  95u,
  98u,
  121u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15638[15] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  110u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15656[26] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  51u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15668[24] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  108u,
  111u,
  99u,
  107u,
  95u,
  100u,
  101u,
  108u,
  97u,
  121u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15700[17] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  98u,
  109u,
  49u,
  51u,
  57u,
  51u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15726[9] = { 99u, 104u, 101u, 99u, 107u, 95u, 104u, 119u, 0u }; // idb
const unsigned __int8 _FUNCTION___15752[11] = { 110u, 111u, 110u, 99u, 101u, 95u, 99u, 97u, 108u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___15767[23] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  97u,
  110u,
  100u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15841[15] =
{
  115u,
  101u,
  116u,
  95u,
  117u,
  110u,
  117u,
  115u,
  101u,
  100u,
  95u,
  112u,
  108u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15871[21] =
{
  99u,
  104u,
  97u,
  110u,
  103u,
  101u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  112u,
  108u,
  108u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15888[24] =
{
  99u,
  104u,
  97u,
  110u,
  103u,
  101u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  112u,
  108u,
  108u,
  95u,
  98u,
  121u,
  95u,
  97u,
  105u,
  115u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15917[18] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15930[15] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  108u,
  108u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15962[23] =
{
  115u,
  99u,
  114u,
  101u,
  101u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  97u,
  114u,
  114u,
  97u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15981[21] =
{
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15994[30] =
{
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  98u,
  121u,
  95u,
  105u,
  110u,
  100u,
  101u,
  120u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16006[6] = { 99u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 _FUNCTION___16023[6] = { 115u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 _FUNCTION___16033[32] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16045[9] = { 105u, 110u, 105u, 116u, 95u, 112u, 105u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___16051[12] = { 115u, 101u, 116u, 95u, 116u, 105u, 109u, 101u, 111u, 117u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___16059[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16086[27] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  105u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16152[35] =
{
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  121u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  110u,
  101u,
  119u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16194[29] =
{
  108u,
  111u,
  119u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  104u,
  97u,
  110u,
  100u,
  108u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16300[23] =
{
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16312[31] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  95u,
  105u,
  110u,
  95u,
  102u,
  111u,
  114u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16327[23] =
{
  103u,
  101u,
  116u,
  95u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  95u,
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16367[14] =
{
  102u,
  105u,
  120u,
  95u,
  99u,
  104u,
  105u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16395[28] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16404[17] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16418[16] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16459[19] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  109u,
  105u,
  110u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16471[15] =
{
  98u,
  114u,
  105u,
  110u,
  103u,
  95u,
  117u,
  112u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16487[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16502[14] = { 99u, 104u, 101u, 99u, 107u, 95u, 102u, 97u, 110u, 95u, 110u, 117u, 109u, 0u }; // idb
const unsigned __int8 _FUNCTION___16512[19] =
{
  110u,
  101u,
  101u,
  100u,
  95u,
  109u,
  111u,
  100u,
  101u,
  50u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  117u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16527[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16291[21] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16567[13] = { 114u, 101u, 95u, 111u, 112u, 101u, 110u, 95u, 99u, 111u, 114u, 101u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___16573[13] = { 114u, 101u, 95u, 111u, 112u, 101u, 110u, 95u, 99u, 111u, 114u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___16593[22] =
{
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16637[9] = { 115u, 101u, 110u, 100u, 95u, 106u, 111u, 98u, 0u }; // idb
const unsigned __int8 _func___16681[18] =
{
  99u,
  111u,
  112u,
  121u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___16694[20] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16697[20] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16702[26] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  114u,
  101u,
  105u,
  110u,
  105u,
  116u,
  95u,
  100u,
  101u,
  118u,
  105u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___16709[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  100u,
  101u,
  116u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16735[16] =
{
  104u,
  97u,
  115u,
  104u,
  116u,
  101u,
  115u,
  116u,
  95u,
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___16763[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16775[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _func___16807[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16864[16] =
{
  103u,
  101u,
  116u,
  68u,
  105u,
  102u,
  102u,
  70u,
  114u,
  101u,
  113u,
  73u,
  110u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16900[22] =
{
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  116u,
  111u,
  95u,
  98u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16918[31] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  105u,
  110u,
  105u,
  116u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16931[21] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16959[26] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  102u,
  97u,
  115u,
  116u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14396[25] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  95u,
  99u,
  111u,
  100u,
  101u,
  95u,
  115u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14409[20] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  115u,
  101u,
  116u,
  95u,
  115u,
  116u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14417[20] =
{
  115u,
  99u,
  97u,
  110u,
  102u,
  114u,
  101u,
  113u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  99u,
  97u,
  108u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14451[36] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  111u,
  102u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  111u,
  110u,
  101u,
  95u,
  102u,
  105u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14461[19] =
{
  115u,
  99u,
  97u,
  110u,
  102u,
  114u,
  101u,
  113u,
  95u,
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  115u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___14465[19] =
{
  115u,
  99u,
  97u,
  110u,
  102u,
  114u,
  101u,
  113u,
  95u,
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14483[14] = { 78u, 111u, 110u, 99u, 101u, 95u, 77u, 97u, 116u, 99u, 104u, 95u, 49u, 0u }; // idb
const unsigned __int8 _FUNCTION___14574[18] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14620[20] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14674[23] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14678[37] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  97u,
  110u,
  100u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14811[32] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  112u,
  114u,
  105u,
  110u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  122u,
  101u,
  114u,
  111u,
  95u,
  99u,
  104u,
  105u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14908[21] =
{
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14994[38] =
{
  102u,
  111u,
  114u,
  99u,
  101u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  105u,
  115u,
  95u,
  97u,
  108u,
  108u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  102u,
  105u,
  110u,
  105u,
  115u,
  104u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15099[38] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  97u,
  118u,
  101u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  110u,
  101u,
  119u,
  95u,
  102u,
  111u,
  114u,
  109u,
  97u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15141[29] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  103u,
  101u,
  116u,
  95u,
  110u,
  101u,
  120u,
  116u,
  95u,
  98u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15176[25] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  102u,
  105u,
  110u,
  100u,
  95u,
  98u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15227[16] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15241[25] =
{
  115u,
  99u,
  97u,
  110u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  98u,
  121u,
  95u,
  99u,
  111u,
  108u,
  117u,
  109u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15292[32] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  112u,
  114u,
  105u,
  110u,
  116u,
  95u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  95u,
  99u,
  111u,
  108u,
  117u,
  109u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15323[25] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  103u,
  101u,
  116u,
  95u,
  110u,
  101u,
  120u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15390[38] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  97u,
  110u,
  100u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15420[31] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  112u,
  114u,
  105u,
  110u,
  116u,
  95u,
  99u,
  104u,
  105u,
  112u,
  95u,
  109u,
  97u,
  120u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15448[29] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  103u,
  101u,
  116u,
  95u,
  99u,
  104u,
  105u,
  112u,
  95u,
  109u,
  97u,
  120u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15570[30] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  103u,
  101u,
  116u,
  95u,
  105u,
  100u,
  101u,
  97u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15601[29] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  105u,
  100u,
  101u,
  97u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15632[21] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  105u,
  120u,
  95u,
  105u,
  100u,
  101u,
  97u,
  108u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15661[22] =
{
  97u,
  115u,
  105u,
  99u,
  95u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  115u,
  116u,
  97u,
  116u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15684[20] =
{
  97u,
  115u,
  105u,
  99u,
  95u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  115u,
  116u,
  97u,
  116u,
  95u,
  101u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15713[20] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  102u,
  111u,
  114u,
  95u,
  109u,
  111u,
  100u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15723[21] =
{
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  121u,
  95u,
  99u,
  111u,
  108u,
  117u,
  109u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15812[38] =
{
  98u,
  111u,
  97u,
  114u,
  100u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  97u,
  110u,
  100u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15856[25] =
{
  98u,
  111u,
  97u,
  114u,
  100u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  110u,
  101u,
  120u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15868[29] =
{
  98u,
  111u,
  97u,
  114u,
  100u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  99u,
  104u,
  105u,
  112u,
  95u,
  109u,
  97u,
  120u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15885[30] =
{
  98u,
  111u,
  97u,
  114u,
  100u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  105u,
  100u,
  101u,
  97u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15927[17] =
{
  98u,
  111u,
  97u,
  114u,
  100u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15937[16] =
{
  98u,
  111u,
  97u,
  114u,
  100u,
  115u,
  119u,
  101u,
  101u,
  112u,
  95u,
  116u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12640[12] = { 115u, 116u, 111u, 112u, 95u, 109u, 105u, 110u, 105u, 110u, 103u, 0u }; // idb
const unsigned __int8 _FUNCTION___12665[9] = { 112u, 111u, 119u, 101u, 114u, 95u, 111u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___12674[26] =
{
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  112u,
  114u,
  111u,
  116u,
  111u,
  99u,
  97u,
  108u,
  95u,
  116u,
  121u,
  112u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12681[11] = { 112u, 111u, 119u, 101u, 114u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___12690[20] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12696[29] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12708[28] =
{
  115u,
  101u,
  116u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  114u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12716[29] =
{
  115u,
  101u,
  116u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12724[29] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12732[29] =
{
  103u,
  101u,
  116u,
  95u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12740[28] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  114u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12753[18] =
{
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  112u,
  108u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12787[15] =
{
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  99u,
  109u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12883[18] =
{
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12890[33] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  105u,
  105u,
  99u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12897[33] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  105u,
  105u,
  99u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12904[25] =
{
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  98u,
  121u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12911[26] =
{
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  98u,
  121u,
  95u,
  105u,
  105u,
  99u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12925[33] =
{
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12932[42] =
{
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12971[39] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  99u,
  117u,
  115u,
  116u,
  111u,
  109u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12979[48] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  99u,
  117u,
  115u,
  116u,
  111u,
  109u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12986[40] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12992[49] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13020[48] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  114u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13034[20] =
{
  103u,
  101u,
  116u,
  95u,
  97u,
  118u,
  101u,
  114u,
  97u,
  103u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13065[33] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  116u,
  49u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13098[29] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  49u,
  49u,
  0u
}; // idb
const int hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // idb
const unsigned __int8 _func___11532[10] = { 103u, 101u, 116u, 95u, 112u, 114u, 111u, 120u, 121u, 0u }; // idb
const unsigned __int8 hex_11542[16] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u
}; // idb
const unsigned __int8 _func___11552[8] = { 98u, 105u, 110u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 _func___11664[7] = { 116u, 113u, 95u, 110u, 101u, 119u, 0u }; // idb
const unsigned __int8 _func___11677[14] =
{
  116u,
  113u,
  95u,
  102u,
  114u,
  101u,
  101u,
  122u,
  101u,
  116u,
  104u,
  97u,
  119u,
  0u
}; // idb
const unsigned __int8 _func___11690[8] = { 116u, 113u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _FUNCTION___11692[8] = { 116u, 113u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _FUNCTION___11703[7] = { 116u, 113u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___11704[7] = { 116u, 113u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___11716[16] =
{
  116u,
  104u,
  114u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  99u,
  114u,
  101u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___11918[13] = { 115u, 116u, 114u, 97u, 116u, 117u, 109u, 95u, 115u, 101u, 110u, 100u, 0u }; // idb
const unsigned __int8 _func___11950[11] = { 99u, 108u, 101u, 97u, 114u, 95u, 115u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___11967[14] = { 114u, 101u, 99u, 97u, 108u, 108u, 111u, 99u, 95u, 115u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___12023[13] = { 112u, 97u, 114u, 115u, 101u, 95u, 110u, 111u, 116u, 105u, 102u, 121u, 0u }; // idb
const unsigned __int8 _FUNCTION___12063[21] =
{
  112u,
  114u,
  111u,
  99u,
  101u,
  115u,
  115u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___12102[11] = { 112u, 97u, 114u, 115u, 101u, 95u, 100u, 105u, 102u, 102u, 0u }; // idb
const unsigned __int8 _func___12113[17] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  101u,
  120u,
  116u,
  114u,
  97u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___12138[16] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  114u,
  101u,
  99u,
  111u,
  110u,
  110u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___12253[17] =
{
  115u,
  111u,
  99u,
  107u,
  115u,
  53u,
  95u,
  110u,
  101u,
  103u,
  111u,
  116u,
  105u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___12281[17] =
{
  115u,
  111u,
  99u,
  107u,
  115u,
  52u,
  95u,
  110u,
  101u,
  103u,
  111u,
  116u,
  105u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___12306[21] =
{
  115u,
  101u,
  116u,
  117u,
  112u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  111u,
  99u,
  107u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___12358[16] =
{
  115u,
  117u,
  115u,
  112u,
  101u,
  110u,
  100u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___12407[17] =
{
  105u,
  110u,
  105u,
  116u,
  105u,
  97u,
  116u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___12511[18] =
{
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___12520[22] =
{
  99u,
  103u,
  95u,
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12130[8] = { 115u, 101u, 116u, 95u, 105u, 105u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___12168[36] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  97u,
  110u,
  100u,
  95u,
  106u,
  111u,
  98u,
  95u,
  105u,
  100u,
  95u,
  115u,
  116u,
  111u,
  114u,
  101u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12174[22] =
{
  103u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12179[22] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12191[26] =
{
  103u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12196[26] =
{
  115u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12204[20] =
{
  115u,
  101u,
  116u,
  95u,
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12225[16] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12230[16] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12236[17] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  111u,
  110u,
  95u,
  112u,
  108u,
  117u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12245[21] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  114u,
  100u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12255[14] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  115u,
  112u,
  101u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12277[21] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12282[21] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12299[22] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12305[22] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12311[21] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12320[24] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  95u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12337[21] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12346[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12351[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12357[11] = { 103u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___12362[11] = { 115u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___12373[15] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12379[25] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12385[27] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12402[25] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12407[27] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12422[15] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12427[15] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12433[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12438[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12449[20] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  114u,
  101u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12455[38] =
{
  103u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12460[38] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12466[16] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12472[16] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12478[22] =
{
  103u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12483[22] =
{
  115u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12489[25] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12494[25] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12500[22] =
{
  103u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12506[22] =
{
  115u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12534[25] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12539[25] =
{
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12550[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  97u,
  120u,
  105u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
char byte_8A828[4] = { '\0', '\0', '\0', '\0' }; // weak
char a0_1[2] = "0"; // weak
const unsigned __int8 bench_hidiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    50u,
    98u,
    49u,
    53u,
    49u,
    52u,
    101u,
    55u,
    98u,
    54u,
    53u,
    54u,
    53u,
    57u,
    52u,
    49u,
    101u,
    53u,
    56u,
    50u,
    52u,
    102u,
    48u,
    56u,
    52u,
    50u,
    57u,
    50u,
    49u,
    54u,
    52u,
    101u,
    99u,
    53u,
    102u,
    57u,
    55u,
    101u,
    55u,
    101u,
    97u,
    50u,
    48u,
    99u,
    52u,
    57u,
    52u,
    98u,
    100u,
    57u,
    54u,
    101u,
    53u,
    50u,
    52u,
    100u,
    52u,
    55u,
    56u,
    57u,
    55u,
    55u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    50u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    98u,
    49u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    101u,
    52u,
    101u,
    51u,
    98u,
    101u,
    99u,
    99u,
    48u,
    49u,
    48u,
    54u,
    52u,
    100u,
    56u,
    48u,
    56u,
    50u,
    54u,
    57u,
    98u,
    51u,
    51u,
    48u,
    102u,
    52u,
    48u,
    102u,
    52u,
    100u,
    101u,
    56u,
    50u,
    100u,
    99u,
    57u,
    50u,
    101u,
    56u,
    57u,
    52u,
    100u,
    54u,
    51u,
    53u,
    48u,
    50u,
    53u,
    100u,
    97u,
    97u,
    51u,
    101u,
    50u,
    101u,
    50u,
    99u,
    52u,
    49u,
    48u,
    98u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    57u,
    101u,
    98u,
    98u,
    99u,
    101u,
    50u,
    102u,
    53u,
    102u,
    48u,
    100u,
    54u,
    99u,
    99u,
    48u,
    97u,
    99u,
    97u,
    50u,
    56u,
    52u,
    101u,
    99u,
    98u,
    49u,
    48u,
    53u,
    57u,
    99u,
    56u,
    53u,
    54u,
    101u,
    102u,
    50u,
    102u,
    55u,
    102u,
    52u,
    50u,
    101u,
    55u,
    101u,
    100u,
    100u,
    52u,
    48u,
    51u,
    100u,
    50u,
    52u,
    54u,
    55u,
    53u,
    52u,
    101u,
    101u,
    52u,
    99u,
    57u,
    48u,
    53u,
    97u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    102u,
    100u,
    97u,
    48u,
    51u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    55u,
    56u,
    100u,
    97u,
    102u,
    49u,
    98u,
    53u,
    101u,
    98u,
    51u,
    51u,
    57u,
    55u,
    97u,
    102u,
    49u,
    99u,
    48u,
    48u,
    100u,
    98u,
    100u,
    57u,
    98u,
    48u,
    54u,
    54u,
    53u,
    57u,
    99u,
    100u,
    99u,
    48u,
    52u,
    49u,
    56u,
    51u,
    99u,
    56u,
    98u,
    97u,
    97u,
    102u,
    53u,
    98u,
    101u,
    49u,
    100u,
    98u,
    102u,
    51u,
    50u,
    102u,
    55u,
    57u,
    101u,
    48u,
    48u,
    52u,
    53u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    48u,
    52u,
    54u,
    53u,
    48u,
    97u,
    56u,
    101u,
    55u,
    52u,
    56u,
    100u,
    50u,
    101u,
    54u,
    102u,
    100u,
    101u,
    56u,
    54u,
    97u,
    56u,
    97u,
    57u,
    50u,
    48u,
    98u,
    50u,
    56u,
    53u,
    102u,
    51u,
    101u,
    50u,
    50u,
    51u,
    57u,
    56u,
    102u,
    53u,
    56u,
    51u,
    55u,
    48u,
    48u,
    50u,
    51u,
    54u,
    57u,
    53u,
    56u,
    51u,
    50u,
    51u,
    101u,
    102u,
    57u,
    101u,
    97u,
    56u,
    51u,
    50u,
    49u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    52u,
    53u,
    55u,
    48u,
    101u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    49u,
    100u,
    54u,
    53u,
    52u,
    97u,
    101u,
    50u,
    98u,
    48u,
    54u,
    102u,
    50u,
    49u,
    57u,
    99u,
    99u,
    102u,
    52u,
    54u,
    48u,
    49u,
    57u,
    51u,
    51u,
    102u,
    97u,
    98u,
    52u,
    48u,
    56u,
    100u,
    101u,
    49u,
    99u,
    51u,
    98u,
    55u,
    99u,
    56u,
    99u,
    57u,
    99u,
    56u,
    53u,
    101u,
    48u,
    51u,
    50u,
    51u,
    49u,
    100u,
    52u,
    97u,
    97u,
    102u,
    53u,
    97u,
    50u,
    54u,
    99u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    52u,
    98u,
    51u,
    57u,
    49u,
    51u,
    52u,
    99u,
    50u,
    57u,
    51u,
    48u,
    100u,
    50u,
    102u,
    50u,
    101u,
    55u,
    51u,
    51u,
    57u,
    102u,
    57u,
    100u,
    53u,
    48u,
    50u,
    99u,
    55u,
    55u,
    54u,
    99u,
    52u,
    52u,
    100u,
    54u,
    101u,
    101u,
    53u,
    57u,
    57u,
    102u,
    55u,
    101u,
    102u,
    101u,
    98u,
    101u,
    99u,
    54u,
    99u,
    57u,
    98u,
    98u,
    100u,
    48u,
    52u,
    55u,
    56u,
    55u,
    97u,
    97u,
    101u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    50u,
    55u,
    49u,
    48u,
    102u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    57u,
    52u,
    101u,
    54u,
    48u,
    99u,
    49u,
    49u,
    56u,
    48u,
    48u,
    50u,
    50u,
    102u,
    51u,
    51u,
    55u,
    50u,
    51u,
    50u,
    97u,
    98u,
    51u,
    100u,
    50u,
    57u,
    56u,
    102u,
    56u,
    51u,
    56u,
    51u,
    48u,
    52u,
    98u,
    54u,
    48u,
    48u,
    56u,
    97u,
    98u,
    50u,
    51u,
    55u,
    99u,
    102u,
    55u,
    101u,
    49u,
    55u,
    49u,
    55u,
    102u,
    49u,
    57u,
    51u,
    51u,
    52u,
    48u,
    55u,
    101u,
    53u,
    57u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    53u,
    98u,
    56u,
    50u,
    49u,
    102u,
    98u,
    48u,
    98u,
    50u,
    54u,
    100u,
    54u,
    51u,
    98u,
    48u,
    48u,
    99u,
    99u,
    50u,
    54u,
    101u,
    55u,
    97u,
    99u,
    52u,
    100u,
    54u,
    99u,
    102u,
    100u,
    49u,
    100u,
    51u,
    102u,
    99u,
    49u,
    48u,
    57u,
    98u,
    48u,
    100u,
    98u,
    49u,
    56u,
    56u,
    101u,
    55u,
    101u,
    55u,
    57u,
    50u,
    101u,
    51u,
    100u,
    49u,
    56u,
    51u,
    52u,
    50u,
    57u,
    49u,
    57u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    100u,
    52u,
    56u,
    48u,
    53u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    57u,
    48u,
    101u,
    97u,
    99u,
    54u,
    49u,
    54u,
    52u,
    50u,
    57u,
    52u,
    57u,
    99u,
    48u,
    48u,
    100u,
    49u,
    55u,
    102u,
    55u,
    99u,
    100u,
    53u,
    57u,
    56u,
    48u,
    97u,
    98u,
    101u,
    100u,
    98u,
    56u,
    54u,
    52u,
    55u,
    102u,
    99u,
    53u,
    100u,
    102u,
    57u,
    57u,
    53u,
    53u,
    100u,
    99u,
    102u,
    101u,
    52u,
    100u,
    53u,
    54u,
    97u,
    53u,
    48u,
    97u,
    48u,
    99u,
    53u,
    54u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    101u,
    57u,
    100u,
    57u,
    52u,
    98u,
    102u,
    53u,
    97u,
    48u,
    97u,
    98u,
    55u,
    98u,
    50u,
    48u,
    50u,
    100u,
    51u,
    57u,
    101u,
    49u,
    50u,
    48u,
    48u,
    97u,
    102u,
    57u,
    54u,
    48u,
    55u,
    52u,
    101u,
    52u,
    102u,
    54u,
    52u,
    49u,
    102u,
    52u,
    101u,
    53u,
    53u,
    101u,
    51u,
    101u,
    57u,
    101u,
    51u,
    97u,
    101u,
    101u,
    55u,
    50u,
    97u,
    97u,
    48u,
    48u,
    97u,
    55u,
    48u,
    101u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    48u,
    102u,
    55u,
    48u,
    49u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    52u,
    55u,
    55u,
    99u,
    97u,
    56u,
    53u,
    51u,
    54u,
    55u,
    48u,
    50u,
    101u,
    97u,
    99u,
    98u,
    100u,
    54u,
    53u,
    97u,
    54u,
    97u,
    49u,
    54u,
    50u,
    99u,
    102u,
    101u,
    57u,
    48u,
    100u,
    54u,
    50u,
    48u,
    49u,
    54u,
    97u,
    49u,
    52u,
    102u,
    102u,
    101u,
    53u,
    56u,
    100u,
    53u,
    50u,
    98u,
    55u,
    100u,
    100u,
    52u,
    99u,
    51u,
    54u,
    50u,
    56u,
    97u,
    50u,
    55u,
    101u,
    53u,
    98u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    98u,
    98u,
    98u,
    50u,
    53u,
    48u,
    102u,
    50u,
    100u,
    99u,
    50u,
    51u,
    55u,
    49u,
    55u,
    101u,
    56u,
    49u,
    57u,
    50u,
    99u,
    48u,
    98u,
    56u,
    98u,
    101u,
    99u,
    54u,
    97u,
    49u,
    55u,
    53u,
    99u,
    100u,
    48u,
    53u,
    57u,
    101u,
    52u,
    48u,
    56u,
    57u,
    100u,
    51u,
    50u,
    53u,
    48u,
    48u,
    54u,
    101u,
    97u,
    101u,
    101u,
    51u,
    52u,
    52u,
    54u,
    50u,
    53u,
    52u,
    99u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    57u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    54u,
    57u,
    56u,
    48u,
    99u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    56u,
    100u,
    98u,
    53u,
    57u,
    57u,
    100u,
    54u,
    98u,
    55u,
    97u,
    53u,
    53u,
    102u,
    100u,
    54u,
    49u,
    100u,
    52u,
    50u,
    52u,
    52u,
    97u,
    51u,
    100u,
    102u,
    97u,
    52u,
    54u,
    53u,
    48u,
    53u,
    53u,
    101u,
    97u,
    100u,
    54u,
    98u,
    53u,
    99u,
    48u,
    97u,
    51u,
    55u,
    99u,
    55u,
    97u,
    51u,
    100u,
    52u,
    53u,
    53u,
    53u,
    98u,
    53u,
    56u,
    101u,
    57u,
    57u,
    48u,
    54u,
    53u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    50u,
    101u,
    49u,
    55u,
    98u,
    97u,
    98u,
    100u,
    52u,
    48u,
    56u,
    57u,
    98u,
    50u,
    48u,
    52u,
    55u,
    57u,
    55u,
    99u,
    101u,
    98u,
    100u,
    97u,
    55u,
    100u,
    99u,
    54u,
    101u,
    50u,
    55u,
    55u,
    57u,
    53u,
    48u,
    101u,
    97u,
    98u,
    49u,
    98u,
    50u,
    57u,
    48u,
    56u,
    57u,
    57u,
    49u,
    97u,
    101u,
    49u,
    100u,
    55u,
    50u,
    51u,
    51u,
    53u,
    102u,
    56u,
    50u,
    100u,
    50u,
    48u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    102u,
    50u,
    100u,
    48u,
    57u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    99u,
    55u,
    100u,
    54u,
    48u,
    49u,
    99u,
    101u,
    51u,
    98u,
    48u,
    49u,
    101u,
    53u,
    54u,
    57u,
    97u,
    52u,
    57u,
    53u,
    48u,
    56u,
    100u,
    53u,
    52u,
    49u,
    98u,
    98u,
    99u,
    98u,
    97u,
    57u,
    98u,
    51u,
    99u,
    56u,
    51u,
    57u,
    52u,
    98u,
    49u,
    56u,
    51u,
    52u,
    53u,
    50u,
    51u,
    101u,
    102u,
    49u,
    101u,
    53u,
    99u,
    98u,
    50u,
    99u,
    54u,
    48u,
    98u,
    100u,
    51u,
    52u,
    97u,
    51u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    56u,
    56u,
    98u,
    54u,
    102u,
    48u,
    50u,
    50u,
    49u,
    52u,
    52u,
    100u,
    98u,
    49u,
    51u,
    52u,
    97u,
    102u,
    49u,
    98u,
    99u,
    56u,
    101u,
    54u,
    49u,
    98u,
    51u,
    56u,
    53u,
    99u,
    97u,
    51u,
    55u,
    99u,
    97u,
    101u,
    48u,
    51u,
    56u,
    99u,
    49u,
    100u,
    49u,
    54u,
    53u,
    97u,
    101u,
    57u,
    56u,
    99u,
    52u,
    57u,
    54u,
    98u,
    51u,
    98u,
    52u,
    49u,
    101u,
    56u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    97u,
    56u,
    101u,
    97u,
    48u,
    101u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    49u,
    48u,
    55u,
    54u,
    49u,
    101u,
    57u,
    55u,
    101u,
    54u,
    55u,
    98u,
    52u,
    57u,
    52u,
    102u,
    100u,
    53u,
    52u,
    55u,
    99u,
    102u,
    101u,
    57u,
    102u,
    102u,
    98u,
    98u,
    51u,
    54u,
    56u,
    57u,
    51u,
    100u,
    97u,
    55u,
    97u,
    101u,
    99u,
    55u,
    53u,
    99u,
    54u,
    98u,
    53u,
    49u,
    98u,
    56u,
    100u,
    53u,
    102u,
    51u,
    56u,
    102u,
    56u,
    55u,
    98u,
    53u,
    100u,
    54u,
    51u,
    99u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    49u,
    102u,
    48u,
    99u,
    102u,
    100u,
    102u,
    53u,
    97u,
    100u,
    56u,
    50u,
    52u,
    56u,
    102u,
    99u,
    52u,
    53u,
    50u,
    48u,
    102u,
    51u,
    98u,
    98u,
    48u,
    98u,
    50u,
    48u,
    52u,
    48u,
    50u,
    50u,
    54u,
    52u,
    51u,
    48u,
    51u,
    52u,
    56u,
    99u,
    100u,
    100u,
    101u,
    102u,
    102u,
    53u,
    99u,
    97u,
    57u,
    49u,
    56u,
    49u,
    98u,
    101u,
    101u,
    98u,
    55u,
    56u,
    56u,
    55u,
    48u,
    100u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    48u,
    100u,
    54u,
    48u,
    48u,
    102u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    49u,
    97u,
    56u,
    100u,
    51u,
    53u,
    52u,
    97u,
    55u,
    101u,
    56u,
    98u,
    49u,
    51u,
    101u,
    99u,
    52u,
    55u,
    102u,
    52u,
    99u,
    51u,
    100u,
    57u,
    48u,
    55u,
    100u,
    48u,
    48u,
    57u,
    52u,
    53u,
    97u,
    54u,
    49u,
    101u,
    56u,
    54u,
    48u,
    53u,
    57u,
    102u,
    52u,
    57u,
    52u,
    51u,
    101u,
    52u,
    50u,
    99u,
    49u,
    101u,
    53u,
    50u,
    51u,
    57u,
    56u,
    101u,
    98u,
    97u,
    53u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    50u,
    97u,
    49u,
    54u,
    100u,
    51u,
    56u,
    99u,
    99u,
    48u,
    101u,
    49u,
    51u,
    101u,
    52u,
    98u,
    49u,
    54u,
    100u,
    57u,
    49u,
    55u,
    98u,
    102u,
    102u,
    52u,
    99u,
    51u,
    52u,
    55u,
    50u,
    55u,
    100u,
    101u,
    98u,
    51u,
    98u,
    53u,
    99u,
    53u,
    48u,
    101u,
    52u,
    50u,
    52u,
    102u,
    98u,
    56u,
    52u,
    53u,
    51u,
    102u,
    102u,
    57u,
    98u,
    50u,
    97u,
    100u,
    99u,
    98u,
    52u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    50u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    102u,
    49u,
    48u,
    48u,
    50u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    99u,
    54u,
    55u,
    100u,
    51u,
    56u,
    102u,
    51u,
    49u,
    102u,
    53u,
    56u,
    57u,
    98u,
    49u,
    56u,
    98u,
    57u,
    100u,
    56u,
    101u,
    53u,
    51u,
    49u,
    98u,
    57u,
    57u,
    52u,
    99u,
    101u,
    53u,
    55u,
    51u,
    51u,
    99u,
    48u,
    50u,
    49u,
    97u,
    48u,
    51u,
    100u,
    56u,
    56u,
    100u,
    51u,
    56u,
    54u,
    49u,
    49u,
    101u,
    101u,
    54u,
    98u,
    52u,
    99u,
    50u,
    55u,
    49u,
    48u,
    97u,
    53u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    56u,
    54u,
    48u,
    52u,
    55u,
    49u,
    50u,
    55u,
    55u,
    98u,
    52u,
    97u,
    57u,
    51u,
    102u,
    101u,
    97u,
    50u,
    97u,
    56u,
    98u,
    54u,
    100u,
    56u,
    99u,
    50u,
    56u,
    49u,
    102u,
    97u,
    98u,
    55u,
    98u,
    100u,
    101u,
    51u,
    98u,
    55u,
    56u,
    102u,
    50u,
    97u,
    99u,
    100u,
    49u,
    98u,
    102u,
    100u,
    99u,
    56u,
    57u,
    100u,
    52u,
    54u,
    52u,
    101u,
    100u,
    51u,
    98u,
    98u,
    51u,
    99u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    53u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    100u,
    51u,
    48u,
    48u,
    52u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    51u,
    55u,
    54u,
    56u,
    54u,
    99u,
    54u,
    49u,
    49u,
    97u,
    97u,
    101u,
    52u,
    51u,
    57u,
    55u,
    99u,
    55u,
    99u,
    48u,
    52u,
    98u,
    50u,
    99u,
    49u,
    57u,
    48u,
    55u,
    48u,
    56u,
    52u,
    53u,
    51u,
    100u,
    48u,
    48u,
    101u,
    56u,
    99u,
    57u,
    53u,
    54u,
    51u,
    53u,
    50u,
    53u,
    54u,
    49u,
    48u,
    99u,
    51u,
    49u,
    98u,
    97u,
    52u,
    54u,
    101u,
    56u,
    48u,
    100u,
    98u,
    99u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    51u,
    55u,
    48u,
    50u,
    51u,
    48u,
    54u,
    48u,
    55u,
    57u,
    57u,
    56u,
    102u,
    98u,
    98u,
    100u,
    49u,
    48u,
    50u,
    55u,
    53u,
    99u,
    53u,
    56u,
    57u,
    48u,
    56u,
    56u,
    53u,
    102u,
    99u,
    100u,
    56u,
    49u,
    98u,
    54u,
    56u,
    48u,
    49u,
    56u,
    98u,
    97u,
    50u,
    51u,
    55u,
    51u,
    97u,
    98u,
    102u,
    48u,
    102u,
    57u,
    51u,
    97u,
    48u,
    54u,
    100u,
    48u,
    50u,
    97u,
    98u,
    50u,
    56u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    51u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    51u,
    55u,
    55u,
    53u,
    48u,
    98u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    102u,
    100u,
    100u,
    97u,
    57u,
    53u,
    50u,
    100u,
    97u,
    54u,
    97u,
    98u,
    100u,
    55u,
    48u,
    48u,
    50u,
    50u,
    97u,
    54u,
    101u,
    53u,
    102u,
    50u,
    98u,
    57u,
    100u,
    99u,
    53u,
    101u,
    49u,
    98u,
    54u,
    54u,
    48u,
    49u,
    49u,
    49u,
    50u,
    56u,
    99u,
    51u,
    102u,
    97u,
    50u,
    52u,
    57u,
    102u,
    48u,
    98u,
    55u,
    52u,
    51u,
    57u,
    102u,
    48u,
    48u,
    100u,
    53u,
    57u,
    52u,
    51u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    97u,
    50u,
    99u,
    57u,
    49u,
    102u,
    99u,
    52u,
    49u,
    50u,
    53u,
    52u,
    53u,
    51u,
    57u,
    97u,
    53u,
    98u,
    50u,
    97u,
    50u,
    55u,
    98u,
    101u,
    50u,
    56u,
    100u,
    101u,
    50u,
    97u,
    54u,
    49u,
    56u,
    55u,
    101u,
    50u,
    97u,
    102u,
    51u,
    102u,
    49u,
    50u,
    57u,
    100u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    52u,
    53u,
    102u,
    102u,
    99u,
    53u,
    49u,
    50u,
    100u,
    53u,
    99u,
    97u,
    51u,
    98u,
    99u,
    52u,
    100u,
    50u,
    48u,
    54u,
    51u,
    100u,
    100u,
    51u,
    97u,
    102u,
    49u,
    54u,
    54u,
    57u,
    99u,
    50u,
    57u,
    54u,
    97u,
    101u,
    49u,
    50u,
    54u,
    97u,
    53u,
    97u,
    50u,
    101u,
    102u,
    56u,
    57u,
    54u,
    100u,
    49u,
    101u,
    49u,
    57u,
    48u,
    99u,
    101u,
    100u,
    102u,
    54u,
    55u,
    98u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    53u,
    53u,
    98u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    48u,
    57u,
    52u,
    100u,
    54u,
    99u,
    98u,
    101u,
    55u,
    54u,
    53u,
    51u,
    56u,
    97u,
    56u,
    56u,
    54u,
    49u,
    50u,
    54u,
    50u,
    52u,
    102u,
    99u,
    53u,
    101u,
    54u,
    53u,
    53u,
    99u,
    99u,
    52u,
    48u,
    53u,
    99u,
    98u,
    56u,
    49u,
    57u,
    56u,
    100u,
    99u,
    97u,
    100u,
    53u,
    49u,
    54u,
    98u,
    56u,
    56u,
    100u,
    98u,
    97u,
    99u,
    53u,
    98u,
    102u,
    56u,
    98u,
    57u,
    48u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    99u,
    53u,
    52u,
    56u,
    56u,
    49u,
    53u,
    49u,
    50u,
    55u,
    99u,
    49u,
    50u,
    53u,
    49u,
    52u,
    55u,
    97u,
    102u,
    57u,
    49u,
    99u,
    51u,
    53u,
    54u,
    99u,
    50u,
    57u,
    51u,
    102u,
    48u,
    100u,
    101u,
    102u,
    98u,
    100u,
    50u,
    55u,
    55u,
    49u,
    102u,
    56u,
    100u,
    99u,
    51u,
    98u,
    49u,
    49u,
    52u,
    50u,
    98u,
    51u,
    54u,
    55u,
    53u,
    50u,
    56u,
    54u,
    53u,
    54u,
    100u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    54u,
    55u,
    55u,
    48u,
    97u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    98u,
    100u,
    98u,
    98u,
    51u,
    98u,
    49u,
    98u,
    101u,
    55u,
    50u,
    49u,
    54u,
    56u,
    55u,
    50u,
    101u,
    97u,
    55u,
    56u,
    55u,
    54u,
    50u,
    55u,
    98u,
    48u,
    51u,
    99u,
    51u,
    56u,
    57u,
    97u,
    53u,
    50u,
    55u,
    52u,
    53u,
    49u,
    102u,
    54u,
    100u,
    100u,
    56u,
    51u,
    50u,
    100u,
    56u,
    53u,
    52u,
    48u,
    56u,
    55u,
    52u,
    51u,
    48u,
    54u,
    102u,
    57u,
    99u,
    48u,
    55u,
    99u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    101u,
    102u,
    55u,
    53u,
    56u,
    55u,
    55u,
    48u,
    98u,
    98u,
    57u,
    48u,
    99u,
    53u,
    98u,
    49u,
    51u,
    55u,
    54u,
    57u,
    99u,
    53u,
    98u,
    54u,
    49u,
    97u,
    102u,
    102u,
    98u,
    51u,
    50u,
    50u,
    98u,
    50u,
    52u,
    99u,
    55u,
    52u,
    55u,
    53u,
    55u,
    51u,
    98u,
    51u,
    56u,
    101u,
    98u,
    101u,
    50u,
    101u,
    101u,
    56u,
    49u,
    55u,
    52u,
    56u,
    100u,
    48u,
    98u,
    53u,
    53u,
    55u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    48u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    57u,
    102u,
    48u,
    48u,
    49u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    97u,
    99u,
    56u,
    101u,
    101u,
    97u,
    54u,
    51u,
    50u,
    56u,
    53u,
    51u,
    53u,
    51u,
    57u,
    52u,
    52u,
    101u,
    52u,
    48u,
    101u,
    101u,
    99u,
    53u,
    52u,
    100u,
    50u,
    100u,
    100u,
    54u,
    99u,
    100u,
    48u,
    57u,
    57u,
    52u,
    98u,
    52u,
    52u,
    55u,
    52u,
    50u,
    57u,
    98u,
    98u,
    48u,
    101u,
    100u,
    48u,
    53u,
    57u,
    56u,
    100u,
    51u,
    56u,
    102u,
    52u,
    50u,
    100u,
    97u,
    48u,
    101u,
    50u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
const unsigned __int8 bench_lodiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    49u,
    102u,
    53u,
    48u,
    50u,
    99u,
    98u,
    51u,
    101u,
    57u,
    102u,
    100u,
    98u,
    48u,
    53u,
    51u,
    50u,
    51u,
    48u,
    101u,
    99u,
    49u,
    50u,
    97u,
    52u,
    57u,
    53u,
    52u,
    99u,
    49u,
    48u,
    50u,
    49u,
    97u,
    54u,
    98u,
    51u,
    53u,
    56u,
    54u,
    50u,
    98u,
    53u,
    101u,
    50u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    52u,
    100u,
    49u,
    98u,
    56u,
    51u,
    97u,
    101u,
    52u,
    52u,
    48u,
    53u,
    55u,
    48u,
    50u,
    53u,
    101u,
    56u,
    99u,
    53u,
    98u,
    53u,
    55u,
    53u,
    54u,
    98u,
    52u,
    52u,
    102u,
    48u,
    52u,
    100u,
    102u,
    53u,
    102u,
    102u,
    102u,
    101u,
    52u,
    97u,
    55u,
    97u,
    51u,
    48u,
    101u,
    53u,
    99u,
    49u,
    50u,
    100u,
    49u,
    50u,
    97u,
    57u,
    55u,
    97u,
    55u,
    97u,
    52u,
    99u,
    50u,
    101u,
    97u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    54u,
    100u,
    54u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    48u,
    56u,
    102u,
    55u,
    101u,
    49u,
    52u,
    99u,
    53u,
    48u,
    100u,
    97u,
    100u,
    55u,
    55u,
    100u,
    99u,
    50u,
    51u,
    56u,
    98u,
    52u,
    100u,
    98u,
    50u,
    57u,
    48u,
    49u,
    97u,
    48u,
    53u,
    55u,
    56u,
    101u,
    54u,
    53u,
    55u,
    98u,
    49u,
    57u,
    53u,
    52u,
    55u,
    55u,
    57u,
    97u,
    98u,
    57u,
    99u,
    100u,
    56u,
    50u,
    97u,
    55u,
    51u,
    56u,
    50u,
    57u,
    101u,
    100u,
    102u,
    55u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    49u,
    97u,
    49u,
    55u,
    52u,
    50u,
    53u,
    52u,
    97u,
    54u,
    53u,
    57u,
    51u,
    102u,
    102u,
    98u,
    97u,
    57u,
    56u,
    55u,
    102u,
    54u,
    56u,
    102u,
    101u,
    50u,
    54u,
    101u,
    55u,
    49u,
    54u,
    101u,
    51u,
    99u,
    49u,
    50u,
    57u,
    97u,
    55u,
    102u,
    51u,
    51u,
    97u,
    57u,
    99u,
    52u,
    51u,
    97u,
    101u,
    55u,
    101u,
    99u,
    102u,
    57u,
    48u,
    99u,
    56u,
    99u,
    100u,
    48u,
    100u,
    50u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    101u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    102u,
    56u,
    49u,
    48u,
    48u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    55u,
    48u,
    48u,
    97u,
    101u,
    101u,
    100u,
    97u,
    100u,
    97u,
    50u,
    98u,
    51u,
    56u,
    55u,
    55u,
    57u,
    48u,
    48u,
    98u,
    53u,
    56u,
    97u,
    49u,
    56u,
    51u,
    99u,
    52u,
    50u,
    99u,
    52u,
    48u,
    57u,
    52u,
    57u,
    57u,
    53u,
    54u,
    98u,
    98u,
    56u,
    98u,
    52u,
    97u,
    56u,
    100u,
    50u,
    49u,
    52u,
    56u,
    49u,
    102u,
    56u,
    57u,
    51u,
    54u,
    98u,
    53u,
    55u,
    50u,
    57u,
    50u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    51u,
    56u,
    99u,
    102u,
    52u,
    98u,
    54u,
    49u,
    100u,
    102u,
    102u,
    55u,
    52u,
    101u,
    51u,
    99u,
    50u,
    54u,
    98u,
    50u,
    100u,
    56u,
    48u,
    48u,
    52u,
    53u,
    48u,
    54u,
    52u,
    101u,
    56u,
    97u,
    98u,
    52u,
    56u,
    48u,
    50u,
    53u,
    50u,
    49u,
    98u,
    97u,
    98u,
    50u,
    99u,
    100u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    49u,
    101u,
    101u,
    102u,
    54u,
    52u,
    97u,
    55u,
    101u,
    102u,
    52u,
    101u,
    52u,
    55u,
    99u,
    100u,
    97u,
    49u,
    54u,
    101u,
    57u,
    54u,
    54u,
    55u,
    51u,
    49u,
    57u,
    55u,
    100u,
    51u,
    54u,
    99u,
    55u,
    50u,
    51u,
    53u,
    97u,
    52u,
    97u,
    97u,
    100u,
    100u,
    50u,
    51u,
    99u,
    50u,
    49u,
    97u,
    51u,
    56u,
    99u,
    101u,
    53u,
    51u,
    56u,
    50u,
    55u,
    100u,
    49u,
    102u,
    56u,
    98u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    57u,
    54u,
    98u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    51u,
    48u,
    99u,
    102u,
    55u,
    97u,
    54u,
    98u,
    56u,
    97u,
    56u,
    53u,
    101u,
    98u,
    49u,
    99u,
    99u,
    48u,
    49u,
    55u,
    98u,
    49u,
    48u,
    57u,
    100u,
    50u,
    51u,
    99u,
    51u,
    57u,
    50u,
    52u,
    54u,
    52u,
    102u,
    57u,
    57u,
    97u,
    97u,
    56u,
    99u,
    48u,
    50u,
    48u,
    101u,
    97u,
    49u,
    48u,
    55u,
    99u,
    53u,
    50u,
    53u,
    98u,
    54u,
    55u,
    49u,
    97u,
    100u,
    100u,
    101u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    101u,
    50u,
    99u,
    54u,
    98u,
    57u,
    50u,
    54u,
    52u,
    54u,
    56u,
    53u,
    54u,
    53u,
    101u,
    53u,
    50u,
    52u,
    97u,
    98u,
    55u,
    99u,
    50u,
    102u,
    49u,
    49u,
    49u,
    48u,
    51u,
    53u,
    100u,
    99u,
    100u,
    101u,
    55u,
    99u,
    54u,
    48u,
    57u,
    53u,
    53u,
    56u,
    52u,
    50u,
    49u,
    49u,
    49u,
    57u,
    51u,
    48u,
    53u,
    56u,
    57u,
    101u,
    99u,
    99u,
    98u,
    52u,
    49u,
    48u,
    102u,
    56u,
    51u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    102u,
    52u,
    50u,
    57u,
    48u,
    48u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    100u,
    98u,
    98u,
    51u,
    55u,
    52u,
    97u,
    57u,
    55u,
    102u,
    49u,
    53u,
    99u,
    53u,
    57u,
    53u,
    56u,
    55u,
    50u,
    53u,
    54u,
    54u,
    54u,
    50u,
    102u,
    51u,
    54u,
    57u,
    48u,
    52u,
    100u,
    48u,
    55u,
    53u,
    100u,
    48u,
    101u,
    54u,
    49u,
    102u,
    55u,
    52u,
    57u,
    54u,
    49u,
    56u,
    49u,
    56u,
    50u,
    55u,
    49u,
    49u,
    50u,
    56u,
    56u,
    97u,
    99u,
    54u,
    49u,
    55u,
    99u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    48u,
    55u,
    51u,
    51u,
    56u,
    53u,
    101u,
    48u,
    53u,
    99u,
    50u,
    57u,
    102u,
    48u,
    52u,
    51u,
    53u,
    97u,
    54u,
    48u,
    48u,
    49u,
    99u,
    56u,
    101u,
    99u,
    97u,
    57u,
    99u,
    56u,
    100u,
    53u,
    54u,
    48u,
    50u,
    56u,
    57u,
    48u,
    97u,
    101u,
    102u,
    102u,
    57u,
    100u,
    52u,
    100u,
    49u,
    48u,
    51u,
    100u,
    51u,
    51u,
    56u,
    51u,
    99u,
    102u,
    56u,
    48u,
    100u,
    97u,
    101u,
    53u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    50u,
    49u,
    100u,
    48u,
    48u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    55u,
    100u,
    97u,
    51u,
    98u,
    57u,
    55u,
    101u,
    56u,
    50u,
    99u,
    48u,
    99u,
    51u,
    49u,
    50u,
    53u,
    97u,
    53u,
    56u,
    100u,
    97u,
    100u,
    56u,
    97u,
    48u,
    100u,
    49u,
    100u,
    48u,
    51u,
    54u,
    57u,
    50u,
    52u,
    52u,
    55u,
    51u,
    49u,
    102u,
    51u,
    98u,
    48u,
    57u,
    54u,
    101u,
    57u,
    55u,
    50u,
    52u,
    56u,
    52u,
    50u,
    57u,
    56u,
    100u,
    49u,
    53u,
    98u,
    56u,
    52u,
    51u,
    100u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    98u,
    53u,
    98u,
    52u,
    100u,
    49u,
    57u,
    99u,
    50u,
    48u,
    97u,
    55u,
    102u,
    99u,
    50u,
    98u,
    49u,
    55u,
    52u,
    102u,
    102u,
    54u,
    55u,
    51u,
    99u,
    48u,
    48u,
    54u,
    101u,
    100u,
    100u,
    50u,
    50u,
    52u,
    55u,
    99u,
    52u,
    98u,
    50u,
    51u,
    51u,
    54u,
    53u,
    55u,
    49u,
    56u,
    54u,
    52u,
    100u,
    102u,
    57u,
    51u,
    101u,
    98u,
    55u,
    101u,
    99u,
    48u,
    99u,
    56u,
    99u,
    50u,
    55u,
    54u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    48u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    54u,
    51u,
    99u,
    48u,
    48u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    53u,
    49u,
    52u,
    98u,
    100u,
    53u,
    56u,
    54u,
    53u,
    49u,
    49u,
    101u,
    53u,
    51u,
    49u,
    101u,
    50u,
    98u,
    54u,
    50u,
    55u,
    55u,
    97u,
    54u,
    100u,
    49u,
    49u,
    50u,
    98u,
    49u,
    55u,
    49u,
    102u,
    57u,
    101u,
    48u,
    48u,
    56u,
    100u,
    53u,
    54u,
    101u,
    102u,
    52u,
    97u,
    57u,
    55u,
    49u,
    101u,
    54u,
    49u,
    57u,
    97u,
    99u,
    102u,
    50u,
    50u,
    101u,
    55u,
    53u,
    48u,
    55u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    101u,
    51u,
    48u,
    51u,
    48u,
    54u,
    50u,
    57u,
    102u,
    102u,
    52u,
    50u,
    53u,
    56u,
    48u,
    53u,
    54u,
    100u,
    99u,
    57u,
    101u,
    102u,
    97u,
    102u,
    57u,
    50u,
    50u,
    98u,
    100u,
    49u,
    55u,
    51u,
    97u,
    54u,
    53u,
    102u,
    54u,
    53u,
    101u,
    101u,
    55u,
    57u,
    57u,
    98u,
    48u,
    99u,
    55u,
    54u,
    53u,
    48u,
    57u,
    55u,
    100u,
    51u,
    100u,
    101u,
    101u,
    100u,
    100u,
    101u,
    102u,
    49u,
    48u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    56u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    52u,
    51u,
    48u,
    48u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    98u,
    55u,
    55u,
    97u,
    57u,
    99u,
    51u,
    54u,
    100u,
    56u,
    57u,
    52u,
    100u,
    50u,
    100u,
    98u,
    99u,
    51u,
    49u,
    52u,
    51u,
    55u,
    101u,
    53u,
    99u,
    50u,
    97u,
    49u,
    53u,
    54u,
    52u,
    101u,
    57u,
    50u,
    55u,
    57u,
    51u,
    55u,
    56u,
    52u,
    56u,
    101u,
    97u,
    50u,
    101u,
    98u,
    50u,
    48u,
    98u,
    51u,
    56u,
    54u,
    51u,
    56u,
    97u,
    102u,
    99u,
    54u,
    52u,
    98u,
    57u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    49u,
    51u,
    99u,
    50u,
    50u,
    98u,
    98u,
    57u,
    57u,
    101u,
    57u,
    100u,
    97u,
    97u,
    57u,
    57u,
    51u,
    54u,
    98u,
    48u,
    100u,
    102u,
    53u,
    100u,
    99u,
    101u,
    54u,
    52u,
    100u,
    55u,
    55u,
    51u,
    55u,
    101u,
    51u,
    55u,
    48u,
    54u,
    98u,
    101u,
    57u,
    57u,
    101u,
    53u,
    48u,
    57u,
    56u,
    100u,
    49u,
    49u,
    50u,
    48u,
    48u,
    50u,
    52u,
    57u,
    50u,
    99u,
    102u,
    56u,
    49u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    54u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    52u,
    52u,
    49u,
    48u,
    48u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    100u,
    56u,
    57u,
    54u,
    50u,
    54u,
    55u,
    102u,
    100u,
    97u,
    53u,
    100u,
    100u,
    97u,
    48u,
    102u,
    56u,
    53u,
    51u,
    48u,
    56u,
    101u,
    55u,
    55u,
    102u,
    55u,
    53u,
    52u,
    99u,
    56u,
    98u,
    57u,
    52u,
    98u,
    55u,
    98u,
    56u,
    56u,
    101u,
    51u,
    99u,
    98u,
    51u,
    49u,
    53u,
    52u,
    55u,
    53u,
    99u,
    100u,
    57u,
    101u,
    102u,
    100u,
    49u,
    54u,
    52u,
    48u,
    49u,
    101u,
    51u,
    99u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    102u,
    53u,
    99u,
    102u,
    102u,
    100u,
    55u,
    101u,
    53u,
    97u,
    55u,
    48u,
    56u,
    55u,
    102u,
    49u,
    98u,
    52u,
    56u,
    52u,
    98u,
    53u,
    50u,
    54u,
    99u,
    55u,
    51u,
    53u,
    48u,
    99u,
    56u,
    54u,
    100u,
    56u,
    51u,
    56u,
    57u,
    50u,
    56u,
    51u,
    53u,
    48u,
    57u,
    99u,
    97u,
    56u,
    55u,
    56u,
    53u,
    48u,
    50u,
    102u,
    55u,
    57u,
    50u,
    49u,
    49u,
    53u,
    101u,
    56u,
    100u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    97u,
    100u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    57u,
    57u,
    100u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    51u,
    51u,
    57u,
    51u,
    53u,
    52u,
    53u,
    54u,
    56u,
    102u,
    53u,
    48u,
    54u,
    97u,
    99u,
    51u,
    99u,
    100u,
    54u,
    57u,
    98u,
    98u,
    52u,
    50u,
    55u,
    98u,
    49u,
    97u,
    102u,
    56u,
    51u,
    97u,
    48u,
    52u,
    55u,
    51u,
    98u,
    56u,
    55u,
    99u,
    49u,
    54u,
    98u,
    102u,
    51u,
    98u,
    53u,
    54u,
    50u,
    97u,
    57u,
    51u,
    100u,
    48u,
    97u,
    50u,
    102u,
    102u,
    99u,
    53u,
    51u,
    101u,
    53u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    50u,
    53u,
    97u,
    54u,
    50u,
    52u,
    101u,
    53u,
    99u,
    56u,
    52u,
    102u,
    57u,
    54u,
    100u,
    50u,
    99u,
    51u,
    52u,
    100u,
    99u,
    101u,
    51u,
    98u,
    54u,
    97u,
    55u,
    51u,
    54u,
    97u,
    100u,
    100u,
    98u,
    56u,
    57u,
    49u,
    55u,
    50u,
    52u,
    98u,
    52u,
    56u,
    97u,
    51u,
    54u,
    51u,
    50u,
    48u,
    99u,
    55u,
    52u,
    57u,
    52u,
    52u,
    51u,
    53u,
    102u,
    57u,
    99u,
    57u,
    49u,
    53u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    54u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    102u,
    98u,
    48u,
    48u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    56u,
    51u,
    54u,
    50u,
    48u,
    48u,
    57u,
    99u,
    48u,
    55u,
    99u,
    102u,
    52u,
    56u,
    50u,
    52u,
    57u,
    102u,
    52u,
    56u,
    49u,
    98u,
    101u,
    54u,
    98u,
    55u,
    57u,
    101u,
    54u,
    55u,
    50u,
    52u,
    55u,
    99u,
    97u,
    98u,
    49u,
    100u,
    50u,
    48u,
    48u,
    53u,
    48u,
    99u,
    102u,
    49u,
    49u,
    99u,
    50u,
    55u,
    54u,
    48u,
    56u,
    53u,
    98u,
    57u,
    48u,
    55u,
    51u,
    50u,
    49u,
    49u,
    48u,
    99u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    54u,
    57u,
    102u,
    49u,
    100u,
    54u,
    53u,
    48u,
    55u,
    102u,
    52u,
    98u,
    55u,
    98u,
    53u,
    48u,
    57u,
    56u,
    48u,
    57u,
    51u,
    48u,
    102u,
    55u,
    100u,
    56u,
    48u,
    56u,
    57u,
    56u,
    51u,
    52u,
    102u,
    98u,
    101u,
    54u,
    53u,
    102u,
    48u,
    57u,
    56u,
    48u,
    98u,
    56u,
    53u,
    57u,
    50u,
    100u,
    53u,
    51u,
    99u,
    100u,
    100u,
    97u,
    48u,
    56u,
    101u,
    53u,
    48u,
    100u,
    50u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    55u,
    100u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    101u,
    101u,
    98u,
    48u,
    48u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    101u,
    52u,
    102u,
    54u,
    53u,
    52u,
    100u,
    50u,
    54u,
    97u,
    98u,
    56u,
    99u,
    57u,
    49u,
    54u,
    52u,
    102u,
    102u,
    51u,
    49u,
    49u,
    54u,
    53u,
    55u,
    97u,
    57u,
    102u,
    57u,
    99u,
    52u,
    99u,
    100u,
    99u,
    48u,
    101u,
    56u,
    97u,
    48u,
    57u,
    51u,
    51u,
    52u,
    57u,
    50u,
    53u,
    102u,
    55u,
    99u,
    48u,
    50u,
    49u,
    51u,
    56u,
    56u,
    49u,
    57u,
    100u,
    55u,
    101u,
    54u,
    49u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    57u,
    50u,
    51u,
    98u,
    54u,
    51u,
    102u,
    53u,
    51u,
    99u,
    55u,
    50u,
    99u,
    48u,
    52u,
    101u,
    98u,
    101u,
    54u,
    99u,
    49u,
    99u,
    57u,
    49u,
    52u,
    48u,
    98u,
    54u,
    51u,
    55u,
    55u,
    49u,
    51u,
    50u,
    98u,
    54u,
    101u,
    53u,
    48u,
    56u,
    54u,
    53u,
    56u,
    49u,
    52u,
    102u,
    101u,
    53u,
    54u,
    50u,
    50u,
    57u,
    49u,
    98u,
    100u,
    48u,
    50u,
    51u,
    100u,
    51u,
    52u,
    56u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    53u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    53u,
    50u,
    101u,
    48u,
    48u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    100u,
    98u,
    57u,
    49u,
    97u,
    50u,
    53u,
    52u,
    48u,
    49u,
    97u,
    56u,
    57u,
    100u,
    97u,
    102u,
    57u,
    102u,
    102u,
    55u,
    100u,
    55u,
    57u,
    53u,
    52u,
    98u,
    97u,
    98u,
    55u,
    50u,
    50u,
    98u,
    56u,
    57u,
    52u,
    98u,
    97u,
    52u,
    56u,
    48u,
    102u,
    101u,
    102u,
    97u,
    102u,
    49u,
    102u,
    48u,
    97u,
    57u,
    53u,
    97u,
    97u,
    102u,
    53u,
    102u,
    54u,
    48u,
    48u,
    53u,
    54u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    101u,
    57u,
    56u,
    49u,
    55u,
    49u,
    54u,
    48u,
    101u,
    51u,
    53u,
    100u,
    52u,
    52u,
    49u,
    48u,
    54u,
    48u,
    49u,
    99u,
    56u,
    100u,
    99u,
    55u,
    52u,
    49u,
    99u,
    49u,
    97u,
    56u,
    49u,
    48u,
    99u,
    52u,
    56u,
    53u,
    102u,
    51u,
    98u,
    52u,
    48u,
    97u,
    48u,
    56u,
    53u,
    57u,
    98u,
    101u,
    53u,
    102u,
    53u,
    56u,
    102u,
    48u,
    98u,
    102u,
    54u,
    101u,
    102u,
    49u,
    54u,
    57u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    51u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    101u,
    49u,
    102u,
    48u,
    48u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    101u,
    50u,
    49u,
    53u,
    55u,
    56u,
    53u,
    49u,
    55u,
    56u,
    102u,
    102u,
    54u,
    51u,
    53u,
    48u,
    48u,
    54u,
    52u,
    48u,
    54u,
    48u,
    101u,
    98u,
    98u,
    98u,
    50u,
    49u,
    57u,
    97u,
    55u,
    49u,
    55u,
    49u,
    54u,
    97u,
    49u,
    48u,
    101u,
    56u,
    56u,
    53u,
    50u,
    56u,
    102u,
    99u,
    52u,
    98u,
    98u,
    49u,
    99u,
    98u,
    53u,
    99u,
    56u,
    102u,
    100u,
    100u,
    48u,
    99u,
    102u,
    54u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    53u,
    49u,
    52u,
    99u,
    102u,
    55u,
    51u,
    56u,
    52u,
    53u,
    53u,
    97u,
    53u,
    52u,
    102u,
    48u,
    48u,
    52u,
    101u,
    99u,
    56u,
    54u,
    101u,
    100u,
    97u,
    102u,
    99u,
    102u,
    100u,
    57u,
    102u,
    100u,
    50u,
    48u,
    50u,
    50u,
    48u,
    49u,
    55u,
    98u,
    98u,
    51u,
    49u,
    99u,
    50u,
    52u,
    53u,
    51u,
    52u,
    48u,
    51u,
    53u,
    51u,
    57u,
    49u,
    49u,
    55u,
    52u,
    52u,
    102u,
    98u,
    55u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    49u,
    102u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    54u,
    53u,
    102u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    97u,
    102u,
    97u,
    97u,
    56u,
    54u,
    100u,
    101u,
    102u,
    101u,
    56u,
    53u,
    48u,
    98u,
    48u,
    53u,
    55u,
    97u,
    101u,
    55u,
    52u,
    102u,
    55u,
    50u,
    49u,
    56u,
    97u,
    55u,
    57u,
    98u,
    48u,
    101u,
    100u,
    101u,
    48u,
    56u,
    54u,
    97u,
    49u,
    57u,
    54u,
    102u,
    49u,
    56u,
    102u,
    48u,
    101u,
    55u,
    99u,
    53u,
    56u,
    53u,
    101u,
    98u,
    56u,
    56u,
    100u,
    49u,
    49u,
    51u,
    57u,
    97u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    100u,
    98u,
    100u,
    53u,
    51u,
    102u,
    99u,
    99u,
    54u,
    52u,
    56u,
    53u,
    48u,
    98u,
    53u,
    51u,
    51u,
    52u,
    54u,
    55u,
    56u,
    49u,
    57u,
    57u,
    100u,
    55u,
    54u,
    57u,
    53u,
    49u,
    52u,
    56u,
    49u,
    56u,
    102u,
    98u,
    99u,
    99u,
    55u,
    57u,
    56u,
    54u,
    49u,
    102u,
    99u,
    55u,
    55u,
    101u,
    53u,
    55u,
    50u,
    98u,
    98u,
    52u,
    55u,
    53u,
    51u,
    98u,
    55u,
    102u,
    101u,
    50u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    100u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    51u,
    56u,
    57u,
    48u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    54u,
    53u,
    51u,
    100u,
    102u,
    53u,
    57u,
    53u,
    54u,
    101u,
    99u,
    101u,
    53u,
    49u,
    56u,
    97u,
    55u,
    56u,
    97u,
    53u,
    100u,
    49u,
    49u,
    50u,
    57u,
    55u,
    52u,
    51u,
    49u,
    97u,
    102u,
    57u,
    52u,
    99u,
    101u,
    56u,
    98u,
    97u,
    57u,
    49u,
    100u,
    56u,
    48u,
    99u,
    102u,
    98u,
    50u,
    97u,
    97u,
    56u,
    99u,
    53u,
    98u,
    51u,
    48u,
    57u,
    53u,
    102u,
    97u,
    50u,
    53u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    54u,
    102u,
    99u,
    52u,
    97u,
    97u,
    53u,
    100u,
    97u,
    56u,
    51u,
    57u,
    98u,
    97u,
    50u,
    54u,
    55u,
    99u,
    51u,
    54u,
    97u,
    97u,
    49u,
    97u,
    53u,
    98u,
    50u,
    57u,
    100u,
    56u,
    49u,
    51u,
    55u,
    52u,
    55u,
    98u,
    50u,
    50u,
    55u,
    51u,
    100u,
    99u,
    48u,
    51u,
    97u,
    97u,
    57u,
    101u,
    52u,
    48u,
    52u,
    99u,
    52u,
    100u,
    97u,
    48u,
    50u,
    51u,
    56u,
    101u,
    50u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    99u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    101u,
    55u,
    48u,
    48u,
    48u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    50u,
    51u,
    56u,
    48u,
    54u,
    97u,
    53u,
    51u,
    51u,
    98u,
    100u,
    57u,
    53u,
    54u,
    55u,
    56u,
    55u,
    101u,
    101u,
    102u,
    53u,
    50u,
    100u,
    100u,
    56u,
    101u,
    100u,
    101u,
    101u,
    52u,
    53u,
    54u,
    99u,
    54u,
    48u,
    100u,
    54u,
    99u,
    101u,
    99u,
    98u,
    98u,
    54u,
    49u,
    55u,
    53u,
    52u,
    53u,
    56u,
    101u,
    101u,
    53u,
    51u,
    102u,
    99u,
    56u,
    99u,
    54u,
    99u,
    56u,
    49u,
    51u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
const unsigned __int8 _func___14467[11] = { 103u, 101u, 116u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___14476[12] = { 103u, 101u, 116u, 95u, 100u, 101u, 118u, 105u, 99u, 101u, 115u, 0u }; // idb
const unsigned __int8 _func___14492[9] = { 115u, 104u, 97u, 114u, 101u, 108u, 111u, 103u, 0u }; // idb
const unsigned __int8 _func___14524[9] = { 97u, 100u, 100u, 95u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___14532[10] = { 112u, 111u, 111u, 108u, 95u, 116u, 115u, 101u, 116u, 0u }; // idb
const unsigned __int8 _func___14538[12] = { 112u, 111u, 111u, 108u, 95u, 116u, 99u, 108u, 101u, 97u, 114u, 0u }; // idb
const unsigned __int8 _func___14543[13] = { 99u, 117u, 114u, 114u, 101u, 110u, 116u, 95u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___14642[10] = { 115u, 101u, 116u, 117u, 112u, 95u, 117u, 114u, 108u, 0u }; // idb
const unsigned __int8 _func___14714[18] =
{
  108u,
  111u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  99u,
  117u,
  116u,
  111u,
  102u,
  102u,
  115u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___15218[13] = { 112u, 97u, 114u, 115u, 101u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _func___15243[12] = { 108u, 111u, 97u, 100u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _func___15252[20] =
{
  108u,
  111u,
  97u,
  100u,
  95u,
  100u,
  101u,
  102u,
  97u,
  117u,
  108u,
  116u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  0u
}; // idb
const unsigned __int8 _func___15286[14] = { 99u, 97u, 108u, 99u, 95u, 109u, 105u, 100u, 115u, 116u, 97u, 116u, 101u, 0u }; // idb
const unsigned __int8 _func___15291[15] =
{
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  105u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _func___15296[10] = { 109u, 97u, 107u, 101u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___15389[13] = { 103u, 101u, 116u, 95u, 115u, 116u, 97u, 116u, 108u, 105u, 110u, 101u, 0u }; // idb
const unsigned __int8 _func___15412[13] = { 115u, 104u, 97u, 114u, 101u, 95u, 114u, 101u, 115u, 117u, 108u, 116u, 0u }; // idb
const unsigned __int8 _func___15511[19] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  101u,
  110u,
  99u,
  104u,
  109u,
  97u,
  114u,
  107u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___15634[11] = { 95u, 99u, 111u, 112u, 121u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___15665[11] = { 115u, 116u, 97u, 108u, 101u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___15676[11] = { 115u, 104u, 97u, 114u, 101u, 95u, 100u, 105u, 102u, 102u, 0u }; // idb
const unsigned __int8 _func___15711[13] = { 115u, 119u, 105u, 116u, 99u, 104u, 95u, 112u, 111u, 111u, 108u, 115u, 0u }; // idb
const unsigned __int8 _func___15744[9] = { 119u, 97u, 107u, 101u, 95u, 103u, 119u, 115u, 0u }; // idb
const unsigned __int8 _func___15751[14] = { 100u, 105u, 115u, 99u, 97u, 114u, 100u, 95u, 115u, 116u, 97u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___15774[15] =
{
  114u,
  101u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___15789[19] =
{
  115u,
  105u,
  103u,
  110u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15791[19] =
{
  115u,
  105u,
  103u,
  110u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___15800[13] = { 115u, 101u, 116u, 95u, 99u, 117u, 114u, 98u, 108u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___15826[13] = { 98u, 108u, 111u, 99u, 107u, 95u, 101u, 120u, 105u, 115u, 116u, 115u, 0u }; // idb
const unsigned __int8 _func___15921[18] =
{
  116u,
  101u,
  115u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___15942[10] = { 104u, 97u, 115u, 104u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _func___16028[12] = { 106u, 115u, 111u, 110u, 95u, 101u, 115u, 99u, 97u, 112u, 101u, 0u }; // idb
const unsigned __int8 _func___16075[11] = { 122u, 101u, 114u, 111u, 95u, 115u, 116u, 97u, 116u, 115u, 0u }; // idb
const unsigned __int8 _func___16121[10] = { 104u, 97u, 115u, 104u, 109u, 101u, 116u, 101u, 114u, 0u }; // idb
const unsigned __int8 _func___16169[23] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  114u,
  101u,
  115u,
  112u,
  111u,
  110u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___16205[21] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  104u,
  97u,
  114u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___16218[16] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16229[8] = { 99u, 112u, 95u, 112u, 114u, 105u, 111u, 0u }; // idb
const unsigned __int8 _func___16249[16] =
{
  115u,
  117u,
  112u,
  112u,
  111u,
  114u,
  116u,
  115u,
  95u,
  114u,
  101u,
  115u,
  117u,
  109u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___16277[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  114u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16288[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___16303[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___16409[12] = { 112u, 111u, 111u, 108u, 95u, 97u, 99u, 116u, 105u, 118u, 101u, 0u }; // idb
const unsigned __int8 _func___16430[9] = { 104u, 97u, 115u, 104u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___16462[11] = { 115u, 101u, 116u, 95u, 116u, 97u, 114u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _func___16472[19] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _func___16483[17] =
{
  103u,
  101u,
  110u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16499[19] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  101u,
  110u,
  99u,
  104u,
  109u,
  97u,
  114u,
  107u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16508[9] = { 103u, 101u, 116u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___16520[18] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  97u,
  115u,
  121u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _func___16534[14] =
{
  105u,
  110u,
  99u,
  95u,
  104u,
  119u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___16569[18] =
{
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  115u,
  116u,
  97u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16582[19] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  116u,
  101u,
  115u,
  116u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16675[11] = { 109u, 116u, 95u, 100u, 105u, 115u, 97u, 98u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___16707[15] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  115u,
  111u,
  108u,
  101u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16873[12] = { 102u, 108u, 117u, 115u, 104u, 95u, 113u, 117u, 101u, 117u, 101u, 0u }; // idb
const unsigned __int8 _func___16903[17] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  100u,
  114u,
  105u,
  118u,
  101u,
  114u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16916[13] = { 109u, 105u, 110u, 101u, 114u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___16924[15] =
{
  119u,
  97u,
  105u,
  116u,
  95u,
  108u,
  112u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___16942[10] = { 114u, 101u, 97u, 112u, 95u, 99u, 117u, 114u, 108u, 0u }; // idb
const unsigned __int8 _func___16954[21] =
{
  112u,
  114u,
  117u,
  110u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  104u,
  97u,
  114u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___16987[16] =
{
  119u,
  97u,
  116u,
  99u,
  104u,
  100u,
  111u,
  103u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___17111[17] =
{
  116u,
  101u,
  115u,
  116u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___17121[17] =
{
  97u,
  100u,
  100u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  100u,
  101u,
  116u,
  97u,
  105u,
  108u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___17215[14] = { 101u, 110u, 97u, 98u, 108u, 101u, 95u, 100u, 101u, 118u, 105u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___17251[9] = { 97u, 100u, 100u, 95u, 99u, 103u, 112u, 117u, 0u }; // idb
const unsigned __int8 _FUNCTION___17310[12] = { 99u, 110u, 116u, 95u, 111u, 102u, 95u, 112u, 114u, 111u, 99u, 0u }; // idb
const unsigned __int8 _func___17344[5] = { 109u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___11388[12] = { 99u, 108u, 101u, 97u, 114u, 95u, 113u, 117u, 101u, 117u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___11418[21] =
{
  103u,
  101u,
  116u,
  95u,
  97u,
  118u,
  101u,
  114u,
  97u,
  103u,
  101u,
  95u,
  104u,
  97u,
  115u,
  104u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___11310[8] = { 95u, 105u, 111u, 95u, 110u, 101u, 119u, 0u }; // idb
const unsigned __int8 _func___11319[7] = { 105u, 111u, 95u, 97u, 100u, 100u, 0u }; // idb
const unsigned __int8 _func___11349[14] =
{
  101u,
  115u,
  99u,
  97u,
  112u,
  101u,
  95u,
  115u,
  116u,
  114u,
  105u,
  110u,
  103u,
  0u
}; // idb
const unsigned __int8 _func___11373[18] =
{
  97u,
  112u,
  105u,
  95u,
  97u,
  100u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  102u,
  117u,
  108u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___11575[13] = { 97u, 100u, 100u, 95u, 105u, 116u, 101u, 109u, 95u, 98u, 117u, 102u, 0u }; // idb
const unsigned __int8 _func___11589[11] = { 112u, 114u, 105u, 110u, 116u, 95u, 100u, 97u, 116u, 97u, 0u }; // idb
const unsigned __int8 _func___11628[8] = { 110u, 117u, 109u, 97u, 115u, 99u, 115u, 0u }; // idb
const unsigned __int8 _func___11637[10] = { 97u, 115u, 99u, 100u, 101u, 118u, 105u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___11829[8] = { 115u, 117u, 109u, 109u, 97u, 114u, 121u, 0u }; // idb
const unsigned __int8 _func___11862[11] = { 115u, 119u, 105u, 116u, 99u, 104u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___11879[12] = { 112u, 111u, 111u, 108u, 100u, 101u, 116u, 97u, 105u, 108u, 115u, 0u }; // idb
const unsigned __int8 _func___12102_0[9] = { 109u, 105u, 110u, 101u, 99u, 111u, 105u, 110u, 0u }; // idb
const unsigned __int8 _func___12181[10] = { 97u, 115u, 99u, 101u, 110u, 97u, 98u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___12338[7] = { 116u, 105u, 100u, 121u, 117u, 112u, 0u }; // idb
const unsigned __int8 _func___12354[13] = { 115u, 101u, 116u, 117u, 112u, 95u, 103u, 114u, 111u, 117u, 112u, 115u, 0u }; // idb
const unsigned __int8 _func___12392[15] =
{
  115u,
  101u,
  116u,
  117u,
  112u,
  95u,
  105u,
  112u,
  97u,
  99u,
  99u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___12427[12] = { 113u, 117u, 105u, 116u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___12432[15] =
{
  114u,
  101u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___12445[14] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 111u, 110u, 110u, 101u, 99u, 116u, 0u }; // idb
const unsigned __int8 _func___12500[6] = { 109u, 99u, 97u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___12523[11] = { 109u, 99u, 97u, 115u, 116u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _func___12561[4] = { 97u, 112u, 105u, 0u }; // idb
const unsigned __int8 _func___11016[14] =
{
  109u,
  121u,
  95u,
  108u,
  111u,
  103u,
  95u,
  99u,
  117u,
  114u,
  115u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8213[10] = { 109u, 121u, 95u, 115u, 121u, 115u, 116u, 101u, 109u, 0u }; // idb
const unsigned __int8 _FUNCTION___8229[17] =
{
  95u,
  108u,
  111u,
  103u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  110u,
  97u,
  109u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8239[11] = { 108u, 111u, 103u, 95u, 114u, 111u, 116u, 97u, 116u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___8251[26] =
{
  95u,
  108u,
  111u,
  103u,
  95u,
  103u,
  101u,
  110u,
  101u,
  114u,
  97u,
  116u,
  101u,
  95u,
  115u,
  121u,
  109u,
  98u,
  111u,
  108u,
  95u,
  108u,
  105u,
  110u,
  107u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___8265[19] =
{
  108u,
  111u,
  103u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  95u,
  114u,
  111u,
  117u,
  116u,
  105u,
  110u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___8276[9] = { 108u, 111u, 103u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___12273[17] =
{
  105u,
  115u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  101u,
  120u,
  105u,
  115u,
  116u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12278[31] =
{
  105u,
  115u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  108u,
  111u,
  97u,
  100u,
  95u,
  115u,
  117u,
  99u,
  99u,
  101u,
  101u,
  100u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12285[24] =
{
  105u,
  115u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  95u,
  118u,
  97u,
  108u,
  105u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12290[26] =
{
  105u,
  115u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  98u,
  117u,
  102u,
  95u,
  118u,
  97u,
  108u,
  105u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12295[25] =
{
  105u,
  115u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  98u,
  117u,
  102u,
  95u,
  118u,
  97u,
  108u,
  105u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12398[16] =
{
  97u,
  114u,
  114u,
  97u,
  121u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  99u,
  114u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12422_0[17] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12570[20] =
{
  116u,
  114u,
  97u,
  118u,
  101u,
  108u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  116u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12683[26] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  110u,
  98u,
  97u,
  108u,
  97u,
  110u,
  99u,
  101u,
  95u,
  105u,
  110u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12779[28] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12790[29] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  103u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12806[27] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  112u,
  111u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12817[28] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  103u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  112u,
  111u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12842[12] = { 101u, 101u, 112u, 114u, 111u, 109u, 95u, 108u, 111u, 97u, 100u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___12850[12] = { 101u, 101u, 112u, 114u, 111u, 109u, 95u, 115u, 97u, 118u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___12858[12] = { 101u, 101u, 112u, 114u, 111u, 109u, 95u, 115u, 97u, 118u, 101u, 0u }; // idb
const unsigned __int8 _func___10443[14] = { 107u, 95u, 97u, 108u, 108u, 111u, 99u, 95u, 105u, 116u, 101u, 109u, 115u, 0u }; // idb
const unsigned __int8 _func___10472[12] = { 95u, 107u, 95u, 110u, 101u, 119u, 95u, 108u, 105u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___10507[12] = { 95u, 107u, 95u, 97u, 100u, 100u, 95u, 104u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___11640[27] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11651[41] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  106u,
  117u,
  109u,
  112u,
  95u,
  116u,
  111u,
  95u,
  97u,
  112u,
  112u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  108u,
  111u,
  97u,
  100u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11662[32] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  112u,
  105u,
  99u,
  95u,
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11674[34] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  100u,
  99u,
  95u,
  100u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11689[33] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  115u,
  101u,
  116u,
  95u,
  112u,
  105u,
  99u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11776[38] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  103u,
  101u,
  116u,
  95u,
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11787[35] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  105u,
  99u,
  95u,
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  97u,
  108u,
  108u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11852[38] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  99u,
  114u,
  97u,
  98u,
  95u,
  99u,
  105u,
  114u,
  99u,
  117u,
  105u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11886[10] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 114u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___11891[22] =
{
  100u,
  101u,
  99u,
  111u,
  100u,
  101u,
  95u,
  97u,
  110u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  117u,
  102u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11905[37] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  112u,
  105u,
  99u,
  95u,
  103u,
  101u,
  116u,
  95u,
  97u,
  110u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11966[34] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  98u,
  117u,
  105u,
  108u,
  100u,
  95u,
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11983[31] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  112u,
  114u,
  111u,
  99u,
  101u,
  115u,
  115u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  114u,
  101u,
  115u,
  112u,
  111u,
  110u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12025[23] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  100u,
  117u,
  109u,
  112u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12032[24] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  105u,
  115u,
  95u,
  112u,
  97u,
  114u,
  97u,
  109u,
  95u,
  118u,
  97u,
  108u,
  105u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12055[32] =
{
  100u,
  111u,
  95u,
  100u,
  117u,
  109u,
  112u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  108u,
  111u,
  99u,
  107u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
void *off_96A1C = (void *)0x203D7C; // weak
_UNKNOWN unk_96B1C; // weak
const unsigned __int8 _PRETTY_FUNCTION___6523[10] = { 112u, 97u, 114u, 115u, 101u, 95u, 111u, 110u, 101u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___8102[13] = { 106u, 115u, 111u, 110u, 112u, 95u, 115u, 116u, 114u, 116u, 111u, 100u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___7344[11] = { 115u, 116u, 114u, 101u, 97u, 109u, 95u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___7352[13] = { 115u, 116u, 114u, 101u, 97u, 109u, 95u, 117u, 110u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___7375[17] =
{
  108u,
  101u,
  120u,
  95u,
  117u,
  110u,
  103u,
  101u,
  116u,
  95u,
  117u,
  110u,
  115u,
  97u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7390[22] =
{
  100u,
  101u,
  99u,
  111u,
  100u,
  101u,
  95u,
  117u,
  110u,
  105u,
  99u,
  111u,
  100u,
  101u,
  95u,
  101u,
  115u,
  99u,
  97u,
  112u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7413[16] =
{
  108u,
  101u,
  120u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  115u,
  116u,
  114u,
  105u,
  110u,
  103u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7439[16] =
{
  108u,
  101u,
  120u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 whitespace[33] =
{
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  0u
}; // idb
unsigned __int8 byte_970A8[4] = { 10u, 0u, 0u, 0u }; // weak
unsigned __int8 byte_970AC[4] = { 32u, 0u, 0u, 0u }; // weak
unsigned __int8 byte_970B0[4] = { 34u, 0u, 0u, 0u }; // weak
_UNKNOWN unk_970B4; // weak
_UNKNOWN unk_970B8; // weak
_UNKNOWN unk_970BC; // weak
_UNKNOWN unk_970C0; // weak
_UNKNOWN unk_970C4; // weak
_UNKNOWN unk_970C8; // weak
_UNKNOWN unk_970CC; // weak
_UNKNOWN unk_970D0; // weak
const unsigned __int8 _PRETTY_FUNCTION___7383[8] = { 100u, 111u, 95u, 100u, 117u, 109u, 112u, 0u }; // idb
void *_frame_dummy_init_array_entry = (void *)0x12795; // weak
uint32_t gBM1393_MISC_CONTROL_reg = 14849u; // idb
freq_pll freq_pll_1393[179] =
{
  { 19, 131136u, 1056u, 2097779u },
  { 22, 131136u, 1056u, 2097763u },
  { 26, 131136u, 1056u, 2097747u },
  { 28, 131136u, 1056u, 2097778u },
  { 33, 131136u, 1056u, 2097731u },
  { 40, 131136u, 1056u, 2097746u },
  { 50, 131136u, 1056u, 2097730u },
  { 57, 131136u, 1056u, 2097777u },
  { 66, 131136u, 1056u, 2097761u },
  { 80, 131136u, 1056u, 2097745u },
  { 100, 131136u, 1056u, 2097729u },
  { 125, 163904u, 1056u, 2622017u },
  { 150, 196672u, 1056u, 7864660u },
  { 175, 229440u, 1056u, 3670593u },
  { 200, 262208u, 1056u, 4194881u },
  { 225, 294976u, 1056u, 4719169u },
  { 250, 327744u, 1056u, 5243457u },
  { 275, 360512u, 1056u, 5767745u },
  { 300, 393280u, 1056u, 7864658u },
  { 303, 393280u, 1056u, 6357569u },
  { 306, 393280u, 1056u, 6423105u },
  { 309, 393280u, 1056u, 6488641u },
  { 312, 393280u, 1056u, 6554177u },
  { 315, 393280u, 1056u, 6619713u },
  { 318, 393280u, 1056u, 6685249u },
  { 321, 393280u, 1056u, 6750785u },
  { 325, 426048u, 1056u, 6816321u },
  { 328, 393280u, 1056u, 6881857u },
  { 331, 393280u, 1056u, 6947393u },
  { 334, 393280u, 1056u, 7012929u },
  { 337, 458816u, 1056u, 7078465u },
  { 340, 393280u, 1056u, 7144001u },
  { 343, 393280u, 1056u, 7209537u },
  { 346, 393280u, 1056u, 7275073u },
  { 350, 426048u, 1056u, 5505330u },
  { 353, 393280u, 1056u, 7406145u },
  { 356, 393280u, 1056u, 7471681u },
  { 359, 393280u, 1056u, 7537217u },
  { 362, 393280u, 1056u, 7602753u },
  { 365, 393280u, 1056u, 7668289u },
  { 368, 393280u, 1056u, 7733825u },
  { 371, 393280u, 1056u, 7799361u },
  { 375, 426048u, 1056u, 7864897u },
  { 378, 393280u, 1056u, 7930433u },
  { 381, 393280u, 1056u, 7995969u },
  { 384, 393280u, 1056u, 8061505u },
  { 387, 458816u, 1056u, 8127041u },
  { 390, 393280u, 1056u, 8192577u },
  { 393, 393280u, 1056u, 8258113u },
  { 396, 393280u, 1056u, 8323649u },
  { 400, 524352u, 1056u, 8389185u },
  { 404, 397376u, 800u, 6357553u },
  { 406, 266304u, 544u, 4260385u },
  { 408, 401472u, 800u, 6423089u },
  { 412, 270400u, 544u, 4325921u },
  { 416, 409664u, 800u, 6554161u },
  { 418, 274496u, 544u, 4391457u },
  { 420, 413760u, 800u, 6619697u },
  { 425, 278592u, 544u, 4456993u },
  { 429, 421952u, 800u, 6750769u },
  { 431, 282688u, 544u, 4522529u },
  { 433, 426048u, 800u, 6816305u },
  { 437, 286784u, 544u, 4588065u },
  { 441, 434240u, 800u, 6947377u },
  { 443, 290880u, 544u, 4653601u },
  { 445, 438336u, 800u, 7012913u },
  { 450, 294976u, 544u, 4719137u },
  { 454, 446528u, 800u, 7143985u },
  { 456, 299072u, 544u, 4784673u },
  { 458, 450624u, 800u, 7209521u },
  { 462, 303168u, 544u, 4850209u },
  { 466, 458816u, 800u, 7340593u },
  { 468, 307264u, 544u, 4915745u },
  { 470, 462912u, 800u, 7406129u },
  { 475, 311360u, 544u, 4981281u },
  { 479, 471104u, 800u, 7537201u },
  { 481, 315456u, 544u, 5046817u },
  { 483, 475200u, 800u, 7602737u },
  { 487, 319552u, 544u, 5112353u },
  { 491, 483392u, 800u, 7733809u },
  { 493, 323648u, 544u, 5177889u },
  { 495, 487488u, 800u, 7799345u },
  { 500, 327744u, 544u, 5243425u },
  { 504, 495680u, 800u, 7930417u },
  { 506, 331840u, 544u, 5308961u },
  { 508, 499776u, 800u, 7995953u },
  { 512, 335936u, 544u, 5374497u },
  { 516, 507968u, 800u, 8127025u },
  { 518, 340032u, 544u, 5440033u },
  { 520, 512064u, 800u, 8192561u },
  { 525, 344128u, 544u, 5505569u },
  { 529, 520256u, 800u, 8323633u },
  { 531, 348224u, 544u, 5571105u },
  { 533, 524352u, 800u, 8389169u },
  { 537, 352320u, 544u, 5636641u },
  { 543, 356416u, 544u, 5702177u },
  { 550, 360512u, 544u, 5767713u },
  { 556, 364608u, 544u, 5833249u },
  { 562, 368704u, 544u, 5898785u },
  { 568, 372800u, 544u, 5964321u },
  { 575, 376896u, 544u, 6029857u },
  { 581, 380992u, 544u, 6095393u },
  { 587, 385088u, 544u, 6160929u },
  { 593, 389184u, 544u, 6226465u },
  { 600, 393280u, 544u, 6291777u },
  { 606, 397376u, 544u, 6357537u },
  { 612, 401472u, 544u, 6423073u },
  { 618, 405568u, 544u, 6488609u },
  { 625, 409664u, 544u, 6554145u },
  { 631, 413760u, 544u, 6619681u },
  { 637, 417856u, 544u, 6685217u },
  { 643, 421952u, 544u, 6750753u },
  { 650, 426048u, 544u, 6816289u },
  { 656, 430144u, 544u, 6881825u },
  { 662, 434240u, 544u, 6947361u },
  { 668, 438336u, 544u, 7012897u },
  { 675, 442432u, 544u, 7078433u },
  { 681, 446528u, 544u, 7143969u },
  { 687, 450624u, 544u, 7209505u },
  { 693, 454720u, 544u, 7275041u },
  { 700, 458816u, 544u, 7340577u },
  { 706, 462912u, 544u, 7406113u },
  { 712, 467008u, 544u, 7471649u },
  { 718, 471104u, 544u, 7537185u },
  { 725, 475200u, 544u, 7602721u },
  { 731, 479296u, 544u, 7668257u },
  { 737, 483392u, 544u, 7733793u },
  { 743, 487488u, 544u, 7799329u },
  { 750, 491584u, 544u, 7864865u },
  { 756, 495680u, 544u, 7930401u },
  { 762, 499776u, 544u, 7995937u },
  { 768, 503872u, 544u, 8061473u },
  { 775, 507968u, 544u, 8127009u },
  { 781, 512064u, 544u, 8192545u },
  { 787, 516160u, 544u, 8258081u },
  { 793, 520256u, 544u, 8323617u },
  { 800, 524352u, 544u, 8389153u },
  { 825, 270400u, 288u, 4325905u },
  { 850, 278592u, 288u, 4456977u },
  { 875, 286784u, 288u, 4588049u },
  { 900, 294976u, 288u, 7078193u },
  { 925, 303168u, 288u, 4850193u },
  { 950, 311360u, 288u, 4981265u },
  { 975, 319552u, 288u, 5112337u },
  { 1000, 327744u, 288u, 5243409u },
  { 1025, 335936u, 288u, 5374481u },
  { 1050, 344128u, 288u, 5505553u },
  { 1075, 352320u, 288u, 5636625u },
  { 1100, 360512u, 288u, 5767697u },
  { 1125, 368704u, 288u, 5898769u },
  { 1150, 376896u, 288u, 6029841u },
  { 1175, 385088u, 288u, 6160913u },
  { 1200, 385088u, 288u, 6291985u },
  { 1300, 385088u, 288u, 6816273u },
  { 1400, 385088u, 288u, 7340561u },
  { 1500, 385088u, 288u, 7864849u },
  { 1600, 385088u, 288u, 8389137u },
  { 1700, 385088u, 288u, 8913425u },
  { 1800, 385088u, 288u, 9437713u },
  { 1900, 385088u, 288u, 9962001u },
  { 2000, 385088u, 288u, 5243153u },
  { 2100, 393248u, 288u, 5505297u },
  { 2200, 393248u, 288u, 5767441u },
  { 2300, 393248u, 288u, 6029585u },
  { 2400, 393248u, 288u, 6291729u },
  { 2500, 409632u, 288u, 6553873u },
  { 2550, 409632u, 288u, 13369873u },
  { 2600, 426016u, 288u, 6816017u },
  { 2625, 426016u, 288u, 13763089u },
  { 2700, 442400u, 288u, 7078161u },
  { 2750, 442400u, 288u, 14418449u },
  { 2800, 458784u, 288u, 7340305u },
  { 2850, 458784u, 288u, 14942737u },
  { 2875, 458784u, 288u, 15073809u },
  { 2900, 458784u, 288u, 7602449u },
  { 3000, 458784u, 288u, 7864593u },
  { 3100, 458784u, 288u, 8126737u },
  { 3200, 458784u, 288u, 8388881u },
  { 3300, 458784u, 288u, 8651025u }
}; // idb
high_pll_out freq_high_pll_1393[33] =
{
  { 100u, 15u, 1500u },
  { 125u, 12u, 1500u },
  { 150u, 10u, 1500u },
  { 175u, 12u, 2100u },
  { 200u, 15u, 3000u },
  { 225u, 12u, 2700u },
  { 250u, 12u, 3000u },
  { 275u, 10u, 2750u },
  { 300u, 10u, 3000u },
  { 325u, 8u, 2600u },
  { 350u, 8u, 2800u },
  { 375u, 8u, 3000u },
  { 400u, 7u, 2800u },
  { 425u, 6u, 2550u },
  { 450u, 6u, 2700u },
  { 475u, 6u, 2850u },
  { 500u, 6u, 3000u },
  { 525u, 5u, 2625u },
  { 550u, 5u, 2750u },
  { 575u, 5u, 2870u },
  { 600u, 5u, 3000u },
  { 625u, 4u, 2500u },
  { 650u, 4u, 2600u },
  { 675u, 4u, 2700u },
  { 700u, 4u, 2800u },
  { 725u, 4u, 2900u },
  { 750u, 4u, 3000u },
  { 775u, 4u, 3100u },
  { 800u, 4u, 3200u },
  { 825u, 4u, 3300u },
  { 850u, 3u, 2550u },
  { 875u, 3u, 2625u },
  { 900u, 3u, 2700u }
}; // idb
unsigned __int8 *temp_log = &aVarLogTemp; // idb
int env_temperature = 1000; // idb
int min_temperature = 1000; // idb
int min_chip_temperature = 1000; // idb
device_drv bitmain_soc_drv =
{
  DRIVER_bitmain_soc,
  &aBitmainSoc,
  &aBtmSoc,
  (void (*)(bool))0x2B447,
  (void (*)(cgpu_info *))0x2B3B9,
  (void (*)(unsigned __int8 *, size_t, cgpu_info *))0x2CA25,
  NULL,
  (api_data *(*)(cgpu_info *))0x2E499,
  NULL,
  NULL,
  NULL,
  (bool (*)(thr_info *))0x2B18B,
  NULL,
  NULL,
  NULL,
  (void (*)(thr_info *))0x59227,
  NULL,
  (int64_t (*)(thr_info *))0x2C74D,
  NULL,
  (void (*)(cgpu_info *))0x2C79D,
  (void (*)(cgpu_info *))0x2C79D,
  NULL,
  (void (*)(thr_info *))0x2F961,
  NULL,
  NULL,
  false,
  0.0,
  0.0
}; // idb
float init_freq = 100.0; // idb
float freq_step = 25.0; // idb
float freq_adjust_step = 5.0; // idb
int freq_mode = 2; // idb
bool enable_get_freq_from_eeprom = true; // idb
const unsigned __int8 *aging_file = &aNvdataAgingInf; // idb
const unsigned __int8 *aging_debug = &aNvdataAgingDeb; // idb
int ticket_mask = 63; // idb
uint32_t given_id = 2u; // idb
int opt_bitmain_soc_freq = 300; // idb
int opt_bitmain_soc_voltage = 980; // idb
uint8_t All_Chain = 255u; // idb
unsigned __int8 g_Clock_delay_control = 2u; // idb
unsigned int PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608u; // idb
unsigned __int8 last_job_buffer[8192] =
{
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
bool is_on_15064 = true; // idb
int tmp_version_16634 = -1; // idb
bool is_env_temp_detected_16957 = true; // idb
volatile bool first_time_init = true; // idb
uint8_t power_iic_addr = 16u; // idb
uint8_t power_iic_no = 1u; // idb
uint16_t power_protocal_type = 1u; // idb
const unsigned __int8 *power_log_file = &aVarLogTemp_0; // idb
int (*selective_yield)(void) = (int (*)(void))0x3DA53; // idb
unsigned __int8 bit_swap_table[256] =
{
  0u,
  128u,
  64u,
  192u,
  32u,
  160u,
  96u,
  224u,
  16u,
  144u,
  80u,
  208u,
  48u,
  176u,
  112u,
  240u,
  8u,
  136u,
  72u,
  200u,
  40u,
  168u,
  104u,
  232u,
  24u,
  152u,
  88u,
  216u,
  56u,
  184u,
  120u,
  248u,
  4u,
  132u,
  68u,
  196u,
  36u,
  164u,
  100u,
  228u,
  20u,
  148u,
  84u,
  212u,
  52u,
  180u,
  116u,
  244u,
  12u,
  140u,
  76u,
  204u,
  44u,
  172u,
  108u,
  236u,
  28u,
  156u,
  92u,
  220u,
  60u,
  188u,
  124u,
  252u,
  2u,
  130u,
  66u,
  194u,
  34u,
  162u,
  98u,
  226u,
  18u,
  146u,
  82u,
  210u,
  50u,
  178u,
  114u,
  242u,
  10u,
  138u,
  74u,
  202u,
  42u,
  170u,
  106u,
  234u,
  26u,
  154u,
  90u,
  218u,
  58u,
  186u,
  122u,
  250u,
  6u,
  134u,
  70u,
  198u,
  38u,
  166u,
  102u,
  230u,
  22u,
  150u,
  86u,
  214u,
  54u,
  182u,
  118u,
  246u,
  14u,
  142u,
  78u,
  206u,
  46u,
  174u,
  110u,
  238u,
  30u,
  158u,
  94u,
  222u,
  62u,
  190u,
  126u,
  254u,
  1u,
  129u,
  65u,
  193u,
  33u,
  161u,
  97u,
  225u,
  17u,
  145u,
  81u,
  209u,
  49u,
  177u,
  113u,
  241u,
  9u,
  137u,
  73u,
  201u,
  41u,
  169u,
  105u,
  233u,
  25u,
  153u,
  89u,
  217u,
  57u,
  185u,
  121u,
  249u,
  5u,
  133u,
  69u,
  197u,
  37u,
  165u,
  101u,
  229u,
  21u,
  149u,
  85u,
  213u,
  53u,
  181u,
  117u,
  245u,
  13u,
  141u,
  77u,
  205u,
  45u,
  173u,
  109u,
  237u,
  29u,
  157u,
  93u,
  221u,
  61u,
  189u,
  125u,
  253u,
  3u,
  131u,
  67u,
  195u,
  35u,
  163u,
  99u,
  227u,
  19u,
  147u,
  83u,
  211u,
  51u,
  179u,
  115u,
  243u,
  11u,
  139u,
  75u,
  203u,
  43u,
  171u,
  107u,
  235u,
  27u,
  155u,
  91u,
  219u,
  59u,
  187u,
  123u,
  251u,
  7u,
  135u,
  71u,
  199u,
  39u,
  167u,
  103u,
  231u,
  23u,
  151u,
  87u,
  215u,
  55u,
  183u,
  119u,
  247u,
  15u,
  143u,
  79u,
  207u,
  47u,
  175u,
  111u,
  239u,
  31u,
  159u,
  95u,
  223u,
  63u,
  191u,
  127u,
  255u
}; // idb
$262D70590CF6D71EA9430194459E5D8E proxynames[7] =
{
  { &aHttp_0, 0 },
  { &aHttp0, 1 },
  { &aSocks4, 2 },
  { &aSocks5, 3 },
  { &aSocks4a, 4 },
  { &aSocks5h, 5 },
  { NULL, 0 }
}; // idb
unsigned __int8 *blank_merkle = &a00000000000000; // idb
unsigned __int8 *curly = &unk_8A61C; // idb
strategies strategies_0[] = { { &aFailover } }; // idb
benchfile_layout benchfile_data[5] =
{
  { 1, &aVersion_1 },
  { 64, &aMerkleroot },
  { 64, &aPrevhash },
  { 8, &aDifficultybits },
  { 10, &aNoncetime }
}; // idb
int opt_log_interval = 5; // idb
int max_queue = 1; // idb
int opt_scantime = -1; // idb
int opt_expiry = 120; // idb
int opt_pool_fallback = 120; // idb
unsigned int global_quota_gcd = 1u; // idb
bool opt_restart = true; // idb
bool opt_submit_stale = true; // idb
bool opt_bitmain_ab = true; // idb
unsigned __int8 *opt_api_description = &aCgminer100; // idb
int opt_api_port = 4028; // idb
unsigned __int8 *opt_api_host = &a0000; // idb
unsigned __int8 *opt_api_mcast_addr = &a2240075; // idb
unsigned __int8 *opt_api_mcast_code = &aFtw; // idb
unsigned __int8 *opt_api_mcast_des = &byte_8A828; // idb
int opt_api_mcast_port = 4028; // idb
unsigned __int8 best_share[8] = { 48u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // idb
double current_diff = 1.84467441e19; // idb
int opt_multi_version = 1; // idb
unsigned __int8 *getwork_req = &aMethodGetworkP; // idb
opt_table opt_config_table[78] =
{
  {
    &aVersionFile,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49DDB,
    NULL,
    { &opt_hidden },
    &aSetMinerVersio
  },
  {
    &aLogfileOpenfla,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49C37,
    NULL,
    { &opt_hidden },
    &aSetLogFileOpen
  },
  {
    &aLogwork,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49C57,
    NULL,
    { &opt_hidden },
    &aSetLogWorkFile
  },
  {
    &aLogworkAsicnum,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49C77,
    NULL,
    { &opt_hidden },
    &aSetLogWorkAsic
  },
  {
    &aLogworkDiff,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_logwork_diff },
    &aAllowLogWorkDi
  },
  {
    &aLogfile,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49C17,
    NULL,
    { &opt_hidden },
    &aSetLogFileDefa
  },
  {
    &aApiAllow,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_api_allow },
    &aAllowApiAccess
  },
  {
    &aApiDescription,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_api_description },
    &aDescriptionPla
  },
  {
    &aApiGroups,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_api_groups },
    &aApiOneLetterGr
  },
  {
    &aApiListen,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_api_listen },
    &aEnableApiDefau
  },
  {
    &aApiMcast,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_api_mcast },
    &aEnableApiMulti
  },
  {
    &aApiMcastAddr,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_api_mcast_addr },
    &aApiMulticastLi_0
  },
  {
    &aApiMcastCode,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_api_mcast_code },
    &aCodeExpectedIn
  },
  {
    &aApiMcastDes,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_api_mcast_des },
    &aDescriptionApp
  },
  {
    &aApiMcastPort,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48E0B,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_api_mcast_port },
    &aApiMulticastLi_1
  },
  {
    &aApiNetwork,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_api_network },
    &aAllowApiIfEnab
  },
  {
    &aApiPort,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48E0B,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_api_port },
    &aPortNumberOfMi
  },
  {
    &aApiHost,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_api_host },
    &aSpecifyApiList
  },
  {
    &aBalance,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x48FCF,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo
  },
  {
    &aBenchfile_0,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_benchfile },
    &aRunCgminerInBe
  },
  {
    &aBenchfileDispl,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_benchfile_display },
    &aDisplayEachBen
  },
  {
    &aBenchmark_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_benchmark },
    &aRunCgminerInBe_0
  },
  {
    &aBitmainFanCtrl,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_bitmain_fan_ctrl },
    &aEnableBitmainM
  },
  {
    &aBitmainNobeepe,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x7948B,
    NULL,
    NULL,
    { &opt_bitmain_ab },
    &aEnableBitmainL
  },
  {
    &aBitmainFanPwm,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48E4D,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_bitmain_fan_pwm },
    &aSetBitmainFanP
  },
  {
    &aBitmainFreq,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48DE9,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_bitmain_soc_freq },
    &aSetFrequency
  },
  {
    &aBitmainVoltage,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48DE9,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_bitmain_soc_voltage },
    &aSetVoltage
  },
  {
    &aFixedFreq,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_fixed_freq },
    &aSetBitmainMine
  },
  {
    &aNoPreHeat,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x7946F,
    NULL,
    NULL,
    { &opt_pre_heat },
    &aSetBitmainMine_0
  },
  {
    &aBitmainInitFre,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49D61,
    (void (*)(unsigned __int8 *, const void *))0x79683,
    { &init_freq },
    &aSetInitFreqRan
  },
  {
    &aBitmainFreqSte,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49D61,
    (void (*)(unsigned __int8 *, const void *))0x79683,
    { &freq_step },
    &aIncreaseFreqSt
  },
  {
    &aBitmainUsePllL,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_use_pll_list },
    &aSetBitmainMine
  },
  {
    &aPrePatternTest,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_pattern },
    &aDoPatternTestB
  },
  {
    &aBitmainEconomi,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_bitmain_economic_mode },
    &aEnableBitmainM_0
  },
  {
    &aDebugD,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x496DF,
    NULL,
    NULL,
    { &opt_debug },
    &aEnableDebugOut
  },
  {
    &aDisableRejecti,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_disable_pool },
    &aAutomaticallyD
  },
  {
    &aExpiryE,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48DE9,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_expiry },
    &aUpperBoundOnHo
  },
  {
    &aExtranonceSubs_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x49603,
    NULL,
    NULL,
    { NULL },
    &aEnableExtranon_0
  },
  {
    &aFailoverOnly,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_fail_only },
    &aDonTLeakWorkTo
  },
  {
    &aFixProtocol,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_fix_protocol },
    &aDoNotRedirectT
  },
  {
    &aFallbackTime,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794C5,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_pool_fallback },
    &aSetTimeInSecon
  },
  {
    &aHotplug_0,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48DE9,
    NULL,
    { &hotplug_time },
    &opt_hidden
  },
  {
    &aLoadBalance,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x48FEB,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_0
  },
  {
    &aLogL,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48DE9,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_log_interval },
    &aIntervalInSeco
  },
  {
    &aLowmem,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_lowmem },
    &aMinimiseCachin
  },
  {
    &aMonitorM,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_stderr_cmd },
    &aUseCustomPipeC
  },
  {
    &aNetDelay,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_delaynet },
    &aImposeSmallDel
  },
  {
    &aNoPoolDisable,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x7948B,
    NULL,
    NULL,
    { &opt_disable_pool },
    &opt_hidden
  },
  {
    &aNoSubmitStale,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x7948B,
    NULL,
    NULL,
    { &opt_submit_stale },
    &aDonTSubmitShar
  },
  {
    &aPassP,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49477,
    NULL,
    { &opt_set_null },
    &aPasswordForBit
  },
  {
    &aPerDeviceStats,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &want_per_device_stats },
    &aForceVerboseMo
  },
  {
    &aPools_1,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x79453,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aProtocolDumpP,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_protocol },
    &aVerboseDumpOfP
  },
  {
    &aQueueQ,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48DE9,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_queue },
    &aMaximumNumberO
  },
  {
    &aQuietQ,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_quiet },
    &aDisableLogging
  },
  {
    &aQuotaU,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x492B1,
    NULL,
    { &opt_set_null },
    &aQuotaUrlCombin
  },
  {
    &aRealQuiet,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_realquiet },
    &aDisableAllOutp
  },
  {
    &aRetries,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49DC5,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRetryPause,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49DC5,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRotate,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49007,
    NULL,
    { &opt_set_null },
    &aChangeMultipoo_1
  },
  {
    &aRoundRobin,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x4903B,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_2
  },
  {
    &aScanTimeS,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x48DE9,
    (void (*)(unsigned __int8 *, const void *))0x7965D,
    { &opt_scantime },
    &aUpperBoundOnTi
  },
  {
    &aSchedStart,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49773,
    NULL,
    { &opt_set_sched_start },
    &aSetATimeOfDayI
  },
  {
    &aSchedStop,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49793,
    NULL,
    { &opt_set_sched_stop },
    &aSetATimeOfDayI_0
  },
  {
    &aSharelog,
    OPT_PROCESSARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x497B3,
    NULL,
    { &opt_set_sharelog },
    &aAppendShareLog
  },
  {
    &aShares,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794C5,
    NULL,
    { &opt_shares },
    &aQuitAfterMinin
  },
  {
    &aSocksProxy,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794A7,
    NULL,
    { &opt_socks_proxy },
    &aSetSocks4Proxy
  },
  {
    &aSuggestDiff,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794C5,
    NULL,
    { &opt_suggest_diff },
    &aSuggestMinerDi
  },
  {
    &aMultiVersion,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x794C5,
    NULL,
    { &opt_multi_version },
    &aMultiVersionMi
  },
  {
    &aSyslog_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &use_syslog },
    &aUseSystemLogFo
  },
  {
    &aTextOnlyT,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x7948B,
    NULL,
    NULL,
    { &use_curses },
    &opt_hidden
  },
  {
    &aUrlO,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x491E3,
    NULL,
    { &opt_set_null },
    &aUrlForBitcoinJ
  },
  {
    &aUserU,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x493ED,
    NULL,
    { &opt_set_null },
    &aUsernameForBit
  },
  {
    &aUserpassO,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x49501,
    NULL,
    { &opt_set_null },
    &aUsernamePasswo
  },
  {
    &aVerbose_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_log_output },
    &aLogVerboseOutp
  },
  {
    &aWidescreen,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_widescreen },
    &aUseExtraWideDi
  },
  {
    &aWorktime_0,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x79453,
    NULL,
    NULL,
    { &opt_worktime },
    &aDisplayExtraWo
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
opt_table opt_cmdline_table[5] =
{
  {
    &aConfigC,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x4A189,
    NULL,
    { &opt_set_null },
    &aLoadAJsonForma
  },
  {
    &aDefaultConfig,
    OPT_HASARG,
    NULL,
    (unsigned __int8 *(*)(const unsigned __int8 *, void *))0x4A295,
    NULL,
    { &opt_set_null },
    &aSpecifyTheFile
  },
  {
    &aHelpH,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x4A33D,
    NULL,
    NULL,
    { NULL },
    &aPrintThisMessa
  },
  {
    &aVersionV,
    OPT_NOARG,
    (unsigned __int8 *(*)(void *))0x795F9,
    NULL,
    NULL,
    { &packagename },
    &aDisplayVersion
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
unsigned __int8 *workpadding = &a00000080000000; // idb
double total_secs = 1.0; // idb
double new_total_secs = 1.0; // idb
double last_total_secs = 1.0; // idb
unsigned __int8 *hash_log = &aVarLogThash; // idb
const unsigned __int8 *UNAVAILABLE = &aApiWillNotBeAv; // idb
const unsigned __int8 *MUNAVAILABLE = &aApiMulticastLi; // idb
const unsigned __int8 *BLANK = &unk_9256C; // idb
const unsigned __int8 *COMMA = &asc_92570; // idb
const unsigned __int8 *APIVERSION = &a31; // idb
const unsigned __int8 *DEAD = &aDead; // idb
const unsigned __int8 *SICK = &aSick; // idb
const unsigned __int8 *NOSTART = &aNostart; // idb
const unsigned __int8 *INIT = &aInitialising; // idb
const unsigned __int8 *DISABLED = &aDisabled_0; // idb
const unsigned __int8 *ALIVE = &aAlive; // idb
const unsigned __int8 *REJECTING = &aRejecting; // idb
const unsigned __int8 *UNKNOWN = &aUnknown_0; // idb
const unsigned __int8 *NONE = &aNone; // idb
const unsigned __int8 *YES = &aY; // idb
const unsigned __int8 *NO = &aN; // idb
const unsigned __int8 *NULLSTR = &aNull; // idb
const unsigned __int8 *TRUESTR = &aTrue; // idb
const unsigned __int8 *FALSESTR = &aFalse; // idb
const unsigned __int8 *SHA256STR = &aSha256; // idb
const unsigned __int8 *DEVICECODE = &unk_9256C; // idb
const unsigned __int8 *OSINFO = &aLinux; // idb
const unsigned __int8 *JSON_COMMAND = &aCommand; // idb
const unsigned __int8 *JSON_PARAMETER = &aParameter; // idb
CODES codes[84] =
{
  { SEVERITY_SUCC, 7, PARAM_PMAX, &aDPoolS },
  { SEVERITY_ERR, 8, PARAM_NONE, &aNoPools },
  { SEVERITY_SUCC, 9, PARAM_DMAX, &aDAscS },
  { SEVERITY_ERR, 10, PARAM_NONE, &aNoAscs },
  { SEVERITY_SUCC, 11, PARAM_NONE, &aSummary_1 },
  { SEVERITY_SUCC, 16, PARAM_NONE, &aNonceNum },
  { SEVERITY_ERR, 14, PARAM_NONE, &aInvalidCommand },
  { SEVERITY_ERR, 15, PARAM_NONE, &aMissingDeviceI },
  { SEVERITY_SUCC, 59, PARAM_NONE, &aPgaCount_0 },
  { SEVERITY_SUCC, 104, PARAM_NONE, &aAscCount_0 },
  { SEVERITY_SUCC, 22, PARAM_NONE, &aCgminerVersion },
  { SEVERITY_ERR, 23, PARAM_NONE, &aInvalidJson },
  { SEVERITY_ERR, 24, PARAM_CMD, &aMissingJsonS },
  { SEVERITY_ERR, 25, PARAM_NONE, &aMissingPoolIdP },
  { SEVERITY_ERR, 26, PARAM_POOLMAX, &aInvalidPoolIdD },
  { SEVERITY_SUCC, 27, PARAM_POOL, &aSwitchingToPoo_1 },
  { SEVERITY_SUCC, 33, PARAM_NONE, &aCgminerConfig },
  { SEVERITY_ERR, 42, PARAM_NONE, &aMissingSaveFil },
  { SEVERITY_ERR, 43, PARAM_STR, &aCanTOpenOrCrea },
  { SEVERITY_SUCC, 44, PARAM_STR, &aConfigurationS },
  { SEVERITY_ERR, 45, PARAM_STR, &aAccessDeniedTo },
  { SEVERITY_SUCC, 46, PARAM_NONE, &aPrivilegedAcce },
  { SEVERITY_SUCC, 47, PARAM_POOL, &aEnablingPoolDS },
  { SEVERITY_SUCC, 73, PARAM_NONE, &aChangedPoolPri },
  { SEVERITY_ERR, 74, PARAM_PID, &aDuplicatePoolS },
  { SEVERITY_SUCC, 48, PARAM_POOL, &aDisablingPoolD },
  { SEVERITY_INFO, 49, PARAM_POOL, &aPoolDSAlreadyE },
  { SEVERITY_INFO, 50, PARAM_POOL, &aPoolDSAlreadyD },
  { SEVERITY_ERR, 51, PARAM_POOL, &aCannotDisableL },
  { SEVERITY_ERR, 52, PARAM_NONE, &aMissingAddpool },
  { SEVERITY_ERR, 53, PARAM_STR, &aInvalidAddpool },
  { SEVERITY_ERR, 54, PARAM_NONE, &aReachedMaximum },
  { SEVERITY_SUCC, 55, PARAM_POOL, &aAddedPoolDS },
  { SEVERITY_ERR, 66, PARAM_POOL, &aCannotRemoveLa },
  { SEVERITY_ERR, 67, PARAM_POOL, &aCannotRemoveAc },
  { SEVERITY_SUCC, 68, PARAM_BOTH, &aRemovedPoolDS },
  { SEVERITY_SUCC, 60, PARAM_NONE, &aNotify_1 },
  { SEVERITY_SUCC, 69, PARAM_NONE, &aDeviceDetails },
  { SEVERITY_SUCC, 70, PARAM_NONE, &aCgminerStats },
  { SEVERITY_ERR, 71, PARAM_NONE, &aMissingCheckCm },
  { SEVERITY_SUCC, 72, PARAM_NONE, &aCheckCommand },
  { SEVERITY_ERR, 75, PARAM_NONE, &aMissingParamet },
  { SEVERITY_ERR, 76, PARAM_NONE, &aInvalidParamet },
  { SEVERITY_SUCC, 77, PARAM_BOOL, &aFailoverOnlySe },
  { SEVERITY_SUCC, 78, PARAM_NONE, &aCgminerCoin },
  { SEVERITY_SUCC, 79, PARAM_NONE, &aDebugSettings },
  { SEVERITY_SUCC, 82, PARAM_SET, &aSetConfigSToD },
  { SEVERITY_ERR, 83, PARAM_STR, &aUnknownConfigS },
  { SEVERITY_ERR, 126, PARAM_STR, &aDeprecatedConf },
  { SEVERITY_ERR, 84, PARAM_BOTH, &aInvalidNumberD },
  { SEVERITY_ERR, 121, PARAM_BOTH, &aInvalidNegativ_0 },
  { SEVERITY_SUCC, 122, PARAM_SET, &aSetPoolSToQuot },
  { SEVERITY_ERR, 85, PARAM_NONE, &aMissingConfigP },
  { SEVERITY_ERR, 86, PARAM_STR, &aMissingConfigV },
  { SEVERITY_SUCC, 87, PARAM_NONE, &aUsbStatistics },
  { SEVERITY_INFO, 88, PARAM_NONE, &aNoUsbStatistic },
  { SEVERITY_ERR, 94, PARAM_NONE, &aMissingZeroPar },
  { SEVERITY_ERR, 95, PARAM_STR, &aInvalidZeroPar },
  { SEVERITY_SUCC, 96, PARAM_STR, &aZeroedSStatsWi },
  { SEVERITY_SUCC, 97, PARAM_STR, &aZeroedSStatsWi_0 },
  { SEVERITY_ERR, 99, PARAM_STR, &aInvalidValueFo },
  { SEVERITY_SUCC, 100, PARAM_INT, &aHotplugCheckSe },
  { SEVERITY_SUCC, 101, PARAM_NONE, &aHotplugDisable },
  { SEVERITY_WARN, 102, PARAM_NONE, &aHotplugIsNotAv },
  { SEVERITY_ERR, 103, PARAM_NONE, &aMissingHotplug },
  { SEVERITY_ERR, 105, PARAM_NONE, &aNoAscs },
  { SEVERITY_SUCC, 106, PARAM_ASC, &aAscD },
  { SEVERITY_ERR, 107, PARAM_ASCMAX, &aInvalidAscIdDR },
  { SEVERITY_INFO, 108, PARAM_ASC, &aAscDAlreadyEna },
  { SEVERITY_INFO, 109, PARAM_ASC, &aAscDAlreadyDis },
  { SEVERITY_INFO, 110, PARAM_ASC, &aAscDSentEnable },
  { SEVERITY_INFO, 111, PARAM_ASC, &aAscDSetDisable },
  { SEVERITY_ERR, 112, PARAM_ASC, &aAscDIsNotFlagg },
  { SEVERITY_SUCC, 113, PARAM_ASC, &aIdentifyComman },
  { SEVERITY_WARN, 114, PARAM_ASC, &aAscDDoesNotSup },
  { SEVERITY_ERR, 116, PARAM_NONE, &aMissingOptionA },
  { SEVERITY_WARN, 117, PARAM_ASC, &aAscDDoesNotSup_0 },
  { SEVERITY_INFO, 118, PARAM_BOTH, &aAscDSetHelpS },
  { SEVERITY_SUCC, 119, PARAM_BOTH, &aAscDSetOk },
  { SEVERITY_ERR, 120, PARAM_BOTH, &aAscDSetFailedS },
  { SEVERITY_SUCC, 125, PARAM_NONE, &aLcd },
  { SEVERITY_SUCC, 123, PARAM_NONE, &aLockStatsCreat },
  { SEVERITY_WARN, 124, PARAM_NONE, &aLockStatsNotEn },
  { SEVERITY_FAIL, 0, PARAM_PGA, NULL }
}; // idb
const unsigned __int8 *localaddr = &a127001; // idb
CMDS cmds[40] =
{
  {
    &aVersion_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x632F7,
    false,
    true
  },
  {
    &aConfig_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x633E9,
    false,
    true
  },
  {
    &aDevs_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x63995,
    false,
    true
  },
  {
    &aEdevs,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x63A5F,
    false,
    true
  },
  {
    &aPools_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x63B29,
    false,
    true
  },
  {
    &aSummary_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x64511,
    false,
    true
  },
  {
    &aNoncenum_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x64AF5,
    false,
    true
  },
  {
    &aPgacount,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x64BB1,
    false,
    true
  },
  {
    &aSwitchpool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x64C39,
    true,
    false
  },
  {
    &aAddpool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x64E7F,
    true,
    false
  },
  {
    &aPoolpriority,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x65033,
    true,
    false
  },
  {
    &aPoolquota,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x652EB,
    true,
    false
  },
  {
    &aEnablepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x64F55,
    true,
    false
  },
  {
    &aDisablepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x653F5,
    true,
    false
  },
  {
    &aRemovepool,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x654EF,
    true,
    false
  },
  {
    &aSave,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x65BB1,
    true,
    false
  },
  {
    &aQuit_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x65629,
    true,
    false
  },
  {
    &aPrivileged,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x656CD,
    true,
    false
  },
  {
    &aNotify_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x65971,
    false,
    true
  },
  {
    &aDevdetails_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x65A1B,
    false,
    true
  },
  {
    &aRestart_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x6567B,
    true,
    false
  },
  {
    &aStats_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x65EC7,
    false,
    true
  },
  {
    &aEstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x6602D,
    false,
    true
  },
  {
    &aCheck_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x671D3,
    false,
    false
  },
  {
    &aFailoverOnly_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x6611D,
    true,
    false
  },
  {
    &aCoin_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66143,
    false,
    true
  },
  {
    &aDebug_2,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66275,
    true,
    false
  },
  {
    &aSetconfig,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x665E5,
    true,
    false
  },
  {
    &aUsbstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66657,
    false,
    true
  },
  {
    &aZero,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66687,
    true,
    false
  },
  {
    &aHotplug_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x6680D,
    true,
    false
  },
  {
    &aAsc_1,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66833,
    false,
    false
  },
  {
    &aAscenable,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x668F7,
    true,
    false
  },
  {
    &aAscdisable,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66B65,
    true,
    false
  },
  {
    &aAscidentify,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66D0B,
    true,
    false
  },
  {
    &aAscset,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66E75,
    true,
    false
  },
  {
    &aAsccount,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x66DE5,
    false,
    true
  },
  {
    &aLcd_0,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x64365,
    false,
    true
  },
  {
    &aLockstats,
    (void (*)(io_data *, int, unsigned __int8 *, bool, unsigned __int8))0x632D1,
    true,
    true
  },
  { NULL, NULL, false, false }
}; // idb
int opt_log_level = 5; // idb
unsigned int log_level = 4u; // idb
unsigned __int8 *log_file = &aVarLogLog; // idb
uint32_t sha256_h0[8] =
{
  1779033703u,
  3144134277u,
  1013904242u,
  2773480762u,
  1359893119u,
  2600822924u,
  528734635u,
  1541459225u
}; // idb
uint32_t sha256_k[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
const unsigned __int8 *register_file_str = &aVarLogRegister; // idb
int listen_sockfd = -1; // idb
json_t_0 the_true_8961 = { JSON_TRUE, 4294967295u }; // idb
json_t_0 the_false_8965 = { JSON_FALSE, 4294967295u }; // idb
json_t_0 the_null_8969 = { JSON_NULL, 4294967295u }; // idb
json_malloc_t do_malloc = &malloc; // idb
json_free_t do_free = &free; // idb
_UNKNOWN _bss_start; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
char completed_10540; // weak
int8_t middle_Offset[96]; // idb
int chain_temp_toolow[16]; // idb
bool is218_Temp; // idb
bool chip_hasNoMiddle; // idb
STATUS_CODE status_value; // idb
bool read_temp_error; // idb
bool pcb_chip_over_temp; // idb
int max_temperature; // idb
int max_chip_temperature; // idb
float environemnt_temp; // idb
bool has_disabled_flag_11871; // idb
uint32_t network_err_count_11905; // idb
float env_temp_11960; // idb
bool minor_type_init_12029; // idb
CHIP_MINOR_TYPE minor_types_12028; // idb
bool low_temp_env_init_12042; // idb
bool is_low_temp_env_12043; // idb
int last_chip_temp_12052; // idb
CALC_NONCE_INFO calc_nonce_info; // idb
CALC_NONCE_INFO scanfreq_calc_nonce_info; // idb
bool doTestPatten; // idb
bool startCheckNetworkJob; // idb
bool opt_use_pll_list; // idb
bool opt_pattern; // idb
int last_testpatten_highest_pcb_temp; // idb
int last_testpatten_lowest_pcb_temp; // idb
int last_testpatten_highest_chip_temp; // idb
int last_testpatten_lowest_chip_temp; // idb
int freq_scan_status; // idb
bool g_freq_test; // idb
bool is_reading_core_reg; // idb
int bring_up_pcb_temp; // idb
volatile bool set_voltage_flag; // idb
pthread_mutex_t set_voltage_lock; // idb
bool b_is_re_open_core; // idb
uint32_t re_open_core_times; // idb
uint32_t aging_re_open_core_times; // idb
uint32_t force_reopen_times; // idb
float freq_adjust_index[16][6]; // idb
aging_test_info_s aging_info; // idb
unsigned __int8 reopen_time[100][64]; // idb
uint8_t chain_pcb_version[16]; // idb
unsigned int *axi_fpga_addr; // idb
unsigned int *fpga_mem_addr; // idb
unsigned int *nonce2_jobid_address; // idb
unsigned int *job_start_address_1; // idb
unsigned int *job_start_address_2; // idb
thr_info *read_temp_id; // idb
thr_info *read_temp_id_in_force; // idb
thr_info *pic_heart_beat; // idb
bool gBegin_get_nonce; // idb
timeval tv_send_job; // idb
timeval tv_send; // idb
pthread_mutex_t reg_mutex; // idb
pthread_mutex_t nonce_mutex; // idb
pthread_mutex_t iic_mutex; // idb
pthread_mutex_t fpga_mutex; // idb
pthread_mutex_t reopen_core; // idb
uint32_t c_coinbase_padding; // idb
uint32_t c_merkles_num; // idb
uint32_t l_coinbase_padding; // idb
uint32_t l_merkles_num; // idb
bool opt_bitmain_fan_ctrl; // idb
bool opt_bitmain_economic_mode; // idb
int opt_bitmain_fan_pwm; // idb
int total_freq; // idb
int find_asic_with_count; // idb
int find_asic_with_pre_open_core_count; // idb
sweep_config_t g_sweep_config_eco; // idb
sweep_config_t g_sweep_config_hpf; // idb
CHIP_MAJOR_TYPE g_major_type[16]; // idb
CHIP_MINOR_TYPE g_minor_type[16]; // idb
CHIP_LEVEL g_bin_level[16]; // idb
uint8_t bom_version[16]; // idb
CHIP_MINOR_TYPE g_device_minor_type; // idb
CHIP_LEVEL g_device_bin_level; // idb
pattern_info pattern_info_t; // idb
bool status_error; // idb
float freq_from_board[16]; // idb
double chain_asic_RT[16][60]; // idb
uint64_t rate[16]; // idb
uint64_t nonce_num[16][128][60]; // idb
int nonce_times; // idb
int rate_error[16]; // idb
unsigned __int8 last_freq[16][256]; // idb
int chain_badcore_num[16][256]; // idb
int x_time[16][256]; // idb
bool isChainAllCoresOpened[16]; // idb
pthread_mutex_t reinit_mutex; // idb
uint8_t g_pulse_mode; // idb
bool g_is_mode2_startup; // idb
uint64_t h_each_chain[16]; // idb
double each_chain_h_avg[16]; // idb
double geach_chain_h_all; // idb
int g_total_fixed_hashrate; // idb
uint32_t base_domain_nonce_buf[384]; // idb
int64_t h; // idb
uint32_t nonce_at_domain_15210[16][24]; // idb
uint32_t last_total_seconds_15366; // idb
bool minor_type_init_15414; // idb
CHIP_MINOR_TYPE minor_types_15415; // idb
bool volt_increased_flag_15550[16]; // idb
bool outer_reopen_flag_15551; // idb
bool working_volt_decreased_flag_15559; // idb
int nonce_at_asic_15813[16][60]; // idb
uint64_t pool_send_nu_16613; // idb
uint64_t pool_diff_16726; // idb
uint64_t pool_diff_bit_16728; // idb
uint64_t net_diff_16727; // idb
uint64_t net_diff_bit_16729; // idb
uint32_t last_nonce3_16760; // idb
uint32_t last_workid_16761; // idb
bool is_env_temp_detected_16929; // idb
float freq_adjust_record[16][6]; // idb
float calc_ability[20]; // idb
float calc_ability_per_chain[20][16]; // idb
float calc_ability_per_chain_recode[16]; // idb
uint32_t scanfreq_best_times; // idb
bool need_set_final_freq; // idb
bool check_column_nonce; // idb
bool test_8pattern; // idb
bool check_nonce_rate; // idb
SCAN_FREQ_INFO scanfreq_info; // idb
uint32_t low_rate_error; // idb
bool low_rate_error_now; // idb
bool is_freq_scan_succeeded_flag; // idb
int scan_base_freq[2]; // idb
inbalance_info_t inbalance_info[16]; // idb
inbalance_info_t inbalance_info_record[16]; // idb
uint8_t *asic_sweep_state; // idb
bool sweep_failed_base_freq; // idb
bool sweep_failed_middle_freq; // idb
bool sweep_failed_few_succeed_freq; // idb
CHIP_MINOR_TYPE g_minor_type; // idb
power_info_t power_info[16]; // idb
bool successful_connect; // idb
unsigned __int8 packagename[256]; // idb
FILE *g_logwork_file; // idb
FILE *g_logwork_files[65]; // idb
FILE *g_logwork_diffs[65]; // idb
int g_logwork_asicnum; // idb
unsigned __int8 *opt_benchfile; // idb
bool opt_benchfile_display; // idb
FILE *benchfile_in; // idb
int benchfile_line; // idb
int benchfile_work; // idb
bool opt_benchmark; // idb
bool work_filled; // idb
bool work_emptied; // idb
bool opt_display_devs; // idb
int most_devices; // idb
bool alt_status; // idb
bool switch_status; // idb
int opt_shares; // idb
bool opt_fix_protocol; // idb
unsigned __int8 *opt_version_path; // idb
unsigned __int8 *opt_logfile_path; // idb
unsigned __int8 *opt_logfile_openflag; // idb
unsigned __int8 *opt_logwork_path; // idb
unsigned __int8 *opt_logwork_asicnum; // idb
bool opt_logwork_diff; // idb
unsigned __int8 *opt_api_allow; // idb
bool no_work; // idb
unsigned __int8 *opt_set_null; // idb
int gwsched_thr_id; // idb
int watchpool_thr_id; // idb
int watchdog_thr_id; // idb
int api_thr_id; // idb
int total_control_threads; // idb
int new_devices; // idb
int new_threads; // idb
pthread_mutex_t *stgd_lock; // idb
pthread_rwlock_t blk_lock; // idb
pthread_mutex_t sshare_lock; // idb
pthread_mutex_t lp_lock; // idb
pthread_cond_t lp_cond; // idb
double g_local_mhashes_dones[12]; // idb
int g_local_mhashes_index; // idb
double g_displayed_rolling; // idb
unsigned __int8 g_miner_version[256]; // idb
unsigned __int8 g_miner_compiletime[256]; // idb
unsigned __int8 g_miner_type[256]; // idb
unsigned __int8 displayed_hash_rate[16]; // idb
unsigned __int8 displayed_working_voltage[16]; // idb
unsigned __int8 displayed_mode[16]; // idb
timeval total_tv_start; // idb
timeval total_tv_end; // idb
timeval restart_tv_start; // idb
timeval update_tv_start; // idb
int staged_rollable; // idb
unsigned int work_block; // idb
unsigned int local_work_last; // idb
int local_work_lasttime; // idb
pool *currentpool; // idb
pool_strategy pool_strategy_0; // idb
int total_urls; // idb
int total_users; // idb
int total_passes; // idb
int total_userpasses; // idb
int total_extranonce; // idb
unsigned __int8 prev_block[12]; // idb
unsigned __int8 current_block[32]; // idb
unsigned __int8 datestamp[40]; // idb
unsigned __int8 blocktime[32]; // idb
unsigned __int8 block_diff[8]; // idb
uint64_t best_diff; // idb
block *blocks; // idb
stratum_share *stratum_shares; // idb
unsigned __int8 *opt_socks_proxy; // idb
unsigned __int8 *default_config; // idb
bool config_loaded; // idb
int include_count; // idb
unsigned __int8 *opt_stderr_cmd; // idb
int forkpid; // idb
uint32_t total_work; // idb
work *staged_work; // idb
unsigned __int8 exit_buf[512]; // idb
pthread_mutex_t sharelog_lock; // idb
FILE *sharelog_file; // idb
unsigned __int8 *temp_cutoff_str; // idb
int fileconf_load; // idb
unsigned __int8 *cnfbuf; // idb
unsigned __int8 statusline[256]; // idb
int devcursor; // idb
int logstart; // idb
int logcursor; // idb
unsigned __int8 bench_hidiff_bins[16][160]; // idb
unsigned __int8 bench_lodiff_bins[16][160]; // idb
unsigned __int8 bench_target[32]; // idb
unsigned __int8 **initial_args; // idb
JE *jedata; // idb
timeval tv_hashmeter; // idb
time_t hashdisplay_t; // idb
timeval rotate_tv; // idb
bool pools_active; // idb
int cgminer_id_count; // idb
unsigned __int8 err_buf_15212[200]; // idb
_cgpu_devid_counter *devids_17226; // idb
int rotating_pool_15462; // idb
double thashrate_array[65]; // idb
uint32_t thash_index; // idb
uint32_t length; // idb
uint32_t minutes_11382; // idb
int my_thr_id; // idb
bool bye; // idb
pthread_mutex_t quit_restart_lock; // idb
bool do_a_quit; // idb
bool do_a_restart; // idb
time_t when; // idb
IPACCESS *ipaccess; // idb
int ips; // idb
io_list *io_head; // idb
K_LIST *strbufs; // idb
bool opt_debug; // idb
bool opt_log_output; // idb
FILE *g_log_file; // idb
bool g_logfile_enable; // idb
unsigned __int8 g_logfile_path[256]; // idb
unsigned __int8 g_logfile_openflag[32]; // idb
_log_ctx log_ctx; // idb
uint8_t eeprom_info[16][256]; // idb
uint8_t eeprom_dirty_flag[16][256]; // idb
bool state_is_eeprom_chain_load_succeeded[16]; // idb
bool state_is_eeprom_all_chain_load_succeeded; // idb
bool ExitServer; // idb
volatile uint32_t hashtable_seed; // idb
device_drv bitmain_drv; // idb
device_drv modminer_drv; // idb
device_drv bitforce_drv; // idb
temp_info_t temp_info[16]; // idb
int8_t DEVICEADDR[16]; // idb
thr_info *read_hash_rate; // idb
thr_info *store_hash_rate_id; // idb
volatile nonce_buf nonce_read_out; // idb
low_temp_process_parms_t low_temp_process_parm[2]; // idb
volatile reg_buf reg_value_buf; // idb
int pcb_version; // idb
LOG_FILE_BACKUP init_log_bak; // idb
unsigned __int8 search_failed_info[64]; // idb
int scan_freq_average[16]; // idb
int imbalance_domain_count_total; // idb
unsigned __int8 FPGA_ID_str[32]; // idb
unsigned __int8 displayed_rate[16][32]; // idb
thr_info *read_nonce_reg_id; // idb
thr_info *check_system_work_id; // idb
init_config config_parameter; // idb
all_parameters *dev; // idb
SCAN_FREQ_RESULT scan_result[16]; // idb
int fpga_version; // idb
int imbalance_domain_count_chain[16]; // idb
pthread_t receive_id; // idb
LOG_FILE_BACKUP scanfreq_log_bak; // idb
bool is_asic_bad[16][60]; // idb
unsigned __int8 *opt_api_groups; // idb
schedtime schedstop; // idb
int64_t total_stale; // idb
time_t total_tv_start_sys; // idb
unsigned __int8 current_hash[68]; // idb
int hw_errors; // idb
double total_diff_accepted; // idb
bool opt_quiet; // idb
int64_t total_discarded; // idb
bool want_per_device_stats; // idb
double total_diff_rejected; // idb
bool opt_protocol; // idb
schedtime schedstart; // idb
int total_pools; // idb
sigaction abrthandler; // idb
unsigned int found_blocks; // idb
bool sched_paused; // idb
int opt_rotate_period; // idb
cgpu_info **devices; // idb
unsigned __int64 global_hashrate; // idb
bool hotplug_mode; // idb
bool opt_api_mcast; // idb
int opt_suggest_diff; // idb
unsigned __int8 nonce_num60_string[4096]; // idb
time_t total_tv_end_sys; // idb
bool use_curses; // idb
int swork_id; // idb
unsigned int total_ro; // idb
int zombie_devs; // idb
bool opt_worktime; // idb
time_t last_getwork; // idb
thr_info **mining_thr; // idb
pthread_rwlock_t mining_thr_lock; // idb
pool **pools; // idb
pthread_cond_t gws_cond; // idb
bool use_syslog; // idb
bool opt_delaynet; // idb
bool have_longpoll; // idb
cglock_t ch_lock; // idb
cglock_t control_lock; // idb
int enabled_pools; // idb
unsigned __int8 nonce_num30_string[4096]; // idb
unsigned __int8 *cgminer_path; // idb
int g_max_fan; // idb
int g_max_temp; // idb
int mining_threads; // idb
double total_rolling; // idb
thr_info *control_thr; // idb
bool opt_realquiet; // idb
pthread_rwlock_t netacc_lock; // idb
int total_devices; // idb
unsigned __int8 *opt_kernel_path; // idb
unsigned int total_go; // idb
bool opt_fail_only; // idb
int64_t total_accepted; // idb
thread_q *getq; // idb
int64_t total_getworks; // idb
timeval block_timeval; // idb
sigaction termhandler; // idb
bool opt_lowmem; // idb
bool opt_api_listen; // idb
double rolling5; // idb
double rolling1; // idb
double rolling15; // idb
double total_mhashes_done; // idb
bool opt_compact; // idb
unsigned __int8 nonce_num10_string[4096]; // idb
double total_diff_stale; // idb
pthread_mutex_t stats_lock; // idb
unsigned int new_blocks; // idb
bool opt_disable_pool; // idb
pthread_mutex_t console_lock; // idb
pthread_cond_t restart_cond; // idb
sigaction inthandler; // idb
bool opt_api_network; // idb
list_head scan_devices; // idb
pthread_mutex_t update_job_lock; // idb
unsigned int local_work; // idb
int64_t total_rejected; // idb
bool opt_work_update; // idb
pthread_mutex_t restart_lock; // idb
pthread_rwlock_t devices_lock; // idb
double new_total_mhashes_done; // idb
pthread_mutex_t hash_lock; // idb
int64_t total_diff1; // idb
APIGROUPS apigroups[26]; // idb
unsigned int opt_num_short_arg; // idb
unsigned int opt_num_long; // idb
unsigned int opt_num_short; // idb
opt_table *opt_table_0; // idb
const unsigned __int8 *opt_argv0; // idb
unsigned int opt_count; // idb
const unsigned __int8 opt_hidden[]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00011F08) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (00011F14) --------------------------------------------------------
void sub_11F14()
{
  JUMPOUT(0);
}
// 11F20: control flows out of bounds to 0

//----- (000126D8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)&va,
    (void (*)(void))init,
    _libc_csu_fini,
    a1,
    &va);
  abort();
}
// 126E2: positive sp value 4 has been found
// 126F4: variable 'v4' is possibly undefined

//----- (00012708) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 122AC: using guessed type int _gmon_start__(void);

//----- (0001272C) --------------------------------------------------------
void *deregister_tm_clones()
{
  return &_bss_start;
}

//----- (00012750) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &_bss_start;
  HIDWORD(result) = 0;
  return result;
}

//----- (0001277C) --------------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // r0

  if ( !completed_10540 )
  {
    result = deregister_tm_clones();
    completed_10540 = 1;
  }
  return result;
}
// AC430: using guessed type char completed_10540;

//----- (00012798) --------------------------------------------------------
int __cdecl get_index_from_pll_B1393(int pll)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  for ( i = 0; (unsigned int)i <= 0xB2 && pll != freq_pll_1393[i].freq; ++i )
    ;
  if ( i != 179 )
    return i;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "freq index set error,return default pll index");
    applog(3, tmp42, 0);
  }
  return get_index_from_pll_B1393(200);
}

//----- (00012854) --------------------------------------------------------
void __cdecl get_plldata_from_index(int index, uint8_t *vil_pll)
{
  size_t v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 plldivider1[32]; // [sp+808h] [bp+808h] BYREF

  memset(plldivider1, 0, sizeof(plldivider1));
  if ( (unsigned int)index > 0xB2 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "freq set error");
      applog(3, tmp42, 0);
    }
    exit(0);
  }
  sprintf((char *)plldivider1, "%08x", freq_pll_1393[index].vilpll);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "vil pll data:%s", (const char *)plldivider1);
    applog(5, tmp42, 0);
  }
  v2 = strlen((const char *)plldivider1);
  if ( !hex2bin(vil_pll, plldivider1, v2 >> 1) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "hex2bin failed in %s", (const char *)_FUNCTION___11356);
      applog(4, tmp42, 0);
    }
    exit(-1);
  }
}

//----- (000129D8) --------------------------------------------------------
int __cdecl get_pllparam_divider(float freq, uint32_t *pll_param, uint8_t *divider, float *pll_freq)
{
  float v4; // s0
  unsigned int v5; // r3
  unsigned __int8 tmp42[2048]; // [sp+38h] [bp+18h] BYREF
  float real_freq; // [sp+838h] [bp+818h]
  uint32_t postdiv_i_0; // [sp+83Ch] [bp+81Ch]
  float postdiv_f_0; // [sp+840h] [bp+820h]
  uint32_t postdiv_i; // [sp+844h] [bp+824h]
  float postdiv_f; // [sp+848h] [bp+828h]
  float decimals; // [sp+84Ch] [bp+82Ch]
  uint32_t pll_out_div_i; // [sp+850h] [bp+830h]
  float pll_out_div_f; // [sp+854h] [bp+834h]
  uint8_t fbdiv; // [sp+85Bh] [bp+83Bh]
  float min_vco; // [sp+85Ch] [bp+83Ch]
  float max_vco; // [sp+860h] [bp+840h]
  uint8_t refdiv; // [sp+866h] [bp+846h]
  bool need_recal; // [sp+867h] [bp+847h]
  float decimals_last; // [sp+868h] [bp+848h]
  uint8_t postdiv; // [sp+86Eh] [bp+84Eh]
  uint8_t pll_div; // [sp+86Fh] [bp+84Fh]
  uint8_t postdiv2; // [sp+870h] [bp+850h]
  uint8_t postdiv1; // [sp+871h] [bp+851h]
  uint8_t refdiv_choice; // [sp+872h] [bp+852h]
  uint8_t fbdiv_choice; // [sp+873h] [bp+853h]
  float pll_vco_step; // [sp+874h] [bp+854h]
  float pll_vco_choice; // [sp+878h] [bp+858h]
  float pll_vco; // [sp+87Ch] [bp+85Ch]

  pll_vco_choice = 0.0;
  refdiv = 0;
  fbdiv_choice = 0;
  refdiv_choice = 0;
  postdiv1 = 1;
  postdiv2 = 1;
  pll_div = 1;
  postdiv = 0;
  decimals_last = 25.0;
  max_vco = 2800.0;
  min_vco = 2400.0;
  need_recal = 0;
  pll_vco = 2800.0;
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        if ( pll_vco >= 3125.0 )
          pll_vco_step = 25.0;
        else
          pll_vco_step = 12.5;
        if ( need_recal )
        {
          pll_vco = pll_vco_choice - pll_vco_step;
          need_recal = 0;
          decimals_last = 25.0;
        }
        refdiv = (unsigned int)(float)(25.0 / pll_vco_step);
        fbdiv = (unsigned int)(float)((float)((float)refdiv * pll_vco) / 25.0);
        pll_out_div_f = pll_vco / v4;
        pll_out_div_i = (unsigned int)(float)(pll_vco / v4);
        decimals = (float)(pll_vco / v4) - (float)pll_out_div_i;
        if ( decimals < decimals_last )
        {
          postdiv = pll_out_div_i;
          pll_vco_choice = pll_vco;
          fbdiv_choice = fbdiv;
          refdiv_choice = refdiv;
          decimals_last = decimals;
        }
        pll_vco = pll_vco - pll_vco_step;
      }
      while ( pll_vco >= min_vco );
      if ( postdiv <= 0x10u )
      {
        pll_div = postdiv;
        postdiv2 = 1;
        postdiv1 = 1;
LABEL_57:
        real_freq = (float)((float)(25.0 / (float)refdiv_choice) * (float)fbdiv_choice)
                  / (float)(pll_div * postdiv2 * postdiv1);
        if ( divider )
          *(float *)divider = (float)((float)(25.0 / (float)refdiv_choice) * (float)fbdiv_choice)
                            / (float)(postdiv2 * postdiv1);
        *(_DWORD *)LODWORD(freq) = postdiv2 | (fbdiv_choice << 16) | (refdiv_choice << 8) | (16 * postdiv1);
        *(_BYTE *)pll_param = pll_div;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Want freq %f  real freq %f", v4, real_freq);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "pll_vco %f, fbdiv %#x refdiv %#x postdiv1 %#x postdiv2 %#x, pll_divider %d ,{pll_value %#x}",
            pll_vco_choice,
            fbdiv_choice,
            refdiv_choice,
            postdiv1,
            postdiv2,
            *(unsigned __int8 *)pll_param,
            *(_DWORD *)LODWORD(freq));
          applog(7, tmp42, 0);
        }
        return 0;
      }
      pll_div = 16;
      while ( 1 )
      {
        v5 = pll_div--;
        if ( v5 <= 2 )
          break;
        postdiv_f = (float)postdiv / (float)pll_div;
        postdiv_i = (unsigned int)postdiv_f;
        decimals = postdiv_f - (float)(unsigned int)postdiv_f;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "pll_div decimals %f postdiv_f %f", decimals, postdiv_f);
          applog(7, tmp42, 0);
        }
        if ( decimals < 0.0001 )
        {
          postdiv /= pll_div;
          break;
        }
      }
      if ( pll_div != 2 || (postdiv & 1) == 0 )
        break;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "need recal 1");
        applog(7, tmp42, 0);
      }
      if ( pll_vco_choice <= min_vco )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "!!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll");
          applog(3, tmp42, 0);
        }
        *(_DWORD *)LODWORD(freq) = 7864593;
        *(_BYTE *)pll_param = 15;
        return -1;
      }
      pll_vco = pll_vco_choice;
      need_recal = 1;
    }
    if ( postdiv <= 7u )
    {
      postdiv1 = postdiv;
      postdiv2 = 1;
      goto LABEL_57;
    }
    postdiv1 = 7;
    postdiv2 = 1;
    while ( postdiv1-- )
    {
      postdiv_f_0 = (float)postdiv / (float)postdiv1;
      postdiv_i_0 = (unsigned int)postdiv_f_0;
      decimals = postdiv_f_0 - (float)(unsigned int)postdiv_f_0;
      if ( decimals < 0.0001 )
      {
        postdiv2 = (unsigned int)postdiv_f_0;
        break;
      }
    }
    if ( postdiv1 >= (unsigned int)postdiv2 && postdiv2 <= 7u )
      break;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "need recal 2");
      applog(7, tmp42, 0);
    }
    if ( pll_vco_choice <= min_vco )
      break;
    pll_vco = pll_vco_choice;
    need_recal = 1;
  }
  if ( postdiv == postdiv2 * postdiv1 )
    goto LABEL_57;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "Don't find postdiv1 %d * postdiv2 %d = postdiv %d", postdiv1, postdiv2, postdiv);
    applog(3, tmp42, 0);
  }
  *(_DWORD *)LODWORD(freq) = 7864593;
  *(_BYTE *)pll_param = 15;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "!!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll");
    applog(3, tmp42, 0);
  }
  return -1;
}
// 12B3E: variable 'v4' is possibly undefined

//----- (000132B0) --------------------------------------------------------
int is_T11()
{
  return 1;
}

//----- (000132C0) --------------------------------------------------------
int is_T11a()
{
  return 0;
}

//----- (000132D0) --------------------------------------------------------
int is_T11b()
{
  return 0;
}

//----- (000132E0) --------------------------------------------------------
int is_special_mode()
{
  return 0;
}

//----- (000132F0) --------------------------------------------------------
void __cdecl chain_inactive(unsigned __int8 chain)
{
  unsigned int cmd_buf[3]; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 buf[5]; // [sp+30h] [bp+18h] BYREF
  FILE *pFile; // [sp+38h] [bp+20h]
  unsigned int value; // [sp+3Ch] [bp+24h]
  unsigned int ret; // [sp+40h] [bp+28h]
  FILE *pFile_0; // [sp+44h] [bp+2Ch]

  buf[0] = 0;
  buf[1] = 0;
  buf[2] = 0;
  buf[3] = 0;
  buf[4] = 5;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    buf[0] = 83;
    buf[1] = 5;
    buf[2] = 0;
    buf[3] = 0;
    buf[4] = CRC5(buf, 0x20u);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x\n",
          "asic.c",
          502,
          (const char *)_FUNCTION___11424,
          buf[0],
          buf[1],
          buf[2],
          buf[3],
          buf[4]);
      fclose(pFile_0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = buf[4] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
  else
  {
    buf[0] = -125;
    buf[1] = 0;
    buf[2] = 0;
    buf[3] = CRC5(buf, 0x1Bu);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
          "asic.c",
          486,
          (const char *)_FUNCTION___11424,
          buf[0],
          buf[1],
          buf[2],
          buf[3]);
      fclose(pFile);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (00013508) --------------------------------------------------------
void __cdecl set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address)
{
  unsigned int cmd_buf[3]; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+30h] [bp+18h] BYREF
  FILE *pFile; // [sp+3Ch] [bp+24h]
  unsigned int value; // [sp+40h] [bp+28h]
  unsigned int ret; // [sp+44h] [bp+2Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( opt_multi_version )
  {
    buf[0] = 64;
    buf[1] = 5;
    buf[2] = address;
    buf[3] = 0;
    buf[4] = CRC5(buf, 0x20u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = buf[4] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
  else
  {
    buf[0] = 0;
    buf[1] = address;
    buf[2] = 0;
    if ( mode )
      buf[0] |= 0x80u;
    buf[3] = CRC5(buf, 0x1Bu);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
          "asic.c",
          533,
          (const char *)_FUNCTION___11438,
          buf[0],
          buf[1],
          buf[2],
          buf[3]);
      fclose(pFile);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (000136B2) --------------------------------------------------------
int __cdecl calculate_core_number(unsigned int actual_core_number)
{
  FILE *pFile; // [sp+10h] [bp+8h]

  if ( actual_core_number == 1 )
    return 1;
  if ( actual_core_number == 2 )
    return 2;
  if ( actual_core_number > 2 && actual_core_number <= 4 )
    return 4;
  if ( actual_core_number > 4 && actual_core_number <= 8 )
    return 8;
  if ( actual_core_number > 8 && actual_core_number <= 0x10 )
    return 16;
  if ( actual_core_number > 0x10 && actual_core_number <= 0x20 )
    return 32;
  if ( actual_core_number > 0x20 && actual_core_number <= 0x40 )
    return 64;
  if ( actual_core_number > 0x40 && actual_core_number <= 0x80 )
    return 128;
  if ( actual_core_number > 0x80 && actual_core_number <= 0xD0 )
    return 256;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: actual_core_number = %d, but it is error\n",
        "asic.c",
        650,
        (const char *)_FUNCTION___11452,
        actual_core_number);
    fclose(pFile);
  }
  return -1;
}

//----- (000137D4) --------------------------------------------------------
void __cdecl set_core_number_BM1390(unsigned __int8 which_chain, unsigned __int8 chip_addr)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp+14h] BYREF
  unsigned int value; // [sp+20h] [bp+20h]

  *(_DWORD *)buf = 2369;
  *(_DWORD *)&buf[4] = 13669139;
  buf[8] = 0;
  buf[7] = chip_addr;
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  set_BC_command_buffer(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (which_chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (00013896) --------------------------------------------------------
void __cdecl set_addr_one_chain(const uint8_t chain)
{
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  unsigned __int8 chip_addr; // [sp+23h] [bp+13h]
  int j; // [sp+24h] [bp+14h]

  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: -- %d, -- interval %d\n",
        "asic.c",
        688,
        (const char *)_FUNCTION___11467,
        chain,
        dev->addrInterval);
    fclose(pFile);
  }
  if ( dev->chain_exist[chain] == 1 && dev->chain_asic_num[chain] )
  {
    chip_addr = 0;
    chain_inactive(chain);
    cgsleep_ms(30);
    chain_inactive(chain);
    cgsleep_ms(30);
    chain_inactive(chain);
    cgsleep_ms(30);
    for ( j = 0; j < 256 / dev->addrInterval; ++j )
    {
      set_address(chain, 0, chip_addr);
      cgsleep_ms(2);
      set_core_number_BM1390(chain, chip_addr);
      chip_addr += dev->addrInterval;
      cgsleep_ms(50);
    }
  }
}

//----- (000139FA) --------------------------------------------------------
void init_address_info()
{
  unsigned __int8 check_bit; // [sp+7h] [bp+7h]

  dev->check_bit = 0;
  dev->corenum = -48;
  dev->addrInterval = 4;
  for ( check_bit = dev->addrInterval - 1; check_bit; check_bit >>= 1 )
    ++dev->check_bit;
}

//----- (00013A90) --------------------------------------------------------
void __cdecl enable_core_clock_BM1393(unsigned __int8 core_id, unsigned __int8 mode, unsigned __int8 chain)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp+14h] BYREF
  unsigned int value; // [sp+20h] [bp+20h]
  unsigned int ret; // [sp+24h] [bp+24h]

  *(_DWORD *)buf = 65;
  *(_DWORD *)&buf[4] = 0;
  buf[8] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    buf[0] |= 0x10u;
  buf[1] = 9;
  buf[2] = 0;
  strcpy((char *)&buf[3], "<");
  buf[5] = core_id;
  buf[6] = -124;
  buf[7] = -86;
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  set_BC_command_buffer(cmd_buf);
  ret = get_BC_write_command();
  value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
  usleep(0x1388u);
}

//----- (00013B6C) --------------------------------------------------------
void __cdecl set_core_cmd_BM1393(core_cmd *core)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp+14h] BYREF
  unsigned int ret; // [sp+24h] [bp+24h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( core )
  {
    buf[0] = 65;
    if ( core->mode )
      buf[0] |= 0x10u;
    buf[1] = 9;
    buf[2] = core->chip_addr;
    strcpy((char *)&buf[3], "<");
    if ( core->core_mode )
      buf[4] = 0x80;
    buf[5] = core->core_id;
    buf[6] = core->cmd_type | (core->rw_falg << 7);
    buf[7] = core->reg_data;
    buf[8] = 0;
    buf[8] = CRC5(buf, 0x40u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
    cmd_buf[2] = buf[8] << 24;
    set_BC_command_buffer(cmd_buf);
    ret = get_BC_write_command();
    set_BC_write_command(ret & 0xFFF0FFFF | (core->chain << 16) | 0x80800000);
  }
}

//----- (00013C6C) --------------------------------------------------------
void __cdecl set_config_BM1393_t(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 mode,
        unsigned __int8 reg,
        unsigned int reg_data)
{
  unsigned int cmd_buf[8]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+2Ch] [bp+2Ch] BYREF
  unsigned int value; // [sp+38h] [bp+38h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    buf[0] = 81;
  else
    buf[0] = 65;
  buf[1] = 9;
  buf[2] = chip_addr;
  buf[3] = reg;
  buf[4] = HIBYTE(reg_data);
  buf[5] = BYTE2(reg_data);
  buf[6] = BYTE1(reg_data);
  buf[7] = reg_data;
  if ( reg == 20 )
    cmd_buf[7] = bit_swap_table[reg];
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  set_BC_command_buffer_t(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (which_chain << 16) | 0x80800000;
  set_BC_write_command_t(value);
}

//----- (00013D92) --------------------------------------------------------
void __cdecl set_config_BM1393(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 mode,
        unsigned __int8 reg,
        unsigned int reg_data)
{
  unsigned int cmd_buf[8]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+2Ch] [bp+2Ch] BYREF
  unsigned int value; // [sp+38h] [bp+38h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    buf[0] = 81;
  else
    buf[0] = 65;
  buf[1] = 9;
  buf[2] = chip_addr;
  buf[3] = reg;
  buf[4] = HIBYTE(reg_data);
  buf[5] = BYTE2(reg_data);
  buf[6] = BYTE1(reg_data);
  buf[7] = reg_data;
  if ( reg == 20 )
    cmd_buf[7] = bit_swap_table[reg];
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  set_BC_command_buffer(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (which_chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (00013EB8) --------------------------------------------------------
void __cdecl read_asic_register(
        unsigned __int8 chain,
        unsigned __int8 mode,
        unsigned __int8 chip_addr,
        unsigned __int8 reg_addr)
{
  int hash_on_plug; // r0
  unsigned int cmd_buf[3]; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 buf[5]; // [sp+30h] [bp+18h] BYREF
  FILE *pFile; // [sp+38h] [bp+20h]
  unsigned int value; // [sp+3Ch] [bp+24h]
  FILE *pFile_1; // [sp+40h] [bp+28h]
  unsigned int ret; // [sp+44h] [bp+2Ch]
  FILE *pFile_0; // [sp+48h] [bp+30h]
  int wait_count; // [sp+4Ch] [bp+34h]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  wait_count = 0;
  if ( opt_multi_version )
  {
    buf[0] = 66;
    if ( mode )
      buf[0] |= 0x10u;
    buf[1] = 5;
    buf[2] = chip_addr;
    buf[3] = reg_addr;
    buf[4] = CRC5(buf, 0x20u);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: VIL buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x\n",
          "asic.c",
          982,
          (const char *)_FUNCTION___11548,
          buf[0],
          buf[1],
          buf[2],
          buf[3],
          buf[4]);
      fclose(pFile_0);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = buf[4] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
      if ( ++wait_count > 3000 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
          {
            hash_on_plug = get_hash_on_plug();
            fprintf(
              pFile_1,
              "%s:%d:%s: Error: clement debug: wait BC ready timeout, PLUG ON=0x%08x..\n",
              "asic.c",
              997,
              (const char *)_FUNCTION___11548,
              hash_on_plug);
          }
          fclose(pFile_1);
        }
        break;
      }
    }
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
  else
  {
    buf[0] = 2;
    buf[1] = chip_addr;
    buf[2] = reg_addr;
    if ( mode )
      buf[0] |= 0x80u;
    buf[3] = CRC5(buf, 0x1Bu);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
          "asic.c",
          964,
          (const char *)_FUNCTION___11548,
          buf[0],
          buf[1],
          buf[2],
          buf[3]);
      fclose(pFile);
    }
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    set_BC_command_buffer(cmd_buf);
    value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (0001418C) --------------------------------------------------------
void __cdecl read_temp(
        unsigned __int8 device,
        unsigned int reg,
        unsigned __int8 data,
        unsigned __int8 write,
        unsigned __int8 chip_addr,
        int chain)
{
  unsigned int cmd_buf[3]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+18h] [bp+18h] BYREF
  unsigned int value; // [sp+24h] [bp+24h]
  unsigned int ret; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  i = chain;
  if ( opt_multi_version )
  {
    qmemcpy(buf, "A\t", 2);
    buf[2] = chip_addr;
    buf[3] = 28;
    buf[4] = 1;
    buf[5] = write | device;
    buf[6] = reg;
    buf[7] = data;
    buf[8] = CRC5(buf, 0x40u);
    cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
    cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
    cmd_buf[2] = buf[8] << 24;
    while ( 1 )
    {
      ret = get_BC_write_command();
      if ( (ret & 0x80000000) == 0 )
        break;
      cgsleep_ms(1);
    }
    set_BC_command_buffer(cmd_buf);
    value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
    set_BC_write_command(value);
  }
}

//----- (00014284) --------------------------------------------------------
void __cdecl set_baud_one_chain(unsigned __int8 bauddiv, int change_fpga_baud, const uint8_t chain)
{
  unsigned int cmd_buf[4]; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 buf[10]; // [sp+34h] [bp+1Ch] BYREF
  FILE *pFile_2; // [sp+40h] [bp+28h]
  FILE *pFile_1; // [sp+44h] [bp+2Ch]
  FILE *pFile; // [sp+48h] [bp+30h]
  unsigned int value; // [sp+4Ch] [bp+34h]
  unsigned int ret; // [sp+50h] [bp+38h]
  FILE *pFile_0; // [sp+54h] [bp+3Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( dev->chain_exist[chain] == 1 )
  {
    if ( opt_multi_version )
    {
      gBM1393_MISC_CONTROL_reg = gBM1393_MISC_CONTROL_reg & 0xFFFFE0FF | (bauddiv << 8) & 0x1F00;
      strcpy((char *)buf, "Q\t");
      buf[3] = 24;
      buf[4] = HIBYTE(gBM1393_MISC_CONTROL_reg);
      buf[5] = BYTE2(gBM1393_MISC_CONTROL_reg);
      buf[6] = BYTE1(gBM1393_MISC_CONTROL_reg);
      buf[7] = gBM1393_MISC_CONTROL_reg;
      buf[8] = CRC5(buf, 0x40u);
      cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
      cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
      cmd_buf[2] = buf[8] << 24;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: cmd_buf[0]=0x%x, cmd_buf[1]=0x%x, cmd_buf[2]=0x%x, misc=0x%x\n",
            "asic.c",
            1126,
            (const char *)_FUNCTION___11588,
            cmd_buf[0],
            cmd_buf[1],
            cmd_buf[2],
            gBM1393_MISC_CONTROL_reg);
        fclose(pFile_0);
      }
      set_BC_command_buffer(cmd_buf);
      ret = get_BC_write_command();
      value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
      set_BC_write_command(value);
    }
    else
    {
      buf[1] = 16;
      buf[2] = bauddiv & 0x1F;
      buf[0] = -122;
      buf[3] = CRC5(buf, 0x1Bu);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
            "asic.c",
            1100,
            (const char *)_FUNCTION___11588,
            buf[0],
            buf[1],
            buf[2],
            buf[3]);
        fclose(pFile);
      }
      cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
      set_BC_command_buffer(cmd_buf);
      ret = get_BC_write_command();
      value = ret & 0xFFF0FFFF | (chain << 16) | 0x80800000;
      set_BC_write_command(value);
    }
    if ( change_fpga_baud )
    {
      cgsleep_us(50000LL);
      ret = get_BC_write_command();
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: read bc write is 0x%0x\n", "asic.c", 1139, (const char *)_FUNCTION___11588, ret);
        fclose(pFile_1);
      }
      value = bauddiv & 0x3F | ret & 0xFFFFFFC0;
      set_BC_write_command(value);
      dev->baud = bauddiv;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, "%s:%d:%s: set baud %d\n", "asic.c", 1144, (const char *)_FUNCTION___11588, dev->baud);
        fclose(pFile_2);
      }
    }
  }
}

//----- (00014674) --------------------------------------------------------
void __cdecl set_baud(unsigned __int8 bauddiv, int no_use)
{
  FILE *pFile_0; // [sp+18h] [bp+10h]
  unsigned int ret; // [sp+1Ch] [bp+14h]
  FILE *pFile; // [sp+20h] [bp+18h]
  unsigned int i; // [sp+24h] [bp+1Ch]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set baud=%d\n", "asic.c", 1153, (const char *)_FUNCTION___11600, bauddiv);
    fclose(pFile);
  }
  for ( i = 0; i <= 0xF; ++i )
    set_baud_one_chain(bauddiv, 0, i);
  cgsleep_us(50000LL);
  ret = get_BC_write_command();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: read bc write is 0x%0x\n", "asic.c", 1164, (const char *)_FUNCTION___11600, ret);
    fclose(pFile_0);
  }
  set_BC_write_command(bauddiv & 0x3F | ret & 0xFFFFFFC0);
  dev->baud = bauddiv;
}

//----- (000147C2) --------------------------------------------------------
void __cdecl set_baud_by_chain(unsigned __int8 bauddiv, int chain)
{
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  unsigned int ret; // [sp+20h] [bp+10h]
  FILE *pFile; // [sp+24h] [bp+14h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: chain %d set baud=%d\n",
        "asic.c",
        1176,
        (const char *)_FUNCTION___11612,
        chain,
        bauddiv);
    fclose(pFile);
  }
  set_baud_one_chain(bauddiv, 0, chain);
  cgsleep_us(50000LL);
  ret = get_BC_write_command();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: read bc write is 0x%0x\n", "asic.c", 1184, (const char *)_FUNCTION___11612, ret);
    fclose(pFile_0);
  }
  set_BC_write_command(bauddiv & 0x3F | ret & 0xFFFFFFC0);
  dev->baud = bauddiv;
}

//----- (00014902) --------------------------------------------------------
void set_working_uart_baud()
{
  set_baud(1u, 1);
}

//----- (00014912) --------------------------------------------------------
void set_default_uart_baud()
{
  gBM1393_MISC_CONTROL_reg = 14849;
}

//----- (0001492E) --------------------------------------------------------
void __cdecl set_asic_ticket_mask(unsigned int ticket_mask)
{
  char ticket_maska; // [sp+1Ch] [bp+4h]
  unsigned int cmd_buf[3]; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 buf[9]; // [sp+30h] [bp+18h] BYREF
  FILE *pFile; // [sp+3Ch] [bp+24h]
  unsigned int value; // [sp+40h] [bp+28h]
  unsigned int ret; // [sp+44h] [bp+2Ch]
  unsigned int tm; // [sp+48h] [bp+30h]
  unsigned int i; // [sp+4Ch] [bp+34h]

  ticket_maska = ticket_mask;
  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  tm = (ticket_mask << 24) | HIBYTE(ticket_mask) | (ticket_mask >> 8) & 0xFF00 | (ticket_mask << 8) & 0xFF0000;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( opt_multi_version )
      {
        strcpy((char *)buf, "Q\t");
        buf[3] = 20;
        *(_DWORD *)&buf[4] = tm;
        buf[4] = bit_swap_table[(unsigned __int8)tm];
        buf[5] = bit_swap_table[BYTE1(tm)];
        buf[6] = bit_swap_table[BYTE2(tm)];
        buf[7] = bit_swap_table[HIBYTE(tm)];
        buf[8] = CRC5(buf, 0x40u);
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
        cmd_buf[2] = buf[8] << 24;
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
      else
      {
        buf[1] = 16;
        buf[2] = ticket_maska & 0x1F;
        buf[0] = -122;
        buf[3] = CRC5(buf, 0x1Bu);
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
              "asic.c",
              1283,
              (const char *)_FUNCTION___11639,
              buf[0],
              buf[1],
              buf[2],
              buf[3]);
          fclose(pFile);
        }
        cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
        set_BC_command_buffer(cmd_buf);
        ret = get_BC_write_command();
        value = ret & 0xFFF0FFFF | (i << 16) | 0x80800000;
        set_BC_write_command(value);
      }
    }
  }
}

//----- (00014B80) --------------------------------------------------------
void __cdecl set_misc_control(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 addr, int i2c)
{
  unsigned int cmd_buf[3]; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 buf[9]; // [sp+2Ch] [bp+14h] BYREF
  unsigned int value; // [sp+38h] [bp+20h]
  FILE *pFile; // [sp+40h] [bp+28h]
  unsigned int temp_misc; // [sp+44h] [bp+2Ch]

  memset(buf, 0, sizeof(buf));
  memset(cmd_buf, 0, sizeof(cmd_buf));
  temp_misc = gBM1393_MISC_CONTROL_reg;
  if ( i2c )
    temp_misc |= 0x4060u;
  buf[0] = 65;
  if ( mode )
    buf[0] |= 0x10u;
  buf[1] = 9;
  buf[2] = addr;
  buf[3] = 24;
  buf[4] = HIBYTE(temp_misc);
  buf[5] = BYTE2(temp_misc);
  buf[6] = BYTE1(temp_misc);
  buf[7] = temp_misc;
  buf[8] = CRC5(buf, 0x40u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = _byteswap_ulong(*(unsigned int *)&buf[4]);
  cmd_buf[2] = buf[8] << 24;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: cmd_buf[0]=0x%x, cmd_buf[1]=0x%x, cmd_buf[2]=0x%x, misc=0x%x\n",
        "asic.c",
        1429,
        (const char *)_FUNCTION___11677,
        cmd_buf[0],
        cmd_buf[1],
        cmd_buf[2],
        temp_misc);
    fclose(pFile);
  }
  set_BC_command_buffer(cmd_buf);
  value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (00014CFC) --------------------------------------------------------
unsigned int __cdecl check_asic_reg_with_addr(
        unsigned int reg,
        unsigned __int8 chip_addr,
        unsigned int chain,
        int check_num)
{
  FILE *pFile_0; // [sp+20h] [bp+10h]
  FILE *pFile; // [sp+24h] [bp+14h]
  unsigned int reg_buf; // [sp+28h] [bp+18h]
  unsigned int reg_value_num; // [sp+2Ch] [bp+1Ch]
  int not_reg_data_time; // [sp+30h] [bp+20h]
  unsigned int i; // [sp+34h] [bp+24h]

  not_reg_data_time = 0;
  LOBYTE(i) = chain;
  while ( 1 )
  {
    clear_register_value_buf();
    read_asic_register(i, 0, chip_addr, reg);
    cgsleep_ms(20);
LABEL_28:
    if ( not_reg_data_time > 4 )
    {
      clear_register_value_buf();
      return 0;
    }
    pthread_mutex_lock(&reg_mutex);
    reg_value_num = reg_value_buf.reg_value_num;
    pthread_mutex_unlock(&reg_mutex);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: reg_value_num %d\n",
          "temperature.c",
          127,
          (const char *)_FUNCTION___11638,
          reg_value_num);
      fclose(pFile);
    }
    if ( reg_value_num <= 0x1FE && reg_value_buf.p_rd <= 0x1FE && reg_value_num )
      break;
    ++not_reg_data_time;
  }
  pthread_mutex_lock(&reg_mutex);
  for ( i = 0; ; ++i )
  {
    if ( reg_value_num <= i )
    {
      pthread_mutex_unlock(&reg_mutex);
      goto LABEL_28;
    }
    reg_buf = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
    if ( chain != reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number )
    {
      ++reg_value_buf.p_rd;
      --reg_value_buf.reg_value_num;
      if ( reg_value_buf.p_rd > 0x1FE )
        reg_value_buf.p_rd = 0;
      continue;
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chip %x reg %x reg_buff %x\n",
          "temperature.c",
          155,
          (const char *)_FUNCTION___11638,
          chip_addr,
          reg,
          reg_buf);
      fclose(pFile_0);
    }
    ++reg_value_buf.p_rd;
    --reg_value_buf.reg_value_num;
    if ( reg_value_buf.p_rd > 0x1FE )
      reg_value_buf.p_rd = 0;
    if ( reg == 28 )
      break;
  }
  pthread_mutex_unlock(&reg_mutex);
  clear_register_value_buf();
  if ( (reg_buf & 0xC0000000) != 0 )
    return 0;
  else
    return reg_buf;
}
// 14DEA: conditional instruction was optimized away because %not_reg_data_time.4<5
// 14DF8: conditional instruction was optimized away because %not_reg_data_time.4<5

//----- (00014FC4) --------------------------------------------------------
unsigned int __cdecl wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update)
{
  unsigned __int8 chip_addra; // [sp+Ch] [bp+Ch]
  unsigned int ret; // [sp+10h] [bp+10h]
  int fail_time; // [sp+14h] [bp+14h]

  chip_addra = chip_addr;
  for ( fail_time = 0; fail_time <= 3; ++fail_time )
  {
    ret = check_asic_reg_with_addr(0x1Cu, chip_addra, chain, 1);
    if ( ret )
      return ret;
    cgsleep_ms(1);
  }
  return 0;
}

//----- (00015012) --------------------------------------------------------
unsigned int __cdecl check_reg_temp(
        unsigned __int8 device,
        unsigned int reg,
        unsigned __int8 data,
        unsigned __int8 write,
        unsigned __int8 chip_addr,
        int chain)
{
  unsigned int ret; // [sp+10h] [bp+8h]
  int fail_time; // [sp+14h] [bp+Ch]

  fail_time = 0;
  if ( write )
  {
    do
    {
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, data, write, chip_addr, chain);
      wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, 0, 0, chip_addr, chain);
      ret = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      ++fail_time;
    }
    while ( reg != BYTE1(ret) && (unsigned __int8)ret != data && fail_time <= 1 );
  }
  else
  {
    do
    {
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(device, reg, data, 0, chip_addr, chain);
      cgsleep_ms(1);
      ret = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      ++fail_time;
    }
    while ( reg != BYTE1(ret) && fail_time <= 1 );
  }
  if ( fail_time == 2 )
    return 0;
  else
    return ret;
}

//----- (00015128) --------------------------------------------------------
int8_t __cdecl calc_offset_simple(int remote, int local)
{
  return local - remote;
}

//----- (0001514C) --------------------------------------------------------
int16_t __cdecl get_remote(int16_t remote)
{
  return remote - 64;
}

//----- (0001516E) --------------------------------------------------------
int16_t __cdecl get_local(int16_t local)
{
  return local - 64;
}

//----- (00015190) --------------------------------------------------------
void __cdecl do_calibration_sensor_offset_by_eeprom(
        unsigned __int8 device,
        unsigned __int8 chip_addr,
        int chain,
        int temp_chip_index)
{
  FILE *pFile; // [sp+28h] [bp+10h]

  check_reg_temp(device, 9u, 4u, 1u, chip_addr, chain);
  check_reg_temp(device, 0x11u, middle_Offset[6 * chain + temp_chip_index], 1u, chip_addr, chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: New offset - Chain[%d] Chip[%d] local:%hhd remote:%hhd offset:%hhd \n",
        "temperature.c",
        337,
        (const char *)_FUNCTION___11695,
        chain,
        (chip_addr >> 2) + 1,
        0,
        0,
        middle_Offset[6 * chain + temp_chip_index]);
    fclose(pFile);
  }
}

//----- (00015298) --------------------------------------------------------
int8_t __cdecl do_calibration_sensor_offset(
        unsigned __int8 device,
        unsigned __int8 chip_addr,
        int chain,
        int temp_chip_index)
{
  int v4; // r3
  FILE *pFile_1; // [sp+28h] [bp+10h]
  FILE *pFile_0; // [sp+2Ch] [bp+14h]
  FILE *pFile; // [sp+30h] [bp+18h]
  int8_t middle; // [sp+37h] [bp+1Fh]
  unsigned __int8 ret; // [sp+38h] [bp+20h]
  int8_t local; // [sp+3Ah] [bp+22h]
  int8_t offset; // [sp+3Bh] [bp+23h]
  int wait_times; // [sp+3Ch] [bp+24h]

  wait_times = 0;
  if ( dev->TempChipType[chain][temp_chip_index] != 26 && dev->TempChipType[chain][temp_chip_index] != 85 )
  {
    DEVICEADDR[chain] = -104;
    device = DEVICEADDR[chain];
    dev->TempChipType[chain][temp_chip_index] = check_reg_temp(device, 0xFEu, 0, 0, chip_addr, chain);
    if ( dev->TempChipType[chain][temp_chip_index] != 26 && dev->TempChipType[chain][temp_chip_index] != 85 )
    {
      DEVICEADDR[chain] = -102;
      device = DEVICEADDR[chain];
      dev->TempChipType[chain][temp_chip_index] = check_reg_temp(device, 0xFEu, 0, 0, chip_addr, chain);
      if ( dev->TempChipType[chain][temp_chip_index] != 26 && dev->TempChipType[chain][temp_chip_index] != 85 )
      {
        DEVICEADDR[chain] = -100;
        device = DEVICEADDR[chain];
        dev->TempChipType[chain][temp_chip_index] = check_reg_temp(device, 0xFEu, 0, 0, chip_addr, chain);
      }
    }
  }
  if ( dev->TempChipType[chain][temp_chip_index] == 26 )
    is218_Temp = 1;
  check_reg_temp(device, 9u, 4u, 1u, chip_addr, chain);
  while ( 1 )
  {
    check_reg_temp(device, 0x11u, 0, 1u, chip_addr, chain);
    ret = check_reg_temp(device, 0, 0, 0, chip_addr, chain);
    local = get_local(ret);
    middle = check_reg_temp(device, 1u, 0, 0, chip_addr, chain) - 64;
    if ( local <= 40 )
    {
      v4 = local - middle;
      if ( v4 < 0 )
        v4 = middle - local;
      if ( v4 <= 7 )
        break;
    }
    if ( wait_times > 2 )
      break;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: too hot! local:%d, remote:%d,  wait 20s......\n",
          "temperature.c",
          397,
          (const char *)_FUNCTION___11709,
          local,
          middle);
      fclose(pFile);
    }
    set_PWM(0x64u);
    sleep(0x14u);
    ++wait_times;
  }
  if ( wait_times > 2 && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: calibrate at risk...\n", "temperature.c", 405, (const char *)_FUNCTION___11709);
    fclose(pFile_0);
  }
  offset = calc_offset_simple(middle, local);
  check_reg_temp(device, 0x11u, offset, 1u, chip_addr, chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: Chain[%d] Chip[%d]:local:%hhd remote:%hhd offset:%hhd \n",
        "temperature.c",
        425,
        (const char *)_FUNCTION___11709,
        chain,
        (chip_addr >> 2) + 1,
        local,
        middle,
        offset);
    fclose(pFile_1);
  }
  return offset;
}

//----- (00015776) --------------------------------------------------------
bool __cdecl is_tempsensor_data_correct(temp_info_t temp_info)
{
  int v2; // r3
  FILE *pFile; // [sp+14h] [bp+4h]
  FILE *pFile_0; // [sp+18h] [bp+8h]
  FILE *pFile_1; // [sp+1Ch] [bp+Ch]
  FILE *pFile_2; // [sp+20h] [bp+10h]
  uint32_t i; // [sp+24h] [bp+14h]

  if ( temp_info.type == TMP451 )
  {
    if ( temp_info.num && temp_info.num <= 6 )
    {
      for ( i = 0; ; ++i )
      {
        if ( i >= temp_info.num )
          return 1;
        if ( temp_info.pos[i] <= 0 || temp_info.pos[i] > 60 )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: Bad,temp_info.pos[%d] = %d\n",
                "temperature.c",
                529,
                (const char *)_FUNCTION___11719,
                i,
                temp_info.pos[i]);
            fclose(pFile_1);
          }
          return 0;
        }
        v2 = temp_info.offset[i];
        if ( v2 < 0 )
          v2 = -v2;
        if ( v2 > 9 )
          break;
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: Bad,temp_info.pos[%d] = %d\n",
            "temperature.c",
            535,
            (const char *)_FUNCTION___11719,
            i,
            temp_info.offset[i]);
        fclose(pFile_2);
      }
      return 0;
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Bad,temp_info.num = %d\n",
            "temperature.c",
            521,
            (const char *)_FUNCTION___11719,
            temp_info.num);
        fclose(pFile_0);
      }
      return 0;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Bad,temp_info.type = %d\n",
          "temperature.c",
          515,
          (const char *)_FUNCTION___11719,
          temp_info.type);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (000159DC) --------------------------------------------------------
void __cdecl get_temp_info_from_eeprom_by_chain(uint32_t chain)
{
  FILE *pFile_4; // [sp+14h] [bp+Ch]
  FILE *pFile_7; // [sp+18h] [bp+10h]
  FILE *pFile_8; // [sp+1Ch] [bp+14h]
  FILE *pFile_6; // [sp+20h] [bp+18h]
  FILE *pFile_5; // [sp+24h] [bp+1Ch]
  FILE *pFile_3; // [sp+28h] [bp+20h]
  FILE *pFile_2; // [sp+2Ch] [bp+24h]
  FILE *pFile_1; // [sp+30h] [bp+28h]
  FILE *pFile_0; // [sp+34h] [bp+2Ch]
  FILE *pFile; // [sp+38h] [bp+30h]
  int i; // [sp+3Ch] [bp+34h]
  int ia; // [sp+3Ch] [bp+34h]

  if ( !eeprom_get_temp_sensor_type(chain, &temp_info[chain].type) && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: get temp sensor type,error!\n", "temperature.c", 550, (const char *)_FUNCTION___11731);
    fclose(pFile);
  }
  if ( !eeprom_get_temp_sensor_pos(chain, (uint8_t *)temp_info[chain].pos, &temp_info[chain].num) && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: get temp sensor pos&num,error!\n",
        "temperature.c",
        555,
        (const char *)_FUNCTION___11731);
    fclose(pFile_0);
  }
  if ( !eeprom_get_temp_sensor_data(chain, (uint8_t *)temp_info[chain].offset, &temp_info[chain].num) && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: get temp sensor offset&num,error!\n",
        "temperature.c",
        560,
        (const char *)_FUNCTION___11731);
    fclose(pFile_1);
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(pFile_2, "sensor type = %d,sensor num = %d\n", temp_info[chain].type, temp_info[chain].num);
    fclose(pFile_2);
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fwrite("sensor pos:", 1u, 0xBu, pFile_3);
    fclose(pFile_3);
  }
  for ( i = 0; i <= 5; ++i )
  {
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, " %d ", temp_info[chain].pos[i]);
      fclose(pFile_4);
    }
  }
  if ( log_level > 3 )
  {
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fputc(10, pFile_5);
    fclose(pFile_5);
  }
  if ( log_level > 3 )
  {
    pFile_6 = fopen((const char *)log_file, "a+");
    if ( pFile_6 )
      fwrite("sensor offset:", 1u, 0xEu, pFile_6);
    fclose(pFile_6);
  }
  for ( ia = 0; ia <= 5; ++ia )
  {
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, " %d ", temp_info[chain].offset[ia]);
      fclose(pFile_7);
    }
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fputc(10, pFile_8);
    fclose(pFile_8);
  }
}

//----- (00015E40) --------------------------------------------------------
bool __cdecl is_eeprom_tempsensor_data_correct(uint8_t chain)
{
  int v2; // r3
  int8_t sensor_offset[6]; // [sp+24h] [bp+Ch] BYREF
  uint8_t sensor_pos[6]; // [sp+2Ch] [bp+14h] BYREF
  uint32_t sensor_num; // [sp+34h] [bp+1Ch] BYREF
  TEMP_SENSOR_TYPE sensor_type; // [sp+38h] [bp+20h] BYREF
  FILE *pFile_0; // [sp+3Ch] [bp+24h]
  FILE *pFile_1; // [sp+40h] [bp+28h]
  FILE *pFile_3; // [sp+44h] [bp+2Ch]
  FILE *pFile_5; // [sp+48h] [bp+30h]
  FILE *pFile_9; // [sp+4Ch] [bp+34h]
  FILE *pFile_10; // [sp+50h] [bp+38h]
  FILE *pFile_8; // [sp+54h] [bp+3Ch]
  FILE *pFile_7; // [sp+58h] [bp+40h]
  FILE *pFile_6; // [sp+5Ch] [bp+44h]
  FILE *pFile_4; // [sp+60h] [bp+48h]
  FILE *pFile_2; // [sp+64h] [bp+4Ch]
  FILE *pFile; // [sp+68h] [bp+50h]
  int i; // [sp+6Ch] [bp+54h]

  i = 0;
  sensor_type = 0;
  sensor_num = 0;
  memset(sensor_pos, 0, sizeof(sensor_pos));
  memset(sensor_offset, 0, sizeof(sensor_offset));
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: check sensor info ...\n", "temperature.c", 582, (const char *)_FUNCTION___11756);
    fclose(pFile);
  }
  if ( !eeprom_get_temp_sensor_type(chain, &sensor_type) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: get temp sensor type,error!\n",
          "temperature.c",
          586,
          (const char *)_FUNCTION___11756);
      fclose(pFile_0);
    }
    return 0;
  }
  else if ( sensor_type == TMP451 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%s:%d:%s: sensor type is TMP451\n", "temperature.c", 597, (const char *)_FUNCTION___11756);
      fclose(pFile_2);
    }
    usleep(0x186A0u);
    if ( !eeprom_get_temp_sensor_pos(chain, sensor_pos, &sensor_num) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: get temp sensor pos,error!\n",
            "temperature.c",
            604,
            (const char *)_FUNCTION___11756);
        fclose(pFile_3);
      }
      return 0;
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(pFile_4, "%s:%d:%s: %d\n", "temperature.c", 609, (const char *)_FUNCTION___11756, sensor_num);
        fclose(pFile_4);
      }
      if ( sensor_num )
      {
        if ( sensor_num > 1 )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_7 = fopen((const char *)log_file, "a+");
            if ( pFile_7 )
              fprintf(
                pFile_7,
                "%s:%d:%s: sensor num is %d\n",
                "temperature.c",
                623,
                (const char *)_FUNCTION___11756,
                sensor_num);
            fclose(pFile_7);
          }
          dev->chain_asic_temp_num[chain] = 4;
          for ( i = 0; i < sensor_num; ++i )
          {
            if ( !sensor_pos[i] || sensor_pos[i] > 0x3Cu )
              return 0;
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_8 = fopen((const char *)log_file, "a+");
            if ( pFile_8 )
              fprintf(
                pFile_8,
                "%s:%d:%s: sensor pos = %d, %d, %d, %d\n",
                "temperature.c",
                632,
                (const char *)_FUNCTION___11756,
                sensor_pos[0],
                sensor_pos[1],
                sensor_pos[2],
                sensor_pos[3]);
            fclose(pFile_8);
          }
          usleep(0x186A0u);
          if ( !eeprom_get_temp_sensor_data(chain, (uint8_t *)sensor_offset, &sensor_num) )
          {
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile_9 = fopen((const char *)log_file, "a+");
              if ( pFile_9 )
                fprintf(
                  pFile_9,
                  "%s:%d:%s: get temp sensor offset,error!\n",
                  "temperature.c",
                  639,
                  (const char *)_FUNCTION___11756);
              fclose(pFile_9);
            }
            return 0;
          }
          else
          {
            for ( i = 0; i < sensor_num; ++i )
            {
              v2 = sensor_offset[i];
              if ( v2 < 0 )
                v2 = -v2;
              if ( v2 > 50 )
                return 0;
            }
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile_10 = fopen((const char *)log_file, "a+");
              if ( pFile_10 )
                fprintf(
                  pFile_10,
                  "%s:%d:%s: chain[%d] temp sensor info, correct!\n",
                  "temperature.c",
                  650,
                  (const char *)_FUNCTION___11756,
                  chain);
              fclose(pFile_10);
            }
            return 1;
          }
        }
        else
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_6 = fopen((const char *)log_file, "a+");
            if ( pFile_6 )
              fprintf(
                pFile_6,
                "%s:%d:%s: sensor num is less than expected:%d\n",
                "temperature.c",
                618,
                (const char *)_FUNCTION___11756,
                sensor_num);
            fclose(pFile_6);
          }
          return 0;
        }
      }
      else
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_5 = fopen((const char *)log_file, "a+");
          if ( pFile_5 )
            fprintf(
              pFile_5,
              "%s:%d:%s: sensor num is %d, error\n",
              "temperature.c",
              613,
              (const char *)_FUNCTION___11756,
              0);
          fclose(pFile_5);
        }
        return 0;
      }
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: sensor type is not TMP451,error\n",
          "temperature.c",
          593,
          (const char *)_FUNCTION___11756);
      fclose(pFile_1);
    }
    return 0;
  }
}
// 161BA: conditional instruction was optimized away because %sensor_num.4!=0

//----- (000164A0) --------------------------------------------------------
int8_t __cdecl re_calibrate_sensor_offset(unsigned __int8 device, int chain)
{
  int8_t v2; // r0
  int8_t sensor_offset[4]; // [sp+24h] [bp+Ch] BYREF
  uint8_t sensor_pos[4]; // [sp+28h] [bp+10h] BYREF
  FILE *pFile_3; // [sp+2Ch] [bp+14h]
  FILE *pFile_2; // [sp+30h] [bp+18h]
  FILE *pFile_4; // [sp+34h] [bp+1Ch]
  FILE *pFile_1; // [sp+38h] [bp+20h]
  FILE *pFile_0; // [sp+3Ch] [bp+24h]
  FILE *pFile; // [sp+40h] [bp+28h]
  uint32_t sensor_num; // [sp+44h] [bp+2Ch]
  TEMP_SENSOR_TYPE sensor_type; // [sp+48h] [bp+30h]
  int i; // [sp+4Ch] [bp+34h]

  sensor_type = 0;
  sensor_num = 0;
  *(_DWORD *)sensor_pos = 0;
  *(_DWORD *)sensor_offset = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: start to calibrate the temp senosr offset value\n",
        "temperature.c",
        664,
        (const char *)_FUNCTION___11784);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: chain[%d] temp chip I2C addr=0x%02x\n",
        "temperature.c",
        666,
        (const char *)_FUNCTION___11784,
        chain,
        device);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: Warning: Chain[%d] has no temp offset in PIC! will fix it\n",
        "temperature.c",
        669,
        (const char *)_FUNCTION___11784,
        chain);
    fclose(pFile_1);
  }
  sensor_type = TMP451;
  sensor_num = 2;
  sensor_pos[0] = 31;
  sensor_pos[1] = 40;
  if ( (unsigned __int8)is_T11() != 1 )
  {
    sensor_pos[2] = 0;
    sensor_pos[3] = 0;
  }
  dev->chain_asic_temp_num[chain] = sensor_num;
  for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
    dev->TempChipAddr[chain][i] = 4 * (sensor_pos[i] + 63);
  for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
  {
    set_misc_control(chain, 0, dev->TempChipAddr[chain][i], 1);
    check_asic_reg_with_addr(0x18u, dev->TempChipAddr[chain][i], chain, 1);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: Chain[%d] use default temp chip[%d] \n",
          "temperature.c",
          704,
          (const char *)_FUNCTION___11784,
          chain,
          (dev->TempChipAddr[chain][i] >> 2) + 1);
      fclose(pFile_2);
    }
    v2 = do_calibration_sensor_offset(device, dev->TempChipAddr[chain][i], chain, i);
    middle_Offset[6 * chain + i] = v2;
    sensor_offset[i] = middle_Offset[6 * chain + i];
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: Chain[%d] Chip[%d] get middle temp offset=%d typeID=%02x\n",
          "temperature.c",
          709,
          (const char *)_FUNCTION___11784,
          chain,
          (dev->TempChipAddr[chain][i] >> 2) + 1,
          middle_Offset[6 * chain + i],
          dev->TempChipType[chain][i]);
      fclose(pFile_3);
    }
  }
  if ( !eeprom_set_temp_sensor_type(chain, sensor_type) )
    stop_scan(3, chain);
  if ( !eeprom_set_temp_sensor_num(chain, sensor_num) )
    stop_scan(3, chain);
  if ( !eeprom_set_temp_sensor_pos(chain, sensor_pos, sensor_num) )
    stop_scan(3, chain);
  if ( !eeprom_set_temp_sensor_data(chain, (uint8_t *)sensor_offset, sensor_num) )
    stop_scan(3, chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(pFile_4, "%s:%d:%s: temp sensor info save,done!\n", "temperature.c", 725, (const char *)_FUNCTION___11784);
    fclose(pFile_4);
  }
  return 0;
}

//----- (00016A22) --------------------------------------------------------
void __cdecl check_eeprom_calibration_data(int chain)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  FILE *pFile_0; // [sp+14h] [bp+Ch]

  if ( !is_eeprom_tempsensor_data_correct(chain) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chain[%d] start calibrate ...\n",
          "temperature.c",
          734,
          (const char *)_FUNCTION___11800,
          chain);
      fclose(pFile);
    }
    re_calibrate_sensor_offset(0x98u, chain);
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: chain[%d] no need to calibrate !\n",
        "temperature.c",
        739,
        (const char *)_FUNCTION___11800,
        chain);
    fclose(pFile_0);
  }
}

//----- (00016B2E) --------------------------------------------------------
int8_t __cdecl calibration_sensor_offset(unsigned __int8 device, int chain)
{
  TEMP_SENSOR_TYPE type; // r3
  unsigned __int8 devicea; // [sp+1Fh] [bp+7h]
  int8_t sensor_pos[4]; // [sp+20h] [bp+8h] BYREF
  FILE *pFile_6; // [sp+24h] [bp+Ch]
  FILE *pFile_5; // [sp+28h] [bp+10h]
  FILE *pFile_4; // [sp+2Ch] [bp+14h]
  FILE *pFile_3; // [sp+30h] [bp+18h]
  FILE *pFile_9; // [sp+34h] [bp+1Ch]
  FILE *pFile_8; // [sp+38h] [bp+20h]
  FILE *pFile_7; // [sp+3Ch] [bp+24h]
  FILE *pFile_2; // [sp+40h] [bp+28h]
  FILE *pFile_1; // [sp+44h] [bp+2Ch]
  FILE *pFile; // [sp+48h] [bp+30h]
  FILE *pFile_0; // [sp+4Ch] [bp+34h]
  uint32_t ret; // [sp+50h] [bp+38h]
  int i; // [sp+54h] [bp+3Ch]

  ret = 0;
  *(_DWORD *)sensor_pos = 0;
  check_eeprom_calibration_data(chain);
  if ( !is_tempsensor_data_correct(temp_info[chain]) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chain[%d] temp info,Bad. Reload from eeprom..\n",
          "temperature.c",
          754,
          (const char *)_FUNCTION___11810,
          chain);
      fclose(pFile);
    }
    get_temp_info_from_eeprom_by_chain(chain);
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: chain[%d] temp info,OK\n",
        "temperature.c",
        759,
        (const char *)_FUNCTION___11810,
        chain);
    fclose(pFile_0);
  }
  type = temp_info[chain].type;
  if ( type == TMP441B )
  {
    DEVICEADDR[chain] = -102;
  }
  else if ( type == TMP411C )
  {
    DEVICEADDR[chain] = -100;
  }
  else
  {
    DEVICEADDR[chain] = -104;
  }
  devicea = DEVICEADDR[chain];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: chain[%d] temp chip I2C addr=0x%02x\n",
        "temperature.c",
        780,
        (const char *)_FUNCTION___11810,
        chain,
        devicea);
    fclose(pFile_1);
  }
  if ( temp_info[chain].type != TMP451 && temp_info[chain].type != TMP461 )
  {
    chip_hasNoMiddle = 1;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: chain[%d] has no middle temp, use special fix mode.\n",
          "temperature.c",
          786,
          (const char *)_FUNCTION___11810,
          chain);
      fclose(pFile_2);
    }
  }
  if ( is_tempsensor_data_correct(temp_info[chain]) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: get temp info from eeprom,just use it!\n",
          "temperature.c",
          792,
          (const char *)_FUNCTION___11810);
      fclose(pFile_3);
    }
    dev->chain_asic_temp_num[chain] = temp_info[chain].num;
    for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
    {
      dev->TempChipAddr[chain][i] = 4 * (temp_info[chain].pos[i] - 1);
      middle_Offset[6 * chain + i] = temp_info[chain].offset[i];
      set_misc_control(chain, 0, dev->TempChipAddr[chain][i], 1);
      check_asic_reg_with_addr(0x18u, dev->TempChipAddr[chain][i], chain, 1);
      ret = check_reg_temp(devicea, 0xFEu, 0, 0, dev->TempChipAddr[chain][i], chain);
      dev->TempChipType[chain][i] = ret;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: Chain[%d] chip[%d] use PIC middle temp offset=%d, typeID=%02x\n",
            "temperature.c",
            809,
            (const char *)_FUNCTION___11810,
            chain,
            (dev->TempChipAddr[chain][i] >> 2) + 1,
            middle_Offset[6 * chain + i],
            dev->TempChipType[chain][i]);
        fclose(pFile_4);
      }
      if ( dev->TempChipType[chain][i] != 26 && dev->TempChipType[chain][i] != 85 && dev->TempChipType[chain][i] != 65 )
      {
        chip_hasNoMiddle = 1;
        DEVICEADDR[chain] = -104;
        devicea = DEVICEADDR[chain];
        ret = check_reg_temp(devicea, 0xFEu, 0, 0, dev->TempChipAddr[chain][i], chain);
        dev->TempChipType[chain][i] = ret;
        if ( dev->TempChipType[chain][i] != 26 && dev->TempChipType[chain][i] != 85 && dev->TempChipType[chain][i] != 65 )
        {
          DEVICEADDR[chain] = -102;
          devicea = DEVICEADDR[chain];
          ret = check_reg_temp(devicea, 0xFEu, 0, 0, dev->TempChipAddr[chain][i], chain);
          dev->TempChipType[chain][i] = ret;
          if ( dev->TempChipType[chain][i] != 26
            && dev->TempChipType[chain][i] != 85
            && dev->TempChipType[chain][i] != 65 )
          {
            DEVICEADDR[chain] = -100;
            devicea = DEVICEADDR[chain];
            ret = check_reg_temp(devicea, 0xFEu, 0, 0, dev->TempChipAddr[chain][i], chain);
            dev->TempChipType[chain][i] = ret;
          }
        }
      }
      if ( dev->TempChipType[chain][i] != 26 && dev->TempChipType[chain][i] != 85 && dev->TempChipType[chain][i] != 65 )
      {
        dev->chain_asic_temp_num[chain] = 0;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_5 = fopen((const char *)log_file, "a+");
          if ( pFile_5 )
            fprintf(
              pFile_5,
              "%s:%d:%s: wrong temp chip type!!!\n",
              "temperature.c",
              851,
              (const char *)_FUNCTION___11810);
          fclose(pFile_5);
        }
        return 0;
      }
      if ( dev->TempChipType[chain][i] != 85 )
        is218_Temp = 1;
      do_calibration_sensor_offset_by_eeprom(devicea, dev->TempChipAddr[chain][i], chain, i);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: Chain[%d] Chip[%d] get middle temp offset=%d typeID=%02x\n",
            "temperature.c",
            861,
            (const char *)_FUNCTION___11810,
            chain,
            (dev->TempChipAddr[chain][i] >> 2) + 1,
            middle_Offset[6 * chain + i],
            dev->TempChipType[chain][i]);
        fclose(pFile_6);
      }
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(
          pFile_7,
          "%s:%d:%s: Warning: Chain[%d] has no temp info ! we will fix it\n",
          "temperature.c",
          866,
          (const char *)_FUNCTION___11810,
          chain);
      fclose(pFile_7);
    }
    dev->chain_asic_temp_num[chain] = 2;
    sensor_pos[0] = 31;
    sensor_pos[1] = 40;
    if ( (unsigned __int8)is_T11() != 1 )
    {
      sensor_pos[2] = 0;
      sensor_pos[3] = 0;
    }
    for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
    {
      dev->TempChipAddr[chain][i] = 4 * (sensor_pos[i] - 1);
      middle_Offset[6 * chain + i] = -5;
    }
    for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
    {
      set_misc_control(chain, 0, dev->TempChipAddr[chain][i], 1);
      check_asic_reg_with_addr(0x18u, dev->TempChipAddr[chain][i], chain, 1);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(
            pFile_8,
            "%s:%d:%s: Chain[%d] use default temp chip[%d] \n",
            "temperature.c",
            898,
            (const char *)_FUNCTION___11810,
            chain,
            (dev->TempChipAddr[chain][i] >> 2) + 1);
        fclose(pFile_8);
      }
      do_calibration_sensor_offset_by_eeprom(devicea, dev->TempChipAddr[chain][i], chain, i);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_9 = fopen((const char *)log_file, "a+");
        if ( pFile_9 )
          fprintf(
            pFile_9,
            "%s:%d:%s: Chain[%d] Chip[%d] get middle temp offset=%d typeID=%02x\n",
            "temperature.c",
            903,
            (const char *)_FUNCTION___11810,
            chain,
            (dev->TempChipAddr[chain][i] >> 2) + 1,
            middle_Offset[6 * chain + i],
            dev->TempChipType[chain][i]);
        fclose(pFile_9);
      }
    }
  }
  return 0;
}

//----- (00017984) --------------------------------------------------------
void read_temp_and_get_statistics()
{
  all_parameters *v0; // r4
  all_parameters *v1; // r4
  int mintemp; // [sp+1Ch] [bp+4h]
  int mintemp_4; // [sp+20h] [bp+8h]
  int mintemp_8; // [sp+24h] [bp+Ch]
  int maxtemp; // [sp+2Ch] [bp+14h]
  int maxtemp_4; // [sp+30h] [bp+18h]
  int maxtemp_8; // [sp+34h] [bp+1Ch]
  int16_t temp_low[4]; // [sp+3Ch] [bp+24h] BYREF
  int16_t temp_top[4]; // [sp+44h] [bp+2Ch] BYREF
  FILE *pFile_2; // [sp+4Ch] [bp+34h]
  FILE *pFile_3; // [sp+50h] [bp+38h]
  FILE *pFile_0; // [sp+54h] [bp+3Ch]
  FILE *pFile_1; // [sp+58h] [bp+40h]
  int ret; // [sp+5Ch] [bp+44h]
  FILE *pFile; // [sp+60h] [bp+48h]
  FILE *pFile_4; // [sp+64h] [bp+4Ch]
  int temp_cnt; // [sp+68h] [bp+50h]
  int temp_sum; // [sp+6Ch] [bp+54h]
  int j; // [sp+70h] [bp+58h]
  int i; // [sp+74h] [bp+5Ch]

  temp_sum = 0;
  temp_cnt = 0;
  read_temp_error = 0;
  dev->temp_num = 0;
  memset(temp_top, 0, sizeof(temp_top));
  memset(temp_low, 0, sizeof(temp_low));
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      maxtemp = 0;
      maxtemp_4 = 0;
      maxtemp_8 = 0;
      mintemp = 1000;
      mintemp_4 = 1000;
      mintemp_8 = 1000;
      for ( j = 0; j < dev->chain_asic_temp_num[i]; ++j )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(temp_log, 3u);
          pFile = fopen((const char *)temp_log, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Chain[%d] Chip[%d] TempTypeID=%02x middle offset=%d\n",
              "temperature.c",
              942,
              (const char *)_FUNCTION___11849,
              i,
              (dev->TempChipAddr[i][j] >> 2) + 1,
              dev->TempChipType[i][j],
              middle_Offset[6 * i + j]);
          fclose(pFile);
        }
        ret = check_reg_temp(DEVICEADDR[i], 0, 0, 0, dev->TempChipAddr[i][j], i);
        if ( ret )
        {
          v0 = dev;
          v0->chain_asic_temp[i][j][0] = get_local((unsigned __int8)ret);
          if ( log_level > 3 )
          {
            print_crt_time_to_file(temp_log, 3u);
            pFile_0 = fopen((const char *)temp_log, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "%s:%d:%s: Chain[%d] Chip[%d] local Temp=%d\n",
                "temperature.c",
                949,
                (const char *)_FUNCTION___11849,
                i,
                (dev->TempChipAddr[i][j] >> 2) + 1,
                dev->chain_asic_temp[i][j][0]);
            fclose(pFile_0);
          }
          if ( (unsigned __int8)(dev->TempChipAddr[i][j] - 120) <= 3u )
          {
            temp_sum += dev->chain_asic_temp[i][j][0];
            ++temp_cnt;
          }
          ++dev->temp_num;
        }
        else
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(temp_log, 3u);
            pFile_1 = fopen((const char *)temp_log, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: read failed, old value: Chain[%d] Chip[%d] local Temp=%d\n",
                "temperature.c",
                960,
                (const char *)_FUNCTION___11849,
                i,
                (dev->TempChipAddr[i][j] >> 2) + 1,
                dev->chain_asic_temp[i][j][0]);
            fclose(pFile_1);
          }
          read_temp_error = 1;
        }
        ret = check_reg_temp(DEVICEADDR[i], 1u, 0, 0, dev->TempChipAddr[i][j], i);
        if ( ret )
        {
          v1 = dev;
          v1->chain_asic_temp[i][j][1] = get_remote((unsigned __int8)ret);
          if ( log_level > 3 )
          {
            print_crt_time_to_file(temp_log, 3u);
            pFile_2 = fopen((const char *)temp_log, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: Chain[%d] Chip[%d] middle Temp=%d\n",
                "temperature.c",
                985,
                (const char *)_FUNCTION___11849,
                i,
                (dev->TempChipAddr[i][j] >> 2) + 1,
                dev->chain_asic_temp[i][j][1]);
            fclose(pFile_2);
          }
        }
        else if ( log_level > 3 )
        {
          print_crt_time_to_file(temp_log, 3u);
          pFile_3 = fopen((const char *)temp_log, "a+");
          if ( pFile_3 )
            fprintf(
              pFile_3,
              "%s:%d:%s: read failed on Chain[%d] Chip[%d] middle Temp old value:%d\n",
              "temperature.c",
              1008,
              (const char *)_FUNCTION___11849,
              i,
              (dev->TempChipAddr[i][j] >> 2) + 1,
              dev->chain_asic_temp[i][j][1]);
          fclose(pFile_3);
        }
        if ( dev->chain_asic_temp[i][j][0] > maxtemp )
          maxtemp = dev->chain_asic_temp[i][j][0];
        if ( dev->chain_asic_temp[i][j][1] > maxtemp_4 )
          maxtemp_4 = dev->chain_asic_temp[i][j][1];
        if ( dev->chain_asic_temp[i][j][2] > maxtemp_8 )
          maxtemp_8 = dev->chain_asic_temp[i][j][2];
        if ( dev->chain_asic_temp[i][j][0] < mintemp )
          mintemp = dev->chain_asic_temp[i][j][0];
        if ( dev->chain_asic_temp[i][j][1] < mintemp_4 )
          mintemp_4 = dev->chain_asic_temp[i][j][1];
        if ( dev->chain_asic_temp[i][j][2] < mintemp_8 )
          mintemp_8 = dev->chain_asic_temp[i][j][2];
      }
      dev->chain_asic_maxtemp[i][0] = maxtemp;
      dev->chain_asic_maxtemp[i][1] = maxtemp_4;
      dev->chain_asic_maxtemp[i][2] = maxtemp_8;
      dev->chain_asic_mintemp[i][0] = mintemp;
      dev->chain_asic_mintemp[i][1] = mintemp_4;
      dev->chain_asic_mintemp[i][2] = mintemp_8;
      if ( dev->chain_asic_maxtemp[i][0] > temp_top[0] )
        temp_top[0] = dev->chain_asic_maxtemp[i][0];
      if ( dev->chain_asic_maxtemp[i][1] > temp_top[1] )
        temp_top[1] = dev->chain_asic_maxtemp[i][1];
      if ( dev->chain_asic_maxtemp[i][2] > temp_top[2] )
        temp_top[2] = dev->chain_asic_maxtemp[i][2];
      if ( dev->chain_asic_mintemp[i][0] < temp_low[0] && dev->chain_asic_mintemp[i][0] > 0 && !chain_temp_toolow[i]
        || !temp_low[0] )
      {
        temp_low[0] = dev->chain_asic_mintemp[i][0];
      }
      if ( dev->chain_asic_mintemp[i][1] < temp_low[1] && dev->chain_asic_mintemp[i][1] > 0 && !chain_temp_toolow[i]
        || !temp_low[1] )
      {
        temp_low[1] = dev->chain_asic_mintemp[i][1];
      }
      if ( dev->chain_asic_mintemp[i][2] < temp_low[2] && dev->chain_asic_mintemp[i][2] > 0 && !chain_temp_toolow[i]
        || !temp_low[2] )
      {
        temp_low[2] = dev->chain_asic_mintemp[i][2];
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_4 = fopen((const char *)temp_log, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: Done read temp on Chain[%d]\n",
            "temperature.c",
            1057,
            (const char *)_FUNCTION___11849,
            i);
        fclose(pFile_4);
      }
    }
  }
  dev->temp_top1[0] = temp_top[0];
  dev->temp_top1[1] = temp_top[1];
  dev->temp_top1[2] = temp_top[2];
  dev->temp_low1[0] = temp_low[0];
  dev->temp_low1[1] = temp_low[1];
  dev->temp_low1[2] = temp_low[2];
  if ( temp_cnt )
    dev->temp_avg = temp_sum / temp_cnt;
  else
    read_temp_error = 1;
  last_testpatten_lowest_pcb_temp = dev->temp_low1[0];
  last_testpatten_highest_pcb_temp = dev->temp_top1[0];
  last_testpatten_lowest_chip_temp = dev->temp_low1[1];
  last_testpatten_highest_chip_temp = dev->temp_top1[1];
}

//----- (0001852E) --------------------------------------------------------
void set_pwm_by_temp()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile_1; // [sp+14h] [bp+Ch]

  if ( (*((_BYTE *)&config_parameter + 4) & 2) != 0 )
  {
    if ( config_parameter.fan_pwm_percent <= 0x64u )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile = fopen((const char *)temp_log, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Set fixed fan speed=%d\n",
            "temperature.c",
            1087,
            (const char *)_FUNCTION___11864,
            config_parameter.fan_pwm_percent);
        fclose(pFile);
      }
      set_PWM(config_parameter.fan_pwm_percent);
      return;
    }
    if ( read_temp_error )
    {
      set_PWM(0x64u);
      dev->fan_pwm = 100;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_0 = fopen((const char *)temp_log, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Set fixed full fan speed\n",
            "temperature.c",
            1098,
            (const char *)_FUNCTION___11864);
        fclose(pFile_0);
      }
      return;
    }
LABEL_19:
    set_PWM_according_to_temperature(last_testpatten_highest_pcb_temp);
    return;
  }
  if ( !read_temp_error )
    goto LABEL_19;
  set_PWM(0x64u);
  dev->fan_pwm = 100;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(temp_log, 3u);
    pFile_1 = fopen((const char *)temp_log, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: Set fixed full fan speed\n", "temperature.c", 1111, (const char *)_FUNCTION___11864);
    fclose(pFile_1);
  }
}

//----- (00018734) --------------------------------------------------------
bool __cdecl disable_hash_board(STATUS_CODE status_value)
{
  int dhash_acc_control; // r0
  FILE *pFile; // [sp+10h] [bp+8h]
  int i; // [sp+14h] [bp+Ch]

  if ( has_disabled_flag_11871 )
    return has_disabled_flag_11871;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: disable_pic_dac as status_value %d\n",
        "temperature.c",
        1124,
        (const char *)_FUNCTION___11873,
        status_value);
    fclose(pFile);
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      disable_pic_dac(i);
  }
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  has_disabled_flag_11871 = 1;
  return 1;
}

//----- (0001882A) --------------------------------------------------------
void __cdecl check_status_value(bool fatal_flag)
{
  all_parameters *v1; // r4
  all_parameters *v2; // r4
  all_parameters *v3; // r4
  all_parameters *v4; // r4
  int diff; // [sp+10h] [bp+8h]
  FILE *pFile_0; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]
  unsigned __int8 ret; // [sp+20h] [bp+18h]
  unsigned __int8 reta; // [sp+20h] [bp+18h]
  unsigned __int8 retb; // [sp+20h] [bp+18h]
  unsigned __int8 retc; // [sp+20h] [bp+18h]
  int j; // [sp+28h] [bp+20h]
  int i; // [sp+2Ch] [bp+24h]

  if ( !fatal_flag )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] == 1 )
      {
        for ( j = 0; j < dev->chain_asic_temp_num[i]; ++j )
        {
          ret = check_reg_temp(DEVICEADDR[i], 0, 0, 0, dev->TempChipAddr[i][j], i);
          v1 = dev;
          v1->chain_asic_temp[i][j][0] = get_local(ret);
          if ( dev->chain_asic_temp[i][j][0] > 85 )
          {
            sleep(3u);
            reta = check_reg_temp(DEVICEADDR[i], 0, 0, 0, dev->TempChipAddr[i][j], i);
            v2 = dev;
            v2->chain_asic_temp[i][j][0] = get_local(reta);
            if ( dev->chain_asic_temp[i][j][0] > 85 )
            {
              status_value = ERROR_OVER_MAXTEMP;
              pcb_chip_over_temp = 0;
              if ( log_level > 3 )
              {
                print_crt_time_to_file(temp_log, 3u);
                pFile = fopen((const char *)temp_log, "a+");
                if ( pFile )
                  fprintf(
                    pFile,
                    "%s:%d:%s: High PCB temp = %d detected!!\n",
                    "temperature.c",
                    1170,
                    (const char *)_FUNCTION___11887,
                    dev->chain_asic_temp[i][j][0]);
                fclose(pFile);
              }
              return;
            }
          }
          retb = check_reg_temp(DEVICEADDR[i], 1u, 0, 0, dev->TempChipAddr[i][j], i);
          v3 = dev;
          v3->chain_asic_temp[i][j][1] = get_remote(retb);
          if ( dev->chain_asic_temp[i][j][1] > 105 )
          {
            sleep(3u);
            retc = check_reg_temp(DEVICEADDR[i], 1u, 0, 0, dev->TempChipAddr[i][j], i);
            v4 = dev;
            v4->chain_asic_temp[i][j][1] = get_remote(retc);
            if ( dev->chain_asic_temp[i][j][1] > 105 )
            {
              status_value = ERROR_OVER_MAXTEMP;
              pcb_chip_over_temp = 1;
              if ( log_level > 3 )
              {
                print_crt_time_to_file(temp_log, 3u);
                pFile_0 = fopen((const char *)temp_log, "a+");
                if ( pFile_0 )
                  fprintf(
                    pFile_0,
                    "%s:%d:%s: High CHIP temp = %d detected!!\n",
                    "temperature.c",
                    1187,
                    (const char *)_FUNCTION___11887,
                    dev->chain_asic_temp[i][j][1]);
                fclose(pFile_0);
              }
              return;
            }
          }
        }
      }
    }
    if ( check_fan() > 1 )
    {
      if ( !startCheckNetworkJob )
        goto LABEL_28;
      cgtime(&tv_send);
      diff = tv_send.tv_sec - tv_send_job.tv_sec;
      if ( tv_send.tv_usec - tv_send_job.tv_usec < 0 )
        --diff;
      if ( diff > 120 )
        status_value = ERROR_NETWORK_LOST;
      else
LABEL_28:
        status_error = 0;
    }
    else
    {
      status_value = ERROR_FAN_LOST;
    }
  }
}

//----- (00018D18) --------------------------------------------------------
bool process_status_value()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile_2; // [sp+14h] [bp+Ch]
  FILE *pFile_1; // [sp+18h] [bp+10h]
  bool has_disabled_hash_board_flag; // [sp+1Fh] [bp+17h]

  has_disabled_hash_board_flag = 0;
  switch ( status_value )
  {
    case STATUS_INIT:
    case STATUS_OK:
      status_error = 0;
      break;
    case ERROR_OVER_MAXTEMP:
      status_error = 1;
      if ( log_level > 1 )
      {
        print_crt_time_to_file(log_file, 1u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Fatal Error: Temperature is too high!\n",
            "temperature.c",
            1226,
            (const char *)_FUNCTION___11900);
        fclose(pFile);
      }
      goto LABEL_6;
    case ERROR_FAN_LOST:
      status_error = 1;
      if ( log_level > 1 )
      {
        print_crt_time_to_file(log_file, 1u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: Fatal Error: Fan lost!\n", "temperature.c", 1233, (const char *)_FUNCTION___11900);
        fclose(pFile_0);
      }
LABEL_6:
      has_disabled_hash_board_flag = disable_hash_board(status_value);
      break;
    case ERROR_NETWORK_LOST:
      ++network_err_count_11905;
      if ( log_level > 1 )
      {
        print_crt_time_to_file(log_file, 1u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: Fatal Error: network connection lost!\n",
            "temperature.c",
            1241,
            (const char *)_FUNCTION___11900);
        fclose(pFile_1);
      }
      if ( network_err_count_11905 > 0x3C )
      {
        network_err_count_11905 = 0;
        status_error = 1;
        has_disabled_hash_board_flag = disable_hash_board(status_value);
        if ( log_level > 1 )
        {
          print_crt_time_to_file(log_file, 1u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: Reboot system due to network connection lost!\n",
              "temperature.c",
              1248,
              (const char *)_FUNCTION___11900);
          fclose(pFile_2);
        }
        sleep(0x23u);
        system("reboot");
      }
      break;
    default:
      return has_disabled_hash_board_flag;
  }
  return has_disabled_hash_board_flag;
}

//----- (00018FB8) --------------------------------------------------------
void __cdecl read_temp_func_clean_up(void *arg)
{
  pthread_mutex_unlock(&reopen_core);
}

//----- (00018FD4) --------------------------------------------------------
void __cdecl set_iic_for_temperature_by_chain(int chain)
{
  int j; // [sp+Ch] [bp+Ch]

  for ( j = 0; j < dev->chain_asic_temp_num[chain]; ++j )
    set_misc_control(chain, 0, dev->TempChipAddr[chain][j], 1);
}

//----- (0001903A) --------------------------------------------------------
void set_iic_for_temperature()
{
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      set_iic_for_temperature_by_chain(i);
  }
}

//----- (0001907A) --------------------------------------------------------
int __cdecl temp_get_local_temp(float *p_temp)
{
  FILE *pFile; // [sp+18h] [bp+8h]
  int local_temp; // [sp+1Ch] [bp+Ch]
  uint8_t reg_temp; // [sp+23h] [bp+13h]
  int ret; // [sp+28h] [bp+18h]
  float sum; // [sp+2Ch] [bp+1Ch]
  float suma; // [sp+2Ch] [bp+1Ch]
  int good_air_in; // [sp+30h] [bp+20h]
  int good_air_ina; // [sp+30h] [bp+20h]
  int bad_air_in; // [sp+34h] [bp+24h]
  int min; // [sp+38h] [bp+28h]
  int max; // [sp+3Ch] [bp+2Ch]
  int i; // [sp+40h] [bp+30h]
  int chain; // [sp+44h] [bp+34h]

  max = -1000;
  min = 1000;
  bad_air_in = 0;
  good_air_in = 0;
  sum = 0.0;
  ret = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
      {
        if ( dev->TempChipAddr[chain][i] >> 2 == 30 )
        {
          reg_temp = check_reg_temp(DEVICEADDR[chain], 0, 0, 0, dev->TempChipAddr[chain][i], chain);
          if ( reg_temp )
          {
            local_temp = get_local(reg_temp);
            if ( log_level > 4 )
            {
              print_crt_time_to_file(log_file, 4u);
              pFile = fopen((const char *)log_file, "a+");
              if ( pFile )
                fprintf(
                  pFile,
                  "%s:%d:%s: sensor[%d] = %d, reg_temp = %d\n",
                  "temperature.c",
                  1321,
                  (const char *)_FUNCTION___11945,
                  31,
                  local_temp,
                  reg_temp);
              fclose(pFile);
            }
            ++good_air_in;
            sum = sum + (float)local_temp;
            if ( local_temp < min )
              min = local_temp;
            if ( local_temp > max )
              max = local_temp;
          }
          else
          {
            ++bad_air_in;
          }
        }
      }
    }
  }
  suma = (float)(sum - (float)max) - (float)min;
  good_air_ina = good_air_in - 2;
  if ( !good_air_ina || bad_air_in > good_air_ina )
    return -1;
  *p_temp = suma / (float)good_air_ina;
  return ret;
}

//----- (000192B0) --------------------------------------------------------
void get_env_temperature()
{
  float local_temp; // [sp+8h] [bp+0h] BYREF
  FILE *pFile; // [sp+Ch] [bp+4h]
  int try_count; // [sp+10h] [bp+8h]
  float sum; // [sp+14h] [bp+Ch]
  int good_temp_count; // [sp+18h] [bp+10h]
  int i; // [sp+1Ch] [bp+14h]

  try_count = 5;
  good_temp_count = 0;
  sum = 0.0;
  for ( i = 0; i < try_count; ++i )
  {
    if ( temp_get_local_temp(&local_temp) )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Get too many bad air in temperature.\n",
            "temperature.c",
            1375,
            (const char *)_FUNCTION___11962);
        fclose(pFile);
      }
    }
    else
    {
      sum = sum + local_temp;
      ++good_temp_count;
    }
    cgsleep_ms(20);
  }
  if ( good_temp_count )
    env_temp_11960 = sum / (float)good_temp_count;
}

//----- (000193AA) --------------------------------------------------------
void __noreturn read_temp_func()
{
  float v0; // s0
  unsigned int crc_count; // r0
  __pthread_unwind_buf_t __cancel_buf; // [sp+10h] [bp+0h] BYREF
  FILE *pFile_4; // [sp+12Ch] [bp+11Ch]
  FILE *pFile_3; // [sp+130h] [bp+120h]
  FILE *pFile_2; // [sp+134h] [bp+124h]
  FILE *pFile_1; // [sp+138h] [bp+128h]
  FILE *pFile_0; // [sp+13Ch] [bp+12Ch]
  FILE *pFile; // [sp+140h] [bp+130h]
  void *__cancel_arg; // [sp+148h] [bp+138h]
  void (*__cancel_routine)(void *); // [sp+14Ch] [bp+13Ch]
  bool fatal_flag; // [sp+152h] [bp+142h]
  bool is_bringup_temp_collected; // [sp+153h] [bp+143h]
  uint32_t counter; // [sp+154h] [bp+144h]

  counter = 0;
  is_bringup_temp_collected = 0;
  fatal_flag = 0;
  while ( 1 )
  {
    if ( !(++counter % 0xA) )
    {
      copy_log_to_latest(temp_log);
      clear_log(temp_log);
    }
    pthread_mutex_lock(&reopen_core);
    __cancel_routine = (void (*)(void *))read_temp_func_clean_up;
    __cancel_arg = 0;
    if ( _sigsetjmp((struct __jmp_buf_tag *)&__cancel_buf, 0) )
    {
      __cancel_routine(__cancel_arg);
      _pthread_unwind_next(&__cancel_buf);
    }
    _pthread_register_cancel(&__cancel_buf);
    read_temp_and_get_statistics();
    store_max_min_temperature();
    if ( !is_bringup_temp_collected )
    {
      if ( last_testpatten_lowest_pcb_temp )
      {
        bring_up_pcb_temp = last_testpatten_lowest_pcb_temp;
        is_bringup_temp_collected = 1;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: bring_up_pcb_temp = %d\n",
              "temperature.c",
              1418,
              (const char *)_FUNCTION___11977,
              bring_up_pcb_temp);
          fclose(pFile);
        }
      }
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_0 = fopen((const char *)temp_log, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: lowest temp = %d, highest temp = %d \n",
          "temperature.c",
          1421,
          (const char *)_FUNCTION___11977,
          last_testpatten_lowest_pcb_temp,
          last_testpatten_highest_pcb_temp);
      fclose(pFile_0);
    }
    if ( !is_force_mode() || freq_scan_status )
      set_pwm_by_temp();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_1 = fopen((const char *)temp_log, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: fan map is 0x%08x, num = %d\n",
          "temperature.c",
          1426,
          (const char *)_FUNCTION___11977,
          dev->fan_exist_map,
          dev->fan_num);
      fclose(pFile_1);
    }
    check_status_value(fatal_flag);
    fatal_flag = process_status_value();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_2 = fopen((const char *)temp_log, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: FAN PWM: %d\n",
          "temperature.c",
          1431,
          (const char *)_FUNCTION___11977,
          dev->fan_pwm);
      fclose(pFile_2);
    }
    get_env_temperature();
    environemnt_temp = v0;
    _pthread_unregister_cancel(&__cancel_buf);
    pthread_mutex_unlock(&reopen_core);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_3 = fopen((const char *)temp_log, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%s:%d:%s: read_temp_func Done!\n", "temperature.c", 1438, (const char *)_FUNCTION___11977);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_4 = fopen((const char *)temp_log, "a+");
      if ( pFile_4 )
      {
        crc_count = get_crc_count();
        fprintf(
          pFile_4,
          "%s:%d:%s: CRC error counter=%d\n",
          "temperature.c",
          1439,
          (const char *)_FUNCTION___11977,
          crc_count);
      }
      fclose(pFile_4);
    }
    sleep(0xAu);
  }
}
// 1970A: variable 'v0' is possibly undefined

//----- (0001981A) --------------------------------------------------------
void __cdecl set_PWM(unsigned __int8 pwm_percent)
{
  FILE *pFile; // [sp+14h] [bp+Ch]
  int temp_pwm_percent; // [sp+1Ch] [bp+14h]

  temp_pwm_percent = pwm_percent;
  if ( pwm_percent <= 4u )
    temp_pwm_percent = 5;
  if ( temp_pwm_percent > 100 )
    temp_pwm_percent = 100;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: fan pwm = %d\n",
        "temperature.c",
        1462,
        (const char *)_FUNCTION___11991,
        temp_pwm_percent);
    fclose(pFile);
  }
  dev->pwm_value = ((unsigned __int16)((__int16)(50 * temp_pwm_percent) / 100) << 16) | (unsigned __int16)((__int16)(50 * (100 - temp_pwm_percent)) / 100);
  dev->pwm_percent = temp_pwm_percent;
  set_fan_control(dev->pwm_value);
  dev->fan_pwm = dev->pwm_percent;
}

//----- (0001995C) --------------------------------------------------------
int __cdecl get_target_chip_temp_t11a(bool is_low_temp_env, int min_entrance_pcb_temp)
{
  if ( min_entrance_pcb_temp <= 21 )
    return 85;
  if ( min_entrance_pcb_temp > 25 )
  {
    if ( min_entrance_pcb_temp > 30 )
    {
      if ( min_entrance_pcb_temp > 44 )
        return 76;
      else
        return 14 * (min_entrance_pcb_temp - 30) / 15 + 62;
    }
    else
    {
      return 62;
    }
  }
  else if ( is_low_temp_env )
  {
    return 85;
  }
  else
  {
    return 62;
  }
}

//----- (000199CA) --------------------------------------------------------
int __cdecl get_target_chip_temp_t11(bool is_low_temp_env, int min_entrance_pcb_temp)
{
  FILE *pFile_0; // [sp+14h] [bp+Ch]
  FILE *pFile; // [sp+18h] [bp+10h]
  int chain; // [sp+1Ch] [bp+14h]

  if ( !minor_type_init_12029 )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        minor_types_12028 = g_minor_type[chain];
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chip miner_type = [%d]\n",
              "temperature.c",
              1601,
              (const char *)_FUNCTION___12033,
              minor_types_12028);
          fclose(pFile);
        }
      }
    }
    minor_type_init_12029 = 1;
  }
  if ( minor_types_12028 && minor_types_12028 != PKG_BE )
  {
    if ( minor_types_12028 == PKG_CE )
    {
      if ( is_economic_mode() )
      {
        if ( min_entrance_pcb_temp > 16 )
        {
          if ( min_entrance_pcb_temp > 24 )
          {
            if ( min_entrance_pcb_temp > 29 )
            {
              if ( min_entrance_pcb_temp > 39 )
              {
                if ( min_entrance_pcb_temp > 48 )
                  return 82;
                else
                  return 10 * (min_entrance_pcb_temp - 39) / 9 + 72;
              }
              else
              {
                return 12 * (min_entrance_pcb_temp - 29) / 10 + 60;
              }
            }
            else
            {
              return 10 * (min_entrance_pcb_temp - 24) / -5 + 70;
            }
          }
          else
          {
            return 75 - 5 * (min_entrance_pcb_temp - 16) / 8;
          }
        }
        else
        {
          return 75;
        }
      }
      else
      {
        return 85;
      }
    }
    else if ( minor_types_12028 == PKG_B_BGM )
    {
      if ( is_economic_mode() )
      {
        if ( min_entrance_pcb_temp > 12 )
        {
          if ( min_entrance_pcb_temp > 17 )
          {
            if ( min_entrance_pcb_temp > 25 )
            {
              if ( min_entrance_pcb_temp > 35 )
                return 82;
              else
                return 12 * (min_entrance_pcb_temp - 25) / 10 + 70;
            }
            else
            {
              return 75 - 5 * (min_entrance_pcb_temp - 17) / 8;
            }
          }
          else
          {
            return 10 * (min_entrance_pcb_temp - 12) / -5 + 85;
          }
        }
        else
        {
          return 85;
        }
      }
      else if ( minor_types_12028 == PKG_B_BGM && is_special_mode() )
      {
        return 90;
      }
      else
      {
        return 85;
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_0 = fopen((const char *)temp_log, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: error, unknow chip package type....\n",
            "temperature.c",
            1705,
            (const char *)_FUNCTION___12033);
        fclose(pFile_0);
      }
      if ( is_economic_mode() )
      {
        if ( min_entrance_pcb_temp > 16 )
        {
          if ( min_entrance_pcb_temp > 24 )
          {
            if ( min_entrance_pcb_temp > 29 )
            {
              if ( min_entrance_pcb_temp > 39 )
              {
                if ( min_entrance_pcb_temp > 48 )
                  return 82;
                else
                  return 10 * (min_entrance_pcb_temp - 39) / 9 + 72;
              }
              else
              {
                return 12 * (min_entrance_pcb_temp - 29) / 10 + 60;
              }
            }
            else
            {
              return 10 * (min_entrance_pcb_temp - 24) / -5 + 70;
            }
          }
          else
          {
            return 75 - 5 * (min_entrance_pcb_temp - 16) / 8;
          }
        }
        else
        {
          return 75;
        }
      }
      else
      {
        return 85;
      }
    }
  }
  else if ( is_economic_mode() )
  {
    if ( min_entrance_pcb_temp > 26 )
    {
      if ( min_entrance_pcb_temp > 35 )
      {
        if ( min_entrance_pcb_temp > 44 )
          return 83;
        else
          return 9 * (min_entrance_pcb_temp - 35) / 9 + 74;
      }
      else
      {
        return 11 * (min_entrance_pcb_temp - 26) / -9 + 85;
      }
    }
    else
    {
      return 85;
    }
  }
  else if ( minor_types_12028 || !is_special_mode() )
  {
    return 85;
  }
  else
  {
    return 90;
  }
}

//----- (00019E24) --------------------------------------------------------
int __cdecl get_target_chip_temp(int min_entrance_pcb_temp)
{
  int low_temp; // r3
  int middle_temp; // r3
  const char *v3; // r3
  FILE *pFile_1; // [sp+10h] [bp+8h]
  FILE *pFile_0; // [sp+14h] [bp+Ch]
  FILE *pFile; // [sp+18h] [bp+10h]
  int low_temp_exit_threshold; // [sp+1Ch] [bp+14h]
  int low_temp_bingup_threshold; // [sp+20h] [bp+18h]

  if ( is_economic_mode() )
    low_temp = low_temp_process_parm[0].low_temp;
  else
    low_temp = low_temp_process_parm[1].low_temp;
  low_temp_bingup_threshold = low_temp;
  if ( is_economic_mode() )
    middle_temp = low_temp_process_parm[0].middle_temp;
  else
    middle_temp = low_temp_process_parm[1].middle_temp;
  low_temp_exit_threshold = middle_temp;
  if ( !low_temp_env_init_12042 )
  {
    low_temp_env_init_12042 = 1;
    is_low_temp_env_12043 = min_entrance_pcb_temp < low_temp_bingup_threshold;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
      {
        if ( is_low_temp_env_12043 )
          v3 = "YES";
        else
          v3 = "NO";
        fprintf(
          pFile,
          "%s:%d:%s: if startup in low temp environment: %s\n",
          "temperature.c",
          1755,
          (const char *)_FUNCTION___12047,
          v3);
      }
      fclose(pFile);
    }
  }
  if ( min_entrance_pcb_temp < low_temp_bingup_threshold && !is_low_temp_env_12043 )
  {
    is_low_temp_env_12043 = 1;
    if ( log_level > 3 )
    {
      print_crt_time_to_file("/var/log/temp", 3u);
      pFile_0 = fopen("/var/log/temp", "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: change to low temp pwm\n", "temperature.c", 1761, (const char *)_FUNCTION___12047);
      fclose(pFile_0);
    }
  }
  if ( min_entrance_pcb_temp > low_temp_exit_threshold && is_low_temp_env_12043 )
  {
    is_low_temp_env_12043 = 0;
    if ( log_level > 3 )
    {
      print_crt_time_to_file("/var/log/temp", 3u);
      pFile_1 = fopen("/var/log/temp", "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%s:%d:%s: change to normal pid pwm\n", "temperature.c", 1767, (const char *)_FUNCTION___12047);
      fclose(pFile_1);
    }
  }
  if ( is_T11() )
    return get_target_chip_temp_t11(is_low_temp_env_12043, min_entrance_pcb_temp);
  else
    return get_target_chip_temp_t11a(is_low_temp_env_12043, min_entrance_pcb_temp);
}

//----- (0001A070) --------------------------------------------------------
int set_pwm_by_pid_method()
{
  int v0; // r3
  FILE *pFile; // [sp+24h] [bp+4h]
  FILE *pFile_1; // [sp+28h] [bp+8h]
  FILE *pFile_0; // [sp+2Ch] [bp+Ch]
  int max_pwm_chip_temp; // [sp+30h] [bp+10h]
  int pwm_change; // [sp+34h] [bp+14h]
  int target_chip_temp; // [sp+40h] [bp+20h]
  int entrance_pcb_temp; // [sp+44h] [bp+24h]
  int current_chip_temp; // [sp+48h] [bp+28h]
  int pwm_percent; // [sp+4Ch] [bp+2Ch]
  int pwm_percenta; // [sp+4Ch] [bp+2Ch]

  pwm_percent = dev->fan_pwm;
  if ( is_special_mode() )
    v0 = 95;
  else
    v0 = 90;
  max_pwm_chip_temp = v0;
  entrance_pcb_temp = dev->temp_low1[0];
  current_chip_temp = dev->temp_top1[1];
  if ( !last_chip_temp_12052 )
    last_chip_temp_12052 = dev->temp_top1[1];
  if ( current_chip_temp > v0 )
  {
    pwm_percenta = 100;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile = fopen((const char *)temp_log, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chip temp %d exceeds %d will set max pwm\n",
          "temperature.c",
          1799,
          (const char *)_FUNCTION___12062,
          current_chip_temp,
          max_pwm_chip_temp);
      fclose(pFile);
    }
LABEL_26:
    set_PWM(pwm_percenta);
    dev->fan_pwm = pwm_percenta;
    last_chip_temp_12052 = current_chip_temp;
    return pwm_percenta;
  }
  target_chip_temp = get_target_chip_temp(entrance_pcb_temp);
  pwm_change = (int)(float)((float)((float)(current_chip_temp - target_chip_temp) * 4.0)
                          - (float)((float)(last_chip_temp_12052 - target_chip_temp) * 2.0));
  if ( pwm_change < -1 || pwm_change > 1 )
  {
    pwm_percenta = pwm_change + pwm_percent;
    if ( pwm_percenta <= 4 )
      pwm_percenta = 5;
    if ( pwm_percenta > 100 )
      pwm_percenta = 100;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_1 = fopen((const char *)temp_log, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: PWM change from %d to %d: last_temp=%d, current_temp=%d, entrance_pcb_temp=%d, target_temp=%d, pwm_change=%d\n",
          "temperature.c",
          1821,
          (const char *)_FUNCTION___12062,
          dev->fan_pwm,
          pwm_percenta,
          last_chip_temp_12052,
          current_chip_temp,
          entrance_pcb_temp,
          target_chip_temp,
          pwm_change);
      fclose(pFile_1);
    }
    goto LABEL_26;
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(temp_log, 3u);
    pFile_0 = fopen((const char *)temp_log, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: PWM keep %d: last_temp=%d, current_temp=%d, entrance_pcb_temp=%d, target_temp=%d, pwm_change=%d\n",
        "temperature.c",
        1809,
        (const char *)_FUNCTION___12062,
        pwm_percent,
        last_chip_temp_12052,
        current_chip_temp,
        entrance_pcb_temp,
        target_chip_temp,
        pwm_change);
    fclose(pFile_0);
  }
  return pwm_percent;
}

//----- (0001A358) --------------------------------------------------------
int __cdecl set_PWM_according_to_temperature(int avg_temp)
{
  return set_pwm_by_pid_method();
}

//----- (0001A36E) --------------------------------------------------------
STATUS_CODE get_error_type()
{
  return status_value;
}

//----- (0001A386) --------------------------------------------------------
bool is_in_error()
{
  return (unsigned int)status_value > STATUS_OK;
}

//----- (0001A3A8) --------------------------------------------------------
void __cdecl set_status(STATUS_CODE err)
{
  status_value = err;
}

//----- (0001A3C8) --------------------------------------------------------
void detect_environment_temperature()
{
  int v0; // r3
  FILE *pFile_3; // [sp+10h] [bp+0h]
  FILE *pFile_2; // [sp+14h] [bp+4h]
  FILE *pFile_1; // [sp+18h] [bp+8h]
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  FILE *pFile; // [sp+20h] [bp+10h]
  unsigned __int8 test_index; // [sp+27h] [bp+17h]

  test_index = 0;
  env_temperature = 1000;
  read_temp_and_get_statistics();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      test_index = 1;
      fprintf(
        pFile,
        "%s:%d:%s: test[%d] environment temperature: %d\n",
        "temperature.c",
        1950,
        (const char *)_FUNCTION___12081,
        0,
        last_testpatten_lowest_pcb_temp);
    }
    fclose(pFile);
  }
  if ( last_testpatten_lowest_pcb_temp < env_temperature )
    env_temperature = last_testpatten_lowest_pcb_temp;
  do
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Enter %d secs to cool down hash board...\n",
          "temperature.c",
          1957,
          (const char *)_FUNCTION___12081,
          10);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%s:%d:%s: waiting..........\n", "temperature.c", 1958, (const char *)_FUNCTION___12081);
      fclose(pFile_1);
    }
    sleep(0xAu);
    read_temp_and_get_statistics();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
      {
        v0 = test_index++;
        fprintf(
          pFile_2,
          "%s:%d:%s: test[%d] environment temperature: %d\n",
          "temperature.c",
          1961,
          (const char *)_FUNCTION___12081,
          v0,
          last_testpatten_lowest_pcb_temp);
      }
      fclose(pFile_2);
    }
    if ( last_testpatten_lowest_pcb_temp < env_temperature )
      env_temperature = last_testpatten_lowest_pcb_temp;
  }
  while ( test_index < 3u );
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s: environment temperature : [%d]\n",
        "temperature.c",
        1967,
        (const char *)_FUNCTION___12081,
        env_temperature);
    fclose(pFile_3);
  }
}

//----- (0001A6B0) --------------------------------------------------------
void get_env_temperature()
{
  ;
}

//----- (0001A6CE) --------------------------------------------------------
void store_max_min_temperature()
{
  if ( last_testpatten_lowest_pcb_temp < min_temperature )
    min_temperature = last_testpatten_lowest_pcb_temp;
  if ( last_testpatten_highest_pcb_temp > max_temperature )
    max_temperature = last_testpatten_highest_pcb_temp;
  if ( last_testpatten_highest_chip_temp > max_chip_temperature )
    max_chip_temperature = last_testpatten_highest_chip_temp;
  if ( last_testpatten_lowest_chip_temp < min_chip_temperature )
    min_chip_temperature = last_testpatten_lowest_chip_temp;
}

//----- (0001A78C) --------------------------------------------------------
int get_max_temperature()
{
  int temp; // [sp+4h] [bp+4h]

  temp = max_temperature;
  max_temperature = 0;
  return temp;
}

//----- (0001A7B8) --------------------------------------------------------
int get_min_temperature()
{
  int temp; // [sp+4h] [bp+4h]

  temp = min_temperature;
  min_temperature = 1000;
  return temp;
}

//----- (0001A7E6) --------------------------------------------------------
int get_max_chip_temperature()
{
  int temp; // [sp+4h] [bp+4h]

  temp = max_chip_temperature;
  max_chip_temperature = 0;
  return temp;
}

//----- (0001A812) --------------------------------------------------------
int get_min_chip_temperature()
{
  int temp; // [sp+4h] [bp+4h]

  temp = min_chip_temperature;
  min_chip_temperature = 1000;
  return temp;
}

//----- (0001A840) --------------------------------------------------------
unsigned int __cdecl _bswap_32(unsigned int __bsx)
{
  return bswap32(__bsx);
}

//----- (0001A858) --------------------------------------------------------
__uint64_t __cdecl _uint64_identity(__uint64_t __x)
{
  return __x;
}

//----- (0001A872) --------------------------------------------------------
uint32_t __cdecl swab32(uint32_t v)
{
  return bswap32(v);
}

//----- (0001A88A) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (0001A8D2) --------------------------------------------------------
void __cdecl mutex_lock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001A94E) --------------------------------------------------------
void __cdecl mutex_unlock_noyield(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001A9CA) --------------------------------------------------------
void __cdecl mutex_unlock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield(lock, file, func, line);
  selective_yield();
}

//----- (0001A9F8) --------------------------------------------------------
void __cdecl wr_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001AA74) --------------------------------------------------------
void __cdecl rd_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001AAF0) --------------------------------------------------------
void __cdecl rw_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001AB6C) --------------------------------------------------------
void __cdecl wr_unlock_noyield(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock(lock, file, func, line);
}

//----- (0001AB8E) --------------------------------------------------------
void __cdecl rd_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock(lock, file, func, line);
  selective_yield();
}

//----- (0001ABBC) --------------------------------------------------------
void __cdecl mutex_init(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001AC3A) --------------------------------------------------------
void __cdecl rwlock_init(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0001ACB8) --------------------------------------------------------
void __cdecl cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init(&lock->mutex, file, func, line);
  rwlock_init(&lock->rwlock, file, func, line);
}

//----- (0001ACEA) --------------------------------------------------------
void __cdecl cg_rlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock(&lock->mutex, file, func, line);
  rd_lock(&lock->rwlock, file, func, line);
  mutex_unlock_noyield(&lock->mutex, file, func, line);
}

//----- (0001AD28) --------------------------------------------------------
void __cdecl cg_wlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock(&lock->mutex, file, func, line);
  wr_lock(&lock->rwlock, file, func, line);
}

//----- (0001AD5A) --------------------------------------------------------
void __cdecl cg_runlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock(&lock->rwlock, file, func, line);
}

//----- (0001AD80) --------------------------------------------------------
void __cdecl cg_wunlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield(&lock->rwlock, file, func, line);
  mutex_unlock(&lock->mutex, file, func, line);
}

//----- (0001ADB2) --------------------------------------------------------
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; length >> 2 > i; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (0001AE00) --------------------------------------------------------
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len)
{
  const uint8_t *v2; // r3
  uint16_t wIndex; // [sp+Ch] [bp+Ch]
  uint8_t chCRCLo; // [sp+Eh] [bp+Eh]
  uint8_t chCRCHi; // [sp+Fh] [bp+Fh]

  chCRCHi = -1;
  chCRCLo = -1;
  while ( w_len-- )
  {
    v2 = p_data++;
    wIndex = (unsigned __int8)(chCRCLo ^ *v2);
    chCRCLo = chCRCHi ^ chCRCHTalbe[chCRCLo ^ *v2];
    chCRCHi = chCRCLTalbe[wIndex];
  }
  return chCRCLo | (chCRCHi << 8);
}

//----- (0001AE70) --------------------------------------------------------
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  unsigned __int8 crcout[5]; // [sp+Ch] [bp+Ch]
  int crcin; // [sp+14h] [bp+14h]
  char crcin_4; // [sp+18h] [bp+18h]
  bool din; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 crc; // [sp+1Ch] [bp+1Ch]
  unsigned __int8 k; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 j; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  crcin = 16843009;
  crcin_4 = 1;
  j = 0x80;
  k = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    din = (j & *ptr) != 0;
    crcout[0] = din ^ crcin_4;
    crcout[1] = crcin;
    crcout[2] = din ^ crcin_4 ^ BYTE1(crcin);
    *(_WORD *)&crcout[3] = HIWORD(crcin);
    j >>= 1;
    if ( ++k == 8 )
    {
      j = 0x80;
      k = 0;
      ++ptr;
    }
    crcin = *(_DWORD *)crcout;
    crcin_4 = crcout[4];
  }
  crc = 0;
  if ( crcin_4 )
    crc = 16;
  if ( HIBYTE(crcin) )
    crc |= 8u;
  if ( BYTE2(crcin) )
    crc |= 4u;
  if ( BYTE1(crcin) )
    crc |= 2u;
  if ( (_BYTE)crcin )
    crc |= 1u;
  return crc;
}

//----- (0001AF98) --------------------------------------------------------
void __noreturn get_hash_rate()
{
  uint64_t *v0; // r2
  double *v1; // r2
  int index[16]; // [sp+0h] [bp+0h] BYREF
  double each_chain_h[16][10]; // [sp+40h] [bp+40h] BYREF
  timeval diff; // [sp+540h] [bp+540h]
  timeval new_h; // [sp+548h] [bp+548h] BYREF
  timeval old_h; // [sp+550h] [bp+550h] BYREF
  unsigned __int8 *hash_log; // [sp+558h] [bp+558h]
  uint32_t counter; // [sp+55Ch] [bp+55Ch]
  double each_chain_h_all; // [sp+560h] [bp+560h]
  uint32_t i; // [sp+568h] [bp+568h]
  uint32_t which_chain; // [sp+56Ch] [bp+56Ch]

  which_chain = 0;
  i = 0;
  memset(each_chain_h, 0, sizeof(each_chain_h));
  each_chain_h_all = 0.0;
  memset(index, 0, sizeof(index));
  cgtime(&old_h);
  cgtime(&new_h);
  counter = 0;
  hash_log = "/var/log/hash_rate";
  while ( 1 )
  {
    ++counter;
    cgtime(&new_h);
    diff.tv_sec = new_h.tv_sec - old_h.tv_sec;
    diff.tv_usec = new_h.tv_usec - old_h.tv_usec;
    if ( new_h.tv_usec - old_h.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    each_chain_h_all = 0.0;
    for ( which_chain = 0; which_chain <= 0xF; ++which_chain )
    {
      if ( dev->chain_exist[which_chain] )
      {
        each_chain_h[which_chain][index[which_chain]] = (double)(0xFFFFFFFF * h_each_chain[which_chain]);
        v0 = &h_each_chain[which_chain];
        *(_DWORD *)v0 = 0;
        *((_DWORD *)v0 + 1) = 0;
        each_chain_h[which_chain][index[which_chain]] = each_chain_h[which_chain][index[which_chain]]
                                                      / ((double)diff.tv_sec + (double)(diff.tv_usec + 1) / 1000000.0);
        v1 = &each_chain_h_avg[which_chain];
        *(_DWORD *)v1 = 0;
        *((_DWORD *)v1 + 1) = 0;
        for ( i = 0; i <= 9; ++i )
          each_chain_h_avg[which_chain] = each_chain_h_avg[which_chain] + each_chain_h[which_chain][i];
        sprintf((char *)displayed_rate[which_chain], "%.2f", each_chain_h_avg[which_chain] / 1000000000.0 / 10.0);
        each_chain_h_all = each_chain_h_all + each_chain_h_avg[which_chain] / 1000000000.0 / 10.0;
        if ( ++index[which_chain] > 9 )
          index[which_chain] = 0;
      }
    }
    sprintf((char *)displayed_hash_rate, "%.2f", each_chain_h_all);
    geach_chain_h_all = each_chain_h_all;
    copy_time(&old_h, &new_h);
    sleep(5u);
  }
}

//----- (0001B328) --------------------------------------------------------
int eeprom_date_check()
{
  FILE *pFile; // [sp+Ch] [bp+4h]

  if ( eeprom_load() )
    return 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: eeprom_load failed\n", "driver-btm-soc.c", 616, (const char *)_FUNCTION___14720);
    fclose(pFile);
  }
  return -1;
}

//----- (0001B3B2) --------------------------------------------------------
void slowly_set_iic_power_to_working_voltage()
{
  pthread_mutex_lock(&set_voltage_lock);
  set_voltage_flag = 1;
  pthread_mutex_unlock(&set_voltage_lock);
  if ( is_T11() )
    slowly_set_iic_power_voltage_t11(1);
  else
    slowly_set_iic_power_to_working_voltage();
  pthread_mutex_lock(&set_voltage_lock);
  set_voltage_flag = 0;
  pthread_mutex_unlock(&set_voltage_lock);
}

//----- (0001B418) --------------------------------------------------------
int set_iic_power_to_highest_voltage()
{
  double v0; // r0
  power_info_t *v1; // r2
  int v2; // r3
  int v3; // r3
  int ret; // [sp+0h] [bp+0h]
  int _chain; // [sp+4h] [bp+4h]

  ret = 0;
  pthread_mutex_lock(&set_voltage_lock);
  set_voltage_flag = 1;
  pthread_mutex_unlock(&set_voltage_lock);
  LODWORD(v0) = is_T11();
  if ( LODWORD(v0) )
  {
    for ( _chain = 0; _chain <= 15; ++_chain )
    {
      if ( dev->chain_exist[_chain] )
      {
        if ( set_iic_power_to_highest_voltage_by_chain(_chain) )
          v2 = 0;
        else
          v2 = -1;
        ret |= v2;
      }
    }
  }
  else
  {
    if ( set_iic_power_to_highest_voltage(v0, v1) )
      v3 = 0;
    else
      v3 = -1;
    ret = v3;
  }
  pthread_mutex_lock(&set_voltage_lock);
  set_voltage_flag = 0;
  pthread_mutex_unlock(&set_voltage_lock);
  return ret;
}
// 1B49C: variable 'v0' is possibly undefined
// 1B49C: variable 'v1' is possibly undefined

//----- (0001B4DE) --------------------------------------------------------
void __cdecl set_working_voltage(double volt)
{
  double v1; // r0
  double v2; // r2
  int _chain; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&set_voltage_lock);
  set_voltage_flag = 1;
  pthread_mutex_unlock(&set_voltage_lock);
  LODWORD(v1) = is_T11();
  if ( LODWORD(v1) )
  {
    for ( _chain = 0; _chain <= 15; ++_chain )
    {
      if ( dev->chain_exist[_chain] )
      {
        HIDWORD(v2) = (unsigned __int8)_chain;
        LODWORD(v2) = _chain + 2;
        set_working_voltage_by_chain(_chain, v2);
      }
    }
  }
  else
  {
    set_working_voltage(v1);
  }
  pthread_mutex_lock(&set_voltage_lock);
  set_voltage_flag = 0;
  pthread_mutex_unlock(&set_voltage_lock);
}
// 1B556: variable 'v1' is possibly undefined

//----- (0001B586) --------------------------------------------------------
int check_chain()
{
  FILE *pFile_0; // [sp+Ch] [bp+4h]
  FILE *pFile_1; // [sp+10h] [bp+8h]
  FILE *pFile; // [sp+14h] [bp+Ch]
  int ret; // [sp+18h] [bp+10h]
  int i; // [sp+1Ch] [bp+14h]
  int ia; // [sp+1Ch] [bp+14h]

  dev->chain_num = 0;
  ret = get_hash_on_plug();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: get_hash_on_plug is 0x%x\n",
        "driver-btm-soc.c",
        861,
        (const char *)_FUNCTION___14755,
        ret);
    fclose(pFile);
  }
  if ( ret >= 0 )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( ((ret >> i) & 1) != 0 )
      {
        dev->chain_exist[i] = 1;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: !! chain[%d]is exist\n",
              "driver-btm-soc.c",
              873,
              (const char *)_FUNCTION___14755,
              i);
          fclose(pFile_1);
        }
        ++dev->chain_num;
      }
      else
      {
        dev->chain_exist[i] = 0;
      }
    }
    if ( dev->chain_num == 3 || freq_mode && freq_mode != 2 )
    {
      return 0;
    }
    else
    {
      for ( ia = 0; ia <= 2; ++ia )
      {
        if ( dev->chain_exist[ia] != 1 )
          freq_scan_error_code_set(2, ia);
      }
      return -1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: get_hash_on_plug functions error\n",
          "driver-btm-soc.c",
          864,
          (const char *)_FUNCTION___14755);
      fclose(pFile_0);
    }
    return -1;
  }
}

//----- (0001B7DA) --------------------------------------------------------
int check_hashboard_hardware_info()
{
  FILE *pFile; // [sp+14h] [bp+4h]
  FILE *pFile_8; // [sp+18h] [bp+8h]
  FILE *pFile_7; // [sp+1Ch] [bp+Ch]
  FILE *pFile_6; // [sp+20h] [bp+10h]
  FILE *pFile_5; // [sp+24h] [bp+14h]
  FILE *pFile_4; // [sp+28h] [bp+18h]
  FILE *pFile_3; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_2; // [sp+30h] [bp+20h]
  FILE *pFile_1; // [sp+34h] [bp+24h]
  FILE *pFile_0; // [sp+38h] [bp+28h]
  CHIP_LEVEL bin; // [sp+3Ch] [bp+2Ch]
  CHIP_MINOR_TYPE minor; // [sp+40h] [bp+30h]
  CHIP_MAJOR_TYPE major; // [sp+44h] [bp+34h]
  bool success; // [sp+4Bh] [bp+3Bh]
  bool successa; // [sp+4Bh] [bp+3Bh]
  bool successb; // [sp+4Bh] [bp+3Bh]
  bool successc; // [sp+4Bh] [bp+3Bh]
  bool successd; // [sp+4Bh] [bp+3Bh]
  int chain; // [sp+4Ch] [bp+3Ch]

  success = 1;
  major = 0xFFFF;
  minor = 0xFFFF;
  bin = 0xFFFF;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      successa = (success & eeprom_get_chip_major_type(chain, &g_major_type[chain])) != 0;
      successb = (successa & eeprom_get_chip_minor_type(chain, &g_minor_type[chain])) != 0;
      successc = (successb & eeprom_get_chip_level(chain, &g_bin_level[chain])) != 0;
      successd = (successc & eeprom_get_bom_version(chain, &bom_version[chain])) != 0;
      success = (successd & eeprom_get_pcb_version(chain, &chain_pcb_version[chain])) != 0;
      g_device_minor_type = g_minor_type[chain];
      g_device_bin_level = g_bin_level[chain];
      if ( !success )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: error! chain[%d] hashboard hardware info is wrong!\n",
              "driver-btm-soc.c",
              969,
              (const char *)_FUNCTION___14784,
              chain);
          fclose(pFile);
        }
LABEL_56:
        freq_scan_error_code_set(3, chain);
        return -1;
      }
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "\nread chain[%d] hardware info:\n", chain);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "major type: %d\n", g_major_type[chain]);
        fclose(pFile_1);
      }
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, "minor type: %d\n", g_minor_type[chain]);
        fclose(pFile_2);
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(pFile_3, "chip level: %d\n", g_bin_level[chain]);
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(pFile_4, "bom version: 0x%02x\n", bom_version[chain]);
        fclose(pFile_4);
      }
      if ( log_level > 3 )
      {
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(pFile_5, "pcb version: 0x%02x\n", chain_pcb_version[chain]);
        fclose(pFile_5);
      }
      if ( major == 0xFFFF )
      {
        major = g_major_type[chain];
      }
      else if ( major != g_major_type[chain] )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_6 = fopen((const char *)log_file, "a+");
          if ( pFile_6 )
            fprintf(
              pFile_6,
              "%s:%d:%s: error! chain[%d] hashboard hardware info is wrong! %d != %d \n",
              "driver-btm-soc.c",
              981,
              (const char *)_FUNCTION___14784,
              chain,
              major,
              g_major_type[chain]);
          fclose(pFile_6);
        }
        goto LABEL_56;
      }
      if ( minor == 0xFFFF )
      {
        minor = g_minor_type[chain];
      }
      else if ( minor != g_minor_type[chain] )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_7 = fopen((const char *)log_file, "a+");
          if ( pFile_7 )
            fprintf(
              pFile_7,
              "%s:%d:%s: error! chain[%d] hashboard hardware info is wrong! %d != %d \n",
              "driver-btm-soc.c",
              982,
              (const char *)_FUNCTION___14784,
              chain,
              minor,
              g_minor_type[chain]);
          fclose(pFile_7);
        }
        goto LABEL_56;
      }
      if ( bin == 0xFFFF )
      {
        bin = g_bin_level[chain];
      }
      else if ( bin != g_bin_level[chain] )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_8 = fopen((const char *)log_file, "a+");
          if ( pFile_8 )
            fprintf(
              pFile_8,
              "%s:%d:%s: error! chain[%d] hashboard hardware info is wrong! %d != %d \n",
              "driver-btm-soc.c",
              983,
              (const char *)_FUNCTION___14784,
              chain,
              bin,
              g_bin_level[chain]);
          fclose(pFile_8);
        }
        goto LABEL_56;
      }
    }
  }
  return 0;
}

//----- (0001BDEA) --------------------------------------------------------
int check_fan()
{
  unsigned int fan_speed; // [sp+14h] [bp+4h] BYREF
  unsigned __int8 fan_id; // [sp+1Bh] [bp+Bh] BYREF
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  FILE *pFile_0; // [sp+20h] [bp+10h]
  int i; // [sp+24h] [bp+14h]

  fan_id = 0;
  dev->fan_speed_top1 = 0;
  dev->fan_speed_low1 = 0;
  for ( i = 0; ; ++i )
  {
    if ( i > 7 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: fan num = %d\n",
            "driver-btm-soc.c",
            1026,
            (const char *)_FUNCTION___14803,
            dev->fan_num);
        fclose(pFile_0);
      }
      return dev->fan_num;
    }
    if ( get_fan_speed(&fan_id, &fan_speed) != -1 )
    {
      dev->fan_speed_value[fan_id] = 120 * fan_speed;
      if ( !fan_speed || dev->fan_exist[fan_id] )
      {
        if ( !fan_speed && dev->fan_exist[fan_id] == 1 )
        {
          dev->fan_exist[fan_id] = 0;
          --dev->fan_num;
          dev->fan_exist_map &= ~(1 << fan_id);
        }
      }
      else
      {
        dev->fan_exist[fan_id] = 1;
        ++dev->fan_num;
        dev->fan_exist_map |= 1 << fan_id;
      }
      if ( dev->fan_speed_top1 < dev->fan_speed_value[fan_id] )
        dev->fan_speed_top1 = dev->fan_speed_value[fan_id];
      if ( dev->fan_speed_low1 > dev->fan_speed_value[fan_id] && dev->fan_speed_value[fan_id] || !dev->fan_speed_low1 )
        dev->fan_speed_low1 = dev->fan_speed_value[fan_id];
      if ( dev->fan_speed_value[fan_id] < 0x1F4 && dev->fan_exist[fan_id] == 1 )
        break;
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: check FAN Speed Error: fan[%d] speed=%d\n",
        "driver-btm-soc.c",
        1021,
        (const char *)_FUNCTION___14803,
        fan_id,
        dev->fan_speed_value[fan_id]);
    fclose(pFile);
  }
  return -1;
}

//----- (0001C1CC) --------------------------------------------------------
int __cdecl get_index_from_high_pll(int freq)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  unsigned int i; // [sp+14h] [bp+Ch]

  for ( i = 0;
        i <= 0x20
     && freq_high_pll_1393[i].freq != freq
     && (freq_high_pll_1393[i].freq <= freq || freq_high_pll_1393[i - 1].freq >= freq);
        ++i )
  {
    ;
  }
  if ( i != 33 )
    return i;
  if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: high freq index set error,return default pll index\n",
        "driver-btm-soc.c",
        1073,
        (const char *)_FUNCTION___14830);
    fclose(pFile);
  }
  return get_index_from_high_pll(200);
}

//----- (0001C2C8) --------------------------------------------------------
int GetTotalRate()
{
  int total_rate; // [sp+0h] [bp+0h]
  int chain; // [sp+4h] [bp+4h]

  total_rate = 0;
  if ( freq_mode != 2 )
    return g_total_fixed_hashrate;
  for ( chain = 0; chain <= 7; ++chain )
  {
    if ( dev->chain_exist[chain] )
      total_rate = (int)(float)((float)total_rate + (float)((float)(freq_from_board[chain] * 60.0) * 208.0));
  }
  return total_rate / 1000;
}

//----- (0001C374) --------------------------------------------------------
unsigned int do_get_ideal_max_hash_rate()
{
  uint32_t *freq_one_chain; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]
  int chain; // [sp+8h] [bp+8h]
  uint32_t total_rate; // [sp+Ch] [bp+Ch]

  freq_one_chain = (uint32_t *)malloc(0xF0u);
  total_rate = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( is_economic_mode() )
        eeprom_get_freq_mode1(chain, freq_one_chain);
      else
        eeprom_get_freq_mode2(chain, freq_one_chain);
      for ( i = 0; i <= 59; ++i )
        total_rate += 208 * freq_one_chain[i];
    }
  }
  if ( freq_one_chain )
    free(freq_one_chain);
  return total_rate / 0x3E8;
}

//----- (0001C430) --------------------------------------------------------
int get_ideal_hash_rate_max()
{
  int total_rate; // [sp+0h] [bp+0h]
  int chain; // [sp+4h] [bp+4h]

  total_rate = 0;
  if ( freq_mode != 2 )
    return do_get_ideal_max_hash_rate();
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      total_rate = (int)(float)((float)total_rate + (float)((float)(freq_from_board[chain] * 60.0) * 208.0));
  }
  return total_rate / 1000;
}

//----- (0001C4D8) --------------------------------------------------------
int __cdecl fix_hash_rate(int hashrateGH)
{
  return 500 * ((hashrateGH - 100) / 500);
}

//----- (0001C50A) --------------------------------------------------------
int get_fixed_total_hash_rate()
{
  int total_rate; // [sp+4h] [bp+4h]

  total_rate = get_eeprom_total_hash_rate();
  return fix_hash_rate(total_rate);
}

//----- (0001C52A) --------------------------------------------------------
int get_eeprom_total_hash_rate()
{
  int hashrate_tmp; // [sp+10h] [bp+0h] BYREF
  FILE *pFile; // [sp+14h] [bp+4h]
  FILE *pFile_0; // [sp+18h] [bp+8h]
  int try_times; // [sp+1Ch] [bp+Ch]
  int total_rate; // [sp+20h] [bp+10h]
  int chain; // [sp+24h] [bp+14h]

  total_rate = 0;
  hashrate_tmp = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      try_times = 3;
      do
      {
        if ( is_economic_mode() )
          eeprom_get_hashrate_mode1(chain, (uint32_t *)&hashrate_tmp);
        else
          eeprom_get_hashrate_mode2(chain, (uint32_t *)&hashrate_tmp);
        if ( hashrate_tmp )
          break;
      }
      while ( try_times-- );
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d] hash rate = %d\n",
            "driver-btm-soc.c",
            1198,
            (const char *)_FUNCTION___14875,
            chain,
            hashrate_tmp);
        fclose(pFile);
      }
      total_rate += hashrate_tmp;
      usleep(0x186A0u);
    }
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: total rate = %d\n",
        "driver-btm-soc.c",
        1202,
        (const char *)_FUNCTION___14875,
        total_rate);
    fclose(pFile_0);
  }
  return total_rate;
}

//----- (0001C69E) --------------------------------------------------------
void get_ideal_hash_rate()
{
  FILE *pFile; // [sp+Ch] [bp+4h]

  g_total_fixed_hashrate = get_fixed_total_hash_rate();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: get ideal hash rate %d\n",
        "driver-btm-soc.c",
        1210,
        (const char *)_FUNCTION___14883,
        g_total_fixed_hashrate);
    fclose(pFile);
  }
}

//----- (0001C732) --------------------------------------------------------
int __cdecl ConvirtTotalRate(int totalRate)
{
  if ( !is_economic_mode() )
    return totalRate;
  if ( is_T11() )
    return totalRate;
  return 17500;
}

//----- (0001C766) --------------------------------------------------------
void clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  reg_value_buf.p_wr = 0;
  reg_value_buf.p_rd = 0;
  reg_value_buf.reg_value_num = 0;
  pthread_mutex_unlock(&reg_mutex);
}

//----- (0001C7B0) --------------------------------------------------------
void __cdecl suffix_string_soc(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display)
{
  double v5; // r0
  double v6; // r0
  double v7; // d7
  unsigned __int8 suffix[2]; // [sp+28h] [bp+10h] BYREF
  int ndigits; // [sp+2Ch] [bp+14h]
  uint64_t exa; // [sp+30h] [bp+18h]
  uint64_t peta; // [sp+38h] [bp+20h]
  uint64_t tera; // [sp+40h] [bp+28h]
  uint64_t giga; // [sp+48h] [bp+30h]
  uint64_t mega; // [sp+50h] [bp+38h]
  uint64_t kilo; // [sp+58h] [bp+40h]
  double dkilo; // [sp+60h] [bp+48h]
  double dval; // [sp+68h] [bp+50h]
  bool decimal; // [sp+77h] [bp+5Fh]

  dkilo = 1000.0;
  kilo = 1000LL;
  LODWORD(mega) = &calc_nonce_info.chain_asic_core_nonce_num[5][48][190];
  HIDWORD(mega) = 0;
  giga = 1000000000LL;
  tera = 1000000000000LL;
  peta = 1000000000000000LL;
  exa = 1000000000000000000LL;
  *(_WORD *)suffix = 0;
  decimal = 1;
  if ( val < 0x3B9ACA00 )
  {
    if ( val < mega )
    {
      v5 = (double)val;
      if ( val >= kilo )
      {
        dval = (double)val / dkilo;
        strcpy((char *)suffix, "K");
      }
      else
      {
        dval = (double)val;
        decimal = 0;
      }
    }
    else
    {
      v5 = (double)(val / kilo);
      dval = v5 / dkilo;
      strcpy((char *)suffix, "M");
    }
  }
  else
  {
    v5 = (double)(val / mega);
    dval = v5 / dkilo;
    strcpy((char *)suffix, "G");
  }
  if ( sigdigits )
  {
    if ( dval <= 0.0 )
    {
      v7 = 0.0;
    }
    else
    {
      v6 = log10(v5);
      floor(v6);
      v7 = dval;
    }
    ndigits = (int)((double)(sigdigits - 1) - v7);
    if ( display )
      snprintf((char *)buf, bufsiz, "%*.*f%s", sigdigits + 1, ndigits, dval, (const char *)suffix);
    else
      snprintf((char *)buf, bufsiz, "%*.*f", sigdigits + 1, ndigits, dval);
  }
  else if ( decimal )
  {
    snprintf((char *)buf, bufsiz, "%.3g%s", dval, (const char *)suffix);
  }
  else
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)dval, (const char *)suffix);
  }
}

//----- (0001CA08) --------------------------------------------------------
bool __cdecl check_asic_reg_oneChain(int chainIndex, unsigned int reg, bool core_response)
{
  double v3; // d0
  int v5; // r0
  int v6; // r4
  uint64_t *v7; // r2
  unsigned __int8 displayed_rate_asic[32]; // [sp+2Ch] [bp+14h] BYREF
  uint8_t rate_buf[10]; // [sp+4Ch] [bp+34h] BYREF
  unsigned __int8 reg_buf[7]; // [sp+58h] [bp+40h] BYREF
  FILE *pFile_8; // [sp+60h] [bp+48h]
  FILE *pFile; // [sp+64h] [bp+4Ch]
  FILE *pFile_7; // [sp+68h] [bp+50h]
  FILE *pFile_0; // [sp+6Ch] [bp+54h]
  FILE *pFile_6; // [sp+70h] [bp+58h]
  FILE *pFile_5; // [sp+74h] [bp+5Ch]
  uint64_t temp_hash_rate; // [sp+78h] [bp+60h]
  FILE *pFile_2; // [sp+80h] [bp+68h]
  FILE *pFile_4; // [sp+84h] [bp+6Ch]
  FILE *pFile_3; // [sp+88h] [bp+70h]
  FILE *pFile_1; // [sp+8Ch] [bp+74h]
  unsigned int reg_value; // [sp+90h] [bp+78h]
  int i; // [sp+94h] [bp+7Ch]
  unsigned int reg_value_num; // [sp+98h] [bp+80h]
  int ii; // [sp+9Ch] [bp+84h]
  unsigned __int8 reg_address; // [sp+A3h] [bp+8Bh]
  int reg_processed_counter; // [sp+A4h] [bp+8Ch]
  uint64_t tmp_rate; // [sp+A8h] [bp+90h]
  int read_num; // [sp+B4h] [bp+9Ch]
  int not_reg_data_time; // [sp+B8h] [bp+A0h]
  int j; // [sp+BCh] [bp+A4h]

  not_reg_data_time = 0;
  reg_value_num = 0;
  memset(reg_buf, 0, sizeof(reg_buf));
  read_num = 0;
  tmp_rate = 0LL;
  reg_processed_counter = 0;
  reg_address = 0;
rerun_all:
  if ( !core_response )
    clear_register_value_buf();
  tmp_rate = 0LL;
  i = chainIndex;
  reg_processed_counter = 0;
  read_num = 0;
  if ( dev->chain_exist[chainIndex] == 1 )
  {
    tmp_rate = 0LL;
    if ( !core_response )
      read_asic_register(i, 1u, 0, reg);
    if ( !reg )
      dev->chain_asic_num[i] = 0;
    while ( not_reg_data_time <= 2 )
    {
      cgsleep_ms(300);
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf.reg_value_num;
      if ( (reg_value_buf.reg_value_num > 0x1FE || reg_value_buf.p_rd > 0x1FE) && not_reg_data_time <= 2 )
      {
        ++not_reg_data_time;
        pthread_mutex_unlock(&reg_mutex);
        goto rerun_all;
      }
      if ( not_reg_data_time == 3 )
      {
        pthread_mutex_unlock(&reg_mutex);
        return 1;
      }
      if ( reg_value_num )
      {
        reg_processed_counter += reg_value_num;
        if ( reg_processed_counter > 600 )
        {
          pthread_mutex_unlock(&reg_mutex);
          return 0;
        }
        not_reg_data_time = 0;
        for ( j = 0; reg_value_num > j; ++j )
        {
          if ( i == reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number )
          {
            reg_buf[3] = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
            reg_buf[2] = BYTE1(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_buf[1] = BYTE2(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_buf[0] = HIBYTE(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_address = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_address;
            reg_value = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
            if ( CRC5(reg_buf, 0x33u) == reg_value_buf.reg_buffer[reg_value_buf.p_rd].crc )
            {
              ++reg_value_buf.p_rd;
              --reg_value_buf.reg_value_num;
              if ( reg_value_buf.p_rd > 0x1FE )
                reg_value_buf.p_rd = 0;
              switch ( reg_address )
              {
                case 0u:
                  if ( HIWORD(reg_value) == 5011 )
                    ++dev->chain_asic_num[i];
                  if ( log_level > 4 )
                  {
                    print_crt_time_to_file(log_file, 4u);
                    pFile_0 = fopen((const char *)log_file, "a+");
                    if ( pFile_0 )
                      fprintf(
                        pFile_0,
                        "%s:%d:%s: chain[%02d] num[%d]: the asic CHIP_ADDRESS is 0x%08x\n",
                        "driver-btm-soc.c",
                        1829,
                        (const char *)_FUNCTION___15022,
                        i,
                        j,
                        reg_value);
                    fclose(pFile_0);
                  }
                  break;
                case 4u:
                  temp_hash_rate = 0LL;
                  if ( ++read_num <= 60 )
                  {
                    for ( ii = 0; ii <= 3; ++ii )
                      sprintf((char *)&rate_buf[2 * ii], "%02x", reg_buf[ii]);
                    temp_hash_rate = (__int64)strtol((const char *)rate_buf, 0, 16) << 24;
                    tmp_rate += temp_hash_rate;
                    suffix_string_soc(temp_hash_rate, displayed_rate_asic, 0x20u, 6, 0);
                    if ( log_level > 3 )
                    {
                      print_crt_time_to_file(log_file, 3u);
                      pFile_5 = fopen((const char *)log_file, "a+");
                      if ( pFile_5 )
                        fprintf(
                          pFile_5,
                          "%s:%d:%s: Asic[%02d]=%s ",
                          "driver-btm-soc.c",
                          1868,
                          (const char *)_FUNCTION___15022,
                          read_num,
                          (const char *)displayed_rate_asic);
                      fclose(pFile_5);
                    }
                    v6 = read_num - 1;
                    atof((const char *)displayed_rate_asic);
                    chain_asic_RT[i][v6] = v3;
                    if ( ((read_num & 7) == 0 || read_num == 60) && log_level > 3 )
                    {
                      print_crt_time_to_file(log_file, 3u);
                      pFile_6 = fopen((const char *)log_file, "a+");
                      if ( pFile_6 )
                        fprintf(pFile_6, "%s:%d:%s: \n", "driver-btm-soc.c", 1874, (const char *)_FUNCTION___15022);
                      fclose(pFile_6);
                    }
                  }
                  break;
                case 8u:
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_2 = fopen((const char *)log_file, "a+");
                    if ( pFile_2 )
                      fprintf(
                        pFile_2,
                        "%s:%d:%s: chain[%d]: the asic freq is 0x%x\n",
                        "driver-btm-soc.c",
                        1835,
                        (const char *)_FUNCTION___15022,
                        i,
                        reg_value);
                    fclose(pFile_2);
                  }
                  break;
                case 0x10u:
                  ++read_num;
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_4 = fopen((const char *)log_file, "a+");
                    if ( pFile_4 )
                      fprintf(
                        pFile_4,
                        "%s:%d:%s: chain[%02d] chip[%02d]: the asic HASH_COUNTING_NUMBER is 0x%08x\n",
                        "driver-btm-soc.c",
                        1843,
                        (const char *)_FUNCTION___15022,
                        i,
                        read_num,
                        reg_value);
                    fclose(pFile_4);
                  }
                  break;
                case 0x14u:
                  ++read_num;
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_3 = fopen((const char *)log_file, "a+");
                    if ( pFile_3 )
                      fprintf(
                        pFile_3,
                        "%s:%d:%s: chain[%02d] chip[%02d]: the asic TICKET_MASK is 0x%08x\n",
                        "driver-btm-soc.c",
                        1839,
                        (const char *)_FUNCTION___15022,
                        i,
                        read_num,
                        reg_value);
                    fclose(pFile_3);
                  }
                  break;
                case 0x18u:
                  if ( log_level > 4 )
                  {
                    print_crt_time_to_file(log_file, 4u);
                    pFile_1 = fopen((const char *)log_file, "a+");
                    if ( pFile_1 )
                      fprintf(
                        pFile_1,
                        "%s:%d:%s: chain[%02d] chip[%02d]: the misc is 0x%08x\n",
                        "driver-btm-soc.c",
                        1832,
                        (const char *)_FUNCTION___15022,
                        i,
                        read_num,
                        reg_value);
                    fclose(pFile_1);
                  }
                  break;
                default:
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_7 = fopen((const char *)log_file, "a+");
                    if ( pFile_7 )
                      fprintf(
                        pFile_7,
                        "%s:%d:%s: chain[%02d] num[%d]: the register  %02x value is 0x%08x\n",
                        "driver-btm-soc.c",
                        1879,
                        (const char *)_FUNCTION___15022,
                        i,
                        j,
                        reg_address,
                        reg_value);
                    fclose(pFile_7);
                  }
                  break;
              }
            }
            else
            {
              if ( log_level > 3 )
              {
                print_crt_time_to_file(log_file, 3u);
                pFile = fopen((const char *)log_file, "a+");
                if ( pFile )
                {
                  v5 = CRC5(reg_buf, 0x23u);
                  fprintf(
                    pFile,
                    "%s:%d:%s: crc is 0x%x, but it should be 0x%x\n",
                    "driver-btm-soc.c",
                    1805,
                    (const char *)_FUNCTION___15022,
                    v5,
                    reg_value_buf.reg_buffer[reg_value_buf.p_rd].crc);
                }
                fclose(pFile);
              }
              ++reg_value_buf.p_rd;
              --reg_value_buf.reg_value_num;
              if ( reg_value_buf.p_rd > 0x1FE )
                reg_value_buf.p_rd = 0;
            }
          }
          else
          {
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
          }
        }
        if ( !reg_address && dev->chain_asic_num[i] == 60 )
        {
          pthread_mutex_unlock(&reg_mutex);
          break;
        }
      }
      else
      {
        cgsleep_ms(100);
        ++not_reg_data_time;
      }
      pthread_mutex_unlock(&reg_mutex);
    }
    not_reg_data_time = 0;
    if ( !reg_address && dev->chain_asic_num[i] > (unsigned int)dev->max_asic_num_in_one_chain )
      dev->max_asic_num_in_one_chain = dev->chain_asic_num[i];
    if ( read_num == dev->chain_asic_num[i] )
    {
      rate[i] = tmp_rate;
      suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
      rate_error[i] = 0;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(
            pFile_8,
            "%s:%d:%s: chain %d hashrate is %s\n",
            "driver-btm-soc.c",
            1920,
            (const char *)_FUNCTION___15022,
            i,
            (const char *)displayed_rate[i]);
        fclose(pFile_8);
      }
    }
    if ( (!read_num || status_error) && (++rate_error[i] > 3 || status_error) )
    {
      v7 = &rate[i];
      *(_DWORD *)v7 = 0;
      *((_DWORD *)v7 + 1) = 0;
      suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
    }
    clear_register_value_buf();
  }
  return 1;
}
// 1D2A2: variable 'v3' is possibly undefined

//----- (0001D63C) --------------------------------------------------------
void __cdecl led_on(const unsigned __int8 *led)
{
  unsigned __int8 cmd[64]; // [sp+8h] [bp+8h] BYREF

  memset(cmd, 0, sizeof(cmd));
  sprintf((char *)cmd, "echo %d > %s", 1, (const char *)led);
  system((const char *)cmd);
}

//----- (0001D678) --------------------------------------------------------
void __cdecl led_off(const unsigned __int8 *led)
{
  unsigned __int8 cmd[64]; // [sp+8h] [bp+8h] BYREF

  memset(cmd, 0, sizeof(cmd));
  sprintf((char *)cmd, "echo %d > %s", 0, (const char *)led);
  system((const char *)cmd);
}

//----- (0001D6B4) --------------------------------------------------------
void __cdecl led_blink(const unsigned __int8 *led)
{
  unsigned __int8 cmd[64]; // [sp+8h] [bp+8h] BYREF

  memset(cmd, 0, sizeof(cmd));
  is_on_15064 = !is_on_15064;
  sprintf((char *)cmd, "echo %d > %s", !is_on_15064, (const char *)led);
  system((const char *)cmd);
}

//----- (0001D72C) --------------------------------------------------------
void set_led()
{
  switch ( get_error_type() )
  {
    case STATUS_OK:
      led_off("/sys/class/gpio/gpio941/value");
      led_blink("/sys/class/gpio/gpio942/value");
      break;
    case ERROR_OVER_MAXTEMP:
    case ERROR_UNKOWN_STATUS:
      led_blink("/sys/class/gpio/gpio941/value");
      led_off("/sys/class/gpio/gpio942/value");
      break;
    case ERROR_FAN_LOST:
      led_off("/sys/class/gpio/gpio941/value");
      led_off("/sys/class/gpio/gpio942/value");
      break;
    case ERROR_NETWORK_LOST:
      led_off("/sys/class/gpio/gpio941/value");
      led_on("/sys/class/gpio/gpio942/value");
      break;
    default:
      return;
  }
}

//----- (0001D7E8) --------------------------------------------------------
void *__cdecl __noreturn pic_heart_beat_func(void *arg)
{
  bool check_set_voltage_flag; // [sp+Eh] [bp+Eh]
  uint8_t i; // [sp+Fh] [bp+Fh]

  while ( 1 )
  {
    pthread_mutex_lock(&set_voltage_lock);
    check_set_voltage_flag = set_voltage_flag;
    pthread_mutex_unlock(&set_voltage_lock);
    if ( !check_set_voltage_flag )
    {
      for ( i = 0; i <= 0xFu; ++i )
      {
        if ( dev->chain_exist[i] )
        {
          if ( !*((_BYTE *)&pattern_info_t.scan_record_count[-587305] + (_DWORD)&pattern_info_t + i) )
            pic_heart_beat_each_chain(i);
        }
      }
    }
    sleep(0xAu);
  }
}

//----- (0001D87A) --------------------------------------------------------
int __cdecl get_asic_nonce_num(int chain, int asic, int timeslice)
{
  int nonce; // [sp+14h] [bp+14h]
  int index; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  nonce = 0;
  for ( i = 1; i <= timeslice; ++i )
  {
    if ( nonce_times % 60 - i < 0 )
      index = nonce_times % 60 - i + 60;
    else
      index = nonce_times % 60 - i;
    nonce += LODWORD(nonce_num[chain][asic][index]);
  }
  return nonce;
}

//----- (0001D976) --------------------------------------------------------
void __cdecl get_lastn_nonce_num(unsigned __int8 *dest, int n)
{
  int asic_nonce_num; // r0
  int v3; // r0
  unsigned __int8 xtime[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 tmp[20]; // [sp+80Ch] [bp+80Ch] BYREF
  int j; // [sp+820h] [bp+820h]
  int i; // [sp+824h] [bp+824h]

  j = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      *(_DWORD *)xtime = 123;
      memset(&xtime[4], 0, 0x7FCu);
      memset(tmp, 0, sizeof(tmp));
      sprintf((char *)tmp, "Chain%d:{", i + 1);
      strcat((char *)xtime, (const char *)tmp);
      asic_nonce_num = get_asic_nonce_num(i, 0, n);
      sprintf((char *)tmp, "N%d=%d", 0, asic_nonce_num);
      strcat((char *)xtime, (const char *)tmp);
      for ( j = 1; j < dev->max_asic_num_in_one_chain; ++j )
      {
        v3 = get_asic_nonce_num(i, j, n);
        sprintf((char *)tmp, ",N%d=%d", j, v3);
        strcat((char *)xtime, (const char *)tmp);
      }
      strcat((char *)xtime, "},");
      strcat((char *)dest, (const char *)xtime);
    }
  }
  dest[strlen((const char *)dest) - 1] = 0;
}

//----- (0001DB02) --------------------------------------------------------
void __cdecl saveTestID(int testID)
{
  unsigned __int8 testnumStr[32]; // [sp+Ch] [bp+Ch] BYREF
  FILE *fd; // [sp+2Ch] [bp+2Ch]

  fd = fopen("/tmp/testID", "wb");
  if ( fd )
  {
    memset(testnumStr, 0, sizeof(testnumStr));
    sprintf((char *)testnumStr, "%d", testID);
    fwrite(testnumStr, 1u, 0x20u, fd);
    fclose(fd);
  }
}

//----- (0001DB64) --------------------------------------------------------
void clear_test_ID()
{
  unsigned __int8 testnumStr[32]; // [sp+4h] [bp+4h] BYREF
  FILE *fd; // [sp+24h] [bp+24h]

  fd = fopen("/tmp/testID", "wb");
  if ( fd )
  {
    memset(testnumStr, 0, sizeof(testnumStr));
    sprintf((char *)testnumStr, "%d", 0);
    fwrite(testnumStr, 1u, 0x20u, fd);
    fclose(fd);
  }
}

//----- (0001DBBE) --------------------------------------------------------
int __cdecl read_test_ID(uint32_t *testID, uint32_t *data)
{
  unsigned __int8 testnumStr[32]; // [sp+18h] [bp+8h] BYREF
  FILE *pFile; // [sp+38h] [bp+28h]
  FILE *fd; // [sp+3Ch] [bp+2Ch]

  fd = fopen("/tmp/testID", "rb");
  if ( !fd )
    return 0;
  memset(testnumStr, 0, sizeof(testnumStr));
  fread(testnumStr, 1u, 0x20u, fd);
  fclose(fd);
  if ( testnumStr[0] != 48 || testnumStr[1] != 120 )
    return atoi((const char *)testnumStr);
  sscanf((const char *)testnumStr, "%x %x", testID, data);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: receive test id :0x%x, data : 0x%x!\n",
        "driver-btm-soc.c",
        2179,
        (const char *)_FUNCTION___15142,
        *testID,
        *data);
    fclose(pFile);
  }
  return 0;
}

//----- (0001DCB8) --------------------------------------------------------
void process_test()
{
  double v0; // d0
  int reopen_pwm; // r0
  double v2; // r2
  double v3; // r0
  double v4; // r2
  uint32_t data; // [sp+18h] [bp+0h] BYREF
  uint32_t testID; // [sp+1Ch] [bp+4h] BYREF
  FILE *pFile; // [sp+20h] [bp+8h]
  FILE *pFile_0; // [sp+24h] [bp+Ch]
  double custom_voltage; // [sp+28h] [bp+10h]
  FILE *pFile_1; // [sp+30h] [bp+18h]
  FILE *pFile_2; // [sp+34h] [bp+1Ch]
  double custom_voltage_0; // [sp+38h] [bp+20h]
  int core; // [sp+40h] [bp+28h]
  int asic; // [sp+44h] [bp+2Ch]
  int i; // [sp+48h] [bp+30h]
  int chain; // [sp+4Ch] [bp+34h]

  testID = 0;
  data = 0;
  read_test_ID(&testID, &data);
  clear_test_ID();
  if ( !testID )
    return;
  saveTestID(0);
  switch ( testID )
  {
    case 0x11u:
      dump_nonce_info_all_asic();
      return;
    case 0x12u:
      reopen_pwm = get_reopen_pwm();
      re_open_core(reopen_pwm);
      slowly_set_iic_power_to_working_voltage();
      return;
    case 0x13u:
      custom_voltage = 0.0;
      if ( is_T11() )
      {
        for ( chain = 0; chain <= 15; ++chain )
        {
          if ( dev->chain_exist[chain] )
          {
            get_current_voltage_by_chain(chain);
            custom_voltage = v0;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile = fopen((const char *)log_file, "a+");
              if ( pFile )
                fprintf(
                  pFile,
                  "%s:%d:%s: chain[%d] voltage: %0.2f, now set to: %0.2f\n",
                  "driver-btm-soc.c",
                  2223,
                  (const char *)_FUNCTION___15153,
                  chain,
                  custom_voltage,
                  custom_voltage + 0.100000001);
              fclose(pFile);
            }
            HIDWORD(v2) = (unsigned __int8)chain;
            v0 = custom_voltage + 0.100000001;
            slowly_set_iic_power_to_custom_voltage_by_chain(chain, v2);
          }
        }
        return;
      }
      get_current_voltage();
      custom_voltage = v0;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: voltage: %0.2f, now set to: %0.2f\n",
            "driver-btm-soc.c",
            2230,
            (const char *)_FUNCTION___15153,
            custom_voltage,
            custom_voltage + 0.100000001);
        LODWORD(v3) = fclose(pFile_0);
      }
LABEL_22:
      slowly_set_iic_power_to_custom_voltage(v3);
      return;
    case 0x14u:
      custom_voltage_0 = 0.0;
      if ( !is_T11() )
      {
        get_current_voltage();
        custom_voltage_0 = v0;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: voltage: %0.2f, now set to: %0.2f\n",
              "driver-btm-soc.c",
              2251,
              (const char *)_FUNCTION___15153,
              custom_voltage_0,
              custom_voltage_0 - 0.100000001);
          LODWORD(v3) = fclose(pFile_2);
        }
        goto LABEL_22;
      }
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] )
        {
          get_current_voltage_by_chain(chain);
          custom_voltage_0 = v0;
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: chain[%d] voltage: %0.2f, now set to: %0.2f\n",
                "driver-btm-soc.c",
                2244,
                (const char *)_FUNCTION___15153,
                chain,
                custom_voltage_0,
                custom_voltage_0 - 0.100000001);
            fclose(pFile_1);
          }
          HIDWORD(v4) = (unsigned __int8)chain;
          v0 = custom_voltage_0 - 0.100000001;
          slowly_set_iic_power_to_custom_voltage_by_chain(chain, v4);
        }
      }
      break;
    default:
      if ( (testID & 0xFF000000) == -1308622848 )
      {
        chain = (testID >> 20) & 0xF;
        asic = (unsigned __int8)(testID >> 12);
        core = (unsigned __int8)testID;
        if ( (unsigned __int8)testID == 255 )
        {
          for ( i = 0; i <= 207; ++i )
            do_dump_core_hash_clock_counter(chain, asic, i);
        }
        else
        {
          do_dump_core_hash_clock_counter(chain, asic, core);
        }
      }
      break;
  }
}
// 1DD4C: variable 'v0' is possibly undefined
// 1DDEC: variable 'v2' is possibly undefined
// 1DE9C: variable 'v3' is possibly undefined
// 1DF86: variable 'v4' is possibly undefined

//----- (0001E0A8) --------------------------------------------------------
uint32_t __cdecl get_domain_nounce_number(uint32_t chain, uint32_t domain)
{
  int j; // [sp+1Ch] [bp+1Ch]
  int i; // [sp+20h] [bp+20h]
  uint32_t nounc_num; // [sp+24h] [bp+24h]

  nounc_num = 0;
  for ( i = 10 * (domain >> 2); i < (int)(10 * (domain >> 2) + 10); ++i )
  {
    for ( j = 52 * (domain & 3); j < (int)(52 * (domain & 3) + 52); ++j )
      nounc_num += calc_nonce_info.chain_asic_core_nonce_num[chain][i][j];
  }
  return nounc_num;
}

//----- (0001E144) --------------------------------------------------------
void dump_nonce_info_all_domain()
{
  FILE *pFile_2; // [sp+Ch] [bp+4h]
  FILE *pFile_1; // [sp+10h] [bp+8h]
  FILE *pFile_4; // [sp+14h] [bp+Ch]
  FILE *pFile_3; // [sp+18h] [bp+10h]
  FILE *pFile_0; // [sp+1Ch] [bp+14h]
  FILE *pFile_6; // [sp+20h] [bp+18h]
  FILE *pFile_5; // [sp+24h] [bp+1Ch]
  FILE *pFile; // [sp+28h] [bp+20h]
  uint32_t nonce_num; // [sp+30h] [bp+28h]
  uint32_t total_big_domain_nonce_num; // [sp+34h] [bp+2Ch]
  int inbalance_domain_num_all_chain; // [sp+38h] [bp+30h]
  int inbalance_domain_num_single_chain; // [sp+3Ch] [bp+34h]
  int domain_id; // [sp+40h] [bp+38h]
  int chain_id; // [sp+44h] [bp+3Ch]

  inbalance_domain_num_all_chain = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file("/var/log/hash_rate", 3u);
    pFile = fopen("/var/log/hash_rate", "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: \n dump domain nonce number...\n",
        "driver-btm-soc.c",
        2359,
        (const char *)_FUNCTION___15215);
    fclose(pFile);
  }
  for ( chain_id = 0; chain_id <= 15; ++chain_id )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "Chain[%d]:\n", chain_id);
        fclose(pFile_0);
      }
      total_big_domain_nonce_num = 0;
      inbalance_domain_num_single_chain = 0;
      for ( domain_id = 0; domain_id <= 23; ++domain_id )
      {
        nonce_num = get_domain_nounce_number(chain_id, domain_id);
        if ( log_level > 3 )
        {
          pFile_1 = fopen("/var/log/hash_rate", "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "D[%02d]:%-10d ", domain_id, nonce_num);
          fclose(pFile_1);
        }
        total_big_domain_nonce_num += nonce_num;
        if ( (((_BYTE)domain_id + 1) & 3) == 0 )
        {
          if ( log_level > 3 )
          {
            pFile_2 = fopen("/var/log/hash_rate", "a+");
            if ( pFile_2 )
              fprintf(pFile_2, "D_BIG[%02d]:%-10d\n", domain_id / 4, total_big_domain_nonce_num);
            fclose(pFile_2);
          }
          total_big_domain_nonce_num = 0;
        }
        if ( nonce_num == nonce_at_domain_15210[chain_id][domain_id] )
        {
          ++inbalance_domain_num_single_chain;
          ++inbalance_domain_num_all_chain;
        }
        nonce_at_domain_15210[chain_id][domain_id] = nonce_num;
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_3 )
          fprintf(pFile_3, "chain [%d] inbalance domain number: %d\n", chain_id, inbalance_domain_num_single_chain);
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_4 )
          fputc(10, pFile_4);
        fclose(pFile_4);
      }
      imbalance_domain_count_chain[chain_id] = inbalance_domain_num_single_chain;
    }
  }
  if ( log_level > 3 )
  {
    pFile_5 = fopen("/var/log/hash_rate", "a+");
    if ( pFile_5 )
      fprintf(pFile_5, "inbalance domain number of all chain: %d\n", inbalance_domain_num_all_chain);
    fclose(pFile_5);
  }
  if ( log_level > 3 )
  {
    pFile_6 = fopen("/var/log/hash_rate", "a+");
    if ( pFile_6 )
      fputc(10, pFile_6);
    fclose(pFile_6);
  }
  imbalance_domain_count_total = inbalance_domain_num_all_chain;
}

//----- (0001E43A) --------------------------------------------------------
void __cdecl get_imbalance_domain_count(unsigned __int8 *infoStr)
{
  int chain; // [sp+8h] [bp+8h]
  int len; // [sp+Ch] [bp+Ch]

  len = sprintf((char *)infoStr, "%d ", imbalance_domain_count_total);
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      len += sprintf((char *)&infoStr[len], "%d ", imbalance_domain_count_chain[chain]);
  }
}

//----- (0001E4CA) --------------------------------------------------------
void __cdecl get_domain_nonce_data(uint32_t *buf, uint32_t *len)
{
  uint32_t v2; // r3
  uint32_t nonce_num; // [sp+8h] [bp+8h]
  uint32_t index; // [sp+Ch] [bp+Ch]
  int domain_id; // [sp+10h] [bp+10h]
  int chain_id; // [sp+14h] [bp+14h]

  index = 0;
  for ( chain_id = 0; chain_id <= 15; ++chain_id )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      for ( domain_id = 0; domain_id <= 23; ++domain_id )
      {
        nonce_num = get_domain_nounce_number(chain_id, domain_id);
        v2 = index++;
        buf[v2] = nonce_num;
      }
    }
  }
  *len = index;
}

//----- (0001E552) --------------------------------------------------------
void save_base_domain_nonce_data()
{
  uint32_t len; // [sp+4h] [bp+4h] BYREF

  get_domain_nonce_data(base_domain_nonce_buf, &len);
}

//----- (0001E570) --------------------------------------------------------
void aging_get_finish_avg_hashrate()
{
  ;
}

//----- (0001E58E) --------------------------------------------------------
uint32_t aging_get_last_stable_time()
{
  return aging_info.aging_seconds - aging_info.last_inbalance_time;
}

//----- (0001E5B4) --------------------------------------------------------
void aging_save_info()
{
  const char *v0; // r3
  int v1; // r0
  const char *v2; // r3
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  const char *v15; // r3
  int v16; // r0
  const char *v17; // r3
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  unsigned __int8 logstr[2048]; // [sp+8h] [bp+0h] BYREF
  FILE *fd; // [sp+808h] [bp+800h]
  int chain; // [sp+80Ch] [bp+804h]
  int len; // [sp+810h] [bp+808h]
  int i; // [sp+814h] [bp+80Ch]

  fd = 0;
  memset(logstr, 0, sizeof(logstr));
  len = 0;
  fd = fopen((const char *)aging_file, "wb");
  if ( fd )
  {
    fwrite(&aging_info, 1u, 0x99C0u, fd);
    fclose(fd);
  }
  fd = fopen((const char *)aging_debug, (const char *)&word_81B34);
  if ( fd )
    fclose(fd);
  fd = fopen((const char *)aging_debug, "a+");
  if ( fd )
  {
    if ( aging_info.is_aging_finished )
      v0 = (const char *)&unk_81B38;
    else
      v0 = (const char *)&unk_81B3C;
    v1 = sprintf((char *)&logstr[len], "is aging finished : %s\n", v0);
    len += v1;
    if ( aging_info.is_bad_machine )
      v2 = (const char *)&unk_81B38;
    else
      v2 = (const char *)&unk_81B3C;
    v3 = sprintf((char *)&logstr[len], "is bad machine    : %s\n", v2);
    len += v3;
    v4 = sprintf((char *)&logstr[len], "total aging time  : %d seconds\n", aging_info.aging_seconds);
    len += v4;
    v5 = sprintf((char *)&logstr[len], "sweep temperature : %d\n", aging_info.sweep_temp);
    len += v5;
    v6 = sprintf((char *)&logstr[len], "last inbalance at : %d second\n", aging_info.last_inbalance_time);
    len += v6;
    v7 = sprintf((char *)&logstr[len], "start time        : %s", (const char *)aging_info.start_time);
    len += v7;
    if ( aging_info.finish_time[0] )
    {
      v8 = sprintf((char *)&logstr[len], "finish time       : %s", (const char *)aging_info.finish_time);
      len += v8;
    }
    else
    {
      strcpy((char *)&logstr[len], "finish time       : \n");
      len += 21;
    }
    v9 = sprintf((char *)&logstr[len], "start time value  : %lu\n", aging_info.tv_start_time.tv_sec);
    len += v9;
    v10 = sprintf((char *)&logstr[len], "finish time value : %lu\n", aging_info.tv_finish_time.tv_sec);
    len += v10;
    v11 = sprintf((char *)&logstr[len], "average hashrate  : %.2f\n", aging_info.avg_hashrate_when_finish);
    len += v11;
    fwrite(logstr, 1u, len, fd);
    len = 0;
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        v12 = sprintf(
                (char *)&logstr[len],
                "\nchain %d inbalance %d times:\n",
                chain,
                aging_info.inbalance_times[chain]);
        len += v12;
        for ( i = 0; aging_info.inbalance_times[chain] > i; ++i )
        {
          v13 = sprintf(
                  (char *)&logstr[len],
                  "%d. %s",
                  i + 1,
                  (const char *)aging_info.inbalance_timestamp + 64 * (i + 32 * chain));
          len += v13;
          v14 = sprintf(
                  (char *)&logstr[--len],
                  ", time %4ds, voltage %.2f\n",
                  aging_info.inbalance_detected_time[chain][i],
                  aging_info.inbalance_voltage[chain][i]);
          len += v14;
          if ( len > 1024 )
          {
            fwrite(logstr, 1u, len, fd);
            len = 0;
          }
        }
      }
    }
    fwrite(logstr, 1u, len, fd);
    len = 0;
    if ( aging_info.aging_24_hour_finished )
      v15 = (const char *)&unk_81B38;
    else
      v15 = (const char *)&unk_81B3C;
    v16 = sprintf((char *)logstr, "\naging_24_hour_finished  : %s\n", v15);
    len += v16;
    if ( aging_info.is_hash_rate_updated )
      v17 = (const char *)&unk_81B38;
    else
      v17 = (const char *)&unk_81B3C;
    v18 = sprintf((char *)&logstr[len], "is_hash_rate_updated    : %s\n", v17);
    len += v18;
    v19 = sprintf((char *)&logstr[len], "org_ideal_fixed_hashrate: %d\n", aging_info.fixed_hashrate);
    len += v19;
    v20 = sprintf((char *)&logstr[len], "avg_hashrate_24_hour    : %d\n", aging_info.avg_hashrate_24_hour);
    len += v20;
    if ( aging_info.aging_24_hour_finished )
    {
      v21 = sprintf((char *)&logstr[len], "update time: %s", (const char *)aging_info.aging_24_hour_finish_time);
      len += v21;
    }
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        v22 = sprintf(
                (char *)&logstr[len],
                "chain %d old_hashrate %d new_hashrate %d\n",
                chain,
                aging_info.old_hashrate[chain],
                aging_info.new_hashrate[chain]);
        len += v22;
      }
    }
    fwrite(logstr, 1u, len, fd);
    fclose(fd);
  }
}
// 81B34: using guessed type __int16 word_81B34;

//----- (0001EC18) --------------------------------------------------------
void aging_get_info()
{
  FILE *fd; // [sp+4h] [bp+4h]

  fd = fopen((const char *)aging_file, "rb");
  if ( fd )
  {
    fread(&aging_info, 1u, 0x99C0u, fd);
  }
  else
  {
    memset(&aging_info, 0, sizeof(aging_info));
    aging_info.is_aging_finished = 1;
  }
  aging_info.is_aging_finished = 1;
  if ( fd )
    fclose(fd);
}

//----- (0001EC98) --------------------------------------------------------
void aging_start()
{
  float v0; // s0
  char *v1; // r0
  char *v2; // r0
  time_t curtime; // [sp+4h] [bp+4h] BYREF

  memset(&aging_info, 0, sizeof(aging_info));
  time(&curtime);
  v1 = ctime(&curtime);
  strcpy((char *)aging_info.start_time, v1);
  cgtime(&aging_info.tv_start_time);
  get_env_temperature();
  aging_info.sweep_temp = (int)v0;
  v2 = ctime(&curtime);
  strcpy((char *)aging_info.finish_time, v2);
  aging_info.is_aging_finished = 1;
  cgtime(&aging_info.tv_finish_time);
  aging_save_info();
}
// 1ECE8: variable 'v0' is possibly undefined

//----- (0001ED2C) --------------------------------------------------------
void aging_stop()
{
  double v0; // d0
  char *v1; // r0
  time_t curtime; // [sp+4h] [bp+4h] BYREF

  time(&curtime);
  v1 = ctime(&curtime);
  strcpy((char *)aging_info.finish_time, v1);
  aging_info.is_aging_finished = 1;
  cgtime(&aging_info.tv_finish_time);
  getAVGhashrate();
  aging_info.avg_hashrate_when_finish = v0;
  aging_save_info();
}
// 1ED6E: variable 'v0' is possibly undefined

//----- (0001ED88) --------------------------------------------------------
uint32_t aging_get_total_inbalance_times()
{
  return aging_info.total_inbalance_times;
}

//----- (0001EDA2) --------------------------------------------------------
int aging_get_sweep_temp()
{
  return aging_info.sweep_temp;
}

//----- (0001EDBC) --------------------------------------------------------
void __cdecl aging_update_time(int aging_time_increase)
{
  double v1; // d0

  get_total_secs();
  aging_info.aging_seconds += (unsigned int)v1 - last_total_seconds_15366;
  last_total_seconds_15366 = (unsigned int)v1;
  aging_save_info();
}
// 1EDEE: variable 'v1' is possibly undefined

//----- (0001EE16) --------------------------------------------------------
uint32_t aging_get_time()
{
  return aging_info.aging_seconds;
}

//----- (0001EE2E) --------------------------------------------------------
bool aging_is_ongoing()
{
  return !aging_info.is_aging_finished;
}

//----- (0001EE5C) --------------------------------------------------------
bool aging_is_bad_machine()
{
  return aging_info.is_bad_machine && !aging_info.aging_24_hour_finished;
}

//----- (0001EE98) --------------------------------------------------------
void __cdecl aging_get_update_hashrate_info(unsigned __int8 *infoStr)
{
  const char *v1; // r3
  const char *v2; // r3
  int chain; // [sp+8h] [bp+8h]
  int len; // [sp+Ch] [bp+Ch]
  int lenb; // [sp+Ch] [bp+Ch]
  int lena; // [sp+Ch] [bp+Ch]

  if ( aging_info.aging_24_hour_finished )
    v1 = (const char *)&unk_81B38;
  else
    v1 = (const char *)&unk_81B3C;
  len = sprintf((char *)infoStr, "aging_24_hour_finished: %s, ", v1);
  if ( aging_info.is_hash_rate_updated )
    v2 = (const char *)&unk_81B38;
  else
    v2 = (const char *)&unk_81B3C;
  lenb = len + sprintf((char *)&infoStr[len], "hashrate updated: %s, ", v2);
  lena = lenb
       + sprintf(
           (char *)&infoStr[lenb],
           "fixed %d avg %d, ",
           aging_info.fixed_hashrate,
           aging_info.avg_hashrate_24_hour);
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      lena += sprintf((char *)&infoStr[lena], "%d->%d ", aging_info.old_hashrate[chain], aging_info.new_hashrate[chain]);
  }
  if ( aging_info.aging_24_hour_finished )
    sprintf((char *)&infoStr[lena], "update time: %s, ", (const char *)aging_info.aging_24_hour_finish_time);
}

//----- (0001F01C) --------------------------------------------------------
void __cdecl getAginginfo(unsigned __int8 *infoStr)
{
  const char *v1; // r2
  const char *v2; // r3
  int len; // [sp+14h] [bp+Ch]
  int lena; // [sp+14h] [bp+Ch]

  if ( aging_info.is_aging_finished )
    v1 = (const char *)&unk_81B38;
  else
    v1 = (const char *)&unk_81B3C;
  if ( aging_info.is_bad_machine )
    v2 = (const char *)&unk_81B38;
  else
    v2 = (const char *)&unk_81B3C;
  len = sprintf((char *)infoStr, "finished: %s bad: %s from %s", v1, v2, (const char *)aging_info.start_time) - 1;
  lena = len + sprintf((char *)&infoStr[len], " to %s", (const char *)aging_info.finish_time);
  sprintf(
    (char *)&infoStr[lena],
    " inbalance_times %d %d %d",
    aging_info.inbalance_times[0],
    aging_info.inbalance_times[1],
    aging_info.inbalance_times[2]);
}

//----- (0001F0FC) --------------------------------------------------------
int *get_hw_errors()
{
  if ( aging_is_bad_machine() )
    return &calc_nonce_info.chain_asic_core_nonce_num[5][48][190];
  else
    return (int *)hw_errors;
}

//----- (0001F122) --------------------------------------------------------
void low_temp_process_parm_init()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  int chain; // [sp+14h] [bp+Ch]

  if ( !minor_type_init_15414 )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        minor_types_15415 = g_minor_type[chain];
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chip miner_type = [%d]\n",
              "driver-btm-soc.c",
              2916,
              (const char *)_FUNCTION___15419,
              minor_types_15415);
          fclose(pFile);
        }
      }
    }
    minor_type_init_15414 = 1;
  }
  if ( is_T11() )
  {
    if ( minor_types_15415 )
    {
      switch ( minor_types_15415 )
      {
        case PKG_CE:
          low_temp_process_parm[0].low_temp = 12;
          low_temp_process_parm[0].middle_temp = 24;
          low_temp_process_parm[0].high_temp = 29;
          low_temp_process_parm[0].delta_vol = 0.2;
          low_temp_process_parm[1].low_temp = 28;
          low_temp_process_parm[1].middle_temp = 37;
          low_temp_process_parm[1].high_temp = 42;
          low_temp_process_parm[1].delta_vol = 0.2;
          break;
        case PKG_B_BGM:
          low_temp_process_parm[0].low_temp = 23;
          low_temp_process_parm[0].middle_temp = 25;
          low_temp_process_parm[0].high_temp = 30;
          low_temp_process_parm[0].delta_vol = 0.2;
          low_temp_process_parm[1].low_temp = 28;
          low_temp_process_parm[1].middle_temp = 32;
          low_temp_process_parm[1].high_temp = 37;
          low_temp_process_parm[1].delta_vol = 0.2;
          break;
        case PKG_BE:
          low_temp_process_parm[0].low_temp = 23;
          low_temp_process_parm[0].middle_temp = 35;
          low_temp_process_parm[0].high_temp = 40;
          low_temp_process_parm[0].delta_vol = 0.6;
          low_temp_process_parm[1].low_temp = 23;
          low_temp_process_parm[1].middle_temp = 35;
          low_temp_process_parm[1].high_temp = 40;
          low_temp_process_parm[1].delta_vol = 1.5;
          break;
        default:
          low_temp_process_parm[0].low_temp = 12;
          low_temp_process_parm[0].middle_temp = 24;
          low_temp_process_parm[0].high_temp = 29;
          low_temp_process_parm[0].delta_vol = 0.5;
          low_temp_process_parm[1].low_temp = 28;
          low_temp_process_parm[1].middle_temp = 37;
          low_temp_process_parm[1].high_temp = 42;
          low_temp_process_parm[1].delta_vol = 0.3;
          break;
      }
    }
    else
    {
      low_temp_process_parm[0].low_temp = 12;
      low_temp_process_parm[0].middle_temp = 22;
      low_temp_process_parm[0].high_temp = 27;
      low_temp_process_parm[0].delta_vol = 0.2;
      low_temp_process_parm[1].low_temp = 18;
      low_temp_process_parm[1].middle_temp = 26;
      low_temp_process_parm[1].high_temp = 31;
      low_temp_process_parm[1].delta_vol = 0.3;
    }
  }
  else
  {
    low_temp_process_parm[0].low_temp = 22;
    low_temp_process_parm[0].middle_temp = 26;
    low_temp_process_parm[0].high_temp = 31;
    low_temp_process_parm[0].delta_vol = 1.5;
    low_temp_process_parm[1].low_temp = 22;
    low_temp_process_parm[1].middle_temp = 26;
    low_temp_process_parm[1].high_temp = 31;
    low_temp_process_parm[1].delta_vol = 1.7;
  }
}

//----- (0001F568) --------------------------------------------------------
int get_reopen_pwm()
{
  FILE *pFile_0; // [sp+8h] [bp+0h]
  FILE *pFile_3; // [sp+Ch] [bp+4h]
  FILE *pFile_2; // [sp+10h] [bp+8h]
  FILE *pFile_1; // [sp+14h] [bp+Ch]
  FILE *pFile; // [sp+18h] [bp+10h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: lowest pcb temp: %d\n",
        "driver-btm-soc.c",
        3231,
        (const char *)_FUNCTION___15465,
        last_testpatten_lowest_pcb_temp);
    fclose(pFile);
  }
  if ( last_testpatten_lowest_pcb_temp > 26 )
  {
    if ( last_testpatten_lowest_pcb_temp > 30 )
    {
      if ( last_testpatten_lowest_pcb_temp > 34 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(
              pFile_3,
              "%s:%d:%s: reopen pwm = %d\n",
              "driver-btm-soc.c",
              3253,
              (const char *)_FUNCTION___15465,
              100);
          fclose(pFile_3);
        }
        return 100;
      }
      else
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: reopen pwm = %d\n",
              "driver-btm-soc.c",
              3247,
              (const char *)_FUNCTION___15465,
              80);
          fclose(pFile_2);
        }
        return 80;
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: reopen pwm = %d\n", "driver-btm-soc.c", 3241, (const char *)_FUNCTION___15465, 30);
        fclose(pFile_1);
      }
      return 30;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: reopen pwm = %d\n", "driver-btm-soc.c", 3235, (const char *)_FUNCTION___15465, 0);
      fclose(pFile_0);
    }
    return 0;
  }
}

//----- (0001F80C) --------------------------------------------------------
void switch_to_mode0()
{
  int reopen_pwm; // r0
  FILE *pFile; // [sp+8h] [bp+0h]
  int chain; // [sp+Ch] [bp+4h]

  g_pulse_mode = 0;
  for ( chain = 0; chain < dev->chain_num; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: \n\nswitch chain %d\n",
            "driver-btm-soc.c",
            3267,
            (const char *)_FUNCTION___15474,
            chain);
        fclose(pFile);
      }
      reopen_pwm = get_reopen_pwm();
      re_open_core_by_chain(reopen_pwm, chain, 0);
      sleep(0x3Cu);
    }
  }
}

//----- (0001F8EA) --------------------------------------------------------
void check_asic_status()
{
  uint32_t *v0; // r3
  FILE *pFile; // [sp+1Ch] [bp+4h]
  FILE *pFile_0; // [sp+20h] [bp+8h]
  int offset; // [sp+24h] [bp+Ch]
  int avg_num; // [sp+28h] [bp+10h]
  int asic_num; // [sp+2Ch] [bp+14h]
  int j; // [sp+30h] [bp+18h]
  int ja; // [sp+30h] [bp+18h]
  int i; // [sp+34h] [bp+1Ch]
  int ia; // [sp+34h] [bp+1Ch]

  if ( !is_in_error() )
  {
    asic_num = 0;
    avg_num = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] )
      {
        asic_num += dev->chain_asic_num[i];
        for ( j = 0; j < dev->chain_asic_num[i]; ++j )
        {
          nonce_num[i][j][nonce_times % 60] = dev->chain_asic_nonce[i][j];
          avg_num += LODWORD(dev->chain_asic_nonce[i][j]);
          if ( log_level > 4 )
          {
            print_crt_time_to_file(log_file, 4u);
            pFile = fopen((const char *)log_file, "a+");
            if ( pFile )
              fprintf(
                pFile,
                "%s:%d:%s: chain %d asic %d asic_nonce_num %llu\n",
                "driver-btm-soc.c",
                3291,
                (const char *)_FUNCTION___15485,
                i,
                j,
                dev->chain_asic_nonce[i][j]);
            fclose(pFile);
          }
        }
      }
    }
    ++nonce_times;
    memset(nonce_num10_string, 0, sizeof(nonce_num10_string));
    memset(nonce_num30_string, 0, sizeof(nonce_num30_string));
    memset(nonce_num60_string, 0, sizeof(nonce_num60_string));
    get_lastn_nonce_num(nonce_num10_string, 10);
    get_lastn_nonce_num(nonce_num30_string, 30);
    get_lastn_nonce_num(nonce_num60_string, 60);
    if ( asic_num && log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: avg_num %d asic_num %d\n",
          "driver-btm-soc.c",
          3305,
          (const char *)_FUNCTION___15485,
          avg_num,
          asic_num);
      fclose(pFile_0);
    }
    for ( ia = 0; ia <= 15; ++ia )
    {
      if ( dev->chain_exist[ia] )
      {
        offset = 0;
        for ( ja = 0; ja < dev->chain_asic_num[ia]; ++ja )
        {
          if ( (ja & 7) == 0 )
            dev->chain_asic_status_string[ia][ja + offset++] = 32;
          if ( get_asic_nonce_num(ia, ja, 1) <= 1 )
          {
            dev->chain_asic_status_string[ia][ja + offset] = 111;
            if ( !status_error )
              ++x_time[ia][ja];
          }
          else
          {
            dev->chain_asic_status_string[ia][ja + offset] = 111;
          }
          v0 = &dev->chain_hw[256 * ia + 15 + 2 * ja];
          v0[1] = 0;
          v0[2] = 0;
        }
        dev->chain_asic_status_string[ia][ja + offset] = 0;
      }
    }
  }
}

//----- (0001FD50) --------------------------------------------------------
void __cdecl volt_decrease_for_mode0(double lower_limit_volt, double delta_volt, bool *increased_flag)
{
  double v3; // d0
  double v4; // d1
  double v5; // r2
  bool *increased_flaga; // [sp+1Ch] [bp+4h]
  double lower_limit_volta; // [sp+28h] [bp+10h]
  double working_voltage; // [sp+30h] [bp+18h] BYREF
  FILE *pFile_0; // [sp+38h] [bp+20h]
  FILE *pFile_1; // [sp+3Ch] [bp+24h]
  FILE *pFile_2; // [sp+40h] [bp+28h]
  FILE *pFile; // [sp+44h] [bp+2Ch]
  double custom_voltage; // [sp+48h] [bp+30h]
  int chain; // [sp+54h] [bp+3Ch]

  lower_limit_volta = v3;
  increased_flaga = (bool *)LODWORD(lower_limit_volt);
  custom_voltage = 0.0;
  working_voltage = 0.0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      get_current_voltage_by_chain(chain);
      custom_voltage = v3;
      eeprom_get_voltage_mode2(chain, &working_voltage);
      LODWORD(v5) = increased_flaga;
      if ( !increased_flaga[chain] && custom_voltage < working_voltage )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chain[%d] is not sanctified with decreasing requirements\n",
              "driver-btm-soc.c",
              3377,
              (const char *)_FUNCTION___15510,
              chain);
          fclose(pFile);
        }
      }
      else if ( custom_voltage >= lower_limit_volta )
      {
        if ( lower_limit_volta < custom_voltage - v4 )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: chain[%d] voltage: %0.2f, now set to: %0.2f\n",
                "driver-btm-soc.c",
                3394,
                (const char *)_FUNCTION___15510,
                chain,
                custom_voltage,
                custom_voltage - v4);
            fclose(pFile_2);
          }
          HIDWORD(v5) = (unsigned __int8)chain;
          v3 = custom_voltage - v4;
          slowly_set_iic_power_to_custom_voltage_by_chain(chain, v5);
        }
        else
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: chain[%d] voltage: %0.2f, now set to: %0.2f\n",
                "driver-btm-soc.c",
                3388,
                (const char *)_FUNCTION___15510,
                chain,
                custom_voltage,
                lower_limit_volta);
            fclose(pFile_1);
          }
          HIDWORD(v5) = (unsigned __int8)chain;
          v3 = lower_limit_volta;
          slowly_set_iic_power_to_custom_voltage_by_chain(chain, v5);
          increased_flaga[chain] = 0;
        }
        if ( custom_voltage - v4 == working_voltage )
          increased_flaga[chain] = 0;
      }
      else if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: chain[%d] is not sanctified with decreasing requirements\n",
            "driver-btm-soc.c",
            3383,
            (const char *)_FUNCTION___15510,
            chain);
        fclose(pFile_0);
      }
    }
  }
}
// 1FD56: variable 'v3' is possibly undefined
// 1FED6: variable 'v4' is possibly undefined
// 1FF70: variable 'v5' is possibly undefined

//----- (00020066) --------------------------------------------------------
void __cdecl volt_increase_for_mode0(
        double upper_limit_volt,
        double delta_volt,
        bool *increased_flag,
        bool *outer_reopen_flag)
{
  double v4; // d0
  double v5; // d1
  int reopen_pwm; // r0
  double v8; // r2
  double upper_limit_volta; // [sp+28h] [bp+10h]
  FILE *pFile; // [sp+30h] [bp+18h]
  FILE *pFile_1; // [sp+34h] [bp+1Ch]
  FILE *pFile_2; // [sp+38h] [bp+20h]
  FILE *pFile_0; // [sp+3Ch] [bp+24h]
  int chain; // [sp+4Ch] [bp+34h]

  upper_limit_volta = v4;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      get_current_voltage_by_chain(chain);
      if ( v4 < upper_limit_volta )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: chain[%d] start reopen core for low temperature voltage increment\n",
              "driver-btm-soc.c",
              3423,
              (const char *)_FUNCTION___15527,
              chain);
          fclose(pFile_0);
        }
        reopen_pwm = get_reopen_pwm();
        re_open_core_by_chain(reopen_pwm, chain, 1);
        sleep(0x1Eu);
        reCalculateAVG();
        recalc_hashrate();
        if ( upper_limit_volta > v4 + v5 )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: chain[%d] voltage: %0.2f, now set to: %0.2f\n",
                "driver-btm-soc.c",
                3436,
                (const char *)_FUNCTION___15527,
                chain,
                v4,
                v4 + v5);
            fclose(pFile_2);
          }
          HIDWORD(v8) = (unsigned __int8)chain;
          v4 = v4 + v5;
          set_higher_voltage_by_chain(chain, v8);
        }
        else
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: chain[%d] voltage: %0.2f, now set to: %0.2f\n",
                "driver-btm-soc.c",
                3431,
                (const char *)_FUNCTION___15527,
                chain,
                v4,
                upper_limit_volta);
            fclose(pFile_1);
          }
          HIDWORD(v8) = (unsigned __int8)chain;
          v4 = upper_limit_volta;
          set_higher_voltage_by_chain(chain, v8);
        }
        slowly_set_iic_power_to_higher_voltage_by_chain(chain);
        *(_BYTE *)(chain + LODWORD(upper_limit_volt)) = 1;
      }
      else
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chain[%d] voltage is high enough, no need to increase voltage\n",
              "driver-btm-soc.c",
              3418,
              (const char *)_FUNCTION___15527,
              chain);
          fclose(pFile);
        }
        *(_BYTE *)HIDWORD(upper_limit_volt) = 1;
      }
    }
  }
}
// 2006C: variable 'v4' is possibly undefined
// 201CC: variable 'v5' is possibly undefined
// 20266: variable 'v8' is possibly undefined

//----- (0002033A) --------------------------------------------------------
void reopen_once()
{
  int reopen_pwm; // r0
  FILE *pFile; // [sp+8h] [bp+0h]
  int chain; // [sp+Ch] [bp+4h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: in normal environment temperature, start reopen for hash rate loss",
        "driver-btm-soc.c",
        3448,
        (const char *)_FUNCTION___15538);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      reopen_pwm = get_reopen_pwm();
      re_open_core_by_chain(reopen_pwm, chain, 0);
      sleep(0x1Eu);
      reCalculateAVG();
      recalc_hashrate();
    }
  }
}

//----- (00020400) --------------------------------------------------------
void __cdecl hash_rate_guard(bool enable, float env_temp, double real_rate, bool high_chip_temp_flag)
{
  float v4; // s0
  double v5; // d1
  double v6; // r0
  double v7; // r2
  double v8; // r0
  double v9; // r0
  double v10; // r2
  bool *increased_flag; // [sp+0h] [bp-20h]
  bool *v12; // [sp+4h] [bp-1Ch]
  char high_chip_temp_flaga; // [sp+2Eh] [bp+Eh]
  FILE *pFile_0; // [sp+30h] [bp+10h]
  FILE *pFile; // [sp+34h] [bp+14h]
  double ideal_rate; // [sp+38h] [bp+18h]

  high_chip_temp_flaga = LOBYTE(env_temp);
  if ( enable )
  {
    if ( is_fixed_mode() )
      ideal_rate = (double)get_ideal_hash_rate_max();
    else
      ideal_rate = (double)get_eeprom_total_hash_rate();
    if ( v5 >= ideal_rate * 0.980000019 )
    {
      LODWORD(v10) = 1;
      outer_reopen_flag_15551 = 1;
      if ( v4 <= 35.0 && v4 > 29.0 || v4 <= 41.0 && v4 > 35.0 || v4 > 41.0 )
      {
        HIDWORD(v10) = &g_sweep_config_hpf;
        LODWORD(v6) = volt_increased_flag_15550;
        volt_decrease_for_mode0(v6, v10, increased_flag);
      }
    }
    else
    {
      if ( high_chip_temp_flaga )
        return;
      HIDWORD(v7) = log_level;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: hash rate guard triggered! env_temp: %0.1f, avg_rate: %0.1f < %0.1f in 30min\n",
            "driver-btm-soc.c",
            3485,
            (const char *)_FUNCTION___15553,
            v4,
            v5,
            ideal_rate * 0.980000019);
        fclose(pFile);
      }
      if ( v4 <= 24.0 || v4 <= 30.0 && v4 > 24.0 )
      {
        HIDWORD(v8) = &outer_reopen_flag_15551;
        LODWORD(v8) = volt_increased_flag_15550;
        volt_increase_for_mode0(v8, v7, increased_flag, v12);
        outer_reopen_flag_15551 = 0;
      }
      else if ( v4 <= 36.0 && v4 > 30.0 || v4 <= 40.0 && v4 > 36.0 )
      {
        HIDWORD(v9) = &outer_reopen_flag_15551;
        LODWORD(v9) = volt_increased_flag_15550;
        volt_increase_for_mode0(v9, v7, increased_flag, v12);
      }
      else if ( v4 > 40.0 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: env temp is above 30, will not increase voltage",
            "driver-btm-soc.c",
            3506,
            (const char *)_FUNCTION___15553);
        fclose(pFile_0);
      }
    }
    if ( v5 < ideal_rate * 0.980000019 && outer_reopen_flag_15551 )
    {
      outer_reopen_flag_15551 = 0;
      reopen_once();
    }
  }
}
// 20476: variable 'v5' is possibly undefined
// 204E2: variable 'v4' is possibly undefined
// 2053A: variable 'v7' is possibly undefined
// 2053A: variable 'increased_flag' is possibly undefined
// 2053A: variable 'v12' is possibly undefined
// 2076E: variable 'v6' is possibly undefined

//----- (000207F0) --------------------------------------------------------
void __cdecl decrease_voltage_at_high_temp(bool *high_chip_temp_flag)
{
  double v1; // d0
  double v2; // r2
  double v3; // r2
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile; // [sp+14h] [bp+Ch]
  uint8_t chain; // [sp+1Fh] [bp+17h]
  uint8_t chaina; // [sp+1Fh] [bp+17h]
  uint8_t chainb; // [sp+1Fh] [bp+17h]

  for ( chain = 0; chain <= 0xFu; ++chain )
  {
    if ( dev->chain_exist[chain] && g_minor_type[chain] != PKG_B_BGM )
      return;
  }
  if ( dev->fan_pwm == 100 && last_testpatten_highest_chip_temp > 92 && !working_volt_decreased_flag_15559 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: decrease volt for max chip temp is %d\n",
          "driver-btm-soc.c",
          3551,
          (const char *)_FUNCTION___15566,
          last_testpatten_highest_chip_temp);
      fclose(pFile);
    }
    for ( chaina = 0; chaina <= 0xFu; ++chaina )
    {
      if ( dev->chain_exist[chaina] )
      {
        get_working_voltage_by_chain(chaina);
        HIDWORD(v2) = chaina;
        v1 = v1 - 0.2;
        set_working_voltage_by_chain(chaina, v2);
      }
    }
    slowly_set_iic_power_voltage_t11(1);
    working_volt_decreased_flag_15559 = 1;
  }
  else if ( last_testpatten_highest_chip_temp <= 86 && working_volt_decreased_flag_15559 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: increase volt for max chip temp is %d\n",
          "driver-btm-soc.c",
          3563,
          (const char *)_FUNCTION___15566,
          last_testpatten_highest_chip_temp);
      fclose(pFile_0);
    }
    for ( chainb = 0; chainb <= 0xFu; ++chainb )
    {
      if ( dev->chain_exist[chainb] )
      {
        get_working_voltage_by_chain(chainb);
        HIDWORD(v3) = chainb;
        v1 = v1 + 0.2;
        set_working_voltage_by_chain(chainb, v3);
      }
    }
    slowly_set_iic_power_voltage_t11(1);
    working_volt_decreased_flag_15559 = 0;
  }
  *high_chip_temp_flag = working_volt_decreased_flag_15559;
}
// 20924: variable 'v1' is possibly undefined
// 2092A: variable 'v2' is possibly undefined
// 20A1C: variable 'v3' is possibly undefined

//----- (00020A68) --------------------------------------------------------
void __noreturn check_system_work()
{
  double v0; // d0
  int reopen_pwm; // r0
  int v2; // r0
  int min_temperature; // r4
  int max_temperature; // r5
  int min_chip_temperature; // r6
  int max_chip_temperature; // r0
  double v7; // r2
  bool v8; // [sp+0h] [bp-20h]
  bool high_chip_temp_flag; // [sp+27h] [bp+7h] BYREF
  timeval tv_diff; // [sp+28h] [bp+8h]
  timeval tv_end; // [sp+30h] [bp+10h] BYREF
  timeval tv_start; // [sp+38h] [bp+18h] BYREF
  FILE *pFile_3; // [sp+40h] [bp+20h]
  FILE *pFile_2; // [sp+44h] [bp+24h]
  FILE *pFile_1; // [sp+48h] [bp+28h]
  FILE *pFile_0; // [sp+4Ch] [bp+2Ch]
  FILE *pFile; // [sp+50h] [bp+30h]
  float env_temp; // [sp+54h] [bp+34h]
  double latest_avg_rate; // [sp+58h] [bp+38h]
  unsigned __int8 *hash_log; // [sp+64h] [bp+44h]
  uint32_t counter_base; // [sp+68h] [bp+48h]
  uint32_t counter; // [sp+6Ch] [bp+4Ch]

  hash_log = "/var/log/hash_rate";
  counter = 0;
  counter_base = 540;
  latest_avg_rate = 0.0;
  env_temp = 0.0;
  high_chip_temp_flag = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: check system thread start...\n",
        "driver-btm-soc.c",
        3585,
        (const char *)_FUNCTION___15588);
    fclose(pFile);
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        ++counter;
        cgtime(&tv_start);
        set_led();
        if ( !doTestPatten )
          break;
        cgsleep_ms(100);
      }
      if ( get_error_type() == STATUS_OK )
        break;
      counter = 0;
      cgsleep_ms(1000);
      reCalculateAVG();
    }
    if ( counter == 10 && (unsigned __int8)is_T11() != 1 )
      disable_crab_circuit();
    if ( counter == 300 )
    {
      if ( need_mode2_startup() )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: mode0 startup failed, reopen for mode 2 startup\n",
              "driver-btm-soc.c",
              3625,
              (const char *)_FUNCTION___15588);
          fclose(pFile_0);
        }
        g_pulse_mode = 1;
        g_is_mode2_startup = 1;
        reopen_pwm = get_reopen_pwm();
        re_open_core(reopen_pwm);
        reCalculateAVG();
      }
      else
      {
        g_is_mode2_startup = 0;
        counter_base = counter;
      }
    }
    if ( counter == 420 && g_is_mode2_startup )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: reopen for mode 2 startup again\n",
            "driver-btm-soc.c",
            3642,
            (const char *)_FUNCTION___15588);
        fclose(pFile_1);
      }
      v2 = get_reopen_pwm();
      re_open_core(v2);
      reCalculateAVG();
    }
    if ( counter == 540 && g_is_mode2_startup )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: mode 2 startup finished, switch to mode 0\n",
            "driver-btm-soc.c",
            3651,
            (const char *)_FUNCTION___15588);
        fclose(pFile_2);
      }
      switch_to_mode0();
      g_is_mode2_startup = 0;
      reCalculateAVG();
      counter_base = counter;
    }
    if ( counter > counter_base && !((counter - counter_base) % 0x78) )
      decrease_voltage_at_high_temp(&high_chip_temp_flag);
    if ( !(counter % 5) )
      process_test();
    if ( !(counter % 0x78) )
    {
      if ( !(counter % 0xE10) )
      {
        copy_log_to_latest(hash_log);
        clear_log(hash_log);
      }
      dump_nonce_info_all_domain();
      dump_nonce_info_all_asic();
    }
    if ( counter - counter_base == 180 )
      save_base_domain_nonce_data();
    if ( !(counter % 0x708) )
    {
      get_30minutes_hashrate();
      latest_avg_rate = v0;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
        {
          min_temperature = get_min_temperature();
          max_temperature = get_max_temperature();
          min_chip_temperature = get_min_chip_temperature();
          max_chip_temperature = get_max_chip_temperature();
          fprintf(
            pFile_3,
            "%s:%d:%s: 30 mins avg rate [%05.0f], PCB temp [%d - %d], CHIP temp [%d - %d]\n",
            "driver-btm-soc.c",
            3695,
            (const char *)_FUNCTION___15588,
            latest_avg_rate,
            min_temperature,
            max_temperature,
            min_chip_temperature,
            max_chip_temperature);
        }
        fclose(pFile_3);
      }
    }
    if ( aging_is_ongoing() )
    {
      if ( (int)aging_get_time() < 7200 )
      {
        if ( !(counter % 0x3C) )
          aging_update_time(60);
      }
      else
      {
        aging_stop();
      }
    }
    if ( !(counter % 0x3C) )
      check_asic_status();
    if ( counter > counter_base && !((counter - counter_base) % 0x708) )
    {
      get_30minutes_hashrate();
      latest_avg_rate = v0;
      get_env_temperature();
      env_temp = *(float *)&v0;
      HIDWORD(v7) = high_chip_temp_flag;
      hash_rate_guard(1, COERCE_FLOAT(high_chip_temp_flag), v7, v8);
    }
    cgtime(&tv_end);
    tv_diff.tv_sec = tv_end.tv_sec - tv_start.tv_sec;
    tv_diff.tv_usec = tv_end.tv_usec - tv_start.tv_usec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --tv_diff.tv_sec;
      tv_diff.tv_usec += 1000000;
    }
    if ( tv_diff.tv_sec <= 0 )
      cgsleep_us(1000000 - tv_diff.tv_usec);
  }
}
// 20E12: variable 'v0' is possibly undefined
// 20F52: variable 'v7' is possibly undefined
// 20F52: variable 'v8' is possibly undefined

//----- (00020FAA) --------------------------------------------------------
void __cdecl pre_open_core_one_chain(uint8_t num, const uint8_t chain)
{
  unsigned int buf_vil_tw[13]; // [sp+18h] [bp+8h] BYREF
  FILE *pFile; // [sp+4Ch] [bp+3Ch]
  FILE *pFile_0; // [sp+50h] [bp+40h]
  FILE *pFile_1; // [sp+54h] [bp+44h]
  uint32_t work_fifo_ready; // [sp+58h] [bp+48h]
  uint32_t loop; // [sp+5Ch] [bp+4Ch]

  work_fifo_ready = 0;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  if ( dev->chain_exist[chain] == 1 )
  {
    for ( loop = 0; loop < num; ++loop )
    {
      enable_core_clock_BM1393(loop, 1u, chain);
      enable_core_clock_BM1393(loop + 52, 1u, chain);
      enable_core_clock_BM1393(loop + 104, 1u, chain);
      enable_core_clock_BM1393(loop - 100, 1u, chain);
      buf_vil_tw[0] = (chain << 16) | 0x1000080;
      while ( 1 )
      {
        work_fifo_ready = get_buffer_space();
        if ( (work_fifo_ready & (1 << chain)) != 0 )
          break;
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chain%d work fifo not ready: 0x%x\n",
              "driver-btm-soc.c",
              3760,
              (const char *)_FUNCTION___15604,
              chain,
              work_fifo_ready);
          fclose(pFile);
        }
        usleep(0x3E8u);
      }
      set_TW_write_command_vil(buf_vil_tw);
      usleep(0x4E20u);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: for chain %d\n", "driver-btm-soc.c", 3768, (const char *)_FUNCTION___15604, chain);
      fclose(pFile_0);
    }
  }
  else if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: filed on chain %d,do not exist!!\n",
        "driver-btm-soc.c",
        3772,
        (const char *)_FUNCTION___15604,
        chain);
    fclose(pFile_1);
  }
}

//----- (000211DC) --------------------------------------------------------
bool __cdecl check_asic_num_without_power_off(int chain, unsigned __int8 set)
{
  double v2; // d0
  unsigned int crc_count; // r0
  FILE *pFile_2; // [sp+1Ch] [bp+Ch]
  FILE *pFile_1; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]
  FILE *pFile; // [sp+28h] [bp+18h]

  hash_board_reset(chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Open %d core for chain %d\n",
        "driver-btm-soc.c",
        3783,
        (const char *)_FUNCTION___15617,
        5,
        chain);
    fclose(pFile);
  }
  open_core_BM1393_pre_open(chain, 5u, set);
  check_asic_reg_oneChain(chain, 0, 0);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: chain %d, find asic num = %d\n",
        "driver-btm-soc.c",
        3789,
        (const char *)_FUNCTION___15617,
        chain,
        dev->chain_asic_num[chain]);
    fclose(pFile_0);
  }
  if ( (unsigned __int8)is_T11() != 1 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
      {
        get_average_voltage();
        fprintf(
          pFile_1,
          "%s:%d:%s: the current avg vol is %5.2f\n",
          "driver-btm-soc.c",
          3792,
          (const char *)_FUNCTION___15617,
          v2);
      }
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
      {
        crc_count = get_crc_count();
        fprintf(pFile_2, "%s:%d:%s: crc = %d\n", "driver-btm-soc.c", 3793, (const char *)_FUNCTION___15617, crc_count);
      }
      fclose(pFile_2);
    }
  }
  return dev->chain_asic_num[chain] == 60;
}
// 2137E: variable 'v2' is possibly undefined

//----- (00021422) --------------------------------------------------------
bool __cdecl check_asic_num_by_pre_open_core(int chain)
{
  double v1; // d0
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  FILE *pFile; // [sp+20h] [bp+10h]
  int i; // [sp+28h] [bp+18h]
  bool ret; // [sp+2Fh] [bp+1Fh]

  ret = 0;
  for ( i = 0; i < 2; ++i )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Try to find asic by pre core: times %d\n",
          "driver-btm-soc.c",
          3815,
          (const char *)_FUNCTION___15628,
          i);
      fclose(pFile);
    }
    ret = check_asic_num_without_power_off(chain, 0);
    if ( ret )
      break;
    if ( (unsigned __int8)is_T11() != 1 && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
      {
        get_average_voltage();
        fprintf(
          pFile_0,
          "%s:%d:%s: the current avg vol is %5.2f\n",
          "driver-btm-soc.c",
          3827,
          (const char *)_FUNCTION___15628,
          v1);
      }
      fclose(pFile_0);
    }
  }
  return ret;
}
// 21534: variable 'v1' is possibly undefined

//----- (0002155C) --------------------------------------------------------
int __cdecl check_asic_num(int chain)
{
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  FILE *pFile_1; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]
  int i_0; // [sp+28h] [bp+18h]
  int i; // [sp+2Ch] [bp+1Ch]

  ++find_asic_with_count;
  for ( i = 0; i <= 1; ++i )
  {
    check_asic_reg_oneChain(chain, 0, 0);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: without pre_open_core chain %d, find asic num = %d\n",
          "driver-btm-soc.c",
          3842,
          (const char *)_FUNCTION___15638,
          chain,
          dev->chain_asic_num[chain]);
      fclose(pFile);
    }
    if ( dev->chain_asic_num[chain] == 60 )
      return 0;
    hash_board_reset(chain);
  }
  ++find_asic_with_pre_open_core_count;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: check asic num with pre_open_core\n",
        "driver-btm-soc.c",
        3850,
        (const char *)_FUNCTION___15638);
    fclose(pFile_0);
  }
  if ( check_asic_num_by_pre_open_core(chain) )
    return 0;
  disable_pic_dac(chain);
  if ( (is_force_mode() || is_fixed_mode()) && !is_re_open_core_now() )
  {
    for ( i_0 = 0; i_0 <= 15; ++i_0 )
    {
      if ( dev->chain_exist[i_0] == 1 )
        disable_pic_dac(i_0);
    }
    freq_scan_error_code_set(1, chain);
  }
  else
  {
    dev->chain_exist[chain] = 0;
    --dev->chain_num;
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: chian %d check asic number failed! \n",
        "driver-btm-soc.c",
        3872,
        (const char *)_FUNCTION___15638,
        chain);
    fclose(pFile_1);
  }
  return -1;
}

//----- (000217F4) --------------------------------------------------------
void __cdecl open_core_BM1393_pre_open(int chain, unsigned __int8 num, unsigned __int8 set)
{
  int dhash_acc_control; // r0
  int v4; // r0
  FILE *pFile; // [sp+10h] [bp+8h]
  unsigned __int8 i; // [sp+17h] [bp+Fh]

  if ( set )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control((opt_multi_version << 8) & 0xF00 | dhash_acc_control & 0xFFFF7FDF | 0x8000);
    set_hash_counting_number(0);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: pre open core = %d\n", "driver-btm-soc.c", 3888, (const char *)_FUNCTION___15656, num);
    fclose(pFile);
  }
  if ( chain == All_Chain )
  {
    for ( i = 0; i <= 0xFu; ++i )
    {
      if ( dev->chain_exist[i] == 1 )
        pre_open_core_one_chain(num, i);
    }
  }
  else
  {
    pre_open_core_one_chain(num, chain);
  }
  if ( set )
  {
    v4 = get_dhash_acc_control();
    set_dhash_acc_control((opt_multi_version << 8) & 0xF00 | v4 | 0x8000);
  }
}

//----- (0002192E) --------------------------------------------------------
void __cdecl set_clock_delay_control(const uint8_t chain, uint8_t pulse_mode)
{
  core_cmd core; // [sp+10h] [bp+8h] BYREF
  FILE *pFile_2; // [sp+1Ch] [bp+14h]
  FILE *pFile_1; // [sp+20h] [bp+18h]
  FILE *pFile; // [sp+24h] [bp+1Ch]
  FILE *pFile_0; // [sp+28h] [bp+20h]
  uint8_t core_data; // [sp+2Eh] [bp+26h]
  uint8_t i; // [sp+2Fh] [bp+27h]

  i = 0;
  core_data = 0;
  memset(&core, 0, sizeof(core));
  if ( pulse_mode )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: set mode 2\n", "driver-btm-soc.c", 3924, (const char *)_FUNCTION___15668);
      fclose(pFile_0);
    }
    g_Clock_delay_control |= 2u;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: set mode 0\n", "driver-btm-soc.c", 3919, (const char *)_FUNCTION___15668);
      fclose(pFile);
    }
    g_Clock_delay_control &= ~2u;
  }
  g_Clock_delay_control |= 4u;
  core_data = g_Clock_delay_control;
  core.chip_addr = 0;
  core.mode = 1;
  core.core_mode = 1;
  core.core_id = 0;
  core.cmd_type = 0;
  core.reg_data = g_Clock_delay_control;
  core.rw_falg = 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: core_data = 0x%02x\n",
        "driver-btm-soc.c",
        3938,
        (const char *)_FUNCTION___15668,
        core_data);
    fclose(pFile_1);
  }
  if ( chain != All_Chain )
    i = chain;
  while ( i <= 0xFu )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( dev->chain_asic_num[i] )
      {
        core.chain = i;
        set_core_cmd_BM1393(&core);
        if ( chain != All_Chain )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: single chain mode\n",
                "driver-btm-soc.c",
                3952,
                (const char *)_FUNCTION___15668);
            fclose(pFile_2);
          }
          return;
        }
      }
    }
    ++i;
  }
}

//----- (00021C12) --------------------------------------------------------
void __cdecl open_core_bm1393(bool set, uint8_t chain_mode)
{
  int dhash_acc_control; // r0
  int v3; // r0
  unsigned int buf_vil_tw[13]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile_1; // [sp+50h] [bp+40h]
  FILE *pFile_0; // [sp+54h] [bp+44h]
  FILE *pFile; // [sp+58h] [bp+48h]
  int core_index; // [sp+5Ch] [bp+4Ch]
  unsigned int work_fifo_ready; // [sp+60h] [bp+50h]
  int slot; // [sp+64h] [bp+54h]
  int core_id; // [sp+68h] [bp+58h]
  unsigned int i; // [sp+6Ch] [bp+5Ch]

  i = 0;
  work_fifo_ready = 0;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  core_id = 0;
  slot = 0;
  core_index = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Start Open Core!!\n", "driver-btm-soc.c", 4009, (const char *)_FUNCTION___15700);
    fclose(pFile);
  }
  if ( opt_multi_version )
  {
    if ( set )
    {
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control((opt_multi_version << 8) & 0xF00 | dhash_acc_control & 0xFFFF7FDF | 0x8000);
      set_hash_counting_number(0);
    }
    for ( core_id = 0; core_id <= 51; ++core_id )
    {
      for ( i = 0; i <= 0xF; ++i )
      {
        if ( (chain_mode == All_Chain || i == chain_mode) && dev->chain_exist[i] == 1 )
        {
          buf_vil_tw[0] = (i << 16) | 0x1000080;
          for ( slot = 0; slot <= 3; ++slot )
          {
            core_index = 52 * slot + core_id;
            enable_core_clock_BM1393(52 * slot + core_id, 1u, i);
          }
          cgsleep_ms(5);
          if ( set )
          {
            while ( 1 )
            {
              work_fifo_ready = get_buffer_space();
              if ( (work_fifo_ready & (1 << i)) != 0 )
                break;
              if ( log_level > 3 )
              {
                print_crt_time_to_file(log_file, 3u);
                pFile_0 = fopen((const char *)log_file, "a+");
                if ( pFile_0 )
                  fprintf(
                    pFile_0,
                    "%s:%d:%s: chain%d work fifo not ready: 0x%x\n",
                    "driver-btm-soc.c",
                    4056,
                    (const char *)_FUNCTION___15700,
                    i,
                    work_fifo_ready);
                fclose(pFile_0);
              }
              usleep(0x3E8u);
            }
            set_TW_write_command_vil(buf_vil_tw);
            cgsleep_ms(10);
          }
        }
      }
    }
    if ( set )
    {
      v3 = get_dhash_acc_control();
      set_dhash_acc_control((opt_multi_version << 8) & 0xF00 | v3 | 0x8000);
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: End Open Core!!\n", "driver-btm-soc.c", 4076, (const char *)_FUNCTION___15700);
    fclose(pFile_1);
  }
}

//----- (00021EDC) --------------------------------------------------------
int __cdecl check_hw(SCAN_FREQ_WORK *work, unsigned int nonce, bool print)
{
  sha2_context ctx; // [sp+14h] [bp+14h] BYREF
  unsigned int nonce_temp; // [sp+FCh] [bp+FCh]
  unsigned __int8 hash2[32]; // [sp+100h] [bp+100h] BYREF
  unsigned __int8 hash1[32]; // [sp+120h] [bp+120h] BYREF
  uint32_t *hash2_32; // [sp+140h] [bp+140h]
  unsigned int m; // [sp+144h] [bp+144h]

  m = 0;
  memset(hash1, 0, sizeof(hash1));
  memset(hash2, 0, sizeof(hash2));
  hash2_32 = (uint32_t *)hash1;
  nonce_temp = (nonce << 24) | HIBYTE(nonce) | (nonce >> 8) & 0xFF00 | (nonce << 8) & 0xFF0000;
  if ( !work )
    return 0;
  memcpy(ctx.state, work->midstate, sizeof(ctx.state));
  rev((unsigned __int8 *)ctx.state, 0x20u);
  ctx.total[0] = 80;
  ctx.total[1] = 0;
  memcpy(hash1, work->data, 0xCu);
  rev(hash1, 0xCu);
  flip_swab(ctx.buffer, hash1, 0xCu);
  *(_DWORD *)hash1 = nonce_temp;
  rev(hash1, 4u);
  flip_swab(&ctx.buffer[12], hash1, 4u);
  sha2_finish(&ctx, hash1);
  memset(&ctx, 0, sizeof(ctx));
  sha2(hash1, 32, hash2);
  flip32(hash1, hash2);
  if ( !hash2_32[7] )
    return 0;
  if ( print )
  {
    printf("\n%s: Got a HW!\n", (const char *)_FUNCTION___15726);
    printf("hash1=0x");
    for ( m = 0; m <= 0x1F; ++m )
      printf("%02x", hash1[m]);
    putchar(10);
    printf("midstate=0x");
    for ( m = 0; m <= 0x1F; ++m )
      printf("%02x", work->midstate[m]);
    printf("\tdata2=0x");
    for ( m = 0; m <= 0xB; ++m )
      printf("%02x", work->data[m]);
    printf("\treturn nonce=0x%08x, but it should be nonce=0x%08x\n", nonce, work->nonce);
  }
  return 1;
}

//----- (0002214E) --------------------------------------------------------
void __cdecl nonce_calc(int chain, unsigned int buf)
{
  FILE *pFile_0; // [sp+18h] [bp+8h]
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  unsigned int whose_nonce; // [sp+20h] [bp+10h]
  unsigned int which_core_nonce; // [sp+24h] [bp+14h]

  which_core_nonce = (unsigned __int8)buf;
  whose_nonce = HIBYTE(buf) / dev->addrInterval;
  if ( chain <= 15 && whose_nonce <= 0x3B && (unsigned __int8)buf <= 0xCFu && buf )
  {
    ++calc_nonce_info.chain_asic_core_nonce_num[chain][whose_nonce][(unsigned __int8)buf];
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: buf [%x] is error!\n", "driver-btm-soc.c", 4176, (const char *)_FUNCTION___15752, buf);
      fclose(pFile);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain = %d,chip = %d,core = %d\n",
          "driver-btm-soc.c",
          4177,
          (const char *)_FUNCTION___15752,
          chain,
          whose_nonce,
          which_core_nonce);
      fclose(pFile_0);
    }
  }
}

//----- (000222DA) --------------------------------------------------------
void __noreturn get_nonce_and_register()
{
  int nonce_fifo_interrupt; // r0
  __int16 nonce_number_in_fifo; // r0
  uint32_t v2; // r6
  uint32_t *p_work_id; // r3
  unsigned int buf[2]; // [sp+8h] [bp+0h] BYREF
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile_1; // [sp+14h] [bp+Ch]
  FILE *pFile_2; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]
  uint64_t n2l; // [sp+20h] [bp+18h]
  uint64_t n2h; // [sp+28h] [bp+20h]
  unsigned int read_loop; // [sp+30h] [bp+28h]
  unsigned int nonce_number; // [sp+34h] [bp+2Ch]
  unsigned int *data_addr; // [sp+38h] [bp+30h]
  unsigned int work_id; // [sp+3Ch] [bp+34h]
  unsigned int m; // [sp+40h] [bp+38h]
  unsigned int j; // [sp+44h] [bp+3Ch]

  work_id = 0;
  data_addr = 0;
  j = 0;
  m = 0;
  nonce_number = 0;
  read_loop = 0;
  buf[0] = 0;
  buf[1] = 0;
  n2h = 0LL;
  n2l = 0LL;
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        cgsleep_ms(1);
        if ( !doTestPatten )
          break;
        cgsleep_ms(100);
      }
      read_loop = 0;
      nonce_number_in_fifo = get_nonce_number_in_fifo();
      nonce_number = nonce_number_in_fifo & 0x1FF;
    }
    while ( (nonce_number_in_fifo & 0x1FF) == 0 );
    read_loop = nonce_number;
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: read_loop = %d\n",
          "driver-btm-soc.c",
          4207,
          (const char *)_FUNCTION___15767,
          read_loop);
      fclose(pFile);
    }
    for ( j = 0; j < read_loop; ++j )
    {
      get_return_nonce(buf);
      if ( (buf[0] & 0x80000000) == 0 )
      {
        if ( reg_value_buf.reg_value_num > 0x1FE )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: reg_value_buf buffer is full!\n",
                "driver-btm-soc.c",
                4311,
                (const char *)_FUNCTION___15767);
            fclose(pFile_2);
          }
        }
        else if ( (buf[0] & 0x40) != 0 )
        {
          if ( log_level > 4 )
          {
            print_crt_time_to_file(log_file, 4u);
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "%s:%d:%s: !!! reg crc error\n",
                "driver-btm-soc.c",
                4284,
                (const char *)_FUNCTION___15767);
            fclose(pFile_0);
          }
        }
        else
        {
          pthread_mutex_lock(&reg_mutex);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = buf[1];
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = HIBYTE(buf[0]) & 0x1F;
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].chip_address = BYTE2(buf[0]);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_address = BYTE1(buf[0]);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = buf[0] & 0xF;
          if ( ((buf[0] >> 29) & 3) != 0 && log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: !!! REG_TYPE = 1\n",
                "driver-btm-soc.c",
                4295,
                (const char *)_FUNCTION___15767);
            fclose(pFile_1);
          }
          if ( is_reading_core_reg
            || !is_reading_core_reg && reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_address != 64 )
          {
            ++reg_value_buf.p_wr;
            ++reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_wr > 0x1FE )
              reg_value_buf.p_wr = 0;
          }
          pthread_mutex_unlock(&reg_mutex);
        }
      }
      else if ( gBegin_get_nonce && (buf[0] & 0x80) != 0 )
      {
        pthread_mutex_lock(&nonce_mutex);
        work_id = HIWORD(buf[0]) & 0x7FFF;
        data_addr = &nonce2_jobid_address[16 * work_id];
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].work_id = work_id;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].nonce3 = buf[1];
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].chain_num = buf[0] & 0xF;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].job_id = *data_addr;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].header_version = data_addr[1];
        n2h = data_addr[3];
        n2l = data_addr[2];
        v2 = n2h;
        p_work_id = &nonce_read_out.nonce_buffer[nonce_read_out.p_wr].work_id;
        p_work_id[2] = n2l;
        p_work_id[3] = v2;
        for ( m = 0; m <= 0x1F; ++m )
          nonce_read_out.nonce_buffer[nonce_read_out.p_wr].midstate[m] = *((_BYTE *)data_addr + m + 32);
        if ( nonce_read_out.p_wr >= 0x1FE )
          nonce_read_out.p_wr = 0;
        else
          ++nonce_read_out.p_wr;
        if ( nonce_read_out.nonce_num > 0x1FE )
          nonce_read_out.nonce_num = 511;
        else
          ++nonce_read_out.nonce_num;
        nonce_calc(
          nonce_read_out.nonce_buffer[nonce_read_out.p_wr].chain_num,
          nonce_read_out.nonce_buffer[nonce_read_out.p_wr].nonce3);
        pthread_mutex_unlock(&nonce_mutex);
      }
    }
  }
}

//----- (0002290A) --------------------------------------------------------
void dump_nonce_info_all_asic()
{
  FILE *pFile_2; // [sp+4h] [bp+4h]
  FILE *pFile_1; // [sp+8h] [bp+8h]
  FILE *pFile_5; // [sp+Ch] [bp+Ch]
  FILE *pFile_4; // [sp+10h] [bp+10h]
  FILE *pFile_3; // [sp+14h] [bp+14h]
  FILE *pFile_0; // [sp+18h] [bp+18h]
  FILE *pFile_7; // [sp+1Ch] [bp+1Ch]
  FILE *pFile_6; // [sp+20h] [bp+20h]
  FILE *pFile; // [sp+24h] [bp+24h]
  uint32_t total_nonce_num; // [sp+2Ch] [bp+2Ch]
  int inbalance_asic_num_all_chain; // [sp+30h] [bp+30h]
  int inbalance_asic_num_single_chain; // [sp+34h] [bp+34h]
  uint32_t nounc_num; // [sp+38h] [bp+38h]
  int core_id; // [sp+3Ch] [bp+3Ch]
  int chip_id; // [sp+40h] [bp+40h]
  int chain_id; // [sp+44h] [bp+44h]

  inbalance_asic_num_all_chain = 0;
  if ( log_level > 3 )
  {
    pFile = fopen("/var/log/hash_rate", "a+");
    if ( pFile )
      fwrite("\n dump asic nonce number...\n", 1u, 0x1Cu, pFile);
    fclose(pFile);
  }
  for ( chain_id = 0; chain_id <= 15; ++chain_id )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      inbalance_asic_num_single_chain = 0;
      if ( log_level > 3 )
      {
        pFile_0 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "Chain[%d]:\n", chain_id);
        fclose(pFile_0);
      }
      total_nonce_num = 0;
      for ( chip_id = 0; chip_id <= 59; ++chip_id )
      {
        nounc_num = 0;
        for ( core_id = 0; core_id <= 207; ++core_id )
          nounc_num += calc_nonce_info.chain_asic_core_nonce_num[chain_id][chip_id][core_id];
        if ( log_level > 3 )
        {
          pFile_1 = fopen("/var/log/hash_rate", "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "ic[%03d]=%-10d", chip_id, nounc_num);
          fclose(pFile_1);
        }
        if ( nounc_num == nonce_at_asic_15813[chain_id][chip_id] )
        {
          ++inbalance_asic_num_single_chain;
          ++inbalance_asic_num_all_chain;
        }
        nonce_at_asic_15813[chain_id][chip_id] = nounc_num;
        total_nonce_num += nounc_num;
        if ( !((chip_id + 1) % 10) && log_level > 3 )
        {
          pFile_2 = fopen("/var/log/hash_rate", "a+");
          if ( pFile_2 )
            fputc(10, pFile_2);
          fclose(pFile_2);
        }
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_3 )
          fprintf(pFile_3, "Chain[%d] total nonce number = %d\n", chain_id, total_nonce_num);
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_4 )
          fprintf(pFile_4, "Chain[%d] inbalance asic number: %d\n", chain_id, inbalance_asic_num_single_chain);
        fclose(pFile_4);
      }
      if ( log_level > 3 )
      {
        pFile_5 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_5 )
          fputc(10, pFile_5);
        fclose(pFile_5);
      }
    }
  }
  if ( log_level > 3 )
  {
    pFile_6 = fopen("/var/log/hash_rate", "a+");
    if ( pFile_6 )
      fprintf(pFile_6, "inbalance asic number of all chain: %d\n", inbalance_asic_num_all_chain);
    fclose(pFile_6);
  }
  if ( log_level > 3 )
  {
    pFile_7 = fopen("/var/log/hash_rate", "a+");
    if ( pFile_7 )
      fputc(10, pFile_7);
    fclose(pFile_7);
  }
}

//----- (00022C3C) --------------------------------------------------------
void set_unused_pll()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int chain; // [sp+Ch] [bp+4h]

  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set unused pll enter\n", "driver-btm-soc.c", 4423, (const char *)_FUNCTION___15841);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      set_config_BM1393_t(chain, 0, 1u, 0x74u, 0xF0F0F0Fu);
      set_config_BM1393_t(chain, 0, 1u, 0x60u, 0x80103F77);
      set_config_BM1393_t(chain, 0, 1u, 0x74u, 0xF0F0F0Fu);
      set_config_BM1393_t(chain, 0, 1u, 0x60u, 0x80103F77);
      set_config_BM1393_t(chain, 0, 1u, 0x78u, 0xF0F0F0Fu);
      set_config_BM1393_t(chain, 0, 1u, 0x64u, 0x80103F77);
      set_config_BM1393_t(chain, 0, 1u, 0x78u, 0xF0F0F0Fu);
      set_config_BM1393_t(chain, 0, 1u, 0x64u, 0x80103F77);
      set_config_BM1393_t(chain, 0, 1u, 0x7Cu, 0xF0F0F0Fu);
      set_config_BM1393_t(chain, 0, 1u, 0x68u, 0x80103F77);
      set_config_BM1393_t(chain, 0, 1u, 0x7Cu, 0xF0F0F0Fu);
      set_config_BM1393_t(chain, 0, 1u, 0x68u, 0x80103F77);
    }
  }
}

//----- (00022DEC) --------------------------------------------------------
int __cdecl change_high_pll_test(uint8_t chain, float freq, int index)
{
  float v3; // s0
  uint8_t divider; // [sp+2Fh] [bp+17h] BYREF
  float pll_freq; // [sp+30h] [bp+18h] BYREF
  uint32_t vil_pll_t; // [sp+34h] [bp+1Ch] BYREF
  uint8_t vil_pll[4]; // [sp+38h] [bp+20h] BYREF
  FILE *pFile_1; // [sp+3Ch] [bp+24h]
  FILE *pFile_0; // [sp+40h] [bp+28h]
  FILE *pFile; // [sp+44h] [bp+2Ch]
  uint32_t pll_index; // [sp+48h] [bp+30h]
  uint32_t pll; // [sp+4Ch] [bp+34h]

  divider = freq_high_pll_1393[LODWORD(freq)].divider;
  pll = freq_high_pll_1393[LODWORD(freq)].pll_out;
  pll_index = 0;
  if ( is_user_mode() )
  {
    get_max_freq();
    if ( !check_freq_valid_single((unsigned int)v3, (unsigned int)v3) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
        {
          get_max_freq();
          fprintf(
            pFile,
            "%s:%d:%s: User Mode: chain[%d] base freq %f over the max freq %f \n",
            "driver-btm-soc.c",
            4496,
            (const char *)_FUNCTION___15871,
            chain,
            v3,
            v3);
        }
        fclose(pFile);
      }
LABEL_7:
      disable_pic_dac(chain);
      dev->chain_exist[chain] = 0;
      --dev->chain_num;
      return -1;
    }
  }
  if ( is_force_mode() )
  {
    get_max_scanfreq(0);
    if ( !check_freq_valid_single((unsigned int)v3, (unsigned int)v3) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          get_max_scanfreq(0);
          fprintf(
            pFile_0,
            "%s:%d:%s: Force Mode: chain[%d] base freq %f over the max freq %f \n",
            "driver-btm-soc.c",
            4508,
            (const char *)_FUNCTION___15871,
            chain,
            v3,
            v3);
        }
        fclose(pFile_0);
      }
      goto LABEL_7;
    }
  }
  if ( opt_use_pll_list )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: set freq %d, pll_out %d\n",
          "driver-btm-soc.c",
          4518,
          (const char *)_FUNCTION___15871,
          freq_high_pll_1393[LODWORD(freq)].freq,
          pll);
      fclose(pFile_1);
    }
    pll_index = get_index_from_pll_B1393(pll);
    get_plldata_from_index(pll_index, vil_pll);
  }
  else
  {
    get_pllparam_divider(COERCE_FLOAT(&vil_pll_t), (uint32_t *)&divider, (uint8_t *)&pll_freq, (float *)&vil_pll_t);
    *(_DWORD *)vil_pll = _bswap_32(vil_pll_t);
  }
  set_config_BM1393_t(chain, 0, 1u, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1393_t(chain, 0, 1u, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_config_BM1393_t(chain, 0, 1u, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1393_t(chain, 0, 1u, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_unused_pll();
  return 0;
}
// 22E46: variable 'v3' is possibly undefined

//----- (000231B0) --------------------------------------------------------
void __cdecl change_high_pll_by_aisc(uint32_t chain, uint32_t asic, float freq, int index)
{
  float v4; // s0
  uint8_t divider; // [sp+33h] [bp+13h] BYREF
  float pll_freq; // [sp+34h] [bp+14h] BYREF
  uint32_t vil_pll_t; // [sp+38h] [bp+18h] BYREF
  uint8_t vil_pll[4]; // [sp+3Ch] [bp+1Ch] BYREF
  FILE *pFile_1; // [sp+40h] [bp+20h]
  FILE *pFile_0; // [sp+44h] [bp+24h]
  FILE *pFile; // [sp+48h] [bp+28h]
  uint32_t chip_addr; // [sp+4Ch] [bp+2Ch]
  uint32_t pll_index; // [sp+50h] [bp+30h]
  uint32_t pll; // [sp+54h] [bp+34h]

  divider = freq_high_pll_1393[LODWORD(freq)].divider;
  pll = freq_high_pll_1393[LODWORD(freq)].pll_out;
  pll_index = 0;
  chip_addr = 4 * asic;
  if ( is_user_mode() )
  {
    get_max_freq();
    if ( !check_freq_valid_single((unsigned int)v4, (unsigned int)v4) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
        {
          get_max_freq();
          fprintf(
            pFile,
            "%s:%d:%s: User Mode: chain[%d] asic[%d] freq %f over the max freq %f \n",
            "driver-btm-soc.c",
            4556,
            (const char *)_FUNCTION___15888,
            chain,
            asic,
            v4,
            v4);
        }
        fclose(pFile);
      }
LABEL_7:
      disable_pic_dac(chain);
      dev->chain_exist[chain] = 0;
      --dev->chain_num;
      return;
    }
  }
  if ( is_force_mode() )
  {
    get_max_scanfreq(0);
    if ( !check_freq_valid_single((unsigned int)v4, (unsigned int)v4) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          get_max_scanfreq(0);
          fprintf(
            pFile_0,
            "%s:%d:%s: Force Mode: chain[%d] asic[%d] freq %f over the max freq %f \n",
            "driver-btm-soc.c",
            4568,
            (const char *)_FUNCTION___15888,
            chain,
            asic,
            v4,
            v4);
        }
        fclose(pFile_0);
      }
      goto LABEL_7;
    }
  }
  if ( opt_use_pll_list )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: set freq %d, pll_out %d\n",
          "driver-btm-soc.c",
          4578,
          (const char *)_FUNCTION___15888,
          freq_high_pll_1393[LODWORD(freq)].freq,
          pll);
      fclose(pFile_1);
    }
    pll_index = get_index_from_pll_B1393(pll);
    get_plldata_from_index(pll_index, vil_pll);
  }
  else
  {
    get_pllparam_divider(COERCE_FLOAT(&vil_pll_t), (uint32_t *)&divider, (uint8_t *)&pll_freq, (float *)&vil_pll_t);
    *(_DWORD *)vil_pll = _bswap_32(vil_pll_t);
  }
  set_config_BM1393_t(chain, chip_addr, 0, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1393_t(chain, chip_addr, 0, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_config_BM1393_t(chain, chip_addr, 0, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1393_t(chain, chip_addr, 0, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_unused_pll();
}
// 23214: variable 'v4' is possibly undefined

//----- (0002357E) --------------------------------------------------------
void __cdecl set_pll(float pll_value)
{
  float v1; // s0
  int local_pll_index; // [sp+8h] [bp+8h]
  uint8_t chain; // [sp+Fh] [bp+Fh]

  local_pll_index = 0;
  if ( opt_use_pll_list )
    local_pll_index = get_index_from_high_pll((int)v1);
  for ( chain = 0; chain <= 0xFu; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( !scanfreq_info.test_done[chain] )
        change_high_pll_test(chain, *(float *)&local_pll_index, chain);
    }
  }
}
// 235A2: variable 'v1' is possibly undefined

//----- (00023606) --------------------------------------------------------
int __cdecl set_freq_by_chain(float freq, int chain)
{
  float v2; // s0
  int v3; // r2
  FILE *pFile; // [sp+18h] [bp+8h]
  int local_pll_index; // [sp+1Ch] [bp+Ch]

  local_pll_index = 0;
  if ( opt_use_pll_list )
    local_pll_index = get_index_from_high_pll((int)v2);
  v3 = LODWORD(freq) + 2;
  if ( !dev->chain_exist[LODWORD(freq)] )
    return 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: chain[%d] set freq:%5.2f\n",
        "driver-btm-soc.c",
        4665,
        (const char *)_FUNCTION___15917,
        freq,
        v2);
    fclose(pFile);
  }
  return change_high_pll_test(LOBYTE(freq), *(float *)&local_pll_index, v3);
}
// 2362C: variable 'v2' is possibly undefined
// 236D2: variable 'v3' is possibly undefined

//----- (000236E4) --------------------------------------------------------
void __cdecl set_pll_adjust(float low_freq, float final_freq)
{
  float v2; // s0
  float v3; // s1
  FILE *pFile; // [sp+24h] [bp+Ch]
  FILE *pFile_0; // [sp+28h] [bp+10h]
  uint32_t i; // [sp+30h] [bp+18h]
  float steps; // [sp+34h] [bp+1Ch]
  float freq_tmp; // [sp+38h] [bp+20h]
  uint8_t chip; // [sp+3Dh] [bp+25h]
  uint8_t vol_region; // [sp+3Eh] [bp+26h]
  uint8_t chain; // [sp+3Fh] [bp+27h]

  if ( v2 == v3 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: \nno need to adjust freq,the final freq is same %f\n",
          "driver-btm-soc.c",
          4681,
          (const char *)_FUNCTION___15930,
          v2);
      fclose(pFile);
    }
  }
  else
  {
    for ( chain = 0; chain <= 0xFu; ++chain )
    {
      if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
      {
        steps = (float)(v3 - v2) / freq_adjust_step;
        if ( v3 > (float)((float)(freq_adjust_step * steps) + v2) )
          steps = steps + 1.0;
        for ( i = 0; steps > (float)i; ++i )
        {
          freq_tmp = v2 + (float)((float)(i + 1) * freq_adjust_step);
          if ( freq_tmp > v3 )
            freq_tmp = v3;
          for ( vol_region = 0; vol_region <= 5u; ++vol_region )
          {
            if ( freq_tmp <= freq_adjust_index[chain][vol_region] )
            {
              for ( chip = 0; chip <= 9u; ++chip )
                change_high_pll_by_aisc(chain, chip + 10 * vol_region, 0.0, chip + 10 * vol_region);
              if ( log_level > 4 )
              {
                print_crt_time_to_file(log_file, 4u);
                pFile_0 = fopen((const char *)log_file, "a+");
                if ( pFile_0 )
                  fprintf(
                    pFile_0,
                    "%s:%d:%s: chain[%d] domain[%2d] to %f\n",
                    "driver-btm-soc.c",
                    4718,
                    (const char *)_FUNCTION___15930,
                    chain,
                    vol_region + 1,
                    freq_tmp);
                fclose(pFile_0);
              }
            }
          }
          sleep(1u);
        }
      }
    }
  }
}
// 23728: variable 'v2' is possibly undefined
// 23728: variable 'v3' is possibly undefined

//----- (000239D8) --------------------------------------------------------
float __cdecl screen_freq_from_array(float array, bool is_high_freq)
{
  FILE *pFile; // [sp+18h] [bp+8h]
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  int domain; // [sp+20h] [bp+10h]
  int domaina; // [sp+20h] [bp+10h]
  int chain; // [sp+24h] [bp+14h]
  int chaina; // [sp+24h] [bp+14h]
  float low_freq; // [sp+28h] [bp+18h]
  float high_freq; // [sp+2Ch] [bp+1Ch]

  if ( is_high_freq )
  {
    high_freq = freq_adjust_index[0][0];
    for ( chain = 0; chain <= 3; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        for ( domain = 0; domain <= 5; ++domain )
        {
          if ( high_freq < freq_adjust_index[chain][domain] )
            high_freq = freq_adjust_index[chain][domain];
        }
      }
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: high_freq = %f\n",
          "driver-btm-soc.c",
          4749,
          (const char *)_FUNCTION___15962,
          high_freq);
      return COERCE_FLOAT(fclose(pFile));
    }
  }
  else
  {
    low_freq = freq_adjust_index[0][0];
    for ( chaina = 0; chaina <= 3; ++chaina )
    {
      if ( dev->chain_exist[chaina] )
      {
        for ( domaina = 0; domaina <= 5; ++domaina )
        {
          if ( low_freq > freq_adjust_index[chaina][domaina] )
            low_freq = freq_adjust_index[chaina][domaina];
        }
      }
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: low_freq = %f\n",
          "driver-btm-soc.c",
          4767,
          (const char *)_FUNCTION___15962,
          low_freq);
      return COERCE_FLOAT(fclose(pFile_0));
    }
  }
  return array;
}

//----- (00023C28) --------------------------------------------------------
void __cdecl increase_freq_slowly(float init_freq, float final_freq, float freq_step, uint8_t chain)
{
  float v4; // s0
  float v5; // s1
  float v6; // s2
  uint8_t chaina; // [sp+13h] [bp+3h]
  FILE *pFile; // [sp+20h] [bp+10h]
  float freq_tmp; // [sp+24h] [bp+14h]
  int steps; // [sp+28h] [bp+18h]
  int i; // [sp+2Ch] [bp+1Ch]

  chaina = LOBYTE(init_freq);
  steps = (int)(float)((float)(v5 - v4) / v6);
  if ( v5 > (float)((float)((float)steps * v6) + v4) )
    ++steps;
  for ( i = 0; i < steps; ++i )
  {
    freq_tmp = v4 + (float)((float)(i + 1) * v6);
    if ( freq_tmp > v5 )
      freq_tmp = v5;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: \n\nIncrease frequency to %.2fM\n",
          "driver-btm-soc.c",
          4786,
          (const char *)_FUNCTION___15981,
          freq_tmp);
      init_freq = COERCE_FLOAT(fclose(pFile));
    }
    if ( chaina == All_Chain )
      set_pll(init_freq);
    else
      change_high_pll_test(chaina, 0.0, chaina);
    init_freq = COERCE_FLOAT(sleep(1u));
  }
}
// 23C46: variable 'v5' is possibly undefined
// 23C46: variable 'v4' is possibly undefined
// 23C4E: variable 'v6' is possibly undefined

//----- (00023D80) --------------------------------------------------------
void __cdecl increase_freq_slowly_by_index(float init_freq, float low_freq, float high_freq)
{
  float v3; // s0
  float v4; // s1
  float v5; // s2
  FILE *pFile_1; // [sp+34h] [bp+14h]
  FILE *pFile_2; // [sp+38h] [bp+18h]
  FILE *pFile_0; // [sp+3Ch] [bp+1Ch]
  FILE *pFile; // [sp+40h] [bp+20h]
  float freq_tmp; // [sp+44h] [bp+24h]
  int steps; // [sp+48h] [bp+28h]
  int i; // [sp+4Ch] [bp+2Ch]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: \n init freq = %f, low_freq = %f, high_freq = %f\n",
        "driver-btm-soc.c",
        4804,
        (const char *)_FUNCTION___15994,
        v3,
        v4,
        v5);
    init_freq = COERCE_FLOAT(fclose(pFile));
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: \nstep1\n", "driver-btm-soc.c", 4806, (const char *)_FUNCTION___15994);
    init_freq = COERCE_FLOAT(fclose(pFile_0));
  }
  steps = (int)(float)((float)(v4 - v3) / freq_step);
  if ( v4 > (float)((float)((float)steps * freq_step) + v3) )
    ++steps;
  for ( i = 0; i < steps; ++i )
  {
    freq_tmp = v3 + (float)((float)(i + 1) * freq_step);
    if ( freq_tmp > v4 )
      freq_tmp = v4;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: all chains increase frequency to %.2fM\n",
          "driver-btm-soc.c",
          4818,
          (const char *)_FUNCTION___15994,
          freq_tmp);
      init_freq = COERCE_FLOAT(fclose(pFile_1));
    }
    set_pll(init_freq);
    init_freq = COERCE_FLOAT(sleep(1u));
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(pFile_2, "%s:%d:%s: \nstep2\n", "driver-btm-soc.c", 4826, (const char *)_FUNCTION___15994);
    init_freq = COERCE_FLOAT(fclose(pFile_2));
  }
  set_pll_adjust(init_freq, low_freq);
}
// 23DFA: variable 'v3' is possibly undefined
// 23DF6: variable 'v4' is possibly undefined
// 23DF2: variable 'v5' is possibly undefined
// 24036: variable 'low_freq' is possibly undefined

//----- (00024042) --------------------------------------------------------
unsigned __int8 __cdecl c2hex(unsigned __int8 value)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  unsigned __int8 ret; // [sp+17h] [bp+Fh]

  ret = -1;
  if ( value > 0x2Fu && value <= 0x39u )
    return value & 0xF;
  switch ( value )
  {
    case 'a':
    case 'A':
      return 10;
    case 'b':
    case 'B':
      return 11;
    case 'c':
    case 'C':
      return 12;
    case 'd':
    case 'D':
      return 13;
    case 'e':
    case 'E':
      return 14;
    case 'f':
    case 'F':
      return 15;
  }
  if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: input value error: %c\n",
        "driver-btm-soc.c",
        4850,
        (const char *)_FUNCTION___16006,
        value);
    fclose(pFile);
  }
  return ret;
}

//----- (0002414A) --------------------------------------------------------
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  unsigned __int8 higha; // [sp+7h] [bp+7h]

  higha = c2hex(high);
  return c2hex(low) ^ (16 * higha);
}

//----- (0002418E) --------------------------------------------------------
int __cdecl s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen)
{
  FILE *pFile; // [sp+24h] [bp+14h]
  int p; // [sp+2Ch] [bp+1Ch]
  int len; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  if ( src && inlen > 0 && dst )
  {
    len = inlen / 2;
    p = inlen & 1;
    for ( i = 0; i < len; ++i )
      dst[i] = twoc2hex(src[2 * i], src[2 * i + 1]);
    if ( p )
      dst[i] = twoc2hex(src[2 * i], 0);
    return p + len;
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: s2hex para error dst(%p), src(%p), inlen(%d)\n",
          "driver-btm-soc.c",
          4871,
          (const char *)_FUNCTION___16023,
          dst,
          src,
          inlen);
      fclose(pFile);
    }
    return -1;
  }
}
// 24246: conditional instruction was optimized away because %inlen.4>=1

//----- (000242C8) --------------------------------------------------------
void get_working_voltage_from_eeprom()
{
  double v0; // r0
  double v1; // r2
  double working_voltage; // [sp+18h] [bp+0h] BYREF
  FILE *pFile; // [sp+20h] [bp+8h]
  int chain; // [sp+24h] [bp+Ch]

  working_voltage = 0.0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( is_economic_mode() )
        eeprom_get_voltage_mode1(chain, &working_voltage);
      else
        eeprom_get_voltage_mode2(chain, &working_voltage);
      if ( is_column_sweep() )
        working_voltage = working_voltage + 0.3;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: get working vol [%5.2f] from chain[%d] eeprom\n",
            "driver-btm-soc.c",
            4912,
            (const char *)_FUNCTION___16033,
            working_voltage,
            chain);
        fclose(pFile);
      }
      if ( working_voltage > 8.0 && working_voltage < 10.5 )
      {
        LODWORD(v0) = is_T11();
        if ( !LODWORD(v0) )
        {
          set_working_voltage(v0);
          return;
        }
        HIDWORD(v1) = (unsigned __int8)chain;
        set_working_voltage_by_chain(chain, v1);
      }
    }
  }
}
// 243F0: variable 'v1' is possibly undefined
// 243FE: variable 'v0' is possibly undefined

//----- (00024428) --------------------------------------------------------
int init_pic()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  int ret; // [sp+10h] [bp+8h]
  uint8_t i; // [sp+17h] [bp+Fh]

  ret = 0;
  for ( i = 0; i <= 0xFu; ++i )
  {
    if ( init_pic_one_chain(i) )
    {
      freq_scan_error_code_set(4, i);
      dev->chain_exist[i] = 0;
      --dev->chain_num;
      ret = -1;
    }
  }
  if ( pic_heart_beat )
    return ret;
  pic_heart_beat = (thr_info *)calloc(1u, 0x40u);
  if ( !thr_info_create(pic_heart_beat, 0, (void *(*)(void *))pic_heart_beat_func, pic_heart_beat) )
    return ret;
  if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: create thread for get nonce and register from FPGA failed\n",
        "driver-btm-soc.c",
        4949,
        (const char *)_FUNCTION___16045);
    fclose(pFile);
  }
  return -5;
}

//----- (0002455C) --------------------------------------------------------
void __cdecl set_timeout(int final_freq, int percent)
{
  FILE *pFile; // [sp+1Ch] [bp+Ch]

  dev->timeout = percent * (dev->addrInterval * (0x1000000 / calculate_core_number(dev->corenum)) / final_freq) / 100;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: freq %d final timeout=%d\n",
        "driver-btm-soc.c",
        4964,
        (const char *)_FUNCTION___16051,
        final_freq,
        dev->timeout);
    fclose(pFile);
  }
  if ( opt_multi_version )
    set_time_out_control((opt_multi_version * dev->timeout) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
}

//----- (000246AA) --------------------------------------------------------
void __fastcall set_target_freq(int a1, float a2, float a3)
{
  FILE *pFile; // [sp+1Ch] [bp+4h]
  float max_freq; // [sp+20h] [bp+8h]
  uint8_t i; // [sp+27h] [bp+Fh]
  uint8_t ia; // [sp+27h] [bp+Fh]

  max_freq = 0.0;
  if ( opt_pattern )
  {
    for ( i = 0; i <= 0xFu; ++i )
    {
      if ( dev->chain_exist[i] )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: set freq %f on chain %d\n",
              "driver-btm-soc.c",
              4982,
              (const char *)_FUNCTION___16059,
              freq_from_board[i],
              i);
          fclose(pFile);
        }
        if ( max_freq <= freq_from_board[i] )
          max_freq = freq_from_board[i];
        increase_freq_slowly(COERCE_FLOAT(i), a2, COERCE_FLOAT(4 * i), i);
      }
    }
  }
  else
  {
    increase_freq_slowly(COERCE_FLOAT(All_Chain), a2, a3, All_Chain);
    for ( ia = 0; ia <= 0xFu; ++ia )
    {
      if ( dev->chain_exist[ia] )
        freq_from_board[ia] = (float)dev->frequency;
    }
  }
}
// 247D6: variable 'a2' is possibly undefined

//----- (000248C2) --------------------------------------------------------
void set_adjust_freq()
{
  float v0; // r0
  float v1; // r1
  float v2; // r2

  screen_freq_from_array(freq_adjust_index[0], 0);
  v0 = screen_freq_from_array(freq_adjust_index[0], 1);
  increase_freq_slowly_by_index(v0, v1, v2);
}
// 24916: variable 'v1' is possibly undefined
// 24916: variable 'v2' is possibly undefined

//----- (0002492E) --------------------------------------------------------
void __cdecl scan_freq_set_freq_by_chip(uint8_t chain, uint8_t chip_addr, float freq)
{
  float v3; // s0
  uint8_t divider; // [sp+23h] [bp+Bh] BYREF
  float pll_freq; // [sp+24h] [bp+Ch] BYREF
  uint32_t vil_pll_t; // [sp+28h] [bp+10h] BYREF
  uint8_t vil_pll[4]; // [sp+2Ch] [bp+14h] BYREF
  FILE *pFile; // [sp+30h] [bp+18h]
  uint32_t pll_index; // [sp+34h] [bp+1Ch]
  uint32_t pll; // [sp+38h] [bp+20h]
  int index; // [sp+3Ch] [bp+24h]

  index = get_index_from_high_pll((int)v3);
  divider = freq_high_pll_1393[index].divider;
  pll = freq_high_pll_1393[index].pll_out;
  pll_index = 0;
  if ( opt_use_pll_list )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chain %d chip %d set freq %d, pll_out %d",
          "driver-btm-soc.c",
          5032,
          (const char *)_FUNCTION___16086,
          chain,
          chip_addr,
          freq_high_pll_1393[index].freq,
          pll);
      fclose(pFile);
    }
    pll_index = get_index_from_pll_B1393(pll);
    get_plldata_from_index(pll_index, vil_pll);
  }
  else
  {
    get_pllparam_divider(COERCE_FLOAT(&vil_pll_t), (uint32_t *)&divider, (uint8_t *)&pll_freq, (float *)&vil_pll_t);
    *(_DWORD *)vil_pll = _bswap_32(vil_pll_t);
  }
  set_config_BM1393(chain, chip_addr, 0, 0x70u, divider - 1);
  set_config_BM1393(chain, chip_addr, 0, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_config_BM1393(chain, chip_addr, 0, 0x70u, divider - 1);
  set_config_BM1393(chain, chip_addr, 0, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
}
// 2494A: variable 'v3' is possibly undefined

//----- (00024ADA) --------------------------------------------------------
int __cdecl get_physical_chip_no(int logical_row, int logical_col)
{
  if ( logical_row > 5 )
    return 0;
  if ( (logical_row & 1) != 0 )
    return 10 * (logical_row + 1) - 1 - logical_col;
  return logical_col + 10 * logical_row;
}

//----- (00024B28) --------------------------------------------------------
int __cdecl get_logical_column_by_chip_no(int chip)
{
  int logical_row; // [sp+Ch] [bp+Ch]

  logical_row = chip / 10;
  if ( !(chip / 10) )
    return chip;
  switch ( logical_row )
  {
    case 1:
      return 19 - chip;
    case 2:
      return chip - 20;
    case 3:
      return 39 - chip;
    case 4:
      return chip - 40;
    case 5:
      return 59 - chip;
  }
  return 0;
}

//----- (00024B9E) --------------------------------------------------------
float get_max_freq()
{
  bool v0; // r0

  is_economic_mode();
  v0 = is_economic_mode();
  return get_max_scanfreq(v0);
}

//----- (00024BDC) --------------------------------------------------------
uint16_t __cdecl increase_freq_by_eeprom_slowly(int init_freq, int freq_step)
{
  return increase_freq_by_eeprom_slowly_new(init_freq, freq_step);
}

//----- (00024BF8) --------------------------------------------------------
uint16_t __cdecl increase_freq_by_eeprom_slowly_new(int init_freq, int freq_step)
{
  float v2; // s0
  uint32_t *freq_eeprom; // r4
  int v4; // r4
  int v6; // r2
  uint16_t v7; // r3
  int chip_freq_array[60]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile_0; // [sp+10Ch] [bp+FCh]
  uint16_t final_freq; // [sp+112h] [bp+102h]
  uint16_t asic_freq; // [sp+114h] [bp+104h]
  uint16_t tmp_freq; // [sp+116h] [bp+106h]
  FILE *pFile_5; // [sp+118h] [bp+108h]
  FILE *pFile_4; // [sp+11Ch] [bp+10Ch]
  FILE *pFile_6; // [sp+120h] [bp+110h]
  FILE *pFile_3; // [sp+124h] [bp+114h]
  FILE *pFile_2; // [sp+128h] [bp+118h]
  FILE *pFile_1; // [sp+12Ch] [bp+11Ch]
  FILE *pFile; // [sp+130h] [bp+120h]
  uint16_t freq_temp; // [sp+136h] [bp+126h]
  int total_freq_tmp; // [sp+138h] [bp+128h]
  uint16_t total_freq_chain; // [sp+13Eh] [bp+12Eh]
  uint16_t max_freq_chain; // [sp+140h] [bp+130h]
  uint16_t min_freq_chain; // [sp+142h] [bp+132h]
  uint16_t max_freq; // [sp+144h] [bp+134h]
  uint16_t step; // [sp+146h] [bp+136h]
  uint16_t steps; // [sp+148h] [bp+138h]
  uint8_t column; // [sp+14Bh] [bp+13Bh]
  uint8_t asic; // [sp+14Ch] [bp+13Ch]
  uint8_t chip; // [sp+14Dh] [bp+13Dh]
  uint8_t vol_region; // [sp+14Eh] [bp+13Eh]
  uint8_t chain; // [sp+14Fh] [bp+13Fh]

  max_freq = 0;
  total_freq_tmp = 0;
  freq_temp = 0;
  memset(chip_freq_array, 0, sizeof(chip_freq_array));
  for ( chain = 0; ; ++chain )
  {
    if ( chain > 0xFu )
    {
      total_freq = total_freq_tmp;
      return max_freq;
    }
    if ( dev->chain_exist[chain] )
      break;
LABEL_76:
    ;
  }
  min_freq_chain = -1;
  max_freq_chain = 0;
  total_freq_chain = 0;
  for ( asic = 0; asic <= 0x3Bu; ++asic )
  {
    asic_freq = scan_result[chain].freq_eeprom[asic];
    if ( max_freq_chain < (unsigned int)asic_freq )
      max_freq_chain = asic_freq;
    if ( min_freq_chain > (unsigned int)asic_freq )
      min_freq_chain = asic_freq;
    total_freq_chain += asic_freq;
  }
  if ( max_freq < (unsigned int)max_freq_chain )
    max_freq = max_freq_chain;
  if ( !is_user_mode()
    || (freq_eeprom = scan_result[chain].freq_eeprom,
        get_max_freq(),
        check_freq_valid(freq_eeprom, 0x3Cu, (unsigned int)v2)) )
  {
    scan_freq_average[chain] = total_freq_chain / 0x3Cu;
    total_freq_tmp += total_freq_chain;
    steps = (min_freq_chain - init_freq) / freq_step;
    if ( freq_step * steps + init_freq < min_freq_chain )
      ++steps;
    for ( step = 0; step < (unsigned int)steps; ++step )
    {
      freq_temp = init_freq + (step + 1) * freq_step;
      v6 = freq_temp;
      if ( freq_temp > (unsigned int)min_freq_chain )
        freq_temp = min_freq_chain;
      v2 = (float)freq_temp;
      change_high_pll_test(chain, 0.0, v6);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: chain[%d] increase to %d\n",
            "driver-btm-soc.c",
            5303,
            (const char *)_FUNCTION___16152,
            chain,
            freq_temp);
        fclose(pFile_0);
      }
      for ( asic = 0; asic <= 0x3Bu; ++asic )
        chip_freq_array[asic] = freq_temp;
      sleep(1u);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: max = %d ,min = %d\n",
          "driver-btm-soc.c",
          5313,
          (const char *)_FUNCTION___16152,
          max_freq_chain,
          min_freq_chain);
      fclose(pFile_1);
    }
    steps = (max_freq_chain - min_freq_chain) / freq_step;
    if ( min_freq_chain + freq_step * steps < max_freq_chain )
      ++steps;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: chain[%d] increaseing the diff freq ...\n",
          "driver-btm-soc.c",
          5319,
          (const char *)_FUNCTION___16152,
          chain);
      fclose(pFile_2);
    }
    for ( step = 0; step < (unsigned int)steps; ++step )
    {
      tmp_freq = min_freq_chain + (step + 1) * freq_step;
      for ( column = 0; column <= 9u; ++column )
      {
        for ( vol_region = 0; vol_region <= 5u; ++vol_region )
        {
          asic = column + 10 * vol_region;
          asic_freq = scan_result[chain].freq_eeprom[asic];
          v7 = tmp_freq;
          if ( tmp_freq >= (unsigned int)asic_freq )
            v7 = asic_freq;
          final_freq = v7;
          chip_freq_array[asic] = v7;
          v2 = (float)final_freq;
          change_high_pll_by_aisc(chain, asic, 0.0, chain);
        }
      }
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: chain %d final freq setting:\n",
          "driver-btm-soc.c",
          5347,
          (const char *)_FUNCTION___16152,
          chain);
      fclose(pFile_3);
    }
    for ( chip = 0; chip <= 0x3Bu; ++chip )
    {
      if ( log_level > 3 )
      {
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(pFile_4, "%03d ", chip_freq_array[chip]);
        fclose(pFile_4);
      }
      if ( !((chip + 1) % 10) && log_level > 3 )
      {
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fputc(10, pFile_5);
        fclose(pFile_5);
      }
    }
    if ( is_env_temperature_high() )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: set chain %u to working voltage\n",
            "driver-btm-soc.c",
            5359,
            (const char *)_FUNCTION___16152,
            chain);
        fclose(pFile_6);
      }
      slowly_set_working_power_t11(chain);
    }
    goto LABEL_76;
  }
  dump_freq_data(chain, scan_result[chain].freq_eeprom);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      v4 = chain;
      get_max_freq();
      fprintf(
        pFile,
        "%s:%d:%s: fetal error: chain[%d] freq data over valid max freq %d\n",
        "driver-btm-soc.c",
        5280,
        (const char *)_FUNCTION___16152,
        v4,
        (unsigned int)v2);
    }
    fclose(pFile);
  }
  disable_pic_dac(chain);
  dev->chain_exist[chain] = 0;
  --dev->chain_num;
  return -1;
}
// 24D1E: variable 'v2' is possibly undefined

//----- (000253F8) --------------------------------------------------------
bool is_env_temperature_high()
{
  return dev->pwm_percent >= 0x50u;
}

//----- (0002542E) --------------------------------------------------------
void low_temperature_freq_handler()
{
  FILE *pFile; // [sp+10h] [bp+0h]
  int asic; // [sp+18h] [bp+8h]
  int chain; // [sp+1Ch] [bp+Ch]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( asic = 0; asic <= 59; ++asic )
      {
        scan_result[chain].freq_eeprom[asic] += 10;
        if ( scan_result[chain].freq_eeprom[asic] > g_sweep_config_eco.sweep_max_freq + 10 )
          scan_result[chain].freq_eeprom[asic] = g_sweep_config_eco.sweep_max_freq + 10;
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d] increase [%d] MHz...\n",
            "driver-btm-soc.c",
            5404,
            (const char *)_FUNCTION___16194,
            chain,
            10);
        fclose(pFile);
      }
    }
  }
}

//----- (0002559E) --------------------------------------------------------
bool is_fixed_mode()
{
  return freq_mode == 2;
}

//----- (000255C0) --------------------------------------------------------
bool is_force_mode()
{
  return freq_mode == 0;
}

//----- (000255E2) --------------------------------------------------------
bool is_user_mode()
{
  return freq_mode == 1;
}

//----- (00025604) --------------------------------------------------------
bool is_economic_mode()
{
  return opt_bitmain_economic_mode;
}

//----- (00025620) --------------------------------------------------------
void init_working_voltage()
{
  double v0; // r0
  FILE *pFile; // [sp+14h] [bp+4h]

  LODWORD(v0) = is_fixed_mode();
  if ( LODWORD(v0) )
  {
    set_working_voltage(v0);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: set fixed voltage to %f\n",
          "driver-btm-soc.c",
          5641,
          (const char *)_FUNCTION___16291,
          (double)config_parameter.voltage / 100.0);
      fclose(pFile);
    }
  }
  else
  {
    get_working_voltage_from_eeprom();
  }
}
// 2564E: variable 'v0' is possibly undefined

//----- (000256F0) --------------------------------------------------------
void update_highest_voltage()
{
  double v0; // r2
  double hpf_working_volt; // [sp+10h] [bp+0h] BYREF
  FILE *pFile; // [sp+18h] [bp+8h]
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  double max_volt; // [sp+20h] [bp+10h]
  int chain; // [sp+2Ch] [bp+1Ch]

  hpf_working_volt = 0.0;
  max_volt = 0.0;
  if ( is_T11() && !is_fixed_mode() )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        eeprom_get_voltage_mode2(chain, &hpf_working_volt);
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chain %d hpf working voltage %.2f\n",
              "driver-btm-soc.c",
              5660,
              (const char *)_FUNCTION___16300,
              chain,
              hpf_working_volt);
          fclose(pFile);
        }
        if ( max_volt < hpf_working_volt )
          max_volt = hpf_working_volt;
      }
    }
    max_volt = max_volt * 1.08;
    if ( max_volt > 10.1999998 )
      max_volt = 10.1999998;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: open core at max voltage %.2f\n",
          "driver-btm-soc.c",
          5669,
          (const char *)_FUNCTION___16300,
          max_volt);
      fclose(pFile_0);
    }
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        HIDWORD(v0) = (unsigned __int8)chain;
        LODWORD(v0) = chain + 2;
        set_highest_voltage_by_chain(chain, v0);
      }
    }
  }
}

//----- (000258E8) --------------------------------------------------------
void init_read_temp_thread_in_force()
{
  FILE *pFile; // [sp+Ch] [bp+4h]

  read_temp_id_in_force = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_temp_id_in_force, 0, (void *(*)(void *))read_temp_func, read_temp_id_in_force) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: create thread for read temp\n",
          "driver-btm-soc.c",
          5685,
          (const char *)_FUNCTION___16312);
      fclose(pFile);
    }
  }
  else
  {
    pthread_detach(read_temp_id_in_force->pth);
  }
}

//----- (000259B4) --------------------------------------------------------
void shutdown_read_temp_thread_in_force()
{
  if ( read_temp_id_in_force )
  {
    thr_info_cancel(read_temp_id_in_force);
    read_temp_id_in_force = 0;
  }
}

//----- (000259E6) --------------------------------------------------------
int get_current_total_rate()
{
  FILE *pFile; // [sp+14h] [bp+4h]
  FILE *pFile_0; // [sp+18h] [bp+8h]
  int tmp_rate; // [sp+1Ch] [bp+Ch]
  int tmp_freq; // [sp+20h] [bp+10h]
  int total_rate; // [sp+24h] [bp+14h]
  int chip; // [sp+28h] [bp+18h]
  int chain; // [sp+2Ch] [bp+1Ch]

  total_rate = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      tmp_freq = 0;
      for ( chip = 0; chip <= 59; ++chip )
        tmp_freq += scan_result[chain].freq_eeprom[chip];
      tmp_rate = 208 * tmp_freq / 1000;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d] hash rate = %d\n",
            "driver-btm-soc.c",
            5719,
            (const char *)_FUNCTION___16327,
            chain,
            tmp_rate);
        fclose(pFile);
      }
      total_rate += tmp_rate;
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: total rate = %d\n",
        "driver-btm-soc.c",
        5723,
        (const char *)_FUNCTION___16327,
        total_rate);
    fclose(pFile_0);
  }
  return total_rate;
}

//----- (00025B7A) --------------------------------------------------------
void print_chip_freq()
{
  FILE *pFile_1; // [sp+0h] [bp+0h]
  FILE *pFile_0; // [sp+4h] [bp+4h]
  FILE *pFile_2; // [sp+8h] [bp+8h]
  FILE *pFile; // [sp+Ch] [bp+Ch]
  int chip; // [sp+10h] [bp+10h]
  int chain; // [sp+14h] [bp+14h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "chain %d freq:\n", chain);
        fclose(pFile);
      }
      for ( chip = 0; chip <= 59; ++chip )
      {
        if ( log_level > 3 )
        {
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(pFile_0, "%d ", scan_result[chain].freq_eeprom[chip]);
          fclose(pFile_0);
        }
        if ( !((chip + 1) % 10) && log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fputc(10, pFile_1);
          fclose(pFile_1);
        }
      }
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fputc(10, pFile_2);
        fclose(pFile_2);
      }
    }
  }
}

//----- (00025D0E) --------------------------------------------------------
void fix_chip_freq()
{
  int down_count[16]; // [sp+1Ch] [bp+4h] BYREF
  FILE *pFile_0; // [sp+5Ch] [bp+44h]
  FILE *pFile_1; // [sp+60h] [bp+48h]
  FILE *pFile; // [sp+64h] [bp+4Ch]
  int fixed_totalRate; // [sp+68h] [bp+50h]
  int step_rate; // [sp+6Ch] [bp+54h]
  int step; // [sp+70h] [bp+58h]
  int min_down_count; // [sp+74h] [bp+5Ch]
  int fix_chain; // [sp+78h] [bp+60h]
  int totalRate; // [sp+7Ch] [bp+64h]
  int chip; // [sp+80h] [bp+68h]
  int chain; // [sp+84h] [bp+6Ch]
  int v12; // [sp+88h] [bp+70h] BYREF

  step = 10;
  step_rate = 124;
  totalRate = get_current_total_rate();
  fixed_totalRate = 18500;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: total rate %d, fixed rate %d, step rate %d\n",
        "driver-btm-soc.c",
        5774,
        (const char *)_FUNCTION___16367,
        totalRate,
        fixed_totalRate,
        step_rate);
    fclose(pFile);
  }
  memset(down_count, 0, sizeof(down_count));
  while ( totalRate >= step_rate + fixed_totalRate )
  {
    min_down_count = 1000;
    fix_chain = -1;
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] == 1 && min_down_count > *(&v12 + chain - 27) )
      {
        min_down_count = *(&v12 + chain - 27);
        fix_chain = chain;
      }
    }
    if ( fix_chain == -1 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: error, can not find a chain to fix\n",
            "driver-btm-soc.c",
            5817,
            (const char *)_FUNCTION___16367);
        fclose(pFile_0);
      }
      return;
    }
    ++*(&v12 + fix_chain - 27);
    for ( chip = 0; chip <= 59; ++chip )
      scan_result[fix_chain].freq_eeprom[chip] -= step;
    totalRate = get_current_total_rate();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: chain %d down a step of %dM, rate of %dG, total rate %dG\n",
          "driver-btm-soc.c",
          5827,
          (const char *)_FUNCTION___16367,
          fix_chain,
          step,
          step_rate,
          totalRate);
      fclose(pFile_1);
    }
  }
}

//----- (00025FA6) --------------------------------------------------------
void get_freq_result_from_eeprom()
{
  uint32_t *buf; // [sp+8h] [bp+0h]
  FILE *pFile_0; // [sp+Ch] [bp+4h]
  FILE *pFile; // [sp+10h] [bp+8h]
  uint8_t i; // [sp+16h] [bp+Eh]
  uint8_t ia; // [sp+16h] [bp+Eh]
  uint8_t chain; // [sp+17h] [bp+Fh]

  for ( chain = 0; chain <= 0xFu; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      buf = scan_result[chain].freq_eeprom;
      memset(buf, 0, 0xF0u);
      if ( is_economic_mode() )
      {
        if ( !eeprom_get_freq_mode1(chain, buf) )
        {
          for ( i = 0; i <= 0x3Bu; ++i )
            buf[i] = g_sweep_config_eco.sweep_min_freq;
        }
      }
      else if ( !eeprom_get_freq_mode2(chain, buf) )
      {
        for ( ia = 0; ia <= 0x3Bu; ++ia )
          buf[ia] = g_sweep_config_hpf.sweep_min_freq;
      }
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: orginal chip freq: \n", "driver-btm-soc.c", 5870, (const char *)_FUNCTION___16395);
    fclose(pFile);
  }
  print_chip_freq();
  if ( (unsigned __int8)is_T11() != 1 && is_economic_mode() )
  {
    fix_chip_freq();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: fixed chip freq for economic mode of bgm miner: ",
          "driver-btm-soc.c",
          5877,
          (const char *)_FUNCTION___16395);
      fclose(pFile_0);
    }
    print_chip_freq();
  }
}

//----- (00026188) --------------------------------------------------------
bool read_freq_result()
{
  FILE *pFile_1; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile; // [sp+14h] [bp+Ch]
  FILE *pFile_2; // [sp+18h] [bp+10h]
  bool ret; // [sp+1Fh] [bp+17h]
  int asic; // [sp+20h] [bp+18h]
  int chain; // [sp+24h] [bp+1Ch]

  ret = 1;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( eeprom_get_freq(chain, scan_result[chain].freq_eeprom) )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chain[%d] freq in eeprom is:\n",
              "driver-btm-soc.c",
              5892,
              (const char *)_FUNCTION___16404,
              chain);
          fclose(pFile);
        }
        for ( asic = 0; asic <= 59; ++asic )
        {
          if ( log_level > 3 )
          {
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(pFile_0, "IC[%03d]:%d ", asic, scan_result[chain].freq_eeprom[asic]);
            fclose(pFile_0);
          }
          if ( !((asic + 1) % 10) && log_level > 3 )
          {
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fputc(10, pFile_1);
            fclose(pFile_1);
          }
        }
      }
      else
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: Fail to get freq from eeprom of chain %d!\n",
              "driver-btm-soc.c",
              5904,
              (const char *)_FUNCTION___16404,
              chain);
          fclose(pFile_2);
        }
        freq_scan_error_code_set(3, 255);
        stop_mining("read freq error!");
        ret = 0;
      }
    }
  }
  return ret;
}

//----- (000263C4) --------------------------------------------------------
void __cdecl get_freq_result(int default_freq)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  check_chain();
  if ( !read_freq_result() )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: scan freq result error, set default freq %dM\n",
          "driver-btm-soc.c",
          5919,
          (const char *)_FUNCTION___16418,
          default_freq);
      fclose(pFile);
    }
    set_freq_default(default_freq);
  }
}

//----- (0002645E) --------------------------------------------------------
void show_mode()
{
  memset(displayed_mode, 0, sizeof(displayed_mode));
  if ( is_economic_mode() )
    displayed_mode[0] = 76;
  else
    displayed_mode[0] = 72;
}

//----- (0002649A) --------------------------------------------------------
void __cdecl set_freq_default(int default_freq)
{
  int v1; // r3
  int column; // [sp+8h] [bp+8h]
  int chain; // [sp+Ch] [bp+Ch]

  memset(scan_result, 0, sizeof(scan_result));
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      BYTE1(v1) = BYTE1(default_freq);
      if ( default_freq < 0 )
        LOWORD(v1) = default_freq + 255;
      scan_result[chain].start_freq_high = BYTE1(v1);
      LOBYTE(v1) = default_freq;
      if ( default_freq <= 0 )
        v1 = -(unsigned __int8)-(char)default_freq;
      scan_result[chain].start_freq_low = v1;
      scan_result[chain].freq_step = 5;
      for ( column = 0; column <= 9; ++column )
        scan_result[chain].column_freq_level[column] = 0;
    }
  }
}

//----- (00026590) --------------------------------------------------------
void init_sweep_config()
{
  unsigned int v0; // r1
  unsigned int v1; // r2
  FILE *pFile_8; // [sp+0h] [bp+0h]
  FILE *pFile_7; // [sp+4h] [bp+4h]
  FILE *pFile_6; // [sp+8h] [bp+8h]
  FILE *pFile_5; // [sp+Ch] [bp+Ch]
  FILE *pFile_4; // [sp+10h] [bp+10h]
  FILE *pFile_3; // [sp+14h] [bp+14h]
  FILE *pFile_2; // [sp+18h] [bp+18h]
  FILE *pFile_1; // [sp+1Ch] [bp+1Ch]
  FILE *pFile_0; // [sp+20h] [bp+20h]
  FILE *pFile; // [sp+24h] [bp+24h]
  CHIP_LEVEL _g_bin_level; // [sp+34h] [bp+34h]
  CHIP_MINOR_TYPE _g_minor_type; // [sp+38h] [bp+38h]
  int chain; // [sp+3Ch] [bp+3Ch]

  _g_minor_type = PKG_BSL;
  _g_bin_level = BIN1;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      _g_minor_type = g_minor_type[chain];
      _g_bin_level = g_bin_level[chain];
      break;
    }
  }
  if ( is_T11() )
  {
    if ( _g_minor_type && _g_minor_type != PKG_B_BGM )
    {
      if ( _g_minor_type == PKG_BE )
      {
        if ( _g_bin_level == BIN1 || _g_bin_level == BIN2 )
        {
          *(_QWORD *)&g_sweep_config_eco.sweep_start_voltage = loc_27350;
          g_sweep_config_eco.max_aging_voltage = loc_27350 + *(double *)sub_27310;
          g_sweep_config_eco.sweep_min_freq = 280;
          g_sweep_config_eco.sweep_max_freq = 330;
          g_sweep_config_hpf.sweep_start_voltage = *(double *)sub_27318;
          g_sweep_config_hpf.max_aging_voltage = *(double *)sub_27318 + *(double *)sub_27310;
          g_sweep_config_hpf.sweep_min_freq = 300;
          g_sweep_config_hpf.sweep_max_freq = 360;
        }
        else
        {
          if ( _g_bin_level == BIN3 )
          {
            g_sweep_config_eco.sweep_start_voltage = *(double *)sub_27330;
            g_sweep_config_eco.max_aging_voltage = *(double *)sub_27330 + *(double *)sub_27310;
            g_sweep_config_eco.sweep_min_freq = 270;
            g_sweep_config_eco.sweep_max_freq = 310;
            *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27338;
            g_sweep_config_hpf.max_aging_voltage = loc_27338 + *(double *)sub_27310;
          }
          else
          {
            *(_QWORD *)&g_sweep_config_eco.sweep_start_voltage = loc_27340;
            g_sweep_config_eco.max_aging_voltage = loc_27340 + *(double *)sub_27310;
            g_sweep_config_eco.sweep_min_freq = 270;
            g_sweep_config_eco.sweep_max_freq = 310;
            *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27348;
            g_sweep_config_hpf.max_aging_voltage = loc_27348 + *(double *)sub_27310;
          }
          g_sweep_config_hpf.sweep_min_freq = 300;
          g_sweep_config_hpf.sweep_max_freq = 350;
        }
      }
      else if ( _g_minor_type == PKG_CE )
      {
        if ( _g_bin_level == BIN1 || _g_bin_level == BIN2 )
        {
          *(_QWORD *)&g_sweep_config_eco.sweep_start_voltage = loc_27358;
          g_sweep_config_eco.max_aging_voltage = loc_27358 + *(double *)sub_27310;
          g_sweep_config_eco.sweep_min_freq = 300;
          g_sweep_config_eco.sweep_max_freq = 380;
          *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27350;
          g_sweep_config_hpf.max_aging_voltage = loc_27350 + *(double *)sub_27310;
          g_sweep_config_hpf.sweep_min_freq = 415;
          g_sweep_config_hpf.sweep_max_freq = 465;
        }
        else
        {
          *(_QWORD *)&g_sweep_config_eco.sweep_start_voltage = loc_27360;
          g_sweep_config_eco.max_aging_voltage = loc_27360 + *(double *)sub_27310;
          g_sweep_config_eco.sweep_min_freq = 310;
          g_sweep_config_eco.sweep_max_freq = 360;
          *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27368;
          g_sweep_config_hpf.max_aging_voltage = loc_27368 + *(double *)sub_27310;
          g_sweep_config_hpf.sweep_min_freq = 400;
          g_sweep_config_hpf.sweep_max_freq = 450;
        }
      }
      else
      {
        *(_QWORD *)&g_sweep_config_eco.sweep_start_voltage = loc_27370;
        g_sweep_config_eco.max_aging_voltage = loc_27370 + *(double *)sub_27310;
        g_sweep_config_eco.sweep_min_freq = 250;
        g_sweep_config_eco.sweep_max_freq = 300;
        *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27378;
        g_sweep_config_hpf.max_aging_voltage = loc_27378 + *(double *)sub_27310;
        g_sweep_config_hpf.sweep_min_freq = 300;
        g_sweep_config_hpf.sweep_max_freq = 360;
      }
    }
    else if ( _g_bin_level )
    {
      if ( _g_bin_level == BIN2 )
      {
        g_sweep_config_eco.sweep_start_voltage = 9.25;
        g_sweep_config_eco.max_aging_voltage = *(double *)sub_27310 + 9.25;
        g_sweep_config_eco.sweep_min_freq = 300;
        g_sweep_config_eco.sweep_max_freq = 350;
        if ( is_column_sweep() )
        {
          g_sweep_config_hpf.sweep_start_voltage = *(double *)sub_27318;
          g_sweep_config_hpf.max_aging_voltage = *(double *)sub_27318 + *(double *)sub_27310;
          g_sweep_config_hpf.sweep_min_freq = 335;
        }
        else
        {
          g_sweep_config_hpf.sweep_start_voltage = *(double *)sub_27328;
          g_sweep_config_hpf.max_aging_voltage = *(double *)sub_27328 + *(double *)sub_27310;
          g_sweep_config_hpf.sweep_min_freq = 355;
        }
        g_sweep_config_hpf.sweep_max_freq = 385;
      }
      else
      {
        if ( _g_bin_level == BIN3 )
        {
          g_sweep_config_eco.sweep_start_voltage = *(double *)sub_27330;
          g_sweep_config_eco.max_aging_voltage = *(double *)sub_27330 + *(double *)sub_27310;
          g_sweep_config_eco.sweep_min_freq = 270;
          g_sweep_config_eco.sweep_max_freq = 310;
          *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27338;
          g_sweep_config_hpf.max_aging_voltage = loc_27338 + *(double *)sub_27310;
        }
        else
        {
          *(_QWORD *)&g_sweep_config_eco.sweep_start_voltage = loc_27340;
          g_sweep_config_eco.max_aging_voltage = loc_27340 + *(double *)sub_27310;
          g_sweep_config_eco.sweep_min_freq = 270;
          g_sweep_config_eco.sweep_max_freq = 310;
          *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27348;
          g_sweep_config_hpf.max_aging_voltage = loc_27348 + *(double *)sub_27310;
        }
        g_sweep_config_hpf.sweep_min_freq = 300;
        g_sweep_config_hpf.sweep_max_freq = 350;
      }
    }
    else
    {
      g_sweep_config_eco.sweep_start_voltage = 9.25;
      g_sweep_config_eco.max_aging_voltage = *(double *)sub_27310 + 9.25;
      g_sweep_config_eco.sweep_min_freq = 300;
      g_sweep_config_eco.sweep_max_freq = 350;
      if ( is_column_sweep() )
      {
        g_sweep_config_hpf.sweep_start_voltage = *(double *)sub_27318;
        g_sweep_config_hpf.max_aging_voltage = *(double *)sub_27318 + *(double *)sub_27310;
        g_sweep_config_hpf.sweep_min_freq = 335;
        g_sweep_config_hpf.sweep_max_freq = 385;
      }
      else
      {
        if ( _g_minor_type == PKG_B_BGM )
        {
          v1 = loc_27324;
          v0 = *(_DWORD *)sub_27320;
        }
        else
        {
          v1 = loc_2732C;
          v0 = *(_DWORD *)sub_27328;
        }
        *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = __PAIR64__(v1, v0);
        g_sweep_config_hpf.max_aging_voltage = COERCE_DOUBLE(__PAIR64__(v1, v0)) + *(double *)sub_27310;
        g_sweep_config_hpf.sweep_min_freq = 355;
        g_sweep_config_hpf.sweep_max_freq = 385;
      }
    }
  }
  else if ( is_T11a() )
  {
    *(_QWORD *)&g_sweep_config_eco.sweep_start_voltage = loc_27380;
    *(_QWORD *)&g_sweep_config_eco.max_aging_voltage = loc_27388;
    g_sweep_config_eco.sweep_min_freq = 250;
    g_sweep_config_eco.sweep_max_freq = 275;
    *(_QWORD *)&g_sweep_config_hpf.sweep_start_voltage = loc_27390;
    g_sweep_config_hpf.max_aging_voltage = 19.5;
    g_sweep_config_hpf.sweep_min_freq = 295;
    g_sweep_config_hpf.sweep_max_freq = 320;
  }
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fwrite("\nsweep config for eco mode: \n", 1u, 0x1Du, pFile);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "sweep_start_voltage: %.2f\n", g_sweep_config_eco.sweep_start_voltage);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "max_aging_voltage:   %.2f\n", g_sweep_config_eco.max_aging_voltage);
    fclose(pFile_1);
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(pFile_2, "sweep_min_freq:      %dM\n", g_sweep_config_eco.sweep_min_freq);
    fclose(pFile_2);
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(pFile_3, "sweep_max_freq:      %dM\n", g_sweep_config_eco.sweep_max_freq);
    fclose(pFile_3);
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fwrite("\nsweep config for hpf mode: \n", 1u, 0x1Du, pFile_4);
    fclose(pFile_4);
  }
  if ( log_level > 3 )
  {
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fprintf(pFile_5, "sweep_start_voltage: %.2f\n", g_sweep_config_hpf.sweep_start_voltage);
    fclose(pFile_5);
  }
  if ( log_level > 3 )
  {
    pFile_6 = fopen((const char *)log_file, "a+");
    if ( pFile_6 )
      fprintf(pFile_6, "max_aging_voltage:   %.2f\n", g_sweep_config_hpf.max_aging_voltage);
    fclose(pFile_6);
  }
  if ( log_level > 3 )
  {
    pFile_7 = fopen((const char *)log_file, "a+");
    if ( pFile_7 )
      fprintf(pFile_7, "sweep_min_freq:      %dM\n", g_sweep_config_hpf.sweep_min_freq);
    fclose(pFile_7);
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fprintf(pFile_8, "sweep_max_freq:      %dM\n", g_sweep_config_hpf.sweep_max_freq);
    fclose(pFile_8);
  }
}

//----- (00027310) --------------------------------------------------------
int __fastcall sub_27310(int a1)
{
  return sub_27318(a1, STACK[0x264]);
}
// 27318: using guessed type int __fastcall sub_27318(_DWORD, _DWORD);

//----- (00027318) --------------------------------------------------------
int __fastcall sub_27318(int a1, int a2, int a3, int a4)
{
  int v4; // r4

  return sub_27320(a1, a2, a3, (a4 + 153) & v4);
}
// 2731E: variable 'v4' is possibly undefined
// 27320: using guessed type int __fastcall sub_27320(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027320) --------------------------------------------------------
int __fastcall sub_27320(int a1, int a2, int a3, int a4)
{
  int v4; // r4
  int v5; // r6

  *(_DWORD *)(v4 + 100) = v5;
  *(_DWORD *)(v4 + 100) = v5;
  *(_DWORD *)(v4 + 100) = v5;
  return sub_27328(a1, a2, a3, a4 & v4);
}
// 27320: variable 'v5' is possibly undefined
// 27320: variable 'v4' is possibly undefined
// 27328: using guessed type int __fastcall sub_27328(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027328) --------------------------------------------------------
int __fastcall sub_27328(int a1, int a2)
{
  _DWORD *v2; // r4

  return sub_27330(*v2, a2, v2[9], v2[10] & (unsigned int)(v2 + 13));
}
// 27328: variable 'v2' is possibly undefined
// 27330: using guessed type int __fastcall sub_27330(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027330) --------------------------------------------------------
int sub_27330()
{
  return bring_up_all_chain();
}

//----- (00027398) --------------------------------------------------------
void init_miner_version()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int hardware_version; // [sp+Ch] [bp+4h]

  hardware_version = get_hardware_version();
  pcb_version = BYTE2(hardware_version);
  fpga_version = (unsigned __int8)hardware_version;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: FPGA Version = 0x%04X\n",
        "driver-btm-soc.c",
        6205,
        (const char *)_FUNCTION___16459,
        (unsigned __int16)hardware_version);
    fclose(pFile);
  }
  sprintf((char *)g_miner_version, "%d.%d.%d.%d", fpga_version, pcb_version, 1, 3);
}

//----- (0002746C) --------------------------------------------------------
void __cdecl power_on_chain(int chain)
{
  disable_pic_dac(chain);
  set_reset_hashboard(chain, 1);
  sleep(1u);
  enable_pic_dac(chain);
  sleep(1u);
  set_reset_hashboard(chain, 0);
  sleep(1u);
}

//----- (000274B2) --------------------------------------------------------
void __cdecl hash_board_reset(int chain)
{
  set_reset_hashboard(chain, 1);
  sleep(1u);
  set_reset_hashboard(chain, 0);
  sleep(1u);
}

//----- (000274DE) --------------------------------------------------------
int __cdecl bring_up_chain(int chain, bool poweron)
{
  int v3; // r1
  FILE *pFile; // [sp+14h] [bp+Ch]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: \n\nbring up chain %d\n",
        "driver-btm-soc.c",
        6234,
        (const char *)_FUNCTION___16471,
        chain);
    fclose(pFile);
  }
  if ( poweron )
    power_on_chain(chain);
  else
    hash_board_reset(chain);
  if ( check_asic_num(chain) < 0 )
    return -1;
  set_addr_one_chain(chain);
  if ( set_freq_by_chain(*(float *)&chain, v3) < 0 )
    return -1;
  open_core_BM1393_pre_open(chain, 0xDu, 1u);
  calibration_sensor_offset(0x98u, chain);
  return 0;
}
// 2759A: variable 'v3' is possibly undefined

//----- (000275C6) --------------------------------------------------------
int bring_up_all_chain()
{
  int ret; // [sp+0h] [bp+0h]
  int chain; // [sp+4h] [bp+4h]

  ret = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      ret |= bring_up_chain(chain, 1);
  }
  return ret;
}

//----- (00027616) --------------------------------------------------------
int check_pool_worker()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  int ret; // [sp+14h] [bp+Ch]
  int valid_pool; // [sp+18h] [bp+10h]
  int pool; // [sp+1Ch] [bp+14h]

  valid_pool = 0;
  ret = 0;
  for ( pool = 0; pool < total_pools; ++pool )
  {
    if ( *pools[pool]->rpc_url )
    {
      if ( *pools[pool]->rpc_user )
      {
        ++valid_pool;
      }
      else if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: Blank worker exists.\n", "driver-btm-soc.c", 6277, (const char *)_FUNCTION___16487);
        fclose(pFile);
      }
    }
  }
  if ( !valid_pool )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: No valid pools, please configure them first!\n",
          "driver-btm-soc.c",
          6284,
          (const char *)_FUNCTION___16487);
      fclose(pFile_0);
    }
    return -1;
  }
  return ret;
}

//----- (0002776A) --------------------------------------------------------
int check_pool_for_validation()
{
  return 0;
}

//----- (0002777A) --------------------------------------------------------
int check_fan_num()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  int ret; // [sp+10h] [bp+8h]
  int retry_times; // [sp+14h] [bp+Ch]

  retry_times = 3;
  do
  {
    set_PWM(0x64u);
    ret = check_fan();
    if ( ret > 1 )
      return 0;
    sleep(1u);
  }
  while ( retry_times-- );
  freq_scan_error_code_set(10, 0);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: FETAL ERROR! %d Fan detected!\n",
        "driver-btm-soc.c",
        6343,
        (const char *)_FUNCTION___16502,
        ret);
    fclose(pFile);
  }
  return -1;
}

//----- (0002782C) --------------------------------------------------------
void init_pulse_mode()
{
  g_pulse_mode = g_device_minor_type && g_device_minor_type != PKG_B_BGM;
}

//----- (00027870) --------------------------------------------------------
bool need_mode2_startup()
{
  double v0; // d0
  float v1; // s15
  uint32_t chain_ideal_hash_rate; // [sp+18h] [bp+0h] BYREF
  FILE *pFile_0; // [sp+1Ch] [bp+4h]
  FILE *pFile; // [sp+20h] [bp+8h]
  float chain_rt_hash_rate; // [sp+24h] [bp+Ch]
  bool mode0_failed; // [sp+2Bh] [bp+13h]
  int chain; // [sp+2Ch] [bp+14h]

  mode0_failed = 0;
  for ( chain = 0; chain < dev->chain_num; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      atof((const char *)displayed_rate[chain]);
      v1 = v0;
      chain_rt_hash_rate = v1;
      eeprom_get_hashrate_mode2(chain, &chain_ideal_hash_rate);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain %d rt_hash_rate %.2f ideal_hash_rate %d\n",
            "driver-btm-soc.c",
            6372,
            (const char *)_FUNCTION___16512,
            chain,
            chain_rt_hash_rate,
            chain_ideal_hash_rate);
        fclose(pFile);
      }
      if ( chain_rt_hash_rate < (float)(chain_ideal_hash_rate >> 1) )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: chain %d startup failed\n",
              "driver-btm-soc.c",
              6375,
              (const char *)_FUNCTION___16512,
              chain);
          fclose(pFile_0);
        }
        mode0_failed = 1;
      }
    }
  }
  return mode0_failed;
}
// 278B4: variable 'v0' is possibly undefined

//----- (00027A00) --------------------------------------------------------
int __cdecl bitmain_soc_init(init_config config)
{
  double v1; // d0
  const char *v2; // r3
  int dhash_acc_control; // r0
  int v5; // r0
  float v6; // r1
  float v7; // r2
  uint32_t *v8; // r3
  sysinfo si; // [sp+10h] [bp+0h] BYREF
  FILE *pFile_8; // [sp+50h] [bp+40h]
  FILE *pFile_9; // [sp+54h] [bp+44h]
  FILE *pFile_10; // [sp+58h] [bp+48h]
  FILE *pFile_17; // [sp+5Ch] [bp+4Ch]
  FILE *pFile_18; // [sp+60h] [bp+50h]
  FILE *pFile_19; // [sp+64h] [bp+54h]
  FILE *pFile_20; // [sp+68h] [bp+58h]
  FILE *pFile_21; // [sp+6Ch] [bp+5Ch]
  FILE *pFile_16; // [sp+70h] [bp+60h]
  FILE *pFile_15; // [sp+74h] [bp+64h]
  FILE *pFile_14; // [sp+78h] [bp+68h]
  FILE *pFile_13; // [sp+7Ch] [bp+6Ch]
  FILE *pFile_12; // [sp+80h] [bp+70h]
  FILE *pFile_11; // [sp+84h] [bp+74h]
  FILE *pFile_7; // [sp+88h] [bp+78h]
  FILE *pFile_4; // [sp+8Ch] [bp+7Ch]
  FILE *pFile_5; // [sp+90h] [bp+80h]
  FILE *pFile_6; // [sp+94h] [bp+84h]
  FILE *pFile_3; // [sp+98h] [bp+88h]
  FILE *pFile_1; // [sp+9Ch] [bp+8Ch]
  FILE *pFile_2; // [sp+A0h] [bp+90h]
  FILE *pFile_0; // [sp+A4h] [bp+94h]
  FILE *pFile; // [sp+A8h] [bp+98h]
  unsigned __int8 *initlogfile; // [sp+ACh] [bp+9Ch]
  int ret; // [sp+B0h] [bp+A0h]
  uint16_t crc; // [sp+B6h] [bp+A6h]
  int offset; // [sp+B8h] [bp+A8h]
  float max_freq; // [sp+BCh] [bp+ACh]
  int y; // [sp+C0h] [bp+B0h]
  int x; // [sp+C4h] [bp+B4h]

  crc = 0;
  x = 0;
  y = 0;
  ret = 0;
  initlogfile = "/tmp/initlog";
  opt_multi_version = 1;
  set_privite_log_file("/tmp/initlog", &init_log_bak);
  log_init();
  aging_get_info();
  freq_mode = 2;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: This is %s fix freq version\n",
        "driver-btm-soc.c",
        6404,
        (const char *)_FUNCTION___16527,
        (const char *)g_miner_type);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
    {
      if ( is_special_mode() )
        v2 = "enabled";
      else
        v2 = "disabled";
      fprintf(pFile_0, "%s:%d:%s: special mode: %s\n", "driver-btm-soc.c", 6407, (const char *)_FUNCTION___16527, v2);
    }
    fclose(pFile_0);
  }
  if ( is_economic_mode() )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%s:%d:%s: This is economic mode\n", "driver-btm-soc.c", 6410, (const char *)_FUNCTION___16527);
      fclose(pFile_1);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(
        pFile_2,
        "%s:%d:%s: This is high performance mode\n",
        "driver-btm-soc.c",
        6414,
        (const char *)_FUNCTION___16527);
    fclose(pFile_2);
  }
  show_mode();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s: last commit version: 2f40e5d commit time: 2019-06-25 15:53:07 build: 2019-06-25 16:07:18\n",
        "driver-btm-soc.c",
        6419,
        (const char *)_FUNCTION___16527);
    fclose(pFile_3);
  }
  sysinfo_0(&si);
  if ( si.totalram <= 0x3B9ACA00 )
  {
    if ( si.totalram <= 0x1DCD6500 )
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 251658240;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: Detect 256MB control board of XILINX\n",
            "driver-btm-soc.c",
            6440,
            (const char *)_FUNCTION___16527);
        fclose(pFile_6);
      }
    }
    else
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 520093696;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: Detect 512MB control board of XILINX\n",
            "driver-btm-soc.c",
            6434,
            (const char *)_FUNCTION___16527);
        fclose(pFile_5);
      }
    }
  }
  else
  {
    PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(
          pFile_4,
          "%s:%d:%s: Detect 1GB control board of XILINX\n",
          "driver-btm-soc.c",
          6428,
          (const char *)_FUNCTION___16527);
      fclose(pFile_4);
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_7 = fopen((const char *)log_file, "a+");
    if ( pFile_7 )
      fprintf(
        pFile_7,
        "%s:%d:%s: Miner compile time: %s type: %s\n",
        "driver-btm-soc.c",
        6443,
        (const char *)_FUNCTION___16527,
        (const char *)g_miner_compiletime,
        (const char *)g_miner_type);
    fclose(pFile_7);
  }
  config_parameter = config;
  if ( config.token_type == 81 )
  {
    crc = CRC16(&config_parameter.token_type, 0x1Eu);
    if ( crc == config_parameter.crc )
    {
      ret = bitmain_axi_init();
      if ( ret )
      {
        return ret;
      }
      else
      {
        ret = check_pool_worker();
        if ( ret )
        {
          return ret;
        }
        else
        {
          ret = check_pool_for_validation();
          if ( ret )
          {
            return ret;
          }
          else
          {
            StartHttpThread();
            ret = check_fan_num();
            if ( ret )
            {
              return ret;
            }
            else
            {
              ret = check_chain();
              if ( !ret || dev->chain_num && freq_mode && freq_mode != 2 )
              {
                ret = eeprom_date_check();
                if ( !ret || dev->chain_num && freq_mode && freq_mode != 2 )
                {
                  ret = check_hashboard_hardware_info();
                  if ( ret )
                  {
                    return ret;
                  }
                  else
                  {
                    init_sweep_config();
                    init_pulse_mode();
                    if ( is_force_mode() )
                    {
                      if ( is_column_sweep() )
                      {
                        ret = sweep_freq_by_column();
                        if ( ret )
                          return ret;
                      }
                      else if ( is_board_sweep() )
                      {
                        boardsweep_task();
                      }
                      else
                      {
                        scan_freq_scan_by_column();
                      }
                      if ( is_scan_freq_trigged_and_succeeded() )
                      {
                        clear_probability_file();
                        remove("/nvdata/high_temp_assert_history");
                      }
                    }
                    else
                    {
                      scan_freq_mark_success();
                    }
                    if ( !is_fixed_mode() )
                    {
                      if ( enable_get_freq_from_eeprom )
                        get_freq_result_from_eeprom();
                      else
                        get_freq_result(config_parameter.frequency);
                    }
                    read_nonce_reg_id = (thr_info *)calloc(1u, 0x40u);
                    if ( thr_info_create(
                           read_nonce_reg_id,
                           0,
                           (void *(*)(void *))get_nonce_and_register,
                           read_nonce_reg_id) )
                    {
                      if ( log_level > 4 )
                      {
                        print_crt_time_to_file(log_file, 4u);
                        pFile_10 = fopen((const char *)log_file, "a+");
                        if ( pFile_10 )
                          fprintf(
                            pFile_10,
                            "%s:%d:%s: create thread for get nonce and register from FPGA failed\n",
                            "driver-btm-soc.c",
                            6526,
                            (const char *)_FUNCTION___16527);
                        fclose(pFile_10);
                      }
                      return -5;
                    }
                    else
                    {
                      pthread_detach(read_nonce_reg_id->pth);
                      if ( (*((_BYTE *)&config_parameter + 4) & 1) != 0 )
                      {
                        if ( log_level > 3 )
                        {
                          print_crt_time_to_file(log_file, 3u);
                          pFile_11 = fopen((const char *)log_file, "a+");
                          if ( pFile_11 )
                            fprintf(
                              pFile_11,
                              "%s:%d:%s: reset all...\n",
                              "driver-btm-soc.c",
                              6534,
                              (const char *)_FUNCTION___16527);
                          fclose(pFile_11);
                        }
                        set_QN_write_data_command(0x8080800F);
                        sleep(2u);
                        set_PWM(0x64u);
                      }
                      set_Hardware_version(0x40000000u);
                      read_fpga_id(FPGA_ID_str);
                      if ( log_level > 3 )
                      {
                        print_crt_time_to_file(log_file, 3u);
                        pFile_12 = fopen((const char *)log_file, "a+");
                        if ( pFile_12 )
                          fprintf(
                            pFile_12,
                            "%s:%d:%s: miner ID : %s\n",
                            "driver-btm-soc.c",
                            6542,
                            (const char *)_FUNCTION___16527,
                            (const char *)FPGA_ID_str);
                        fclose(pFile_12);
                      }
                      init_miner_version();
                      dev->baud = 26;
                      set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
                      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
                      set_PWM(0x64u);
                      sleep(1u);
                      ret = init_pic();
                      if ( !ret || dev->chain_num && freq_mode && freq_mode != 2 )
                      {
                        get_pic_software_version_all_chain();
                        power_init();
                        init_working_voltage();
                        update_highest_voltage();
                        ret = set_iic_power_to_highest_voltage();
                        if ( ret )
                        {
                          return ret;
                        }
                        else
                        {
                          get_ideal_hash_rate();
                          if ( !is_fixed_mode() )
                            eeprom_dump();
                          if ( (unsigned __int8)is_T11() != 1 && log_level > 3 )
                          {
                            print_crt_time_to_file(log_file, 3u);
                            pFile_13 = fopen((const char *)log_file, "a+");
                            if ( pFile_13 )
                            {
                              get_average_voltage();
                              fprintf(
                                pFile_13,
                                "%s:%d:%s: the current avg vol is %5.2f\n",
                                "driver-btm-soc.c",
                                6574,
                                (const char *)_FUNCTION___16527,
                                v1);
                            }
                            fclose(pFile_13);
                          }
                          if ( (*((_BYTE *)&config_parameter + 4) & 8) != 0 )
                          {
                            dev->frequency = config_parameter.frequency;
                            sprintf((char *)dev->frequency_t, "%u", dev->frequency);
                          }
                          dev->fan_eft = (*((_BYTE *)&config_parameter + 4) & 2) != 0;
                          dev->fan_pwm = config_parameter.fan_pwm_percent;
                          if ( log_level > 3 )
                          {
                            print_crt_time_to_file(log_file, 3u);
                            pFile_14 = fopen((const char *)log_file, "a+");
                            if ( pFile_14 )
                              fprintf(
                                pFile_14,
                                "%s:%d:%s: fan_eft : %d  fan_pwm : %d\n",
                                "driver-btm-soc.c",
                                6585,
                                (const char *)_FUNCTION___16527,
                                dev->fan_eft,
                                dev->fan_pwm);
                            fclose(pFile_14);
                          }
                          if ( opt_multi_version )
                          {
                            dhash_acc_control = get_dhash_acc_control();
                            set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
                          }
                          cgsleep_ms(10);
                          init_address_info();
                          set_default_uart_baud();
                          ret = bring_up_all_chain();
                          if ( !ret || dev->chain_num && freq_mode && freq_mode != 2 )
                          {
                            set_working_uart_baud();
                            set_iic_for_temperature();
                            if ( log_level > 3 )
                            {
                              print_crt_time_to_file(log_file, 3u);
                              pFile_15 = fopen((const char *)log_file, "a+");
                              if ( pFile_15 )
                                fprintf(
                                  pFile_15,
                                  "%s:%d:%s: set TICKET_MASK\n",
                                  "driver-btm-soc.c",
                                  6600,
                                  (const char *)_FUNCTION___16527);
                              fclose(pFile_15);
                            }
                            set_asic_ticket_mask(ticket_mask);
                            cgsleep_ms(10);
                            detect_environment_temperature();
                            set_clock_delay_control(All_Chain, g_pulse_mode);
                            open_core_bm1393(1, All_Chain);
                            max_freq = 0.0;
                            v5 = is_fixed_mode();
                            if ( v5 )
                            {
                              if ( g_freq_test )
                                set_adjust_freq();
                              else
                                set_target_freq(v5, v6, v7);
                              max_freq = *(float *)&v1;
                            }
                            else
                            {
                              max_freq = (float)increase_freq_by_eeprom_slowly((int)init_freq, (int)freq_step);
                            }
                            if ( log_level > 3 )
                            {
                              print_crt_time_to_file(log_file, 3u);
                              pFile_16 = fopen((const char *)log_file, "a+");
                              if ( pFile_16 )
                                fprintf(
                                  pFile_16,
                                  "%s:%d:%s: set to working voltage...\n",
                                  "driver-btm-soc.c",
                                  6625,
                                  (const char *)_FUNCTION___16527);
                              fclose(pFile_16);
                            }
                            slowly_set_iic_power_to_working_voltage();
                            set_timeout((int)max_freq, 50);
                            for ( x = 0; x <= 15; ++x )
                            {
                              if ( dev->chain_exist[x] )
                              {
                                offset = 0;
                                for ( y = 0; y < dev->chain_asic_num[x]; ++y )
                                {
                                  if ( (y & 7) == 0 )
                                    dev->chain_asic_status_string[x][y + offset++] = 32;
                                  dev->chain_asic_status_string[x][y + offset] = 111;
                                  v8 = &dev->chain_hw[256 * x + 15 + 2 * y];
                                  v8[1] = 0;
                                  v8[2] = 0;
                                }
                                dev->chain_asic_status_string[x][y + offset] = 0;
                              }
                            }
                            low_temp_process_parm_init();
                            read_temp_id = (thr_info *)calloc(1u, 0x40u);
                            if ( thr_info_create(read_temp_id, 0, (void *(*)(void *))read_temp_func, read_temp_id) )
                            {
                              if ( log_level > 3 )
                              {
                                print_crt_time_to_file(log_file, 3u);
                                pFile_17 = fopen((const char *)log_file, "a+");
                                if ( pFile_17 )
                                  fprintf(
                                    pFile_17,
                                    "%s:%d:%s: create thread for read temp\n",
                                    "driver-btm-soc.c",
                                    6659,
                                    (const char *)_FUNCTION___16527);
                                fclose(pFile_17);
                              }
                              return -7;
                            }
                            else
                            {
                              pthread_detach(read_temp_id->pth);
                              cgtime(&tv_send_job);
                              cgtime(&tv_send);
                              startCheckNetworkJob = 1;
                              read_hash_rate = (thr_info *)calloc(1u, 0x40u);
                              if ( thr_info_create(read_hash_rate, 0, (void *(*)(void *))get_hash_rate, read_hash_rate) )
                              {
                                if ( log_level > 3 )
                                {
                                  print_crt_time_to_file(log_file, 3u);
                                  pFile_18 = fopen((const char *)log_file, "a+");
                                  if ( pFile_18 )
                                    fprintf(
                                      pFile_18,
                                      "%s:%d:%s: create thread for get hashrate from asic failed\n",
                                      "driver-btm-soc.c",
                                      6670,
                                      (const char *)_FUNCTION___16527);
                                  fclose(pFile_18);
                                }
                                return -6;
                              }
                              else
                              {
                                pthread_detach(read_hash_rate->pth);
                                check_system_work_id = (thr_info *)calloc(1u, 0x40u);
                                if ( thr_info_create(
                                       check_system_work_id,
                                       0,
                                       (void *(*)(void *))check_system_work,
                                       check_system_work_id) )
                                {
                                  if ( log_level > 3 )
                                  {
                                    print_crt_time_to_file(log_file, 3u);
                                    pFile_19 = fopen((const char *)log_file, "a+");
                                    if ( pFile_19 )
                                      fprintf(
                                        pFile_19,
                                        "%s:%d:%s: create thread for check system\n",
                                        "driver-btm-soc.c",
                                        6678,
                                        (const char *)_FUNCTION___16527);
                                    fclose(pFile_19);
                                  }
                                  return -6;
                                }
                                else
                                {
                                  pthread_detach(check_system_work_id->pth);
                                  store_hash_rate_id = (thr_info *)calloc(1u, 0x40u);
                                  if ( thr_info_create(
                                         store_hash_rate_id,
                                         0,
                                         (void *(*)(void *))store_hash_rate,
                                         store_hash_rate_id) )
                                  {
                                    if ( log_level > 3 )
                                    {
                                      print_crt_time_to_file(log_file, 3u);
                                      pFile_20 = fopen((const char *)log_file, "a+");
                                      if ( pFile_20 )
                                        fprintf(
                                          pFile_20,
                                          "%s:%d:%s: create thread for store hashrate history\n",
                                          "driver-btm-soc.c",
                                          6687,
                                          (const char *)_FUNCTION___16527);
                                      fclose(pFile_20);
                                    }
                                    return -6;
                                  }
                                  else
                                  {
                                    pthread_detach(store_hash_rate_id->pth);
                                    cgsleep_ms(500);
                                    setStartTimePoint();
                                    if ( log_level > 3 )
                                    {
                                      print_crt_time_to_file(log_file, 3u);
                                      pFile_21 = fopen((const char *)log_file, "a+");
                                      if ( pFile_21 )
                                        fprintf(
                                          pFile_21,
                                          "%s:%d:%s: Init done!\n",
                                          "driver-btm-soc.c",
                                          6694,
                                          (const char *)_FUNCTION___16527);
                                      fclose(pFile_21);
                                    }
                                    restore_syslog_file(&init_log_bak);
                                    return 0;
                                  }
                                }
                              }
                            }
                          }
                          else
                          {
                            return ret;
                          }
                        }
                      }
                      else
                      {
                        return ret;
                      }
                    }
                  }
                }
                else
                {
                  return ret;
                }
              }
              else
              {
                return ret;
              }
            }
          }
        }
      }
    }
    else
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_9 = fopen((const char *)log_file, "a+");
        if ( pFile_9 )
          fprintf(
            pFile_9,
            "%s:%d:%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
            "driver-btm-soc.c",
            6454,
            (const char *)_FUNCTION___16527,
            config_parameter.crc,
            crc);
        fclose(pFile_9);
      }
      return -2;
    }
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(
          pFile_8,
          "%s:%d:%s: config_parameter.token_type != 0x%x, it is 0x%x\n",
          "driver-btm-soc.c",
          6447,
          (const char *)_FUNCTION___16527,
          81,
          config_parameter.token_type);
      fclose(pFile_8);
    }
    return -1;
  }
}
// 28526: variable 'v1' is possibly undefined
// 287C6: variable 'v6' is possibly undefined
// 287C6: variable 'v7' is possibly undefined

//----- (00028D78) --------------------------------------------------------
int __cdecl re_open_core(int fan_pwm)
{
  double v1; // d0
  unsigned int crc_count; // r0
  int dhash_acc_control; // r0
  int v4; // r0
  float v5; // r1
  float v6; // r2
  uint32_t *v7; // r3
  FILE *pFile_3; // [sp+20h] [bp+8h]
  FILE *pFile_4; // [sp+24h] [bp+Ch]
  FILE *pFile_9; // [sp+28h] [bp+10h]
  FILE *pFile_8; // [sp+2Ch] [bp+14h]
  FILE *pFile_7; // [sp+30h] [bp+18h]
  FILE *pFile_6; // [sp+34h] [bp+1Ch]
  FILE *pFile_5; // [sp+38h] [bp+20h]
  FILE *pFile_2; // [sp+3Ch] [bp+24h]
  FILE *pFile_1; // [sp+40h] [bp+28h]
  FILE *pFile_0; // [sp+44h] [bp+2Ch]
  FILE *pFile; // [sp+48h] [bp+30h]
  int offset; // [sp+4Ch] [bp+34h]
  float max_freq; // [sp+50h] [bp+38h]
  int retry_count; // [sp+54h] [bp+3Ch]
  int y; // [sp+58h] [bp+40h]
  int x; // [sp+5Ch] [bp+44h]

  for ( retry_count = 0; ; ++retry_count )
  {
    if ( log_level > 3 )
    {
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fputc(10, pFile);
      fclose(pFile);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: re_open_core start!PWM %d\n",
          "driver-btm-soc.c",
          6708,
          (const char *)_FUNCTION___16567,
          fan_pwm);
      fclose(pFile_0);
    }
    b_is_re_open_core = 1;
    startCheckNetworkJob = 0;
    pthread_mutex_lock(&reinit_mutex);
    pthread_mutex_lock(&reopen_core);
    set_PWM(fan_pwm);
    if ( freq_mode != 2 )
      get_freq_result_from_eeprom();
    get_ideal_hash_rate();
    if ( (*((_BYTE *)&config_parameter + 4) & 1) != 0 )
    {
      set_QN_write_data_command(0x8080800F);
      sleep(2u);
      set_PWM(fan_pwm);
    }
    set_Hardware_version(0x40000000u);
    read_fpga_id(FPGA_ID_str);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: miner ID : %s\n",
          "driver-btm-soc.c",
          6735,
          (const char *)_FUNCTION___16567,
          (const char *)FPGA_ID_str);
      fclose(pFile_1);
    }
    init_miner_version();
    set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
    set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
    dev->baud = 26;
    check_chain();
    set_PWM(fan_pwm);
    init_pic();
    update_highest_voltage();
    set_iic_power_to_highest_voltage();
    if ( (unsigned __int8)is_T11() != 1 )
    {
      enable_crab_circuit();
      sleep(1u);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
        {
          get_average_voltage();
          crc_count = get_crc_count();
          fprintf(
            pFile_2,
            "%s:%d:%s: the current avg vol is %5.2f, crc = %d\n",
            "driver-btm-soc.c",
            6756,
            (const char *)_FUNCTION___16567,
            v1,
            crc_count);
        }
        fclose(pFile_2);
      }
    }
    if ( opt_multi_version )
    {
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
    }
    cgsleep_ms(10);
    init_address_info();
    set_default_uart_baud();
    set_baud(0x1Au, 0);
    bring_up_all_chain();
    set_working_uart_baud();
    set_iic_for_temperature();
    if ( dev->chain_num )
      break;
    if ( retry_count > 2 )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "Assert fail!! %s:%d: Cannot find all asic.", "driver-btm-soc.c", 6783);
      fclose(pFile_4);
      _assert_fail("0", "driver-btm-soc.c", 0x1A7Fu, (const char *)_PRETTY_FUNCTION___16573);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: chain num is 0, retry for %d times\n",
          "driver-btm-soc.c",
          6775,
          (const char *)_FUNCTION___16567,
          retry_count);
      fclose(pFile_3);
    }
    pthread_mutex_unlock(&reopen_core);
    pthread_mutex_unlock(&reinit_mutex);
  }
  if ( retry_count > 0 && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fprintf(
        pFile_5,
        "%s:%d:%s: find asic success after retry for %d times\n",
        "driver-btm-soc.c",
        6790,
        (const char *)_FUNCTION___16567,
        retry_count);
    fclose(pFile_5);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_6 = fopen((const char *)log_file, "a+");
    if ( pFile_6 )
      fprintf(pFile_6, "%s:%d:%s: set TICKET_MASK\n", "driver-btm-soc.c", 6796, (const char *)_FUNCTION___16567);
    fclose(pFile_6);
  }
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms(10);
  set_clock_delay_control(All_Chain, g_pulse_mode);
  open_core_bm1393(1, All_Chain);
  if ( is_economic_mode() && !fan_pwm && !is_column_sweep() && !is_board_sweep() )
    low_temperature_freq_handler();
  v4 = is_fixed_mode();
  if ( v4 )
  {
    if ( g_freq_test )
      set_adjust_freq();
    else
      set_target_freq(v4, v5, v6);
    max_freq = *(float *)&v1;
  }
  else
  {
    max_freq = (float)increase_freq_by_eeprom_slowly((int)init_freq, (int)freq_step);
  }
  set_timeout((int)max_freq, 50);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_7 = fopen((const char *)log_file, "a+");
    if ( pFile_7 )
      fprintf(
        pFile_7,
        "%s:%d:%s: set to working voltage...\n",
        "driver-btm-soc.c",
        6823,
        (const char *)_FUNCTION___16567);
    fclose(pFile_7);
  }
  slowly_set_iic_power_to_working_voltage();
  for ( x = 0; x <= 15; ++x )
  {
    if ( dev->chain_exist[x] )
    {
      offset = 0;
      for ( y = 0; y < dev->chain_asic_num[x]; ++y )
      {
        if ( (y & 7) == 0 )
          dev->chain_asic_status_string[x][y + offset++] = 32;
        dev->chain_asic_status_string[x][y + offset] = 111;
        v7 = &dev->chain_hw[256 * x + 15 + 2 * y];
        v7[1] = 0;
        v7[2] = 0;
      }
      dev->chain_asic_status_string[x][y + offset] = 0;
    }
  }
  read_temp_and_get_statistics();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fprintf(
        pFile_8,
        "%s:%d:%s: reopen finished pcb temp is %d - %d, chip temp %d - %d\n",
        "driver-btm-soc.c",
        6853,
        (const char *)_FUNCTION___16567,
        last_testpatten_lowest_pcb_temp,
        last_testpatten_highest_pcb_temp,
        last_testpatten_lowest_chip_temp,
        last_testpatten_highest_chip_temp);
    fclose(pFile_8);
  }
  pthread_mutex_unlock(&reopen_core);
  pthread_mutex_unlock(&reinit_mutex);
  re_send_last_job();
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  startCheckNetworkJob = 1;
  cgsleep_ms(500);
  b_is_re_open_core = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_9 = fopen((const char *)log_file, "a+");
    if ( pFile_9 )
      fprintf(pFile_9, "%s:%d:%s: re_open_core done!\n", "driver-btm-soc.c", 6870, (const char *)_FUNCTION___16567);
    fclose(pFile_9);
  }
  if ( (unsigned __int8)is_T11() != 1 )
    disable_crab_circuit();
  return 0;
}
// 29026: variable 'v1' is possibly undefined
// 29314: variable 'v5' is possibly undefined
// 29314: variable 'v6' is possibly undefined

//----- (00029658) --------------------------------------------------------
int __cdecl re_open_core_by_chain(int fan_pwm, int chain, bool is_low_temp)
{
  int dhash_acc_control; // r0
  double v4; // r2
  int v5; // r0
  float v6; // r1
  float v7; // r2
  FILE *pFile_4; // [sp+2Ch] [bp+14h]
  FILE *pFile_3; // [sp+30h] [bp+18h]
  FILE *pFile_2; // [sp+34h] [bp+1Ch]
  FILE *pFile_1; // [sp+38h] [bp+20h]
  FILE *pFile_0; // [sp+3Ch] [bp+24h]
  FILE *pFile; // [sp+40h] [bp+28h]
  float max_freq; // [sp+44h] [bp+2Ch]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: \nre_open_core start!PWM %d\n",
        "driver-btm-soc.c",
        6882,
        (const char *)_FUNCTION___16593,
        fan_pwm);
    fclose(pFile);
  }
  b_is_re_open_core = 1;
  startCheckNetworkJob = 0;
  pthread_mutex_lock(&reinit_mutex);
  pthread_mutex_lock(&reopen_core);
  set_QN_write_data_command(0x8080800F);
  sleep(2u);
  set_Hardware_version(0x40000000u);
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  set_PWM(fan_pwm);
  dev->baud = 26;
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
  cgsleep_ms(10);
  HIDWORD(v4) = (unsigned __int8)chain;
  set_highest_voltage_by_chain(chain, v4);
  set_iic_power_to_highest_voltage_by_chain(chain);
  init_address_info();
  set_default_uart_baud();
  set_baud_by_chain(0x1Au, chain);
  bring_up_chain(chain, 1);
  set_baud_by_chain(1u, chain);
  set_iic_for_temperature_by_chain(chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: set TICKET_MASK\n", "driver-btm-soc.c", 6916, (const char *)_FUNCTION___16593);
    fclose(pFile_0);
  }
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms(10);
  set_clock_delay_control(chain, g_pulse_mode);
  open_core_bm1393(1, chain);
  memset(dev->chain_exist, 0, sizeof(dev->chain_exist));
  dev->chain_exist[chain] = 1;
  dev->chain_num = 1;
  v5 = is_fixed_mode();
  if ( v5 )
  {
    if ( g_freq_test )
      set_adjust_freq();
    else
      set_target_freq(v5, v6, v7);
    max_freq = 3.6893e19;
  }
  else
  {
    max_freq = (float)increase_freq_by_eeprom_slowly((int)init_freq, (int)freq_step);
  }
  set_timeout((int)max_freq, 50);
  check_chain();
  read_temp_and_get_statistics();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: reopen chain %d finished, chain %d chip temp %d - %d\n",
        "driver-btm-soc.c",
        6948,
        (const char *)_FUNCTION___16593,
        chain,
        chain,
        dev->chain_asic_mintemp[chain][1],
        dev->chain_asic_maxtemp[chain][1]);
    fclose(pFile_1);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(
        pFile_2,
        "%s:%d:%s: all chain chip temp %d - %d\n",
        "driver-btm-soc.c",
        6950,
        (const char *)_FUNCTION___16593,
        last_testpatten_lowest_chip_temp,
        last_testpatten_highest_chip_temp);
    fclose(pFile_2);
  }
  pthread_mutex_unlock(&reopen_core);
  if ( !is_low_temp )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: set to working voltage...\n",
          "driver-btm-soc.c",
          6956,
          (const char *)_FUNCTION___16593);
      fclose(pFile_3);
    }
    slowly_set_iic_power_to_working_voltage_by_chain(chain);
  }
  pthread_mutex_unlock(&reinit_mutex);
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  startCheckNetworkJob = 1;
  cgsleep_ms(500);
  b_is_re_open_core = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(pFile_4, "%s:%d:%s: re_open_core done!\n", "driver-btm-soc.c", 6970, (const char *)_FUNCTION___16593);
    fclose(pFile_4);
  }
  return 0;
}
// 29788: variable 'v4' is possibly undefined
// 298C4: variable 'v6' is possibly undefined
// 298C4: variable 'v7' is possibly undefined

//----- (00029B94) --------------------------------------------------------
bool is_re_open_core_now()
{
  return b_is_re_open_core;
}

//----- (00029BAC) --------------------------------------------------------
int __cdecl parse_job_to_soc(unsigned __int8 **buf, pool *pool, uint32_t id)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+10h] BYREF
  part_of_job part_job; // [sp+810h] [bp+810h] BYREF
  uint64_t nonce2; // [sp+868h] [bp+868h] BYREF
  uint16_t crc; // [sp+872h] [bp+872h]
  unsigned __int8 *tmp_buf; // [sp+874h] [bp+874h]
  uint32_t buf_len; // [sp+878h] [bp+878h]
  int i; // [sp+87Ch] [bp+87Ch]

  crc = 0;
  buf_len = 0;
  nonce2 = 0LL;
  part_job.token_type = 82;
  part_job.version = 0;
  part_job.pool_nu = pool_send_nu_16613;
  *((_BYTE *)&part_job + 9) = *((_BYTE *)&part_job + 9) & 0xFE | pool->swork.clean | 2;
  part_job.asic_diff = 15;
  part_job.job_id = id;
  part_job.support_ab = pool->support_ab;
  part_job.version_num = pool->version_num;
  hex2bin((unsigned __int8 *)&part_job.bbversion, pool->bbversion, 4u);
  hex2bin(part_job.prev_hash, pool->prev_hash, 0x20u);
  hex2bin((unsigned __int8 *)&part_job.nbit, pool->nbit, 4u);
  hex2bin((unsigned __int8 *)&part_job.ntime, pool->ntime, 4u);
  part_job.coinbase_len = pool->coinbase_len;
  part_job.nonce2_offset = pool->nonce2_offset;
  part_job.nonce2_bytes_num = pool->n2size;
  nonce2 = _uint64_identity(pool->nonce2);
  memcpy(&part_job.nonce2_start_value, &pool->coinbase[pool->nonce2_offset], sizeof(part_job.nonce2_start_value));
  memcpy(&part_job.nonce2_start_value, &nonce2, pool->n2size);
  part_job.merkles_num = pool->merkles;
  buf_len = pool->coinbase_len + 32 * pool->merkles + 90;
  tmp_buf = (unsigned __int8 *)malloc(buf_len);
  if ( !tmp_buf )
  {
    strcpy((char *)tmp42, "Failed to malloc tmp_buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  part_job.length = buf_len - 8;
  memset(tmp_buf, 0, buf_len);
  memcpy(tmp_buf, &part_job, 0x58u);
  memcpy(tmp_buf + 88, pool->coinbase, pool->coinbase_len);
  for ( i = 0; i < pool->merkles; ++i )
    memcpy(&tmp_buf[32 * i + 88 + pool->coinbase_len], pool->swork.merkle_bin[i], 0x20u);
  crc = CRC16(tmp_buf, buf_len - 2);
  *(_WORD *)&tmp_buf[buf_len - 2] = crc;
  ++pool_send_nu_16613;
  *buf = (unsigned __int8 *)malloc(buf_len);
  if ( !tmp_buf )
  {
    strcpy((char *)tmp42, "Failed to malloc buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  memcpy(*buf, tmp_buf, buf_len);
  memcpy(last_job_buffer, tmp_buf, buf_len);
  free(tmp_buf);
  return buf_len;
}

//----- (00029F2C) --------------------------------------------------------
int __cdecl send_job(unsigned __int8 *buf, pool *pool)
{
  int dhash_acc_control; // r0
  int nonce_fifo_interrupt; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  unsigned int buf2[32]; // [sp+24h] [bp+Ch] BYREF
  FILE *pFile_0; // [sp+A4h] [bp+8Ch]
  FILE *pFile_2; // [sp+A8h] [bp+90h]
  FILE *pFile_5; // [sp+ACh] [bp+94h]
  FILE *pFile_9; // [sp+B0h] [bp+98h]
  FILE *pFile_12; // [sp+B4h] [bp+9Ch]
  FILE *pFile_13; // [sp+B8h] [bp+A0h]
  FILE *pFile_11; // [sp+BCh] [bp+A4h]
  FILE *pFile_10; // [sp+C0h] [bp+A8h]
  FILE *pFile_7; // [sp+C4h] [bp+ACh]
  FILE *pFile_8; // [sp+C8h] [bp+B0h]
  FILE *pFile_6; // [sp+CCh] [bp+B4h]
  FILE *pFile_4; // [sp+D0h] [bp+B8h]
  FILE *pFile_3; // [sp+D4h] [bp+BCh]
  FILE *pFile_1; // [sp+D8h] [bp+C0h]
  FILE *pFile; // [sp+DCh] [bp+C4h]
  part_of_job *part_job; // [sp+E0h] [bp+C8h]
  unsigned __int8 *coinbase_padding; // [sp+E4h] [bp+CCh]
  unsigned __int8 *temp_buf; // [sp+E8h] [bp+D0h]
  unsigned __int16 job_length; // [sp+EEh] [bp+D6h]
  unsigned int j; // [sp+F0h] [bp+D8h]
  unsigned int len; // [sp+F4h] [bp+DCh]
  int times; // [sp+F8h] [bp+E0h]
  unsigned __int8 *merkles_bin; // [sp+FCh] [bp+E4h]
  unsigned int coinbase_padding_len; // [sp+100h] [bp+E8h]
  unsigned int i; // [sp+104h] [bp+ECh]
  int v37; // [sp+108h] [bp+F0h] BYREF

  len = 0;
  i = 0;
  j = 0;
  coinbase_padding_len = 0;
  job_length = 0;
  temp_buf = 0;
  coinbase_padding = 0;
  merkles_bin = 0;
  memset(buf2, 0, sizeof(buf2));
  times = 0;
  part_job = 0;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: doTestPatten value %d\n",
        "driver-btm-soc.c",
        7058,
        (const char *)_FUNCTION___16637,
        doTestPatten);
    fclose(pFile);
  }
  if ( doTestPatten )
    return 0;
  if ( *buf != 82 )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: SEND_JOB_TYPE is wrong : 0x%x\n",
          "driver-btm-soc.c",
          7064,
          (const char *)_FUNCTION___16637,
          *buf);
      fclose(pFile_0);
    }
    return -1;
  }
  len = *((_DWORD *)buf + 1);
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: len = 0x%x\n", "driver-btm-soc.c", 7069, (const char *)_FUNCTION___16637, len);
    fclose(pFile_1);
  }
  temp_buf = (unsigned __int8 *)malloc(len + 8);
  if ( !temp_buf )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%s:%d:%s: malloc buffer failed.\n", "driver-btm-soc.c", 7074, (const char *)_FUNCTION___16637);
      fclose(pFile_2);
    }
    return -2;
  }
  memset(temp_buf, 0, len + 8);
  memcpy(temp_buf, buf, len + 8);
  part_job = (part_of_job *)temp_buf;
  if ( dev->current_job_start_address == job_start_address_1 )
  {
    dev->current_job_start_address = job_start_address_2;
    goto LABEL_32;
  }
  if ( dev->current_job_start_address == job_start_address_2 )
  {
    dev->current_job_start_address = job_start_address_1;
LABEL_32:
    if ( part_job->support_ab )
      opt_multi_version = part_job->version_num;
    else
      opt_multi_version = 1;
    if ( tmp_version_16634 != opt_multi_version )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: Version num %d\n",
            "driver-btm-soc.c",
            7106,
            (const char *)_FUNCTION___16637,
            opt_multi_version);
        fclose(pFile_4);
      }
      tmp_version_16634 = opt_multi_version;
    }
    if ( (part_job->coinbase_len & 0x3Fu) <= 0x37 )
      coinbase_padding_len = ((part_job->coinbase_len >> 6) + 1) << 6;
    else
      coinbase_padding_len = ((part_job->coinbase_len >> 6) + 2) << 6;
    coinbase_padding = (unsigned __int8 *)malloc(coinbase_padding_len);
    if ( !coinbase_padding )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: malloc coinbase_padding failed.\n",
            "driver-btm-soc.c",
            7122,
            (const char *)_FUNCTION___16637);
        fclose(pFile_5);
      }
      return -4;
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "%s:%d:%s: coinbase_padding = 0x%x\n",
          "driver-btm-soc.c",
          7127,
          (const char *)_FUNCTION___16637,
          coinbase_padding);
      fclose(pFile_6);
    }
    if ( part_job->merkles_num )
    {
      merkles_bin = (unsigned __int8 *)malloc(32 * part_job->merkles_num);
      if ( !merkles_bin )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_7 = fopen((const char *)log_file, "a+");
          if ( pFile_7 )
            fprintf(
              pFile_7,
              "%s:%d:%s: malloc merkles_bin failed.\n",
              "driver-btm-soc.c",
              7135,
              (const char *)_FUNCTION___16637);
          fclose(pFile_7);
        }
        if ( coinbase_padding )
          free(coinbase_padding);
        return -5;
      }
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(
            pFile_8,
            "%s:%d:%s: merkles_bin = 0x%x\n",
            "driver-btm-soc.c",
            7144,
            (const char *)_FUNCTION___16637,
            merkles_bin);
        fclose(pFile_8);
      }
    }
    memset(coinbase_padding, 0, coinbase_padding_len);
    memcpy(coinbase_padding, buf + 88, part_job->coinbase_len);
    coinbase_padding[part_job->coinbase_len] = 0x80;
    *(_DWORD *)&coinbase_padding[(coinbase_padding_len - 4) & 0xFFFFFFFC] = (part_job->coinbase_len << 27) | ((8 * (unsigned int)part_job->coinbase_len) >> 24) | ((8 * (unsigned int)part_job->coinbase_len) >> 8) & 0xFF00 | (part_job->coinbase_len << 11) & 0xFF0000;
    *(_DWORD *)&coinbase_padding[(coinbase_padding_len - 8) & 0xFFFFFFFC] = 0;
    l_coinbase_padding = c_coinbase_padding;
    c_coinbase_padding = coinbase_padding_len;
    for ( i = 0; i < coinbase_padding_len; ++i )
      *((_BYTE *)dev->current_job_start_address + i) = coinbase_padding[i];
    for ( i = 0; i < coinbase_padding_len; ++i )
    {
      if ( *((unsigned __int8 *)dev->current_job_start_address + i) != coinbase_padding[i] && log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_9 = fopen((const char *)log_file, "a+");
        if ( pFile_9 )
          fprintf(
            pFile_9,
            "%s:%d:%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x\n",
            "driver-btm-soc.c",
            7168,
            (const char *)_FUNCTION___16637,
            i,
            *((unsigned __int8 *)dev->current_job_start_address + i),
            i,
            coinbase_padding[i]);
        fclose(pFile_9);
      }
    }
    l_merkles_num = c_merkles_num;
    c_merkles_num = part_job->merkles_num;
    if ( part_job->merkles_num )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_10 = fopen((const char *)log_file, "a+");
        if ( pFile_10 )
          fprintf(
            pFile_10,
            "%s:%d:%s: copy merkle bin into memory ...\n",
            "driver-btm-soc.c",
            7175,
            (const char *)_FUNCTION___16637);
        fclose(pFile_10);
      }
      memset(merkles_bin, 0, 32 * part_job->merkles_num);
      memcpy(merkles_bin, &buf[part_job->coinbase_len + 88], 32 * part_job->merkles_num);
      for ( i = 0; i < 32 * (unsigned int)part_job->merkles_num; ++i )
        *((_BYTE *)dev->current_job_start_address + i + coinbase_padding_len) = merkles_bin[i];
      for ( i = 0; i < 32 * (unsigned int)part_job->merkles_num; ++i )
      {
        if ( *((unsigned __int8 *)dev->current_job_start_address + i + coinbase_padding_len) != merkles_bin[i]
          && log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_11 = fopen((const char *)log_file, "a+");
          if ( pFile_11 )
            fprintf(
              pFile_11,
              "%s:%d:%s: merkles_in_ddr[%d] = 0x%x, but *(merkles_bin + %d) =0x%x\n",
              "driver-btm-soc.c",
              7189,
              (const char *)_FUNCTION___16637,
              i,
              *((unsigned __int8 *)dev->current_job_start_address + i + coinbase_padding_len),
              i,
              merkles_bin[i]);
          fclose(pFile_11);
        }
      }
    }
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFFFF3F | 0x80);
    cgsleep_ms(1);
    while ( (get_dhash_acc_control() & 0x40) != 0 )
    {
      cgsleep_ms(1);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_12 = fopen((const char *)log_file, "a+");
        if ( pFile_12 )
          fprintf(
            pFile_12,
            "%s:%d:%s: run bit is 1 after set it to 0\n",
            "driver-btm-soc.c",
            7199,
            (const char *)_FUNCTION___16637);
        fclose(pFile_12);
      }
      ++times;
    }
    cgsleep_ms(1);
    if ( dev->current_job_start_address == job_start_address_1 )
    {
      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
    }
    else if ( dev->current_job_start_address == job_start_address_2 )
    {
      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2162688);
    }
    if ( (*((_BYTE *)part_job + 9) & 2) != 0 )
    {
      set_ticket_mask(part_job->asic_diff);
      dev->diff = part_job->asic_diff;
    }
    set_job_id(part_job->job_id);
    set_block_header_version(part_job->bbversion);
    get_block_header_version();
    if ( opt_multi_version == 2 )
    {
      set_block_header_version_1(part_job->bbversion | 0x4000);
      get_block_header_version_1();
    }
    memset(buf2, 0, sizeof(buf2));
    for ( i = 0; i <= 7; ++i )
      *(&v37 + i - 57) = (part_job->prev_hash[4 * i + 1] << 8) | (part_job->prev_hash[4 * i + 3] << 24) | (part_job->prev_hash[4 * i + 2] << 16) | part_job->prev_hash[4 * i];
    set_pre_header_hash(buf2);
    set_time_stamp(part_job->ntime);
    set_target_bits(part_job->nbit);
    j = ((unsigned __int8)part_job->nonce2_bytes_num << 8) | (part_job->nonce2_offset << 16) | (unsigned __int8)(coinbase_padding_len >> 6);
    set_coinbase_length_and_nonce2_length(j);
    buf2[0] = 0;
    buf2[1] = 0;
    *(_QWORD *)buf2 = part_job->nonce2_start_value;
    set_work_nonce2(buf2);
    set_merkle_bin_number(part_job->merkles_num);
    job_length = coinbase_padding_len + 32 * part_job->merkles_num;
    set_job_length(job_length);
    cgsleep_ms(1);
    if ( !gBegin_get_nonce )
    {
      nonce_fifo_interrupt = get_nonce_fifo_interrupt();
      set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
      v5 = get_dhash_acc_control();
      set_dhash_acc_control(v5 | 0x80);
      gBegin_get_nonce = 1;
      reCalculateAVG();
    }
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
    if ( (*((_BYTE *)part_job + 9) & 1) != 0 )
    {
      if ( pool->support_ab )
      {
LABEL_116:
        v6 = get_dhash_acc_control();
        set_dhash_acc_control((opt_multi_version << 8) & 0xF00 | v6 & 0xFFFFF0BF | 0x8060);
LABEL_120:
        free(temp_buf);
        free(coinbase_padding);
        if ( part_job->merkles_num )
          free(merkles_bin);
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_13 = fopen((const char *)log_file, "a+");
          if ( pFile_13 )
            fprintf(pFile_13, "%s:%d:%s: --- end\n", "driver-btm-soc.c", 7309, (const char *)_FUNCTION___16637);
          fclose(pFile_13);
        }
        cgtime(&tv_send_job);
        set_status(STATUS_OK);
        cgsleep_ms(1);
        return 0;
      }
    }
    else if ( pool->support_ab )
    {
      goto LABEL_116;
    }
    v7 = get_dhash_acc_control();
    set_dhash_acc_control(v7 & 0xFFFF709F | 0x8160);
    goto LABEL_120;
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s: dev->current_job_start_address = 0x%x, but job_start_address_1 = 0x%x, job_start_address_2 = 0x%x\n",
        "driver-btm-soc.c",
        7096,
        (const char *)_FUNCTION___16637,
        dev->current_job_start_address,
        job_start_address_1,
        job_start_address_2);
    fclose(pFile_3);
  }
  return -3;
}

//----- (0002AECE) --------------------------------------------------------
void re_send_last_job()
{
  if ( last_job_buffer[0] != 23 )
  {
    pthread_mutex_lock(&reinit_mutex);
    pthread_mutex_unlock(&reinit_mutex);
  }
}

//----- (0002AEFC) --------------------------------------------------------
void __cdecl copy_pool_stratum(pool *pool_stratum, pool *pool)
{
  uint16_t v2; // r0
  unsigned __int8 **v3; // r4
  unsigned __int16 crc; // [sp+16h] [bp+Eh]
  uint16_t job_id_len; // [sp+18h] [bp+10h]
  unsigned int coinbase_len; // [sp+1Ch] [bp+14h]
  int merkles; // [sp+20h] [bp+18h]
  int i; // [sp+24h] [bp+1Ch]
  int ia; // [sp+24h] [bp+1Ch]

  merkles = pool->merkles;
  coinbase_len = pool->coinbase_len;
  if ( pool->swork.job_id )
  {
    if ( !pool_stratum->swork.job_id
      || (v2 = strlen((const char *)pool->swork.job_id),
          crc = CRC16(pool->swork.job_id, v2),
          job_id_len = strlen((const char *)pool_stratum->swork.job_id),
          crc != CRC16(pool_stratum->swork.job_id, job_id_len)) )
    {
      cg_wlock(&pool_stratum->data_lock, "driver-btm-soc.c", _func___16681, 7347);
      free(pool_stratum->swork.job_id);
      free(pool_stratum->nonce1);
      free(pool_stratum->coinbase);
      pool_stratum->coinbase = (unsigned __int8 *)cgcalloc(coinbase_len, 1u, "driver-btm-soc.c", _func___16681, 7352);
      memcpy(pool_stratum->coinbase, pool->coinbase, coinbase_len);
      for ( i = 0; i < pool_stratum->merkles; ++i )
        free(pool_stratum->swork.merkle_bin[i]);
      if ( merkles )
      {
        pool_stratum->swork.merkle_bin = (unsigned __int8 **)cgrealloc(
                                                               pool_stratum->swork.merkle_bin,
                                                               4 * merkles + 1,
                                                               "driver-btm-soc.c",
                                                               _func___16681,
                                                               7360);
        for ( ia = 0; ia < merkles; ++ia )
        {
          v3 = &pool_stratum->swork.merkle_bin[ia];
          *v3 = (unsigned __int8 *)cgmalloc(0x20u, "driver-btm-soc.c", _func___16681, 7363);
          memcpy(pool_stratum->swork.merkle_bin[ia], pool->swork.merkle_bin[ia], 0x20u);
        }
      }
      pool_stratum->pool_no = pool->pool_no;
      pool_stratum->sdiff = pool->sdiff;
      pool_stratum->coinbase_len = pool->coinbase_len;
      pool_stratum->nonce2_offset = pool->nonce2_offset;
      pool_stratum->n2size = pool->n2size;
      pool_stratum->merkles = pool->merkles;
      pool_stratum->swork.job_id = (unsigned __int8 *)strdup((const char *)pool->swork.job_id);
      pool_stratum->nonce1 = (unsigned __int8 *)strdup((const char *)pool->nonce1);
      memcpy(pool_stratum->ntime, pool->ntime, sizeof(pool_stratum->ntime));
      memcpy(pool_stratum->header_bin, pool->header_bin, sizeof(pool_stratum->header_bin));
      cg_wunlock(&pool_stratum->data_lock, "driver-btm-soc.c", _func___16681, 7379);
    }
  }
}

//----- (0002B18A) --------------------------------------------------------
bool __cdecl bitmain_soc_prepare(thr_info *thr)
{
  const char *v1; // r3
  init_config soc_config; // [sp+18h] [bp+8h] BYREF
  FILE *pFile; // [sp+38h] [bp+28h]
  int ret; // [sp+3Ch] [bp+2Ch]
  bitmain_soc_info *info; // [sp+40h] [bp+30h]
  cgpu_info *bitmain_soc; // [sp+44h] [bp+34h]

  bitmain_soc = thr->cgpu;
  info = (bitmain_soc_info *)bitmain_soc->device_data;
  ret = 0;
  info->thr = thr;
  mutex_init(&info->lock, "driver-btm-soc.c", _func___16694, 7389);
  cglock_init(&info->update_lock, "driver-btm-soc.c", _func___16694, 7390);
  cglock_init(&info->pool0.data_lock, "driver-btm-soc.c", _func___16694, 7391);
  cglock_init(&info->pool1.data_lock, "driver-btm-soc.c", _func___16694, 7392);
  cglock_init(&info->pool2.data_lock, "driver-btm-soc.c", _func___16694, 7393);
  memset(&soc_config, 0, sizeof(soc_config));
  soc_config.token_type = 81;
  soc_config.length = 26;
  *((_BYTE *)&soc_config + 4) |= 1u;
  *((_BYTE *)&soc_config + 4) = *((_BYTE *)&soc_config + 4) & 0xFD | (2 * opt_bitmain_fan_ctrl);
  *((_BYTE *)&soc_config + 4) |= 4u;
  *((_BYTE *)&soc_config + 4) |= 8u;
  *((_BYTE *)&soc_config + 4) |= 0x10u;
  *((_BYTE *)&soc_config + 4) |= 0x20u;
  *((_BYTE *)&soc_config + 4) |= 0x40u;
  *((_BYTE *)&soc_config + 4) |= 0x80u;
  *((_BYTE *)&soc_config + 5) |= 1u;
  *((_BYTE *)&soc_config + 5) |= 2u;
  *((_BYTE *)&soc_config + 5) |= 4u;
  soc_config.asic_num = 60;
  soc_config.fan_pwm_percent = opt_bitmain_fan_pwm;
  soc_config.temperature = 80;
  soc_config.frequency = opt_bitmain_soc_freq;
  soc_config.voltage = opt_bitmain_soc_voltage;
  soc_config.chain_check_time_integer = 10;
  soc_config.chain_check_time_fractions = 10;
  soc_config.chip_address = 4;
  soc_config.chain_min_freq = 400;
  soc_config.chain_max_freq = 600;
  soc_config.crc = CRC16(&soc_config.token_type, 0x1Eu);
  ret = bitmain_soc_init(soc_config);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( ret )
        v1 = "failed";
      else
        v1 = "success";
      fprintf(pFile, "%s:%d:%s: bitmain soc init %s.\n", "driver-btm-soc.c", 7431, (const char *)_FUNCTION___16697, v1);
    }
    fclose(pFile);
  }
  return 1;
}

//----- (0002B3B8) --------------------------------------------------------
void __cdecl bitmain_soc_reinit_device(cgpu_info *bitmain)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  if ( !status_error && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: reinit device, but do nothing here.\n",
        "driver-btm-soc.c",
        7441,
        (const char *)_FUNCTION___16702);
    fclose(pFile);
  }
}

//----- (0002B446) --------------------------------------------------------
void __cdecl bitmain_soc_detect(bool hotplug)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  bitmain_soc_info *a; // [sp+80Ch] [bp+80Ch]
  device_drv *drv; // [sp+810h] [bp+810h]
  cgpu_info *cgpu; // [sp+814h] [bp+814h]

  cgpu = (cgpu_info *)calloc(1u, 0x188u);
  drv = &bitmain_soc_drv;
  if ( !cgpu )
    _assert_fail("cgpu", "driver-btm-soc.c", 0x1D1Bu, (const char *)_PRETTY_FUNCTION___16709);
  cgpu->drv = drv;
  cgpu->deven = DEV_ENABLED;
  cgpu->threads = 1;
  cgpu->device_data = calloc(0x1898u, 1u);
  if ( !cgpu->device_data )
  {
    strcpy((char *)tmp42, "Failed to calloc cgpu_info data");
    applog(3, tmp42, 1);
    quit(1);
  }
  a = (bitmain_soc_info *)cgpu->device_data;
  a->pool0_given_id = 0;
  a->pool1_given_id = 1;
  a->pool2_given_id = 2;
  if ( !add_cgpu(cgpu) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-soc.c", 0x1D27u, (const char *)_PRETTY_FUNCTION___16709);
}

//----- (0002B56E) --------------------------------------------------------
uint64_t __cdecl hashtest_submit(
        thr_info *thr,
        work *work,
        uint32_t nonce,
        uint8_t *midstate,
        pool *pool,
        uint64_t nonce2,
        uint32_t chain_id)
{
  unsigned int v7; // r3
  unsigned int v8; // r4
  uint64_t v10; // [sp+38h] [bp+18h]
  sha2_context ctx; // [sp+58h] [bp+38h] BYREF
  unsigned __int8 hash2[32]; // [sp+140h] [bp+120h] BYREF
  unsigned __int8 hash1[32]; // [sp+160h] [bp+140h] BYREF
  FILE *pFile_3; // [sp+180h] [bp+160h]
  FILE *pFile_2; // [sp+184h] [bp+164h]
  FILE *pFile_1; // [sp+188h] [bp+168h]
  FILE *pFile_4; // [sp+18Ch] [bp+16Ch]
  unsigned __int8 which_core_nonce; // [sp+192h] [bp+172h]
  unsigned __int8 which_asic_nonce; // [sp+193h] [bp+173h]
  uint32_t *hash2_32; // [sp+194h] [bp+174h]
  FILE *pFile_0; // [sp+198h] [bp+178h]
  FILE *pFile; // [sp+19Ch] [bp+17Ch]
  uint64_t tmp_net_diff; // [sp+1A0h] [bp+180h]
  uint64_t tmp_pool_diff; // [sp+1A8h] [bp+188h]
  uint64_t hashes; // [sp+1B0h] [bp+190h]
  int i; // [sp+1BCh] [bp+19Ch]

  hashes = 0LL;
  if ( (unsigned __int64)work->sdiff != pool_diff_16726 )
  {
    pool_diff_16726 = (unsigned __int64)work->sdiff;
    pool_diff_bit_16728 = 0LL;
    tmp_pool_diff = pool_diff_16726;
    while ( tmp_pool_diff )
    {
      tmp_pool_diff >>= 1;
      ++pool_diff_bit_16728;
    }
    --pool_diff_bit_16728;
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: pool_diff:%llu work_diff:%f pool_diff_bit:%llu ...\n",
          "driver-btm-soc.c",
          7492,
          (const char *)_FUNCTION___16735,
          pool_diff_16726,
          work->sdiff,
          pool_diff_bit_16728);
      fclose(pFile);
    }
  }
  if ( (unsigned __int64)current_diff != net_diff_16727 )
  {
    net_diff_16727 = (unsigned __int64)current_diff;
    net_diff_bit_16729 = 0LL;
    tmp_net_diff = (unsigned __int64)current_diff;
    while ( tmp_net_diff )
    {
      tmp_net_diff >>= 1;
      ++net_diff_bit_16729;
    }
    LODWORD(v10) = net_diff_bit_16729 - 1;
    HIDWORD(v10) = ((_DWORD)net_diff_bit_16729 != 0) + HIDWORD(net_diff_bit_16729) - 1;
    net_diff_bit_16729 = v10;
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: net_diff:%llu current_diff:%f net_diff_bit %llu ...\n",
          "driver-btm-soc.c",
          7506,
          (const char *)_FUNCTION___16735,
          net_diff_16727,
          current_diff,
          net_diff_bit_16729);
      fclose(pFile_0);
    }
  }
  hash2_32 = (uint32_t *)hash1;
  memcpy(ctx.state, work->midstate, sizeof(ctx.state));
  ctx.total[0] = 80;
  ctx.total[1] = 0;
  memcpy(hash1, &work->data[64], 0xCu);
  flip_swab(ctx.buffer, hash1, 0xCu);
  *(_DWORD *)hash1 = nonce;
  flip_swab(&ctx.buffer[12], hash1, 4u);
  sha2_finish(&ctx, hash1);
  memset(&ctx, 0, sizeof(ctx));
  sha2(hash1, 32, hash2);
  flip32(hash1, hash2);
  if ( hash2_32[7] )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      inc_hw_errors(thr);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: chain[%d] nonce fail\n",
            "driver-btm-soc.c",
            7540,
            (const char *)_FUNCTION___16735,
            chain_id);
        fclose(pFile_1);
      }
      ++dev->chain_hw[chain_id];
      which_asic_nonce = nonce >> (dev->check_bit + 24);
      which_core_nonce = nonce;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: HW: chain[%d] asic[%d] core[%d]\n",
            "driver-btm-soc.c",
            7547,
            (const char *)_FUNCTION___16735,
            chain_id,
            which_asic_nonce,
            which_core_nonce);
        fclose(pFile_2);
      }
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%s:%d:%s: HASH2_32[7] != 0\n", "driver-btm-soc.c", 7551, (const char *)_FUNCTION___16735);
      fclose(pFile_3);
    }
    v7 = 0;
    v8 = 0;
  }
  else
  {
    for ( i = 0; i <= 6 && !_bswap_32(hash2_32[6 - i]); ++i )
      ;
    if ( i >= pool_diff_bit_16728 >> 5 )
    {
      which_asic_nonce = nonce >> (dev->check_bit + 24);
      which_core_nonce = nonce;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: chain %d which_asic_nonce %d which_core_nonce %d\n",
            "driver-btm-soc.c",
            7570,
            (const char *)_FUNCTION___16735,
            chain_id,
            which_asic_nonce,
            which_core_nonce);
        fclose(pFile_4);
      }
      ++dev->chain_asic_nonce[chain_id][which_asic_nonce];
      if ( _bswap_32(hash2_32[-(unsigned int)((__int64)pool_diff_bit_16728 >> 5) + 6]) >= 0xFFFFFFFF >> (pool_diff_bit_16728 & 0x1F) )
      {
        if ( _bswap_32(hash2_32[6]) <= 0xFFFFFE )
        {
          hashes += 256LL;
          h_each_chain[chain_id] += 256LL;
        }
      }
      else
      {
        hashes += 256LL;
        if ( current_diff != 0.0 )
        {
          for ( i = 0; i < net_diff_bit_16729 >> 5 && !_bswap_32(hash2_32[6 - i]); ++i )
            ;
          if ( i == net_diff_bit_16729 >> 5 )
            _bswap_32(hash2_32[-(unsigned int)((__int64)net_diff_bit_16729 >> 5) + 6]);
        }
        submit_nonce(thr, work, nonce);
      }
    }
    v8 = HIDWORD(hashes);
    v7 = hashes;
  }
  return __PAIR64__(v8, v7);
}

//----- (0002BE64) --------------------------------------------------------
void *__cdecl bitmain_scanhash(void *arg)
{
  int nonce2_high; // r4
  int v2; // r3
  uint32_t v3; // r3
  uint8_t midstate[32]; // [sp+38h] [bp+18h] BYREF
  work *work; // [sp+58h] [bp+38h] BYREF
  FILE *pFile_4; // [sp+5Ch] [bp+3Ch]
  pool *c_pool; // [sp+60h] [bp+40h]
  FILE *pFile_3; // [sp+64h] [bp+44h]
  FILE *pFile_2; // [sp+68h] [bp+48h]
  FILE *pFile_1; // [sp+6Ch] [bp+4Ch]
  FILE *pFile_0; // [sp+70h] [bp+50h]
  pool *pool_stratum2; // [sp+74h] [bp+54h]
  pool *pool_stratum1; // [sp+78h] [bp+58h]
  pool *pool_stratum0; // [sp+7Ch] [bp+5Ch]
  FILE *pFile; // [sp+80h] [bp+60h]
  uint32_t version; // [sp+84h] [bp+64h]
  uint32_t work_id; // [sp+88h] [bp+68h]
  uint32_t chain_id; // [sp+8Ch] [bp+6Ch]
  uint64_t nonce2; // [sp+90h] [bp+70h]
  uint32_t job_id; // [sp+98h] [bp+78h]
  uint32_t nonce3; // [sp+9Ch] [bp+7Ch]
  FILE *pFile_5; // [sp+A0h] [bp+80h]
  bitmain_soc_info *info; // [sp+A4h] [bp+84h]
  cgpu_info *bitmain_soc; // [sp+A8h] [bp+88h]
  thr_info *thr; // [sp+ACh] [bp+8Ch]
  pool *pool; // [sp+B0h] [bp+90h]
  int i; // [sp+B4h] [bp+94h]

  thr = (thr_info *)arg;
  bitmain_soc = (cgpu_info *)*((_DWORD *)arg + 9);
  info = (bitmain_soc_info *)bitmain_soc->device_data;
  h = 0LL;
  pthread_mutex_lock(&nonce_mutex);
  cg_rlock(&info->update_lock, "driver-btm-soc.c", _func___16763, 7614);
  while ( nonce_read_out.nonce_num )
  {
    nonce3 = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce3;
    job_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].job_id;
    nonce2_high = HIDWORD(nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce2);
    LODWORD(nonce2) = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce2;
    HIDWORD(nonce2) = nonce2_high;
    chain_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].chain_num;
    work_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].work_id;
    version = (nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version << 24) | HIBYTE(nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version) | (nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version >> 8) & 0xFF00 | (nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version << 8) & 0xFF0000;
    memset(midstate, 0, sizeof(midstate));
    for ( i = 0; i <= 31; ++i )
    {
      v2 = i & 3;
      if ( i <= 0 )
        v2 = -(-i & 3);
      midstate[4 * (7 - i / 4) + v2] = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].midstate[i];
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chain_id:%d   job_id:0x%x   work_id:0x%x   nonce2:0x%llx   nonce3:0x%x   version:0x%x\n",
          "driver-btm-soc.c",
          7628,
          (const char *)_FUNCTION___16775,
          chain_id,
          job_id,
          work_id,
          nonce2,
          nonce3,
          version);
      fclose(pFile);
    }
    pool_stratum0 = &info->pool0;
    pool_stratum1 = &info->pool1;
    pool_stratum2 = &info->pool2;
    if ( nonce_read_out.p_rd >= 0x1FE )
      nonce_read_out.p_rd = 0;
    else
      ++nonce_read_out.p_rd;
    --nonce_read_out.nonce_num;
    if ( nonce3 == last_nonce3_16760 && work_id == last_workid_16761 )
    {
      if ( dev->chain_exist[chain_id] == 1 )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: recv same nonce ...\n",
              "driver-btm-soc.c",
              7656,
              (const char *)_FUNCTION___16775);
          fclose(pFile_0);
        }
        inc_hw_errors(thr);
        if ( !is_re_open_core_now() )
          ++dev->chain_hw[chain_id];
      }
    }
    else
    {
      last_nonce3_16760 = nonce3;
      last_workid_16761 = work_id;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: Chain ID J%d ...\n",
            "driver-btm-soc.c",
            7664,
            (const char *)_FUNCTION___16775,
            chain_id + 1);
        fclose(pFile_1);
      }
      if ( job_id >= given_id - 2 || job_id <= given_id )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(
              pFile_3,
              "%s:%d:%s: given_id:%d job_id:%d switch:%d  ...\n",
              "driver-btm-soc.c",
              7676,
              (const char *)_FUNCTION___16775,
              given_id,
              job_id,
              given_id - job_id);
          fclose(pFile_3);
        }
        v3 = given_id - job_id;
        if ( given_id - job_id == 1 )
        {
          pool = pool_stratum1;
          goto LABEL_53;
        }
        if ( !v3 )
        {
          pool = pool_stratum0;
          goto LABEL_53;
        }
        if ( v3 == 2 )
        {
          pool = pool_stratum2;
LABEL_53:
          c_pool = pools[pool->pool_no];
          get_work_by_nonce2(thr, &work, pool, c_pool, nonce2, version);
          h += hashtest_submit(thr, work, nonce3, midstate, pool, nonce2, chain_id);
          free_work(&work, "driver-btm-soc.c", _func___16763, 7701);
        }
        else
        {
          if ( log_level > 4 )
          {
            print_crt_time_to_file(log_file, 4u);
            pFile_4 = fopen((const char *)log_file, "a+");
            if ( pFile_4 )
              fprintf(
                pFile_4,
                "%s:%d:%s: job_id non't found given=%d, job=%d...\n",
                "driver-btm-soc.c",
                7690,
                (const char *)_FUNCTION___16775,
                given_id,
                job_id);
            fclose(pFile_4);
          }
          if ( dev->chain_exist[chain_id] == 1 )
          {
LABEL_35:
            inc_hw_errors(thr);
            ++dev->chain_hw[chain_id];
          }
        }
      }
      else
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(pFile_2, "%s:%d:%s: job_id error ...\n", "driver-btm-soc.c", 7667, (const char *)_FUNCTION___16775);
          fclose(pFile_2);
        }
        if ( dev->chain_exist[chain_id] == 1 )
          goto LABEL_35;
      }
    }
  }
  cg_runlock(&info->update_lock, "driver-btm-soc.c", _func___16763, 7703);
  pthread_mutex_unlock(&nonce_mutex);
  cgsleep_ms(1);
  if ( h && log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fprintf(
        pFile_5,
        "%s:%d:%s: hashes %llu ...\n",
        "driver-btm-soc.c",
        7708,
        (const char *)_FUNCTION___16775,
        0xFFFFFFFFLL * h);
    fclose(pFile_5);
  }
  h *= 0xFFFFFFFFLL;
  return 0;
}

//----- (0002C74C) --------------------------------------------------------
int64_t __cdecl bitmain_soc_scanhash(thr_info *thr)
{
  pthread_t send_id[2]; // [sp+Ch] [bp+Ch] BYREF

  h = 0LL;
  pthread_create(send_id, 0, (void *(*)(void *))bitmain_scanhash, thr);
  pthread_join(send_id[0], 0);
  return h;
}
// 2C74C: using guessed type pthread_t send_id[2];

//----- (0002C79C) --------------------------------------------------------
void __cdecl bitmain_soc_update(cgpu_info *bitmain_soc)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 *buf; // [sp+80Ch] [bp+80Ch] BYREF
  work *work; // [sp+810h] [bp+810h] BYREF
  pool *pool; // [sp+814h] [bp+814h]
  thr_info *thr; // [sp+818h] [bp+818h]
  bitmain_soc_info *info; // [sp+81Ch] [bp+81Ch]

  info = (bitmain_soc_info *)bitmain_soc->device_data;
  thr = *bitmain_soc->thr;
  mutex_lock(&info->lock, "driver-btm-soc.c", _func___16807, 7729);
  buf = 0;
  thr->work_update = 0;
  thr->work_restart = 0;
  work = get_work(thr, thr->id);
  discard_work(&work, "driver-btm-soc.c", _func___16807, 7735);
  pool = current_pool();
  if ( !pool->has_stratum )
  {
    strcpy((char *)tmp42, "Bitmain S9 has to use stratum pools");
    applog(3, tmp42, 1);
    quit(1);
  }
  cg_wlock(&info->update_lock, "driver-btm-soc.c", _func___16807, 7742);
  cg_rlock(&pool->data_lock, "driver-btm-soc.c", _func___16807, 7743);
  info->pool_no = pool->pool_no;
  copy_pool_stratum(&info->pool2, &info->pool1);
  info->pool2_given_id = info->pool1_given_id;
  copy_pool_stratum(&info->pool1, &info->pool0);
  info->pool1_given_id = info->pool0_given_id;
  copy_pool_stratum(&info->pool0, pool);
  info->pool0_given_id = ++given_id;
  parse_job_to_soc(&buf, pool, info->pool0_given_id);
  if ( !status_error )
  {
    pthread_mutex_lock(&reinit_mutex);
    send_job(buf, pool);
    pthread_mutex_unlock(&reinit_mutex);
  }
  cg_runlock(&pool->data_lock, "driver-btm-soc.c", _func___16807, 7762);
  cg_wunlock(&info->update_lock, "driver-btm-soc.c", _func___16807, 7763);
  free(buf);
  mutex_unlock(&info->lock, "driver-btm-soc.c", _func___16807, 7765);
}

//----- (0002CA24) --------------------------------------------------------
void __cdecl get_bitmain_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *bitmain_soc)
{
  ;
}

//----- (0002CA3C) --------------------------------------------------------
void __cdecl restore_syslog_file(LOG_FILE_BACKUP *backlog)
{
  use_syslog = backlog->use_syslog;
  g_logfile_enable = backlog->logfile_enable;
  g_log_file = 0;
  strcpy((char *)g_logfile_path, (const char *)backlog->logfile_path);
  strcpy((char *)g_logfile_openflag, (const char *)backlog->logfile_openflag);
}

//----- (0002CA9A) --------------------------------------------------------
void __cdecl backup_syslog_file(LOG_FILE_BACKUP *backlog)
{
  backlog->use_syslog = use_syslog;
  backlog->logfile_enable = g_logfile_enable;
  strcpy((char *)backlog->logfile_path, (const char *)g_logfile_path);
  strcpy((char *)backlog->logfile_openflag, (const char *)g_logfile_openflag);
}

//----- (0002CAEC) --------------------------------------------------------
void __cdecl set_privite_log_file(unsigned __int8 *logfile_name, LOG_FILE_BACKUP *backlog)
{
  backup_syslog_file(backlog);
  if ( g_log_file )
  {
    fclose(g_log_file);
    g_log_file = 0;
  }
  use_syslog = 0;
  g_logfile_enable = 1;
  strcpy((char *)g_logfile_path, (const char *)logfile_name);
  strcpy((char *)g_logfile_openflag, "w");
}
// 81B34: using guessed type __int16 word_81B34;

//----- (0002CB68) --------------------------------------------------------
void __cdecl getMinerInfo(unsigned __int8 *infoStr)
{
  double v1; // d0
  int chain_num; // [sp+Ch] [bp+Ch]
  double voltage; // [sp+10h] [bp+10h]
  double voltagea; // [sp+10h] [bp+10h]
  int retlen; // [sp+18h] [bp+18h]
  int retlenc; // [sp+18h] [bp+18h]
  int retlena; // [sp+18h] [bp+18h]
  int retlenb; // [sp+18h] [bp+18h]
  int retlend; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]
  int ia; // [sp+1Ch] [bp+1Ch]

  retlen = 0;
  voltage = 0.0;
  chain_num = 0;
  if ( is_T11() )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] )
      {
        get_working_voltage_by_chain(i);
        voltage = voltage + v1 * 100.0;
      }
    }
    voltagea = voltage / (double)i;
  }
  else
  {
    get_working_voltage();
    voltagea = v1 * 100.0;
  }
  for ( ia = 0; ia <= 15; ++ia )
  {
    if ( dev->chain_exist[ia] )
    {
      retlenc = retlen + sprintf((char *)&infoStr[retlen], "chain%d_voltage=%d;", ia + 1, (int)voltagea);
      retlena = retlenc + sprintf((char *)&infoStr[retlenc], "chain%d_voladded=%d;", ia + 1, 0);
      if ( is_economic_mode() )
        retlenb = retlena
                + sprintf((char *)&infoStr[retlena], "chain%d_basefreq=%d;", ia + 1, g_sweep_config_eco.sweep_max_freq);
      else
        retlenb = retlena
                + sprintf((char *)&infoStr[retlena], "chain%d_basefreq=%d;", ia + 1, g_sweep_config_hpf.sweep_max_freq);
      retlen = retlenb + sprintf((char *)&infoStr[retlenb], "chain%d_badcore=%d;", ia + 1, 0);
      ++chain_num;
    }
  }
  retlend = retlen + sprintf((char *)&infoStr[retlen], "chainnum=%d;", chain_num);
  sprintf((char *)&infoStr[retlend], "version=%s;", (const char *)g_miner_compiletime);
}
// 2CBBC: variable 'v1' is possibly undefined

//----- (0002CD50) --------------------------------------------------------
void __cdecl getReopenInfo(unsigned __int8 *infoStr)
{
  sprintf((char *)infoStr, "reopen time=%d", re_open_core_times);
}

//----- (0002CD7A) --------------------------------------------------------
void __cdecl getAgingInbalanceTimes(unsigned __int8 *infoStr)
{
  uint32_t total_inbalance_times; // r0

  total_inbalance_times = aging_get_total_inbalance_times();
  sprintf((char *)infoStr, "aging reopen time=%d", total_inbalance_times);
}

//----- (0002CDA0) --------------------------------------------------------
void __cdecl get_reopen_time_record_info(unsigned __int8 *infoStr)
{
  uint32_t time_struct_size; // [sp+8h] [bp+8h]
  uint32_t reopen_id; // [sp+Ch] [bp+Ch]

  strcpy((char *)infoStr, "reopen time:");
  if ( re_open_core_times )
  {
    time_struct_size = strlen((const char *)reopen_time);
    for ( reopen_id = 0; reopen_id < re_open_core_times; ++reopen_id )
      sprintf(
        (char *)&infoStr[reopen_id * (time_struct_size + 5) + 12],
        "[%03d]%s,",
        reopen_id,
        (const char *)reopen_time[reopen_id]);
  }
}

//----- (0002CE2E) --------------------------------------------------------
void __cdecl getDiffFreqInfo(unsigned __int8 *infoStr)
{
  int sweep_max_freq; // r3
  FILE *pFile_0; // [sp+18h] [bp+8h]
  uint32_t *buf; // [sp+1Ch] [bp+Ch]
  FILE *pFile; // [sp+20h] [bp+10h]
  uint32_t base_freq; // [sp+24h] [bp+14h]
  bool is_chain_number_print; // [sp+33h] [bp+23h]
  int retlen; // [sp+34h] [bp+24h]
  int chip; // [sp+38h] [bp+28h]
  int chain; // [sp+3Ch] [bp+2Ch]

  retlen = 0;
  if ( is_economic_mode() )
    sweep_max_freq = g_sweep_config_eco.sweep_max_freq;
  else
    sweep_max_freq = g_sweep_config_hpf.sweep_max_freq;
  base_freq = sweep_max_freq;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: base freq= %d\n", "driver-btm-soc.c", 7877, (const char *)_FUNCTION___16864, base_freq);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      buf = scan_result[chain].freq_eeprom;
      is_chain_number_print = 0;
      for ( chip = 0; chip <= 59; ++chip )
      {
        if ( !(chip % 10) )
        {
          if ( log_level > 4 )
          {
            print_crt_time_to_file(log_file, 4u);
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "%s:%d:%s: chain[%d] chip[%d] freq:%d\n",
                "driver-btm-soc.c",
                7893,
                (const char *)_FUNCTION___16864,
                chain,
                chip,
                buf[chip]);
            fclose(pFile_0);
          }
          if ( base_freq != buf[chip] )
          {
            if ( !is_chain_number_print )
            {
              retlen += sprintf((char *)&infoStr[retlen], "Chain[%d]: ", chain);
              is_chain_number_print = 1;
            }
            retlen += sprintf((char *)&infoStr[retlen], "vol[%d]:%d  ", chip / 10, buf[chip]);
          }
        }
      }
    }
  }
}

//----- (0002D076) --------------------------------------------------------
void __cdecl get_avg_freq_info(unsigned __int8 *infoStr)
{
  int retlen; // [sp+8h] [bp+8h]
  int chain; // [sp+Ch] [bp+Ch]

  retlen = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      retlen += sprintf((char *)&infoStr[retlen], "%d ", scan_freq_average[chain]);
  }
}

//----- (0002D0E4) --------------------------------------------------------
void __cdecl increase_to_base_freq(float init_freq, float freq_step)
{
  float v2; // s0
  float v3; // s1
  __int64 *v4; // r2
  int steps[16]; // [sp+58h] [bp+48h] BYREF
  FILE *pFile; // [sp+98h] [bp+88h]
  FILE *pFile_0; // [sp+9Ch] [bp+8Ch]
  float freq_tmp; // [sp+A0h] [bp+90h]
  int max_steps; // [sp+A4h] [bp+94h]
  int chain; // [sp+A8h] [bp+98h]
  int i; // [sp+ACh] [bp+9Ch]
  __int64 savedregs; // [sp+B0h] [bp+A0h] BYREF

  memset(steps, 0, sizeof(steps));
  max_steps = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
    {
      if ( is_column_sweep() )
        *((_DWORD *)&savedregs + chain - 38) = 150;
      else
        *((_DWORD *)&savedregs + chain - 38) = scanfreq_info.base_freq[chain];
      *((_DWORD *)&savedregs + chain - 22) = (int)(float)((float)((float)*((int *)&savedregs + chain - 38) - v2) / v3);
      if ( (float)((float)((float)*((int *)&savedregs + chain - 22) * v3) + v2) < (float)*((int *)&savedregs + chain - 38) )
        ++*((_DWORD *)&savedregs + chain - 22);
      if ( max_steps < *((_DWORD *)&savedregs + chain - 22) )
        max_steps = *((_DWORD *)&savedregs + chain - 22);
    }
  }
  for ( i = 0; i < max_steps; ++i )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] && i < *((_DWORD *)&savedregs + chain - 22) )
      {
        freq_tmp = v2 + (float)((float)(i + 1) * v3);
        v4 = &savedregs;
        if ( freq_tmp > (float)*((int *)&savedregs + chain - 38) )
        {
          v4 = &savedregs;
          freq_tmp = (float)*((int *)&savedregs + chain - 38);
        }
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Chain[%d] increase frequency to %.2fM\n",
              "driver-btm-soc.c",
              7966,
              (const char *)_FUNCTION___16900,
              chain,
              freq_tmp);
          fclose(pFile);
        }
        change_high_pll_test(chain, 0.0, (int)v4);
      }
    }
    usleep((__useconds_t)&calc_nonce_info.chain_asic_core_nonce_num[5][48][190]);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: \n", "driver-btm-soc.c", 7971, (const char *)_FUNCTION___16900);
    fclose(pFile_0);
  }
}
// 2D1A6: variable 'v2' is possibly undefined
// 2D1AE: variable 'v3' is possibly undefined
// 2D3CE: variable 'v4' is possibly undefined

//----- (0002D48C) --------------------------------------------------------
bool is_column_sweep()
{
  return is_T11() && g_device_minor_type && g_device_minor_type != PKG_B_BGM;
}

//----- (0002D4C4) --------------------------------------------------------
bool is_board_sweep()
{
  return is_T11() && (g_device_minor_type == PKG_BSL || g_device_minor_type == PKG_B_BGM);
}

//----- (0002D4F8) --------------------------------------------------------
void __cdecl scan_freq_init_highest_voltage(working_mode_e working_mode)
{
  double v1; // r2
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  double max_volt; // [sp+20h] [bp+10h]
  int chain; // [sp+2Ch] [bp+1Ch]

  if ( is_T11() )
  {
    max_volt = g_sweep_config_hpf.sweep_start_voltage * 1.08;
    if ( g_sweep_config_hpf.sweep_start_voltage * 1.08 > 10.1999998 )
      max_volt = 10.1999998;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: sweep open core at max voltage %.2f\n",
          "driver-btm-soc.c",
          8008,
          (const char *)_FUNCTION___16918,
          max_volt);
      fclose(pFile);
    }
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        HIDWORD(v1) = (unsigned __int8)chain;
        LODWORD(v1) = chain + 2;
        set_highest_voltage_by_chain(chain, v1);
      }
    }
  }
}

//----- (0002D610) --------------------------------------------------------
int __cdecl scan_freq_board_init(working_mode_e working_mode)
{
  double v1; // d0
  double v2; // r0
  double v3; // r2
  float v4; // s15
  double v5; // r0
  float v6; // s15
  double v7; // r2
  float v8; // s15
  float v9; // s15
  int dhash_acc_control; // r0
  _BOOL4 v12; // r0
  float v13; // r1
  int v14; // r0
  float v15; // r1
  FILE *pFile_0; // [sp+18h] [bp+8h]
  FILE *pFile_4; // [sp+1Ch] [bp+Ch]
  float min_freq; // [sp+20h] [bp+10h]
  FILE *pFile_2; // [sp+24h] [bp+14h]
  FILE *pFile_3; // [sp+28h] [bp+18h]
  FILE *pFile_1; // [sp+2Ch] [bp+1Ch]
  FILE *pFile; // [sp+34h] [bp+24h]
  int ret; // [sp+38h] [bp+28h]
  int chain; // [sp+3Ch] [bp+2Ch]
  int chaina; // [sp+3Ch] [bp+2Ch]
  int chainb; // [sp+3Ch] [bp+2Ch]
  int chainc; // [sp+3Ch] [bp+2Ch]

  ret = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: board init ..\n", "driver-btm-soc.c", 8026, (const char *)_FUNCTION___16931);
    fclose(pFile);
  }
  set_QN_write_data_command(0x8080800F);
  sleep(2u);
  set_Hardware_version(0x40000000u);
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  set_PWM(0x64u);
  init_pic();
  if ( first_time_init )
  {
    power_init();
    set_working_voltage(v2);
    scan_freq_init_highest_voltage(working_mode);
    goto LABEL_30;
  }
  if ( !is_column_sweep() && !is_board_sweep() )
  {
    if ( working_mode == MODE1 )
    {
      if ( is_T11() )
      {
        for ( chain = 0; chain <= 15; ++chain )
        {
          if ( dev->chain_exist[chain] )
          {
            get_working_voltage_by_chain(chain);
            v4 = v1;
            if ( v4 < g_sweep_config_eco.max_aging_voltage )
            {
              HIDWORD(v3) = (unsigned __int8)chain;
              v1 = v4 + 0.1;
              set_working_voltage_by_chain(chain, v3);
            }
          }
        }
        goto LABEL_30;
      }
      get_working_voltage();
      v6 = v1;
      if ( v6 >= g_sweep_config_eco.max_aging_voltage )
        goto LABEL_30;
LABEL_29:
      set_working_voltage(v5);
      goto LABEL_30;
    }
    if ( !is_T11() )
    {
      get_working_voltage();
      v9 = v1;
      if ( v9 >= g_sweep_config_hpf.max_aging_voltage )
        goto LABEL_30;
      goto LABEL_29;
    }
    for ( chaina = 0; chaina <= 15; ++chaina )
    {
      if ( dev->chain_exist[chaina] )
      {
        get_working_voltage_by_chain(chaina);
        v8 = v1;
        if ( v8 < g_sweep_config_hpf.max_aging_voltage )
        {
          HIDWORD(v7) = (unsigned __int8)chaina;
          v1 = v8 + 0.1;
          set_working_voltage_by_chain(chaina, v7);
        }
      }
    }
  }
LABEL_30:
  set_iic_power_to_highest_voltage();
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
  }
  cgsleep_ms(10);
  init_address_info();
  set_default_uart_baud();
  for ( chainb = 0; chainb <= 15; ++chainb )
  {
    if ( dev->chain_exist[chainb] == 1 && !scanfreq_info.test_done[chainb] && bring_up_chain(chainb, 1) )
    {
      disable_pic_dac(chainb);
      dev->chain_exist[chainb] = 0;
      --dev->chain_num;
      ret = -1;
    }
  }
  if ( ret )
    return ret;
  set_working_uart_baud();
  set_iic_for_temperature();
  if ( !is_env_temp_detected_16929 )
  {
    detect_environment_temperature();
    is_env_temp_detected_16929 = 1;
  }
  set_clock_delay_control(All_Chain, g_pulse_mode);
  for ( chainc = 0; chainc <= 15; ++chainc )
  {
    if ( dev->chain_exist[chainc] == 1 && !scanfreq_info.test_done[chainc] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: open core for chain[%d]\n",
            "driver-btm-soc.c",
            8137,
            (const char *)_FUNCTION___16931,
            chainc);
        fclose(pFile_0);
      }
      open_core_bm1393(1, chainc);
    }
  }
  cgsleep_ms(100);
  v12 = is_column_sweep();
  if ( v12 || (v12 = is_board_sweep()) )
  {
    if ( need_set_final_freq )
      increase_freq_by_eeprom_slowly_new((int)init_freq, (int)freq_step);
    else
      increase_to_base_freq(*(float *)&v12, v13);
    slowly_set_iic_power_to_working_voltage();
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: set to working voltage...\n",
          "driver-btm-soc.c",
          8157,
          (const char *)_FUNCTION___16931);
      fclose(pFile_1);
    }
    slowly_set_iic_power_to_working_voltage();
    if ( first_time_init )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: increase to base freq...\n",
            "driver-btm-soc.c",
            8163,
            (const char *)_FUNCTION___16931);
        v14 = fclose(pFile_2);
      }
      increase_to_base_freq(*(float *)&v14, v15);
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: increase to adjust freq...\n",
            "driver-btm-soc.c",
            8168,
            (const char *)_FUNCTION___16931);
        fclose(pFile_3);
      }
      set_adjust_freq();
    }
  }
  min_freq = (float)scan_freq_get_min_base_freq();
  dev->timeout = (unsigned int)(float)((float)((float)((float)(dev->addrInterval
                                                             * (0x1000000
                                                              / calculate_core_number(dev->corenum)))
                                                     / min_freq)
                                             * 50.0)
                                     / 100.0);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(
        pFile_4,
        "%s:%d:%s: final timeout=%d, min_freq=%.2f\n",
        "driver-btm-soc.c",
        8176,
        (const char *)_FUNCTION___16931,
        dev->timeout,
        min_freq);
    fclose(pFile_4);
  }
  if ( opt_multi_version )
    set_time_out_control((opt_multi_version * dev->timeout) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
  return 0;
}
// 2D6F8: variable 'v2' is possibly undefined
// 2D778: variable 'v1' is possibly undefined
// 2D7B8: variable 'v3' is possibly undefined
// 2D88A: variable 'v7' is possibly undefined
// 2D8E2: variable 'v5' is possibly undefined
// 2DB50: variable 'v13' is possibly undefined
// 2DC62: variable 'v14' is possibly undefined
// 2DC62: variable 'v15' is possibly undefined

//----- (0002DE38) --------------------------------------------------------
int __cdecl scan_freq_board_fast_init(working_mode_e working_mode)
{
  int dhash_acc_control; // r0
  _BOOL4 v3; // r0
  float v4; // r1
  double v5; // r2
  int v6; // r3
  int v7; // r0
  float v8; // r1
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  FILE *pFile_4; // [sp+20h] [bp+10h]
  float min_freq; // [sp+24h] [bp+14h]
  FILE *pFile_2; // [sp+28h] [bp+18h]
  FILE *pFile_3; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_1; // [sp+30h] [bp+20h]
  FILE *pFile; // [sp+34h] [bp+24h]
  int ret; // [sp+38h] [bp+28h]
  int chain; // [sp+3Ch] [bp+2Ch]
  int chaina; // [sp+3Ch] [bp+2Ch]
  int chainb; // [sp+3Ch] [bp+2Ch]

  ret = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: board init ..\n", "driver-btm-soc.c", 0x2000, (const char *)_FUNCTION___16959);
    fclose(pFile);
  }
  set_QN_write_data_command(0x8080800F);
  sleep(2u);
  set_Hardware_version(0x40000000u);
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  set_PWM(0x64u);
  set_iic_power_to_highest_voltage();
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
  }
  cgsleep_ms(10);
  init_address_info();
  set_default_uart_baud();
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] == 1 && !scanfreq_info.test_done[chain] && bring_up_chain(chain, 0) )
    {
      disable_pic_dac(chain);
      dev->chain_exist[chain] = 0;
      --dev->chain_num;
      ret = -1;
    }
  }
  if ( ret )
    return ret;
  set_working_uart_baud();
  set_iic_for_temperature();
  if ( !is_env_temp_detected_16957 )
  {
    detect_environment_temperature();
    is_env_temp_detected_16957 = 1;
  }
  set_clock_delay_control(All_Chain, g_pulse_mode);
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina] == 1 && !scanfreq_info.test_done[chaina] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: open core for chain[%d]\n",
            "driver-btm-soc.c",
            8242,
            (const char *)_FUNCTION___16959,
            chaina);
        fclose(pFile_0);
      }
      open_core_bm1393(1, chaina);
    }
  }
  cgsleep_ms(100);
  v3 = is_column_sweep();
  if ( v3 || (v3 = is_board_sweep()) )
  {
    if ( need_set_final_freq )
    {
      increase_freq_by_eeprom_slowly_new((int)init_freq, (int)freq_step);
      for ( chainb = 0; chainb <= 15; ++chainb )
      {
        if ( dev->chain_exist[chainb] == 1 )
        {
          HIDWORD(v5) = (unsigned __int8)chainb;
          LODWORD(v5) = chainb + 2;
          if ( slowly_set_iic_power_to_custom_voltage_by_chain(chainb, v5) )
            v6 = 0;
          else
            v6 = -1;
          ret = v6;
        }
        if ( ret )
          return ret;
      }
    }
    else
    {
      increase_to_base_freq(*(float *)&v3, v4);
      slowly_set_iic_power_to_working_voltage();
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: set to working voltage...\n",
          "driver-btm-soc.c",
          8268,
          (const char *)_FUNCTION___16959);
      fclose(pFile_1);
    }
    slowly_set_iic_power_to_working_voltage();
    if ( first_time_init )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: increase to base freq...\n",
            "driver-btm-soc.c",
            8274,
            (const char *)_FUNCTION___16959);
        v7 = fclose(pFile_2);
      }
      increase_to_base_freq(*(float *)&v7, v8);
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: increase to adjust freq...\n",
            "driver-btm-soc.c",
            8279,
            (const char *)_FUNCTION___16959);
        fclose(pFile_3);
      }
      set_adjust_freq();
    }
  }
  min_freq = (float)scan_freq_get_min_base_freq();
  dev->timeout = (unsigned int)(float)((float)((float)((float)(dev->addrInterval
                                                             * (0x1000000
                                                              / calculate_core_number(dev->corenum)))
                                                     / min_freq)
                                             * 50.0)
                                     / 100.0);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(
        pFile_4,
        "%s:%d:%s: final timeout=%d, min_freq=%.2f\n",
        "driver-btm-soc.c",
        8287,
        (const char *)_FUNCTION___16959,
        dev->timeout,
        min_freq);
    fclose(pFile_4);
  }
  if ( opt_multi_version )
    set_time_out_control((opt_multi_version * dev->timeout) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
  return 0;
}
// 2E19A: variable 'v4' is possibly undefined
// 2E2AC: variable 'v7' is possibly undefined
// 2E2AC: variable 'v8' is possibly undefined

//----- (0002E498) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
api_data *__cdecl bitmain_api_stats(cgpu_info *cgpu)
{
  double v1; // d0
  int v2; // r0
  int v3; // r0
  double TotalRate; // d7
  double v5; // d7
  _BYTE param_name[2048]; // [sp+Ch] [bp+Ch] OVERLAPPED BYREF
  unsigned __int8 tmp_2[20]; // [sp+80Ch] [bp+80Ch] BYREF
  unsigned __int8 chain_opencore[20]; // [sp+820h] [bp+820h] BYREF
  unsigned __int8 tmp_1[20]; // [sp+834h] [bp+834h] BYREF
  unsigned __int8 chain_offside[20]; // [sp+848h] [bp+848h] BYREF
  unsigned __int8 tmp_0[20]; // [sp+85Ch] [bp+85Ch] BYREF
  unsigned __int8 chain_xtime[16]; // [sp+870h] [bp+870h] BYREF
  unsigned __int8 chain_rate[16]; // [sp+880h] [bp+880h] BYREF
  unsigned __int8 chain_hw[16]; // [sp+890h] [bp+890h] BYREF
  unsigned __int8 chain_asic_name[12]; // [sp+8A0h] [bp+8A0h] BYREF
  unsigned __int8 chain_name[12]; // [sp+8ACh] [bp+8ACh] BYREF
  double dev_sum_freq_2; // [sp+8B8h] [bp+8B8h] BYREF
  double total_rate; // [sp+8C0h] [bp+8C0h] BYREF
  int16_t asic_num_total; // [sp+8CEh] [bp+8CEh] BYREF
  double dev_sum_freq_1; // [sp+8D0h] [bp+8D0h] BYREF
  double dev_sum_freq_0; // [sp+8D8h] [bp+8D8h] BYREF
  double dev_sum_freq; // [sp+8E0h] [bp+8E0h] BYREF
  unsigned __int8 freq_sum[12]; // [sp+8E8h] [bp+8E8h] BYREF
  unsigned __int8 temp_chip_name[12]; // [sp+8F4h] [bp+8F4h] BYREF
  unsigned __int8 no_value_0[2]; // [sp+900h] [bp+900h] BYREF
  unsigned __int8 temp_pcb_name[12]; // [sp+904h] [bp+904h] BYREF
  unsigned __int8 no_value[2]; // [sp+910h] [bp+910h] BYREF
  unsigned __int8 temp2_name[12]; // [sp+914h] [bp+914h] BYREF
  unsigned __int8 temp_name[12]; // [sp+920h] [bp+920h] BYREF
  unsigned __int8 fan_name[12]; // [sp+92Ch] [bp+92Ch] BYREF
  unsigned __int8 chain_freq[12]; // [sp+938h] [bp+938h] BYREF
  unsigned __int8 tmp[12]; // [sp+944h] [bp+944h] BYREF
  double dev_hwp; // [sp+950h] [bp+950h] BYREF
  int temp_offside[16]; // [sp+958h] [bp+958h] BYREF
  int hw_errors_temp; // [sp+998h] [bp+998h] BYREF
  int8_t temp_senor_num; // [sp+99Fh] [bp+99Fh] BYREF
  int temp_2; // [sp+9A0h] [bp+9A0h]
  int temp_1; // [sp+9A4h] [bp+9A4h]
  int temp_0; // [sp+9A8h] [bp+9A8h]
  int t11a_eco_rate; // [sp+9ACh] [bp+9ACh]
  int t11_eco_rate; // [sp+9B0h] [bp+9B0h]
  bool copy_data; // [sp+9B7h] [bp+9B7h]
  int temp; // [sp+9B8h] [bp+9B8h]
  int j_4; // [sp+9BCh] [bp+9BCh]
  bool first; // [sp+9C3h] [bp+9C3h]
  int j_3; // [sp+9C4h] [bp+9C4h]
  int total_acn_num; // [sp+9C8h] [bp+9C8h]
  int j_2; // [sp+9CCh] [bp+9CCh]
  int len_0; // [sp+9D0h] [bp+9D0h]
  int j_1; // [sp+9D4h] [bp+9D4h]
  int len; // [sp+9D8h] [bp+9D8h]
  int j_0; // [sp+9DCh] [bp+9DCh]
  uint64_t hash_rate_all; // [sp+9E0h] [bp+9E0h]
  int j; // [sp+9ECh] [bp+9ECh]
  int i; // [sp+9F0h] [bp+9F0h]
  api_data *root; // [sp+9F4h] [bp+9F4h]
  _DWORD v58[3]; // [sp+9F8h] [bp+9F8h] BYREF

  root = 0;
  i = 0;
  temp = 0;
  j = 0;
  temp_senor_num = 0;
  hash_rate_all = 0LL;
  copy_data = 1;
  hw_errors_temp = (int)get_hw_errors();
  memset(temp_offside, 0, sizeof(temp_offside));
  root = api_add_uint8(0, "miner_count", &dev->chain_num, 1);
  root = api_add_string(root, "frequency", dev->frequency_t, copy_data);
  for ( i = 0; i <= 7; ++i )
  {
    sprintf((char *)chain_freq, "freq%d", i + 1);
    if ( freq_mode == 2 )
      sprintf((char *)tmp, "%u", (int)freq_from_board[i]);
    else
      sprintf((char *)tmp, "%u", scan_freq_average[i]);
    root = api_add_string(root, chain_freq, tmp, copy_data);
  }
  root = api_add_uint8(root, "fan_num", &dev->fan_num, copy_data);
  for ( i = 0; i <= 7; ++i )
  {
    sprintf((char *)fan_name, "fan%d", i + 1);
    root = api_add_uint(root, fan_name, &dev->fan_speed_value[i], copy_data);
  }
  temp_senor_num = 2 * dev->chain_num;
  root = api_add_uint8(root, "temp_num", (uint8_t *)&temp_senor_num, copy_data);
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp_name, "temp%d", i + 1);
    root = api_add_int16(root, temp_name, dev->chain_asic_maxtemp[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp2_name, "temp2_%d", i + 1);
    root = api_add_int16(root, temp2_name, &dev->chain_asic_temp[i][0][1], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    strcpy((char *)no_value, "-");
    len = 0;
    for ( j_0 = 0; j_0 < dev->chain_asic_temp_num[i]; ++j_0 )
    {
      v2 = sprintf(&param_name[len], "%d", dev->chain_asic_temp[i][j_0][0]);
      len += v2;
      if ( j_0 + 1 < dev->chain_asic_temp_num[i] )
        strcpy(&param_name[len++], "-");
    }
    sprintf((char *)temp_pcb_name, "temp_pcb%d", i + 1);
    if ( len <= 0 )
      root = api_add_string(root, temp_pcb_name, no_value, copy_data);
    else
      root = api_add_string(root, temp_pcb_name, param_name, copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    strcpy((char *)no_value_0, "-");
    len_0 = 0;
    for ( j_1 = 0; j_1 < dev->chain_asic_temp_num[i]; ++j_1 )
    {
      v3 = sprintf(&param_name[len_0], "%d", dev->chain_asic_temp[i][j_1][1]);
      len_0 += v3;
      if ( j_1 + 1 < dev->chain_asic_temp_num[i] )
        strcpy(&param_name[len_0++], "-");
    }
    sprintf((char *)temp_chip_name, "temp_chip%d", i + 1);
    if ( len_0 <= 0 )
      root = api_add_string(root, temp_chip_name, no_value_0, copy_data);
    else
      root = api_add_string(root, temp_chip_name, param_name, copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    dev_sum_freq = 0.0;
    sprintf((char *)freq_sum, "freq_avg%d", i + 1);
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j = 0; j < dev->chain_asic_num[i]; ++j )
      {
        if ( chain_badcore_num[i][j] > 14 )
          dev_sum_freq = (double)freq_pll_1393[12].freq + dev_sum_freq;
        else
          dev_sum_freq = (double)freq_pll_1393[last_freq[i][2 * j + 3]].freq + dev_sum_freq;
      }
      if ( dev->chain_asic_num[i] )
        dev_sum_freq = dev_sum_freq / (double)dev->chain_asic_num[i];
    }
    temp = (int)(dev_sum_freq * 100.0);
    dev_sum_freq = (double)temp / 100.0;
    root = api_add_mhs(root, freq_sum, &dev_sum_freq, 1);
  }
  dev_sum_freq_0 = 0.0;
  strcpy(param_name, "total_rateideal");
  t11_eco_rate = GetTotalRate();
  t11a_eco_rate = 17500;
  if ( is_economic_mode() )
  {
    if ( is_T11() )
      TotalRate = (double)t11_eco_rate;
    else
      TotalRate = (double)t11a_eco_rate;
  }
  else
  {
    TotalRate = (double)GetTotalRate();
  }
  dev_sum_freq_0 = TotalRate;
  root = api_add_mhs(root, param_name, &dev_sum_freq_0, 1);
  j_2 = 0;
  total_acn_num = 0;
  dev_sum_freq_1 = 0.0;
  strcpy(param_name, "total_freqavg");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_2 = 0; j_2 < dev->chain_asic_num[i]; ++j_2 )
      {
        if ( chain_badcore_num[i][j_2] > 14 )
          dev_sum_freq_1 = (double)freq_pll_1393[12].freq + dev_sum_freq_1;
        else
          dev_sum_freq_1 = (double)freq_pll_1393[last_freq[i][2 * j_2 + 3]].freq + dev_sum_freq_1;
        ++total_acn_num;
      }
    }
  }
  dev_sum_freq_1 = dev_sum_freq_1 / (double)total_acn_num;
  temp_0 = (int)(dev_sum_freq_1 * 100.0);
  dev_sum_freq_1 = (double)temp_0 / 100.0;
  root = api_add_mhs(root, param_name, &dev_sum_freq_1, 1);
  asic_num_total = 0;
  strcpy(param_name, "total_acn");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      asic_num_total += dev->chain_asic_num[i];
  }
  root = api_add_int16(root, param_name, &asic_num_total, 1);
  total_rate = 0.0;
  strcpy(param_name, "total_rate");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && displayed_rate[i][0] )
    {
      atof((const char *)displayed_rate[i]);
      total_rate = v1 + total_rate;
    }
  }
  temp_1 = (int)(total_rate * 100.0);
  total_rate = (double)temp_1 / 100.0;
  root = api_add_mhs(root, param_name, &total_rate, 1);
  for ( i = 0; i <= 15; ++i )
  {
    j_3 = 0;
    dev_sum_freq_2 = 0.0;
    sprintf(param_name, "chain_rateideal%d", i + 1);
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_3 = 0; j_3 < dev->chain_asic_num[i]; ++j_3 )
      {
        if ( chain_badcore_num[i][j_3] <= 14 )
          dev_sum_freq_2 = (double)((208 - chain_badcore_num[i][j_3]) * freq_pll_1393[last_freq[i][2 * j_3 + 3]].freq)
                         + dev_sum_freq_2;
      }
    }
    dev_sum_freq_2 = dev_sum_freq_2 / 1000.0;
    temp_2 = (int)(dev_sum_freq_2 * 100.0);
    dev_sum_freq_2 = (double)temp_2 / 100.0;
    root = api_add_mhs(root, param_name, &dev_sum_freq_2, 1);
  }
  root = api_add_int(root, "temp_max", dev->temp_top1, copy_data);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  if ( hw_errors_temp + total_diff1 )
    v5 = (double)hw_errors_temp / (double)(hw_errors_temp + total_diff1);
  else
    v5 = 0.0;
  dev_hwp = v5;
  root = api_add_percent(root, "Device Hardware%", &dev_hwp, 1);
  root = api_add_int(root, "no_matching_work", &hw_errors_temp, copy_data);
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_name, "chain_acn%d", i + 1);
    root = api_add_uint8(root, chain_name, &dev->chain_asic_num[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_asic_name, "chain_acs%d", i + 1);
    root = api_add_string(root, chain_asic_name, dev->chain_asic_status_string[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_hw, "chain_hw%d", i + 1);
    root = api_add_uint32(root, chain_hw, &dev->chain_hw[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_rate, "chain_rate%d", i + 1);
    root = api_add_string(root, chain_rate, displayed_rate[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      printf("chain_rate[%d]=(%s) ", i + 1, (const char *)displayed_rate[i]);
  }
  putchar(10);
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      first = 1;
      j_4 = 0;
      *(_DWORD *)param_name = 123;
      memset(&param_name[4], 0, 0x7FCu);
      memset(tmp_0, 0, sizeof(tmp_0));
      sprintf((char *)chain_xtime, "chain_xtime%d", i + 1);
      if ( x_time[i][0] )
      {
        sprintf((char *)tmp_0, "X%d=%d", 0, x_time[i][0]);
        strcat(param_name, (const char *)tmp_0);
        first = 0;
      }
      for ( j_4 = 1; j_4 < dev->chain_asic_num[i]; ++j_4 )
      {
        if ( x_time[i][j_4] )
        {
          if ( first )
          {
            sprintf((char *)tmp_0, "X%d=%d", j_4, x_time[i][j_4]);
            first = 0;
          }
          else
          {
            sprintf((char *)tmp_0, ",X%d=%d", j_4, x_time[i][j_4]);
          }
          strcat(param_name, (const char *)tmp_0);
        }
      }
      strcat(param_name, "}");
      root = api_add_string(root, chain_xtime, param_name, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      sprintf((char *)chain_offside, "chain_offside_%d", i + 1);
      sprintf((char *)tmp_1, "%d", v58[i - 40]);
      root = api_add_string(root, chain_offside, tmp_1, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      sprintf((char *)chain_opencore, "chain_opencore_%d", i + 1);
      if ( isChainAllCoresOpened[i] )
        strcpy((char *)tmp_2, "1");
      else
        strcpy((char *)tmp_2, "0");
      root = api_add_string(root, chain_opencore, tmp_2, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      hash_rate_all += rate[i];
  }
  strcpy(param_name, "miner_version");
  root = api_add_string(root, param_name, g_miner_version, copy_data);
  strcpy(param_name, "miner_id");
  return api_add_string(root, param_name, FPGA_ID_str, copy_data);
}
// 2E498: variables would overlap: ^C.2048 and stkvar "param_name" ^C.32(has user info)

//----- (0002F960) --------------------------------------------------------
void __cdecl bitmain_soc_shutdown(thr_info *thr)
{
  int dhash_acc_control; // r0
  unsigned int ret; // [sp+Ch] [bp+Ch]

  scan_freq_stop_hash_board();
  thr_info_cancel(check_system_work_id);
  thr_info_cancel(read_nonce_reg_id);
  thr_info_cancel(read_temp_id);
  thr_info_cancel(pic_heart_beat);
  ret = get_BC_write_command() & 0xFFBFFFFF;
  set_BC_write_command(ret);
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
}

//----- (0002F9DC) --------------------------------------------------------
void __cdecl freq_scan_error_code_set(int err_code, int chain)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  if ( freq_mode != 1 )
  {
    freq_scan_status = 2;
    switch ( err_code )
    {
      case 0:
        snprintf((char *)search_failed_info, 0x40u, "J%d:1", chain);
        break;
      case 1:
        snprintf((char *)search_failed_info, 0x40u, "J%d:2", chain);
        break;
      case 2:
        snprintf((char *)search_failed_info, 0x40u, "J%d:3", chain);
        break;
      case 3:
        snprintf((char *)search_failed_info, 0x40u, "J%d:4", chain);
        break;
      case 4:
        snprintf((char *)search_failed_info, 0x40u, "J%d:5", chain);
        break;
      case 5:
        strcpy((char *)search_failed_info, "R:1");
        break;
      case 6:
        strcpy((char *)search_failed_info, "R:2");
        break;
      case 7:
        snprintf((char *)search_failed_info, 0x40u, "T:%d", chain);
        break;
      case 8:
        *(_DWORD *)search_failed_info = &pattern_info_t.asic_core_nonce_num[3][63][156];
        break;
      case 9:
        *(_DWORD *)search_failed_info = &pattern_info_t.asic_core_nonce_num[3][127][156];
        break;
      case 10:
        strcpy((char *)search_failed_info, "F:1");
        break;
      case 11:
        snprintf((char *)search_failed_info, 0x40u, "J%d:6", chain);
        break;
      case 12:
        strcpy((char *)search_failed_info, "V:1");
        break;
      case 13:
        strcpy((char *)search_failed_info, "M:1");
        break;
      case 14:
        strcpy((char *)search_failed_info, "N:1");
        break;
      case 15:
        *(_DWORD *)search_failed_info = &pattern_info_t.asic_core_nonce_num[3][255][156];
        break;
      case 17:
        strcpy((char *)search_failed_info, "R:3");
        break;
      case 18:
        strcpy((char *)search_failed_info, "C:1");
        break;
      case 19:
        strcpy((char *)search_failed_info, "N:2");
        break;
      default:
        strcpy((char *)search_failed_info, "unknown");
        break;
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Frequency scan error_code = %s.\n",
          "freq_scan.c",
          190,
          (const char *)_FUNCTION___14396,
          (const char *)search_failed_info);
      fclose(pFile);
    }
  }
}

//----- (0002FCB4) --------------------------------------------------------
int freq_scan_get_sale_hash_rate()
{
  int hash_rate_ideal; // [sp+0h] [bp+0h]
  int chain; // [sp+4h] [bp+4h]

  hash_rate_ideal = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      hash_rate_ideal += scanfreq_info.ideal_hashrate[chain];
  }
  return 500 * ((hash_rate_ideal - 100) / 500);
}

//----- (0002FD34) --------------------------------------------------------
void freq_scan_set_state()
{
  FILE *pFile; // [sp+10h] [bp+0h]
  int hash_rate_sale; // [sp+14h] [bp+4h]

  hash_rate_sale = freq_scan_get_sale_hash_rate();
  if ( hash_rate_sale <= 13499 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: hash_rate_for_sale = %d  < %d \n",
          "freq_scan.c",
          220,
          (const char *)_FUNCTION___14409,
          hash_rate_sale,
          13500);
      fclose(pFile);
    }
    freq_scan_error_code_set(6, 255);
  }
}

//----- (0002FDCC) --------------------------------------------------------
void __cdecl scanfreq_nonce_calc(int chain, unsigned int buf)
{
  FILE *pFile_0; // [sp+18h] [bp+8h]
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  unsigned int whose_nonce; // [sp+20h] [bp+10h]
  unsigned int which_core_nonce; // [sp+24h] [bp+14h]

  which_core_nonce = (unsigned __int8)buf;
  whose_nonce = HIBYTE(buf) / dev->addrInterval;
  if ( chain <= 15 && whose_nonce <= 0x3B && (unsigned __int8)buf <= 0xCFu && buf )
  {
    ++scanfreq_calc_nonce_info.chain_asic_core_nonce_num[chain][whose_nonce][(unsigned __int8)buf];
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: buf [%x] is error!\n", "freq_scan.c", 236, (const char *)_FUNCTION___14417, buf);
      fclose(pFile);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain = %d,chip = %d,core = %d\n",
          "freq_scan.c",
          237,
          (const char *)_FUNCTION___14417,
          chain,
          whose_nonce,
          which_core_nonce);
      fclose(pFile_0);
    }
  }
}

//----- (0002FF54) --------------------------------------------------------
int __cdecl scan_freq_get_work_of_core_one_file(int which_asic, int which_core, FILE **stream, int count)
{
  uint32_t v4; // r0
  unsigned __int8 str[1024]; // [sp+1Ch] [bp+14h] BYREF
  FILE *pFile; // [sp+41Ch] [bp+414h]
  SCAN_FREQ_WORK *new_work; // [sp+420h] [bp+418h]
  int read_pattern_count; // [sp+424h] [bp+41Ch]
  unsigned int subid; // [sp+428h] [bp+420h]
  uint8_t *temp; // [sp+42Ch] [bp+424h]

  memset(str, 0, sizeof(str));
  subid = 0;
  read_pattern_count = 0;
  while ( 1 )
  {
    if ( !fgets((char *)str, 1023, *stream) )
      return subid;
    ++read_pattern_count;
    if ( subid < count )
      break;
LABEL_16:
    if ( read_pattern_count > 7 )
      return subid;
  }
  new_work = &scanfreq_info.works[which_asic][subid + count * which_core];
  temp = (uint8_t *)strstr((const char *)str, "nonce");
  if ( temp )
  {
    for ( temp += 5; *temp == 32; ++temp )
      ;
    s2hex((unsigned __int8 *)&new_work->nonce, temp, 8);
    v4 = htonl(new_work->nonce);
    new_work->nonce = v4;
    temp = (uint8_t *)strstr((const char *)str, "midstate");
    if ( temp )
    {
      for ( temp += 8; *temp == 32; ++temp )
        ;
      s2hex(new_work->midstate, temp, 64);
      temp = (uint8_t *)strstr((const char *)str, "data");
      if ( temp )
      {
        for ( temp += 4; *temp == 32; ++temp )
          ;
        s2hex(new_work->data, temp, 24);
        memset(new_work->is_nonce_return_back, 0, sizeof(new_work->is_nonce_return_back));
        new_work->id = subid++;
        goto LABEL_16;
      }
    }
  }
  free(new_work);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: get work err\n", "freq_scan.c", 307, (const char *)_FUNCTION___14451);
    fclose(pFile);
  }
  return subid;
}

//----- (000301CC) --------------------------------------------------------
int scanfreq_get_works()
{
  int work_of_core_one_file; // r0
  FILE *fp; // [sp+14h] [bp+4h] BYREF
  FILE *pFile_1; // [sp+18h] [bp+8h]
  FILE *pFile_2; // [sp+1Ch] [bp+Ch]
  FILE *pFile_3; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]
  FILE *pFile; // [sp+28h] [bp+18h]
  int AsicNum; // [sp+2Ch] [bp+1Ch]
  int CoreNum; // [sp+30h] [bp+20h]
  int asic_work_num; // [sp+34h] [bp+24h]
  int j; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  asic_work_num = 0;
  CoreNum = scanfreq_info.CoreNum;
  AsicNum = scanfreq_info.AsicNum;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: read all patterns from one file\n", "freq_scan.c", 318, (const char *)_FUNCTION___14461);
    fclose(pFile);
  }
  fp = 0;
  if ( is_T11() )
  {
    fp = fopen("/dev/83601_8pattern.txt", "r");
  }
  else if ( is_T11a() )
  {
    fp = fopen("/dev/83602_8pattern.txt", "r");
  }
  else
  {
    if ( !is_T11b() )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "Assert fail!! %s:%d: unkown type, prepare test pattern file yourself", "freq_scan.c", 335);
      fclose(pFile_0);
      _assert_fail("0", "freq_scan.c", 0x14Fu, (const char *)_PRETTY_FUNCTION___14465);
    }
    fp = fopen("/dev/83603_8pattern.txt", "r");
  }
  if ( fp )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= AsicNum )
      {
        fclose(fp);
        return 0;
      }
      asic_work_num = 0;
      scanfreq_info.works[i] = (SCAN_FREQ_WORK *)malloc(116 * scanfreq_info.AsicWorkCount);
      if ( !scanfreq_info.works[i] )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(pFile_2, "%s:%d:%s: malloc struct work err\n", "freq_scan.c", 349, (const char *)_FUNCTION___14461);
          fclose(pFile_2);
        }
        return -1;
      }
      for ( j = 0; j < CoreNum; ++j )
      {
        work_of_core_one_file = scan_freq_get_work_of_core_one_file(i, j, &fp, scanfreq_info.AsicWorkCount / CoreNum);
        asic_work_num += work_of_core_one_file;
      }
      if ( asic_work_num < scanfreq_info.AsicWorkCount )
        break;
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: Error: Asic %d get %d work, required work=%d\n",
          "freq_scan.c",
          360,
          (const char *)_FUNCTION___14461,
          i,
          asic_work_num,
          scanfreq_info.AsicWorkCount);
      fclose(pFile_3);
    }
    fclose(fp);
    return -1;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: !!!!!!!!!!!!!! Open pattern file error\n",
          "freq_scan.c",
          339,
          (const char *)_FUNCTION___14461);
      fclose(pFile_1);
    }
    return -1;
  }
}

//----- (0003056A) --------------------------------------------------------
void __cdecl Nonce_Match_1(int chain, unsigned int buf, unsigned int which_pattern)
{
  FILE *pFile; // [sp+24h] [bp+14h]
  unsigned int whose_nonce; // [sp+28h] [bp+18h]

  whose_nonce = HIBYTE(buf) / dev->addrInterval;
  if ( whose_nonce <= 0xFF )
  {
    ++scanfreq_info.asic_nonce_num[chain][whose_nonce];
    ++scanfreq_info.asic_core_nonce_num[0][whose_nonce + (chain << 8)][(unsigned __int8)buf];
    ++scanfreq_info.valid_nonce_num[chain];
    scanfreq_info.works[whose_nonce][which_pattern
                                   + (unsigned __int8)buf * (scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum)].is_nonce_return_back[chain] = 1;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: buf [%x] is error!\n",
        "freq_scan.c",
        380,
        (const char *)_FUNCTION___14483,
        (const char *)_FUNCTION___14483,
        buf);
    fclose(pFile);
  }
}
// 305A8: conditional instruction was optimized away because %which_core_nonce.4<100u

//----- (00030730) --------------------------------------------------------
void *__cdecl __noreturn scanfreq_receive_nonce_register(void *arg)
{
  __int16 nonce_number_in_fifo; // r0
  SCAN_FREQ_WORK *v2; // r2
  unsigned int buf[2]; // [sp+8h] [bp+8h] BYREF
  SCAN_FREQ_WORK *work_1; // [sp+10h] [bp+10h]
  int chainIndex; // [sp+14h] [bp+14h]
  unsigned __int8 which_pattern; // [sp+1Bh] [bp+1Bh]
  unsigned int m_nonce; // [sp+1Ch] [bp+1Ch]
  unsigned __int8 ret; // [sp+23h] [bp+23h]
  unsigned int read_loop; // [sp+24h] [bp+24h]
  unsigned int nonce_number; // [sp+28h] [bp+28h]
  unsigned int work_id; // [sp+2Ch] [bp+2Ch]
  uint8_t which_core_nonce; // [sp+32h] [bp+32h]
  uint8_t which_asic_nonce; // [sp+33h] [bp+33h]
  SCAN_FREQ_WORK *work_3; // [sp+34h] [bp+34h]
  SCAN_FREQ_WORK *work_2; // [sp+38h] [bp+38h]
  unsigned int j; // [sp+3Ch] [bp+3Ch]

  work_id = 0;
  j = 0;
  nonce_number = 0;
  read_loop = 0;
  buf[0] = 0;
  buf[1] = 0;
  ret = 0;
  m_nonce = 0;
  which_asic_nonce = 0;
  which_core_nonce = 0;
  which_pattern = 0;
  chainIndex = 0;
  do
  {
LABEL_2:
    usleep(0x3E8u);
    read_loop = 0;
    nonce_number_in_fifo = get_nonce_number_in_fifo();
    nonce_number = nonce_number_in_fifo & 0x1FF;
  }
  while ( (nonce_number_in_fifo & 0x1FF) == 0 );
  read_loop = nonce_number;
  for ( j = 0; ; ++j )
  {
    if ( j >= read_loop )
      goto LABEL_2;
    get_return_nonce(buf);
    if ( (buf[0] & 0x80000000) == 0 )
    {
      if ( reg_value_buf.reg_value_num <= 0x1FE && reg_value_buf.p_wr <= 0x1FE )
      {
        pthread_mutex_lock(&reg_mutex);
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = buf[1];
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = HIBYTE(buf[0]) & 0x1F;
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].chip_address = BYTE2(buf[0]);
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_address = BYTE1(buf[0]);
        reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = buf[0] & 0xF;
        if ( reg_value_buf.p_wr >= 0x1FE )
          reg_value_buf.p_wr = 0;
        else
          ++reg_value_buf.p_wr;
        if ( reg_value_buf.reg_value_num > 0x1FE )
          reg_value_buf.reg_value_num = 511;
        else
          ++reg_value_buf.reg_value_num;
        pthread_mutex_unlock(&reg_mutex);
      }
      else
      {
        clear_register_value_buf();
      }
    }
    else if ( gBegin_get_nonce && (buf[0] & 0x80) != 0 && (buf[0] & 0x40) == 0 && (buf[0] & 0x20) == 0 )
    {
      chainIndex = buf[0] & 0xF;
      if ( (unsigned int)chainIndex <= 0xF && dev->chain_exist[chainIndex] && !scanfreq_info.test_done[chainIndex] )
      {
        ++scanfreq_info.ret_nonce_num[chainIndex];
        which_pattern = (unsigned int)(HIWORD(buf[0]) & 0x7FFF) >> 7;
        work_id = BYTE2(buf[0]) & 0x7F;
        if ( dev->addrInterval )
        {
          which_asic_nonce = HIBYTE(buf[1]) / dev->addrInterval;
          which_core_nonce = buf[1];
          if ( which_asic_nonce >= scanfreq_info.AsicNum )
            continue;
        }
        else
        {
          which_asic_nonce = buf[1] >> 26;
          if ( which_asic_nonce >= scanfreq_info.AsicNum )
            continue;
        }
        if ( work_id <= 0x80 )
        {
          m_nonce = scanfreq_info.send_work[chainIndex][work_id].nonce;
          if ( m_nonce == buf[1] )
          {
            if ( which_pattern < scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum )
            {
              if ( scanfreq_info.works[which_asic_nonce][which_pattern
                                                       + scanfreq_info.AsicWorkCount
                                                       / scanfreq_info.CoreNum
                                                       * which_core_nonce].is_nonce_return_back[chainIndex] )
              {
                v2 = &scanfreq_info.works[which_asic_nonce][which_pattern
                                                          + scanfreq_info.AsicWorkCount
                                                          / scanfreq_info.CoreNum
                                                          * which_core_nonce];
                ++v2->is_nonce_return_back[chainIndex];
                ++scanfreq_info.repeated_nonce_num[chainIndex];
              }
              else
              {
                scanfreq_nonce_calc(chainIndex, buf[1]);
                Nonce_Match_1(chainIndex, buf[1], which_pattern);
              }
            }
            else
            {
              ++scanfreq_info.other_nonce_num[chainIndex];
            }
          }
          else
          {
            work_1 = &scanfreq_info.send_work[chainIndex][work_id];
            if ( work_id <= 1 )
            {
              if ( work_id == 1 )
              {
                work_2 = scanfreq_info.send_work[chainIndex];
                work_3 = &scanfreq_info.send_work[chainIndex][127];
              }
              else
              {
                work_2 = &scanfreq_info.send_work[chainIndex][127];
                work_3 = &scanfreq_info.send_work[chainIndex][126];
              }
            }
            else
            {
              work_2 = (SCAN_FREQ_WORK *)&scanfreq_info.ideal_hashrate[3712 * chainIndex + 3 + 29 * work_id];
              work_3 = (SCAN_FREQ_WORK *)&scanfreq_info.chain_nonce_rate[3712 * chainIndex + 6 + 29 * work_id];
            }
            ret = check_hw(work_1, buf[1], 0);
            if ( ret )
            {
              ret = check_hw(work_2, buf[1], 0);
              if ( ret )
              {
                ret = check_hw(work_3, buf[1], 0);
                if ( ret )
                  ++scanfreq_info.HW_nonce_num[chainIndex];
                else
                  ++scanfreq_info.other_nonce_num[chainIndex];
              }
              else
              {
                ++scanfreq_info.other_nonce_num[chainIndex];
              }
            }
            else
            {
              ++scanfreq_info.other_nonce_num[chainIndex];
            }
          }
        }
        else
        {
          printf("Error: work_id=%d\n", work_id);
        }
      }
    }
  }
}
// 30B48: conditional instruction was optimized away because %work_id.4==0

//----- (00030E04) --------------------------------------------------------
void scan_freq_init_info()
{
  int column; // [sp+0h] [bp+0h]
  int chain; // [sp+4h] [bp+4h]

  memset(&scanfreq_info, 0, (size_t)&pattern_info_t.asic_core_enabled_flag[9][39][4]);
  scanfreq_info.AsicNum = 60;
  scanfreq_info.CoreNum = 208;
  if ( test_8pattern )
    scanfreq_info.AsicWorkCount = 8 * scanfreq_info.CoreNum;
  else
    scanfreq_info.AsicWorkCount = scanfreq_info.CoreNum;
  if ( check_column_nonce )
    scanfreq_info.RequiredChainNonce = scanfreq_info.AsicNum * scanfreq_info.AsicWorkCount / 10;
  else
    scanfreq_info.RequiredChainNonce = scanfreq_info.AsicNum * scanfreq_info.AsicWorkCount;
  scanfreq_info.RequiredAsicNonce = scanfreq_info.AsicWorkCount;
  scanfreq_info.PassNonceRate = 0.99;
  strcpy((char *)scanfreq_info.workdataPathPrefix, "/log/minertest64-BM1393/btc-asic-");
  strcpy((char *)scanfreq_info.workdataFilePrefix, "/btc-core-");
  scanfreq_info.freq_step = 5;
  scan_base_freq[0] = g_sweep_config_eco.sweep_max_freq;
  scan_base_freq[1] = g_sweep_config_hpf.sweep_max_freq;
  for ( chain = 0; chain <= 15; ++chain )
  {
    for ( column = 0; column <= 9; ++column )
    {
      scanfreq_info.base_freq_index[chain] = 0;
      scanfreq_info.base_freq[chain] = scan_base_freq[scanfreq_info.base_freq_index[chain]];
      scanfreq_info.freq_index_min[chain][column] = 0;
      scanfreq_info.freq_index_max[chain][column] = 40;
      scanfreq_info.domain_last_freq_level[chain][column] = 0;
      scanfreq_info.current_is_pass[chain][column] = 1;
    }
  }
}

//----- (00031080) --------------------------------------------------------
int scan_freq_get_min_base_freq()
{
  int min_freq; // [sp+0h] [bp+0h]
  int chain; // [sp+4h] [bp+4h]

  min_freq = 1000;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] && min_freq > scanfreq_info.base_freq[chain] )
      min_freq = scanfreq_info.base_freq[chain];
  }
  return min_freq;
}

//----- (00031112) --------------------------------------------------------
int scan_freq_prepare()
{
  FILE *pFile_0; // [sp+Ch] [bp+4h]
  FILE *pFile; // [sp+10h] [bp+8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: scan_freq_prepare\n", "freq_scan.c", 894, (const char *)_FUNCTION___14574);
    fclose(pFile);
  }
  scan_freq_init_info();
  if ( scanfreq_get_works() >= 0 )
  {
    pthread_create(&receive_id, 0, (void *(*)(void *))scanfreq_receive_nonce_register, 0);
    pthread_detach(receive_id);
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: scanfreq get works failed\n", "freq_scan.c", 900, (const char *)_FUNCTION___14574);
      fclose(pFile_0);
    }
    return -1;
  }
}

//----- (00031238) --------------------------------------------------------
void __cdecl san_freq_clear_nonce_return_back_flag(int chain)
{
  SCAN_FREQ_WORK *works; // [sp+10h] [bp+10h]
  int n; // [sp+14h] [bp+14h]
  int j; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  for ( i = 0; i < scanfreq_info.AsicNum; ++i )
  {
    works = scanfreq_info.works[i];
    for ( n = 0; n < scanfreq_info.CoreNum; ++n )
    {
      for ( j = 0; j < scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum; ++j )
        works[j + n * (scanfreq_info.AsicWorkCount / scanfreq_info.CoreNum)].is_nonce_return_back[chain] = 0;
    }
  }
}

//----- (0003130E) --------------------------------------------------------
void scan_freq_reset_result()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( !scanfreq_info.test_done[chain] )
      {
        memset(scanfreq_info.asic_nonce_num[chain], 0, sizeof(scanfreq_info.asic_nonce_num[chain]));
        memset(scanfreq_info.asic_core_nonce_num[chain], 0, sizeof(scanfreq_info.asic_core_nonce_num[chain]));
        scanfreq_info.send_work_num[chain] = 0;
        scanfreq_info.ret_nonce_num[chain] = 0;
        scanfreq_info.repeated_nonce_num[chain] = 0;
        scanfreq_info.other_nonce_num[chain] = 0;
        scanfreq_info.HW_nonce_num[chain] = 0;
        scanfreq_info.valid_nonce_num[chain] = 0;
        san_freq_clear_nonce_return_back_flag(chain);
      }
    }
  }
}

//----- (0003143C) --------------------------------------------------------
void scan_freq_send_work()
{
  int nonce_fifo_interrupt; // r0
  unsigned int buf_vil[13]; // [sp+10h] [bp+0h] BYREF
  vil_work_1387 work_vil_1387; // [sp+44h] [bp+34h] BYREF
  SCAN_FREQ_WORK *work; // [sp+78h] [bp+68h]
  SCAN_FREQ_WORK *works; // [sp+7Ch] [bp+6Ch]
  int column; // [sp+80h] [bp+70h]
  FILE *pFile_0; // [sp+84h] [bp+74h]
  FILE *pFile_1; // [sp+88h] [bp+78h]
  FILE *pFile; // [sp+8Ch] [bp+7Ch]
  int AsicNum; // [sp+90h] [bp+80h]
  int CoreNum; // [sp+94h] [bp+84h]
  unsigned int work_fifo_ready; // [sp+98h] [bp+88h]
  int wait_count; // [sp+9Ch] [bp+8Ch]
  int last_recv_num; // [sp+A0h] [bp+90h]
  unsigned int work_id; // [sp+A4h] [bp+94h]
  int which_pattern; // [sp+A8h] [bp+98h]
  int which_core; // [sp+ACh] [bp+9Ch]
  int which_asic; // [sp+B0h] [bp+A0h]
  int chain; // [sp+B4h] [bp+A4h]
  int j; // [sp+B8h] [bp+A8h]
  int i; // [sp+BCh] [bp+ACh]
  __int64 savedregs; // [sp+C0h] [bp+B0h] BYREF

  chain = 0;
  which_asic = 0;
  which_core = 0;
  which_pattern = 0;
  work_fifo_ready = 0;
  work_id = 0;
  memset(buf_vil, 0, sizeof(buf_vil));
  CoreNum = scanfreq_info.CoreNum;
  AsicNum = scanfreq_info.AsicNum;
  last_recv_num = 0;
  wait_count = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: start send work\n", "freq_scan.c", 962, (const char *)_FUNCTION___14620);
    fclose(pFile);
  }
  gBegin_get_nonce = 1;
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
    {
      for ( which_asic = 0; which_asic < AsicNum; ++which_asic )
      {
        if ( check_column_nonce )
        {
          column = get_logical_column_by_chip_no(which_asic);
          if ( column != scanfreq_info.current_column[chain] || scanfreq_info.current_column_finish[chain][column] )
            continue;
        }
        works = scanfreq_info.works[which_asic];
        for ( which_core = 0; which_core < CoreNum; ++which_core )
        {
          for ( which_pattern = 0; which_pattern < scanfreq_info.AsicWorkCount / CoreNum; ++which_pattern )
          {
            while ( 1 )
            {
              work_fifo_ready = get_buffer_space();
              if ( (work_fifo_ready & (1 << chain)) != 0 )
                break;
              usleep(0x3E8u);
            }
            memset(buf_vil, 0, sizeof(buf_vil));
            work = &works[which_pattern + which_core * (scanfreq_info.AsicWorkCount / CoreNum)];
            memset(&work_vil_1387, 0, sizeof(work_vil_1387));
            work_vil_1387.work_type = 1;
            work_vil_1387.chain_id = chain | 0x80;
            work_vil_1387.reserved1[0] = 0;
            work_vil_1387.reserved1[1] = 0;
            if ( ++work_id > 0x7F )
              work_id = 0;
            work_vil_1387.work_count = work_id & 0x7F | (which_pattern << 7);
            memcpy(&scanfreq_info.send_work[chain][work_id], work, sizeof(scanfreq_info.send_work[chain][work_id]));
            for ( i = 0; i <= 11; ++i )
              work_vil_1387.data[i] = work->data[i];
            for ( i = 0; i <= 31; ++i )
              work_vil_1387.midstate[i] = work->midstate[i];
            buf_vil[0] = _byteswap_ulong(*(unsigned int *)&work_vil_1387.work_type);
            buf_vil[1] = work_vil_1387.work_count;
            for ( j = 2; (unsigned int)j <= 4; ++j )
              buf_vil[j] = (*((unsigned __int8 *)&savedregs + 4 * j - 122) << 8) | (*((unsigned __int8 *)&savedregs
                                                                                    + 4 * j
                                                                                    - 124) << 24) | (*((unsigned __int8 *)&savedregs + 4 * j - 123) << 16) | *((unsigned __int8 *)&savedregs + 4 * j - 121);
            for ( j = 5; (unsigned int)j <= 0xC; ++j )
              buf_vil[j] = (*((unsigned __int8 *)&savedregs + 4 * j - 122) << 8) | (*((unsigned __int8 *)&savedregs
                                                                                    + 4 * j
                                                                                    - 124) << 24) | (*((unsigned __int8 *)&savedregs + 4 * j - 123) << 16) | *((unsigned __int8 *)&savedregs + 4 * j - 121);
            set_TW_write_command_vil(buf_vil);
            ++scanfreq_info.send_work_num[chain];
          }
        }
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Chain[%d] send %d works\n",
            "freq_scan.c",
            1052,
            (const char *)_FUNCTION___14620,
            chain,
            scanfreq_info.send_work_num[chain]);
        fclose(pFile_0);
      }
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: wait for receiving nonce\n", "freq_scan.c", 1056, (const char *)_FUNCTION___14620);
    fclose(pFile_1);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
    {
      last_recv_num = 0;
      wait_count = 0;
      while ( wait_count <= 2 && scanfreq_info.valid_nonce_num[chain] < scanfreq_info.RequiredChainNonce )
      {
        if ( last_recv_num == scanfreq_info.valid_nonce_num[chain] )
        {
          ++wait_count;
        }
        else
        {
          wait_count = 0;
          last_recv_num = scanfreq_info.valid_nonce_num[chain];
        }
        usleep(0x186A0u);
      }
    }
  }
  gBegin_get_nonce = 0;
}

//----- (00031B28) --------------------------------------------------------
bool __cdecl scan_freq_check_result(int chain)
{
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile; // [sp+14h] [bp+Ch]
  FILE *pFile_1; // [sp+18h] [bp+10h]
  int column; // [sp+1Ch] [bp+14h]
  int m; // [sp+20h] [bp+18h]
  int i; // [sp+24h] [bp+1Ch]

  column = 0;
  for ( i = 0; i < scanfreq_info.AsicNum; ++i )
  {
    if ( check_column_nonce )
    {
      column = get_logical_column_by_chip_no(i);
      if ( column != scanfreq_info.current_column[chain] )
        continue;
    }
    if ( log_level > 3 )
    {
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "check chain %d column %d asic %d", chain, column, i);
      fclose(pFile);
    }
    for ( m = 0; m <= 207; ++m )
    {
      if ( scanfreq_info.asic_core_nonce_num[0][i + (chain << 8)][m] <= 1 )
      {
        if ( log_level > 3 )
        {
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "check fail: chain %d asic %d core %d return %d nonce",
              chain,
              i,
              m,
              scanfreq_info.asic_core_nonce_num[0][i + (chain << 8)][m]);
          fclose(pFile_0);
        }
        return 0;
      }
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: check ok: chain %d \n", "freq_scan.c", 1109, (const char *)_FUNCTION___14674, chain);
    fclose(pFile_1);
  }
  return 1;
}

//----- (00031CF6) --------------------------------------------------------
void scan_freq_send_work_and_check_result()
{
  FILE *pFile_8; // [sp+10h] [bp+0h]
  FILE *pFile_9; // [sp+14h] [bp+4h]
  FILE *pFile_7; // [sp+18h] [bp+8h]
  FILE *pFile_6; // [sp+1Ch] [bp+Ch]
  FILE *pFile_5; // [sp+20h] [bp+10h]
  FILE *pFile_4; // [sp+24h] [bp+14h]
  FILE *pFile_3; // [sp+28h] [bp+18h]
  FILE *pFile_2; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_1; // [sp+30h] [bp+20h]
  FILE *pFile_0; // [sp+34h] [bp+24h]
  FILE *pFile; // [sp+38h] [bp+28h]
  int pass_nonce_num; // [sp+3Ch] [bp+2Ch]
  bool is_pass; // [sp+43h] [bp+33h]
  int i; // [sp+44h] [bp+34h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: send work and check result\n", "freq_scan.c", 1116, (const char *)_FUNCTION___14678);
    fclose(pFile);
  }
  if ( check_column_nonce )
  {
    scanfreq_info.RequiredChainNonce = scanfreq_info.AsicNum * scanfreq_info.AsicWorkCount / 10;
    pass_nonce_num = (int)(float)(scanfreq_info.PassNonceRate
                                * (float)(scanfreq_info.AsicNum * scanfreq_info.AsicWorkCount / 10));
  }
  else
  {
    scanfreq_info.RequiredChainNonce = scanfreq_info.AsicNum * scanfreq_info.AsicWorkCount;
    pass_nonce_num = (int)(float)(scanfreq_info.PassNonceRate
                                * (float)(scanfreq_info.AsicNum * scanfreq_info.AsicWorkCount));
  }
  scan_freq_reset_result();
  scan_freq_send_work();
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] && !scanfreq_info.test_done[i] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: \n", "freq_scan.c", 1143, (const char *)_FUNCTION___14678);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: chain[%d] base freq is %d\n",
            "freq_scan.c",
            1144,
            (const char *)_FUNCTION___14678,
            i,
            scanfreq_info.base_freq[i]);
        fclose(pFile_1);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: chain[%d] total valid nonce number:    %d\n",
            "freq_scan.c",
            1145,
            (const char *)_FUNCTION___14678,
            i,
            scanfreq_info.valid_nonce_num[i]);
        fclose(pFile_2);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: chain[%d] total send work number:      %d\n",
            "freq_scan.c",
            1146,
            (const char *)_FUNCTION___14678,
            i,
            scanfreq_info.send_work_num[i]);
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: chain[%d] require valid nonce number:  %d\n",
            "freq_scan.c",
            1147,
            (const char *)_FUNCTION___14678,
            i,
            pass_nonce_num);
        fclose(pFile_4);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: chain[%d] hw nonce number:       %d\n",
            "freq_scan.c",
            1148,
            (const char *)_FUNCTION___14678,
            i,
            scanfreq_info.HW_nonce_num[i]);
        fclose(pFile_5);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: chain[%d] repeated nonce number: %d\n",
            "freq_scan.c",
            1149,
            (const char *)_FUNCTION___14678,
            i,
            scanfreq_info.repeated_nonce_num[i]);
        fclose(pFile_6);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(
            pFile_7,
            "%s:%d:%s: chain[%d] other nonce number:    %d\n",
            "freq_scan.c",
            1150,
            (const char *)_FUNCTION___14678,
            i,
            scanfreq_info.other_nonce_num[i]);
        fclose(pFile_7);
      }
      if ( check_nonce_rate )
        is_pass = pass_nonce_num < scanfreq_info.valid_nonce_num[i];
      else
        is_pass = scan_freq_check_result(i);
      if ( is_pass )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_8 = fopen((const char *)log_file, "a+");
          if ( pFile_8 )
            fprintf(
              pFile_8,
              "%s:%d:%s: chain[%d] freq scan success!\n",
              "freq_scan.c",
              1160,
              (const char *)_FUNCTION___14678,
              i);
          fclose(pFile_8);
        }
      }
      else if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_9 = fopen((const char *)log_file, "a+");
        if ( pFile_9 )
          fprintf(
            pFile_9,
            "%s:%d:%s: chain[%d] freq scan failed!\n",
            "freq_scan.c",
            1166,
            (const char *)_FUNCTION___14678,
            i);
        fclose(pFile_9);
      }
    }
  }
}

//----- (000323B4) --------------------------------------------------------
void __cdecl scan_freq_print_nonce_zero_chip(int chain)
{
  FILE *pFile_1; // [sp+18h] [bp+8h]
  FILE *pFile_0; // [sp+20h] [bp+10h]
  FILE *pFile; // [sp+24h] [bp+14h]
  float nonce_rate; // [sp+28h] [bp+18h]
  int bad_core_num; // [sp+2Ch] [bp+1Ch]
  int m; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  nonce_rate = (float)((float)scanfreq_info.valid_nonce_num[chain] / (float)scanfreq_info.RequiredChainNonce) * 100.0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Chain %d Nonce rate: %.2f\n",
        "freq_scan.c",
        1449,
        (const char *)_FUNCTION___14811,
        chain,
        nonce_rate);
    fclose(pFile);
  }
  if ( nonce_rate < 40.0 )
  {
    low_rate_error_now = 1;
    ++low_rate_error;
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "low nonce rate on chain[%d]!!!      total [%d] times\n", chain, low_rate_error);
      fclose(pFile_0);
    }
  }
  if ( low_rate_error > 2 )
    stop_scan(14, chain);
  if ( check_column_nonce )
  {
    for ( i = 0; i < scanfreq_info.AsicNum; ++i )
    {
      if ( !check_column_nonce || get_logical_column_by_chip_no(i) == scanfreq_info.current_column[chain] )
      {
        bad_core_num = 0;
        for ( m = 0; m <= 207; ++m )
        {
          if ( !scanfreq_info.asic_core_nonce_num[0][i + (chain << 8)][m] )
            ++bad_core_num;
        }
      }
    }
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (00032604) --------------------------------------------------------
void scan_freq_print_noncerate_badchips()
{
  FILE *pFile; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
      scan_freq_print_nonce_zero_chip(i);
  }
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fputc(10, pFile);
    fclose(pFile);
  }
}

//----- (00032680) --------------------------------------------------------
void __cdecl scan_freq_print_inbalance_region(int freq_scan_times)
{
  FILE *pFile_1; // [sp+10h] [bp+8h]
  FILE *pFile_0; // [sp+14h] [bp+Ch]
  FILE *pFile; // [sp+18h] [bp+10h]
  int chain; // [sp+1Ch] [bp+14h]

  memset(inbalance_info_record, 0, sizeof(inbalance_info_record));
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      scan_freq_print_inbalance_region_by_chain(chain, freq_scan_times);
      if ( log_level > 3 )
      {
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "vol num = %d\n", inbalance_info_record[chain].len);
        fclose(pFile);
      }
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "inbalance vol = %d,%d,%d,%d\n",
            inbalance_info_record[chain].vol0,
            inbalance_info_record[chain].vol1,
            inbalance_info_record[chain].vol2,
            inbalance_info_record[chain].vol3);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fputc(10, pFile_1);
        fclose(pFile_1);
      }
    }
  }
}

//----- (00032818) --------------------------------------------------------
void __cdecl scan_freq_print_inbalance_region_by_chain(int chain, int freq_scan_times)
{
  int bad_core[6]; // [sp+Ch] [bp+Ch] BYREF
  FILE *pFile_1; // [sp+24h] [bp+24h]
  FILE *pFile_0; // [sp+28h] [bp+28h]
  FILE *pFile; // [sp+2Ch] [bp+2Ch]
  FILE *pFile_2; // [sp+30h] [bp+30h]
  FILE *pFile_3; // [sp+34h] [bp+34h]
  int chip; // [sp+38h] [bp+38h]
  unsigned __int8 inbalance_vol_num; // [sp+3Eh] [bp+3Eh]
  bool handle_flag; // [sp+3Fh] [bp+3Fh]
  int core; // [sp+40h] [bp+40h]
  int vol_region; // [sp+44h] [bp+44h]
  int v14; // [sp+48h] [bp+48h] BYREF

  chip = 0;
  core = 0;
  memset(bad_core, 0, sizeof(bad_core));
  handle_flag = 0;
  inbalance_vol_num = 0;
  for ( vol_region = 0; vol_region <= 5; ++vol_region )
  {
    *(&v14 + vol_region - 15) = 0;
    chip = get_physical_chip_no(vol_region, 0);
    if ( log_level > 4 )
    {
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "chip[%3d]\n", chip);
      fclose(pFile);
    }
    for ( core = 0; core <= 207; ++core )
    {
      if ( scanfreq_info.asic_core_nonce_num[0][chip + (chain << 8)][core] < scanfreq_info.AsicWorkCount / 208 )
        ++*(&v14 + vol_region - 15);
    }
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "domain[%2d] bad cores:[%3d]\n", vol_region + 1, *(&v14 + vol_region - 15));
      fclose(pFile_0);
    }
    if ( *(&v14 + vol_region - 15) > 51 )
    {
      handle_flag = 1;
      if ( inbalance_vol_num )
      {
        switch ( inbalance_vol_num )
        {
          case 1u:
            inbalance_info_record[chain].vol1 = vol_region + 1;
            break;
          case 2u:
            inbalance_info_record[chain].vol2 = vol_region + 1;
            break;
          case 3u:
            inbalance_info_record[chain].vol3 = vol_region + 1;
            break;
          default:
            if ( log_level > 3 )
            {
              pFile_1 = fopen((const char *)log_file, "a+");
              if ( pFile_1 )
                fprintf(pFile_1, "too much inbalance vol region[%d]\n", inbalance_vol_num + 1);
              fclose(pFile_1);
            }
            break;
        }
      }
      else
      {
        inbalance_info_record[chain].vol0 = vol_region + 1;
      }
      ++inbalance_vol_num;
    }
  }
  inbalance_info_record[chain].len = inbalance_vol_num;
  if ( !handle_flag )
  {
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "Chain[%d]  PASS!!!\n", chain);
      fclose(pFile_2);
    }
    scanfreq_info.test_done[chain] = 1;
  }
  else if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(pFile_3, "Chain[%d]  FAIL !!!\n", chain);
    fclose(pFile_3);
  }
}

//----- (00032B70) --------------------------------------------------------
void __cdecl adjust_freq_by_chain(int chain, int freq_scan_times, working_mode_e working_mode)
{
  int freq_scan_timesa; // [sp+10h] [bp+8h]
  int bad_core[6]; // [sp+1Ch] [bp+14h] BYREF
  FILE *pFile_5; // [sp+34h] [bp+2Ch]
  FILE *pFile_3; // [sp+38h] [bp+30h]
  FILE *pFile_4; // [sp+3Ch] [bp+34h]
  FILE *pFile_1; // [sp+40h] [bp+38h]
  FILE *pFile_2; // [sp+44h] [bp+3Ch]
  FILE *pFile; // [sp+48h] [bp+40h]
  FILE *pFile_0; // [sp+4Ch] [bp+44h]
  FILE *pFile_7; // [sp+50h] [bp+48h]
  FILE *pFile_6; // [sp+54h] [bp+4Ch]
  int chip; // [sp+58h] [bp+50h]
  float min_adjust_freq; // [sp+5Ch] [bp+54h]
  int invalid_region_num; // [sp+60h] [bp+58h]
  int bad_region_num; // [sp+64h] [bp+5Ch]
  int core; // [sp+68h] [bp+60h]
  int vol_region; // [sp+6Ch] [bp+64h]
  int v21; // [sp+70h] [bp+68h] BYREF

  vol_region = 0;
  chip = 0;
  core = 0;
  memset(bad_core, 0, sizeof(bad_core));
  bad_region_num = 0;
  invalid_region_num = 0;
  min_adjust_freq = 0.0;
  if ( working_mode )
    min_adjust_freq = (float)g_sweep_config_hpf.sweep_min_freq;
  else
    min_adjust_freq = (float)g_sweep_config_eco.sweep_min_freq;
  freq_scan_timesa = freq_scan_times - 1;
  for ( vol_region = 0; vol_region <= 5; ++vol_region )
  {
    *(&v21 + vol_region - 21) = 0;
    chip = get_physical_chip_no(vol_region, 0);
    for ( core = 0; core <= 207; ++core )
    {
      if ( scanfreq_info.asic_core_nonce_num[0][chip + (chain << 8)][core] < scanfreq_info.AsicWorkCount / 208 )
        ++*(&v21 + vol_region - 21);
    }
    if ( *(&v21 + vol_region - 21) > 51 )
      ++bad_region_num;
    if ( *(&v21 + vol_region - 21) && (*(&v21 + vol_region - 21) <= 0 || *(&v21 + vol_region - 21) > 51) )
    {
      if ( *(&v21 + vol_region - 21) <= 51 || *(&v21 + vol_region - 21) > 103 )
      {
        if ( *(&v21 + vol_region - 21) <= 103 || *(&v21 + vol_region - 21) > 155 )
        {
          if ( *(&v21 + vol_region - 21) <= 155 || *(&v21 + vol_region - 21) > 208 )
          {
            if ( log_level > 3 )
            {
              pFile_5 = fopen((const char *)log_file, "a+");
              if ( pFile_5 )
                fwrite("wrong bad core number!\n", 1u, 0x17u, pFile_5);
              fclose(pFile_5);
            }
          }
          else if ( min_adjust_freq < freq_adjust_index[chain][vol_region] )
          {
            freq_adjust_index[chain][vol_region] = freq_adjust_index[chain][vol_region]
                                                 - (float)(freq_adjust_step * 3.0);
            if ( min_adjust_freq > freq_adjust_index[chain][vol_region] )
              freq_adjust_index[chain][vol_region] = min_adjust_freq;
            if ( log_level > 3 )
            {
              pFile_4 = fopen((const char *)log_file, "a+");
              if ( pFile_4 )
                fprintf(
                  pFile_4,
                  "chain[%d] domain[%02d] to %f\n",
                  chain,
                  vol_region + 1,
                  freq_adjust_index[chain][vol_region]);
              fclose(pFile_4);
            }
          }
          else
          {
            if ( log_level > 3 )
            {
              pFile_3 = fopen((const char *)log_file, "a+");
              if ( pFile_3 )
                fwrite("The freq is low enough,jump!\n", 1u, 0x1Du, pFile_3);
              fclose(pFile_3);
            }
            ++invalid_region_num;
          }
        }
        else if ( min_adjust_freq < freq_adjust_index[chain][vol_region] )
        {
          freq_adjust_index[chain][vol_region] = freq_adjust_index[chain][vol_region]
                                               - (float)(freq_adjust_step + freq_adjust_step);
          if ( min_adjust_freq > freq_adjust_index[chain][vol_region] )
            freq_adjust_index[chain][vol_region] = min_adjust_freq;
          if ( log_level > 3 )
          {
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "chain[%d] domain[%02d] to %f\n",
                chain,
                vol_region + 1,
                freq_adjust_index[chain][vol_region]);
            fclose(pFile_2);
          }
        }
        else
        {
          if ( log_level > 3 )
          {
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fwrite("The freq is low enough,jump!\n", 1u, 0x1Du, pFile_1);
            fclose(pFile_1);
          }
          ++invalid_region_num;
        }
      }
      else if ( min_adjust_freq < freq_adjust_index[chain][vol_region] )
      {
        freq_adjust_index[chain][vol_region] = freq_adjust_index[chain][vol_region] - freq_adjust_step;
        if ( min_adjust_freq > freq_adjust_index[chain][vol_region] )
          freq_adjust_index[chain][vol_region] = min_adjust_freq;
        if ( log_level > 3 )
        {
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "chain[%d] domain[%02d] to %f\n",
              chain,
              vol_region + 1,
              freq_adjust_index[chain][vol_region]);
          fclose(pFile_0);
        }
      }
      else
      {
        if ( log_level > 3 )
        {
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fwrite("The freq is low enough,jump!\n", 1u, 0x1Du, pFile);
          fclose(pFile);
        }
        ++invalid_region_num;
      }
    }
  }
  if ( bad_region_num && bad_region_num == invalid_region_num )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "%s:%d:%s: chain[%d] early quit ...\n",
          "freq_scan.c",
          1754,
          (const char *)_FUNCTION___14908,
          chain);
      fclose(pFile_6);
    }
    force_scan_freq_is_finished_by_chain(chain);
    calc_ability_per_chain_recode[chain] = calc_ability_per_chain[freq_scan_timesa][chain];
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(
          pFile_7,
          "--record chain[%d] last value :%5.3f THash\n",
          chain,
          calc_ability_per_chain_recode[chain] / 1000.0);
      fclose(pFile_7);
    }
  }
}

//----- (00033350) --------------------------------------------------------
uint32_t __cdecl get_vol_region_nonce_number(uint32_t chain, uint32_t vol_region)
{
  uint32_t tmp; // [sp+8h] [bp+8h]
  uint32_t core; // [sp+Ch] [bp+Ch]
  uint32_t asic; // [sp+10h] [bp+10h]
  uint32_t nonce_number; // [sp+14h] [bp+14h]

  nonce_number = 0;
  for ( asic = 10 * vol_region; asic < 10 * (vol_region + 1); ++asic )
  {
    tmp = 0;
    for ( core = 0; core <= 0xCF; ++core )
      tmp += scanfreq_calc_nonce_info.chain_asic_core_nonce_num[chain][asic][core];
    nonce_number += tmp;
  }
  return nonce_number;
}

//----- (000333E8) --------------------------------------------------------
void __cdecl print_calculation_ability(int freq_scan_times)
{
  uint32_t vol_region_nonce_number; // r0
  float v2; // s15
  int freq_scan_timesa; // [sp+Ch] [bp+4h]
  float nonce_rate[16][6]; // [sp+14h] [bp+Ch] BYREF
  FILE *pFile_0; // [sp+194h] [bp+18Ch]
  FILE *pFile_1; // [sp+198h] [bp+190h]
  FILE *pFile; // [sp+19Ch] [bp+194h]
  FILE *pFile_3; // [sp+1A0h] [bp+198h]
  FILE *pFile_2; // [sp+1A4h] [bp+19Ch]
  float required_vol_region_nonce; // [sp+1A8h] [bp+1A0h]
  float tmp; // [sp+1ACh] [bp+1A4h]
  uint32_t vol_region; // [sp+1B0h] [bp+1A8h]
  uint32_t chain; // [sp+1B4h] [bp+1ACh]

  vol_region = 0;
  tmp = 0.0;
  memset(nonce_rate, 0, sizeof(nonce_rate));
  required_vol_region_nonce = (float)scanfreq_info.RequiredChainNonce / 6.0;
  freq_scan_timesa = freq_scan_times - 1;
  for ( chain = 0; chain <= 0xF; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( vol_region = 0; vol_region <= 5; ++vol_region )
      {
        vol_region_nonce_number = get_vol_region_nonce_number(chain, vol_region);
        nonce_rate[chain][vol_region] = (float)vol_region_nonce_number / required_vol_region_nonce;
        v2 = (float)((float)(freq_adjust_index[chain][vol_region] * 208.0) * 10.0)
           / 1000.0
           * nonce_rate[chain][vol_region];
        tmp = v2;
        calc_ability_per_chain[freq_scan_timesa][chain] = calc_ability_per_chain[freq_scan_timesa][chain] + v2;
      }
      if ( log_level > 3 )
      {
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "chain[%d] calc power:%5.3f THash\n",
            chain,
            calc_ability_per_chain[freq_scan_timesa][chain] / 1000.0);
        fclose(pFile);
      }
      if ( scanfreq_info.test_done[chain] )
      {
        if ( calc_ability_per_chain_recode[chain] == 0.0 )
        {
          calc_ability_per_chain_recode[chain] = calc_ability_per_chain[freq_scan_timesa][chain];
          if ( log_level > 3 )
          {
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "--record chain[%d] final :%5.3f THash\n",
                chain,
                calc_ability_per_chain_recode[chain] / 1000.0);
            fclose(pFile_0);
          }
        }
        else
        {
          calc_ability_per_chain[freq_scan_timesa][chain] = calc_ability_per_chain_recode[chain];
          if ( log_level > 3 )
          {
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "--replace chain[%d] final: %5.3f THash to calc...\n",
                chain,
                calc_ability_per_chain[freq_scan_timesa][chain] / 1000.0);
            fclose(pFile_1);
          }
        }
      }
      calc_ability[freq_scan_timesa] = calc_ability[freq_scan_timesa] + calc_ability_per_chain[freq_scan_timesa][chain];
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(
        pFile_2,
        "\ntimes[%d]:calc power:%5.3f THash\n",
        freq_scan_timesa + 1,
        calc_ability[freq_scan_timesa] / 1000.0);
    fclose(pFile_2);
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (00033898) --------------------------------------------------------
void __cdecl choose_best_freq_array(int freq_scan_times)
{
  int freq_scan_timesa; // [sp+1Ch] [bp+4h]
  FILE *pFile_0; // [sp+20h] [bp+8h]
  FILE *pFile; // [sp+24h] [bp+Ch]

  freq_scan_timesa = freq_scan_times - 1;
  if ( freq_scan_times == 1 )
  {
    memcpy(freq_adjust_record, freq_adjust_index, sizeof(freq_adjust_record));
    scanfreq_best_times = 0;
    memcpy(inbalance_info, inbalance_info_record, sizeof(inbalance_info));
  }
  else if ( calc_ability[freq_scan_timesa] > calc_ability[scanfreq_best_times] )
  {
    if ( log_level > 3 )
    {
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fwrite("replacing the best freq array...\n", 1u, 0x21u, pFile);
      fclose(pFile);
    }
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%5.3f [%d times]replace %5.3f [%d times]\n",
          (float)(calc_ability[freq_scan_timesa] / 1000.0),
          freq_scan_timesa + 1,
          (float)(calc_ability[scanfreq_best_times] / 1000.0),
          scanfreq_best_times + 1);
      fclose(pFile_0);
    }
    scanfreq_best_times = freq_scan_timesa;
    memcpy(freq_adjust_record, freq_adjust_index, sizeof(freq_adjust_record));
    memcpy(inbalance_info, inbalance_info_record, sizeof(inbalance_info));
  }
}

//----- (00033A68) --------------------------------------------------------
void print_freq_adjust_index()
{
  FILE *pFile_1; // [sp+Ch] [bp+4h]
  FILE *pFile_2; // [sp+10h] [bp+8h]
  FILE *pFile_3; // [sp+14h] [bp+Ch]
  FILE *pFile_0; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]
  uint32_t vol_region; // [sp+20h] [bp+18h]
  uint32_t chain; // [sp+24h] [bp+1Ch]

  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fwrite("freq to test:\n", 1u, 0xEu, pFile);
    fclose(pFile);
  }
  if ( log_level > 5 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fputc(10, pFile_0);
    fclose(pFile_0);
  }
  for ( chain = 0; chain <= 0xF; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( vol_region = 0; vol_region <= 5; ++vol_region )
      {
        if ( log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "V[%02d]:%3.0f ", vol_region + 1, freq_adjust_index[chain][vol_region]);
          fclose(pFile_1);
        }
      }
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fputc(10, pFile_2);
        fclose(pFile_2);
      }
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (00033C24) --------------------------------------------------------
void __cdecl adjust_freq_according_result(int freq_scan_times, working_mode_e working_mode)
{
  FILE *pFile_0; // [sp+Ch] [bp+Ch]
  FILE *pFile; // [sp+10h] [bp+10h]
  int chain; // [sp+14h] [bp+14h]

  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fputc(10, pFile);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      adjust_freq_by_chain(chain, freq_scan_times, working_mode);
  }
  if ( log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fputc(10, pFile_0);
    fclose(pFile_0);
  }
}

//----- (00033CE8) --------------------------------------------------------
bool scan_freq_is_all_chain_finished()
{
  FILE *pFile; // [sp+0h] [bp+0h]
  int chain_num; // [sp+4h] [bp+4h]
  int done_num; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  done_num = 0;
  chain_num = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      ++chain_num;
      if ( scanfreq_info.test_done[i] )
        ++done_num;
    }
  }
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "\nfinished %d of %d\n", done_num, chain_num);
    fclose(pFile);
  }
  return done_num == chain_num;
}

//----- (00033DA2) --------------------------------------------------------
void force_scan_freq_is_all_chain_finished()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int i; // [sp+Ch] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
      scanfreq_info.test_done[i] = 1;
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s:  force scan freq finished!\n", "freq_scan.c", 2016, (const char *)_FUNCTION___14994);
    fclose(pFile);
  }
}

//----- (00033E5C) --------------------------------------------------------
void __cdecl force_scan_freq_is_finished_by_chain(int chain)
{
  scanfreq_info.test_done[chain] = 1;
}

//----- (00033E86) --------------------------------------------------------
void __cdecl scan_freq_save_result_with_new_format(working_mode_e working_mode)
{
  uint32_t freq_asic[60]; // [sp+10h] [bp+8h] BYREF
  int asic; // [sp+100h] [bp+F8h]
  FILE *pFile; // [sp+104h] [bp+FCh]
  FILE *pFile_0; // [sp+108h] [bp+100h]
  int volt_region; // [sp+10Ch] [bp+104h]
  int column; // [sp+110h] [bp+108h]
  int chain; // [sp+114h] [bp+10Ch]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      memset(freq_asic, 0, sizeof(freq_asic));
      for ( column = 0; column <= 9; ++column )
      {
        for ( volt_region = 0; volt_region <= 5; ++volt_region )
        {
          asic = column + 10 * volt_region;
          freq_asic[asic] = (unsigned int)freq_adjust_index[chain][volt_region];
        }
      }
      if ( working_mode )
      {
        if ( !eeprom_set_freq_mode2(chain, freq_asic) )
          stop_scan(3, chain);
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(pFile_0, "%s:%d:%s: save freq for mode2\n", "freq_scan.c", 2209, (const char *)_FUNCTION___15099);
          fclose(pFile_0);
        }
      }
      else
      {
        if ( !eeprom_set_freq_mode1(chain, freq_asic) )
          stop_scan(3, chain);
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(pFile, "%s:%d:%s: save freq for mode1\n", "freq_scan.c", 2203, (const char *)_FUNCTION___15099);
          fclose(pFile);
        }
      }
    }
  }
}

//----- (000340AC) --------------------------------------------------------
void __cdecl scan_freq_save_more_result(working_mode_e working_mode)
{
  double v1; // d0
  double v2; // r2
  double v3; // r2
  FILE *pFile_2; // [sp+14h] [bp+Ch]
  FILE *pFile_1; // [sp+18h] [bp+10h]
  FILE *pFile_0; // [sp+1Ch] [bp+14h]
  FILE *pFile; // [sp+20h] [bp+18h]
  int chain; // [sp+24h] [bp+1Ch]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( !dev->chain_exist[chain] )
      continue;
    if ( working_mode )
    {
      if ( eeprom_set_hashrate_mode2(chain, (unsigned int)calc_ability_per_chain[scanfreq_best_times][chain]) )
        goto LABEL_8;
    }
    else if ( eeprom_set_hashrate_mode1(chain, (unsigned int)calc_ability_per_chain[scanfreq_best_times][chain]) )
    {
      goto LABEL_8;
    }
    stop_scan(3, chain);
LABEL_8:
    if ( log_level > 3 )
    {
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "chain[%d]\n", chain);
      fclose(pFile);
    }
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "vol num = %d\n", inbalance_info[chain].len);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "inbalance vol = %d,%d,%d,%d\n",
          inbalance_info[chain].vol0,
          inbalance_info[chain].vol1,
          inbalance_info[chain].vol2,
          inbalance_info[chain].vol3);
      fclose(pFile_1);
    }
    if ( working_mode == MODE1
      && !eeprom_set_inbalance_info(chain, &inbalance_info[chain].vol0, inbalance_info[chain].len) )
    {
      stop_scan(3, chain);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
      {
        get_working_voltage_by_chain(chain);
        fprintf(pFile_2, "chain[%d] working vol = %.2f\n", chain, v1);
      }
      fclose(pFile_2);
    }
    if ( working_mode )
    {
      get_working_voltage_by_chain(chain);
      if ( eeprom_set_voltage_mode2(chain, v3) )
        continue;
    }
    else
    {
      get_working_voltage_by_chain(chain);
      if ( eeprom_set_voltage_mode1(chain, v2) )
        continue;
    }
    stop_scan(3, chain);
  }
}
// 3434C: variable 'v1' is possibly undefined
// 34374: variable 'v2' is possibly undefined
// 343AA: variable 'v3' is possibly undefined

//----- (000343E0) --------------------------------------------------------
void scan_freq_done_mark()
{
  system("touch /config/scanfreqdone");
}

//----- (000343F4) --------------------------------------------------------
int scan_freq_already_done()
{
  FILE *fp; // [sp+4h] [bp+4h]

  fp = fopen("/config/scanfreqdone", "r");
  if ( !fp )
    return 0;
  fclose(fp);
  return 1;
}

//----- (0003442A) --------------------------------------------------------
void scan_freq_prepare_log()
{
  set_privite_log_file("/tmp/freqscanlog", &scanfreq_log_bak);
}

//----- (00034450) --------------------------------------------------------
void __cdecl init_freq_adjust_index(int base_freq)
{
  int domain; // [sp+8h] [bp+8h]
  int chain; // [sp+Ch] [bp+Ch]

  for ( chain = 0; chain <= 15; ++chain )
  {
    for ( domain = 0; domain <= 5; ++domain )
      freq_adjust_index[chain][domain] = (float)base_freq;
  }
}

//----- (000344B0) --------------------------------------------------------
void __cdecl scan_freq_get_next_base_freq(working_mode_e *working_mode)
{
  FILE *pFile; // [sp+18h] [bp+8h]
  FILE *pFile_1; // [sp+1Ch] [bp+Ch]
  FILE *pFile_0; // [sp+20h] [bp+10h]
  int chain; // [sp+24h] [bp+14h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
    {
      if ( scanfreq_info.base_freq_index[chain] + 1 > 1 )
      {
        scanfreq_info.last_all_pass = 1;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chain[%d] has no more base freq to test! finish!\n",
              "freq_scan.c",
              2314,
              (const char *)_FUNCTION___15141,
              chain);
          fclose(pFile);
        }
        return;
      }
      scanfreq_info.base_freq[chain] = scan_base_freq[++scanfreq_info.base_freq_index[chain]];
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: chain[%d] get next base freq %d\n",
            "freq_scan.c",
            2328,
            (const char *)_FUNCTION___15141,
            chain,
            scanfreq_info.base_freq[chain]);
        fclose(pFile_0);
      }
      if ( scanfreq_info.base_freq_index[chain] == 1 )
      {
        *working_mode = MODE2;
      }
      else if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: error,only 2 mode in T11\n", "freq_scan.c", 2336, (const char *)_FUNCTION___15141);
        fclose(pFile_1);
      }
      init_freq_adjust_index(g_sweep_config_hpf.sweep_max_freq);
    }
  }
}

//----- (00034736) --------------------------------------------------------
void __cdecl scan_freq_find_base_freq(working_mode_e working_mode)
{
  FILE *pFile_12; // [sp+14h] [bp+Ch]
  FILE *pFile_11; // [sp+18h] [bp+10h]
  FILE *pFile_10; // [sp+1Ch] [bp+14h]
  FILE *pFile_9; // [sp+20h] [bp+18h]
  FILE *pFile_8; // [sp+24h] [bp+1Ch]
  FILE *pFile_13; // [sp+28h] [bp+20h]
  FILE *pFile_7; // [sp+2Ch] [bp+24h]
  FILE *pFile_4; // [sp+30h] [bp+28h]
  FILE *pFile_3; // [sp+34h] [bp+2Ch]
  FILE *pFile_6; // [sp+38h] [bp+30h]
  FILE *pFile_5; // [sp+3Ch] [bp+34h]
  FILE *pFile_2; // [sp+40h] [bp+38h]
  FILE *pFile_1; // [sp+44h] [bp+3Ch]
  FILE *pFile_0; // [sp+48h] [bp+40h]
  FILE *pFile; // [sp+4Ch] [bp+44h]
  int freq_scan_times; // [sp+50h] [bp+48h]
  bool first_time; // [sp+57h] [bp+4Fh]

  first_time = 1;
  freq_scan_times = 0;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fwrite("=======================================\n", 1u, 0x28u, pFile);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "        scanfreq mode is MODE[%d]\n", working_mode + 1);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fwrite("=======================================\n", 1u, 0x28u, pFile_1);
    fclose(pFile_1);
  }
  while ( 1 )
  {
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "\nbegin to test ,[%d] times...\n\n", freq_scan_times + 1);
      fclose(pFile_2);
    }
    if ( first_time )
    {
      first_time = 0;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: first time to init the board...\n",
            "freq_scan.c",
            2402,
            (const char *)_FUNCTION___15176);
        fclose(pFile_3);
      }
      scan_freq_board_init(working_mode);
      first_time_init = 0;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: first time to init the board,done!\n",
            "freq_scan.c",
            2406,
            (const char *)_FUNCTION___15176);
        fclose(pFile_4);
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(pFile_5, "%s:%d:%s: re init...\n", "freq_scan.c", 2410, (const char *)_FUNCTION___15176);
        fclose(pFile_5);
      }
      scan_freq_board_init(working_mode);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(pFile_6, "%s:%d:%s: re init,done!\n", "freq_scan.c", 2412, (const char *)_FUNCTION___15176);
        fclose(pFile_6);
      }
    }
    low_rate_error_now = 0;
    ++freq_scan_times;
    init_read_temp_thread_in_force();
    print_freq_adjust_index();
    memset(&scanfreq_calc_nonce_info, 0, (size_t)&calc_nonce_info.chain_asic_core_nonce_num[1][51][143]);
    scan_freq_send_work_and_check_result();
    scan_freq_print_noncerate_badchips();
    scan_freq_print_inbalance_region(freq_scan_times);
    print_calculation_ability(freq_scan_times);
    choose_best_freq_array(freq_scan_times);
    shutdown_read_temp_thread_in_force();
    if ( freq_scan_times > 19 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(
            pFile_7,
            "%s:%d:%s: reach the max try times [%d]",
            "freq_scan.c",
            2437,
            (const char *)_FUNCTION___15176,
            20);
        fclose(pFile_7);
      }
      force_scan_freq_is_all_chain_finished();
    }
    if ( scan_freq_is_all_chain_finished() )
      break;
    if ( !low_rate_error_now )
    {
      adjust_freq_according_result(freq_scan_times, working_mode);
    }
    else if ( log_level > 3 )
    {
      pFile_13 = fopen((const char *)log_file, "a+");
      if ( pFile_13 )
        fwrite("low nonce rate !!! No need to change freq!!!\n", 1u, 0x2Du, pFile_13);
      fclose(pFile_13);
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fprintf(pFile_8, "%s:%d:%s: copy the best freq array...", "freq_scan.c", 2444, (const char *)_FUNCTION___15176);
    fclose(pFile_8);
  }
  memcpy(freq_adjust_index, freq_adjust_record, sizeof(freq_adjust_index));
  if ( log_level > 3 )
  {
    pFile_9 = fopen((const char *)log_file, "a+");
    if ( pFile_9 )
      fprintf(pFile_9, "freq scan [%d] times\n", freq_scan_times);
    fclose(pFile_9);
  }
  if ( log_level > 3 )
  {
    pFile_10 = fopen((const char *)log_file, "a+");
    if ( pFile_10 )
      fprintf(pFile_10, "best result at [%d] times\n", scanfreq_best_times + 1);
    fclose(pFile_10);
  }
  print_freq_adjust_index();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_11 = fopen((const char *)log_file, "a+");
    if ( pFile_11 )
      fprintf(pFile_11, "%s:%d:%s: freq scan,Done!\n", "freq_scan.c", 2452, (const char *)_FUNCTION___15176);
    fclose(pFile_11);
  }
  scan_freq_save_result_with_new_format(working_mode);
  scan_freq_save_more_result(working_mode);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_12 = fopen((const char *)log_file, "a+");
    if ( pFile_12 )
      fprintf(pFile_12, "%s:%d:%s: final freq scan,done!\n", "freq_scan.c", 2458, (const char *)_FUNCTION___15176);
    fclose(pFile_12);
  }
}

//----- (00034D7C) --------------------------------------------------------
void scan_freq_reset_scan_info()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      scanfreq_info.test_done[chain] = 0;
      scanfreq_info.current_column[chain] = 0;
      scanfreq_info.need_init = 0;
      memset(scanfreq_info.domain_freq_level[chain], 0, sizeof(scanfreq_info.domain_freq_level[chain]));
      memset(scanfreq_info.current_column_finish[chain], 0, sizeof(scanfreq_info.current_column_finish[chain]));
      memset(scanfreq_info.chip_max_freq[chain], 0, sizeof(scanfreq_info.chip_max_freq[chain]));
      memset(scanfreq_info.final_chip_freq[chain], 0, sizeof(scanfreq_info.final_chip_freq[chain]));
      memset(scanfreq_info.chip_rate[chain], 0, sizeof(scanfreq_info.chip_rate[chain]));
      memset(scanfreq_info.chip_sweep_failed[chain], 0, sizeof(scanfreq_info.chip_sweep_failed[chain]));
    }
  }
}

//----- (00034ED0) --------------------------------------------------------
void scan_freq_reset_scan_mark()
{
  low_rate_error = 0;
  low_rate_error_now = 0;
  first_time_init = 1;
  memset(freq_adjust_record, 0, sizeof(freq_adjust_record));
  cgsleep_ms(10);
  memset(calc_ability, 0, sizeof(calc_ability));
  memset(calc_ability_per_chain, 0, sizeof(calc_ability_per_chain));
  memset(calc_ability_per_chain_recode, 0, sizeof(calc_ability_per_chain_recode));
  cgsleep_ms(10);
  memset(&scanfreq_calc_nonce_info, 0, (size_t)&calc_nonce_info.chain_asic_core_nonce_num[1][51][143]);
  cgsleep_ms(10);
  low_rate_error = 0;
}

//----- (00034F74) --------------------------------------------------------
void scan_freq_start()
{
  working_mode_e working_mode; // [sp+8h] [bp+0h] BYREF
  FILE *pFile_0; // [sp+Ch] [bp+4h]
  FILE *pFile_1; // [sp+10h] [bp+8h]
  FILE *pFile; // [sp+14h] [bp+Ch]

  working_mode = MODE1;
  scan_freq_prepare_log();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: freq_scan_start .. \n", "freq_scan.c", 2582, (const char *)_FUNCTION___15227);
    fclose(pFile);
  }
  freq_scan_status = 0;
  is_freq_scan_succeeded_flag = 0;
  check_chain();
  check_hashboard_hardware_info();
  sleep(1u);
  init_freq_adjust_index(g_sweep_config_eco.sweep_max_freq);
  if ( scan_freq_prepare() < 0 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: freq_scan_prepare failed\n", "freq_scan.c", 2593, (const char *)_FUNCTION___15227);
      fclose(pFile_0);
    }
    freq_scan_status = 2;
    while ( 1 )
      sleep(0xAu);
  }
  check_nonce_rate = 1;
  do
  {
    scan_freq_reset_scan_mark();
    scan_freq_find_base_freq(working_mode);
    scan_freq_reset_scan_info();
    scan_freq_get_next_base_freq(&working_mode);
  }
  while ( !scanfreq_info.last_all_pass );
  eeprom_dump();
  scan_freq_done_mark();
  is_freq_scan_succeeded_flag = 1;
  aging_start();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: cancel the receive thread\n", "freq_scan.c", 2620, (const char *)_FUNCTION___15227);
    fclose(pFile_1);
  }
  pthread_cancel(receive_id);
  freq_scan_status = 1;
}

//----- (0003518E) --------------------------------------------------------
void scan_freq_mark_success()
{
  freq_scan_status = 1;
}

//----- (000351A8) --------------------------------------------------------
void scan_freq_scan_by_column()
{
  int diff; // [sp+Ch] [bp+4h]
  int diffa; // [sp+Ch] [bp+4h]
  timeval tv_end; // [sp+14h] [bp+Ch] BYREF
  timeval tv_start; // [sp+1Ch] [bp+14h] BYREF
  FILE *pFile_0; // [sp+24h] [bp+1Ch]
  FILE *pFile; // [sp+28h] [bp+20h]
  FILE *pFile_1; // [sp+2Ch] [bp+24h]

  cgtime(&tv_start);
  if ( scan_freq_already_done() )
  {
    freq_scan_status = 1;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: scan freq has already been done\n",
          "freq_scan.c",
          2645,
          (const char *)_FUNCTION___15241);
      fclose(pFile);
    }
    cgtime(&tv_end);
    diff = tv_end.tv_sec - tv_start.tv_sec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
      --diff;
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "\nFreq Scan Cost Time: %ld Minutes\n", diff / 60);
      fclose(pFile_0);
    }
  }
  else
  {
    check_column_nonce = 1;
    test_8pattern = 1;
    scan_freq_start();
    cgtime(&tv_end);
    diffa = tv_end.tv_sec - tv_start.tv_sec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
      --diffa;
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "\nFreq Scan Cost Time: %ld Minutes\n", diffa / 60);
      fclose(pFile_1);
    }
    eeprom_save();
  }
}

//----- (00035380) --------------------------------------------------------
void scan_freq_stop_hash_board()
{
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      disable_pic_dac(i);
  }
}

//----- (000353C4) --------------------------------------------------------
void __cdecl stop_scan(int error_num, uint8_t chain)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      disable_pic_dac(i);
  }
  freq_scan_error_code_set(error_num, chain);
  while ( 1 )
  {
    process_test();
    sleep(1u);
  }
}

//----- (0003541C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float __cdecl get_max_scanfreq(bool is_economic_mode)
{
  float result; // r0

  LOBYTE(result) = is_economic_mode;
  return result;
}
// 3541C: bad return variable

//----- (00035460) --------------------------------------------------------
void sweep_freq_print_current_column()
{
  FILE *pFile_1; // [sp+Ch] [bp+4h]
  FILE *pFile_2; // [sp+10h] [bp+8h]
  FILE *pFile_0; // [sp+14h] [bp+Ch]
  FILE *pFile_3; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]
  int column; // [sp+20h] [bp+18h]
  int chain; // [sp+24h] [bp+1Ch]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: current column freq level\n", "freq_scan.c", 2763, (const char *)_FUNCTION___15292);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "Chain %d:  ", chain);
        fclose(pFile_0);
      }
      for ( column = 0; column <= 9; ++column )
      {
        if ( log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "%02d ", scanfreq_info.domain_freq_level[chain][column]);
          fclose(pFile_1);
        }
      }
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, ",  current column %d\n", scanfreq_info.current_column[chain]);
        fclose(pFile_2);
      }
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (00035674) --------------------------------------------------------
bool __cdecl sweep_freq_all_chip_failed(int chain, int column)
{
  int row; // [sp+Ch] [bp+Ch]

  for ( row = 0; row <= 5; ++row )
  {
    if ( !scanfreq_info.chip_sweep_failed[chain][get_physical_chip_no(row, column)] )
      return 0;
  }
  return 1;
}

//----- (000356CE) --------------------------------------------------------
void __cdecl sweep_freq_get_next_freq(working_mode_e working_mode)
{
  int sweep_max_freq; // r3
  FILE *pFile_0; // [sp+18h] [bp+8h]
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  int next_freq; // [sp+20h] [bp+10h]
  FILE *pFile_1; // [sp+24h] [bp+14h]
  int current_column; // [sp+28h] [bp+18h]
  int current_columna; // [sp+28h] [bp+18h]
  int max_freq; // [sp+2Ch] [bp+1Ch]
  bool is_all_current_column_finish; // [sp+33h] [bp+23h]
  int chain; // [sp+34h] [bp+24h]
  int chaina; // [sp+34h] [bp+24h]
  int chainb; // [sp+34h] [bp+24h]

  is_all_current_column_finish = 1;
  if ( working_mode )
    sweep_max_freq = g_sweep_config_hpf.sweep_max_freq;
  else
    sweep_max_freq = g_sweep_config_eco.sweep_max_freq;
  max_freq = sweep_max_freq;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( !scanfreq_info.test_done[chain] )
      {
        current_column = scanfreq_info.current_column[chain];
        if ( !scanfreq_info.current_column_finish[chain][current_column] )
        {
          next_freq = scanfreq_info.freq_step * (scanfreq_info.domain_freq_level[chain][current_column] + 2)
                    + scanfreq_info.base_freq[chain];
          if ( sweep_freq_all_chip_failed(chain, current_column) || next_freq > max_freq )
          {
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile = fopen((const char *)log_file, "a+");
              if ( pFile )
                fprintf(
                  pFile,
                  "%s:%d:%s:  ----- chain %d column %d finished ----\n",
                  "freq_scan.c",
                  2816,
                  (const char *)_FUNCTION___15323,
                  chain,
                  current_column);
              fclose(pFile);
            }
            scanfreq_info.current_column_finish[chain][current_column] = 1;
            if ( current_column == 9 )
            {
              scanfreq_info.test_done[chain] = 1;
              if ( log_level > 3 )
              {
                print_crt_time_to_file(log_file, 3u);
                pFile_0 = fopen((const char *)log_file, "a+");
                if ( pFile_0 )
                  fprintf(
                    pFile_0,
                    "%s:%d:%s:  ********* chain[%d] scan finish ********* \n",
                    "freq_scan.c",
                    2821,
                    (const char *)_FUNCTION___15323,
                    chain);
                fclose(pFile_0);
              }
            }
          }
          else
          {
            scanfreq_info.domain_freq_level[chain][current_column] += 2;
          }
        }
      }
    }
  }
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina]
      && !scanfreq_info.test_done[chaina]
      && !scanfreq_info.current_column_finish[chaina][scanfreq_info.current_column[chaina]] )
    {
      is_all_current_column_finish = 0;
      break;
    }
  }
  if ( is_all_current_column_finish )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: all chain current column finished\n",
          "freq_scan.c",
          2845,
          (const char *)_FUNCTION___15323);
      fclose(pFile_1);
    }
    for ( chainb = 0; chainb <= 15; ++chainb )
    {
      if ( dev->chain_exist[chainb] )
      {
        if ( !scanfreq_info.test_done[chainb] )
        {
          current_columna = scanfreq_info.current_column[chainb];
          scanfreq_info.domain_freq_level[chainb][current_columna] = 0;
          scanfreq_info.current_column[chainb] = current_columna + 1;
          scanfreq_info.need_init = 1;
        }
      }
    }
  }
}

//----- (00035B1C) --------------------------------------------------------
void __cdecl sweep_freq_set_column_freq_from_minfreq(int chain, int column)
{
  FILE *pFile_0; // [sp+14h] [bp+Ch]
  FILE *pFile_1; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]
  int chip_freq; // [sp+28h] [bp+20h]
  int chip; // [sp+2Ch] [bp+24h]
  int steps; // [sp+30h] [bp+28h]
  int step; // [sp+34h] [bp+2Ch]
  int freq_tmp; // [sp+38h] [bp+30h]
  int row; // [sp+3Ch] [bp+34h]

  chip_freq = scanfreq_info.freq_step * scanfreq_info.domain_freq_level[chain][column] + scanfreq_info.base_freq[chain];
  steps = (chip_freq - 150) / 25;
  if ( chip_freq > 25 * steps + 150 )
    ++steps;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "chain %d set column %d freq %dM\n", chain, column, chip_freq);
    fclose(pFile);
  }
  for ( step = 0; step < steps; ++step )
  {
    freq_tmp = 25 * (step + 1) + 150;
    if ( freq_tmp > chip_freq )
      freq_tmp = chip_freq;
    for ( row = 0; row <= 5; ++row )
    {
      chip = get_physical_chip_no(row, column);
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "[chip%d %d] ", chip, freq_tmp);
        fclose(pFile_0);
      }
      scan_freq_set_freq_by_chip(chain, 4 * chip, COERCE_FLOAT((unsigned __int8)chain));
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fputc(10, pFile_1);
      fclose(pFile_1);
    }
  }
}

//----- (00035D0A) --------------------------------------------------------
void sweep_freq_set_next_freq_from_minfreq()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( !scanfreq_info.test_done[chain] )
        sweep_freq_set_column_freq_from_minfreq(chain, scanfreq_info.current_column[chain]);
    }
  }
}

//----- (00035D84) --------------------------------------------------------
void __cdecl sweep_freq_set_column_freq_directly(int chain, int column)
{
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile_1; // [sp+14h] [bp+Ch]
  FILE *pFile; // [sp+18h] [bp+10h]
  int chip_freq; // [sp+1Ch] [bp+14h]
  int chip; // [sp+20h] [bp+18h]
  int row; // [sp+24h] [bp+1Ch]

  chip_freq = scanfreq_info.freq_step * scanfreq_info.domain_freq_level[chain][column] + scanfreq_info.base_freq[chain];
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "chain %d set column %d freq %dM\n", chain, column, chip_freq);
    fclose(pFile);
  }
  for ( row = 0; row <= 5; ++row )
  {
    chip = get_physical_chip_no(row, column);
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "[chip%d %d] ", chip, chip_freq);
      fclose(pFile_0);
    }
    scan_freq_set_freq_by_chip(chain, 4 * chip, COERCE_FLOAT((unsigned __int8)chain));
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (00035F00) --------------------------------------------------------
void sweep_freq_set_next_freq_directly()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( !scanfreq_info.test_done[chain] )
        sweep_freq_set_column_freq_directly(chain, scanfreq_info.current_column[chain]);
    }
  }
}

//----- (00035F7A) --------------------------------------------------------
void sweep_freq_send_work_and_check_result()
{
  FILE *pFile_9; // [sp+20h] [bp+0h]
  FILE *pFile_8; // [sp+24h] [bp+4h]
  int chip; // [sp+28h] [bp+8h]
  int column_freq; // [sp+2Ch] [bp+Ch]
  FILE *pFile_7; // [sp+30h] [bp+10h]
  FILE *pFile_6; // [sp+34h] [bp+14h]
  FILE *pFile_5; // [sp+38h] [bp+18h]
  FILE *pFile_4; // [sp+3Ch] [bp+1Ch]
  FILE *pFile_3; // [sp+40h] [bp+20h]
  FILE *pFile_2; // [sp+44h] [bp+24h]
  FILE *pFile_1; // [sp+48h] [bp+28h]
  FILE *pFile_0; // [sp+4Ch] [bp+2Ch]
  int column; // [sp+50h] [bp+30h]
  int domain_balance_num; // [sp+58h] [bp+38h]
  int pass_nonce_num; // [sp+60h] [bp+40h]
  FILE *pFile; // [sp+64h] [bp+44h]
  int row; // [sp+68h] [bp+48h]
  int i; // [sp+6Ch] [bp+4Ch]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: send work and check result\n", "freq_scan.c", 2943, (const char *)_FUNCTION___15390);
    fclose(pFile);
  }
  pass_nonce_num = (int)(float)((float)scanfreq_info.AsicWorkCount * 0.99);
  domain_balance_num = (int)(float)((float)scanfreq_info.AsicWorkCount * 0.75);
  scan_freq_reset_result();
  scan_freq_send_work();
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      if ( !scanfreq_info.test_done[i] )
      {
        column = scanfreq_info.current_column[i];
        if ( !scanfreq_info.current_column_finish[i][column] )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(pFile_0, "%s:%d:%s: \n", "freq_scan.c", 2967, (const char *)_FUNCTION___15390);
            fclose(pFile_0);
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: chain[%d] base freq is %d\n",
                "freq_scan.c",
                2968,
                (const char *)_FUNCTION___15390,
                i,
                scanfreq_info.base_freq[i]);
            fclose(pFile_1);
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: chain[%d] total valid nonce number:    %d\n",
                "freq_scan.c",
                2969,
                (const char *)_FUNCTION___15390,
                i,
                scanfreq_info.valid_nonce_num[i]);
            fclose(pFile_2);
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_3 = fopen((const char *)log_file, "a+");
            if ( pFile_3 )
              fprintf(
                pFile_3,
                "%s:%d:%s: chain[%d] total send work number:      %d\n",
                "freq_scan.c",
                2970,
                (const char *)_FUNCTION___15390,
                i,
                scanfreq_info.send_work_num[i]);
            fclose(pFile_3);
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_4 = fopen((const char *)log_file, "a+");
            if ( pFile_4 )
              fprintf(
                pFile_4,
                "%s:%d:%s: chain[%d] hw nonce number:       %d\n",
                "freq_scan.c",
                2971,
                (const char *)_FUNCTION___15390,
                i,
                scanfreq_info.HW_nonce_num[i]);
            fclose(pFile_4);
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_5 = fopen((const char *)log_file, "a+");
            if ( pFile_5 )
              fprintf(
                pFile_5,
                "%s:%d:%s: chain[%d] repeated nonce number: %d\n",
                "freq_scan.c",
                2972,
                (const char *)_FUNCTION___15390,
                i,
                scanfreq_info.repeated_nonce_num[i]);
            fclose(pFile_5);
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_6 = fopen((const char *)log_file, "a+");
            if ( pFile_6 )
              fprintf(
                pFile_6,
                "%s:%d:%s: chain[%d] other nonce number:    %d\n",
                "freq_scan.c",
                2973,
                (const char *)_FUNCTION___15390,
                i,
                scanfreq_info.other_nonce_num[i]);
            fclose(pFile_6);
          }
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_7 = fopen((const char *)log_file, "a+");
            if ( pFile_7 )
              fprintf(
                pFile_7,
                "%s:%d:%s: chain[%d] required nonce number:       %d\n",
                "freq_scan.c",
                2974,
                (const char *)_FUNCTION___15390,
                i,
                pass_nonce_num);
            fclose(pFile_7);
          }
          column_freq = scanfreq_info.freq_step * scanfreq_info.domain_freq_level[i][column]
                      + scanfreq_info.base_freq[i];
          for ( row = 0; row <= 5; ++row )
          {
            chip = get_physical_chip_no(row, column);
            scanfreq_info.chip_sweep_failed[i][chip] = 0;
            if ( pass_nonce_num > scanfreq_info.asic_nonce_num[i][chip] )
            {
              scanfreq_info.chip_sweep_failed[i][chip] = 1;
              if ( !scanfreq_info.chip_max_freq[i][chip] )
                scanfreq_info.chip_max_freq[i][chip] = scanfreq_info.base_freq[i];
            }
            asic_sweep_stat(
              i,
              chip,
              scanfreq_info.domain_freq_level[i][column],
              scanfreq_info.chip_sweep_failed[i][chip]);
            if ( domain_balance_num >= scanfreq_info.asic_nonce_num[i][chip] )
            {
              if ( log_level > 3 )
              {
                print_crt_time_to_file(log_file, 3u);
                pFile_8 = fopen((const char *)log_file, "a+");
                if ( pFile_8 )
                  fprintf(
                    pFile_8,
                    "%s:%d:%s: chain %d chip %d nonce num:%d is too low,need to reinit.\n",
                    "freq_scan.c",
                    2998,
                    (const char *)_FUNCTION___15390,
                    i,
                    chip,
                    scanfreq_info.asic_nonce_num[i][chip]);
                fclose(pFile_8);
              }
              scanfreq_info.need_init = 1;
            }
            if ( !scanfreq_info.chip_sweep_failed[i][chip] )
              scanfreq_info.chip_max_freq[i][chip] = column_freq;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile_9 = fopen((const char *)log_file, "a+");
              if ( pFile_9 )
                fprintf(
                  pFile_9,
                  "%s:%d:%s: chain %d chip[%03d] nonce %04d, nonce_rate %.2f, max freq %03d, is failed %d\n",
                  "freq_scan.c",
                  3009,
                  (const char *)_FUNCTION___15390,
                  i,
                  chip,
                  scanfreq_info.asic_nonce_num[i][chip],
                  (float)((float)scanfreq_info.asic_nonce_num[i][chip] / (float)scanfreq_info.AsicWorkCount),
                  scanfreq_info.chip_max_freq[i][chip],
                  scanfreq_info.chip_sweep_failed[i][chip]);
              fclose(pFile_9);
            }
          }
        }
      }
    }
  }
}

//----- (0003686C) --------------------------------------------------------
void sweep_freq_print_chip_max_freq()
{
  FILE *pFile_2; // [sp+8h] [bp+0h]
  FILE *pFile_1; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile; // [sp+14h] [bp+Ch]
  int j; // [sp+18h] [bp+10h]
  int i; // [sp+1Ch] [bp+14h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: chip max freq:\n", "freq_scan.c", 3016, (const char *)_FUNCTION___15420);
    fclose(pFile);
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "chain[%d]:\n", i);
        fclose(pFile_0);
      }
      for ( j = 0; j <= 59; ++j )
      {
        if ( log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "%03d  ", scanfreq_info.chip_max_freq[i][j]);
          fclose(pFile_1);
        }
        if ( !((j + 1) % 10) && log_level > 3 )
        {
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fputc(10, pFile_2);
          fclose(pFile_2);
        }
      }
    }
  }
}

//----- (00036A2A) --------------------------------------------------------
void __cdecl sweep_freq_set_base_freq(working_mode_e working_mode)
{
  int sweep_min_freq; // r1
  int chain; // [sp+Ch] [bp+Ch]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( working_mode )
      sweep_min_freq = g_sweep_config_hpf.sweep_min_freq;
    else
      sweep_min_freq = g_sweep_config_eco.sweep_min_freq;
    scanfreq_info.base_freq[chain] = sweep_min_freq;
  }
}

//----- (00036A82) --------------------------------------------------------
int __cdecl sweep_freq_get_chip_max_freq(working_mode_e working_mode)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  int ret; // [sp+14h] [bp+Ch]
  int reta; // [sp+14h] [bp+Ch]
  int count; // [sp+18h] [bp+10h]
  bool first_time; // [sp+1Fh] [bp+17h]

  first_time = 1;
  count = 0;
  sweep_freq_set_base_freq(working_mode);
  scan_freq_reset_scan_info();
  while ( 1 )
  {
    if ( first_time )
    {
      shutdown_read_temp_thread_in_force();
      first_time = 0;
      first_time_init = 1;
      ret = scan_freq_board_init(working_mode);
      if ( ret )
        return ret;
      sweep_freq_set_next_freq_from_minfreq();
      first_time_init = 0;
      init_read_temp_thread_in_force();
      goto LABEL_12;
    }
    sweep_freq_get_next_freq(working_mode);
    if ( scan_freq_is_all_chain_finished() )
      break;
    sweep_freq_print_current_column();
    if ( scanfreq_info.need_init )
    {
      shutdown_read_temp_thread_in_force();
      scanfreq_info.need_init = 0;
      reta = scan_freq_board_fast_init(working_mode);
      if ( reta )
        return reta;
      sweep_freq_set_next_freq_from_minfreq();
      init_read_temp_thread_in_force();
    }
    else
    {
      sweep_freq_set_next_freq_directly();
    }
LABEL_12:
    sweep_freq_send_work_and_check_result();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: scan freq for %d times \n",
          "freq_scan.c",
          3105,
          (const char *)_FUNCTION___15448,
          ++count);
      fclose(pFile);
    }
  }
  shutdown_read_temp_thread_in_force();
  sweep_freq_print_chip_max_freq();
  return 0;
}

//----- (00036BCE) --------------------------------------------------------
void __cdecl sweep_freq_sort_array(int row, int *src, int *rate, unsigned int len)
{
  int index_of_max; // [sp+18h] [bp+18h]
  int max; // [sp+1Ch] [bp+1Ch]
  unsigned int j; // [sp+20h] [bp+20h]
  unsigned int i; // [sp+24h] [bp+24h]
  unsigned int ia; // [sp+24h] [bp+24h]

  for ( i = 0; len > i; ++i )
    rate[i] = 0;
  for ( ia = 0; len > ia; ++ia )
  {
    max = 0x80000000;
    index_of_max = 0x80000000;
    for ( j = 0; len > j; ++j )
    {
      if ( (row & 1) != 0 )
      {
        if ( !rate[j] && max <= src[j] )
        {
          max = src[j];
          index_of_max = j;
        }
      }
      else if ( !rate[j] && max < src[j] )
      {
        max = src[j];
        index_of_max = j;
      }
    }
    rate[index_of_max] = ia + 1;
  }
}

//----- (00036CB4) --------------------------------------------------------
int __cdecl sweep_freq_get_rate_min_freq(int chain, int rate)
{
  int min_freq; // [sp+8h] [bp+8h]
  int chip; // [sp+Ch] [bp+Ch]

  min_freq = 0xFFFF;
  for ( chip = 0; chip <= 59; ++chip )
  {
    if ( rate == scanfreq_info.chip_rate[chain][chip] && min_freq > scanfreq_info.chip_max_freq[chain][chip] )
      min_freq = scanfreq_info.chip_max_freq[chain][chip];
  }
  return min_freq;
}

//----- (00036D46) --------------------------------------------------------
void __cdecl sweep_freq_set_rate_freq(int chain, int rate, int freq)
{
  int chip; // [sp+14h] [bp+14h]

  for ( chip = 0; chip <= 59; ++chip )
  {
    if ( rate == scanfreq_info.chip_rate[chain][chip] )
      scanfreq_info.final_chip_freq[chain][chip] = freq;
  }
}

//----- (00036DB0) --------------------------------------------------------
void sweep_freq_balance_domain_freq()
{
  FILE *pFile_0; // [sp+0h] [bp+0h]
  FILE *pFile_1; // [sp+4h] [bp+4h]
  FILE *pFile; // [sp+8h] [bp+8h]
  int rate_min_freq; // [sp+Ch] [bp+Ch]
  FILE *pFile_4; // [sp+10h] [bp+10h]
  FILE *pFile_3; // [sp+14h] [bp+14h]
  FILE *pFile_2; // [sp+18h] [bp+18h]
  int rate; // [sp+1Ch] [bp+1Ch]
  int chip; // [sp+20h] [bp+20h]
  int col; // [sp+24h] [bp+24h]
  int row; // [sp+28h] [bp+28h]
  int chain; // [sp+2Ch] [bp+2Ch]
  int chaina; // [sp+2Ch] [bp+2Ch]
  int chainb; // [sp+2Ch] [bp+2Ch]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "\nchain %d chip rating:\n", chain);
        fclose(pFile);
      }
      for ( row = 0; row <= 5; ++row )
      {
        sweep_freq_sort_array(
          row,
          &scanfreq_info.chip_max_freq[chain][10 * row],
          &scanfreq_info.chip_rate[chain][10 * row],
          0xAu);
        for ( col = 0; col <= 9; ++col )
        {
          if ( log_level > 3 )
          {
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(pFile_0, "%d ", scanfreq_info.chip_rate[chain][10 * row + col]);
            fclose(pFile_0);
          }
        }
        if ( log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fputc(10, pFile_1);
          fclose(pFile_1);
        }
      }
    }
  }
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina] )
    {
      for ( rate = 1; rate <= 10; ++rate )
      {
        rate_min_freq = sweep_freq_get_rate_min_freq(chaina, rate);
        sweep_freq_set_rate_freq(chaina, rate, rate_min_freq);
      }
    }
  }
  for ( chainb = 0; chainb <= 15; ++chainb )
  {
    if ( dev->chain_exist[chainb] )
    {
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, "\nchain %d balanced freq:\n", chainb);
        fclose(pFile_2);
      }
      for ( chip = 0; chip <= 59; ++chip )
      {
        if ( log_level > 3 )
        {
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(pFile_3, "%d ", scanfreq_info.final_chip_freq[chainb][chip]);
          fclose(pFile_3);
        }
        if ( !((chip + 1) % 10) && log_level > 3 )
        {
          pFile_4 = fopen((const char *)log_file, "a+");
          if ( pFile_4 )
            fputc(10, pFile_4);
          fclose(pFile_4);
        }
      }
    }
  }
}

//----- (000370F2) --------------------------------------------------------
void __cdecl sweep_freq_save_result(working_mode_e working_mode)
{
  double v1; // r2
  double v2; // r2
  int chain; // [sp+Ch] [bp+Ch]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( !dev->chain_exist[chain] )
      continue;
    if ( working_mode )
    {
      if ( !eeprom_set_freq_mode2(chain, (uint32_t *)scanfreq_info.final_chip_freq[chain]) )
        stop_scan(3, chain);
      get_working_voltage_by_chain(chain);
      if ( !eeprom_set_voltage_mode2(chain, v2) )
        stop_scan(3, chain);
      if ( !eeprom_set_hashrate_mode2(chain, scanfreq_info.ideal_hashrate[chain]) )
      {
LABEL_15:
        stop_scan(3, chain);
        continue;
      }
    }
    else
    {
      if ( !eeprom_set_freq_mode1(chain, (uint32_t *)scanfreq_info.final_chip_freq[chain]) )
        stop_scan(3, chain);
      get_working_voltage_by_chain(chain);
      if ( !eeprom_set_voltage_mode1(chain, v1) )
        stop_scan(3, chain);
      if ( !eeprom_set_hashrate_mode1(chain, scanfreq_info.ideal_hashrate[chain]) )
        goto LABEL_15;
    }
  }
}
// 3716E: variable 'v1' is possibly undefined
// 37214: variable 'v2' is possibly undefined

//----- (00037282) --------------------------------------------------------
void __cdecl sweep_freq_decrease_freq(working_mode_e working_mode)
{
  int sweep_max_freq; // r3
  FILE *pFile_1; // [sp+8h] [bp+8h]
  FILE *pFile_0; // [sp+Ch] [bp+Ch]
  FILE *pFile; // [sp+10h] [bp+10h]
  int max_freq; // [sp+14h] [bp+14h]
  int chip; // [sp+18h] [bp+18h]
  int chain; // [sp+1Ch] [bp+1Ch]

  if ( working_mode )
    sweep_max_freq = g_sweep_config_hpf.sweep_max_freq;
  else
    sweep_max_freq = g_sweep_config_eco.sweep_max_freq;
  max_freq = sweep_max_freq;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "\nchain %d decreased freq:\n", chain);
        fclose(pFile);
      }
      for ( chip = 0; chip <= 59; ++chip )
      {
        if ( max_freq == scanfreq_info.final_chip_freq[chain][chip] )
          scanfreq_info.final_chip_freq[chain][chip] -= 5;
        else
          scanfreq_info.final_chip_freq[chain][chip] -= 10;
        if ( log_level > 3 )
        {
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(pFile_0, "%d ", scanfreq_info.final_chip_freq[chain][chip]);
          fclose(pFile_0);
        }
        if ( !((chip + 1) % 10) && log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fputc(10, pFile_1);
          fclose(pFile_1);
        }
      }
    }
  }
}

//----- (00037492) --------------------------------------------------------
int __cdecl sweep_freq_get_ideal_hashrate(working_mode_e working_mode)
{
  int ideal_hash_rate[16]; // [sp+1Ch] [bp+Ch] BYREF
  int max_hash_rate[16]; // [sp+5Ch] [bp+4Ch] BYREF
  int chip; // [sp+9Ch] [bp+8Ch]
  int chain; // [sp+A0h] [bp+90h]
  FILE *pFile_7; // [sp+A4h] [bp+94h]
  FILE *pFile_6; // [sp+A8h] [bp+98h]
  FILE *pFile_5; // [sp+ACh] [bp+9Ch]
  FILE *pFile_4; // [sp+B0h] [bp+A0h]
  FILE *pFile_3; // [sp+B4h] [bp+A4h]
  FILE *pFile_2; // [sp+B8h] [bp+A8h]
  FILE *pFile_1; // [sp+BCh] [bp+ACh]
  FILE *pFile_0; // [sp+C0h] [bp+B0h]
  FILE *pFile; // [sp+C4h] [bp+B4h]
  int ret; // [sp+C8h] [bp+B8h]
  bool check_column_nonce_bak; // [sp+CFh] [bp+BFh]
  int v19; // [sp+D0h] [bp+C0h] BYREF

  check_column_nonce_bak = check_column_nonce;
  memset(max_hash_rate, 0, sizeof(max_hash_rate));
  memset(ideal_hash_rate, 0, sizeof(ideal_hash_rate));
  ret = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: \nget ideal hash rate\n", "freq_scan.c", 3305, (const char *)_FUNCTION___15570);
    fclose(pFile);
  }
  check_column_nonce = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      scanfreq_info.test_done[chain] = 0;
      for ( chip = 0; chip <= 255; ++chip )
      {
        scan_result[chain].freq_eeprom[chip] = scanfreq_info.final_chip_freq[chain][chip];
        *(&v19 + chain - 29) += 208 * scanfreq_info.final_chip_freq[chain][chip];
      }
    }
  }
  need_set_final_freq = 1;
  ret = scan_freq_board_init(working_mode);
  if ( ret )
    return ret;
  need_set_final_freq = 0;
  scan_freq_reset_result();
  scan_freq_send_work();
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      *(&v19 + chain - 29) /= 1000;
      scanfreq_info.chain_nonce_rate[chain] = (float)scanfreq_info.valid_nonce_num[chain]
                                            / (float)scanfreq_info.send_work_num[chain];
      *(&v19 + chain - 45) = (int)(float)(scanfreq_info.chain_nonce_rate[chain] * (float)*(&v19 + chain - 29));
      scanfreq_info.max_hashrate[chain] = *(&v19 + chain - 29);
      scanfreq_info.ideal_hashrate[chain] = *(&v19 + chain - 45);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: chain[%d] nonce rate:            %.2f\n",
            "freq_scan.c",
            3344,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.chain_nonce_rate[chain]);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: chain[%d] max hashrate:          %d\n",
            "freq_scan.c",
            3345,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.max_hashrate[chain]);
        fclose(pFile_1);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: chain[%d] ideal hashrate:        %d\n",
            "freq_scan.c",
            3346,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.ideal_hashrate[chain]);
        fclose(pFile_2);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: chain[%d] valid nonce number:    %d\n",
            "freq_scan.c",
            3347,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.valid_nonce_num[chain]);
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: chain[%d] send work number:      %d\n",
            "freq_scan.c",
            3348,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.send_work_num[chain]);
        fclose(pFile_4);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: chain[%d] hw nonce number:       %d\n",
            "freq_scan.c",
            3349,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.HW_nonce_num[chain]);
        fclose(pFile_5);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: chain[%d] repeated nonce number: %d\n",
            "freq_scan.c",
            3350,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.repeated_nonce_num[chain]);
        fclose(pFile_6);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(
            pFile_7,
            "%s:%d:%s: chain[%d] other nonce number:    %d\n\n",
            "freq_scan.c",
            3351,
            (const char *)_FUNCTION___15570,
            chain,
            scanfreq_info.other_nonce_num[chain]);
        fclose(pFile_7);
      }
    }
  }
  check_column_nonce = check_column_nonce_bak;
  return 0;
}

//----- (00037C90) --------------------------------------------------------
void sweep_update_ideal_hash_rate()
{
  int max_hash_rate[16]; // [sp+14h] [bp+4h] BYREF
  FILE *pFile; // [sp+54h] [bp+44h]
  FILE *pFile_0; // [sp+58h] [bp+48h]
  int ideal_hash_rate; // [sp+5Ch] [bp+4Ch]
  int chip; // [sp+60h] [bp+50h]
  int chain; // [sp+64h] [bp+54h]
  int v6; // [sp+68h] [bp+58h] BYREF

  memset(max_hash_rate, 0, sizeof(max_hash_rate));
  ideal_hash_rate = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( chip = 0; chip <= 255; ++chip )
        *(&v6 + chain - 21) += 208 * scanfreq_info.final_chip_freq[chain][chip];
      *(&v6 + chain - 21) /= 1000;
      scanfreq_info.ideal_hashrate[chain] = (int)(float)(scanfreq_info.chain_nonce_rate[chain]
                                                       * (float)*(&v6 + chain - 21));
      ideal_hash_rate += scanfreq_info.ideal_hashrate[chain];
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d] fixed ideal hashrate:     %d\n",
            "freq_scan.c",
            3376,
            (const char *)_FUNCTION___15601,
            chain,
            scanfreq_info.ideal_hashrate[chain]);
        fclose(pFile);
      }
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: total fixed ideal hashrate:     %d\n",
        "freq_scan.c",
        3378,
        (const char *)_FUNCTION___15601,
        ideal_hash_rate);
    fclose(pFile_0);
  }
}

//----- (00037EC0) --------------------------------------------------------
int sweep_get_current_ideal_hash_rate()
{
  int max_hash_rate[16]; // [sp+4h] [bp+4h] BYREF
  int ideal_hash_rate; // [sp+44h] [bp+44h]
  int chip; // [sp+48h] [bp+48h]
  int chain; // [sp+4Ch] [bp+4Ch]
  int v5; // [sp+50h] [bp+50h] BYREF

  memset(max_hash_rate, 0, sizeof(max_hash_rate));
  ideal_hash_rate = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( chip = 0; chip <= 255; ++chip )
        *(&v5 + chain - 19) += 208 * scanfreq_info.final_chip_freq[chain][chip];
      *(&v5 + chain - 19) /= 1000;
      ideal_hash_rate = (int)(float)((float)ideal_hash_rate
                                   + (float)(scanfreq_info.chain_nonce_rate[chain] * (float)*(&v5 + chain - 19)));
    }
  }
  return ideal_hash_rate;
}

//----- (00037FD8) --------------------------------------------------------
void sweep_fix_ideal_rate()
{
  int down_count[16]; // [sp+18h] [bp+0h] BYREF
  FILE *pFile_0; // [sp+58h] [bp+40h]
  FILE *pFile_1; // [sp+5Ch] [bp+44h]
  FILE *pFile; // [sp+60h] [bp+48h]
  int target_rate; // [sp+64h] [bp+4Ch]
  int step_rate; // [sp+68h] [bp+50h]
  int step; // [sp+6Ch] [bp+54h]
  int margin; // [sp+70h] [bp+58h]
  int min_down_count; // [sp+74h] [bp+5Ch]
  int fix_chain; // [sp+78h] [bp+60h]
  int totalRate; // [sp+7Ch] [bp+64h]
  int chip; // [sp+80h] [bp+68h]
  int chain; // [sp+84h] [bp+6Ch]

  margin = 100;
  if ( (unsigned __int8)is_T11() == 1 )
  {
    step = 5;
    step_rate = 62;
    totalRate = sweep_get_current_ideal_hash_rate();
    target_rate = margin + fix_hash_rate(totalRate);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: total rate %d, target rate %d, step rate %d\n",
          "freq_scan.c",
          3421,
          (const char *)_FUNCTION___15632,
          totalRate,
          target_rate,
          step_rate);
      fclose(pFile);
    }
    memset(down_count, 0, sizeof(down_count));
    while ( totalRate >= step_rate + target_rate )
    {
      min_down_count = 1000;
      fix_chain = -1;
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] == 1 && min_down_count > down_count[chain] )
        {
          min_down_count = down_count[chain];
          fix_chain = chain;
        }
      }
      if ( fix_chain == -1 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: error, can not find a chain to fix\n",
              "freq_scan.c",
              3442,
              (const char *)_FUNCTION___15632);
          fclose(pFile_0);
        }
        break;
      }
      ++down_count[fix_chain];
      for ( chip = 0; chip <= 59; ++chip )
        scanfreq_info.final_chip_freq[fix_chain][chip] -= step;
      totalRate = sweep_get_current_ideal_hash_rate();
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: chain %d down a step of %dM, rate of %dG, current total rate %dG\n",
            "freq_scan.c",
            3451,
            (const char *)_FUNCTION___15632,
            fix_chain,
            step,
            step_rate,
            totalRate);
        fclose(pFile_1);
      }
    }
    sweep_update_ideal_hash_rate();
  }
}

//----- (0003828C) --------------------------------------------------------
void __cdecl sweep_set_current_chain(int chain_count)
{
  int count; // [sp+8h] [bp+8h]
  int chain; // [sp+Ch] [bp+Ch]

  count = 0;
  check_chain();
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( count != chain_count )
        dev->chain_exist[chain] = 0;
      ++count;
    }
  }
  dev->chain_num = 1;
}

//----- (0003830A) --------------------------------------------------------
void asic_sweep_stat_start()
{
  FILE *pFile; // [sp+Ch] [bp+4h]

  asic_sweep_state = (uint8_t *)malloc(0x9600u);
  if ( asic_sweep_state )
  {
    memset(asic_sweep_state, 0, 0x9600u);
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: alloc memory failed", "freq_scan.c", 3500, (const char *)_FUNCTION___15661);
    fclose(pFile);
  }
}

//----- (000383C0) --------------------------------------------------------
void __cdecl asic_sweep_stat(int chain, int chip, int level, bool failed)
{
  if ( asic_sweep_state )
  {
    if ( 40 * chip + 2400 * chain + level < 38400 )
      asic_sweep_state[2400 * chain + 40 * chip + level] = failed;
  }
}

//----- (00038424) --------------------------------------------------------
void __cdecl get_asic_sweep_stat(unsigned __int8 *infoStr)
{
  sprintf((char *)infoStr, "%d %d %d", sweep_failed_few_succeed_freq, sweep_failed_base_freq, sweep_failed_middle_freq);
}

//----- (00038468) --------------------------------------------------------
int asic_sweep_stat_end()
{
  FILE *pFile_1; // [sp+18h] [bp+8h]
  FILE *pFile_2; // [sp+1Ch] [bp+Ch]
  FILE *pFile_0; // [sp+20h] [bp+10h]
  FILE *pFile_3; // [sp+24h] [bp+14h]
  FILE *pFile; // [sp+28h] [bp+18h]
  int level_num; // [sp+2Ch] [bp+1Ch]
  int succeed_freq_cnt; // [sp+30h] [bp+20h]
  int level; // [sp+34h] [bp+24h]
  int chip; // [sp+38h] [bp+28h]
  int chipa; // [sp+38h] [bp+28h]
  int chain; // [sp+3Ch] [bp+2Ch]
  int chaina; // [sp+3Ch] [bp+2Ch]

  if ( !asic_sweep_state )
    return 0;
  sweep_failed_base_freq = 0;
  sweep_failed_middle_freq = 0;
  sweep_failed_few_succeed_freq = 0;
  memset(is_asic_bad, 0, sizeof(is_asic_bad));
  level_num = (g_sweep_config_hpf.sweep_max_freq - g_sweep_config_hpf.sweep_min_freq) / scanfreq_info.freq_step;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: level_num = %d\n", "freq_scan.c", 3543, (const char *)_FUNCTION___15684, level_num);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( chip = 0; chip <= 59; ++chip )
      {
        succeed_freq_cnt = 0;
        for ( level = 0; level <= level_num; level += 2 )
        {
          if ( 40 * chip + 2400 * chain + level < 38400 && !asic_sweep_state[2400 * chain + 40 * chip + level] )
            ++succeed_freq_cnt;
        }
        if ( succeed_freq_cnt <= 1 )
        {
          is_asic_bad[chain][chip] = 1;
          *((_BYTE *)&pattern_info_t.scan_record_count[-448768] + (_DWORD)&scanfreq_info + chain) = 1;
          sweep_failed_few_succeed_freq = 1;
          freq_scan_error_code_set(14, chain);
        }
      }
    }
  }
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina] )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "\nchain %d bad chips: ", chaina);
        fclose(pFile_0);
      }
      for ( chipa = 0; chipa <= 59; ++chipa )
      {
        if ( is_asic_bad[chaina][chipa] && log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "[chip %02d] ", chipa);
          fclose(pFile_1);
        }
      }
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fputc(10, pFile_2);
        fclose(pFile_2);
      }
    }
  }
  free(asic_sweep_state);
  asic_sweep_state = 0;
  if ( !sweep_failed_few_succeed_freq && !sweep_failed_base_freq && !sweep_failed_middle_freq )
    return 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s: sweep failed caused by bad chip , few_succeed_freq %d, base_freq %d, middle_freq %d\n",
        "freq_scan.c",
        3626,
        (const char *)_FUNCTION___15684,
        sweep_failed_few_succeed_freq,
        sweep_failed_base_freq,
        sweep_failed_middle_freq);
    fclose(pFile_3);
  }
  return -1;
}

//----- (00038846) --------------------------------------------------------
int __cdecl sweep_freq_for_mode(working_mode_e working_mode)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  int chain_num; // [sp+14h] [bp+Ch]
  int ret; // [sp+18h] [bp+10h]
  int reta; // [sp+18h] [bp+10h]
  int retb; // [sp+18h] [bp+10h]
  int chain_count; // [sp+1Ch] [bp+14h]

  asic_sweep_stat_start();
  chain_num = dev->chain_num;
  for ( chain_count = 0; chain_count < chain_num; ++chain_count )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: sweep for %d chain\n",
          "freq_scan.c",
          3644,
          (const char *)_FUNCTION___15713,
          chain_count);
      fclose(pFile);
    }
    sweep_set_current_chain(chain_count);
    ret = sweep_freq_get_chip_max_freq(working_mode);
    if ( ret )
      return ret;
    sweep_freq_balance_domain_freq();
    sweep_freq_decrease_freq(working_mode);
    reta = sweep_freq_get_ideal_hashrate(working_mode);
    if ( reta )
      return reta;
    scan_freq_stop_hash_board();
  }
  check_chain();
  sweep_fix_ideal_rate();
  sweep_freq_save_result(working_mode);
  if ( (unsigned __int8)eeprom_save() != 1 )
    return -1;
  retb = asic_sweep_stat_end();
  if ( retb )
    return retb;
  freq_scan_set_state();
  return 0;
}

//----- (0003896A) --------------------------------------------------------
int sweep_freq_by_column()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  FILE *pFile_0; // [sp+Ch] [bp+4h]
  FILE *pFile_3; // [sp+10h] [bp+8h]
  time_t search_end_time; // [sp+14h] [bp+Ch]
  FILE *pFile_2; // [sp+18h] [bp+10h]
  FILE *pFile_1; // [sp+1Ch] [bp+14h]
  time_t search_start_time; // [sp+20h] [bp+18h]
  int ret; // [sp+24h] [bp+1Ch]
  int reta; // [sp+24h] [bp+1Ch]

  freq_scan_status = 0;
  if ( scan_freq_already_done() )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: scan freq has already been done\n",
          "freq_scan.c",
          3685,
          (const char *)_FUNCTION___15723);
      fclose(pFile);
    }
    freq_scan_status = 1;
    return 0;
  }
  else
  {
    is_freq_scan_succeeded_flag = 0;
    test_8pattern = 1;
    check_column_nonce = 1;
    search_start_time = time(0);
    if ( scan_freq_prepare() >= 0 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: sweep freq for mode 2\n", "freq_scan.c", 3704, (const char *)_FUNCTION___15723);
        fclose(pFile_1);
      }
      ret = sweep_freq_for_mode(MODE2);
      check_chain();
      scan_freq_stop_hash_board();
      sleep(0x1Eu);
      if ( ret )
      {
        return ret;
      }
      else
      {
        reta = eeprom_date_check();
        if ( reta )
        {
          return reta;
        }
        else
        {
          eeprom_dump();
          scan_freq_done_mark();
          is_freq_scan_succeeded_flag = 1;
          aging_start();
          freq_scan_status = 1;
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: cancel the receive thread\n",
                "freq_scan.c",
                3724,
                (const char *)_FUNCTION___15723);
            fclose(pFile_2);
          }
          pthread_cancel(receive_id);
          search_end_time = time(0);
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_3 = fopen((const char *)log_file, "a+");
            if ( pFile_3 )
              fprintf(
                pFile_3,
                "%s:%d:%s: total cost time %ld s \n",
                "freq_scan.c",
                3728,
                (const char *)_FUNCTION___15723,
                search_end_time - search_start_time);
            fclose(pFile_3);
          }
          return 0;
        }
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: sweep freq prepare failed\n",
            "freq_scan.c",
            3696,
            (const char *)_FUNCTION___15723);
        fclose(pFile_0);
      }
      freq_scan_status = 2;
      return -1;
    }
  }
}

//----- (00038C72) --------------------------------------------------------
bool is_scan_freq_trigged_and_succeeded()
{
  return is_freq_scan_succeeded_flag;
}

//----- (00038C8A) --------------------------------------------------------
void boardsweep_print_bad_cores()
{
  FILE *pFile_2; // [sp+0h] [bp+0h]
  FILE *pFile_1; // [sp+4h] [bp+4h]
  FILE *pFile_0; // [sp+8h] [bp+8h]
  FILE *pFile; // [sp+Ch] [bp+Ch]
  FILE *pFile_3; // [sp+10h] [bp+10h]
  int bad_core_num; // [sp+18h] [bp+18h]
  int chip; // [sp+1Ch] [bp+1Ch]
  int m; // [sp+20h] [bp+20h]
  int i; // [sp+24h] [bp+24h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      if ( log_level > 3 )
      {
        pFile = fopen("/var/log/bad_cores", "a+");
        if ( pFile )
          fprintf(pFile, "\nchain %d freq %d: \n", i, scanfreq_info.base_freq[i]);
        fclose(pFile);
      }
      for ( chip = 0; chip < scanfreq_info.AsicNum; ++chip )
      {
        bad_core_num = 0;
        if ( log_level > 3 )
        {
          pFile_0 = fopen("/var/log/bad_cores", "a+");
          if ( pFile_0 )
            fprintf(pFile_0, "[chip %02d]\n", chip);
          fclose(pFile_0);
        }
        for ( m = 0; m <= 207; ++m )
        {
          ++bad_core_num;
          if ( log_level > 3 )
          {
            pFile_1 = fopen("/var/log/bad_cores", "a+");
            if ( pFile_1 )
              fprintf(pFile_1, "[%03d %d] ", m, scanfreq_info.asic_core_nonce_num[0][chip + (i << 8)][m]);
            fclose(pFile_1);
          }
          if ( !(bad_core_num % 13) && log_level > 3 )
          {
            pFile_2 = fopen("/var/log/bad_cores", "a+");
            if ( pFile_2 )
              fputc(10, pFile_2);
            fclose(pFile_2);
          }
        }
      }
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen("/var/log/bad_cores", "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (00038E7A) --------------------------------------------------------
void boardsweep_send_work_and_check_result()
{
  FILE *pFile_7; // [sp+20h] [bp+0h]
  FILE *pFile_6; // [sp+24h] [bp+4h]
  FILE *pFile_5; // [sp+28h] [bp+8h]
  FILE *pFile_4; // [sp+2Ch] [bp+Ch]
  FILE *pFile_3; // [sp+30h] [bp+10h]
  FILE *pFile_2; // [sp+34h] [bp+14h]
  FILE *pFile_1; // [sp+38h] [bp+18h]
  FILE *pFile_0; // [sp+3Ch] [bp+1Ch]
  int index; // [sp+40h] [bp+20h]
  int chain_ideal_hash_rate; // [sp+44h] [bp+24h]
  float chain_nonce_rate; // [sp+4Ch] [bp+2Ch]
  int pass_nonce_num; // [sp+54h] [bp+34h]
  FILE *pFile; // [sp+58h] [bp+38h]
  int chain; // [sp+5Ch] [bp+3Ch]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: send work and check result\n", "freq_scan.c", 3879, (const char *)_FUNCTION___15812);
    fclose(pFile);
  }
  pass_nonce_num = (int)(float)((float)scanfreq_info.AsicWorkCount * 0.98);
  scan_freq_reset_result();
  scan_freq_send_work();
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
    {
      chain_nonce_rate = (float)scanfreq_info.valid_nonce_num[chain] / (float)scanfreq_info.send_work_num[chain];
      chain_ideal_hash_rate = (int)(float)((float)(12480 * scanfreq_info.base_freq[chain] / 1000) * chain_nonce_rate);
      index = scanfreq_info.ideal_hash_rate_index[chain];
      scanfreq_info.ideal_hash_rate_freq[chain][index] = scanfreq_info.base_freq[chain];
      scanfreq_info.ideal_hash_rate[chain][index] = chain_ideal_hash_rate;
      ++scanfreq_info.ideal_hash_rate_index[chain];
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: \n", "freq_scan.c", 3907, (const char *)_FUNCTION___15812);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: chain[%d] freq is %d, nonce_rate is %.3f, ideal hash %d\n",
            "freq_scan.c",
            3909,
            (const char *)_FUNCTION___15812,
            chain,
            scanfreq_info.base_freq[chain],
            chain_nonce_rate,
            chain_ideal_hash_rate);
        fclose(pFile_1);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: chain[%d] total valid nonce number:    %d\n",
            "freq_scan.c",
            3910,
            (const char *)_FUNCTION___15812,
            chain,
            scanfreq_info.valid_nonce_num[chain]);
        fclose(pFile_2);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: chain[%d] total send work number:      %d\n",
            "freq_scan.c",
            3911,
            (const char *)_FUNCTION___15812,
            chain,
            scanfreq_info.send_work_num[chain]);
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: chain[%d] hw nonce number:       %d\n",
            "freq_scan.c",
            3912,
            (const char *)_FUNCTION___15812,
            chain,
            scanfreq_info.HW_nonce_num[chain]);
        fclose(pFile_4);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: chain[%d] repeated nonce number: %d\n",
            "freq_scan.c",
            3913,
            (const char *)_FUNCTION___15812,
            chain,
            scanfreq_info.repeated_nonce_num[chain]);
        fclose(pFile_5);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: chain[%d] other nonce number:    %d\n",
            "freq_scan.c",
            3914,
            (const char *)_FUNCTION___15812,
            chain,
            scanfreq_info.other_nonce_num[chain]);
        fclose(pFile_6);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(
            pFile_7,
            "%s:%d:%s: chain[%d] required nonce number:       %d\n",
            "freq_scan.c",
            3915,
            (const char *)_FUNCTION___15812,
            chain,
            pass_nonce_num);
        fclose(pFile_7);
      }
    }
  }
}

//----- (000394B6) --------------------------------------------------------
void __cdecl boardsweep_get_next_freq(working_mode_e working_mode)
{
  int sweep_max_freq; // r3
  FILE *pFile; // [sp+10h] [bp+8h]
  int next_freq; // [sp+14h] [bp+Ch]
  int max_freq; // [sp+18h] [bp+10h]
  int chain; // [sp+1Ch] [bp+14h]

  if ( working_mode )
    sweep_max_freq = g_sweep_config_hpf.sweep_max_freq;
  else
    sweep_max_freq = g_sweep_config_eco.sweep_max_freq;
  max_freq = sweep_max_freq;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !scanfreq_info.test_done[chain] )
    {
      next_freq = 2 * scanfreq_info.freq_step + scanfreq_info.base_freq[chain];
      if ( next_freq <= max_freq )
      {
        scanfreq_info.base_freq[chain] = next_freq;
      }
      else
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s:  ----- chain %d sweep finished ----\n",
              "freq_scan.c",
              3983,
              (const char *)_FUNCTION___15856,
              chain);
          fclose(pFile);
        }
        scanfreq_info.test_done[chain] = 1;
      }
    }
  }
}

//----- (000395FE) --------------------------------------------------------
int __cdecl boardsweep_get_chip_max_freq(working_mode_e working_mode)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  int ret; // [sp+14h] [bp+Ch]
  int reta; // [sp+14h] [bp+Ch]
  int count; // [sp+18h] [bp+10h]
  bool first_time; // [sp+1Fh] [bp+17h]

  first_time = 1;
  count = 0;
  sweep_freq_set_base_freq(working_mode);
  scan_freq_reset_scan_info();
  while ( 1 )
  {
    if ( first_time )
    {
      shutdown_read_temp_thread_in_force();
      first_time = 0;
      first_time_init = 1;
      ret = scan_freq_board_init(working_mode);
      if ( ret )
        return ret;
      first_time_init = 0;
      init_read_temp_thread_in_force();
      goto LABEL_10;
    }
    boardsweep_get_next_freq(working_mode);
    if ( scan_freq_is_all_chain_finished() )
      break;
    shutdown_read_temp_thread_in_force();
    reta = scan_freq_board_fast_init(working_mode);
    if ( reta )
      return reta;
    init_read_temp_thread_in_force();
LABEL_10:
    boardsweep_send_work_and_check_result();
    boardsweep_print_bad_cores();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: scan freq for %d times \n",
          "freq_scan.c",
          4033,
          (const char *)_FUNCTION___15868,
          ++count);
      fclose(pFile);
    }
  }
  shutdown_read_temp_thread_in_force();
  return 0;
}

//----- (00039712) --------------------------------------------------------
void __cdecl boardsweep_get_ideal_hashrate(working_mode_e working_mode)
{
  int fixed; // r0
  int down_count[16]; // [sp+1Ch] [bp+Ch] BYREF
  int chain_max_ideal_hashrate_index[16]; // [sp+5Ch] [bp+4Ch] BYREF
  int chain_max_ideal_hashrate[16]; // [sp+9Ch] [bp+8Ch] BYREF
  FILE *pFile_0; // [sp+DCh] [bp+CCh]
  FILE *pFile_7; // [sp+E0h] [bp+D0h]
  FILE *pFile_6; // [sp+E4h] [bp+D4h]
  FILE *pFile_5; // [sp+E8h] [bp+D8h]
  FILE *pFile_2; // [sp+ECh] [bp+DCh]
  FILE *pFile_4; // [sp+F0h] [bp+E0h]
  FILE *pFile_3; // [sp+F4h] [bp+E4h]
  FILE *pFile_1; // [sp+F8h] [bp+E8h]
  FILE *pFile; // [sp+FCh] [bp+ECh]
  int margin; // [sp+100h] [bp+F0h]
  int target_rate; // [sp+104h] [bp+F4h]
  int min_down_count; // [sp+108h] [bp+F8h]
  int fix_chain; // [sp+10Ch] [bp+FCh]
  int total_ideal_hashrate; // [sp+110h] [bp+100h]
  int index; // [sp+114h] [bp+104h]
  int chip; // [sp+118h] [bp+108h]
  int chain; // [sp+11Ch] [bp+10Ch]
  int v22; // [sp+120h] [bp+110h] BYREF

  memset(chain_max_ideal_hashrate, 0, sizeof(chain_max_ideal_hashrate));
  memset(chain_max_ideal_hashrate_index, 0, sizeof(chain_max_ideal_hashrate_index));
  index = 0;
  total_ideal_hashrate = 0;
  target_rate = 0;
  margin = 100;
  memset(down_count, 0, sizeof(down_count));
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: \nget ideal hash rate\n", "freq_scan.c", 4052, (const char *)_FUNCTION___15885);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( index = 0; index < scanfreq_info.ideal_hash_rate_index[chain]; ++index )
      {
        if ( scanfreq_info.ideal_hash_rate[chain][index] > *(&v22 + chain - 33) )
        {
          *(&v22 + chain - 33) = scanfreq_info.ideal_hash_rate[chain][index];
          *(&v22 + chain - 49) = index;
        }
      }
    }
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: chain %d max ideal hash is %d at freq %d\n",
            "freq_scan.c",
            4073,
            (const char *)_FUNCTION___15885,
            chain,
            *(&v22 + chain - 33),
            scanfreq_info.ideal_hash_rate_freq[chain][*(&v22 + chain - 49)]);
        fclose(pFile_0);
      }
      total_ideal_hashrate += *(&v22 + chain - 33);
    }
  }
  fixed = fix_hash_rate(total_ideal_hashrate);
  target_rate = margin + fixed;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: total ideal hash is %d, target hash is %d\n",
        "freq_scan.c",
        4078,
        (const char *)_FUNCTION___15885,
        total_ideal_hashrate,
        target_rate);
    fclose(pFile_1);
  }
  memset(down_count, 0, sizeof(down_count));
  while ( 1 )
  {
    min_down_count = 1000;
    fix_chain = -1;
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] == 1 && min_down_count > down_count[chain] )
      {
        min_down_count = down_count[chain];
        fix_chain = chain;
      }
    }
    if ( fix_chain == -1 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: error, can not find a chain to fix\n",
            "freq_scan.c",
            4099,
            (const char *)_FUNCTION___15885);
        fclose(pFile_2);
      }
      goto LABEL_55;
    }
    ++down_count[fix_chain];
    if ( *(&v22 + fix_chain - 49) > 0 )
    {
      index = *(&v22 + fix_chain - 49) - 1;
      *(&v22 + fix_chain - 33) = scanfreq_info.ideal_hash_rate[fix_chain][index];
      *(&v22 + fix_chain - 49) = index;
      total_ideal_hashrate = 0;
      for ( chain = 0; chain <= 15; ++chain )
      {
        if ( dev->chain_exist[chain] == 1 )
          total_ideal_hashrate += *(&v22 + chain - 33);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: chain %d down to %d, total hash is %d\n",
            "freq_scan.c",
            4119,
            (const char *)_FUNCTION___15885,
            fix_chain,
            scanfreq_info.ideal_hash_rate_freq[fix_chain][index],
            total_ideal_hashrate);
        fclose(pFile_3);
      }
      if ( total_ideal_hashrate < target_rate )
        break;
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(pFile_4, "%s:%d:%s: reach target hashrate\n", "freq_scan.c", 4123, (const char *)_FUNCTION___15885);
    fclose(pFile_4);
  }
  *(&v22 + fix_chain - 33) = scanfreq_info.ideal_hash_rate[fix_chain][index + 1];
  *(&v22 + fix_chain - 49) = index + 1;
LABEL_55:
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      index = *(&v22 + chain - 49);
      scanfreq_info.max_hashrate[chain] = 12480 * scanfreq_info.ideal_hash_rate_freq[chain][index] / 1000;
      scanfreq_info.ideal_hashrate[chain] = *(&v22 + chain - 33);
      for ( chip = 0; chip <= 59; ++chip )
        scanfreq_info.final_chip_freq[chain][chip] = scanfreq_info.ideal_hash_rate_freq[chain][index];
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: chain[%d] ideal hash freq:       %d\n",
            "freq_scan.c",
            4146,
            (const char *)_FUNCTION___15885,
            chain,
            scanfreq_info.ideal_hash_rate_freq[chain][index]);
        fclose(pFile_5);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: chain[%d] max hashrate:          %d\n",
            "freq_scan.c",
            4147,
            (const char *)_FUNCTION___15885,
            chain,
            scanfreq_info.max_hashrate[chain]);
        fclose(pFile_6);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(
            pFile_7,
            "%s:%d:%s: chain[%d] ideal hashrate:        %d\n",
            "freq_scan.c",
            4148,
            (const char *)_FUNCTION___15885,
            chain,
            scanfreq_info.ideal_hashrate[chain]);
        fclose(pFile_7);
      }
    }
  }
}

//----- (0003A0A0) --------------------------------------------------------
int __cdecl boardsweep_start(working_mode_e working_mode)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  int chain_num; // [sp+14h] [bp+Ch]
  int ret; // [sp+18h] [bp+10h]
  int chain_count; // [sp+1Ch] [bp+14h]

  chain_num = dev->chain_num;
  for ( chain_count = 0; chain_count < chain_num; ++chain_count )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: sweep for %d chain\n",
          "freq_scan.c",
          4161,
          (const char *)_FUNCTION___15927,
          chain_count);
      fclose(pFile);
    }
    sweep_set_current_chain(chain_count);
    ret = boardsweep_get_chip_max_freq(working_mode);
    if ( ret )
      return ret;
    scan_freq_stop_hash_board();
  }
  check_chain();
  boardsweep_get_ideal_hashrate(working_mode);
  sweep_freq_save_result(working_mode);
  if ( (unsigned __int8)eeprom_save() != 1 )
    return -1;
  freq_scan_set_state();
  return 0;
}

//----- (0003A196) --------------------------------------------------------
int boardsweep_task()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile_2; // [sp+14h] [bp+Ch]
  time_t search_end_time; // [sp+18h] [bp+10h]
  FILE *pFile_1; // [sp+1Ch] [bp+14h]
  time_t search_start_time; // [sp+20h] [bp+18h]
  int ret; // [sp+24h] [bp+1Ch]

  freq_scan_status = 0;
  if ( scan_freq_already_done() )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: scan freq has already been done\n",
          "freq_scan.c",
          4198,
          (const char *)_FUNCTION___15937);
      fclose(pFile);
    }
    freq_scan_status = 1;
    return 0;
  }
  else
  {
    is_freq_scan_succeeded_flag = 0;
    test_8pattern = 1;
    check_column_nonce = 0;
    search_start_time = time(0);
    if ( scan_freq_prepare() >= 0 )
    {
      boardsweep_start(MODE2);
      check_chain();
      scan_freq_stop_hash_board();
      sleep(0x1Eu);
      ret = eeprom_date_check();
      if ( ret )
      {
        return ret;
      }
      else
      {
        eeprom_dump();
        scan_freq_done_mark();
        is_freq_scan_succeeded_flag = 1;
        aging_start();
        freq_scan_status = 1;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: cancel the receive thread\n",
              "freq_scan.c",
              4234,
              (const char *)_FUNCTION___15937);
          fclose(pFile_1);
        }
        pthread_cancel(receive_id);
        search_end_time = time(0);
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: total cost time %ld s \n",
              "freq_scan.c",
              4238,
              (const char *)_FUNCTION___15937,
              search_end_time - search_start_time);
          fclose(pFile_2);
        }
        return 0;
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: sweep freq prepare failed\n",
            "freq_scan.c",
            4209,
            (const char *)_FUNCTION___15937);
        fclose(pFile_0);
      }
      freq_scan_status = 2;
      return -1;
    }
  }
}
// 3A2FA: conditional instruction was optimized away because %ret.4==0

//----- (0003A432) --------------------------------------------------------
void __cdecl stop_mining(const unsigned __int8 *str)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  int chain; // [sp+14h] [bp+Ch]

  if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: fetal error: stop ming: %s\n",
        "power.c",
        84,
        (const char *)_FUNCTION___12640,
        (const char *)str);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      disable_pic_dac(chain);
      dev->chain_exist[chain] = 0;
      --dev->chain_num;
    }
  }
  while ( 1 )
    sleep(1u);
}

//----- (0003A518) --------------------------------------------------------
void power_on()
{
  FILE *pFile; // [sp+Ch] [bp+4h]

  if ( access("/sys/class/gpio/gpio907", 0) == -1 )
  {
    system("echo 907 > /sys/class/gpio/export");
    system("echo out > /sys/class/gpio/gpio907/direction");
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: init gpio907\n", "power.c", 140, (const char *)_FUNCTION___12665);
      fclose(pFile);
    }
  }
  system("echo 0 > /sys/class/gpio/gpio907/value");
  sleep(1u);
}

//----- (0003A5CE) --------------------------------------------------------
void power_check_protocal_type()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  uint8_t ret; // [sp+17h] [bp+Fh]

  pthread_mutex_lock(&iic_mutex);
  ret = zynq_set_iic(power_iic_addr, power_iic_no, 1, 1, 0, 0);
  if ( ret == 245 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: power protocal %02x, using package cmd\n",
          "power.c",
          169,
          (const char *)_FUNCTION___12674,
          ret);
      fclose(pFile);
    }
    power_protocal_type = 2;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: power protocal %02x, using simple cmd\n",
          "power.c",
          174,
          (const char *)_FUNCTION___12674,
          ret);
      fclose(pFile_0);
    }
    power_protocal_type = 1;
  }
  pthread_mutex_unlock(&iic_mutex);
}

//----- (0003A718) --------------------------------------------------------
void power_init()
{
  double *p_current_voltage; // r2
  double *p_higher_voltage; // r2
  FILE *pFile; // [sp+8h] [bp+0h]
  int chain; // [sp+Ch] [bp+4h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: power init ... \n", "power.c", 183, (const char *)_FUNCTION___12681);
    fclose(pFile);
  }
  if ( is_T11() )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        power_info[chain].is_voltage_stable = 0;
        p_current_voltage = &power_info[chain].current_voltage;
        *(_DWORD *)p_current_voltage = 0;
        *((_DWORD *)p_current_voltage + 1) = 0;
        power_info[chain].working_voltage = 9.80000019;
        p_higher_voltage = &power_info[chain].higher_voltage;
        *(_DWORD *)p_higher_voltage = 0;
        *((_DWORD *)p_higher_voltage + 1) = 0;
        power_info[chain].highest_voltage = 10.1999998;
        power_info[chain].current_iic_data = 0;
        power_info[chain].chain_num = chain;
        g_minor_type = g_minor_type[chain];
      }
    }
  }
  else
  {
    power_info[0].is_voltage_stable = 0;
    power_info[0].current_voltage = 0.0;
    power_info[0].working_voltage = 9.80000019;
    power_info[0].higher_voltage = 0.0;
    power_info[0].highest_voltage = 10.1999998;
    power_info[0].chain_num = -1;
  }
  if ( (unsigned __int8)is_T11() != 1 )
  {
    power_check_protocal_type();
    power_on();
  }
}

//----- (0003A950) --------------------------------------------------------
void __cdecl set_working_voltage(double working_voltage)
{
  double v1; // d0
  FILE *pFile; // [sp+1Ch] [bp+Ch]

  power_info[0].working_voltage = v1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: working_voltage = %f\n",
        "power.c",
        219,
        (const char *)_FUNCTION___12690,
        power_info[0].working_voltage);
    fclose(pFile);
  }
}
// 3A966: variable 'v1' is possibly undefined

//----- (0003A9EA) --------------------------------------------------------
void __cdecl set_working_voltage_by_chain(uint8_t chain, double working_voltage)
{
  double v2; // d0
  FILE *pFile; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]

  if ( dev->chain_exist[chain] == 1 )
  {
    power_info[chain].working_voltage = v2;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chain[%d] working_voltage = %f\n",
          "power.c",
          228,
          (const char *)_FUNCTION___12696,
          chain,
          power_info[chain].working_voltage);
      fclose(pFile);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: error! chain[%d] does not exist!\n",
        "power.c",
        232,
        (const char *)_FUNCTION___12696,
        chain);
    fclose(pFile_0);
  }
}
// 3AA2A: variable 'v2' is possibly undefined

//----- (0003AB30) --------------------------------------------------------
void __cdecl set_higher_voltage_by_chain(uint8_t chain, double higher_voltage)
{
  double v2; // d0
  __int64 higher_voltagea; // [sp+18h] [bp+0h]
  FILE *pFile_0; // [sp+2Ch] [bp+14h]
  FILE *pFile; // [sp+30h] [bp+18h]
  FILE *pFile_1; // [sp+34h] [bp+1Ch]

  higher_voltagea = *(_QWORD *)&v2;
  if ( dev->chain_exist[chain] == 1 )
  {
    if ( v2 > 10.8000002 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: warning!!!chain[%d] higher_voltage = %f,max_higher_voltage = %f\n",
            "power.c",
            248,
            (const char *)_FUNCTION___12708,
            chain,
            v2,
            10.8000002);
        fclose(pFile);
      }
      higher_voltagea = 0x40259999A0000000LL;
    }
    *(_QWORD *)&power_info[chain].higher_voltage = higher_voltagea;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain[%d] higher_voltage = %f\n",
          "power.c",
          253,
          (const char *)_FUNCTION___12708,
          chain,
          power_info[chain].higher_voltage);
      fclose(pFile_0);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: error! chain[%d] does not exist!\n",
        "power.c",
        257,
        (const char *)_FUNCTION___12708,
        chain);
    fclose(pFile_1);
  }
}
// 3AB38: variable 'v2' is possibly undefined

//----- (0003AD20) --------------------------------------------------------
void __cdecl set_highest_voltage_by_chain(uint8_t chain, double highest_voltage)
{
  double v2; // d0
  FILE *pFile; // [sp+1Ch] [bp+14h]

  if ( dev->chain_exist[chain] == 1 )
  {
    power_info[chain].highest_voltage = v2;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: error! chain[%d] does not exist!\n",
        "power.c",
        269,
        (const char *)_FUNCTION___12716,
        chain);
    fclose(pFile);
  }
}
// 3AD60: variable 'v2' is possibly undefined

//----- (0003ADDC) --------------------------------------------------------
void get_working_voltage()
{
  ;
}

//----- (0003ADFA) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl get_working_voltage_by_chain(uint8_t chain)
{
  int v1; // r1
  double result; // r0
  uint8_t chaina; // [sp+Fh] [bp+7h]
  FILE *pFile; // [sp+14h] [bp+Ch]

  chaina = chain;
  if ( dev->chain_exist[chain] == 1 )
  {
    v1 = chain;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: error! chain[%d] does not exist!\n",
        "power.c",
        286,
        (const char *)_FUNCTION___12724,
        chaina);
    *(_DWORD *)&chain = fclose(pFile);
  }
  LOBYTE(result) = chain;
  return result;
}
// 3ADFA: variables would overlap: r0.1 and r0.8
// 3ADFA: bad return variable

//----- (0003AEBA) --------------------------------------------------------
void get_current_voltage()
{
  ;
}

//----- (0003AED8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl get_current_voltage_by_chain(uint8_t chain)
{
  int v1; // r1
  double result; // r0
  uint8_t chaina; // [sp+Fh] [bp+7h]
  FILE *pFile; // [sp+14h] [bp+Ch]

  chaina = chain;
  if ( dev->chain_exist[chain] == 1 )
  {
    v1 = chain;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: error! chain[%d] does not exist!\n",
        "power.c",
        304,
        (const char *)_FUNCTION___12732,
        chaina);
    *(_DWORD *)&chain = fclose(pFile);
  }
  LOBYTE(result) = chain;
  return result;
}
// 3AED8: variables would overlap: r0.1 and r0.8
// 3AED8: bad return variable

//----- (0003AF98) --------------------------------------------------------
void get_higher_voltage()
{
  ;
}

//----- (0003AFB6) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl get_higher_voltage_by_chain(uint8_t chain)
{
  int v1; // r1
  double result; // r0
  uint8_t chaina; // [sp+Fh] [bp+7h]
  FILE *pFile; // [sp+14h] [bp+Ch]

  chaina = chain;
  if ( dev->chain_exist[chain] == 1 )
  {
    v1 = chain;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: error! chain[%d] does not exist!\n",
        "power.c",
        322,
        (const char *)_FUNCTION___12740,
        chaina);
    *(_DWORD *)&chain = fclose(pFile);
  }
  LOBYTE(result) = chain;
  return result;
}
// 3AFB6: variables would overlap: r0.1 and r0.8
// 3AFB6: bad return variable

//----- (0003B076) --------------------------------------------------------
bool power_is_support_cmd_package()
{
  return power_protocal_type == 2;
}

//----- (0003B098) --------------------------------------------------------
bool __cdecl power_check_reply(uint8_t *cmd, uint8_t *reply_buf, uint8_t reply_len)
{
  FILE *pFile_0; // [sp+20h] [bp+10h]
  FILE *pFile_1; // [sp+24h] [bp+14h]
  FILE *pFile; // [sp+28h] [bp+18h]
  FILE *pFile_3; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_4; // [sp+30h] [bp+20h]
  FILE *pFile_2; // [sp+34h] [bp+24h]
  uint16_t crc_reply; // [sp+3Ah] [bp+2Ah]
  uint16_t i; // [sp+3Ch] [bp+2Ch]
  uint16_t ia; // [sp+3Ch] [bp+2Ch]
  uint16_t ib; // [sp+3Ch] [bp+2Ch]
  uint16_t crc; // [sp+3Eh] [bp+2Eh]

  crc = 0;
  if ( *cmd == *reply_buf && cmd[1] == reply_buf[1] && cmd[3] == reply_buf[3] && reply_buf[2] + 2 == reply_len )
  {
    for ( ia = 2; ia < reply_len - 2; ++ia )
      crc += reply_buf[ia];
    crc_reply = reply_buf[reply_len - 2] + (reply_buf[reply_len - 1] << 8);
    if ( crc == crc_reply )
    {
      return 1;
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: power reply crc error, crc %04x != crc_reply %04x:\n",
            "power.c",
            356,
            (const char *)_FUNCTION___12753,
            crc,
            crc_reply);
        fclose(pFile_2);
      }
      for ( ib = 0; ib < (unsigned int)reply_len; ++ib )
      {
        if ( log_level > 3 )
        {
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(pFile_3, "%02x ", reply_buf[ib]);
          fclose(pFile_3);
        }
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fputc(10, pFile_4);
        fclose(pFile_4);
      }
      return 0;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: power reply data error:\n", "power.c", 340, (const char *)_FUNCTION___12753);
      fclose(pFile);
    }
    for ( i = 0; i < (unsigned int)reply_len; ++i )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%02x ", reply_buf[i]);
        fclose(pFile_0);
      }
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fputc(10, pFile_1);
      fclose(pFile_1);
    }
    return 0;
  }
}

//----- (0003B36C) --------------------------------------------------------
bool __cdecl power_send_cmd(uint8_t *cmd, uint8_t len, uint8_t *reply_buf, uint8_t reply_len)
{
  FILE *pFile; // [sp+24h] [bp+14h]
  uint8_t retry; // [sp+2Eh] [bp+1Eh]
  uint8_t i; // [sp+2Fh] [bp+1Fh]
  uint8_t ia; // [sp+2Fh] [bp+1Fh]

  retry = 0;
  pthread_mutex_lock(&iic_mutex);
  while ( retry <= 2u )
  {
    for ( i = 0; i < (unsigned int)len; zynq_set_iic(0x10u, 1u, 0, 1, 0x11u, cmd[i++]) )
      ;
    usleep(0x7A120u);
    for ( ia = 0; ia < (unsigned int)reply_len; reply_buf[ia++] = zynq_set_iic(0x10u, 1u, 1, 0, 0x11u, 0) )
      ;
    if ( power_check_reply(cmd, reply_buf, reply_len) )
      break;
    ++retry;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: power send cmd 0x%02x failed, retry for %d times\n",
          "power.c",
          391,
          (const char *)_FUNCTION___12787,
          cmd[3],
          retry);
      fclose(pFile);
    }
  }
  pthread_mutex_unlock(&iic_mutex);
  return retry <= 2u;
}

//----- (0003B4CA) --------------------------------------------------------
void __cdecl power_set_da_value(uint8_t da_value)
{
  uint8_t reply[32]; // [sp+Ch] [bp+Ch] BYREF
  uint8_t cmd[8]; // [sp+2Ch] [bp+2Ch] BYREF
  uint16_t i; // [sp+34h] [bp+34h]
  uint16_t crc; // [sp+36h] [bp+36h]
  __int64 savedregs; // [sp+38h] [bp+38h] BYREF

  *(_DWORD *)cmd = -2096715179;
  memset(reply, 0, sizeof(reply));
  crc = 0;
  *(_DWORD *)&cmd[4] = da_value;
  for ( i = 2; i <= 5u; ++i )
    crc += *((unsigned __int8 *)&savedregs + i - 12);
  *(_WORD *)&cmd[6] = crc;
  power_send_cmd(cmd, 8u, reply, 8u);
}

//----- (0003B552) --------------------------------------------------------
uint8_t __cdecl power_set_da_value_simple(uint8_t data)
{
  uint8_t ret; // [sp+15h] [bp+Dh]

  pthread_mutex_lock(&iic_mutex);
  usleep(0x186A0u);
  ret = zynq_set_iic(power_iic_addr, power_iic_no, 0, 1, 2u, data);
  pthread_mutex_unlock(&iic_mutex);
  return ret;
}

//----- (0003B5C0) --------------------------------------------------------
uint8_t __cdecl power_set_voltage(power_info_t *power, uint8_t da_value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]
  FILE *pFile_0; // [sp+18h] [bp+10h]

  if ( is_T11() )
  {
    if ( power->chain_num == 255 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: error! power info is not correct, please check!\n",
            "power.c",
            565,
            (const char *)_FUNCTION___12883);
        fclose(pFile);
      }
      return -1;
    }
    return set_pic_da_value(power->chain_num, da_value);
  }
  if ( power->chain_num == 255 )
  {
    if ( power_is_support_cmd_package() )
    {
      power_set_da_value(da_value);
      return 0;
    }
    return power_set_da_value_simple(da_value);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: error! power info is not correct, please check!\n",
        "power.c",
        576,
        (const char *)_FUNCTION___12883);
    fclose(pFile_0);
  }
  return -1;
}

//----- (0003B710) --------------------------------------------------------
uint8_t __cdecl get_power_iic_value_from_voltage(double voltage)
{
  double v1; // d0
  FILE *pFile; // [sp+18h] [bp+10h]
  uint8_t iic_index; // [sp+1Fh] [bp+17h]

  if ( is_T11() )
  {
    if ( g_minor_type == PKG_CE || g_minor_type == PKG_B_BGM )
      iic_index = (unsigned int)((1943.4048 - v1 * 174.9552) / (v1 * 5.74 - 44.244));
    else
      iic_index = (unsigned int)((1899.7248 - v1 * 161.5872) / (v1 * 5.26 - 43.956));
    if ( (iic_index & 0x80u) != 0 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: %d iic data is more than voltage max iic data 127\n",
            "power.c",
            609,
            (const char *)_FUNCTION___12890,
            iic_index);
        fclose(pFile);
      }
      return 127;
    }
  }
  else if ( power_is_support_cmd_package() )
  {
    return (unsigned int)(1215.89444 - v1 * 59.931507);
  }
  else
  {
    return (unsigned int)(1718.45913 - v1 * 85.509875);
  }
  return iic_index;
}
// 3B74E: variable 'v1' is possibly undefined

//----- (0003B8F0) --------------------------------------------------------
double __cdecl get_power_voltage_from_iic_value(uint8_t data)
{
  double result; // r0
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  double voltage; // [sp+20h] [bp+10h]

  if ( is_T11() )
  {
    if ( (data & 0x80u) == 0 )
    {
      if ( g_minor_type == PKG_CE || g_minor_type == PKG_B_BGM )
        voltage = ((double)data * 44.244 + 1943.4048) / ((double)data * 5.74 + 174.9552);
      else
        voltage = ((double)data * 43.956 + 1899.7248) / ((double)data * 5.26 + 161.5872);
    }
    else
    {
      voltage = 0.0;
    }
  }
  else if ( power_is_support_cmd_package() )
  {
    voltage = (1215.89444 - (double)data) / 59.931507;
  }
  else
  {
    voltage = (1718.45913 - (double)data) / 85.509875;
  }
  LODWORD(result) = is_T11();
  if ( LOBYTE(result) != 1 && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: iic_index for voltage[%d] = %f\n",
        "power.c",
        676,
        (const char *)_FUNCTION___12897,
        data,
        voltage);
    LODWORD(result) = fclose(pFile);
  }
  return result;
}

//----- (0003BAF8) --------------------------------------------------------
bool __cdecl set_iic_power_by_voltage(double target_vol, power_info_t *power)
{
  double v2; // d0
  power_info_t *powera; // [sp+14h] [bp+4h]
  FILE *pFile; // [sp+20h] [bp+10h]
  uint8_t iic_vol_data; // [sp+27h] [bp+17h]

  powera = (power_info_t *)LODWORD(target_vol);
  *(_BYTE *)LODWORD(target_vol) = 1;
  iic_vol_data = get_power_iic_value_from_voltage(target_vol);
  power_set_voltage(powera, iic_vol_data);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: now setting voltage to : %f \n", "power.c", 689, (const char *)_FUNCTION___12904, v2);
    fclose(pFile);
  }
  usleep(0x493E0u);
  powera->current_voltage = v2;
  powera->current_iic_data = iic_vol_data;
  return 1;
}
// 3BB8C: variable 'v2' is possibly undefined

//----- (0003BBBE) --------------------------------------------------------
bool __cdecl set_iic_power_by_iic_data(uint8_t target_data, power_info_t *power)
{
  double v2; // d0
  FILE *pFile; // [sp+1Ch] [bp+Ch]

  power->is_voltage_stable = 1;
  get_power_voltage_from_iic_value(target_data);
  power_set_voltage(power, target_data);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: now setting voltage to : %f \n",
        "power.c",
        710,
        (const char *)_FUNCTION___12911,
        power->current_voltage);
    fclose(pFile);
  }
  usleep(0x493E0u);
  power->current_voltage = v2;
  power->current_iic_data = target_data;
  return 1;
}
// 3BC6C: variable 'v2' is possibly undefined

//----- (0003BC82) --------------------------------------------------------
int __fastcall set_iic_power_to_highest_voltage(double a1, power_info_t *a2)
{
  FILE *pFile; // [sp+14h] [bp+4h]
  double target_vol; // [sp+18h] [bp+8h]

  target_vol = power_info[0].highest_voltage;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: setting to hightest voltage: %0.2f ...\n",
        "power.c",
        741,
        (const char *)_FUNCTION___12925,
        target_vol);
    fclose(pFile);
  }
  LODWORD(a1) = power_info;
  if ( set_iic_power_by_voltage(a1, a2) )
    return 1;
  freq_scan_error_code_set(12, 0);
  return 0;
}
// 3BD14: variable 'a1' is possibly undefined
// 3BD14: variable 'a2' is possibly undefined

//----- (0003BD3A) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __cdecl set_iic_power_to_highest_voltage_by_chain(int8_t chain)
{
  power_info_t *v2; // r2
  double v3; // r0
  FILE *pFile; // [sp+18h] [bp+8h]
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  double target_vol; // [sp+20h] [bp+10h]

  if ( dev->chain_exist[chain] )
  {
    v2 = power_info;
    target_vol = power_info[chain].highest_voltage;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain[%d] setting to hightest voltage: %0.2f ...\n",
          "power.c",
          763,
          (const char *)_FUNCTION___12932,
          chain,
          target_vol);
      fclose(pFile_0);
    }
    LODWORD(v3) = &power_info[chain];
    if ( !set_iic_power_by_voltage(v3, v2) )
    {
      freq_scan_error_code_set(12, 0);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error! chain[%d] does not exist!\n",
          "power.c",
          758,
          (const char *)_FUNCTION___12932,
          chain);
      fclose(pFile);
    }
    return 0;
  }
}
// 3BD3A: variables would overlap: r0.1 and r0.8

//----- (0003BE96) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __cdecl slowly_adapt_voltage(power_info_t *power, double target_vol, uint32_t ms_delay)
{
  double v3; // d0
  int v4; // r1
  int v5; // r1
  double v6; // r0
  double v7; // r0
  int v8; // r2
  __int64 v9; // kr00_8
  int v10; // r2
  int v12; // r3
  int v13; // r3
  int v14; // r3
  uint8_t threshold_iic_data; // [sp+17h] [bp+17h]
  uint8_t target_iic_data; // [sp+18h] [bp+18h]
  bool reta; // [sp+19h] [bp+19h]
  bool ret; // [sp+19h] [bp+19h]
  uint8_t diff_iic_data; // [sp+1Ah] [bp+1Ah]
  uint8_t temp_iic_data; // [sp+1Bh] [bp+1Bh]
  int negate; // [sp+1Ch] [bp+1Ch]
  int sleep_ms; // [sp+20h] [bp+20h]
  int i; // [sp+24h] [bp+24h]

  i = 0;
  if ( v4 )
    sleep_ms = v5;
  else
    sleep_ms = 1000;
  if ( v3 > power->current_voltage )
    negate = -1;
  else
    negate = 1;
  LODWORD(v6) = get_power_iic_value_from_voltage(*(double *)&power);
  temp_iic_data = LOBYTE(v6);
  target_iic_data = get_power_iic_value_from_voltage(v6);
  v8 = abs32(temp_iic_data - target_iic_data);
  v9 = 715827883LL * v8;
  v10 = v8 >> 31;
  threshold_iic_data = BYTE4(v9) - v10;
  if ( negate == -1 )
  {
    LODWORD(v7) = power;
    reta = set_iic_power_by_voltage(v7, (power_info_t *)v10);
    power->current_voltage = v3;
    power->current_iic_data = target_iic_data;
    return reta;
  }
  while ( i <= 4 )
  {
    temp_iic_data += threshold_iic_data * negate;
    if ( !set_iic_power_by_iic_data(temp_iic_data, power) )
      return 0;
    usleep(500 * sleep_ms);
    if ( !threshold_iic_data )
      goto LABEL_14;
    ++i;
  }
  while ( 1 )
  {
LABEL_14:
    v12 = temp_iic_data - target_iic_data;
    if ( v12 < 0 )
      LOBYTE(v12) = target_iic_data - temp_iic_data;
    if ( (unsigned __int8)v12 <= 0x20u )
    {
      if ( (unsigned __int8)v12 <= 0x10u )
        diff_iic_data = 2;
      else
        diff_iic_data = 8;
    }
    else
    {
      diff_iic_data = 16;
    }
    v13 = temp_iic_data - target_iic_data;
    if ( v13 < 0 )
      v13 = target_iic_data - temp_iic_data;
    if ( v13 > 2 )
    {
      temp_iic_data += diff_iic_data * negate;
      if ( !set_iic_power_by_iic_data(temp_iic_data, power) )
        return 0;
      goto LABEL_26;
    }
    v14 = temp_iic_data - target_iic_data;
    if ( v14 < 0 )
      v14 = target_iic_data - temp_iic_data;
    if ( v14 <= 1 )
      break;
    temp_iic_data += negate;
    if ( !set_iic_power_by_iic_data(temp_iic_data, power) )
      return 0;
LABEL_26:
    usleep(500 * sleep_ms);
  }
  ret = set_iic_power_by_iic_data(target_iic_data, power);
  if ( !ret )
    return 0;
  usleep(500 * sleep_ms);
  power->current_voltage = v3;
  power->current_iic_data = target_iic_data;
  return ret;
}
// 3BE96: variables would overlap: r0.4 and r0.8

//----- (0003C0C0) --------------------------------------------------------
bool __cdecl slowly_set_iic_power_to_custom_voltage(double custom_voltage)
{
  double v1; // r2
  double v2; // d0
  uint32_t ms_delay; // [sp+0h] [bp-10h]
  FILE *pFile; // [sp+1Ch] [bp+Ch]

  HIDWORD(v1) = log_level;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: slowly setting to voltage: %0.2f ...\n",
        "power.c",
        913,
        (const char *)_FUNCTION___12971,
        v2);
    fclose(pFile);
  }
  if ( slowly_adapt_voltage(power_info, v1, ms_delay) )
    return 1;
  freq_scan_error_code_set(12, 0);
  stop_mining("power set failed!\n");
  return 0;
}
// 3C144: variable 'v2' is possibly undefined
// 3C156: variable 'v1' is possibly undefined
// 3C156: variable 'ms_delay' is possibly undefined

//----- (0003C188) --------------------------------------------------------
bool __cdecl slowly_set_iic_power_to_custom_voltage_by_chain(uint8_t chain, double custom_voltage)
{
  double v2; // d0
  double v4; // r2
  uint32_t ms_delay; // [sp+0h] [bp-10h]
  FILE *pFile; // [sp+24h] [bp+14h]
  FILE *pFile_0; // [sp+28h] [bp+18h]

  if ( dev->chain_exist[chain] )
  {
    LODWORD(v4) = power_info;
    HIDWORD(v4) = log_level;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain[%d] slowly setting to voltage: %0.2f ...\n",
          "power.c",
          935,
          (const char *)_FUNCTION___12979,
          chain,
          v2);
      fclose(pFile_0);
    }
    if ( !slowly_adapt_voltage(&power_info[chain], v4, ms_delay) )
    {
      freq_scan_error_code_set(12, 0);
      disable_pic_dac(chain);
      dev->chain_exist[chain] = 0;
      --dev->chain_num;
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error! chain[%d] does not exist!\n",
          "power.c",
          931,
          (const char *)_FUNCTION___12979,
          chain);
      fclose(pFile);
    }
    return 0;
  }
}
// 3C2A8: variable 'v2' is possibly undefined
// 3C2BA: variable 'v4' is possibly undefined
// 3C2BA: variable 'ms_delay' is possibly undefined

//----- (0003C31C) --------------------------------------------------------
int slowly_set_iic_power_to_working_voltage()
{
  double v0; // r2
  uint32_t ms_delay; // [sp+0h] [bp-10h]
  FILE *pFile; // [sp+14h] [bp+4h]
  double target_vol; // [sp+18h] [bp+8h]

  target_vol = power_info[0].working_voltage;
  sprintf((char *)displayed_working_voltage, "%.2f", power_info[0].working_voltage);
  HIDWORD(v0) = log_level;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: slowly setting to voltage: %0.2f ...\n",
        "power.c",
        954,
        (const char *)_FUNCTION___12986,
        target_vol);
    fclose(pFile);
  }
  if ( slowly_adapt_voltage(power_info, v0, ms_delay) )
    return 1;
  freq_scan_error_code_set(12, 0);
  stop_mining("power set failed!\n");
  return 0;
}
// 3C3C8: variable 'v0' is possibly undefined
// 3C3C8: variable 'ms_delay' is possibly undefined

//----- (0003C3FA) --------------------------------------------------------
bool __cdecl slowly_set_iic_power_to_working_voltage_by_chain(uint8_t chain)
{
  double v2; // r2
  uint32_t ms_delay; // [sp+0h] [bp-10h]
  FILE *pFile; // [sp+18h] [bp+8h]
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  double target_vol; // [sp+20h] [bp+10h]
  power_info_t *power; // [sp+2Ch] [bp+1Ch]

  if ( dev->chain_exist[chain] )
  {
    power = &power_info[chain];
    target_vol = power->working_voltage;
    sprintf((char *)displayed_working_voltage, "%.2f", target_vol);
    HIDWORD(v2) = log_level;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain[%d] slowly setting to voltage: %0.2f ...\n",
          "power.c",
          978,
          (const char *)_FUNCTION___12992,
          chain,
          target_vol);
      fclose(pFile_0);
    }
    if ( !slowly_adapt_voltage(power, v2, ms_delay) )
    {
      freq_scan_error_code_set(12, 0);
      stop_mining("power set failed!\n");
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error! chain[%d] does not exist!\n",
          "power.c",
          970,
          (const char *)_FUNCTION___12992,
          chain);
      fclose(pFile);
    }
    return 0;
  }
}
// 3C542: variable 'v2' is possibly undefined
// 3C542: variable 'ms_delay' is possibly undefined

//----- (0003C574) --------------------------------------------------------
bool __cdecl slowly_set_iic_power_to_higher_voltage_by_chain(uint8_t chain)
{
  double v2; // r2
  uint32_t ms_delay; // [sp+0h] [bp-10h]
  FILE *pFile; // [sp+18h] [bp+8h]
  FILE *pFile_0; // [sp+1Ch] [bp+Ch]
  double target_vol; // [sp+20h] [bp+10h]
  power_info_t *power; // [sp+2Ch] [bp+1Ch]

  if ( dev->chain_exist[chain] )
  {
    power = &power_info[chain];
    target_vol = power->higher_voltage;
    sprintf((char *)displayed_working_voltage, "%.2f", target_vol);
    HIDWORD(v2) = log_level;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain[%d] slowly setting to voltage: %0.2f ...\n",
          "power.c",
          1058,
          (const char *)_FUNCTION___13020,
          chain,
          target_vol);
      fclose(pFile_0);
    }
    if ( !slowly_adapt_voltage(power, v2, ms_delay) )
    {
      freq_scan_error_code_set(12, 0);
      stop_mining("power set failed!\n");
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error! chain[%d] does not exist!\n",
          "power.c",
          1050,
          (const char *)_FUNCTION___13020,
          chain);
      fclose(pFile);
    }
    return 0;
  }
}
// 3C6BC: variable 'v2' is possibly undefined
// 3C6BC: variable 'ms_delay' is possibly undefined

//----- (0003C6EE) --------------------------------------------------------
void get_average_voltage()
{
  double v0; // d0
  FILE *pFile; // [sp+14h] [bp+4h]
  FILE *pFile_0; // [sp+18h] [bp+8h]
  FILE *pFile_1; // [sp+1Ch] [bp+Ch]
  double volt; // [sp+28h] [bp+18h]
  double volta; // [sp+28h] [bp+18h]
  int i; // [sp+30h] [bp+20h]
  int total_chain; // [sp+34h] [bp+24h]

  total_chain = 0;
  volt = 0.0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      get_pic_an_voltage2(i);
      volt = volt + v0;
      ++total_chain;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(power_log_file, 3u);
        pFile = fopen((const char *)power_log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d], voltage is: %f \n",
            "power.c",
            1085,
            (const char *)_FUNCTION___13034,
            i,
            v0);
        fclose(pFile);
      }
    }
  }
  if ( total_chain )
  {
    volta = volt / (double)total_chain;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(power_log_file, 3u);
      pFile_1 = fopen((const char *)power_log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%s:%d:%s: average voltage is: %f \n", "power.c", 1096, (const char *)_FUNCTION___13034, volta);
      fclose(pFile_1);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(power_log_file, 3u);
    pFile_0 = fopen((const char *)power_log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: error: total_chain get 0 !!", "power.c", 1091, (const char *)_FUNCTION___13034);
    fclose(pFile_0);
  }
}
// 3C746: variable 'v0' is possibly undefined

//----- (0003C8EA) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl calc_power_iic_data_by_chain(power_info_t *power, double target_vol)
{
  double v2; // d0
  double v3; // r0
  int v4; // r3
  int v5; // r3
  int v6; // r3
  uint8_t threshold_iic_data; // [sp+14h] [bp+14h]
  uint8_t target_iic_data; // [sp+15h] [bp+15h]
  uint8_t diff_iic_data; // [sp+16h] [bp+16h]
  uint8_t data; // [sp+17h] [bp+17h]
  int negate; // [sp+18h] [bp+18h]
  int index; // [sp+1Ch] [bp+1Ch]

  index = 0;
  LODWORD(v3) = get_power_iic_value_from_voltage(*(double *)&power);
  data = LOBYTE(v3);
  target_iic_data = get_power_iic_value_from_voltage(v3);
  threshold_iic_data = (char)abs32(data - target_iic_data) / 6;
  if ( v2 > power->current_voltage )
    negate = -1;
  else
    negate = 1;
  if ( negate == -1 )
  {
    power->iic_data[0] = target_iic_data;
    power->iic_data_index = 0;
  }
  else
  {
    while ( index <= 4 )
    {
      data += threshold_iic_data * negate;
      power->iic_data[index] = data;
      power->iic_data_index = index;
      if ( !threshold_iic_data )
        break;
      ++index;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v4 = data - target_iic_data;
        if ( v4 < 0 )
          LOBYTE(v4) = target_iic_data - data;
        if ( (unsigned __int8)v4 <= 0x20u )
        {
          if ( (unsigned __int8)v4 <= 0x10u )
            diff_iic_data = 2;
          else
            diff_iic_data = 8;
        }
        else
        {
          diff_iic_data = 16;
        }
        v5 = data - target_iic_data;
        if ( v5 < 0 )
          v5 = target_iic_data - data;
        if ( v5 <= 2 )
          break;
        data += diff_iic_data * negate;
        power->iic_data[index] = data;
        power->iic_data_index = index++;
      }
      v6 = data - target_iic_data;
      if ( v6 < 0 )
        v6 = target_iic_data - data;
      if ( v6 <= 1 )
        break;
      data += negate;
      power->iic_data[index] = data;
      power->iic_data_index = index++;
    }
    power->iic_data[index] = target_iic_data;
    power->iic_data_index = index;
  }
}
// 3C8EA: variables would overlap: r0.4 and r0.8

//----- (0003CA88) --------------------------------------------------------
void __cdecl slowly_set_iic_power_voltage_t11(int voltage_flag)
{
  double v1; // d0
  double v2; // r2
  int index[16]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile_2; // [sp+5Ch] [bp+4Ch]
  FILE *pFile_3; // [sp+60h] [bp+50h]
  FILE *pFile_1; // [sp+64h] [bp+54h]
  FILE *pFile_6; // [sp+68h] [bp+58h]
  FILE *pFile_7; // [sp+6Ch] [bp+5Ch]
  FILE *pFile_5; // [sp+70h] [bp+60h]
  FILE *pFile_4; // [sp+74h] [bp+64h]
  FILE *pFile_0; // [sp+78h] [bp+68h]
  FILE *pFile; // [sp+7Ch] [bp+6Ch]
  double voltage; // [sp+80h] [bp+70h]
  int max_index; // [sp+8Ch] [bp+7Ch]
  int chain; // [sp+90h] [bp+80h]
  int i; // [sp+94h] [bp+84h]
  int v18; // [sp+98h] [bp+88h] BYREF

  memset(index, 0, sizeof(index));
  voltage = 0.0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      memset(power_info[chain].iic_data, 255, sizeof(power_info[chain].iic_data));
      power_info[chain].is_voltage_stable = 1;
      if ( chain != power_info[chain].chain_num )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: ERROR! power info is incorrect!\n",
              "power.c",
              1196,
              (const char *)_FUNCTION___13065);
          fclose(pFile);
        }
        break;
      }
      if ( voltage_flag == 1 )
      {
        voltage = power_info[chain].working_voltage;
      }
      else if ( voltage_flag == 2 )
      {
        voltage = power_info[chain].higher_voltage;
      }
      LODWORD(v2) = power_info;
      HIDWORD(v2) = &power_info[chain];
      v1 = voltage;
      calc_power_iic_data_by_chain((power_info_t *)HIDWORD(v2), v2);
      *(&v18 + chain - 31) = power_info[chain].iic_data_index;
    }
  }
  max_index = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( max_index <= *(&v18 + i - 31) )
      max_index = *(&v18 + i - 31);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: parallel set all chain to working voltage:\n",
        "power.c",
        1225,
        (const char *)_FUNCTION___13065);
    fclose(pFile_0);
  }
  for ( i = 0; i <= max_index; ++i )
  {
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fwrite("now setting ", 1u, 0xCu, pFile_1);
      fclose(pFile_1);
    }
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        if ( power_info[chain].iic_data[i] != 255 )
        {
          get_power_voltage_from_iic_value(power_info[chain].iic_data[i]);
          voltage = v1;
          power_set_voltage(&power_info[chain], power_info[chain].iic_data[i]);
          power_info[chain].current_voltage = voltage;
          power_info[chain].current_iic_data = power_info[chain].iic_data[i];
          if ( log_level > 3 )
          {
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "chain[%d]-volt[%05.2f]-data[%03d] ",
                chain,
                power_info[chain].current_voltage,
                power_info[chain].current_iic_data);
            fclose(pFile_2);
          }
        }
      }
    }
    usleep(0x7A120u);
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fputc(10, pFile_3);
      fclose(pFile_3);
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(
        pFile_4,
        "%s:%d:%s: parallel set all chain to working voltage end!\n",
        "power.c",
        1245,
        (const char *)_FUNCTION___13065);
    fclose(pFile_4);
  }
  if ( log_level > 3 )
  {
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fwrite("now setting ", 1u, 0xCu, pFile_5);
    fclose(pFile_5);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "chain[%d]-volt[%05.2f]-data[%03d] ",
          chain,
          power_info[chain].current_voltage,
          power_info[chain].current_iic_data);
      fclose(pFile_6);
    }
  }
  if ( log_level > 3 )
  {
    pFile_7 = fopen((const char *)log_file, "a+");
    if ( pFile_7 )
      fputc(10, pFile_7);
    fclose(pFile_7);
  }
}
// 3CDC0: variable 'v1' is possibly undefined

//----- (0003D106) --------------------------------------------------------
void __cdecl slowly_set_working_power_t11(const uint8_t chain)
{
  double v1; // r2
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  FILE *pFile_3; // [sp+20h] [bp+10h]
  FILE *pFile_2; // [sp+24h] [bp+14h]
  FILE *pFile_1; // [sp+28h] [bp+18h]
  FILE *pFile_4; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_0; // [sp+30h] [bp+20h]
  int index; // [sp+34h] [bp+24h]
  double voltage; // [sp+38h] [bp+28h]
  int i; // [sp+44h] [bp+34h]

  memset(power_info[chain].iic_data, 255, sizeof(power_info[chain].iic_data));
  power_info[chain].is_voltage_stable = 1;
  if ( chain == power_info[chain].chain_num )
  {
    voltage = power_info[chain].working_voltage;
    LODWORD(v1) = power_info;
    HIDWORD(v1) = &power_info[chain];
    calc_power_iic_data_by_chain((power_info_t *)HIDWORD(v1), v1);
    index = power_info[chain].iic_data_index;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: set chain %u to working voltage:\n",
          "power.c",
          1275,
          (const char *)_FUNCTION___13098,
          chain);
      fclose(pFile_0);
    }
    for ( i = 0; i <= index; ++i )
    {
      if ( log_level > 3 )
      {
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fwrite("now setting ", 1u, 0xCu, pFile_1);
        fclose(pFile_1);
      }
      if ( power_info[chain].iic_data[i] != 255 )
      {
        get_power_voltage_from_iic_value(power_info[chain].iic_data[i]);
        power_set_voltage(&power_info[chain], power_info[chain].iic_data[i]);
        power_info[chain].current_voltage = voltage;
        power_info[chain].current_iic_data = power_info[chain].iic_data[i];
        if ( log_level > 3 )
        {
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "chain[%d]-volt[%05.2f]-data[%03d] ",
              chain,
              power_info[chain].current_voltage,
              power_info[chain].current_iic_data);
          fclose(pFile_2);
        }
        usleep(0x7A120u);
        if ( log_level > 3 )
        {
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fputc(10, pFile_3);
          fclose(pFile_3);
        }
      }
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%s:%d:%s: done!\n", "power.c", 1290, (const char *)_FUNCTION___13098);
      fclose(pFile_4);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: ERROR! power info is incorrect!\n", "power.c", 1267, (const char *)_FUNCTION___13098);
    fclose(pFile);
  }
}

//----- (0003D516) --------------------------------------------------------
__uint32_t __cdecl _uint32_identity(__uint32_t __x)
{
  return __x;
}

//----- (0003D52C) --------------------------------------------------------
void __cdecl json_decref(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0003D564) --------------------------------------------------------
void __cdecl _list_add(list_head *a1, list_head *prev, list_head *next)
{
  next->prev = a1;
  a1->next = next;
  a1->prev = prev;
  prev->next = a1;
}

//----- (0003D594) --------------------------------------------------------
void __cdecl list_add_tail(list_head *a1, list_head *head)
{
  _list_add(a1, head->prev, head);
}

//----- (0003D5B4) --------------------------------------------------------
void __cdecl _list_del(list_head *prev, list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

//----- (0003D5D6) --------------------------------------------------------
void __cdecl list_del(list_head *entry)
{
  _list_del(entry->prev, entry->next);
  entry->next = 0;
  entry->prev = 0;
}

//----- (0003D602) --------------------------------------------------------
int __cdecl list_empty(list_head *head)
{
  return head == head->next;
}

//----- (0003D626) --------------------------------------------------------
int sock_blocks()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (0003D652) --------------------------------------------------------
bool sock_timeout()
{
  return *_errno_location() == 110;
}

//----- (0003D66C) --------------------------------------------------------
bool interrupted()
{
  return *_errno_location() == 4;
}

//----- (0003D686) --------------------------------------------------------
void __cdecl align_len(size_t *len)
{
  if ( (*len & 3) != 0 )
    *len = (*len & 0xFFFFFFFC) + 4;
}

//----- (0003D6B4) --------------------------------------------------------
uint32_t __cdecl swab32_0(uint32_t v)
{
  return bswap32(v);
}

//----- (0003D6CC) --------------------------------------------------------
void __cdecl swab256(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = swab32_0(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = swab32_0(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = swab32_0(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = swab32_0(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = swab32_0(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = swab32_0(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = swab32_0(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = swab32_0(*(_DWORD *)src_p);
}

//----- (0003D78E) --------------------------------------------------------
void __cdecl mutex_lock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0003D80A) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0003D886) --------------------------------------------------------
void __cdecl mutex_unlock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_0(lock, file, func, line);
  selective_yield();
}

//----- (0003D8B4) --------------------------------------------------------
int __cdecl mutex_trylock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_mutex_trylock(lock);
}

//----- (0003D8D4) --------------------------------------------------------
void __cdecl wr_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0003D950) --------------------------------------------------------
void __cdecl rw_unlock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0003D9CC) --------------------------------------------------------
void __cdecl wr_unlock_noyield_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_0(lock, file, func, line);
}

//----- (0003D9EE) --------------------------------------------------------
void __cdecl cg_wlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_0(&lock->mutex, file, func, line);
  wr_lock_0(&lock->rwlock, file, func, line);
}

//----- (0003DA20) --------------------------------------------------------
void __cdecl cg_wunlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_0(&lock->rwlock, file, func, line);
  mutex_unlock_0(&lock->mutex, file, func, line);
}

//----- (0003DA52) --------------------------------------------------------
int no_yield()
{
  return 0;
}

//----- (0003DA62) --------------------------------------------------------
void __cdecl keep_sockalive(int fd)
{
  int tcp_keepintvl; // [sp+10h] [bp+8h] BYREF
  int tcp_keepidle; // [sp+14h] [bp+Ch] BYREF
  int tcp_one; // [sp+18h] [bp+10h] BYREF
  int flags; // [sp+1Ch] [bp+14h]

  tcp_one = 1;
  tcp_keepidle = 45;
  tcp_keepintvl = 30;
  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags | 0x800);
  setsockopt(fd, 1, 9, &tcp_one, 4u);
  if ( !opt_delaynet )
    fcntl(fd, 2, 1);
  setsockopt(fd, 6, 1, &tcp_one, 4u);
  setsockopt(fd, 6, 6, &tcp_one, 4u);
  setsockopt(fd, 6, 4, &tcp_keepidle, 4u);
  setsockopt(fd, 6, 5, &tcp_keepintvl, 4u);
}

//----- (0003DB1C) --------------------------------------------------------
void *__cdecl cgmalloc(uint32_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  size_t sizea[2]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  void *ret; // [sp+824h] [bp+814h]

  sizea[0] = size;
  align_len(sizea);
  ret = malloc(sizea[0]);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to malloc size %d from %s %s:%d",
      sizea[0],
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}
// 3DB1C: using guessed type size_t size[2];

//----- (0003DBAE) --------------------------------------------------------
void *__cdecl cgcalloc(int memb, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  size_t sizea; // [sp+18h] [bp+8h] BYREF
  int memba; // [sp+1Ch] [bp+Ch]
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  void *ret; // [sp+824h] [bp+814h]

  memba = memb;
  sizea = size;
  align_len(&sizea);
  ret = calloc(memba, sizea);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc memb %d size %d from %s %s:%d",
      memba,
      sizea,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}

//----- (0003DC4C) --------------------------------------------------------
void *__cdecl cgrealloc(
        void *ptr,
        size_t size,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  size_t sizea; // [sp+18h] [bp+8h] BYREF
  void *ptra; // [sp+1Ch] [bp+Ch]
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  void *ret; // [sp+824h] [bp+814h]

  ptra = ptr;
  sizea = size;
  align_len(&sizea);
  ret = realloc(ptra, sizea);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to realloc size %d from %s %s:%d",
      sizea,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}

//----- (0003DCE0) --------------------------------------------------------
const unsigned __int8 *__cdecl proxytype(proxytypes_t a1)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; proxynames[i].name; ++i )
  {
    if ( a1 == proxynames[i].proxytype )
      return proxynames[i].name;
  }
  return "invalid";
}

//----- (0003DD40) --------------------------------------------------------
unsigned __int8 *__cdecl get_proxy(unsigned __int8 *url, pool *pool)
{
  unsigned __int8 *split; // [sp+Ch] [bp+Ch]
  int plen; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  pool->rpc_proxy = 0;
  for ( i = 0; proxynames[i].name; ++i )
  {
    plen = strlen((const char *)proxynames[i].name);
    if ( !strncmp((const char *)url, (const char *)proxynames[i].name, plen) )
    {
      split = (unsigned __int8 *)strchr((const char *)url, 124);
      if ( !split )
        return url;
      *split = 0;
      pool->rpc_proxy = (unsigned __int8 *)cgmalloc(split - url - plen + 1, "util.c", _func___11532, 758);
      strcpy((char *)pool->rpc_proxy, (const char *)&url[plen]);
      extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
      pool->rpc_proxytype = proxynames[i].proxytype;
      return split + 1;
    }
  }
  return url;
}

//----- (0003DE42) --------------------------------------------------------
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *v3; // r2
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i < (int)len; ++i )
  {
    *s = hex_11542[p[i] >> 4];
    v3 = s + 1;
    s += 2;
    *v3 = hex_11542[p[i] & 0xF];
  }
  *s = 0;
}

//----- (0003DEB6) --------------------------------------------------------
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len)
{
  int v2; // r3
  unsigned __int8 *s; // [sp+10h] [bp+8h]
  int slen; // [sp+14h] [bp+Ch]

  slen = 2 * len + 1;
  if ( (slen & 3) != 0 )
  {
    v2 = slen & 3;
    if ( slen <= 0 )
      v2 = -(-slen & 3);
    slen += 4 - v2;
  }
  s = (unsigned __int8 *)cgcalloc(slen, 1u, "util.c", _func___11552, 798);
  _bin2hex(s, p, len);
  return s;
}

//----- (0003DF20) --------------------------------------------------------
bool __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len)
{
  unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+14h] BYREF
  int nibble2; // [sp+814h] [bp+814h]
  int nibble1; // [sp+818h] [bp+818h]
  unsigned __int8 idx; // [sp+81Eh] [bp+81Eh]
  bool ret; // [sp+81Fh] [bp+81Fh]

  ret = 0;
  while ( 1 )
  {
    if ( !*hexstr || !len )
    {
      if ( !len && !*hexstr )
        return 1;
      return ret;
    }
    if ( !hexstr[1] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "hex2bin str truncated");
        applog(3, tmp42, 0);
      }
      return ret;
    }
    idx = *hexstr;
    nibble1 = hex2bin_tbl[idx];
    v4 = (unsigned __int8 *)(hexstr + 1);
    hexstr += 2;
    idx = *v4;
    nibble2 = hex2bin_tbl[idx];
    if ( nibble1 < 0 || nibble2 < 0 )
      break;
    v5 = p++;
    *v5 = nibble2 | (16 * nibble1);
    --len;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "hex2bin scan failed");
    applog(3, tmp42, 0);
  }
  return ret;
}

//----- (0003E0CE) --------------------------------------------------------
bool __cdecl valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 idx; // [sp+823h] [bp+813h]
  int len; // [sp+824h] [bp+814h]
  bool ret; // [sp+82Bh] [bp+81Bh]
  int i; // [sp+82Ch] [bp+81Ch]

  ret = 0;
  if ( s )
  {
    len = strlen((const char *)s);
    for ( i = 0; ; ++i )
    {
      if ( i >= len )
      {
        ret = 1;
        return 1;
      }
      idx = s[i];
      if ( hex2bin_tbl[idx] < 0 )
        break;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Invalid char 0x%x passed to valid_hex from in %s %s():%d",
        idx,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Null string passed to valid_hex from in %s %s():%d",
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
}

//----- (0003E232) --------------------------------------------------------
bool __cdecl valid_ascii(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 idx; // [sp+823h] [bp+813h]
  int len; // [sp+824h] [bp+814h]
  bool ret; // [sp+82Bh] [bp+81Bh]
  int i; // [sp+82Ch] [bp+81Ch]

  ret = 0;
  if ( s )
  {
    len = strlen((const char *)s);
    if ( len )
    {
      for ( i = 0; ; ++i )
      {
        if ( i >= len )
        {
          ret = 1;
          return 1;
        }
        idx = s[i];
        if ( idx <= 0x1Fu || idx > 0x7Eu )
          break;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Invalid char 0x%x passed to valid_ascii from in %s %s():%d",
          idx,
          (const char *)file,
          (const char *)func,
          line);
        applog(3, tmp42, 0);
      }
      return ret;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Zero length string passed to valid_ascii from in %s %s():%d",
          (const char *)file,
          (const char *)func,
          line);
        applog(3, tmp42, 0);
      }
      return ret;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Null string passed to valid_ascii from in %s %s():%d",
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
}

//----- (0003E3FE) --------------------------------------------------------
bool __cdecl fulltest(const unsigned __int8 *hash, const unsigned __int8 *target)
{
  const char *v2; // r3
  unsigned __int8 hash_swap[32]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 target_swap[32]; // [sp+30h] [bp+28h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+50h] [bp+48h] BYREF
  unsigned __int8 *target_str; // [sp+850h] [bp+848h]
  unsigned __int8 *hash_str; // [sp+854h] [bp+84Ch]
  uint32_t t32tmp; // [sp+858h] [bp+850h]
  uint32_t h32tmp; // [sp+85Ch] [bp+854h]
  uint32_t *target32; // [sp+860h] [bp+858h]
  uint32_t *hash32; // [sp+864h] [bp+85Ch]
  int i; // [sp+868h] [bp+860h]
  bool rc; // [sp+86Fh] [bp+867h]

  hash32 = (uint32_t *)hash;
  target32 = (uint32_t *)target;
  rc = 1;
  for ( i = 7; i >= 0; --i )
  {
    h32tmp = _uint32_identity(hash32[i]);
    t32tmp = _uint32_identity(target32[i]);
    if ( h32tmp > t32tmp )
    {
      rc = 0;
      break;
    }
    if ( h32tmp < t32tmp )
    {
      rc = 1;
      break;
    }
  }
  if ( opt_debug )
  {
    swab256(hash_swap, hash);
    swab256(target_swap, target);
    hash_str = bin2hex(hash_swap, 0x20u);
    target_str = bin2hex(target_swap, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      if ( rc )
        v2 = "YES (hash <= target)";
      else
        v2 = "no (false positive; hash > target)";
      snprintf(
        (char *)tmp42,
        0x800u,
        " Proof: %s\nTarget: %s\nTrgVal? %s",
        (const char *)hash_str,
        (const char *)target_str,
        v2);
      applog(7, tmp42, 0);
    }
    free(hash_str);
    free(target_str);
  }
  return rc;
}

//----- (0003E57E) --------------------------------------------------------
thread_q *tq_new()
{
  thread_q *tq; // [sp+Ch] [bp+4h]

  tq = (thread_q *)cgcalloc(1, 0x58u, "util.c", _func___11664, 1087);
  tq->q.next = &tq->q;
  tq->q.prev = &tq->q;
  pthread_mutex_init(&tq->mutex, 0);
  pthread_cond_init(&tq->cond, 0);
  return tq;
}

//----- (0003E5D2) --------------------------------------------------------
void __cdecl tq_freezethaw(thread_q *tq, bool frozen)
{
  mutex_lock_0(&tq->mutex, "util.c", _func___11677, 1119);
  tq->frozen = frozen;
  pthread_cond_signal(&tq->cond);
  mutex_unlock_0(&tq->mutex, "util.c", _func___11677, 1122);
}

//----- (0003E632) --------------------------------------------------------
void __cdecl tq_freeze(thread_q *tq)
{
  tq_freezethaw(tq, 1);
}

//----- (0003E64A) --------------------------------------------------------
bool __cdecl tq_push(thread_q *tq, void *data)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  tq_ent *ent; // [sp+810h] [bp+808h]
  bool rc; // [sp+817h] [bp+80Fh]

  rc = 1;
  ent = (tq_ent *)cgcalloc(1, 0xCu, "util.c", _func___11690, 1140);
  ent->data = data;
  ent->q_node.next = &ent->q_node;
  ent->q_node.prev = &ent->q_node;
  mutex_lock_0(&tq->mutex, "util.c", _func___11690, 1144);
  if ( !tq->frozen )
  {
    list_add_tail(&ent->q_node, &tq->q);
  }
  else
  {
    free(ent);
    rc = 0;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11692, 1155);
    applog(7, tmp42, 0);
  }
  pthread_cond_signal(&tq->cond);
  mutex_unlock_0(&tq->mutex, "util.c", _func___11690, 1157);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11692, 1158);
    applog(7, tmp42, 0);
  }
  return rc;
}

//----- (0003E800) --------------------------------------------------------
void *__cdecl tq_pop(thread_q *tq, const timespec *abstime)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  tq_ent *ent; // [sp+810h] [bp+808h]
  int ret; // [sp+814h] [bp+80Ch]
  int rc; // [sp+818h] [bp+810h]
  void *rval; // [sp+81Ch] [bp+814h]

  rval = 0;
  ret = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11703, 1170);
    applog(7, tmp42, 0);
  }
  ret = mutex_trylock(&tq->mutex, "util.c", _func___11704, 1171);
  if ( ret )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "mutex_trylock failed in %s %d", (const char *)_FUNCTION___11703, ret);
      applog(4, tmp42, 0);
    }
    return rval;
  }
  else
  {
    if ( !list_empty(&tq->q)
      || (!abstime ? (rc = pthread_cond_wait(&tq->cond, &tq->mutex)) : (rc = pthread_cond_timedwait(
                                                                               &tq->cond,
                                                                               &tq->mutex,
                                                                               abstime)),
          !rc && !list_empty(&tq->q)) )
    {
      ent = (tq_ent *)&tq->q.next[-1].prev;
      rval = ent->data;
      list_del(&ent->q_node);
      free(ent);
    }
    mutex_unlock_0(&tq->mutex, "util.c", _func___11704, 1207);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11703, 1208);
      applog(7, tmp42, 0);
    }
    return rval;
  }
}

//----- (0003EA44) --------------------------------------------------------
int __cdecl thr_info_create(thr_info *thr, pthread_attr_t_0 *attr, void *(*start)(void *), void *arg)
{
  cgsem_init(&thr->sem, "util.c", _func___11716, 1214);
  return pthread_create(&thr->pth, attr, start, arg);
}

//----- (0003EA8A) --------------------------------------------------------
void __cdecl thr_info_cancel(thr_info *thr)
{
  if ( thr )
  {
    if ( thr->pth )
    {
      pthread_cancel(thr->pth);
      thr->pth = 0;
    }
    cgsem_destroy(&thr->sem);
  }
}

//----- (0003EAC4) --------------------------------------------------------
void __cdecl subtime(timeval *a, timeval *b)
{
  b->tv_sec = a->tv_sec - b->tv_sec;
  b->tv_usec = a->tv_usec - b->tv_usec;
  if ( b->tv_usec < 0 )
  {
    --b->tv_sec;
    b->tv_usec += 1000000;
  }
}

//----- (0003EB18) --------------------------------------------------------
void __cdecl addtime(timeval *a, timeval *b)
{
  b->tv_sec += a->tv_sec;
  b->tv_usec += a->tv_usec;
  if ( b->tv_usec > 999999 )
  {
    ++b->tv_sec;
    b->tv_usec -= 1000000;
  }
}

//----- (0003EB74) --------------------------------------------------------
bool __cdecl time_more(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec > b->tv_usec;
  else
    return a->tv_sec > b->tv_sec;
}

//----- (0003EBBC) --------------------------------------------------------
bool __cdecl time_less(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec < b->tv_usec;
  else
    return a->tv_sec < b->tv_sec;
}

//----- (0003EC04) --------------------------------------------------------
void __cdecl copy_time(timeval *dest, const timeval *src)
{
  memcpy(dest, src, sizeof(timeval));
}

//----- (0003EC20) --------------------------------------------------------
void __cdecl timeval_to_spec(timespec *spec, const timeval *val)
{
  spec->tv_sec = val->tv_sec;
  spec->tv_nsec = 1000 * val->tv_usec;
}

//----- (0003EC4E) --------------------------------------------------------
void __cdecl us_to_timespec(timespec *spec, int64_t us)
{
  lldiv_t tvdiv; // [sp+18h] [bp+10h] BYREF

  lldiv(&tvdiv, &tvdiv, us, HIDWORD(us), &calc_nonce_info.chain_asic_core_nonce_num[5][48][190], 0, us, HIDWORD(us));
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = 1000 * LODWORD(tvdiv.rem);
}
// 12534: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003EC9E) --------------------------------------------------------
void __cdecl ms_to_timespec(timespec *spec, int64_t ms)
{
  lldiv_t tvdiv; // [sp+18h] [bp+10h] BYREF

  lldiv(&tvdiv, &tvdiv, ms, HIDWORD(ms), 1000, 0, ms, HIDWORD(ms));
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = (_DWORD)&calc_nonce_info.chain_asic_core_nonce_num[5][48][190] * LODWORD(tvdiv.rem);
}
// 12534: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003ECEE) --------------------------------------------------------
void __cdecl spec_nscheck(timespec *ts)
{
  while ( ts->tv_nsec > 999999999 )
  {
    ts->tv_nsec -= 1000000000;
    ++ts->tv_sec;
  }
  while ( ts->tv_nsec < 0 )
  {
    ts->tv_nsec += 1000000000;
    --ts->tv_sec;
  }
}

//----- (0003ED56) --------------------------------------------------------
void __cdecl timeraddspec(timespec *a, const timespec *b)
{
  a->tv_sec += b->tv_sec;
  a->tv_nsec += b->tv_nsec;
  spec_nscheck(a);
}

//----- (0003ED8A) --------------------------------------------------------
void __cdecl cgtime(timeval *tv)
{
  gettimeofday(tv, 0);
}

//----- (0003EDA2) --------------------------------------------------------
void __cdecl cgtimer_time(cgtimer_t *ts_start)
{
  clock_gettime(1, ts_start);
}

//----- (0003EDBA) --------------------------------------------------------
void __cdecl nanosleep_abstime(timespec *ts_end)
{
  while ( clock_nanosleep(1, 1, ts_end, 0) == 4 )
    ;
}

//----- (0003EDDE) --------------------------------------------------------
void __cdecl cgsleep_ms_r(cgtimer_t *ts_start, int ms)
{
  timespec ts_end; // [sp+8h] [bp+8h] BYREF

  ms_to_timespec(&ts_end, ms);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (0003EE1A) --------------------------------------------------------
void __cdecl cgsleep_us_r(cgtimer_t *ts_start, int64_t us)
{
  timespec ts_end; // [sp+10h] [bp+10h] BYREF

  us_to_timespec(&ts_end, us);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (0003EE52) --------------------------------------------------------
void __cdecl cgsleep_ms(int ms)
{
  cgtimer_t ts_start; // [sp+8h] [bp+8h] BYREF

  cgtimer_time(&ts_start);
  cgsleep_ms_r(&ts_start, ms);
}

//----- (0003EE78) --------------------------------------------------------
void __cdecl cgsleep_us(int64_t us)
{
  cgtimer_t ts_start; // [sp+8h] [bp+8h] BYREF

  cgtimer_time(&ts_start);
  cgsleep_us_r(&ts_start, us);
}

//----- (0003EEA8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl tdiff(timeval *end, timeval *start)
{
  double result; // r0

  LODWORD(result) = end;
  return result;
}
// 3EEA8: variables would overlap: r0.4 and r0.8
// 3EEA8: bad return variable

//----- (0003EEF8) --------------------------------------------------------
bool __cdecl extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port)
{
  unsigned __int8 port[6]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 url_address[256]; // [sp+20h] [bp+18h] BYREF
  unsigned __int8 *slash; // [sp+120h] [bp+118h]
  unsigned __int8 *ipv6_end; // [sp+124h] [bp+11Ch]
  unsigned __int8 *ipv6_begin; // [sp+128h] [bp+120h]
  int port_len; // [sp+12Ch] [bp+124h]
  int url_len; // [sp+130h] [bp+128h]
  unsigned __int8 *port_start; // [sp+134h] [bp+12Ch]
  unsigned __int8 *url_end; // [sp+138h] [bp+130h]
  unsigned __int8 *url_begin; // [sp+13Ch] [bp+134h]

  port_start = 0;
  port_len = 0;
  *sockaddr_url = url;
  url_begin = (unsigned __int8 *)strstr((const char *)url, "//");
  if ( url_begin )
    url_begin += 2;
  else
    url_begin = url;
  ipv6_begin = (unsigned __int8 *)strchr((const char *)url_begin, 91);
  ipv6_end = (unsigned __int8 *)strchr((const char *)url_begin, 93);
  if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin )
    url_end = (unsigned __int8 *)strchr((const char *)ipv6_end, 58);
  else
    url_end = (unsigned __int8 *)strchr((const char *)url_begin, 58);
  if ( url_end )
  {
    url_len = url_end - url_begin;
    port_len = strlen((const char *)url_begin) - (url_end - url_begin) - 1;
    if ( port_len <= 0 )
      return 0;
    port_start = url_end + 1;
  }
  else
  {
    url_len = strlen((const char *)url_begin);
  }
  if ( url_len <= 0 )
    return 0;
  if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin )
  {
    url_len -= 2;
    ++url_begin;
  }
  snprintf((char *)url_address, 0xFEu, "%.*s", url_len, (const char *)url_begin);
  if ( port_len )
  {
    snprintf((char *)port, 6u, "%.*s", port_len, (const char *)port_start);
    slash = (unsigned __int8 *)strpbrk((const char *)port, "/#");
    if ( slash )
      *slash = 0;
  }
  else
  {
    strcpy((char *)port, "80");
  }
  *sockaddr_port = (unsigned __int8 *)strdup((const char *)port);
  *sockaddr_url = (unsigned __int8 *)strdup((const char *)url_address);
  return 1;
}

//----- (0003F0F6) --------------------------------------------------------
send_ret __cdecl _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  int v3; // r3
  signed int lenb; // [sp+Ch] [bp+4h]
  fd_set wd; // [sp+1Ch] [bp+14h] BYREF
  timeval timeout; // [sp+81Ch] [bp+814h] BYREF
  fd_set *__arr; // [sp+824h] [bp+81Ch]
  int sock; // [sp+828h] [bp+820h]
  unsigned int __i; // [sp+82Ch] [bp+824h]
  ssize_t sent; // [sp+830h] [bp+828h]
  ssize_t ssent; // [sp+834h] [bp+82Ch]

  sock = pool->sock;
  ssent = 0;
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)&wd, 0x800u, "SEND: %s", (const char *)s);
    applog(7, (const unsigned __int8 *)&wd, 0);
  }
  strcat((char *)s, "\n");
  for ( lenb = len + 1; lenb > 0; lenb -= sent )
  {
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    while ( 1 )
    {
      __arr = &wd;
      for ( __i = 0; __i <= 0x1F; ++__i )
        __arr->fds_bits[__i] = 0;
      LOBYTE(v3) = sock & 0x1F;
      if ( sock <= 0 )
        v3 = -(-sock & 0x1F);
      wd.fds_bits[sock / 32] |= 1 << v3;
      if ( select(sock + 1, 0, &wd, 0, &timeout) > 0 )
        break;
      if ( !interrupted() )
        return 1;
    }
    sent = send(pool->sock, &s[ssent], lenb, 0x4000);
    if ( sent < 0 )
    {
      if ( (unsigned __int8)sock_blocks() != 1 )
        return 2;
      sent = 0;
    }
    ssent += sent;
  }
  ++pool->cgminer_pool_stats.times_sent;
  pool->cgminer_pool_stats.bytes_sent += ssent;
  pool->cgminer_pool_stats.net_bytes_sent += ssent;
  return 0;
}

//----- (0003F346) --------------------------------------------------------
bool __cdecl stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+14h] BYREF
  send_ret ret; // [sp+814h] [bp+814h]

  ret = SEND_INACTIVE;
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "SEND: %s", (const char *)s);
    applog(7, tmp42, 0);
  }
  mutex_lock_0(&pool->stratum_lock, "util.c", _func___11918, 1743);
  if ( pool->stratum_active )
    ret = _stratum_send(pool, s, len);
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___11918, 1750);
  switch ( ret )
  {
    case SEND_SENDFAIL:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Failed to send in stratum_send");
        applog(7, tmp42, 0);
      }
      goto LABEL_17;
    case SEND_INACTIVE:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Stratum send failed due to no pool stratum_active");
        applog(7, tmp42, 0);
      }
      break;
    case SEND_SELECTFAIL:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Write select failed on pool %d sock", pool->pool_no);
        applog(7, tmp42, 0);
      }
LABEL_17:
      suspend_stratum(pool);
      break;
  }
  return ret == SEND_OK;
}

//----- (0003F5B0) --------------------------------------------------------
bool __cdecl socket_full(pool *pool, int wait)
{
  int v2; // r3
  __time_t waita; // [sp+8h] [bp+0h]
  fd_set rd; // [sp+14h] [bp+Ch] BYREF
  timeval timeout; // [sp+94h] [bp+8Ch] BYREF
  fd_set *__arr; // [sp+9Ch] [bp+94h]
  int sock; // [sp+A0h] [bp+98h]
  unsigned int __i; // [sp+A4h] [bp+9Ch]
  __int64 savedregs; // [sp+A8h] [bp+A0h] BYREF

  waita = wait;
  sock = pool->sock;
  if ( wait < 0 )
    waita = 0;
  __arr = &rd;
  for ( __i = 0; __i <= 0x1F; ++__i )
    __arr->fds_bits[__i] = 0;
  LOBYTE(v2) = sock & 0x1F;
  if ( sock <= 0 )
    v2 = -(-sock & 0x1F);
  *((_DWORD *)&savedregs + sock / 32 - 37) |= 1 << v2;
  timeout.tv_usec = 0;
  timeout.tv_sec = waita;
  return select(sock + 1, &rd, 0, 0, &timeout) > 0;
}

//----- (0003F67C) --------------------------------------------------------
bool __cdecl sock_full(pool *pool)
{
  return *pool->sockbuf || socket_full(pool, 0);
}

//----- (0003F6A6) --------------------------------------------------------
void __cdecl clear_sockbuf(pool *pool)
{
  if ( pool->sockbuf )
    *pool->sockbuf = 0;
}

//----- (0003F6CE) --------------------------------------------------------
void __cdecl clear_sock(pool *pool)
{
  int n; // [sp+Ch] [bp+Ch]

  mutex_lock_0(&pool->stratum_lock, "util.c", _func___11950, 1825);
  do
  {
    if ( pool->sock )
      n = recv(pool->sock, pool->sockbuf, 0x1FFCu, 0);
    else
      n = 0;
  }
  while ( n > 0 );
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___11950, 1834);
  clear_sockbuf(pool);
}

//----- (0003F74E) --------------------------------------------------------
void __cdecl recalloc_sock(pool *pool, size_t len)
{
  size_t news; // [sp+10h] [bp+8h]
  size_t old; // [sp+14h] [bp+Ch]

  old = strlen((const char *)pool->sockbuf);
  if ( len + old + 1 >= pool->sockbuf_size )
  {
    news = ((len + old + 1) & 0xFFFFE000) + 0x2000;
    pool->sockbuf = (unsigned __int8 *)cgrealloc(pool->sockbuf, news, "util.c", _func___11967, 1863);
    memset(&pool->sockbuf[old], 0, news - old);
    pool->sockbuf_size = news;
  }
}

//----- (0003F7E0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned __int8 *__cdecl recv_line(pool *pool)
{
  double v1; // d0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+14h] BYREF
  _BYTE tmp42_0[8192]; // [sp+814h] [bp+814h] OVERLAPPED BYREF
  timeval now; // [sp+2814h] [bp+2814h] BYREF
  timeval rstart; // [sp+281Ch] [bp+281Ch] BYREF
  ssize_t len; // [sp+2824h] [bp+2824h]
  unsigned __int8 *tok; // [sp+2828h] [bp+2828h]
  ssize_t buflen; // [sp+282Ch] [bp+282Ch]
  size_t slen; // [sp+2830h] [bp+2830h]
  ssize_t n; // [sp+2834h] [bp+2834h]
  int waited; // [sp+2838h] [bp+2838h]
  unsigned __int8 *sret; // [sp+283Ch] [bp+283Ch]

  sret = 0;
  waited = 0;
  if ( strchr((const char *)pool->sockbuf, 10) )
    goto LABEL_27;
  cgtime(&rstart);
  if ( !socket_full(pool, 60) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42_0, "Timed out waiting for data on socket_full");
      applog(7, tmp42_0, 0);
    }
    goto out;
  }
  while ( 1 )
  {
    memset(tmp42_0, 0, sizeof(tmp42_0));
    n = recv(pool->sock, tmp42_0, 0x1FFCu, 0);
    if ( !n )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Socket closed waiting in recv_line");
        applog(7, tmp42, 0);
      }
      goto LABEL_14;
    }
    cgtime(&now);
    tdiff(&now, &rstart);
    waited = (int)v1;
    if ( n < 0 )
      break;
    slen = strlen(tmp42_0);
    recalloc_sock(pool, slen);
    strcat((char *)pool->sockbuf, tmp42_0);
LABEL_25:
    if ( waited > 59 || strchr((const char *)pool->sockbuf, 10) )
      goto LABEL_27;
  }
  if ( (unsigned __int8)sock_blocks() == 1 && socket_full(pool, 60 - waited) )
    goto LABEL_25;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Failed to recv sock in recv_line");
    applog(7, tmp42, 0);
  }
LABEL_14:
  suspend_stratum(pool);
LABEL_27:
  buflen = strlen((const char *)pool->sockbuf);
  tok = (unsigned __int8 *)strtok((char *)pool->sockbuf, "\n");
  if ( tok )
  {
    sret = (unsigned __int8 *)strdup((const char *)tok);
    len = strlen((const char *)sret);
    if ( buflen <= len + 1 )
      *pool->sockbuf = 0;
    else
      memmove(pool->sockbuf, &pool->sockbuf[len + 1], buflen - len + 1);
    ++pool->cgminer_pool_stats.times_received;
    pool->cgminer_pool_stats.bytes_received += len;
    pool->cgminer_pool_stats.net_bytes_received += len;
  }
  else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42_0, "Failed to parse a \\n terminated string in recv_line");
    applog(7, tmp42_0, 0);
  }
out:
  if ( sret )
  {
    if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42_0, 0x800u, "RECVD: %s", (const char *)sret);
      applog(7, tmp42_0, 0);
    }
  }
  else
  {
    clear_sock(pool);
  }
  return sret;
}
// 3F7E0: variables would overlap: ^814.8192 and stkvar "tmp42_0" ^814.2048(has user info)

//----- (0003FD7E) --------------------------------------------------------
unsigned __int8 *__cdecl _json_array_string(json_t_0 *val, unsigned int entry)
{
  const json_t_0 *arr_entry; // [sp+Ch] [bp+Ch]

  if ( val && val->type == JSON_NULL )
    return 0;
  if ( !val || val->type != JSON_ARRAY )
    return 0;
  if ( entry > json_array_size(val) )
    return 0;
  arr_entry = json_array_get(val, entry);
  if ( arr_entry && arr_entry->type == JSON_STRING )
    return (unsigned __int8 *)json_string_value(arr_entry);
  else
    return 0;
}

//----- (0003FDEA) --------------------------------------------------------
unsigned __int8 *__cdecl json_array_string(json_t_0 *val, unsigned int entry)
{
  unsigned __int8 *buf; // [sp+Ch] [bp+Ch]

  buf = _json_array_string(val, entry);
  if ( buf )
    return (unsigned __int8 *)strdup((const char *)buf);
  else
    return 0;
}

//----- (0003FE18) --------------------------------------------------------
bool __cdecl parse_notify(pool *pool, json_t_0 *val)
{
  bool v2; // r3
  unsigned __int8 **v3; // r4
  unsigned __int8 *v4; // r0
  const char *v5; // r3
  json_t_0 *vala; // [sp+18h] [bp+0h] BYREF
  pool *poola; // [sp+1Ch] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 header[228]; // [sp+820h] [bp+808h] BYREF
  unsigned __int8 *cb; // [sp+904h] [bp+8ECh]
  unsigned __int8 *merkle; // [sp+908h] [bp+8F0h]
  size_t alloc_len; // [sp+90Ch] [bp+8F4h]
  size_t cb2_len; // [sp+910h] [bp+8F8h]
  size_t cb1_len; // [sp+914h] [bp+8FCh]
  bool clean; // [sp+91Bh] [bp+903h]
  unsigned __int8 *ntime; // [sp+91Ch] [bp+904h]
  unsigned __int8 *nbit; // [sp+920h] [bp+908h]
  unsigned __int8 *bbversion; // [sp+924h] [bp+90Ch]
  unsigned __int8 *coinbase2; // [sp+928h] [bp+910h]
  unsigned __int8 *coinbase1; // [sp+92Ch] [bp+914h]
  unsigned __int8 *prev_hash; // [sp+930h] [bp+918h]
  unsigned __int8 *job_id; // [sp+934h] [bp+91Ch]
  int merkles; // [sp+938h] [bp+920h]
  json_t_0 *arr; // [sp+93Ch] [bp+924h]
  unsigned __int8 *cb2; // [sp+940h] [bp+928h]
  unsigned __int8 *cb1; // [sp+944h] [bp+92Ch]
  int i; // [sp+948h] [bp+930h]
  bool ret; // [sp+94Fh] [bp+937h]

  poola = pool;
  vala = val;
  cb1 = 0;
  cb2 = 0;
  ret = 0;
  arr = json_array_get(val, 4u);
  if ( arr && arr->type == JSON_ARRAY )
  {
    merkles = json_array_size(arr);
    job_id = json_array_string(vala, 0);
    prev_hash = _json_array_string(vala, 1u);
    coinbase1 = json_array_string(vala, 2u);
    coinbase2 = json_array_string(vala, 3u);
    bbversion = _json_array_string(vala, 5u);
    nbit = _json_array_string(vala, 6u);
    ntime = _json_array_string(vala, 7u);
    v2 = json_array_get(vala, 8u) && json_array_get(vala, 8u)->type == JSON_TRUE;
    clean = v2;
    if ( !valid_ascii(job_id, "util.c", _func___12023, 2007)
      || !valid_hex(prev_hash, "util.c", _func___12023, 2007)
      || !valid_hex(coinbase1, "util.c", _func___12023, 2007)
      || !valid_hex(coinbase2, "util.c", _func___12023, 2008)
      || !valid_hex(bbversion, "util.c", _func___12023, 2008)
      || !valid_hex(nbit, "util.c", _func___12023, 2008)
      || !valid_hex(ntime, "util.c", _func___12023, 2009) )
    {
      free(job_id);
      free(coinbase1);
      free(coinbase2);
    }
    else
    {
      cg_wlock_0(&poola->data_lock, "util.c", _func___12023, 2018);
      free(poola->swork.job_id);
      poola->swork.job_id = job_id;
      snprintf((char *)poola->prev_hash, 0x41u, "%s", (const char *)prev_hash);
      cb1_len = strlen((const char *)coinbase1) >> 1;
      cb2_len = strlen((const char *)coinbase2) >> 1;
      snprintf((char *)poola->bbversion, 9u, "%s", (const char *)bbversion);
      snprintf((char *)poola->nbit, 9u, "%s", (const char *)nbit);
      snprintf((char *)poola->ntime, 9u, "%s", (const char *)ntime);
      poola->swork.clean = clean;
      if ( poola->next_diff > 0.0 )
        poola->sdiff = poola->next_diff;
      poola->coinbase_len = poola->n1_len + cb1_len + poola->n2size + cb2_len;
      alloc_len = poola->coinbase_len;
      poola->nonce2_offset = cb1_len + poola->n1_len;
      for ( i = 0; i < poola->merkles; ++i )
        free(poola->swork.merkle_bin[i]);
      if ( merkles )
      {
        poola->swork.merkle_bin = (unsigned __int8 **)cgrealloc(
                                                        poola->swork.merkle_bin,
                                                        4 * merkles + 1,
                                                        "util.c",
                                                        _func___12023,
                                                        2040);
        for ( i = 0; i < merkles; ++i )
        {
          merkle = json_array_string(arr, i);
          v3 = &poola->swork.merkle_bin[i];
          *v3 = (unsigned __int8 *)cgmalloc(0x20u, "util.c", _func___12023, 2045);
          if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "merkle %d: %s", i, (const char *)merkle);
            applog(7, tmp42, 0);
          }
          ret = hex2bin(poola->swork.merkle_bin[i], merkle, 0x20u);
          free(merkle);
          if ( !ret )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              strcpy((char *)tmp42, "Failed to convert merkle to merkle_bin in parse_notify");
              applog(3, tmp42, 0);
            }
            goto out_unlock;
          }
        }
      }
      poola->merkles = merkles;
      if ( poola->merkles <= 1 )
        ++poola->bad_work;
      if ( clean )
        poola->nonce2 = 0LL;
      snprintf(
        (char *)header,
        0xE1u,
        "%s%s%s%s%s%s%s",
        (const char *)poola->bbversion,
        (const char *)poola->prev_hash,
        (const char *)blank_merkle,
        (const char *)poola->ntime,
        (const char *)poola->nbit,
        "00000000",
        (const char *)workpadding);
      ret = hex2bin(poola->header_bin, header, 0x70u);
      if ( !ret )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "Failed to convert header to header_bin in parse_notify");
          applog(3, tmp42, 0);
        }
      }
      else
      {
        cb1 = (unsigned __int8 *)&vala;
        ret = hex2bin((unsigned __int8 *)&vala, coinbase1, cb1_len);
        if ( !ret )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            strcpy((char *)tmp42, "Failed to convert cb1 to cb1_bin in parse_notify");
            applog(3, tmp42, 0);
          }
        }
        else
        {
          cb2 = (unsigned __int8 *)&vala;
          ret = hex2bin((unsigned __int8 *)&vala, coinbase2, cb2_len);
          if ( !ret )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              strcpy((char *)tmp42, "Failed to convert cb2 to cb2_bin in parse_notify");
              applog(3, tmp42, 0);
            }
          }
          else
          {
            free(poola->coinbase);
            v4 = (unsigned __int8 *)cgcalloc(alloc_len, 1u, "util.c", _func___12023, 2102);
            poola->coinbase = v4;
            cg_memcpy(poola->coinbase, cb1, cb1_len, "util.c", _func___12023, 2103);
            if ( poola->n1_len )
              cg_memcpy(&poola->coinbase[cb1_len], poola->nonce1bin, poola->n1_len, "util.c", _func___12023, 2105);
            cg_memcpy(
              &poola->coinbase[poola->n2size + poola->n1_len + cb1_len],
              cb2,
              cb2_len,
              "util.c",
              _func___12023,
              2106);
            if ( opt_debug )
            {
              cb = bin2hex(poola->coinbase, poola->coinbase_len);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "Pool %d coinbase %s", poola->pool_no, (const char *)cb);
                applog(7, tmp42, 0);
              }
              free(cb);
            }
          }
        }
      }
out_unlock:
      cg_wunlock_0(&poola->data_lock, "util.c", _func___12023, 2115);
      if ( opt_protocol )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "job_id: %s", (const char *)job_id);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "prev_hash: %s", (const char *)prev_hash);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "coinbase1: %s", (const char *)coinbase1);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "coinbase2: %s", (const char *)coinbase2);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "bbversion: %s", (const char *)bbversion);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "nbit: %s", (const char *)nbit);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "ntime: %s", (const char *)ntime);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          if ( clean )
            v5 = "yes";
          else
            v5 = "no";
          snprintf((char *)tmp42, 0x800u, "clean: %s", v5);
          applog(7, tmp42, 0);
        }
      }
      free(coinbase1);
      free(coinbase2);
      ++poola->getwork_requested;
      ++total_getworks;
      if ( poola == current_pool() )
        opt_work_update = 1;
    }
  }
  return ret;
}
// 3FF0E: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (00040B24) --------------------------------------------------------
uint32_t __cdecl real_mask(uint32_t mask, int need_bit)
{
  int bits; // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  uint32_t real_mask_bit; // [sp+14h] [bp+14h]

  real_mask_bit = 0;
  bits = 0;
  for ( i = 0; i <= 31; ++i )
  {
    if ( ((mask >> i) & 1) != 0 )
    {
      real_mask_bit |= 1 << i;
      if ( ++bits == need_bit )
        break;
    }
  }
  return real_mask_bit;
}

//----- (00040B8C) --------------------------------------------------------
void __cdecl process_version_mask(pool *pool, unsigned __int8 *mask)
{
  int v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile; // [sp+81Ch] [bp+80Ch]

  if ( mask )
  {
    v2 = strtol((const char *)mask, 0, 16);
    pool->ab_mask = swab32_0(v2);
    pool->ab_mask = real_mask(pool->ab_mask & 0xC000, 2);
    if ( (pool->ab_mask & 0xC000) != 0 )
    {
      pool->support_ab = 1;
      pool->version_num = 2;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Pool %d Version num is %d\n",
            "util.c",
            2178,
            (const char *)_FUNCTION___12063,
            pool->pool_no,
            pool->version_num);
        fclose(pFile);
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d rolling mask do not match!", pool->pool_no);
        applog(5, tmp42, 0);
      }
      pool->support_ab = 0;
      pool->version_num = 1;
    }
  }
  else
  {
    pool->support_ab = 0;
    pool->version_num = 1;
  }
}

//----- (00040D12) --------------------------------------------------------
bool __cdecl parse_version_mask(pool *pool, json_t_0 *val)
{
  json_t_0 *v2; // r0
  unsigned __int8 *mask; // [sp+Ch] [bp+Ch]

  v2 = json_array_get(val, 0);
  mask = (unsigned __int8 *)json_string_value(v2);
  process_version_mask(pool, mask);
  return 1;
}

//----- (00040D44) --------------------------------------------------------
bool __cdecl parse_version_rolling_mask(pool *pool, unsigned __int8 *sret)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  json_error_t err; // [sp+810h] [bp+808h] BYREF
  json_t_0 *value; // [sp+90Ch] [bp+904h]
  json_t_0 *err_val; // [sp+910h] [bp+908h]
  json_t_0 *res_val; // [sp+914h] [bp+90Ch]
  json_t_0 *val; // [sp+918h] [bp+910h]
  unsigned __int8 *mask; // [sp+91Ch] [bp+914h]
  const unsigned __int8 *key; // [sp+920h] [bp+918h]
  bool ret; // [sp+927h] [bp+91Fh]

  ret = 0;
  mask = 0;
  val = 0;
  val = json_loads(sret, 0, &err);
  if ( val )
  {
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    if ( res_val && res_val->type != JSON_NULL && (!err_val || err_val->type == JSON_NULL) )
    {
      v2 = json_object_iter(res_val);
      for ( key = json_object_iter_key(v2); key; key = json_object_iter_key(v4) )
      {
        v5 = json_object_key_to_iter(key);
        value = json_object_iter_value(v5);
        if ( !value )
          break;
        if ( !strcasecmp((const char *)key, "version-rolling") && strlen((const char *)key) == 15 )
        {
          if ( !value || value->type != JSON_TRUE )
          {
            pool->support_ab = 0;
            pool->version_num = 1;
            goto out;
          }
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "POOL %d support ab mode!", pool->pool_no);
            applog(5, tmp42, 0);
          }
        }
        else if ( !strcasecmp((const char *)key, "version-rolling.mask") )
        {
          mask = (unsigned __int8 *)json_string_value(value);
          process_version_mask(pool, mask);
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "JSON-RPC unexpected mining.configure value: %s", (const char *)key);
          applog(3, tmp42, 0);
        }
        v3 = json_object_key_to_iter(key);
        v4 = json_object_iter_next(res_val, v3);
      }
      ret = 1;
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
    applog(6, tmp42, 0);
  }
out:
  json_decref(val);
  return ret;
}
// 40E18: conditional instruction was optimized away because %res_val.4!=0
// 40E34: conditional instruction was optimized away because %err_val.4!=0

//----- (00040FE8) --------------------------------------------------------
bool __cdecl parse_version(pool *pool, json_t_0 *val)
{
  size_t j; // r0
  json_t_0 *v4; // r0
  unsigned int i; // [sp+Ch] [bp+Ch]

  i = 0;
  for ( j = json_array_size(val); j > i; j = json_array_size(val) )
  {
    if ( !json_array_get(val, i) || json_array_get(val, i)->type != JSON_INTEGER )
      return 0;
    v4 = json_array_get(val, i);
    pool->version[i++] = json_integer_value(v4);
  }
  return 1;
}

//----- (0004105E) --------------------------------------------------------
bool __cdecl parse_diff(pool *pool, json_t_0 *val)
{
  double v2; // d0
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int idiff; // [sp+814h] [bp+80Ch]
  double diff; // [sp+818h] [bp+810h]
  double old_diff; // [sp+820h] [bp+818h]

  v3 = json_array_get(val, 0);
  json_number_value(v3);
  diff = v2;
  if ( v2 == 0.0 )
    return 0;
  cg_wlock_0(&pool->data_lock, "util.c", _func___12102, 2262);
  if ( pool->next_diff <= 0.0 )
  {
    old_diff = pool->sdiff;
    pool->sdiff = diff;
    pool->next_diff = pool->sdiff;
  }
  else
  {
    old_diff = pool->next_diff;
    pool->next_diff = diff;
  }
  cg_wunlock_0(&pool->data_lock, "util.c", _func___12102, 2275);
  if ( old_diff == diff )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d difficulty set to %f", pool->pool_no, diff);
      applog(7, tmp42, 0);
    }
  }
  else
  {
    idiff = (int)diff;
    if ( diff == (double)(int)diff )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %d", pool->pool_no, idiff);
        applog(5, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %.1f", pool->pool_no, diff);
      applog(5, tmp42, 0);
    }
  }
  return 1;
}
// 41084: variable 'v2' is possibly undefined

//----- (000412E4) --------------------------------------------------------
bool __cdecl parse_extranonce(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  int n2size; // [sp+810h] [bp+808h]
  unsigned __int8 *nonce1; // [sp+814h] [bp+80Ch]

  nonce1 = json_array_string(val, 0);
  if ( !valid_hex(nonce1, "util.c", _func___12113, 2305) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Failed to get valid nonce1 in parse_extranonce");
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    v3 = json_array_get(val, 1u);
    n2size = json_integer_value(v3);
    if ( n2size )
    {
      cg_wlock_0(&pool->data_lock, "util.c", _func___12113, 2318);
      free(pool->nonce1);
      pool->nonce1 = nonce1;
      pool->n1_len = strlen((const char *)nonce1) >> 1;
      free(pool->nonce1bin);
      pool->nonce1bin = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", _func___12113, 2323);
      if ( !pool->nonce1bin )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to calloc pool->nonce1bin in %s %s():%d",
          "util.c",
          (const char *)_func___12113,
          2325);
        applog(3, tmp42, 1);
        quit(1);
      }
      hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
      pool->n2size = n2size;
      cg_wunlock_0(&pool->data_lock, "util.c", _func___12113, 2328);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d extranonce change requested", pool->pool_no);
        applog(5, tmp42, 0);
      }
      opt_work_update = 1;
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        strcpy((char *)tmp42, "Failed to get valid n2size in parse_extranonce");
        applog(6, tmp42, 0);
      }
      free(nonce1);
      return 0;
    }
  }
}

//----- (000415A4) --------------------------------------------------------
void __cdecl _suspend_stratum(pool *pool)
{
  clear_sockbuf(pool);
  pool->stratum_notify = 0;
  pool->stratum_active = pool->stratum_notify;
  if ( pool->sock )
    close(pool->sock);
  pool->sock = 0;
}

//----- (000415EC) --------------------------------------------------------
bool __cdecl parse_reconnect(pool *pool, json_t_0 *val)
{
  json_t_0 *v2; // r0
  json_t_0 *v4; // r0
  json_t_0 *v5; // r0
  char v7[264]; // [sp+8h] [bp-108h] BYREF
  json_t_0 *vala; // [sp+110h] [bp+0h]
  pool *poola; // [sp+114h] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+118h] [bp+8h] BYREF
  unsigned __int8 address[256]; // [sp+918h] [bp+808h] BYREF
  unsigned __int8 *stratum_port; // [sp+A18h] [bp+908h] BYREF
  unsigned __int8 *sockaddr_url; // [sp+A1Ch] [bp+90Ch] BYREF
  unsigned __int8 *tmp; // [sp+A20h] [bp+910h]
  int port_no; // [sp+A24h] [bp+914h]
  unsigned __int8 *dot_reconnect; // [sp+A28h] [bp+918h]
  unsigned __int8 *dot_pool; // [sp+A2Ch] [bp+91Ch]
  unsigned __int8 *port; // [sp+A30h] [bp+920h]
  unsigned __int8 *url; // [sp+A34h] [bp+924h]

  poola = pool;
  vala = val;
  memset(address, 0, 0xFFu);
  v2 = json_array_get(vala, 0);
  url = (unsigned __int8 *)json_string_value(v2);
  if ( !url )
  {
    url = poola->sockaddr_url;
LABEL_21:
    v4 = json_array_get(vala, 1u);
    port_no = json_integer_value(v4);
    if ( port_no )
    {
      port = (unsigned __int8 *)v7;
      sprintf(v7, "%d", port_no);
    }
    else
    {
      v5 = json_array_get(vala, 1u);
      port = (unsigned __int8 *)json_string_value(v5);
      if ( !port )
        port = poola->stratum_port;
    }
    snprintf((char *)address, 0xFEu, "%s:%s", (const char *)url, (const char *)port);
    if ( !extract_sockaddr(address, &sockaddr_url, &stratum_port) )
      return 0;
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Stratum reconnect requested from pool %d to %s",
        poola->pool_no,
        (const char *)address);
      applog(4, tmp42, 0);
    }
    clear_pool_work(poola);
    mutex_lock_0(&poola->stratum_lock, "util.c", _func___12138, 2402);
    _suspend_stratum(poola);
    tmp = poola->sockaddr_url;
    poola->sockaddr_url = sockaddr_url;
    poola->stratum_url = poola->sockaddr_url;
    free(tmp);
    tmp = poola->stratum_port;
    poola->stratum_port = stratum_port;
    free(tmp);
    mutex_unlock_0(&poola->stratum_lock, "util.c", _func___12138, 2411);
    return restart_stratum(poola);
  }
  dot_pool = (unsigned __int8 *)strchr((const char *)poola->sockaddr_url, 46);
  if ( dot_pool )
  {
    dot_reconnect = (unsigned __int8 *)strchr((const char *)url, 46);
    if ( dot_reconnect )
    {
      if ( !strcmp((const char *)dot_pool, (const char *)dot_reconnect) )
        goto LABEL_21;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Denied stratum reconnect request to non-matching domain url '%s'",
          (const char *)poola->sockaddr_url);
        applog(3, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Denied stratum reconnect request to url without domain '%s'",
          (const char *)url);
        applog(3, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Denied stratum reconnect request for pool without domain '%s'",
        (const char *)poola->sockaddr_url);
      applog(3, tmp42, 0);
    }
    return 0;
  }
}

//----- (0004193A) --------------------------------------------------------
bool __cdecl send_version(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  size_t v4; // r0
  unsigned __int8 s[8192]; // [sp+8h] [bp+8h] BYREF
  int id; // [sp+2008h] [bp+2008h]

  if ( !json_object_get(val, "id") )
    return 0;
  v3 = json_object_get(val, "id");
  id = json_integer_value(v3);
  sprintf((char *)s, "{\"id\": %d, \"result\": \"cgminer/2.0.0\", \"error\": null}", id);
  v4 = strlen((const char *)s);
  return stratum_send(pool, s, v4);
}

//----- (00041A0C) --------------------------------------------------------
bool __cdecl send_pong(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  size_t v4; // r0
  unsigned __int8 s[8192]; // [sp+8h] [bp+8h] BYREF
  int id; // [sp+2008h] [bp+2008h]

  if ( !json_object_get(val, "id") )
    return 0;
  v3 = json_object_get(val, "id");
  id = json_integer_value(v3);
  sprintf((char *)s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", id);
  v4 = strlen((const char *)s);
  return stratum_send(pool, s, v4);
}

//----- (00041ADE) --------------------------------------------------------
bool __cdecl show_message(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 *msg; // [sp+814h] [bp+80Ch]

  if ( !val || val->type != JSON_ARRAY )
    return 0;
  v3 = json_array_get(val, 0);
  msg = (unsigned __int8 *)json_string_value(v3);
  if ( !msg )
    return 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d message: %s", pool->pool_no, (const char *)msg);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (00041B8C) --------------------------------------------------------
bool __cdecl parse_method(pool *pool, unsigned __int8 *s)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  json_error_t err; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 *buf; // [sp+90Ch] [bp+904h]
  json_t_0 *params; // [sp+910h] [bp+908h]
  json_t_0 *err_val; // [sp+914h] [bp+90Ch]
  json_t_0 *method; // [sp+918h] [bp+910h]
  json_t_0 *val; // [sp+91Ch] [bp+914h]
  unsigned __int8 *ss; // [sp+920h] [bp+918h]
  bool ret; // [sp+927h] [bp+91Fh]

  val = 0;
  ret = 0;
  if ( s )
  {
    val = json_loads(s, 0, &err);
    if ( val )
    {
      method = json_object_get(val, "method");
      if ( method )
      {
        err_val = json_object_get(val, "error");
        params = json_object_get(val, "params");
        if ( !err_val || err_val->type == JSON_NULL )
        {
          buf = (unsigned __int8 *)json_string_value(method);
          if ( buf )
          {
            if ( !strncasecmp((const char *)buf, "mining.multi_version", 0x14u) )
            {
              pool->support_ab = 1;
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                strcpy((char *)tmp42, "Pool support multi version");
                applog(6, tmp42, 0);
              }
              ret = parse_version(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.notify", 0xDu) )
            {
              if ( parse_notify(pool, params) )
              {
                ret = 1;
                pool->stratum_notify = 1;
              }
              else
              {
                ret = 0;
                pool->stratum_notify = 0;
              }
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_version_mask", 0x17u) )
            {
              if ( parse_version_mask(pool, params) )
              {
                ret = 1;
                pool->stratum_notify = 1;
              }
              else
              {
                ret = 0;
                pool->stratum_notify = 0;
              }
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_difficulty", 0x15u) )
            {
              ret = parse_diff(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_extranonce", 0x15u) )
            {
              ret = parse_extranonce(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "client.reconnect", 0x10u) )
            {
              ret = parse_reconnect(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "client.get_version", 0x12u) )
            {
              ret = send_version(pool, val);
            }
            else if ( !strncasecmp((const char *)buf, "client.show_message", 0x13u) )
            {
              ret = show_message(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.ping", 0xBu) )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                snprintf((char *)tmp42, 0x800u, "Pool %d ping", pool->pool_no);
                applog(6, tmp42, 0);
              }
              ret = send_pong(pool, val);
            }
          }
        }
        else
        {
          ss = json_dumps(err_val, 3u);
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "JSON-RPC method decode failed: %s", (const char *)ss);
            applog(6, tmp42, 0);
          }
          free(ss);
        }
      }
      json_decref(val);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
      applog(6, tmp42, 0);
    }
  }
  return ret;
}
// 41C80: conditional instruction was optimized away because %err_val.4!=0
// 41C92: conditional instruction was optimized away because %err_val.4!=0

//----- (00041FDC) --------------------------------------------------------
bool __cdecl subscribe_extranonce(pool *pool)
{
  int v1; // r2
  size_t v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  json_error_t err; // [sp+814h] [bp+80Ch] BYREF
  unsigned __int8 s[8192]; // [sp+910h] [bp+908h] BYREF
  json_t_0 *err_val; // [sp+2910h] [bp+2908h]
  json_t_0 *res_val; // [sp+2914h] [bp+290Ch]
  unsigned __int8 *sret; // [sp+2918h] [bp+2910h]
  unsigned __int8 *ss; // [sp+291Ch] [bp+2914h]
  bool ret; // [sp+2923h] [bp+291Bh]
  json_t_0 *val; // [sp+2924h] [bp+291Ch]

  val = 0;
  sret = 0;
  ret = 0;
  v1 = swork_id++;
  sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v1);
  v2 = strlen((const char *)s);
  if ( stratum_send(pool, s, v2) )
  {
    while ( 1 )
    {
      if ( !socket_full(pool, 2) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Timed out waiting for response extranonce.subscribe");
          applog(7, tmp42, 0);
        }
        ret = 1;
        goto out;
      }
      sret = recv_line(pool);
      if ( !sret )
        return ret;
      if ( !parse_method(pool, sret) )
        break;
      free(sret);
    }
    val = json_loads(sret, 0, &err);
    free(sret);
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    if ( res_val && res_val->type != JSON_FALSE && (!err_val || err_val->type == JSON_NULL) )
    {
      ret = 1;
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum extranonce subscribe for pool %d", pool->pool_no);
        applog(6, tmp42, 0);
      }
      goto out;
    }
    if ( err_val )
    {
      ss = _json_array_string(err_val, 1u);
      if ( !ss )
        ss = (unsigned __int8 *)json_string_value(err_val);
      if ( ss && !strcmp((const char *)ss, "Method 'subscribe' not found for service 'mining.extranonce'") )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        ret = 1;
out:
        json_decref(val);
        return ret;
      }
      if ( ss && !strcmp((const char *)ss, "Unrecognized request provided") )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        ret = 1;
        goto out;
      }
      ss = json_dumps(err_val, 3u);
    }
    else
    {
      ss = (unsigned __int8 *)strdup("(unknown reason)");
    }
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d JSON extranonce subscribe failed: %s", pool->pool_no, (const char *)ss);
      applog(6, tmp42, 0);
    }
    free(ss);
    goto out;
  }
  return ret;
}
// 421F0: conditional instruction was optimized away because %res_val.4!=0
// 4221E: conditional instruction was optimized away because %err_val.4!=0

//----- (000424E0) --------------------------------------------------------
bool __cdecl auth_stratum(pool *pool)
{
  int v1; // r2
  size_t v2; // r0
  int v4; // r2
  size_t v5; // r0
  int v6; // r4
  uint32_t v7; // r0
  size_t v8; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  json_error_t err; // [sp+814h] [bp+80Ch] BYREF
  unsigned __int8 s[8192]; // [sp+910h] [bp+908h] BYREF
  json_t_0 *err_val; // [sp+2910h] [bp+2908h]
  json_t_0 *res_val; // [sp+2914h] [bp+290Ch]
  unsigned __int8 *sret; // [sp+2918h] [bp+2910h]
  json_t_0 *val; // [sp+291Ch] [bp+2914h]
  unsigned __int8 *ss; // [sp+2920h] [bp+2918h]
  bool ret; // [sp+2927h] [bp+291Fh]

  val = 0;
  sret = 0;
  ret = 0;
  v1 = swork_id++;
  sprintf(
    (char *)s,
    "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}",
    v1,
    (const char *)pool->rpc_user,
    (const char *)pool->rpc_pass);
  v2 = strlen((const char *)s);
  if ( !stratum_send(pool, s, v2) )
    return ret;
  while ( 1 )
  {
    sret = recv_line(pool);
    if ( !sret )
      return ret;
    if ( !parse_method(pool, sret) )
      break;
    free(sret);
  }
  val = json_loads(sret, 0, &err);
  free(sret);
  res_val = json_object_get(val, "result");
  err_val = json_object_get(val, "error");
  if ( res_val && res_val->type != JSON_FALSE && (!err_val || err_val->type == JSON_NULL) )
  {
    ret = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Stratum authorisation success for pool %d", pool->pool_no);
      applog(6, tmp42, 0);
    }
    pool->probed = 1;
    successful_connect = 1;
    if ( opt_suggest_diff )
    {
      v4 = swork_id++;
      sprintf(
        (char *)s,
        "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}",
        v4,
        opt_suggest_diff);
      v5 = strlen((const char *)s);
      stratum_send(pool, s, v5);
    }
    if ( opt_bitmain_ab )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "LOW POWER MODE!");
        applog(5, tmp42, 0);
      }
      v6 = swork_id++;
      v7 = swab32_0(0xC000u);
      sprintf(
        (char *)s,
        "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%08x\""
        ",\"version-rolling.min-bit-count\":%d}]}",
        v6,
        v7,
        2);
      v8 = strlen((const char *)s);
      stratum_send(pool, s, v8);
      pool->version_num = 1;
    }
  }
  else
  {
    if ( err_val )
      ss = json_dumps(err_val, 3u);
    else
      ss = (unsigned __int8 *)strdup("(unknown reason)");
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "pool %d JSON stratum auth failed: %s", pool->pool_no, (const char *)ss);
      applog(6, tmp42, 0);
    }
    free(ss);
    suspend_stratum(pool);
  }
  json_decref(val);
  return ret;
}
// 4267C: conditional instruction was optimized away because %res_val.4!=0
// 426A8: conditional instruction was optimized away because %err_val.4!=0

//----- (00042954) --------------------------------------------------------
int __cdecl recv_byte(int sockd)
{
  unsigned __int8 c; // [sp+Fh] [bp+Fh] BYREF

  if ( recv(sockd, &c, 1u, 0) == -1 )
    return -1;
  else
    return c;
}

//----- (00042982) --------------------------------------------------------
bool __cdecl http_negotiate(pool *pool, int sockd, bool http0)
{
  size_t v3; // r0
  unsigned __int8 v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 buf[1024]; // [sp+820h] [bp+810h] BYREF
  int len; // [sp+C20h] [bp+C10h]
  int i; // [sp+C24h] [bp+C14h]

  if ( http0 )
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.0\r\n\r\n",
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port);
  else
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n",
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port,
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Sending proxy %s:%s - %s",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port,
      (const char *)buf);
    applog(7, tmp42, 0);
  }
  v3 = strlen((const char *)buf);
  send(sockd, buf, v3, 0);
  len = recv(sockd, buf, 0xCu, 0);
  if ( len > 0 )
  {
    buf[len] = 0;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Received from proxy %s:%s - %s",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port,
        (const char *)buf);
      applog(7, tmp42, 0);
    }
    if ( !strcmp((const char *)buf, "HTTP/1.1 200") || !strcmp((const char *)buf, "HTTP/1.0 200") )
    {
      for ( i = 0; i <= 3; ++i )
      {
        v5 = recv_byte(sockd);
        buf[i] = v5;
        if ( buf[i] == 255 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Couldn't read HTTP byte from proxy %s:%s",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(4, tmp42, 0);
          }
          return 0;
        }
      }
      do
      {
        if ( !strncmp((const char *)buf, "\r\n\r\n", 4u) )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Success negotiating with %s:%s HTTP proxy",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(7, tmp42, 0);
          }
          return 1;
        }
        for ( i = 0; i <= 2; ++i )
          buf[i] = buf[i + 1];
        buf[3] = recv_byte(sockd);
      }
      while ( buf[3] != 255 );
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Couldn't read HTTP byte from proxy %s:%s",
          (const char *)pool->sockaddr_proxy_url,
          (const char *)pool->sockaddr_proxy_port);
        applog(4, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "HTTP Error from proxy %s:%s - %s",
          (const char *)pool->sockaddr_proxy_url,
          (const char *)pool->sockaddr_proxy_port,
          (const char *)buf);
        applog(4, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Couldn't read from proxy %s:%s after sending CONNECT",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
}

//----- (00042E54) --------------------------------------------------------
bool __cdecl socks5_negotiate(pool *pool, int sockd)
{
  int v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf[515]; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 atyp; // [sp+A13h] [bp+A0Bh]
  unsigned __int16 port; // [sp+A14h] [bp+A0Ch]
  unsigned __int8 uclen; // [sp+A17h] [bp+A0Fh]
  int len; // [sp+A18h] [bp+A10h]
  int i; // [sp+A1Ch] [bp+A14h]

  buf[0] = 5;
  buf[1] = 1;
  buf[2] = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Attempting to negotiate with %s:%s SOCKS5 proxy",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port);
    applog(7, tmp42, 0);
  }
  send(sockd, buf, 3u, 0);
  if ( recv_byte(sockd) != 5 || (v2 = recv_byte(sockd), v2 != buf[2]) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS5 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  buf[0] = 5;
  buf[1] = 1;
  buf[2] = 0;
  buf[3] = 3;
  len = strlen((const char *)pool->sockaddr_url);
  if ( len > 255 )
    len = 255;
  uclen = len;
  buf[4] = len;
  cg_memcpy(&buf[5], pool->sockaddr_url, len, "util.c", _func___12253, 2822);
  port = atoi((const char *)pool->stratum_port);
  buf[len + 5] = HIBYTE(port);
  buf[len + 6] = port;
  send(sockd, buf, len + 7, 0);
  if ( recv_byte(sockd) != 5 || recv_byte(sockd) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS5 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  recv_byte(sockd);
  atyp = recv_byte(sockd);
  if ( atyp == 1 )
  {
    for ( i = 0; i <= 3; ++i )
      recv_byte(sockd);
LABEL_37:
    for ( i = 0; i <= 1; ++i )
      recv_byte(sockd);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Success negotiating with %s:%s SOCKS5 proxy",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(7, tmp42, 0);
    }
    return 1;
  }
  if ( atyp == 3 )
  {
    len = recv_byte(sockd);
    for ( i = 0; i < len; ++i )
      recv_byte(sockd);
    goto LABEL_37;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Bad response from %s:%s SOCKS5 server",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port);
    applog(4, tmp42, 0);
  }
  return 0;
}

//----- (00043252) --------------------------------------------------------
bool __cdecl socks4_negotiate(pool *pool, int sockd, bool socks4a)
{
  uint32_t v3; // r0
  int v5; // r3
  addrinfo servinfobase; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+3Ch] [bp+34h] BYREF
  addrinfo *servinfo; // [sp+83Ch] [bp+834h] BYREF
  unsigned __int8 buf[515]; // [sp+840h] [bp+838h] BYREF
  sockaddr_in *saddr_in; // [sp+A44h] [bp+A3Ch]
  unsigned __int16 port; // [sp+A4Ah] [bp+A42h]
  int len; // [sp+A4Ch] [bp+A44h]
  int i; // [sp+A50h] [bp+A48h]
  in_addr_t inp; // [sp+A54h] [bp+A4Ch]

  buf[0] = 4;
  buf[1] = 1;
  port = atoi((const char *)pool->stratum_port);
  buf[2] = HIBYTE(port);
  buf[3] = port;
  strcpy((char *)&buf[8], "CGMINER");
  v3 = inet_addr((const char *)pool->sockaddr_url);
  inp = ntohl(v3);
  if ( inp == -1 )
  {
    servinfo = &servinfobase;
    memset(tmp42, 0, 0x20u);
    *(_DWORD *)&tmp42[4] = 2;
    if ( !getaddrinfo((const char *)pool->sockaddr_url, 0, (const struct addrinfo *)tmp42, &servinfo) )
    {
      saddr_in = (sockaddr_in *)servinfo->ai_addr;
      inp = ntohl(saddr_in->sin_addr.s_addr);
      socks4a = 0;
      freeaddrinfo(servinfo);
    }
  }
  else
  {
    socks4a = 0;
  }
  if ( !socks4a )
  {
    if ( inp == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Invalid IP address specified for socks4 proxy: %s",
          (const char *)pool->sockaddr_url);
        applog(4, tmp42, 0);
      }
      return 0;
    }
    buf[4] = HIBYTE(inp);
    buf[5] = BYTE2(inp);
    buf[6] = BYTE1(inp);
    buf[7] = inp;
    send(sockd, buf, 0x10u, 0);
  }
  else
  {
    buf[4] = 0;
    buf[5] = 0;
    buf[6] = 0;
    buf[7] = 1;
    len = strlen((const char *)pool->sockaddr_url);
    if ( len > 255 )
      len = 255;
    cg_memcpy(&buf[16], pool->sockaddr_url, len, "util.c", _func___12281, 2924);
    len += 16;
    v5 = len++;
    buf[v5] = 0;
    send(sockd, buf, len, 0);
  }
  if ( !recv_byte(sockd) && recv_byte(sockd) == 90 )
  {
    for ( i = 0; i <= 5; ++i )
      recv_byte(sockd);
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS4 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
}

//----- (0004357C) --------------------------------------------------------
void __cdecl noblock_socket(int fd)
{
  int flags; // [sp+Ch] [bp+Ch]

  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags | 0x800);
}

//----- (000435A8) --------------------------------------------------------
void __cdecl block_socket(int fd)
{
  int flags; // [sp+Ch] [bp+Ch]

  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags & 0xFFFFF7FF);
}

//----- (000435D4) --------------------------------------------------------
bool sock_connecting()
{
  return *_errno_location() == 115;
}

//----- (000435F0) --------------------------------------------------------
bool __cdecl setup_stratum_socket(pool *pool)
{
  bool v1; // r3
  int v2; // r3
  int v3; // r3
  fd_set rw; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+94h] [bp+8Ch] BYREF
  int err; // [sp+894h] [bp+88Ch] BYREF
  socklen_t len; // [sp+898h] [bp+890h] BYREF
  timeval tv_timeout; // [sp+89Ch] [bp+894h] BYREF
  addrinfo hints; // [sp+8A4h] [bp+89Ch] BYREF
  addrinfo *servinfo; // [sp+8C4h] [bp+8BCh] BYREF
  int n; // [sp+8C8h] [bp+8C0h]
  int selret; // [sp+8CCh] [bp+8C4h]
  fd_set *__arr; // [sp+8D0h] [bp+8C8h]
  unsigned int __i; // [sp+8D4h] [bp+8CCh]
  int sockd; // [sp+8D8h] [bp+8D0h]
  unsigned __int8 *sockaddr_port; // [sp+8DCh] [bp+8D4h]
  unsigned __int8 *sockaddr_url; // [sp+8E0h] [bp+8D8h]
  addrinfo *p; // [sp+8E4h] [bp+8DCh]

  mutex_lock_0(&pool->stratum_lock, "util.c", _func___12306, 2971);
  pool->stratum_active = 0;
  if ( pool->sock )
    close(pool->sock);
  pool->sock = 0;
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___12306, 2976);
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  if ( !pool->rpc_proxy && opt_socks_proxy )
  {
    pool->rpc_proxy = opt_socks_proxy;
    extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
    pool->rpc_proxytype = 3;
  }
  if ( pool->rpc_proxy )
  {
    sockaddr_url = pool->sockaddr_proxy_url;
    sockaddr_port = pool->sockaddr_proxy_port;
  }
  else
  {
    sockaddr_url = pool->sockaddr_url;
    sockaddr_port = pool->stratum_port;
  }
  if ( getaddrinfo((const char *)sockaddr_url, (const char *)sockaddr_port, &hints, &servinfo) )
  {
    if ( !pool->probed )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to resolve (?wrong URL) %s:%s",
          (const char *)sockaddr_url,
          (const char *)sockaddr_port);
        applog(4, tmp42, 0);
      }
      pool->probed = 1;
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to getaddrinfo for %s:%s",
        (const char *)sockaddr_url,
        (const char *)sockaddr_port);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    for ( p = servinfo; p; p = p->ai_next )
    {
      sockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
      if ( sockd == -1 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Failed socket");
          applog(7, tmp42, 0);
        }
      }
      else
      {
        noblock_socket(sockd);
        if ( connect(sockd, p->ai_addr, p->ai_addrlen) != -1 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy((char *)tmp42, "Succeeded immediate connect");
            applog(4, tmp42, 0);
          }
LABEL_63:
          block_socket(sockd);
          break;
        }
        tv_timeout.tv_sec = 1;
        tv_timeout.tv_usec = 0;
        if ( !sock_connecting() )
        {
          close(sockd);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Failed sock connect");
            applog(7, tmp42, 0);
          }
        }
        else
        {
          do
          {
            __arr = &rw;
            for ( __i = 0; __i <= 0x1F; ++__i )
              __arr->fds_bits[__i] = 0;
            LOBYTE(v2) = sockd & 0x1F;
            if ( sockd <= 0 )
              v2 = -(-sockd & 0x1F);
            rw.fds_bits[sockd / 32] |= 1 << v2;
            selret = select(sockd + 1, 0, &rw, 0, &tv_timeout);
            if ( selret > 0 )
            {
              LOBYTE(v3) = sockd & 0x1F;
              if ( sockd <= 0 )
                v3 = -(-sockd & 0x1F);
              if ( ((1 << v3) & rw.fds_bits[sockd / 32]) != 0 )
              {
                len = 4;
                n = getsockopt(sockd, 1, 4, &err, &len);
                if ( !n && !err )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    strcpy((char *)tmp42, "Succeeded delayed connect");
                    applog(7, tmp42, 0);
                  }
                  goto LABEL_63;
                }
              }
            }
          }
          while ( selret < 0 && interrupted() );
          close(sockd);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Select timeout/failed connect");
            applog(7, tmp42, 0);
          }
        }
      }
    }
    if ( p )
    {
      freeaddrinfo(servinfo);
      if ( pool->rpc_proxy )
      {
        switch ( pool->rpc_proxytype )
        {
          case 0:
            if ( http_negotiate(pool, sockd, 0) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 1:
            if ( http_negotiate(pool, sockd, 1) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 2:
            if ( socks4_negotiate(pool, sockd, 0) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 3:
          case 5:
            if ( socks5_negotiate(pool, sockd) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 4:
            if ( socks4_negotiate(pool, sockd, 1) )
              goto LABEL_89;
            v1 = 0;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Unsupported proxy type for %s:%s",
                (const char *)pool->sockaddr_proxy_url,
                (const char *)pool->sockaddr_proxy_port);
              applog(4, tmp42, 0);
            }
            v1 = 0;
            break;
        }
      }
      else
      {
LABEL_89:
        if ( !pool->sockbuf )
        {
          pool->sockbuf = (unsigned __int8 *)cgcalloc(0x2000, 1u, "util.c", _func___12306, 3113);
          pool->sockbuf_size = 0x2000;
        }
        pool->sock = sockd;
        keep_sockalive(sockd);
        return 1;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to connect to stratum on %s:%s",
          (const char *)sockaddr_url,
          (const char *)sockaddr_port);
        applog(6, tmp42, 0);
      }
      freeaddrinfo(servinfo);
      return 0;
    }
  }
  return v1;
}

//----- (00043DC8) --------------------------------------------------------
unsigned __int8 *__cdecl get_sessionid(json_t_0 *val)
{
  bool v1; // r3
  unsigned __int8 *notify; // [sp+8h] [bp+8h]
  json_t_0 *arr; // [sp+Ch] [bp+Ch]
  int arrsize; // [sp+10h] [bp+10h]
  const json_t_0 *arr_val; // [sp+14h] [bp+14h]
  int i; // [sp+18h] [bp+18h]
  unsigned __int8 *ret; // [sp+1Ch] [bp+1Ch]

  ret = 0;
  arr_val = json_array_get(val, 0);
  if ( arr_val && arr_val->type == JSON_ARRAY )
  {
    arrsize = json_array_size(arr_val);
    for ( i = 0; i < arrsize; ++i )
    {
      arr = json_array_get(arr_val, i);
      v1 = !arr || arr->type != JSON_ARRAY;
      if ( v1 || arr == 0 )
        break;
      notify = _json_array_string(arr, 0);
      if ( notify && !strncasecmp((const char *)notify, "mining.notify", 0xDu) )
        return json_array_string(arr, 1u);
    }
  }
  return ret;
}

//----- (00043E8E) --------------------------------------------------------
void __cdecl suspend_stratum(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Closing socket for stratum pool %d", pool->pool_no);
    applog(6, tmp42, 0);
  }
  mutex_lock_0(&pool->stratum_lock, "util.c", _func___12358, 3156);
  _suspend_stratum(pool);
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___12358, 3158);
}

//----- (00043F3E) --------------------------------------------------------
bool __cdecl initiate_stratum(pool *pool)
{
  int v1; // r2
  int v2; // r2
  size_t v3; // r0
  json_t_0 *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  json_error_t err; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 s[8192]; // [sp+90Ch] [bp+904h] BYREF
  int n2size; // [sp+290Ch] [bp+2904h]
  unsigned __int8 *nonce1; // [sp+2910h] [bp+2908h]
  unsigned __int8 *sessionid; // [sp+2914h] [bp+290Ch]
  json_t_0 *err_val; // [sp+2918h] [bp+2910h]
  json_t_0 *res_val; // [sp+291Ch] [bp+2914h]
  unsigned __int8 *sret; // [sp+2920h] [bp+2918h]
  unsigned __int8 *ss; // [sp+2924h] [bp+291Ch]
  json_t_0 *val; // [sp+2928h] [bp+2920h]
  bool sockd; // [sp+292Ch] [bp+2924h]
  bool noresume; // [sp+292Dh] [bp+2925h]
  bool recvd; // [sp+292Eh] [bp+2926h]
  bool ret; // [sp+292Fh] [bp+2927h]

  ret = 0;
  recvd = 0;
  noresume = 0;
  sockd = 0;
  sret = 0;
  for ( val = 0; ; json_decref(val) )
  {
    cgsleep_us(100LL);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "initiate_stratum");
      applog(5, tmp42, 0);
    }
    if ( !setup_stratum_socket(pool) )
    {
      sockd = 0;
    }
    else
    {
      sockd = 1;
      if ( recvd )
      {
        clear_sock(pool);
        v1 = swork_id++;
        sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v1);
      }
      else
      {
        v2 = swork_id;
        if ( pool->sessionid )
        {
          ++swork_id;
          sprintf(
            (char *)s,
            "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/2.0.0\", \"%s\"]}",
            v2,
            (const char *)pool->sessionid);
        }
        else
        {
          ++swork_id;
          sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/2.0.0\"]}", v2);
        }
      }
      v3 = strlen((const char *)s);
      if ( _stratum_send(pool, s, v3) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Failed to send s in initiate_stratum");
          applog(7, tmp42, 0);
        }
      }
      else if ( !socket_full(pool, 60) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Timed out waiting for response in initiate_stratum");
          applog(7, tmp42, 0);
        }
      }
      else
      {
        sret = recv_line(pool);
        if ( sret )
        {
          recvd = 1;
          val = json_loads(sret, 0, &err);
          free(sret);
          if ( val )
          {
            res_val = json_object_get(val, "result");
            err_val = json_object_get(val, "error");
            if ( res_val && res_val->type != JSON_NULL && (!err_val || err_val->type == JSON_NULL) )
            {
              sessionid = get_sessionid(res_val);
              if ( !sessionid && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "Failed to get sessionid in initiate_stratum");
                applog(7, tmp42, 0);
              }
              nonce1 = json_array_string(res_val, 1u);
              if ( !valid_hex(nonce1, "util.c", _func___12407, 3326) )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 5 )
                {
                  strcpy((char *)tmp42, "Failed to get valid nonce1 in initiate_stratum");
                  applog(6, tmp42, 0);
                }
                free(sessionid);
              }
              else
              {
                v4 = json_array_get(res_val, 2u);
                n2size = json_integer_value(v4);
                if ( n2size > 1 && n2size <= 16 )
                {
                  if ( sessionid
                    && pool->sessionid
                    && !strcmp((const char *)sessionid, (const char *)pool->sessionid)
                    && (use_syslog || opt_log_output || opt_log_level > 4) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "Pool %d successfully negotiated resume with the same session ID",
                      pool->pool_no);
                    applog(5, tmp42, 0);
                  }
                  cg_wlock_0(&pool->data_lock, "util.c", _func___12407, 3347);
                  pool->sessionid = sessionid;
                  pool->nonce1 = nonce1;
                  pool->n1_len = strlen((const char *)nonce1) >> 1;
                  free(pool->nonce1bin);
                  pool->nonce1bin = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", _func___12407, 3354);
                  hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
                  pool->n2size = n2size;
                  cg_wunlock_0(&pool->data_lock, "util.c", _func___12407, 3357);
                  if ( sessionid && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "Pool %d stratum session id: %s",
                      pool->pool_no,
                      (const char *)pool->sessionid);
                    applog(7, tmp42, 0);
                  }
                  ret = 1;
                }
                else
                {
                  if ( use_syslog || opt_log_output || opt_log_level > 5 )
                  {
                    strcpy((char *)tmp42, "Failed to get valid n2size in initiate_stratum");
                    applog(6, tmp42, 0);
                  }
                  free(sessionid);
                  free(nonce1);
                }
              }
            }
            else
            {
              if ( err_val )
                ss = json_dumps(err_val, 3u);
              else
                ss = (unsigned __int8 *)strdup("(unknown reason)");
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                snprintf((char *)tmp42, 0x800u, "JSON-RPC decode failed: %s", (const char *)ss);
                applog(6, tmp42, 0);
              }
              free(ss);
            }
          }
          else if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
            applog(6, tmp42, 0);
          }
        }
      }
    }
    if ( ret )
    {
      if ( !pool->stratum_url )
        pool->stratum_url = pool->sockaddr_url;
      pool->stratum_active = 1;
      LODWORD(pool->next_diff) = 0;
      HIDWORD(pool->next_diff) = 0;
      LODWORD(pool->sdiff) = 0;
      HIDWORD(pool->sdiff) = 1072693248;
      if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
          pool->pool_no,
          (const char *)pool->nonce1,
          pool->n2size);
        applog(7, tmp42, 0);
      }
      goto LABEL_100;
    }
    if ( !recvd || noresume )
      break;
    cg_wlock_0(&pool->data_lock, "util.c", _func___12407, 3385);
    free(pool->sessionid);
    free(pool->nonce1);
    pool->nonce1 = 0;
    pool->sessionid = pool->nonce1;
    cg_wunlock_0(&pool->data_lock, "util.c", _func___12407, 3389);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Failed to resume stratum, trying afresh");
      applog(7, tmp42, 0);
    }
    noresume = 1;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Initiate stratum failed");
    applog(7, tmp42, 0);
  }
  if ( sockd )
    suspend_stratum(pool);
LABEL_100:
  json_decref(val);
  return ret;
}
// 44340: conditional instruction was optimized away because %res_val.4!=0
// 4436C: conditional instruction was optimized away because %err_val.4!=0

//----- (00044B88) --------------------------------------------------------
bool __cdecl restart_stratum(pool *pool)
{
  bool ret; // [sp+Fh] [bp+Fh]

  ret = 0;
  if ( pool->stratum_active )
    suspend_stratum(pool);
  if ( initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool) )
    ret = 1;
  if ( !ret )
    pool_died(pool);
  else
    stratum_resumed(pool);
  return ret;
}

//----- (00044C18) --------------------------------------------------------
void __cdecl dev_error(cgpu_info *dev, dev_reason reason)
{
  dev->device_last_not_well = time(0);
  dev->device_not_well_reason = reason;
  switch ( reason )
  {
    case REASON_THREAD_FAIL_INIT:
      ++dev->thread_fail_init_count;
      break;
    case REASON_THREAD_ZERO_HASH:
      ++dev->thread_zero_hash_count;
      break;
    case REASON_THREAD_FAIL_QUEUE:
      ++dev->thread_fail_queue_count;
      break;
    case REASON_DEV_SICK_IDLE_60:
      ++dev->dev_sick_idle_60_count;
      break;
    case REASON_DEV_DEAD_IDLE_600:
      ++dev->dev_dead_idle_600_count;
      break;
    case REASON_DEV_NOSTART:
      ++dev->dev_nostart_count;
      break;
    case REASON_DEV_OVER_HEAT:
      ++dev->dev_over_heat_count;
      break;
    case REASON_DEV_THERMAL_CUTOFF:
      ++dev->dev_thermal_cutoff_count;
      break;
    case REASON_DEV_COMMS_ERROR:
      ++dev->dev_comms_error_count;
      break;
    case REASON_DEV_THROTTLE:
      ++dev->dev_throttle_count;
      break;
    default:
      return;
  }
}

//----- (00044D14) --------------------------------------------------------
void __cdecl RenameThread(const unsigned __int8 *name)
{
  unsigned __int8 buf[16]; // [sp+10h] [bp+8h] BYREF

  snprintf((char *)buf, 0x10u, "cg@%s", (const char *)name);
  prctl(15, buf, 0, 0, 0);
}

//----- (00044D4A) --------------------------------------------------------
void __cdecl cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  int ret; // [sp+824h] [bp+814h]

  ret = sem_init(cgsem, 0, 0);
  if ( ret )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_init ret=%d errno=%d in %s %s():%d",
      ret,
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00044DD4) --------------------------------------------------------
void __cdecl cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( sem_post(cgsem) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d",
      *v4,
      cgsem,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00044E58) --------------------------------------------------------
void __cdecl cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  while ( sem_wait(cgsem) )
  {
    if ( !interrupted() )
    {
      v4 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d",
        *v4,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (00044EE8) --------------------------------------------------------
int __cdecl cgsem_mswait(
        cgsem_t *cgsem,
        int ms,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  timeval tv_now; // [sp+824h] [bp+814h] BYREF
  timespec ts_now; // [sp+82Ch] [bp+81Ch] BYREF
  timespec abs_timeout; // [sp+834h] [bp+824h] BYREF

  cgtime(&tv_now);
  timeval_to_spec(&ts_now, &tv_now);
  ms_to_timespec(&abs_timeout, ms);
  while ( 1 )
  {
    timeraddspec(&abs_timeout, &ts_now);
    if ( !sem_timedwait(cgsem, &abs_timeout) )
      break;
    if ( sock_timeout() )
      return 110;
    if ( !interrupted() )
    {
      v6 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        *v6,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  return 0;
}

//----- (00044FD4) --------------------------------------------------------
void __cdecl cgsem_destroy(cgsem_t *cgsem)
{
  sem_destroy(cgsem);
}

//----- (00044FEA) --------------------------------------------------------
void *__cdecl completion_thread(void *arg)
{
  pthread_setcanceltype(1, 0);
  (*((void (__fastcall **)(_DWORD))arg + 4))(*((_DWORD *)arg + 5));
  cgsem_post((cgsem_t *)arg, "util.c", _func___12511, 3737);
  return 0;
}

//----- (0004502E) --------------------------------------------------------
bool __cdecl cg_completion_timeout(void *fn, void *fnarg, int timeout)
{
  pthread_t pthread; // [sp+1Ch] [bp+14h] BYREF
  cg_completion *cgc; // [sp+20h] [bp+18h]
  bool ret; // [sp+27h] [bp+1Fh]

  ret = 0;
  cgc = (cg_completion *)cgmalloc(0x18u, "util.c", _func___12520, 3748);
  cgsem_init(&cgc->cgsem, "util.c", _func___12520, 3749);
  cgc->fn = (void (*)(void *))fn;
  cgc->fnarg = fnarg;
  pthread_create(&pthread, 0, (void *(*)(void *))completion_thread, cgc);
  ret = cgsem_mswait(&cgc->cgsem, timeout, "util.c", _func___12520, 3755) != 0;
  if ( !ret )
  {
    pthread_join(pthread, 0);
    free(cgc);
  }
  else
  {
    pthread_cancel(pthread);
  }
  return !ret;
}

//----- (00045104) --------------------------------------------------------
void __cdecl cg_memcpy(
        void *dest,
        const void *src,
        unsigned int n,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( n && n <= 0x80000000 )
  {
    if ( dest )
    {
      if ( src )
      {
        memcpy(dest, src, n);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d",
          n,
          (const char *)file,
          (const char *)func,
          line);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d",
        n,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "ERR: Asked to memcpy %u bytes from %s %s():%d",
      n,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (0004529C) --------------------------------------------------------
void __cdecl rev(unsigned __int8 *s, size_t l)
{
  unsigned __int8 t; // [sp+Fh] [bp+Fh]
  size_t j; // [sp+10h] [bp+10h]
  size_t i; // [sp+14h] [bp+14h]

  i = 0;
  for ( j = l - 1; i < j; --j )
  {
    t = s[i];
    s[i] = s[j];
    s[j] = t;
    ++i;
  }
}

//----- (000452F6) --------------------------------------------------------
unsigned int get_iic()
{
  return axi_fpga_addr[12];
}

//----- (00045320) --------------------------------------------------------
unsigned __int8 __cdecl set_iic(unsigned int data)
{
  int v2; // r3
  FILE *pFile; // [sp+10h] [bp+8h]
  signed int ret; // [sp+18h] [bp+10h]
  int wait_counter; // [sp+1Ch] [bp+14h]

  wait_counter = 0;
  axi_fpga_addr[12] = data & 0x3FFFFFFF;
  while ( 1 )
  {
    ret = get_iic();
    if ( ret < 0 )
      return ret;
    v2 = wait_counter++;
    if ( v2 > 100 )
      break;
    usleep(0x1388u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: could not get iic, ret = 0x%08x\n", "zynq.c", 63, (const char *)_FUNCTION___12130, ret);
    fclose(pFile);
  }
  return 0;
}

//----- (000453E8) --------------------------------------------------------
uint8_t __cdecl zynq_set_iic(
        unsigned __int8 dev_addr,
        unsigned __int8 which_iic,
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 data)
{
  uint32_t value; // [sp+Ch] [bp+Ch]

  value = 0;
  if ( read )
    value = 0x2000000;
  if ( reg_addr_valid )
    value |= (reg_addr << 8) | 0x1000000;
  return set_iic(data | (dev_addr << 16) & 0x70000 | (dev_addr >> 3 << 20) & 0xF00000 | (which_iic << 26) & 0xC000000 | value);
}

//----- (0004547C) --------------------------------------------------------
void __cdecl read_fpga_id(unsigned __int8 *pFpgaID)
{
  sprintf((char *)pFpgaID, "%08x%08x", axi_fpga_addr[61], axi_fpga_addr[60]);
}

//----- (000454C6) --------------------------------------------------------
unsigned int get_nonce2_and_job_id_store_address()
{
  return axi_fpga_addr[68];
}

//----- (000454F2) --------------------------------------------------------
void __cdecl set_nonce2_and_job_id_store_address(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  get_nonce2_and_job_id_store_address();
  axi_fpga_addr[68] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set NONCE2_AND_JOBID_STORE_ADDRESS is 0x%x\n",
        "zynq.c",
        154,
        (const char *)_FUNCTION___12168,
        value);
    fclose(pFile);
  }
  get_nonce2_and_job_id_store_address();
}

//----- (00045588) --------------------------------------------------------
int get_job_start_address()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[70];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: JOB_START_ADDRESS is 0x%x\n", "zynq.c", 162, (const char *)_FUNCTION___12174, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (0004561C) --------------------------------------------------------
void __cdecl set_job_start_address(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[70] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set JOB_START_ADDRESS is 0x%x\n", "zynq.c", 169, (const char *)_FUNCTION___12179, value);
    fclose(pFile);
  }
  get_job_start_address();
}

//----- (000456AE) --------------------------------------------------------
int get_QN_write_data_command()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[32];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: QN_WRITE_DATA_COMMAND is 0x%x\n", "zynq.c", 189, (const char *)_FUNCTION___12191, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045740) --------------------------------------------------------
void __cdecl set_QN_write_data_command(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[32] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set QN_WRITE_DATA_COMMAND is 0x%x\n",
        "zynq.c",
        196,
        (const char *)_FUNCTION___12196,
        value);
    fclose(pFile);
  }
  get_QN_write_data_command();
}

//----- (000457D0) --------------------------------------------------------
void __cdecl set_reset_hashboard(int chainIndex, int resetBit)
{
  FILE *pFile; // [sp+14h] [bp+Ch]
  unsigned int resetFlag; // [sp+18h] [bp+10h]
  unsigned int ret; // [sp+1Ch] [bp+14h]
  int reta; // [sp+1Ch] [bp+14h]

  ret = axi_fpga_addr[13];
  resetFlag = 1 << chainIndex;
  if ( resetBit <= 0 )
    reta = ~resetFlag & ret;
  else
    reta = resetFlag | ret;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set_reset_hashboard = 0x%08x\n", "zynq.c", 212, (const char *)_FUNCTION___12204, reta);
    fclose(pFile);
  }
  axi_fpga_addr[13] = reta;
}

//----- (00045890) --------------------------------------------------------
int get_fan_control()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[33];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: FAN_CONTROL is 0x%x\n", "zynq.c", 252, (const char *)_FUNCTION___12225, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045922) --------------------------------------------------------
void __cdecl set_fan_control(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[33] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set FAN_CONTROL is 0x%x\n", "zynq.c", 259, (const char *)_FUNCTION___12230, value);
    fclose(pFile);
  }
  get_fan_control();
}

//----- (000459B4) --------------------------------------------------------
int get_hash_on_plug()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[2];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: HASH_ON_PLUG is 0x%x\n", "zynq.c", 268, (const char *)_FUNCTION___12236, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045A48) --------------------------------------------------------
unsigned int get_crc_count()
{
  return (unsigned __int16)axi_fpga_addr[62];
}

//----- (00045A6E) --------------------------------------------------------
int get_hardware_version()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = *axi_fpga_addr;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: HARDWARE_VERSION is 0x%x\n", "zynq.c", 284, (const char *)_FUNCTION___12245, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045B00) --------------------------------------------------------
void __cdecl set_Hardware_version(unsigned int value)
{
  *axi_fpga_addr = value;
}

//----- (00045B22) --------------------------------------------------------
int __cdecl get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed)
{
  FILE *pFile; // [sp+18h] [bp+8h]
  unsigned int ret; // [sp+1Ch] [bp+Ch]

  ret = axi_fpga_addr[1];
  *fan_speed = (unsigned __int8)ret;
  *fan_id = BYTE1(ret) & 7;
  if ( *fan_speed && log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: fan_id is 0x%x, fan_speed is 0x%x\n",
        "zynq.c",
        301,
        (const char *)_FUNCTION___12255,
        *fan_id,
        *fan_speed);
    fclose(pFile);
  }
  return ret;
}

//----- (00045BE4) --------------------------------------------------------
int get_time_out_control()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[34];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TIME_OUT_CONTROL is 0x%x\n", "zynq.c", 342, (const char *)_FUNCTION___12277, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045C78) --------------------------------------------------------
void __cdecl set_time_out_control(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[34] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TIME_OUT_CONTROL is 0x%x\n", "zynq.c", 349, (const char *)_FUNCTION___12282, value);
    fclose(pFile);
  }
  get_time_out_control();
}

//----- (00045D0A) --------------------------------------------------------
int __cdecl get_BC_command_buffer(unsigned int *buf)
{
  FILE *pFile; // [sp+18h] [bp+8h]
  unsigned int ret; // [sp+1Ch] [bp+Ch]

  *buf = axi_fpga_addr[49];
  buf[1] = axi_fpga_addr[50];
  ret = axi_fpga_addr[51];
  buf[2] = ret;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: BC_COMMAND_BUFFER buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x\n",
        "zynq.c",
        377,
        (const char *)_FUNCTION___12299,
        *buf,
        buf[1],
        buf[2]);
    fclose(pFile);
  }
  return ret;
}

//----- (00045DE8) --------------------------------------------------------
void __cdecl set_BC_command_buffer(unsigned int *value)
{
  unsigned int buf[4]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile; // [sp+2Ch] [bp+1Ch]

  memset(buf, 0, sizeof(buf));
  axi_fpga_addr[49] = *value;
  axi_fpga_addr[50] = value[1];
  axi_fpga_addr[51] = value[2];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set BC_COMMAND_BUFFER value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x\n",
        "zynq.c",
        387,
        (const char *)_FUNCTION___12305,
        *value,
        value[1],
        value[2]);
    fclose(pFile);
  }
  get_BC_command_buffer(buf);
}

//----- (00045EC6) --------------------------------------------------------
int get_BC_write_command()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[48];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: BC_WRITE_COMMAND is 0x%x\n", "zynq.c", 395, (const char *)_FUNCTION___12311, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045F5A) --------------------------------------------------------
void __cdecl set_BC_command_buffer_t(unsigned int *value)
{
  unsigned int buf[4]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile; // [sp+2Ch] [bp+1Ch]

  while ( get_BC_write_command() < 0 )
    usleep(0x3E8u);
  memset(buf, 0, sizeof(buf));
  axi_fpga_addr[49] = *value;
  axi_fpga_addr[50] = value[1];
  axi_fpga_addr[51] = value[2];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set BC_COMMAND_BUFFER value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x\n",
        "zynq.c",
        411,
        (const char *)_FUNCTION___12320,
        *value,
        value[1],
        value[2]);
    fclose(pFile);
  }
  get_BC_command_buffer(buf);
}

//----- (0004604C) --------------------------------------------------------
unsigned int get_nonce_number_in_fifo()
{
  return axi_fpga_addr[6];
}

//----- (00046076) --------------------------------------------------------
int __cdecl get_return_nonce(unsigned int *buf)
{
  unsigned int ret; // [sp+Ch] [bp+Ch]

  *buf = axi_fpga_addr[4];
  ret = axi_fpga_addr[5];
  buf[1] = ret;
  return ret;
}

//----- (000460C0) --------------------------------------------------------
void __cdecl set_BC_write_command_t(unsigned int value)
{
  axi_fpga_addr[48] = value;
}

//----- (000460E4) --------------------------------------------------------
void __cdecl set_BC_write_command(unsigned int value)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  int wait_count; // [sp+14h] [bp+Ch]

  wait_count = 0;
  axi_fpga_addr[48] = value;
  if ( (value & 0x80000000) == 0 )
  {
    get_BC_write_command();
  }
  else
  {
    while ( get_BC_write_command() < 0 )
    {
      cgsleep_ms(1);
      if ( ++wait_count > 3000 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Error: set_BC_write_command wait buffer ready timeout!\n",
              "zynq.c",
              455,
              (const char *)_FUNCTION___12337);
          fclose(pFile);
        }
        return;
      }
    }
  }
}

//----- (000461A6) --------------------------------------------------------
int get_ticket_mask()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[35];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TICKET_MASK_FPGA is 0x%x\n", "zynq.c", 471, (const char *)_FUNCTION___12346, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (0004623A) --------------------------------------------------------
void __cdecl set_ticket_mask(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[35] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TICKET_MASK_FPGA is 0x%x\n", "zynq.c", 478, (const char *)_FUNCTION___12351, value);
    fclose(pFile);
  }
  get_ticket_mask();
}

//----- (000462CC) --------------------------------------------------------
int get_job_id()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[73];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: JOB_ID is 0x%x\n", "zynq.c", 486, (const char *)_FUNCTION___12357, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00046362) --------------------------------------------------------
void __cdecl set_job_id(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[73] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set JOB_ID is 0x%x\n", "zynq.c", 493, (const char *)_FUNCTION___12362, value);
    fclose(pFile);
  }
  get_job_id();
}

//----- (000463F6) --------------------------------------------------------
void __cdecl set_job_length(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[71] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set JOB_LENGTH is 0x%x\n", "zynq.c", 508, (const char *)_FUNCTION___12373, value);
    fclose(pFile);
  }
  get_job_id();
}

//----- (0004648A) --------------------------------------------------------
int get_block_header_version()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[76];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: BLOCK_HEADER_VERSION is 0x%x\n", "zynq.c", 516, (const char *)_FUNCTION___12379, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00046520) --------------------------------------------------------
int get_block_header_version_1()
{
  FILE *pFile; // [sp+10h] [bp+0h]
  int ret; // [sp+14h] [bp+4h]

  ret = axi_fpga_addr[89];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: BLOCK_HEADER_VERSION 1 is 0x%x\n",
        "zynq.c",
        523,
        (const char *)_FUNCTION___12385,
        (const char *)_FUNCTION___12385,
        ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000465C0) --------------------------------------------------------
void __cdecl set_block_header_version(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[76] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set BLOCK_HEADER_VERSION is 0x%x\n",
        "zynq.c",
        544,
        (const char *)_FUNCTION___12402,
        value);
    fclose(pFile);
  }
  get_block_header_version();
}

//----- (00046654) --------------------------------------------------------
void __cdecl set_block_header_version_1(uint32_t value)
{
  FILE *pFile; // [sp+1Ch] [bp+Ch]

  axi_fpga_addr[89] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: set BLOCK_HEADER_VERSION is 0x%x\n",
        "zynq.c",
        550,
        (const char *)_FUNCTION___12407,
        (const char *)_FUNCTION___12407,
        value);
    fclose(pFile);
  }
  get_block_header_version_1();
}

//----- (000466F2) --------------------------------------------------------
int get_time_stamp()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[77];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TIME_STAMP is 0x%x\n", "zynq.c", 570, (const char *)_FUNCTION___12422, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00046788) --------------------------------------------------------
void __cdecl set_time_stamp(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[77] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TIME_STAMP is 0x%x\n", "zynq.c", 577, (const char *)_FUNCTION___12427, value);
    fclose(pFile);
  }
  get_time_stamp();
}

//----- (0004681C) --------------------------------------------------------
int get_target_bits()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[78];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TARGET_BITS is 0x%x\n", "zynq.c", 585, (const char *)_FUNCTION___12433, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000468B2) --------------------------------------------------------
void __cdecl set_target_bits(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[78] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TARGET_BITS is 0x%x\n", "zynq.c", 592, (const char *)_FUNCTION___12438, value);
    fclose(pFile);
  }
  get_target_bits();
}

//----- (00046946) --------------------------------------------------------
void __cdecl set_pre_header_hash(unsigned int *value)
{
  FILE *pFile; // [sp+34h] [bp+Ch]

  axi_fpga_addr[80] = *value;
  axi_fpga_addr[81] = value[1];
  axi_fpga_addr[82] = value[2];
  axi_fpga_addr[83] = value[3];
  axi_fpga_addr[84] = value[4];
  axi_fpga_addr[85] = value[5];
  axi_fpga_addr[86] = value[6];
  axi_fpga_addr[87] = value[7];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set PRE_HEADER_HASH value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x, value[3]: 0x%x, value[4]: 0x%x, va"
        "lue[5]: 0x%x, value[6]: 0x%x, value[7]: 0x%x\n",
        "zynq.c",
        623,
        (const char *)_FUNCTION___12449,
        *value,
        value[1],
        value[2],
        value[3],
        value[4],
        value[5],
        value[6],
        value[7]);
    fclose(pFile);
  }
}

//----- (00046AA6) --------------------------------------------------------
int get_coinbase_length_and_nonce2_length()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[65];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
        "zynq.c",
        631,
        (const char *)_FUNCTION___12455,
        ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00046B3C) --------------------------------------------------------
void __cdecl set_coinbase_length_and_nonce2_length(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[65] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
        "zynq.c",
        638,
        (const char *)_FUNCTION___12460,
        value);
    fclose(pFile);
  }
  get_coinbase_length_and_nonce2_length();
}

//----- (00046BD0) --------------------------------------------------------
int __cdecl get_work_nonce2(unsigned int *buf)
{
  FILE *pFile; // [sp+18h] [bp+8h]

  *buf = axi_fpga_addr[66];
  buf[1] = axi_fpga_addr[67];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: WORK_NONCE_2 buf[0]: 0x%x, buf[1]: 0x%x\n",
        "zynq.c",
        647,
        (const char *)_FUNCTION___12466,
        *buf,
        buf[1]);
    fclose(pFile);
  }
  return -1;
}

//----- (00046C86) --------------------------------------------------------
void __cdecl set_work_nonce2(unsigned int *value)
{
  unsigned int buf[2]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile; // [sp+24h] [bp+14h]

  buf[0] = 0;
  buf[1] = 0;
  axi_fpga_addr[66] = *value;
  axi_fpga_addr[67] = value[1];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set WORK_NONCE_2 value[0]: 0x%x, value[1]: 0x%x\n",
        "zynq.c",
        656,
        (const char *)_FUNCTION___12472,
        *value,
        value[1]);
    fclose(pFile);
  }
  get_work_nonce2(buf);
}

//----- (00046D4A) --------------------------------------------------------
int get_merkle_bin_number()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = (unsigned __int16)axi_fpga_addr[69];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: MERKLE_BIN_NUMBER is 0x%x\n", "zynq.c", 665, (const char *)_FUNCTION___12478, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00046DE6) --------------------------------------------------------
void __cdecl set_merkle_bin_number(unsigned int value)
{
  unsigned __int16 valuea; // [sp+Ch] [bp+4h]
  FILE *pFile; // [sp+14h] [bp+Ch]

  valuea = value;
  axi_fpga_addr[69] = (unsigned __int16)value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set MERKLE_BIN_NUMBER is 0x%x\n",
        "zynq.c",
        672,
        (const char *)_FUNCTION___12483,
        valuea);
    fclose(pFile);
  }
  get_merkle_bin_number();
}

//----- (00046E7E) --------------------------------------------------------
int get_nonce_fifo_interrupt()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[7];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: NONCE_FIFO_INTERRUPT is 0x%x\n", "zynq.c", 680, (const char *)_FUNCTION___12489, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00046F12) --------------------------------------------------------
void __cdecl set_nonce_fifo_interrupt(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[7] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set NONCE_FIFO_INTERRUPT is 0x%x\n",
        "zynq.c",
        687,
        (const char *)_FUNCTION___12494,
        value);
    fclose(pFile);
  }
  get_nonce_fifo_interrupt();
}

//----- (00046FA4) --------------------------------------------------------
int get_dhash_acc_control()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[64];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 695, (const char *)_FUNCTION___12500, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (0004703A) --------------------------------------------------------
void __cdecl set_dhash_acc_control(unsigned int value)
{
  FILE *pFile_0; // [sp+14h] [bp+Ch]
  FILE *pFile; // [sp+18h] [bp+10h]
  int a; // [sp+1Ch] [bp+14h]

  a = 10;
  axi_fpga_addr[64] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 703, (const char *)_FUNCTION___12506, value);
    fclose(pFile);
  }
  while ( a > 0 && (value | 0x80) != (get_dhash_acc_control() | 0x80) )
  {
    axi_fpga_addr[64] = value;
    --a;
    cgsleep_ms(2);
  }
  if ( !a && log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: set DHASH_ACC_CONTROL failed!", "zynq.c", 713, (const char *)_FUNCTION___12506);
    fclose(pFile_0);
  }
}

//----- (0004717C) --------------------------------------------------------
void __cdecl set_TW_write_command_vil(unsigned int *value)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&fpga_mutex);
  for ( i = 0; i <= 0xC; ++i )
  {
    if ( i )
      axi_fpga_addr[17] = value[i];
    else
      axi_fpga_addr[16] = *value;
  }
  pthread_mutex_unlock(&fpga_mutex);
}

//----- (000471F4) --------------------------------------------------------
unsigned int get_buffer_space()
{
  return axi_fpga_addr[3];
}

//----- (0004721E) --------------------------------------------------------
int get_hash_counting_number()
{
  FILE *pFile; // [sp+8h] [bp+0h]
  int ret; // [sp+Ch] [bp+4h]

  ret = axi_fpga_addr[36];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 754, (const char *)_FUNCTION___12534, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000472B2) --------------------------------------------------------
void __cdecl set_hash_counting_number(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  axi_fpga_addr[36] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 761, (const char *)_FUNCTION___12539, value);
    fclose(pFile);
  }
  get_hash_counting_number();
}

//----- (00047344) --------------------------------------------------------
int bitmain_axi_init()
{
  FILE *pFile; // [sp+10h] [bp+0h]
  FILE *pFile_0; // [sp+14h] [bp+4h]
  FILE *pFile_4; // [sp+18h] [bp+8h]
  FILE *pFile_5; // [sp+1Ch] [bp+Ch]
  FILE *pFile_9; // [sp+20h] [bp+10h]
  FILE *pFile_10; // [sp+24h] [bp+14h]
  FILE *pFile_8; // [sp+28h] [bp+18h]
  FILE *pFile_7; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_6; // [sp+30h] [bp+20h]
  int fd_fpga_mem; // [sp+34h] [bp+24h]
  FILE *pFile_3; // [sp+38h] [bp+28h]
  FILE *pFile_2; // [sp+3Ch] [bp+2Ch]
  unsigned int data; // [sp+40h] [bp+30h]
  FILE *pFile_1; // [sp+44h] [bp+34h]
  int fd; // [sp+48h] [bp+38h]

  fd = open("/dev/axi_fpga_dev", 2);
  if ( fd < 0 )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: /dev/axi_fpga_dev open failed. fd = %d\n",
          "zynq.c",
          780,
          (const char *)_FUNCTION___12550,
          fd);
      fclose(pFile);
    }
LABEL_6:
    perror("open");
    return -1;
  }
  axi_fpga_addr = (unsigned int *)mmap(0, 0x160u, 3, 1, fd, 0);
  if ( axi_fpga_addr )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: mmap axi_fpga_addr = 0x%x\n",
          "zynq.c",
          791,
          (const char *)_FUNCTION___12550,
          axi_fpga_addr);
      fclose(pFile_1);
    }
    data = *axi_fpga_addr;
    if ( (unsigned __int16)*axi_fpga_addr != 50433 && log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n",
          "zynq.c",
          797,
          (const char *)_FUNCTION___12550,
          data,
          50433);
      fclose(pFile_2);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%s:%d:%s: axi_fpga_addr data = 0x%x\n", "zynq.c", 800, (const char *)_FUNCTION___12550, data);
      fclose(pFile_3);
    }
    fd_fpga_mem = open("/dev/fpga_mem", 2);
    if ( fd_fpga_mem < 0 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: /dev/fpga_mem open failed. fd_fpga_mem = %d\n",
            "zynq.c",
            805,
            (const char *)_FUNCTION___12550,
            fd_fpga_mem);
        fclose(pFile_4);
      }
      goto LABEL_6;
    }
    fpga_mem_addr = (unsigned int *)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
    if ( fpga_mem_addr )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: mmap fpga_mem_addr = 0x%x\n",
            "zynq.c",
            816,
            (const char *)_FUNCTION___12550,
            fpga_mem_addr);
        fclose(pFile_6);
      }
      nonce2_jobid_address = fpga_mem_addr;
      job_start_address_1 = fpga_mem_addr + 0x80000;
      job_start_address_2 = fpga_mem_addr + 540672;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(
            pFile_7,
            "%s:%d:%s: job_start_address_1 = 0x%x\n",
            "zynq.c",
            822,
            (const char *)_FUNCTION___12550,
            job_start_address_1);
        fclose(pFile_7);
      }
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(
            pFile_8,
            "%s:%d:%s: job_start_address_2 = 0x%x\n",
            "zynq.c",
            823,
            (const char *)_FUNCTION___12550,
            job_start_address_2);
        fclose(pFile_8);
      }
      set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
      dev = (all_parameters *)calloc(0x534Cu, 1u);
      if ( dev )
      {
        dev->current_job_start_address = job_start_address_1;
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_10 = fopen((const char *)log_file, "a+");
          if ( pFile_10 )
            fprintf(pFile_10, "%s:%d:%s: kmalloc for dev success.\n", "zynq.c", 837, (const char *)_FUNCTION___12550);
          fclose(pFile_10);
        }
        close(fd);
        close(fd_fpga_mem);
        return 0;
      }
      else
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_9 = fopen((const char *)log_file, "a+");
          if ( pFile_9 )
            fprintf(pFile_9, "%s:%d:%s: kmalloc for dev failed.\n", "zynq.c", 831, (const char *)_FUNCTION___12550);
          fclose(pFile_9);
        }
        return -1;
      }
    }
    else
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n",
            "zynq.c",
            813,
            (const char *)_FUNCTION___12550,
            fpga_mem_addr);
        fclose(pFile_5);
      }
      return -1;
    }
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n",
          "zynq.c",
          788,
          (const char *)_FUNCTION___12550,
          axi_fpga_addr);
      fclose(pFile_0);
    }
    return -1;
  }
}

//----- (00047A3A) --------------------------------------------------------
unsigned int __cdecl _bswap_32_0(unsigned int __bsx)
{
  return bswap32(__bsx);
}

//----- (00047A52) --------------------------------------------------------
__uint32_t __cdecl _uint32_identity_0(__uint32_t __x)
{
  return __x;
}

//----- (00047A68) --------------------------------------------------------
__uint64_t __cdecl _uint64_identity_0(__uint64_t __x)
{
  return __x;
}

//----- (00047A82) --------------------------------------------------------
void __cdecl json_decref_0(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (00047ABA) --------------------------------------------------------
void __cdecl _list_del_0(list_head *prev, list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

//----- (00047ADC) --------------------------------------------------------
void __cdecl list_del_0(list_head *entry)
{
  _list_del_0(entry->prev, entry->next);
  entry->next = 0;
  entry->prev = 0;
}

//----- (00047B08) --------------------------------------------------------
uint32_t __cdecl swab32_1(uint32_t v)
{
  return bswap32(v);
}

//----- (00047B20) --------------------------------------------------------
void __cdecl swap256(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = *((_DWORD *)src_p + 7);
  *((_DWORD *)dest_p + 1) = *((_DWORD *)src_p + 6);
  *((_DWORD *)dest_p + 2) = *((_DWORD *)src_p + 5);
  *((_DWORD *)dest_p + 3) = *((_DWORD *)src_p + 4);
  *((_DWORD *)dest_p + 4) = *((_DWORD *)src_p + 3);
  *((_DWORD *)dest_p + 5) = *((_DWORD *)src_p + 2);
  *((_DWORD *)dest_p + 6) = *((_DWORD *)src_p + 1);
  *((_DWORD *)dest_p + 7) = *(_DWORD *)src_p;
}

//----- (00047B8C) --------------------------------------------------------
void __cdecl swab256_0(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = swab32_1(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = swab32_1(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = swab32_1(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = swab32_1(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = swab32_1(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = swab32_1(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = swab32_1(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = swab32_1(*(_DWORD *)src_p);
}

//----- (00047C4E) --------------------------------------------------------
void __cdecl flip32_0(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32_1(*((_DWORD *)src_p + i));
}

//----- (00047C96) --------------------------------------------------------
void __cdecl flip64(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 15; ++i )
    *((_DWORD *)dest_p + i) = swab32_1(*((_DWORD *)src_p + i));
}

//----- (00047CDE) --------------------------------------------------------
void __cdecl flip80(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i <= 19; ++i )
    *((_DWORD *)dest_p + i) = swab32_1(*((_DWORD *)src_p + i));
}

//----- (00047D26) --------------------------------------------------------
void __cdecl endian_flip32(void *dest_p, const void *src_p)
{
  ;
}

//----- (00047D3C) --------------------------------------------------------
void __cdecl mutex_lock_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047DB8) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047E34) --------------------------------------------------------
void __cdecl mutex_unlock_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_1(lock, file, func, line);
  selective_yield();
}

//----- (00047E62) --------------------------------------------------------
void __cdecl wr_lock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047EDE) --------------------------------------------------------
int __cdecl wr_trylock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_rwlock_trywrlock(lock);
}

//----- (00047EFE) --------------------------------------------------------
void __cdecl rd_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047F7A) --------------------------------------------------------
void __cdecl rw_unlock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047FF6) --------------------------------------------------------
void __cdecl wr_unlock_noyield_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
}

//----- (00048018) --------------------------------------------------------
void __cdecl rd_unlock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
  selective_yield();
}

//----- (00048046) --------------------------------------------------------
void __cdecl wr_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
  selective_yield();
}

//----- (00048074) --------------------------------------------------------
void __cdecl mutex_init_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000480F2) --------------------------------------------------------
void __cdecl rwlock_init_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00048170) --------------------------------------------------------
void __cdecl cglock_init_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init_0(&lock->mutex, file, func, line);
  rwlock_init_0(&lock->rwlock, file, func, line);
}

//----- (000481A2) --------------------------------------------------------
void __cdecl cg_rlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_1(&lock->mutex, file, func, line);
  rd_lock_0(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_1(&lock->mutex, file, func, line);
}

//----- (000481E0) --------------------------------------------------------
void __cdecl cg_wlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_1(&lock->mutex, file, func, line);
  wr_lock_1(&lock->rwlock, file, func, line);
}

//----- (00048212) --------------------------------------------------------
void __cdecl cg_dwlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_1(&lock->rwlock, file, func, line);
  rd_lock_0(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_1(&lock->mutex, file, func, line);
}

//----- (00048254) --------------------------------------------------------
void __cdecl cg_runlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock_0(&lock->rwlock, file, func, line);
}

//----- (0004827A) --------------------------------------------------------
void __cdecl cg_wunlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_1(&lock->rwlock, file, func, line);
  mutex_unlock_1(&lock->mutex, file, func, line);
}

//----- (000482AC) --------------------------------------------------------
bool __cdecl time_before(tm *tm1, tm *tm2)
{
  return tm1->tm_hour < tm2->tm_hour || tm1->tm_hour == tm2->tm_hour && tm1->tm_min < tm2->tm_min;
}

//----- (000482F0) --------------------------------------------------------
bool should_run()
{
  time_t tmp_time; // [sp+0h] [bp+0h] BYREF
  timeval tv; // [sp+4h] [bp+4h] BYREF
  tm *tm; // [sp+Ch] [bp+Ch]

  if ( !schedstart.enable && !schedstop.enable )
    return 1;
  cgtime(&tv);
  tmp_time = tv.tv_sec;
  tm = localtime(&tmp_time);
  if ( !schedstart.enable )
    return time_before(tm, &schedstop.tm);
  if ( !schedstop.enable )
  {
    if ( time_before(tm, &schedstart.tm) )
    {
      return 0;
    }
    else
    {
      schedstart.enable = 0;
      return 1;
    }
  }
  else if ( time_before(&schedstart.tm, &schedstop.tm) )
  {
    return time_before(tm, &schedstop.tm) && !time_before(tm, &schedstart.tm);
  }
  else
  {
    return !time_before(tm, &schedstart.tm) || time_before(tm, &schedstop.tm);
  }
}

//----- (00048408) --------------------------------------------------------
void __cdecl get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv)
{
  time_t tmp_time; // [sp+2Ch] [bp+14h] BYREF
  tm *tm; // [sp+30h] [bp+18h]
  int ms; // [sp+34h] [bp+1Ch]

  tmp_time = tv->tv_sec;
  ms = tv->tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf(
    (char *)f,
    fsiz,
    "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
    tm->tm_year + 1900,
    tm->tm_mon + 1,
    tm->tm_mday,
    tm->tm_hour,
    tm->tm_min,
    tm->tm_sec,
    ms);
}

//----- (00048484) --------------------------------------------------------
void __cdecl get_timestamp(unsigned __int8 *f, size_t fsiz, timeval *tv)
{
  time_t tmp_time; // [sp+24h] [bp+14h] BYREF
  tm *tm; // [sp+28h] [bp+18h]
  int ms; // [sp+2Ch] [bp+1Ch]

  tmp_time = tv->tv_sec;
  ms = tv->tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf((char *)f, fsiz, "[%02d:%02d:%02d.%03d]", tm->tm_hour, tm->tm_min, tm->tm_sec, ms);
}

//----- (000484E8) --------------------------------------------------------
void __noreturn applog_and_exit(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+14h] BYREF

  va_start(varg_r1, fmt);
  vsnprintf((char *)exit_buf, 0x200u, (const char *)fmt, varg_r1);
  applog(3, exit_buf, 1);
  exit(1);
}

//----- (00048520) --------------------------------------------------------
thr_info *__cdecl _get_thread(int thr_id)
{
  return mining_thr[thr_id];
}

//----- (00048546) --------------------------------------------------------
thr_info *__cdecl get_thread(int thr_id)
{
  thr_info *thr; // [sp+Ch] [bp+Ch]

  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___14467, 588);
  thr = _get_thread(thr_id);
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___14467, 590);
  return thr;
}

//----- (000485A0) --------------------------------------------------------
cgpu_info *__cdecl get_thr_cgpu(int thr_id)
{
  return get_thread(thr_id)->cgpu;
}

//----- (000485BC) --------------------------------------------------------
cgpu_info *__cdecl get_devices(int id)
{
  cgpu_info *cgpu; // [sp+Ch] [bp+Ch]

  rd_lock_0(&devices_lock, "cgminer.c", _func___14476, 608);
  cgpu = devices[id];
  rd_unlock_0(&devices_lock, "cgminer.c", _func___14476, 610);
  return cgpu;
}

//----- (00048622) --------------------------------------------------------
void __cdecl sharelog(const unsigned __int8 *disposition, const work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+2Ch] [bp+Ch] BYREF
  unsigned __int8 s[1024]; // [sp+82Ch] [bp+80Ch] BYREF
  size_t ret; // [sp+C2Ch] [bp+C0Ch]
  int rv; // [sp+C30h] [bp+C10h]
  unsigned __int8 *data; // [sp+C34h] [bp+C14h]
  unsigned __int8 *hash; // [sp+C38h] [bp+C18h]
  unsigned __int8 *target; // [sp+C3Ch] [bp+C1Ch]
  unsigned int t; // [sp+C40h] [bp+C20h]
  pool *pool; // [sp+C44h] [bp+C24h]
  cgpu_info *cgpu; // [sp+C48h] [bp+C28h]
  int thr_id; // [sp+C4Ch] [bp+C2Ch]

  if ( !sharelog_file )
    return;
  thr_id = work->thr_id;
  cgpu = get_thr_cgpu(thr_id);
  pool = work->pool;
  t = work->tv_work_found.tv_sec;
  target = bin2hex(work->target, 0x20u);
  hash = bin2hex(work->hash, 0x20u);
  data = bin2hex(work->data, 0x80u);
  rv = snprintf(
         (char *)s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         t,
         (const char *)disposition,
         (const char *)target,
         (const char *)pool->rpc_url,
         (const char *)cgpu->drv->name,
         cgpu->device_id,
         thr_id,
         (const char *)hash,
         (const char *)data);
  free(target);
  free(hash);
  free(data);
  if ( rv >= 1024 )
  {
    s[1023] = 0;
LABEL_9:
    mutex_lock_1(&sharelog_lock, "cgminer.c", _func___14492, 656);
    ret = fwrite(s, rv, 1u, sharelog_file);
    fflush(sharelog_file);
    mutex_unlock_1(&sharelog_lock, "cgminer.c", _func___14492, 659);
    if ( ret != 1 && (use_syslog || opt_log_output || opt_log_level > 2) )
    {
      strcpy((char *)tmp42, "sharelog fwrite error");
      applog(3, tmp42, 0);
    }
    return;
  }
  if ( rv >= 0 )
    goto LABEL_9;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "sharelog printf error");
    applog(3, tmp42, 0);
  }
}

//----- (00048866) --------------------------------------------------------
void adjust_quota_gcd()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  unsigned int quota; // [sp+804h] [bp+804h]
  pool *pool; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]
  unsigned int lowest_quota; // [sp+810h] [bp+810h]
  unsigned int gcd; // [sp+814h] [bp+814h]

  lowest_quota = -1;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    quota = pool->quota;
    if ( quota && quota < lowest_quota )
      lowest_quota = quota;
  }
  if ( lowest_quota == -1 )
  {
    gcd = 1;
  }
  else
  {
    gcd = lowest_quota;
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      quota = pool->quota;
      if ( quota )
      {
        while ( quota % gcd )
          --gcd;
      }
    }
  }
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->quota_used *= global_quota_gcd;
    pool->quota_used /= gcd;
    pool->quota_gcd = pool->quota / gcd;
  }
  global_quota_gcd = gcd;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Global quota greatest common denominator set to %lu", gcd);
    applog(7, tmp42, 0);
  }
}

//----- (00048A68) --------------------------------------------------------
pool *add_pool()
{
  int v0; // r2
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  pool *pool; // [sp+80Ch] [bp+804h]

  pool = (pool *)cgcalloc(1848, 1u, "cgminer.c", _func___14524, 741);
  pool->support_ab = 0;
  if ( !pool )
  {
    strcpy((char *)tmp42, "Failed to malloc pool in add_pool");
    applog(3, tmp42, 1);
    quit(1);
  }
  pool->prio = total_pools;
  pool->pool_no = pool->prio;
  pools = (pool **)cgrealloc(pools, 4 * (total_pools + 2), "cgminer.c", _func___14524, 753);
  v0 = total_pools++;
  pools[v0] = pool;
  mutex_init_0(&pool->pool_lock, "cgminer.c", _func___14524, 756);
  if ( pthread_cond_init(&pool->cr_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init in add_pool");
    applog(3, tmp42, 1);
    quit(1);
  }
  cglock_init_0(&pool->data_lock, "cgminer.c", _func___14524, 763);
  mutex_init_0(&pool->stratum_lock, "cgminer.c", _func___14524, 764);
  cglock_init_0(&pool->gbt_lock, "cgminer.c", _func___14524, 765);
  pool->curlring.next = &pool->curlring;
  pool->curlring.prev = &pool->curlring;
  pool->tv_idle.tv_sec = -1;
  pool->rpc_req = getwork_req;
  pool->rpc_proxy = 0;
  pool->quota = 1;
  adjust_quota_gcd();
  pool->extranonce_subscribe = 0;
  return pool;
}

//----- (00048C8A) --------------------------------------------------------
bool __cdecl pool_tset(pool *pool, bool *var)
{
  bool ret; // [sp+Fh] [bp+Fh]

  mutex_lock_1(&pool->pool_lock, "cgminer.c", _func___14532, 787);
  ret = *var;
  *var = 1;
  mutex_unlock_1(&pool->pool_lock, "cgminer.c", _func___14532, 792);
  return ret;
}

//----- (00048CE6) --------------------------------------------------------
bool __cdecl pool_tclear(pool *pool, bool *var)
{
  bool ret; // [sp+Fh] [bp+Fh]

  mutex_lock_1(&pool->pool_lock, "cgminer.c", _func___14538, 802);
  ret = *var;
  *var = 0;
  mutex_unlock_1(&pool->pool_lock, "cgminer.c", _func___14538, 807);
  return ret;
}

//----- (00048D42) --------------------------------------------------------
pool *current_pool()
{
  pool *pool; // [sp+4h] [bp+4h]

  cg_rlock_0(&control_lock, "cgminer.c", _func___14543, 817);
  pool = currentpool;
  cg_runlock_0(&control_lock, "cgminer.c", _func___14543, 821);
  return pool;
}

//----- (00048D9E) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_range(const unsigned __int8 *arg, int *i, int min, int max)
{
  unsigned __int8 *err; // [sp+14h] [bp+14h]

  err = opt_set_intval(arg, i);
  if ( err )
    return err;
  if ( min <= *i && max >= *i )
    return 0;
  return "Value out of range";
}

//----- (00048DE8) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_9999(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 9999);
}

//----- (00048E0A) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_65535(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 0xFFFF);
}

//----- (00048E2C) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 10);
}

//----- (00048E4C) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_100(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 100);
}

//----- (00048E6C) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 255);
}

//----- (00048E8C) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 255);
}

//----- (00048EAC) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_7680(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 7680);
}

//----- (00048ECE) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_200(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 200);
}

//----- (00048EEE) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_32_to_63(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 32, 63);
}

//----- (00048F0E) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_22_to_75(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 75);
}

//----- (00048F2E) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_42_to_85(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 85);
}

//----- (00048F4E) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_22_to_55(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 55);
}

//----- (00048F6E) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_42_to_65(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 62);
}

//----- (00048F8E) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 10);
}

//----- (00048FAE) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_4(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 4);
}

//----- (00048FCE) --------------------------------------------------------
unsigned __int8 *__cdecl set_balance(pool_strategy *strategy)
{
  *strategy = POOL_BALANCE;
  return 0;
}

//----- (00048FEA) --------------------------------------------------------
unsigned __int8 *__cdecl set_loadbalance(pool_strategy *strategy)
{
  *strategy = POOL_LOADBALANCE;
  return 0;
}

//----- (00049006) --------------------------------------------------------
unsigned __int8 *__cdecl set_rotate(const unsigned __int8 *arg, unsigned __int8 *i)
{
  pool_strategy_0 = POOL_ROTATE;
  return set_int_range(arg, &opt_rotate_period, 0, 9999);
}

//----- (0004903A) --------------------------------------------------------
unsigned __int8 *__cdecl set_rr(pool_strategy *strategy)
{
  *strategy = POOL_ROUNDROBIN;
  return 0;
}

//----- (00049056) --------------------------------------------------------
bool __cdecl detect_stratum(pool *pool, unsigned __int8 *url)
{
  if ( !extract_sockaddr(url, &pool->sockaddr_url, &pool->stratum_port) )
    return 0;
  if ( strncasecmp((const char *)url, "stratum+tcp://", 0xEu) )
    return 0;
  pool->rpc_url = (unsigned __int8 *)strdup((const char *)url);
  pool->has_stratum = 1;
  pool->stratum_url = pool->sockaddr_url;
  return 1;
}

//----- (000490CC) --------------------------------------------------------
pool *add_url()
{
  if ( ++total_urls > total_pools )
    add_pool();
  return *(&pools[total_urls] + 0x3FFFFFFF);
}

//----- (00049126) --------------------------------------------------------
unsigned __int8 *__cdecl setup_url(pool *pool, unsigned __int8 *arg)
{
  unsigned __int8 *arga; // [sp+0h] [bp+0h]
  unsigned __int8 *httpinput; // [sp+Ch] [bp+Ch]

  arga = get_proxy(arg, pool);
  if ( !detect_stratum(pool, arga) )
  {
    opt_set_charp(arga, &pool->rpc_url);
    if ( strncmp((const char *)arga, "http://", 7u) )
    {
      if ( strncmp((const char *)arga, "https://", 8u) )
      {
        httpinput = (unsigned __int8 *)cgmalloc(0x100u, "cgminer.c", _func___14642, 1021);
        strcpy((char *)httpinput, "stratum+tcp://");
        strncat((char *)httpinput, (const char *)arga, 0xF2u);
        detect_stratum(pool, httpinput);
      }
    }
  }
  return pool->rpc_url;
}

//----- (000491E2) --------------------------------------------------------
unsigned __int8 *__cdecl set_url(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  pool *pool; // [sp+80Ch] [bp+80Ch]

  pool = add_url();
  setup_url(pool, arg);
  if ( strstr((const char *)pool->rpc_url, ".nicehash.com") || strstr((const char *)pool->rpc_url, "#xnsub") )
  {
    pool->extranonce_subscribe = 1;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d extranonce subscribing enabled.", pool->pool_no);
      applog(7, tmp42, 0);
    }
  }
  return 0;
}

//----- (000492B0) --------------------------------------------------------
unsigned __int8 *__cdecl set_quota(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  pool *pool; // [sp+810h] [bp+808h]
  unsigned __int8 *url; // [sp+814h] [bp+80Ch]
  int quota; // [sp+818h] [bp+810h]
  int qlen; // [sp+81Ch] [bp+814h]
  int len; // [sp+820h] [bp+818h]
  unsigned __int8 *semicolon; // [sp+824h] [bp+81Ch]

  semicolon = (unsigned __int8 *)strchr((const char *)arg, 59);
  if ( !semicolon )
    return "No semicolon separated quota;URL pair found";
  len = strlen((const char *)arg);
  *semicolon = 0;
  qlen = strlen((const char *)arg);
  if ( !qlen )
    return "No parameter for quota found";
  len -= qlen + 1;
  if ( len <= 0 )
    return "No parameter for URL found";
  quota = atoi((const char *)arg);
  if ( quota < 0 )
    return "Invalid negative parameter for quota set";
  url = &arg[qlen + 1];
  pool = add_url();
  setup_url(pool, url);
  pool->quota = quota;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Setting pool %d to quota %d", pool->pool_no, pool->quota);
    applog(6, tmp42, 0);
  }
  adjust_quota_gcd();
  return 0;
}

//----- (000493EC) --------------------------------------------------------
unsigned __int8 *__cdecl set_user(const unsigned __int8 *arg)
{
  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_users > total_pools )
    add_pool();
  opt_set_charp(arg, &(*(&pools[total_users] + 0x3FFFFFFF))->rpc_user);
  return 0;
}

//----- (00049476) --------------------------------------------------------
unsigned __int8 *__cdecl set_pass(const unsigned __int8 *arg)
{
  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_passes > total_pools )
    add_pool();
  opt_set_charp(arg, &(*(&pools[total_passes] + 0x3FFFFFFF))->rpc_pass);
  return 0;
}

//----- (00049500) --------------------------------------------------------
unsigned __int8 *__cdecl set_userpass(const unsigned __int8 *arg)
{
  char *updup; // [sp+8h] [bp+8h]
  pool *pool; // [sp+Ch] [bp+Ch]

  if ( total_users || total_passes )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_userpasses > total_pools )
    add_pool();
  pool = *(&pools[total_userpasses] + 0x3FFFFFFF);
  updup = strdup((const char *)arg);
  opt_set_charp(arg, &pool->rpc_userpass);
  pool->rpc_user = (unsigned __int8 *)strtok(updup, ":");
  if ( !pool->rpc_user )
    return "Failed to find : delimited user info";
  pool->rpc_pass = (unsigned __int8 *)strtok(0, ":");
  if ( !pool->rpc_pass )
    pool->rpc_pass = (unsigned __int8 *)strdup(byte_8A828);
  return 0;
}

//----- (00049602) --------------------------------------------------------
unsigned __int8 *__cdecl set_extranonce_subscribe(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  pool *pool; // [sp+80Ch] [bp+80Ch]

  if ( ++total_extranonce > total_pools )
    add_pool();
  pool = *(&pools[total_extranonce] + 0x3FFFFFFF);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Enable extranonce subscribe on %d", pool->pool_no);
    applog(7, tmp42, 0);
  }
  opt_set_bool(&pool->extranonce_subscribe);
  return 0;
}

//----- (000496DE) --------------------------------------------------------
unsigned __int8 *__cdecl enable_debug(bool *flag)
{
  *flag = 1;
  opt_log_output = 1;
  return 0;
}

//----- (00049706) --------------------------------------------------------
unsigned __int8 *__cdecl set_schedtime(const unsigned __int8 *arg, schedtime *st)
{
  if ( sscanf((const char *)arg, "%d:%d", &st->tm.tm_hour, &st->tm.tm_min) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( st->tm.tm_hour > 23 || st->tm.tm_min > 59 || st->tm.tm_hour < 0 || st->tm.tm_min < 0 )
    return "Invalid time set.";
  st->enable = 1;
  return 0;
}

//----- (00049772) --------------------------------------------------------
unsigned __int8 *__cdecl set_sched_start(const unsigned __int8 *arg)
{
  return set_schedtime(arg, &schedstart);
}

//----- (00049792) --------------------------------------------------------
unsigned __int8 *__cdecl set_sched_stop(const unsigned __int8 *arg)
{
  return set_schedtime(arg, &schedstop);
}

//----- (000497B2) --------------------------------------------------------
unsigned __int8 *__cdecl set_sharelog(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *r; // [sp+808h] [bp+808h] BYREF
  int i; // [sp+80Ch] [bp+80Ch]

  r = (unsigned __int8 *)byte_8A828;
  i = strtol((const char *)arg, (char **)&r, 10);
  if ( *r || i < 0 )
  {
    if ( !strcmp((const char *)arg, "-") )
    {
      sharelog_file = (FILE *)stdout;
      if ( !stdout && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        strcpy((char *)tmp42, "Standard output missing for share log");
        applog(3, tmp42, 0);
      }
    }
    else
    {
      sharelog_file = fopen((const char *)arg, "a");
      if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        snprintf((char *)tmp42, 0x800u, "Failed to open %s for share log", (const char *)arg);
        applog(3, tmp42, 0);
      }
    }
  }
  else
  {
    sharelog_file = fdopen(i, "a");
    if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
    {
      snprintf((char *)tmp42, 0x800u, "Failed to open fd %u for share log", i);
      applog(3, tmp42, 0);
    }
  }
  return 0;
}
// AC42C: using guessed type int stdout;

//----- (0004998C) --------------------------------------------------------
void load_temp_cutoffs()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 *nextptr; // [sp+800h] [bp+800h]
  int device; // [sp+804h] [bp+804h]
  int val; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]

  val = 0;
  device = 0;
  if ( temp_cutoff_str )
  {
    device = 0;
    for ( nextptr = (unsigned __int8 *)strtok((char *)temp_cutoff_str, ",");
          nextptr;
          nextptr = (unsigned __int8 *)strtok(0, ",") )
    {
      if ( device >= total_devices )
      {
        strcpy((char *)tmp42, "Too many values passed to set temp cutoff");
        applog(3, tmp42, 1);
        quit(1);
      }
      val = atoi((const char *)nextptr);
      if ( val < 0 || val > 200 )
      {
        strcpy((char *)tmp42, "Invalid value passed to set temp cutoff");
        applog(3, tmp42, 1);
        quit(1);
      }
      rd_lock_0(&devices_lock, "cgminer.c", _func___14714, 1315);
      devices[device]->cutofftemp = val;
      rd_unlock_0(&devices_lock, "cgminer.c", _func___14714, 1317);
      ++device;
    }
    if ( device <= 1 )
    {
      rd_lock_0(&devices_lock, "cgminer.c", _func___14714, 1338);
      for ( i = device; i < total_devices; ++i )
        devices[i]->cutofftemp = val;
      rd_unlock_0(&devices_lock, "cgminer.c", _func___14714, 1344);
    }
  }
  else
  {
    rd_lock_0(&devices_lock, "cgminer.c", _func___14714, 1322);
    for ( i = device; i < total_devices; ++i )
    {
      if ( !devices[i]->cutofftemp )
        devices[i]->cutofftemp = 95;
    }
    rd_unlock_0(&devices_lock, "cgminer.c", _func___14714, 1331);
  }
}

//----- (00049C16) --------------------------------------------------------
unsigned __int8 *__cdecl set_logfile_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_path);
  return 0;
}

//----- (00049C36) --------------------------------------------------------
unsigned __int8 *__cdecl set_logfile_openflag(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_openflag);
  return 0;
}

//----- (00049C56) --------------------------------------------------------
unsigned __int8 *__cdecl set_logwork_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_path);
  return 0;
}

//----- (00049C76) --------------------------------------------------------
unsigned __int8 *__cdecl set_logwork_asicnum(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_asicnum);
  return 0;
}

//----- (00049C98) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_125_to_500(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 125.0 && *i <= 500.0 )
    return 0;
  return "Value out of range";
}

//----- (00049CFC) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_100_to_250(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 100.0 && *i <= 250.0 )
    return 0;
  return "Value out of range";
}

//----- (00049D60) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_0_to_500(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 100.0 && *i <= 250.0 )
    return 0;
  return "Value out of range";
}

//----- (00049DC4) --------------------------------------------------------
unsigned __int8 *__cdecl set_null(const unsigned __int8 *arg)
{
  return 0;
}

//----- (00049DDA) --------------------------------------------------------
unsigned __int8 *__cdecl set_version_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_version_path);
  return 0;
}

//----- (00049DFA) --------------------------------------------------------
unsigned __int8 *__cdecl parse_config(json_t_0 *config, bool fileconf)
{
  size_t v2; // r0
  const unsigned __int8 *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  json_t_0 *arr_val; // [sp+810h] [bp+808h]
  const unsigned __int8 *str; // [sp+814h] [bp+80Ch]
  unsigned __int8 *name; // [sp+818h] [bp+810h]
  json_t_0 *val; // [sp+81Ch] [bp+814h]
  size_t index; // [sp+820h] [bp+818h]
  unsigned __int8 *err; // [sp+824h] [bp+81Ch]
  unsigned __int8 *p; // [sp+828h] [bp+820h]
  opt_table *opt; // [sp+82Ch] [bp+824h]

  if ( fileconf && !fileconf_load )
    fileconf_load = 1;
  for ( opt = opt_config_table; opt->type != OPT_END; ++opt )
  {
    if ( (opt->type & 8) != 0 )
      _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x79Au, (const char *)_PRETTY_FUNCTION___15218);
    if ( opt->names )
    {
      name = (unsigned __int8 *)strdup((const char *)opt->names);
      for ( p = (unsigned __int8 *)strtok((char *)name, "|"); p; p = (unsigned __int8 *)strtok(0, "|") )
      {
        err = 0;
        if ( p[1] == 45 )
        {
          val = json_object_get(config, p + 2);
          if ( val )
          {
            if ( (opt->type & 6) != 0 && val->type == JSON_STRING )
            {
              str = json_string_value(val);
              err = opt->cb_arg(str, opt->u.tlen);
              if ( opt->type == OPT_PROCESSARG )
                opt_set_charp(str, (unsigned __int8 **)opt->u.carg);
            }
            else if ( (opt->type & 6) != 0 && val->type == JSON_ARRAY )
            {
              for ( index = 0; ; ++index )
              {
                v2 = json_array_size(val);
                if ( index >= v2 )
                  break;
                arr_val = json_array_get(val, index);
                if ( !arr_val )
                  break;
                if ( arr_val->type == JSON_STRING )
                {
                  str = json_string_value(arr_val);
                  err = opt->cb_arg(str, opt->u.tlen);
                  if ( opt->type == OPT_PROCESSARG )
                    opt_set_charp(str, (unsigned __int8 **)opt->u.carg);
                }
                else if ( arr_val->type == JSON_OBJECT )
                {
                  err = parse_config(arr_val, 0);
                }
                if ( err )
                  break;
              }
            }
            else
            {
              err = (opt->type & 1) != 0 && val->type == JSON_TRUE ? opt->cb(opt->u.tlen) : "Invalid value";
            }
            if ( err )
            {
              if ( !fileconf )
              {
                snprintf((char *)err_buf_15212, 0xC8u, "Parsing JSON option %s: %s", (const char *)p, (const char *)err);
                return err_buf_15212;
              }
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf((char *)tmp42, 0x800u, "Invalid config option %s: %s", (const char *)p, (const char *)err);
                applog(3, tmp42, 0);
              }
              fileconf_load = -1;
            }
          }
        }
      }
      free(name);
    }
  }
  val = json_object_get(config, "include");
  if ( !val || val->type != JSON_STRING )
    return 0;
  v4 = json_string_value(val);
  return load_config(v4, 0);
}
// 49EE4: conditional instruction was optimized away because %val.4!=0
// 49F46: conditional instruction was optimized away because %val.4!=0
// 49FB2: conditional instruction was optimized away because %arr_val.4!=0
// 4A022: conditional instruction was optimized away because %val.4!=0

//----- (0004A188) --------------------------------------------------------
unsigned __int8 *__cdecl load_config(const unsigned __int8 *arg, void *unused)
{
  size_t v3; // r4
  json_error_t err; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 *json_error; // [sp+10Ch] [bp+104h]
  size_t siz; // [sp+110h] [bp+108h]
  json_t_0 *config; // [sp+114h] [bp+10Ch]

  if ( !cnfbuf )
    cnfbuf = (unsigned __int8 *)strdup((const char *)arg);
  if ( ++include_count > 10 )
    return "Too many levels of JSON includes (limit 10) or a loop";
  config = json_load_file(arg, 0, &err);
  if ( config && config->type == JSON_OBJECT )
  {
    config_loaded = 1;
    return parse_config(config, 1);
  }
  else
  {
    v3 = strlen((const char *)arg);
    siz = strlen((const char *)err.text) + v3 + 35;
    json_error = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___15243, 2100);
    snprintf((char *)json_error, siz, "JSON decode of file '%s' failed\n %s", (const char *)arg, (const char *)err.text);
    return json_error;
  }
}

//----- (0004A294) --------------------------------------------------------
unsigned __int8 *__cdecl set_default_config(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &default_config);
  return 0;
}

//----- (0004A2B4) --------------------------------------------------------
void load_default_config()
{
  cnfbuf = (unsigned __int8 *)cgmalloc(0x1000u, "cgminer.c", _func___15252, 2125);
  default_save_file(cnfbuf);
  if ( access((const char *)cnfbuf, 4) )
  {
    free(cnfbuf);
    cnfbuf = 0;
  }
  else
  {
    load_config(cnfbuf, 0);
  }
}

//----- (0004A33C) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_verusage_and_exit(const unsigned __int8 *extra)
{
  unsigned __int8 *v1; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", (const char *)packagename);
  v1 = opt_usage(opt_argv0, extra);
  printf("%s", (const char *)v1);
  fflush((FILE *)stdout);
  exit(0);
}
// AC42C: using guessed type int stdout;

//----- (0004A390) --------------------------------------------------------
void __cdecl calc_midstate(work *work)
{
  sha256_ctx ctx; // [sp+14h] [bp+Ch] BYREF
  unsigned __int8 data[64]; // [sp+BCh] [bp+B4h] BYREF
  uint32_t *data32; // [sp+FCh] [bp+F4h]

  data32 = (uint32_t *)data;
  flip64(data, work);
  sha256_init(&ctx);
  sha256_update(&ctx, data, 0x40u);
  cg_memcpy(work->midstate, ctx.h, 0x20u, "cgminer.c", _func___15286, 2232);
  endian_flip32(work->midstate, work->midstate);
}

//----- (0004A40C) --------------------------------------------------------
int total_work_inc()
{
  uint32_t v0; // r2
  int ret; // [sp+4h] [bp+4h]

  cg_wlock_1(&control_lock, "cgminer.c", _func___15291, 2241);
  v0 = total_work++;
  ret = v0;
  cg_wunlock_1(&control_lock, "cgminer.c", _func___15291, 2243);
  return ret;
}

//----- (0004A474) --------------------------------------------------------
work *make_work()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  work *work; // [sp+80Ch] [bp+804h]

  work = (work *)cgcalloc(1, 0x1C0u, "cgminer.c", _func___15296, 2250);
  if ( !work )
  {
    strcpy((char *)tmp42, "Failed to calloc work in make_work");
    applog(3, tmp42, 1);
    quit(1);
  }
  work->id = total_work_inc();
  return work;
}

//----- (0004A4FA) --------------------------------------------------------
void __cdecl clean_work(work *work)
{
  free(work->job_id);
  free(work->ntime);
  free(work->coinbase);
  free(work->nonce1);
  memset(work, 0, sizeof(work));
}

//----- (0004A546) --------------------------------------------------------
void __cdecl free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  work *work; // [sp+81Ch] [bp+814h]

  work = *workptr;
  if ( work )
  {
    clean_work(work);
    free(work);
    *workptr = 0;
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Free work called with NULL work from %s %s:%d",
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (0004A5FC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl decay_time(double *f, double fadd, double fsecs, double interval)
{
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double fprop; // [sp+28h] [bp+28h]

  if ( v5 > 0.0 )
  {
    exp(*(double *)&f);
    fprop = 1.0 - 1.0 / (v5 / v6);
    *f = *f + v4 / v5 * fprop;
    *f = *f / (fprop + 1.0);
  }
}
// 4A5FC: variables would overlap: r0.4 and r0.8

//----- (0004A69C) --------------------------------------------------------
unsigned int _total_staged()
{
  if ( staged_work )
    return staged_work->hh.tbl->num_items;
  else
    return 0;
}

//----- (0004A6D0) --------------------------------------------------------
void __cdecl suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits)
{
  double v4; // r0
  double v5; // r0
  double v6; // d7
  unsigned __int8 suffix[2]; // [sp+28h] [bp+10h] BYREF
  int ndigits; // [sp+2Ch] [bp+14h]
  uint64_t exa; // [sp+30h] [bp+18h]
  uint64_t peta; // [sp+38h] [bp+20h]
  uint64_t tera; // [sp+40h] [bp+28h]
  uint64_t giga; // [sp+48h] [bp+30h]
  uint64_t mega; // [sp+50h] [bp+38h]
  uint64_t kilo; // [sp+58h] [bp+40h]
  double dkilo; // [sp+60h] [bp+48h]
  bool decimal; // [sp+6Fh] [bp+57h]
  double dval; // [sp+70h] [bp+58h]

  dkilo = 1000.0;
  kilo = 1000LL;
  LODWORD(mega) = &calc_nonce_info.chain_asic_core_nonce_num[5][48][190];
  HIDWORD(mega) = 0;
  giga = 1000000000LL;
  tera = 1000000000000LL;
  peta = 1000000000000000LL;
  exa = 1000000000000000000LL;
  *(_WORD *)suffix = 0;
  decimal = 1;
  if ( val < 0xDE0B6B3A7640000LL )
  {
    if ( val < peta )
    {
      if ( val < tera )
      {
        if ( val < giga )
        {
          if ( val < mega )
          {
            v4 = (double)val;
            if ( val >= kilo )
            {
              dval = (double)val / dkilo;
              strcpy((char *)suffix, "K");
            }
            else
            {
              dval = (double)val;
              decimal = 0;
            }
          }
          else
          {
            v4 = (double)(val / kilo);
            dval = v4 / dkilo;
            strcpy((char *)suffix, "M");
          }
        }
        else
        {
          v4 = (double)(val / mega);
          dval = v4 / dkilo;
          strcpy((char *)suffix, "G");
        }
      }
      else
      {
        v4 = (double)(val / giga);
        dval = v4 / dkilo;
        strcpy((char *)suffix, "T");
      }
    }
    else
    {
      v4 = (double)(val / tera);
      dval = v4 / dkilo;
      strcpy((char *)suffix, "P");
    }
  }
  else
  {
    v4 = (double)(val / peta);
    dval = v4 / dkilo;
    strcpy((char *)suffix, "E");
  }
  if ( sigdigits )
  {
    if ( dval <= 0.0 )
    {
      v6 = 0.0;
    }
    else
    {
      v5 = log10(v4);
      floor(v5);
      v6 = dval;
    }
    ndigits = (int)((double)(sigdigits - 1) - v6);
    snprintf((char *)buf, bufsiz, "%*.*f%s", sigdigits + 1, ndigits, dval, (const char *)suffix);
  }
  else if ( decimal )
  {
    snprintf((char *)buf, bufsiz, "%.3g%s", dval, (const char *)suffix);
  }
  else
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)dval, (const char *)suffix);
  }
}

//----- (0004A9C8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl cgpu_runtime(cgpu_info *cgpu)
{
  double result; // r0
  cgpu_info *cgpua; // [sp+4h] [bp+4h]
  timeval now; // [sp+8h] [bp+8h] BYREF
  double dev_runtime; // [sp+10h] [bp+10h]

  cgpua = cgpu;
  if ( cgpu->dev_start_tv.tv_sec )
  {
    cgtime(&now);
    *(double *)&cgpu = tdiff(&now, &cgpua->dev_start_tv);
  }
  else
  {
    dev_runtime = total_secs;
  }
  LODWORD(result) = cgpu;
  return result;
}
// 4A9C8: variables would overlap: r0.4 and r0.8
// 4A9C8: bad return variable

//----- (0004AA40) --------------------------------------------------------
void __cdecl get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  double v3; // d0
  unsigned __int8 tmp13[64]; // [sp+38h] [bp+10h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+78h] [bp+50h] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+878h] [bp+850h] BYREF
  unsigned __int8 displayed_hashes[16]; // [sp+888h] [bp+860h] BYREF
  size_t len13; // [sp+898h] [bp+870h]
  size_t buflen; // [sp+89Ch] [bp+874h]
  uint64_t dr64; // [sp+8A0h] [bp+878h]
  uint64_t dh64; // [sp+8A8h] [bp+880h]
  double wu; // [sp+8B0h] [bp+888h]
  double dev_runtime; // [sp+8B8h] [bp+890h]

  cgpu_runtime(cgpu);
  dev_runtime = v3;
  wu = (double)cgpu->diff1 / v3 * 60.0;
  dh64 = (unsigned __int64)(cgpu->total_mhashes / v3 * 1000000.0);
  dr64 = (unsigned __int64)(cgpu->rolling * 1000000.0);
  suffix_string(dh64, displayed_hashes, 0x10u, 4);
  suffix_string(dr64, displayed_rolling, 0x10u, 4);
  snprintf((char *)buf, bufsiz, "%s%d ", (const char *)cgpu->drv->name, cgpu->device_id);
  cgpu->drv->get_statline_before(buf, bufsiz, cgpu);
  buflen = strlen((const char *)buf);
  snprintf(
    (char *)tmp13,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    opt_log_interval,
    (const char *)displayed_rolling,
    (const char *)displayed_hashes,
    cgpu->diff_accepted,
    cgpu->diff_rejected,
    cgpu->hw_errors,
    wu);
  len13 = strlen((const char *)tmp13);
  if ( bufsiz <= len13 + buflen )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "tailsprintf buffer overflow in %s %s line %d",
      "cgminer.c",
      (const char *)_func___15389,
      3093);
    applog(3, tmp42, 1);
    quit(1);
  }
  strcat((char *)buf, (const char *)tmp13);
  cgpu->drv->get_statline(buf, bufsiz, cgpu);
}
// 4AA64: variable 'v3' is possibly undefined

//----- (0004AC70) --------------------------------------------------------
int shared_strategy()
{
  return pool_strategy_0 == POOL_LOADBALANCE || pool_strategy_0 == POOL_BALANCE;
}

//----- (0004ACA6) --------------------------------------------------------
void __cdecl enable_pool(pool *pool)
{
  if ( pool->enabled != POOL_ENABLED )
  {
    ++enabled_pools;
    pool->enabled = POOL_ENABLED;
  }
}

//----- (0004ACDE) --------------------------------------------------------
void __cdecl reject_pool(pool *pool)
{
  if ( pool->enabled == POOL_ENABLED )
    --enabled_pools;
  pool->enabled = POOL_REJECTING;
}

//----- (0004AD18) --------------------------------------------------------
void __cdecl share_result(
        json_t_0 *val,
        json_t_0 *res,
        json_t_0 *err,
        const work *work,
        unsigned __int8 *hashshow,
        bool resubmit,
        unsigned __int8 *worktime)
{
  const char *v7; // r3
  const char *v8; // r3
  const char *v9; // r3
  unsigned __int8 reason[32]; // [sp+30h] [bp+18h] BYREF
  unsigned __int8 disposition[36]; // [sp+50h] [bp+38h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+74h] [bp+5Ch] BYREF
  unsigned __int8 where[20]; // [sp+874h] [bp+85Ch] BYREF
  double utility; // [sp+888h] [bp+870h]
  const unsigned __int8 *reasontmp; // [sp+894h] [bp+87Ch]
  const unsigned __int8 *s; // [sp+898h] [bp+880h]
  unsigned __int8 *reason_str; // [sp+89Ch] [bp+884h]
  json_t_0 *reason_val; // [sp+8A0h] [bp+888h]
  cgpu_info *cgpu; // [sp+8A4h] [bp+88Ch]
  pool *pool; // [sp+8A8h] [bp+890h]
  size_t reasonLen; // [sp+8ACh] [bp+894h]

  pool = work->pool;
  cgpu = get_thr_cgpu(work->thr_id);
  if ( res && res->type == JSON_TRUE || work->gbt && res && res->type == JSON_NULL )
  {
    mutex_lock_1(&stats_lock, "cgminer.c", _func___15412, 3503);
    ++cgpu->accepted;
    ++total_accepted;
    ++pool->accepted;
    cgpu->diff_accepted = cgpu->diff_accepted + work->work_difficulty;
    total_diff_accepted = work->work_difficulty + total_diff_accepted;
    pool->diff_accepted = pool->diff_accepted + work->work_difficulty;
    mutex_unlock_1(&stats_lock, "cgminer.c", _func___15412, 3513);
    pool->seq_rejects = 0;
    cgpu->last_share_pool = pool->pool_no;
    cgpu->last_share_pool_time = time(0);
    cgpu->last_share_diff = work->work_difficulty;
    pool->last_share_time = cgpu->last_share_pool_time;
    pool->last_share_diff = work->work_difficulty;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "PROOF OF WORK RESULT: true (yay!!!)");
      applog(7, tmp42, 0);
    }
    if ( !opt_quiet && !opt_realquiet )
    {
      if ( total_pools <= 1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          if ( resubmit )
            v8 = "(resubmit)";
          else
            v8 = byte_8A828;
          snprintf(
            (char *)tmp42,
            0x800u,
            "Accepted %s %s %d %s%s",
            (const char *)hashshow,
            (const char *)cgpu->drv->name,
            cgpu->device_id,
            v8,
            (const char *)worktime);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( resubmit )
          v7 = "(resubmit)";
        else
          v7 = byte_8A828;
        snprintf(
          (char *)tmp42,
          0x800u,
          "Accepted %s %s %d pool %d %s%s",
          (const char *)hashshow,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          work->pool->pool_no,
          v7,
          (const char *)worktime);
        applog(5, tmp42, 0);
      }
    }
    sharelog("accept", work);
    if ( opt_shares && (double)opt_shares <= total_diff_accepted )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Successfully mined %d accepted shares as requested and exiting.", opt_shares);
        applog(4, tmp42, 0);
      }
      kill_work();
    }
    if ( pool->enabled == POOL_REJECTING )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Rejecting pool %d now accepting shares, re-enabling!", pool->pool_no);
        applog(4, tmp42, 0);
      }
      enable_pool(pool);
      switch_pools(0);
    }
    if ( work->block )
      restart_threads();
  }
  else
  {
    mutex_lock_1(&stats_lock, "cgminer.c", _func___15412, 3566);
    ++cgpu->rejected;
    ++total_rejected;
    ++pool->rejected;
    cgpu->diff_rejected = cgpu->diff_rejected + work->work_difficulty;
    total_diff_rejected = work->work_difficulty + total_diff_rejected;
    pool->diff_rejected = pool->diff_rejected + work->work_difficulty;
    ++pool->seq_rejects;
    mutex_unlock_1(&stats_lock, "cgminer.c", _func___15412, 3574);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "PROOF OF WORK RESULT: false (booooo)");
      applog(7, tmp42, 0);
    }
    if ( !opt_quiet && !opt_realquiet )
    {
      strcpy((char *)disposition, "reject");
      memset(&disposition[7], 0, 0x1Du);
      reason[0] = 0;
      if ( total_pools <= 1 )
        where[0] = 0;
      else
        snprintf((char *)where, 0x14u, "pool %d", work->pool->pool_no);
      if ( !work->gbt )
        res = json_object_get(val, "reject-reason");
      if ( res )
      {
        reasontmp = json_string_value(res);
        reasonLen = strlen((const char *)reasontmp);
        if ( reasonLen > 0x1C )
          reasonLen = 28;
        qmemcpy(reason, " (", 2);
        cg_memcpy(&reason[2], reasontmp, reasonLen, "cgminer.c", _func___15412, 3614);
        reason[reasonLen + 2] = 41;
        reason[reasonLen + 3] = 0;
        cg_memcpy(&disposition[7], reasontmp, reasonLen, "cgminer.c", _func___15412, 3619);
        disposition[6] = 58;
        disposition[reasonLen + 7] = 0;
      }
      else if ( work->stratum && err )
      {
        if ( err->type == JSON_ARRAY )
        {
          reason_val = json_array_get(err, 1u);
          if ( reason_val && reason_val->type == JSON_STRING )
          {
            reason_str = (unsigned __int8 *)json_string_value(reason_val);
            snprintf((char *)reason, 0x1Fu, " (%s)", (const char *)reason_str);
          }
        }
        else if ( err->type == JSON_STRING )
        {
          s = json_string_value(err);
          snprintf((char *)reason, 0x1Fu, " (%s)", (const char *)s);
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( resubmit )
          v9 = "(resubmit)";
        else
          v9 = byte_8A828;
        snprintf(
          (char *)tmp42,
          0x800u,
          "Rejected %s %s %d %s%s %s%s",
          (const char *)hashshow,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          (const char *)where,
          (const char *)reason,
          v9,
          (const char *)worktime);
        applog(5, tmp42, 0);
      }
      sharelog(disposition, work);
    }
    if ( pool->seq_rejects > 10 && !work->stale && opt_disable_pool && enabled_pools > 1 )
    {
      utility = (double)total_accepted / total_secs * 60.0;
      if ( (double)pool->seq_rejects > utility * 3.0 && enabled_pools > 1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Pool %d rejected %d sequential shares, disabling!",
            pool->pool_no,
            pool->seq_rejects);
          applog(4, tmp42, 0);
        }
        reject_pool(pool);
        if ( pool == current_pool() )
          switch_pools(0);
        pool->seq_rejects = 0;
      }
    }
  }
}
// 4B4C4: conditional instruction was optimized away because %err.4!=0
// 4B528: conditional instruction was optimized away because %err.4!=0

//----- (0004B740) --------------------------------------------------------
void __cdecl show_hash(work *work, unsigned __int8 *hashshow)
{
  double work_difficulty; // d0
  int v3; // r1
  const char *v4; // r3
  unsigned __int8 diffdisp[16]; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 rhash[32]; // [sp+30h] [bp+18h] BYREF
  uint64_t uintdiff; // [sp+50h] [bp+38h]
  unsigned int h32; // [sp+5Ch] [bp+44h]
  uint32_t *hash32; // [sp+60h] [bp+48h]
  int ofs; // [sp+64h] [bp+4Ch]

  swab256_0(rhash, work->hash);
  for ( ofs = 0; ofs <= 28 && !rhash[ofs]; ++ofs )
    ;
  hash32 = (uint32_t *)&rhash[ofs];
  h32 = _bswap_32_0(*(_DWORD *)&rhash[ofs]);
  work_difficulty = work->work_difficulty;
  round(h32, v3);
  uintdiff = (unsigned __int64)work_difficulty;
  suffix_string(work->share_diff, diffdisp, 0x10u, 0);
  if ( work->block )
    v4 = " BLOCK!";
  else
    v4 = byte_8A828;
  snprintf((char *)hashshow, 0x40u, "%08lx Diff %s/%llu%s", h32, (const char *)diffdisp, uintdiff, v4);
}
// 4B7A0: variable 'v3' is possibly undefined
// 1230C: using guessed type int __fastcall round(_DWORD, _DWORD);

//----- (0004B812) --------------------------------------------------------
bool __cdecl pool_unusable(pool *pool)
{
  if ( pool->idle )
    return 1;
  if ( pool->enabled == POOL_ENABLED )
    return pool->has_stratum && (!pool->stratum_active || !pool->stratum_notify);
  return 1;
}

//----- (0004B870) --------------------------------------------------------
pool *__cdecl select_balanced(pool *cp)
{
  pool *pool; // [sp+8h] [bp+8h]
  pool *ret; // [sp+Ch] [bp+Ch]
  int lowest; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  lowest = cp->shares;
  ret = cp;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    if ( !pool_unusable(pool) && lowest > pool->shares )
    {
      lowest = pool->shares;
      ret = pool;
    }
  }
  ++ret->shares;
  return ret;
}

//----- (0004B8F4) --------------------------------------------------------
pool *select_pool()
{
  int quota_used; // r3
  pool *v1; // r0
  int v2; // r2
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  pool *tp_0; // [sp+804h] [bp+804h]
  pool *tp; // [sp+808h] [bp+808h]
  pool *cp; // [sp+80Ch] [bp+80Ch]
  int i; // [sp+810h] [bp+810h]
  int tested; // [sp+814h] [bp+814h]
  bool avail; // [sp+81Bh] [bp+81Bh]
  pool *pool; // [sp+81Ch] [bp+81Ch]

  avail = 0;
  cp = current_pool();
  if ( pool_strategy_0 == POOL_BALANCE )
  {
    pool = select_balanced(cp);
  }
  else if ( pool_strategy_0 == POOL_LOADBALANCE )
  {
    pool = 0;
    for ( i = 0; i < total_pools; ++i )
    {
      tp = pools[i];
      if ( tp->quota_used < tp->quota_gcd )
      {
        avail = 1;
        break;
      }
    }
    if ( !avail )
    {
      for ( i = 0; i < total_pools; ++i )
        pools[i]->quota_used = 0;
      if ( ++rotating_pool_15462 >= total_pools )
        rotating_pool_15462 = 0;
    }
    tested = 0;
    while ( !pool )
    {
      v2 = tested++;
      if ( v2 >= total_pools )
        break;
      pool = pools[rotating_pool_15462];
      quota_used = pool->quota_used;
      pool->quota_used = quota_used + 1;
      if ( quota_used < pool->quota_gcd )
      {
        if ( !pool_unusable(pool) )
          break;
        if ( opt_fail_only )
        {
          v1 = priority_pool(0);
          --v1->quota_used;
        }
      }
      pool = 0;
      if ( ++rotating_pool_15462 >= total_pools )
        rotating_pool_15462 = 0;
    }
    if ( !pool )
    {
      for ( i = 0; i < total_pools; ++i )
      {
        tp_0 = priority_pool(i);
        if ( !pool_unusable(tp_0) )
        {
          pool = tp_0;
          break;
        }
      }
    }
    if ( !pool )
      pool = cp;
  }
  else
  {
    pool = cp;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Selecting pool %d for work", pool->pool_no);
    applog(7, tmp42, 0);
  }
  return pool;
}

//----- (0004BBC8) --------------------------------------------------------
double __cdecl le256todouble(const void *target)
{
  _uint64_identity_0(*((_QWORD *)target + 3));
  _uint64_identity_0(*((_QWORD *)target + 2));
  _uint64_identity_0(*((_QWORD *)target + 1));
  return (double)_uint64_identity_0(*(_QWORD *)target);
}

//----- (0004BCC8) --------------------------------------------------------
double __cdecl diff_from_target(void *target)
{
  return le256todouble(target);
}

//----- (0004BD28) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl calc_diff(work *work, double known)
{
  double v2; // d0
  int v3; // r1
  work *worka; // [sp+14h] [bp+Ch]
  double difficulty; // [sp+20h] [bp+18h]
  cgminer_pool_stats *pool_stats; // [sp+2Ch] [bp+24h]

  worka = work;
  pool_stats = &work->pool->cgminer_pool_stats;
  if ( v2 == 0.0 )
  {
    *(double *)&work = diff_from_target(work->target);
    worka->work_difficulty = v2;
  }
  else
  {
    work->work_difficulty = v2;
  }
  difficulty = worka->work_difficulty;
  pool_stats->last_diff = difficulty;
  round(work, v3);
  suffix_string((unsigned __int64)difficulty, worka->pool->diff, 8u, 0);
  if ( difficulty == pool_stats->min_diff )
  {
    ++pool_stats->min_diff_count;
  }
  else if ( difficulty < pool_stats->min_diff || pool_stats->min_diff == 0.0 )
  {
    pool_stats->min_diff = difficulty;
    pool_stats->min_diff_count = 1;
  }
  if ( difficulty == pool_stats->max_diff )
  {
    ++pool_stats->max_diff_count;
  }
  else if ( difficulty > pool_stats->max_diff )
  {
    pool_stats->max_diff = difficulty;
    pool_stats->max_diff_count = 1;
  }
}
// 4BD28: variables would overlap: r0.4 and r0.8
// 1230C: using guessed type int __fastcall round(_DWORD, _DWORD);

//----- (0004BE58) --------------------------------------------------------
void __cdecl get_benchmark_work(work *work)
{
  work->work_difficulty = 0x4040000000000000LL;
  cg_memcpy(work->target, bench_target, 0x20u, "cgminer.c", _func___15511, 4246);
  work->drv_rolllimit = 0;
  work->mandatory = 1;
  work->pool = *pools;
  cgtime(&work->tv_getwork);
  copy_time(&work->tv_getwork_reply, &work->tv_getwork);
  work->getwork_mode = 66;
}

//----- (0004BEF0) --------------------------------------------------------
void __cdecl benchfile_dspwork(work *work, uint32_t nonce)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 buf[1024]; // [sp+810h] [bp+808h] BYREF
  int i; // [sp+C10h] [bp+C08h]
  uint32_t dn; // [sp+C14h] [bp+C0Ch]

  dn = 0;
  for ( i = 0; i <= 3; ++i )
  {
    dn = (unsigned __int8)nonce + (dn << 8);
    nonce >>= 8;
  }
  _bin2hex(buf, work->data, 0x80u);
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", dn, dn, (const char *)buf);
    applog(3, tmp42, 0);
  }
}

//----- (0004BFBA) --------------------------------------------------------
bool __cdecl benchfile_get_work(work *work)
{
  unsigned __int8 *v1; // r0
  unsigned __int8 *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 *commas[5]; // [sp+818h] [bp+808h]
  unsigned __int8 item[1024]; // [sp+82Ch] [bp+81Ch] BYREF
  unsigned __int8 buf[1024]; // [sp+C2Ch] [bp+C1Ch] BYREF
  int nonce_time; // [sp+102Ch] [bp+101Ch]
  int len; // [sp+1030h] [bp+1020h]
  int j; // [sp+1034h] [bp+1024h]
  int i; // [sp+1038h] [bp+1028h]
  bool got; // [sp+103Fh] [bp+102Fh]

  got = 0;
  if ( !benchfile_in )
  {
    if ( !opt_benchfile )
    {
      strcpy((char *)tmp42, "BENCHFILE Invalid benchfile NULL");
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_in = fopen((const char *)opt_benchfile, "r");
    if ( !benchfile_in )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to open benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_line = 0;
    if ( !fgets((char *)buf, 1024, benchfile_in) )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to read benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    got = 1;
    benchfile_work = 0;
  }
  if ( got || fgets((char *)buf, 1024, benchfile_in) )
  {
    do
    {
      ++benchfile_line;
      if ( buf[0] && buf[0] != 35 && buf[0] != 47 )
      {
        commas[0] = buf;
        for ( i = 1; i <= 4; ++i )
        {
          v1 = (unsigned __int8 *)strchr((const char *)commas[i - 1], 44);
          commas[i] = v1;
          if ( !commas[i] )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
              benchfile_line,
              i,
              5);
            applog(3, tmp42, 1);
            quit(1);
          }
          len = commas[i] - commas[i - 1];
          if ( benchfile_data[i - 1].length && len != benchfile_data[i - 1].length )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
              benchfile_line,
              i,
              (const char *)benchfile_data[i - 1].name,
              len,
              benchfile_data[i - 1].length);
            applog(3, tmp42, 1);
            quit(1);
          }
          v2 = commas[i];
          commas[i] = v2 + 1;
          *v2 = 0;
        }
        len = strlen((const char *)commas[4]);
        if ( len < benchfile_data[4].length )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
            benchfile_line,
            5,
            (const char *)benchfile_data[4].name,
            len,
            benchfile_data[4].length);
          applog(3, tmp42, 1);
          quit(1);
        }
        sprintf((char *)item, "0000000%c", *commas[0]);
        j = strlen((const char *)item);
        for ( i = benchfile_data[2].length - 8; i >= 0; i -= 8 )
        {
          sprintf((char *)&item[j], "%.8s", (const char *)&commas[2][i]);
          j += 8;
        }
        for ( i = benchfile_data[1].length - 8; i >= 0; i -= 8 )
        {
          sprintf((char *)&item[j], "%.8s", (const char *)&commas[1][i]);
          j += 8;
        }
        nonce_time = atol((const char *)commas[4]);
        sprintf((char *)&item[j], "%08lx", nonce_time);
        j += 8;
        strcpy((char *)&item[j], (const char *)commas[3]);
        j += benchfile_data[3].length;
        memset(work, 0, sizeof(work));
        hex2bin(work->data, item, j >> 1);
        calc_midstate(work);
        ++benchfile_work;
        return 1;
      }
    }
    while ( fgets((char *)buf, 1024, benchfile_in) );
    if ( !benchfile_work )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE No work in benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  else if ( !benchfile_work )
  {
    snprintf((char *)tmp42, 0x800u, "BENCHFILE No work in benchfile '%s'", (const char *)opt_benchfile);
    applog(3, tmp42, 1);
    quit(1);
  }
  fclose(benchfile_in);
  benchfile_in = 0;
  return benchfile_get_work(work);
}

//----- (0004C710) --------------------------------------------------------
void __cdecl get_benchfile_work(work *work)
{
  double v1; // r2

  benchfile_get_work(work);
  work->mandatory = 1;
  work->pool = *pools;
  cgtime(&work->tv_getwork);
  copy_time(&work->tv_getwork_reply, &work->tv_getwork);
  HIDWORD(v1) = work;
  LODWORD(v1) = 66;
  work->getwork_mode = 66;
  calc_diff(work, v1);
}

//----- (0004C780) --------------------------------------------------------
void __cdecl kill_timeout(thr_info *thr)
{
  cg_completion_timeout(thr_info_cancel, thr, 1000);
}

//----- (0004C7A2) --------------------------------------------------------
void kill_mining()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  thr_info *thr; // [sp+804h] [bp+804h]
  pthread_t *pth; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Killing off mining threads");
    applog(7, tmp42, 1);
  }
  for ( i = 0; i < mining_threads; ++i )
  {
    pth = 0;
    thr = get_thread(i);
    if ( thr && thr->pth )
      pth = &thr->pth;
    thr_info_cancel(thr);
    if ( pth )
    {
      if ( *pth )
        pthread_join(*pth, 0);
    }
  }
}

//----- (0004C892) --------------------------------------------------------
void _kill_work()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  cgpu_info *cgpu; // [sp+804h] [bp+804h]
  thr_info *thr; // [sp+808h] [bp+808h]
  int i; // [sp+80Ch] [bp+80Ch]

  if ( successful_connect )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Received kill message");
      applog(6, tmp42, 1);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off watchpool thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[watchpool_thr_id];
    kill_timeout(thr);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off watchdog thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[watchdog_thr_id];
    kill_timeout(thr);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Shutting down mining threads");
      applog(7, tmp42, 1);
    }
    for ( i = 0; i < mining_threads; ++i )
    {
      thr = get_thread(i);
      if ( thr )
      {
        cgpu = thr->cgpu;
        if ( cgpu )
          cgpu->shutdown = 1;
      }
    }
    sleep(1u);
    cg_completion_timeout(kill_mining, 0, 3000);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off API thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[api_thr_id];
    kill_timeout(thr);
  }
}

//----- (0004CB6E) --------------------------------------------------------
void __noreturn kill_work()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF

  cg_completion_timeout(_kill_work, 0, 5000);
  strcpy((char *)tmp42, "Shutdown signal received.");
  applog(3, tmp42, 1);
  quit(0);
}

//----- (0004CBBE) --------------------------------------------------------
void app_restart()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Attempting to restart %s", (const char *)packagename);
    applog(4, tmp42, 0);
  }
  cg_completion_timeout(_kill_work, 0, 5000);
  clean_up(1);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  execv((const char *)*initial_args, (char *const *)initial_args);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Failed to restart application");
    applog(4, tmp42, 0);
  }
}

//----- (0004CCD2) --------------------------------------------------------
void __cdecl __noreturn sighandler(int sig)
{
  sigaction_0(15, &termhandler, 0);
  sigaction_0(2, &inthandler, 0);
  sigaction_0(6, &abrthandler, 0);
  kill_work();
}

//----- (0004CD16) --------------------------------------------------------
void *__cdecl submit_work_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0004CD34) --------------------------------------------------------
unsigned __int8 *__cdecl offset_ntime(const unsigned __int8 *ntime, int noffset)
{
  unsigned int v2; // r0
  unsigned __int8 bin[4]; // [sp+Ch] [bp+Ch] BYREF
  uint32_t h32; // [sp+10h] [bp+10h]
  uint32_t *be32; // [sp+14h] [bp+14h]

  be32 = (uint32_t *)bin;
  hex2bin(bin, ntime, 4u);
  h32 = noffset + _bswap_32_0(*be32);
  v2 = _bswap_32_0(h32);
  *be32 = v2;
  return bin2hex(bin, 4u);
}

//----- (0004CD86) --------------------------------------------------------
void __cdecl copy_work(work *work, const work *base_work, int noffset)
{
  unsigned int ntime; // [sp+1Ch] [bp+14h]
  unsigned int ntime_0; // [sp+24h] [bp+1Ch]
  uint32_t id; // [sp+2Ch] [bp+24h]

  id = work->id;
  clean_work(work);
  cg_memcpy(work, base_work, 0x1C0u, "cgminer.c", _func___15634, 4932);
  work->id = id;
  if ( base_work->job_id )
    work->job_id = (unsigned __int8 *)strdup((const char *)base_work->job_id);
  if ( base_work->nonce1 )
    work->nonce1 = (unsigned __int8 *)strdup((const char *)base_work->nonce1);
  if ( base_work->ntime )
  {
    if ( noffset )
    {
      ntime = noffset + _bswap_32_0(*(_DWORD *)&work->data[68]);
      *(_DWORD *)&work->data[68] = _bswap_32_0(ntime);
      work->ntime = offset_ntime(base_work->ntime, noffset);
    }
    else
    {
      work->ntime = (unsigned __int8 *)strdup((const char *)base_work->ntime);
    }
  }
  else if ( noffset )
  {
    ntime_0 = noffset + _bswap_32_0(*(_DWORD *)&work->data[68]);
    *(_DWORD *)&work->data[68] = _bswap_32_0(ntime_0);
  }
  if ( base_work->coinbase )
    work->coinbase = (unsigned __int8 *)strdup((const char *)base_work->coinbase);
  work->version = base_work->version;
}

//----- (0004CED2) --------------------------------------------------------
work *__cdecl copy_work_noffset(work *base_work, int noffset)
{
  work *work; // [sp+Ch] [bp+Ch]

  work = make_work();
  copy_work(work, base_work, noffset);
  return work;
}

//----- (0004CEF6) --------------------------------------------------------
void __cdecl pool_died(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  if ( !pool_tset(pool, &pool->idle) )
  {
    cgtime(&pool->tv_idle);
    if ( pool == current_pool() )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d %s not responding!", pool->pool_no, (const char *)pool->rpc_url);
        applog(4, tmp42, 0);
      }
      switch_pools(0);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s failed to return work", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
}

//----- (0004D008) --------------------------------------------------------
bool __cdecl stale_work(work *work, bool share)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  timeval now; // [sp+808h] [bp+808h] BYREF
  int getwork_delay; // [sp+810h] [bp+810h]
  pool *pool; // [sp+814h] [bp+814h]
  bool same_job; // [sp+81Bh] [bp+81Bh]
  time_t work_expiry; // [sp+81Ch] [bp+81Ch]

  if ( opt_benchmark || opt_benchfile )
    return 0;
  if ( work->work_block != work_block )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to block mismatch");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  if ( work->rolltime <= opt_scantime )
    work_expiry = opt_expiry;
  else
    work_expiry = work->rolltime;
  pool = work->pool;
  if ( share || !pool->has_stratum )
    goto LABEL_33;
  if ( !pool->stratum_active || !pool->stratum_notify )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to stratum inactive");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  same_job = 1;
  cg_rlock_0(&pool->data_lock, "cgminer.c", _func___15665, 5070);
  if ( strcmp((const char *)work->job_id, (const char *)pool->swork.job_id) )
    same_job = 0;
  cg_runlock_0(&pool->data_lock, "cgminer.c", _func___15665, 5077);
  if ( !same_job )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to stratum job_id mismatch");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  else
  {
LABEL_33:
    getwork_delay = (int)(pool->cgminer_pool_stats.getwork_wait_rolling * 5.0 + 1.0);
    work_expiry -= getwork_delay;
    if ( work_expiry <= 4 )
      work_expiry = 5;
    cgtime(&now);
    if ( work_expiry > now.tv_sec - work->tv_staged.tv_sec )
    {
      if ( !opt_fail_only
        || share
        || pool == current_pool()
        || work->mandatory
        || pool_strategy_0 == POOL_LOADBALANCE
        || pool_strategy_0 == POOL_BALANCE )
      {
        return 0;
      }
      else
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Work stale due to fail only pool mismatch");
          applog(7, tmp42, 0);
        }
        return 1;
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Work stale due to expiry");
        applog(7, tmp42, 0);
      }
      return 1;
    }
  }
}

//----- (0004D420) --------------------------------------------------------
uint64_t __cdecl share_diff(const work *work)
{
  double v1; // d0
  double v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  uint64_t ret; // [sp+810h] [bp+808h]
  double d64; // [sp+818h] [bp+810h]
  double s64; // [sp+820h] [bp+818h]
  bool new_best; // [sp+82Fh] [bp+827h]

  new_best = 0;
  d64 = 2.69595353e67;
  v2 = le256todouble(work->hash);
  s64 = v1;
  if ( v1 == 0.0 )
    s64 = 0.0;
  round(LODWORD(v2), HIDWORD(v2));
  ret = (unsigned __int64)(d64 / s64);
  cg_wlock_1(&control_lock, "cgminer.c", _func___15676, 5131);
  if ( best_diff < ret )
  {
    new_best = 1;
    best_diff = ret;
    suffix_string(ret, best_share, 8u, 0);
  }
  if ( work->pool->best_diff < ret )
    work->pool->best_diff = ret;
  cg_wunlock_1(&control_lock, "cgminer.c", _func___15676, 5145);
  if ( new_best && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "New best share: %s", (const char *)best_share);
    applog(6, tmp42, 0);
  }
  return ret;
}
// 4D450: variable 'v1' is possibly undefined
// 1230C: using guessed type int __fastcall round(_DWORD, _DWORD);

//----- (0004D5E8) --------------------------------------------------------
void __cdecl regen_hash(work *work)
{
  unsigned __int8 hash1[32]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 swap[80]; // [sp+28h] [bp+28h] BYREF
  uint32_t *swap32; // [sp+78h] [bp+78h]
  uint32_t *data32; // [sp+7Ch] [bp+7Ch]

  data32 = (uint32_t *)work;
  swap32 = (uint32_t *)swap;
  flip80(swap, work);
  sha256(swap, 0x50u, hash1);
  sha256(hash1, 0x20u, work->hash);
}

//----- (0004D62C) --------------------------------------------------------
pool *__cdecl priority_pool(int choice)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  pool *pool; // [sp+80Ch] [bp+80Ch]
  int i; // [sp+810h] [bp+810h]
  pool *ret; // [sp+814h] [bp+814h]

  ret = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    if ( choice == pool->prio )
    {
      ret = pool;
      break;
    }
  }
  if ( ret )
    return ret;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "WTF No pool %d found!", choice);
    applog(3, tmp42, 0);
  }
  return pools[choice];
}

//----- (0004D710) --------------------------------------------------------
void __cdecl switch_pools(pool *selected)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  pool *pool; // [sp+814h] [bp+80Ch]
  pool *last_pool; // [sp+818h] [bp+810h]
  int next_pool; // [sp+81Ch] [bp+814h]
  int pool_no; // [sp+820h] [bp+818h]
  int i; // [sp+824h] [bp+81Ch]

  cg_wlock_1(&control_lock, "cgminer.c", _func___15711, 5224);
  last_pool = currentpool;
  pool_no = currentpool->pool_no;
  if ( selected && selected->prio )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( pool->prio < selected->prio )
        ++pool->prio;
    }
    selected->prio = 0;
  }
  switch ( pool_strategy_0 )
  {
    case POOL_FAILOVER:
    case POOL_LOADBALANCE:
    case POOL_BALANCE:
      for ( i = 0; i < total_pools; ++i )
      {
        pool = priority_pool(i);
        if ( !pool_unusable(pool) )
        {
          pool_no = pool->pool_no;
          goto LABEL_26;
        }
      }
      break;
    case POOL_ROUNDROBIN:
    case POOL_ROTATE:
      if ( selected && !selected->idle )
      {
        pool_no = selected->pool_no;
      }
      else
      {
        next_pool = pool_no;
        for ( i = 1; i < total_pools; ++i )
        {
          if ( ++next_pool >= total_pools )
            next_pool = 0;
          pool = pools[next_pool];
          if ( !pool_unusable(pool) )
          {
            pool_no = next_pool;
            goto LABEL_26;
          }
        }
      }
      break;
    default:
      break;
  }
LABEL_26:
  currentpool = pools[pool_no];
  pool = currentpool;
  cg_wunlock_1(&control_lock, "cgminer.c", _func___15711, 5305);
  if ( pool != last_pool && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Switching to pool %d %s", pool->pool_no, (const char *)pool->rpc_url);
      applog(4, tmp42, 0);
    }
    clear_pool_work(last_pool);
  }
  mutex_lock_1(&lp_lock, "cgminer.c", _func___15711, 5313);
  pthread_cond_broadcast(&lp_cond);
  mutex_unlock_1(&lp_lock, "cgminer.c", _func___15711, 5315);
}

//----- (0004DA24) --------------------------------------------------------
void __cdecl discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  work *work; // [sp+81Ch] [bp+814h]

  work = *workptr;
  if ( work )
  {
    if ( !work->clone && !work->rolls && !work->mined )
    {
      if ( work->pool )
      {
        ++work->pool->discarded_work;
        --work->pool->quota_used;
        --work->pool->works;
      }
      ++total_discarded;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Discarded work");
        applog(7, tmp42, 0);
      }
    }
    else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Discarded cloned or rolled work");
      applog(7, tmp42, 0);
    }
    free_work(workptr, file, func, line);
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Discard work called with NULL work from %s %s:%d",
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (0004DC26) --------------------------------------------------------
void wake_gws()
{
  mutex_lock_1(stgd_lock, "cgminer.c", _func___15744, 5349);
  pthread_cond_signal(&gws_cond);
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___15744, 5351);
}

//----- (0004DC7E) --------------------------------------------------------
void discard_stale()
{
  work *next; // r3
  UT_hash_bucket_0 *v1; // r3
  work *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  work *work; // [sp+804h] [bp+804h] BYREF
  unsigned int _hd_bkt; // [sp+808h] [bp+808h]
  UT_hash_handle *_hd_hh_del; // [sp+80Ch] [bp+80Ch]
  int stale; // [sp+810h] [bp+810h]
  work *tmp; // [sp+814h] [bp+814h]

  stale = 0;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___15751, 5359);
  work = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( stale_work(work, 0) )
    {
      if ( work->hh.prev || work->hh.next )
      {
        _hd_hh_del = &work->hh;
        if ( (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) == work )
          staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
        if ( work->hh.prev )
          *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
        else
          staged_work = (work *)work->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v1 = &staged_work->hh.tbl->buckets[_hd_bkt];
        --v1->count;
        if ( _hd_hh_del == staged_work->hh.tbl->buckets[_hd_bkt].hh_head )
          staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --staged_work->hh.tbl->num_items;
      }
      else
      {
        free(staged_work->hh.tbl->buckets);
        free(staged_work->hh.tbl);
        staged_work = 0;
      }
      discard_work(&work, "cgminer.c", _func___15751, 5366);
      ++stale;
    }
    work = tmp;
    if ( tmp )
      v2 = (work *)tmp->hh.next;
    else
      v2 = 0;
    tmp = v2;
  }
  pthread_cond_signal(&gws_cond);
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___15751, 5372);
  if ( stale && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Discarded %d stales that didn't match current hash", stale);
    applog(7, tmp42, 0);
  }
}

//----- (0004DFDE) --------------------------------------------------------
void *__cdecl restart_thread(void *arg)
{
  pthread_t v1; // r0
  cgpu_info *cgpu; // [sp+Ch] [bp+Ch]
  int mt; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  v1 = pthread_self();
  pthread_detach(v1);
  discard_stale();
  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___15774, 5425);
  mt = mining_threads;
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___15774, 5427);
  for ( i = 0; i < mt; ++i )
  {
    cgpu = mining_thr[i]->cgpu;
    if ( cgpu && cgpu->deven == DEV_ENABLED )
    {
      mining_thr[i]->work_restart = 1;
      flush_queue(cgpu);
      cgpu->drv->flush_work(cgpu);
    }
  }
  mutex_lock_1(&restart_lock, "cgminer.c", _func___15774, 5448);
  pthread_cond_broadcast(&restart_cond);
  mutex_unlock_1(&restart_lock, "cgminer.c", _func___15774, 5450);
  return 0;
}

//----- (0004E100) --------------------------------------------------------
void restart_threads()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  pthread_t rthread; // [sp+804h] [bp+804h] BYREF

  cgtime(&restart_tv_start);
  if ( pthread_create(&rthread, 0, (void *(*)(void *))restart_thread, 0) )
  {
    strcpy((char *)tmp42, "Failed to create restart thread");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0004E164) --------------------------------------------------------
void signal_work_update()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+804h] [bp+804h]

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    strcpy((char *)tmp42, "Work update message received");
    applog(6, tmp42, 0);
  }
  cgtime(&update_tv_start);
  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___15789, 5483);
  for ( i = 0; i < mining_threads; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, " %s set work_update true", (const char *)_FUNCTION___15791);
      applog(5, tmp42, 0);
    }
    mining_thr[i]->work_update = 1;
  }
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___15789, 5491);
}

//----- (0004E2A0) --------------------------------------------------------
void __cdecl set_curblock(const unsigned __int8 *hexstr, const unsigned __int8 *bedata)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  int ofs; // [sp+814h] [bp+80Ch]

  cg_wlock_1(&ch_lock, "cgminer.c", _func___15800, 5498);
  cgtime(&block_timeval);
  strcpy((char *)current_hash, (const char *)hexstr);
  cg_memcpy(current_block, bedata, 0x20u, "cgminer.c", _func___15800, 5501);
  get_timestamp(blocktime, 0x20u, &block_timeval);
  cg_wunlock_1(&ch_lock, "cgminer.c", _func___15800, 5503);
  for ( ofs = 0; ofs <= 56 && current_hash[ofs] == (unsigned __int8)a0_1[0]; ++ofs )
    ;
  strncpy((char *)prev_block, (const char *)&current_hash[ofs], 8u);
  prev_block[8] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "New block: %s... diff %s", (const char *)current_hash, (const char *)block_diff);
    applog(6, tmp42, 0);
  }
}

//----- (0004E41A) --------------------------------------------------------
int __cdecl block_sort(block *blocka, block *blockb)
{
  return blocka->block_no - blockb->block_no;
}

//----- (0004E43A) --------------------------------------------------------
void __cdecl set_blockdiff(const work *work)
{
  unsigned __int64 v1; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  double ddiff; // [sp+810h] [bp+808h]
  double numerator; // [sp+818h] [bp+810h]
  uint32_t diff32; // [sp+824h] [bp+81Ch]
  uint8_t pow; // [sp+82Bh] [bp+823h]
  int powdiff; // [sp+82Ch] [bp+824h]

  pow = work->data[72];
  powdiff = 8 * (29 - pow);
  if ( powdiff <= 7 )
    powdiff = 8;
  diff32 = _bswap_32_0(*(_DWORD *)&work->data[72]) & 0xFFFFFF;
  LODWORD(v1) = 0xFFFF << powdiff;
  HIDWORD(v1) = (0xFFFF << (powdiff - 32)) | (0xFFFFu >> (32 - powdiff));
  numerator = (double)v1;
  ddiff = (double)v1 / (double)diff32;
  if ( ddiff != current_diff )
  {
    suffix_string((unsigned __int64)ddiff, block_diff, 8u, 0);
    current_diff = ddiff;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Network diff set to %s", (const char *)block_diff);
      applog(5, tmp42, 0);
    }
  }
}

//----- (0004E590) --------------------------------------------------------
bool __cdecl block_exists(const unsigned __int8 *hexstr, const unsigned __int8 *bedata, const work *work)
{
  size_t v3; // r0
  int v4; // r2
  UT_hash_handle *v5; // r3
  UT_hash_handle *v6; // r3
  UT_hash_handle *v7; // r3
  UT_hash_handle *v8; // r3
  UT_hash_handle *v9; // r3
  char *v10; // r3
  char *v11; // r3
  UT_hash_bucket_0 *v12; // r3
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v14; // r3
  unsigned int v15; // r3
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  UT_hash_bucket_0 *_he_newbkt; // [sp+81Ch] [bp+814h]
  unsigned int _he_bkt; // [sp+820h] [bp+818h]
  UT_hash_handle *_he_hh_nxt; // [sp+824h] [bp+81Ch]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+828h] [bp+820h]
  unsigned int _ha_bkt; // [sp+82Ch] [bp+824h]
  unsigned int _hd_bkt; // [sp+830h] [bp+828h]
  UT_hash_handle *_hd_hh_del; // [sp+834h] [bp+82Ch]
  block *oldblock; // [sp+838h] [bp+830h]
  unsigned int _hf_bkt; // [sp+83Ch] [bp+834h]
  UT_hash_handle *_he_thh; // [sp+840h] [bp+838h]
  unsigned int _he_bkt_i; // [sp+844h] [bp+83Ch]
  const unsigned __int8 *_hj_key_0; // [sp+848h] [bp+840h]
  unsigned int _hj_k_0; // [sp+84Ch] [bp+844h]
  unsigned int _hj_j_0; // [sp+850h] [bp+848h]
  unsigned int _hj_i_0; // [sp+854h] [bp+84Ch]
  unsigned int _ha_hashv; // [sp+858h] [bp+850h]
  UT_hash_handle *_hs_tail; // [sp+85Ch] [bp+854h]
  UT_hash_handle *_hs_list; // [sp+860h] [bp+858h]
  UT_hash_handle *_hs_e; // [sp+864h] [bp+85Ch]
  UT_hash_handle *_hs_q; // [sp+868h] [bp+860h]
  UT_hash_handle *_hs_p; // [sp+86Ch] [bp+864h]
  unsigned int _hs_qsize; // [sp+870h] [bp+868h]
  unsigned int _hs_psize; // [sp+874h] [bp+86Ch]
  unsigned int _hs_insize; // [sp+878h] [bp+870h]
  unsigned int _hs_nmerges; // [sp+87Ch] [bp+874h]
  unsigned int _hs_looping; // [sp+880h] [bp+878h]
  unsigned int _hs_i; // [sp+884h] [bp+87Ch]
  const unsigned __int8 *_hj_key; // [sp+888h] [bp+880h]
  unsigned int _hj_k; // [sp+88Ch] [bp+884h]
  unsigned int _hj_j; // [sp+890h] [bp+888h]
  unsigned int _hj_i; // [sp+894h] [bp+88Ch]
  unsigned int _hf_hashv; // [sp+898h] [bp+890h]
  bool ret; // [sp+89Fh] [bp+897h]
  block *s; // [sp+8A0h] [bp+898h]
  int deleted_block; // [sp+8A4h] [bp+89Ch]

  deleted_block = 0;
  ret = 1;
  wr_lock_1(&blk_lock, "cgminer.c", _func___15826, 5553);
  _hj_key = hexstr;
  _hf_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)hexstr); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_i += (_hj_key[3] << 24) + *_hj_key + (_hj_key[1] << 8) + (_hj_key[2] << 16);
    _hj_j += (_hj_key[7] << 24) + _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16);
    _hf_hashv += (_hj_key[11] << 24) + _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16);
    _hj_i = (_hf_hashv >> 13) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 8) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 13) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_i = (_hf_hashv >> 12) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 16) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 5) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_i = (_hf_hashv >> 3) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 10) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 15) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_key += 12;
  }
  _hf_hashv += strlen((const char *)hexstr);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      goto LABEL_9;
    case 8u:
      goto LABEL_8;
    case 9u:
      goto LABEL_7;
    case 0xAu:
      goto LABEL_6;
    case 0xBu:
      _hf_hashv += _hj_key[10] << 24;
LABEL_6:
      _hf_hashv += _hj_key[9] << 16;
LABEL_7:
      _hf_hashv += _hj_key[8] << 8;
LABEL_8:
      _hj_j += _hj_key[7] << 24;
LABEL_9:
      _hj_j += _hj_key[6] << 16;
LABEL_10:
      _hj_j += _hj_key[5] << 8;
LABEL_11:
      _hj_j += _hj_key[4];
LABEL_12:
      _hj_i += _hj_key[3] << 24;
LABEL_13:
      _hj_i += _hj_key[2] << 16;
LABEL_14:
      _hj_i += _hj_key[1] << 8;
LABEL_15:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_i = (_hf_hashv >> 13) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 8) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 13) ^ (_hf_hashv - _hj_i - _hj_j);
  _hj_i = (_hf_hashv >> 12) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 16) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 5) ^ (_hf_hashv - _hj_i - _hj_j);
  _hj_i = (_hf_hashv >> 3) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 10) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 15) ^ (_hf_hashv - _hj_i - _hj_j);
  s = 0;
  if ( blocks )
  {
    _hf_bkt = (blocks->hh.tbl->num_buckets - 1) & _hf_hashv;
    if ( blocks->hh.tbl->buckets[_hf_bkt].hh_head )
      s = (block *)((char *)blocks->hh.tbl->buckets[_hf_bkt].hh_head - blocks->hh.tbl->hho);
    else
      s = 0;
    while ( s )
    {
      if ( _hf_hashv == s->hh.hashv && s->hh.keylen == strlen((const char *)hexstr) )
      {
        v3 = strlen((const char *)hexstr);
        if ( !memcmp(s->hh.key, hexstr, v3) )
          break;
      }
      if ( s->hh.hh_next )
        s = (block *)((char *)s->hh.hh_next - blocks->hh.tbl->hho);
      else
        s = 0;
    }
  }
  if ( !s )
  {
    s = (block *)cgcalloc(104, 1u, "cgminer.c", _func___15826, 5557);
    if ( !s )
    {
      strcpy((char *)tmp42, "block_exists OOM");
      applog(3, tmp42, 1);
      quit(1);
    }
    strcpy((char *)s, (const char *)hexstr);
    v4 = new_blocks++;
    s->block_no = v4;
    ret = 0;
    if ( blocks && blocks->hh.tbl->num_items > 3 )
    {
      if ( blocks )
      {
        _hs_insize = 1;
        _hs_looping = 1;
        _hs_list = &blocks->hh;
        while ( _hs_looping )
        {
          _hs_p = _hs_list;
          _hs_list = 0;
          _hs_tail = 0;
          _hs_nmerges = 0;
          while ( _hs_p )
          {
            ++_hs_nmerges;
            _hs_q = _hs_p;
            _hs_psize = 0;
            for ( _hs_i = 0; _hs_i < _hs_insize; ++_hs_i )
            {
              ++_hs_psize;
              v5 = _hs_q->next ? (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho) : 0;
              _hs_q = v5;
              if ( !v5 )
                break;
            }
            _hs_qsize = _hs_insize;
            while ( _hs_psize || _hs_qsize && _hs_q )
            {
              if ( _hs_psize )
              {
                if ( _hs_qsize && _hs_q )
                {
                  if ( block_sort(
                         (block *)((char *)_hs_p - blocks->hh.tbl->hho),
                         (block *)((char *)_hs_q - blocks->hh.tbl->hho)) > 0 )
                  {
                    _hs_e = _hs_q;
                    if ( _hs_q->next )
                      v9 = (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho);
                    else
                      v9 = 0;
                    _hs_q = v9;
                    --_hs_qsize;
                  }
                  else
                  {
                    _hs_e = _hs_p;
                    if ( _hs_p )
                    {
                      if ( _hs_p->next )
                        v8 = (UT_hash_handle *)((char *)_hs_p->next + blocks->hh.tbl->hho);
                      else
                        v8 = 0;
                      _hs_p = v8;
                    }
                    --_hs_psize;
                  }
                }
                else
                {
                  _hs_e = _hs_p;
                  if ( _hs_p )
                  {
                    if ( _hs_p->next )
                      v7 = (UT_hash_handle *)((char *)_hs_p->next + blocks->hh.tbl->hho);
                    else
                      v7 = 0;
                    _hs_p = v7;
                  }
                  --_hs_psize;
                }
              }
              else
              {
                _hs_e = _hs_q;
                if ( _hs_q->next )
                  v6 = (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho);
                else
                  v6 = 0;
                _hs_q = v6;
                --_hs_qsize;
              }
              if ( _hs_tail )
              {
                if ( _hs_e )
                  v10 = (char *)_hs_e - blocks->hh.tbl->hho;
                else
                  v10 = 0;
                _hs_tail->next = v10;
              }
              else
              {
                _hs_list = _hs_e;
              }
              if ( _hs_e )
              {
                if ( _hs_tail )
                  v11 = (char *)_hs_tail - blocks->hh.tbl->hho;
                else
                  v11 = 0;
                _hs_e->prev = v11;
              }
              _hs_tail = _hs_e;
            }
            _hs_p = _hs_q;
          }
          if ( _hs_tail )
            _hs_tail->next = 0;
          if ( _hs_nmerges <= 1 )
          {
            _hs_looping = 0;
            blocks->hh.tbl->tail = _hs_tail;
            blocks = (block *)((char *)_hs_list - blocks->hh.tbl->hho);
          }
          _hs_insize *= 2;
        }
      }
      oldblock = blocks;
      deleted_block = blocks->block_no;
      if ( blocks->hh.prev || oldblock->hh.next )
      {
        _hd_hh_del = &oldblock->hh;
        if ( oldblock == (block *)((char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho) )
          blocks->hh.tbl->tail = (UT_hash_handle *)((char *)oldblock->hh.prev + blocks->hh.tbl->hho);
        if ( oldblock->hh.prev )
          *(_DWORD *)((char *)oldblock->hh.prev + blocks->hh.tbl->hho + 8) = oldblock->hh.next;
        else
          blocks = (block *)oldblock->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + blocks->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (blocks->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v12 = &blocks->hh.tbl->buckets[_hd_bkt];
        --v12->count;
        if ( _hd_hh_del == blocks->hh.tbl->buckets[_hd_bkt].hh_head )
          blocks->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --blocks->hh.tbl->num_items;
      }
      else
      {
        free(blocks->hh.tbl->buckets);
        free(blocks->hh.tbl);
        blocks = 0;
      }
      free(oldblock);
    }
    _hj_key_0 = (const unsigned __int8 *)s;
    _ha_hashv = -17973521;
    _hj_j_0 = -1640531527;
    _hj_i_0 = -1640531527;
    for ( _hj_k_0 = strlen((const char *)s); _hj_k_0 > 0xB; _hj_k_0 -= 12 )
    {
      _hj_i_0 += (_hj_key_0[3] << 24) + *_hj_key_0 + (_hj_key_0[1] << 8) + (_hj_key_0[2] << 16);
      _hj_j_0 += (_hj_key_0[7] << 24) + _hj_key_0[4] + (_hj_key_0[5] << 8) + (_hj_key_0[6] << 16);
      _ha_hashv += (_hj_key_0[11] << 24) + _hj_key_0[8] + (_hj_key_0[9] << 8) + (_hj_key_0[10] << 16);
      _hj_i_0 = (_ha_hashv >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 8) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 13) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_i_0 = (_ha_hashv >> 12) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 16) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 5) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_i_0 = (_ha_hashv >> 3) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_key_0 += 12;
    }
    _ha_hashv += strlen((const char *)s);
    switch ( _hj_k_0 )
    {
      case 1u:
        goto LABEL_122;
      case 2u:
        goto LABEL_121;
      case 3u:
        goto LABEL_120;
      case 4u:
        goto LABEL_119;
      case 5u:
        goto LABEL_118;
      case 6u:
        goto LABEL_117;
      case 7u:
        goto LABEL_116;
      case 8u:
        goto LABEL_115;
      case 9u:
        goto LABEL_114;
      case 0xAu:
        goto LABEL_113;
      case 0xBu:
        _ha_hashv += _hj_key_0[10] << 24;
LABEL_113:
        _ha_hashv += _hj_key_0[9] << 16;
LABEL_114:
        _ha_hashv += _hj_key_0[8] << 8;
LABEL_115:
        _hj_j_0 += _hj_key_0[7] << 24;
LABEL_116:
        _hj_j_0 += _hj_key_0[6] << 16;
LABEL_117:
        _hj_j_0 += _hj_key_0[5] << 8;
LABEL_118:
        _hj_j_0 += _hj_key_0[4];
LABEL_119:
        _hj_i_0 += _hj_key_0[3] << 24;
LABEL_120:
        _hj_i_0 += _hj_key_0[2] << 16;
LABEL_121:
        _hj_i_0 += _hj_key_0[1] << 8;
LABEL_122:
        _hj_i_0 += *_hj_key_0;
        break;
      default:
        break;
    }
    _hj_i_0 = (_ha_hashv >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 8) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 13) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    _hj_i_0 = (_ha_hashv >> 12) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 16) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 5) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    _hj_i_0 = (_ha_hashv >> 3) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    s->hh.hashv = _ha_hashv;
    s->hh.key = s;
    s->hh.keylen = strlen((const char *)s);
    if ( blocks )
    {
      s->hh.tbl = blocks->hh.tbl;
      s->hh.next = 0;
      s->hh.prev = (char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho;
      blocks->hh.tbl->tail->next = s;
      blocks->hh.tbl->tail = &s->hh;
    }
    else
    {
      s->hh.next = 0;
      s->hh.prev = 0;
      blocks = s;
      s->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !blocks->hh.tbl )
        exit(-1);
      memset(blocks->hh.tbl, 0, sizeof(UT_hash_table));
      blocks->hh.tbl->tail = &blocks->hh;
      blocks->hh.tbl->num_buckets = 32;
      blocks->hh.tbl->log2_num_buckets = 5;
      blocks->hh.tbl->hho = 68;
      tbl = blocks->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !blocks->hh.tbl->buckets )
        exit(-1);
      memset(blocks->hh.tbl->buckets, 0, 0x180u);
      blocks->hh.tbl->signature = -1609490463;
    }
    ++blocks->hh.tbl->num_items;
    _ha_bkt = (blocks->hh.tbl->num_buckets - 1) & _ha_hashv;
    v14 = &blocks->hh.tbl->buckets[_ha_bkt];
    ++v14->count;
    s->hh.hh_next = blocks->hh.tbl->buckets[_ha_bkt].hh_head;
    s->hh.hh_prev = 0;
    if ( blocks->hh.tbl->buckets[_ha_bkt].hh_head )
      blocks->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &s->hh;
    blocks->hh.tbl->buckets[_ha_bkt].hh_head = &s->hh;
    if ( blocks->hh.tbl->buckets[_ha_bkt].count >= 10 * (blocks->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && s->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * s->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * s->hh.tbl->num_buckets);
      s->hh.tbl->ideal_chain_maxlen = (s->hh.tbl->num_items >> (s->hh.tbl->log2_num_buckets + 1))
                                    + (((2 * s->hh.tbl->num_buckets - 1) & s->hh.tbl->num_items) != 0);
      s->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; _he_bkt_i < s->hh.tbl->num_buckets; ++_he_bkt_i )
      {
        for ( _he_thh = s->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_bkt = (2 * s->hh.tbl->num_buckets - 1) & _he_thh->hashv;
          _he_newbkt = &_he_new_buckets[_he_bkt];
          if ( ++_he_newbkt->count > s->hh.tbl->ideal_chain_maxlen )
          {
            ++s->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / s->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(s->hh.tbl->buckets);
      s->hh.tbl->num_buckets *= 2;
      ++s->hh.tbl->log2_num_buckets;
      s->hh.tbl->buckets = _he_new_buckets;
      if ( s->hh.tbl->nonideal_items <= s->hh.tbl->num_items >> 1 )
        v15 = 0;
      else
        v15 = s->hh.tbl->ineff_expands + 1;
      s->hh.tbl->ineff_expands = v15;
      if ( s->hh.tbl->ineff_expands > 1 )
        s->hh.tbl->noexpand = 1;
    }
    set_blockdiff(work);
    if ( deleted_block && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", deleted_block);
      applog(7, tmp42, 0);
    }
  }
  wr_unlock(&blk_lock, "cgminer.c", _func___15826, 5591);
  if ( !ret )
    set_curblock(hexstr, bedata);
  if ( deleted_block && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", deleted_block);
    applog(7, tmp42, 0);
  }
  return ret;
}

//----- (0004FD54) --------------------------------------------------------
bool __cdecl test_work_current(work *work)
{
  const char *v2; // r3
  pool *v3; // r4
  const char *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  uint32_t height; // [sp+810h] [bp+808h] BYREF
  unsigned __int8 hexstr[68]; // [sp+814h] [bp+80Ch] BYREF
  unsigned __int8 bedata[32]; // [sp+858h] [bp+850h] BYREF
  uint8_t cb_height_sz; // [sp+87Bh] [bp+873h]
  unsigned __int8 *bin_height; // [sp+87Ch] [bp+874h]
  pool *pool; // [sp+880h] [bp+878h]
  bool ret; // [sp+887h] [bp+87Fh]

  pool = work->pool;
  ret = 1;
  bin_height = pool->coinbase + 43;
  cb_height_sz = *(bin_height - 1);
  height = 0;
  if ( !work->mandatory )
  {
    swap256(bedata, &work->data[4]);
    _bin2hex(hexstr, bedata, 0x20u);
    if ( cb_height_sz <= 4u )
    {
      cg_memcpy(&height, bin_height, cb_height_sz, "cgminer.c", _func___15921, 5627);
      height = _uint32_identity_0(height) - 1;
    }
    cg_wlock_1(&pool->data_lock, "cgminer.c", _func___15921, 5632);
    if ( pool->swork.clean )
    {
      pool->swork.clean = 0;
      work->longpoll = 1;
    }
    cg_wunlock_1(&pool->data_lock, "cgminer.c", _func___15921, 5640);
    if ( !block_exists(hexstr, bedata, work) )
    {
      cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", _func___15921, 5648);
      if ( new_blocks == 1 )
      {
        ret = 0;
out:
        work->longpoll = 0;
        return ret;
      }
      work->work_block = ++work_block;
      if ( work->longpoll )
      {
        if ( work->stratum )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Stratum from pool %d detected new block at height %d",
              pool->pool_no,
              height);
            applog(5, tmp42, 0);
          }
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          if ( work->gbt )
            v2 = "GBT ";
          else
            v2 = byte_8A828;
          snprintf((char *)tmp42, 0x800u, "%sLONGPOLL from pool %d detected new block", v2, work->pool->pool_no);
          applog(5, tmp42, 0);
        }
      }
      else if ( have_longpoll && !pool->gbt_solo )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy((char *)tmp42, "New block detected on network before pool notification");
          applog(5, tmp42, 0);
        }
      }
      else if ( !pool->gbt_solo && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        strcpy((char *)tmp42, "New block detected on network");
        applog(5, tmp42, 0);
      }
    }
    else
    {
      if ( memcmp(pool->prev_block, bedata, 0x20u) )
      {
        if ( !memcmp(bedata, current_block, 0x20u) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "Pool %d now up to date at height %d", pool->pool_no, height);
            applog(6, tmp42, 0);
          }
          cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", _func___15921, 5698);
        }
        else
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "Stale data from pool %d at height %d", pool->pool_no, height);
            applog(7, tmp42, 0);
          }
          ret = 0;
        }
      }
      if ( !work->longpoll )
        goto out;
      work->work_block = ++work_block;
      if ( !shared_strategy() )
      {
        v3 = work->pool;
        if ( v3 != current_pool() )
          goto out;
      }
      if ( work->stratum )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Stratum from pool %d requested work restart", pool->pool_no);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( work->gbt )
          v4 = "GBT ";
        else
          v4 = byte_8A828;
        snprintf((char *)tmp42, 0x800u, "%sLONGPOLL from pool %d requested work restart", v4, work->pool->pool_no);
        applog(5, tmp42, 0);
      }
    }
    restart_threads();
    goto out;
  }
  return ret;
}

//----- (0005034E) --------------------------------------------------------
int __cdecl tv_sort(work *worka, work *workb)
{
  return worka->tv_staged.tv_sec - workb->tv_staged.tv_sec;
}

//----- (00050372) --------------------------------------------------------
bool __cdecl work_rollable(work *work)
{
  return !work->clone && work->rolltime;
}
// 503A0: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (000503AC) --------------------------------------------------------
bool __cdecl hash_push(work *work)
{
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v2; // r3
  unsigned int v3; // r3
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  char *v9; // r3
  char *v10; // r3
  UT_hash_bucket_0 *_he_newbkt; // [sp+8h] [bp+8h]
  UT_hash_handle *_he_hh_nxt; // [sp+10h] [bp+10h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+14h] [bp+14h]
  unsigned int _ha_bkt; // [sp+18h] [bp+18h]
  UT_hash_handle *_hs_tail; // [sp+1Ch] [bp+1Ch]
  UT_hash_handle *_hs_list; // [sp+20h] [bp+20h]
  UT_hash_handle *_hs_e; // [sp+24h] [bp+24h]
  UT_hash_handle *_hs_q; // [sp+28h] [bp+28h]
  UT_hash_handle *_hs_p; // [sp+2Ch] [bp+2Ch]
  unsigned int _hs_qsize; // [sp+30h] [bp+30h]
  unsigned int _hs_psize; // [sp+34h] [bp+34h]
  unsigned int _hs_insize; // [sp+38h] [bp+38h]
  unsigned int _hs_nmerges; // [sp+3Ch] [bp+3Ch]
  unsigned int _hs_looping; // [sp+40h] [bp+40h]
  unsigned int _hs_i; // [sp+44h] [bp+44h]
  UT_hash_handle *_he_thh; // [sp+48h] [bp+48h]
  unsigned int _he_bkt_i; // [sp+4Ch] [bp+4Ch]
  unsigned int _hj_j; // [sp+58h] [bp+58h]
  unsigned int _hj_ja; // [sp+58h] [bp+58h]
  int _hj_i; // [sp+5Ch] [bp+5Ch]
  int _hj_ia; // [sp+5Ch] [bp+5Ch]
  int _hj_ib; // [sp+5Ch] [bp+5Ch]
  unsigned int _ha_hashva; // [sp+60h] [bp+60h]
  unsigned int _ha_hashvb; // [sp+60h] [bp+60h]
  unsigned int _ha_hashv; // [sp+60h] [bp+60h]
  bool rc; // [sp+67h] [bp+67h]

  rc = 1;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___15942, 5754);
  if ( work_rollable(work) )
    ++staged_rollable;
  if ( !getq->frozen )
  {
    _hj_i = ((BYTE1(work->id) << 8) + (BYTE2(work->id) << 16) + (HIBYTE(work->id) << 24) + LOBYTE(work->id) + 17973517) ^ 0x7F76D;
    _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
    _ha_hashva = (_hj_j >> 13) ^ (-17973517 - _hj_i - _hj_j);
    _hj_ia = (_ha_hashva >> 12) ^ (_hj_i - _hj_j - _ha_hashva);
    _hj_ja = (_hj_ia << 16) ^ (_hj_j - _ha_hashva - _hj_ia);
    _ha_hashvb = (_hj_ja >> 5) ^ (_ha_hashva - _hj_ia - _hj_ja);
    _hj_ib = (_ha_hashvb >> 3) ^ (_hj_ia - _hj_ja - _ha_hashvb);
    _ha_hashv = (((_hj_ib << 10) ^ (_hj_ja - _ha_hashvb - _hj_ib)) >> 15) ^ (_ha_hashvb
                                                                           - _hj_ib
                                                                           - ((_hj_ib << 10) ^ (_hj_ja
                                                                                              - _ha_hashvb
                                                                                              - _hj_ib)));
    work->hh.hashv = _ha_hashv;
    work->hh.key = &work->id;
    work->hh.keylen = 4;
    if ( staged_work )
    {
      work->hh.tbl = staged_work->hh.tbl;
      work->hh.next = 0;
      work->hh.prev = (char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho;
      staged_work->hh.tbl->tail->next = work;
      staged_work->hh.tbl->tail = &work->hh;
    }
    else
    {
      work->hh.next = 0;
      work->hh.prev = 0;
      staged_work = work;
      work->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !staged_work->hh.tbl )
        exit(-1);
      memset(staged_work->hh.tbl, 0, sizeof(UT_hash_table));
      staged_work->hh.tbl->tail = &staged_work->hh;
      staged_work->hh.tbl->num_buckets = 32;
      staged_work->hh.tbl->log2_num_buckets = 5;
      staged_work->hh.tbl->hho = 344;
      tbl = staged_work->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !staged_work->hh.tbl->buckets )
        exit(-1);
      memset(staged_work->hh.tbl->buckets, 0, 0x180u);
      staged_work->hh.tbl->signature = -1609490463;
    }
    ++staged_work->hh.tbl->num_items;
    _ha_bkt = (staged_work->hh.tbl->num_buckets - 1) & _ha_hashv;
    v2 = &staged_work->hh.tbl->buckets[_ha_bkt];
    ++v2->count;
    work->hh.hh_next = staged_work->hh.tbl->buckets[_ha_bkt].hh_head;
    work->hh.hh_prev = 0;
    if ( staged_work->hh.tbl->buckets[_ha_bkt].hh_head )
      staged_work->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &work->hh;
    staged_work->hh.tbl->buckets[_ha_bkt].hh_head = &work->hh;
    if ( staged_work->hh.tbl->buckets[_ha_bkt].count >= 10 * (staged_work->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && work->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * work->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * work->hh.tbl->num_buckets);
      work->hh.tbl->ideal_chain_maxlen = (work->hh.tbl->num_items >> (work->hh.tbl->log2_num_buckets + 1))
                                       + (((2 * work->hh.tbl->num_buckets - 1) & work->hh.tbl->num_items) != 0);
      work->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; _he_bkt_i < work->hh.tbl->num_buckets; ++_he_bkt_i )
      {
        for ( _he_thh = work->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_newbkt = &_he_new_buckets[(2 * work->hh.tbl->num_buckets - 1) & _he_thh->hashv];
          if ( ++_he_newbkt->count > work->hh.tbl->ideal_chain_maxlen )
          {
            ++work->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / work->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(work->hh.tbl->buckets);
      work->hh.tbl->num_buckets *= 2;
      ++work->hh.tbl->log2_num_buckets;
      work->hh.tbl->buckets = _he_new_buckets;
      if ( work->hh.tbl->nonideal_items <= work->hh.tbl->num_items >> 1 )
        v3 = 0;
      else
        v3 = work->hh.tbl->ineff_expands + 1;
      work->hh.tbl->ineff_expands = v3;
      if ( work->hh.tbl->ineff_expands > 1 )
        work->hh.tbl->noexpand = 1;
    }
    if ( staged_work )
    {
      _hs_insize = 1;
      _hs_looping = 1;
      _hs_list = &staged_work->hh;
      while ( _hs_looping )
      {
        _hs_p = _hs_list;
        _hs_list = 0;
        _hs_tail = 0;
        _hs_nmerges = 0;
        while ( _hs_p )
        {
          ++_hs_nmerges;
          _hs_q = _hs_p;
          _hs_psize = 0;
          for ( _hs_i = 0; _hs_i < _hs_insize; ++_hs_i )
          {
            ++_hs_psize;
            v4 = _hs_q->next ? (int)_hs_q->next + staged_work->hh.tbl->hho : 0;
            _hs_q = (UT_hash_handle *)v4;
            if ( !v4 )
              break;
          }
          _hs_qsize = _hs_insize;
          while ( _hs_psize || _hs_qsize && _hs_q )
          {
            if ( _hs_psize )
            {
              if ( _hs_qsize && _hs_q )
              {
                if ( tv_sort(
                       (work *)((char *)_hs_p - staged_work->hh.tbl->hho),
                       (work *)((char *)_hs_q - staged_work->hh.tbl->hho)) > 0 )
                {
                  _hs_e = _hs_q;
                  if ( _hs_q->next )
                    v8 = (int)_hs_q->next + staged_work->hh.tbl->hho;
                  else
                    v8 = 0;
                  _hs_q = (UT_hash_handle *)v8;
                  --_hs_qsize;
                }
                else
                {
                  _hs_e = _hs_p;
                  if ( _hs_p )
                  {
                    if ( _hs_p->next )
                      v7 = (int)_hs_p->next + staged_work->hh.tbl->hho;
                    else
                      v7 = 0;
                    _hs_p = (UT_hash_handle *)v7;
                  }
                  --_hs_psize;
                }
              }
              else
              {
                _hs_e = _hs_p;
                if ( _hs_p )
                {
                  if ( _hs_p->next )
                    v6 = (int)_hs_p->next + staged_work->hh.tbl->hho;
                  else
                    v6 = 0;
                  _hs_p = (UT_hash_handle *)v6;
                }
                --_hs_psize;
              }
            }
            else
            {
              _hs_e = _hs_q;
              if ( _hs_q->next )
                v5 = (int)_hs_q->next + staged_work->hh.tbl->hho;
              else
                v5 = 0;
              _hs_q = (UT_hash_handle *)v5;
              --_hs_qsize;
            }
            if ( _hs_tail )
            {
              if ( _hs_e )
                v9 = (char *)_hs_e - staged_work->hh.tbl->hho;
              else
                v9 = 0;
              _hs_tail->next = v9;
            }
            else
            {
              _hs_list = _hs_e;
            }
            if ( _hs_e )
            {
              if ( _hs_tail )
                v10 = (char *)_hs_tail - staged_work->hh.tbl->hho;
              else
                v10 = 0;
              _hs_e->prev = v10;
            }
            _hs_tail = _hs_e;
          }
          _hs_p = _hs_q;
        }
        if ( _hs_tail )
          _hs_tail->next = 0;
        if ( _hs_nmerges <= 1 )
        {
          _hs_looping = 0;
          staged_work->hh.tbl->tail = _hs_tail;
          staged_work = (work *)((char *)_hs_list - staged_work->hh.tbl->hho);
        }
        _hs_insize *= 2;
      }
    }
  }
  else
  {
    rc = 0;
  }
  pthread_cond_broadcast(&getq->cond);
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___15942, 5772);
  return rc;
}
// 505B8: conditional instruction was optimized away because %_hj_k.4==4

//----- (00050F1C) --------------------------------------------------------
void __cdecl stage_work(work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Pushing work from pool %d to hash queue", work->pool->pool_no);
    applog(7, tmp42, 0);
  }
  work->work_block = work_block;
  test_work_current(work);
  ++work->pool->works;
  hash_push(work);
}

//----- (00050FC6) --------------------------------------------------------
void __cdecl remove_pool(pool *pool)
{
  pool *other; // [sp+Ch] [bp+Ch]
  int last_pool; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  last_pool = total_pools - 1;
  for ( i = 0; i < total_pools; ++i )
  {
    other = pools[i];
    if ( other->prio > pool->prio )
      --other->prio;
  }
  if ( last_pool > pool->pool_no )
  {
    pools[last_pool]->pool_no = pool->pool_no;
    pools[pool->pool_no] = pools[last_pool];
  }
  pool->pool_no = total_pools;
  pool->removed = 1;
  --total_pools;
}

//----- (000510A2) --------------------------------------------------------
void json_escape_free()
{
  JE *jenext; // [sp+0h] [bp+0h]
  JE *jeptr; // [sp+4h] [bp+4h]

  jeptr = jedata;
  jedata = 0;
  while ( jeptr )
  {
    jenext = jeptr->next;
    free(jeptr->buf);
    free(jeptr);
    jeptr = jenext;
  }
}

//----- (000510EA) --------------------------------------------------------
unsigned __int8 *__cdecl json_escape(unsigned __int8 *str)
{
  size_t v1; // r0
  JE *v2; // r0
  unsigned __int8 *v3; // r3
  unsigned __int8 *v4; // r2
  unsigned __int8 *v5; // r3
  unsigned __int8 *stra; // [sp+4h] [bp+4h]
  unsigned __int8 *buf; // [sp+10h] [bp+10h]
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]

  stra = str;
  v1 = strlen((const char *)str);
  buf = (unsigned __int8 *)cgmalloc(2 * v1 + 1, "cgminer.c", _func___16028, 5898);
  ptr = buf;
  v2 = (JE *)cgmalloc(8u, "cgminer.c", _func___16028, 5899);
  v2->buf = buf;
  v2->next = jedata;
  jedata = v2;
  while ( *stra )
  {
    if ( *stra == 92 || *stra == 34 )
    {
      v3 = ptr++;
      *v3 = 92;
    }
    v4 = stra++;
    v5 = ptr++;
    *v5 = *v4;
  }
  *ptr = 0;
  return buf;
}

//----- (0005119C) --------------------------------------------------------
void __cdecl write_config(FILE *fcfg)
{
  const char *v1; // r5
  unsigned __int8 *v2; // r0
  const char *v3; // r8
  const char *v4; // r6
  const char *v5; // r4
  unsigned __int8 *v6; // r0
  const char *v7; // r5
  unsigned __int8 *v8; // r0
  const char *v9; // r8
  const char *v10; // r6
  const char *v11; // r4
  unsigned __int8 *v12; // r0
  unsigned __int8 *v13; // r0
  unsigned __int8 *v14; // r0
  unsigned __int8 *v15; // r0
  int quota; // [sp+10h] [bp+0h]
  pool *pool; // [sp+18h] [bp+8h]
  unsigned __int8 *carg; // [sp+1Ch] [bp+Ch]
  char *name; // [sp+20h] [bp+10h]
  unsigned __int8 *p; // [sp+24h] [bp+14h]
  int i; // [sp+28h] [bp+18h]
  opt_table *opt; // [sp+2Ch] [bp+1Ch]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, fcfg);
  for ( i = 0; i < total_pools; ++i )
  {
    pool = priority_pool(i);
    if ( pool->quota == 1 )
    {
      if ( i <= 0 )
        v7 = byte_8A828;
      else
        v7 = ",";
      if ( pool->rpc_proxy )
      {
        v8 = (unsigned __int8 *)proxytype(pool->rpc_proxytype);
        v9 = (const char *)json_escape(v8);
      }
      else
      {
        v9 = byte_8A828;
      }
      if ( pool->rpc_proxy )
        v10 = (const char *)json_escape(pool->rpc_proxy);
      else
        v10 = byte_8A828;
      if ( pool->rpc_proxy )
        v11 = "|";
      else
        v11 = byte_8A828;
      v12 = json_escape(pool->rpc_url);
      fprintf(fcfg, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v7, v9, v10, v11, (const char *)v12);
    }
    else
    {
      if ( i <= 0 )
        v1 = byte_8A828;
      else
        v1 = ",";
      if ( pool->rpc_proxy )
      {
        v2 = (unsigned __int8 *)proxytype(pool->rpc_proxytype);
        v3 = (const char *)json_escape(v2);
      }
      else
      {
        v3 = byte_8A828;
      }
      if ( pool->rpc_proxy )
        v4 = (const char *)json_escape(pool->rpc_proxy);
      else
        v4 = byte_8A828;
      if ( pool->rpc_proxy )
        v5 = "|";
      else
        v5 = byte_8A828;
      quota = pool->quota;
      v6 = json_escape(pool->rpc_url);
      fprintf(fcfg, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v1, v3, v4, v5, quota, (const char *)v6);
    }
    if ( pool->extranonce_subscribe )
      fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 0x21u, fcfg);
    v13 = json_escape(pool->rpc_user);
    fprintf(fcfg, "\n\t\t\"user\" : \"%s\",", (const char *)v13);
    v14 = json_escape(pool->rpc_pass);
    fprintf(fcfg, "\n\t\t\"pass\" : \"%s\"\n\t}", (const char *)v14);
  }
  fwrite("\n]\n", 1u, 3u, fcfg);
  for ( opt = opt_config_table; opt->type != OPT_END; ++opt )
  {
    name = strdup((const char *)opt->names);
    for ( p = (unsigned __int8 *)strtok(name, "|"); p; p = (unsigned __int8 *)strtok(0, "|") )
    {
      if ( p[1] == 45 && opt->desc != opt_hidden )
      {
        if ( (opt->type & 1) != 0
          && ((unsigned __int8 *(__cdecl *)(bool *))opt->cb == opt_set_bool
           || (unsigned __int8 *(__cdecl *)(bool *))opt->cb == opt_set_invbool)
          && *(_BYTE *)opt->u.carg == (opt->cb == (unsigned __int8 *(*)(void *))opt_set_bool) )
        {
          fprintf(fcfg, ",\n\"%s\" : true", (const char *)p + 2);
        }
        else if ( (opt->type & 2) != 0
               && ((unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == opt_set_intval
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_9999
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_65535
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_10
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_10
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_100
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_255
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_255
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_7680
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_200
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_4
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_32_to_63
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_22_to_75
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_42_to_85
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_22_to_55
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_42_to_65) )
        {
          fprintf(fcfg, ",\n\"%s\" : \"%d\"", (const char *)p + 2, *(_DWORD *)opt->u.carg);
        }
        else if ( (opt->type & 2) != 0
               && ((unsigned __int8 *(__cdecl *)(const unsigned __int8 *, float *))opt->cb_arg == set_float_125_to_500
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, float *))opt->cb_arg == set_float_100_to_250) )
        {
          fprintf(fcfg, ",\n\"%s\" : \"%.1f\"", (const char *)p + 2, *(float *)opt->u.carg);
        }
        else if ( (opt->type & 6) != 0 && opt->u.carg != &opt_set_null )
        {
          carg = *(unsigned __int8 **)opt->u.carg;
          if ( carg )
          {
            v15 = json_escape(carg);
            fprintf(fcfg, ",\n\"%s\" : \"%s\"", (const char *)p + 2, (const char *)v15);
          }
        }
      }
    }
    free(name);
  }
  if ( pool_strategy_0 == POOL_BALANCE )
    fwrite(",\n\"balance\" : true", 1u, 0x12u, fcfg);
  if ( pool_strategy_0 == POOL_LOADBALANCE )
    fwrite(",\n\"load-balance\" : true", 1u, 0x17u, fcfg);
  if ( pool_strategy_0 == POOL_ROUNDROBIN )
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, fcfg);
  if ( pool_strategy_0 == POOL_ROTATE )
    fprintf(fcfg, ",\n\"rotate\" : \"%d\"", opt_rotate_period);
  fwrite("\n}\n", 1u, 3u, fcfg);
  json_escape_free();
}

//----- (000516F6) --------------------------------------------------------
void zero_bestshare()
{
  pool *v0; // r2
  int i; // [sp+Ch] [bp+4h]

  best_diff = 0LL;
  memset(best_share, 0, sizeof(best_share));
  suffix_string(0LL, best_share, 8u, 0);
  for ( i = 0; i < total_pools; ++i )
  {
    v0 = pools[i];
    LODWORD(v0->best_diff) = 0;
    HIDWORD(v0->best_diff) = 0;
  }
}

//----- (00051784) --------------------------------------------------------
void zero_stats()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  double *v3; // r2
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  sysinfo sInfo; // [sp+80Ch] [bp+804h] BYREF
  pool *pool; // [sp+84Ch] [bp+844h]
  cgpu_info *cgpu; // [sp+850h] [bp+848h]
  int i; // [sp+854h] [bp+84Ch]

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v0 = *_errno_location();
      v1 = _errno_location();
      v2 = strerror(*v1);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v2);
      applog(6, tmp42, 0);
    }
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
  }
  cgtime(&total_tv_start);
  copy_time(&tv_hashmeter, &total_tv_start);
  total_rolling = 0.0;
  rolling1 = 0.0;
  rolling5 = 0.0;
  rolling15 = 0.0;
  total_mhashes_done = 0.0;
  new_total_mhashes_done = 0.0;
  for ( i = 0; i <= 11; ++i )
  {
    v3 = &g_local_mhashes_dones[i];
    *(_DWORD *)v3 = 0;
    *((_DWORD *)v3 + 1) = 0;
  }
  g_local_mhashes_index = 0;
  g_max_fan = 0;
  g_max_temp = 0;
  total_getworks = 0LL;
  total_accepted = 0LL;
  total_rejected = 0LL;
  hw_errors = 0;
  total_stale = 0LL;
  total_discarded = 0LL;
  local_work = 0;
  total_go = 0;
  total_ro = 0;
  total_secs = 1.0;
  new_total_secs = 1.0;
  last_total_secs = 1.0;
  total_diff1 = 0LL;
  found_blocks = 0;
  total_diff_accepted = 0.0;
  total_diff_rejected = 0.0;
  total_diff_stale = 0.0;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->getwork_requested = 0;
    pool->accepted = 0LL;
    pool->rejected = 0LL;
    pool->stale_shares = 0;
    pool->discarded_work = 0;
    pool->getfail_occasions = 0;
    pool->remotefail_occasions = 0;
    pool->last_share_time = 0;
    pool->diff1 = 0LL;
    pool->diff_accepted = 0LL;
    pool->diff_rejected = 0LL;
    pool->diff_stale = 0LL;
    pool->last_share_diff = 0LL;
  }
  zero_bestshare();
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu = get_devices(i);
    copy_time(&cgpu->dev_start_tv, &total_tv_start);
    mutex_lock_1(&hash_lock, "cgminer.c", _func___16075, 6152);
    cgpu->total_mhashes = 0LL;
    cgpu->accepted = 0;
    cgpu->rejected = 0;
    cgpu->hw_errors = 0;
    cgpu->utility = 0LL;
    cgpu->last_share_pool_time = 0;
    cgpu->diff1 = 0LL;
    cgpu->diff_accepted = 0LL;
    cgpu->diff_rejected = 0LL;
    cgpu->last_share_diff = 0LL;
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___16075, 6165);
    cgpu->drv->zero_stats(cgpu);
  }
}

//----- (00051C54) --------------------------------------------------------
void set_highprio()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+804h] [bp+804h]

  ret = nice(-10);
  if ( !ret && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Unable to set thread to high priority");
    applog(7, tmp42, 0);
  }
}

//----- (00051CDE) --------------------------------------------------------
void set_lowprio()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp+4h] BYREF
  int ret; // [sp+804h] [bp+804h]

  ret = nice(10);
  if ( !ret && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    strcpy((char *)tmp42, "Unable to set thread to low priority");
    applog(6, tmp42, 0);
  }
}

//----- (00051D58) --------------------------------------------------------
void __cdecl default_save_file(unsigned __int8 *filename)
{
  char *v1; // r0

  if ( default_config && *default_config )
  {
    strcpy((char *)filename, (const char *)default_config);
  }
  else
  {
    if ( getenv("HOME") && *getenv("HOME") )
    {
      v1 = getenv("HOME");
      strcpy((char *)filename, v1);
      strcat((char *)filename, "/");
    }
    else
    {
      *filename = 0;
    }
    strcat((char *)filename, ".bmminer/");
    mkdir((const char *)filename, 0x1FFu);
    strcat((char *)filename, "bmminer.conf");
  }
}

//----- (00051E44) --------------------------------------------------------
void *__cdecl api_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  RenameThread("API");
  set_lowprio();
  api(api_thr_id);
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (00051E94) --------------------------------------------------------
void __cdecl thread_reportin(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 0;
  cgtime(&thr->last);
  thr->cgpu->status = LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00051ECE) --------------------------------------------------------
void __cdecl thread_reportout(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 1;
  cgtime(&thr->last);
  thr->cgpu->status = LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00051F08) --------------------------------------------------------
void __cdecl hashmeter(int thr_id, uint64_t hashes_done)
{
  double v2; // d0
  int v3; // r4
  int *v4; // r0
  char *v5; // r0
  double v6; // r2
  double v7; // r2
  double v8; // r2
  double v9; // r2
  double v10; // r0
  double v11; // r2
  double v12; // r0
  double v13; // r2
  double v14; // r0
  double v15; // r2
  double *v16; // r2
  double fsecs; // [sp+0h] [bp-18h]
  double fsecsa; // [sp+0h] [bp-18h]
  double fsecsb; // [sp+0h] [bp-18h]
  double fsecsc; // [sp+0h] [bp-18h]
  double fsecsd; // [sp+0h] [bp-18h]
  double fsecse; // [sp+0h] [bp-18h]
  double fsecsf; // [sp+0h] [bp-18h]
  double fsecsg; // [sp+0h] [bp-18h]
  double fsecsh; // [sp+0h] [bp-18h]
  double fsecsi; // [sp+0h] [bp-18h]
  double interval; // [sp+8h] [bp-10h]
  double intervala; // [sp+8h] [bp-10h]
  double intervalb; // [sp+8h] [bp-10h]
  double intervalc; // [sp+8h] [bp-10h]
  double intervald; // [sp+8h] [bp-10h]
  double intervale; // [sp+8h] [bp-10h]
  double intervalf; // [sp+8h] [bp-10h]
  double intervalg; // [sp+8h] [bp-10h]
  double intervalh; // [sp+8h] [bp-10h]
  double intervali; // [sp+8h] [bp-10h]
  int thr_idb; // [sp+24h] [bp+Ch]
  unsigned __int8 logline[256]; // [sp+28h] [bp+10h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+128h] [bp+110h] BYREF
  unsigned __int8 displayed_r15[16]; // [sp+928h] [bp+910h] BYREF
  unsigned __int8 displayed_r5[16]; // [sp+938h] [bp+920h] BYREF
  unsigned __int8 displayed_r1[16]; // [sp+948h] [bp+930h] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+958h] [bp+940h] BYREF
  unsigned __int8 displayed_hashes[16]; // [sp+968h] [bp+950h] BYREF
  sysinfo sInfo; // [sp+978h] [bp+960h] BYREF
  uint64_t d64; // [sp+9B8h] [bp+9A0h]
  double thr_mhs; // [sp+9C0h] [bp+9A8h]
  double device_tdiff; // [sp+9C8h] [bp+9B0h] BYREF
  cgpu_info *cgpu; // [sp+9D0h] [bp+9B8h]
  thr_info *thr; // [sp+9D4h] [bp+9BCh]
  double device_tdiff_0; // [sp+9D8h] [bp+9C0h] BYREF
  cgpu_info *cgpu_0; // [sp+9E0h] [bp+9C8h]
  thr_info *thr_0; // [sp+9E4h] [bp+9CCh]
  int diff_t; // [sp+9E8h] [bp+9D0h]
  time_t now_t; // [sp+9ECh] [bp+9D4h]
  double tv_tdiff; // [sp+9F0h] [bp+9D8h] BYREF
  int i; // [sp+9F8h] [bp+9E0h]
  int local_mhashes_done_count; // [sp+9FCh] [bp+9E4h]
  uint64_t local_mhashes_done_avg; // [sp+A00h] [bp+9E8h]
  uint64_t local_mhashes_done; // [sp+A08h] [bp+9F0h]
  bool showlog; // [sp+A17h] [bp+9FFh]

  showlog = 0;
  local_mhashes_done = 0LL;
  local_mhashes_done_avg = 0LL;
  local_mhashes_done_count = 0;
  i = 0;
  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v3 = *_errno_location();
      v4 = _errno_location();
      v5 = strerror(*v4);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v3, v5);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
  }
  cgtime(&total_tv_end);
  tdiff(&total_tv_end, &tv_hashmeter);
  tv_tdiff = v2;
  now_t = total_tv_end.tv_sec;
  diff_t = total_tv_end.tv_sec - hashdisplay_t;
  if ( total_tv_end.tv_sec - hashdisplay_t < opt_log_interval )
  {
    if ( thr_id < 0 )
      return;
  }
  else
  {
    alt_status = switch_status != alt_status;
    hashdisplay_t = now_t;
    showlog = 1;
  }
  copy_time(&tv_hashmeter, &total_tv_end);
  if ( thr_id < 0 )
  {
    mutex_lock_1(&hash_lock, "cgminer.c", _func___16121, 7068);
    for ( thr_idb = 0; thr_idb < mining_threads; ++thr_idb )
    {
      thr_0 = get_thread(thr_idb);
      cgpu_0 = thr_0->cgpu;
      tdiff(&total_tv_end, &cgpu_0->last_message_tv);
      device_tdiff_0 = v2;
      copy_time(&cgpu_0->last_message_tv, &total_tv_end);
      LODWORD(v6) = &cgpu_0->rolling;
      HIDWORD(v6) = &device_tdiff_0;
      decay_time(&cgpu_0->rolling, v6, fsecs, interval);
      HIDWORD(v7) = &cgpu_0->rolling1;
      LODWORD(v7) = &device_tdiff_0;
      decay_time(&cgpu_0->rolling1, v7, fsecsd, intervald);
      HIDWORD(v8) = &cgpu_0->rolling5;
      LODWORD(v8) = &device_tdiff_0;
      decay_time(&cgpu_0->rolling5, v8, fsecse, intervale);
      HIDWORD(v9) = &cgpu_0->rolling15;
      LODWORD(v9) = &device_tdiff_0;
      v2 = 0.0;
      decay_time(&cgpu_0->rolling15, v9, fsecsf, intervalf);
    }
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___16121, 7083);
  }
  else
  {
    thr = get_thread(thr_id);
    cgpu = thr->cgpu;
    copy_time(&thr->last, &total_tv_end);
    cgpu->device_last_well = now_t;
    tdiff(&total_tv_end, &cgpu->last_message_tv);
    device_tdiff = v2;
    copy_time(&cgpu->last_message_tv, &total_tv_end);
    thr_mhs = (double)hashes_done / device_tdiff / 1000000.0;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "[thread %d: %llu hashes, %.1f mhash/sec]", thr_id, hashes_done, thr_mhs);
      applog(7, tmp42, 0);
    }
    hashes_done /= (unsigned int)&calc_nonce_info.chain_asic_core_nonce_num[5][48][190];
    mutex_lock_1(&hash_lock, "cgminer.c", _func___16121, 7039);
    cgpu->total_mhashes = cgpu->total_mhashes + (double)hashes_done;
    decay_time(
      &cgpu->rolling,
      COERCE_DOUBLE(__PAIR64__(&device_tdiff, HIDWORD(COERCE_UNSIGNED_INT64((double)hashes_done)))),
      fsecs,
      interval);
    decay_time(&cgpu->rolling1, (double)hashes_done, fsecsa, intervala);
    decay_time(&cgpu->rolling5, (double)hashes_done, fsecsb, intervalb);
    decay_time(&cgpu->rolling15, (double)hashes_done, fsecsc, intervalc);
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___16121, 7046);
    if ( want_per_device_stats && showlog )
    {
      get_statline(logline, 0x100u, cgpu);
      printf("%s          \r", (const char *)logline);
      fflush((FILE *)stdout);
    }
  }
  mutex_lock_1(&hash_lock, "cgminer.c", _func___16121, 7086);
  total_mhashes_done = (double)hashes_done + total_mhashes_done;
  if ( showlog )
  {
    if ( ++g_local_mhashes_index > 11 )
      g_local_mhashes_index = 0;
    for ( i = 0; i <= 11; ++i )
    {
      if ( g_local_mhashes_dones[i] >= 0.0 )
      {
        local_mhashes_done_avg = (unsigned __int64)((double)local_mhashes_done_avg + g_local_mhashes_dones[i]);
        ++local_mhashes_done_count;
      }
    }
    if ( local_mhashes_done_count <= 0 )
      local_mhashes_done = hashes_done;
    else
      local_mhashes_done = local_mhashes_done_avg / local_mhashes_done_count;
    decay_time(
      &total_rolling,
      COERCE_DOUBLE(__PAIR64__(opt_log_interval, HIDWORD(COERCE_UNSIGNED_INT64((double)local_mhashes_done)))),
      fsecs,
      interval);
    v10 = (double)hashes_done;
    HIDWORD(v11) = LODWORD(v10);
    LODWORD(v11) = &tv_tdiff;
    decay_time(&rolling1, v11, fsecsg, intervalg);
    v12 = (double)hashes_done;
    HIDWORD(v13) = LODWORD(v12);
    LODWORD(v13) = &tv_tdiff;
    decay_time(&rolling5, v13, fsecsh, intervalh);
    v14 = (double)hashes_done;
    HIDWORD(v15) = LODWORD(v14);
    LODWORD(v15) = &tv_tdiff;
    decay_time(&rolling15, v15, fsecsi, intervali);
    global_hashrate = (unsigned __int64)(total_rolling * 1000000.0);
    v16 = &g_local_mhashes_dones[g_local_mhashes_index];
    *(_DWORD *)v16 = 0;
    *((_DWORD *)v16 + 1) = 0;
  }
  g_local_mhashes_dones[g_local_mhashes_index] = g_local_mhashes_dones[g_local_mhashes_index] + (double)hashes_done;
  total_secs = (double)total_tv_end_sys - (double)total_tv_start_sys;
  if ( (double)total_tv_end_sys - (double)total_tv_start_sys - last_total_secs <= 86400.0 )
  {
    last_total_secs = total_secs;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "cgminer time error total_secs = %f last_total_secs = %f",
        total_secs,
        last_total_secs);
      applog(3, tmp42, 0);
    }
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___16121, 7134);
    zero_stats();
    mutex_lock_1(&hash_lock, "cgminer.c", _func___16121, 7136);
  }
  if ( showlog )
  {
    d64 = (unsigned __int64)(total_mhashes_done / total_secs * 1000000.0);
    suffix_string(d64, displayed_hashes, 0x10u, 4);
    d64 = (unsigned __int64)(total_rolling * 1000000.0);
    g_displayed_rolling = (double)((int)total_rolling / 10) / 100.0;
    suffix_string(d64, displayed_rolling, 0x10u, 4);
    d64 = (unsigned __int64)(rolling1 * 1000000.0);
    suffix_string(d64, displayed_r1, 0x10u, 4);
    d64 = (unsigned __int64)(rolling5 * 1000000.0);
    suffix_string(d64, displayed_r5, 0x10u, 4);
    d64 = (unsigned __int64)(rolling15 * 1000000.0);
    suffix_string(d64, displayed_r15, 0x10u, 4);
    snprintf(
      (char *)statusline,
      0x100u,
      "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
      opt_log_interval,
      (const char *)displayed_rolling,
      (const char *)displayed_r1,
      (const char *)displayed_r5,
      (const char *)displayed_r15,
      (const char *)displayed_hashes);
  }
  mutex_unlock_1(&hash_lock, "cgminer.c", _func___16121, 7177);
  if ( showlog )
  {
    printf("%s          \r", (const char *)statusline);
    fflush((FILE *)stdout);
  }
}
// 52010: variable 'v2' is possibly undefined
// 5225A: variable 'fsecs' is possibly undefined
// 5225A: variable 'interval' is possibly undefined
// 52286: variable 'fsecsa' is possibly undefined
// 52286: variable 'intervala' is possibly undefined
// 522B2: variable 'fsecsb' is possibly undefined
// 522B2: variable 'intervalb' is possibly undefined
// 522DE: variable 'fsecsc' is possibly undefined
// 522DE: variable 'intervalc' is possibly undefined
// 52498: variable 'fsecsd' is possibly undefined
// 52498: variable 'intervald' is possibly undefined
// 524B4: variable 'fsecse' is possibly undefined
// 524B4: variable 'intervale' is possibly undefined
// 524D0: variable 'fsecsf' is possibly undefined
// 524D0: variable 'intervalf' is possibly undefined
// 526C6: variable 'fsecsg' is possibly undefined
// 526C6: variable 'intervalg' is possibly undefined
// 526F0: variable 'fsecsh' is possibly undefined
// 526F0: variable 'intervalh' is possibly undefined
// 5271A: variable 'fsecsi' is possibly undefined
// 5271A: variable 'intervali' is possibly undefined
// AC42C: using guessed type int stdout;

//----- (00052B88) --------------------------------------------------------
void __cdecl stratum_share_result(json_t_0 *val, json_t_0 *res_val, json_t_0 *err_val, stratum_share *sshare)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  unsigned __int8 hashshow[64]; // [sp+824h] [bp+814h] BYREF
  int srdiff; // [sp+864h] [bp+854h]
  time_t now_t; // [sp+868h] [bp+858h]
  work *work; // [sp+86Ch] [bp+85Ch]

  work = sshare->work;
  now_t = time(0);
  srdiff = now_t - sshare->sshare_sent;
  if ( (opt_debug || srdiff > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stratum share result lag time %d seconds", work->pool->pool_no, srdiff);
    applog(6, tmp42, 0);
  }
  show_hash(work, hashshow);
  share_result(val, res_val, err_val, work, hashshow, 0, (unsigned __int8 *)byte_8A828);
}

//----- (00052C80) --------------------------------------------------------
bool __cdecl parse_stratum_response(pool *pool, unsigned __int8 *s)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+10h] BYREF
  int id; // [sp+818h] [bp+810h] BYREF
  json_error_t err; // [sp+81Ch] [bp+814h] BYREF
  double pool_diff; // [sp+918h] [bp+910h]
  unsigned int _hd_bkt; // [sp+920h] [bp+918h]
  UT_hash_handle *_hd_hh_del; // [sp+924h] [bp+91Ch]
  unsigned int _hf_bkt; // [sp+928h] [bp+920h]
  json_t_0 *version_mask; // [sp+92Ch] [bp+924h]
  json_t_0 *id_val; // [sp+930h] [bp+928h]
  json_t_0 *err_val; // [sp+934h] [bp+92Ch]
  json_t_0 *res_val; // [sp+938h] [bp+930h]
  json_t_0 *val; // [sp+93Ch] [bp+934h]
  const unsigned __int8 *_hj_key; // [sp+940h] [bp+938h]
  unsigned int _hj_k; // [sp+944h] [bp+93Ch]
  unsigned int _hj_j; // [sp+948h] [bp+940h]
  unsigned int _hj_i; // [sp+94Ch] [bp+944h]
  unsigned int _hf_hashv; // [sp+950h] [bp+948h]
  unsigned __int8 *ss; // [sp+954h] [bp+94Ch]
  bool ret; // [sp+95Bh] [bp+953h]
  stratum_share *sshare; // [sp+95Ch] [bp+954h]

  val = 0;
  ret = 0;
  val = json_loads(s, 0, &err);
  if ( val )
  {
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    id_val = json_object_get(val, "id");
    if ( id_val && id_val->type == JSON_NULL || !id_val )
    {
      if ( err_val )
        ss = json_dumps(err_val, 3u);
      else
        ss = (unsigned __int8 *)strdup("(unknown reason)");
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "JSON-RPC non method decode failed: %s", (const char *)ss);
        applog(6, tmp42, 0);
      }
      free(ss);
    }
    else
    {
      version_mask = json_object_get(res_val, "version-rolling.mask");
      if ( !version_mask
        && !strstr((const char *)s, "mining.configure")
        && !strstr((const char *)s, "mining.set_version_mask") )
      {
        id = json_integer_value(id_val);
        mutex_lock_1(&sshare_lock, "cgminer.c", _func___16169, 7264);
        _hj_key = (const unsigned __int8 *)&id;
        _hj_k = 4;
        _hj_i = (HIBYTE(id) << 24) - 1640531527;
        _hj_i += BYTE2(id) << 16;
        _hj_i += BYTE1(id) << 8;
        _hj_i += (unsigned __int8)id;
        _hj_i += 1640531527;
        _hj_i += 17973517;
        _hj_i ^= 0x7F76Du;
        _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
        _hf_hashv = -17973517 - _hj_i - _hj_j;
        _hf_hashv ^= _hj_j >> 13;
        _hj_i -= _hj_j;
        _hj_i -= _hf_hashv;
        _hj_i ^= _hf_hashv >> 12;
        _hj_j -= _hf_hashv;
        _hj_j -= _hj_i;
        _hj_j ^= _hj_i << 16;
        _hf_hashv -= _hj_i;
        _hf_hashv -= _hj_j;
        _hf_hashv ^= _hj_j >> 5;
        _hj_i -= _hj_j;
        _hj_i -= _hf_hashv;
        _hj_i ^= _hf_hashv >> 3;
        _hj_j -= _hf_hashv;
        _hj_j -= _hj_i;
        _hj_j ^= _hj_i << 10;
        _hf_hashv -= _hj_i;
        _hf_hashv -= _hj_j;
        _hf_hashv ^= _hj_j >> 15;
        sshare = 0;
        if ( stratum_shares )
        {
          _hf_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hf_hashv;
          if ( stratum_shares->hh.tbl->buckets[_hf_bkt].hh_head )
            sshare = (stratum_share *)((char *)stratum_shares->hh.tbl->buckets[_hf_bkt].hh_head
                                     - stratum_shares->hh.tbl->hho);
          else
            sshare = 0;
          while ( sshare && (_hf_hashv != sshare->hh.hashv || sshare->hh.keylen != 4 || memcmp(sshare->hh.key, &id, 4u)) )
          {
            if ( sshare->hh.hh_next )
              sshare = (stratum_share *)((char *)sshare->hh.hh_next - stratum_shares->hh.tbl->hho);
            else
              sshare = 0;
          }
        }
        if ( sshare )
        {
          if ( sshare->hh.prev || sshare->hh.next )
          {
            _hd_hh_del = &sshare->hh;
            if ( sshare == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) )
              stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
            if ( sshare->hh.prev )
              *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
            else
              stratum_shares = (stratum_share *)sshare->hh.next;
            if ( _hd_hh_del->next )
              *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
            _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
            --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
            if ( _hd_hh_del == stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head )
              stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
            if ( _hd_hh_del->hh_prev )
              _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
            if ( _hd_hh_del->hh_next )
              _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
            --stratum_shares->hh.tbl->num_items;
          }
          else
          {
            free(stratum_shares->hh.tbl->buckets);
            free(stratum_shares->hh.tbl);
            stratum_shares = 0;
          }
          --pool->sshares;
        }
        mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16169, 7272);
        if ( sshare )
        {
          stratum_share_result(val, res_val, err_val, sshare);
          free_work(&sshare->work, "cgminer.c", _func___16169, 7317);
          free(sshare);
          ret = 1;
        }
        else if ( res_val )
        {
          cg_rlock_0(&pool->data_lock, "cgminer.c", _func___16169, 7284);
          pool_diff = pool->sdiff;
          cg_runlock_0(&pool->data_lock, "cgminer.c", _func___16169, 7286);
          if ( res_val && res_val->type == JSON_TRUE )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf((char *)tmp42, 0x800u, "Accepted untracked stratum share from pool %d", pool->pool_no);
              applog(5, tmp42, 0);
            }
            mutex_lock_1(&stats_lock, "cgminer.c", _func___16169, 7294);
            ++total_accepted;
            ++pool->accepted;
            total_diff_accepted = total_diff_accepted + pool_diff;
            pool->diff_accepted = pool->diff_accepted + pool_diff;
            mutex_unlock_1(&stats_lock, "cgminer.c", _func___16169, 7299);
          }
          else
          {
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf((char *)tmp42, 0x800u, "Rejected untracked stratum share from pool %d", pool->pool_no);
              applog(5, tmp42, 0);
            }
            mutex_lock_1(&stats_lock, "cgminer.c", _func___16169, 7305);
            ++total_rejected;
            ++pool->rejected;
            total_diff_rejected = total_diff_rejected + pool_diff;
            pool->diff_rejected = pool->diff_rejected + pool_diff;
            mutex_unlock_1(&stats_lock, "cgminer.c", _func___16169, 7310);
          }
        }
      }
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
    applog(6, tmp42, 0);
  }
  if ( val )
    json_decref_0(val);
  return ret;
}
// 530FE: conditional instruction was optimized away because %_hj_k.4==4

//----- (000539E0) --------------------------------------------------------
void __cdecl clear_stratum_shares(pool *pool)
{
  stratum_share *next; // r3
  stratum_share *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  unsigned int _hd_bkt; // [sp+814h] [bp+80Ch]
  UT_hash_handle *_hd_hh_del; // [sp+818h] [bp+810h]
  int cleared; // [sp+81Ch] [bp+814h]
  double diff_cleared; // [sp+820h] [bp+818h]
  stratum_share *tmpshare; // [sp+828h] [bp+820h]
  stratum_share *sshare; // [sp+82Ch] [bp+824h]

  diff_cleared = 0.0;
  cleared = 0;
  mutex_lock_1(&sshare_lock, "cgminer.c", _func___16205, 7339);
  sshare = stratum_shares;
  if ( stratum_shares )
    next = (stratum_share *)stratum_shares->hh.next;
  else
    next = 0;
  tmpshare = next;
  while ( sshare )
  {
    if ( pool == sshare->work->pool )
    {
      if ( sshare->hh.prev || sshare->hh.next )
      {
        _hd_hh_del = &sshare->hh;
        if ( sshare == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) )
          stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
        if ( sshare->hh.prev )
          *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
        else
          stratum_shares = (stratum_share *)sshare->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
        if ( _hd_hh_del == stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head )
          stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --stratum_shares->hh.tbl->num_items;
      }
      else
      {
        free(stratum_shares->hh.tbl->buckets);
        free(stratum_shares->hh.tbl);
        stratum_shares = 0;
      }
      diff_cleared = diff_cleared + sshare->work->work_difficulty;
      free_work(&sshare->work, "cgminer.c", _func___16205, 7347);
      --pool->sshares;
      free(sshare);
      ++cleared;
    }
    sshare = tmpshare;
    if ( tmpshare )
      v2 = (stratum_share *)tmpshare->hh.next;
    else
      v2 = 0;
    tmpshare = v2;
  }
  mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16205, 7353);
  if ( cleared )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", cleared, pool->pool_no);
      applog(4, tmp42, 0);
    }
    pool->stale_shares += cleared;
    total_stale += cleared;
    pool->diff_stale = pool->diff_stale + diff_cleared;
    total_diff_stale = total_diff_stale + diff_cleared;
  }
}

//----- (00053DC8) --------------------------------------------------------
void __cdecl clear_pool_work(pool *pool)
{
  work *next; // r3
  UT_hash_bucket_0 *v2; // r3
  work *v3; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  work *work; // [sp+814h] [bp+80Ch] BYREF
  unsigned int _hd_bkt; // [sp+818h] [bp+810h]
  UT_hash_handle *_hd_hh_del; // [sp+81Ch] [bp+814h]
  int cleared; // [sp+820h] [bp+818h]
  work *tmp; // [sp+824h] [bp+81Ch]

  cleared = 0;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___16218, 7370);
  work = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( pool == work->pool )
    {
      if ( work->hh.prev || work->hh.next )
      {
        _hd_hh_del = &work->hh;
        if ( (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) == work )
          staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
        if ( work->hh.prev )
          *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
        else
          staged_work = (work *)work->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v2 = &staged_work->hh.tbl->buckets[_hd_bkt];
        --v2->count;
        if ( _hd_hh_del == staged_work->hh.tbl->buckets[_hd_bkt].hh_head )
          staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --staged_work->hh.tbl->num_items;
      }
      else
      {
        free(staged_work->hh.tbl->buckets);
        free(staged_work->hh.tbl);
        staged_work = 0;
      }
      free_work(&work, "cgminer.c", _func___16218, 7376);
      ++cleared;
    }
    work = tmp;
    if ( tmp )
      v3 = (work *)tmp->hh.next;
    else
      v3 = 0;
    tmp = v3;
  }
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___16218, 7380);
  if ( cleared && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Cleared %d work items due to stratum disconnect on pool %d",
      cleared,
      pool->pool_no);
    applog(6, tmp42, 0);
  }
}

//----- (0005411C) --------------------------------------------------------
int cp_prio()
{
  int prio; // [sp+4h] [bp+4h]

  cg_rlock_0(&control_lock, "cgminer.c", _func___16229, 7390);
  prio = currentpool->prio;
  cg_runlock_0(&control_lock, "cgminer.c", _func___16229, 7392);
  return prio;
}

//----- (0005417A) --------------------------------------------------------
bool __cdecl cnx_needed(pool *pool)
{
  bool v1; // r3
  int prio; // r4

  if ( pool->enabled != POOL_ENABLED )
    return 0;
  if ( pool_strategy_0 == POOL_BALANCE )
    return 1;
  if ( pool_strategy_0 == POOL_LOADBALANCE )
    return 1;
  if ( pool->has_stratum && pool->idle )
    return 1;
  if ( current_pool() == pool )
    return 1;
  if ( pool->sshares )
    return 1;
  v1 = pool_strategy_0 == POOL_FAILOVER && (prio = pool->prio, prio < cp_prio()) || no_work;
  return v1;
}

//----- (00054226) --------------------------------------------------------
void __cdecl stratum_resumed(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( pool_tclear(pool, &pool->idle) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d resumed", pool->pool_no);
      applog(6, tmp42, 0);
    }
    pool_resus(pool);
  }
}

//----- (000542AE) --------------------------------------------------------
bool __cdecl supports_resume(pool *pool)
{
  bool ret; // [sp+Fh] [bp+Fh]

  cg_rlock_0(&pool->data_lock, "cgminer.c", _func___16249, 7455);
  ret = pool->sessionid != 0;
  cg_runlock_0(&pool->data_lock, "cgminer.c", _func___16249, 7457);
  return ret;
}

//----- (0005430C) --------------------------------------------------------
void *__cdecl stratum_rthread(void *userdata)
{
  pthread_t v1; // r0
  bool v2; // nf
  int v3; // r0
  int sock; // r3
  int v5; // r0
  fd_set rd; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+90h] [bp+88h] BYREF
  work *work; // [sp+890h] [bp+888h] BYREF
  timeval timeout; // [sp+894h] [bp+88Ch] BYREF
  unsigned __int8 threadname[16]; // [sp+89Ch] [bp+894h] BYREF
  int sel_ret; // [sp+8ACh] [bp+8A4h]
  fd_set *__arr; // [sp+8B0h] [bp+8A8h]
  pool *pool; // [sp+8B4h] [bp+8ACh]
  unsigned int __i; // [sp+8B8h] [bp+8B0h]
  unsigned __int8 *s; // [sp+8BCh] [bp+8B4h]

  pool = (pool *)userdata;
  v1 = pthread_self();
  pthread_detach(v1);
  snprintf((char *)threadname, 0x10u, "%d/RStratum", pool->pool_no);
  RenameThread(threadname);
  while ( !pool->removed )
  {
    if ( !sock_full(pool) && !cnx_needed(pool) )
    {
      suspend_stratum(pool);
      clear_stratum_shares(pool);
      clear_pool_work(pool);
      wait_lpcurrent(pool);
      while ( !restart_stratum(pool) )
      {
        pool_died(pool);
        if ( pool->removed )
          return 0;
        cgsleep_ms(5000);
      }
    }
    __arr = &rd;
    for ( __i = 0; __i <= 0x1F; ++__i )
      __arr->fds_bits[__i] = 0;
    sock = pool->sock;
    v3 = -sock;
    v2 = -sock < 0;
    LOBYTE(sock) = sock & 0x1F;
    v5 = v3 & 0x1F;
    if ( !v2 )
      sock = -v5;
    rd.fds_bits[pool->sock / 32] |= 1 << sock;
    timeout.tv_sec = 90;
    timeout.tv_usec = 0;
    if ( !sock_full(pool) && (sel_ret = select(pool->sock + 1, &rd, 0, 0, &timeout), sel_ret <= 0) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum select failed on pool %d with value %d", pool->pool_no, sel_ret);
        applog(7, tmp42, 0);
      }
      s = 0;
    }
    else
    {
      s = recv_line(pool);
    }
    if ( s )
    {
      stratum_resumed(pool);
      if ( !parse_method(pool, s) && !parse_stratum_response(pool, s) && !parse_version_rolling_mask(pool, s) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Unknown stratum msg: %s", (const char *)s);
          applog(6, tmp42, 0);
        }
      }
      else if ( pool->swork.clean )
      {
        work = make_work();
        pool->swork.clean = 0;
        gen_stratum_work(pool, work);
        work->longpoll = 1;
        test_work_current(work);
        free_work(&work, "cgminer.c", _func___16277, 7569);
      }
      free(s);
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d interrupted", pool->pool_no);
        applog(5, tmp42, 0);
      }
      ++pool->getfail_occasions;
      ++total_go;
      if ( !supports_resume(pool) || opt_lowmem )
        clear_stratum_shares(pool);
      clear_pool_work(pool);
      if ( pool == current_pool() )
        restart_threads();
      while ( !restart_stratum(pool) )
      {
        pool_died(pool);
        if ( pool->removed )
          return 0;
        cgsleep_ms(5000);
      }
    }
  }
  suspend_stratum(pool);
  return 0;
}

//----- (00054738) --------------------------------------------------------
void *__cdecl stratum_sthread(void *userdata)
{
  pthread_t v1; // r0
  uint64_t v2; // r0
  int v3; // r2
  unsigned __int8 *rpc_user; // r6
  unsigned __int8 *job_id; // r4
  unsigned __int8 *ntime; // r5
  uint32_t v7; // r10
  uint32_t v8; // r0
  __uint32_t v9; // r0
  size_t v10; // r0
  stratum_share *v11; // r4
  UT_hash_table *tbl; // r4
  unsigned int v13; // r3
  bool v14; // r3
  unsigned __int8 s[1024]; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+424h] [bp+40Ch] BYREF
  uint32_t pool_version; // [sp+C24h] [bp+C0Ch] BYREF
  work *work; // [sp+C28h] [bp+C10h] BYREF
  unsigned __int8 nonce2[8]; // [sp+C2Ch] [bp+C14h] BYREF
  uint32_t nonce; // [sp+C34h] [bp+C1Ch] BYREF
  unsigned __int8 nonce2hex[20]; // [sp+C38h] [bp+C20h] BYREF
  unsigned __int8 noncehex[12]; // [sp+C4Ch] [bp+C34h] BYREF
  unsigned __int8 threadname[16]; // [sp+C58h] [bp+C40h] BYREF
  int ssdiff; // [sp+C68h] [bp+C50h]
  UT_hash_bucket_0 *_he_newbkt; // [sp+C6Ch] [bp+C54h]
  unsigned int _he_bkt; // [sp+C70h] [bp+C58h]
  UT_hash_handle *_he_hh_nxt; // [sp+C74h] [bp+C5Ch]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+C78h] [bp+C60h]
  unsigned int _ha_bkt; // [sp+C7Ch] [bp+C64h]
  bool sessionid_match; // [sp+C83h] [bp+C6Bh]
  uint32_t *hash32; // [sp+C84h] [bp+C6Ch]
  stratum_share *sshare; // [sp+C88h] [bp+C70h]
  uint64_t *nonce2_64; // [sp+C8Ch] [bp+C74h]
  pool *pool; // [sp+C90h] [bp+C78h]
  UT_hash_handle *_he_thh; // [sp+C94h] [bp+C7Ch]
  unsigned int _he_bkt_i; // [sp+C98h] [bp+C80h]
  const unsigned __int8 *_hj_key; // [sp+C9Ch] [bp+C84h]
  unsigned int _hj_k; // [sp+CA0h] [bp+C88h]
  unsigned int _hj_j; // [sp+CA4h] [bp+C8Ch]
  unsigned int _hj_i; // [sp+CA8h] [bp+C90h]
  unsigned int _ha_hashv; // [sp+CACh] [bp+C94h]
  bool submitted; // [sp+CB3h] [bp+C9Bh]
  uint32_t last_nonce; // [sp+CB4h] [bp+C9Ch]
  uint64_t last_nonce2; // [sp+CB8h] [bp+CA0h]

  pool = (pool *)userdata;
  last_nonce2 = 0LL;
  last_nonce = 0;
  v1 = pthread_self();
  pthread_detach(v1);
  snprintf((char *)threadname, 0x10u, "%d/SStratum", pool->pool_no);
  RenameThread(threadname);
  pool->stratum_q = tq_new();
  if ( !pool->stratum_q )
  {
    strcpy((char *)tmp42, "Failed to create stratum_q in stratum_sthread");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "in %s ", (const char *)_FUNCTION___16288);
    applog(5, tmp42, 0);
  }
  while ( !pool->removed )
  {
    work = (work *)tq_pop(pool->stratum_q, 0);
    if ( !work )
    {
      strcpy((char *)tmp42, "Stratum q returned empty work");
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( work->nonce2_len <= 8 )
    {
      nonce = *(_DWORD *)&work->data[76];
      nonce2_64 = (uint64_t *)nonce2;
      v2 = _uint64_identity_0(work->nonce2);
      *nonce2_64 = v2;
      if ( last_nonce == nonce && last_nonce2 == *nonce2_64 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Filtering duplicate share to pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        free_work(&work, "cgminer.c", _func___16303, 7636);
      }
      else
      {
        last_nonce = nonce;
        last_nonce2 = *nonce2_64;
        _bin2hex(noncehex, (const unsigned __int8 *)&nonce, 4u);
        _bin2hex(nonce2hex, nonce2, work->nonce2_len);
        sshare = (stratum_share *)cgcalloc(52, 1u, "cgminer.c", _func___16303, 7645);
        hash32 = (uint32_t *)work->hash;
        submitted = 0;
        sshare->sshare_time = time(0);
        sshare->work = work;
        memset(s, 0, sizeof(s));
        mutex_lock_1(&sshare_lock, "cgminer.c", _func___16303, 7654);
        v3 = swork_id++;
        sshare->id = v3;
        mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16303, 7657);
        pool_version = 0;
        hex2bin((unsigned __int8 *)&pool_version, pool->bbversion, 4u);
        if ( pool->support_ab )
        {
          rpc_user = pool->rpc_user;
          job_id = work->job_id;
          ntime = work->ntime;
          v7 = swab32_1(work->version);
          v8 = swab32_1(pool_version);
          snprintf(
            (char *)s,
            0x400u,
            "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
            (const char *)rpc_user,
            (const char *)job_id,
            (const char *)nonce2hex,
            (const char *)ntime,
            (const char *)noncehex,
            v7 & ~v8,
            sshare->id);
        }
        else
        {
          snprintf(
            (char *)s,
            0x400u,
            "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
            (const char *)pool->rpc_user,
            (const char *)work->job_id,
            (const char *)nonce2hex,
            (const char *)work->ntime,
            (const char *)noncehex,
            sshare->id);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          v9 = _uint32_identity_0(hash32[6]);
          snprintf((char *)tmp42, 0x800u, "Submitting share %08lx to pool %d", v9, pool->pool_no);
          applog(6, tmp42, 0);
        }
        while ( time(0) < sshare->sshare_time + 120 )
        {
          v10 = strlen((const char *)s);
          if ( stratum_send(pool, s, v10) )
          {
            mutex_lock_1(&sshare_lock, "cgminer.c", _func___16303, 7696);
            _hj_key = (const unsigned __int8 *)&sshare->id;
            _hj_j = -1640531527;
            _hj_i = -1640531527;
            _hj_k = 4;
            _ha_hashv = -17973517;
            _hj_i = (HIBYTE(sshare->id) << 24) - 1640531527;
            _hj_i += BYTE2(sshare->id) << 16;
            _hj_i += BYTE1(sshare->id) << 8;
            _hj_i += LOBYTE(sshare->id);
            _hj_i += 1640531527;
            _hj_i += 17973517;
            _hj_i ^= 0x7F76Du;
            _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
            _ha_hashv = -17973517 - _hj_i - _hj_j;
            _ha_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _ha_hashv;
            _hj_i ^= _ha_hashv >> 12;
            _hj_j -= _ha_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _ha_hashv -= _hj_i;
            _ha_hashv -= _hj_j;
            _ha_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _ha_hashv;
            _hj_i ^= _ha_hashv >> 3;
            _hj_j -= _ha_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _ha_hashv -= _hj_i;
            _ha_hashv -= _hj_j;
            _ha_hashv ^= _hj_j >> 15;
            sshare->hh.hashv = _ha_hashv;
            sshare->hh.key = &sshare->id;
            sshare->hh.keylen = 4;
            if ( stratum_shares )
            {
              sshare->hh.tbl = stratum_shares->hh.tbl;
              sshare->hh.next = 0;
              sshare->hh.prev = (char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho;
              stratum_shares->hh.tbl->tail->next = sshare;
              stratum_shares->hh.tbl->tail = &sshare->hh;
            }
            else
            {
              sshare->hh.next = 0;
              sshare->hh.prev = 0;
              stratum_shares = sshare;
              v11 = sshare;
              v11->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
              if ( !stratum_shares->hh.tbl )
                exit(-1);
              memset(stratum_shares->hh.tbl, 0, sizeof(UT_hash_table));
              stratum_shares->hh.tbl->tail = &stratum_shares->hh;
              stratum_shares->hh.tbl->num_buckets = 32;
              stratum_shares->hh.tbl->log2_num_buckets = 5;
              stratum_shares->hh.tbl->hho = 0;
              tbl = stratum_shares->hh.tbl;
              tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
              if ( !stratum_shares->hh.tbl->buckets )
                exit(-1);
              memset(stratum_shares->hh.tbl->buckets, 0, 0x180u);
              stratum_shares->hh.tbl->signature = -1609490463;
            }
            ++stratum_shares->hh.tbl->num_items;
            _ha_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _ha_hashv;
            ++stratum_shares->hh.tbl->buckets[_ha_bkt].count;
            sshare->hh.hh_next = stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head;
            sshare->hh.hh_prev = 0;
            if ( stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head )
              stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &sshare->hh;
            stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head = &sshare->hh;
            if ( stratum_shares->hh.tbl->buckets[_ha_bkt].count >= 10
                                                                 * (stratum_shares->hh.tbl->buckets[_ha_bkt].expand_mult
                                                                  + 1)
              && sshare->hh.tbl->noexpand != 1 )
            {
              _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * sshare->hh.tbl->num_buckets);
              if ( !_he_new_buckets )
                exit(-1);
              memset(_he_new_buckets, 0, 24 * sshare->hh.tbl->num_buckets);
              sshare->hh.tbl->ideal_chain_maxlen = (sshare->hh.tbl->num_items >> (sshare->hh.tbl->log2_num_buckets + 1))
                                                 + (((2 * sshare->hh.tbl->num_buckets - 1) & sshare->hh.tbl->num_items) != 0);
              sshare->hh.tbl->nonideal_items = 0;
              for ( _he_bkt_i = 0; _he_bkt_i < sshare->hh.tbl->num_buckets; ++_he_bkt_i )
              {
                for ( _he_thh = sshare->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
                {
                  _he_hh_nxt = _he_thh->hh_next;
                  _he_bkt = (2 * sshare->hh.tbl->num_buckets - 1) & _he_thh->hashv;
                  _he_newbkt = &_he_new_buckets[_he_bkt];
                  if ( ++_he_newbkt->count > sshare->hh.tbl->ideal_chain_maxlen )
                  {
                    ++sshare->hh.tbl->nonideal_items;
                    _he_newbkt->expand_mult = _he_newbkt->count / sshare->hh.tbl->ideal_chain_maxlen;
                  }
                  _he_thh->hh_prev = 0;
                  _he_thh->hh_next = _he_newbkt->hh_head;
                  if ( _he_newbkt->hh_head )
                    _he_newbkt->hh_head->hh_prev = _he_thh;
                  _he_newbkt->hh_head = _he_thh;
                }
              }
              free(sshare->hh.tbl->buckets);
              sshare->hh.tbl->num_buckets *= 2;
              ++sshare->hh.tbl->log2_num_buckets;
              sshare->hh.tbl->buckets = _he_new_buckets;
              if ( sshare->hh.tbl->nonideal_items <= sshare->hh.tbl->num_items >> 1 )
                v13 = 0;
              else
                v13 = sshare->hh.tbl->ineff_expands + 1;
              sshare->hh.tbl->ineff_expands = v13;
              if ( sshare->hh.tbl->ineff_expands > 1 )
                sshare->hh.tbl->noexpand = 1;
            }
            ++pool->sshares;
            mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16303, 7699);
            if ( pool_tclear(pool, &pool->submit_fail) && (use_syslog || opt_log_output || opt_log_level > 3) )
            {
              snprintf((char *)tmp42, 0x800u, "Pool %d communication resumed, submitting work", pool->pool_no);
              applog(4, tmp42, 0);
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "Successfully submitted, adding to stratum_shares db");
              applog(7, tmp42, 0);
            }
            submitted = 1;
            break;
          }
          if ( !pool_tset(pool, &pool->submit_fail) && cnx_needed(pool) )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf((char *)tmp42, 0x800u, "Pool %d stratum share submission failure", pool->pool_no);
              applog(4, tmp42, 0);
            }
            ++total_ro;
            ++pool->remotefail_occasions;
          }
          if ( opt_lowmem )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "Lowmem option prevents resubmitting stratum share");
              applog(7, tmp42, 0);
            }
            break;
          }
          cg_rlock_0(&pool->data_lock, "cgminer.c", _func___16303, 7721);
          v14 = pool->nonce1 && !strcmp((const char *)work->nonce1, (const char *)pool->nonce1);
          sessionid_match = v14;
          cg_runlock_0(&pool->data_lock, "cgminer.c", _func___16303, 7723);
          if ( !sessionid_match )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "No matching session id for resubmitting stratum share");
              applog(7, tmp42, 0);
            }
            break;
          }
          sleep(2u);
        }
        if ( !submitted )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Failed to submit stratum share, discarding");
            applog(7, tmp42, 0);
          }
          free_work(&work, "cgminer.c", _func___16303, 7738);
          free(sshare);
          ++pool->stale_shares;
          ++total_stale;
        }
        else
        {
          sshare->sshare_sent = time(0);
          ssdiff = sshare->sshare_sent - sshare->sshare_time;
          if ( (opt_debug || ssdiff > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Pool %d stratum share submission lag time %d seconds",
              pool->pool_no,
              ssdiff);
            applog(6, tmp42, 0);
          }
        }
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d asking for inappropriately long nonce2 length %d",
          pool->pool_no,
          work->nonce2_len);
        applog(3, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "Not attempting to submit shares");
        applog(3, tmp42, 0);
      }
      free_work(&work, "cgminer.c", _func___16303, 7624);
    }
  }
  tq_freeze(pool->stratum_q);
  return 0;
}
// 54F40: conditional instruction was optimized away because %_hj_k.4==4

//----- (00055BA0) --------------------------------------------------------
void __cdecl init_stratum_threads(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  have_longpoll = 1;
  if ( pthread_create(&pool->stratum_sthread, 0, (void *(*)(void *))stratum_sthread, pool) )
  {
    strcpy((char *)tmp42, "Failed to create stratum sthread");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_create(&pool->stratum_rthread, 0, (void *(*)(void *))stratum_rthread, pool) )
  {
    strcpy((char *)tmp42, "Failed to create stratum rthread");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00055C62) --------------------------------------------------------
bool __cdecl stratum_works(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %d stratum %s", pool->pool_no, (const char *)pool->stratum_url);
    applog(6, tmp42, 0);
  }
  return extract_sockaddr(pool->stratum_url, &pool->sockaddr_url, &pool->stratum_port) && initiate_stratum(pool);
}

//----- (00055D1E) --------------------------------------------------------
bool __cdecl setup_gbt_solo(CURL *curl, pool *pool)
{
  return 0;
}

//----- (00055D36) --------------------------------------------------------
void __cdecl pool_start_lp(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  if ( !pool->lp_started )
  {
    pool->lp_started = 1;
    if ( pthread_create(&pool->longpoll_thread, 0, (void *(*)(void *))longpoll_thread, pool) )
    {
      strcpy((char *)tmp42, "Failed to create pool longpoll thread");
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (00055DC0) --------------------------------------------------------
bool __cdecl pool_active(pool *pool, bool pinging)
{
  bool v2; // r3
  unsigned __int8 *v4; // r3
  size_t v5; // r4
  const char *v6; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  work *work; // [sp+814h] [bp+80Ch] BYREF
  timeval tv_getwork_reply; // [sp+818h] [bp+810h] BYREF
  timeval tv_getwork; // [sp+820h] [bp+818h] BYREF
  bool ret_0; // [sp+82Ah] [bp+822h]
  size_t siz; // [sp+82Ch] [bp+824h]
  unsigned __int8 *copy_start; // [sp+830h] [bp+828h]
  unsigned __int8 *hdr_path; // [sp+834h] [bp+82Ch]
  bool rc; // [sp+83Bh] [bp+833h]
  CURL *curl; // [sp+848h] [bp+840h]
  json_t_0 *val; // [sp+850h] [bp+848h]
  bool need_slash; // [sp+857h] [bp+84Fh]
  bool ret; // [sp+867h] [bp+85Fh]

  val = 0;
  ret = 0;
  if ( pool->has_gbt )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Retrieving block template from pool %s", (const char *)pool->rpc_url);
      applog(7, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %s", (const char *)pool->rpc_url);
    applog(6, tmp42, 0);
  }
  while ( 1 )
  {
    if ( pool->has_stratum )
    {
      if ( pool_tset(pool, &pool->stratum_init) )
        return pool->stratum_active;
      v2 = initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool);
      ret_0 = v2;
      if ( v2 )
        init_stratum_threads(pool);
      else
        pool_tclear(pool, &pool->stratum_init);
      return ret_0;
    }
    curl = curly;
    if ( !curly )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "CURL initialisation failed");
        applog(3, tmp42, 0);
      }
      return 0;
    }
    if ( !pool->probed )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Probing for GBT support");
        applog(7, tmp42, 0);
      }
      val = 0;
      pool->probed = 0;
      if ( pool->has_gbt )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "GBT coinbase + append support found, switching to GBT protocol");
          applog(7, tmp42, 0);
        }
      }
      else if ( pool->gbt_solo )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "GBT coinbase without append found, switching to GBT solo protocol");
          applog(7, tmp42, 0);
        }
      }
      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "No GBT coinbase + append support found, pool unusable if it has no stratum");
        applog(7, tmp42, 0);
      }
    }
    cgtime(&tv_getwork);
    val = 0;
    cgtime(&tv_getwork_reply);
    if ( !pool->stratum_url || opt_fix_protocol || !stratum_works(pool) )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Switching pool %d %s to %s",
        pool->pool_no,
        (const char *)pool->rpc_url,
        (const char *)pool->stratum_url);
      applog(5, tmp42, 0);
    }
    if ( !pool->rpc_url )
      pool->rpc_url = (unsigned __int8 *)strdup((const char *)pool->stratum_url);
    pool->has_stratum = 1;
  }
  if ( !pool->has_stratum && !pool->gbt_solo && !pool->has_gbt )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "No Stratum, GBT or Solo support in pool %d %s unable to use",
        pool->pool_no,
        (const char *)pool->rpc_url);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  else
  {
    if ( val )
    {
      work = make_work();
      rc = 0;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Successfully retrieved but FAILED to decipher work from pool %u %s",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(7, tmp42, 0);
      }
      free_work(&work, "cgminer.c", _func___16409, 8059);
      if ( !pool->lp_url )
      {
        if ( pool->hdr_path )
        {
          need_slash = 0;
          hdr_path = pool->hdr_path;
          if ( strstr((const char *)hdr_path, "://") )
          {
            pool->lp_url = hdr_path;
            hdr_path = 0;
          }
          else
          {
            if ( *hdr_path == 47 )
              v4 = hdr_path + 1;
            else
              v4 = hdr_path;
            copy_start = v4;
            if ( pool->rpc_url[strlen((const char *)pool->rpc_url) - 1] != 47 )
              need_slash = 1;
            v5 = strlen((const char *)pool->rpc_url);
            siz = strlen((const char *)copy_start) + v5 + 2;
            pool->lp_url = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___16409, 8092);
            if ( need_slash )
              v6 = "/";
            else
              v6 = byte_8A828;
            snprintf((char *)pool->lp_url, siz, "%s%s%s", (const char *)pool->rpc_url, v6, (const char *)copy_start);
          }
        }
        else
        {
          pool->lp_url = 0;
        }
        pool_start_lp(pool);
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "FAILED to retrieve work from pool %u %s",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(7, tmp42, 0);
      }
      if ( !pinging && !pool->idle && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %u slow/down or URL or credentials invalid", pool->pool_no);
        applog(4, tmp42, 0);
      }
    }
    if ( val )
      json_decref_0(val);
    return ret;
  }
}

//----- (00056938) --------------------------------------------------------
void __cdecl pool_resus(pool *pool)
{
  int prio; // r4
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  pool->seq_getfails = 0;
  if ( pool_strategy_0 || (prio = pool->prio, prio >= cp_prio()) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s alive", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d %s alive, testing stability", pool->pool_no, (const char *)pool->rpc_url);
    applog(4, tmp42, 0);
  }
}

//----- (00056A36) --------------------------------------------------------
work *__cdecl hash_pop(bool blocking)
{
  int num_items; // r3
  work *next; // r3
  work *v3; // r3
  UT_hash_bucket_0 *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  timeval now; // [sp+808h] [bp+808h] BYREF
  timespec then; // [sp+810h] [bp+810h] BYREF
  unsigned int _hd_bkt; // [sp+818h] [bp+818h]
  UT_hash_handle *_hd_hh_del; // [sp+81Ch] [bp+81Ch]
  int hc; // [sp+820h] [bp+820h]
  work *tmp; // [sp+828h] [bp+828h]
  work *work; // [sp+82Ch] [bp+82Ch]

  work = 0;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___16430, 8145);
  if ( !staged_work || !staged_work->hh.tbl->num_items )
  {
    work_emptied = 1;
    if ( !blocking )
      goto out_unlock;
    do
    {
      cgtime(&now);
      then.tv_sec = now.tv_sec + 10;
      then.tv_nsec = 1000 * now.tv_usec;
      pthread_cond_signal(&gws_cond);
      if ( pthread_cond_timedwait(&getq->cond, stgd_lock, &then) )
      {
        if ( !no_work )
        {
          no_work = 1;
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy((char *)tmp42, "Waiting for work to be available from pools.");
            applog(4, tmp42, 0);
          }
        }
      }
    }
    while ( !staged_work || !staged_work->hh.tbl->num_items );
  }
  if ( no_work )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Work available from pools, resuming.");
      applog(4, tmp42, 0);
    }
    no_work = 0;
  }
  if ( staged_work )
    num_items = staged_work->hh.tbl->num_items;
  else
    num_items = 0;
  hc = num_items;
  if ( num_items <= staged_rollable )
  {
    work = staged_work;
  }
  else
  {
    work = staged_work;
    if ( staged_work )
      next = (work *)staged_work->hh.next;
    else
      next = 0;
    tmp = next;
    while ( work && work_rollable(work) )
    {
      work = tmp;
      if ( tmp )
        v3 = (work *)tmp->hh.next;
      else
        v3 = 0;
      tmp = v3;
    }
  }
  if ( work->hh.prev || work->hh.next )
  {
    _hd_hh_del = &work->hh;
    if ( work == (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) )
      staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
    if ( work->hh.prev )
      *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
    else
      staged_work = (work *)work->hh.next;
    if ( _hd_hh_del->next )
      *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
    _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
    v4 = &staged_work->hh.tbl->buckets[_hd_bkt];
    --v4->count;
    if ( _hd_hh_del == staged_work->hh.tbl->buckets[_hd_bkt].hh_head )
      staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
    if ( _hd_hh_del->hh_prev )
      _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
    if ( _hd_hh_del->hh_next )
      _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
    --staged_work->hh.tbl->num_items;
  }
  else
  {
    free(staged_work->hh.tbl->buckets);
    free(staged_work->hh.tbl);
    staged_work = 0;
  }
  if ( work_rollable(work) )
    --staged_rollable;
  pthread_cond_signal(&gws_cond);
  pthread_cond_signal(&getq->cond);
  last_getwork = time(0);
out_unlock:
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___16430, 8217);
  return work;
}

//----- (00056F5A) --------------------------------------------------------
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len)
{
  unsigned __int8 hash1[32]; // [sp+10h] [bp+10h] BYREF

  sha256(data, len, hash1);
  sha256(hash1, 0x20u, hash);
}

//----- (00056F90) --------------------------------------------------------
void __cdecl set_target(unsigned __int8 *dest_target, double diff)
{
  double v2; // d0
  uint64_t v3; // r0
  uint64_t v4; // r0
  double diffa; // [sp+8h] [bp+0h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 target[32]; // [sp+818h] [bp+810h] BYREF
  unsigned __int8 *htarget; // [sp+838h] [bp+830h]
  uint64_t *data64; // [sp+83Ch] [bp+834h]
  uint64_t h64; // [sp+840h] [bp+838h]
  double dcut64; // [sp+848h] [bp+840h]
  double d64; // [sp+850h] [bp+848h]

  diffa = v2;
  if ( v2 == 0.0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "Diff zero passed to set_target");
      applog(3, tmp42, 0);
    }
    diffa = 1.0;
  }
  d64 = 2.69595353e67 / diffa;
  dcut64 = 2.69595353e67 / diffa / 6.27710174e57;
  h64 = (unsigned __int64)dcut64;
  data64 = (uint64_t *)&target[24];
  v3 = _uint64_identity_0((unsigned __int64)dcut64);
  *data64 = v3;
  d64 = d64 - (double)h64 * 6.27710174e57;
  dcut64 = d64 / 3.40282367e38;
  h64 = (unsigned __int64)(d64 / 3.40282367e38);
  data64 = (uint64_t *)&target[16];
  *(_QWORD *)&target[16] = _uint64_identity_0(h64);
  d64 = d64 - (double)h64 * 3.40282367e38;
  dcut64 = d64 / 1.84467441e19;
  h64 = (unsigned __int64)(d64 / 1.84467441e19);
  data64 = (uint64_t *)&target[8];
  *(_QWORD *)&target[8] = _uint64_identity_0(h64);
  dcut64 = (double)h64 * 1.84467441e19;
  d64 = d64 - dcut64;
  h64 = (unsigned __int64)d64;
  data64 = (uint64_t *)target;
  v4 = _uint64_identity_0((unsigned __int64)d64);
  *data64 = v4;
  if ( opt_debug )
  {
    htarget = bin2hex(target, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated target %s", (const char *)htarget);
      applog(7, tmp42, 0);
    }
    free(htarget);
  }
  cg_memcpy(dest_target, target, 0x20u, "cgminer.c", _func___16462, 8279);
}
// 56FA0: variable 'v2' is possibly undefined

//----- (00057330) --------------------------------------------------------
void __cdecl get_work_by_nonce2(
        thr_info *thr,
        work **work,
        pool *pool,
        pool *real_pool,
        uint64_t nonce2,
        uint32_t version)
{
  int thr_id; // [sp+1Ch] [bp+14h]

  *work = make_work();
  thr_id = thr->id;
  cg_wlock_1(&pool->data_lock, "cgminer.c", _func___16472, 8293);
  pool->nonce2 = nonce2;
  version = (version << 24) | HIBYTE(version) | (version >> 8) & 0xFF00 | (version << 8) & 0xFF0000;
  cg_memcpy(pool->header_bin, &version, 4u, "cgminer.c", _func___16472, 8296);
  cg_wunlock_1(&pool->data_lock, "cgminer.c", _func___16472, 8297);
  gen_stratum_work(pool, *work);
  (*work)->pool = real_pool;
  (*work)->thr_id = thr_id;
  (*work)->work_block = work_block;
  ++(*work)->pool->works;
  (*work)->mined = 1;
  (*work)->version = version;
}

//----- (00057438) --------------------------------------------------------
void __cdecl gen_stratum_work(pool *pool, work *work)
{
  uint64_t nonce2; // kr00_8
  double v3; // r2
  double v4; // r2
  work *worka; // [sp+10h] [bp+0h] BYREF
  pool *poola; // [sp+14h] [bp+4h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp+8h] BYREF
  uint64_t nonce2le; // [sp+818h] [bp+808h] BYREF
  unsigned __int8 merkle_sha[64]; // [sp+824h] [bp+814h] BYREF
  unsigned __int8 merkle_root[32]; // [sp+864h] [bp+854h] BYREF
  unsigned __int8 *merkle_hash; // [sp+884h] [bp+874h]
  unsigned __int8 *header; // [sp+888h] [bp+878h]
  uint32_t *swap32; // [sp+88Ch] [bp+87Ch]
  uint32_t *data32; // [sp+890h] [bp+880h]
  int i; // [sp+894h] [bp+884h]

  poola = pool;
  worka = work;
  cg_wlock_1(&pool->data_lock, "cgminer.c", _func___16483, 8323);
  nonce2le = _uint64_identity_0(poola->nonce2);
  cg_memcpy(&poola->coinbase[poola->nonce2_offset], &nonce2le, poola->n2size, "cgminer.c", _func___16483, 8328);
  nonce2 = poola->nonce2;
  poola->nonce2 = nonce2 + 1;
  worka->nonce2 = nonce2;
  worka->nonce2_len = poola->n2size;
  cg_dwlock(&poola->data_lock, "cgminer.c", _func___16483, 8334);
  gen_hash(poola->coinbase, merkle_root, poola->coinbase_len);
  cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", _func___16483, 8338);
  for ( i = 0; i < poola->merkles; ++i )
  {
    cg_memcpy(&merkle_sha[32], poola->swork.merkle_bin[i], 0x20u, "cgminer.c", _func___16483, 8342);
    gen_hash(merkle_sha, merkle_root, 64);
    cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", _func___16483, 8344);
  }
  data32 = (uint32_t *)merkle_sha;
  swap32 = (uint32_t *)merkle_root;
  flip32_0(merkle_root, merkle_sha);
  cg_memcpy(worka, poola->header_bin, 0x70u, "cgminer.c", _func___16483, 8353);
  cg_memcpy(&worka->data[36], merkle_root, 0x20u, "cgminer.c", _func___16483, 8354);
  worka->sdiff = poola->sdiff;
  worka->job_id = (unsigned __int8 *)strdup((const char *)poola->swork.job_id);
  worka->nonce1 = (unsigned __int8 *)strdup((const char *)poola->nonce1);
  worka->ntime = (unsigned __int8 *)strdup((const char *)poola->ntime);
  cg_runlock_0(&poola->data_lock, "cgminer.c", _func___16483, 8365);
  if ( opt_debug )
  {
    header = bin2hex(worka->data, 0x70u);
    merkle_hash = bin2hex(merkle_root, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated stratum merkle %s", (const char *)merkle_hash);
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated stratum header %s", (const char *)header);
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Work job_id %s nonce2 %llu ntime %s",
        (const char *)worka->job_id,
        worka->nonce2,
        (const char *)worka->ntime);
      applog(7, tmp42, 0);
    }
    free(header);
    free(merkle_hash);
  }
  calc_midstate(worka);
  LODWORD(v3) = worka->target;
  HIDWORD(v3) = worka;
  set_target(worka->target, v3);
  ++local_work;
  if ( time(0) - local_work_lasttime > 5 )
  {
    local_work_lasttime = time(0);
    local_work_last = local_work;
  }
  worka->pool = poola;
  worka->stratum = 1;
  worka->nonce = 0;
  worka->longpoll = 0;
  worka->getwork_mode = 83;
  worka->work_block = work_block;
  LODWORD(v4) = 60;
  worka->drv_rolllimit = 60;
  HIDWORD(v4) = &worka;
  calc_diff(worka, v4);
  cgtime(&worka->tv_staged);
}

//----- (00057936) --------------------------------------------------------
void __cdecl set_benchmark_work(cgpu_info *cgpu, work *work)
{
  cgpu->lodiff += cgpu->direction;
  if ( cgpu->lodiff <= 0 )
    cgpu->direction = 1;
  if ( cgpu->lodiff <= 15 )
  {
    cg_memcpy(work, bench_lodiff_bins[cgpu->lodiff], 0xA0u, "cgminer.c", _func___16499, 8590);
  }
  else
  {
    cgpu->direction = -1;
    if ( ++cgpu->hidiff > 15 )
      cgpu->hidiff = 0;
    cg_memcpy(work, bench_hidiff_bins[cgpu->hidiff], 0xA0u, "cgminer.c", _func___16499, 8586);
  }
}

//----- (00057A14) --------------------------------------------------------
work *__cdecl get_work(thr_info *thr, const int thr_id)
{
  int max_diff_low; // r3
  int max_diff_high; // r4
  work *v4; // r2
  int device_diff_low; // r3
  int device_diff_high; // r4
  work *v7; // r2
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  work *work; // [sp+80Ch] [bp+80Ch] BYREF
  time_t diff_t; // [sp+810h] [bp+810h]
  cgpu_info *cgpu; // [sp+814h] [bp+814h]

  cgpu = thr->cgpu;
  work = 0;
  thread_reportout(thr);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Popping work from get queue to get work");
    applog(7, tmp42, 0);
  }
  diff_t = time(0);
  while ( !work )
  {
    work = hash_pop(1);
    if ( stale_work(work, 0) )
    {
      discard_work(&work, "cgminer.c", _func___16508, 8609);
      wake_gws();
    }
  }
  diff_t = time(0) - diff_t;
  if ( diff_t > 0 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Get work blocked for %ld seconds", diff_t);
      applog(7, tmp42, 0);
    }
    cgpu->last_device_valid_work += diff_t;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Got work from get queue to get work for thread %d", thr_id);
    applog(7, tmp42, 0);
  }
  work->thr_id = thr_id;
  if ( opt_benchmark )
    set_benchmark_work(cgpu, work);
  thread_reportin(thr);
  work->mined = 1;
  if ( cgpu->drv->max_diff <= work->work_difficulty )
  {
    max_diff_high = HIDWORD(cgpu->drv->max_diff);
    max_diff_low = LODWORD(cgpu->drv->max_diff);
  }
  else
  {
    max_diff_high = HIDWORD(work->work_difficulty);
    max_diff_low = LODWORD(work->work_difficulty);
  }
  v4 = work;
  LODWORD(work->device_diff) = max_diff_low;
  HIDWORD(v4->device_diff) = max_diff_high;
  if ( cgpu->drv->min_diff <= work->device_diff )
  {
    device_diff_high = HIDWORD(work->device_diff);
    device_diff_low = LODWORD(work->device_diff);
  }
  else
  {
    device_diff_high = HIDWORD(cgpu->drv->min_diff);
    device_diff_low = LODWORD(cgpu->drv->min_diff);
  }
  v7 = work;
  LODWORD(work->device_diff) = device_diff_low;
  HIDWORD(v7->device_diff) = device_diff_high;
  return work;
}

//----- (00057C98) --------------------------------------------------------
void __cdecl submit_work_async(work *work)
{
  work *worka[2]; // [sp+Ch] [bp+4h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  pthread_t submit_thread; // [sp+814h] [bp+80Ch] BYREF
  cgpu_info *cgpu; // [sp+818h] [bp+810h]
  pool *pool; // [sp+81Ch] [bp+814h]

  worka[0] = work;
  pool = work->pool;
  cgtime(&work->tv_work_found);
  if ( opt_benchmark )
  {
    cgpu = get_thr_cgpu(worka[0]->thr_id);
    mutex_lock_1(&stats_lock, "cgminer.c", _func___16520, 8653);
    ++cgpu->accepted;
    ++total_accepted;
    ++pool->accepted;
    cgpu->diff_accepted = cgpu->diff_accepted + worka[0]->work_difficulty;
    total_diff_accepted = worka[0]->work_difficulty + total_diff_accepted;
    pool->diff_accepted = pool->diff_accepted + worka[0]->work_difficulty;
    mutex_unlock_1(&stats_lock, "cgminer.c", _func___16520, 8660);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Accepted %s %d benchmark share nonce %08x",
        (const char *)cgpu->drv->name,
        cgpu->device_id,
        *(_DWORD *)&worka[0]->data[76]);
      applog(5, tmp42, 0);
    }
    return;
  }
  if ( !stale_work(worka[0], 1) )
    goto LABEL_23;
  if ( opt_submit_stale )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as user requested", pool->pool_no);
      applog(5, tmp42, 0);
    }
LABEL_22:
    worka[0]->stale = 1;
LABEL_23:
    if ( worka[0]->stratum )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Pushing pool %d work to stratum queue", pool->pool_no);
        applog(7, tmp42, 0);
      }
      if ( !pool->stratum_q || !tq_push(pool->stratum_q, worka[0]) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          strcpy((char *)tmp42, "Discarding work from removed pool");
          applog(4, tmp42, 0);
        }
        if ( !pool->stratum_q && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          snprintf((char *)tmp42, 0x800u, "Pushing pool %d work to stratum queue", pool->pool_no);
          applog(5, tmp42, 0);
        }
        free_work(worka, "cgminer.c", _func___16520, 8704);
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "Pushing submit work to work thread");
        applog(5, tmp42, 0);
      }
      if ( pthread_create(&submit_thread, 0, (void *(*)(void *))submit_work_thread, worka[0]) )
      {
        strcpy((char *)tmp42, "Failed to create submit_work_thread");
        applog(3, tmp42, 1);
        quit(1);
      }
    }
    return;
  }
  if ( pool->submit_old )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as pool requested", pool->pool_no);
      applog(5, tmp42, 0);
    }
    goto LABEL_22;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, discarding", pool->pool_no);
    applog(5, tmp42, 0);
  }
  sharelog("discard", worka[0]);
  mutex_lock_1(&stats_lock, "cgminer.c", _func___16520, 8681);
  ++total_stale;
  ++pool->stale_shares;
  total_diff_stale = worka[0]->work_difficulty + total_diff_stale;
  pool->diff_stale = pool->diff_stale + worka[0]->work_difficulty;
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___16520, 8688);
  free_work(worka, "cgminer.c", _func___16520, 8690);
}

//----- (00058260) --------------------------------------------------------
void __cdecl inc_hw_errors(thr_info *thr)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s %d: invalid nonce - HW error",
      (const char *)thr->cgpu->drv->name,
      thr->cgpu->device_id);
    applog(6, tmp42, 0);
  }
  mutex_lock_1(&stats_lock, "cgminer.c", _func___16534, 8721);
  ++hw_errors;
  ++thr->cgpu->hw_errors;
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___16534, 8724);
  thr->cgpu->drv->hw_error(thr);
}

//----- (0005834A) --------------------------------------------------------
void __cdecl rebuild_nonce(work *work, uint32_t nonce)
{
  *(_DWORD *)&work->data[76] = _uint32_identity_0(nonce);
  regen_hash(work);
}

//----- (00058374) --------------------------------------------------------
bool __cdecl test_nonce(work *work, uint32_t nonce)
{
  uint32_t *hash_32; // [sp+Ch] [bp+Ch]

  hash_32 = (uint32_t *)&work->hash[28];
  rebuild_nonce(work, nonce);
  return *hash_32 == 0;
}

//----- (000583A4) --------------------------------------------------------
void __cdecl update_work_stats(thr_info *thr, work *work)
{
  cgpu_info *cgpu; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  double test_diff; // [sp+808h] [bp+808h]

  test_diff = current_diff;
  work->share_diff = share_diff(work);
  if ( test_diff <= (double)work->share_diff )
  {
    work->block = 1;
    ++work->pool->solved;
    ++found_blocks;
    work->mandatory = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Found block for pool %d!", work->pool->pool_no);
      applog(5, tmp42, 0);
    }
  }
  mutex_lock_1(&stats_lock, "cgminer.c", _func___16569, 8799);
  total_diff1 = (__int64)((double)total_diff1 + work->device_diff);
  thr->cgpu->diff1 = (__int64)((double)thr->cgpu->diff1 + work->device_diff);
  work->pool->diff1 = (__int64)((double)work->pool->diff1 + work->device_diff);
  cgpu = thr->cgpu;
  cgpu->last_device_valid_work = time(0);
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___16569, 8804);
}

//----- (0005859C) --------------------------------------------------------
bool __cdecl submit_tested_work(thr_info *thr, work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  work *work_out; // [sp+814h] [bp+80Ch]

  update_work_stats(thr, work);
  if ( !fulltest(work->hash, work->target) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s %s %d: Share above target",
        (const char *)_FUNCTION___16582,
        (const char *)thr->cgpu->drv->name,
        thr->cgpu->device_id);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    work_out = copy_work_noffset(work, 0);
    submit_work_async(work_out);
    return 1;
  }
}

//----- (0005866A) --------------------------------------------------------
bool __cdecl new_nonce(thr_info *thr, uint32_t nonce)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  cgpu_info *cgpu; // [sp+814h] [bp+80Ch]

  cgpu = thr->cgpu;
  if ( nonce == cgpu->last_nonce )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s %d duplicate share detected as HW error",
        (const char *)cgpu->drv->name,
        cgpu->device_id);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    cgpu->last_nonce = nonce;
    return 1;
  }
}

//----- (0005870E) --------------------------------------------------------
bool __cdecl submit_nonce(thr_info *thr, work *work, uint32_t nonce)
{
  if ( new_nonce(thr, nonce) && test_nonce(work, nonce) )
  {
    submit_tested_work(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
      benchfile_dspwork(work, nonce);
    return 1;
  }
  else
  {
    inc_hw_errors(thr);
    return 0;
  }
}

//----- (00058778) --------------------------------------------------------
bool __cdecl abandon_work(work *work, timeval *wdiff, uint64_t hashes)
{
  return wdiff->tv_sec > opt_scantime || hashes > 0xFFFFFFFD || stale_work(work, 0);
}

//----- (000587C8) --------------------------------------------------------
void __cdecl mt_disable(thr_info *mythr, const int thr_id, device_drv *drv)
{
  cgpu_info *cgpu; // r2
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+10h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being disabled", thr_id);
    applog(4, tmp42, 0);
  }
  cgpu = mythr->cgpu;
  LODWORD(cgpu->rolling) = 0;
  HIDWORD(cgpu->rolling) = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Waiting on sem in miner thread");
    applog(7, tmp42, 0);
  }
  cgsem_wait(&mythr->sem, "cgminer.c", _func___16675, 9101);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being re-enabled", thr_id);
    applog(4, tmp42, 0);
  }
  drv->thread_enable(mythr);
}

//----- (0005893A) --------------------------------------------------------
void __cdecl hash_sole_work(thr_info *mythr)
{
  int v1; // r3
  bool v2; // r3
  int max_diff_low; // r3
  int max_diff_high; // r4
  work *v5; // r2
  int device_diff_low; // r3
  int device_diff_high; // r4
  work *v8; // r2
  bool v9; // zf
  int v10; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  timespec rgtp; // [sp+810h] [bp+808h] BYREF
  work *work; // [sp+818h] [bp+810h] BYREF
  timeval wdiff; // [sp+81Ch] [bp+814h] BYREF
  timeval diff; // [sp+824h] [bp+81Ch]
  timeval sdiff; // [sp+82Ch] [bp+824h]
  timeval tv_lastupdate; // [sp+834h] [bp+82Ch] BYREF
  timeval tv_workstart; // [sp+83Ch] [bp+834h] BYREF
  timeval tv_start; // [sp+844h] [bp+83Ch] BYREF
  timeval getwork_start; // [sp+84Ch] [bp+844h] BYREF
  int mult; // [sp+854h] [bp+84Ch]
  int64_t hashes; // [sp+858h] [bp+850h]
  cgminer_stats *pool_stats; // [sp+860h] [bp+858h]
  timeval *tv_end; // [sp+864h] [bp+85Ch]
  bool primary; // [sp+86Bh] [bp+863h]
  int cycle; // [sp+86Ch] [bp+864h]
  cgminer_stats *dev_stats; // [sp+870h] [bp+868h]
  device_drv *drv; // [sp+874h] [bp+86Ch]
  cgpu_info *cgpu; // [sp+878h] [bp+870h]
  int thr_id; // [sp+87Ch] [bp+874h]
  int64_t hashes_done; // [sp+880h] [bp+878h]
  uint32_t max_nonce; // [sp+88Ch] [bp+884h]

  thr_id = mythr->id;
  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  dev_stats = &cgpu->cgminer_stats;
  v1 = opt_log_interval / 5;
  if ( !(opt_log_interval / 5) )
    v1 = 1;
  cycle = v1;
  v2 = !mythr->device_thread || mythr->primary_thread;
  primary = v2;
  wdiff.tv_sec = 0;
  wdiff.tv_usec = 0;
  max_nonce = drv->can_limit_work(mythr);
  hashes_done = 0LL;
  tv_end = &getwork_start;
  cgtime(&getwork_start);
  sdiff.tv_usec = 0;
  sdiff.tv_sec = 0;
  cgtime(&tv_lastupdate);
  while ( !cgpu->shutdown )
  {
    work = get_work(mythr, thr_id);
    mythr->work_restart = 0;
    cgpu->new_work = 1;
    cgtime(&tv_workstart);
    work->nonce = 0;
    cgpu->max_hashes = 0LL;
    if ( !drv->prepare_work(mythr, work) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "work prepare failed, exiting mining thread %d", thr_id);
        applog(3, tmp42, 0);
      }
      break;
    }
    if ( drv->max_diff <= work->work_difficulty )
    {
      max_diff_high = HIDWORD(drv->max_diff);
      max_diff_low = LODWORD(drv->max_diff);
    }
    else
    {
      max_diff_high = HIDWORD(work->work_difficulty);
      max_diff_low = LODWORD(work->work_difficulty);
    }
    v5 = work;
    LODWORD(work->device_diff) = max_diff_low;
    HIDWORD(v5->device_diff) = max_diff_high;
    if ( drv->min_diff <= work->device_diff )
    {
      device_diff_high = HIDWORD(work->device_diff);
      device_diff_low = LODWORD(work->device_diff);
    }
    else
    {
      device_diff_high = HIDWORD(drv->min_diff);
      device_diff_low = LODWORD(drv->min_diff);
    }
    v8 = work;
    LODWORD(work->device_diff) = device_diff_low;
    HIDWORD(v8->device_diff) = device_diff_high;
    while ( 1 )
    {
      cgtime(&tv_start);
      subtime(&tv_start, &getwork_start);
      addtime(&getwork_start, &dev_stats->getwork_wait);
      if ( time_more(&getwork_start, &dev_stats->getwork_wait_max) )
        copy_time(&dev_stats->getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, &dev_stats->getwork_wait_min) )
        copy_time(&dev_stats->getwork_wait_min, &getwork_start);
      ++dev_stats->getwork_calls;
      pool_stats = &work->pool->cgminer_stats;
      addtime(&getwork_start, &pool_stats->getwork_wait);
      if ( time_more(&getwork_start, &pool_stats->getwork_wait_max) )
        copy_time(&pool_stats->getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, &pool_stats->getwork_wait_min) )
        copy_time(&pool_stats->getwork_wait_min, &getwork_start);
      ++pool_stats->getwork_calls;
      cgtime(&work->tv_work_start);
      pthread_setcancelstate(1, 0);
      thread_reportin(mythr);
      hashes = ((__int64 (__fastcall *)(thr_info *, work *, uint32_t, _DWORD))drv->scanhash)(
                 mythr,
                 work,
                 max_nonce + work->nonce,
                 0);
      thread_reportout(mythr);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      cgtime(&getwork_start);
      v9 = HIDWORD(hashes) == -1;
      if ( HIDWORD(hashes) == -1 )
        v9 = (_DWORD)hashes == -1;
      if ( v9 )
        break;
      hashes_done += hashes;
      if ( cgpu->max_hashes < hashes )
        cgpu->max_hashes = hashes;
      diff.tv_sec = tv_end->tv_sec - tv_start.tv_sec;
      diff.tv_usec = tv_end->tv_usec - tv_start.tv_usec;
      if ( diff.tv_usec < 0 )
      {
        --diff.tv_sec;
        diff.tv_usec += 1000000;
      }
      sdiff.tv_sec += diff.tv_sec;
      sdiff.tv_usec += diff.tv_usec;
      if ( sdiff.tv_usec > (int)&calc_nonce_info.chain_asic_core_nonce_num[5][48][190] )
      {
        ++sdiff.tv_sec;
        sdiff.tv_usec -= 1000000;
      }
      wdiff.tv_sec = tv_end->tv_sec - tv_workstart.tv_sec;
      wdiff.tv_usec = tv_end->tv_usec - tv_workstart.tv_usec;
      if ( wdiff.tv_usec < 0 )
      {
        --wdiff.tv_sec;
        wdiff.tv_usec += 1000000;
      }
      if ( cycle <= sdiff.tv_sec )
      {
        if ( cycle >= sdiff.tv_sec )
        {
          if ( sdiff.tv_usec > 100000 )
            max_nonce = (max_nonce << 10)
                      / (((int)&calc_nonce_info.chain_asic_core_nonce_num[5][48][190] * cycle + sdiff.tv_usec)
                       / ((int)&calc_nonce_info.chain_asic_core_nonce_num[5][48][190]
                        * cycle
                        / 1024));
        }
        else
        {
          max_nonce = max_nonce * cycle / sdiff.tv_sec;
        }
      }
      else
      {
        if ( max_nonce == -1 )
          goto LABEL_70;
        v10 = sdiff.tv_usec + 1024;
        if ( sdiff.tv_usec + 1024 < 0 )
          v10 = sdiff.tv_usec + 2047;
        mult = cycle * ((int)&calc_nonce_info.chain_asic_core_nonce_num[5][48][190] / (v10 >> 10) + 16);
        if ( max_nonce <= 0xFFFFFC00 / mult )
          max_nonce = (max_nonce * mult) >> 10;
        else
          max_nonce = -1;
      }
      diff.tv_sec = tv_end->tv_sec - tv_lastupdate.tv_sec;
      diff.tv_usec = tv_end->tv_usec - tv_lastupdate.tv_usec;
      if ( diff.tv_usec < 0 )
      {
        --diff.tv_sec;
        diff.tv_usec += 1000000;
      }
      if ( hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000) || diff.tv_sec >= opt_log_interval )
      {
        hashmeter(thr_id, hashes_done);
        hashes_done = 0LL;
        copy_time(&tv_lastupdate, tv_end);
      }
      if ( mythr->work_restart )
      {
        if ( !primary )
        {
          rgtp.tv_sec = 0;
          rgtp.tv_nsec = 250000000 * mythr->device_thread;
          nanosleep(&rgtp, 0);
        }
        goto LABEL_71;
      }
      if ( mythr->pause || cgpu->deven )
        mt_disable(mythr, thr_id, drv);
      sdiff.tv_usec = 0;
      sdiff.tv_sec = 0;
LABEL_70:
      if ( abandon_work(work, &wdiff, cgpu->max_hashes) )
        goto LABEL_71;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
      applog(3, tmp42, 0);
    }
    cgpu->deven = DEV_DISABLED;
    dev_error(cgpu, REASON_THREAD_ZERO_HASH);
    cgpu->shutdown = 1;
LABEL_71:
    free_work(&work, "cgminer.c", _func___16707, 9299);
  }
  cgpu->deven = DEV_DISABLED;
}
// 589BE: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (00059114) --------------------------------------------------------
void __cdecl flush_queue(cgpu_info *cgpu)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  work *work; // [sp+80Ch] [bp+80Ch] BYREF

  work = 0;
  if ( cgpu )
  {
    if ( !wr_trylock(&cgpu->qlock, "cgminer.c", _func___16873, 9582) )
    {
      work = cgpu->unqueued_work;
      cgpu->unqueued_work = 0;
      wr_unlock(&cgpu->qlock, "cgminer.c", _func___16873, 9589);
      if ( work )
      {
        free_work(&work, "cgminer.c", _func___16873, 9593);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Discarded queued work item");
          applog(7, tmp42, 0);
        }
      }
    }
  }
}

//----- (00059226) --------------------------------------------------------
void __cdecl hash_driver_work(thr_info *mythr)
{
  bool v1; // zf
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  timeval diff; // [sp+810h] [bp+808h]
  timeval tv_end; // [sp+818h] [bp+810h] BYREF
  timeval tv_start; // [sp+820h] [bp+818h] BYREF
  int64_t hashes; // [sp+828h] [bp+820h]
  int thr_id; // [sp+834h] [bp+82Ch]
  device_drv *drv; // [sp+838h] [bp+830h]
  cgpu_info *cgpu; // [sp+83Ch] [bp+834h]
  int64_t hashes_done; // [sp+840h] [bp+838h]

  tv_start.tv_sec = 0;
  tv_start.tv_usec = 0;
  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  thr_id = mythr->id;
  hashes_done = 0LL;
  while ( !cgpu->shutdown )
  {
    mythr->work_update = 0;
    hashes = drv->scanwork(mythr);
    mythr->work_restart = 0;
    v1 = HIDWORD(hashes) == -1;
    if ( HIDWORD(hashes) == -1 )
      v1 = (_DWORD)hashes == -1;
    if ( v1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = DEV_DISABLED;
      dev_error(cgpu, REASON_THREAD_ZERO_HASH);
      break;
    }
    hashes_done += hashes;
    cgtime(&tv_end);
    diff.tv_sec = tv_end.tv_sec - tv_start.tv_sec;
    diff.tv_usec = tv_end.tv_usec - tv_start.tv_usec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    if ( hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000) || diff.tv_sec >= opt_log_interval )
    {
      hashmeter(thr_id, hashes_done);
      hashes_done = 0LL;
      copy_time(&tv_start, &tv_end);
    }
    if ( mythr->pause || cgpu->deven )
      mt_disable(mythr, thr_id, drv);
    if ( mythr->work_update )
    {
      mutex_lock_1(&update_job_lock, "cgminer.c", _func___16903, 9712);
      drv->update_work(cgpu);
      mutex_unlock_1(&update_job_lock, "cgminer.c", _func___16903, 9714);
    }
  }
  cgpu->deven = DEV_DISABLED;
}

//----- (0005948E) --------------------------------------------------------
void *__cdecl miner_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 threadname[16]; // [sp+808h] [bp+808h] BYREF
  device_drv *drv; // [sp+818h] [bp+818h]
  cgpu_info *cgpu; // [sp+81Ch] [bp+81Ch]
  int thr_id; // [sp+820h] [bp+820h]
  thr_info *mythr; // [sp+824h] [bp+824h]

  mythr = (thr_info *)userdata;
  thr_id = *(_DWORD *)userdata;
  cgpu = (cgpu_info *)*((_DWORD *)userdata + 9);
  drv = cgpu->drv;
  snprintf((char *)threadname, 0x10u, "%d/Miner", thr_id);
  RenameThread(threadname);
  thread_reportout(mythr);
  if ( !drv->thread_init(mythr) )
  {
    dev_error(cgpu, REASON_THREAD_FAIL_INIT);
  }
  else
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Waiting on sem in miner thread");
      applog(7, tmp42, 0);
    }
    cgsem_wait(&mythr->sem, "cgminer.c", _func___16916, 9741);
    cgpu->last_device_valid_work = time(0);
    drv->hash_work(mythr);
    drv->thread_shutdown(mythr);
  }
  return 0;
}

//----- (000595C8) --------------------------------------------------------
void __cdecl wait_lpcurrent(pool *pool)
{
  bool i; // r0

  for ( i = cnx_needed(pool);
        !i
     && (pool->enabled == POOL_DISABLED
      || pool != current_pool() && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE);
        i = cnx_needed(pool) )
  {
    mutex_lock_1(&lp_lock, "cgminer.c", _func___16924, 9853);
    pthread_cond_wait(&lp_cond, &lp_lock);
    mutex_unlock_1(&lp_lock, "cgminer.c", _func___16924, 9855);
  }
}

//----- (00059670) --------------------------------------------------------
void *__cdecl longpoll_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0005968E) --------------------------------------------------------
void __cdecl reinit_device(cgpu_info *cgpu)
{
  if ( cgpu->deven != DEV_DISABLED )
    cgpu->drv->reinit_device(cgpu);
}

//----- (000596B2) --------------------------------------------------------
void __cdecl reap_curl(pool *pool)
{
  const char *v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+Ch] BYREF
  timeval now; // [sp+814h] [bp+80Ch] BYREF
  int reaped; // [sp+81Ch] [bp+814h]
  curl_ent *iter; // [sp+820h] [bp+818h]
  curl_ent *ent; // [sp+824h] [bp+81Ch]

  reaped = 0;
  cgtime(&now);
  mutex_lock_1(&pool->pool_lock, "cgminer.c", _func___16942, 10098);
  ent = (curl_ent *)&pool->curlring.next[-1].prev;
  iter = CONTAINING_RECORD(ent->node.next, curl_ent, node);
  while ( &ent->node != &pool->curlring )
  {
    if ( pool->curls <= 1 )
      return;
    if ( now.tv_sec - ent->tv.tv_sec > 300 )
    {
      ++reaped;
      --pool->curls;
      list_del_0(&ent->node);
      free(ent);
    }
    ent = iter;
    iter = CONTAINING_RECORD(iter->node.next, curl_ent, node);
  }
  mutex_unlock_1(&pool->pool_lock, "cgminer.c", _func___16942, 10116);
  if ( reaped && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( reaped <= 1 )
      v1 = byte_8A828;
    else
      v1 = "s";
    snprintf((char *)tmp42, 0x800u, "Reaped %d curl%s from pool %d", reaped, v1, pool->pool_no);
    applog(7, tmp42, 0);
  }
}

//----- (00059836) --------------------------------------------------------
void __cdecl prune_stratum_shares(pool *pool)
{
  stratum_share *next; // r3
  stratum_share *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned int _hd_bkt; // [sp+810h] [bp+808h]
  UT_hash_handle *_hd_hh_del; // [sp+814h] [bp+80Ch]
  time_t current_time; // [sp+818h] [bp+810h]
  int cleared; // [sp+81Ch] [bp+814h]
  stratum_share *tmpshare; // [sp+820h] [bp+818h]
  stratum_share *sshare; // [sp+824h] [bp+81Ch]

  current_time = time(0);
  cleared = 0;
  mutex_lock_1(&sshare_lock, "cgminer.c", _func___16954, 10134);
  sshare = stratum_shares;
  if ( stratum_shares )
    next = (stratum_share *)stratum_shares->hh.next;
  else
    next = 0;
  tmpshare = next;
  while ( sshare )
  {
    if ( pool == sshare->work->pool && current_time > sshare->sshare_time + 120 )
    {
      if ( sshare->hh.prev || sshare->hh.next )
      {
        _hd_hh_del = &sshare->hh;
        if ( sshare == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) )
          stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
        if ( sshare->hh.prev )
          *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
        else
          stratum_shares = (stratum_share *)sshare->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
        if ( _hd_hh_del == stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head )
          stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --stratum_shares->hh.tbl->num_items;
      }
      else
      {
        free(stratum_shares->hh.tbl->buckets);
        free(stratum_shares->hh.tbl);
        stratum_shares = 0;
      }
      free_work(&sshare->work, "cgminer.c", _func___16954, 10141);
      free(sshare);
      ++cleared;
    }
    sshare = tmpshare;
    if ( tmpshare )
      v2 = (stratum_share *)tmpshare->hh.next;
    else
      v2 = 0;
    tmpshare = v2;
  }
  mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16954, 10147);
  if ( cleared )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Lost %d shares due to no stratum share response from pool %d",
        cleared,
        pool->pool_no);
      applog(4, tmp42, 0);
    }
    pool->stale_shares += cleared;
    total_stale += cleared;
  }
}

//----- (00059BC0) --------------------------------------------------------
void *__cdecl __noreturn watchpool_thread(void *userdata)
{
  int prio; // r4
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  timeval now; // [sp+810h] [bp+808h] BYREF
  cgtimer_t cgt; // [sp+818h] [bp+810h] BYREF
  double shares; // [sp+820h] [bp+818h]
  pool *pool; // [sp+82Ch] [bp+824h]
  int i; // [sp+830h] [bp+828h]
  int intervals; // [sp+834h] [bp+82Ch]

  intervals = 0;
  pthread_setcanceltype(1, 0);
  RenameThread("Watchpool");
  set_lowprio();
  cgtimer_time(&cgt);
  while ( 1 )
  {
    if ( ++intervals > 120 )
      intervals = 0;
    cgtime(&now);
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( !opt_benchmark && !opt_benchfile )
      {
        reap_curl(pool);
        prune_stratum_shares(pool);
      }
      if ( intervals > 119 )
      {
        shares = (double)(pool->diff1 - pool->last_shares);
        pool->last_shares = pool->diff1;
        pool->utility = (pool->utility + shares * 0.63) / 1.63;
        pool->shares = (int)pool->utility;
      }
      if ( pool->enabled && !pool->testing )
      {
        if ( pool_active(pool, 1) )
        {
          if ( pool_tclear(pool, &pool->idle) )
            pool_resus(pool);
        }
        else
        {
          cgtime(&pool->tv_idle);
        }
        if ( !pool->idle && pool_strategy_0 == POOL_FAILOVER )
        {
          prio = pool->prio;
          if ( prio < cp_prio() && now.tv_sec - pool->tv_idle.tv_sec > opt_pool_fallback )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Pool %d %s stable for >%d seconds",
                pool->pool_no,
                (const char *)pool->rpc_url,
                opt_pool_fallback);
              applog(4, tmp42, 0);
            }
            switch_pools(0);
          }
        }
      }
    }
    if ( current_pool()->idle )
      switch_pools(0);
    if ( pool_strategy_0 == POOL_ROTATE && now.tv_sec - rotate_tv.tv_sec > 60 * opt_rotate_period )
    {
      cgtime(&rotate_tv);
      switch_pools(0);
    }
    cgsleep_ms_r(&cgt, 5000);
    cgtimer_time(&cgt);
  }
}

//----- (00059EB0) --------------------------------------------------------
void *__cdecl __noreturn watchdog_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 dev_str[8]; // [sp+810h] [bp+808h] BYREF
  timeval now; // [sp+818h] [bp+810h] BYREF
  timeval zero_tv; // [sp+820h] [bp+818h] BYREF
  dev_enable *denable; // [sp+828h] [bp+820h]
  thr_info *thr_0; // [sp+82Ch] [bp+824h]
  cgpu_info *cgpu; // [sp+830h] [bp+828h]
  thr_info *thr; // [sp+834h] [bp+82Ch]
  unsigned int interval; // [sp+838h] [bp+830h]
  int i; // [sp+83Ch] [bp+834h]

  interval = 2;
  pthread_setcanceltype(1, 0);
  RenameThread("Watchdog");
  set_lowprio();
  memset(&zero_tv, 0, sizeof(zero_tv));
  cgtime(&rotate_tv);
LABEL_2:
  sleep(interval);
  discard_stale();
  hashmeter(-1, 0LL);
  cgtime(&now);
  if ( !sched_paused && !should_run() )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Pausing execution as per stop time %02d:%02d scheduled",
        schedstop.tm.tm_hour,
        schedstop.tm.tm_min);
      applog(4, tmp42, 0);
    }
    if ( !schedstart.enable )
    {
      strcpy((char *)tmp42, "Terminating execution as planned");
      applog(3, tmp42, 1);
      quit(0);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Will restart execution as scheduled at %02d:%02d",
        schedstart.tm.tm_hour,
        schedstart.tm.tm_min);
      applog(4, tmp42, 0);
    }
    sched_paused = 1;
    rd_lock_0(&mining_thr_lock, "cgminer.c", _func___16987, 10365);
    for ( i = 0; i < mining_threads; ++i )
      mining_thr[i]->pause = 1;
    rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___16987, 10372);
  }
  else if ( sched_paused && should_run() )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Restarting execution as per start time %02d:%02d scheduled",
        schedstart.tm.tm_hour,
        schedstart.tm.tm_min);
      applog(4, tmp42, 0);
    }
    if ( schedstop.enable && (use_syslog || opt_log_output || opt_log_level > 3) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Will pause execution as scheduled at %02d:%02d",
        schedstop.tm.tm_hour,
        schedstop.tm.tm_min);
      applog(4, tmp42, 0);
    }
    sched_paused = 0;
    for ( i = 0; i < mining_threads; ++i )
    {
      thr = get_thread(i);
      if ( thr->cgpu->deven != DEV_DISABLED )
      {
        thr->pause = 0;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Pushing sem post to thread %d", thr->id);
          applog(7, tmp42, 0);
        }
        cgsem_post(&thr->sem, "cgminer.c", _func___16987, 10399);
      }
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= total_devices )
      goto LABEL_2;
    cgpu = get_devices(i);
    thr_0 = *cgpu->thr;
    if ( thr_0 )
    {
      cgpu->drv->get_stats(cgpu);
      denable = &cgpu->deven;
      snprintf((char *)dev_str, 8u, "%s %d", (const char *)cgpu->drv->name, cgpu->device_id);
      if ( !thr_0->getwork && *denable != DEV_DISABLED )
      {
        if ( cgpu->status && now.tv_sec - thr_0->last.tv_sec <= 119 )
        {
          if ( cgpu->status != LIFE_INIT && (use_syslog || opt_log_output || opt_log_level > 2) )
          {
            snprintf((char *)tmp42, 0x800u, "%s: Recovered, declaring WELL!", (const char *)dev_str);
            applog(3, tmp42, 0);
          }
          cgpu->status = LIFE_WELL;
          cgpu->device_last_well = time(0);
        }
        else if ( cgpu->status || now.tv_sec - thr_0->last.tv_sec <= 120 )
        {
          if ( cgpu->status == LIFE_SICK && now.tv_sec - thr_0->last.tv_sec > 600 )
          {
            cgpu->status = LIFE_DEAD;
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: Not responded for more than 10 minutes, declaring DEAD!",
                (const char *)dev_str);
              applog(3, tmp42, 0);
            }
            cgtime(&thr_0->sick);
            dev_error(cgpu, REASON_DEV_DEAD_IDLE_600);
          }
          else if ( now.tv_sec - thr_0->sick.tv_sec > 60 && (cgpu->status == LIFE_SICK || cgpu->status == LIFE_DEAD) )
          {
            cgtime(&thr_0->sick);
            if ( opt_restart )
              goto LABEL_75;
          }
        }
        else
        {
          cgpu->rolling = 0LL;
          cgpu->status = LIFE_SICK;
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf((char *)tmp42, 0x800u, "%s: Idle for more than 60 seconds, declaring SICK!", (const char *)dev_str);
            applog(3, tmp42, 0);
          }
          cgtime(&thr_0->sick);
          dev_error(cgpu, REASON_DEV_SICK_IDLE_60);
          if ( opt_restart && !is_re_open_core_now() )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf((char *)tmp42, 0x800u, "%s: Attempting to restart", (const char *)dev_str);
              applog(3, tmp42, 0);
            }
LABEL_75:
            reinit_device(cgpu);
            continue;
          }
        }
      }
    }
  }
}

//----- (0005A5D4) --------------------------------------------------------
void __cdecl log_print_status(cgpu_info *cgpu)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 logline[255]; // [sp+808h] [bp+808h] BYREF

  get_statline(logline, 0xFFu, cgpu);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "%s", (const char *)logline);
    applog(4, tmp42, 0);
  }
}

//----- (0005A648) --------------------------------------------------------
void print_summary()
{
  const char *v0; // r3
  unsigned __int8 tmp42[2048]; // [sp+40h] [bp+30h] BYREF
  timeval diff; // [sp+840h] [bp+830h]
  cgpu_info *cgpu; // [sp+848h] [bp+838h]
  pool *pool; // [sp+84Ch] [bp+83Ch]
  double displayed_hashes; // [sp+850h] [bp+840h]
  double work_util; // [sp+858h] [bp+848h]
  double utility; // [sp+860h] [bp+850h]
  int secs; // [sp+868h] [bp+858h]
  int mins; // [sp+86Ch] [bp+85Ch]
  int hours; // [sp+870h] [bp+860h]
  int i; // [sp+874h] [bp+864h]

  diff.tv_sec = total_tv_end.tv_sec - total_tv_start.tv_sec;
  diff.tv_usec = total_tv_end.tv_usec - total_tv_start.tv_usec;
  if ( total_tv_end.tv_usec - total_tv_start.tv_usec < 0 )
  {
    --diff.tv_sec;
    diff.tv_usec += 1000000;
  }
  hours = diff.tv_sec / 3600;
  mins = diff.tv_sec % 3600 / 60;
  secs = diff.tv_sec % 60;
  utility = (double)total_accepted / total_secs * 60.0;
  work_util = (double)total_diff1 / total_secs * 60.0;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "\nSummary of runtime statistics:\n");
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Started at %s", (const char *)datestamp);
    applog(4, tmp42, 0);
  }
  if ( total_pools == 1 && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)(*pools)->rpc_url);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Runtime: %d hrs : %d mins : %d secs", hours, mins, secs);
    applog(4, tmp42, 0);
  }
  displayed_hashes = total_mhashes_done / total_secs;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Average hashrate: %.1f Mhash/s", displayed_hashes);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Solved blocks: %d", found_blocks);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Best share difficulty: %s", (const char *)best_share);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Share submissions: %lld", total_accepted + total_rejected);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Accepted shares: %lld", total_accepted);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Rejected shares: %lld", total_rejected);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Accepted difficulty shares: %1.f", total_diff_accepted);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Rejected difficulty shares: %1.f", total_diff_rejected);
    applog(4, tmp42, 0);
  }
  if ( (total_accepted || total_rejected) && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Reject ratio: %.1f%%",
      (double)(100 * total_rejected) / (double)(total_accepted + total_rejected));
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Hardware errors: %d", hw_errors);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Utility (accepted shares / min): %.2f/min", utility);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", work_util);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Stale submissions discarded due to new blocks: %lld", total_stale);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Unable to get work from server occasions: %d", total_go);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Work items generated locally: %d", local_work);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Submitting work remotely delay occasions: %d", total_ro);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "New blocks detected on network: %d\n", new_blocks);
    applog(4, tmp42, 0);
  }
  if ( total_pools > 1 )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)pool->rpc_url);
        applog(4, tmp42, 0);
      }
      if ( pool->solved && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        if ( pool->solved <= 1 )
          v0 = (const char *)&unk_8A828;
        else
          v0 = "S";
        snprintf((char *)tmp42, 0x800u, "SOLVED %d BLOCK%s!", pool->solved, v0);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Share submissions: %lld", pool->accepted + pool->rejected);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Accepted shares: %lld", pool->accepted);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Rejected shares: %lld", pool->rejected);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Accepted difficulty shares: %1.f", pool->diff_accepted);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Rejected difficulty shares: %1.f", pool->diff_rejected);
        applog(4, tmp42, 0);
      }
      if ( (pool->accepted || pool->rejected) && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          " Reject ratio: %.1f%%",
          (double)(100 * pool->rejected) / (double)(pool->accepted + pool->rejected));
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Items worked on: %d", pool->works);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Stale submissions discarded due to new blocks: %d", pool->stale_shares);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Unable to get work from server occasions: %d", pool->getfail_occasions);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Submitting work remotely delay occasions: %d\n", pool->remotefail_occasions);
        applog(4, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Summary of per device statistics:\n");
    applog(4, tmp42, 0);
  }
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu = get_devices(i);
    cgpu->drv->get_statline_before = (void (*)(unsigned __int8 *, size_t, cgpu_info *))blank_get_statline_before;
    cgpu->drv->get_statline = (void (*)(unsigned __int8 *, size_t, cgpu_info *))noop_get_statline;
    log_print_status(cgpu);
  }
  if ( opt_shares )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Mined %.0f accepted shares of %d requested\n", total_diff_accepted, opt_shares);
      applog(4, tmp42, 0);
    }
    if ( (double)opt_shares > total_diff_accepted && (use_syslog || opt_log_output || opt_log_level > 3) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "WARNING - Mined only %.0f shares of %d requested.",
        total_diff_accepted,
        opt_shares);
      applog(4, tmp42, 0);
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, " ");
    applog(4, tmp42, 0);
  }
  fflush((FILE *)stderr);
  fflush((FILE *)stdout);
}
// AC420: using guessed type int stderr;
// AC42C: using guessed type int stdout;

//----- (0005B704) --------------------------------------------------------
void __cdecl clean_up(bool restarting)
{
  int v1; // r4
  int *v2; // r0
  char *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  sysinfo sInfo; // [sp+810h] [bp+808h] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v1 = *_errno_location();
      v2 = _errno_location();
      v3 = strerror(*v2);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v1, v3);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
  }
  cgtime(&total_tv_end);
  if ( !restarting && !opt_realquiet && successful_connect )
    print_summary();
}

//----- (0005B7F6) --------------------------------------------------------
void *__cdecl __noreturn killall_thread(void *arg)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (0005B81E) --------------------------------------------------------
void __cdecl __noreturn _quit(int status, bool clean)
{
  pthread_t killall_t; // [sp+Ch] [bp+Ch] BYREF

  if ( pthread_create(&killall_t, 0, (void *(*)(void *))killall_thread, 0) )
    exit(1);
  if ( clean )
    clean_up(0);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  pthread_cancel(killall_t);
  exit(status);
}

//----- (0005B890) --------------------------------------------------------
void __cdecl __noreturn quit(int status)
{
  _quit(status, 1);
}

//----- (0005B8A8) --------------------------------------------------------
void *__cdecl test_pool_thread(void *arg)
{
  pthread_t v1; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp+8h] BYREF
  pool *pool; // [sp+810h] [bp+808h]
  bool first_pool; // [sp+817h] [bp+80Fh]

  pool = (pool *)arg;
  if ( *((_BYTE *)arg + 107) != 1 )
  {
    v1 = pthread_self();
    pthread_detach(v1);
  }
  while ( !pool->removed )
  {
    if ( pool_active(pool, 0) )
    {
      pool_tclear(pool, &pool->idle);
      first_pool = 0;
      cg_wlock_1(&control_lock, "cgminer.c", _func___17111, 10711);
      if ( !pools_active )
      {
        currentpool = pool;
        if ( pool->pool_no )
          first_pool = 1;
        pools_active = 1;
      }
      cg_wunlock_1(&control_lock, "cgminer.c", _func___17111, 10725);
      if ( first_pool && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Switching to pool %d %s - first alive pool",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(5, tmp42, 0);
      }
      pool_resus(pool);
      switch_pools(0);
LABEL_17:
      pool->testing = 0;
      return 0;
    }
    pool_died(pool);
    if ( pool->blocking )
      goto LABEL_17;
    sleep(0x1Eu);
  }
  return 0;
}

//----- (0005BA44) --------------------------------------------------------
bool __cdecl add_pool_details(
        pool *pool,
        bool live,
        unsigned __int8 *url,
        unsigned __int8 *user,
        unsigned __int8 *pass)
{
  size_t v5; // r4
  uint32_t siz; // [sp+1Ch] [bp+14h]

  pool->rpc_url = get_proxy(url, pool);
  pool->rpc_user = user;
  pool->rpc_pass = pass;
  v5 = strlen((const char *)pool->rpc_user);
  siz = strlen((const char *)pool->rpc_pass) + v5 + 2;
  pool->rpc_userpass = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___17121, 10764);
  snprintf((char *)pool->rpc_userpass, siz, "%s:%s", (const char *)pool->rpc_user, (const char *)pool->rpc_pass);
  pool->testing = 1;
  pool->idle = 1;
  pool->blocking = !live;
  enable_pool(pool);
  pthread_create(&pool->test_thread, 0, (void *(*)(void *))test_pool_thread, pool);
  if ( live )
    return 1;
  pthread_join(pool->test_thread, 0);
  return pools_active;
}

//----- (0005BB58) --------------------------------------------------------
void fork_monitor()
{
  int pfd[2]; // [sp+Ch] [bp+4h] BYREF
  sighandler_t sr1; // [sp+14h] [bp+Ch]
  sighandler_t sr0; // [sp+18h] [bp+10h]
  int r; // [sp+1Ch] [bp+14h]

  r = pipe(pfd);
  if ( r < 0 )
  {
    perror("pipe - failed to create pipe for --monitor");
    exit(1);
  }
  fflush((FILE *)stderr);
  r = dup2(pfd[1], 2);
  if ( r < 0 )
  {
    perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
    exit(1);
  }
  r = close(pfd[1]);
  if ( r < 0 )
  {
    perror("close - failed to close write end of pipe for --monitor");
    exit(1);
  }
  sr0 = signal(13, (__sighandler_t)1);
  sr1 = signal(13, (__sighandler_t)1);
  if ( sr0 == (sighandler_t)-1 || sr1 == (sighandler_t)-1 )
  {
    perror("signal - failed to edit signal mask for --monitor");
    exit(1);
  }
  forkpid = fork();
  if ( forkpid < 0 )
  {
    perror("fork - failed to fork child process for --monitor");
    exit(1);
  }
  if ( !forkpid )
  {
    r = dup2(pfd[0], 0);
    if ( r < 0 )
    {
      perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
      exit(1);
    }
    close(pfd[0]);
    if ( r < 0 )
    {
      perror("close - in child, failed to close read end of  pipe for --monitor");
      exit(1);
    }
    execl("/bin/bash", "/bin/bash", "-c", opt_stderr_cmd, 0);
    perror("execl - in child failed to exec user specified command for --monitor");
    exit(1);
  }
  r = close(pfd[0]);
  if ( r < 0 )
  {
    perror("close - failed to close read end of pipe for --monitor");
    exit(1);
  }
}
// AC420: using guessed type int stderr;

//----- (0005BCF8) --------------------------------------------------------
void __cdecl noop_reinit_device(cgpu_info *cgpu)
{
  ;
}

//----- (0005BD0C) --------------------------------------------------------
void __cdecl blank_get_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  ;
}

//----- (0005BD24) --------------------------------------------------------
void __cdecl noop_get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  ;
}

//----- (0005BD3C) --------------------------------------------------------
bool __cdecl noop_get_stats(cgpu_info *cgpu)
{
  return 1;
}

//----- (0005BD52) --------------------------------------------------------
bool __cdecl noop_thread_prepare(thr_info *thr)
{
  return 1;
}

//----- (0005BD68) --------------------------------------------------------
bool __cdecl noop_thread_init(thr_info *thr)
{
  return 1;
}

//----- (0005BD7E) --------------------------------------------------------
bool __cdecl noop_prepare_work(thr_info *thr, work *work)
{
  return 1;
}

//----- (0005BD96) --------------------------------------------------------
void __cdecl noop_hw_error(thr_info *thr)
{
  ;
}

//----- (0005BDAA) --------------------------------------------------------
void __cdecl noop_thread_shutdown(thr_info *thr)
{
  ;
}

//----- (0005BDBE) --------------------------------------------------------
void __cdecl noop_thread_enable(thr_info *thr)
{
  ;
}

//----- (0005BDD2) --------------------------------------------------------
void __cdecl noop_detect(bool hotplug)
{
  ;
}

//----- (0005BDE8) --------------------------------------------------------
void __cdecl generic_zero_stats(cgpu_info *cgpu)
{
  cgpu->hw_errors = 0;
  cgpu->diff_rejected = 0.0;
  cgpu->diff_accepted = cgpu->diff_rejected;
}

//----- (0005BE1A) --------------------------------------------------------
void __cdecl fill_device_drv(device_drv *drv)
{
  if ( !drv->drv_detect )
    drv->drv_detect = (void (*)(bool))noop_detect;
  if ( !drv->reinit_device )
    drv->reinit_device = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->get_statline_before )
    drv->get_statline_before = (void (*)(unsigned __int8 *, size_t, cgpu_info *))blank_get_statline_before;
  if ( !drv->get_statline )
    drv->get_statline = (void (*)(unsigned __int8 *, size_t, cgpu_info *))noop_get_statline;
  if ( !drv->get_stats )
    drv->get_stats = (bool (*)(cgpu_info *))noop_get_stats;
  if ( !drv->thread_prepare )
    drv->thread_prepare = (bool (*)(thr_info *))noop_thread_prepare;
  if ( !drv->thread_init )
    drv->thread_init = (bool (*)(thr_info *))noop_thread_init;
  if ( !drv->prepare_work )
    drv->prepare_work = (bool (*)(thr_info *, work *))noop_prepare_work;
  if ( !drv->hw_error )
    drv->hw_error = (void (*)(thr_info *))noop_hw_error;
  if ( !drv->thread_shutdown )
    drv->thread_shutdown = (void (*)(thr_info *))noop_thread_shutdown;
  if ( !drv->thread_enable )
    drv->thread_enable = (void (*)(thr_info *))noop_thread_enable;
  if ( !drv->hash_work )
    drv->hash_work = (void (*)(thr_info *))hash_sole_work;
  if ( !drv->flush_work )
    drv->flush_work = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->update_work )
    drv->update_work = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->queue_full )
    drv->queue_full = (bool (*)(cgpu_info *))noop_get_stats;
  if ( !drv->zero_stats )
    drv->zero_stats = (void (*)(cgpu_info *))generic_zero_stats;
  if ( drv->max_diff == 0.0 )
    drv->max_diff = 0x3FF0000000000000LL;
}

//----- (0005BF8E) --------------------------------------------------------
void __cdecl enable_device(cgpu_info *cgpu)
{
  cgpu_info **v1; // r1
  int v2; // r2

  cgpu->deven = DEV_ENABLED;
  wr_lock_1(&devices_lock, "cgminer.c", _func___17215, 11174);
  v1 = devices;
  v2 = cgminer_id_count++;
  cgpu->cgminer_id = v2;
  v1[cgpu->cgminer_id] = cgpu;
  wr_unlock(&devices_lock, "cgminer.c", _func___17215, 11176);
  if ( hotplug_mode )
    new_threads += cgpu->threads;
  else
    mining_threads += cgpu->threads;
  rwlock_init_0(&cgpu->qlock, "cgminer.c", _func___17215, 11187);
  cgpu->queued_work = 0;
}

//----- (0005C082) --------------------------------------------------------
void adjust_mostdevs()
{
  if ( total_devices - zombie_devs > most_devices )
    most_devices = total_devices - zombie_devs;
}

//----- (0005C0D4) --------------------------------------------------------
bool __cdecl add_cgpu(cgpu_info *cgpu)
{
  size_t v1; // r0
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v3; // r3
  int v4; // r3
  int v5; // r2
  int v6; // r2
  UT_hash_bucket_0 *_he_newbkt; // [sp+14h] [bp+Ch]
  UT_hash_handle *_he_hh_nxt; // [sp+1Ch] [bp+14h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+20h] [bp+18h]
  unsigned int _ha_bkt; // [sp+24h] [bp+1Ch]
  unsigned int _hf_bkt; // [sp+28h] [bp+20h]
  UT_hash_handle *_he_thh; // [sp+2Ch] [bp+24h]
  unsigned int _he_bkt_i; // [sp+30h] [bp+28h]
  const unsigned __int8 *_hj_key_0; // [sp+34h] [bp+2Ch]
  unsigned int _hj_k_0; // [sp+38h] [bp+30h]
  unsigned int _hj_j_0; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0a; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0b; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0c; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0d; // [sp+3Ch] [bp+34h]
  unsigned int _hj_j_0e; // [sp+3Ch] [bp+34h]
  int _hj_i_0; // [sp+40h] [bp+38h]
  int _hj_i_0a; // [sp+40h] [bp+38h]
  int _hj_i_0b; // [sp+40h] [bp+38h]
  int _hj_i_0c; // [sp+40h] [bp+38h]
  int _hj_i_0d; // [sp+40h] [bp+38h]
  int _hj_i_0e; // [sp+40h] [bp+38h]
  int _ha_hashv; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvc; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvd; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashve; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashva; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvf; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvg; // [sp+44h] [bp+3Ch]
  unsigned int _ha_hashvb; // [sp+44h] [bp+3Ch]
  unsigned __int8 *_hj_key; // [sp+48h] [bp+40h]
  unsigned int _hj_k; // [sp+4Ch] [bp+44h]
  unsigned int _hj_j; // [sp+50h] [bp+48h]
  unsigned int _hj_ja; // [sp+50h] [bp+48h]
  unsigned int _hj_jb; // [sp+50h] [bp+48h]
  unsigned int _hj_jc; // [sp+50h] [bp+48h]
  unsigned int _hj_jd; // [sp+50h] [bp+48h]
  unsigned int _hj_je; // [sp+50h] [bp+48h]
  int _hj_i; // [sp+54h] [bp+4Ch]
  int _hj_ia; // [sp+54h] [bp+4Ch]
  int _hj_ib; // [sp+54h] [bp+4Ch]
  int _hj_ic; // [sp+54h] [bp+4Ch]
  int _hj_id; // [sp+54h] [bp+4Ch]
  int _hj_ie; // [sp+54h] [bp+4Ch]
  int _hf_hashv; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvc; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvd; // [sp+58h] [bp+50h]
  unsigned int _hf_hashve; // [sp+58h] [bp+50h]
  unsigned int _hf_hashva; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvf; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvg; // [sp+58h] [bp+50h]
  unsigned int _hf_hashvb; // [sp+58h] [bp+50h]
  _cgpu_devid_counter *d; // [sp+5Ch] [bp+54h]
  _cgpu_devid_counter *da; // [sp+5Ch] [bp+54h]

  _hj_key = cgpu->drv->name;
  _hf_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)_hj_key); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_ja = (_hj_key[7] << 24) + _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16) + _hj_j;
    _hf_hashvc = (_hj_key[11] << 24) + _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16) + _hf_hashv;
    _hj_ia = (_hf_hashvc >> 13) ^ ((_hj_key[3] << 24)
                                 + *_hj_key
                                 + (_hj_key[1] << 8)
                                 + (_hj_key[2] << 16)
                                 + _hj_i
                                 - _hj_ja
                                 - _hf_hashvc);
    _hj_jb = (_hj_ia << 8) ^ (_hj_ja - _hf_hashvc - _hj_ia);
    _hf_hashvd = (_hj_jb >> 13) ^ (_hf_hashvc - _hj_ia - _hj_jb);
    _hj_ib = (_hf_hashvd >> 12) ^ (_hj_ia - _hj_jb - _hf_hashvd);
    _hj_jc = (_hj_ib << 16) ^ (_hj_jb - _hf_hashvd - _hj_ib);
    _hf_hashve = (_hj_jc >> 5) ^ (_hf_hashvd - _hj_ib - _hj_jc);
    _hj_i = (_hf_hashve >> 3) ^ (_hj_ib - _hj_jc - _hf_hashve);
    _hj_j = (_hj_i << 10) ^ (_hj_jc - _hf_hashve - _hj_i);
    _hf_hashv = (_hj_j >> 15) ^ (_hf_hashve - _hj_i - _hj_j);
    _hj_key += 12;
  }
  _hf_hashva = _hf_hashv + strlen((const char *)cgpu->drv->name);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      goto LABEL_9;
    case 8u:
      goto LABEL_8;
    case 9u:
      goto LABEL_7;
    case 0xAu:
      goto LABEL_6;
    case 0xBu:
      _hf_hashva += _hj_key[10] << 24;
LABEL_6:
      _hf_hashva += _hj_key[9] << 16;
LABEL_7:
      _hf_hashva += _hj_key[8] << 8;
LABEL_8:
      _hj_j += _hj_key[7] << 24;
LABEL_9:
      _hj_j += _hj_key[6] << 16;
LABEL_10:
      _hj_j += _hj_key[5] << 8;
LABEL_11:
      _hj_j += _hj_key[4];
LABEL_12:
      _hj_i += _hj_key[3] << 24;
LABEL_13:
      _hj_i += _hj_key[2] << 16;
LABEL_14:
      _hj_i += _hj_key[1] << 8;
LABEL_15:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_ic = (_hf_hashva >> 13) ^ (_hj_i - _hj_j - _hf_hashva);
  _hj_jd = (_hj_ic << 8) ^ (_hj_j - _hf_hashva - _hj_ic);
  _hf_hashvf = (_hj_jd >> 13) ^ (_hf_hashva - _hj_ic - _hj_jd);
  _hj_id = (_hf_hashvf >> 12) ^ (_hj_ic - _hj_jd - _hf_hashvf);
  _hj_je = (_hj_id << 16) ^ (_hj_jd - _hf_hashvf - _hj_id);
  _hf_hashvg = (_hj_je >> 5) ^ (_hf_hashvf - _hj_id - _hj_je);
  _hj_ie = (_hf_hashvg >> 3) ^ (_hj_id - _hj_je - _hf_hashvg);
  _hf_hashvb = (((_hj_ie << 10) ^ (_hj_je - _hf_hashvg - _hj_ie)) >> 15) ^ (_hf_hashvg
                                                                          - _hj_ie
                                                                          - ((_hj_ie << 10) ^ (_hj_je
                                                                                             - _hf_hashvg
                                                                                             - _hj_ie)));
  d = 0;
  if ( devids_17226 )
  {
    _hf_bkt = (devids_17226->hh.tbl->num_buckets - 1) & _hf_hashvb;
    if ( devids_17226->hh.tbl->buckets[_hf_bkt].hh_head )
      d = (_cgpu_devid_counter *)((char *)devids_17226->hh.tbl->buckets[_hf_bkt].hh_head - devids_17226->hh.tbl->hho);
    else
      d = 0;
    while ( d )
    {
      if ( _hf_hashvb == d->hh.hashv && d->hh.keylen == strlen((const char *)cgpu->drv->name) )
      {
        v1 = strlen((const char *)cgpu->drv->name);
        if ( !memcmp(d->hh.key, cgpu->drv->name, v1) )
          break;
      }
      if ( d->hh.hh_next )
        d = (_cgpu_devid_counter *)((char *)d->hh.hh_next - devids_17226->hh.tbl->hho);
      else
        d = 0;
    }
  }
  if ( d )
  {
    cgpu->device_id = ++d->lastid;
  }
  else
  {
    da = (_cgpu_devid_counter *)cgmalloc(0x28u, "cgminer.c", _func___17251, 11221);
    cg_memcpy(da, cgpu->drv->name, 4u, "cgminer.c", _func___17251, 11222);
    da->lastid = 0;
    cgpu->device_id = da->lastid;
    _hj_key_0 = (const unsigned __int8 *)da;
    _ha_hashv = -17973521;
    _hj_j_0 = -1640531527;
    _hj_i_0 = -1640531527;
    for ( _hj_k_0 = strlen((const char *)da); _hj_k_0 > 0xB; _hj_k_0 -= 12 )
    {
      _hj_j_0a = (_hj_key_0[7] << 24) + _hj_key_0[4] + (_hj_key_0[5] << 8) + (_hj_key_0[6] << 16) + _hj_j_0;
      _ha_hashvc = (_hj_key_0[11] << 24) + _hj_key_0[8] + (_hj_key_0[9] << 8) + (_hj_key_0[10] << 16) + _ha_hashv;
      _hj_i_0a = (_ha_hashvc >> 13) ^ ((_hj_key_0[3] << 24)
                                     + *_hj_key_0
                                     + (_hj_key_0[1] << 8)
                                     + (_hj_key_0[2] << 16)
                                     + _hj_i_0
                                     - _hj_j_0a
                                     - _ha_hashvc);
      _hj_j_0b = (_hj_i_0a << 8) ^ (_hj_j_0a - _ha_hashvc - _hj_i_0a);
      _ha_hashvd = (_hj_j_0b >> 13) ^ (_ha_hashvc - _hj_i_0a - _hj_j_0b);
      _hj_i_0b = (_ha_hashvd >> 12) ^ (_hj_i_0a - _hj_j_0b - _ha_hashvd);
      _hj_j_0c = (_hj_i_0b << 16) ^ (_hj_j_0b - _ha_hashvd - _hj_i_0b);
      _ha_hashve = (_hj_j_0c >> 5) ^ (_ha_hashvd - _hj_i_0b - _hj_j_0c);
      _hj_i_0 = (_ha_hashve >> 3) ^ (_hj_i_0b - _hj_j_0c - _ha_hashve);
      _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0c - _ha_hashve - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashve - _hj_i_0 - _hj_j_0);
      _hj_key_0 += 12;
    }
    _ha_hashva = _ha_hashv + strlen((const char *)da);
    switch ( _hj_k_0 )
    {
      case 1u:
        goto LABEL_43;
      case 2u:
        goto LABEL_42;
      case 3u:
        goto LABEL_41;
      case 4u:
        goto LABEL_40;
      case 5u:
        goto LABEL_39;
      case 6u:
        goto LABEL_38;
      case 7u:
        goto LABEL_37;
      case 8u:
        goto LABEL_36;
      case 9u:
        goto LABEL_35;
      case 0xAu:
        goto LABEL_34;
      case 0xBu:
        _ha_hashva += _hj_key_0[10] << 24;
LABEL_34:
        _ha_hashva += _hj_key_0[9] << 16;
LABEL_35:
        _ha_hashva += _hj_key_0[8] << 8;
LABEL_36:
        _hj_j_0 += _hj_key_0[7] << 24;
LABEL_37:
        _hj_j_0 += _hj_key_0[6] << 16;
LABEL_38:
        _hj_j_0 += _hj_key_0[5] << 8;
LABEL_39:
        _hj_j_0 += _hj_key_0[4];
LABEL_40:
        _hj_i_0 += _hj_key_0[3] << 24;
LABEL_41:
        _hj_i_0 += _hj_key_0[2] << 16;
LABEL_42:
        _hj_i_0 += _hj_key_0[1] << 8;
LABEL_43:
        _hj_i_0 += *_hj_key_0;
        break;
      default:
        break;
    }
    _hj_i_0c = (_ha_hashva >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashva);
    _hj_j_0d = (_hj_i_0c << 8) ^ (_hj_j_0 - _ha_hashva - _hj_i_0c);
    _ha_hashvf = (_hj_j_0d >> 13) ^ (_ha_hashva - _hj_i_0c - _hj_j_0d);
    _hj_i_0d = (_ha_hashvf >> 12) ^ (_hj_i_0c - _hj_j_0d - _ha_hashvf);
    _hj_j_0e = (_hj_i_0d << 16) ^ (_hj_j_0d - _ha_hashvf - _hj_i_0d);
    _ha_hashvg = (_hj_j_0e >> 5) ^ (_ha_hashvf - _hj_i_0d - _hj_j_0e);
    _hj_i_0e = (_ha_hashvg >> 3) ^ (_hj_i_0d - _hj_j_0e - _ha_hashvg);
    _ha_hashvb = (((_hj_i_0e << 10) ^ (_hj_j_0e - _ha_hashvg - _hj_i_0e)) >> 15) ^ (_ha_hashvg
                                                                                  - _hj_i_0e
                                                                                  - ((_hj_i_0e << 10) ^ (_hj_j_0e - _ha_hashvg - _hj_i_0e)));
    da->hh.hashv = _ha_hashvb;
    da->hh.key = da;
    da->hh.keylen = strlen((const char *)da);
    if ( devids_17226 )
    {
      da->hh.tbl = devids_17226->hh.tbl;
      da->hh.next = 0;
      da->hh.prev = (char *)devids_17226->hh.tbl->tail - devids_17226->hh.tbl->hho;
      devids_17226->hh.tbl->tail->next = da;
      devids_17226->hh.tbl->tail = &da->hh;
    }
    else
    {
      da->hh.next = 0;
      da->hh.prev = 0;
      devids_17226 = da;
      da->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !devids_17226->hh.tbl )
        exit(-1);
      memset(devids_17226->hh.tbl, 0, sizeof(UT_hash_table));
      devids_17226->hh.tbl->tail = &devids_17226->hh;
      devids_17226->hh.tbl->num_buckets = 32;
      devids_17226->hh.tbl->log2_num_buckets = 5;
      devids_17226->hh.tbl->hho = 8;
      tbl = devids_17226->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !devids_17226->hh.tbl->buckets )
        exit(-1);
      memset(devids_17226->hh.tbl->buckets, 0, 0x180u);
      devids_17226->hh.tbl->signature = -1609490463;
    }
    ++devids_17226->hh.tbl->num_items;
    _ha_bkt = (devids_17226->hh.tbl->num_buckets - 1) & _ha_hashvb;
    v3 = &devids_17226->hh.tbl->buckets[_ha_bkt];
    ++v3->count;
    da->hh.hh_next = devids_17226->hh.tbl->buckets[_ha_bkt].hh_head;
    da->hh.hh_prev = 0;
    if ( devids_17226->hh.tbl->buckets[_ha_bkt].hh_head )
      devids_17226->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &da->hh;
    devids_17226->hh.tbl->buckets[_ha_bkt].hh_head = &da->hh;
    if ( devids_17226->hh.tbl->buckets[_ha_bkt].count >= 10 * (devids_17226->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && da->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * da->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * da->hh.tbl->num_buckets);
      da->hh.tbl->ideal_chain_maxlen = (da->hh.tbl->num_items >> (da->hh.tbl->log2_num_buckets + 1))
                                     + (((2 * da->hh.tbl->num_buckets - 1) & da->hh.tbl->num_items) != 0);
      da->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; _he_bkt_i < da->hh.tbl->num_buckets; ++_he_bkt_i )
      {
        for ( _he_thh = da->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_newbkt = &_he_new_buckets[(2 * da->hh.tbl->num_buckets - 1) & _he_thh->hashv];
          if ( ++_he_newbkt->count > da->hh.tbl->ideal_chain_maxlen )
          {
            ++da->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / da->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(da->hh.tbl->buckets);
      da->hh.tbl->num_buckets *= 2;
      ++da->hh.tbl->log2_num_buckets;
      da->hh.tbl->buckets = _he_new_buckets;
      if ( da->hh.tbl->nonideal_items <= da->hh.tbl->num_items >> 1 )
        v4 = 0;
      else
        v4 = da->hh.tbl->ineff_expands + 1;
      da->hh.tbl->ineff_expands = v4;
      if ( da->hh.tbl->ineff_expands > 1 )
        da->hh.tbl->noexpand = 1;
    }
  }
  wr_lock_1(&devices_lock, "cgminer.c", _func___17251, 11227);
  devices = (cgpu_info **)cgrealloc(devices, 4 * (new_devices + total_devices + 2), "cgminer.c", _func___17251, 11228);
  wr_unlock(&devices_lock, "cgminer.c", _func___17251, 11229);
  mutex_lock_1(&stats_lock, "cgminer.c", _func___17251, 11231);
  cgpu->last_device_valid_work = time(0);
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___17251, 11233);
  if ( hotplug_mode )
  {
    v5 = new_devices++;
    *(&devices[total_devices] + v5) = cgpu;
  }
  else
  {
    v6 = total_devices++;
    devices[v6] = cgpu;
  }
  adjust_mostdevs();
  return 1;
}

//----- (0005CEE0) --------------------------------------------------------
void probe_pools()
{
  pool *pool; // [sp+0h] [bp+0h]
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->testing = 1;
    pthread_create(&pool->test_thread, 0, (void *(*)(void *))test_pool_thread, pool);
  }
}

//----- (0005CF3C) --------------------------------------------------------
void setStartTimePoint()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  sysinfo sInfo; // [sp+800h] [bp+800h] BYREF
  unsigned __int8 logstr[256]; // [sp+840h] [bp+840h] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    v0 = *_errno_location();
    v1 = _errno_location();
    v2 = strerror(*v1);
    sprintf((char *)logstr, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v2);
    total_tv_start_sys = time(0);
    total_tv_end_sys = total_tv_start_sys + 1;
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
    total_tv_end_sys = sInfo.uptime + 1;
    sprintf(
      (char *)logstr,
      "setStartTimePoint total_tv_start_sys=%ld total_tv_end_sys=%ld\n",
      sInfo.uptime,
      sInfo.uptime + 1);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s", (const char *)logstr);
      applog(5, tmp42, 0);
    }
  }
}

//----- (0005D048) --------------------------------------------------------
int __cdecl cnt_of_proc(const unsigned __int8 *app_name)
{
  size_t v1; // r0
  unsigned __int8 sub_pid[32]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 cmd_stream[64]; // [sp+3Ch] [bp+2Ch] BYREF
  unsigned __int8 buf[256]; // [sp+7Ch] [bp+6Ch] BYREF
  FILE *pFile_3; // [sp+17Ch] [bp+16Ch]
  FILE *pFile_0; // [sp+180h] [bp+170h]
  FILE *pFile; // [sp+184h] [bp+174h]
  FILE *pFile_1; // [sp+188h] [bp+178h]
  int id; // [sp+18Ch] [bp+17Ch]
  int cur_str_size; // [sp+190h] [bp+180h]
  FILE *pFile_2; // [sp+194h] [bp+184h]
  FILE *p_fd; // [sp+198h] [bp+188h]
  int i; // [sp+19Ch] [bp+18Ch]
  int last_space_pos; // [sp+1A0h] [bp+190h]
  int inst_cnt; // [sp+1A4h] [bp+194h]

  memset(buf, 0, sizeof(buf));
  inst_cnt = 0;
  memset(cmd_stream, 0, sizeof(cmd_stream));
  snprintf((char *)cmd_stream, 0x40u, "pidof %s", (const char *)app_name);
  p_fd = popen((const char *)cmd_stream, "r");
  if ( p_fd )
  {
    while ( fgets((char *)buf, 256, p_fd) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: pidof %s command result is:%s\n",
            "cgminer.c",
            11470,
            (const char *)_FUNCTION___17310,
            (const char *)app_name,
            (const char *)buf);
        fclose(pFile);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          v1 = strlen((const char *)buf);
          fprintf(pFile_0, "%s:%d:%s: strlen is: %d\n", "cgminer.c", 11471, (const char *)_FUNCTION___17310, v1);
        }
        fclose(pFile_0);
      }
    }
    pclose(p_fd);
    p_fd = 0;
    last_space_pos = 0;
    for ( i = 1; strlen((const char *)buf) >= i; ++i )
    {
      memset(sub_pid, 0, sizeof(sub_pid));
      if ( ((*_ctype_b_loc())[buf[i - 1]] & 0x2000) != 0 )
      {
        printf("[%d] is a white-space character:%d\n", i, buf[i - 1]);
        cur_str_size = i - last_space_pos - 1;
        strncpy((char *)sub_pid, (const char *)&buf[last_space_pos], cur_str_size);
        last_space_pos = i;
        id = atoi((const char *)sub_pid);
        if ( id > 0 )
        {
          ++inst_cnt;
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: Parsed proc id is: %d\n",
                "cgminer.c",
                11492,
                (const char *)_FUNCTION___17310,
                id);
            fclose(pFile_1);
          }
        }
      }
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(
        pFile_2,
        "%s:%d:%s:  app-service:%s Not Found!!!",
        "cgminer.c",
        11499,
        (const char *)_FUNCTION___17310,
        (const char *)app_name);
    fclose(pFile_2);
  }
  if ( inst_cnt > 0 && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s:  %d instance of %s is  already Running on this machine\n",
        "cgminer.c",
        11504,
        (const char *)_FUNCTION___17310,
        inst_cnt,
        (const char *)app_name);
    fclose(pFile_3);
  }
  return inst_cnt;
}

//----- (0005D432) --------------------------------------------------------
bool is_cgminer_already_started()
{
  return cnt_of_proc("cgminer") > 1;
}

//----- (0005D458) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int8 **v3; // r4
  char *v4; // r4
  char *v5; // r0
  block *v6; // r4
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v8; // r3
  unsigned int v9; // r3
  unsigned __int8 *v10; // r0
  double v11; // r2
  FILE *v12; // r0
  FILE *v13; // r0
  unsigned __int8 *v14; // r0
  size_t v15; // r4
  unsigned __int8 *v16; // r0
  thr_info **v17; // r4
  thr_info **v18; // r0
  double *v19; // r2
  int v20; // r4
  int *v21; // r0
  char *v22; // r0
  char v24; // [sp+10h] [bp-2010h] BYREF
  char v25[4088]; // [sp+1018h] [bp-1008h] BYREF
  unsigned __int8 **argva; // [sp+2020h] [bp+0h]
  int argca; // [sp+2024h] [bp+4h] BYREF
  unsigned __int8 szfilepath[256]; // [sp+2028h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+2128h] [bp+108h] BYREF
  sysinfo sInfo; // [sp+2928h] [bp+908h] BYREF
  work *work; // [sp+2968h] [bp+948h] BYREF
  sigaction handler; // [sp+296Ch] [bp+94Ch] BYREF
  size_t siz; // [sp+29F8h] [bp+9D8h]
  pool *pool_0; // [sp+29FCh] [bp+9DCh]
  cgpu_info *cgpu_0; // [sp+2A00h] [bp+9E0h]
  cgpu_info *cgpu_1; // [sp+2A04h] [bp+9E4h]
  pool *pool_3; // [sp+2A08h] [bp+9E8h]
  int max_staged; // [sp+2A0Ch] [bp+9ECh]
  thr_info *thr; // [sp+2A10h] [bp+9F0h]
  pool *pool_1; // [sp+2A14h] [bp+9F4h]
  pool *pool_2; // [sp+2A18h] [bp+9F8h]
  cgpu_info *cgpu; // [sp+2A1Ch] [bp+9FCh]
  unsigned __int8 *start; // [sp+2A20h] [bp+A00h]
  int len; // [sp+2A24h] [bp+A04h]
  FILE *fpversion; // [sp+2A28h] [bp+A08h]
  pool *pool; // [sp+2A2Ch] [bp+A0Ch]
  UT_hash_bucket_0 *_he_newbkt; // [sp+2A30h] [bp+A10h]
  unsigned int _he_bkt; // [sp+2A34h] [bp+A14h]
  UT_hash_handle *_he_hh_nxt; // [sp+2A38h] [bp+A18h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+2A3Ch] [bp+A1Ch]
  unsigned int _ha_bkt; // [sp+2A40h] [bp+A20h]
  block *block; // [sp+2A44h] [bp+A24h]
  unsigned __int8 *s; // [sp+2A48h] [bp+A28h]
  int ts; // [sp+2A4Ch] [bp+A2Ch]
  UT_hash_handle *_he_thh; // [sp+2A50h] [bp+A30h]
  unsigned int _he_bkt_i; // [sp+2A54h] [bp+A34h]
  const unsigned __int8 *_hj_key; // [sp+2A58h] [bp+A38h]
  unsigned int _hj_k; // [sp+2A5Ch] [bp+A3Ch]
  unsigned int _hj_j; // [sp+2A60h] [bp+A40h]
  unsigned int _hj_i; // [sp+2A64h] [bp+A44h]
  unsigned int _ha_hashv; // [sp+2A68h] [bp+A48h]
  unsigned int k; // [sp+2A6Ch] [bp+A4Ch]
  int slept; // [sp+2A70h] [bp+A50h]
  int j; // [sp+2A74h] [bp+A54h]
  int i; // [sp+2A78h] [bp+A58h]
  bool pool_msg; // [sp+2A7Fh] [bp+A5Fh]

  argca = argc;
  argva = (unsigned __int8 **)argv;
  work = 0;
  pool_msg = 0;
  slept = 0;
  g_logfile_enable = 0;
  if ( is_cgminer_already_started() )
  {
    puts("cgminer is forbidden to start again as it is already started,will exit immediately.");
    exit(-1);
  }
  strcpy((char *)g_logfile_path, "bmminer.log");
  strcpy((char *)g_logfile_openflag, "a+");
  if ( sysconf(84) == 1 )
    selective_yield = sched_yield;
  initial_args = (unsigned __int8 **)cgmalloc(4 * (argca + 1), "cgminer.c", _func___17344, 11571);
  for ( i = 0; i < argca; ++i )
  {
    v3 = &initial_args[i];
    *v3 = (unsigned __int8 *)strdup((const char *)argva[i]);
  }
  initial_args[argca] = 0;
  mutex_init_0(&hash_lock, "cgminer.c", _func___17344, 11580);
  mutex_init_0(&update_job_lock, "cgminer.c", _func___17344, 11581);
  mutex_init_0(&console_lock, "cgminer.c", _func___17344, 11582);
  cglock_init_0(&control_lock, "cgminer.c", _func___17344, 11583);
  mutex_init_0(&stats_lock, "cgminer.c", _func___17344, 11584);
  mutex_init_0(&sharelog_lock, "cgminer.c", _func___17344, 11585);
  cglock_init_0(&ch_lock, "cgminer.c", _func___17344, 11586);
  mutex_init_0(&sshare_lock, "cgminer.c", _func___17344, 11587);
  rwlock_init_0(&blk_lock, "cgminer.c", _func___17344, 11588);
  rwlock_init_0(&netacc_lock, "cgminer.c", _func___17344, 11589);
  rwlock_init_0(&mining_thr_lock, "cgminer.c", _func___17344, 11590);
  rwlock_init_0(&devices_lock, "cgminer.c", _func___17344, 11591);
  mutex_init_0(&lp_lock, "cgminer.c", _func___17344, 11593);
  if ( pthread_cond_init(&lp_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init lp_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  mutex_init_0(&restart_lock, "cgminer.c", _func___17344, 11600);
  if ( pthread_cond_init(&restart_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init restart_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( pthread_cond_init(&gws_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init gws_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  getq = tq_new();
  if ( !getq )
  {
    strcpy((char *)tmp42, "Failed to create getq");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  stgd_lock = &getq->mutex;
  snprintf((char *)packagename, 0x100u, "%s %s", "cgminer", "2.0.0");
  handler.sa_handler = (__sighandler_t)sighandler;
  handler.sa_flags = 0;
  sigemptyset(&handler.sa_mask);
  sigaction_0(15, &handler, &termhandler);
  sigaction_0(2, &handler, &inthandler);
  sigaction_0(6, &handler, &abrthandler);
  opt_kernel_path = (unsigned __int8 *)v25;
  strcpy(v25, "/usr/bin");
  cgminer_path = (unsigned __int8 *)&v24;
  s = (unsigned __int8 *)strdup((const char *)*argva);
  v4 = (char *)cgminer_path;
  v5 = dirname((char *)s);
  strcpy(v4, v5);
  free(s);
  strcat((char *)cgminer_path, "/");
  devcursor = 8;
  logstart = 9;
  logcursor = 10;
  block = (block *)cgcalloc(104, 1u, "cgminer.c", _func___17344, 11647);
  for ( i = 0; i <= 35; ++i )
    strcat((char *)block, "0");
  _hj_key = (const unsigned __int8 *)block;
  _ha_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)block); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_i += (_hj_key[3] << 24) + *_hj_key + (_hj_key[1] << 8) + (_hj_key[2] << 16);
    _hj_j += (_hj_key[7] << 24) + _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16);
    _ha_hashv += (_hj_key[11] << 24) + _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16);
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 13;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 8;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 13;
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 12;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 16;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 5;
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 3;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 10;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 15;
    _hj_key += 12;
  }
  _ha_hashv += strlen((const char *)block);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_33;
    case 2u:
      goto LABEL_32;
    case 3u:
      goto LABEL_31;
    case 4u:
      goto LABEL_30;
    case 5u:
      goto LABEL_29;
    case 6u:
      goto LABEL_28;
    case 7u:
      goto LABEL_27;
    case 8u:
      goto LABEL_26;
    case 9u:
      goto LABEL_25;
    case 0xAu:
      goto LABEL_24;
    case 0xBu:
      _ha_hashv += _hj_key[10] << 24;
LABEL_24:
      _ha_hashv += _hj_key[9] << 16;
LABEL_25:
      _ha_hashv += _hj_key[8] << 8;
LABEL_26:
      _hj_j += _hj_key[7] << 24;
LABEL_27:
      _hj_j += _hj_key[6] << 16;
LABEL_28:
      _hj_j += _hj_key[5] << 8;
LABEL_29:
      _hj_j += _hj_key[4];
LABEL_30:
      _hj_i += _hj_key[3] << 24;
LABEL_31:
      _hj_i += _hj_key[2] << 16;
LABEL_32:
      _hj_i += _hj_key[1] << 8;
LABEL_33:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 13;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 8;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 13;
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 12;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 16;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 5;
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 3;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 10;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 15;
  block->hh.hashv = _ha_hashv;
  block->hh.key = block;
  block->hh.keylen = strlen((const char *)block);
  if ( blocks )
  {
    block->hh.tbl = blocks->hh.tbl;
    block->hh.next = 0;
    block->hh.prev = (char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho;
    blocks->hh.tbl->tail->next = block;
    blocks->hh.tbl->tail = &block->hh;
  }
  else
  {
    block->hh.next = 0;
    block->hh.prev = 0;
    blocks = block;
    v6 = block;
    v6->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
    if ( !blocks->hh.tbl )
      exit(-1);
    memset(blocks->hh.tbl, 0, sizeof(UT_hash_table));
    blocks->hh.tbl->tail = &blocks->hh;
    blocks->hh.tbl->num_buckets = 32;
    blocks->hh.tbl->log2_num_buckets = 5;
    blocks->hh.tbl->hho = 68;
    tbl = blocks->hh.tbl;
    tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
    if ( !blocks->hh.tbl->buckets )
      exit(-1);
    memset(blocks->hh.tbl->buckets, 0, 0x180u);
    blocks->hh.tbl->signature = -1609490463;
  }
  ++blocks->hh.tbl->num_items;
  _ha_bkt = (blocks->hh.tbl->num_buckets - 1) & _ha_hashv;
  v8 = &blocks->hh.tbl->buckets[_ha_bkt];
  ++v8->count;
  block->hh.hh_next = blocks->hh.tbl->buckets[_ha_bkt].hh_head;
  block->hh.hh_prev = 0;
  if ( blocks->hh.tbl->buckets[_ha_bkt].hh_head )
    blocks->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &block->hh;
  blocks->hh.tbl->buckets[_ha_bkt].hh_head = &block->hh;
  if ( blocks->hh.tbl->buckets[_ha_bkt].count >= 10 * (blocks->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
    && block->hh.tbl->noexpand != 1 )
  {
    _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * block->hh.tbl->num_buckets);
    if ( !_he_new_buckets )
      exit(-1);
    memset(_he_new_buckets, 0, 24 * block->hh.tbl->num_buckets);
    block->hh.tbl->ideal_chain_maxlen = (block->hh.tbl->num_items >> (block->hh.tbl->log2_num_buckets + 1))
                                      + (((2 * block->hh.tbl->num_buckets - 1) & block->hh.tbl->num_items) != 0);
    block->hh.tbl->nonideal_items = 0;
    for ( _he_bkt_i = 0; _he_bkt_i < block->hh.tbl->num_buckets; ++_he_bkt_i )
    {
      for ( _he_thh = block->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
      {
        _he_hh_nxt = _he_thh->hh_next;
        _he_bkt = (2 * block->hh.tbl->num_buckets - 1) & _he_thh->hashv;
        _he_newbkt = &_he_new_buckets[_he_bkt];
        if ( ++_he_newbkt->count > block->hh.tbl->ideal_chain_maxlen )
        {
          ++block->hh.tbl->nonideal_items;
          _he_newbkt->expand_mult = _he_newbkt->count / block->hh.tbl->ideal_chain_maxlen;
        }
        _he_thh->hh_prev = 0;
        _he_thh->hh_next = _he_newbkt->hh_head;
        if ( _he_newbkt->hh_head )
          _he_newbkt->hh_head->hh_prev = _he_thh;
        _he_newbkt->hh_head = _he_thh;
      }
    }
    free(block->hh.tbl->buckets);
    block->hh.tbl->num_buckets *= 2;
    ++block->hh.tbl->log2_num_buckets;
    block->hh.tbl->buckets = _he_new_buckets;
    if ( block->hh.tbl->nonideal_items <= block->hh.tbl->num_items >> 1 )
      v9 = 0;
    else
      v9 = block->hh.tbl->ineff_expands + 1;
    block->hh.tbl->ineff_expands = v9;
    if ( block->hh.tbl->ineff_expands > 1 )
      block->hh.tbl->noexpand = 1;
  }
  strcpy((char *)current_hash, (const char *)block);
  scan_devices.next = &scan_devices;
  scan_devices.prev = &scan_devices;
  opt_register_table(opt_config_table, "Options for both config file and command line");
  opt_register_table(opt_cmdline_table, "Options for command line only");
  opt_parse(&argca, argva, applog_and_exit);
  if ( argca != 1 )
  {
    strcpy((char *)tmp42, "Unexpected extra commandline arguments");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( !config_loaded )
    load_default_config();
  if ( opt_benchmark || opt_benchfile )
  {
    pool = add_pool();
    v10 = (unsigned __int8 *)cgmalloc(0xFFu, "cgminer.c", _func___17344, 11683);
    pool->rpc_url = v10;
    if ( opt_benchfile )
      strcpy((char *)pool->rpc_url, "Benchfile");
    else
      strcpy((char *)pool->rpc_url, "Benchmark");
    pool->rpc_user = pool->rpc_url;
    pool->rpc_pass = pool->rpc_url;
    pool->rpc_userpass = pool->rpc_url;
    pool->sockaddr_url = pool->rpc_url;
    strncpy((char *)pool->diff, "?", 7u);
    pool->diff[7] = 0;
    enable_pool(pool);
    pool->idle = 0;
    LODWORD(v11) = 1;
    successful_connect = 1;
    for ( i = 0; ; ++i )
    {
      HIDWORD(v11) = i;
      if ( i > 15 )
        break;
      hex2bin(bench_hidiff_bins[i], bench_hidiffs[i], 0xA0u);
      hex2bin(bench_lodiff_bins[i], bench_lodiffs[i], 0xA0u);
    }
    set_target(bench_target, v11);
  }
  if ( opt_version_path )
  {
    fpversion = fopen((const char *)opt_version_path, "rb");
    memset(szfilepath, 0, sizeof(szfilepath));
    len = 0;
    start = 0;
    if ( fpversion )
    {
      len = fread(szfilepath, 1u, 0x100u, fpversion);
      if ( len > 0 )
      {
        start = (unsigned __int8 *)strchr((const char *)szfilepath, 10);
        if ( start )
        {
          cg_memcpy(g_miner_compiletime, szfilepath, start - szfilepath, "cgminer.c", _func___17344, 11742);
          strcpy((char *)szfilepath, (const char *)start + 1);
          start = (unsigned __int8 *)strchr((const char *)szfilepath, 10);
          if ( start )
            cg_memcpy(g_miner_type, szfilepath, start - szfilepath, "cgminer.c", _func___17344, 11751);
          else
            strcpy((char *)g_miner_type, (const char *)szfilepath);
        }
        else
        {
          strcpy((char *)g_miner_compiletime, (const char *)szfilepath);
        }
        if ( g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] == 10 )
          g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] = 0;
        if ( g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] == 13 )
          g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] = 0;
        if ( g_miner_type[strlen((const char *)g_miner_type) - 1] == 10 )
          g_miner_type[strlen((const char *)g_miner_type) - 1] = 0;
        if ( g_miner_type[strlen((const char *)g_miner_type) - 1] == 13 )
          g_miner_type[strlen((const char *)g_miner_type) - 1] = 0;
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Read miner version file %s error %d", (const char *)opt_version_path, len);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Open miner version file %s error", (const char *)opt_version_path);
      applog(3, tmp42, 0);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Miner compile time: %s type: %s",
        (const char *)g_miner_compiletime,
        (const char *)g_miner_type);
      applog(3, tmp42, 0);
    }
  }
  if ( opt_logfile_path )
  {
    g_logfile_enable = 1;
    strcpy((char *)g_logfile_path, (const char *)opt_logfile_path);
    if ( opt_logfile_openflag )
      strcpy((char *)g_logfile_openflag, (const char *)opt_logfile_openflag);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Log file path: %s Open flag: %s",
        (const char *)g_logfile_path,
        (const char *)g_logfile_openflag);
      applog(3, tmp42, 0);
    }
  }
  if ( opt_logwork_path )
  {
    memset(szfilepath, 0, sizeof(szfilepath));
    if ( opt_logwork_asicnum )
    {
      if ( !*opt_logwork_asicnum )
      {
        strcpy((char *)tmp42, "Log work asic num empty");
        applog(3, tmp42, 1);
        quit(1);
      }
      g_logwork_asicnum = atoi((const char *)opt_logwork_asicnum);
      if ( g_logwork_asicnum != 1 && g_logwork_asicnum != 32 && g_logwork_asicnum != 64 )
      {
        strcpy((char *)tmp42, "Log work asic num must be 1, 32, 64");
        applog(3, tmp42, 1);
        quit(1);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Log work path: %s Asic num: %s",
          (const char *)opt_logwork_path,
          (const char *)opt_logwork_asicnum);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Log work path: %s", (const char *)opt_logwork_path);
      applog(3, tmp42, 0);
    }
    sprintf((char *)szfilepath, "%s.txt", (const char *)opt_logwork_path);
    g_logwork_file = fopen((const char *)szfilepath, "a+");
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Log work open file %s", (const char *)szfilepath);
      applog(3, tmp42, 0);
    }
    if ( g_logwork_asicnum == 1 )
    {
      sprintf((char *)szfilepath, "%s%02d.txt", (const char *)opt_logwork_path, g_logwork_asicnum);
      g_logwork_files[0] = fopen((const char *)szfilepath, "a+");
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Log work open asic %d file %s", g_logwork_asicnum, (const char *)szfilepath);
        applog(3, tmp42, 0);
      }
    }
    else if ( g_logwork_asicnum == 32 || g_logwork_asicnum == 64 )
    {
      for ( i = 0; i <= g_logwork_asicnum; ++i )
      {
        sprintf((char *)szfilepath, "%s%02d_%02d.txt", (const char *)opt_logwork_path, g_logwork_asicnum, i);
        v12 = fopen((const char *)szfilepath, "a+");
        g_logwork_files[i] = v12;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "Log work open asic %d file %s", g_logwork_asicnum, (const char *)szfilepath);
          applog(3, tmp42, 0);
        }
      }
    }
    if ( opt_logwork_diff )
    {
      for ( i = 0; i <= 64; ++i )
      {
        sprintf((char *)szfilepath, "%s_diff_%02d.txt", (const char *)opt_logwork_path, i);
        v13 = fopen((const char *)szfilepath, "a+");
        g_logwork_diffs[i] = v13;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "Log work open diff file %s", (const char *)szfilepath);
          applog(3, tmp42, 0);
        }
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Started %s", (const char *)packagename);
    applog(4, tmp42, 0);
  }
  if ( cnfbuf )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Loaded configuration file %s", (const char *)cnfbuf);
      applog(5, tmp42, 0);
    }
    if ( fileconf_load == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Error in configuration file, partially loaded.");
        applog(4, tmp42, 0);
      }
      if ( use_curses && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        strcpy((char *)tmp42, "Start cgminer with -T to see what failed to load.");
        applog(4, tmp42, 0);
      }
    }
    else if ( !fileconf_load )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Fatal JSON error in configuration file.");
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Configuration file could not be used.");
        applog(4, tmp42, 0);
      }
    }
    free(cnfbuf);
    cnfbuf = 0;
  }
  strcat((char *)opt_kernel_path, "/");
  if ( want_per_device_stats )
    opt_log_output = 1;
  if ( opt_log_output )
    setlogmask(255);
  else
    setlogmask(63);
  if ( opt_scantime < 0 )
    opt_scantime = 60;
  total_control_threads = 8;
  control_thr = (thr_info *)cgcalloc(8, 0x40u, "cgminer.c", _func___17344, 11907);
  gwsched_thr_id = 0;
  fill_device_drv(&bitforce_drv);
  fill_device_drv(&modminer_drv);
  fill_device_drv(&bitmain_drv);
  fill_device_drv(&bitmain_soc_drv);
  bitforce_drv.drv_detect(0);
  modminer_drv.drv_detect(0);
  bitmain_drv.drv_detect(0);
  bitmain_soc_drv.drv_detect(0);
  if ( opt_display_devs )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "Devices detected:");
      applog(3, tmp42, 0);
    }
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = devices[i];
      if ( cgpu->name )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            " %2d. %s %d: %s (driver: %s)",
            i,
            (const char *)cgpu->drv->name,
            cgpu->device_id,
            (const char *)cgpu->name,
            (const char *)cgpu->drv->dname);
          applog(3, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          " %2d. %s %d (driver: %s)",
          i,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          (const char *)cgpu->drv->dname);
        applog(3, tmp42, 0);
      }
    }
    snprintf((char *)tmp42, 0x800u, "%d devices listed", total_devices);
    applog(3, tmp42, 1);
    _quit(0, 0);
  }
  mining_threads = 0;
  for ( i = 0; i < total_devices; ++i )
    enable_device(devices[i]);
  if ( !total_devices )
  {
    strcpy((char *)tmp42, "All devices disabled, cannot mint!");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  most_devices = total_devices;
  load_temp_cutoffs();
  for ( i = 0; i < total_devices; ++i )
    devices[i]->cgminer_stats.getwork_wait_min.tv_sec = 99999999;
  if ( !opt_compact )
  {
    logstart += most_devices;
    logcursor = logstart + 1;
  }
  if ( !total_pools )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Need to specify at least one pool server.");
      applog(4, tmp42, 0);
    }
    strcpy((char *)tmp42, "Pool setup failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  for ( i = 0; i < total_pools; ++i )
  {
    pool_0 = pools[i];
    pool_0->cgminer_stats.getwork_wait_min.tv_sec = 99999999;
    pool_0->cgminer_pool_stats.getwork_wait_min.tv_sec = 99999999;
    if ( !pool_0->rpc_userpass )
    {
      if ( !pool_0->rpc_pass )
      {
        v14 = (unsigned __int8 *)strdup(byte_8A828);
        pool_0->rpc_pass = v14;
      }
      if ( !pool_0->rpc_user )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "No login credentials supplied for pool %u %s",
          i,
          (const char *)pool_0->rpc_url);
        applog(3, tmp42, 1);
        _quit(1, 0);
      }
      v15 = strlen((const char *)pool_0->rpc_user);
      siz = strlen((const char *)pool_0->rpc_pass) + v15 + 2;
      v16 = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___17344, 12016);
      pool_0->rpc_userpass = v16;
      snprintf(
        (char *)pool_0->rpc_userpass,
        siz,
        "%s:%s",
        (const char *)pool_0->rpc_user,
        (const char *)pool_0->rpc_pass);
    }
  }
  currentpool = *pools;
  if ( use_syslog )
    openlog("cgminer", 1, 8);
  if ( opt_stderr_cmd )
    fork_monitor();
  mining_thr = (thr_info **)cgcalloc(mining_threads, 4u, "cgminer.c", _func___17344, 12033);
  for ( i = 0; i < mining_threads; ++i )
  {
    v17 = &mining_thr[i];
    *v17 = (thr_info *)cgcalloc(1, 0x40u, "cgminer.c", _func___17344, 12037);
  }
  k = 0;
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu_0 = devices[i];
    v18 = (thr_info **)cgmalloc(4 * (cgpu_0->threads + 1), "cgminer.c", _func___17344, 12046);
    cgpu_0->thr = v18;
    cgpu_0->thr[cgpu_0->threads] = 0;
    cgpu_0->status = LIFE_INIT;
    j = 0;
    while ( j < cgpu_0->threads )
    {
      thr = get_thread(k);
      thr->id = k;
      thr->cgpu = cgpu_0;
      thr->device_thread = j;
      if ( cgpu_0->drv->thread_prepare(thr) )
      {
        if ( thr_info_create(thr, 0, (void *(*)(void *))miner_thread, thr) )
        {
          snprintf((char *)tmp42, 0x800u, "thread %d create failed", thr->id);
          applog(3, tmp42, 1);
          _quit(1, 0);
        }
        cgpu_0->thr[j] = thr;
        if ( cgpu_0->deven != DEV_DISABLED )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "Pushing sem post to thread %d", thr->id);
            applog(7, tmp42, 0);
          }
          cgsem_post(&thr->sem, "cgminer.c", _func___17344, 12074);
        }
      }
      ++j;
      ++k;
    }
  }
  if ( !opt_benchmark && !opt_benchfile )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool_1 = pools[i];
      enable_pool(pool_1);
      pool_1->idle = 1;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "Probing for an alive pool");
      applog(5, tmp42, 0);
    }
    probe_pools();
    do
    {
      sleep(1u);
      ++slept;
    }
    while ( !pools_active && slept <= 179 );
    do
    {
      if ( pools_active )
        goto begin_bench;
      if ( !pool_msg )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "No servers were found that could be used to get work from.");
          applog(3, tmp42, 0);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "Please check the details from the list below of the servers you have input");
          applog(3, tmp42, 0);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy(
            (char *)tmp42,
            "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
          applog(3, tmp42, 0);
        }
        for ( i = 0; i < total_pools; ++i )
        {
          pool_2 = pools[i];
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Pool: %d  URL: %s  User: %s  Password: %s",
              i,
              (const char *)pool_2->rpc_url,
              (const char *)pool_2->rpc_user,
              (const char *)pool_2->rpc_pass);
            applog(4, tmp42, 0);
          }
        }
        pool_msg = 1;
        if ( use_curses && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          strcpy((char *)tmp42, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
          applog(3, tmp42, 0);
        }
      }
    }
    while ( use_curses );
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "no valid pool enabled, keep running to provide 4028 service.");
      applog(3, tmp42, 0);
    }
  }
begin_bench:
  total_mhashes_done = 0.0;
  for ( i = 0; i <= 11; ++i )
  {
    v19 = &g_local_mhashes_dones[i];
    *(_DWORD *)v19 = 0;
    *((_DWORD *)v19 + 1) = 0;
  }
  g_local_mhashes_index = 0;
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu_1 = devices[i];
    cgpu_1->total_mhashes = 0LL;
    cgpu_1->rolling = cgpu_1->total_mhashes;
  }
  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v20 = *_errno_location();
      v21 = _errno_location();
      v22 = strerror(*v21);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v20, v22);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
    total_tv_start_sys = sInfo.uptime;
  }
  cgtime(&total_tv_start);
  cgtime(&total_tv_end);
  cgtime(&tv_hashmeter);
  get_datestamp(datestamp, 0x28u, &total_tv_start);
  watchpool_thr_id = 2;
  thr = control_thr + 2;
  if ( thr_info_create(control_thr + 2, 0, (void *(*)(void *))watchpool_thread, 0) )
  {
    strcpy((char *)tmp42, "watchpool thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  pthread_detach(thr->pth);
  watchdog_thr_id = 3;
  thr = control_thr + 3;
  if ( thr_info_create(control_thr + 3, 0, (void *(*)(void *))watchdog_thread, 0) )
  {
    strcpy((char *)tmp42, "watchdog thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  pthread_detach(thr->pth);
  api_thr_id = 5;
  thr = control_thr + 5;
  if ( thr_info_create(control_thr + 5, 0, (void *(*)(void *))api_thread, &control_thr[5]) )
  {
    strcpy((char *)tmp42, "API thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( total_control_threads != 8 )
  {
    snprintf((char *)tmp42, 0x800u, "incorrect total_control_threads (%d) should be 8", total_control_threads);
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  set_highprio();
  while ( 1 )
  {
    while ( 1 )
    {
      max_staged = max_queue;
      if ( opt_work_update )
        signal_work_update();
      opt_work_update = 0;
      mutex_lock_1(stgd_lock, "cgminer.c", _func___17344, 12255);
      ts = _total_staged();
      if ( ts > max_staged )
      {
        work_filled = 1;
        pthread_cond_wait(&gws_cond, stgd_lock);
        ts = _total_staged();
      }
      mutex_unlock_1(stgd_lock, "cgminer.c", _func___17344, 12266);
      if ( ts <= max_staged )
        break;
      work_filled = 1;
      work = hash_pop(0);
      if ( work )
        discard_work(&work, "cgminer.c", _func___17344, 12278);
    }
    if ( work )
      discard_work(&work, "cgminer.c", _func___17344, 12286);
    work = make_work();
    while ( 1 )
    {
      pool_3 = select_pool();
      if ( !pool_unusable(pool_3) )
        break;
      switch_pools(0);
      pool_3 = select_pool();
      if ( pool_unusable(pool_3) )
        cgsleep_ms(11);
    }
    if ( pool_3->has_stratum )
    {
      gen_stratum_work(pool_3, work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated stratum work");
        applog(7, tmp42, 0);
      }
      goto LABEL_367;
    }
    if ( opt_benchfile )
    {
      get_benchfile_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchfile work");
        applog(7, tmp42, 0);
      }
      goto LABEL_367;
    }
    if ( opt_benchmark )
    {
      get_benchmark_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchmark work");
        applog(7, tmp42, 0);
      }
      goto LABEL_367;
    }
    if ( opt_benchfile )
      break;
    if ( opt_benchmark )
    {
      get_benchmark_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchmark work");
        applog(7, tmp42, 0);
      }
LABEL_367:
      stage_work(work);
      work = 0;
    }
  }
  get_benchfile_work(work);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Generated benchfile work");
    applog(7, tmp42, 0);
  }
  goto LABEL_367;
}
// 5E6F4: variable 'v11' is possibly undefined

//----- (00060624) --------------------------------------------------------
void clear_probability_file()
{
  FILE *fd; // [sp+4h] [bp+4h]
  FILE *fda; // [sp+4h] [bp+4h]
  FILE *fdb; // [sp+4h] [bp+4h]
  FILE *fdc; // [sp+4h] [bp+4h]
  FILE *fdd; // [sp+4h] [bp+4h]

  fd = fopen("/config/reopen_algorithm_static_parameters.config", "wb");
  if ( fd )
  {
    fclose(fd);
    remove("/config/reopen_algorithm_static_parameters.config");
  }
  fda = fopen("/config/reopen_algorithm_efficient_normal_temp_parameters.config", "wb");
  if ( fda )
  {
    fclose(fda);
    remove("/config/reopen_algorithm_efficient_normal_temp_parameters.config");
  }
  fdb = fopen("/config/reopen_algorithm_efficient_low_temp_parameters.config", "wb");
  if ( fdb )
  {
    fclose(fdb);
    remove("/config/reopen_algorithm_efficient_low_temp_parameters.config");
  }
  fdc = fopen("/config/reopen_algorithm_high_power_normal_temp_parameters.config", "wb");
  if ( fdc )
  {
    fclose(fdc);
    remove("/config/reopen_algorithm_high_power_normal_temp_parameters.config");
  }
  fdd = fopen("/config/reopen_algorithm_high_power_low_temp_parameters.config", "wb");
  if ( fdd )
  {
    fclose(fdd);
    remove("/config/reopen_algorithm_high_power_low_temp_parameters.config");
  }
}

//----- (00060718) --------------------------------------------------------
void __cdecl store_mhashrate_history(double thash)
{
  double v1; // d0
  FILE *pFile_0; // [sp+8h] [bp+8h]
  FILE *pFile; // [sp+Ch] [bp+Ch]

  if ( thash_index > 0x40 )
    thash_index = 0;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)hash_log, "a+");
    if ( pFile )
      fprintf(pFile, "%d minutes countue...\n", minutes_11382);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    pFile_0 = fopen((const char *)hash_log, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "[%d] array\n", thash_index);
    fclose(pFile_0);
  }
  thashrate_array[thash_index] = v1;
  ++minutes_11382;
  if ( ++length > 0x40 )
    length = 65;
}
// 607F2: variable 'v1' is possibly undefined

//----- (00060844) --------------------------------------------------------
void clear_queue()
{
  FILE *pFile_0; // [sp+10h] [bp+0h]
  FILE *pFile; // [sp+14h] [bp+4h]

  thash_index = 0;
  length = 0;
  memset(thashrate_array, 0, sizeof(thashrate_array));
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: reset calc...\n", "hash_rate.c", 58, (const char *)_FUNCTION___11388);
    fclose(pFile);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: thash_index = %d,length = %d\n",
        "hash_rate.c",
        59,
        (const char *)_FUNCTION___11388,
        thash_index,
        length);
    fclose(pFile_0);
  }
}

//----- (00060964) --------------------------------------------------------
void recalc_hashrate()
{
  clear_queue();
}

//----- (0006096E) --------------------------------------------------------
void show_hashrate_history()
{
  FILE *pFile_1; // [sp+8h] [bp+0h]
  FILE *pFile_0; // [sp+Ch] [bp+4h]
  FILE *pFile_2; // [sp+10h] [bp+8h]
  FILE *pFile; // [sp+14h] [bp+Ch]
  uint32_t i; // [sp+1Ch] [bp+14h]

  if ( log_level > 3 )
  {
    pFile = fopen((const char *)hash_log, "a+");
    if ( pFile )
      fwrite("Unit:THash\n", 1u, 0xBu, pFile);
    fclose(pFile);
  }
  for ( i = 0; i <= 0x40; ++i )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)hash_log, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "hash[%02d]:%9.0f   ", i, thashrate_array[i]);
      fclose(pFile_0);
    }
    if ( !((i + 1) % 5) && log_level > 3 )
    {
      pFile_1 = fopen((const char *)hash_log, "a+");
      if ( pFile_1 )
        fputc(10, pFile_1);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)hash_log, "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
}

//----- (00060AC0) --------------------------------------------------------
void __noreturn store_hash_rate()
{
  double v0; // d0
  double v1; // r0
  uint32_t counter; // [sp+Ch] [bp+Ch]

  counter = 0;
  memset(thashrate_array, 0, sizeof(thashrate_array));
  while ( 1 )
  {
    ++counter;
    get_total_hashs();
    v0 = v0 / 1000.0 / 1000.0;
    store_mhashrate_history(v1);
    show_hashrate_history();
    sleep(0x3Cu);
    if ( !(counter % 0x1E) )
    {
      copy_log_to_latest(hash_log);
      clear_log(hash_log);
    }
    ++thash_index;
  }
}
// 60AFA: variable 'v0' is possibly undefined
// 60B0E: variable 'v1' is possibly undefined

//----- (00060B80) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl get_average_hashrate(uint32_t minutes)
{
  double result; // r0
  uint32_t minutesa; // [sp+1Ch] [bp+4h]
  FILE *pFile; // [sp+24h] [bp+Ch]
  FILE *pFile_7; // [sp+28h] [bp+10h]
  FILE *pFile_6; // [sp+2Ch] [bp+14h]
  FILE *pFile_5; // [sp+30h] [bp+18h]
  FILE *pFile_4; // [sp+34h] [bp+1Ch]
  FILE *pFile_3; // [sp+38h] [bp+20h]
  FILE *pFile_2; // [sp+3Ch] [bp+24h]
  FILE *pFile_1; // [sp+40h] [bp+28h]
  FILE *pFile_0; // [sp+44h] [bp+2Ch]
  double hash_rate; // [sp+48h] [bp+30h]
  double diff_secs; // [sp+50h] [bp+38h]
  double diff_hashrate; // [sp+58h] [bp+40h]
  int32_t start_index; // [sp+68h] [bp+50h]
  int32_t end_index; // [sp+6Ch] [bp+54h]

  minutesa = minutes;
  if ( length > 1 )
  {
    if ( minutes >= length - 1 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(hash_log, 3u);
        pFile_0 = fopen((const char *)hash_log, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: minutes = %d,max length = %d,use minute = %d instead\n",
            "hash_rate.c",
            129,
            (const char *)_FUNCTION___11418,
            minutesa,
            length,
            length - 1);
        minutes = fclose(pFile_0);
      }
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: minutes = %d beyond max length = %d,use minute = %d instead\n",
            "hash_rate.c",
            130,
            (const char *)_FUNCTION___11418,
            minutesa,
            length,
            length - 1);
        minutes = fclose(pFile_1);
      }
      minutesa = length - 1;
    }
    diff_secs = (double)(60 * minutesa);
    start_index = thash_index;
    if ( (int)(thash_index - minutesa) >= 0 )
      end_index = thash_index - minutesa;
    else
      end_index = thash_index - minutesa + 65;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(hash_log, 3u);
      pFile_2 = fopen((const char *)hash_log, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: start_index = %d, end_index = %d\n",
          "hash_rate.c",
          144,
          (const char *)_FUNCTION___11418,
          start_index,
          end_index);
      minutes = fclose(pFile_2);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: start_index = %d, end_index = %d\n",
          "hash_rate.c",
          145,
          (const char *)_FUNCTION___11418,
          start_index,
          end_index);
      minutes = fclose(pFile_3);
    }
    diff_hashrate = thashrate_array[start_index] - thashrate_array[end_index];
    hash_rate = diff_hashrate / diff_secs;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(hash_log, 3u);
      pFile_4 = fopen((const char *)hash_log, "a+");
      if ( pFile_4 )
        fprintf(
          pFile_4,
          "%s:%d:%s: diff_hashrate = %.3f, diff_secs = %.0f\n",
          "hash_rate.c",
          151,
          (const char *)_FUNCTION___11418,
          diff_hashrate,
          diff_secs);
      minutes = fclose(pFile_4);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(
          pFile_5,
          "%s:%d:%s: diff_hashrate = %.3f, diff_secs = %.0f\n",
          "hash_rate.c",
          152,
          (const char *)_FUNCTION___11418,
          diff_hashrate,
          diff_secs);
      minutes = fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(hash_log, 3u);
      pFile_6 = fopen((const char *)hash_log, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "%s:%d:%s: [%d] minutes ave hashrate : [%.3f] THash/s\n",
          "hash_rate.c",
          154,
          (const char *)_FUNCTION___11418,
          minutesa,
          hash_rate);
      minutes = fclose(pFile_6);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(
          pFile_7,
          "%s:%d:%s: [%d] minutes ave hashrate : [%.3f] THash/s\n",
          "hash_rate.c",
          155,
          (const char *)_FUNCTION___11418,
          minutesa,
          hash_rate);
      minutes = fclose(pFile_7);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: hash rate data is not enough!\n", "hash_rate.c", 123, (const char *)_FUNCTION___11418);
    minutes = fclose(pFile);
  }
  LODWORD(result) = minutes;
  return result;
}
// 60B80: variables would overlap: r0.4 and r0.8
// 60B80: bad return variable

//----- (000610C0) --------------------------------------------------------
double get_30minutes_hashrate()
{
  return get_average_hashrate(0x1Eu);
}

//----- (000610D4) --------------------------------------------------------
void __cdecl json_decref_1(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0006110C) --------------------------------------------------------
int sock_blocks_0()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (00061138) --------------------------------------------------------
void __cdecl mutex_lock_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000611B4) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00061230) --------------------------------------------------------
void __cdecl mutex_unlock_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_2(lock, file, func, line);
  selective_yield();
}

//----- (0006125E) --------------------------------------------------------
void __cdecl wr_lock_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000612DA) --------------------------------------------------------
void __cdecl rd_lock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00061356) --------------------------------------------------------
void __cdecl rw_unlock_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000613D2) --------------------------------------------------------
void __cdecl wr_unlock_noyield_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_2(lock, file, func, line);
}

//----- (000613F4) --------------------------------------------------------
void __cdecl rd_unlock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_2(lock, file, func, line);
  selective_yield();
}

//----- (00061422) --------------------------------------------------------
void __cdecl mutex_init_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000614A0) --------------------------------------------------------
void __cdecl cg_rlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_2(&lock->mutex, file, func, line);
  rd_lock_1(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_2(&lock->mutex, file, func, line);
}

//----- (000614DE) --------------------------------------------------------
void __cdecl cg_wlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_2(&lock->mutex, file, func, line);
  wr_lock_2(&lock->rwlock, file, func, line);
}

//----- (00061510) --------------------------------------------------------
void __cdecl cg_runlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock_1(&lock->rwlock, file, func, line);
}

//----- (00061536) --------------------------------------------------------
void __cdecl cg_wunlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_2(&lock->rwlock, file, func, line);
  mutex_unlock_2(&lock->mutex, file, func, line);
}

//----- (00061568) --------------------------------------------------------
void __cdecl io_reinit(io_data *io_data)
{
  io_data->cur = io_data->ptr;
  *io_data->ptr = 0;
  io_data->close = 0;
}

//----- (00061592) --------------------------------------------------------
io_data *__cdecl io_new(size_t initial, bool socket_buf)
{
  io_list *io_list; // [sp+8h] [bp+8h]
  io_data *io_data; // [sp+Ch] [bp+Ch]

  io_data = (io_data *)cgmalloc(0x10u, "api-btm.c", _func___11310, 723);
  io_data->ptr = (unsigned __int8 *)cgmalloc(initial, "api-btm.c", _func___11310, 724);
  io_data->siz = initial;
  io_data->sock = socket_buf;
  io_reinit(io_data);
  io_list = (io_list *)cgmalloc(0xCu, "api-btm.c", _func___11310, 729);
  io_list->io_data = io_data;
  if ( io_head )
  {
    io_list->next = io_head;
    io_list->prev = io_head->prev;
    io_list->next->prev = io_list;
    io_list->prev->next = io_list;
  }
  else
  {
    io_list->prev = io_list;
    io_list->next = io_list;
    io_head = io_list;
  }
  return io_data;
}

//----- (00061670) --------------------------------------------------------
bool __cdecl io_add(io_data *io_data, unsigned __int8 *buf)
{
  unsigned int tot; // [sp+10h] [bp+8h]
  size_t dif; // [sp+14h] [bp+Ch]
  size_t len; // [sp+18h] [bp+10h]
  unsigned int newa; // [sp+1Ch] [bp+14h]

  len = strlen((const char *)buf);
  dif = io_data->cur - io_data->ptr;
  tot = dif + len + 12;
  if ( tot > io_data->siz )
  {
    newa = io_data->siz + 0x20000;
    if ( newa < tot )
      newa = ((unsigned int)(float)((float)tot / 65536.0) + 2) << 16;
    io_data->ptr = (unsigned __int8 *)cgrealloc(io_data->ptr, newa, "api-btm.c", _func___11319, 766);
    io_data->cur = &io_data->ptr[dif];
    io_data->siz = newa;
  }
  memcpy(io_data->cur, buf, len + 1);
  io_data->cur += len;
  return 1;
}

//----- (00061738) --------------------------------------------------------
bool __cdecl io_put(io_data *io_data, unsigned __int8 *buf)
{
  io_reinit(io_data);
  return io_add(io_data, buf);
}

//----- (0006175A) --------------------------------------------------------
void __cdecl io_close(io_data *io_data)
{
  io_data->close = 1;
}

//----- (00061774) --------------------------------------------------------
void io_free()
{
  io_list *io_next; // [sp+0h] [bp+0h]
  io_list *io_list; // [sp+4h] [bp+4h]

  if ( io_head )
  {
    io_list = io_head;
    do
    {
      io_next = io_list->next;
      free(io_list->io_data->ptr);
      free(io_list->io_data);
      free(io_list);
      io_list = io_next;
    }
    while ( io_next != io_head );
    io_head = 0;
  }
}

//----- (000617DE) --------------------------------------------------------
unsigned __int8 *__cdecl escape_string(unsigned __int8 *str, bool isjson)
{
  int v2; // r3
  size_t v4; // r0
  int v5; // r3
  unsigned __int8 *v6; // r3
  unsigned __int8 *v7; // r2
  unsigned __int8 *v8; // r3
  unsigned __int8 *v9; // r3
  unsigned __int8 *v10; // r2
  unsigned __int8 *v11; // r3
  unsigned __int8 *v12; // r2
  unsigned __int8 *v13; // r3
  unsigned __int8 *v14; // r2
  unsigned __int8 *v15; // r3
  unsigned __int8 *stra; // [sp+4h] [bp+4h]
  unsigned __int8 *buf; // [sp+Ch] [bp+Ch]
  int count; // [sp+10h] [bp+10h]
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]
  unsigned __int8 *ptra; // [sp+14h] [bp+14h]

  stra = str;
  count = 0;
  for ( ptr = str; *ptr; ++ptr )
  {
    v2 = *ptr;
    if ( v2 == 61 )
      goto LABEL_9;
    if ( *ptr > 0x3Du )
    {
      if ( v2 == 92 )
      {
        ++count;
        continue;
      }
      if ( v2 != 124 )
        continue;
LABEL_9:
      if ( !isjson )
        ++count;
      continue;
    }
    if ( v2 != 34 )
    {
      if ( v2 != 44 )
        continue;
      goto LABEL_9;
    }
    if ( isjson )
      ++count;
  }
  if ( count )
  {
    v4 = strlen((const char *)str);
    buf = (unsigned __int8 *)cgmalloc(count + v4 + 1, "api-btm.c", _func___11349, 842);
    ptra = buf;
    while ( 1 )
    {
      if ( !*stra )
      {
        *ptra = 0;
        return buf;
      }
      v5 = *stra;
      if ( v5 == 61 )
        goto LABEL_26;
      if ( *stra > 0x3Du )
      {
        if ( v5 == 92 )
        {
          *ptra = 92;
          v12 = stra++;
          v13 = ptra + 1;
          ptra += 2;
          *v13 = *v12;
        }
        else
        {
          if ( v5 != 124 )
            goto LABEL_33;
LABEL_26:
          if ( !isjson )
          {
            v6 = ptra++;
            *v6 = 92;
          }
          v7 = stra++;
          v8 = ptra++;
          *v8 = *v7;
        }
      }
      else if ( v5 == 34 )
      {
        if ( isjson )
        {
          v9 = ptra++;
          *v9 = 92;
        }
        v10 = stra++;
        v11 = ptra++;
        *v11 = *v10;
      }
      else
      {
        if ( v5 == 44 )
          goto LABEL_26;
LABEL_33:
        v14 = stra++;
        v15 = ptra++;
        *v15 = *v14;
      }
    }
  }
  return str;
}

//----- (00061936) --------------------------------------------------------
api_data *__cdecl api_add_extra(api_data *root, api_data *extra)
{
  api_data *roota; // [sp+4h] [bp+4h]
  api_data *tmp; // [sp+Ch] [bp+Ch]

  roota = root;
  if ( !root )
    return extra;
  if ( extra )
  {
    tmp = extra->prev;
    extra->prev = root->prev;
    root->prev->next = extra;
    tmp->next = root;
    root->prev = tmp;
  }
  return roota;
}

//----- (00061984) --------------------------------------------------------
api_data *__cdecl api_add_data_full(
        api_data *root,
        unsigned __int8 *name,
        api_data_type type,
        void *data,
        bool copy_data)
{
  size_t v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+14h] BYREF
  api_data *api_data; // [sp+814h] [bp+814h]

  api_data = (api_data *)cgmalloc(0x18u, "api-btm.c", _func___11373, 908);
  api_data->name = (unsigned __int8 *)strdup((const char *)name);
  api_data->type = type;
  if ( root )
  {
    api_data->prev = root->prev;
    root->prev = api_data;
    api_data->next = root;
    api_data->prev->next = api_data;
  }
  else
  {
    root = api_data;
    api_data->prev = api_data;
    root->next = root;
  }
  api_data->data_was_malloc = copy_data;
  if ( !data )
  {
    type = API_CONST;
    api_data->type = API_CONST;
    data = (void *)NULLSTR;
    copy_data = 0;
    api_data->data_was_malloc = 0;
  }
  if ( !copy_data )
  {
    api_data->data = data;
  }
  else
  {
    switch ( type )
    {
      case API_ESCAPE:
      case API_STRING:
      case API_CONST:
        v5 = strlen((const char *)data);
        api_data->data = cgmalloc(v5 + 1, "api-btm.c", _func___11373, 945);
        strcpy((char *)api_data->data, (const char *)data);
        break;
      case API_UINT8:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 950);
        *(_BYTE *)api_data->data = *(_BYTE *)data;
        break;
      case API_INT16:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 955);
        *(_WORD *)api_data->data = *(_WORD *)data;
        break;
      case API_UINT16:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 960);
        *(_WORD *)api_data->data = *(_WORD *)data;
        break;
      case API_INT:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 964);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 968);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT32:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 972);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_HEX32:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 976);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT64:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11373, 980);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_INT64:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11373, 984);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_DOUBLE:
      case API_ELAPSED:
      case API_MHS:
      case API_MHTOTAL:
      case API_UTILITY:
      case API_FREQ:
      case API_HS:
      case API_DIFF:
      case API_PERCENT:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11373, 996);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_BOOL:
        api_data->data = cgmalloc(1u, "api-btm.c", _func___11373, 1000);
        *(_BYTE *)api_data->data = *(_BYTE *)data;
        break;
      case API_TIMEVAL:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11373, 1004);
        memcpy(api_data->data, data, 8u);
        break;
      case API_TIME:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 1008);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_TEMP:
      case API_VOLTS:
      case API_AVG:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11373, 1014);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: unknown1 data type %d ignored", type);
          applog(3, tmp42, 0);
        }
        api_data->type = API_STRING;
        api_data->data_was_malloc = 0;
        api_data->data = (void *)UNKNOWN;
        break;
    }
  }
  return root;
}

//----- (00061EA4) --------------------------------------------------------
api_data *__cdecl api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ESCAPE, data, copy_data);
}

//----- (00061ECC) --------------------------------------------------------
api_data *__cdecl api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_STRING, data, copy_data);
}

//----- (00061EF4) --------------------------------------------------------
api_data *__cdecl api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_CONST, (void *)data, copy_data);
}

//----- (00061F1C) --------------------------------------------------------
api_data *__cdecl api_add_uint8(api_data *root, unsigned __int8 *name, uint8_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT8, data, copy_data);
}

//----- (00061F44) --------------------------------------------------------
api_data *__cdecl api_add_int16(api_data *root, unsigned __int8 *name, int16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT16, data, copy_data);
}

//----- (00061F6C) --------------------------------------------------------
api_data *__cdecl api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT, data, copy_data);
}

//----- (00061F94) --------------------------------------------------------
api_data *__cdecl api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT, data, copy_data);
}

//----- (00061FBC) --------------------------------------------------------
api_data *__cdecl api_add_uint32(api_data *root, unsigned __int8 *name, uint32_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT32, data, copy_data);
}

//----- (00061FE4) --------------------------------------------------------
api_data *__cdecl api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT64, data, copy_data);
}

//----- (0006200C) --------------------------------------------------------
api_data *__cdecl api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT64, data, copy_data);
}

//----- (00062034) --------------------------------------------------------
api_data *__cdecl api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ELAPSED, data, copy_data);
}

//----- (0006205C) --------------------------------------------------------
api_data *__cdecl api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data)
{
  return api_add_data_full(root, name, API_BOOL, data, copy_data);
}

//----- (00062084) --------------------------------------------------------
api_data *__cdecl api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIMEVAL, data, copy_data);
}

//----- (000620AC) --------------------------------------------------------
api_data *__cdecl api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIME, data, copy_data);
}

//----- (000620D4) --------------------------------------------------------
api_data *__cdecl api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHS, data, copy_data);
}

//----- (000620FC) --------------------------------------------------------
api_data *__cdecl api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHTOTAL, data, copy_data);
}

//----- (00062124) --------------------------------------------------------
api_data *__cdecl api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TEMP, data, copy_data);
}

//----- (0006214C) --------------------------------------------------------
api_data *__cdecl api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UTILITY, data, copy_data);
}

//----- (00062174) --------------------------------------------------------
api_data *__cdecl api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_DIFF, data, copy_data);
}

//----- (0006219C) --------------------------------------------------------
api_data *__cdecl api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_PERCENT, data, copy_data);
}

//----- (000621C4) --------------------------------------------------------
void __cdecl add_item_buf(K_ITEM *item, const unsigned __int8 *str)
{
  size_t old_siz; // [sp+1Ch] [bp+14h]
  size_t siz; // [sp+20h] [bp+18h]
  unsigned __int8 *buf; // [sp+24h] [bp+1Ch]

  buf = *(unsigned __int8 **)item->data;
  siz = strlen((const char *)str);
  old_siz = *((_DWORD *)item->data + 1);
  if ( siz + old_siz + 1 > *((_DWORD *)item->data + 2) )
  {
    buf = (unsigned __int8 *)cgrealloc(
                               *(void **)item->data,
                               *((_DWORD *)item->data + 2) + siz - (((_WORD)siz + 1) & 0xFFF) + 4097,
                               "api-btm.c",
                               _func___11575,
                               1176);
    *(_DWORD *)item->data = buf;
    *((_DWORD *)item->data + 2) += siz - (((_WORD)siz + 1) & 0xFFF) + 4097;
  }
  memcpy(&buf[old_siz], str, siz + 1);
  *((_DWORD *)item->data + 1) += siz;
}

//----- (00062280) --------------------------------------------------------
api_data *__cdecl print_data(io_data *io_data, api_data *root, bool isjson, bool precom)
{
  const unsigned __int8 *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 buf[64]; // [sp+81Ch] [bp+814h] BYREF
  api_data *tmp; // [sp+85Ch] [bp+854h]
  unsigned __int8 *escape; // [sp+860h] [bp+858h]
  unsigned __int8 *original; // [sp+864h] [bp+85Ch]
  K_ITEM *item; // [sp+868h] [bp+860h]
  bool first; // [sp+86Eh] [bp+866h]
  bool done; // [sp+86Fh] [bp+867h]

  first = 1;
  cg_wlock_2(strbufs->lock, "api-btm.c", _func___11589, 1192);
  item = k_unlink_head(strbufs, "api-btm.c", _func___11589, 1193);
  cg_wunlock_2(strbufs->lock, "api-btm.c", _func___11589, 1194);
  *((_DWORD *)item->data + 1) = 0;
  if ( precom )
    add_item_buf(item, COMMA);
  if ( isjson )
    add_item_buf(item, "{");
  while ( root )
  {
    if ( !first )
      add_item_buf(item, COMMA);
    else
      first = 0;
    if ( isjson )
      add_item_buf(item, "\"");
    add_item_buf(item, root->name);
    if ( isjson )
      add_item_buf(item, "\"");
    if ( isjson )
      add_item_buf(item, ":");
    else
      add_item_buf(item, "=");
    first = 0;
    done = 0;
    switch ( root->type )
    {
      case API_ESCAPE:
        original = (unsigned __int8 *)root->data;
        escape = escape_string((unsigned __int8 *)root->data, isjson);
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, escape);
        if ( isjson )
          add_item_buf(item, "\"");
        if ( escape != original )
          free(escape);
        done = 1;
        break;
      case API_STRING:
      case API_CONST:
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, (const unsigned __int8 *)root->data);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
      case API_UINT8:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int8 *)root->data);
        break;
      case API_INT16:
        snprintf((char *)buf, 0x40u, "%d", *(__int16 *)root->data);
        break;
      case API_UINT16:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int16 *)root->data);
        break;
      case API_INT:
        snprintf((char *)buf, 0x40u, "%d", *(_DWORD *)root->data);
        break;
      case API_UINT:
      case API_UINT32:
        snprintf((char *)buf, 0x40u, "%u", *(_DWORD *)root->data);
        break;
      case API_HEX32:
        if ( isjson )
          add_item_buf(item, "\"");
        snprintf((char *)buf, 0x40u, "0x%08x", *(_DWORD *)root->data);
        add_item_buf(item, buf);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
      case API_UINT64:
        snprintf((char *)buf, 0x40u, "%llu", *(_QWORD *)root->data);
        break;
      case API_INT64:
        snprintf((char *)buf, 0x40u, "%lld", *(_QWORD *)root->data);
        break;
      case API_DOUBLE:
        snprintf((char *)buf, 0x40u, "%f", *(double *)root->data);
        break;
      case API_ELAPSED:
        snprintf((char *)buf, 0x40u, "%.0f", *(double *)root->data);
        break;
      case API_BOOL:
        if ( *(_BYTE *)root->data )
          v4 = TRUESTR;
        else
          v4 = FALSESTR;
        snprintf((char *)buf, 0x40u, "%s", (const char *)v4);
        break;
      case API_TIMEVAL:
        snprintf((char *)buf, 0x40u, "%ld.%06ld", *(_DWORD *)root->data, *((_DWORD *)root->data + 1));
        break;
      case API_TIME:
        snprintf((char *)buf, 0x40u, "%lu", *(_DWORD *)root->data);
        break;
      case API_MHS:
      case API_UTILITY:
      case API_FREQ:
        snprintf((char *)buf, 0x40u, "%.2f", *(double *)root->data);
        break;
      case API_MHTOTAL:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data);
        break;
      case API_TEMP:
        snprintf((char *)buf, 0x40u, "%.2f", *(float *)root->data);
        break;
      case API_VOLTS:
      case API_AVG:
        snprintf((char *)buf, 0x40u, "%.3f", *(float *)root->data);
        break;
      case API_HS:
        snprintf((char *)buf, 0x40u, "%.15f", *(double *)root->data);
        break;
      case API_DIFF:
        snprintf((char *)buf, 0x40u, "%.8f", *(double *)root->data);
        break;
      case API_PERCENT:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data * 100.0);
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: unknown2 data type %d ignored", root->type);
          applog(3, tmp42, 0);
        }
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, UNKNOWN);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
    }
    if ( !done )
      add_item_buf(item, buf);
    free(root->name);
    if ( root->data_was_malloc )
      free(root->data);
    if ( root == root->next )
    {
      free(root);
      root = 0;
    }
    else
    {
      tmp = root;
      root = root->next;
      root->prev = tmp->prev;
      root->prev->next = root;
      free(tmp);
    }
  }
  if ( isjson )
    add_item_buf(item, "}");
  else
    add_item_buf(item, "|");
  io_add(io_data, *(unsigned __int8 **)item->data);
  cg_wlock_2(strbufs->lock, "api-btm.c", _func___11589, 1364);
  k_add_head(strbufs, item, "api-btm.c", _func___11589, 1365);
  cg_wunlock_2(strbufs->lock, "api-btm.c", _func___11589, 1366);
  return 0;
}

//----- (00062A98) --------------------------------------------------------
int numascs()
{
  int i; // [sp+0h] [bp+0h]
  int count; // [sp+4h] [bp+4h]

  count = 0;
  rd_lock_1(&devices_lock, "api-btm.c", _func___11628, 1380);
  for ( i = 0; i < total_devices; ++i )
  {
    if ( devices[i]->drv->drv_id == DRIVER_bitmain )
      ++count;
    if ( devices[i]->drv->drv_id == DRIVER_bitmain_soc )
      ++count;
  }
  rd_unlock_1(&devices_lock, "api-btm.c", _func___11628, 1385);
  return count;
}

//----- (00062B48) --------------------------------------------------------
int __cdecl ascdevice(int ascid)
{
  int i; // [sp+8h] [bp+8h]
  int count; // [sp+Ch] [bp+Ch]

  count = 0;
  rd_lock_1(&devices_lock, "api-btm.c", _func___11637, 1394);
  for ( i = 0; ; ++i )
  {
    if ( i >= total_devices )
    {
      rd_unlock_1(&devices_lock, "api-btm.c", _func___11637, 1402);
      return -1;
    }
    if ( devices[i]->drv->drv_id == DRIVER_bitmain )
      ++count;
    if ( devices[i]->drv->drv_id == DRIVER_bitmain_soc )
      ++count;
    if ( count == ascid + 1 )
      break;
  }
  rd_unlock_1(&devices_lock, "api-btm.c", _func___11637, 1407);
  return i;
}

//----- (00062C2C) --------------------------------------------------------
void __cdecl message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson)
{
  code_severity v5; // r3
  const unsigned __int8 *v6; // r2
  api_data *v7; // r0
  int messageida; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  int id; // [sp+14h] [bp+14h] BYREF
  unsigned __int8 severity[2]; // [sp+18h] [bp+18h] BYREF
  unsigned __int8 buf[8192]; // [sp+1Ch] [bp+1Ch] BYREF
  int asc; // [sp+201Ch] [bp+201Ch]
  api_data *root; // [sp+2020h] [bp+2020h]
  int i; // [sp+2024h] [bp+2024h]

  io_dataa = io_data;
  messageida = messageid;
  root = 0;
  if ( isjson )
    io_add(io_dataa, "{\"STATUS\":[");
  for ( i = 0; ; ++i )
  {
    if ( codes[i].severity == SEVERITY_FAIL )
    {
      v7 = api_add_string(root, "STATUS", "F", 0);
      root = api_add_time(v7, "When", &when, 0);
      id = -1;
      root = api_add_int(root, "Code", &id, 0);
      sprintf((char *)buf, "%d", messageida);
      root = api_add_escape(root, "Msg", buf, 0);
      root = api_add_escape(root, "Description", opt_api_description, 0);
      root = print_data(io_dataa, root, isjson, 0);
      if ( isjson )
        io_add(io_dataa, "]");
      return;
    }
    if ( codes[i].code == messageida )
      break;
  }
  v5 = codes[i].severity;
  switch ( v5 )
  {
    case SEVERITY_INFO:
      severity[0] = 73;
      break;
    case SEVERITY_SUCC:
      severity[0] = 83;
      break;
    case SEVERITY_WARN:
      severity[0] = 87;
      break;
    default:
      severity[0] = 69;
      break;
  }
  severity[1] = 0;
  switch ( codes[i].params )
  {
    case PARAM_PGA:
    case PARAM_ASC:
    case PARAM_PID:
    case PARAM_INT:
      sprintf((char *)buf, (const char *)codes[i].description, paramid);
      break;
    case PARAM_ASCMAX:
      asc = numascs();
      sprintf((char *)buf, (const char *)codes[i].description, paramid, asc - 1);
      break;
    case PARAM_PMAX:
      sprintf((char *)buf, (const char *)codes[i].description, total_pools);
      break;
    case PARAM_POOLMAX:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, total_pools - 1);
      break;
    case PARAM_DMAX:
      asc = numascs();
      sprintf((char *)buf, (const char *)codes[i].description, asc);
      break;
    case PARAM_CMD:
      sprintf((char *)buf, (const char *)codes[i].description, JSON_COMMAND);
      break;
    case PARAM_POOL:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, pools[paramid]->rpc_url);
      break;
    case PARAM_STR:
      sprintf((char *)buf, (const char *)codes[i].description, param2);
      break;
    case PARAM_BOTH:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, param2);
      break;
    case PARAM_BOOL:
      if ( paramid )
        v6 = TRUESTR;
      else
        v6 = FALSESTR;
      sprintf((char *)buf, (const char *)codes[i].description, v6);
      break;
    case PARAM_SET:
      sprintf((char *)buf, (const char *)codes[i].description, param2, paramid);
      break;
    default:
      strcpy((char *)buf, (const char *)codes[i].description);
      break;
  }
  root = api_add_string(root, "STATUS", severity, 0);
  root = api_add_time(root, "When", &when, 0);
  root = api_add_int(root, "Code", &messageida, 0);
  root = api_add_escape(root, "Msg", buf, 0);
  root = api_add_escape(root, "Description", opt_api_description, 0);
  root = print_data(io_dataa, root, isjson, 0);
  if ( isjson )
    io_add(io_dataa, "]");
}

//----- (000632D0) --------------------------------------------------------
void __cdecl lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 124, 0, 0, isjson);
}

//----- (000632F6) --------------------------------------------------------
void __cdecl apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  bool io_open; // [sp+1Bh] [bp+13h]

  message(io_data, 22, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"VERSION\":[";
  else
    v5 = "VERSION,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_string(0, "CGMiner", "2.0.0", 0);
  v7 = api_add_const(v6, "API", APIVERSION, 0);
  v8 = api_add_string(v7, "Miner", g_miner_version, 0);
  v9 = api_add_string(v8, "CompileTime", g_miner_compiletime, 0);
  v10 = api_add_string(v9, "Type", g_miner_type, 0);
  print_data(io_data, v10, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (000633E8) --------------------------------------------------------
void __cdecl minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int pgacount; // [sp+18h] [bp+10h] BYREF
  int asccount; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  pgacount = 0;
  asccount = numascs();
  message(io_data, 33, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"CONFIG\":[";
  else
    v5 = "CONFIG,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "ASC Count", &asccount, 0);
  root = api_add_int(root, "PGA Count", &pgacount, 0);
  root = api_add_int(root, "Pool Count", &total_pools, 0);
  root = api_add_const(root, "Strategy", strategies_0[pool_strategy_0].s, 0);
  root = api_add_int(root, "Log Interval", &opt_log_interval, 0);
  root = api_add_const(root, "Device Code", DEVICECODE, 0);
  root = api_add_const(root, "OS", OSINFO, 0);
  root = api_add_const(root, "Hotplug", NONE, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00063544) --------------------------------------------------------
const unsigned __int8 *__cdecl status2str(alive status)
{
  const unsigned __int8 *v1; // r3

  switch ( status )
  {
    case LIFE_WELL:
      v1 = ALIVE;
      break;
    case LIFE_SICK:
      v1 = SICK;
      break;
    case LIFE_DEAD:
      v1 = DEAD;
      break;
    case LIFE_NOSTART:
      v1 = NOSTART;
      break;
    case LIFE_INIT:
      v1 = INIT;
      break;
    default:
      v1 = UNKNOWN;
      break;
  }
  return v1;
}

//----- (000635C0) --------------------------------------------------------
void __cdecl ascstatus(io_data *io_data, int asc, bool isjson, bool precom)
{
  double v4; // d0
  float v5; // s15
  int v6; // r3
  double v7; // d7
  double v8; // d7
  int asca; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  double rejp; // [sp+10h] [bp+10h] BYREF
  double hwp; // [sp+18h] [bp+18h] BYREF
  int last_share_pool; // [sp+20h] [bp+20h] BYREF
  unsigned __int8 mhsname[27]; // [sp+24h] [bp+24h] BYREF
  double mhs; // [sp+40h] [bp+40h] BYREF
  double dev_runtime; // [sp+48h] [bp+48h] BYREF
  float temp; // [sp+54h] [bp+54h] BYREF
  unsigned __int8 *status; // [sp+58h] [bp+58h]
  cgpu_info *cgpu; // [sp+5Ch] [bp+5Ch]
  int dev; // [sp+60h] [bp+60h]
  int numasc; // [sp+64h] [bp+64h]
  api_data *root; // [sp+68h] [bp+68h]
  unsigned __int8 *enabled; // [sp+6Ch] [bp+6Ch]

  io_dataa = io_data;
  asca = asc;
  root = 0;
  numasc = numascs();
  if ( numasc > 0 && asca >= 0 && numasc > asca )
  {
    dev = ascdevice(asca);
    if ( dev >= 0 )
    {
      cgpu = get_devices(dev);
      v5 = cgpu->temp;
      temp = v5;
      cgpu_runtime(cgpu);
      dev_runtime = v4;
      cgpu->utility = (double)cgpu->accepted / v4 * 60.0;
      if ( cgpu->deven == DEV_DISABLED )
        enabled = (unsigned __int8 *)NO;
      else
        enabled = (unsigned __int8 *)YES;
      status = (unsigned __int8 *)status2str(cgpu->status);
      root = api_add_int(root, "ASC", &asca, 0);
      root = api_add_string(root, "Name", cgpu->drv->name, 0);
      root = api_add_int(root, "ID", &cgpu->device_id, 0);
      root = api_add_string(root, "Enabled", enabled, 0);
      root = api_add_string(root, "Status", status, 0);
      root = api_add_temp(root, "Temperature", &temp, 0);
      mhs = cgpu->total_mhashes / dev_runtime;
      root = api_add_mhs(root, "MHS av", &mhs, 0);
      sprintf((char *)mhsname, "MHS %ds", opt_log_interval);
      root = api_add_mhs(root, mhsname, &cgpu->rolling, 0);
      root = api_add_int(root, "Accepted", &cgpu->accepted, 0);
      root = api_add_int(root, "Rejected", &cgpu->rejected, 0);
      root = api_add_int(root, "Hardware Errors", &cgpu->hw_errors, 0);
      root = api_add_utility(root, "Utility", &cgpu->utility, 0);
      if ( cgpu->last_share_pool_time <= 0 )
        v6 = -1;
      else
        v6 = cgpu->last_share_pool;
      last_share_pool = v6;
      root = api_add_int(root, "Last Share Pool", &last_share_pool, 0);
      root = api_add_time(root, "Last Share Time", &cgpu->last_share_pool_time, 0);
      root = api_add_mhtotal(root, "Total MH", &cgpu->total_mhashes, 0);
      root = api_add_int64(root, "Diff1 Work", &cgpu->diff1, 0);
      root = api_add_diff(root, "Difficulty Accepted", &cgpu->diff_accepted, 0);
      root = api_add_diff(root, "Difficulty Rejected", &cgpu->diff_rejected, 0);
      root = api_add_diff(root, "Last Share Difficulty", &cgpu->last_share_diff, 0);
      root = api_add_time(root, "Last Valid Work", &cgpu->last_device_valid_work, 0);
      if ( cgpu->hw_errors + cgpu->diff1 )
        v7 = (double)cgpu->hw_errors / (double)(cgpu->hw_errors + cgpu->diff1);
      else
        v7 = 0.0;
      hwp = v7;
      root = api_add_percent(root, "Device Hardware%", &hwp, 0);
      if ( cgpu->diff1 )
        v8 = cgpu->diff_rejected / (double)cgpu->diff1;
      else
        v8 = 0.0;
      rejp = v8;
      root = api_add_percent(root, "Device Rejected%", &rejp, 0);
      root = api_add_elapsed(root, "Device Elapsed", &dev_runtime, 0);
      print_data(io_dataa, root, isjson, precom);
    }
  }
}
// 63632: variable 'v4' is possibly undefined

//----- (00063994) --------------------------------------------------------
void __cdecl devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int numasc; // [sp+20h] [bp+18h]
  int i; // [sp+24h] [bp+1Ch]
  int devcount; // [sp+28h] [bp+20h]
  bool io_open; // [sp+2Fh] [bp+27h]

  io_open = 0;
  devcount = 0;
  numasc = numascs();
  if ( numasc )
  {
    message(io_data, 9, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVS\":[");
    if ( numasc > 0 )
    {
      for ( i = 0; i < numasc; ++i )
      {
        v5 = isjson && devcount > 0;
        ascstatus(io_data, i, isjson, v5);
        ++devcount;
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}
// 639BE: conditional instruction was optimized away because %numpga.4==0

//----- (00063A5E) --------------------------------------------------------
void __cdecl edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int numasc; // [sp+20h] [bp+18h]
  int i; // [sp+24h] [bp+1Ch]
  int devcount; // [sp+28h] [bp+20h]
  bool io_open; // [sp+2Fh] [bp+27h]

  io_open = 0;
  devcount = 0;
  numasc = numascs();
  if ( numasc )
  {
    message(io_data, 9, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVS\":[");
    if ( numasc > 0 )
    {
      for ( i = 0; i < numasc; ++i )
      {
        v5 = isjson && devcount > 0;
        ascstatus(io_data, i, isjson, v5);
        ++devcount;
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}
// 63A88: conditional instruction was optimized away because %numpga.4==0

//----- (00063B28) --------------------------------------------------------
void __cdecl poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool_enable enabled; // r3
  const unsigned __int8 *v6; // r0
  double v7; // d7
  double v8; // d7
  bool v9; // r3
  double stalep; // [sp+18h] [bp+10h] BYREF
  double rejp; // [sp+20h] [bp+18h] BYREF
  unsigned __int8 lasttime[256]; // [sp+28h] [bp+20h] BYREF
  int i; // [sp+128h] [bp+120h] BYREF
  pool *pool; // [sp+12Ch] [bp+124h]
  int second; // [sp+130h] [bp+128h]
  int minute; // [sp+134h] [bp+12Ch]
  int hour; // [sp+138h] [bp+130h]
  int timediff; // [sp+13Ch] [bp+134h]
  unsigned __int8 *lp; // [sp+140h] [bp+138h]
  unsigned __int8 *status; // [sp+144h] [bp+13Ch]
  bool io_open; // [sp+14Bh] [bp+143h]
  api_data *root; // [sp+14Ch] [bp+144h]

  root = 0;
  io_open = 0;
  hour = 0;
  minute = 0;
  second = 0;
  memset(lasttime, 0, sizeof(lasttime));
  timediff = 0;
  if ( total_pools )
  {
    message(io_data, 7, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"POOLS\":[");
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( !pool->removed )
      {
        enabled = pool->enabled;
        if ( enabled == POOL_ENABLED )
        {
          if ( pool->idle )
            status = (unsigned __int8 *)DEAD;
          else
            status = (unsigned __int8 *)ALIVE;
        }
        else if ( enabled )
        {
          if ( enabled == POOL_REJECTING )
            status = (unsigned __int8 *)REJECTING;
          else
            status = (unsigned __int8 *)UNKNOWN;
        }
        else
        {
          status = (unsigned __int8 *)DISABLED;
        }
        if ( pool->hdr_path )
          lp = (unsigned __int8 *)YES;
        else
          lp = (unsigned __int8 *)NO;
        if ( pool->last_share_time > 0 )
        {
          timediff = time(0) - pool->last_share_time;
          if ( timediff < 0 )
            timediff = 0;
          hour = timediff / 3600;
          minute = timediff % 3600 / 60;
          second = timediff % 3600 % 60;
          sprintf((char *)lasttime, "%d:%02d:%02d", timediff / 3600, minute, second);
        }
        else
        {
          strcpy((char *)lasttime, "0");
        }
        root = api_add_int(root, "POOL", &i, 0);
        root = api_add_escape(root, "URL", pool->rpc_url, 0);
        root = api_add_string(root, "Status", status, 0);
        root = api_add_int(root, "Priority", &pool->prio, 0);
        root = api_add_int(root, "Quota", &pool->quota, 0);
        root = api_add_string(root, "Long Poll", lp, 0);
        root = api_add_uint(root, "Getworks", &pool->getwork_requested, 0);
        root = api_add_int64(root, "Accepted", &pool->accepted, 0);
        root = api_add_int64(root, "Rejected", &pool->rejected, 0);
        root = api_add_uint(root, "Discarded", &pool->discarded_work, 0);
        root = api_add_uint(root, "Stale", &pool->stale_shares, 0);
        root = api_add_uint(root, "Get Failures", &pool->getfail_occasions, 0);
        root = api_add_uint(root, "Remote Failures", &pool->remotefail_occasions, 0);
        root = api_add_escape(root, "User", pool->rpc_user, 0);
        root = api_add_string(root, "Last Share Time", lasttime, 0);
        root = api_add_string(root, "Diff", pool->diff, 0);
        root = api_add_int64(root, "Diff1 Shares", &pool->diff1, 0);
        if ( pool->rpc_proxy )
        {
          v6 = proxytype(pool->rpc_proxytype);
          root = api_add_const(root, "Proxy Type", v6, 0);
          root = api_add_escape(root, "Proxy", pool->rpc_proxy, 0);
        }
        else
        {
          root = api_add_const(root, "Proxy Type", BLANK, 0);
          root = api_add_const(root, "Proxy", BLANK, 0);
        }
        root = api_add_diff(root, "Difficulty Accepted", &pool->diff_accepted, 0);
        root = api_add_diff(root, "Difficulty Rejected", &pool->diff_rejected, 0);
        root = api_add_diff(root, "Difficulty Stale", &pool->diff_stale, 0);
        root = api_add_diff(root, "Last Share Difficulty", &pool->last_share_diff, 0);
        root = api_add_bool(root, "Has Stratum", &pool->has_stratum, 0);
        root = api_add_bool(root, "Stratum Active", &pool->stratum_active, 0);
        if ( pool->stratum_active )
          root = api_add_escape(root, "Stratum URL", pool->stratum_url, 0);
        else
          root = api_add_const(root, "Stratum URL", BLANK, 0);
        root = api_add_bool(root, "Has GBT", &pool->has_gbt, 0);
        root = api_add_uint64(root, "Best Share", &pool->best_diff, 1);
        if ( pool->diff_accepted + pool->diff_rejected + pool->diff_stale == 0.0 )
          v7 = 0.0;
        else
          v7 = pool->diff_rejected / (pool->diff_accepted + pool->diff_rejected + pool->diff_stale);
        rejp = v7;
        root = api_add_percent(root, "Pool Rejected%", &rejp, 0);
        if ( pool->diff_accepted + pool->diff_rejected + pool->diff_stale == 0.0 )
          v8 = 0.0;
        else
          v8 = pool->diff_stale / (pool->diff_accepted + pool->diff_rejected + pool->diff_stale);
        stalep = v8;
        root = api_add_percent(root, "Pool Stale%", &stalep, 0);
        v9 = isjson && i > 0;
        root = print_data(io_data, root, isjson, v9);
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (000642C8) --------------------------------------------------------
void getAVGhashrate()
{
  ;
}

//----- (00064328) --------------------------------------------------------
void get_total_hashs()
{
  ;
}

//----- (00064346) --------------------------------------------------------
void get_total_secs()
{
  ;
}

//----- (00064364) --------------------------------------------------------
void __cdecl lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  double v5; // d0
  unsigned __int8 szuser[32]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 szpool[32]; // [sp+38h] [bp+30h] BYREF
  unsigned __int8 szindex[32]; // [sp+58h] [bp+50h] BYREF
  double ghs; // [sp+78h] [bp+70h] BYREF
  pool *pool; // [sp+84h] [bp+7Ch]
  bool io_open; // [sp+8Bh] [bp+83h]
  api_data *root; // [sp+8Ch] [bp+84h]

  root = 0;
  io_open = 0;
  memset(szindex, 0, sizeof(szindex));
  memset(szpool, 0, sizeof(szpool));
  memset(szuser, 0, sizeof(szuser));
  pool = current_pool();
  message(io_data, 7, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"POOLS\":[");
  getAVGhashrate();
  ghs = v5;
  strcpy((char *)szindex, "0");
  root = api_add_string(root, "LCD", szindex, 0);
  root = api_add_string(root, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHSavg", &ghs, 0);
  if ( pool )
  {
    root = api_add_string(root, "pool", pool->rpc_url, 0);
    root = api_add_string(root, "user", pool->rpc_user, 0);
  }
  else
  {
    strcpy((char *)szpool, "no");
    strcpy((char *)szuser, "no");
    root = api_add_string(root, "pool", szpool, 0);
    root = api_add_string(root, "user", szuser, 0);
  }
  root = print_data(io_data, root, isjson, isjson);
  if ( isjson && io_open )
    io_close(io_data);
}
// 643E0: variable 'v5' is possibly undefined

//----- (00064510) --------------------------------------------------------
void __cdecl summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  double v5; // d0
  char *v6; // r3
  double v7; // d7
  double v8; // d7
  api_data *v9; // r0
  double v10; // d7
  double v11; // d7
  double v12; // d7
  double v13; // d7
  double stalep; // [sp+18h] [bp+10h] BYREF
  double prejp; // [sp+20h] [bp+18h] BYREF
  double rejp; // [sp+28h] [bp+20h] BYREF
  double hwp; // [sp+30h] [bp+28h] BYREF
  int hw_errors_temp; // [sp+3Ch] [bp+34h] BYREF
  double work_utility; // [sp+40h] [bp+38h] BYREF
  double ghs; // [sp+48h] [bp+40h] BYREF
  double utility; // [sp+50h] [bp+48h] BYREF
  bool io_open; // [sp+5Bh] [bp+53h]
  api_data *root; // [sp+5Ch] [bp+54h]

  root = 0;
  hw_errors_temp = (int)get_hw_errors();
  message(io_data, 11, 0, 0, isjson);
  if ( isjson )
    v6 = ",\"SUMMARY\":[";
  else
    v6 = "SUMMARY,";
  io_open = io_add(io_data, (unsigned __int8 *)v6);
  mutex_lock_2(&hash_lock, "api-btm.c", _func___11829, 2789);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  if ( total_secs == 0.0 )
    v7 = 1.0;
  else
    v7 = total_secs;
  utility = (double)total_accepted / v7 * 60.0;
  getAVGhashrate();
  ghs = v5;
  if ( total_secs == 0.0 )
    v8 = 1.0;
  else
    v8 = total_secs;
  work_utility = (double)total_diff1 / v8 * 60.0;
  v9 = api_add_elapsed(root, "Elapsed", &total_secs, 1);
  root = api_add_string(v9, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHS av", &ghs, 0);
  root = api_add_uint(root, "Found Blocks", &found_blocks, 1);
  root = api_add_int64(root, "Getworks", &total_getworks, 1);
  root = api_add_int64(root, "Accepted", &total_accepted, 1);
  root = api_add_int64(root, "Rejected", &total_rejected, 1);
  root = api_add_int(root, "Hardware Errors", &hw_errors_temp, 1);
  root = api_add_utility(root, "Utility", &utility, 0);
  root = api_add_int64(root, "Discarded", &total_discarded, 1);
  root = api_add_int64(root, "Stale", &total_stale, 1);
  root = api_add_uint(root, "Get Failures", &total_go, 1);
  root = api_add_uint(root, "Local Work", &local_work, 1);
  root = api_add_uint(root, "Remote Failures", &total_ro, 1);
  root = api_add_uint(root, "Network Blocks", &new_blocks, 1);
  root = api_add_mhtotal(root, "Total MH", &total_mhashes_done, 1);
  root = api_add_utility(root, "Work Utility", &work_utility, 0);
  root = api_add_diff(root, "Difficulty Accepted", &total_diff_accepted, 1);
  root = api_add_diff(root, "Difficulty Rejected", &total_diff_rejected, 1);
  root = api_add_diff(root, "Difficulty Stale", &total_diff_stale, 1);
  root = api_add_uint64(root, "Best Share", &best_diff, 1);
  if ( hw_errors_temp + total_diff1 )
    v10 = (double)hw_errors_temp / (double)(hw_errors_temp + total_diff1);
  else
    v10 = 0.0;
  hwp = v10;
  root = api_add_percent(root, "Device Hardware%", &hwp, 0);
  if ( total_diff1 )
    v11 = total_diff_rejected / (double)total_diff1;
  else
    v11 = 0.0;
  rejp = v11;
  root = api_add_percent(root, "Device Rejected%", &rejp, 0);
  if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
    v12 = 0.0;
  else
    v12 = total_diff_rejected / (total_diff_accepted + total_diff_rejected + total_diff_stale);
  prejp = v12;
  root = api_add_percent(root, "Pool Rejected%", &prejp, 0);
  if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
    v13 = 0.0;
  else
    v13 = total_diff_stale / (total_diff_accepted + total_diff_rejected + total_diff_stale);
  stalep = v13;
  root = api_add_percent(root, "Pool Stale%", &stalep, 0);
  root = api_add_time(root, "Last getwork", &last_getwork, 0);
  mutex_unlock_2(&hash_lock, "api-btm.c", _func___11829, 2834);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}
// 64622: variable 'v5' is possibly undefined

//----- (00064AF4) --------------------------------------------------------
void __cdecl noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  bool io_open; // [sp+1Bh] [bp+13h]

  message(io_data, 16, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"NONCENUM\":[";
  else
    v5 = "NONCENUM,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_string(0, "10min nonce", nonce_num10_string, 0);
  v7 = api_add_string(v6, "30min nonce", nonce_num30_string, 0);
  v8 = api_add_string(v7, "60min nonce", nonce_num60_string, 0);
  print_data(io_data, v8, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00064BB0) --------------------------------------------------------
void __cdecl pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int count; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  count = 0;
  message(io_data, 59, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"PGAS\":[";
  else
    v5 = "PGAS,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "Count", &count, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00064C38) --------------------------------------------------------
void __cdecl switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool *pool; // [sp+18h] [bp+10h]
  int id; // [sp+1Ch] [bp+14h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      cg_rlock_1(&control_lock, "api-btm.c", _func___11862, 2897);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        pool->enabled = POOL_ENABLED;
        cg_runlock_1(&control_lock, "api-btm.c", _func___11862, 2907);
        switch_pools(pool);
        message(io_data, 27, id, 0, isjson);
      }
      else
      {
        cg_runlock_1(&control_lock, "api-btm.c", _func___11862, 2900);
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (00064D4C) --------------------------------------------------------
void __cdecl copyadvanceafter(unsigned __int8 ch, unsigned __int8 **param, unsigned __int8 **buf)
{
  unsigned __int8 *v3; // r2
  unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r3

  while ( **param && ch != **param )
  {
    if ( **param == 92 && (*param)[1] )
      ++*param;
    v3 = (*param)++;
    v4 = (*buf)++;
    *v4 = *v3;
  }
  if ( **param )
    ++*param;
  v5 = (*buf)++;
  *v5 = 0;
}

//----- (00064DD8) --------------------------------------------------------
bool __cdecl pooldetails(unsigned __int8 *param, unsigned __int8 **url, unsigned __int8 **user, unsigned __int8 **pass)
{
  size_t v4; // r0
  unsigned __int8 *parama; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 *buf; // [sp+10h] [bp+10h] BYREF
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]

  parama = param;
  v4 = strlen((const char *)param);
  buf = (unsigned __int8 *)cgmalloc(v4 + 1, "api-btm.c", _func___11879, 2935);
  ptr = buf;
  *url = buf;
  copyadvanceafter(0x2Cu, &parama, &buf);
  if ( *parama && (*user = buf, copyadvanceafter(0x2Cu, &parama, &buf), *parama) )
  {
    *pass = buf;
    copyadvanceafter(0x2Cu, &parama, &buf);
    return 1;
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (00064E7E) --------------------------------------------------------
void __cdecl addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *pass; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 *user; // [sp+20h] [bp+18h] BYREF
  unsigned __int8 *url; // [sp+24h] [bp+1Ch] BYREF
  unsigned __int8 *ptr; // [sp+28h] [bp+20h]
  pool *pool; // [sp+2Ch] [bp+24h]

  if ( param && *param )
  {
    if ( !pooldetails(param, &url, &user, &pass) )
    {
      ptr = escape_string(param, isjson);
      message(io_data, 53, 0, ptr, isjson);
      if ( ptr != param )
        free(ptr);
      ptr = 0;
    }
    else
    {
      pool = add_pool();
      detect_stratum(pool, url);
      add_pool_details(pool, 1, url, user, pass);
      ptr = escape_string(url, isjson);
      message(io_data, 55, pool->pool_no, ptr, isjson);
      if ( ptr != url )
        free(ptr);
    }
  }
  else
  {
    message(io_data, 52, 0, 0, isjson);
  }
}

//----- (00064F54) --------------------------------------------------------
void __cdecl enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int prio; // r4
  pool *pool; // [sp+18h] [bp+10h]
  int id; // [sp+1Ch] [bp+14h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        if ( pool->enabled == POOL_ENABLED )
        {
          message(io_data, 49, id, 0, isjson);
        }
        else
        {
          pool->enabled = POOL_ENABLED;
          prio = pool->prio;
          if ( prio < current_pool()->prio )
            switch_pools(pool);
          message(io_data, 47, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (00065032) --------------------------------------------------------
void __cdecl poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  int v6; // r3
  int v7; // r2
  char v8[3]; // [sp+8h] [bp+0h] BYREF
  bool isjsona; // [sp+Bh] [bp+3h]
  unsigned __int8 *parama; // [sp+Ch] [bp+4h]
  int ca; // [sp+10h] [bp+8h]
  io_data *io_dataa; // [sp+14h] [bp+Ch]
  unsigned __int8 *ptr; // [sp+1Ch] [bp+14h]
  int (*p_new_prio)[]; // [sp+20h] [bp+18h]
  int v15; // [sp+24h] [bp+1Ch]
  bool (*p_pools_changed)[]; // [sp+28h] [bp+20h]
  int v17; // [sp+2Ch] [bp+24h]
  unsigned __int8 *next; // [sp+30h] [bp+28h]
  int i; // [sp+34h] [bp+2Ch]
  int pr; // [sp+38h] [bp+30h]
  int prio; // [sp+3Ch] [bp+34h]

  io_dataa = io_data;
  ca = c;
  parama = param;
  isjsona = isjson;
  prio = 0;
  if ( total_pools )
  {
    if ( parama && *parama )
    {
      v17 = total_pools - 1;
      p_pools_changed = (bool (*)[])v8;
      v15 = total_pools - 1;
      p_new_prio = (int (*)[])v8;
      for ( i = 0; i < total_pools; ++i )
        *((_BYTE *)p_pools_changed + i) = 0;
      next = parama;
      while ( next && *next )
      {
        ptr = next;
        next = (unsigned __int8 *)strchr((const char *)next, 44);
        if ( next )
        {
          v5 = next++;
          *v5 = 0;
        }
        i = atoi((const char *)ptr);
        if ( i < 0 || i >= total_pools )
        {
          message(io_dataa, 26, i, 0, isjsona);
          return;
        }
        if ( *((_BYTE *)p_pools_changed + i) )
        {
          message(io_dataa, 74, i, 0, isjsona);
          return;
        }
        *((_BYTE *)p_pools_changed + i) = 1;
        v6 = prio++;
        *((_DWORD *)p_new_prio + i) = v6;
      }
      for ( i = 0; i < total_pools; ++i )
      {
        if ( *((_BYTE *)p_pools_changed + i) )
          pools[i]->prio = *((_DWORD *)p_new_prio + i);
      }
      for ( pr = 0; pr < total_pools; ++pr )
      {
        for ( i = 0; i < total_pools; ++i )
        {
          if ( *((_BYTE *)p_pools_changed + i) != 1 && pr == pools[i]->prio )
          {
            v7 = prio++;
            pools[i]->prio = v7;
            *((_BYTE *)p_pools_changed + i) = 1;
            break;
          }
        }
      }
      if ( current_pool()->prio )
        switch_pools(0);
      message(io_dataa, 73, 0, 0, isjsona);
    }
    else
    {
      message(io_dataa, 25, 0, 0, isjsona);
    }
  }
  else
  {
    message(io_dataa, 8, 0, 0, isjsona);
  }
}

//----- (000652EA) --------------------------------------------------------
void __cdecl poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  int quota; // [sp+18h] [bp+10h]
  pool *pool; // [sp+1Ch] [bp+14h]
  int id; // [sp+20h] [bp+18h]
  unsigned __int8 *comma; // [sp+24h] [bp+1Ch]
  unsigned __int8 *commaa; // [sp+24h] [bp+1Ch]

  if ( total_pools )
  {
    if ( param && *param )
    {
      comma = (unsigned __int8 *)strchr((const char *)param, 44);
      if ( comma )
      {
        v5 = comma;
        commaa = comma + 1;
        *v5 = 0;
        id = atoi((const char *)param);
        if ( id >= 0 && id < total_pools )
        {
          pool = pools[id];
          quota = atoi((const char *)commaa);
          if ( quota >= 0 )
          {
            pool->quota = quota;
            adjust_quota_gcd();
            message(io_data, 122, quota, pool->rpc_url, isjson);
          }
          else
          {
            message(io_data, 121, quota, pool->rpc_url, isjson);
          }
        }
        else
        {
          message(io_data, 26, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 86, 0, param, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (000653F4) --------------------------------------------------------
void __cdecl disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool *pool; // [sp+18h] [bp+10h]
  int id; // [sp+1Ch] [bp+14h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        if ( pool->enabled )
        {
          if ( enabled_pools > 1 )
          {
            pool->enabled = POOL_DISABLED;
            if ( pool == current_pool() )
              switch_pools(0);
            message(io_data, 48, id, 0, isjson);
          }
          else
          {
            message(io_data, 51, id, 0, isjson);
          }
        }
        else
        {
          message(io_data, 50, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (000654EE) --------------------------------------------------------
void __cdecl removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *rpc_url; // [sp+18h] [bp+10h]
  pool *pool; // [sp+1Ch] [bp+14h]
  int id; // [sp+20h] [bp+18h]
  bool dofree; // [sp+27h] [bp+1Fh]

  dofree = 0;
  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        if ( total_pools > 1 )
        {
          pool = pools[id];
          if ( pool == current_pool() )
            switch_pools(0);
          if ( pool == current_pool() )
          {
            message(io_data, 67, id, 0, isjson);
          }
          else
          {
            pool->enabled = POOL_DISABLED;
            rpc_url = escape_string(pool->rpc_url, isjson);
            if ( rpc_url != pool->rpc_url )
              dofree = 1;
            remove_pool(pool);
            message(io_data, 68, id, rpc_url, isjson);
            if ( dofree )
              free(rpc_url);
          }
        }
        else
        {
          message(io_data, 66, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (00065628) --------------------------------------------------------
void __cdecl doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"BYE\"");
  else
    io_put(io_data, "BYE");
  bye = 1;
  do_a_quit = 1;
}

//----- (0006567A) --------------------------------------------------------
void __cdecl dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"RESTART\"");
  else
    io_put(io_data, "RESTART");
  bye = 1;
  do_a_restart = 1;
}

//----- (000656CC) --------------------------------------------------------
void __cdecl privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 46, 0, 0, isjson);
}

//----- (000656F4) --------------------------------------------------------
void __cdecl notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int devicea; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  api_data *root; // [sp+10h] [bp+10h]
  unsigned __int8 *reason; // [sp+14h] [bp+14h]

  io_dataa = io_data;
  devicea = device;
  root = 0;
  if ( cgpu->device_last_not_well )
  {
    switch ( cgpu->device_not_well_reason )
    {
      case REASON_THREAD_FAIL_INIT:
        reason = "Thread failed to init";
        break;
      case REASON_THREAD_ZERO_HASH:
        reason = "Thread got zero hashes";
        break;
      case REASON_THREAD_FAIL_QUEUE:
        reason = "Thread failed to queue work";
        break;
      case REASON_DEV_SICK_IDLE_60:
        reason = "Device idle for 60s";
        break;
      case REASON_DEV_DEAD_IDLE_600:
        reason = "Device dead - idle for 600s";
        break;
      case REASON_DEV_NOSTART:
        reason = "Device failed to start";
        break;
      case REASON_DEV_OVER_HEAT:
        reason = "Device over heated";
        break;
      case REASON_DEV_THERMAL_CUTOFF:
        reason = "Device reached thermal cutoff";
        break;
      case REASON_DEV_COMMS_ERROR:
        reason = "Device comms error";
        break;
      default:
        reason = "Unknown reason - code bug";
        break;
    }
  }
  else
  {
    reason = "None";
  }
  root = api_add_int(root, "NOTIFY", &devicea, 0);
  root = api_add_string(root, "Name", cgpu->drv->name, 0);
  root = api_add_int(root, "ID", &cgpu->device_id, 0);
  root = api_add_time(root, "Last Well", &cgpu->device_last_well, 0);
  root = api_add_time(root, "Last Not Well", &cgpu->device_last_not_well, 0);
  root = api_add_string(root, "Reason Not Well", reason, 0);
  root = api_add_int(root, "*Thread Fail Init", &cgpu->thread_fail_init_count, 0);
  root = api_add_int(root, "*Thread Zero Hash", &cgpu->thread_zero_hash_count, 0);
  root = api_add_int(root, "*Thread Fail Queue", &cgpu->thread_fail_queue_count, 0);
  root = api_add_int(root, "*Dev Sick Idle 60s", &cgpu->dev_sick_idle_60_count, 0);
  root = api_add_int(root, "*Dev Dead Idle 600s", &cgpu->dev_dead_idle_600_count, 0);
  root = api_add_int(root, "*Dev Nostart", &cgpu->dev_nostart_count, 0);
  root = api_add_int(root, "*Dev Over Heat", &cgpu->dev_over_heat_count, 0);
  root = api_add_int(root, "*Dev Thermal Cutoff", &cgpu->dev_thermal_cutoff_count, 0);
  root = api_add_int(root, "*Dev Comms Error", &cgpu->dev_comms_error_count, 0);
  root = api_add_int(root, "*Dev Throttle", &cgpu->dev_throttle_count, 0);
  v5 = isjson && devicea > 0;
  print_data(io_dataa, root, isjson, v5);
}

//----- (00065970) --------------------------------------------------------
void __cdecl notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  cgpu_info *cgpu; // [sp+1Ch] [bp+14h]
  int i; // [sp+20h] [bp+18h]
  bool io_open; // [sp+27h] [bp+1Fh]

  io_open = 0;
  if ( total_devices )
  {
    message(io_data, 60, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"NOTIFY\":[");
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = get_devices(i);
      notifystatus(io_data, i, cgpu, isjson, group);
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}

//----- (00065A1A) --------------------------------------------------------
void __cdecl devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  const unsigned __int8 *kname; // r2
  unsigned __int8 *name; // r2
  unsigned __int8 *device_path; // r2
  bool v8; // r3
  int i; // [sp+18h] [bp+10h] BYREF
  cgpu_info *cgpu; // [sp+1Ch] [bp+14h]
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  io_open = 0;
  if ( total_devices )
  {
    message(io_data, 69, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVDETAILS\":[");
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = get_devices(i);
      root = api_add_int(root, "DEVDETAILS", &i, 0);
      root = api_add_string(root, "Name", cgpu->drv->name, 0);
      root = api_add_int(root, "ID", &cgpu->device_id, 0);
      root = api_add_string(root, "Driver", cgpu->drv->dname, 0);
      kname = cgpu->kname;
      if ( !kname )
        kname = BLANK;
      root = api_add_const(root, "Kernel", kname, 0);
      if ( cgpu->name )
        name = cgpu->name;
      else
        name = (unsigned __int8 *)BLANK;
      root = api_add_const(root, "Model", name, 0);
      if ( cgpu->device_path )
        device_path = cgpu->device_path;
      else
        device_path = (unsigned __int8 *)BLANK;
      root = api_add_const(root, "Device Path", device_path, 0);
      v8 = isjson && i > 0;
      root = print_data(io_data, root, isjson, v8);
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}

//----- (00065BB0) --------------------------------------------------------
void __cdecl dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *parama; // [sp+Ch] [bp+4h]
  unsigned __int8 filename[4096]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 *ptr; // [sp+1018h] [bp+1010h]
  FILE *fcfg; // [sp+101Ch] [bp+1014h]

  parama = param;
  if ( !param || !*param )
  {
    default_save_file(filename);
    parama = filename;
  }
  fcfg = fopen((const char *)parama, "w");
  if ( fcfg )
  {
    write_config(fcfg);
    fclose(fcfg);
    ptr = escape_string(parama, isjson);
    message(io_data, 44, 0, ptr, isjson);
    if ( ptr != parama )
      free(ptr);
  }
  else
  {
    ptr = escape_string(parama, isjson);
    message(io_data, 43, 0, ptr, isjson);
    if ( ptr != parama )
      free(ptr);
    ptr = 0;
  }
}

//----- (00065D4C) --------------------------------------------------------
int __cdecl itemstats(
        io_data *io_data,
        int i,
        unsigned __int8 *id,
        cgminer_stats *stats,
        cgminer_pool_stats *pool_stats,
        api_data *extra,
        cgpu_info *cgpu,
        bool isjson)
{
  double v8; // d0
  int ia; // [sp+8h] [bp+8h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp+Ch]
  double ghs; // [sp+10h] [bp+10h] BYREF
  api_data *root; // [sp+1Ch] [bp+1Ch]

  io_dataa = io_data;
  ia = i;
  root = 0;
  getAVGhashrate();
  ghs = v8;
  root = api_add_int(0, "STATS", &ia, 0);
  root = api_add_string(root, "ID", id, 0);
  root = api_add_elapsed(root, "Elapsed", &total_secs, 0);
  root = api_add_uint32(root, "Calls", &stats->getwork_calls, 0);
  root = api_add_timeval(root, "Wait", &stats->getwork_wait, 0);
  root = api_add_timeval(root, "Max", &stats->getwork_wait_max, 0);
  root = api_add_timeval(root, "Min", &stats->getwork_wait_min, 0);
  if ( !displayed_hash_rate[0] )
    sprintf((char *)displayed_hash_rate, "%.2f", 0.0);
  root = api_add_string(root, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHS av", &ghs, 0);
  root = api_add_string(root, "Voltage", displayed_working_voltage, 0);
  root = api_add_string(root, "Mode", displayed_mode, 0);
  if ( extra )
    root = api_add_extra(root, extra);
  print_data(io_dataa, root, isjson, 1);
  return ia + 1;
}
// 65D66: variable 'v8' is possibly undefined

//----- (00065EC6) --------------------------------------------------------
void __cdecl minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  api_data *v5; // r0
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  unsigned __int8 id[20]; // [sp+24h] [bp+14h] BYREF
  cgpu_info *cgpu; // [sp+38h] [bp+28h]
  api_data *root; // [sp+3Ch] [bp+2Ch]
  int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]
  api_data *extra; // [sp+48h] [bp+38h]
  bool io_open; // [sp+4Fh] [bp+3Fh]

  root = 0;
  io_open = 0;
  message(io_data, 70, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"STATS\":[");
  v5 = api_add_string(root, "BMMiner", "2.0.0", 0);
  v6 = api_add_string(v5, "Miner", g_miner_version, 0);
  v7 = api_add_string(v6, "CompileTime", g_miner_compiletime, 0);
  v8 = api_add_string(v7, "Type", g_miner_type, 0);
  root = print_data(io_data, v8, isjson, 0);
  i = 0;
  for ( j = 0; j < total_devices; ++j )
  {
    cgpu = get_devices(j);
    if ( cgpu && cgpu->drv )
    {
      if ( cgpu->drv->get_api_stats )
        extra = cgpu->drv->get_api_stats(cgpu);
      else
        extra = 0;
      sprintf((char *)id, "%s%d", (const char *)cgpu->drv->name, cgpu->device_id);
      i = itemstats(io_data, i, id, &cgpu->cgminer_stats, 0, extra, cgpu, isjson);
    }
  }
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0006602C) --------------------------------------------------------
void __cdecl minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 id[20]; // [sp+20h] [bp+10h] BYREF
  cgpu_info *cgpu; // [sp+34h] [bp+24h]
  int j; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]
  api_data *extra; // [sp+40h] [bp+30h]
  bool io_open; // [sp+47h] [bp+37h]

  io_open = 0;
  message(io_data, 70, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"STATS\":[");
  i = 0;
  for ( j = 0; j < total_devices; ++j )
  {
    cgpu = get_devices(j);
    if ( cgpu && cgpu->drv )
    {
      if ( cgpu->drv->get_api_stats )
        extra = cgpu->drv->get_api_stats(cgpu);
      else
        extra = 0;
      sprintf((char *)id, "%s%d", (const char *)cgpu->drv->name, cgpu->device_id);
      i = itemstats(io_data, i, id, &cgpu->cgminer_stats, 0, extra, cgpu, isjson);
    }
  }
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0006611C) --------------------------------------------------------
void __cdecl failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 126, 0, param, isjson);
}

//----- (00066142) --------------------------------------------------------
void __cdecl minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  bool io_open; // [sp+1Bh] [bp+13h]
  api_data *root; // [sp+1Ch] [bp+14h]
  api_data *roota; // [sp+1Ch] [bp+14h]

  message(io_data, 78, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"COIN\":[";
  else
    v5 = "COIN,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_const(0, "Hash Method", SHA256STR, 0);
  cg_rlock_1(&ch_lock, "api-btm.c", _func___12102_0, 3677);
  v6 = api_add_timeval(root, "Current Block Time", &block_timeval, 1);
  roota = api_add_string(v6, "Current Block Hash", current_hash, 1);
  cg_runlock_1(&ch_lock, "api-btm.c", _func___12102_0, 3680);
  v7 = api_add_bool(roota, "LP", &have_longpoll, 0);
  v8 = api_add_diff(v7, "Network Difficulty", &current_diff, 1);
  print_data(io_data, v8, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00066274) --------------------------------------------------------
void __cdecl debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  const unsigned __int8 *parama; // [sp+Ch] [bp+4h]
  bool io_open; // [sp+1Bh] [bp+13h]

  parama = param;
  if ( param )
    *param = tolower(*param);
  else
    parama = BLANK;
  switch ( *parama )
  {
    case 'd':
      opt_debug = !opt_debug;
      opt_log_output = opt_debug;
      if ( opt_debug )
        opt_quiet = 0;
      break;
    case 'n':
      opt_log_output = 0;
      opt_debug = 0;
      opt_quiet = 0;
      opt_protocol = 0;
      want_per_device_stats = 0;
      opt_worktime = 0;
      break;
    case 'p':
      want_per_device_stats = !want_per_device_stats;
      opt_log_output = want_per_device_stats;
      break;
    case 'q':
      opt_quiet = !opt_quiet;
      break;
    case 'r':
      opt_protocol = !opt_protocol;
      if ( opt_protocol )
        opt_quiet = 0;
      break;
    case 's':
      opt_realquiet = 1;
      break;
    case 'v':
      opt_log_output = !opt_log_output;
      if ( opt_log_output )
        opt_quiet = 0;
      break;
    case 'w':
      opt_worktime = !opt_worktime;
      break;
    default:
      break;
  }
  message(io_data, 79, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"DEBUG\":[";
  else
    v5 = "DEBUG,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_bool(0, "Silent", &opt_realquiet, 0);
  v7 = api_add_bool(v6, "Quiet", &opt_quiet, 0);
  v8 = api_add_bool(v7, "Verbose", &opt_log_output, 0);
  v9 = api_add_bool(v8, "Debug", &opt_debug, 0);
  v10 = api_add_bool(v9, "RPCProto", &opt_protocol, 0);
  v11 = api_add_bool(v10, "PerDevice", &want_per_device_stats, 0);
  v12 = api_add_bool(v11, "WorkTime", &opt_worktime, 0);
  print_data(io_data, v12, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (000665E4) --------------------------------------------------------
void __cdecl setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( !strcasecmp((const char *)param, "queue")
    || !strcasecmp((const char *)param, "scantime")
    || !strcasecmp((const char *)param, "expiry") )
  {
    message(io_data, 126, 0, param, isjson);
  }
  message(io_data, 83, 0, param, isjson);
}

//----- (00066656) --------------------------------------------------------
void __cdecl usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 88, 0, 0, isjson);
}

//----- (00066686) --------------------------------------------------------
void __cdecl dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  char *v6; // r3
  char *v7; // r3
  bool dosum; // [sp+19h] [bp+11h]
  bool bs; // [sp+1Ah] [bp+12h]
  bool all; // [sp+1Bh] [bp+13h]
  unsigned __int8 *sum; // [sp+1Ch] [bp+14h]

  if ( param && *param )
  {
    sum = (unsigned __int8 *)strchr((const char *)param, 44);
    if ( sum )
    {
      v5 = sum++;
      *v5 = 0;
    }
    if ( sum && *sum )
    {
      all = 0;
      bs = 0;
      if ( !strcasecmp((const char *)param, "all") )
      {
        all = 1;
      }
      else if ( !strcasecmp((const char *)param, "bestshare") )
      {
        bs = 1;
      }
      if ( !all && !bs )
      {
        message(io_data, 95, 0, param, isjson);
      }
      else
      {
        *sum = tolower(*sum);
        if ( *sum == 116 || *sum == 102 )
        {
          dosum = *sum == 116;
          if ( *sum == 116 )
            print_summary();
          if ( all )
            zero_stats();
          if ( bs )
            zero_bestshare();
          if ( dosum )
          {
            if ( all )
              v6 = "All";
            else
              v6 = "BestShare";
            message(io_data, 96, 0, (unsigned __int8 *)v6, isjson);
          }
          else
          {
            if ( all )
              v7 = "All";
            else
              v7 = "BestShare";
            message(io_data, 97, 0, (unsigned __int8 *)v7, isjson);
          }
        }
        else
        {
          message(io_data, 76, 0, 0, isjson);
        }
      }
    }
    else
    {
      message(io_data, 75, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 94, 0, 0, isjson);
  }
}

//----- (0006680C) --------------------------------------------------------
void __cdecl dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 102, 0, 0, isjson);
}

//----- (00066832) --------------------------------------------------------
void __cdecl ascdev(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int id; // [sp+1Ch] [bp+14h]
  int numasc; // [sp+20h] [bp+18h]
  bool io_open; // [sp+27h] [bp+1Fh]

  io_open = 0;
  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc )
      {
        message(io_data, 106, id, 0, isjson);
        if ( isjson )
          io_open = io_add(io_data, ",\"ASC\":[");
        ascstatus(io_data, id, isjson, 0);
        if ( isjson && io_open )
          io_close(io_data);
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (000668F6) --------------------------------------------------------
void __cdecl ascenable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  int asc; // [sp+824h] [bp+814h]
  thr_info *thr; // [sp+828h] [bp+818h]
  cgpu_info *cgpu; // [sp+82Ch] [bp+81Ch]
  int dev; // [sp+830h] [bp+820h]
  int id; // [sp+834h] [bp+824h]
  int numasc; // [sp+838h] [bp+828h]
  int i; // [sp+83Ch] [bp+82Ch]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: request to ascenable ascid %d device %d %s%u",
            id,
            dev,
            (const char *)cgpu->drv->name,
            cgpu->device_id);
          applog(7, tmp42, 0);
        }
        if ( cgpu->deven == DEV_DISABLED )
        {
          for ( i = 0; i < mining_threads; ++i )
          {
            thr = get_thread(i);
            asc = thr->cgpu->cgminer_id;
            if ( asc == dev )
            {
              cgpu->deven = DEV_ENABLED;
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "API: Pushing sem post to thread %d", thr->id);
                applog(7, tmp42, 0);
              }
              cgsem_post(&thr->sem, "api-btm.c", _func___12181, 4075);
            }
          }
          message(io_data, 110, id, 0, isjson);
        }
        else
        {
          message(io_data, 108, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (00066B64) --------------------------------------------------------
void __cdecl ascdisable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF
  cgpu_info *cgpu; // [sp+820h] [bp+810h]
  int dev; // [sp+824h] [bp+814h]
  int id; // [sp+828h] [bp+818h]
  int numasc; // [sp+82Ch] [bp+81Ch]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: request to ascdisable ascid %d device %d %s%u",
            id,
            dev,
            (const char *)cgpu->drv->name,
            cgpu->device_id);
          applog(7, tmp42, 0);
        }
        if ( cgpu->deven == DEV_DISABLED )
        {
          message(io_data, 109, id, 0, isjson);
        }
        else
        {
          cgpu->deven = DEV_DISABLED;
          message(io_data, 111, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (00066D0A) --------------------------------------------------------
void __cdecl ascidentify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  device_drv *drv; // [sp+1Ch] [bp+14h]
  cgpu_info *cgpu; // [sp+20h] [bp+18h]
  int dev; // [sp+24h] [bp+1Ch]
  int id; // [sp+28h] [bp+20h]
  int numasc; // [sp+2Ch] [bp+24h]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        drv = cgpu->drv;
        if ( drv->identify_device )
        {
          drv->identify_device(cgpu);
          message(io_data, 113, id, 0, isjson);
        }
        else
        {
          message(io_data, 114, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (00066DE4) --------------------------------------------------------
void __cdecl asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int count; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+23h] [bp+1Bh]
  api_data *root; // [sp+24h] [bp+1Ch]

  root = 0;
  count = numascs();
  message(io_data, 104, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"ASCS\":[";
  else
    v5 = "ASCS,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "Count", &count, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00066E74) --------------------------------------------------------
void __cdecl ascset(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  unsigned __int8 *v6; // r3
  unsigned __int8 buf[8192]; // [sp+18h] [bp+10h] BYREF
  unsigned __int8 *ret; // [sp+2018h] [bp+2010h]
  device_drv *drv; // [sp+201Ch] [bp+2014h]
  cgpu_info *cgpu; // [sp+2020h] [bp+2018h]
  int dev; // [sp+2024h] [bp+201Ch]
  int id; // [sp+2028h] [bp+2020h]
  int numasc; // [sp+202Ch] [bp+2024h]
  unsigned __int8 *set; // [sp+2030h] [bp+2028h]
  unsigned __int8 *opt; // [sp+2034h] [bp+202Ch]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      opt = (unsigned __int8 *)strchr((const char *)param, 44);
      if ( opt )
      {
        v5 = opt++;
        *v5 = 0;
      }
      if ( opt && *opt )
      {
        id = atoi((const char *)param);
        if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
        {
          cgpu = get_devices(dev);
          drv = cgpu->drv;
          set = (unsigned __int8 *)strchr((const char *)opt, 44);
          if ( set )
          {
            v6 = set++;
            *v6 = 0;
          }
          if ( drv->set_device )
          {
            ret = drv->set_device(cgpu, opt, set, buf);
            if ( ret )
            {
              if ( !strcasecmp((const char *)opt, "help") )
                message(io_data, 118, id, ret, isjson);
              else
                message(io_data, 120, id, ret, isjson);
            }
            else
            {
              message(io_data, 119, id, 0, isjson);
            }
          }
          else
          {
            message(io_data, 117, id, 0, isjson);
          }
        }
        else
        {
          message(io_data, 107, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 116, 0, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (000671D2) --------------------------------------------------------
void __cdecl checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int v5; // r4
  int v6; // r4
  int v7; // r0
  char *v8; // r3
  const unsigned __int8 *v9; // r2
  const unsigned __int8 *v10; // r2
  unsigned __int8 cmdbuf[100]; // [sp+1Ch] [bp+14h] BYREF
  bool io_open; // [sp+83h] [bp+7Bh]
  api_data *root; // [sp+84h] [bp+7Ch]
  int i; // [sp+88h] [bp+80h]
  bool access; // [sp+8Eh] [bp+86h]
  bool found; // [sp+8Fh] [bp+87h]

  root = 0;
  if ( param && *param )
  {
    found = 0;
    access = 0;
    for ( i = 0; cmds[i].name; ++i )
    {
      if ( !strcmp((const char *)cmds[i].name, (const char *)param) )
      {
        found = 1;
        sprintf((char *)cmdbuf, "|%s|", (const char *)param);
        v5 = toupper(group);
        if ( v5 == toupper(87)
          || (v6 = toupper(group),
              v7 = toupper(65),
              strstr((const char *)apigroups[v6 - v7].commands, (const char *)cmdbuf)) )
        {
          access = 1;
        }
        break;
      }
    }
    message(io_data, 72, 0, 0, isjson);
    if ( isjson )
      v8 = ",\"CHECK\":[";
    else
      v8 = "CHECK,";
    io_open = io_add(io_data, (unsigned __int8 *)v8);
    if ( found )
      v9 = YES;
    else
      v9 = NO;
    root = api_add_const(root, "Exists", v9, 0);
    if ( access )
      v10 = YES;
    else
      v10 = NO;
    root = api_add_const(root, "Access", v10, 0);
    root = print_data(io_data, root, isjson, 0);
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 71, 0, 0, isjson);
  }
}

//----- (00067394) --------------------------------------------------------
void __cdecl head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin)
{
  unsigned __int8 *ptr; // [sp+14h] [bp+14h]

  if ( *firstjoin )
  {
    if ( isjson )
      io_add(io_data, "{");
    *firstjoin = 0;
  }
  else if ( isjson )
  {
    io_add(io_data, ",");
  }
  ptr = escape_string(cmdptr, isjson);
  if ( isjson )
  {
    io_add(io_data, "\"");
    io_add(io_data, ptr);
    io_add(io_data, "\":[");
  }
  else
  {
    io_add(io_data, "CMD=");
    io_add(io_data, ptr);
    io_add(io_data, "|");
  }
  if ( ptr != cmdptr )
    free(ptr);
}

//----- (0006744E) --------------------------------------------------------
void __cdecl tail_join(io_data *io_data, bool isjson)
{
  if ( io_data->close )
  {
    io_add(io_data, "]");
    io_data->close = 0;
  }
  if ( isjson )
  {
    io_add(io_data, ",\"id\":1}");
    io_add(io_data, "]");
  }
}

//----- (000674A0) --------------------------------------------------------
void __cdecl send_result(io_data *io_data, int c, bool isjson)
{
  const char *v3; // r3
  int v4; // r3
  int v5; // r5
  int v6; // r4
  int *v7; // r0
  char *v8; // r0
  fd_set wd; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+9Ch] [bp+94h] BYREF
  timeval timeout; // [sp+89Ch] [bp+894h] BYREF
  int n; // [sp+8A4h] [bp+89Ch]
  int res; // [sp+8A8h] [bp+8A0h]
  fd_set *__arr; // [sp+8ACh] [bp+8A4h]
  int len; // [sp+8B0h] [bp+8A8h]
  unsigned int __i; // [sp+8B4h] [bp+8ACh]
  unsigned __int8 *buf; // [sp+8B8h] [bp+8B0h]
  int tosend; // [sp+8BCh] [bp+8B4h]
  int sendc; // [sp+8C0h] [bp+8B8h]
  int count; // [sp+8C4h] [bp+8BCh]

  buf = io_data->ptr;
  strcpy((char *)buf, (const char *)io_data->ptr);
  if ( io_data->close )
    strcat((char *)buf, "]");
  if ( isjson )
    strcat((char *)buf, ",\"id\":1}");
  len = strlen((const char *)buf);
  tosend = len + 1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( len > 10 )
      v3 = "...";
    else
      v3 = (const char *)BLANK;
    snprintf((char *)tmp42, 0x800u, "API: send reply: (%d) '%.10s%s'", tosend, (const char *)buf, v3);
    applog(7, tmp42, 0);
  }
  sendc = 0;
  count = 0;
  while ( count <= 4 && tosend > 0 )
  {
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    __arr = &wd;
    for ( __i = 0; __i <= 0x1F; ++__i )
      __arr->fds_bits[__i] = 0;
    LOBYTE(v4) = c & 0x1F;
    if ( c <= 0 )
      v4 = -(-c & 0x1F);
    wd.fds_bits[c / 32] |= 1 << v4;
    res = select(c + 1, 0, &wd, 0, &timeout);
    if ( res <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API: send select failed (%d)", res);
        applog(4, tmp42, 0);
      }
      return;
    }
    n = send(c, buf, tosend, 0);
    ++sendc;
    if ( n >= 0 )
    {
      if ( sendc > 1 )
      {
        if ( n == tosend )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "API: sent all of remaining %d (sendc=%d)", tosend, sendc);
            applog(7, tmp42, 0);
          }
        }
        else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent %d of remaining %d (sendc=%d)", n, tosend, sendc);
          applog(7, tmp42, 0);
        }
      }
      else if ( n == tosend )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent all of %d first go", tosend);
          applog(7, tmp42, 0);
        }
      }
      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "API: sent %d of %d first go", n, tosend);
        applog(7, tmp42, 0);
      }
      tosend -= n;
      buf += n;
      if ( !n )
        ++count;
    }
    else
    {
      ++count;
      if ( !sock_blocks_0() )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          v5 = len + 1;
          v6 = len + 1 - tosend;
          v7 = _errno_location();
          v8 = strerror(*v7);
          snprintf((char *)tmp42, 0x800u, "API: send (%d:%d) failed: %s", v5, v6, v8);
          applog(4, tmp42, 0);
        }
        return;
      }
    }
  }
}

//----- (00067998) --------------------------------------------------------
void __cdecl tidyup(void *arg)
{
  mutex_lock_2(&quit_restart_lock, "api-btm.c", _func___12338, 4571);
  bye = 1;
  if ( *(_DWORD *)arg != -1 )
  {
    shutdown(*(_DWORD *)arg, 2);
    close(*(_DWORD *)arg);
    *(_DWORD *)arg = -1;
  }
  if ( ipaccess )
  {
    free(ipaccess);
    ipaccess = 0;
  }
  io_free();
  mutex_unlock_2(&quit_restart_lock, "api-btm.c", _func___12338, 4592);
}

//----- (00067A4E) --------------------------------------------------------
void setup_groups()
{
  unsigned __int8 *v0; // r3
  size_t v1; // r0
  unsigned __int8 *v2; // r3
  int v3; // r4
  int v4; // r4
  int v5; // r4
  int v6; // r0
  int v7; // r4
  int v8; // r0
  int v9; // r4
  unsigned __int8 *v10; // r3
  unsigned __int8 *v11; // r3
  unsigned __int8 *v12; // r3
  uint32_t v13; // r5
  int v14; // r4
  int v15; // r4
  unsigned __int8 *v16; // r3
  uint32_t v17; // r5
  int v18; // r0
  int v19; // r4
  int v20; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+0h] BYREF
  unsigned __int8 cmdbuf[100]; // [sp+808h] [bp+800h] BYREF
  unsigned __int8 commands[8192]; // [sp+86Ch] [bp+864h] BYREF
  unsigned __int8 group; // [sp+286Fh] [bp+2867h]
  unsigned __int8 *buf; // [sp+2870h] [bp+2868h]
  unsigned __int8 *api_groups; // [sp+2874h] [bp+286Ch]
  int i; // [sp+2878h] [bp+2870h]
  bool did; // [sp+287Eh] [bp+2876h]
  bool addstar; // [sp+287Fh] [bp+2877h]
  unsigned __int8 *cmd; // [sp+2880h] [bp+2878h]
  unsigned __int8 *colon; // [sp+2884h] [bp+287Ch]
  unsigned __int8 *next; // [sp+2888h] [bp+2880h]
  unsigned __int8 *ptr; // [sp+288Ch] [bp+2884h]

  if ( opt_api_groups )
    v0 = opt_api_groups;
  else
    v0 = (unsigned __int8 *)BLANK;
  api_groups = v0;
  v1 = strlen((const char *)v0);
  buf = (unsigned __int8 *)cgmalloc(v1 + 1, "api-btm.c", _func___12354, 4609);
  strcpy((char *)buf, (const char *)api_groups);
  next = buf;
  while ( next && *next )
  {
    ptr = next;
    next = (unsigned __int8 *)strchr((const char *)next, 44);
    if ( next )
    {
      v2 = next++;
      *v2 = 0;
    }
    if ( ptr[1] != 58 )
    {
      colon = (unsigned __int8 *)strchr((const char *)ptr, 58);
      if ( colon )
        *colon = 0;
      snprintf((char *)tmp42, 0x800u, "API invalid group name '%s'", (const char *)ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    group = toupper(*ptr);
    v3 = toupper(group);
    if ( v3 < toupper(65) || (v4 = toupper(group), v4 > toupper(90)) )
    {
      snprintf((char *)tmp42, 0x800u, "API invalid group name '%c'", *ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    v5 = group;
    if ( v5 == toupper(87) )
    {
      v6 = toupper(87);
      snprintf((char *)tmp42, 0x800u, "API group name can't be '%c'", v6);
      applog(3, tmp42, 1);
      quit(1);
    }
    v7 = group;
    if ( v7 == toupper(82) )
    {
      v8 = toupper(82);
      snprintf((char *)tmp42, 0x800u, "API group name can't be '%c'", v8);
      applog(3, tmp42, 1);
      quit(1);
    }
    v9 = toupper(group);
    if ( apigroups[v9 - toupper(65)].commands )
    {
      snprintf((char *)tmp42, 0x800u, "API duplicate group name '%c'", *ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    ptr += 2;
    cmd = &commands[1];
    strcpy((char *)commands, "|");
    addstar = 0;
    while ( ptr && *ptr )
    {
      colon = (unsigned __int8 *)strchr((const char *)ptr, 58);
      if ( colon )
      {
        v10 = colon++;
        *v10 = 0;
      }
      if ( !strcmp((const char *)ptr, "*") )
      {
        addstar = 1;
      }
      else
      {
        did = 0;
        for ( i = 0; cmds[i].name; ++i )
        {
          if ( !strcasecmp((const char *)ptr, (const char *)cmds[i].name) )
          {
            did = 1;
            break;
          }
        }
        if ( !did )
        {
          snprintf((char *)tmp42, 0x800u, "API unknown command '%s' in group '%c'", (const char *)ptr, group);
          applog(3, tmp42, 1);
          quit(1);
        }
        sprintf((char *)cmdbuf, "|%s|", (const char *)cmds[i].name);
        if ( !strstr((const char *)commands, (const char *)cmdbuf) )
        {
          strcpy((char *)cmd, (const char *)cmds[i].name);
          cmd += strlen((const char *)cmds[i].name);
          v11 = cmd++;
          *v11 = 124;
          *cmd = 0;
        }
      }
      ptr = colon;
    }
    if ( addstar )
    {
      for ( i = 0; cmds[i].name; ++i )
      {
        if ( !cmds[i].iswritemode )
        {
          sprintf((char *)cmdbuf, "|%s|", (const char *)cmds[i].name);
          if ( !strstr((const char *)commands, (const char *)cmdbuf) )
          {
            strcpy((char *)cmd, (const char *)cmds[i].name);
            cmd += strlen((const char *)cmds[i].name);
            v12 = cmd++;
            *v12 = 124;
            *cmd = 0;
          }
        }
      }
    }
    v13 = strlen((const char *)commands) + 1;
    v14 = toupper(group);
    v15 = v14 - toupper(65);
    apigroups[v15].commands = (unsigned __int8 *)cgmalloc(v13, "api-btm.c", _func___12354, 4711);
    ptr = apigroups[v15].commands;
    strcpy((char *)ptr, (const char *)commands);
  }
  cmd = &commands[1];
  strcpy((char *)commands, "|");
  for ( i = 0; cmds[i].name; ++i )
  {
    if ( !cmds[i].iswritemode )
    {
      strcpy((char *)cmd, (const char *)cmds[i].name);
      cmd += strlen((const char *)cmds[i].name);
      v16 = cmd++;
      *v16 = 124;
      *cmd = 0;
    }
  }
  v17 = strlen((const char *)commands) + 1;
  v18 = toupper(82);
  v19 = toupper(v18);
  v20 = v19 - toupper(65);
  apigroups[v20].commands = (unsigned __int8 *)cgmalloc(v17, "api-btm.c", _func___12354, 4731);
  ptr = apigroups[v20].commands;
  strcpy((char *)ptr, (const char *)commands);
  free(buf);
}

//----- (000683B8) --------------------------------------------------------
void setup_ipaccess()
{
  size_t v0; // r0
  unsigned __int8 *v1; // r3
  unsigned __int8 *v2; // r3
  int v3; // r4
  int v4; // r4
  unsigned __int8 *v5; // r3
  unsigned __int8 *v6; // r3
  unsigned __int8 *v7; // r3
  unsigned __int8 *v8; // r3
  int v9; // r3
  int v11; // r3
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  unsigned __int8 original[64]; // [sp+80Ch] [bp+804h] BYREF
  unsigned __int8 tmp[64]; // [sp+84Ch] [bp+844h] BYREF
  unsigned __int8 *dot; // [sp+88Ch] [bp+884h]
  unsigned __int8 *slash; // [sp+890h] [bp+888h]
  unsigned __int8 *buf; // [sp+894h] [bp+88Ch]
  unsigned __int8 group; // [sp+89Ah] [bp+892h]
  bool ipv6; // [sp+89Bh] [bp+893h]
  int shift; // [sp+89Ch] [bp+894h]
  int i; // [sp+8A0h] [bp+898h]
  int mask; // [sp+8A4h] [bp+89Ch]
  int ipcount; // [sp+8A8h] [bp+8A0h]
  unsigned __int8 *end; // [sp+8ACh] [bp+8A4h]
  unsigned __int8 *comma; // [sp+8B0h] [bp+8A8h]
  unsigned __int8 *ptr; // [sp+8B4h] [bp+8ACh]

  ipv6 = 0;
  v0 = strlen((const char *)opt_api_allow);
  buf = (unsigned __int8 *)cgmalloc(v0 + 1, "api-btm.c", _func___12392, 4758);
  strcpy((char *)buf, (const char *)opt_api_allow);
  ipcount = 1;
  ptr = buf;
  while ( *ptr )
  {
    v1 = ptr++;
    if ( *v1 == 44 )
      ++ipcount;
  }
  ipaccess = (IPACCESS *)cgcalloc(ipcount, 0x24u, "api-btm.c", _func___12392, 4769);
  ips = 0;
  ptr = buf;
  while ( ptr && *ptr )
  {
    while ( *ptr == 32 || *ptr == 9 )
      ++ptr;
    if ( *ptr == 44 )
    {
      ++ptr;
    }
    else
    {
      comma = (unsigned __int8 *)strchr((const char *)ptr, 44);
      if ( comma )
      {
        v2 = comma++;
        *v2 = 0;
      }
      strncpy((char *)original, (const char *)ptr, 0x40u);
      original[63] = 0;
      group = toupper(82);
      if ( ((*_ctype_b_loc())[*ptr] & 0x400) != 0 && ptr[1] == 58 )
      {
        v3 = toupper(*ptr);
        if ( v3 == toupper(87) || (v4 = toupper(*ptr), apigroups[v4 - toupper(65)].commands) )
          group = toupper(*ptr);
        ptr += 2;
      }
      ipaccess[ips].group = group;
      if ( !strcmp((const char *)ptr, "0/0") )
      {
        for ( i = 0; i <= 15; ++i )
        {
          ipaccess[ips].ip.__u6_addr8[i] = 0;
          ipaccess[ips].mask.__u6_addr8[i] = 0;
        }
LABEL_74:
        ++ips;
        goto popipo;
      }
      end = (unsigned __int8 *)strchr((const char *)ptr, 47);
      if ( !end )
      {
        for ( i = 0; i <= 15; ++i )
          ipaccess[ips].mask.__u6_addr8[i] = -1;
        end = &ptr[strlen((const char *)ptr)];
      }
      v5 = end--;
      slash = v5;
      if ( *ptr == 91 && *end == 93 )
      {
        v6 = ptr++;
        *v6 = 0;
        v7 = end--;
        *v7 = 0;
        ipv6 = 1;
      }
      else
      {
        ipv6 = 0;
      }
      if ( *slash )
      {
        v8 = slash++;
        *v8 = 0;
        mask = atoi((const char *)slash);
        if ( mask <= 0 || (!ipv6 ? (v9 = 96) : (v9 = 0), mask += v9, mask > 128) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "API: ignored address with invalid mask (%d) '%s'",
              mask,
              (const char *)original);
            applog(3, tmp42, 0);
          }
          goto popipo;
        }
        for ( i = 0; i <= 15; ++i )
          ipaccess[ips].mask.__u6_addr8[i] = 0;
        i = 0;
        shift = 7;
        while ( 1 )
        {
          v11 = mask--;
          if ( v11 <= 0 )
            break;
          ipaccess[ips].mask.__u6_addr8[i] |= 1 << shift;
          if ( !shift-- )
          {
            ++i;
            shift = 7;
          }
        }
      }
      for ( i = 0; i <= 15; ++i )
        ipaccess[ips].ip.__u6_addr8[i] = 0;
      if ( ipv6 )
      {
        if ( inet_pton(10, (const char *)ptr, &ipaccess[ips]) == 1 )
          goto LABEL_71;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: ignored invalid IPv6 address '%s'", (const char *)original);
          applog(3, tmp42, 0);
        }
      }
      else
      {
        dot = (unsigned __int8 *)strchr((const char *)ptr, 46);
        if ( dot )
        {
          dot = (unsigned __int8 *)strchr((const char *)dot + 1, 46);
          if ( dot )
          {
            dot = (unsigned __int8 *)strchr((const char *)dot + 1, 46);
            if ( dot )
              snprintf((char *)tmp, 0x40u, "::ffff:%s", (const char *)ptr);
            else
              snprintf((char *)tmp, 0x40u, "::ffff:%s.0", (const char *)ptr);
          }
          else
          {
            snprintf((char *)tmp, 0x40u, "::ffff:%s.0.0", (const char *)ptr);
          }
        }
        else
        {
          snprintf((char *)tmp, 0x40u, "::ffff:%s.0.0.0", (const char *)ptr);
        }
        if ( inet_pton(10, (const char *)tmp, &ipaccess[ips]) == 1 )
        {
LABEL_71:
          for ( i = 0; i <= 15; ++i )
            ipaccess[ips].ip.__u6_addr8[i] &= ipaccess[ips].mask.__u6_addr8[i];
          goto LABEL_74;
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: ignored invalid IPv4 address '%s' (as %s)",
            (const char *)original,
            (const char *)tmp);
          applog(3, tmp42, 0);
        }
      }
popipo:
      ptr = comma;
    }
  }
  free(buf);
}

//----- (00068B68) --------------------------------------------------------
void *__cdecl __noreturn quit_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  mutex_lock_2(&quit_restart_lock, "api-btm.c", _func___12427, 4927);
  mutex_unlock_2(&quit_restart_lock, "api-btm.c", _func___12427, 4928);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "API: killing cgminer");
    applog(7, tmp42, 0);
  }
  kill_work();
}

//----- (00068C36) --------------------------------------------------------
void *__cdecl restart_thread_0(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp+8h] BYREF

  mutex_lock_2(&quit_restart_lock, "api-btm.c", _func___12432, 4941);
  mutex_unlock_2(&quit_restart_lock, "api-btm.c", _func___12432, 4942);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "API: restarting cgminer");
    applog(7, tmp42, 0);
  }
  app_restart();
  return 0;
}

//----- (00068D02) --------------------------------------------------------
bool __cdecl check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group)
{
  uint32_t v3; // r4
  bool v5; // r3
  in6_addr client_ip; // [sp+24h] [bp+14h] BYREF
  unsigned __int8 tmp[30]; // [sp+34h] [bp+24h] BYREF
  const in6_addr *__a; // [sp+54h] [bp+44h]
  bool match; // [sp+5Bh] [bp+4Bh]
  int j; // [sp+5Ch] [bp+4Ch]
  int i; // [sp+60h] [bp+50h]
  bool addrok; // [sp+67h] [bp+57h]

  addrok = 0;
  *connectaddr = (unsigned __int8 *)cgmalloc(0x2Eu, "api-btm.c", _func___12445, 4960);
  getnameinfo((const struct sockaddr *)cli, 0x80u, (char *)*connectaddr, 0x2Eu, 0, 0, 1u);
  if ( cli->ss_family == 2 )
  {
    sprintf((char *)tmp, "::ffff:%s", (const char *)*connectaddr);
    inet_pton(10, (const char *)tmp, &client_ip);
  }
  else
  {
    inet_pton(10, (const char *)*connectaddr, &client_ip);
  }
  *group = toupper(82);
  if ( opt_api_allow )
  {
    for ( i = 0; i < ips; ++i )
    {
      match = 1;
      for ( j = 0; j <= 15; ++j )
      {
        if ( (unsigned __int8)(ipaccess[i].mask.__u6_addr8[j] & client_ip.__u6_addr8[j]) != ipaccess[i].ip.__u6_addr8[j] )
        {
          match = 0;
          break;
        }
      }
      if ( match )
      {
        addrok = 1;
        *group = ipaccess[i].group;
        return addrok;
      }
    }
  }
  else if ( opt_api_network )
  {
    return 1;
  }
  else
  {
    v5 = 1;
    if ( strcmp((const char *)*connectaddr, (const char *)localaddr) )
    {
      __a = &client_ip;
      if ( client_ip.__u6_addr32[0] )
        return 0;
      if ( __a->__u6_addr32[1] )
        return 0;
      if ( __a->__u6_addr32[2] )
        return 0;
      v3 = __a->__u6_addr32[3];
      if ( v3 != htonl(1u) )
        return 0;
    }
    return v5;
  }
  return addrok;
}
// 68EDE: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (00068EEE) --------------------------------------------------------
void mcast()
{
  int *v0; // r0
  char *v1; // r0
  int *v2; // r0
  int ai_family; // r3
  int *v4; // r0
  char *v5; // r0
  int *v6; // r0
  char *v7; // r0
  size_t v8; // r0
  int *v9; // r0
  char *v10; // r0
  const char *v11; // r3
  size_t v12; // r0
  int *v13; // r0
  char *v14; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp+4h] BYREF
  ipv6_mreq grp_0; // [sp+814h] [bp+804h] BYREF
  ip_mreq grp; // [sp+828h] [bp+818h] BYREF
  int optval; // [sp+830h] [bp+820h] BYREF
  unsigned __int8 replybuf[1024]; // [sp+834h] [bp+824h] BYREF
  unsigned __int8 buf[1024]; // [sp+C34h] [bp+C24h] BYREF
  unsigned __int8 expect[9]; // [sp+1034h] [bp+1024h] BYREF
  addrinfo *res; // [sp+1040h] [bp+1030h] BYREF
  addrinfo hints; // [sp+1044h] [bp+1034h] BYREF
  unsigned __int8 came_from_port[10]; // [sp+1064h] [bp+1054h] BYREF
  unsigned __int8 port_s[10]; // [sp+1070h] [bp+1060h] BYREF
  unsigned __int8 group; // [sp+107Bh] [bp+106Bh] BYREF
  unsigned __int8 *connectaddr; // [sp+107Ch] [bp+106Ch] BYREF
  socklen_t came_from_siz; // [sp+1080h] [bp+1070h] BYREF
  sockaddr_storage came_from; // [sp+1084h] [bp+1074h] BYREF
  int reply_port; // [sp+1104h] [bp+10F4h]
  bool addrok; // [sp+110Bh] [bp+10FBh]
  unsigned __int8 *expect_code; // [sp+110Ch] [bp+10FCh]
  size_t expect_code_len; // [sp+1110h] [bp+1100h]
  time_t bindstart; // [sp+1114h] [bp+1104h]
  addrinfo *client; // [sp+1118h] [bp+1108h]
  addrinfo *host; // [sp+111Ch] [bp+110Ch]
  int count; // [sp+1120h] [bp+1110h]
  int bound; // [sp+1124h] [bp+1114h]
  ssize_t rep; // [sp+1128h] [bp+1118h]
  int reply_sock; // [sp+112Ch] [bp+111Ch]
  int mcast_sock; // [sp+1130h] [bp+1120h]
  unsigned __int8 *binderror; // [sp+1134h] [bp+1124h]

  mcast_sock = -1;
  reply_sock = -1;
  strcpy((char *)expect, "cgminer-");
  sprintf((char *)port_s, "%d", opt_api_mcast_port);
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  if ( getaddrinfo((const char *)opt_api_mcast_addr, (const char *)port_s, &hints, &res) )
  {
    strcpy((char *)tmp42, "Invalid API Multicast Address");
    applog(3, tmp42, 1);
    quit(1);
  }
  for ( host = res; host; host = host->ai_next )
  {
    mcast_sock = socket(res->ai_family, 2, 0);
    if ( mcast_sock > 0 )
      break;
  }
  if ( mcast_sock == -1 )
  {
    freeaddrinfo(res);
    strcpy((char *)tmp42, "API mcast could not open socket");
    applog(3, tmp42, 1);
    quit(1);
  }
  optval = 1;
  if ( setsockopt(mcast_sock, 1, 2, &optval, 4u) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v0 = _errno_location();
      v1 = strerror(*v0);
      snprintf((char *)tmp42, 0x800u, "API mcast setsockopt SO_REUSEADDR failed (%s)%s", v1, (const char *)MUNAVAILABLE);
      applog(3, tmp42, 0);
    }
    goto die;
  }
  bound = 0;
  bindstart = time(0);
  while ( !bound )
  {
    if ( bind(mcast_sock, host->ai_addr, host->ai_addrlen) >= 0 )
    {
      bound = 1;
    }
    else
    {
      v2 = _errno_location();
      binderror = (unsigned __int8 *)strerror(*v2);
      if ( time(0) - bindstart > 61 )
        break;
      cgsleep_ms(30000);
    }
  }
  if ( !bound )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "API mcast bind to port %d failed (%s)%s",
        opt_api_mcast_port,
        (const char *)binderror,
        (const char *)MUNAVAILABLE);
      applog(3, tmp42, 0);
    }
    goto die;
  }
  ai_family = host->ai_family;
  if ( ai_family != 2 )
  {
    if ( ai_family == 10 )
    {
      memcpy(&grp_0, &host->ai_addr->sa_data[6], 0x10u);
      grp_0.ipv6mr_interface = 0;
      if ( setsockopt(mcast_sock, 41, 20, &grp_0, 0x14u) < 0 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          v6 = _errno_location();
          v7 = strerror(*v6);
          snprintf((char *)tmp42, 0x800u, "API mcast join failed (%s)%s", v7, (const char *)MUNAVAILABLE);
          applog(3, tmp42, 0);
        }
        goto die;
      }
    }
LABEL_38:
    freeaddrinfo(res);
    v8 = strlen((const char *)opt_api_mcast_code);
    expect_code_len = v8 + 9;
    expect_code = (unsigned __int8 *)cgmalloc(v8 + 10, "api-btm.c", _func___12500, 5120);
    snprintf((char *)expect_code, expect_code_len + 1, "%s%s-", (const char *)expect, (const char *)opt_api_mcast_code);
    count = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        cgsleep_ms(1000);
        ++count;
        came_from_siz = 128;
        rep = recvfrom(mcast_sock, buf, 0x3FFu, 0, (struct sockaddr *)&came_from, &came_from_siz);
        if ( rep >= 0 )
          break;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          v9 = _errno_location();
          v10 = strerror(*v9);
          snprintf((char *)tmp42, 0x800u, "API mcast failed count=%d (%s) (%d)", count, v10, mcast_sock);
          applog(7, tmp42, 0);
        }
      }
      addrok = check_connect(&came_from, &connectaddr, &group);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        if ( addrok )
          v11 = "Accepted";
        else
          v11 = "Ignored";
        snprintf((char *)tmp42, 0x800u, "API mcast from %s - %s", (const char *)connectaddr, v11);
        applog(7, tmp42, 0);
      }
      if ( addrok )
      {
        buf[rep] = 0;
        if ( rep > 0 && buf[rep - 1] == 10 )
          buf[--rep] = 0;
        getnameinfo((const struct sockaddr *)&came_from, came_from_siz, 0, 0, (char *)came_from_port, 0xAu, 1u);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API mcast request rep=%d (%s) from [%s]:%s",
            rep,
            (const char *)buf,
            (const char *)connectaddr,
            (const char *)came_from_port);
          applog(7, tmp42, 0);
        }
        if ( expect_code_len < rep && !memcmp(buf, expect_code, expect_code_len) )
        {
          reply_port = atoi((const char *)&buf[expect_code_len]);
          if ( reply_port > 0 && reply_port < 0x10000 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "API mcast request OK port %s=%d",
                (const char *)&buf[expect_code_len],
                reply_port);
              applog(7, tmp42, 0);
            }
            if ( getaddrinfo((const char *)connectaddr, (const char *)&buf[expect_code_len], &hints, &res) )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf((char *)tmp42, 0x800u, "Invalid client address %s", (const char *)connectaddr);
                applog(3, tmp42, 0);
              }
            }
            else
            {
              for ( client = res; client; client = client->ai_next )
              {
                reply_sock = socket(res->ai_family, 2, 0);
                if ( mcast_sock > 0 )
                  break;
              }
              if ( reply_sock == -1 )
              {
                freeaddrinfo(res);
                if ( use_syslog || opt_log_output || opt_log_level > 2 )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "API mcast could not open socket to client %s",
                    (const char *)connectaddr);
                  applog(3, tmp42, 0);
                }
              }
              else
              {
                snprintf((char *)replybuf, 0x400u, "cgm-FTW-%d-%s", opt_api_port, (const char *)opt_api_mcast_des);
                v12 = strlen((const char *)replybuf);
                rep = sendto(reply_sock, replybuf, v12 + 1, 0, client->ai_addr, client->ai_addrlen);
                freeaddrinfo(res);
                if ( rep >= 0 )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "API mcast send reply (%s) succeeded (%d) (%d)",
                      (const char *)replybuf,
                      rep,
                      reply_sock);
                    applog(7, tmp42, 0);
                  }
                }
                else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  v13 = _errno_location();
                  v14 = strerror(*v13);
                  snprintf((char *)tmp42, 0x800u, "API mcast send reply failed (%s) (%d)", v14, reply_sock);
                  applog(7, tmp42, 0);
                }
                close(reply_sock);
              }
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "API mcast request ignored - invalid port (%s)",
              (const char *)&buf[expect_code_len]);
            applog(7, tmp42, 0);
          }
        }
        else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "API mcast request was no good");
          applog(7, tmp42, 0);
        }
      }
    }
  }
  memset(&grp, 0, sizeof(grp));
  grp.imr_multiaddr.s_addr = *(_DWORD *)&host->ai_addr->sa_data[2];
  grp.imr_interface.s_addr = 0;
  if ( setsockopt(mcast_sock, 0, 35, &grp, 8u) >= 0 )
    goto LABEL_38;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v4 = _errno_location();
    v5 = strerror(*v4);
    snprintf((char *)tmp42, 0x800u, "API mcast join failed (%s)%s", v5, (const char *)MUNAVAILABLE);
    applog(3, tmp42, 0);
  }
die:
  close(mcast_sock);
}

//----- (00069C3A) --------------------------------------------------------
void *__cdecl mcast_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  RenameThread("APIMcast");
  mcast();
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (00069C7A) --------------------------------------------------------
void mcast_init()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+4h] BYREF
  thr_info *thr; // [sp+80Ch] [bp+804h]

  thr = (thr_info *)cgcalloc(1, 0x40u, "api-btm.c", _func___12523, 5237);
  if ( thr_info_create(thr, 0, (void *(*)(void *))mcast_thread, thr) )
  {
    strcpy((char *)tmp42, "API mcast thread create failed");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00069CFC) --------------------------------------------------------
void reCalculateAVG()
{
  new_total_mhashes_done = total_mhashes_done;
  if ( total_secs <= 0.0 )
    new_total_secs = total_secs;
  else
    new_total_secs = total_secs - 1.0;
}

//----- (00069D72) --------------------------------------------------------
void __cdecl api(int api_thr_id)
{
  double v1; // d0
  int v2; // r0
  int *v3; // r0
  char *v4; // r0
  int *v5; // r0
  char *v6; // r0
  int *v7; // r0
  int *v8; // r0
  char *v9; // r0
  int *v10; // r0
  char *v11; // r0
  const char *v12; // r3
  int *v13; // r0
  char *v14; // r0
  unsigned __int8 *v15; // r3
  int v16; // r0
  size_t v17; // r0
  unsigned __int8 *v18; // r3
  int v19; // r4
  int v20; // r4
  int v21; // r0
  const char *v22; // r3
  __pthread_unwind_buf_t __cancel_buf; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+130h] [bp+120h] BYREF
  unsigned __int8 tmp42_0[2048]; // [sp+930h] [bp+920h] BYREF
  unsigned __int8 tmp42_1[2048]; // [sp+1130h] [bp+1120h] BYREF
  unsigned __int8 tmp42_2[2048]; // [sp+1930h] [bp+1920h] BYREF
  unsigned __int8 tmp42_3[2048]; // [sp+2130h] [bp+2120h] BYREF
  unsigned __int8 tmp42_4[2048]; // [sp+2930h] [bp+2920h] BYREF
  unsigned __int8 tmp42_5[2048]; // [sp+3130h] [bp+3120h] BYREF
  unsigned __int8 tmp42_6[2048]; // [sp+3930h] [bp+3920h] BYREF
  unsigned __int8 tmp42_7[2048]; // [sp+4130h] [bp+4120h] BYREF
  unsigned __int8 tmp42_8[2048]; // [sp+4930h] [bp+4920h] BYREF
  unsigned __int8 tmp42_9[2048]; // [sp+5130h] [bp+5120h] BYREF
  unsigned __int8 tmp42_10[2048]; // [sp+5930h] [bp+5920h] BYREF
  unsigned __int8 tmp42_11[2048]; // [sp+6130h] [bp+6120h] BYREF
  unsigned __int8 tmp42_12[2048]; // [sp+6930h] [bp+6920h] BYREF
  unsigned __int8 tmp42_13[2048]; // [sp+7130h] [bp+7120h] BYREF
  unsigned __int8 tmp42_14[2048]; // [sp+7930h] [bp+7920h] BYREF
  unsigned __int8 tmp42_15[2048]; // [sp+8130h] [bp+8120h] BYREF
  unsigned __int8 tmp42_16[2048]; // [sp+8930h] [bp+8920h] BYREF
  unsigned __int8 tmp42_17[2048]; // [sp+9130h] [bp+9120h] BYREF
  int optval; // [sp+9930h] [bp+9920h] BYREF
  addrinfo *res; // [sp+9934h] [bp+9924h] BYREF
  addrinfo hints; // [sp+9938h] [bp+9928h] BYREF
  bool firstjoin; // [sp+995Bh] [bp+994Bh] BYREF
  json_error_t json_err; // [sp+995Ch] [bp+994Ch] BYREF
  unsigned __int8 group; // [sp+9A5Bh] [bp+9A4Bh] BYREF
  unsigned __int8 cmdbuf[100]; // [sp+9A5Ch] [bp+9A4Ch] BYREF
  socklen_t clisiz; // [sp+9AC0h] [bp+9AB0h] BYREF
  sockaddr_storage cli; // [sp+9AC4h] [bp+9AB4h] BYREF
  unsigned __int8 port_s[10]; // [sp+9B44h] [bp+9B34h] BYREF
  unsigned __int8 *connectaddr; // [sp+9B50h] [bp+9B40h] BYREF
  unsigned __int8 param_buf[8192]; // [sp+9B54h] [bp+9B44h] BYREF
  unsigned __int8 buf[8192]; // [sp+BB54h] [bp+BB44h] BYREF
  thr_info bye_thr; // [sp+DB54h] [bp+DB44h] BYREF
  json_t_0 *json_val; // [sp+DB94h] [bp+DB84h]
  int n; // [sp+DB98h] [bp+DB88h]
  bool addrok; // [sp+DB9Fh] [bp+DB8Fh]
  int c; // [sp+DBA0h] [bp+DB90h]
  time_t bindstart; // [sp+DBA4h] [bp+DB94h]
  __int16 port; // [sp+DBAEh] [bp+DB9Eh]
  unsigned __int8 *cmdsbuf; // [sp+DBB0h] [bp+DBA0h]
  unsigned __int8 *cmdptr; // [sp+DBB4h] [bp+DBA4h]
  void *__cancel_arg; // [sp+DBB8h] [bp+DBA8h]
  void (*__cancel_routine)(void *); // [sp+DBBCh] [bp+DBACh]
  int *apisock; // [sp+DBC0h] [bp+DBB0h]
  addrinfo *host; // [sp+DBC4h] [bp+DBB4h]
  int i; // [sp+DBC8h] [bp+DBB8h]
  bool isjoin; // [sp+DBCDh] [bp+DBBDh]
  bool did; // [sp+DBCEh] [bp+DBBEh]
  bool isjson; // [sp+DBCFh] [bp+DBBFh]
  json_t_0 *json_config; // [sp+DBD0h] [bp+DBC0h]
  unsigned __int8 *param; // [sp+DBD4h] [bp+DBC4h]
  unsigned __int8 *cmd; // [sp+DBD8h] [bp+DBC8h]
  unsigned __int8 *binderror; // [sp+DBDCh] [bp+DBCCh]
  int bound; // [sp+DBE0h] [bp+DBD0h]
  io_data *io_data; // [sp+DBE4h] [bp+DBD4h]

  port = opt_api_port;
  cmd = 0;
  apisock = (int *)cgmalloc(4u, "api-btm.c", _func___12561, 5281);
  *apisock = -1;
  json_config = 0;
  isjoin = 0;
  if ( !opt_api_listen )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "API not running%s", (const char *)UNAVAILABLE);
      applog(7, tmp42, 0);
    }
    free(apisock);
    return;
  }
  io_data = io_new(0x10000u, 1);
  mutex_init_1(&quit_restart_lock, "api-btm.c", _func___12561, 5295);
  __cancel_routine = (void (*)(void *))tidyup;
  __cancel_arg = apisock;
  if ( _sigsetjmp((struct __jmp_buf_tag *)&__cancel_buf, 0) )
  {
    __cancel_routine(__cancel_arg);
    _pthread_unwind_next(&__cancel_buf);
  }
  _pthread_register_cancel(&__cancel_buf);
  my_thr_id = api_thr_id;
  setup_groups();
  if ( opt_api_allow )
  {
    setup_ipaccess();
    if ( !ips )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42_0, 0x800u, "API not running (no valid IPs specified)%s", (const char *)UNAVAILABLE);
        applog(4, tmp42_0, 0);
      }
LABEL_54:
      free(apisock);
      return;
    }
  }
  cgsleep_ms(1000 * opt_log_interval);
  sprintf((char *)port_s, "%d", port);
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = 1;
  hints.ai_family = 0;
  if ( getaddrinfo((const char *)opt_api_host, (const char *)port_s, &hints, &res) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42_1, 0x800u, "API failed to resolve %s", (const char *)opt_api_host);
      applog(3, tmp42_1, 0);
    }
    goto LABEL_54;
  }
  for ( host = res; host; host = host->ai_next )
  {
    v2 = socket(res->ai_family, 1, 0);
    *apisock = v2;
    if ( *apisock > 0 )
      break;
  }
  if ( *apisock == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v3 = _errno_location();
      v4 = strerror(*v3);
      snprintf((char *)tmp42_2, 0x800u, "API initialisation failed (%s)%s", v4, (const char *)UNAVAILABLE);
      applog(3, tmp42_2, 0);
    }
    freeaddrinfo(res);
    free(apisock);
    return;
  }
  optval = 1;
  if ( setsockopt(*apisock, 1, 2, &optval, 4u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v5 = _errno_location();
    v6 = strerror(*v5);
    snprintf((char *)tmp42_3, 0x800u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v6);
    applog(7, tmp42_3, 0);
  }
  bound = 0;
  bindstart = time(0);
  while ( !bound )
  {
    if ( bind(*apisock, host->ai_addr, host->ai_addrlen) >= 0 )
    {
      bound = 1;
    }
    else
    {
      v7 = _errno_location();
      binderror = (unsigned __int8 *)strerror(*v7);
      if ( time(0) - bindstart > 61 )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42_4, 0x800u, "API bind to port %d failed - trying again in 30sec", port);
        applog(4, tmp42_4, 0);
      }
      cgsleep_ms(30000);
    }
  }
  freeaddrinfo(res);
  if ( !bound )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42_5,
        0x800u,
        "API bind to port %d failed (%s)%s",
        port,
        (const char *)binderror,
        (const char *)UNAVAILABLE);
      applog(3, tmp42_5, 0);
    }
    goto LABEL_54;
  }
  if ( listen(*apisock, 100) >= 0 )
  {
    if ( opt_api_allow )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42_7, 0x800u, "API running in IP access mode on port %d (%d)", port, *apisock);
        applog(4, tmp42_7, 0);
      }
    }
    else if ( opt_api_network )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42_8,
          0x800u,
          "API running in UNRESTRICTED read access mode on port %d (%d)",
          port,
          *apisock);
        applog(4, tmp42_8, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42_9, 0x800u, "API running in local read access mode on port %d (%d)", port, *apisock);
      applog(4, tmp42_9, 0);
    }
    if ( opt_api_mcast )
      mcast_init();
    strbufs = k_new_list("StrBufs", 0xCu, 2, 0, 0, "api-btm.c", _func___12561, 5407);
    while ( !bye )
    {
      clisiz = 128;
      c = accept(*apisock, (struct sockaddr *)&cli, &clisiz);
      if ( c < 0 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          v10 = _errno_location();
          v11 = strerror(*v10);
          snprintf((char *)tmp42_10, 0x800u, "API failed (%s)%s (%d)", v11, (const char *)UNAVAILABLE, *apisock);
          applog(3, tmp42_10, 0);
        }
        break;
      }
      addrok = check_connect(&cli, &connectaddr, &group);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        if ( addrok )
          v12 = "Accepted";
        else
          v12 = "Ignored";
        snprintf((char *)tmp42_11, 0x800u, "API: connection from %s - %s", (const char *)connectaddr, v12);
        applog(7, tmp42_11, 0);
      }
      if ( addrok )
      {
        n = recv(c, buf, 0x1FFFu, 0);
        if ( n >= 0 )
          buf[n] = 0;
        else
          buf[0] = 0;
        if ( opt_debug )
        {
          if ( n >= 0 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42_13, 0x800u, "API: recv command: (%d) '%s'", n, (const char *)buf);
              applog(7, tmp42_13, 0);
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            v13 = _errno_location();
            v14 = strerror(*v13);
            snprintf((char *)tmp42_12, 0x800u, "API: recv failed: %s", v14);
            applog(7, tmp42_12, 0);
          }
        }
        if ( n >= 0 )
        {
          when = time(0);
          io_reinit(io_data);
          did = 0;
          if ( buf[0] == 123 )
          {
            isjson = 1;
            param = 0;
            json_config = json_loadb(buf, n, 0, &json_err);
            if ( json_config && json_config->type == JSON_OBJECT )
            {
              json_val = json_object_get(json_config, JSON_COMMAND);
              if ( json_val )
              {
                if ( json_val->type == JSON_STRING )
                {
                  cmd = (unsigned __int8 *)json_string_value(json_val);
                  json_val = json_object_get(json_config, JSON_PARAMETER);
                  if ( json_val && json_val->type == JSON_STRING )
                  {
                    param = (unsigned __int8 *)json_string_value(json_val);
                  }
                  else if ( json_val && json_val->type == JSON_INTEGER )
                  {
                    v16 = json_integer_value(json_val);
                    sprintf((char *)param_buf, "%d", v16);
                    param = param_buf;
                  }
                  else if ( json_val && json_val->type == JSON_REAL )
                  {
                    json_real_value(json_val);
                    sprintf((char *)param_buf, "%f", v1);
                    param = param_buf;
                  }
                }
                else
                {
                  message(io_data, 14, 0, 0, isjson);
                  send_result(io_data, c, isjson);
                  did = 1;
                }
              }
              else
              {
                message(io_data, 24, 0, 0, isjson);
                send_result(io_data, c, isjson);
                did = 1;
              }
            }
            else
            {
              message(io_data, 23, 0, 0, isjson);
              send_result(io_data, c, isjson);
              did = 1;
            }
          }
          else
          {
            isjson = 0;
            param = (unsigned __int8 *)strchr((const char *)buf, 124);
            if ( param )
            {
              v15 = param++;
              *v15 = 0;
            }
            cmd = buf;
          }
          if ( !did )
          {
            cmdsbuf = 0;
            if ( strchr((const char *)cmd, 43) )
            {
              isjoin = 1;
              firstjoin = 1;
              v17 = strlen((const char *)cmd);
              cmdsbuf = (unsigned __int8 *)cgmalloc(v17 + 3, "api-btm.c", _func___12561, 5516);
              strcpy((char *)cmdsbuf, "|");
              param = 0;
            }
            else
            {
              isjoin = 0;
              firstjoin = 0;
            }
            cmdptr = cmd;
            do
            {
              did = 0;
              if ( !isjoin )
                goto LABEL_137;
              cmd = (unsigned __int8 *)strchr((const char *)cmdptr, 43);
              if ( cmd )
              {
                v18 = cmd++;
                *v18 = 0;
              }
              if ( *cmdptr )
              {
LABEL_137:
                for ( i = 0; cmds[i].name; ++i )
                {
                  if ( !strcmp((const char *)cmdptr, (const char *)cmds[i].name) )
                  {
                    sprintf((char *)cmdbuf, "|%s|", (const char *)cmdptr);
                    if ( !isjoin )
                      goto LABEL_144;
                    if ( strstr((const char *)cmdsbuf, (const char *)cmdbuf) )
                    {
                      did = 1;
                      break;
                    }
                    strcat((char *)cmdsbuf, (const char *)cmdptr);
                    strcat((char *)cmdsbuf, "|");
                    head_join(io_data, cmdptr, isjson, &firstjoin);
                    if ( !cmds[i].joinable )
                    {
                      message(io_data, 45, 0, cmds[i].name, isjson);
                      did = 1;
                      tail_join(io_data, isjson);
                    }
                    else
                    {
LABEL_144:
                      v19 = toupper(group);
                      if ( v19 == toupper(87)
                        || (v20 = toupper(group),
                            v21 = toupper(65),
                            strstr((const char *)apigroups[v20 - v21].commands, (const char *)cmdbuf)) )
                      {
                        cmds[i].func(io_data, c, param, isjson, group);
                      }
                      else
                      {
                        message(io_data, 45, 0, cmds[i].name, isjson);
                        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                        {
                          snprintf(
                            (char *)tmp42_14,
                            0x800u,
                            "API: access denied to '%s' for '%s' command",
                            (const char *)connectaddr,
                            (const char *)cmds[i].name);
                          applog(7, tmp42_14, 0);
                        }
                      }
                      did = 1;
                      if ( !isjoin )
                        send_result(io_data, c, isjson);
                      else
                        tail_join(io_data, isjson);
                    }
                    break;
                  }
                }
                if ( !did )
                {
                  if ( isjoin )
                    head_join(io_data, cmdptr, isjson, &firstjoin);
                  message(io_data, 14, 0, 0, isjson);
                  if ( isjoin )
                    tail_join(io_data, isjson);
                  else
                    send_result(io_data, c, isjson);
                }
              }
              if ( isjoin )
                cmdptr = cmd;
            }
            while ( isjoin && cmdptr );
          }
          if ( isjoin )
            send_result(io_data, c, isjson);
          if ( isjson && json_config && json_config->type == JSON_OBJECT )
            json_decref_1(json_config);
        }
      }
      close(c);
    }
    _pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
    free(apisock);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      if ( do_a_quit )
      {
        v22 = "QUIT";
      }
      else if ( do_a_restart )
      {
        v22 = "RESTART";
      }
      else if ( bye )
      {
        v22 = "BYE";
      }
      else
      {
        v22 = "UNKNOWN!";
      }
      snprintf((char *)tmp42_15, 0x800u, "API: terminating due to: %s", v22);
      applog(7, tmp42_15, 0);
    }
    mutex_lock_2(&quit_restart_lock, "api-btm.c", _func___12561, 5615);
    if ( do_a_restart )
    {
      if ( thr_info_create(&bye_thr, 0, (void *(*)(void *))restart_thread_0, &bye_thr) )
      {
        mutex_unlock_2(&quit_restart_lock, "api-btm.c", _func___12561, 5621);
        strcpy((char *)tmp42_16, "API failed to initiate a restart - aborting");
        applog(3, tmp42_16, 1);
        quit(1);
      }
    }
    else
    {
      if ( !do_a_quit )
      {
LABEL_195:
        mutex_unlock_2(&quit_restart_lock, "api-btm.c", _func___12561, 5636);
        return;
      }
      if ( thr_info_create(&bye_thr, 0, (void *(*)(void *))quit_thread, &bye_thr) )
      {
        mutex_unlock_2(&quit_restart_lock, "api-btm.c", _func___12561, 5630);
        strcpy((char *)tmp42_17, "API failed to initiate a clean quit - aborting");
        applog(3, tmp42_17, 1);
        quit(1);
      }
    }
    pthread_detach(bye_thr.pth);
    goto LABEL_195;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v8 = _errno_location();
    v9 = strerror(*v8);
    snprintf((char *)tmp42_6, 0x800u, "API3 initialisation failed (%s)%s", v9, (const char *)UNAVAILABLE);
    applog(3, tmp42_6, 0);
  }
  close(*apisock);
  free(apisock);
}
// 6AD9E: variable 'v1' is possibly undefined

//----- (0006B6FE) --------------------------------------------------------
void __cdecl mutex_lock_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0006B77A) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0006B7F6) --------------------------------------------------------
void __cdecl mutex_unlock_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_3(lock, file, func, line);
  selective_yield();
}

//----- (0006B824) --------------------------------------------------------
int __cdecl mutex_trylock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_mutex_trylock(lock);
}

//----- (0006B844) --------------------------------------------------------
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force)
{
  if ( !opt_quiet || prio == 3 )
  {
    if ( force )
    {
      mutex_trylock_0(&console_lock, "logging.c", _func___11016, 40);
      mutex_unlock_3(&console_lock, "logging.c", _func___11016, 41);
    }
    mutex_lock_3(&console_lock, "logging.c", _func___11016, 52);
    printf("%s%s%s", (const char *)datetime, (const char *)str, "                    \n");
    mutex_unlock_3(&console_lock, "logging.c", _func___11016, 54);
  }
}

//----- (0006B906) --------------------------------------------------------
void __cdecl applog(int prio, const unsigned __int8 *str, bool force)
{
  int v3; // r0
  size_t v4; // r0
  size_t v5; // r0
  unsigned __int8 datetime[64]; // [sp+2Ch] [bp+14h] BYREF
  time_t tmp_time; // [sp+6Ch] [bp+54h] BYREF
  timeval tv; // [sp+70h] [bp+58h] BYREF
  tm *tm; // [sp+78h] [bp+60h]
  int ms; // [sp+7Ch] [bp+64h]

  if ( use_syslog )
  {
    syslog(prio | 0x80, "%s\n", (const char *)str);
  }
  else
  {
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    cgtime(&tv);
    tmp_time = tv.tv_sec;
    ms = tv.tv_usec / 1000;
    tm = localtime(&tmp_time);
    snprintf(
      (char *)datetime,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      tm->tm_year + 1900,
      tm->tm_mon + 1,
      tm->tm_mday,
      tm->tm_hour,
      tm->tm_min,
      tm->tm_sec,
      ms);
    v3 = fileno((FILE *)stderr);
    if ( !isatty(v3) )
    {
      fprintf((FILE *)stderr, "%s%s\n", (const char *)datetime, (const char *)str);
      fflush((FILE *)stderr);
    }
    if ( g_logfile_enable )
    {
      if ( !g_log_file )
        g_log_file = fopen((const char *)g_logfile_path, (const char *)g_logfile_openflag);
      if ( g_log_file )
      {
        v4 = strlen((const char *)datetime);
        fwrite(datetime, v4, 1u, g_log_file);
        v5 = strlen((const char *)str);
        fwrite(str, v5, 1u, g_log_file);
        fwrite("\n", 1u, 1u, g_log_file);
        fflush(g_log_file);
      }
    }
    my_log_curses(prio, datetime, str, force);
  }
}
// AC420: using guessed type int stderr;

//----- (0006BAC2) --------------------------------------------------------
int __cdecl my_system(const unsigned __int8 *cmd)
{
  int *v2; // r0
  char *v3; // r0
  unsigned __int8 buf[1024]; // [sp+10h] [bp+8h] BYREF
  FILE *pFile; // [sp+410h] [bp+408h]
  FILE *pFile_0; // [sp+414h] [bp+40Ch]
  FILE *pFile_1; // [sp+418h] [bp+410h]
  FILE *pFile_2; // [sp+41Ch] [bp+414h]
  int res; // [sp+420h] [bp+418h]
  FILE *fp; // [sp+424h] [bp+41Ch]

  if ( cmd )
  {
    fp = popen((const char *)cmd, "r");
    if ( fp )
    {
      while ( fgets((char *)buf, 1024, fp) )
        ;
      res = pclose(fp);
      if ( res == -1 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: close popen file pointer fp error!\n",
              "log.c",
              75,
              (const char *)_FUNCTION___8213);
          fclose(pFile_1);
        }
        return res;
      }
      else if ( res )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: pclose res is :%d\n",
              "log.c",
              84,
              (const char *)_FUNCTION___8213,
              (res & 0x7F) == 0);
          fclose(pFile_2);
        }
        return BYTE1(res);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          v2 = _errno_location();
          v3 = strerror(*v2);
          fprintf(pFile_0, "%s:%d:%s: popen error: %s/n", "log.c", 64, (const char *)_FUNCTION___8213, v3);
        }
        fclose(pFile_0);
      }
      return -1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: cmd is NULL!\n", "log.c", 59, (const char *)_FUNCTION___8213);
      fclose(pFile);
    }
    return -1;
  }
}

//----- (0006BD3A) --------------------------------------------------------
int __cdecl log_update_name(
        const _log_ctx *ctx,
        const unsigned __int8 *prefix,
        const unsigned __int8 *path,
        const unsigned __int8 *ts)
{
  unsigned __int8 cmd[4096]; // [sp+28h] [bp+10h] BYREF
  FILE *pFile; // [sp+1028h] [bp+1010h]
  FILE *pFile_1; // [sp+102Ch] [bp+1014h]
  FILE *pFile_0; // [sp+1030h] [bp+1018h]
  int ret; // [sp+1034h] [bp+101Ch]

  ret = snprintf(
          (char *)cmd,
          0x1000u,
          "/usr/bin/updatename.sh %s %s %s %s %s %s",
          (const char *)ctx->tgt_dir,
          (const char *)ctx->path,
          (const char *)ctx->ts,
          (const char *)prefix,
          (const char *)path,
          (const char *)ts);
  if ( ret == -1 || (unsigned int)ret >= 0x1000 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: too large command LOGUPDATENAME\n", "log.c", 98, (const char *)_FUNCTION___8229);
      fclose(pFile);
    }
    return -1;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: _log_update_name\n", "log.c", 101, (const char *)_FUNCTION___8229);
      fclose(pFile_0);
    }
    ret = my_system(cmd);
    if ( ret && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: my_system returned failed %d on LOGUPDATENAME\n",
          "log.c",
          105,
          (const char *)_FUNCTION___8229,
          ret);
      fclose(pFile_1);
    }
    return ret;
  }
}

//----- (0006BFC6) --------------------------------------------------------
int __cdecl log_rotate(const _log_ctx *ctx)
{
  unsigned __int8 cmd[4096]; // [sp+20h] [bp+8h] BYREF
  FILE *pFile; // [sp+1020h] [bp+1008h]
  FILE *pFile_1; // [sp+1024h] [bp+100Ch]
  FILE *pFile_2; // [sp+1028h] [bp+1010h]
  FILE *pFile_0; // [sp+102Ch] [bp+1014h]
  int ret; // [sp+1030h] [bp+1018h]
  int debug; // [sp+1034h] [bp+101Ch]

  debug = 0;
  ret = snprintf((char *)cmd, 0x1000u, "/usr/bin/checksize.sh %d %s", 0, (const char *)ctx->tgt_dir);
  if ( ret == -1 || (unsigned int)ret >= 0x1000 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: too large command LOGCHECKSIZE\n", "log.c", 120, (const char *)_FUNCTION___8239);
      fclose(pFile);
    }
    return -1;
  }
  else
  {
    ret = my_system(cmd);
    if ( ret && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: my_system returned failed %d on LOGCHECKSIZE\n",
          "log.c",
          126,
          (const char *)_FUNCTION___8239,
          ret);
      fclose(pFile_0);
    }
    ret = snprintf(
            (char *)cmd,
            0x1000u,
            "/usr/bin/rotate.sh %d %d %s %s %s %s %s",
            debug,
            ctx->need_clear,
            (const char *)ctx->tgt_dir,
            (const char *)ctx->src_dir,
            (const char *)ctx->path,
            (const char *)ctx->ts,
            (const char *)ctx->prefix);
    if ( ret == -1 || (unsigned int)ret >= 0x1000 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: too large command LOGROTATE\n", "log.c", 132, (const char *)_FUNCTION___8239);
        fclose(pFile_1);
      }
      return -1;
    }
    else
    {
      ret = my_system(cmd);
      if ( ret && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: my_system returned failed %d on LOGROTATE\n",
            "log.c",
            138,
            (const char *)_FUNCTION___8239,
            ret);
        fclose(pFile_2);
      }
      return ret;
    }
  }
}

//----- (0006C372) --------------------------------------------------------
int __cdecl log_generate_symbol_link(const _log_ctx *ctx, const unsigned __int8 *prefix, const unsigned __int8 *path)
{
  unsigned __int8 cmd[4096]; // [sp+24h] [bp+14h] BYREF
  FILE *pFile; // [sp+1024h] [bp+1014h]
  FILE *pFile_0; // [sp+1028h] [bp+1018h]
  int ret; // [sp+102Ch] [bp+101Ch]

  ret = snprintf(
          (char *)cmd,
          0x1000u,
          "/usr/bin/symbollink.sh %s %s %s %s %s",
          (const char *)ctx->tgt_dir,
          (const char *)ctx->path,
          (const char *)ctx->ts,
          (const char *)prefix,
          (const char *)path);
  if ( ret == -1 || (unsigned int)ret >= 0x1000 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: too large command LOG_SYMBOL_LINK\n", "log.c", 152, (const char *)_FUNCTION___8251);
      fclose(pFile);
    }
    return -1;
  }
  else
  {
    ret = my_system(cmd);
    if ( ret && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: my_system returned failed %d on LOG_SYMBOL_LINK\n",
          "log.c",
          159,
          (const char *)_FUNCTION___8251,
          ret);
      fclose(pFile_0);
    }
    return ret;
  }
}

//----- (0006C56C) --------------------------------------------------------
void *__cdecl __noreturn log_thread_routine(void *arg)
{
  int updated; // r0
  size_t v2; // r0
  unsigned __int8 ts[20]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 path[30]; // [sp+20h] [bp+20h] BYREF
  time_t tloc; // [sp+40h] [bp+40h] BYREF
  FILE *pFile; // [sp+44h] [bp+44h]
  int ret; // [sp+48h] [bp+48h]
  tm *tm_info; // [sp+4Ch] [bp+4Ch]
  _log_ctx *ctx; // [sp+50h] [bp+50h]
  uint32_t counter; // [sp+54h] [bp+54h]

  ctx = (_log_ctx *)arg;
  counter = 0;
  if ( !arg )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "Assert fail!! %s:%d: input arg wrong\n", "log.c", 178);
    fclose(pFile);
    _assert_fail("0", "log.c", 0xB2u, (const char *)_PRETTY_FUNCTION___8265);
  }
  ctx->need_clear = 0;
  ctx->prefix = "cglog_sync";
  while ( 1 )
  {
    if ( !(++counter % 0x1E) )
    {
      time(&tloc);
      tm_info = localtime(&tloc);
      strftime((char *)path, 0xFu, "%Y-%m/%d", tm_info);
      strftime((char *)ts, 0xAu, "%H-%M-%S", tm_info);
      if ( !strncmp((const char *)ctx->path, "1970", 4u) && tloc > 31536000 )
      {
        ret = log_update_name(ctx, "cglog_init", path, ts);
        updated = log_update_name(ctx, "cglog_sync", path, ts);
        ret |= updated;
        if ( !ret )
        {
          strncpy((char *)ctx->path, (const char *)path, 0x1Eu);
          strncpy((char *)ctx->ts, (const char *)ts, 0x14u);
          strcpy((char *)ctx->last_path, (const char *)ctx->path);
        }
      }
      if ( ctx->last_path[0] )
      {
        v2 = strlen((const char *)path);
        if ( strncmp((const char *)ctx->last_path, (const char *)path, v2) )
        {
          ret = log_generate_symbol_link(ctx, "cglog_sync", path);
          if ( !ret )
            strncpy((char *)ctx->last_path, (const char *)path, 0x1Eu);
        }
      }
      else
      {
        strcpy((char *)ctx->last_path, (const char *)ctx->path);
      }
      log_rotate(ctx);
    }
    sleep(1u);
  }
}

//----- (0006C776) --------------------------------------------------------
void log_init()
{
  pthread_t log_thread; // [sp+4h] [bp+4h] BYREF
  time_t timer; // [sp+8h] [bp+8h] BYREF
  FILE *pFile; // [sp+Ch] [bp+Ch]
  tm *tm_info; // [sp+10h] [bp+10h]
  _log_ctx *ctx; // [sp+14h] [bp+14h]

  ctx = &log_ctx;
  if ( !log_ctx.path[0] )
  {
    time(&timer);
    tm_info = localtime(&timer);
    strftime((char *)ctx->path, 0xFu, "%Y-%m/%d", tm_info);
    strftime((char *)ctx->ts, 0xAu, "%H-%M-%S", tm_info);
    ctx->need_clear = 1;
    ctx->src_dir = "/var/log";
    ctx->tgt_dir = "nvdata";
    ctx->prefix = "cglog_init";
    log_rotate(ctx);
    if ( pthread_create(&log_thread, 0, (void *(*)(void *))log_thread_routine, ctx) )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "Assert fail!! %s:%d: Failed to create log thread", "log.c", 257);
      fclose(pFile);
      _assert_fail("0", "log.c", 0x101u, (const char *)_PRETTY_FUNCTION___8276);
    }
    pthread_detach(log_thread);
  }
}

//----- (0006C8A0) --------------------------------------------------------
void __cdecl clear_log(unsigned __int8 *file)
{
  FILE *fd; // [sp+Ch] [bp+Ch]

  fd = fopen((const char *)file, "w");
  if ( fd )
    fclose(fd);
}

//----- (0006C8CC) --------------------------------------------------------
void __cdecl copy_log_to_latest(unsigned __int8 *file)
{
  unsigned __int8 cmd[512]; // [sp+10h] [bp+8h] BYREF

  memset(cmd, 0, sizeof(cmd));
  sprintf(
    (char *)cmd,
    "if [ -f %s ];then cp %s %s_latest;fi;",
    (const char *)file,
    (const char *)file,
    (const char *)file);
  system((const char *)cmd);
}

//----- (0006C91C) --------------------------------------------------------
void __cdecl print_crt_time_to_file(const unsigned __int8 *file, unsigned int level)
{
  unsigned __int8 buffer[26]; // [sp+8h] [bp+8h] BYREF
  time_t timer; // [sp+24h] [bp+24h] BYREF
  FILE *pFile; // [sp+28h] [bp+28h]
  tm *tm_info; // [sp+2Ch] [bp+2Ch]

  time(&timer);
  tm_info = localtime(&timer);
  strftime((char *)buffer, 0x1Au, "%Y-%m-%d %H:%M:%S", tm_info);
  if ( level < log_level )
  {
    pFile = fopen((const char *)file, "a+");
    if ( pFile )
      fprintf(pFile, "%s ", (const char *)buffer);
    fclose(pFile);
  }
}

//----- (0006C998) --------------------------------------------------------
void __cdecl dump_mem(unsigned __int8 *desc, void *addr, int len)
{
  int v3; // r3
  int v4; // r3
  int v5; // r3
  unsigned __int8 buff[17]; // [sp+14h] [bp+14h] BYREF
  FILE *pFile_2; // [sp+28h] [bp+28h]
  FILE *pFile_1; // [sp+2Ch] [bp+2Ch]
  FILE *pFile_0; // [sp+30h] [bp+30h]
  FILE *pFile_3; // [sp+34h] [bp+34h]
  FILE *pFile_4; // [sp+38h] [bp+38h]
  FILE *pFile; // [sp+3Ch] [bp+3Ch]
  unsigned __int8 *pc; // [sp+40h] [bp+40h]
  int i; // [sp+44h] [bp+44h]
  __int64 savedregs; // [sp+48h] [bp+48h] BYREF

  pc = (unsigned __int8 *)addr;
  if ( desc && log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:\n", (const char *)desc);
    fclose(pFile);
  }
  for ( i = 0; i < len; ++i )
  {
    if ( (i & 0xF) == 0 )
    {
      if ( i && log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "  %s\n", (const char *)buff);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "  %04x ", i);
        fclose(pFile_1);
      }
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, " %02x", pc[i]);
      fclose(pFile_2);
    }
    if ( pc[i] > 0x1Fu && pc[i] <= 0x7Eu )
    {
      v4 = i & 0xF;
      if ( i <= 0 )
        v4 = -(-i & 0xF);
      *((_BYTE *)&savedregs + v4 - 52) = pc[i];
    }
    else
    {
      v3 = i & 0xF;
      if ( i <= 0 )
        v3 = -(-i & 0xF);
      *((_BYTE *)&savedregs + v3 - 52) = 46;
    }
    v5 = i & 0xF;
    if ( i <= 0 )
      v5 = -(-i & 0xF);
    *((_BYTE *)&savedregs + v5 - 51) = 0;
  }
  while ( (i & 0xF) != 0 )
  {
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fwrite("   ", 1u, 3u, pFile_3);
      fclose(pFile_3);
    }
    ++i;
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(pFile_4, "  %s\n", (const char *)buff);
    fclose(pFile_4);
  }
}

//----- (0006CC0E) --------------------------------------------------------
bool __cdecl is_chain_existed(uint8_t chain)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  if ( dev->chain_exist[chain] )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: chain[%d] does not exist\n", "eeprom.c", 71, (const char *)_FUNCTION___12273, chain);
    fclose(pFile);
  }
  return 0;
}

//----- (0006CCA8) --------------------------------------------------------
bool __cdecl is_eeprom_chain_load_succeeded(uint8_t chain)
{
  FILE *pFile; // [sp+10h] [bp+8h]
  FILE *pFile_0; // [sp+14h] [bp+Ch]

  if ( dev->chain_exist[chain] )
  {
    if ( !state_is_eeprom_all_chain_load_succeeded && (unsigned __int8)eeprom_load() != 1 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: chain[%d]: data load from eeprom to dram fail\n",
            "eeprom.c",
            89,
            (const char *)_FUNCTION___12278,
            chain);
        fclose(pFile_0);
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: chain[%d] does not exist\n", "eeprom.c", 81, (const char *)_FUNCTION___12278, chain);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (0006CDD6) --------------------------------------------------------
bool __cdecl is_eeprom_address_valid(uint32_t address, uint32_t len)
{
  FILE *pFile; // [sp+1Ch] [bp+Ch]

  if ( len + address <= 0x100 )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: warning: eeprom address (start %d, length %d)  overflow %d \n",
        "eeprom.c",
        100,
        (const char *)_FUNCTION___12285,
        address,
        len,
        256);
    fclose(pFile);
  }
  return 0;
}

//----- (0006CE70) --------------------------------------------------------
bool __cdecl is_eeprom_write_buf_valid(uint8_t *buf)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  if ( buf )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: warning: write buf is null \n", "eeprom.c", 110, (const char *)_FUNCTION___12290);
    fclose(pFile);
  }
  return 0;
}

//----- (0006CEF4) --------------------------------------------------------
bool __cdecl is_eeprom_read_buf_valid(uint8_t *buf)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  if ( buf )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: warning: read buf is null \n", "eeprom.c", 120, (const char *)_FUNCTION___12295);
    fclose(pFile);
  }
  return 0;
}

//----- (0006CF78) --------------------------------------------------------
uint8_t __cdecl write_eeprom_iic(uint8_t chain, uint8_t reg_addr, uint8_t data)
{
  return zynq_set_iic(chain & 7 | 0x50, 0, 0, 1, reg_addr, data);
}

//----- (0006CFC8) --------------------------------------------------------
uint8_t __cdecl read_eeprom_iic(uint8_t chain, uint8_t reg_addr)
{
  return zynq_set_iic(chain & 7 | 0x50, 0, 1, 1, reg_addr, 0);
}

//----- (0006D016) --------------------------------------------------------
void __cdecl eeprom_write_one_byte(uint8_t address, uint8_t data, uint8_t chain)
{
  write_eeprom_iic(chain, address, data);
}

//----- (0006D03C) --------------------------------------------------------
void __cdecl array_write_one_byte(uint8_t address, uint8_t data, uint8_t chain)
{
  eeprom_info[chain][address] = data;
  eeprom_dirty_flag[chain][address >> 3] |= 1 << (address & 7);
}

//----- (0006D0BC) --------------------------------------------------------
uint8_t __cdecl eeprom_read_one_byte(uint8_t address, uint8_t chain)
{
  return read_eeprom_iic(chain, address);
}

//----- (0006D0EA) --------------------------------------------------------
uint8_t __cdecl array_read_one_byte(uint8_t address, uint8_t chain)
{
  return eeprom_info[chain][address];
}

//----- (0006D11A) --------------------------------------------------------
void __cdecl eeprom_write_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length)
{
  uint32_t i; // [sp+14h] [bp+14h]

  for ( i = 0; i < length; ++i )
  {
    if ( (((int)eeprom_dirty_flag[chain][(i + address) >> 3] >> ((i + address) & 7)) & 1) != 0 )
    {
      eeprom_write_one_byte(address + i, buf[i], chain);
      eeprom_dirty_flag[chain][(i + address) >> 3] &= ~(unsigned __int8)(1 << ((i + address) & 7));
      usleep(0x2710u);
    }
  }
}

//----- (0006D1F4) --------------------------------------------------------
void __cdecl array_write_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length)
{
  uint32_t i; // [sp+14h] [bp+14h]

  for ( i = 0; i < length; ++i )
    array_write_one_byte(address + i, buf[i], chain);
}

//----- (0006D240) --------------------------------------------------------
void __cdecl eeprom_read_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length)
{
  uint32_t i; // [sp+14h] [bp+14h]

  for ( i = 0; i < length; ++i )
  {
    buf[i] = eeprom_read_one_byte(address + i, chain);
    usleep(0x2710u);
  }
}

//----- (0006D296) --------------------------------------------------------
void __cdecl array_read_bytes(uint8_t address, uint8_t *buf, uint8_t chain, uint32_t length)
{
  uint32_t i; // [sp+14h] [bp+14h]

  for ( i = 0; i < length; ++i )
    buf[i] = array_read_one_byte(address + i, chain);
}

//----- (0006D2E4) --------------------------------------------------------
bool __cdecl array_update_crc(uint8_t chain)
{
  uint16_t crc; // [sp+Ah] [bp+Ah] BYREF
  uint8_t *dram_buf; // [sp+Ch] [bp+Ch]

  dram_buf = eeprom_info[chain];
  crc = CRC16(dram_buf, 0xFEu);
  array_write_bytes(0xFEu, (uint8_t *)&crc, chain, 2u);
  return 1;
}

//----- (0006D326) --------------------------------------------------------
bool __cdecl array_check_crc(uint8_t chain)
{
  uint16_t _crc_; // [sp+1Eh] [bp+Eh] BYREF
  FILE *pFile_0; // [sp+20h] [bp+10h]
  FILE *pFile; // [sp+24h] [bp+14h]
  uint16_t crc; // [sp+2Ah] [bp+1Ah]
  uint8_t *buf; // [sp+2Ch] [bp+1Ch]

  buf = eeprom_info[chain];
  _crc_ = 0;
  crc = CRC16(buf, 0xFEu);
  array_read_bytes(0xFEu, (uint8_t *)&_crc_, chain, 2u);
  if ( (unsigned __int16)(crc << 8) == (_crc_ & 0xFF00)
    && (unsigned __int16)(_crc_ << 8) == (crc & 0xFF00)
    && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: CAUTION: seems high/low bytes reversed\n",
        "eeprom.c",
        287,
        (const char *)_FUNCTION___12398);
    fclose(pFile);
  }
  if ( crc != _crc_ && log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: chain [%d] CRC error: 0x%x != 0x%x\n",
        "eeprom.c",
        292,
        (const char *)_FUNCTION___12398,
        chain,
        crc,
        _crc_);
    fclose(pFile_0);
  }
  return crc == _crc_;
}

//----- (0006D480) --------------------------------------------------------
eeprom_store_t *__cdecl read_eeprom_store_from_at24c02(eeprom_store_t *eeprom_store, uint8_t chain)
{
  eeprom_store->magic_num = array_read_one_byte(0, chain);
  eeprom_store->chain_volt = array_read_one_byte(1u, chain);
  array_read_bytes(2u, eeprom_store->chain_freq_data, chain, 0x3Cu);
  array_read_bytes(0x6Eu, eeprom_store->hash_rate, chain, 4u);
  if ( eeprom_target_eeprom_version() == eeprom_store->magic_num )
  {
    eeprom_store->chain_volt_mode2 = array_read_one_byte(0x87u, chain);
    array_read_bytes(0x88u, eeprom_store->chain_freq_data_mode2, chain, 0x3Cu);
    array_read_bytes(0xF4u, eeprom_store->hash_rate_mode2, chain, 4u);
  }
  return eeprom_store;
}

//----- (0006D524) --------------------------------------------------------
bool __cdecl eeprom_set_freq(uint8_t chain, uint32_t *buf, uint8_t mode)
{
  uint8_t v3; // r3
  uint8_t send_buf[60]; // [sp+10h] [bp+8h] BYREF
  FILE *pFile; // [sp+4Ch] [bp+44h]
  uint8_t freq_addr; // [sp+53h] [bp+4Bh]
  int i; // [sp+54h] [bp+4Ch]

  memset(send_buf, 0, sizeof(send_buf));
  for ( i = 0; i <= 59; ++i )
  {
    if ( buf[i] % 5 && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: ** warning: freq is not multiple of %d **\n",
          "eeprom.c",
          355,
          (const char *)_FUNCTION___12422_0,
          5);
      fclose(pFile);
    }
    send_buf[i] = buf[i] / 5;
  }
  if ( mode == 1 )
    v3 = -120;
  else
    v3 = 2;
  freq_addr = v3;
  array_write_bytes(v3, send_buf, chain, 0x3Cu);
  return array_update_crc(chain);
}

//----- (0006D640) --------------------------------------------------------
bool __cdecl eeprom_set_freq(uint8_t chain, uint32_t *buf)
{
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_write_buf_valid((uint8_t *)buf) )
    return 0;
  return eeprom_set_freq(chain, buf, 0);
}

//----- (0006D690) --------------------------------------------------------
bool __cdecl eeprom_set_freq_mode1(uint8_t chain, uint32_t *buf)
{
  return eeprom_set_freq(chain, buf);
}

//----- (0006D6B0) --------------------------------------------------------
bool __cdecl eeprom_set_freq_mode2(uint8_t chain, uint32_t *buf)
{
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_write_buf_valid((uint8_t *)buf) )
    return 0;
  return eeprom_set_freq(chain, buf, 1u);
}

//----- (0006D700) --------------------------------------------------------
bool __cdecl eeprom_get_freq(uint8_t chain, uint32_t *buf, uint8_t mode)
{
  unsigned __int8 v3; // r3
  int i; // [sp+14h] [bp+14h]

  if ( mode == 1 )
    v3 = -120;
  else
    v3 = 2;
  for ( i = 0; i <= 59; ++i )
    buf[i] = 5 * eeprom_info[chain][i + v3];
  return 1;
}

//----- (0006D774) --------------------------------------------------------
bool __cdecl eeprom_get_freq(uint8_t chain, uint32_t *buf)
{
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_read_buf_valid((uint8_t *)buf) )
    return 0;
  return eeprom_get_freq(chain, buf, 0);
}

//----- (0006D7C4) --------------------------------------------------------
bool __cdecl eeprom_get_freq_mode1(uint8_t chain, uint32_t *buf)
{
  return eeprom_get_freq(chain, buf);
}

//----- (0006D7E4) --------------------------------------------------------
bool __cdecl eeprom_get_freq_mode2(uint8_t chain, uint32_t *buf)
{
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_read_buf_valid((uint8_t *)buf) )
    return 0;
  return eeprom_get_freq(chain, buf, 1u);
}

//----- (0006D838) --------------------------------------------------------
bool __cdecl eeprom_set_voltage(uint8_t chain, double voltage, uint8_t mode)
{
  uint8_t v3; // r1
  double v4; // d0
  float v5; // s15
  uint8_t v6; // r3
  uint8_t modea; // [sp+Eh] [bp+Eh]

  modea = v3;
  ((void (__fastcall *)(uint8_t))roundf)(chain);
  if ( modea == 1 )
    v6 = -121;
  else
    v6 = 1;
  v5 = v4 * 100.0;
  array_write_one_byte(v6, (unsigned int)(float)((float)(v5 / 2.0) - 300.0), chain);
  return array_update_crc(chain);
}
// 6D84A: variable 'v3' is possibly undefined
// 6D854: variable 'v4' is possibly undefined
// 1257C: using guessed type int __fastcall roundf(_DWORD, _DWORD);

//----- (0006D8BC) --------------------------------------------------------
bool __cdecl eeprom_set_voltage(uint8_t chain, double voltage)
{
  uint8_t v2; // d0.b[0]
  double v3; // r2

  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  HIDWORD(v3) = chain;
  return eeprom_set_voltage(chain, v3, v2);
}
// 6D8EC: variable 'v3' is possibly undefined
// 6D8EC: variable 'v2' is possibly undefined

//----- (0006D8FA) --------------------------------------------------------
bool __cdecl eeprom_set_voltage_mode1(uint8_t chain, double voltage)
{
  HIDWORD(voltage) = chain;
  return eeprom_set_voltage(chain, voltage);
}

//----- (0006D91E) --------------------------------------------------------
bool __cdecl eeprom_set_voltage_mode2(uint8_t chain, double voltage)
{
  uint8_t v2; // d0.b[0]
  double v3; // r2

  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  HIDWORD(v3) = chain;
  return eeprom_set_voltage(chain, v3, v2);
}
// 6D94E: variable 'v3' is possibly undefined
// 6D94E: variable 'v2' is possibly undefined

//----- (0006D960) --------------------------------------------------------
bool __cdecl eeprom_get_voltage(uint8_t chain, double *voltage, uint8_t mode)
{
  uint8_t v3; // r3
  uint32_t vol; // [sp+Ch] [bp+Ch]

  if ( mode == 1 )
    v3 = -121;
  else
    v3 = 1;
  vol = array_read_one_byte(v3, chain);
  *voltage = ((double)(vol + 300) + (double)(vol + 300)) / 100.0;
  return 1;
}

//----- (0006D9C8) --------------------------------------------------------
bool __cdecl eeprom_get_voltage(uint8_t chain, double *voltage)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_get_voltage(chain, voltage, 0);
}

//----- (0006DA02) --------------------------------------------------------
bool __cdecl eeprom_get_voltage_mode1(uint8_t chain, double *voltage)
{
  return eeprom_get_voltage(chain, voltage);
}

//----- (0006DA22) --------------------------------------------------------
bool __cdecl eeprom_get_voltage_mode2(uint8_t chain, double *voltage)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_get_voltage(chain, voltage, 1u);
}

//----- (0006DA5C) --------------------------------------------------------
bool __cdecl eeprom_set_hashrate(uint8_t chain, uint32_t hash, uint8_t mode)
{
  uint8_t v3; // r3
  uint8_t hash_rate[4]; // [sp+Ch] [bp+Ch] BYREF
  uint8_t hash_addr; // [sp+13h] [bp+13h]
  int i; // [sp+14h] [bp+14h]

  i = 0;
  *(_DWORD *)hash_rate = hash;
  if ( mode == 1 )
    v3 = -12;
  else
    v3 = 110;
  hash_addr = v3;
  for ( i = 0; (unsigned int)i <= 3; ++i )
    array_write_one_byte(hash_addr + i, hash_rate[i], chain);
  return array_update_crc(chain);
}

//----- (0006DAE0) --------------------------------------------------------
bool __cdecl eeprom_set_hashrate(uint8_t chain, uint32_t hash)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_set_hashrate(chain, hash, 0);
}

//----- (0006DB1A) --------------------------------------------------------
bool __cdecl eeprom_set_hashrate_mode1(uint8_t chain, uint32_t hash)
{
  return eeprom_set_hashrate(chain, hash);
}

//----- (0006DB3A) --------------------------------------------------------
bool __cdecl eeprom_set_hashrate_mode2(uint8_t chain, uint32_t hash)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_set_hashrate(chain, hash, 1u);
}

//----- (0006DB74) --------------------------------------------------------
bool __cdecl eeprom_get_hashrate(uint8_t chain, uint32_t *hash, uint8_t mode)
{
  uint8_t v3; // r3
  uint8_t hash_rate[4]; // [sp+Ch] [bp+Ch] BYREF
  uint8_t hash_addr; // [sp+13h] [bp+13h]
  int i; // [sp+14h] [bp+14h]

  *(_DWORD *)hash_rate = 0;
  if ( mode == 1 )
    v3 = -12;
  else
    v3 = 110;
  hash_addr = v3;
  for ( i = 0; (unsigned int)i <= 3; ++i )
    hash_rate[i] = array_read_one_byte(hash_addr + i, chain);
  *hash = hash_rate[0] + (hash_rate[1] << 8) + (hash_rate[2] << 16) + (hash_rate[3] << 24);
  return 1;
}

//----- (0006DBF4) --------------------------------------------------------
bool __cdecl eeprom_get_hashrate(uint8_t chain, uint32_t *hash)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_get_hashrate(chain, hash, 0);
}

//----- (0006DC2E) --------------------------------------------------------
bool __cdecl eeprom_get_hashrate_mode1(uint8_t chain, uint32_t *hash)
{
  return eeprom_get_hashrate(chain, hash);
}

//----- (0006DC4E) --------------------------------------------------------
bool __cdecl eeprom_get_hashrate_mode2(uint8_t chain, uint32_t *hash)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_get_hashrate(chain, hash, 1u);
}

//----- (0006DC88) --------------------------------------------------------
void __cdecl dump_freq_data(uint8_t chain, uint32_t *freq)
{
  FILE *pFile_0; // [sp+Ch] [bp+Ch]
  FILE *pFile_1; // [sp+10h] [bp+10h]
  FILE *pFile; // [sp+14h] [bp+14h]
  int k; // [sp+18h] [bp+18h]
  int l; // [sp+1Ch] [bp+1Ch]

  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "chain [%d] freq data per ASIC:\n", chain);
    fclose(pFile);
  }
  for ( l = 0; l <= 5; ++l )
  {
    for ( k = 0; k <= 9; ++k )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "IC[%03d]:%d ", 60 * l / 6 + k, freq[k + 60 * l / 6]);
        fclose(pFile_0);
      }
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fputc(10, pFile_1);
      fclose(pFile_1);
    }
  }
}

//----- (0006DDD8) --------------------------------------------------------
void __cdecl travel_eeprom_store(uint8_t chain, bool debug)
{
  uint8_t bom_version_t; // [sp+12h] [bp+Ah] BYREF
  uint8_t pcb_version_t; // [sp+13h] [bp+Bh] BYREF
  char temp_sensor_data[6]; // [sp+14h] [bp+Ch] BYREF
  char temp_sensor_pos[6]; // [sp+1Ch] [bp+14h] BYREF
  uint32_t temp_sensor_num; // [sp+24h] [bp+1Ch] BYREF
  TEMP_SENSOR_TYPE temp_sensor_type_t; // [sp+28h] [bp+20h] BYREF
  FILE *pFile; // [sp+2Ch] [bp+24h]
  FILE *pFile_5; // [sp+30h] [bp+28h]
  FILE *pFile_6; // [sp+34h] [bp+2Ch]
  FILE *pFile_19; // [sp+38h] [bp+30h]
  FILE *pFile_22; // [sp+3Ch] [bp+34h]
  FILE *pFile_23; // [sp+40h] [bp+38h]
  FILE *pFile_21; // [sp+44h] [bp+3Ch]
  FILE *pFile_20; // [sp+48h] [bp+40h]
  FILE *pFile_18; // [sp+4Ch] [bp+44h]
  FILE *pFile_17; // [sp+50h] [bp+48h]
  FILE *pFile_16; // [sp+54h] [bp+4Ch]
  FILE *pFile_11; // [sp+58h] [bp+50h]
  FILE *pFile_12; // [sp+5Ch] [bp+54h]
  FILE *pFile_15; // [sp+60h] [bp+58h]
  FILE *pFile_14; // [sp+64h] [bp+5Ch]
  FILE *pFile_13; // [sp+68h] [bp+60h]
  FILE *pFile_10; // [sp+6Ch] [bp+64h]
  uint32_t hash_rate_mode2_t; // [sp+70h] [bp+68h]
  FILE *pFile_9; // [sp+74h] [bp+6Ch]
  FILE *pFile_8; // [sp+78h] [bp+70h]
  FILE *pFile_7; // [sp+7Ch] [bp+74h]
  FILE *pFile_4; // [sp+80h] [bp+78h]
  FILE *pFile_3; // [sp+84h] [bp+7Ch]
  FILE *pFile_2; // [sp+88h] [bp+80h]
  FILE *pFile_1; // [sp+8Ch] [bp+84h]
  FILE *pFile_0; // [sp+90h] [bp+88h]
  uint32_t hast_rate; // [sp+94h] [bp+8Ch]
  eeprom_store_t *eeprom; // [sp+98h] [bp+90h]
  int i; // [sp+9Ch] [bp+94h]
  int l; // [sp+A0h] [bp+98h]
  int k; // [sp+A4h] [bp+9Ch]

  k = 0;
  l = 0;
  hast_rate = 0;
  eeprom = (eeprom_store_t *)malloc(0x83u);
  if ( eeprom )
  {
    memset(eeprom, 0, sizeof(eeprom_store_t));
    eeprom = read_eeprom_store_from_at24c02(eeprom, chain);
    temp_sensor_type_t = 0;
    temp_sensor_num = 0;
    memset(temp_sensor_pos, 0, sizeof(temp_sensor_pos));
    memset(temp_sensor_data, 0, sizeof(temp_sensor_data));
    pcb_version_t = 0;
    bom_version_t = 0;
    i = 0;
    if ( debug )
    {
      eeprom_get_pcb_version(chain, &pcb_version_t);
      eeprom_get_bom_version(chain, &bom_version_t);
      eeprom_get_temp_sensor_type(chain, &temp_sensor_type_t);
      eeprom_get_temp_sensor_pos(chain, (uint8_t *)temp_sensor_pos, &temp_sensor_num);
      eeprom_get_temp_sensor_data(chain, (uint8_t *)temp_sensor_data, &temp_sensor_num);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain[%d] data in eeprom is:\n",
          "eeprom.c",
          634,
          (const char *)_FUNCTION___12570,
          chain);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "magic number: 0x%02x\n", eeprom->magic_num);
      fclose(pFile_1);
    }
    if ( debug )
    {
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, "pcb version: 0x%02x\n", pcb_version_t);
        fclose(pFile_2);
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(pFile_3, "bom version: 0x%02x\n", bom_version_t);
        fclose(pFile_3);
      }
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fwrite("freq data per ASIC:\n", 1u, 0x14u, pFile_4);
      fclose(pFile_4);
    }
    for ( l = 0; l <= 5; ++l )
    {
      for ( k = 0; k <= 9; ++k )
      {
        if ( log_level > 3 )
        {
          pFile_5 = fopen((const char *)log_file, "a+");
          if ( pFile_5 )
            fprintf(pFile_5, "IC[%03d]:%d ", 60 * l / 6 + k, 5 * eeprom->chain_freq_data[k + 60 * l / 6]);
          fclose(pFile_5);
        }
      }
      if ( log_level > 3 )
      {
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fputc(10, pFile_6);
        fclose(pFile_6);
      }
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "voltage: %.02f V\n", (float)((float)(2 * ((unsigned int)eeprom->chain_volt + 300)) / 100.0));
      fclose(pFile_7);
    }
    hast_rate = (eeprom->hash_rate[3] << 24)
              + eeprom->hash_rate[0]
              + (eeprom->hash_rate[1] << 8)
              + (eeprom->hash_rate[2] << 16);
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "hash rate: %05d GH/s\n", hast_rate);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fputc(10, pFile_9);
      fclose(pFile_9);
    }
    if ( eeprom_target_eeprom_version() == eeprom->magic_num )
    {
      hash_rate_mode2_t = 0;
      if ( log_level > 3 )
      {
        pFile_10 = fopen((const char *)log_file, "a+");
        if ( pFile_10 )
          fwrite("freq data per ASIC in mode2:\n", 1u, 0x1Du, pFile_10);
        fclose(pFile_10);
      }
      for ( l = 0; l <= 5; ++l )
      {
        for ( k = 0; k <= 9; ++k )
        {
          if ( log_level > 3 )
          {
            pFile_11 = fopen((const char *)log_file, "a+");
            if ( pFile_11 )
              fprintf(pFile_11, "IC[%03d]:%d ", 60 * l / 6 + k, 5 * eeprom->chain_freq_data_mode2[k + 60 * l / 6]);
            fclose(pFile_11);
          }
        }
        if ( log_level > 3 )
        {
          pFile_12 = fopen((const char *)log_file, "a+");
          if ( pFile_12 )
            fputc(10, pFile_12);
          fclose(pFile_12);
        }
      }
      if ( log_level > 3 )
      {
        pFile_13 = fopen((const char *)log_file, "a+");
        if ( pFile_13 )
          fprintf(
            pFile_13,
            "voltage in mode2: %.02f V\n",
            (float)((float)(2 * ((unsigned int)eeprom->chain_volt_mode2 + 300)) / 100.0));
        fclose(pFile_13);
      }
      hash_rate_mode2_t = (eeprom->hash_rate_mode2[3] << 24)
                        + eeprom->hash_rate_mode2[0]
                        + (eeprom->hash_rate_mode2[1] << 8)
                        + (eeprom->hash_rate_mode2[2] << 16);
      if ( log_level > 3 )
      {
        pFile_14 = fopen((const char *)log_file, "a+");
        if ( pFile_14 )
          fprintf(pFile_14, "hash rate in mode2: %05d GH/s\n", hash_rate_mode2_t);
        fclose(pFile_14);
      }
      if ( log_level > 3 )
      {
        pFile_15 = fopen((const char *)log_file, "a+");
        if ( pFile_15 )
          fputc(10, pFile_15);
        fclose(pFile_15);
      }
    }
    if ( debug )
    {
      if ( log_level > 3 )
      {
        pFile_16 = fopen((const char *)log_file, "a+");
        if ( pFile_16 )
          fprintf(pFile_16, "TEMP SENSOR TYPE: %d \n", temp_sensor_type_t);
        fclose(pFile_16);
      }
      if ( log_level > 3 )
      {
        pFile_17 = fopen((const char *)log_file, "a+");
        if ( pFile_17 )
          fprintf(pFile_17, "TEMP SENSOR NUM: %d \n", temp_sensor_num);
        fclose(pFile_17);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_18 = fopen((const char *)log_file, "a+");
        if ( pFile_18 )
          fprintf(pFile_18, "%s:%d:%s: sensor pos =", "eeprom.c", 685, (const char *)_FUNCTION___12570);
        fclose(pFile_18);
      }
      for ( i = 0; i < temp_sensor_num; ++i )
      {
        if ( log_level > 3 )
        {
          pFile_19 = fopen((const char *)log_file, "a+");
          if ( pFile_19 )
            fprintf(pFile_19, " %d ", temp_sensor_pos[i]);
          fclose(pFile_19);
        }
      }
      if ( log_level > 3 )
      {
        pFile_20 = fopen((const char *)log_file, "a+");
        if ( pFile_20 )
          fputc(10, pFile_20);
        fclose(pFile_20);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_21 = fopen((const char *)log_file, "a+");
        if ( pFile_21 )
          fprintf(pFile_21, "%s:%d:%s: sensor offset =", "eeprom.c", 691, (const char *)_FUNCTION___12570);
        fclose(pFile_21);
      }
      for ( i = 0; i < temp_sensor_num; ++i )
      {
        if ( log_level > 3 )
        {
          pFile_22 = fopen((const char *)log_file, "a+");
          if ( pFile_22 )
            fprintf(pFile_22, " %d ", temp_sensor_data[i]);
          fclose(pFile_22);
        }
      }
      if ( log_level > 3 )
      {
        pFile_23 = fopen((const char *)log_file, "a+");
        if ( pFile_23 )
          fputc(10, pFile_23);
        fclose(pFile_23);
      }
    }
    if ( eeprom )
      free(eeprom);
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: fetal error: failed to allocate memory for eeprom!\n",
          "eeprom.c",
          611,
          (const char *)_FUNCTION___12570);
      fclose(pFile);
    }
    eeprom = 0;
  }
}

//----- (0006E858) --------------------------------------------------------
void eeprom_dump()
{
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
      travel_eeprom_store(i, 0);
  }
}

//----- (0006E89E) --------------------------------------------------------
void eeprom_dump_for_debug()
{
  int i; // [sp+4h] [bp+4h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
      travel_eeprom_store(i, 1);
  }
}

//----- (0006E8E4) --------------------------------------------------------
bool __cdecl eeprom_write_full_length(uint8_t chain, uint8_t *buf)
{
  uint8_t receive_buf[256]; // [sp+8h] [bp+8h] BYREF

  if ( !is_chain_existed(chain) )
    return 0;
  if ( !is_eeprom_write_buf_valid(buf) )
    return 0;
  memset(receive_buf, 0, sizeof(receive_buf));
  pthread_mutex_lock(&iic_mutex);
  eeprom_write_bytes(0, buf, chain, 0x100u);
  usleep(0x2710u);
  eeprom_read_bytes(0, receive_buf, chain, 0x100u);
  pthread_mutex_unlock(&iic_mutex);
  return memcmp(buf, receive_buf, 0x100u) == 0;
}

//----- (0006E9A2) --------------------------------------------------------
bool __cdecl eeprom_read(uint8_t chain, uint32_t addr, uint8_t *buf, uint32_t len)
{
  if ( !is_chain_existed(chain) )
    return 0;
  if ( !is_eeprom_address_valid(addr, len) )
    return 0;
  if ( !is_eeprom_read_buf_valid(buf) )
    return 0;
  pthread_mutex_lock(&iic_mutex);
  eeprom_read_bytes(addr, buf, chain, len);
  usleep(0x2710u);
  pthread_mutex_unlock(&iic_mutex);
  return 1;
}

//----- (0006EA30) --------------------------------------------------------
bool __cdecl eeprom_set_inbalance_info(uint8_t chain, uint8_t *buf, uint32_t len)
{
  FILE *pFile; // [sp+1Ch] [bp+14h]

  if ( len <= 4 )
  {
    if ( !is_eeprom_chain_load_succeeded(chain) )
    {
      return 0;
    }
    else
    {
      array_write_one_byte(0x72u, len, chain);
      array_write_bytes(0x73u, buf, chain, len);
      return array_update_crc(chain);
    }
  }
  else
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: inbalance data are more than %d\n",
          "eeprom.c",
          858,
          (const char *)_FUNCTION___12683,
          4);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (0006EAFA) --------------------------------------------------------
bool __cdecl eeprom_get_pcb_version(uint8_t chain, uint8_t *pcb_version)
{
  *pcb_version = array_read_one_byte(0xFCu, chain);
  return 1;
}

//----- (0006EB22) --------------------------------------------------------
bool __cdecl eeprom_get_pcb_version(uint8_t chain, uint8_t *pcb_version)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_get_pcb_version(chain, pcb_version);
}

//----- (0006EB5A) --------------------------------------------------------
bool __cdecl eeprom_get_bom_version(uint8_t chain, uint8_t *bom_version)
{
  *bom_version = array_read_one_byte(0xFDu, chain);
  return 1;
}

//----- (0006EB82) --------------------------------------------------------
bool __cdecl eeprom_get_bom_version(uint8_t chain, uint8_t *bom_version)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_get_bom_version(chain, bom_version);
}

//----- (0006EBBA) --------------------------------------------------------
bool __cdecl eeprom_get_chip_major_type(uint8_t chain, CHIP_MAJOR_TYPE *type)
{
  chip_info_t chip_info; // [sp+8h] [bp+8h] BYREF
  uint8_t *p; // [sp+Ch] [bp+Ch]

  memset(&chip_info, 0, sizeof(chip_info));
  p = (uint8_t *)&chip_info;
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  *p = array_read_one_byte(0xF8u, chain);
  *type = *(_BYTE *)&chip_info & 7;
  return 1;
}

//----- (0006EC1C) --------------------------------------------------------
bool __cdecl eeprom_get_chip_minor_type(uint8_t chain, CHIP_MINOR_TYPE *type)
{
  chip_info_t chip_info; // [sp+8h] [bp+8h] BYREF
  uint8_t *p; // [sp+Ch] [bp+Ch]

  memset(&chip_info, 0, sizeof(chip_info));
  p = (uint8_t *)&chip_info;
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  *p = array_read_one_byte(0xF8u, chain);
  *type = (*(unsigned __int8 *)&chip_info >> 3) & 7;
  return 1;
}

//----- (0006EC7E) --------------------------------------------------------
bool __cdecl eeprom_get_chip_level(uint8_t chain, CHIP_LEVEL *level)
{
  chip_info_t chip_info; // [sp+8h] [bp+8h] BYREF
  uint8_t *p; // [sp+Ch] [bp+Ch]

  memset(&chip_info, 0, sizeof(chip_info));
  p = (uint8_t *)&chip_info;
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  *p = array_read_one_byte(0xF8u, chain);
  *level = *(unsigned __int8 *)&chip_info >> 6;
  return 1;
}

//----- (0006ECE0) --------------------------------------------------------
bool __cdecl eeprom_get_temp_sensor_type(uint8_t chain, TEMP_SENSOR_TYPE *type)
{
  *type = array_read_one_byte(0x79u, chain);
  return 1;
}

//----- (0006ED08) --------------------------------------------------------
bool __cdecl eeprom_get_temp_sensor_type(uint8_t chain, TEMP_SENSOR_TYPE *type)
{
  return is_eeprom_chain_load_succeeded(chain) && eeprom_get_temp_sensor_type(chain, type);
}

//----- (0006ED40) --------------------------------------------------------
bool __cdecl eeprom_set_temp_sensor_type(uint8_t chain, TEMP_SENSOR_TYPE type)
{
  uint8_t typea; // [sp+0h] [bp+0h]

  typea = type;
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  array_write_one_byte(0x79u, typea, chain);
  return array_update_crc(chain);
}

//----- (0006ED84) --------------------------------------------------------
bool __cdecl eeprom_set_temp_sensor_num(uint8_t chain, uint8_t num)
{
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  array_write_one_byte(0x7Bu, num, chain);
  return array_update_crc(chain);
}

//----- (0006EDCA) --------------------------------------------------------
bool __cdecl eeprom_set_temp_sensor_data(uint8_t chain, uint8_t *buf, uint32_t len)
{
  FILE *pFile; // [sp+18h] [bp+10h]
  unsigned int i; // [sp+1Ch] [bp+14h]

  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_write_buf_valid(buf) )
    return 0;
  if ( len <= 6 )
  {
    array_write_one_byte(0x7Au, len, chain);
    for ( i = 0; len > i; ++i )
      array_write_one_byte(2 * (i + 62), buf[i], chain);
    return array_update_crc(chain);
  }
  else
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: temperature data are more than %d\n",
          "eeprom.c",
          1106,
          (const char *)_FUNCTION___12779,
          6);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (0006EED0) --------------------------------------------------------
bool __cdecl eeprom_get_temp_sensor_data(uint8_t chain, uint8_t *buf, uint32_t *len)
{
  FILE *pFile; // [sp+20h] [bp+10h]
  unsigned int i; // [sp+24h] [bp+14h]

  *len = array_read_one_byte(0x7Au, chain);
  if ( *len <= 6 )
  {
    for ( i = 0; *len > i; ++i )
      buf[i] = array_read_one_byte(2 * (i + 62), chain);
    return 1;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: chain[%d] temperature data num %d read, is more than MAX_OFFSET %d\n",
          "eeprom.c",
          1123,
          (const char *)_FUNCTION___12790,
          chain,
          *len,
          6);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (0006EFB4) --------------------------------------------------------
bool __cdecl eeprom_get_temp_sensor_data(uint8_t chain, uint8_t *buf, uint32_t *len)
{
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_read_buf_valid(buf) )
    return 0;
  return eeprom_get_temp_sensor_data(chain, buf, len);
}

//----- (0006F006) --------------------------------------------------------
bool __cdecl eeprom_set_temp_sensor_pos(uint8_t chain, uint8_t *buf, uint32_t len)
{
  FILE *pFile; // [sp+18h] [bp+10h]
  unsigned int i; // [sp+1Ch] [bp+14h]

  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_write_buf_valid(buf) )
    return 0;
  if ( len <= 6 )
  {
    array_write_one_byte(0x7Au, len, chain);
    for ( i = 0; len > i; ++i )
      array_write_one_byte(2 * i + 123, buf[i], chain);
    return array_update_crc(chain);
  }
  else
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: position data are more than %d\n",
          "eeprom.c",
          1161,
          (const char *)_FUNCTION___12806,
          6);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (0006F10E) --------------------------------------------------------
bool __cdecl eeprom_get_temp_sensor_pos(uint8_t chain, uint8_t *buf, uint32_t *len)
{
  FILE *pFile; // [sp+20h] [bp+10h]
  unsigned int i; // [sp+24h] [bp+14h]

  *len = array_read_one_byte(0x7Au, chain);
  if ( *len <= 6 )
  {
    for ( i = 0; *len > i; ++i )
      buf[i] = array_read_one_byte(2 * i + 123, chain);
    return 1;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: chain[%d] temp position data num %d read, is more than MAX_OFFSET %d\n",
          "eeprom.c",
          1178,
          (const char *)_FUNCTION___12817,
          chain,
          *len,
          6);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (0006F1F4) --------------------------------------------------------
bool __cdecl eeprom_get_temp_sensor_pos(uint8_t chain, uint8_t *buf, uint32_t *len)
{
  if ( !is_eeprom_chain_load_succeeded(chain) )
    return 0;
  if ( !is_eeprom_read_buf_valid(buf) )
    return 0;
  return eeprom_get_temp_sensor_pos(chain, buf, len);
}

//----- (0006F246) --------------------------------------------------------
int eeprom_load()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  bool load_flaga; // [sp+13h] [bp+Bh]
  bool load_flag; // [sp+13h] [bp+Bh]
  int i; // [sp+14h] [bp+Ch]
  bool ret; // [sp+1Bh] [bp+13h]
  int try_time; // [sp+1Ch] [bp+14h]

  if ( state_is_eeprom_all_chain_load_succeeded )
    return 1;
  ret = 1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      try_time = 0;
      do
      {
        load_flaga = eeprom_read(i, 0, eeprom_info[i], 0x100u);
        load_flag = (load_flaga & array_check_crc(i)) != 0;
        ++try_time;
      }
      while ( try_time <= 3 && !load_flag );
      if ( !load_flag )
      {
        freq_scan_error_code_set(3, i);
        eeprom_dump_for_debug();
        state_is_eeprom_chain_load_succeeded[i] = 0;
        dev->chain_exist[i] = 0;
        --dev->chain_num;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: warning: in chain [%d], eeprom crc doesn't match with eeprom data. \n",
              "eeprom.c",
              1253,
              (const char *)_FUNCTION___12842,
              i);
          fclose(pFile);
        }
        ret = 0;
      }
      else
      {
        state_is_eeprom_chain_load_succeeded[i] = 1;
      }
    }
    else
    {
      state_is_eeprom_chain_load_succeeded[i] = 0;
    }
  }
  memset(eeprom_dirty_flag, 0, sizeof(eeprom_dirty_flag));
  state_is_eeprom_all_chain_load_succeeded = 1;
  return ret;
}

//----- (0006F406) --------------------------------------------------------
int eeprom_save()
{
  FILE *pFile; // [sp+Ch] [bp+4h]
  FILE *pFile_0; // [sp+10h] [bp+8h]
  FILE *pFile_1; // [sp+14h] [bp+Ch]
  uint8_t magic_num; // [sp+1Ah] [bp+12h]
  bool save_flag; // [sp+1Bh] [bp+13h]
  int j; // [sp+1Ch] [bp+14h]
  int i; // [sp+20h] [bp+18h]
  int try_time; // [sp+24h] [bp+1Ch]

  if ( !state_is_eeprom_all_chain_load_succeeded )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "Assert fail!! %s:%d: warning: eeprom data hasnot been loaded into dram \n!", "eeprom.c", 1271);
    fclose(pFile);
    _assert_fail("0", "eeprom.c", 0x4F7u, (const char *)_PRETTY_FUNCTION___12850);
  }
  for ( i = 0; ; ++i )
  {
    if ( i > 15 )
    {
      memset(eeprom_info, 0, sizeof(eeprom_info));
      for ( j = 0; j <= 15; ++j )
        state_is_eeprom_chain_load_succeeded[j] = 0;
      state_is_eeprom_all_chain_load_succeeded = 0;
      return 1;
    }
    if ( dev->chain_exist[i] )
    {
      try_time = 0;
      magic_num = array_read_one_byte(0, i);
      if ( magic_num != eeprom_target_eeprom_version() )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: Warning, eeprom magic:%d number is wrong!\n",
              "eeprom.c",
              1290,
              (const char *)_FUNCTION___12858,
              magic_num);
          fclose(pFile_0);
        }
        eeprom_dump_for_debug();
        freq_scan_error_code_set(3, i);
        return 0;
      }
      do
      {
        save_flag = eeprom_write_full_length(i, eeprom_info[i]);
        ++try_time;
      }
      while ( try_time <= 3 && !save_flag );
      if ( !save_flag )
        break;
    }
  }
  eeprom_dump_for_debug();
  freq_scan_error_code_set(3, i);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: eeprom [%d] save fail! Please check the eeprom chip. \n",
        "eeprom.c",
        1306,
        (const char *)_FUNCTION___12858,
        i);
    fclose(pFile_1);
  }
  return 0;
}

//----- (0006F674) --------------------------------------------------------
bool __cdecl check_freq_valid_single(uint32_t freq, uint32_t valid_max_freq)
{
  return freq <= valid_max_freq;
}

//----- (0006F698) --------------------------------------------------------
int eeprom_target_eeprom_version()
{
  return 125;
}

//----- (0006F6A8) --------------------------------------------------------
bool __cdecl check_freq_valid(uint32_t *freq_buf, uint32_t len, uint32_t valid_max_freq)
{
  unsigned int i; // [sp+14h] [bp+14h]

  for ( i = 0; len > i; ++i )
  {
    if ( freq_buf[i] > valid_max_freq + 1 )
      return 0;
  }
  return 1;
}

//----- (0006F6F6) --------------------------------------------------------
void __cdecl mutex_init_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0006F774) --------------------------------------------------------
void __cdecl rwlock_init_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp+10h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0006F7F2) --------------------------------------------------------
void __cdecl cglock_init_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init_2(&lock->mutex, file, func, line);
  rwlock_init_1(&lock->rwlock, file, func, line);
}

//----- (0006F824) --------------------------------------------------------
void __cdecl k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+34h] [bp+14h] BYREF
  int i; // [sp+834h] [bp+814h]
  int allocate; // [sp+838h] [bp+818h]
  K_ITEM *item; // [sp+83Ch] [bp+81Ch]

  if ( list->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___10443,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___10443,
      20);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( list->limit <= 0 || list->total < list->limit )
  {
    allocate = list->allocate;
    if ( list->limit > 0 && list->total + allocate > list->limit )
      allocate = list->limit - list->total;
    ++list->item_mem_count;
    list->item_memory = (void **)realloc(list->item_memory, 4 * list->item_mem_count);
    if ( !list->item_memory )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s item_memory failed to realloc count=%d in %s %s():%d",
        (const char *)list->name,
        list->item_mem_count,
        "klist.c",
        (const char *)_func___10443,
        35);
      applog(3, tmp42, 1);
      quit(1);
    }
    item = (K_ITEM *)calloc(allocate, 0x10u);
    if ( !item )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
        (const char *)list->name,
        allocate,
        list->total,
        list->limit,
        "klist.c",
        (const char *)_func___10443,
        41);
      applog(3, tmp42, 1);
      quit(1);
    }
    DWORD1073741823(list->item_memory[list->item_mem_count]) = item;
    list->total += allocate;
    list->count = allocate;
    list->count_up = allocate;
    item->name = list->name;
    item->prev = 0;
    item->next = item + 1;
    for ( i = 1; i < allocate - 1; ++i )
    {
      item[i].name = list->name;
      item[i].prev = &item[i - 1];
      item[i].next = &item[i + 1];
    }
    item[allocate - 1].name = list->name;
    item[allocate - 1].prev = &item[allocate - 2];
    item[allocate - 1].next = 0;
    list->head = item;
    if ( list->do_tail )
      list->tail = &item[allocate - 1];
    for ( item = list->head; item; item = item->next )
    {
      ++list->data_mem_count;
      list->data_memory = (void **)realloc(list->data_memory, 4 * list->data_mem_count);
      if ( !list->data_memory )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "List %s data_memory failed to realloc count=%d in %s %s():%d",
          (const char *)list->name,
          list->data_mem_count,
          "klist.c",
          (const char *)_func___10443,
          75);
        applog(3, tmp42, 1);
        quit(1);
      }
      item->data = calloc(1u, list->siz);
      if ( !item->data )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "List %s failed to calloc item data in %s %s():%d",
          (const char *)list->name,
          "klist.c",
          (const char *)_func___10443,
          79);
        applog(3, tmp42, 1);
        quit(1);
      }
      DWORD1073741823(list->data_memory[list->data_mem_count]) = item->data;
    }
  }
}

//----- (0006FCF6) --------------------------------------------------------
K_LIST *__cdecl k_new_list(
        const unsigned __int8 *name,
        size_t siz,
        int allocate,
        int limit,
        bool do_tail,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp+14h] BYREF
  K_LIST *list; // [sp+824h] [bp+814h]

  if ( allocate <= 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      (const char *)name,
      allocate,
      "klist.c",
      (const char *)_func___10472,
      106);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( limit < 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      (const char *)name,
      limit,
      "klist.c",
      (const char *)_func___10472,
      109);
    applog(3, tmp42, 1);
    quit(1);
  }
  list = (K_LIST *)calloc(1u, 0x40u);
  if ( !list )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___10472,
      113);
    applog(3, tmp42, 1);
    quit(1);
  }
  list->is_store = 0;
  list->lock = (cglock_t *)calloc(1u, 0x38u);
  if ( !list->lock )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc lock for list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___10472,
      119);
    applog(3, tmp42, 1);
    quit(1);
  }
  cglock_init_1(list->lock, "klist.c", _func___10472, 121);
  list->name = name;
  list->siz = siz;
  list->allocate = allocate;
  list->limit = limit;
  list->do_tail = do_tail;
  k_alloc_items(list, file, func, line);
  return list;
}

//----- (0006FEF6) --------------------------------------------------------
K_ITEM *__cdecl k_unlink_head(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  k_item *item; // [sp+14h] [bp+14h]

  if ( !list->head && !list->is_store )
    k_alloc_items(list, file, func, line);
  if ( !list->head )
    return 0;
  item = list->head;
  list->head = item->next;
  if ( list->head )
  {
    list->head->prev = 0;
  }
  else if ( list->do_tail )
  {
    list->tail = 0;
  }
  item->next = 0;
  item->prev = item->next;
  --list->count;
  return item;
}

//----- (0006FF84) --------------------------------------------------------
void __cdecl k_add_head(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp+10h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___10507,
      (const char *)item->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___10507,
      214);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = 0;
  item->next = list->head;
  if ( list->head )
    list->head->prev = item;
  list->head = item;
  if ( list->do_tail && !list->tail )
    list->tail = item;
  ++list->count;
  ++list->count_up;
}

//----- (000700BE) --------------------------------------------------------
uint8_t __cdecl write_pic_iic(uint8_t chain, uint8_t data)
{
  if ( is_T11a() && chain_pcb_version[chain] <= 0x20u )
  {
    if ( chain == 1 )
    {
      chain = 2;
    }
    else if ( chain == 2 )
    {
      chain = 1;
    }
  }
  return zynq_set_iic(chain & 7 | 0x20, 0, 0, 0, 0, data);
}

//----- (00070140) --------------------------------------------------------
uint8_t __cdecl read_pic_iic(uint8_t chain)
{
  if ( is_T11a() && chain_pcb_version[chain] <= 0x20u )
  {
    if ( chain == 1 )
    {
      chain = 2;
    }
    else if ( chain == 2 )
    {
      chain = 1;
    }
  }
  return zynq_set_iic(chain & 7 | 0x20, 0, 1, 0, 0, 0);
}

//----- (000701BC) --------------------------------------------------------
void __cdecl send_pic_cmd(uint8_t chain, uint8_t *cmd, uint8_t cmd_len, uint8_t *reply_buf, uint8_t reply_len)
{
  uint16_t crc; // [sp+12h] [bp+12h]
  int32_t i; // [sp+14h] [bp+14h]
  int32_t ia; // [sp+14h] [bp+14h]
  int32_t ib; // [sp+14h] [bp+14h]

  crc = cmd_len + 3;
  for ( i = 0; i < cmd_len; ++i )
    crc += cmd[i];
  pthread_mutex_lock(&iic_mutex);
  write_pic_iic(chain, 0x55u);
  write_pic_iic(chain, 0xAAu);
  write_pic_iic(chain, cmd_len + 3);
  for ( ia = 0; ia < cmd_len; ++ia )
    write_pic_iic(chain, cmd[ia]);
  write_pic_iic(chain, HIBYTE(crc));
  write_pic_iic(chain, crc);
  usleep((__useconds_t)": chain %d down a step of %dM, rate of %dG, current total rate %dG\n");
  for ( ib = 0; ib < reply_len; ++ib )
    reply_buf[ib] = read_pic_iic(chain);
  pthread_mutex_unlock(&iic_mutex);
}

//----- (000702DA) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_reset_pic(uint8_t chain)
{
  uint8_t cmd[1]; // [sp+18h] [bp+8h] BYREF
  uint8_t read_back_data[2]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile_1; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]
  FILE *pFile; // [sp+28h] [bp+18h]
  int retry_count; // [sp+2Ch] [bp+1Ch]

  retry_count = 0;
  cmd[0] = 7;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 1u, read_back_data, 2u);
    if ( read_back_data[0] == 7 && read_back_data[1] == 1 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: chain[%d] ok!\n", "dspic33ep16gs202.c", 153, (const char *)_FUNCTION___11640, chain);
        fclose(pFile);
      }
      return 0;
    }
    if ( retry_count > 2 )
      break;
    sleep(3u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        158,
        (const char *)_FUNCTION___11640,
        chain,
        retry_count);
    fclose(pFile_0);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x\n",
        "dspic33ep16gs202.c",
        159,
        (const char *)_FUNCTION___11640,
        read_back_data[0],
        read_back_data[1]);
    fclose(pFile_1);
  }
  return -1;
}

//----- (00070480) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_jump_to_app_from_loader(uint32_t chain)
{
  uint8_t cmd[1]; // [sp+18h] [bp+8h] BYREF
  uint8_t read_back_data[2]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile_1; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]
  FILE *pFile; // [sp+28h] [bp+18h]
  int retry_count; // [sp+2Ch] [bp+1Ch]

  retry_count = 0;
  cmd[0] = 6;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 1u, read_back_data, 2u);
    if ( read_back_data[0] == 6 && read_back_data[1] == 1 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: chain[%d] ok!\n", "dspic33ep16gs202.c", 180, (const char *)_FUNCTION___11651, chain);
        fclose(pFile);
      }
      return 0;
    }
    if ( retry_count > 2 )
      break;
    dsPIC33EP16GS202_reset_pic(chain);
    sleep(2u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        185,
        (const char *)_FUNCTION___11651,
        chain,
        retry_count);
    fclose(pFile_0);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x\n",
        "dspic33ep16gs202.c",
        186,
        (const char *)_FUNCTION___11651,
        read_back_data[0],
        read_back_data[1]);
    fclose(pFile_1);
  }
  return -1;
}

//----- (00070630) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_pic_heart_beat(uint8_t chain)
{
  uint8_t cmd[1]; // [sp+1Ch] [bp+Ch] BYREF
  uint8_t read_back_data[6]; // [sp+20h] [bp+10h] BYREF
  FILE *pFile_1; // [sp+28h] [bp+18h]
  FILE *pFile_0; // [sp+2Ch] [bp+1Ch]
  FILE *pFile; // [sp+30h] [bp+20h]
  int retry_count; // [sp+34h] [bp+24h]

  retry_count = 0;
  cmd[0] = 22;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 1u, read_back_data, 6u);
    if ( read_back_data[1] == 22 && read_back_data[2] == 1 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: chain[%d] ok!\n", "dspic33ep16gs202.c", 208, (const char *)_FUNCTION___11662, chain);
        fclose(pFile);
      }
      return 0;
    }
    if ( retry_count > 2 )
      break;
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        213,
        (const char *)_FUNCTION___11662,
        chain,
        retry_count);
    fclose(pFile_0);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x\n",
        "dspic33ep16gs202.c",
        214,
        (const char *)_FUNCTION___11662,
        read_back_data[1],
        read_back_data[2]);
    fclose(pFile_1);
  }
  return -1;
}

//----- (000707D6) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_enable_pic_dc_dc(uint8_t chain, uint8_t enable)
{
  uint8_t cmd[2]; // [sp+18h] [bp+8h] BYREF
  uint8_t read_back_data[2]; // [sp+1Ch] [bp+Ch] BYREF
  FILE *pFile_1; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]
  FILE *pFile; // [sp+28h] [bp+18h]
  int retry_count; // [sp+2Ch] [bp+1Ch]

  retry_count = 0;
  cmd[0] = 21;
  cmd[1] = enable;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 2u, read_back_data, 2u);
    if ( read_back_data[0] == 21 && read_back_data[1] == 1 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: chain[%d] ok!\n", "dspic33ep16gs202.c", 237, (const char *)_FUNCTION___11674, chain);
        fclose(pFile);
      }
      return 0;
    }
    if ( retry_count > 2 )
      break;
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        242,
        (const char *)_FUNCTION___11674,
        chain,
        retry_count);
    fclose(pFile_0);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x\n",
        "dspic33ep16gs202.c",
        243,
        (const char *)_FUNCTION___11674,
        read_back_data[0],
        read_back_data[1]);
    fclose(pFile_1);
  }
  return -1;
}

//----- (00070986) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_set_pic_voltage(uint8_t chain, uint8_t pic_voltage)
{
  uint8_t cmd[4]; // [sp+1Ch] [bp+Ch] BYREF
  uint8_t read_back_data[2]; // [sp+20h] [bp+10h] BYREF
  FILE *pFile_1; // [sp+24h] [bp+14h]
  FILE *pFile_0; // [sp+28h] [bp+18h]
  FILE *pFile; // [sp+2Ch] [bp+1Ch]
  uint8_t voltage3; // [sp+31h] [bp+21h]
  uint8_t voltage2; // [sp+32h] [bp+22h]
  uint8_t voltage1; // [sp+33h] [bp+23h]
  int retry_count; // [sp+34h] [bp+24h]

  voltage1 = pic_voltage;
  voltage2 = 0;
  voltage3 = 0;
  retry_count = 0;
  cmd[0] = 16;
  cmd[1] = pic_voltage;
  cmd[2] = 0;
  cmd[3] = 0;
  if ( (pic_voltage & 0x80u) != 0 || (voltage2 & 0x80u) != 0 || (voltage3 & 0x80u) != 0 )
    return -2;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 4u, read_back_data, 2u);
    if ( read_back_data[0] == 16 && read_back_data[1] == 1 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: chain[%d] ok!\n", "dspic33ep16gs202.c", 271, (const char *)_FUNCTION___11689, chain);
        fclose(pFile);
      }
      return 0;
    }
    if ( retry_count > 2 )
      break;
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        276,
        (const char *)_FUNCTION___11689,
        chain,
        retry_count);
    fclose(pFile_0);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x\n",
        "dspic33ep16gs202.c",
        277,
        (const char *)_FUNCTION___11689,
        read_back_data[0],
        read_back_data[1]);
    fclose(pFile_1);
  }
  return -1;
}

//----- (00070B7A) --------------------------------------------------------
void __cdecl enable_pic_dac(uint8_t chain)
{
  dsPIC33EP16GS202_enable_pic_dc_dc(chain, 1u);
}

//----- (00070B96) --------------------------------------------------------
void __cdecl disable_pic_dac(uint8_t chain)
{
  dsPIC33EP16GS202_enable_pic_dc_dc(chain, 0);
}

//----- (00070BB2) --------------------------------------------------------
void __cdecl pic_heart_beat_each_chain(uint8_t chain)
{
  dsPIC33EP16GS202_pic_heart_beat(chain);
}

//----- (00070BCC) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_get_software_version(uint8_t chain, uint8_t *version)
{
  uint8_t cmd[1]; // [sp+1Ch] [bp+Ch] BYREF
  uint8_t read_back_data[5]; // [sp+20h] [bp+10h] BYREF
  FILE *pFile_1; // [sp+28h] [bp+18h]
  FILE *pFile_0; // [sp+2Ch] [bp+1Ch]
  FILE *pFile; // [sp+30h] [bp+20h]
  int retry_count; // [sp+34h] [bp+24h]

  retry_count = 0;
  cmd[0] = 23;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 1u, read_back_data, 5u);
    if ( read_back_data[0] == 5 && read_back_data[1] == 23 )
    {
      *version = read_back_data[2];
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: chain[%d] ok!\n", "dspic33ep16gs202.c", 461, (const char *)_FUNCTION___11776, chain);
        fclose(pFile);
      }
      return 0;
    }
    if ( retry_count > 2 )
      break;
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        466,
        (const char *)_FUNCTION___11776,
        chain,
        retry_count);
    fclose(pFile_0);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x, 0x%08x\n",
        "dspic33ep16gs202.c",
        467,
        (const char *)_FUNCTION___11776,
        read_back_data[0],
        read_back_data[1],
        read_back_data[2]);
    fclose(pFile_1);
  }
  return -1;
}

//----- (00070D84) --------------------------------------------------------
void get_pic_software_version_all_chain()
{
  uint8_t version; // [sp+13h] [bp+3h] BYREF
  FILE *pFile; // [sp+14h] [bp+4h]
  int ret; // [sp+18h] [bp+8h]
  int chain; // [sp+1Ch] [bp+Ch]

  ret = 0;
  version = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      ret = dsPIC33EP16GS202_get_software_version(chain, &version);
      if ( !ret && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d] PIC software version: %d\n",
            "dspic33ep16gs202.c",
            486,
            (const char *)_FUNCTION___11787,
            chain,
            version);
        fclose(pFile);
      }
    }
  }
}

//----- (00070E52) --------------------------------------------------------
int __cdecl dsPIC33EP16GS202_crab_circuit_control(uint8_t chain, unsigned __int8 enable)
{
  uint8_t cmd[2]; // [sp+1Ch] [bp+Ch] BYREF
  uint8_t read_back_data[2]; // [sp+20h] [bp+10h] BYREF
  FILE *pFile_2; // [sp+24h] [bp+14h]
  FILE *pFile_1; // [sp+28h] [bp+18h]
  FILE *pFile; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_0; // [sp+30h] [bp+20h]
  int retry_count; // [sp+34h] [bp+24h]

  retry_count = 0;
  cmd[0] = 49;
  cmd[1] = enable;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 2u, read_back_data, 2u);
    if ( read_back_data[0] == 49 && read_back_data[1] == 1 )
    {
      if ( enable )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Enable pic crab(qian wei) for chain %d success!\n",
              "dspic33ep16gs202.c",
              623,
              (const char *)_FUNCTION___11852,
              chain);
          fclose(pFile);
        }
      }
      else if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Disable pic crab(qian wei) for chain %d success!\n",
            "dspic33ep16gs202.c",
            625,
            (const char *)_FUNCTION___11852,
            chain);
        fclose(pFile_0);
      }
      return 0;
    }
    if ( retry_count > 2 )
      break;
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        631,
        (const char *)_FUNCTION___11852,
        chain,
        retry_count);
    fclose(pFile_1);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(
        pFile_2,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x\n",
        "dspic33ep16gs202.c",
        632,
        (const char *)_FUNCTION___11852,
        read_back_data[0],
        read_back_data[1]);
    fclose(pFile_2);
  }
  return -1;
}

//----- (0007107E) --------------------------------------------------------
int __cdecl set_pic_da_value(uint8_t chain, uint8_t da_value)
{
  return dsPIC33EP16GS202_set_pic_voltage(chain, da_value);
}

//----- (000710A4) --------------------------------------------------------
void enable_crab_circuit()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      dsPIC33EP16GS202_crab_circuit_control(chain, 1u);
  }
}

//----- (000710EA) --------------------------------------------------------
void disable_crab_circuit()
{
  int chain; // [sp+4h] [bp+4h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      dsPIC33EP16GS202_crab_circuit_control(chain, 0);
  }
}

//----- (0007112C) --------------------------------------------------------
bool __cdecl check_crc(unsigned __int8 *buf)
{
  unsigned __int8 *v2; // r3
  unsigned __int8 *bufa; // [sp+14h] [bp+4h]
  FILE *pFile; // [sp+1Ch] [bp+Ch]
  uint16_t sum2; // [sp+26h] [bp+16h]
  unsigned int i; // [sp+28h] [bp+18h]
  uint16_t sum1; // [sp+2Eh] [bp+1Eh]

  bufa = buf;
  sum1 = 0;
  if ( !buf || *buf <= 3u )
    return 0;
  for ( i = 0; (unsigned int)*buf - 2 > i; ++i )
  {
    v2 = bufa++;
    sum1 += *v2;
  }
  sum2 = _byteswap_ushort(*(_WORD *)bufa);
  if ( log_level > 5 )
  {
    print_crt_time_to_file(log_file, 5u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: sum1,sum2 = %d,%d\n",
        "dspic33ep16gs202.c",
        694,
        (const char *)_FUNCTION___11886,
        sum1,
        sum2);
    fclose(pFile);
  }
  return sum1 == sum2;
}

//----- (00071228) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl decode_an_voltage_buf(unsigned __int8 *buf)
{
  double result; // r0
  unsigned __int8 *bufa; // [sp+14h] [bp+4h]
  FILE *pFile; // [sp+18h] [bp+8h]
  FILE *pFile_2; // [sp+1Ch] [bp+Ch]
  FILE *pFile_1; // [sp+2Ch] [bp+1Ch]
  double v_an2; // [sp+30h] [bp+20h]
  FILE *pFile_0; // [sp+38h] [bp+28h]
  uint16_t v_n; // [sp+3Eh] [bp+2Eh]

  bufa = buf;
  if ( buf )
  {
    buf = (unsigned __int8 *)check_crc(buf);
    if ( (unsigned __int8)buf != 1 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: crc error!\n", "dspic33ep16gs202.c", 708, (const char *)_FUNCTION___11891);
        buf = (unsigned __int8 *)fclose(pFile);
      }
    }
    else
    {
      v_n = _byteswap_ushort(*(_WORD *)(bufa + 3));
      if ( log_level > 5 )
      {
        print_crt_time_to_file(log_file, 5u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: voltage = %d\n", "dspic33ep16gs202.c", 716, (const char *)_FUNCTION___11891, v_n);
        buf = (unsigned __int8 *)fclose(pFile_0);
      }
      v_an2 = (double)v_n * 3.3 / 4096.0;
      if ( log_level > 5 )
      {
        print_crt_time_to_file(log_file, 5u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: v_an2 = %f\n", "dspic33ep16gs202.c", 721, (const char *)_FUNCTION___11891, v_an2);
        buf = (unsigned __int8 *)fclose(pFile_1);
      }
      if ( log_level > 5 )
      {
        print_crt_time_to_file(log_file, 5u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: v_10 = %f\n",
            "dspic33ep16gs202.c",
            724,
            (const char *)_FUNCTION___11891,
            v_an2 * 7.5999999);
        buf = (unsigned __int8 *)fclose(pFile_2);
      }
    }
  }
  LODWORD(result) = buf;
  return result;
}
// 71228: variables would overlap: r0.4 and r0.8
// 71228: bad return variable

//----- (000714A0) --------------------------------------------------------
double __cdecl dsPIC33EP16GS202_pic_get_an_voltage2(uint8_t chain)
{
  double result; // r0
  uint8_t cmd[1]; // [sp+1Ch] [bp+Ch] BYREF
  uint8_t read_back_data[9]; // [sp+20h] [bp+10h] BYREF
  FILE *pFile_0; // [sp+2Ch] [bp+1Ch]
  FILE *pFile; // [sp+30h] [bp+20h]
  int retry_count; // [sp+34h] [bp+24h]

  retry_count = 0;
  cmd[0] = 41;
  while ( 1 )
  {
    ++retry_count;
    send_pic_cmd(chain, cmd, 1u, read_back_data, 9u);
    if ( read_back_data[1] == 41 && read_back_data[2] == 1 )
      return decode_an_voltage_buf(read_back_data);
    if ( retry_count > 2 )
      break;
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: ERROR! failed on Chain[%d] after %d times try!\n",
        "dspic33ep16gs202.c",
        747,
        (const char *)_FUNCTION___11905,
        chain,
        retry_count);
    fclose(pFile);
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: DEBUG! 0x%08x, 0x%08x,  0x%08x\n",
        "dspic33ep16gs202.c",
        748,
        (const char *)_FUNCTION___11905,
        read_back_data[0],
        read_back_data[1],
        read_back_data[2]);
    fclose(pFile_0);
  }
  dump_mem("read_back_data:", read_back_data, 9);
  return result;
}

//----- (00071606) --------------------------------------------------------
double __cdecl get_pic_an_voltage2(uint8_t chain)
{
  return dsPIC33EP16GS202_pic_get_an_voltage2(chain);
}

//----- (00071626) --------------------------------------------------------
int __cdecl init_pic_one_chain(uint8_t chain)
{
  int ret; // [sp+Ch] [bp+Ch]
  int reta; // [sp+Ch] [bp+Ch]
  int retb; // [sp+Ch] [bp+Ch]

  if ( dev->chain_exist[chain] != 1 )
    return 0;
  ret = dsPIC33EP16GS202_reset_pic(chain);
  if ( !ret )
  {
    reta = dsPIC33EP16GS202_jump_to_app_from_loader(chain);
    if ( reta )
      return reta;
    sleep(1u);
    retb = dsPIC33EP16GS202_enable_pic_dc_dc(chain, 0);
    if ( retb )
      return retb;
    return 0;
  }
  return ret;
}

//----- (00071698) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  uint32_t wv[8]; // [sp+14h] [bp+14h]
  uint32_t w[64]; // [sp+34h] [bp+34h]
  uint32_t t2; // [sp+134h] [bp+134h]
  uint32_t t1; // [sp+138h] [bp+138h]
  const unsigned __int8 *sub_block; // [sp+13Ch] [bp+13Ch]
  int j; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  for ( i = 0; i < (int)block_nb; ++i )
  {
    sub_block = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = sub_block[4 * j + 3] | (sub_block[4 * j + 2] << 8) | (sub_block[4 * j + 1] << 16) | (sub_block[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      wv[j] = ctx->h[j];
    for ( j = 0; j <= 63; ++j )
    {
      t1 = w[j]
         + wv[7]
         + (__ROR4__(wv[4], 25) ^ __ROR4__(wv[4], 6) ^ __ROR4__(wv[4], 11))
         + (wv[6] & ~wv[4] ^ wv[4] & wv[5])
         + sha256_k[j];
      t2 = (wv[2] & wv[1] ^ wv[0] & (wv[2] ^ wv[1])) + (__ROR4__(wv[0], 2) ^ __ROR4__(wv[0], 13) ^ __ROR4__(wv[0], 22));
      wv[7] = wv[6];
      wv[6] = wv[5];
      wv[5] = wv[4];
      wv[4] = wv[3] + t1;
      wv[3] = wv[2];
      wv[2] = wv[1];
      wv[1] = wv[0];
      wv[0] = t1 + t2;
    }
    for ( j = 0; j <= 7; ++j )
      ctx->h[j] += wv[j];
  }
}

//----- (000719EA) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  sha256_ctx ctx; // [sp+10h] [bp+10h] BYREF

  sha256_init(&ctx);
  sha256_update(&ctx, message, len);
  sha256_final(&ctx, digest);
}

//----- (00071A22) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 7; ++i )
    ctx->h[i] = sha256_h0[i];
  ctx->len = 0;
  ctx->tot_len = 0;
}

//----- (00071A6C) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v3; // r3
  const unsigned __int8 *shifted_message; // [sp+14h] [bp+14h]
  unsigned int block_nb; // [sp+18h] [bp+18h]
  unsigned int rem_len; // [sp+20h] [bp+20h]
  size_t rem_lena; // [sp+20h] [bp+20h]

  v3 = len;
  if ( len >= 64 - ctx->len )
    v3 = 64 - ctx->len;
  rem_len = v3;
  memcpy(&ctx->block[ctx->len], message, v3);
  if ( len + ctx->len > 0x3F )
  {
    block_nb = (len - rem_len) >> 6;
    shifted_message = &message[rem_len];
    sha256_transf(ctx, ctx->block, 1u);
    sha256_transf(ctx, &message[rem_len], block_nb);
    rem_lena = (len - rem_len) & 0x3F;
    memcpy(ctx->block, &shifted_message[64 * block_nb], rem_lena);
    ctx->len = rem_lena;
    ctx->tot_len += (block_nb + 1) << 6;
  }
  else
  {
    ctx->len += len;
  }
}

//----- (00071B24) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  unsigned int pm_len; // [sp+8h] [bp+8h]
  unsigned int len_b; // [sp+Ch] [bp+Ch]
  unsigned int block_nb; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( (ctx->len & 0x3F) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  block_nb = v2;
  len_b = 8 * (ctx->len + ctx->tot_len);
  pm_len = v2 << 6;
  memset(&ctx->block[ctx->len], 0, (v2 << 6) - ctx->len);
  ctx->block[ctx->len] = 0x80;
  ctx->block[pm_len - 1] = len_b;
  ctx->block[pm_len - 2] = BYTE1(len_b);
  ctx->block[pm_len - 3] = BYTE2(len_b);
  ctx->block[pm_len - 4] = HIBYTE(len_b);
  sha256_transf(ctx, ctx->block, block_nb);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = ctx->h[i];
    digest[4 * i + 2] = BYTE1(ctx->h[i]);
    digest[4 * i + 1] = BYTE2(ctx->h[i]);
    digest[4 * i] = HIBYTE(ctx->h[i]);
  }
}

//----- (00071C5A) --------------------------------------------------------
void __cdecl register_parse_clock_delay_ctrl(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp+Ch]
  clock_delay_ctrl_t reg_value; // [sp+18h] [bp+10h]
  FILE *pFile_5; // [sp+1Ch] [bp+14h]
  FILE *pFile_4; // [sp+20h] [bp+18h]
  FILE *pFile_3; // [sp+24h] [bp+1Ch]
  FILE *pFile_2; // [sp+28h] [bp+20h]
  FILE *pFile_1; // [sp+2Ch] [bp+24h]
  FILE *pFile_0; // [sp+30h] [bp+28h]
  FILE *pFile; // [sp+34h] [bp+2Ch]

  core_response = core_reg_status->reg_response;
  reg_value.v = core_reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[0] = 0x%02X, Clock Delay Ctrl, %s\n",
        HIBYTE(core_response),
        reg_value.v,
        v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)register_file_str, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:6]  CCDLY_SEL", reg_value.v >> 6);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)register_file_str, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[5:4]  PWTH_SEL", (reg_value.v >> 4) & 3);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)register_file_str, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[3]    HASH_CLKEN", (reg_value.v & 8) != 0);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)register_file_str, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[2]    MMEN", (reg_value.v & 4) != 0);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)register_file_str, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[1]    Reserved", (reg_value.v & 2) != 0);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)register_file_str, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[0]    SWPF_MODE", reg_value.v & 1);
      fclose(pFile_5);
    }
  }
}

//----- (00071ED8) --------------------------------------------------------
void __cdecl register_parse_process_monitor_ctrl(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp+8h]
  process_monitor_ctrl_t reg_value; // [sp+14h] [bp+Ch]
  FILE *pFile_2; // [sp+18h] [bp+10h]
  FILE *pFile_1; // [sp+1Ch] [bp+14h]
  FILE *pFile_0; // [sp+20h] [bp+18h]
  FILE *pFile; // [sp+24h] [bp+1Ch]

  core_response = core_reg_status->reg_response;
  reg_value.v = core_reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[1] = 0x%02X, Process Monitor Ctrl, %s\n",
        HIBYTE(core_response),
        reg_value.v,
        v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)register_file_str, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:3]  Reserved", reg_value.v >> 3);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)register_file_str, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[2]    PM_START", (reg_value.v & 4) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)register_file_str, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[1:0]  PM_SEL", reg_value.v & 3);
      fclose(pFile_2);
    }
  }
}

//----- (0007205E) --------------------------------------------------------
void __cdecl register_parse_process_monitor_data(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp+8h]
  process_monitor_data_t reg_value; // [sp+14h] [bp+Ch]
  FILE *pFile_0; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]

  core_response = core_reg_status->reg_response;
  reg_value._FREQ_CNT = core_reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[2] = 0x%04X, Process Monitor Data, %s\n",
        HIBYTE(core_response),
        reg_value._FREQ_CNT,
        v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)register_file_str, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[15:0] FREQ_CNT", reg_value._FREQ_CNT);
    fclose(pFile_0);
  }
}

//----- (0007213A) --------------------------------------------------------
void __cdecl register_parse_core_error(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp+8h]
  core_error_t reg_value; // [sp+14h] [bp+Ch]
  FILE *pFile_2; // [sp+18h] [bp+10h]
  FILE *pFile_1; // [sp+1Ch] [bp+14h]
  FILE *pFile_0; // [sp+20h] [bp+18h]
  FILE *pFile; // [sp+24h] [bp+1Ch]

  core_response = core_reg_status->reg_response;
  reg_value.v = core_reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> core_id[%d], CORE_REG[3] = 0x%02X, Core Error, %s\n", HIBYTE(core_response), reg_value.v, v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)register_file_str, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:5]  Reserved", reg_value.v >> 5);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)register_file_str, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[4]    INI_NONCE_ERR", (reg_value.v & 0x10) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)register_file_str, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[3:0]  CMD_ERR_CNT", reg_value.v & 0xF);
      fclose(pFile_2);
    }
  }
}

//----- (000722C0) --------------------------------------------------------
void __cdecl register_parse_core_enable(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp+8h]
  core_enable_t reg_value; // [sp+14h] [bp+Ch]
  FILE *pFile_0; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]

  core_response = core_reg_status->reg_response;
  reg_value._CORE_EN_I = core_reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[4] = 0x%04X, Core Enable, %s\n",
        HIBYTE(core_response),
        reg_value._CORE_EN_I,
        v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)register_file_str, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:0]  CORE_EN_I", reg_value._CORE_EN_I);
    fclose(pFile_0);
  }
}

//----- (0007239C) --------------------------------------------------------
void __cdecl register_parse_hash_clock_ctrl(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp+8h]
  hash_clock_ctrl_t reg_value; // [sp+14h] [bp+Ch]
  FILE *pFile_0; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]

  core_response = core_reg_status->reg_response;
  reg_value._CLOCK_CTRL = core_reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[5] = 0x%02X, Hash Clock Control, %s\n",
        HIBYTE(core_response),
        reg_value._CLOCK_CTRL,
        v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)register_file_str, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:0]  CLOCK_CTRL\n", reg_value._CLOCK_CTRL);
    fclose(pFile_0);
  }
}

//----- (00072478) --------------------------------------------------------
void __cdecl register_parse_hash_clock_counter(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp+8h]
  hash_clock_counter_t reg_value; // [sp+14h] [bp+Ch]
  FILE *pFile_0; // [sp+18h] [bp+10h]
  FILE *pFile; // [sp+1Ch] [bp+14h]

  core_response = core_reg_status->reg_response;
  reg_value._CLOCK_CNT = (unsigned __int8)core_reg_status->reg_response;
  if ( log_level > 4 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[6] = 0x%02X, Hash Clock Counter, %s\n",
        HIBYTE(core_response),
        reg_value._CLOCK_CNT,
        v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)register_file_str, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "CLOCK_CNT = 0x%08x freq = %.2f\n",
        reg_value._CLOCK_CNT,
        (float)((float)(2 * reg_value._CLOCK_CNT) * 6.25));
    fclose(pFile_0);
  }
}

//----- (0007256E) --------------------------------------------------------
void __cdecl register_parse_sweep_freq_ctrl(core_reg_status_t *core_reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp+Ch]
  sweep_freq_ctrl_t reg_value; // [sp+18h] [bp+10h]
  FILE *pFile_3; // [sp+1Ch] [bp+14h]
  FILE *pFile_2; // [sp+20h] [bp+18h]
  FILE *pFile_1; // [sp+24h] [bp+1Ch]
  FILE *pFile_0; // [sp+28h] [bp+20h]
  FILE *pFile; // [sp+2Ch] [bp+24h]

  core_response = core_reg_status->reg_response;
  reg_value.v = core_reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
    {
      if ( core_reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[7] = 0x%04X, Sweep Clock Control, %s\n",
        HIBYTE(core_response),
        reg_value.v,
        v1);
    }
    fclose(pFile);
  }
  if ( core_reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)register_file_str, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[15:8] Reserved", reg_value.u._RSVD1);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)register_file_str, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[7]    SWPF_MODE", *(_BYTE *)&reg_value.u >> 7);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)register_file_str, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[6:4]  Reserved", (*(_BYTE *)&reg_value.u >> 4) & 7);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)register_file_str, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[3:0]  CLK_SEL", *(_BYTE *)&reg_value.u & 0xF);
      fclose(pFile_3);
    }
  }
}

//----- (00072742) --------------------------------------------------------
void __cdecl register_build_core_command_read_one(core_command_t *core_cmd, uint8_t core_id, uint8_t reg)
{
  memset(core_cmd, 0, sizeof(core_command_t));
  core_cmd->u._REG_WDATA = -1;
  core_cmd->v[1] = core_cmd->v[1] & 0xF8 | reg & 7;
  core_cmd->v[1] &= ~0x40u;
  core_cmd->v[1] &= ~0x80u;
  core_cmd->u._CORE_ID = core_id;
  core_cmd->v[3] &= ~0x80u;
}

//----- (000727A0) --------------------------------------------------------
void __cdecl register_build_core_command_write_all(core_command_t *core_cmd, uint8_t reg, uint8_t reg_data)
{
  memset(core_cmd, 0, sizeof(core_command_t));
  core_cmd->u._REG_WDATA = reg_data;
  core_cmd->v[1] = core_cmd->v[1] & 0xF8 | reg & 7;
  core_cmd->v[1] &= ~0x40u;
  core_cmd->v[1] |= 0x80u;
  core_cmd->u._CORE_ID = 0;
  core_cmd->v[3] |= 0x80u;
}

//----- (000727FE) --------------------------------------------------------
void __cdecl register_build_set_config_command(set_config_t *set_cfg, uint8_t asic, core_command_t *core_cmd)
{
  FILE *pFile; // [sp+1Ch] [bp+14h]

  if ( set_cfg && core_cmd )
  {
    memset(set_cfg, 0, sizeof(set_config_t));
    set_cfg->v[0] = set_cfg->v[0] & 0xF0 | 1;
    set_cfg->v[0] &= ~0x10u;
    set_cfg->v[0] = set_cfg->v[0] & 0x1F | 0x40;
    set_cfg->u._Length = 9;
    set_cfg->u._ADDR = asic * dev->addrInterval;
    set_cfg->u._REGADDR = 60;
    set_cfg->u._REGDATA[0] = core_cmd->v[3];
    set_cfg->u._REGDATA[1] = core_cmd->u._CORE_ID;
    set_cfg->u._REGDATA[2] = core_cmd->v[1];
    set_cfg->u._REGDATA[3] = core_cmd->u._REG_WDATA;
    set_cfg->v[8] = set_cfg->v[8] & 0xE0 | CRC5((unsigned __int8 *)set_cfg, 0x40u) & 0x1F;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(register_file_str, 3u);
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Invalid parameter.\n", "register.c", 192, (const char *)_FUNCTION___11966);
    fclose(pFile);
  }
}

//----- (0007291E) --------------------------------------------------------
void __cdecl register_build_bc_command(uint32_t *bc_cmd, set_config_t *set_cfg)
{
  memset(bc_cmd, 0, 0xCu);
  *bc_cmd = _byteswap_ulong(*(_DWORD *)&set_cfg->u);
  bc_cmd[1] = _byteswap_ulong(*(_DWORD *)&set_cfg->v[4]);
  bc_cmd[2] = set_cfg->v[8] << 24;
}

//----- (0007298A) --------------------------------------------------------
bool __cdecl register_process_core_response(int chain, uint8_t asic, core_reg_status_t *core_reg_status)
{
  FILE *pFile; // [sp+20h] [bp+10h]
  FILE *pFile_0; // [sp+24h] [bp+14h]
  uint8_t asic_from_reg; // [sp+2Bh] [bp+1Bh]
  unsigned __int8 reg; // [sp+33h] [bp+23h]
  unsigned int reg_value_num; // [sp+34h] [bp+24h]
  unsigned int i; // [sp+38h] [bp+28h]
  bool found; // [sp+3Fh] [bp+2Fh]

  found = 0;
  reg_value_num = reg_value_buf.reg_value_num;
  for ( i = 0; reg_value_num > i && !found; ++i )
  {
    reg = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_address;
    asic_from_reg = reg_value_buf.reg_buffer[reg_value_buf.p_rd].chip_address / dev->addrInterval;
    if ( reg == 64 )
    {
      if ( chain == reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number && asic_from_reg == asic )
      {
        core_reg_status->reg_response = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
      }
      else if ( log_level > 3 )
      {
        print_crt_time_to_file(register_file_str, 3u);
        pFile = fopen((const char *)register_file_str, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Get another core response: chain = %d, asic = %d\n",
            "register.c",
            256,
            (const char *)_FUNCTION___11983,
            reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number,
            asic_from_reg);
        fclose(pFile);
      }
      found = 1;
    }
    else if ( log_level > 3 )
    {
      print_crt_time_to_file(register_file_str, 3u);
      pFile_0 = fopen((const char *)register_file_str, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Get another register: 0x%X\n",
          "register.c",
          263,
          (const char *)_FUNCTION___11983,
          reg);
      fclose(pFile_0);
    }
    ++reg_value_buf.p_rd;
    --reg_value_buf.reg_value_num;
    if ( reg_value_buf.p_rd > 0x1FE )
      reg_value_buf.p_rd = 0;
  }
  return found;
}

//----- (00072BD8) --------------------------------------------------------
void __cdecl register_receive_core_response(int chain, uint8_t asic, core_reg_status_t *core_reg_status)
{
  bool found; // [sp+13h] [bp+13h]
  int try_count; // [sp+14h] [bp+14h]

  try_count = 10;
  found = 0;
  while ( !found )
  {
    if ( !try_count-- )
      break;
    pthread_mutex_lock(&reg_mutex);
    if ( reg_value_buf.reg_value_num )
      found = register_process_core_response(chain, asic, core_reg_status);
    pthread_mutex_unlock(&reg_mutex);
    if ( !found )
      cgsleep_ms(300);
  }
  if ( found )
    core_reg_status->found = 1;
}

//----- (00072C64) --------------------------------------------------------
void __cdecl register_send_cmd_read_one(int chain, uint8_t asic, uint8_t core_id, uint8_t core_reg)
{
  uint32_t bc_cmd[3]; // [sp+Ch] [bp+Ch] BYREF
  set_config_t set_cfg; // [sp+18h] [bp+18h] BYREF
  core_command_t core_cmd; // [sp+24h] [bp+24h] BYREF
  uint32_t value; // [sp+28h] [bp+28h]

  clear_register_value_buf();
  register_build_core_command_read_one(&core_cmd, core_id, core_reg);
  register_build_set_config_command(&set_cfg, asic, &core_cmd);
  register_build_bc_command(bc_cmd, &set_cfg);
  set_BC_command_buffer(bc_cmd);
  value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (00072CE8) --------------------------------------------------------
void __cdecl register_send_core_cmd_write_all(int chain, uint8_t asic, uint8_t core_reg, uint8_t core_reg_data)
{
  uint32_t bc_cmd[3]; // [sp+Ch] [bp+Ch] BYREF
  set_config_t set_cfg; // [sp+18h] [bp+18h] BYREF
  core_command_t core_cmd; // [sp+24h] [bp+24h] BYREF
  uint32_t value; // [sp+28h] [bp+28h]

  clear_register_value_buf();
  register_build_core_command_write_all(&core_cmd, core_reg, core_reg_data);
  register_build_set_config_command(&set_cfg, asic, &core_cmd);
  register_build_bc_command(bc_cmd, &set_cfg);
  set_BC_command_buffer(bc_cmd);
  value = get_BC_write_command() & 0xFFF0FFFF | (chain << 16) | 0x80800000;
  set_BC_write_command(value);
}

//----- (00072D6C) --------------------------------------------------------
void __cdecl register_dump_core_reg(uint8_t core_reg, core_reg_status_t *core_reg_status)
{
  FILE *pFile; // [sp+14h] [bp+Ch]

  if ( core_reg )
  {
    switch ( core_reg )
    {
      case 1u:
        register_parse_process_monitor_ctrl(core_reg_status);
        break;
      case 2u:
        register_parse_process_monitor_data(core_reg_status);
        break;
      case 3u:
        register_parse_core_error(core_reg_status);
        break;
      case 4u:
        register_parse_core_enable(core_reg_status);
        break;
      case 5u:
        register_parse_hash_clock_ctrl(core_reg_status);
        break;
      case 6u:
        register_parse_hash_clock_counter(core_reg_status);
        break;
      case 7u:
        register_parse_sweep_freq_ctrl(core_reg_status);
        break;
      default:
        if ( log_level > 3 )
        {
          print_crt_time_to_file(register_file_str, 3u);
          pFile = fopen((const char *)register_file_str, "a+");
          if ( pFile )
            fprintf(pFile, "%s:%d:%s: Unknown reg: %d\n", "register.c", 382, (const char *)_FUNCTION___12025, core_reg);
          fclose(pFile);
        }
        break;
    }
  }
  else
  {
    register_parse_clock_delay_ctrl(core_reg_status);
  }
}

//----- (00072E5E) --------------------------------------------------------
bool __cdecl register_is_param_valid(int chain, uint8_t asic, uint8_t core)
{
  FILE *pFile; // [sp+14h] [bp+Ch]
  FILE *pFile_0; // [sp+18h] [bp+10h]
  FILE *pFile_1; // [sp+1Ch] [bp+14h]

  if ( chain <= 15 && dev->chain_exist[chain] )
  {
    if ( asic <= 0x3Bu )
    {
      if ( core <= 0xCFu )
      {
        return 1;
      }
      else
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(register_file_str, 3u);
          pFile_1 = fopen((const char *)register_file_str, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: Invalid core ID: %d\n",
              "register.c",
              402,
              (const char *)_FUNCTION___12032,
              core);
          fclose(pFile_1);
        }
        return 0;
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(register_file_str, 3u);
        pFile_0 = fopen((const char *)register_file_str, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: Invalid ASIC ID: %d\n", "register.c", 396, (const char *)_FUNCTION___12032, asic);
        fclose(pFile_0);
      }
      return 0;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(register_file_str, 3u);
      pFile = fopen((const char *)register_file_str, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: Invalid chain ID: %d\n", "register.c", 390, (const char *)_FUNCTION___12032, chain);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (00072FF6) --------------------------------------------------------
void __cdecl do_dump_core_hash_clock_counter(int chain, uint8_t asic, uint32_t core)
{
  core_reg_status_t core_regs; // [sp+24h] [bp+14h] BYREF
  FILE *pFile_0; // [sp+2Ch] [bp+1Ch]
  FILE *pFile_1; // [sp+30h] [bp+20h]
  FILE *pFile; // [sp+34h] [bp+24h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(register_file_str, 3u);
    pFile = fopen((const char *)register_file_str, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: chain[%d] asic[%02d] core[%03d]: ",
        "register.c",
        445,
        (const char *)_FUNCTION___12055,
        chain,
        asic,
        core);
    fclose(pFile);
  }
  if ( !register_is_param_valid(chain, asic, core) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(register_file_str, 3u);
      pFile_0 = fopen((const char *)register_file_str, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: register is invalid.\n", "register.c", 449, (const char *)_FUNCTION___12055);
      fclose(pFile_0);
    }
  }
  else
  {
    memset(&core_regs, 0, sizeof(core_regs));
    pthread_mutex_lock(&reopen_core);
    is_reading_core_reg = 1;
    register_send_core_cmd_write_all(chain, asic, 5u, 1u);
    register_send_cmd_read_one(chain, asic, core, 5u);
    register_receive_core_response(chain, asic, &core_regs);
    register_send_cmd_read_one(chain, asic, core, 6u);
    register_receive_core_response(chain, asic, &core_regs);
    register_dump_core_reg(6u, &core_regs);
    register_send_core_cmd_write_all(chain, asic, 5u, 0);
    is_reading_core_reg = 0;
    pthread_mutex_unlock(&reopen_core);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(register_file_str, 4u);
      pFile_1 = fopen((const char *)register_file_str, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: Dump core hash clock register done.\n",
          "register.c",
          478,
          (const char *)_FUNCTION___12055);
      fclose(pFile_1);
    }
  }
}

//----- (00073210) --------------------------------------------------------
void get_higher_voltage()
{
  double v0; // d0
  float v1; // s15
  float volt; // [sp+0h] [bp+0h]
  int _chain; // [sp+4h] [bp+4h]

  volt = 0.0;
  if ( is_T11() )
  {
    for ( _chain = 0; _chain <= 15; ++_chain )
    {
      if ( dev->chain_exist[_chain] )
      {
        get_higher_voltage_by_chain(_chain);
        v1 = v0 + volt;
        volt = v1;
      }
    }
  }
  else
  {
    get_higher_voltage();
  }
}
// 73258: variable 'v0' is possibly undefined

//----- (000732A6) --------------------------------------------------------
void *__cdecl statusServiceThread(void *param)
{
  double v1; // d0
  char *v3; // r4
  int v4; // r0
  int eeprom_total_hash_rate; // r0
  int ideal_hash_rate_max; // r0
  const char *v7; // r1
  const char *v8; // r3
  const char *v9; // r2
  uint32_t last_stable_time; // r0
  int sweep_temp; // r0
  int TotalRate; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  size_t v23; // r0
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 endofrequest[5]; // [sp+81Ch] [bp+80Ch] BYREF
  int testID; // [sp+824h] [bp+814h] BYREF
  unsigned __int8 sendbuf[3]; // [sp+828h] [bp+818h] BYREF
  int recvlen; // [sp+82Ch] [bp+81Ch] BYREF
  unsigned __int8 strSendbuf[10240]; // [sp+830h] [bp+820h] BYREF
  unsigned __int8 buf[8192]; // [sp+3030h] [bp+3020h] BYREF
  sockaddr_in from; // [sp+5030h] [bp+5020h] BYREF
  unsigned __int8 recvbuf[10240]; // [sp+5040h] [bp+5030h] BYREF
  timeval timeout; // [sp+7840h] [bp+7830h] BYREF
  CHIP_LEVEL bin_level; // [sp+7848h] [bp+7838h]
  CHIP_MINOR_TYPE minor_type; // [sp+784Ch] [bp+783Ch]
  CHIP_MAJOR_TYPE major_type; // [sp+7850h] [bp+7840h]
  int bError; // [sp+7854h] [bp+7844h]
  int ret; // [sp+7858h] [bp+7848h]
  int s1; // [sp+785Ch] [bp+784Ch]
  int chain; // [sp+7860h] [bp+7850h]
  int res_mode; // [sp+7864h] [bp+7854h]
  int sentlen; // [sp+7868h] [bp+7858h]
  int buflen; // [sp+786Ch] [bp+785Ch]
  int len; // [sp+7870h] [bp+7860h]
  unsigned __int8 *precvbuf; // [sp+7874h] [bp+7864h]

  s1 = (int)param;
  timeout.tv_sec = 3;
  timeout.tv_usec = 0;
  precvbuf = recvbuf;
  ret = -1;
  len = 0;
  bError = 0;
  buflen = 0;
  recvlen = 0;
  sentlen = 0;
  strcpy((char *)sendbuf, "\r\n");
  testID = -1;
  res_mode = 0;
  strcpy((char *)endofrequest, "\r\n\r\n");
  memset(recvbuf, 0, sizeof(recvbuf));
  while ( !ExitServer )
  {
    ret = recvfrom(s1, precvbuf, 10239 - buflen, 0, (struct sockaddr *)&from, (socklen_t *)&recvlen);
    if ( ret <= 0 )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, ":statusServiceThread recvfrom<=0");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    buflen = ret;
    if ( ret == 10239 )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "BUFSIZE is too small!");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    precvbuf = &recvbuf[buflen];
    if ( strstr((const char *)recvbuf, (const char *)endofrequest) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "find http request end flag!");
        applog(7, tmp42, 0);
      }
      break;
    }
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "get http=%s", (const char *)recvbuf);
    applog(7, tmp42, 0);
  }
  if ( recvbuf[0] != 71 || recvbuf[1] != 69 || recvbuf[2] != 84 || recvbuf[3] != 32 )
  {
    close(s1);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "statusServiceThread not support http command");
      applog(7, tmp42, 0);
    }
    return 0;
  }
  if ( strstr((const char *)&recvbuf[4], "/rate") )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "cmd : get rate");
      applog(7, tmp42, 0);
    }
    res_mode = 0;
  }
  else if ( strstr((const char *)&recvbuf[4], "/ideal_rate") )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "cmd : get ideal rate");
      applog(7, tmp42, 0);
    }
    res_mode = 2;
  }
  else if ( strstr((const char *)&recvbuf[4], "/max_rate") )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "cmd : get max rate");
      applog(7, tmp42, 0);
    }
    res_mode = 3;
  }
  else
  {
    if ( !strstr((const char *)&recvbuf[4], "/test") )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "statusServiceThread exit for Error cmd!");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    _isoc99_sscanf(&recvbuf[4], "/test.%d", &testID);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "cmd : get test = %d", testID);
      applog(7, tmp42, 0);
    }
    res_mode = 1;
  }
  ret = setsockopt(s1, 1, 21, &timeout, 8u);
  if ( ret )
  {
    close(s1);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "setsockopt SO_SNDTIMEO failed");
      applog(7, tmp42, 0);
    }
    return 0;
  }
  else
  {
    ret = setsockopt(s1, 1, 20, &timeout, 8u);
    if ( ret )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "setsockopt SO_RCVTIMEO failed");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( res_mode == 1 )
      {
        switch ( testID )
        {
          case 523:
            getMinerInfo(buf);
            break;
          case 524:
            getReopenInfo(buf);
            break;
          case 525:
            getAgingInbalanceTimes(buf);
            break;
          case 526:
            getDiffFreqInfo(buf);
            break;
          case 527:
            if ( is_T11() )
            {
              strcpy((char *)buf, "current working voltage= ");
              len = 25;
              for ( chain = 0; chain <= 15; ++chain )
              {
                if ( dev->chain_exist[chain] )
                {
                  v3 = (char *)&buf[len];
                  get_working_voltage_by_chain(chain);
                  v4 = sprintf(v3, "%2.2f ", v1);
                  len += v4;
                }
              }
            }
            else
            {
              get_working_voltage();
              sprintf((char *)buf, "current working voltage=%.2f", v1);
            }
            break;
          case 528:
            get_reopen_time_record_info(buf);
            break;
          case 529:
            getAginginfo(buf);
            break;
          case 530:
            eeprom_total_hash_rate = get_eeprom_total_hash_rate();
            sprintf((char *)buf, "%d", eeprom_total_hash_rate);
            break;
          case 531:
            ideal_hash_rate_max = get_ideal_hash_rate_max();
            sprintf((char *)buf, "%d", ideal_hash_rate_max);
            break;
          case 532:
            get_higher_voltage();
            sprintf((char *)buf, "higher voltage=%.2f", *(float *)&v1);
            break;
          case 534:
            major_type = g_major_type[0];
            minor_type = g_minor_type[0];
            bin_level = g_bin_level[0];
            if ( g_major_type[0] )
            {
              if ( major_type == CHIP_1391 )
              {
                v7 = "1391";
              }
              else if ( major_type == CHIP_1397 )
              {
                v7 = "1397";
              }
              else
              {
                v7 = "-";
              }
            }
            else
            {
              v7 = "1393";
            }
            if ( minor_type )
            {
              switch ( minor_type )
              {
                case PKG_BE:
                  v8 = "BE";
                  break;
                case PKG_B_BGM:
                  v8 = "B_BGM";
                  break;
                case PKG_BE_BGM:
                  v8 = "BE_BGM";
                  break;
                case PKG_CE:
                  v8 = "CE";
                  break;
                default:
                  v8 = "-";
                  break;
              }
            }
            else
            {
              v8 = "BSL";
            }
            if ( bin_level )
            {
              switch ( bin_level )
              {
                case BIN2:
                  v9 = "BIN2";
                  break;
                case BIN3:
                  v9 = "BIN3";
                  break;
                case BIN4:
                  v9 = "BIN4";
                  break;
                default:
                  v9 = "-";
                  break;
              }
            }
            else
            {
              v9 = "BIN1";
            }
            sprintf((char *)buf, "%s %s %s", v7, v8, v9);
            break;
          case 535:
            aging_get_finish_avg_hashrate();
            sprintf((char *)buf, "average hashrate when aging finish = %.2f", v1);
            break;
          case 536:
            last_stable_time = aging_get_last_stable_time();
            sprintf((char *)buf, "aging last stable = %d seconds", last_stable_time);
            break;
          case 537:
            aging_get_update_hashrate_info(buf);
            break;
          case 538:
            sprintf(
              (char *)buf,
              "find_asic_count %d with_pre_open_core %d",
              find_asic_with_count,
              find_asic_with_pre_open_core_count);
            break;
          case 539:
            sprintf((char *)buf, "%d", aging_re_open_core_times);
            break;
          case 540:
            sprintf((char *)buf, "%d", force_reopen_times);
            break;
          case 541:
            sprintf(
              (char *)buf,
              " %d %d %d %d %d",
              dev->fan_speed_top1,
              dev->temp_low1[0],
              dev->temp_top1[0],
              dev->temp_low1[1],
              dev->temp_top1[1]);
            break;
          case 542:
            sweep_temp = aging_get_sweep_temp();
            sprintf((char *)buf, "%d", sweep_temp);
            break;
          case 543:
            get_imbalance_domain_count(buf);
            break;
          case 544:
            get_avg_freq_info(buf);
            break;
          case 545:
            get_asic_sweep_stat(buf);
            break;
          default:
            sprintf((char *)buf, "OK get test=%d", testID);
            break;
        }
      }
      if ( !res_mode )
      {
        if ( freq_scan_status == 1 )
        {
          TotalRate = GetTotalRate();
          v13 = ConvirtTotalRate(TotalRate);
          sprintf((char *)buf, "%d", v13);
        }
        else if ( freq_scan_status == 2 )
        {
          sprintf((char *)buf, "searchfailed:%s", (const char *)search_failed_info);
        }
        else
        {
          strcpy((char *)buf, "searching");
        }
      }
      if ( res_mode == 2 )
      {
        if ( freq_scan_status == 1 )
        {
          v14 = get_eeprom_total_hash_rate();
          sprintf((char *)buf, "%d", v14);
        }
        else if ( freq_scan_status == 2 )
        {
          sprintf((char *)buf, "searchfailed:%s", (const char *)search_failed_info);
        }
        else
        {
          strcpy((char *)buf, "searching");
        }
      }
      if ( res_mode == 3 )
      {
        if ( freq_scan_status == 1 )
        {
          v15 = get_ideal_hash_rate_max();
          sprintf((char *)buf, "%d", v15);
        }
        else if ( freq_scan_status == 2 )
        {
          sprintf((char *)buf, "searchfailed:%s", (const char *)search_failed_info);
        }
        else
        {
          strcpy((char *)buf, "searching");
        }
      }
      len = strlen((const char *)buf);
      ret = 0;
      v16 = sprintf((char *)strSendbuf, "HTTP/1.0  200  OK%s", (const char *)sendbuf);
      ret += v16;
      v17 = sprintf((char *)&strSendbuf[ret], "Server: SearchFreqServer%s", (const char *)sendbuf);
      ret += v17;
      v18 = sprintf((char *)&strSendbuf[ret], "Cache-Control: no-cache%s", (const char *)sendbuf);
      ret += v18;
      v19 = sprintf((char *)&strSendbuf[ret], "Pragma: no-cache%s", (const char *)sendbuf);
      ret += v19;
      v20 = sprintf((char *)&strSendbuf[ret], "Content-Type: text/plain%s", (const char *)sendbuf);
      ret += v20;
      v21 = sprintf((char *)&strSendbuf[ret], "Content-Length: %d%s", len, (const char *)sendbuf);
      ret += v21;
      v22 = sprintf((char *)&strSendbuf[ret], "Connection: Keep-Alive%s", (const char *)endofrequest);
      ret += v22;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "send http response...\n");
        applog(7, tmp42, 0);
      }
      while ( !ExitServer )
      {
        sentlen = 0;
        do
        {
          v23 = strlen((const char *)strSendbuf);
          ret = send(s1, &strSendbuf[sentlen], v23 - sentlen, 0);
          if ( ret == -1 && *_errno_location() == 11 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "statusServiceThread send http timeout, try again...");
              applog(7, tmp42, 0);
            }
            usleep(0x186A0u);
          }
          else
          {
            if ( ret <= 0 )
            {
              close(s1);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "statusServiceThread send http response error");
                applog(7, tmp42, 0);
              }
              return 0;
            }
            sentlen += ret;
          }
        }
        while ( strlen((const char *)strSendbuf) > sentlen && !ExitServer );
        if ( strlen((const char *)strSendbuf) <= sentlen || ExitServer )
          break;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "send http data...");
        applog(7, tmp42, 0);
      }
      sentlen = 0;
      while ( 1 )
      {
        ret = send(s1, &buf[sentlen], len - sentlen, 0);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "send http data ret=%d", ret);
          applog(7, tmp42, 0);
        }
        if ( ret <= 0 )
          break;
        sentlen += ret;
        if ( sentlen >= len || bError || ExitServer )
          goto LABEL_231;
      }
      bError = 1;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "statusServiceThread send http data error");
        applog(7, tmp42, 0);
      }
LABEL_231:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "one client disconnected!");
        applog(7, tmp42, 0);
      }
      close(s1);
      return (void *)sentlen;
    }
  }
}
// 73CD2: variable 'v1' is possibly undefined
// 123A8: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00074AE0) --------------------------------------------------------
void *__cdecl httpListenThread(void *param)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp+Ch] BYREF
  int addr_len; // [sp+80Ch] [bp+80Ch] BYREF
  sockaddr_in client_addr; // [sp+810h] [bp+810h] BYREF
  sockaddr_in service; // [sp+820h] [bp+820h] BYREF
  int ret; // [sp+830h] [bp+830h]
  int AcceptSocket; // [sp+834h] [bp+834h]

  ret = 0;
  AcceptSocket = -1;
  sleep(0x1Eu);
  do
  {
    listen_sockfd = socket(2, 1, 6);
    if ( listen_sockfd >= 0 )
    {
      memset(&service, 0, sizeof(service));
      service.sin_family = 2;
      service.sin_addr.s_addr = htonl(0);
      service.sin_port = htons(0x17ACu);
      if ( bind(listen_sockfd, (const struct sockaddr *)&service, 0x10u) >= 0 )
      {
        if ( listen(listen_sockfd, 100) >= 0 )
          break;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy((char *)tmp42, "http listen failed! try again after 10s...");
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "http port bind failed! try again after 10s...");
        applog(5, tmp42, 0);
      }
      close(listen_sockfd);
      listen_sockfd = -1;
      sleep(0xAu);
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "socket creating failed, try again after 10s...");
        applog(5, tmp42, 0);
      }
      sleep(0xAu);
    }
  }
  while ( !ExitServer );
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "start listen on 6060 ...");
    applog(5, tmp42, 0);
  }
  while ( !ExitServer )
  {
    for ( AcceptSocket = -1;
          AcceptSocket == -1 && !ExitServer;
          AcceptSocket = accept(listen_sockfd, (struct sockaddr *)&client_addr, (socklen_t *)&addr_len) )
    {
      usleep(0x2710u);
      addr_len = 16;
    }
    if ( ExitServer )
    {
      if ( AcceptSocket != -1 )
      {
        close(AcceptSocket);
        AcceptSocket = -1;
      }
      break;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "one client connected sock=%d", AcceptSocket);
      applog(7, tmp42, 0);
    }
    statusServiceThread((void *)AcceptSocket);
  }
  close(listen_sockfd);
  listen_sockfd = -1;
  return (void *)ret;
}

//----- (00074E88) --------------------------------------------------------
void StartHttpThread()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp+0h] BYREF
  pthread_attr_t_0 tattr_ctrl; // [sp+800h] [bp+800h] BYREF
  pthread_t tid_ctrl; // [sp+824h] [bp+824h] BYREF
  int stacksize_ctrl; // [sp+828h] [bp+828h]
  int ret; // [sp+82Ch] [bp+82Ch]

  ret = pthread_attr_init(&tattr_ctrl);
  stacksize_ctrl = 0x200000;
  ret = pthread_attr_setstacksize(&tattr_ctrl, 0x200000u);
  ret = pthread_create(&tid_ctrl, &tattr_ctrl, (void *(*)(void *))httpListenThread, 0);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "httpListenThread start ret=%d", ret);
    applog(5, tmp42, 0);
  }
}

//----- (00074F2A) --------------------------------------------------------
void __cdecl sha2_starts(sha2_context *ctx)
{
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[0] = 1779033703;
  ctx->state[1] = -1150833019;
  ctx->state[2] = 1013904242;
  ctx->state[3] = -1521486534;
  ctx->state[4] = 1359893119;
  ctx->state[5] = -1694144372;
  ctx->state[6] = 528734635;
  ctx->state[7] = 1541459225;
}

//----- (00074FAA) --------------------------------------------------------
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int W; // [sp+8h] [bp+8h]
  unsigned int W_4; // [sp+Ch] [bp+Ch]
  unsigned int W_8; // [sp+10h] [bp+10h]
  unsigned int W_12; // [sp+14h] [bp+14h]
  unsigned int W_16; // [sp+18h] [bp+18h]
  unsigned int W_20; // [sp+1Ch] [bp+1Ch]
  unsigned int W_24; // [sp+20h] [bp+20h]
  unsigned int W_28; // [sp+24h] [bp+24h]
  unsigned int W_32; // [sp+28h] [bp+28h]
  unsigned int W_36; // [sp+2Ch] [bp+2Ch]
  unsigned int W_40; // [sp+30h] [bp+30h]
  unsigned int W_44; // [sp+34h] [bp+34h]
  unsigned int W_48; // [sp+38h] [bp+38h]
  unsigned int W_52; // [sp+3Ch] [bp+3Ch]
  unsigned int W_56; // [sp+40h] [bp+40h]
  unsigned int W_60; // [sp+44h] [bp+44h]
  unsigned int W_64; // [sp+48h] [bp+48h]
  unsigned int W_68; // [sp+4Ch] [bp+4Ch]
  unsigned int W_72; // [sp+50h] [bp+50h]
  unsigned int W_76; // [sp+54h] [bp+54h]
  unsigned int W_80; // [sp+58h] [bp+58h]
  unsigned int W_84; // [sp+5Ch] [bp+5Ch]
  unsigned int W_88; // [sp+60h] [bp+60h]
  unsigned int W_92; // [sp+64h] [bp+64h]
  unsigned int W_96; // [sp+68h] [bp+68h]
  unsigned int W_100; // [sp+6Ch] [bp+6Ch]
  unsigned int W_104; // [sp+70h] [bp+70h]
  unsigned int W_108; // [sp+74h] [bp+74h]
  unsigned int W_112; // [sp+78h] [bp+78h]
  unsigned int W_116; // [sp+7Ch] [bp+7Ch]
  unsigned int W_120; // [sp+80h] [bp+80h]
  unsigned int W_124; // [sp+84h] [bp+84h]
  unsigned int W_128; // [sp+88h] [bp+88h]
  unsigned int W_132; // [sp+8Ch] [bp+8Ch]
  unsigned int W_136; // [sp+90h] [bp+90h]
  unsigned int W_140; // [sp+94h] [bp+94h]
  unsigned int W_144; // [sp+98h] [bp+98h]
  unsigned int W_148; // [sp+9Ch] [bp+9Ch]
  unsigned int W_152; // [sp+A0h] [bp+A0h]
  unsigned int W_156; // [sp+A4h] [bp+A4h]
  unsigned int W_160; // [sp+A8h] [bp+A8h]
  unsigned int W_164; // [sp+ACh] [bp+ACh]
  unsigned int W_168; // [sp+B0h] [bp+B0h]
  unsigned int W_172; // [sp+B4h] [bp+B4h]
  unsigned int W_176; // [sp+B8h] [bp+B8h]
  unsigned int W_180; // [sp+BCh] [bp+BCh]
  unsigned int W_184; // [sp+C0h] [bp+C0h]
  unsigned int W_188; // [sp+C4h] [bp+C4h]
  unsigned int W_192; // [sp+C8h] [bp+C8h]
  unsigned int W_196; // [sp+CCh] [bp+CCh]
  unsigned int W_200; // [sp+D0h] [bp+D0h]
  unsigned int W_204; // [sp+D4h] [bp+D4h]
  unsigned int W_208; // [sp+D8h] [bp+D8h]
  unsigned int W_212; // [sp+DCh] [bp+DCh]
  unsigned int W_216; // [sp+E0h] [bp+E0h]
  unsigned int W_220; // [sp+E4h] [bp+E4h]
  unsigned int W_224; // [sp+E8h] [bp+E8h]
  unsigned int W_228; // [sp+ECh] [bp+ECh]
  unsigned int W_232; // [sp+F0h] [bp+F0h]
  unsigned int W_236; // [sp+F4h] [bp+F4h]
  unsigned int W_240; // [sp+F8h] [bp+F8h]
  unsigned int W_244; // [sp+FCh] [bp+FCh]
  uint32_t temp1; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1a; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1b; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1c; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1d; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1e; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1f; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1g; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1h; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1i; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1j; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1k; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1l; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1m; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1n; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1o; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1p; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1q; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1r; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1s; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1t; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1u; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1v; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1w; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1x; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1y; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1z; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ba; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bb; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bc; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bd; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1be; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bf; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bg; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bh; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bi; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bj; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bk; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bl; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bm; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bn; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bo; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bp; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bq; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1br; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bs; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bt; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bu; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bv; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bw; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bx; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1by; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1bz; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ca; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cb; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cc; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cd; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ce; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cf; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cg; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ch; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ci; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1cj; // [sp+10Ch] [bp+10Ch]
  uint32_t temp1ck; // [sp+10Ch] [bp+10Ch]
  uint32_t H; // [sp+110h] [bp+110h]
  uint32_t Ha; // [sp+110h] [bp+110h]
  uint32_t Hb; // [sp+110h] [bp+110h]
  uint32_t Hc; // [sp+110h] [bp+110h]
  uint32_t Hd; // [sp+110h] [bp+110h]
  uint32_t He; // [sp+110h] [bp+110h]
  uint32_t Hf; // [sp+110h] [bp+110h]
  uint32_t Hg; // [sp+110h] [bp+110h]
  uint32_t Hh; // [sp+110h] [bp+110h]
  uint32_t Hi; // [sp+110h] [bp+110h]
  uint32_t Hj; // [sp+110h] [bp+110h]
  uint32_t Hk; // [sp+110h] [bp+110h]
  uint32_t Hl; // [sp+110h] [bp+110h]
  uint32_t Hm; // [sp+110h] [bp+110h]
  uint32_t Hn; // [sp+110h] [bp+110h]
  uint32_t Ho; // [sp+110h] [bp+110h]
  uint32_t G; // [sp+114h] [bp+114h]
  uint32_t Ga; // [sp+114h] [bp+114h]
  uint32_t Gb; // [sp+114h] [bp+114h]
  uint32_t Gc; // [sp+114h] [bp+114h]
  uint32_t Gd; // [sp+114h] [bp+114h]
  uint32_t Ge; // [sp+114h] [bp+114h]
  uint32_t Gf; // [sp+114h] [bp+114h]
  uint32_t Gg; // [sp+114h] [bp+114h]
  uint32_t Gh; // [sp+114h] [bp+114h]
  uint32_t Gi; // [sp+114h] [bp+114h]
  uint32_t Gj; // [sp+114h] [bp+114h]
  uint32_t Gk; // [sp+114h] [bp+114h]
  uint32_t Gl; // [sp+114h] [bp+114h]
  uint32_t Gm; // [sp+114h] [bp+114h]
  uint32_t Gn; // [sp+114h] [bp+114h]
  uint32_t Go; // [sp+114h] [bp+114h]
  uint32_t Gp; // [sp+114h] [bp+114h]
  uint32_t F; // [sp+118h] [bp+118h]
  uint32_t Fa; // [sp+118h] [bp+118h]
  uint32_t Fb; // [sp+118h] [bp+118h]
  uint32_t Fc; // [sp+118h] [bp+118h]
  uint32_t Fd; // [sp+118h] [bp+118h]
  uint32_t Fe; // [sp+118h] [bp+118h]
  uint32_t Ff; // [sp+118h] [bp+118h]
  uint32_t Fg; // [sp+118h] [bp+118h]
  uint32_t Fh; // [sp+118h] [bp+118h]
  uint32_t Fi; // [sp+118h] [bp+118h]
  uint32_t Fj; // [sp+118h] [bp+118h]
  uint32_t Fk; // [sp+118h] [bp+118h]
  uint32_t Fl; // [sp+118h] [bp+118h]
  uint32_t Fm; // [sp+118h] [bp+118h]
  uint32_t Fn; // [sp+118h] [bp+118h]
  uint32_t Fo; // [sp+118h] [bp+118h]
  uint32_t Fp; // [sp+118h] [bp+118h]
  uint32_t E; // [sp+11Ch] [bp+11Ch]
  uint32_t Ea; // [sp+11Ch] [bp+11Ch]
  uint32_t Eb; // [sp+11Ch] [bp+11Ch]
  uint32_t Ec; // [sp+11Ch] [bp+11Ch]
  uint32_t Ed; // [sp+11Ch] [bp+11Ch]
  uint32_t Ee; // [sp+11Ch] [bp+11Ch]
  uint32_t Ef; // [sp+11Ch] [bp+11Ch]
  uint32_t Eg; // [sp+11Ch] [bp+11Ch]
  uint32_t Eh; // [sp+11Ch] [bp+11Ch]
  uint32_t Ei; // [sp+11Ch] [bp+11Ch]
  uint32_t Ej; // [sp+11Ch] [bp+11Ch]
  uint32_t Ek; // [sp+11Ch] [bp+11Ch]
  uint32_t El; // [sp+11Ch] [bp+11Ch]
  uint32_t Em; // [sp+11Ch] [bp+11Ch]
  uint32_t En; // [sp+11Ch] [bp+11Ch]
  uint32_t Eo; // [sp+11Ch] [bp+11Ch]
  uint32_t D; // [sp+120h] [bp+120h]
  uint32_t Da; // [sp+120h] [bp+120h]
  uint32_t Db; // [sp+120h] [bp+120h]
  uint32_t Dc; // [sp+120h] [bp+120h]
  uint32_t Dd; // [sp+120h] [bp+120h]
  uint32_t De; // [sp+120h] [bp+120h]
  uint32_t Df; // [sp+120h] [bp+120h]
  uint32_t Dg; // [sp+120h] [bp+120h]
  uint32_t Dh; // [sp+120h] [bp+120h]
  uint32_t Di; // [sp+120h] [bp+120h]
  uint32_t Dj; // [sp+120h] [bp+120h]
  uint32_t Dk; // [sp+120h] [bp+120h]
  uint32_t Dl; // [sp+120h] [bp+120h]
  uint32_t Dm; // [sp+120h] [bp+120h]
  uint32_t Dn; // [sp+120h] [bp+120h]
  uint32_t Do; // [sp+120h] [bp+120h]
  uint32_t C; // [sp+124h] [bp+124h]
  uint32_t Ca; // [sp+124h] [bp+124h]
  uint32_t Cb; // [sp+124h] [bp+124h]
  uint32_t Cc; // [sp+124h] [bp+124h]
  uint32_t Cd; // [sp+124h] [bp+124h]
  uint32_t Ce; // [sp+124h] [bp+124h]
  uint32_t Cf; // [sp+124h] [bp+124h]
  uint32_t Cg; // [sp+124h] [bp+124h]
  uint32_t Ch; // [sp+124h] [bp+124h]
  uint32_t Ci; // [sp+124h] [bp+124h]
  uint32_t Cj; // [sp+124h] [bp+124h]
  uint32_t Ck; // [sp+124h] [bp+124h]
  uint32_t Cl; // [sp+124h] [bp+124h]
  uint32_t Cm; // [sp+124h] [bp+124h]
  uint32_t Cn; // [sp+124h] [bp+124h]
  uint32_t Co; // [sp+124h] [bp+124h]
  uint32_t Cp; // [sp+124h] [bp+124h]
  uint32_t B; // [sp+128h] [bp+128h]
  uint32_t Ba; // [sp+128h] [bp+128h]
  uint32_t Bb; // [sp+128h] [bp+128h]
  uint32_t Bc; // [sp+128h] [bp+128h]
  uint32_t Bd; // [sp+128h] [bp+128h]
  uint32_t Be; // [sp+128h] [bp+128h]
  uint32_t Bf; // [sp+128h] [bp+128h]
  uint32_t Bg; // [sp+128h] [bp+128h]
  uint32_t Bh; // [sp+128h] [bp+128h]
  uint32_t Bi; // [sp+128h] [bp+128h]
  uint32_t Bj; // [sp+128h] [bp+128h]
  uint32_t Bk; // [sp+128h] [bp+128h]
  uint32_t Bl; // [sp+128h] [bp+128h]
  uint32_t Bm; // [sp+128h] [bp+128h]
  uint32_t Bn; // [sp+128h] [bp+128h]
  uint32_t Bo; // [sp+128h] [bp+128h]
  uint32_t Bp; // [sp+128h] [bp+128h]
  uint32_t A; // [sp+12Ch] [bp+12Ch]
  uint32_t Aa; // [sp+12Ch] [bp+12Ch]
  uint32_t Ab; // [sp+12Ch] [bp+12Ch]
  uint32_t Ac; // [sp+12Ch] [bp+12Ch]
  uint32_t Ad; // [sp+12Ch] [bp+12Ch]
  uint32_t Ae; // [sp+12Ch] [bp+12Ch]
  uint32_t Af; // [sp+12Ch] [bp+12Ch]
  uint32_t Ag; // [sp+12Ch] [bp+12Ch]
  uint32_t Ah; // [sp+12Ch] [bp+12Ch]
  uint32_t Ai; // [sp+12Ch] [bp+12Ch]
  uint32_t Aj; // [sp+12Ch] [bp+12Ch]
  uint32_t Ak; // [sp+12Ch] [bp+12Ch]
  uint32_t Al; // [sp+12Ch] [bp+12Ch]
  uint32_t Am; // [sp+12Ch] [bp+12Ch]
  uint32_t An; // [sp+12Ch] [bp+12Ch]
  uint32_t Ao; // [sp+12Ch] [bp+12Ch]

  W = _byteswap_ulong(*(_DWORD *)data);
  W_4 = _byteswap_ulong(*((_DWORD *)data + 1));
  W_8 = _byteswap_ulong(*((_DWORD *)data + 2));
  W_12 = _byteswap_ulong(*((_DWORD *)data + 3));
  W_16 = _byteswap_ulong(*((_DWORD *)data + 4));
  W_20 = _byteswap_ulong(*((_DWORD *)data + 5));
  W_24 = _byteswap_ulong(*((_DWORD *)data + 6));
  W_28 = _byteswap_ulong(*((_DWORD *)data + 7));
  W_32 = _byteswap_ulong(*((_DWORD *)data + 8));
  W_36 = _byteswap_ulong(*((_DWORD *)data + 9));
  W_40 = _byteswap_ulong(*((_DWORD *)data + 10));
  W_44 = _byteswap_ulong(*((_DWORD *)data + 11));
  W_48 = _byteswap_ulong(*((_DWORD *)data + 12));
  W_52 = _byteswap_ulong(*((_DWORD *)data + 13));
  W_56 = _byteswap_ulong(*((_DWORD *)data + 14));
  W_60 = _byteswap_ulong(*((_DWORD *)data + 15));
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  E = ctx->state[4];
  F = ctx->state[5];
  G = ctx->state[6];
  temp1 = (__ROR4__(E, 6) ^ __ROR4__(E, 11) ^ __ROR4__(E, 25)) + ctx->state[7] + (G ^ (F ^ G) & E) + W + 1116352408;
  D = temp1 + ctx->state[3];
  H = (C & (A | B) | A & B) + (__ROR4__(A, 2) ^ __ROR4__(A, 13) ^ __ROR4__(A, 22)) + temp1;
  temp1a = (__ROR4__(D, 6) ^ __ROR4__(D, 11) ^ __ROR4__(D, 25)) + G + (F ^ (E ^ F) & D) + W_4 + 1899447441;
  Ca = temp1a + C;
  Ga = (B & (H | A) | H & A) + (__ROR4__(H, 2) ^ __ROR4__(H, 13) ^ __ROR4__(H, 22)) + temp1a;
  temp1b = (__ROR4__(Ca, 6) ^ __ROR4__(Ca, 11) ^ __ROR4__(Ca, 25)) + F + (E ^ (D ^ E) & Ca) + W_8 - 1245643825;
  Ba = temp1b + B;
  Fa = (A & (Ga | H) | Ga & H) + (__ROR4__(Ga, 2) ^ __ROR4__(Ga, 13) ^ __ROR4__(Ga, 22)) + temp1b;
  temp1c = (__ROR4__(Ba, 6) ^ __ROR4__(Ba, 11) ^ __ROR4__(Ba, 25)) + E + (D ^ (Ca ^ D) & Ba) + W_12 - 373957723;
  Aa = temp1c + A;
  Ea = (H & (Fa | Ga) | Fa & Ga) + (__ROR4__(Fa, 2) ^ __ROR4__(Fa, 13) ^ __ROR4__(Fa, 22)) + temp1c;
  temp1d = (__ROR4__(Aa, 6) ^ __ROR4__(Aa, 11) ^ __ROR4__(Aa, 25)) + D + (Ca ^ (Ba ^ Ca) & Aa) + W_16 + 961987163;
  Ha = temp1d + H;
  Da = (Ga & (Ea | Fa) | Ea & Fa) + (__ROR4__(Ea, 2) ^ __ROR4__(Ea, 13) ^ __ROR4__(Ea, 22)) + temp1d;
  temp1e = (__ROR4__(Ha, 6) ^ __ROR4__(Ha, 11) ^ __ROR4__(Ha, 25)) + Ca + (Ba ^ (Aa ^ Ba) & Ha) + W_20 + 1508970993;
  Gb = temp1e + Ga;
  Cb = (Fa & (Da | Ea) | Da & Ea) + (__ROR4__(Da, 2) ^ __ROR4__(Da, 13) ^ __ROR4__(Da, 22)) + temp1e;
  temp1f = (__ROR4__(Gb, 6) ^ __ROR4__(Gb, 11) ^ __ROR4__(Gb, 25)) + Ba + (Aa ^ (Ha ^ Aa) & Gb) + W_24 - 1841331548;
  Fb = temp1f + Fa;
  Bb = (Ea & (Cb | Da) | Cb & Da) + (__ROR4__(Cb, 2) ^ __ROR4__(Cb, 13) ^ __ROR4__(Cb, 22)) + temp1f;
  temp1g = (__ROR4__(Fb, 6) ^ __ROR4__(Fb, 11) ^ __ROR4__(Fb, 25)) + Aa + (Ha ^ (Gb ^ Ha) & Fb) + W_28 - 1424204075;
  Eb = temp1g + Ea;
  Ab = (Da & (Bb | Cb) | Bb & Cb) + (__ROR4__(Bb, 2) ^ __ROR4__(Bb, 13) ^ __ROR4__(Bb, 22)) + temp1g;
  temp1h = (__ROR4__(Eb, 6) ^ __ROR4__(Eb, 11) ^ __ROR4__(Eb, 25)) + Ha + (Gb ^ (Fb ^ Gb) & Eb) + W_32 - 670586216;
  Db = temp1h + Da;
  Hb = (Cb & (Ab | Bb) | Ab & Bb) + (__ROR4__(Ab, 2) ^ __ROR4__(Ab, 13) ^ __ROR4__(Ab, 22)) + temp1h;
  temp1i = (__ROR4__(Db, 6) ^ __ROR4__(Db, 11) ^ __ROR4__(Db, 25)) + Gb + (Fb ^ (Eb ^ Fb) & Db) + W_36 + 310598401;
  Cc = temp1i + Cb;
  Gc = (Bb & (Hb | Ab) | Hb & Ab) + (__ROR4__(Hb, 2) ^ __ROR4__(Hb, 13) ^ __ROR4__(Hb, 22)) + temp1i;
  temp1j = (__ROR4__(Cc, 6) ^ __ROR4__(Cc, 11) ^ __ROR4__(Cc, 25)) + Fb + (Eb ^ (Db ^ Eb) & Cc) + W_40 + 607225278;
  Bc = temp1j + Bb;
  Fc = (Ab & (Gc | Hb) | Gc & Hb) + (__ROR4__(Gc, 2) ^ __ROR4__(Gc, 13) ^ __ROR4__(Gc, 22)) + temp1j;
  temp1k = (__ROR4__(Bc, 6) ^ __ROR4__(Bc, 11) ^ __ROR4__(Bc, 25)) + Eb + (Db ^ (Cc ^ Db) & Bc) + W_44 + 1426881987;
  Ac = temp1k + Ab;
  Ec = (Hb & (Fc | Gc) | Fc & Gc) + (__ROR4__(Fc, 2) ^ __ROR4__(Fc, 13) ^ __ROR4__(Fc, 22)) + temp1k;
  temp1l = (__ROR4__(Ac, 6) ^ __ROR4__(Ac, 11) ^ __ROR4__(Ac, 25)) + Db + (Cc ^ (Bc ^ Cc) & Ac) + W_48 + 1925078388;
  Hc = temp1l + Hb;
  Dc = (Gc & (Ec | Fc) | Ec & Fc) + (__ROR4__(Ec, 2) ^ __ROR4__(Ec, 13) ^ __ROR4__(Ec, 22)) + temp1l;
  temp1m = (__ROR4__(Hc, 6) ^ __ROR4__(Hc, 11) ^ __ROR4__(Hc, 25)) + Cc + (Bc ^ (Ac ^ Bc) & Hc) + W_52 - 2132889090;
  Gd = temp1m + Gc;
  Cd = (Fc & (Dc | Ec) | Dc & Ec) + (__ROR4__(Dc, 2) ^ __ROR4__(Dc, 13) ^ __ROR4__(Dc, 22)) + temp1m;
  temp1n = (__ROR4__(Gd, 6) ^ __ROR4__(Gd, 11) ^ __ROR4__(Gd, 25)) + Bc + (Ac ^ (Hc ^ Ac) & Gd) + W_56 - 1680079193;
  Fd = temp1n + Fc;
  Bd = (Ec & (Cd | Dc) | Cd & Dc) + (__ROR4__(Cd, 2) ^ __ROR4__(Cd, 13) ^ __ROR4__(Cd, 22)) + temp1n;
  temp1o = (__ROR4__(Fd, 6) ^ __ROR4__(Fd, 11) ^ __ROR4__(Fd, 25)) + Ac + (Hc ^ (Gd ^ Hc) & Fd) + W_60 - 1046744716;
  Ed = temp1o + Ec;
  Ad = (Dc & (Bd | Cd) | Bd & Cd) + (__ROR4__(Bd, 2) ^ __ROR4__(Bd, 13) ^ __ROR4__(Bd, 22)) + temp1o;
  W_64 = (__ROR4__(W_56, 17) ^ __ROR4__(W_56, 19) ^ (W_56 >> 10))
       + W_36
       + ((W_4 >> 3) ^ __ROR4__(W_4, 7) ^ __ROR4__(W_4, 18))
       + W;
  temp1p = (__ROR4__(Ed, 6) ^ __ROR4__(Ed, 11) ^ __ROR4__(Ed, 25)) + Hc + (Gd ^ (Fd ^ Gd) & Ed) + W_64 - 459576895;
  Dd = temp1p + Dc;
  Hd = (Cd & (Ad | Bd) | Ad & Bd) + (__ROR4__(Ad, 2) ^ __ROR4__(Ad, 13) ^ __ROR4__(Ad, 22)) + temp1p;
  W_68 = (__ROR4__(W_60, 17) ^ __ROR4__(W_60, 19) ^ (W_60 >> 10))
       + W_40
       + ((W_8 >> 3) ^ __ROR4__(W_8, 7) ^ __ROR4__(W_8, 18))
       + W_4;
  temp1q = (__ROR4__(Dd, 6) ^ __ROR4__(Dd, 11) ^ __ROR4__(Dd, 25)) + Gd + (Fd ^ (Ed ^ Fd) & Dd) + W_68 - 272742522;
  Ce = temp1q + Cd;
  Ge = (Bd & (Hd | Ad) | Hd & Ad) + (__ROR4__(Hd, 2) ^ __ROR4__(Hd, 13) ^ __ROR4__(Hd, 22)) + temp1q;
  W_72 = (__ROR4__(W_64, 17) ^ __ROR4__(W_64, 19) ^ (W_64 >> 10))
       + W_44
       + ((W_12 >> 3) ^ __ROR4__(W_12, 7) ^ __ROR4__(W_12, 18))
       + W_8;
  temp1r = (__ROR4__(Ce, 6) ^ __ROR4__(Ce, 11) ^ __ROR4__(Ce, 25)) + Fd + (Ed ^ (Dd ^ Ed) & Ce) + W_72 + 264347078;
  Be = temp1r + Bd;
  Fe = (Ad & (Ge | Hd) | Ge & Hd) + (__ROR4__(Ge, 2) ^ __ROR4__(Ge, 13) ^ __ROR4__(Ge, 22)) + temp1r;
  W_76 = (__ROR4__(W_68, 17) ^ __ROR4__(W_68, 19) ^ (W_68 >> 10))
       + W_48
       + ((W_16 >> 3) ^ __ROR4__(W_16, 7) ^ __ROR4__(W_16, 18))
       + W_12;
  temp1s = (__ROR4__(Be, 6) ^ __ROR4__(Be, 11) ^ __ROR4__(Be, 25)) + Ed + (Dd ^ (Ce ^ Dd) & Be) + W_76 + 604807628;
  Ae = temp1s + Ad;
  Ee = (Hd & (Fe | Ge) | Fe & Ge) + (__ROR4__(Fe, 2) ^ __ROR4__(Fe, 13) ^ __ROR4__(Fe, 22)) + temp1s;
  W_80 = (__ROR4__(W_72, 17) ^ __ROR4__(W_72, 19) ^ (W_72 >> 10))
       + W_52
       + ((W_20 >> 3) ^ __ROR4__(W_20, 7) ^ __ROR4__(W_20, 18))
       + W_16;
  temp1t = (__ROR4__(Ae, 6) ^ __ROR4__(Ae, 11) ^ __ROR4__(Ae, 25)) + Dd + (Ce ^ (Be ^ Ce) & Ae) + W_80 + 770255983;
  He = temp1t + Hd;
  De = (Ge & (Ee | Fe) | Ee & Fe) + (__ROR4__(Ee, 2) ^ __ROR4__(Ee, 13) ^ __ROR4__(Ee, 22)) + temp1t;
  W_84 = (__ROR4__(W_76, 17) ^ __ROR4__(W_76, 19) ^ (W_76 >> 10))
       + W_56
       + ((W_24 >> 3) ^ __ROR4__(W_24, 7) ^ __ROR4__(W_24, 18))
       + W_20;
  temp1u = (__ROR4__(He, 6) ^ __ROR4__(He, 11) ^ __ROR4__(He, 25)) + Ce + (Be ^ (Ae ^ Be) & He) + W_84 + 1249150122;
  Gf = temp1u + Ge;
  Cf = (Fe & (De | Ee) | De & Ee) + (__ROR4__(De, 2) ^ __ROR4__(De, 13) ^ __ROR4__(De, 22)) + temp1u;
  W_88 = (__ROR4__(W_80, 17) ^ __ROR4__(W_80, 19) ^ (W_80 >> 10))
       + W_60
       + ((W_28 >> 3) ^ __ROR4__(W_28, 7) ^ __ROR4__(W_28, 18))
       + W_24;
  temp1v = (__ROR4__(Gf, 6) ^ __ROR4__(Gf, 11) ^ __ROR4__(Gf, 25)) + Be + (Ae ^ (He ^ Ae) & Gf) + W_88 + 1555081692;
  Ff = temp1v + Fe;
  Bf = (Ee & (Cf | De) | Cf & De) + (__ROR4__(Cf, 2) ^ __ROR4__(Cf, 13) ^ __ROR4__(Cf, 22)) + temp1v;
  W_92 = (__ROR4__(W_84, 17) ^ __ROR4__(W_84, 19) ^ (W_84 >> 10))
       + W_64
       + ((W_32 >> 3) ^ __ROR4__(W_32, 7) ^ __ROR4__(W_32, 18))
       + W_28;
  temp1w = (__ROR4__(Ff, 6) ^ __ROR4__(Ff, 11) ^ __ROR4__(Ff, 25)) + Ae + (He ^ (Gf ^ He) & Ff) + W_92 + 1996064986;
  Ef = temp1w + Ee;
  Af = (De & (Bf | Cf) | Bf & Cf) + (__ROR4__(Bf, 2) ^ __ROR4__(Bf, 13) ^ __ROR4__(Bf, 22)) + temp1w;
  W_96 = (__ROR4__(W_88, 17) ^ __ROR4__(W_88, 19) ^ (W_88 >> 10))
       + W_68
       + ((W_36 >> 3) ^ __ROR4__(W_36, 7) ^ __ROR4__(W_36, 18))
       + W_32;
  temp1x = (__ROR4__(Ef, 6) ^ __ROR4__(Ef, 11) ^ __ROR4__(Ef, 25)) + He + (Gf ^ (Ff ^ Gf) & Ef) + W_96 - 1740746414;
  Df = temp1x + De;
  Hf = (Cf & (Af | Bf) | Af & Bf) + (__ROR4__(Af, 2) ^ __ROR4__(Af, 13) ^ __ROR4__(Af, 22)) + temp1x;
  W_100 = (__ROR4__(W_92, 17) ^ __ROR4__(W_92, 19) ^ (W_92 >> 10))
        + W_72
        + ((W_40 >> 3) ^ __ROR4__(W_40, 7) ^ __ROR4__(W_40, 18))
        + W_36;
  temp1y = (__ROR4__(Df, 6) ^ __ROR4__(Df, 11) ^ __ROR4__(Df, 25)) + Gf + (Ff ^ (Ef ^ Ff) & Df) + W_100 - 1473132947;
  Cg = temp1y + Cf;
  Gg = (Bf & (Hf | Af) | Hf & Af) + (__ROR4__(Hf, 2) ^ __ROR4__(Hf, 13) ^ __ROR4__(Hf, 22)) + temp1y;
  W_104 = (__ROR4__(W_96, 17) ^ __ROR4__(W_96, 19) ^ (W_96 >> 10))
        + W_76
        + ((W_44 >> 3) ^ __ROR4__(W_44, 7) ^ __ROR4__(W_44, 18))
        + W_40;
  temp1z = (__ROR4__(Cg, 6) ^ __ROR4__(Cg, 11) ^ __ROR4__(Cg, 25)) + Ff + (Ef ^ (Df ^ Ef) & Cg) + W_104 - 1341970488;
  Bg = temp1z + Bf;
  Fg = (Af & (Gg | Hf) | Gg & Hf) + (__ROR4__(Gg, 2) ^ __ROR4__(Gg, 13) ^ __ROR4__(Gg, 22)) + temp1z;
  W_108 = (__ROR4__(W_100, 17) ^ __ROR4__(W_100, 19) ^ (W_100 >> 10))
        + W_80
        + ((W_48 >> 3) ^ __ROR4__(W_48, 7) ^ __ROR4__(W_48, 18))
        + W_44;
  temp1ba = (__ROR4__(Bg, 6) ^ __ROR4__(Bg, 11) ^ __ROR4__(Bg, 25)) + Ef + (Df ^ (Cg ^ Df) & Bg) + W_108 - 1084653625;
  Ag = temp1ba + Af;
  Eg = (Hf & (Fg | Gg) | Fg & Gg) + (__ROR4__(Fg, 2) ^ __ROR4__(Fg, 13) ^ __ROR4__(Fg, 22)) + temp1ba;
  W_112 = (__ROR4__(W_104, 17) ^ __ROR4__(W_104, 19) ^ (W_104 >> 10))
        + W_84
        + ((W_52 >> 3) ^ __ROR4__(W_52, 7) ^ __ROR4__(W_52, 18))
        + W_48;
  temp1bb = (__ROR4__(Ag, 6) ^ __ROR4__(Ag, 11) ^ __ROR4__(Ag, 25)) + Df + (Cg ^ (Bg ^ Cg) & Ag) + W_112 - 958395405;
  Hg = temp1bb + Hf;
  Dg = (Gg & (Eg | Fg) | Eg & Fg) + (__ROR4__(Eg, 2) ^ __ROR4__(Eg, 13) ^ __ROR4__(Eg, 22)) + temp1bb;
  W_116 = (__ROR4__(W_108, 17) ^ __ROR4__(W_108, 19) ^ (W_108 >> 10))
        + W_88
        + ((W_56 >> 3) ^ __ROR4__(W_56, 7) ^ __ROR4__(W_56, 18))
        + W_52;
  temp1bc = (__ROR4__(Hg, 6) ^ __ROR4__(Hg, 11) ^ __ROR4__(Hg, 25)) + Cg + (Bg ^ (Ag ^ Bg) & Hg) + W_116 - 710438585;
  Gh = temp1bc + Gg;
  Ch = (Fg & (Dg | Eg) | Dg & Eg) + (__ROR4__(Dg, 2) ^ __ROR4__(Dg, 13) ^ __ROR4__(Dg, 22)) + temp1bc;
  W_120 = (__ROR4__(W_112, 17) ^ __ROR4__(W_112, 19) ^ (W_112 >> 10))
        + W_92
        + ((W_60 >> 3) ^ __ROR4__(W_60, 7) ^ __ROR4__(W_60, 18))
        + W_56;
  temp1bd = (__ROR4__(Gh, 6) ^ __ROR4__(Gh, 11) ^ __ROR4__(Gh, 25)) + Bg + (Ag ^ (Hg ^ Ag) & Gh) + W_120 + 113926993;
  Fh = temp1bd + Fg;
  Bh = (Eg & (Ch | Dg) | Ch & Dg) + (__ROR4__(Ch, 2) ^ __ROR4__(Ch, 13) ^ __ROR4__(Ch, 22)) + temp1bd;
  W_124 = (__ROR4__(W_116, 17) ^ __ROR4__(W_116, 19) ^ (W_116 >> 10))
        + W_96
        + ((W_64 >> 3) ^ __ROR4__(W_64, 7) ^ __ROR4__(W_64, 18))
        + W_60;
  temp1be = (__ROR4__(Fh, 6) ^ __ROR4__(Fh, 11) ^ __ROR4__(Fh, 25)) + Ag + (Hg ^ (Gh ^ Hg) & Fh) + W_124 + 338241895;
  Eh = temp1be + Eg;
  Ah = (Dg & (Bh | Ch) | Bh & Ch) + (__ROR4__(Bh, 2) ^ __ROR4__(Bh, 13) ^ __ROR4__(Bh, 22)) + temp1be;
  W_128 = (__ROR4__(W_120, 17) ^ __ROR4__(W_120, 19) ^ (W_120 >> 10))
        + W_100
        + ((W_68 >> 3) ^ __ROR4__(W_68, 7) ^ __ROR4__(W_68, 18))
        + W_64;
  temp1bf = (__ROR4__(Eh, 6) ^ __ROR4__(Eh, 11) ^ __ROR4__(Eh, 25)) + Hg + (Gh ^ (Fh ^ Gh) & Eh) + W_128 + 666307205;
  Dh = temp1bf + Dg;
  Hh = (Ch & (Ah | Bh) | Ah & Bh) + (__ROR4__(Ah, 2) ^ __ROR4__(Ah, 13) ^ __ROR4__(Ah, 22)) + temp1bf;
  W_132 = (__ROR4__(W_124, 17) ^ __ROR4__(W_124, 19) ^ (W_124 >> 10))
        + W_104
        + ((W_72 >> 3) ^ __ROR4__(W_72, 7) ^ __ROR4__(W_72, 18))
        + W_68;
  temp1bg = (__ROR4__(Dh, 6) ^ __ROR4__(Dh, 11) ^ __ROR4__(Dh, 25)) + Gh + (Fh ^ (Eh ^ Fh) & Dh) + W_132 + 773529912;
  Ci = temp1bg + Ch;
  Gi = (Bh & (Hh | Ah) | Hh & Ah) + (__ROR4__(Hh, 2) ^ __ROR4__(Hh, 13) ^ __ROR4__(Hh, 22)) + temp1bg;
  W_136 = (__ROR4__(W_128, 17) ^ __ROR4__(W_128, 19) ^ (W_128 >> 10))
        + W_108
        + ((W_76 >> 3) ^ __ROR4__(W_76, 7) ^ __ROR4__(W_76, 18))
        + W_72;
  temp1bh = (__ROR4__(Ci, 6) ^ __ROR4__(Ci, 11) ^ __ROR4__(Ci, 25)) + Fh + (Eh ^ (Dh ^ Eh) & Ci) + W_136 + 1294757372;
  Bi = temp1bh + Bh;
  Fi = (Ah & (Gi | Hh) | Gi & Hh) + (__ROR4__(Gi, 2) ^ __ROR4__(Gi, 13) ^ __ROR4__(Gi, 22)) + temp1bh;
  W_140 = (__ROR4__(W_132, 17) ^ __ROR4__(W_132, 19) ^ (W_132 >> 10))
        + W_112
        + ((W_80 >> 3) ^ __ROR4__(W_80, 7) ^ __ROR4__(W_80, 18))
        + W_76;
  temp1bi = (__ROR4__(Bi, 6) ^ __ROR4__(Bi, 11) ^ __ROR4__(Bi, 25)) + Eh + (Dh ^ (Ci ^ Dh) & Bi) + W_140 + 1396182291;
  Ai = temp1bi + Ah;
  Ei = (Hh & (Fi | Gi) | Fi & Gi) + (__ROR4__(Fi, 2) ^ __ROR4__(Fi, 13) ^ __ROR4__(Fi, 22)) + temp1bi;
  W_144 = (__ROR4__(W_136, 17) ^ __ROR4__(W_136, 19) ^ (W_136 >> 10))
        + W_116
        + ((W_84 >> 3) ^ __ROR4__(W_84, 7) ^ __ROR4__(W_84, 18))
        + W_80;
  temp1bj = (__ROR4__(Ai, 6) ^ __ROR4__(Ai, 11) ^ __ROR4__(Ai, 25)) + Dh + (Ci ^ (Bi ^ Ci) & Ai) + W_144 + 1695183700;
  Hi = temp1bj + Hh;
  Di = (Gi & (Ei | Fi) | Ei & Fi) + (__ROR4__(Ei, 2) ^ __ROR4__(Ei, 13) ^ __ROR4__(Ei, 22)) + temp1bj;
  W_148 = (__ROR4__(W_140, 17) ^ __ROR4__(W_140, 19) ^ (W_140 >> 10))
        + W_120
        + ((W_88 >> 3) ^ __ROR4__(W_88, 7) ^ __ROR4__(W_88, 18))
        + W_84;
  temp1bk = (__ROR4__(Hi, 6) ^ __ROR4__(Hi, 11) ^ __ROR4__(Hi, 25)) + Ci + (Bi ^ (Ai ^ Bi) & Hi) + W_148 + 1986661051;
  Gj = temp1bk + Gi;
  Cj = (Fi & (Di | Ei) | Di & Ei) + (__ROR4__(Di, 2) ^ __ROR4__(Di, 13) ^ __ROR4__(Di, 22)) + temp1bk;
  W_152 = (__ROR4__(W_144, 17) ^ __ROR4__(W_144, 19) ^ (W_144 >> 10))
        + W_124
        + ((W_92 >> 3) ^ __ROR4__(W_92, 7) ^ __ROR4__(W_92, 18))
        + W_88;
  temp1bl = (__ROR4__(Gj, 6) ^ __ROR4__(Gj, 11) ^ __ROR4__(Gj, 25)) + Bi + (Ai ^ (Hi ^ Ai) & Gj) + W_152 - 2117940946;
  Fj = temp1bl + Fi;
  Bj = (Ei & (Cj | Di) | Cj & Di) + (__ROR4__(Cj, 2) ^ __ROR4__(Cj, 13) ^ __ROR4__(Cj, 22)) + temp1bl;
  W_156 = (__ROR4__(W_148, 17) ^ __ROR4__(W_148, 19) ^ (W_148 >> 10))
        + W_128
        + ((W_96 >> 3) ^ __ROR4__(W_96, 7) ^ __ROR4__(W_96, 18))
        + W_92;
  temp1bm = (__ROR4__(Fj, 6) ^ __ROR4__(Fj, 11) ^ __ROR4__(Fj, 25)) + Ai + (Hi ^ (Gj ^ Hi) & Fj) + W_156 - 1838011259;
  Ej = temp1bm + Ei;
  Aj = (Di & (Bj | Cj) | Bj & Cj) + (__ROR4__(Bj, 2) ^ __ROR4__(Bj, 13) ^ __ROR4__(Bj, 22)) + temp1bm;
  W_160 = (__ROR4__(W_152, 17) ^ __ROR4__(W_152, 19) ^ (W_152 >> 10))
        + W_132
        + ((W_100 >> 3) ^ __ROR4__(W_100, 7) ^ __ROR4__(W_100, 18))
        + W_96;
  temp1bn = (__ROR4__(Ej, 6) ^ __ROR4__(Ej, 11) ^ __ROR4__(Ej, 25)) + Hi + (Gj ^ (Fj ^ Gj) & Ej) + W_160 - 1564481375;
  Dj = temp1bn + Di;
  Hj = (Cj & (Aj | Bj) | Aj & Bj) + (__ROR4__(Aj, 2) ^ __ROR4__(Aj, 13) ^ __ROR4__(Aj, 22)) + temp1bn;
  W_164 = (__ROR4__(W_156, 17) ^ __ROR4__(W_156, 19) ^ (W_156 >> 10))
        + W_136
        + ((W_104 >> 3) ^ __ROR4__(W_104, 7) ^ __ROR4__(W_104, 18))
        + W_100;
  temp1bo = (__ROR4__(Dj, 6) ^ __ROR4__(Dj, 11) ^ __ROR4__(Dj, 25)) + Gj + (Fj ^ (Ej ^ Fj) & Dj) + W_164 - 1474664885;
  Ck = temp1bo + Cj;
  Gk = (Bj & (Hj | Aj) | Hj & Aj) + (__ROR4__(Hj, 2) ^ __ROR4__(Hj, 13) ^ __ROR4__(Hj, 22)) + temp1bo;
  W_168 = (__ROR4__(W_160, 17) ^ __ROR4__(W_160, 19) ^ (W_160 >> 10))
        + W_140
        + ((W_108 >> 3) ^ __ROR4__(W_108, 7) ^ __ROR4__(W_108, 18))
        + W_104;
  temp1bp = (__ROR4__(Ck, 6) ^ __ROR4__(Ck, 11) ^ __ROR4__(Ck, 25)) + Fj + (Ej ^ (Dj ^ Ej) & Ck) + W_168 - 1035236496;
  Bk = temp1bp + Bj;
  Fk = (Aj & (Gk | Hj) | Gk & Hj) + (__ROR4__(Gk, 2) ^ __ROR4__(Gk, 13) ^ __ROR4__(Gk, 22)) + temp1bp;
  W_172 = (__ROR4__(W_164, 17) ^ __ROR4__(W_164, 19) ^ (W_164 >> 10))
        + W_144
        + ((W_112 >> 3) ^ __ROR4__(W_112, 7) ^ __ROR4__(W_112, 18))
        + W_108;
  temp1bq = (__ROR4__(Bk, 6) ^ __ROR4__(Bk, 11) ^ __ROR4__(Bk, 25)) + Ej + (Dj ^ (Ck ^ Dj) & Bk) + W_172 - 949202525;
  Ak = temp1bq + Aj;
  Ek = (Hj & (Fk | Gk) | Fk & Gk) + (__ROR4__(Fk, 2) ^ __ROR4__(Fk, 13) ^ __ROR4__(Fk, 22)) + temp1bq;
  W_176 = (__ROR4__(W_168, 17) ^ __ROR4__(W_168, 19) ^ (W_168 >> 10))
        + W_148
        + ((W_116 >> 3) ^ __ROR4__(W_116, 7) ^ __ROR4__(W_116, 18))
        + W_112;
  temp1br = (__ROR4__(Ak, 6) ^ __ROR4__(Ak, 11) ^ __ROR4__(Ak, 25)) + Dj + (Ck ^ (Bk ^ Ck) & Ak) + W_176 - 778901479;
  Hk = temp1br + Hj;
  Dk = (Gk & (Ek | Fk) | Ek & Fk) + (__ROR4__(Ek, 2) ^ __ROR4__(Ek, 13) ^ __ROR4__(Ek, 22)) + temp1br;
  W_180 = (__ROR4__(W_172, 17) ^ __ROR4__(W_172, 19) ^ (W_172 >> 10))
        + W_152
        + ((W_120 >> 3) ^ __ROR4__(W_120, 7) ^ __ROR4__(W_120, 18))
        + W_116;
  temp1bs = (__ROR4__(Hk, 6) ^ __ROR4__(Hk, 11) ^ __ROR4__(Hk, 25)) + Ck + (Bk ^ (Ak ^ Bk) & Hk) + W_180 - 694614492;
  Gl = temp1bs + Gk;
  Cl = (Fk & (Dk | Ek) | Dk & Ek) + (__ROR4__(Dk, 2) ^ __ROR4__(Dk, 13) ^ __ROR4__(Dk, 22)) + temp1bs;
  W_184 = (__ROR4__(W_176, 17) ^ __ROR4__(W_176, 19) ^ (W_176 >> 10))
        + W_156
        + ((W_124 >> 3) ^ __ROR4__(W_124, 7) ^ __ROR4__(W_124, 18))
        + W_120;
  temp1bt = (__ROR4__(Gl, 6) ^ __ROR4__(Gl, 11) ^ __ROR4__(Gl, 25)) + Bk + (Ak ^ (Hk ^ Ak) & Gl) + W_184 - 200395387;
  Fl = temp1bt + Fk;
  Bl = (Ek & (Cl | Dk) | Cl & Dk) + (__ROR4__(Cl, 2) ^ __ROR4__(Cl, 13) ^ __ROR4__(Cl, 22)) + temp1bt;
  W_188 = (__ROR4__(W_180, 17) ^ __ROR4__(W_180, 19) ^ (W_180 >> 10))
        + W_160
        + ((W_128 >> 3) ^ __ROR4__(W_128, 7) ^ __ROR4__(W_128, 18))
        + W_124;
  temp1bu = (__ROR4__(Fl, 6) ^ __ROR4__(Fl, 11) ^ __ROR4__(Fl, 25)) + Ak + (Hk ^ (Gl ^ Hk) & Fl) + W_188 + 275423344;
  El = temp1bu + Ek;
  Al = (Dk & (Bl | Cl) | Bl & Cl) + (__ROR4__(Bl, 2) ^ __ROR4__(Bl, 13) ^ __ROR4__(Bl, 22)) + temp1bu;
  W_192 = (__ROR4__(W_184, 17) ^ __ROR4__(W_184, 19) ^ (W_184 >> 10))
        + W_164
        + ((W_132 >> 3) ^ __ROR4__(W_132, 7) ^ __ROR4__(W_132, 18))
        + W_128;
  temp1bv = (__ROR4__(El, 6) ^ __ROR4__(El, 11) ^ __ROR4__(El, 25)) + Hk + (Gl ^ (Fl ^ Gl) & El) + W_192 + 430227734;
  Dl = temp1bv + Dk;
  Hl = (Cl & (Al | Bl) | Al & Bl) + (__ROR4__(Al, 2) ^ __ROR4__(Al, 13) ^ __ROR4__(Al, 22)) + temp1bv;
  W_196 = (__ROR4__(W_188, 17) ^ __ROR4__(W_188, 19) ^ (W_188 >> 10))
        + W_168
        + ((W_136 >> 3) ^ __ROR4__(W_136, 7) ^ __ROR4__(W_136, 18))
        + W_132;
  temp1bw = (__ROR4__(Dl, 6) ^ __ROR4__(Dl, 11) ^ __ROR4__(Dl, 25)) + Gl + (Fl ^ (El ^ Fl) & Dl) + W_196 + 506948616;
  Cm = temp1bw + Cl;
  Gm = (Bl & (Hl | Al) | Hl & Al) + (__ROR4__(Hl, 2) ^ __ROR4__(Hl, 13) ^ __ROR4__(Hl, 22)) + temp1bw;
  W_200 = (__ROR4__(W_192, 17) ^ __ROR4__(W_192, 19) ^ (W_192 >> 10))
        + W_172
        + ((W_140 >> 3) ^ __ROR4__(W_140, 7) ^ __ROR4__(W_140, 18))
        + W_136;
  temp1bx = (__ROR4__(Cm, 6) ^ __ROR4__(Cm, 11) ^ __ROR4__(Cm, 25)) + Fl + (El ^ (Dl ^ El) & Cm) + W_200 + 659060556;
  Bm = temp1bx + Bl;
  Fm = (Al & (Gm | Hl) | Gm & Hl) + (__ROR4__(Gm, 2) ^ __ROR4__(Gm, 13) ^ __ROR4__(Gm, 22)) + temp1bx;
  W_204 = (__ROR4__(W_196, 17) ^ __ROR4__(W_196, 19) ^ (W_196 >> 10))
        + W_176
        + ((W_144 >> 3) ^ __ROR4__(W_144, 7) ^ __ROR4__(W_144, 18))
        + W_140;
  temp1by = (__ROR4__(Bm, 6) ^ __ROR4__(Bm, 11) ^ __ROR4__(Bm, 25)) + El + (Dl ^ (Cm ^ Dl) & Bm) + W_204 + 883997877;
  Am = temp1by + Al;
  Em = (Hl & (Fm | Gm) | Fm & Gm) + (__ROR4__(Fm, 2) ^ __ROR4__(Fm, 13) ^ __ROR4__(Fm, 22)) + temp1by;
  W_208 = (__ROR4__(W_200, 17) ^ __ROR4__(W_200, 19) ^ (W_200 >> 10))
        + W_180
        + ((W_148 >> 3) ^ __ROR4__(W_148, 7) ^ __ROR4__(W_148, 18))
        + W_144;
  temp1bz = (__ROR4__(Am, 6) ^ __ROR4__(Am, 11) ^ __ROR4__(Am, 25)) + Dl + (Cm ^ (Bm ^ Cm) & Am) + W_208 + 958139571;
  Hm = temp1bz + Hl;
  Dm = (Gm & (Em | Fm) | Em & Fm) + (__ROR4__(Em, 2) ^ __ROR4__(Em, 13) ^ __ROR4__(Em, 22)) + temp1bz;
  W_212 = (__ROR4__(W_204, 17) ^ __ROR4__(W_204, 19) ^ (W_204 >> 10))
        + W_184
        + ((W_152 >> 3) ^ __ROR4__(W_152, 7) ^ __ROR4__(W_152, 18))
        + W_148;
  temp1ca = (__ROR4__(Hm, 6) ^ __ROR4__(Hm, 11) ^ __ROR4__(Hm, 25)) + Cm + (Bm ^ (Am ^ Bm) & Hm) + W_212 + 1322822218;
  Gn = temp1ca + Gm;
  Cn = (Fm & (Dm | Em) | Dm & Em) + (__ROR4__(Dm, 2) ^ __ROR4__(Dm, 13) ^ __ROR4__(Dm, 22)) + temp1ca;
  W_216 = (__ROR4__(W_208, 17) ^ __ROR4__(W_208, 19) ^ (W_208 >> 10))
        + W_188
        + ((W_156 >> 3) ^ __ROR4__(W_156, 7) ^ __ROR4__(W_156, 18))
        + W_152;
  temp1cb = (__ROR4__(Gn, 6) ^ __ROR4__(Gn, 11) ^ __ROR4__(Gn, 25)) + Bm + (Am ^ (Hm ^ Am) & Gn) + W_216 + 1537002063;
  Fn = temp1cb + Fm;
  Bn = (Em & (Cn | Dm) | Cn & Dm) + (__ROR4__(Cn, 2) ^ __ROR4__(Cn, 13) ^ __ROR4__(Cn, 22)) + temp1cb;
  W_220 = (__ROR4__(W_212, 17) ^ __ROR4__(W_212, 19) ^ (W_212 >> 10))
        + W_192
        + ((W_160 >> 3) ^ __ROR4__(W_160, 7) ^ __ROR4__(W_160, 18))
        + W_156;
  temp1cc = (__ROR4__(Fn, 6) ^ __ROR4__(Fn, 11) ^ __ROR4__(Fn, 25)) + Am + (Hm ^ (Gn ^ Hm) & Fn) + W_220 + 1747873779;
  En = temp1cc + Em;
  An = (Dm & (Bn | Cn) | Bn & Cn) + (__ROR4__(Bn, 2) ^ __ROR4__(Bn, 13) ^ __ROR4__(Bn, 22)) + temp1cc;
  W_224 = (__ROR4__(W_216, 17) ^ __ROR4__(W_216, 19) ^ (W_216 >> 10))
        + W_196
        + ((W_164 >> 3) ^ __ROR4__(W_164, 7) ^ __ROR4__(W_164, 18))
        + W_160;
  temp1cd = (__ROR4__(En, 6) ^ __ROR4__(En, 11) ^ __ROR4__(En, 25)) + Hm + (Gn ^ (Fn ^ Gn) & En) + W_224 + 1955562222;
  Dn = temp1cd + Dm;
  Hn = (Cn & (An | Bn) | An & Bn) + (__ROR4__(An, 2) ^ __ROR4__(An, 13) ^ __ROR4__(An, 22)) + temp1cd;
  W_228 = (__ROR4__(W_220, 17) ^ __ROR4__(W_220, 19) ^ (W_220 >> 10))
        + W_200
        + ((W_168 >> 3) ^ __ROR4__(W_168, 7) ^ __ROR4__(W_168, 18))
        + W_164;
  temp1ce = (__ROR4__(Dn, 6) ^ __ROR4__(Dn, 11) ^ __ROR4__(Dn, 25)) + Gn + (Fn ^ (En ^ Fn) & Dn) + W_228 + 2024104815;
  Co = temp1ce + Cn;
  Go = (Bn & (Hn | An) | Hn & An) + (__ROR4__(Hn, 2) ^ __ROR4__(Hn, 13) ^ __ROR4__(Hn, 22)) + temp1ce;
  W_232 = (__ROR4__(W_224, 17) ^ __ROR4__(W_224, 19) ^ (W_224 >> 10))
        + W_204
        + ((W_172 >> 3) ^ __ROR4__(W_172, 7) ^ __ROR4__(W_172, 18))
        + W_168;
  temp1cf = (__ROR4__(Co, 6) ^ __ROR4__(Co, 11) ^ __ROR4__(Co, 25)) + Fn + (En ^ (Dn ^ En) & Co) + W_232 - 2067236844;
  Bo = temp1cf + Bn;
  Fo = (An & (Go | Hn) | Go & Hn) + (__ROR4__(Go, 2) ^ __ROR4__(Go, 13) ^ __ROR4__(Go, 22)) + temp1cf;
  W_236 = (__ROR4__(W_228, 17) ^ __ROR4__(W_228, 19) ^ (W_228 >> 10))
        + W_208
        + ((W_176 >> 3) ^ __ROR4__(W_176, 7) ^ __ROR4__(W_176, 18))
        + W_172;
  temp1cg = (__ROR4__(Bo, 6) ^ __ROR4__(Bo, 11) ^ __ROR4__(Bo, 25)) + En + (Dn ^ (Co ^ Dn) & Bo) + W_236 - 1933114872;
  Ao = temp1cg + An;
  Eo = (Hn & (Fo | Go) | Fo & Go) + (__ROR4__(Fo, 2) ^ __ROR4__(Fo, 13) ^ __ROR4__(Fo, 22)) + temp1cg;
  W_240 = (__ROR4__(W_232, 17) ^ __ROR4__(W_232, 19) ^ (W_232 >> 10))
        + W_212
        + ((W_180 >> 3) ^ __ROR4__(W_180, 7) ^ __ROR4__(W_180, 18))
        + W_176;
  temp1ch = (__ROR4__(Ao, 6) ^ __ROR4__(Ao, 11) ^ __ROR4__(Ao, 25)) + Dn + (Co ^ (Bo ^ Co) & Ao) + W_240 - 1866530822;
  Ho = temp1ch + Hn;
  Do = (Go & (Eo | Fo) | Eo & Fo) + (__ROR4__(Eo, 2) ^ __ROR4__(Eo, 13) ^ __ROR4__(Eo, 22)) + temp1ch;
  W_244 = (__ROR4__(W_236, 17) ^ __ROR4__(W_236, 19) ^ (W_236 >> 10))
        + W_216
        + ((W_184 >> 3) ^ __ROR4__(W_184, 7) ^ __ROR4__(W_184, 18))
        + W_180;
  temp1ci = (__ROR4__(Ho, 6) ^ __ROR4__(Ho, 11) ^ __ROR4__(Ho, 25)) + Co + (Bo ^ (Ao ^ Bo) & Ho) + W_244 - 1538233109;
  Gp = temp1ci + Go;
  Cp = (Fo & (Do | Eo) | Do & Eo) + (__ROR4__(Do, 2) ^ __ROR4__(Do, 13) ^ __ROR4__(Do, 22)) + temp1ci;
  temp1cj = (__ROR4__(Gp, 6) ^ __ROR4__(Gp, 11) ^ __ROR4__(Gp, 25))
          + Bo
          + (Ao ^ (Ho ^ Ao) & Gp)
          + (__ROR4__(W_240, 17) ^ __ROR4__(W_240, 19) ^ (W_240 >> 10))
          + W_220
          + ((W_188 >> 3) ^ __ROR4__(W_188, 7) ^ __ROR4__(W_188, 18))
          + W_184
          - 1090935817;
  Fp = temp1cj + Fo;
  Bp = (Eo & (Cp | Do) | Cp & Do) + (__ROR4__(Cp, 2) ^ __ROR4__(Cp, 13) ^ __ROR4__(Cp, 22)) + temp1cj;
  temp1ck = (__ROR4__(Fp, 6) ^ __ROR4__(Fp, 11) ^ __ROR4__(Fp, 25))
          + Ao
          + (Ho ^ (Gp ^ Ho) & Fp)
          + (__ROR4__(W_244, 17) ^ __ROR4__(W_244, 19) ^ (W_244 >> 10))
          + W_224
          + ((W_192 >> 3) ^ __ROR4__(W_192, 7) ^ __ROR4__(W_192, 18))
          + W_188
          - 965641998;
  ctx->state[0] += (Do & (Bp | Cp) | Bp & Cp) + (__ROR4__(Bp, 2) ^ __ROR4__(Bp, 13) ^ __ROR4__(Bp, 22)) + temp1ck;
  ctx->state[1] += Bp;
  ctx->state[2] += Cp;
  ctx->state[3] += Do;
  ctx->state[4] += temp1ck + Eo;
  ctx->state[5] += Fp;
  ctx->state[6] += Gp;
  ctx->state[7] += Ho;
}

//----- (000790B0) --------------------------------------------------------
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  signed int ilena; // [sp+4h] [bp+4h]
  const unsigned __int8 *inputa; // [sp+8h] [bp+8h]
  signed int fill; // [sp+10h] [bp+10h]
  uint32_t left; // [sp+14h] [bp+14h]

  inputa = input;
  ilena = ilen;
  if ( ilen > 0 )
  {
    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    ctx->total[0] += ilen;
    ctx->total[0] = ctx->total[0];
    if ( ctx->total[0] < ilen )
      ++ctx->total[1];
    if ( left && ilen >= fill )
    {
      memcpy(&ctx->buffer[left], input, fill);
      sha2_process(ctx, ctx->buffer);
      inputa += fill;
      ilena -= fill;
      left = 0;
    }
    while ( ilena > 63 )
    {
      sha2_process(ctx, inputa);
      inputa += 64;
      ilena -= 64;
    }
    if ( ilena > 0 )
      memcpy(&ctx->buffer[left], inputa, ilena);
  }
}

//----- (0007917E) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  uint32_t v2; // r3
  unsigned __int8 msglen[8]; // [sp+8h] [bp+8h] BYREF
  uint32_t padn; // [sp+10h] [bp+10h]
  uint32_t last; // [sp+14h] [bp+14h]
  __int64 low; // [sp+18h] [bp+18h] OVERLAPPED

  low = 8LL * *(_QWORD *)ctx->total;
  msglen[0] = HIBYTE(low);
  msglen[1] = BYTE6(low);
  msglen[2] = BYTE5(low);
  msglen[3] = BYTE4(low);
  msglen[4] = BYTE3(low);
  msglen[5] = BYTE2(low);
  msglen[6] = BYTE1(low);
  msglen[7] = low;
  last = ctx->total[0] & 0x3F;
  if ( last > 0x37 )
    v2 = 120 - last;
  else
    v2 = 56 - last;
  padn = v2;
  sha2_update(ctx, sha2_padding, v2);
  sha2_update(ctx, msglen, 8);
  *output = HIBYTE(ctx->state[0]);
  output[1] = BYTE2(ctx->state[0]);
  output[2] = BYTE1(ctx->state[0]);
  output[3] = ctx->state[0];
  output[4] = HIBYTE(ctx->state[1]);
  output[5] = BYTE2(ctx->state[1]);
  output[6] = BYTE1(ctx->state[1]);
  output[7] = ctx->state[1];
  output[8] = HIBYTE(ctx->state[2]);
  output[9] = BYTE2(ctx->state[2]);
  output[10] = BYTE1(ctx->state[2]);
  output[11] = ctx->state[2];
  output[12] = HIBYTE(ctx->state[3]);
  output[13] = BYTE2(ctx->state[3]);
  output[14] = BYTE1(ctx->state[3]);
  output[15] = ctx->state[3];
  output[16] = HIBYTE(ctx->state[4]);
  output[17] = BYTE2(ctx->state[4]);
  output[18] = BYTE1(ctx->state[4]);
  output[19] = ctx->state[4];
  output[20] = HIBYTE(ctx->state[5]);
  output[21] = BYTE2(ctx->state[5]);
  output[22] = BYTE1(ctx->state[5]);
  output[23] = ctx->state[5];
  output[24] = HIBYTE(ctx->state[6]);
  output[25] = BYTE2(ctx->state[6]);
  output[26] = BYTE1(ctx->state[6]);
  output[27] = ctx->state[6];
  output[28] = HIBYTE(ctx->state[7]);
  output[29] = BYTE2(ctx->state[7]);
  output[30] = BYTE1(ctx->state[7]);
  output[31] = ctx->state[7];
}
// 7917E: variables would overlap: ^18.8 and stkvar "low" ^18.4(has user info),stkvar "high" ^1C.4(has user info)

//----- (000793D2) --------------------------------------------------------
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  sha2_context ctx; // [sp+10h] [bp+10h] BYREF

  sha2_starts(&ctx);
  sha2_update(&ctx, input, ilen);
  sha2_finish(&ctx, output);
  memset(&ctx, 0, sizeof(ctx));
}

//----- (00079418) --------------------------------------------------------
unsigned __int8 *__cdecl arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg)
{
  size_t v2; // r4
  size_t v3; // r0
  unsigned __int8 *str; // [sp+Ch] [bp+Ch]

  v2 = strlen((const char *)fmt);
  v3 = strlen((const char *)arg);
  str = (unsigned __int8 *)malloc(v3 + v2);
  sprintf((char *)str, (const char *)fmt, arg);
  return str;
}

//----- (00079452) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_bool(bool *b)
{
  *b = 1;
  return 0;
}

//----- (0007946E) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_false(bool *b)
{
  *b = 0;
  return 0;
}

//----- (0007948A) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_invbool(bool *b)
{
  *b = 0;
  return 0;
}

//----- (000794A6) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p)
{
  *p = (unsigned __int8 *)arg;
  return 0;
}

//----- (000794C4) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_intval(const unsigned __int8 *arg, int *i)
{
  int l; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *err; // [sp+Ch] [bp+Ch]

  err = opt_set_longval(arg, &l);
  if ( err )
    return err;
  *i = l;
  if ( *i == l )
    return err;
  else
    return arg_bad("value '%s' does not fit into an integer", arg);
}

//----- (00079512) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_floatval(const unsigned __int8 *arg, float *f)
{
  int v2; // s0
  unsigned __int8 *endp; // [sp+Ch] [bp+Ch] BYREF

  *_errno_location() = 0;
  strtof(arg, &endp);
  *(_DWORD *)f = v2;
  if ( *endp || !*arg )
    return arg_bad("'%s' is not a number", arg);
  if ( *_errno_location() )
    return arg_bad("'%s' is out of range", arg);
  return 0;
}
// 79538: variable 'v2' is possibly undefined
// 1221C: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (00079586) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_longval(const unsigned __int8 *arg, int *l)
{
  unsigned __int8 *endp; // [sp+Ch] [bp+Ch] BYREF

  *_errno_location() = 0;
  *l = strtol((const char *)arg, (char **)&endp, 0);
  if ( *endp || !*arg )
    return arg_bad("'%s' is not a number", arg);
  if ( *_errno_location() )
    return arg_bad("'%s' is out of range", arg);
  return 0;
}

//----- (000795F8) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_version_and_exit(const unsigned __int8 *version)
{
  puts((const char *)version);
  fflush((FILE *)stdout);
  exit(0);
}
// AC42C: using guessed type int stdout;

//----- (0007961C) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_usage_and_exit(const unsigned __int8 *extra)
{
  unsigned __int8 *v1; // r0

  v1 = opt_usage(opt_argv0, extra);
  printf("%s", (const char *)v1);
  fflush((FILE *)stdout);
  exit(0);
}
// AC42C: using guessed type int stdout;

//----- (0007965C) --------------------------------------------------------
void __cdecl opt_show_intval(unsigned __int8 *buf, const int *i)
{
  snprintf((char *)buf, 0x50u, "%i", *i);
}

//----- (00079682) --------------------------------------------------------
void __cdecl opt_show_floatval(unsigned __int8 *buf, const float *f)
{
  snprintf((char *)buf, 0x50u, "%.1f", *f);
}

//----- (000796B2) --------------------------------------------------------
const unsigned __int8 *__cdecl first_name(const unsigned __int8 *names, unsigned int *len)
{
  *len = strcspn((const char *)names + 1, (const char *)&off_96A1C);
  return names + 1;
}
// 96A1C: using guessed type void *off_96A1C;

//----- (000796E0) --------------------------------------------------------
const unsigned __int8 *__cdecl next_name(const unsigned __int8 *names, unsigned int *len)
{
  const unsigned __int8 *namesa; // [sp+4h] [bp+4h]

  namesa = &names[*len];
  if ( *namesa == 32 || *namesa == 61 || !*namesa )
    return 0;
  else
    return first_name(namesa + 1, len);
}

//----- (00079726) --------------------------------------------------------
const unsigned __int8 *__cdecl first_opt(unsigned int *i, unsigned int *len)
{
  for ( *i = 0; *i < opt_count; ++*i )
  {
    if ( opt_table_0[*i].type != OPT_SUBTABLE )
      return first_name(opt_table_0[*i].names, len);
  }
  return 0;
}

//----- (000797A4) --------------------------------------------------------
const unsigned __int8 *__cdecl next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  while ( *i < opt_count )
  {
    if ( opt_table_0[*i].type != OPT_SUBTABLE )
    {
      if ( !p )
        return first_name(opt_table_0[*i].names, len);
      p = next_name(p, len);
      if ( p )
        return p;
    }
    ++*i;
  }
  return 0;
}

//----- (00079838) --------------------------------------------------------
const unsigned __int8 *__cdecl first_lopt(unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *p; // [sp+Ch] [bp+Ch]

  for ( p = first_opt(i, len); p; p = next_opt(p, i, len) )
  {
    if ( *p == 45 )
    {
      --*len;
      ++p;
      return p;
    }
  }
  return p;
}

//----- (00079884) --------------------------------------------------------
const unsigned __int8 *__cdecl next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *pa; // [sp+Ch] [bp+Ch]

  for ( pa = next_opt(p, i, len); pa; pa = next_opt(pa, i, len) )
  {
    if ( *pa == 45 )
    {
      --*len;
      ++pa;
      return pa;
    }
  }
  return pa;
}

//----- (000798D4) --------------------------------------------------------
const unsigned __int8 *__cdecl first_sopt(unsigned int *i)
{
  unsigned int len; // [sp+8h] [bp+8h] BYREF
  const unsigned __int8 *p; // [sp+Ch] [bp+Ch]

  len = 0;
  for ( p = first_opt(i, &len); p && *p == 45; p = next_opt(p, i, &len) )
    ;
  return p;
}

//----- (0007991C) --------------------------------------------------------
const unsigned __int8 *__cdecl next_sopt(const unsigned __int8 *p, unsigned int *i)
{
  const unsigned __int8 *pa; // [sp+4h] [bp+4h]
  unsigned int len; // [sp+Ch] [bp+Ch] BYREF

  len = 1;
  for ( pa = next_opt(p, i, &len); pa && *pa == 45; pa = next_opt(pa, i, &len) )
    ;
  return pa;
}

//----- (00079968) --------------------------------------------------------
void __cdecl check_opt(const opt_table *entry)
{
  unsigned int len; // [sp+10h] [bp+8h] BYREF
  const unsigned __int8 *p; // [sp+14h] [bp+Ch]

  if ( entry->type != OPT_HASARG && entry->type != OPT_NOARG && entry->type != OPT_PROCESSARG )
    errx(1, "Option %s: unknown entry type %u", (const char *)entry->names, entry->type);
  if ( !entry->desc )
    errx(1, "Option %s: description cannot be NULL", (const char *)entry->names);
  if ( *entry->names != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)entry->names);
  for ( p = first_name(entry->names, &len); p; p = next_name(p, &len) )
  {
    if ( *p == 45 )
    {
      if ( len == 1 )
        errx(1, "Option %s: invalid long option '--'", (const char *)entry->names);
      ++opt_num_long;
    }
    else
    {
      if ( len != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", (const char *)entry->names, len + 1, (const char *)p - 1);
      ++opt_num_short;
      if ( entry->type == OPT_HASARG || entry->type == OPT_PROCESSARG )
        ++opt_num_short_arg;
    }
    if ( entry->type == OPT_NOARG && (p[len] == 32 || p[len] == 61) )
      errx(1, "Option %s: does not take arguments '%s'", (const char *)entry->names, (const char *)&p[len + 1]);
  }
}

//----- (00079ADE) --------------------------------------------------------
void __cdecl add_opt(const opt_table *entry)
{
  unsigned int v1; // r2
  opt_table *v2; // r4
  opt_type type; // r1
  unsigned __int8 *(*cb)(void *); // r2
  unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *); // r3
  const void *carg; // r1
  const unsigned __int8 *desc; // r2

  opt_table_0 = (opt_table *)realloc(opt_table_0, 28 * (opt_count + 1));
  v1 = opt_count++;
  v2 = &opt_table_0[v1];
  type = entry->type;
  cb = entry->cb;
  cb_arg = entry->cb_arg;
  v2->names = entry->names;
  v2->type = type;
  v2->cb = cb;
  v2->cb_arg = cb_arg;
  v2 = (opt_table *)((char *)v2 + 16);
  carg = entry->u.carg;
  desc = entry->desc;
  v2->names = (const unsigned __int8 *)entry->show;
  v2->type = (opt_type)carg;
  v2->cb = (unsigned __int8 *(*)(void *))desc;
}

//----- (00079B5A) --------------------------------------------------------
void __cdecl opt_register_table(const opt_table *entry, const unsigned __int8 *desc)
{
  opt_table heading; // [sp+Ch] [bp+Ch] BYREF
  unsigned int start; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  start = opt_count;
  if ( desc )
  {
    heading.names = 0;
    heading.type = OPT_SUBTABLE;
    memset(&heading.cb, 0, 16);
    heading.desc = desc;
    add_opt(&heading);
  }
  for ( i = 0; entry[i].type != OPT_END; ++i )
  {
    if ( entry[i].type == OPT_SUBTABLE )
    {
      opt_register_table((const opt_table *)entry[i].names, entry[i].desc);
    }
    else
    {
      check_opt(&entry[i]);
      add_opt(&entry[i]);
    }
  }
  if ( desc )
    opt_table_0[start].u.tlen = opt_count - start;
}

//----- (00079C60) --------------------------------------------------------
bool __cdecl opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...))
{
  unsigned int offset; // [sp+10h] [bp+10h] BYREF
  int ret; // [sp+14h] [bp+14h]

  offset = 0;
  opt_argv0 = *argv;
  do
    ret = parse_one(argc, argv, &offset, errlog);
  while ( ret == 1 );
  return ret == 0;
}

//----- (00079CA8) --------------------------------------------------------
unsigned int __cdecl write_short_options(unsigned __int8 *str)
{
  unsigned int v1; // r3
  unsigned int i; // [sp+Ch] [bp+Ch] BYREF
  const unsigned __int8 *p; // [sp+10h] [bp+10h]
  unsigned int num; // [sp+14h] [bp+14h]

  num = 0;
  for ( p = first_sopt(&i); p; p = next_sopt(p, &i) )
  {
    if ( opt_table_0[i].desc != opt_hidden )
    {
      v1 = num++;
      str[v1] = *p;
    }
  }
  return num;
}

//----- (00079D14) --------------------------------------------------------
unsigned __int8 *__cdecl opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra)
{
  size_t v2; // r4
  int v4; // r0
  unsigned int v5; // r2
  int v6; // r0
  int v7; // r0
  int v8; // r0
  const unsigned __int8 *extraa; // [sp+0h] [bp+0h]
  unsigned __int8 buf[84]; // [sp+8h] [bp+8h] BYREF
  unsigned int num; // [sp+5Ch] [bp+5Ch]
  unsigned __int8 *ret; // [sp+60h] [bp+60h]
  unsigned __int8 *p; // [sp+64h] [bp+64h]
  unsigned int len; // [sp+68h] [bp+68h]
  unsigned int i; // [sp+6Ch] [bp+6Ch]

  extraa = extra;
  if ( !extra )
  {
    extraa = (const unsigned __int8 *)&unk_96B1C;
    for ( i = 0; i < opt_count; ++i )
    {
      if ( (unsigned __int8 *(__cdecl *)(const unsigned __int8 *))opt_table_0[i].cb == opt_usage_and_exit
        && opt_table_0[i].u.tlen )
      {
        extraa = (const unsigned __int8 *)opt_table_0[i].u.carg;
        break;
      }
    }
  }
  v2 = strlen((const char *)argv0) + opt_num_short;
  len = strlen((const char *)extraa) + v2 + 20;
  for ( i = 0; i < opt_count; ++i )
  {
    if ( opt_table_0[i].type == OPT_SUBTABLE )
    {
      len += strlen((const char *)opt_table_0[i].desc) + 3;
    }
    else if ( opt_table_0[i].desc != opt_hidden )
    {
      len += strlen((const char *)opt_table_0[i].names) + 6;
      len += strlen((const char *)opt_table_0[i].desc) + 21;
      if ( opt_table_0[i].show )
        len += 97;
      ++len;
    }
  }
  ret = (unsigned __int8 *)malloc(len);
  p = ret;
  if ( !ret )
    return 0;
  p += sprintf((char *)p, "Usage: %s", (const char *)argv0);
  *(_DWORD *)p = &pattern_info_t.asic_core_nonce_num[2][71][208];
  p += 3;
  num = write_short_options(p);
  if ( num )
  {
    p += num;
    strcpy((char *)p++, "]");
  }
  else
  {
    p -= 3;
  }
  if ( extraa )
    p += sprintf((char *)p, " %s", (const char *)extraa);
  strcpy((char *)p++, "\n");
  for ( i = 0; i < opt_count; ++i )
  {
    if ( opt_table_0[i].desc != opt_hidden )
    {
      if ( opt_table_0[i].type == OPT_SUBTABLE )
      {
        v4 = sprintf((char *)p, "%s:\n", (const char *)opt_table_0[i].desc);
        p += v4;
      }
      else
      {
        len = sprintf((char *)p, "%s", (const char *)opt_table_0[i].names);
        if ( opt_table_0[i].type == OPT_HASARG
          && !strchr((const char *)opt_table_0[i].names, 32)
          && !strchr((const char *)opt_table_0[i].names, 61) )
        {
          strcpy((char *)&p[len], " <arg>");
          len += 6;
        }
        if ( len > 0x13 )
          v5 = 1;
        else
          v5 = 20 - len;
        v6 = sprintf((char *)&p[len], "%.*s", v5, "                    ");
        len += v6;
        v7 = sprintf((char *)&p[len], "%s", (const char *)opt_table_0[i].desc);
        len += v7;
        if ( opt_table_0[i].show )
        {
          strcpy((char *)&buf[80], "...");
          opt_table_0[i].show(buf, (const void *)opt_table_0[i].u.tlen);
          v8 = sprintf((char *)&p[len], " (default: %s)", (const char *)buf);
          len += v8;
        }
        p += len;
        strcpy((char *)p++, "\n");
      }
    }
  }
  *p = 0;
  return ret;
}

//----- (0007A1F2) --------------------------------------------------------
int __cdecl parse_err(
        void (*errlog)(const unsigned __int8 *, ...),
        const unsigned __int8 *argv0,
        const unsigned __int8 *arg,
        unsigned int len,
        const unsigned __int8 *problem)
{
  errlog("%s: %.*s: %s", (const char *)argv0, len, (const char *)arg, (const char *)problem);
  return -1;
}

//----- (0007A222) --------------------------------------------------------
void __cdecl consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum)
{
  memmove(&argv[optnum], &argv[optnum + 1], 4 * (*argc - optnum));
  --*argc;
}

//----- (0007A264) --------------------------------------------------------
int __cdecl parse_one(
        int *argc,
        unsigned __int8 **argv,
        unsigned int *offset,
        void (*errlog)(const unsigned __int8 *, ...))
{
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int len; // [sp+18h] [bp+10h] BYREF
  unsigned int i; // [sp+1Ch] [bp+14h] BYREF
  unsigned __int8 *problem; // [sp+20h] [bp+18h]
  const unsigned __int8 *optarg; // [sp+24h] [bp+1Ch]
  const unsigned __int8 *o; // [sp+28h] [bp+20h]
  unsigned int arg; // [sp+2Ch] [bp+24h]

  optarg = 0;
  if ( getenv("POSIXLY_CORRECT") )
  {
    arg = 1;
  }
  else
  {
    for ( arg = 1; argv[arg] && *argv[arg] != 45; ++arg )
      ;
  }
  if ( !argv[arg] || *argv[arg] != 45 )
    return 0;
  if ( !strcmp((const char *)argv[arg], "--") )
  {
    consume_option(argc, argv, arg);
    return 0;
  }
  else
  {
    if ( argv[arg][1] == 45 )
    {
      if ( *offset )
        _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, (const char *)_PRETTY_FUNCTION___6523);
      for ( o = first_lopt(&i, &len); o; o = next_lopt(o, &i, &len) )
      {
        if ( !strncmp((const char *)argv[arg] + 2, (const char *)o, len) )
        {
          if ( argv[arg][len + 2] == 61 )
          {
            optarg = &argv[arg][len + 3];
            break;
          }
          if ( !argv[arg][len + 2] )
            break;
        }
      }
      if ( !o )
      {
        v5 = strlen((const char *)argv[arg]);
        return parse_err(errlog, *argv, argv[arg], v5, "unrecognized option");
      }
      o -= 2;
      len += 2;
    }
    else
    {
      for ( o = first_sopt(&i); o; o = next_sopt(o, &i) )
      {
        if ( argv[arg][*offset + 1] == *o )
        {
          ++*offset;
          break;
        }
      }
      if ( !o )
      {
        v6 = strlen((const char *)argv[arg]);
        return parse_err(errlog, *argv, argv[arg], v6, "unrecognized option");
      }
      --o;
      len = 2;
    }
    if ( opt_table_0[i].type == OPT_NOARG )
    {
      if ( optarg )
        return parse_err(errlog, *argv, o, len, "doesn't allow an argument");
      problem = opt_table_0[i].cb(opt_table_0[i].u.tlen);
    }
    else
    {
      if ( !optarg )
      {
        if ( *offset && argv[arg][*offset + 1] )
        {
          optarg = &argv[arg][*offset + 1];
          *offset = 0;
        }
        else
        {
          optarg = argv[arg + 1];
        }
      }
      if ( !optarg )
        return parse_err(errlog, *argv, o, len, "requires an argument");
      if ( opt_table_0[i].type == OPT_PROCESSARG )
        opt_set_charp(optarg, (unsigned __int8 **)opt_table_0[i].u.carg);
      problem = opt_table_0[i].cb_arg(optarg, opt_table_0[i].u.tlen);
    }
    if ( problem )
    {
      parse_err(errlog, *argv, o, len, problem);
      free(problem);
      return -1;
    }
    else
    {
      if ( *offset && !argv[arg][*offset + 1] )
        *offset = 0;
      if ( !*offset )
      {
        consume_option(argc, argv, arg);
        if ( optarg )
        {
          if ( optarg == argv[arg] )
            consume_option(argc, argv, arg);
        }
      }
      return 1;
    }
  }
}

//----- (0007A6A0) --------------------------------------------------------
int __cdecl strbuffer_init(strbuffer_t *strbuff)
{
  strbuff->size = 16;
  strbuff->length = 0;
  strbuff->value = (unsigned __int8 *)jsonp_malloc(strbuff->size);
  if ( !strbuff->value )
    return -1;
  *strbuff->value = 0;
  return 0;
}

//----- (0007A6E4) --------------------------------------------------------
void __cdecl strbuffer_close(strbuffer_t *strbuff)
{
  if ( strbuff->value )
    jsonp_free(strbuff->value);
  strbuff->size = 0;
  strbuff->length = 0;
  strbuff->value = 0;
}

//----- (0007A718) --------------------------------------------------------
void __cdecl strbuffer_clear(strbuffer_t *strbuff)
{
  strbuff->length = 0;
  *strbuff->value = 0;
}

//----- (0007A73A) --------------------------------------------------------
const unsigned __int8 *__cdecl strbuffer_value(const strbuffer_t *strbuff)
{
  return strbuff->value;
}

//----- (0007A752) --------------------------------------------------------
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte)
{
  unsigned __int8 bytea; // [sp+3h] [bp+3h] BYREF
  strbuffer_t *strbuffa; // [sp+4h] [bp+4h]

  strbuffa = strbuff;
  bytea = byte;
  return strbuffer_append_bytes(strbuff, &bytea, 1u);
}

//----- (0007A774) --------------------------------------------------------
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size)
{
  size_t v4; // r3
  unsigned __int8 *new_value; // [sp+10h] [bp+10h]
  size_t new_size; // [sp+14h] [bp+14h]

  if ( size < strbuff->size - strbuff->length )
    goto LABEL_11;
  if ( (strbuff->size & 0x80000000) == 0 && size != -1 && strbuff->length <= -2 - size )
  {
    v4 = 2 * strbuff->size;
    if ( v4 < size + strbuff->length + 1 )
      v4 = size + strbuff->length + 1;
    new_size = v4;
    new_value = (unsigned __int8 *)jsonp_malloc(v4);
    if ( !new_value )
      return -1;
    memcpy(new_value, strbuff->value, strbuff->length);
    jsonp_free(strbuff->value);
    strbuff->value = new_value;
    strbuff->size = new_size;
LABEL_11:
    memcpy(&strbuff->value[strbuff->length], data, size);
    strbuff->length += size;
    strbuff->value[strbuff->length] = 0;
    return 0;
  }
  return -1;
}

//----- (0007A844) --------------------------------------------------------
unsigned __int8 __cdecl strbuffer_pop(strbuffer_t *strbuff)
{
  unsigned __int8 *value; // r2
  unsigned __int8 c; // [sp+Fh] [bp+Fh]

  if ( !strbuff->length )
    return 0;
  value = strbuff->value;
  c = value[--strbuff->length];
  strbuff->value[strbuff->length] = 0;
  return c;
}

//----- (0007A88C) --------------------------------------------------------
void __cdecl jsonp_error_init(json_error_t *error, const unsigned __int8 *source)
{
  if ( error )
  {
    error->text[0] = 0;
    error->line = -1;
    error->column = -1;
    error->position = 0;
    if ( source )
      jsonp_error_set_source(error, source);
    else
      error->source[0] = 0;
  }
}

//----- (0007A8D8) --------------------------------------------------------
void __cdecl jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source)
{
  size_t length; // [sp+Ch] [bp+Ch]

  if ( error && source )
  {
    length = strlen((const char *)source);
    if ( length > 0x4F )
    {
      *(_WORD *)error->source = 11822;
      error->source[2] = 46;
      strncpy((char *)&error->source[3], (const char *)&source[length - 76], 0x4Du);
    }
    else
    {
      strncpy((char *)error->source, (const char *)source, length + 1);
    }
  }
}

//----- (0007A950) --------------------------------------------------------
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...)
{
  va_list va; // [sp+2Ch] [bp+24h] BYREF

  va_start(va, msg);
  jsonp_error_vset(error, line, column, position, msg, va);
}

//----- (0007A980) --------------------------------------------------------
void __cdecl jsonp_error_vset(
        json_error_t *error,
        int line,
        int column,
        size_t position,
        const unsigned __int8 *msg,
        va_list ap)
{
  if ( error )
  {
    if ( !error->text[0] )
    {
      error->line = line;
      error->column = column;
      error->position = position;
      vsnprintf((char *)error->text, 0xA0u, (const char *)msg, ap);
      error->text[159] = 0;
    }
  }
}

//----- (0007A9D6) --------------------------------------------------------
void __cdecl to_locale(strbuffer_t *strbuffer)
{
  struct lconv *v1; // r0
  unsigned __int8 *pos; // [sp+8h] [bp+8h]
  const unsigned __int8 *point; // [sp+Ch] [bp+Ch]

  v1 = localeconv();
  point = (const unsigned __int8 *)v1->decimal_point;
  if ( *v1->decimal_point != 46 )
  {
    pos = (unsigned __int8 *)strchr((const char *)strbuffer->value, 46);
    if ( pos )
      *pos = *point;
  }
}

//----- (0007AA16) --------------------------------------------------------
void __cdecl from_locale(unsigned __int8 *buffer)
{
  struct lconv *v1; // r0
  unsigned __int8 *pos; // [sp+8h] [bp+8h]

  v1 = localeconv();
  if ( *v1->decimal_point != 46 )
  {
    pos = (unsigned __int8 *)strchr((const char *)buffer, *(unsigned __int8 *)v1->decimal_point);
    if ( pos )
      *pos = 46;
  }
}

//----- (0007AA58) --------------------------------------------------------
int __cdecl jsonp_strtod(strbuffer_t *strbuffer, double *out)
{
  double v2; // d0
  unsigned __int8 *end; // [sp+Ch] [bp+Ch] BYREF
  double value; // [sp+10h] [bp+10h]

  to_locale(strbuffer);
  *_errno_location() = 0;
  strtod((const char *)strbuffer->value, (char **)&end);
  value = v2;
  if ( &strbuffer->value[strbuffer->length] != end )
    _assert_fail(
      "end == strbuffer->value + strbuffer->length",
      "compat/jansson-2.9/src/strconv.c",
      0x50u,
      (const char *)_PRETTY_FUNCTION___8102);
  if ( (value > 1.79769313e308 || value < -1.79769313e308) && *_errno_location() == 34 )
    return -1;
  *out = value;
  return 0;
}
// 7AA82: variable 'v2' is possibly undefined

//----- (0007AB10) --------------------------------------------------------
int __cdecl jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value, int precision)
{
  double v4; // d0
  int precisiona; // [sp+Ch] [bp+4h]
  signed int ret; // [sp+20h] [bp+18h]
  int length; // [sp+24h] [bp+1Ch]
  unsigned __int8 *end; // [sp+28h] [bp+20h]
  unsigned __int8 *start; // [sp+2Ch] [bp+24h]
  unsigned __int8 *starta; // [sp+2Ch] [bp+24h]

  precisiona = LODWORD(value);
  if ( !LODWORD(value) )
    precisiona = 17;
  ret = snprintf((char *)buffer, size, "%.*g", precisiona, v4);
  if ( ret < 0 )
    return -1;
  length = ret;
  if ( ret >= size )
    return -1;
  from_locale(buffer);
  if ( !strchr((const char *)buffer, 46) && !strchr((const char *)buffer, 101) )
  {
    if ( size <= ret + 3 )
      return -1;
    buffer[ret] = 46;
    buffer[ret + 1] = 48;
    buffer[ret + 2] = 0;
    length = ret + 2;
  }
  start = (unsigned __int8 *)strchr((const char *)buffer, 101);
  if ( start )
  {
    starta = start + 1;
    end = starta + 1;
    if ( *starta == 45 )
      ++starta;
    while ( *end == 48 )
      ++end;
    if ( end != starta )
    {
      memmove(starta, end, length - (end - buffer));
      length -= end - starta;
    }
  }
  return length;
}
// 7AB40: variable 'v4' is possibly undefined

//----- (0007AC2E) --------------------------------------------------------
void __cdecl json_decref_2(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0007AC66) --------------------------------------------------------
void __cdecl json_init(json_t_0 *json, json_type type)
{
  json->type = type;
  json->refcount = 1;
}

//----- (0007AC88) --------------------------------------------------------
json_object_t *json_object()
{
  json_object_t *object; // [sp+4h] [bp+4h]

  object = (json_object_t *)jsonp_malloc(0x28u);
  if ( !object )
    return 0;
  if ( !hashtable_seed )
    json_object_seed(0);
  json_init(&object->json, JSON_OBJECT);
  if ( hashtable_init(&object->hashtable) )
  {
    jsonp_free(object);
    return 0;
  }
  else
  {
    object->visited = 0;
    return object;
  }
}

//----- (0007ACE8) --------------------------------------------------------
void __cdecl json_delete_object(json_object_t *object)
{
  hashtable_close(&object->hashtable);
  jsonp_free(object);
}

//----- (0007AD08) --------------------------------------------------------
size_t __cdecl json_object_size(const json_t_0 *json)
{
  if ( json && json->type == JSON_OBJECT )
    return json[1].type;
  else
    return 0;
}

//----- (0007AD36) --------------------------------------------------------
json_t_0 *__cdecl json_object_get(const json_t_0 *json, const unsigned __int8 *key)
{
  if ( key && json && json->type == JSON_OBJECT )
    return (json_t_0 *)hashtable_get((hashtable_t *)&json[1], key);
  else
    return 0;
}

//----- (0007AD72) --------------------------------------------------------
int __cdecl json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value)
{
  if ( !value )
    return -1;
  if ( key && json && json->type == JSON_OBJECT && json != value && !hashtable_set((hashtable_t *)&json[1], key, value) )
    return 0;
  json_decref_2(value);
  return -1;
}

//----- (0007ADE0) --------------------------------------------------------
void *__cdecl json_object_iter(json_t_0 *json)
{
  if ( json && json->type == JSON_OBJECT )
    return hashtable_iter((hashtable_t *)&json[1]);
  else
    return 0;
}

//----- (0007AE12) --------------------------------------------------------
void *__cdecl json_object_iter_next(json_t_0 *json, void *iter)
{
  if ( json && json->type == JSON_OBJECT && iter )
    return hashtable_iter_next((hashtable_t *)&json[1], iter);
  else
    return 0;
}

//----- (0007AE4E) --------------------------------------------------------
const unsigned __int8 *__cdecl json_object_iter_key(void *iter)
{
  if ( iter )
    return (const unsigned __int8 *)hashtable_iter_key(iter);
  else
    return 0;
}

//----- (0007AE70) --------------------------------------------------------
json_t_0 *__cdecl json_object_iter_value(void *iter)
{
  if ( iter )
    return (json_t_0 *)hashtable_iter_value(iter);
  else
    return 0;
}

//----- (0007AE92) --------------------------------------------------------
void *__cdecl json_object_key_to_iter(const unsigned __int8 *key)
{
  if ( key )
    return (void *)(key - 16);
  else
    return 0;
}

//----- (0007AEB6) --------------------------------------------------------
json_array_t *json_array()
{
  json_array_t *array; // [sp+4h] [bp+4h]

  array = (json_array_t *)jsonp_malloc(0x18u);
  if ( !array )
    return 0;
  json_init(&array->json, JSON_ARRAY);
  array->entries = 0;
  array->size = 8;
  array->table = (json_t_0 **)jsonp_malloc(4 * array->size);
  if ( array->table )
  {
    array->visited = 0;
    return array;
  }
  else
  {
    jsonp_free(array);
    return 0;
  }
}

//----- (0007AF18) --------------------------------------------------------
void __cdecl json_delete_array(json_array_t *array)
{
  size_t i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < array->entries; ++i )
    json_decref_2(array->table[i]);
  jsonp_free(array->table);
  jsonp_free(array);
}

//----- (0007AF60) --------------------------------------------------------
size_t __cdecl json_array_size(const json_t_0 *json)
{
  if ( json && json->type == JSON_ARRAY )
    return json[1].refcount;
  else
    return 0;
}

//----- (0007AF8A) --------------------------------------------------------
json_t_0 *__cdecl json_array_get(const json_t_0 *json, size_t index)
{
  if ( !json || json->type != JSON_ARRAY )
    return 0;
  if ( index < json[1].refcount )
    return *(json_t_0 **)(4 * index + json[2].type);
  return 0;
}

//----- (0007AFD0) --------------------------------------------------------
void __cdecl array_copy(json_t_0 **dest, size_t dpos, json_t_0 **src, size_t spos, size_t count)
{
  memcpy(&dest[dpos], &src[spos], 4 * count);
}

//----- (0007B000) --------------------------------------------------------
json_t_0 **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy)
{
  size_t v4; // r3
  json_t_0 **new_table; // [sp+1Ch] [bp+14h]
  size_t new_size; // [sp+20h] [bp+18h]
  json_t_0 **old_table; // [sp+24h] [bp+1Ch]

  if ( array->entries + amount <= array->size )
    return array->table;
  old_table = array->table;
  v4 = amount + array->size;
  if ( v4 < 2 * array->size )
    v4 = 2 * array->size;
  new_size = v4;
  new_table = (json_t_0 **)jsonp_malloc(4 * v4);
  if ( !new_table )
    return 0;
  array->size = new_size;
  array->table = new_table;
  if ( !copy )
    return old_table;
  array_copy(array->table, 0, old_table, 0, array->entries);
  jsonp_free(old_table);
  return array->table;
}

//----- (0007B090) --------------------------------------------------------
int __cdecl json_array_append_new(json_t_0 *json, json_t_0 *value)
{
  if ( !value )
    return -1;
  if ( json && json->type == JSON_ARRAY && json != value && json_array_grow((json_array_t *)json, 1u, 1) )
  {
    *(_DWORD *)(4 * json[1].refcount++ + json[2].type) = value;
    return 0;
  }
  else
  {
    json_decref_2(value);
    return -1;
  }
}

//----- (0007B10C) --------------------------------------------------------
json_t_0 *__cdecl string_create(const unsigned __int8 *value, size_t len, int own)
{
  json_string_t *string; // [sp+10h] [bp+10h]
  unsigned __int8 *v; // [sp+14h] [bp+14h]

  if ( !value )
    return 0;
  if ( own )
  {
    v = (unsigned __int8 *)value;
  }
  else
  {
    v = jsonp_strndup(value, len);
    if ( !v )
      return 0;
  }
  string = (json_string_t *)jsonp_malloc(0x10u);
  if ( string )
  {
    json_init(&string->json, JSON_STRING);
    string->value = v;
    string->length = len;
    return &string->json;
  }
  else
  {
    if ( !own )
      jsonp_free(v);
    return 0;
  }
}

//----- (0007B180) --------------------------------------------------------
json_t_0 *__cdecl jsonp_stringn_nocheck_own(const unsigned __int8 *value, size_t len)
{
  return string_create(value, len, 1);
}

//----- (0007B19E) --------------------------------------------------------
const unsigned __int8 *__cdecl json_string_value(const json_t_0 *json)
{
  if ( json && json->type == JSON_STRING )
    return (const unsigned __int8 *)json[1].type;
  else
    return 0;
}

//----- (0007B1C8) --------------------------------------------------------
size_t __cdecl json_string_length(const json_t_0 *json)
{
  if ( json && json->type == JSON_STRING )
    return json[1].refcount;
  else
    return 0;
}

//----- (0007B1F2) --------------------------------------------------------
void __cdecl json_delete_string(json_string_t *string)
{
  jsonp_free(string->value);
  jsonp_free(string);
}

//----- (0007B212) --------------------------------------------------------
json_t_0 *__cdecl json_integer(json_int_t value)
{
  json_integer_t *integer; // [sp+Ch] [bp+Ch]

  integer = (json_integer_t *)jsonp_malloc(0x10u);
  if ( !integer )
    return 0;
  json_init(&integer->json, JSON_INTEGER);
  integer->value = value;
  return &integer->json;
}

//----- (0007B24C) --------------------------------------------------------
json_int_t __cdecl json_integer_value(const json_t_0 *json)
{
  json_type type; // r3
  size_t refcount; // r4

  if ( json && json->type == JSON_INTEGER )
  {
    refcount = json[1].refcount;
    type = json[1].type;
  }
  else
  {
    type = JSON_OBJECT;
    refcount = 0;
  }
  return __PAIR64__(refcount, type);
}

//----- (0007B27E) --------------------------------------------------------
void __cdecl json_delete_integer(json_integer_t *integer)
{
  jsonp_free(integer);
}

//----- (0007B298) --------------------------------------------------------
json_t_0 *__cdecl json_real(double value)
{
  double v1; // d0
  json_real_t *real; // [sp+Ch] [bp+Ch]

  if ( fabs(v1) > 1.79769313e308 )
    return 0;
  real = (json_real_t *)jsonp_malloc(0x10u);
  if ( !real )
    return 0;
  json_init(&real->json, JSON_REAL);
  real->value = v1;
  return &real->json;
}
// 7B2B8: variable 'v1' is possibly undefined

//----- (0007B318) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_real_value(const json_t_0 *json)
{
  double result; // r0

  LODWORD(result) = json;
  return result;
}
// 7B318: variables would overlap: r0.4 and r0.8
// 7B318: bad return variable

//----- (0007B34E) --------------------------------------------------------
void __cdecl json_delete_real(json_real_t *real)
{
  jsonp_free(real);
}

//----- (0007B364) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_number_value(const json_t_0 *json)
{
  double result; // r0

  if ( json && json->type == JSON_INTEGER )
  {
    *(double *)&json = (double)json_integer_value(json);
  }
  else if ( json && json->type == JSON_REAL )
  {
    *(double *)&json = json_real_value(json);
  }
  LODWORD(result) = json;
  return result;
}
// 7B364: variables would overlap: r0.4 and r0.8
// 7B364: bad return variable

//----- (0007B3C2) --------------------------------------------------------
json_t_0 *json_true()
{
  return &the_true_8961;
}

//----- (0007B3D8) --------------------------------------------------------
json_t_0 *json_false()
{
  return &the_false_8965;
}

//----- (0007B3EE) --------------------------------------------------------
json_t_0 *json_null()
{
  return &the_null_8969;
}

//----- (0007B404) --------------------------------------------------------
void __cdecl json_delete(json_t_0 *json)
{
  if ( json )
  {
    switch ( json->type )
    {
      case JSON_OBJECT:
        json_delete_object((json_object_t *)json);
        break;
      case JSON_ARRAY:
        json_delete_array((json_array_t *)json);
        break;
      case JSON_STRING:
        json_delete_string((json_string_t *)json);
        break;
      case JSON_INTEGER:
        json_delete_integer((json_integer_t *)json);
        break;
      case JSON_REAL:
        json_delete_real((json_real_t *)json);
        break;
      default:
        return;
    }
  }
}

//----- (0007B468) --------------------------------------------------------
int __cdecl seed_from_timestamp_and_pid(uint32_t *seed)
{
  *seed = time(0);
  return 0;
}

//----- (0007B488) --------------------------------------------------------
uint32_t generate_seed()
{
  uint32_t seed; // [sp+0h] [bp+0h] BYREF
  int done; // [sp+4h] [bp+4h]

  done = 0;
  seed_from_timestamp_and_pid(&seed);
  if ( !seed )
    return 1;
  return seed;
}

//----- (0007B4B4) --------------------------------------------------------
void __cdecl json_object_seed(size_t seed)
{
  uint32_t new_seed; // [sp+Ch] [bp+Ch]

  new_seed = seed;
  if ( !hashtable_seed )
  {
    if ( !seed )
      new_seed = generate_seed();
    hashtable_seed = new_seed;
  }
}

//----- (0007B4EE) --------------------------------------------------------
json_t_0 *__cdecl json_incref(json_t_0 *json)
{
  if ( json )
  {
    if ( json->refcount != -1 )
      ++json->refcount;
  }
  return json;
}

//----- (0007B51E) --------------------------------------------------------
void __cdecl json_decref_3(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0007B556) --------------------------------------------------------
int __cdecl json_object_set_nocheck(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value)
{
  json_t_0 *v3; // r0

  v3 = json_incref(value);
  return json_object_set_new_nocheck(object, key, v3);
}

//----- (0007B57E) --------------------------------------------------------
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value)
{
  json_t_0 *v2; // r0

  v2 = json_incref(value);
  return json_array_append_new(array, v2);
}

//----- (0007B5A2) --------------------------------------------------------
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *msg, ...)
{
  unsigned __int8 msg_with_context[160]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 msg_text[160]; // [sp+B0h] [bp+A8h] BYREF
  va_list ap; // [sp+150h] [bp+148h]
  const unsigned __int8 *saved_text; // [sp+154h] [bp+14Ch]
  const unsigned __int8 *result; // [sp+158h] [bp+150h]
  size_t pos; // [sp+15Ch] [bp+154h]
  int col; // [sp+160h] [bp+158h]
  int line; // [sp+164h] [bp+15Ch]
  const unsigned __int8 *msga; // [sp+170h] [bp+168h]
  va_list varg_r3; // [sp+174h] [bp+16Ch] BYREF

  va_start(varg_r3, msg);
  msga = msg;
  line = -1;
  col = -1;
  pos = 0;
  result = msg_text;
  if ( error )
  {
    va_copy(ap, varg_r3);
    vsnprintf((char *)msg_text, 0xA0u, (const char *)msga, varg_r3);
    msg_text[159] = 0;
    if ( lex )
    {
      saved_text = strbuffer_value(&lex->saved_text);
      line = lex->stream.line;
      col = lex->stream.column;
      pos = lex->stream.position;
      if ( saved_text && *saved_text )
      {
        if ( lex->saved_text.length <= 0x14 )
        {
          snprintf((char *)msg_with_context, 0xA0u, "%s near '%s'", (const char *)msg_text, (const char *)saved_text);
          msg_with_context[159] = 0;
          result = msg_with_context;
        }
      }
      else if ( lex->stream.state == -2 )
      {
        result = msg_text;
      }
      else
      {
        snprintf((char *)msg_with_context, 0xA0u, "%s near end of file", (const char *)msg_text);
        msg_with_context[159] = 0;
        result = msg_with_context;
      }
    }
    jsonp_error_set(error, line, col, pos, "%s", (const char *)result);
  }
}

//----- (0007B6F2) --------------------------------------------------------
void __cdecl stream_init(stream_t *stream, get_func get, void *data)
{
  stream->get = get;
  stream->data = data;
  stream->buffer[0] = 0;
  stream->buffer_pos = 0;
  stream->state = 0;
  stream->line = 1;
  stream->column = 0;
  stream->position = 0;
}

//----- (0007B73A) --------------------------------------------------------
int __cdecl stream_get(stream_t *stream, json_error_t *error)
{
  size_t buffer_pos; // r3
  size_t count; // [sp+Ch] [bp+Ch]
  int c; // [sp+10h] [bp+10h]
  int ca; // [sp+10h] [bp+10h]
  size_t i; // [sp+14h] [bp+14h]

  if ( stream->state )
    return stream->state;
  if ( !stream->buffer[stream->buffer_pos] )
  {
    c = stream->get(stream->data);
    if ( c == -1 )
    {
      stream->state = -1;
      return -1;
    }
    stream->buffer[0] = c;
    stream->buffer_pos = 0;
    if ( c <= 127 || c > 255 )
    {
      stream->buffer[1] = 0;
    }
    else
    {
      count = utf8_check_first(c);
      if ( !count )
        goto out;
      if ( count <= 1 )
        _assert_fail("count >= 2", "compat/jansson-2.9/src/load.c", 0xBCu, (const char *)_PRETTY_FUNCTION___7344);
      for ( i = 1; i < count; ++i )
        stream->buffer[i] = stream->get(stream->data);
      if ( !utf8_check_full(stream->buffer, count, 0) )
      {
out:
        stream->state = -2;
        error_set(error, (const lex_t *)stream, "unable to decode byte 0x%x", c);
        return -2;
      }
      stream->buffer[count] = 0;
    }
  }
  buffer_pos = stream->buffer_pos;
  stream->buffer_pos = buffer_pos + 1;
  ca = stream->buffer[buffer_pos];
  ++stream->position;
  if ( ca == 10 )
  {
    ++stream->line;
    stream->last_column = stream->column;
    stream->column = 0;
  }
  else if ( utf8_check_first(ca) )
  {
    ++stream->column;
  }
  return ca;
}

//----- (0007B8B2) --------------------------------------------------------
void __cdecl stream_unget(stream_t *stream, int c)
{
  if ( c != -1 && c != -2 )
  {
    --stream->position;
    if ( c == 10 )
    {
      --stream->line;
      stream->column = stream->last_column;
    }
    else if ( utf8_check_first(c) )
    {
      --stream->column;
    }
    if ( !stream->buffer_pos )
      _assert_fail(
        "stream->buffer_pos > 0",
        "compat/jansson-2.9/src/load.c",
        0xF0u,
        (const char *)_PRETTY_FUNCTION___7352);
    if ( c != stream->buffer[--stream->buffer_pos] )
      _assert_fail(
        "stream->buffer[stream->buffer_pos] == c",
        "compat/jansson-2.9/src/load.c",
        0xF2u,
        (const char *)_PRETTY_FUNCTION___7352);
  }
}

//----- (0007B972) --------------------------------------------------------
int __cdecl lex_get(lex_t *lex, json_error_t *error)
{
  return stream_get(&lex->stream, error);
}

//----- (0007B990) --------------------------------------------------------
void __cdecl lex_save(lex_t *lex, int c)
{
  strbuffer_append_byte(&lex->saved_text, c);
}

//----- (0007B9B2) --------------------------------------------------------
int __cdecl lex_get_save(lex_t *lex, json_error_t *error)
{
  int c; // [sp+Ch] [bp+Ch]

  c = stream_get(&lex->stream, error);
  if ( c != -1 && c != -2 )
    lex_save(lex, c);
  return c;
}

//----- (0007B9EA) --------------------------------------------------------
void __cdecl lex_unget(lex_t *lex, int c)
{
  stream_unget(&lex->stream, c);
}

//----- (0007BA06) --------------------------------------------------------
void __cdecl lex_unget_unsave(lex_t *lex, int c)
{
  if ( c != -1 && c != -2 )
  {
    stream_unget(&lex->stream, c);
    if ( c != strbuffer_pop(&lex->saved_text) )
      _assert_fail("c == d", "compat/jansson-2.9/src/load.c", 0x11Du, (const char *)_PRETTY_FUNCTION___7375);
  }
}

//----- (0007BA68) --------------------------------------------------------
void __cdecl lex_save_cached(lex_t *lex)
{
  while ( lex->stream.buffer[lex->stream.buffer_pos] )
  {
    lex_save(lex, lex->stream.buffer[lex->stream.buffer_pos]);
    ++lex->stream.buffer_pos;
    ++lex->stream.position;
  }
}

//----- (0007BAAE) --------------------------------------------------------
void __cdecl lex_free_string(lex_t *lex)
{
  jsonp_free(lex->value.string.val);
  lex->value.string.val = 0;
  lex->value.string.len = 0;
}

//----- (0007BAD4) --------------------------------------------------------
int32_t __cdecl decode_unicode_escape(const unsigned __int8 *str)
{
  unsigned __int8 c; // [sp+Fh] [bp+Fh]
  int32_t value; // [sp+10h] [bp+10h]
  int32_t valuea; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  value = 0;
  if ( *str != 117 )
    _assert_fail("str[0] == 'u'", "compat/jansson-2.9/src/load.c", 0x138u, (const char *)_PRETTY_FUNCTION___7390);
  for ( i = 1; i <= 4; ++i )
  {
    c = str[i];
    valuea = 16 * value;
    if ( c <= 0x2Fu || c > 0x39u )
    {
      if ( c <= 0x60u || c > 0x7Au )
      {
        if ( c <= 0x40u || c > 0x5Au )
          return -1;
        value = c - 55 + valuea;
      }
      else
      {
        value = c - 87 + valuea;
      }
    }
    else
    {
      value = c - 48 + valuea;
    }
  }
  return value;
}

//----- (0007BB82) --------------------------------------------------------
void __cdecl lex_scan_string(lex_t *lex, json_error_t *error)
{
  int v2; // r3
  const unsigned __int8 *v3; // r2
  unsigned __int8 *v4; // r3
  size_t length; // [sp+14h] [bp+Ch] BYREF
  int32_t value2; // [sp+18h] [bp+10h]
  int32_t value; // [sp+1Ch] [bp+14h]
  int i; // [sp+20h] [bp+18h]
  unsigned __int8 *t; // [sp+24h] [bp+1Ch]
  const unsigned __int8 *p; // [sp+28h] [bp+20h]
  int c; // [sp+2Ch] [bp+24h]

  lex->value.string.val = 0;
  lex->token = -1;
  c = lex_get_save(lex, error);
  while ( c != 34 )
  {
    if ( c == -2 )
      goto out;
    if ( c == -1 )
    {
      error_set(error, lex, "premature end of input");
out:
      lex_free_string(lex);
      return;
    }
    if ( c >= 0 && c <= 31 )
    {
      lex_unget_unsave(lex, c);
      if ( c == 10 )
        error_set(error, lex, "unexpected newline", 10);
      else
        error_set(error, lex, "control character 0x%x", c);
      goto out;
    }
    if ( c == 92 )
    {
      c = lex_get_save(lex, error);
      if ( c != 117 )
      {
        if ( c != 34 && c != 92 && c != 47 && c != 98 && c != 102 && c != 110 && c != 114 && c != 116 )
        {
LABEL_19:
          error_set(error, lex, "invalid escape");
          goto out;
        }
        goto LABEL_33;
      }
      c = lex_get_save(lex, error);
      for ( i = 0; i <= 3; ++i )
      {
        if ( (c <= 47 || c > 57) && (c <= 64 || c > 70) && (c <= 96 || c > 102) )
          goto LABEL_19;
        c = lex_get_save(lex, error);
      }
    }
    else
    {
LABEL_33:
      c = lex_get_save(lex, error);
    }
  }
  t = (unsigned __int8 *)jsonp_malloc(lex->saved_text.length + 1);
  if ( !t )
    goto out;
  lex->value.string.val = t;
  p = strbuffer_value(&lex->saved_text) + 1;
  while ( *p != 34 )
  {
    if ( *p == 92 )
    {
      if ( *++p == 117 )
      {
        value = decode_unicode_escape(p);
        if ( value < 0 )
          goto LABEL_40;
        p += 5;
        if ( value < 55296 || value >= 56320 )
        {
          if ( value >= 56320 && value < 57344 )
          {
LABEL_53:
            error_set(error, lex, "invalid Unicode '\\u%04X'", value);
            goto out;
          }
        }
        else
        {
          if ( *p != 92 || p[1] != 117 )
            goto LABEL_53;
          value2 = decode_unicode_escape(++p);
          if ( value2 < 0 )
          {
LABEL_40:
            error_set(error, lex, "invalid Unicode escape '%.6s'", (const char *)p - 1);
            goto out;
          }
          p += 5;
          if ( value2 < 56320 || value2 >= 57344 )
          {
            error_set(error, lex, "invalid Unicode '\\u%04X\\u%04X'", value, value2);
            goto out;
          }
          value = value2 - 56320 + ((value - 55296) << 10) + 0x10000;
        }
        if ( utf8_encode(value, t, &length) )
          _assert_fail("0", "compat/jansson-2.9/src/load.c", 0x1DBu, (const char *)_PRETTY_FUNCTION___7413);
        t += length;
      }
      else
      {
        v2 = *p;
        if ( v2 == 98 )
        {
          *t = 8;
        }
        else if ( *p > 0x62u )
        {
          if ( v2 == 110 )
          {
            *t = 10;
          }
          else if ( *p > 0x6Eu )
          {
            if ( v2 == 114 )
            {
              *t = 13;
            }
            else
            {
              if ( v2 != 116 )
                goto LABEL_76;
              *t = 9;
            }
          }
          else
          {
            if ( v2 != 102 )
              goto LABEL_76;
            *t = 12;
          }
        }
        else
        {
          if ( v2 != 47 && v2 != 92 && v2 != 34 )
LABEL_76:
            _assert_fail("0", "compat/jansson-2.9/src/load.c", 0x1F7u, (const char *)_PRETTY_FUNCTION___7413);
          *t = *p;
        }
        ++t;
        ++p;
      }
    }
    else
    {
      v3 = p++;
      v4 = t++;
      *v4 = *v3;
    }
  }
  *t = 0;
  lex->value.string.len = t - lex->value.string.val;
  lex->token = 256;
}

//----- (0007BF3A) --------------------------------------------------------
int __cdecl lex_scan_number(lex_t *lex, int c, json_error_t *error)
{
  int ca; // [sp+8h] [bp+8h]
  int cb; // [sp+8h] [bp+8h]
  double doubleval; // [sp+10h] [bp+10h] BYREF
  unsigned __int8 *end; // [sp+1Ch] [bp+1Ch] BYREF
  json_int_t intval; // [sp+20h] [bp+20h]
  const unsigned __int8 *saved_text; // [sp+2Ch] [bp+2Ch]

  ca = c;
  lex->token = -1;
  if ( c == 45 )
    ca = lex_get_save(lex, error);
  if ( ca == 48 )
  {
    ca = lex_get_save(lex, error);
    if ( ca > 47 && ca <= 57 )
    {
LABEL_6:
      lex_unget_unsave(lex, ca);
      return -1;
    }
  }
  else
  {
    if ( ca <= 47 || ca > 57 )
      goto LABEL_6;
    do
      ca = lex_get_save(lex, error);
    while ( ca > 47 && ca <= 57 );
  }
  if ( (lex->flags & 8) != 0 || ca == 46 || ca == 69 || ca == 101 )
  {
    if ( ca == 46 )
    {
      cb = lex_get(lex, error);
      if ( cb <= 47 || cb > 57 )
      {
        lex_unget(lex, cb);
        return -1;
      }
      lex_save(lex, cb);
      do
        ca = lex_get_save(lex, error);
      while ( ca > 47 && ca <= 57 );
    }
    if ( ca == 69 || ca == 101 )
    {
      ca = lex_get_save(lex, error);
      if ( ca == 43 || ca == 45 )
        ca = lex_get_save(lex, error);
      if ( ca <= 47 || ca > 57 )
        goto LABEL_6;
      do
        ca = lex_get_save(lex, error);
      while ( ca > 47 && ca <= 57 );
    }
    lex_unget_unsave(lex, ca);
    if ( jsonp_strtod(&lex->saved_text, &doubleval) )
    {
      error_set(error, lex, "real number overflow");
      return -1;
    }
    lex->token = 258;
    lex->value.real = doubleval;
    return 0;
  }
  else
  {
    lex_unget_unsave(lex, ca);
    saved_text = strbuffer_value(&lex->saved_text);
    *_errno_location() = 0;
    intval = strtoll((const char *)saved_text, (char **)&end, 10);
    if ( *_errno_location() == 34 )
    {
      if ( intval >= 0 )
        error_set(error, lex, "too big integer", HIDWORD(intval));
      else
        error_set(error, lex, "too big negative integer", HIDWORD(intval));
      return -1;
    }
    if ( &saved_text[lex->saved_text.length] != end )
      _assert_fail(
        "end == saved_text + lex->saved_text.length",
        "compat/jansson-2.9/src/load.c",
        0x249u,
        (const char *)_PRETTY_FUNCTION___7439);
    lex->token = 257;
    lex->value.integer = intval;
    return 0;
  }
}

//----- (0007C170) --------------------------------------------------------
int __cdecl lex_scan(lex_t *lex, json_error_t *error)
{
  const unsigned __int8 *saved_text; // [sp+8h] [bp+8h]
  int c; // [sp+Ch] [bp+Ch]
  int ca; // [sp+Ch] [bp+Ch]

  strbuffer_clear(&lex->saved_text);
  if ( lex->token == 256 )
    lex_free_string(lex);
  do
  {
    do
      c = lex_get(lex, error);
    while ( c == 32 );
  }
  while ( c == 9 || c == 10 || c == 13 );
  if ( c == -1 )
  {
    lex->token = 0;
  }
  else if ( c == -2 )
  {
    lex->token = -1;
  }
  else
  {
    lex_save(lex, c);
    if ( c == 123 || c == 125 || c == 91 || c == 93 || c == 58 || c == 44 )
    {
      lex->token = c;
    }
    else if ( c == 34 )
    {
      lex_scan_string(lex, error);
    }
    else if ( c > 47 && c <= 57 || c == 45 )
    {
      lex_scan_number(lex, c, error);
    }
    else if ( (c <= 64 || c > 90) && (c <= 96 || c > 122) )
    {
      lex_save_cached(lex);
      lex->token = -1;
    }
    else
    {
      do
      {
        do
          ca = lex_get_save(lex, error);
        while ( ca > 64 && ca <= 90 );
      }
      while ( ca > 96 && ca <= 122 );
      lex_unget_unsave(lex, ca);
      saved_text = strbuffer_value(&lex->saved_text);
      if ( !strcmp((const char *)saved_text, "true") )
      {
        lex->token = 259;
      }
      else if ( !strcmp((const char *)saved_text, "false") )
      {
        lex->token = 260;
      }
      else if ( !strcmp((const char *)saved_text, "null") )
      {
        lex->token = 261;
      }
      else
      {
        lex->token = -1;
      }
    }
  }
  return lex->token;
}

//----- (0007C30A) --------------------------------------------------------
unsigned __int8 *__cdecl lex_steal_string(lex_t *lex, size_t *out_len)
{
  unsigned __int8 *result; // [sp+Ch] [bp+Ch]

  result = 0;
  if ( lex->token == 256 )
  {
    result = lex->value.string.val;
    *out_len = lex->value.string.len;
    lex->value.integer = 0LL;
  }
  return result;
}

//----- (0007C34A) --------------------------------------------------------
int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data)
{
  stream_init(&lex->stream, get, data);
  if ( strbuffer_init(&lex->saved_text) )
    return -1;
  lex->flags = flags;
  lex->token = -1;
  return 0;
}

//----- (0007C392) --------------------------------------------------------
void __cdecl lex_close(lex_t *lex)
{
  if ( lex->token == 256 )
    lex_free_string(lex);
  strbuffer_close(&lex->saved_text);
}

//----- (0007C3BC) --------------------------------------------------------
json_t_0 *__cdecl parse_object(lex_t *lex, size_t flags, json_error_t *error)
{
  size_t len; // [sp+10h] [bp+10h] BYREF
  json_t_0 *value; // [sp+14h] [bp+14h]
  unsigned __int8 *key; // [sp+18h] [bp+18h]
  json_t_0 *object; // [sp+1Ch] [bp+1Ch]

  object = (json_t_0 *)json_object();
  if ( !object )
    return 0;
  lex_scan(lex, error);
  if ( lex->token == 125 )
    return object;
  while ( 1 )
  {
    if ( lex->token != 256 )
    {
      error_set(error, lex, "string or '}' expected");
      goto LABEL_25;
    }
    key = lex_steal_string(lex, &len);
    if ( !key )
      return 0;
    if ( rpl_memchr(key, 0, len) )
    {
      jsonp_free(key);
      error_set(error, lex, "NUL byte in object key not supported");
      goto LABEL_25;
    }
    if ( (flags & 1) != 0 && json_object_get(object, key) )
    {
      jsonp_free(key);
      error_set(error, lex, "duplicate object key");
      goto LABEL_25;
    }
    lex_scan(lex, error);
    if ( lex->token != 58 )
    {
      jsonp_free(key);
      error_set(error, lex, "':' expected");
      goto LABEL_25;
    }
    lex_scan(lex, error);
    value = parse_value(lex, flags, error);
    if ( !value )
    {
      jsonp_free(key);
      goto LABEL_25;
    }
    if ( json_object_set_nocheck(object, key, value) )
    {
      jsonp_free(key);
      json_decref_3(value);
      goto LABEL_25;
    }
    json_decref_3(value);
    jsonp_free(key);
    lex_scan(lex, error);
    if ( lex->token != 44 )
      break;
    lex_scan(lex, error);
  }
  if ( lex->token == 125 )
    return object;
  error_set(error, lex, "'}' expected");
LABEL_25:
  json_decref_3(object);
  return 0;
}

//----- (0007C53A) --------------------------------------------------------
json_t_0 *__cdecl parse_array(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t_0 *elem; // [sp+10h] [bp+10h]
  json_array_t *array; // [sp+14h] [bp+14h]

  array = json_array();
  if ( !array )
    return 0;
  lex_scan(lex, error);
  if ( lex->token == 93 )
    return &array->json;
  while ( lex->token )
  {
    elem = parse_value(lex, flags, error);
    if ( !elem )
      goto LABEL_14;
    if ( json_array_append(&array->json, elem) )
    {
      json_decref_3(elem);
      goto LABEL_14;
    }
    json_decref_3(elem);
    lex_scan(lex, error);
    if ( lex->token != 44 )
      break;
    lex_scan(lex, error);
  }
  if ( lex->token == 93 )
    return &array->json;
  error_set(error, lex, "']' expected");
LABEL_14:
  json_decref_3(&array->json);
  return 0;
}

//----- (0007C5EC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__cdecl parse_value(lex_t *lex, size_t flags, json_error_t *error)
{
  int token; // r3
  char v5; // r1
  size_t v6; // r1
  size_t v7; // r1
  size_t len; // [sp+14h] [bp+14h]
  unsigned __int8 *value; // [sp+18h] [bp+18h]
  json_t_0 *json; // [sp+1Ch] [bp+1Ch]

  if ( ++lex->depth > 0x800 )
  {
    error_set(error, lex, "maximum parsing depth reached");
    return 0;
  }
  token = lex->token;
  if ( token == 257 )
  {
    json = json_integer(lex->value.integer);
  }
  else if ( token >= 258 )
  {
    if ( token == 259 )
    {
      json = json_true();
    }
    else if ( token <= 258 )
    {
      json = json_real(*(double *)&lex);
    }
    else if ( token == 260 )
    {
      json = json_false();
    }
    else
    {
      if ( token != 261 )
        goto LABEL_30;
      json = json_null();
    }
  }
  else if ( token == 91 )
  {
    json = parse_array(lex, v7, error);
  }
  else
  {
    if ( token <= 91 )
    {
      if ( token == -1 )
      {
        error_set(error, lex, "invalid token");
        return 0;
      }
LABEL_30:
      error_set(error, lex, "unexpected token");
      return 0;
    }
    if ( token == 123 )
    {
      json = parse_object(lex, v6, error);
    }
    else
    {
      if ( token != 256 )
        goto LABEL_30;
      value = lex->value.string.val;
      len = lex->value.string.len;
      if ( (v5 & 0x10) == 0 && rpl_memchr(value, 0, len) )
      {
        error_set(error, lex, "\\u0000 is not allowed without JSON_ALLOW_NUL");
        return 0;
      }
      json = jsonp_stringn_nocheck_own(value, len);
      if ( json )
      {
        lex->value.string.val = 0;
        lex->value.string.len = 0;
      }
    }
  }
  if ( !json )
    return 0;
  --lex->depth;
  return json;
}
// 7C5EC: variables would overlap: r0.4 and r0.8

//----- (0007C764) --------------------------------------------------------
json_t_0 *__cdecl parse_json(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t_0 *result; // [sp+14h] [bp+14h]

  lex->depth = 0;
  lex_scan(lex, error);
  if ( (flags & 4) != 0 || lex->token == 91 || lex->token == 123 )
  {
    result = parse_value(lex, flags, error);
    if ( result )
    {
      if ( (flags & 2) != 0 || (lex_scan(lex, error), !lex->token) )
      {
        if ( error )
          error->position = lex->stream.position;
        return result;
      }
      else
      {
        error_set(error, lex, "end of file expected");
        json_decref_3(result);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    error_set(error, lex, "'[' or '{' expected");
    return 0;
  }
}

//----- (0007C810) --------------------------------------------------------
int __cdecl string_get(void *data)
{
  unsigned __int8 c; // [sp+Bh] [bp+Bh]

  c = *(_BYTE *)(*(_DWORD *)data + *((_DWORD *)data + 1));
  if ( !c )
    return -1;
  ++*((_DWORD *)data + 1);
  return c;
}

//----- (0007C84E) --------------------------------------------------------
json_t_0 *__cdecl json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error)
{
  string_data_t stream_data; // [sp+10h] [bp+10h] BYREF
  lex_t lex; // [sp+18h] [bp+18h] BYREF
  json_t_0 *result; // [sp+64h] [bp+64h]

  jsonp_error_init(error, "<string>");
  if ( string )
  {
    stream_data.data = string;
    stream_data.pos = 0;
    if ( lex_init(&lex, (get_func)string_get, flags, &stream_data) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (0007C8CE) --------------------------------------------------------
int __cdecl buffer_get(void *data)
{
  unsigned __int8 c; // [sp+Bh] [bp+Bh]

  if ( *((_DWORD *)data + 2) >= *((_DWORD *)data + 1) )
    return -1;
  c = *(_BYTE *)(*((_DWORD *)data + 2) + *(_DWORD *)data);
  ++*((_DWORD *)data + 2);
  return c;
}

//----- (0007C912) --------------------------------------------------------
json_t_0 *__cdecl json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error)
{
  buffer_data_t stream_data; // [sp+14h] [bp+14h] BYREF
  lex_t lex; // [sp+20h] [bp+20h] BYREF
  json_t_0 *result; // [sp+6Ch] [bp+6Ch]

  jsonp_error_init(error, "<buffer>");
  if ( buffer )
  {
    stream_data.data = buffer;
    stream_data.pos = 0;
    stream_data.len = buflen;
    if ( lex_init(&lex, (get_func)buffer_get, flags, &stream_data) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (0007C998) --------------------------------------------------------
json_t_0 *__cdecl json_loadf(FILE *input, size_t flags, json_error_t *error)
{
  lex_t lex; // [sp+10h] [bp+10h] BYREF
  json_t_0 *result; // [sp+58h] [bp+58h]
  const unsigned __int8 *source; // [sp+5Ch] [bp+5Ch]

  if ( input == (FILE *)stdin )
    source = "<stdin>";
  else
    source = "<stream>";
  jsonp_error_init(error, source);
  if ( input )
  {
    if ( lex_init(&lex, (get_func)fgetc, flags, input) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}
// AC428: using guessed type int stdin;

//----- (0007CA2E) --------------------------------------------------------
json_t_0 *__cdecl json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error)
{
  int *v4; // r0
  char *v5; // r0
  json_t_0 *result; // [sp+18h] [bp+10h]
  FILE *fp; // [sp+1Ch] [bp+14h]

  jsonp_error_init(error, path);
  if ( path )
  {
    fp = fopen((const char *)path, "rb");
    if ( fp )
    {
      result = json_loadf(fp, flags, error);
      fclose(fp);
      return result;
    }
    else
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      error_set(error, 0, "unable to open %s: %s", (const char *)path, v5);
      return 0;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (0007CAB6) --------------------------------------------------------
int __cdecl dump_to_strbuffer(const unsigned __int8 *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
}

//----- (0007CAD6) --------------------------------------------------------
int __cdecl dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data)
{
  size_t v6; // r3
  int cur_n; // [sp+14h] [bp+14h]
  unsigned int n_spaces; // [sp+1Ch] [bp+1Ch]

  if ( (flags & 0x1F) == 0 )
  {
    if ( space && (flags & 0x20) == 0 )
      return dump(byte_970AC, 1, data);
    return 0;
  }
  n_spaces = depth * (flags & 0x1F);
  if ( !dump(byte_970A8, 1, data) )
  {
    while ( n_spaces )
    {
      v6 = n_spaces;
      if ( n_spaces >= 0x20 )
        v6 = 32;
      cur_n = v6;
      if ( dump(whitespace, v6, data) )
        return -1;
      n_spaces -= cur_n;
    }
    return 0;
  }
  return -1;
}
// 970A8: using guessed type unsigned __int8 byte_970A8[4];
// 970AC: using guessed type unsigned __int8 byte_970AC[4];

//----- (0007CB80) --------------------------------------------------------
int __cdecl dump_string(const unsigned __int8 *str, size_t len, json_dump_callback_t dump, void *data, size_t flags)
{
  unsigned __int8 seq[13]; // [sp+18h] [bp+10h] BYREF
  int32_t codepoint; // [sp+28h] [bp+20h] BYREF
  int32_t last; // [sp+2Ch] [bp+24h]
  int32_t first; // [sp+30h] [bp+28h]
  const unsigned __int8 *lim; // [sp+34h] [bp+2Ch]
  int length; // [sp+38h] [bp+30h]
  const unsigned __int8 *text; // [sp+3Ch] [bp+34h]
  const unsigned __int8 *end; // [sp+40h] [bp+38h]
  const unsigned __int8 *pos; // [sp+44h] [bp+3Ch]

  if ( !dump(byte_970B0, 1, data) )
  {
    pos = str;
    end = str;
    lim = &str[len];
    while ( 1 )
    {
      while ( end < lim )
      {
        end = utf8_iterate(pos, lim - pos, &codepoint);
        if ( !end )
          return -1;
        if ( codepoint == 92
          || codepoint == 34
          || codepoint <= 31
          || (flags & 0x400) != 0 && codepoint == 47
          || (flags & 0x40) != 0 && codepoint > 127 )
        {
          break;
        }
        pos = end;
      }
      if ( pos != str && dump(str, pos - str, data) )
        return -1;
      if ( end == pos )
        return dump(byte_970B0, 1, data);
      length = 2;
      if ( codepoint == 12 )
      {
        text = (const unsigned __int8 *)&unk_970C0;
        goto LABEL_44;
      }
      if ( codepoint > 12 )
      {
        if ( codepoint == 34 )
        {
          text = (const unsigned __int8 *)&unk_970B8;
          goto LABEL_44;
        }
        if ( codepoint > 34 )
        {
          if ( codepoint == 47 )
          {
            text = (const unsigned __int8 *)&unk_970D0;
            goto LABEL_44;
          }
          if ( codepoint == 92 )
          {
            text = (const unsigned __int8 *)&unk_970B4;
            goto LABEL_44;
          }
        }
        else if ( codepoint == 13 )
        {
          text = (const unsigned __int8 *)&unk_970C8;
          goto LABEL_44;
        }
      }
      else
      {
        switch ( codepoint )
        {
          case 9:
            text = (const unsigned __int8 *)&unk_970CC;
            goto LABEL_44;
          case 10:
            text = (const unsigned __int8 *)&unk_970C4;
            goto LABEL_44;
          case 8:
            text = (const unsigned __int8 *)&unk_970BC;
            goto LABEL_44;
        }
      }
      if ( codepoint >= 0x10000 )
      {
        codepoint -= 0x10000;
        first = (codepoint >> 10) & 0x3FF | 0xD800;
        last = codepoint & 0x3FF | 0xDC00;
        snprintf((char *)seq, 0xDu, "\\u%04X\\u%04X", first, last);
        length = 12;
      }
      else
      {
        snprintf((char *)seq, 0xDu, "\\u%04X", codepoint);
        length = 6;
      }
      text = seq;
LABEL_44:
      if ( dump(text, length, data) )
        return -1;
      pos = end;
      str = end;
    }
  }
  return -1;
}
// 970B0: using guessed type unsigned __int8 byte_970B0[4];

//----- (0007CD88) --------------------------------------------------------
int __cdecl compare_keys(const void *key1, const void *key2)
{
  return strcmp(*(const char **)key1, *(const char **)key2);
}

//----- (0007CDAC) --------------------------------------------------------
int __cdecl do_dump(const json_t_0 *json, size_t flags, int depth, json_dump_callback_t dump, void *data)
{
  double v5; // d0
  json_int_t v7; // r0
  double v8; // r2
  const unsigned __int8 *v9; // r4
  size_t v10; // r0
  json_t_0 *v11; // r0
  size_t v12; // r0
  size_t v13; // r0
  json_t_0 *v14; // r0
  int precision; // [sp+0h] [bp-8h]
  unsigned __int8 buffer[100]; // [sp+18h] [bp+10h] BYREF
  json_t_0 *value_0; // [sp+7Ch] [bp+74h]
  const unsigned __int8 *key; // [sp+80h] [bp+78h]
  const unsigned __int8 **keys; // [sp+84h] [bp+7Ch]
  size_t size_1; // [sp+88h] [bp+80h]
  const unsigned __int8 *key_0; // [sp+8Ch] [bp+84h]
  void *next; // [sp+90h] [bp+88h]
  json_object_t *object; // [sp+94h] [bp+8Ch]
  size_t n; // [sp+98h] [bp+90h]
  json_array_t *array; // [sp+9Ch] [bp+94h]
  int size; // [sp+A0h] [bp+98h]
  int size_0; // [sp+A4h] [bp+9Ch]
  double value; // [sp+A8h] [bp+A0h]
  size_t i_0; // [sp+B4h] [bp+ACh]
  int separator_length; // [sp+B8h] [bp+B0h]
  const unsigned __int8 *separator; // [sp+BCh] [bp+B4h]
  void *iter; // [sp+C0h] [bp+B8h]
  size_t i; // [sp+C4h] [bp+BCh]

  if ( json )
  {
    switch ( json->type )
    {
      case JSON_OBJECT:
        if ( (flags & 0x20) != 0 )
        {
          separator = ":";
          separator_length = 1;
        }
        else
        {
          separator = ": ";
          separator_length = 2;
        }
        object = (json_object_t *)json;
        if ( json[4].refcount )
          goto object_error;
        object->visited = 1;
        iter = json_object_iter((json_t_0 *)json);
        if ( dump("{", 1, data) )
          goto object_error;
        if ( !iter )
          goto LABEL_37;
        if ( dump_indent(flags, depth + 1, 0, dump, data) )
          goto object_error;
        if ( (flags & 0x80) != 0 )
        {
          size_1 = json_object_size(json);
          keys = (const unsigned __int8 **)jsonp_malloc(4 * size_1);
          if ( !keys )
          {
object_error:
            object->visited = 0;
            return -1;
          }
          i_0 = 0;
          while ( iter )
          {
            keys[i_0] = json_object_iter_key(iter);
            iter = json_object_iter_next((json_t_0 *)json, iter);
            ++i_0;
          }
          if ( i_0 != size_1 )
            _assert_fail("i == size", "compat/jansson-2.9/src/dump.c", 0x152u, (const char *)_PRETTY_FUNCTION___7383);
          qsort(keys, size_1, 4u, (__compar_fn_t)compare_keys);
          for ( i_0 = 0; i_0 < size_1; ++i_0 )
          {
            key = keys[i_0];
            value_0 = json_object_get(json, key);
            if ( !value_0 )
              _assert_fail("value", "compat/jansson-2.9/src/dump.c", 0x15Du, (const char *)_PRETTY_FUNCTION___7383);
            v12 = strlen((const char *)key);
            dump_string(key, v12, dump, data, flags);
            if ( dump(separator, separator_length, data) || do_dump(value_0, flags, depth + 1, dump, data) )
            {
LABEL_57:
              jsonp_free(keys);
              goto object_error;
            }
            if ( i_0 >= size_1 - 1 )
            {
              if ( dump_indent(flags, depth, 0, dump, data) )
                goto LABEL_57;
            }
            else if ( dump(",", 1, data) || dump_indent(flags, depth + 1, 1, dump, data) )
            {
              goto LABEL_57;
            }
          }
          jsonp_free(keys);
        }
        else
        {
          while ( iter )
          {
            next = json_object_iter_next((json_t_0 *)json, iter);
            key_0 = json_object_iter_key(iter);
            v13 = strlen((const char *)key_0);
            dump_string(key_0, v13, dump, data, flags);
            if ( dump(separator, separator_length, data) )
              goto object_error;
            v14 = json_object_iter_value(iter);
            if ( do_dump(v14, flags, depth + 1, dump, data) )
              goto object_error;
            if ( next )
            {
              if ( dump(",", 1, data) || dump_indent(flags, depth + 1, 1, dump, data) )
                goto object_error;
            }
            else if ( dump_indent(flags, depth, 0, dump, data) )
            {
              goto object_error;
            }
            iter = next;
          }
        }
LABEL_37:
        object->visited = 0;
        return dump("}", 1, data);
      case JSON_ARRAY:
        array = (json_array_t *)json;
        if ( json[2].refcount )
          goto array_error;
        array->visited = 1;
        n = json_array_size(json);
        if ( dump("[", 1, data) )
          goto array_error;
        if ( !n )
          goto LABEL_18;
        if ( dump_indent(flags, depth + 1, 0, dump, data) )
          goto array_error;
        i = 0;
        while ( 2 )
        {
          if ( i >= n )
          {
LABEL_18:
            array->visited = 0;
            return dump("]", 1, data);
          }
          v11 = json_array_get(json, i);
          if ( do_dump(v11, flags, depth + 1, dump, data) )
            break;
          if ( i >= n - 1 )
          {
            if ( !dump_indent(flags, depth, 0, dump, data) )
            {
LABEL_27:
              ++i;
              continue;
            }
          }
          else if ( !dump(",", 1, data) && !dump_indent(flags, depth + 1, 1, dump, data) )
          {
            goto LABEL_27;
          }
          break;
        }
array_error:
        array->visited = 0;
        return -1;
      case JSON_STRING:
        v9 = json_string_value(json);
        v10 = json_string_length(json);
        return dump_string(v9, v10, dump, data, flags);
      case JSON_INTEGER:
        v7 = json_integer_value(json);
        size = snprintf((char *)buffer, 0x64u, "%lld", v7);
        if ( size >= 0 && size <= 99 )
          return dump(buffer, size, data);
        else
          return -1;
      case JSON_REAL:
        json_real_value(json);
        value = v5;
        LODWORD(v8) = (unsigned __int16)flags >> 11;
        HIDWORD(v8) = buffer;
        size_0 = jsonp_dtostr(buffer, 0x64u, v8, precision);
        if ( size_0 >= 0 )
          return dump(buffer, size_0, data);
        else
          return -1;
      case JSON_TRUE:
        return dump("true", 4, data);
      case JSON_FALSE:
        return dump("false", 5, data);
      case JSON_NULL:
        return dump("null", 4, data);
      default:
        return -1;
    }
  }
  return -1;
}
// 7CE8E: variable 'v5' is possibly undefined
// 7CEA6: variable 'precision' is possibly undefined

//----- (0007D3E4) --------------------------------------------------------
unsigned __int8 *__cdecl json_dumps(const json_t_0 *json, size_t flags)
{
  const unsigned __int8 *v3; // r0
  strbuffer_t strbuff; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 *result; // [sp+14h] [bp+14h]

  if ( strbuffer_init(&strbuff) )
    return 0;
  if ( json_dump_callback(json, (json_dump_callback_t)dump_to_strbuffer, &strbuff, flags) )
  {
    result = 0;
  }
  else
  {
    v3 = strbuffer_value(&strbuff);
    result = jsonp_strdup(v3);
  }
  strbuffer_close(&strbuff);
  return result;
}

//----- (0007D44A) --------------------------------------------------------
int __cdecl json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags)
{
  if ( (flags & 0x200) != 0 || json && json->type == JSON_ARRAY || json && json->type == JSON_OBJECT )
    return do_dump(json, (unsigned __int16)flags, 0, callback, data);
  else
    return -1;
}

//----- (0007D49E) --------------------------------------------------------
void *__cdecl jsonp_malloc(size_t size)
{
  if ( size )
    return do_malloc(size);
  else
    return 0;
}

//----- (0007D4C8) --------------------------------------------------------
void __cdecl jsonp_free(void *ptr)
{
  if ( ptr )
    do_free(ptr);
}

//----- (0007D4EE) --------------------------------------------------------
unsigned __int8 *__cdecl jsonp_strdup(const unsigned __int8 *str)
{
  size_t v1; // r0

  v1 = strlen((const char *)str);
  return jsonp_strndup(str, v1);
}

//----- (0007D510) --------------------------------------------------------
unsigned __int8 *__cdecl jsonp_strndup(const unsigned __int8 *str, size_t len)
{
  unsigned __int8 *new_str; // [sp+Ch] [bp+Ch]

  new_str = (unsigned __int8 *)jsonp_malloc(len + 1);
  if ( !new_str )
    return 0;
  memcpy(new_str, str, len);
  new_str[len] = 0;
  return new_str;
}

//----- (0007D54E) --------------------------------------------------------
int __cdecl utf8_encode(int32_t codepoint, unsigned __int8 *buffer, size_t *size)
{
  if ( codepoint >= 0 )
  {
    if ( codepoint > 127 )
    {
      if ( codepoint >= 2048 )
      {
        if ( codepoint >= 0x10000 )
        {
          if ( codepoint >= 1114112 )
            return -1;
          *buffer = ((codepoint >> 18) & 7) - 16;
          buffer[1] = ((codepoint >> 12) & 0x3F) + 0x80;
          buffer[2] = ((codepoint >> 6) & 0x3F) + 0x80;
          buffer[3] = (codepoint & 0x3F) + 0x80;
          *size = 4;
        }
        else
        {
          *buffer = ((codepoint >> 12) & 0xF) - 32;
          buffer[1] = ((codepoint >> 6) & 0x3F) + 0x80;
          buffer[2] = (codepoint & 0x3F) + 0x80;
          *size = 3;
        }
      }
      else
      {
        *buffer = ((codepoint >> 6) & 0x1F) - 64;
        buffer[1] = (codepoint & 0x3F) + 0x80;
        *size = 2;
      }
    }
    else
    {
      *buffer = codepoint;
      *size = 1;
    }
    return 0;
  }
  return -1;
}

//----- (0007D67A) --------------------------------------------------------
size_t __cdecl utf8_check_first(unsigned __int8 byte)
{
  if ( (byte & 0x80u) == 0 )
    return 1;
  if ( byte <= 0xBFu )
    return 0;
  if ( byte == 192 || byte == 193 )
    return 0;
  if ( byte > 0xC1u && byte <= 0xDFu )
    return 2;
  if ( byte > 0xDFu && byte <= 0xEFu )
    return 3;
  if ( byte <= 0xEFu || byte > 0xF4u )
    return 0;
  return 4;
}

//----- (0007D6F4) --------------------------------------------------------
size_t __cdecl utf8_check_full(const unsigned __int8 *buffer, size_t size, int32_t *codepoint)
{
  _BYTE u[5]; // [sp+17h] [bp+17h]
  size_t i; // [sp+1Ch] [bp+1Ch]

  *(_DWORD *)u = *buffer;
  switch ( size )
  {
    case 2u:
      *(_DWORD *)&u[1] = u[0] & 0x1F;
      break;
    case 3u:
      *(_DWORD *)&u[1] = u[0] & 0xF;
      break;
    case 4u:
      *(_DWORD *)&u[1] = u[0] & 7;
      break;
    default:
      return 0;
  }
  for ( i = 1; i < size; ++i )
  {
    u[0] = buffer[i];
    if ( u[0] >= 0 || u[0] > 0xBFu )
      return 0;
    *(_DWORD *)&u[1] = (u[0] & 0x3F) + (*(_DWORD *)&u[1] << 6);
  }
  if ( *(int *)&u[1] >= 1114112 )
    return 0;
  if ( *(int *)&u[1] >= 55296 && *(int *)&u[1] < 57344 )
    return 0;
  if ( size == 2 && *(int *)&u[1] <= 127 || size == 3 && *(int *)&u[1] < 2048 || size == 4 && *(int *)&u[1] < 0x10000 )
    return 0;
  if ( codepoint )
    *codepoint = *(_DWORD *)&u[1];
  return 1;
}

//----- (0007D7E2) --------------------------------------------------------
const unsigned __int8 *__cdecl utf8_iterate(const unsigned __int8 *buffer, size_t bufsize, int32_t *codepoint)
{
  int32_t value; // [sp+10h] [bp+10h] BYREF
  size_t count; // [sp+14h] [bp+14h]

  if ( !bufsize )
    return buffer;
  count = utf8_check_first(*buffer);
  if ( !count )
    return 0;
  if ( count == 1 )
  {
    value = *buffer;
  }
  else if ( count > bufsize || !utf8_check_full(buffer, count, &value) )
  {
    return 0;
  }
  if ( codepoint )
    *codepoint = value;
  return &buffer[count];
}

//----- (0007D856) --------------------------------------------------------
void __cdecl json_decref_4(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0007D890) --------------------------------------------------------
uint32_t __cdecl hashlittle(const void *key, size_t length, uint32_t initval)
{
  size_t lengtha; // [sp+8h] [bp+8h]
  const uint8_t *k_1; // [sp+20h] [bp+20h]
  const uint16_t *k_0; // [sp+24h] [bp+24h]
  const uint32_t *k; // [sp+28h] [bp+28h]
  int c; // [sp+2Ch] [bp+2Ch]
  uint32_t ca; // [sp+2Ch] [bp+2Ch]
  uint32_t cb; // [sp+2Ch] [bp+2Ch]
  int cc; // [sp+2Ch] [bp+2Ch]
  uint32_t cd; // [sp+2Ch] [bp+2Ch]
  uint32_t ce; // [sp+2Ch] [bp+2Ch]
  uint32_t cf; // [sp+2Ch] [bp+2Ch]
  int cg; // [sp+2Ch] [bp+2Ch]
  uint32_t ch; // [sp+2Ch] [bp+2Ch]
  uint32_t ci; // [sp+2Ch] [bp+2Ch]
  uint32_t cj; // [sp+2Ch] [bp+2Ch]
  int ck; // [sp+2Ch] [bp+2Ch]
  uint32_t cl; // [sp+2Ch] [bp+2Ch]
  uint32_t cm; // [sp+2Ch] [bp+2Ch]
  uint32_t cn; // [sp+2Ch] [bp+2Ch]
  uint32_t b; // [sp+30h] [bp+30h]
  uint32_t ba; // [sp+30h] [bp+30h]
  int bb; // [sp+30h] [bp+30h]
  uint32_t bc; // [sp+30h] [bp+30h]
  int bd; // [sp+30h] [bp+30h]
  uint32_t be; // [sp+30h] [bp+30h]
  int bf; // [sp+30h] [bp+30h]
  uint32_t bg; // [sp+30h] [bp+30h]
  int bh; // [sp+30h] [bp+30h]
  uint32_t bi; // [sp+30h] [bp+30h]
  int bj; // [sp+30h] [bp+30h]
  uint32_t bk; // [sp+30h] [bp+30h]
  int bl; // [sp+30h] [bp+30h]
  uint32_t bm; // [sp+30h] [bp+30h]
  uint32_t bn; // [sp+30h] [bp+30h]
  uint32_t a; // [sp+34h] [bp+34h]
  int aa; // [sp+34h] [bp+34h]
  uint32_t ab; // [sp+34h] [bp+34h]
  int ac; // [sp+34h] [bp+34h]
  int ad; // [sp+34h] [bp+34h]
  uint32_t ae; // [sp+34h] [bp+34h]
  int af; // [sp+34h] [bp+34h]
  int ag; // [sp+34h] [bp+34h]
  uint32_t ah; // [sp+34h] [bp+34h]
  int ai; // [sp+34h] [bp+34h]
  uint32_t aj; // [sp+34h] [bp+34h]
  uint32_t ak; // [sp+34h] [bp+34h]

  lengtha = length;
  c = length + initval - 559038737;
  b = c;
  a = c;
  if ( ((unsigned __int8)key & 3) != 0 )
  {
    if ( ((unsigned __int8)key & 1) != 0 )
    {
      k_1 = (const uint8_t *)key;
      while ( lengtha > 0xC )
      {
        bi = (k_1[7] << 24) + (k_1[6] << 16) + (k_1[5] << 8) + b + k_1[4];
        ci = (k_1[11] << 24) + (k_1[10] << 16) + (k_1[9] << 8) + c + k_1[8];
        ag = __ROR4__(ci, 28) ^ ((k_1[3] << 24) + (k_1[2] << 16) + (k_1[1] << 8) + a + *k_1 - ci);
        cj = bi + ci;
        bj = __ROR4__(ag, 26) ^ (bi - ag);
        ah = cj + ag;
        ck = __ROR4__(bj, 24) ^ (cj - bj);
        bk = ah + bj;
        ai = __ROR4__(ck, 16) ^ (ah - ck);
        cl = bk + ck;
        bl = __ROR4__(ai, 13) ^ (bk - ai);
        a = cl + ai;
        c = __ROR4__(bl, 28) ^ (cl - bl);
        b = a + bl;
        lengtha -= 12;
        k_1 += 12;
      }
      switch ( lengtha )
      {
        case 0u:
          return c;
        case 1u:
          goto LABEL_52;
        case 2u:
          goto LABEL_51;
        case 3u:
          goto LABEL_50;
        case 4u:
          goto LABEL_49;
        case 5u:
          goto LABEL_48;
        case 6u:
          goto LABEL_47;
        case 7u:
          goto LABEL_46;
        case 8u:
          goto LABEL_45;
        case 9u:
          goto LABEL_44;
        case 0xAu:
          goto LABEL_43;
        case 0xBu:
          goto LABEL_42;
        case 0xCu:
          c += k_1[11] << 24;
LABEL_42:
          c += k_1[10] << 16;
LABEL_43:
          c += k_1[9] << 8;
LABEL_44:
          c += k_1[8];
LABEL_45:
          b += k_1[7] << 24;
LABEL_46:
          b += k_1[6] << 16;
LABEL_47:
          b += k_1[5] << 8;
LABEL_48:
          b += k_1[4];
LABEL_49:
          a += k_1[3] << 24;
LABEL_50:
          a += k_1[2] << 16;
LABEL_51:
          a += k_1[1] << 8;
LABEL_52:
          a += *k_1;
          break;
        default:
          break;
      }
    }
    else
    {
      k_0 = (const uint16_t *)key;
      while ( lengtha > 0xC )
      {
        be = (k_0[3] << 16) + k_0[2] + b;
        ce = (k_0[5] << 16) + k_0[4] + c;
        ad = __ROR4__(ce, 28) ^ ((k_0[1] << 16) + *k_0 + a - ce);
        cf = be + ce;
        bf = __ROR4__(ad, 26) ^ (be - ad);
        ae = cf + ad;
        cg = __ROR4__(bf, 24) ^ (cf - bf);
        bg = ae + bf;
        af = __ROR4__(cg, 16) ^ (ae - cg);
        ch = bg + cg;
        bh = __ROR4__(af, 13) ^ (bg - af);
        a = ch + af;
        c = __ROR4__(bh, 28) ^ (ch - bh);
        b = a + bh;
        lengtha -= 12;
        k_0 += 6;
      }
      switch ( lengtha )
      {
        case 0u:
          return c;
        case 1u:
          a += *(unsigned __int8 *)k_0;
          break;
        case 2u:
          goto LABEL_34;
        case 3u:
          a += *((unsigned __int8 *)k_0 + 2) << 16;
LABEL_34:
          a += *k_0;
          break;
        case 4u:
          goto LABEL_32;
        case 5u:
          b += *((unsigned __int8 *)k_0 + 4);
LABEL_32:
          a += (k_0[1] << 16) + *k_0;
          break;
        case 6u:
          goto LABEL_30;
        case 7u:
          b += *((unsigned __int8 *)k_0 + 6) << 16;
LABEL_30:
          b += k_0[2];
          a += (k_0[1] << 16) + *k_0;
          break;
        case 8u:
          goto LABEL_28;
        case 9u:
          c += *((unsigned __int8 *)k_0 + 8);
LABEL_28:
          b += (k_0[3] << 16) + k_0[2];
          a += (k_0[1] << 16) + *k_0;
          break;
        case 0xAu:
          goto LABEL_26;
        case 0xBu:
          c += *((unsigned __int8 *)k_0 + 10) << 16;
LABEL_26:
          c += k_0[4];
          b += (k_0[3] << 16) + k_0[2];
          a += (k_0[1] << 16) + *k_0;
          break;
        case 0xCu:
          c += (k_0[5] << 16) + k_0[4];
          b += (k_0[3] << 16) + k_0[2];
          a += (k_0[1] << 16) + *k_0;
          break;
        default:
          break;
      }
    }
  }
  else
  {
    k = (const uint32_t *)key;
    while ( lengtha > 0xC )
    {
      ba = k[1] + b;
      ca = k[2] + c;
      aa = __ROR4__(ca, 28) ^ (*k + a - ca);
      cb = ba + ca;
      bb = __ROR4__(aa, 26) ^ (ba - aa);
      ab = cb + aa;
      cc = __ROR4__(bb, 24) ^ (cb - bb);
      bc = ab + bb;
      ac = __ROR4__(cc, 16) ^ (ab - cc);
      cd = bc + cc;
      bd = __ROR4__(ac, 13) ^ (bc - ac);
      a = cd + ac;
      c = __ROR4__(bd, 28) ^ (cd - bd);
      b = a + bd;
      lengtha -= 12;
      k += 3;
    }
    switch ( lengtha )
    {
      case 0u:
        return c;
      case 1u:
        goto LABEL_17;
      case 2u:
        goto LABEL_16;
      case 3u:
        a += *((unsigned __int8 *)k + 2) << 16;
LABEL_16:
        a += *((unsigned __int8 *)k + 1) << 8;
LABEL_17:
        a += *(unsigned __int8 *)k;
        break;
      case 4u:
        goto LABEL_14;
      case 5u:
        goto LABEL_13;
      case 6u:
        goto LABEL_12;
      case 7u:
        b += *((unsigned __int8 *)k + 6) << 16;
LABEL_12:
        b += *((unsigned __int8 *)k + 5) << 8;
LABEL_13:
        b += *((unsigned __int8 *)k + 4);
LABEL_14:
        a += *k;
        break;
      case 8u:
        goto LABEL_10;
      case 9u:
        goto LABEL_9;
      case 0xAu:
        goto LABEL_8;
      case 0xBu:
        c += *((unsigned __int8 *)k + 10) << 16;
LABEL_8:
        c += *((unsigned __int8 *)k + 9) << 8;
LABEL_9:
        c += *((unsigned __int8 *)k + 8);
LABEL_10:
        b += k[1];
        a += *k;
        break;
      case 0xCu:
        c += k[2];
        b += k[1];
        a += *k;
        break;
      default:
        break;
    }
  }
  cm = (b ^ c) - __ROR4__(b, 18);
  aj = (cm ^ a) - __ROR4__(cm, 21);
  bm = (aj ^ b) - __ROR4__(aj, 7);
  cn = (bm ^ cm) - __ROR4__(bm, 16);
  ak = (cn ^ aj) - __ROR4__(cn, 28);
  bn = (ak ^ bm) - __ROR4__(ak, 18);
  return (bn ^ cn) - __ROR4__(bn, 8);
}

//----- (0007E060) --------------------------------------------------------
void __cdecl list_init(list_t *list)
{
  list->next = list;
  list->prev = list;
}

//----- (0007E080) --------------------------------------------------------
void __cdecl list_insert(list_t *list, list_t *node)
{
  node->next = list;
  node->prev = list->prev;
  list->prev->next = node;
  list->prev = node;
}

//----- (0007E0B2) --------------------------------------------------------
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket)
{
  return bucket->first == &hashtable->list && bucket->first == bucket->last;
}

//----- (0007E0E6) --------------------------------------------------------
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list)
{
  if ( bucket_is_empty(hashtable, bucket) )
  {
    list_insert(&hashtable->list, list);
    bucket->last = list;
    bucket->first = bucket->last;
  }
  else
  {
    list_insert(bucket->first, list);
    bucket->first = list;
  }
}

//----- (0007E136) --------------------------------------------------------
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const unsigned __int8 *key, size_t hash)
{
  pair_t *list; // [sp+14h] [bp+14h]

  if ( bucket_is_empty(hashtable, bucket) )
    return 0;
  for ( list = (pair_t *)bucket->first; ; list = (pair_t *)list->list.next )
  {
    if ( hash == list->hash && !strcmp((const char *)list->key, (const char *)key) )
      return list;
    if ( list == (pair_t *)bucket->last )
      break;
  }
  return 0;
}

//----- (0007E19E) --------------------------------------------------------
void __cdecl hashtable_do_clear(hashtable_t *hashtable)
{
  list_t *next; // [sp+10h] [bp+10h]
  hashtable_list *list; // [sp+14h] [bp+14h]

  for ( list = hashtable->list.next; list != &hashtable->list; list = next )
  {
    next = list->next;
    json_decref_4((json_t_0 *)list[2].next);
    jsonp_free(list);
  }
}

//----- (0007E1DE) --------------------------------------------------------
int __cdecl hashtable_do_rehash(hashtable_t *hashtable)
{
  size_t order; // r3
  hashtable_bucket *v3; // r3
  list_t *next; // [sp+10h] [bp+10h]
  hashtable_bucket *new_buckets; // [sp+14h] [bp+14h]
  size_t new_size; // [sp+18h] [bp+18h]
  size_t new_order; // [sp+1Ch] [bp+1Ch]
  size_t i; // [sp+20h] [bp+20h]
  hashtable_t *list; // [sp+24h] [bp+24h]

  order = hashtable->order;
  new_order = order + 1;
  new_size = 1 << (order + 1);
  new_buckets = (hashtable_bucket *)jsonp_malloc(8 * new_size);
  if ( !new_buckets )
    return -1;
  jsonp_free(hashtable->buckets);
  hashtable->buckets = new_buckets;
  hashtable->order = new_order;
  for ( i = 0; i < 1 << hashtable->order; ++i )
  {
    v3 = &hashtable->buckets[i];
    v3->last = &hashtable->list;
    hashtable->buckets[i].first = v3->last;
  }
  list = (hashtable_t *)hashtable->list.next;
  list_init(&hashtable->list);
  while ( list != (hashtable_t *)&hashtable->list )
  {
    next = (list_t *)list->buckets;
    insert_to_bucket(hashtable, &hashtable->buckets[(unsigned int)list->list.next % new_size], (list_t *)list);
    list = (hashtable_t *)next;
  }
  return 0;
}

//----- (0007E2B8) --------------------------------------------------------
int __cdecl hashtable_init(hashtable_t *hashtable)
{
  hashtable_bucket *v2; // r3
  size_t i; // [sp+Ch] [bp+Ch]

  hashtable->size = 0;
  hashtable->order = 3;
  hashtable->buckets = (hashtable_bucket *)jsonp_malloc(8 << hashtable->order);
  if ( !hashtable->buckets )
    return -1;
  list_init(&hashtable->list);
  list_init(&hashtable->ordered_list);
  for ( i = 0; i < 1 << hashtable->order; ++i )
  {
    v2 = &hashtable->buckets[i];
    v2->last = &hashtable->list;
    hashtable->buckets[i].first = v2->last;
  }
  return 0;
}

//----- (0007E348) --------------------------------------------------------
void __cdecl hashtable_close(hashtable_t *hashtable)
{
  hashtable_do_clear(hashtable);
  jsonp_free(hashtable->buckets);
}

//----- (0007E368) --------------------------------------------------------
int __cdecl hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, json_t_0 *value)
{
  size_t v4; // r0
  size_t len; // [sp+14h] [bp+14h]
  pair_t *pair; // [sp+18h] [bp+18h]
  pair_t *paira; // [sp+18h] [bp+18h]
  hashtable_bucket *bucket; // [sp+1Ch] [bp+1Ch]
  uint32_t hash; // [sp+24h] [bp+24h]

  if ( !(hashtable->size >> hashtable->order) || !hashtable_do_rehash(hashtable) )
  {
    v4 = strlen((const char *)key);
    hash = hashlittle(key, v4, hashtable_seed);
    bucket = &hashtable->buckets[((1 << hashtable->order) - 1) & hash];
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if ( pair )
    {
      json_decref_4(pair->value);
      pair->value = value;
    }
    else
    {
      len = strlen((const char *)key);
      if ( len > 0xFFFFFFE6 )
        return -1;
      paira = (pair_t *)jsonp_malloc(len + 25);
      if ( !paira )
        return -1;
      paira->hash = hash;
      strncpy((char *)paira->key, (const char *)key, len + 1);
      paira->value = value;
      list_init(&paira->list);
      list_init(&paira->ordered_list);
      insert_to_bucket(hashtable, bucket, &paira->list);
      list_insert(&hashtable->ordered_list, &paira->ordered_list);
      ++hashtable->size;
    }
    return 0;
  }
  return -1;
}

//----- (0007E486) --------------------------------------------------------
void *__cdecl hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v2; // r0
  pair_t *pair; // [sp+Ch] [bp+Ch]
  uint32_t hash; // [sp+14h] [bp+14h]

  v2 = strlen((const char *)key);
  hash = hashlittle(key, v2, hashtable_seed);
  pair = hashtable_find_pair(hashtable, &hashtable->buckets[hash & ((1 << hashtable->order) - 1)], key, hash);
  if ( pair )
    return pair->value;
  else
    return 0;
}

//----- (0007E4EA) --------------------------------------------------------
void *__cdecl hashtable_iter(hashtable_t *hashtable)
{
  return hashtable_iter_next(hashtable, &hashtable->ordered_list);
}

//----- (0007E508) --------------------------------------------------------
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter)
{
  if ( *((hashtable_t **)iter + 1) == (hashtable_t *)&hashtable->ordered_list )
    return 0;
  else
    return (void *)*((_DWORD *)iter + 1);
}

//----- (0007E536) --------------------------------------------------------
void *__cdecl hashtable_iter_key(void *iter)
{
  return (char *)iter + 16;
}

//----- (0007E554) --------------------------------------------------------
void *__cdecl hashtable_iter_value(void *iter)
{
  return (void *)*((_DWORD *)iter + 3);
}

//----- (0007E572) --------------------------------------------------------
void *__cdecl rpl_memchr(const void *s, int c_in, size_t n)
{
  int repeated_c; // [sp+14h] [bp+14h]
  const rpl_memchr::longword *longword_ptr; // [sp+20h] [bp+20h]
  const unsigned __int8 *char_ptra; // [sp+24h] [bp+24h]

  while ( n && ((unsigned __int8)s & 3) != 0 )
  {
    if ( (unsigned __int8)c_in == *(unsigned __int8 *)s )
      return (void *)s;
    --n;
    s = (char *)s + 1;
  }
  for ( longword_ptr = (const rpl_memchr::longword *)s; n > 3; ++longword_ptr )
  {
    repeated_c = ((((unsigned __int8)c_in << 8) | (unsigned __int8)c_in) << 16) | ((unsigned __int8)c_in << 8) | (unsigned __int8)c_in;
    if ( (((*longword_ptr ^ repeated_c) - 16843009) & ~(*longword_ptr ^ repeated_c) & 0x80808080) != 0 )
      break;
    n -= 4;
  }
  char_ptra = (const unsigned __int8 *)longword_ptr;
  while ( n )
  {
    if ( (unsigned __int8)c_in == *char_ptra )
      return (void *)char_ptra;
    --n;
    ++char_ptra;
  }
  return 0;
}

//----- (0007E63C) --------------------------------------------------------
size_t __cdecl critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period)
{
  size_t v4; // r3
  size_t v5; // r3
  unsigned __int8 b; // [sp+12h] [bp+12h]
  unsigned __int8 ba; // [sp+12h] [bp+12h]
  unsigned __int8 a; // [sp+13h] [bp+13h]
  unsigned __int8 aa; // [sp+13h] [bp+13h]
  size_t p; // [sp+14h] [bp+14h]
  size_t pa; // [sp+14h] [bp+14h]
  size_t k; // [sp+18h] [bp+18h]
  size_t ka; // [sp+18h] [bp+18h]
  size_t j; // [sp+1Ch] [bp+1Ch]
  size_t ja; // [sp+1Ch] [bp+1Ch]
  size_t max_suffix_rev; // [sp+20h] [bp+20h]
  size_t max_suffix; // [sp+24h] [bp+24h]

  if ( needle_len > 2 )
  {
    max_suffix = -1;
    j = 0;
    p = 1;
    k = 1;
    while ( needle_len > k + j )
    {
      a = needle[k + j];
      b = needle[k + max_suffix];
      if ( a >= (unsigned int)b )
      {
        if ( a == b )
        {
          if ( k == p )
          {
            j += p;
            k = 1;
          }
          else
          {
            ++k;
          }
        }
        else
        {
          v4 = j++;
          max_suffix = v4;
          p = 1;
          k = 1;
        }
      }
      else
      {
        j += k;
        k = 1;
        p = j - max_suffix;
      }
    }
    *period = p;
    max_suffix_rev = -1;
    ja = 0;
    pa = 1;
    ka = 1;
    while ( needle_len > ka + ja )
    {
      aa = needle[ka + ja];
      ba = needle[ka + max_suffix_rev];
      if ( ba >= (unsigned int)aa )
      {
        if ( aa == ba )
        {
          if ( ka == pa )
          {
            ja += pa;
            ka = 1;
          }
          else
          {
            ++ka;
          }
        }
        else
        {
          v5 = ja++;
          max_suffix_rev = v5;
          pa = 1;
          ka = 1;
        }
      }
      else
      {
        ja += ka;
        ka = 1;
        pa = ja - max_suffix_rev;
      }
    }
    if ( max_suffix_rev + 1 >= max_suffix + 1 )
    {
      *period = pa;
      return max_suffix_rev + 1;
    }
    else
    {
      return max_suffix + 1;
    }
  }
  else
  {
    *period = 1;
    return needle_len - 1;
  }
}

//----- (0007E7A8) --------------------------------------------------------
void *__cdecl two_way_short_needle(
        const unsigned __int8 *haystack,
        size_t haystack_len,
        const unsigned __int8 *needle,
        size_t needle_len)
{
  size_t v4; // r3
  size_t v6; // r3
  size_t period; // [sp+14h] [bp+14h] BYREF
  size_t suffix; // [sp+18h] [bp+18h]
  size_t memory; // [sp+1Ch] [bp+1Ch]
  size_t j; // [sp+20h] [bp+20h]
  size_t i; // [sp+24h] [bp+24h]

  suffix = critical_factorization(needle, needle_len, &period);
  if ( !memcmp(needle, &needle[period], suffix) )
  {
    memory = 0;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      v4 = memory;
      if ( memory < suffix )
        v4 = suffix;
      for ( i = v4; i < needle_len && needle[i] == haystack[j + i]; ++i )
        ;
      if ( needle_len > i )
      {
        j += i - suffix + 1;
        memory = 0;
      }
      else
      {
        for ( i = suffix - 1; memory < i + 1 && needle[i] == haystack[j + i]; --i )
          ;
        if ( i + 1 < memory + 1 )
          return (void *)&haystack[j];
        j += period;
        memory = needle_len - period;
      }
    }
  }
  else
  {
    v6 = suffix;
    if ( suffix < needle_len - suffix )
      v6 = needle_len - suffix;
    period = v6 + 1;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      for ( i = suffix; i < needle_len && needle[i] == haystack[j + i]; ++i )
        ;
      if ( needle_len > i )
      {
        j += i - suffix + 1;
      }
      else
      {
        for ( i = suffix - 1; i != -1 && needle[i] == haystack[j + i]; --i )
          ;
        if ( i == -1 )
          return (void *)&haystack[j];
        j += period;
      }
    }
  }
  return 0;
}

//----- (0007E950) --------------------------------------------------------
void *__cdecl two_way_long_needle(
        const unsigned __int8 *haystack,
        size_t haystack_len,
        const unsigned __int8 *needle,
        size_t needle_len)
{
  size_t v4; // r3
  size_t v6; // r3
  size_t shift_table[256]; // [sp+14h] [bp+14h]
  size_t period; // [sp+414h] [bp+414h] BYREF
  size_t shift_0; // [sp+418h] [bp+418h]
  size_t suffix; // [sp+41Ch] [bp+41Ch]
  size_t shift; // [sp+420h] [bp+420h]
  size_t memory; // [sp+424h] [bp+424h]
  size_t j; // [sp+428h] [bp+428h]
  size_t i; // [sp+42Ch] [bp+42Ch]

  suffix = critical_factorization(needle, needle_len, &period);
  for ( i = 0; i <= 0xFF; ++i )
    shift_table[i] = needle_len;
  for ( i = 0; i < needle_len; ++i )
    shift_table[needle[i]] = needle_len - i - 1;
  if ( !memcmp(needle, &needle[period], suffix) )
  {
    memory = 0;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      shift = shift_table[haystack[needle_len - 1 + j]];
      if ( shift )
      {
        if ( memory && shift < period )
          shift = needle_len - period;
        memory = 0;
        j += shift;
      }
      else
      {
        v4 = memory;
        if ( memory < suffix )
          v4 = suffix;
        for ( i = v4; i < needle_len - 1 && needle[i] == haystack[j + i]; ++i )
          ;
        if ( i < needle_len - 1 )
        {
          j += i - suffix + 1;
          memory = 0;
        }
        else
        {
          for ( i = suffix - 1; memory < i + 1 && needle[i] == haystack[j + i]; --i )
            ;
          if ( i + 1 < memory + 1 )
            return (void *)&haystack[j];
          j += period;
          memory = needle_len - period;
        }
      }
    }
  }
  else
  {
    v6 = suffix;
    if ( suffix < needle_len - suffix )
      v6 = needle_len - suffix;
    period = v6 + 1;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      shift_0 = shift_table[haystack[needle_len - 1 + j]];
      if ( shift_0 )
      {
        j += shift_0;
      }
      else
      {
        for ( i = suffix; i < needle_len - 1 && needle[i] == haystack[j + i]; ++i )
          ;
        if ( i < needle_len - 1 )
        {
          j += i - suffix + 1;
        }
        else
        {
          for ( i = suffix - 1; i != -1 && needle[i] == haystack[j + i]; --i )
            ;
          if ( i == -1 )
            return (void *)&haystack[j];
          j += period;
        }
      }
    }
  }
  return 0;
}

//----- (0007ECE6) --------------------------------------------------------
void *__cdecl memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len)
{
  size_t haystack_lenb; // [sp+8h] [bp+8h]
  const unsigned __int8 *haystack; // [sp+14h] [bp+14h]

  if ( !needle_len )
    return (void *)haystack_start;
  if ( haystack_len < needle_len )
    return 0;
  if ( needle_len > 0x1F )
    return two_way_long_needle(
             (const unsigned __int8 *)haystack_start,
             haystack_len,
             (const unsigned __int8 *)needle_start,
             needle_len);
  haystack = (const unsigned __int8 *)rpl_memchr(haystack_start, *(unsigned __int8 *)needle_start, haystack_len);
  if ( !haystack || needle_len == 1 )
    return (void *)haystack;
  haystack_lenb = haystack_len - (haystack - (_BYTE *)haystack_start);
  if ( haystack_lenb >= needle_len )
    return two_way_short_needle(haystack, haystack_lenb, (const unsigned __int8 *)needle_start, needle_len);
  else
    return 0;
}

//----- (0007EFF6) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_7F038 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 7EFFA: variable 'v2' is possibly undefined

//----- (0007F648) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (0007F6B8) --------------------------------------------------------
UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)
{
  bool v3; // cf
  UDItype v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  UDItype v10; // r6
  UDItype v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = n >= d;
  LODWORD(v4) = n;
  if ( n < d )
    LODWORD(n) = 0;
  HIDWORD(v4) = HIDWORD(n);
  if ( !v3 )
  {
    HIDWORD(n) = n;
    goto LABEL_16;
  }
  v5 = __clz(HIDWORD(d));
  if ( HIDWORD(d) )
  {
    v6 = __clz(HIDWORD(n));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(n));
  v5 = __clz(d) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = d << v7;
  if ( v4 >= d << v7 )
  {
    LODWORD(n) = 1 << v7;
    v4 -= v10;
    HIDWORD(n) = (1 << v8) | (1u >> v9);
  }
  else
  {
    n = 0LL;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)n, (_DWORD)v4);
    LODWORD(n) = n + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(n) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    n -= v4 << v7;
  }
LABEL_16:
  if ( rp )
    *rp = v4;
  return n;
}

//----- (0007F7D0) --------------------------------------------------------
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp)
{
  void **v6; // r5
  int i; // r4
  void (__fastcall *v8)(int, unsigned __int8 **, unsigned __int8 **); // t1

  init_proc();
  v6 = &_frame_dummy_init_array_entry;
  for ( i = 0; i != 1; ++i )
  {
    v8 = (void (__fastcall *)(int, unsigned __int8 **, unsigned __int8 **))*v6++;
    v8(argc, argv, envp);
  }
}
// A7EF8: using guessed type void *_frame_dummy_init_array_entry;

//----- (0007F810) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1549 queued=1204 decompiled=1204 lumina nreq=0 worse=0 better=0
// ALL OK, 1204 function(s) have been successfully decompiled
