/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_109F8();
int j_pthread_mutex_unlock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
int j_printf(const char *format, ...);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// pthread_t pthread_self(void);
void *j_memcpy(void *dest, const void *src, size_t n);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __off_t lseek(int fd, __off_t offset, int whence);
// int memcmp(const void *s1, const void *s2, size_t n);
// unsigned int sleep(unsigned int seconds);
int j_usleep(__useconds_t useconds);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int sched_get_priority_max(int algorithm);
int j_puts(const char *s);
// int puts(const char *s);
// void *malloc(size_t size);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int system(const char *command);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
void *j_memset(void *s, int c, size_t n);
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// int pthread_cancel(pthread_t th);
ssize_t j_write(int fd, const void *buf, size_t n);
// ssize_t write(int fd, const void *buf, size_t n);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// int pthread_join(pthread_t th, void **thread_return);
// int sprintf(char *s, const char *format, ...);
// int pthread_setschedparam(pthread_t target_thread, int policy, const struct sched_param *param);
// int fseek(FILE *stream, int off, int whence);
// void abort(void);
int j_close(int fd);
// int close(int fd);
int __cdecl main(int argc, const char **argv, const char **envp);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_weak_fn();
char *deregister_tm_clones();
int register_tm_clones(); // idb
char *_do_global_dtors_aux();
int frame_dummy(); // idb
void *__fastcall single_BM1385_show_status_func(void *arg);
void *__fastcall single_BM1385_send_func(void *arg);
void __fastcall get_BM1385_plldata(unsigned int freq, uint32_t *reg_data, uint16_t *reg_data2, uint32_t *vil_data);
void __fastcall read_BM1385_asic_register(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg_addr, bool mode);
void __fastcall set_BM1385_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode);
void __fastcall check_BM1385_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode);
void __fastcall BM1385_chain_inactive(unsigned __int8 which_chain);
void __fastcall BM1385_set_address(unsigned __int8 which_chain, unsigned __int8 address);
void __fastcall BM1385_set_baud(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 baud, bool mode);
void __fastcall BM1385_set_gateblk(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode);
void reset_single_BM1385_global_arg(); // idb
void single_BM1385_calculate_timeout_and_baud(); // idb
void __fastcall single_BM1385_set_address(unsigned __int8 which_chain);
void __fastcall single_BM1385_set_baud(unsigned __int8 which_chain, unsigned __int8 baud);
void __fastcall single_BM1385_open_core(unsigned __int8 which_chain);
unsigned int __fastcall single_BM1385_get_result(unsigned __int8 which_chain);
void __fastcall single_BM1385_print_lcd(unsigned __int8 which_chain, unsigned int result);
int __fastcall BM1385_is_nonce_or_reg_value(unsigned __int8 data);
int __fastcall single_BM1385_check_nonce(unsigned __int8 which_chain, unsigned __int8 *nonce_data);
int __fastcall single_BM1385_check_register_value(unsigned __int8 which_chain, unsigned __int8 *register_data);
void *__fastcall single_BM1385_receive_func(void *arg);
void singleAsicTest_BM1385(); // idb
unsigned __int8 __fastcall CRC5(unsigned __int8 *ptr, unsigned __int8 len);
uint16_t __fastcall CRC16(const uint8_t *p_data, uint16_t w_len);
void reset_hash_board(); // idb
void *__fastcall single_BM1391_send_func(void *arg);
void __fastcall BM1391_set_config(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned int reg_data, bool mode);
void __fastcall BM1391_get_status(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned __int8 mode);
void __fastcall set_BM1391_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode);
unsigned int __fastcall check_BM1391_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode);
void __fastcall BM1391_chain_inactive(unsigned __int8 which_chain);
void __fastcall BM1391_set_address(unsigned __int8 which_chain, unsigned __int8 address);
void __fastcall single_BM1391_set_baud(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 asic_baud, bool mode);
void __fastcall single_BM1391_set_IO_strength(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int data, bool mode);
void reset_single_BM1391_global_arg(); // idb
void single_BM1391_calculate_timeout_and_baud(); // idb
void __fastcall BM1391_software_set_address(unsigned __int8 which_chain);
void __fastcall BM1391_set_baud(unsigned __int8 which_chain, unsigned __int8 baud);
void __fastcall BM1391_set_TM(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned int tm, bool mode);
void __fastcall BM1391_enable_read_temperature_from_asic(unsigned __int8 which_chain, unsigned __int8 asic_addr);
void __fastcall BM1391_enable_core_clock(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned __int8 core_id, unsigned __int8 mode);
void __fastcall single_BM1391P_open_core(unsigned __int8 which_chain);
void __fastcall single_BM1391S_open_core(unsigned __int8 which_chain);
unsigned int __fastcall single_BM1391_get_result(unsigned __int8 which_chain);
void __fastcall single_BM1391_print_lcd(unsigned __int8 which_chain, unsigned int result);
void __fastcall BM1391_soft_reset_sensor(unsigned __int8 which_chain);
void __fastcall BM1391_enable_extended_mode_of_temperature_sensor(unsigned __int8 which_chain);
void __fastcall BM1391_get_temperature_offset_value_from_asic(unsigned __int8 which_chain);
void __fastcall BM1391_set_default_temperature_offset_value(unsigned __int8 which_chain);
void __fastcall BM1391_read_asic_temperature_local_remote(unsigned __int8 which_chain);
void __fastcall BM1391_read_asic_temperature_local(unsigned __int8 which_chain);
void *__fastcall single_BM1391_show_status_func(void *arg);
int __fastcall BM1391_is_nonce_or_reg_value(unsigned int data);
int __fastcall BM1391_check_nonce_flag(unsigned int data);
int __fastcall single_BM1391_check_nonce(unsigned __int8 which_chain, unsigned int *buf);
int __fastcall single_BM1391_check_register_value(unsigned __int8 which_chain, unsigned int *buf);
void *__fastcall single_BM1391_receive_func(void *arg);
void singleAsicTest_BM1391(); // idb
int check_chain(); // idb
int open_lcd(); // idb
int close_lcd(); // idb
void __fastcall write_lcd(unsigned int line, unsigned __int8 *buf, unsigned int size);
void __fastcall write_lcd_no_memset(unsigned int line, unsigned __int8 *buf, unsigned int size);
unsigned int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 which_uart);
unsigned int __fastcall read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length);
unsigned int __fastcall uart_send(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length);
unsigned int __fastcall uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length);
unsigned int __fastcall clear_uart_send_fifo(unsigned __int8 which_chain);
unsigned int __fastcall clear_uart_rx_fifo(unsigned __int8 which_chain);
void single_asic_test(); // idb
void hash_board_test(); // idb
void *__fastcall BHB91603_show_status_func(void *arg);
void *__fastcall BHB91603_send_func(void *arg);
void reset_BHB91603_global_arg(); // idb
bool __fastcall BHB91603_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain);
int __fastcall BHB91603_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c);
void BHB91603_calculate_timeout_and_baud(); // idb
void __fastcall BHB91603_set_address(unsigned __int8 which_chain);
void __fastcall BHB91603_set_baud(unsigned __int8 which_chain, unsigned __int8 baud);
void __fastcall BHB91603_P_open_core(unsigned __int8 which_chain);
void __fastcall BHB91603_P_pre_open_core(unsigned __int8 which_chain);
void __fastcall BHB91603_S_open_core(unsigned __int8 which_chain);
void __fastcall BHB91603_S_pre_open_core(unsigned __int8 which_chain);
unsigned int __fastcall BHB91603_get_result(unsigned __int8 which_chain);
void __fastcall BHB91603_print_lcd(unsigned int result);
int __fastcall BHB91603_check_nonce(unsigned __int8 which_chain, unsigned int *buf);
int __fastcall BHB91603_check_register_value(unsigned __int8 which_chain, unsigned int *buf);
void *__fastcall BHB91603_receive_func(void *arg);
void singleBoardTest_BHB91603_BM1391(); // idb
void read_config(); // idb
void *__fastcall V9_show_status_func(void *arg);
void *__fastcall V9_send_func(void *arg);
void reset_V9_global_arg(); // idb
void __fastcall V9_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c, bool whether_add_voltage);
void V9_calculate_timeout_and_baud(); // idb
void __fastcall V9_set_address(unsigned __int8 which_chain);
void __fastcall V9_set_baud(unsigned __int8 which_chain, unsigned __int8 baud);
void __fastcall V9_open_core(unsigned __int8 which_chain);
unsigned int __fastcall V9_get_result(unsigned __int8 which_chain);
void __fastcall V9_print_lcd(unsigned int result);
int __fastcall v9_check_nonce(unsigned __int8 which_chain, unsigned __int8 *nonce_data);
int __fastcall V9_check_register_value(unsigned __int8 which_chain, unsigned __int8 *register_data);
void *__fastcall V9_receive_func(void *arg);
void singleBoardTest_V9_BM1385_45(); // idb
void __fastcall i2c_write(unsigned int config_data);
unsigned __int8 __fastcall i2c_read(unsigned int config_data);
void power_check_type(); // idb
int open_power_control(); // idb
void close_power_control(); // idb
void power_on(); // idb
void power_off(); // idb
unsigned int get_target_voltage(); // idb
bool __fastcall power_check_reply(uint8_t *cmd, uint8_t *reply_buf, uint8_t reply_len);
bool __fastcall power_send_cmd(uint8_t *cmd, uint8_t len, uint8_t *reply_buf, uint8_t reply_len);
unsigned __int8 __fastcall APW8_calculate_voltage(unsigned int voltage);
void __fastcall APW8_set_voltage(unsigned __int8 N);
unsigned __int8 __fastcall APW9_calculate_voltage(unsigned int voltage);
void __fastcall APW9_set_voltage(unsigned __int8 N);
unsigned __int8 __fastcall power_calculate_voltage(unsigned int voltage);
void __fastcall power_set_voltage(unsigned __int8 N);
int __fastcall Calibration_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic);
int __fastcall set_pre_open_core_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic);
void __fastcall adjust_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic);
unsigned int get_fan_speed(); // idb
void __fastcall set_fan_speed(unsigned int speed);
void __fastcall fan_control(unsigned __int8 level);
void __fastcall sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __fastcall sha256_init(sha256_ctx *ctx);
void __fastcall sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __fastcall sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __fastcall sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void *__fastcall BHB91601_show_status_func(void *arg);
void *__fastcall BHB91601_send_func(void *arg);
void reset_BHB91601_global_arg(); // idb
bool __fastcall BHB91601_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain);
int __fastcall BHB91601_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c);
void BHB91601_calculate_timeout_and_baud(); // idb
void __fastcall BHB91601_set_address(unsigned __int8 which_chain);
void __fastcall BHB91601_set_baud(unsigned __int8 which_chain, unsigned __int8 baud);
void __fastcall BHB91601_P_open_core(unsigned __int8 which_chain);
void __fastcall BHB91601_P_pre_open_core(unsigned __int8 which_chain);
void __fastcall BHB91601_S_open_core(unsigned __int8 which_chain);
void __fastcall BHB91601_S_pre_open_core(unsigned __int8 which_chain);
unsigned int __fastcall BHB91601_get_result(unsigned __int8 which_chain);
void __fastcall BHB91601_print_lcd(unsigned int result);
int __fastcall BHB91601_check_nonce(unsigned __int8 which_chain, unsigned int *buf);
int __fastcall BHB91601_check_register_value(unsigned __int8 which_chain, unsigned int *buf);
void *__fastcall BHB91601_receive_func(void *arg);
void singleBoardTest_BHB91601_BM1391(); // idb
int open_key(); // idb
void close_key(); // idb
ssize_t __fastcall read_key(unsigned __int8 *value);
void __fastcall sha2_starts(sha2_context *ctx);
void __fastcall sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __fastcall sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __fastcall sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __fastcall sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
uint32_t __fastcall swab32(uint32_t v);
void __fastcall flip_swab(void *dest_p, const void *src_p, unsigned int length);
void __fastcall flip32(void *dest_p, const void *src_p);
void *__fastcall BHB07601_send_func(void *arg);
void reset_BHB07601_global_arg(); // idb
void __cdecl dump_eeprom_info(eeprom_layout_t eeprom);
bool __fastcall BHB07601_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain);
int __fastcall BHB07601_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c);
void BHB07601_calculate_timeout_and_baud(); // idb
void __fastcall BHB07601_set_address(unsigned __int8 which_chain);
void __fastcall BHB07601_set_baud(unsigned __int8 which_chain, unsigned __int8 baud);
void __fastcall BHB07601_open_core(unsigned __int8 which_chain);
void __fastcall BHB07601_pre_open_core(unsigned __int8 which_chain);
void __fastcall dump_core_lost_nonce(unsigned __int8 which_chain, unsigned __int8 which_asic);
unsigned int __fastcall BHB07601_get_result(unsigned __int8 which_chain);
void __fastcall BHB07601_print_lcd(unsigned int result);
void kill_hashboard(); // idb
void *__fastcall BHB07601_show_status_func(void *arg);
int __fastcall BHB07601_check_nonce(unsigned __int8 which_chain, unsigned int *buf);
int __fastcall BHB07601_check_register_value(unsigned __int8 which_chain, unsigned int *buf);
void *__fastcall BHB07601_receive_func(void *arg);
void singleBoardTest_BHB07601_BM1397(); // idb
int cgpu_init(); // idb
void malloc_register_buf(); // idb
int get_works(); // idb
int configMiner(); // idb
void display_arguments(); // idb
void clear_register_value_buf(); // idb
int __fastcall calculate_core_number(unsigned int actual_core_number);
unsigned int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned int core_number);
unsigned int __fastcall calculate_how_many_nonce_per_domain_get(unsigned __int8 which_chain, unsigned __int8 which_domain);
void display_level_result_on_lcd(); // idb
void reset_global_arg(); // idb
void __fastcall rev(unsigned __int8 *s, unsigned __int8 l);
int __fastcall check_hw(work *work, unsigned int nonce, bool print);
int open_red_led(); // idb
void close_red_led(); // idb
void red_led_on(); // idb
void red_led_off(); // idb
int open_green_led(); // idb
void close_green_led(); // idb
void green_led_on(); // idb
void green_led_off(); // idb
void __fastcall write_pic1704(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data);
unsigned __int8 __fastcall read_pic1704(unsigned __int8 which_i2c, unsigned __int8 which_chain);
void __fastcall write_dspic33ep16gs202(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data);
unsigned __int8 __fastcall read_dspic33ep16gs202(unsigned __int8 which_i2c, unsigned __int8 which_chain);
int __fastcall set_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 flash_addr_h, unsigned __int8 flash_addr_l);
int __fastcall send_data_to_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __fastcall read_PIC16F1704_flash_pointer(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *flash_addr_h, unsigned __int8 *flash_addr_l);
int __fastcall read_PIC16F1704_flash_data(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __fastcall erase_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __fastcall write_data_into_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __fastcall jump_from_loader_to_app_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall reset_PIC16F1704_pic(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall set_PIC16F1704_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage);
int __fastcall write_hash_ID_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 *buf);
int __fastcall read_hash_id_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __fastcall enable_PIC16F1704_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable);
int __fastcall heart_beat_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall get_PIC16F1704_software_version(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *version);
int __fastcall get_PIC16F1704_voltage(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *voltage);
int __fastcall write_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __fastcall read_temperature_offset_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
unsigned __int8 __fastcall erase_PIC16F1704_app_flash(unsigned int which_i2c, unsigned __int8 which_chain);
int __fastcall PIC1704_update_pic_app_program(unsigned int which_i2c, unsigned __int8 which_chain);
int __fastcall save_freq_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 freq);
int __fastcall get_PIC16F1704_freq(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 *freq);
void __fastcall set_temperature_offset_value(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *value);
void __fastcall write_sensor_info_into_pic(unsigned int which_i2c, unsigned __int8 which_chain);
int __fastcall send_data_to_dsPIC33EP16GS202(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf);
int __fastcall jump_from_loader_to_app_dsPIC33EP16GS202(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall reset_dsPIC33EP16GS202_pic(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall dsPIC33EP16GS202_erase_pic_app_program(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall set_dsPIC33EP16GS202_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage);
int __fastcall set_dsPIC33EP16GS202_threshold_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 vol, unsigned __int16 vol1, unsigned __int16 vol2, unsigned __int16 vol3, unsigned __int16 vol_p);
int __fastcall enable_dsPIC33EP16GS202_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable);
int __fastcall enable_dsPIC33EP16GS202_clamping_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable);
int __fastcall heart_beat_dsPIC33EP16GS202(unsigned int which_chain, unsigned __int8 which_i2c);
int __fastcall get_dsPIC33EP16GS202_software_version(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *version);
int __fastcall dsPIC33EP16GS202_read_out_4_voltage(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int *vol0, unsigned int *vol1, unsigned int *vol2, unsigned int *vol3);
void *__fastcall pic_heart_beat_func(void *arg);
void __fastcall dsPIC33EP16GS202_test(unsigned __int8 which_chain, unsigned __int8 which_i2c);
unsigned __int8 __fastcall read_temperature_from_fpga_register(unsigned __int8 which_chain);
unsigned __int8 __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 which_chain, unsigned int which_i2c);
void __fastcall write_EEPROM_iic(bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned __int8 data);
unsigned __int8 __fastcall read_EEPROM_iic(bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 which_iic, unsigned __int8 which_chain);
void __fastcall AT24C02_write_one_byte(unsigned __int8 address, unsigned __int8 data, unsigned __int8 which_iic, unsigned __int8 which_chain);
unsigned __int8 __fastcall AT24C02_read_one_byte(unsigned __int8 address, unsigned __int8 which_iic, unsigned __int8 which_chain);
void __fastcall AT24C02_write_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int length);
void __fastcall AT24C02_read_bytes(unsigned __int8 address, unsigned __int8 *buf, unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int length);
int Test_EEPROM(); // idb
int Test_EEPROM_part_area(); // idb
void __fastcall AT24C02_save_offset_value(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned __int8 *offset_value);
void __fastcall AT24C02_save_voltage(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int voltage);
unsigned __int8 __fastcall c2hex(unsigned __int8 value);
unsigned __int8 __fastcall twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __fastcall s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen);
void print_works(); // idb
int __fastcall get_work(int id, int count);
int __fastcall get_work_hash_board(int which_asic, int which_core, FILE *stream, int count);
int __fastcall skip_rows(FILE *stream, int count);
int get_works_v1(); // idb
int get_works_v2(); // idb
void clear_nonce_return_flag(); // idb
int bitmain_axi_init(); // idb
void bitmain_axi_close(); // idb
unsigned int __fastcall read_axi_fpga(unsigned int address);
void __fastcall write_axi_fpga(unsigned int address, unsigned int data);
void init_fpga(); // idb
void __fastcall get_return_nonce(unsigned int *buf);
void __fastcall set_BC_command_buffer(unsigned int *value);
unsigned int get_BC_write_command(); // idb
void __fastcall set_BC_write_command(unsigned int value);
void __fastcall set_TW_write_command(unsigned int *value);
void __fastcall set_fpga_baud(unsigned __int8 asic_baud);
void *__fastcall single_BM1397_send_func(void *arg);
uint32_t __fastcall BM1397_get_core_id(uint32_t nonce);
void __fastcall BM1397_set_config(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned int reg_data, bool mode);
void __fastcall BM1397_get_status(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned __int8 reg_addr, unsigned __int8 mode);
void __fastcall BM1397_set_clock_order(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode);
void __fastcall set_BM1397_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode);
void __fastcall set_BM1397_freq_slowly(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode);
unsigned int __fastcall check_BM1397_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode);
void __fastcall BM1397_chain_inactive(unsigned __int8 which_chain);
void __fastcall BM1397_set_address(unsigned __int8 which_chain, unsigned __int8 address);
void __fastcall set_baud_ext(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode);
void __fastcall single_BM1397_set_baud(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int asic_baud, bool mode);
void __fastcall single_BM1397_set_IO_strength(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int data, bool mode);
void reset_single_BM1397_global_arg(); // idb
void single_BM1397_calculate_timeout_and_baud(); // idb
void __fastcall BM1397_software_set_address(unsigned __int8 which_chain);
void __fastcall BM1397_set_baud(unsigned __int8 which_chain, unsigned int baud);
void __fastcall BM1397_set_TM(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned int tm, bool mode);
void __fastcall BM1397_enable_read_temperature_from_asic(unsigned __int8 which_chain, unsigned __int8 asic_addr);
void __fastcall BM1397_set_core_clock_delay_all(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned __int8 reg_data, unsigned __int8 mode);
void __fastcall BM1397_enable_core_clock(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned int core_id, unsigned __int8 mode);
void __fastcall single_BM1397_open_core(unsigned __int8 which_chain);
unsigned int __fastcall single_BM1397_get_result(unsigned __int8 which_chain);
void __fastcall single_BM1397_print_lcd(unsigned __int8 which_chain, unsigned int result);
void __fastcall BM1397_soft_reset_sensor(unsigned __int8 which_chain);
void __fastcall BM1397_enable_extended_mode_of_temperature_sensor(unsigned __int8 which_chain);
void __fastcall BM1397_get_temperature_offset_value_from_asic(unsigned __int8 which_chain);
void __fastcall BM1397_set_default_temperature_offset_value(unsigned __int8 which_chain);
void __fastcall BM1397_read_asic_temperature_local_remote(unsigned __int8 which_chain);
void __fastcall BM1397_read_asic_temperature_local(unsigned __int8 which_chain);
void *__fastcall single_BM1397_show_status_func(void *arg);
int __fastcall BM1397_is_nonce_or_reg_value(unsigned int data);
int __fastcall BM1397_check_nonce_flag(unsigned int data);
int __fastcall single_BM1397_check_nonce(unsigned __int8 which_chain, unsigned int *buf);
int __fastcall single_BM1397_check_register_value(unsigned __int8 which_chain, unsigned int *buf);
void *__fastcall single_BM1397_receive_func(void *arg);
void singleAsicTest_BM1397(); // idb
int _aeabi_ldiv0();
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_186A0; // weak
const unsigned __int8 _FUNCTION___8222[24] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7992[19] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  112u,
  108u,
  108u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8000[26] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8012[16] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8023[22] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8069[31] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  103u,
  108u,
  111u,
  98u,
  97u,
  108u,
  95u,
  97u,
  114u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8088[41] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  95u,
  97u,
  110u,
  100u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8105[26] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8113[23] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8121[24] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8184[26] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8201[35] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8259[27] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  114u,
  101u,
  99u,
  101u,
  105u,
  118u,
  101u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8283[22] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  65u,
  115u,
  105u,
  99u,
  84u,
  101u,
  115u,
  116u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  0u
}; // idb
const uint8_t chCRCHTalbe[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // idb
const unsigned __int8 _FUNCTION___8697[24] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8200[16] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8213[22] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8228[22] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  105u,
  110u,
  97u,
  99u,
  116u,
  105u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8249[30] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  73u,
  79u,
  95u,
  115u,
  116u,
  114u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8269[31] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  103u,
  108u,
  111u,
  98u,
  97u,
  108u,
  95u,
  97u,
  114u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8287[41] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  95u,
  97u,
  110u,
  100u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8304[28] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8312[16] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8350[25] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  80u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8379[25] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  83u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8451[25] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  115u,
  111u,
  102u,
  116u,
  95u,
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8467[50] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  101u,
  120u,
  116u,
  101u,
  110u,
  100u,
  101u,
  100u,
  95u,
  109u,
  111u,
  100u,
  101u,
  95u,
  111u,
  102u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8489[46] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  103u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  97u,
  115u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8513[44] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  100u,
  101u,
  102u,
  97u,
  117u,
  108u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8539[42] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  108u,
  111u,
  99u,
  97u,
  108u,
  95u,
  114u,
  101u,
  109u,
  111u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8558[35] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  108u,
  111u,
  99u,
  97u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8567[31] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  115u,
  104u,
  111u,
  119u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8575[24] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  108u,
  97u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8600[26] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8654[35] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8732[22] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  65u,
  115u,
  105u,
  99u,
  84u,
  101u,
  115u,
  116u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7893[12] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 104u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___6339[10] = { 119u, 114u, 105u, 116u, 101u, 95u, 108u, 99u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___6349[20] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  108u,
  99u,
  100u,
  95u,
  110u,
  111u,
  95u,
  109u,
  101u,
  109u,
  115u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8008[33] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  104u,
  111u,
  119u,
  95u,
  109u,
  97u,
  110u,
  121u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  105u,
  110u,
  95u,
  102u,
  112u,
  103u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8033[23] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  105u,
  110u,
  95u,
  102u,
  112u,
  103u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8070[10] = { 117u, 97u, 114u, 116u, 95u, 115u, 101u, 110u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___8092[13] = { 117u, 97u, 114u, 116u, 95u, 114u, 101u, 99u, 101u, 105u, 118u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___8114[21] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  105u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8122[19] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  117u,
  97u,
  114u,
  116u,
  95u,
  114u,
  120u,
  95u,
  102u,
  105u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8156[16] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8281[26] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  115u,
  104u,
  111u,
  119u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8326[19] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8151[34] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8157[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8174[36] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  95u,
  97u,
  110u,
  100u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8180[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8188[18] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8195[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  80u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8207[25] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  80u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8222_0[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  83u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8240[25] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  83u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8298[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8307[30] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8371[22] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  114u,
  101u,
  99u,
  101u,
  105u,
  118u,
  101u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8385[32] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  66u,
  111u,
  97u,
  114u,
  100u,
  84u,
  101u,
  115u,
  116u,
  95u,
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  51u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8218[12] = { 114u, 101u, 97u, 100u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _FUNCTION___8213_0[13] = { 86u, 57u, 95u, 115u, 101u, 110u, 100u, 95u, 102u, 117u, 110u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___8075[15] =
{
  86u,
  57u,
  95u,
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8093[30] =
{
  86u,
  57u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  95u,
  97u,
  110u,
  100u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8099[15] =
{
  86u,
  57u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8107[12] = { 86u, 57u, 95u, 115u, 101u, 116u, 95u, 98u, 97u, 117u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___8114_0[13] = { 86u, 57u, 95u, 111u, 112u, 101u, 110u, 95u, 99u, 111u, 114u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___8173[15] =
{
  118u,
  57u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8181[24] =
{
  86u,
  57u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8235[16] =
{
  86u,
  57u,
  95u,
  114u,
  101u,
  99u,
  101u,
  105u,
  118u,
  101u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8262[29] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  66u,
  111u,
  97u,
  114u,
  100u,
  84u,
  101u,
  115u,
  116u,
  95u,
  86u,
  57u,
  95u,
  66u,
  77u,
  49u,
  51u,
  56u,
  53u,
  95u,
  52u,
  53u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8004[19] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8046[23] =
{
  65u,
  80u,
  87u,
  56u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8056[23] =
{
  65u,
  80u,
  87u,
  57u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8088_0[20] =
{
  67u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8104[26] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8114_1[15] =
{
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8285[26] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  115u,
  104u,
  111u,
  119u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8330[19] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8155[34] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8161[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8178[36] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  95u,
  97u,
  110u,
  100u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8184_0[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8192[18] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8199[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  80u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8211[25] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  80u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8226[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  83u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8244[25] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  83u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8302[21] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8311[30] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8375[22] =
{
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  114u,
  101u,
  99u,
  101u,
  105u,
  118u,
  101u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8389[32] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  66u,
  111u,
  97u,
  114u,
  100u,
  84u,
  101u,
  115u,
  116u,
  95u,
  66u,
  72u,
  66u,
  57u,
  49u,
  54u,
  48u,
  49u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___5378[9] = { 114u, 101u, 97u, 100u, 95u, 107u, 101u, 121u, 0u }; // idb
const unsigned __int8 _FUNCTION___8427[19] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8242[34] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8252[21] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8269_0[36] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  95u,
  97u,
  110u,
  100u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8275[21] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8283_0[18] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8293[19] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8311_0[23] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8385_0[26] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  115u,
  104u,
  111u,
  119u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8401[21] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8407[30] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8469[22] =
{
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  114u,
  101u,
  99u,
  101u,
  105u,
  118u,
  101u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8483[32] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  66u,
  111u,
  97u,
  114u,
  100u,
  84u,
  101u,
  115u,
  116u,
  95u,
  66u,
  72u,
  66u,
  48u,
  55u,
  54u,
  48u,
  49u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8274[10] = { 99u, 103u, 112u, 117u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___8287_0[20] =
{
  109u,
  97u,
  108u,
  108u,
  111u,
  99u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  98u,
  117u,
  102u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8309[22] =
{
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8353[17] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  103u,
  108u,
  111u,
  98u,
  97u,
  108u,
  95u,
  97u,
  114u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8381[9] = { 99u, 104u, 101u, 99u, 107u, 95u, 104u, 119u, 0u }; // idb
const unsigned __int8 _FUNCTION___8002[29] =
{
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  95u,
  112u,
  111u,
  105u,
  110u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8026[24] =
{
  115u,
  101u,
  110u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  116u,
  111u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8045[30] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  95u,
  112u,
  111u,
  105u,
  110u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8063[27] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8083[23] =
{
  101u,
  114u,
  97u,
  115u,
  101u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8100[33] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  105u,
  110u,
  116u,
  111u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8117[35] =
{
  106u,
  117u,
  109u,
  112u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  108u,
  111u,
  97u,
  100u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  97u,
  112u,
  112u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8134[21] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8146[23] =
{
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8176[25] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  73u,
  68u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8194[24] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  105u,
  100u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8209[24] =
{
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  100u,
  99u,
  95u,
  100u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8232[22] =
{
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8250[32] =
{
  103u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8268[23] =
{
  103u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8292[36] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8310[35] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8326_0[27] =
{
  101u,
  114u,
  97u,
  115u,
  101u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  97u,
  112u,
  112u,
  95u,
  102u,
  108u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8347[31] =
{
  80u,
  73u,
  67u,
  49u,
  55u,
  48u,
  52u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  97u,
  112u,
  112u,
  95u,
  112u,
  114u,
  111u,
  103u,
  114u,
  97u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8374[21] =
{
  115u,
  97u,
  118u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8392[20] =
{
  103u,
  101u,
  116u,
  95u,
  80u,
  73u,
  67u,
  49u,
  54u,
  70u,
  49u,
  55u,
  48u,
  52u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8398[29] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8404[27] =
{
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  111u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8428[30] =
{
  115u,
  101u,
  110u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  116u,
  111u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8445[41] =
{
  106u,
  117u,
  109u,
  112u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  108u,
  111u,
  97u,
  100u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  97u,
  112u,
  112u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8462[27] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  112u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8473[39] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  101u,
  114u,
  97u,
  115u,
  101u,
  95u,
  112u,
  105u,
  99u,
  95u,
  97u,
  112u,
  112u,
  95u,
  112u,
  114u,
  111u,
  103u,
  114u,
  97u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8491[29] =
{
  115u,
  101u,
  116u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8513_0[39] =
{
  115u,
  101u,
  116u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  116u,
  104u,
  114u,
  101u,
  115u,
  104u,
  111u,
  108u,
  100u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8531[30] =
{
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  100u,
  99u,
  95u,
  100u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8549[41] =
{
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  99u,
  108u,
  97u,
  109u,
  112u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8572[28] =
{
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8590[38] =
{
  103u,
  101u,
  116u,
  95u,
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8611[36] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  111u,
  117u,
  116u,
  95u,
  52u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8618[20] =
{
  112u,
  105u,
  99u,
  95u,
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8624[22] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7971[36] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  102u,
  112u,
  103u,
  97u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7777[20] =
{
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  98u,
  121u,
  116u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7789[19] =
{
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  98u,
  121u,
  116u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7835[26] =
{
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  115u,
  97u,
  118u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7844[21] =
{
  65u,
  84u,
  50u,
  52u,
  67u,
  48u,
  50u,
  95u,
  115u,
  97u,
  118u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8187[12] = { 112u, 114u, 105u, 110u, 116u, 95u, 119u, 111u, 114u, 107u, 115u, 0u }; // idb
const unsigned __int8 _FUNCTION___8380[13] = { 103u, 101u, 116u, 95u, 119u, 111u, 114u, 107u, 115u, 95u, 118u, 49u, 0u }; // idb
const unsigned __int8 _FUNCTION___8412[13] = { 103u, 101u, 116u, 95u, 119u, 111u, 114u, 107u, 115u, 95u, 118u, 50u, 0u }; // idb
const unsigned __int8 _FUNCTION___8440[24] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  114u,
  101u,
  116u,
  117u,
  114u,
  110u,
  95u,
  102u,
  108u,
  97u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7923[18] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  97u,
  120u,
  105u,
  95u,
  99u,
  108u,
  111u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___7936[10] = { 105u, 110u, 105u, 116u, 95u, 102u, 112u, 103u, 97u, 0u }; // idb
const unsigned __int8 _FUNCTION___7954[21] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8795[24] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8312_0[22] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8327[22] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  105u,
  110u,
  97u,
  99u,
  116u,
  105u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8355[13] = { 115u, 101u, 116u, 95u, 98u, 97u, 117u, 100u, 95u, 101u, 120u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___8370[30] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  115u,
  101u,
  116u,
  95u,
  73u,
  79u,
  95u,
  115u,
  116u,
  114u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8390[31] =
{
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  103u,
  108u,
  111u,
  98u,
  97u,
  108u,
  95u,
  97u,
  114u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8408[41] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  95u,
  97u,
  110u,
  100u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8425[28] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  115u,
  111u,
  102u,
  116u,
  119u,
  97u,
  114u,
  101u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8433[16] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8472[24] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8526[25] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  103u,
  101u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8544[25] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  115u,
  111u,
  102u,
  116u,
  95u,
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8560[50] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  101u,
  110u,
  97u,
  98u,
  108u,
  101u,
  95u,
  101u,
  120u,
  116u,
  101u,
  110u,
  100u,
  101u,
  100u,
  95u,
  109u,
  111u,
  100u,
  101u,
  95u,
  111u,
  102u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8582[46] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  103u,
  101u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  97u,
  115u,
  105u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8606[44] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  115u,
  101u,
  116u,
  95u,
  100u,
  101u,
  102u,
  97u,
  117u,
  108u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8637[42] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  108u,
  111u,
  99u,
  97u,
  108u,
  95u,
  114u,
  101u,
  109u,
  111u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8656[35] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  95u,
  108u,
  111u,
  99u,
  97u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8665[31] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  115u,
  104u,
  111u,
  119u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8673[24] =
{
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  108u,
  97u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8698[26] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8752[35] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8830[22] =
{
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  65u,
  115u,
  105u,
  99u,
  84u,
  101u,
  115u,
  116u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  55u,
  0u
}; // idb
void *_frame_dummy_init_array_entry = (void *)0x10D55; // weak
freq_pll freq_pll_1385[124] =
{
  { &a19, 131136u, 1056u, 2097779u },
  { &a22, 131136u, 1056u, 2097763u },
  { &a26, 131136u, 1056u, 2097747u },
  { &a28, 131136u, 1056u, 2097778u },
  { &a33, 131136u, 1056u, 2097731u },
  { &a40, 131136u, 1056u, 2097746u },
  { &a50, 131136u, 1056u, 2097730u },
  { &a57, 131136u, 1056u, 2097777u },
  { &a66, 131136u, 1056u, 2097761u },
  { &a80, 131136u, 1056u, 2097745u },
  { &a100, 131136u, 1056u, 2097729u },
  { &a125, 163904u, 1056u, 2622017u },
  { &a150, 196672u, 1056u, 3146305u },
  { &a175, 229440u, 1056u, 3670593u },
  { &a200, 262208u, 1056u, 4194881u },
  { &a225, 294976u, 1056u, 4719169u },
  { &a250, 327744u, 1056u, 5243457u },
  { &a275, 360512u, 1056u, 5767745u },
  { &a300, 393280u, 1056u, 6292033u },
  { &a325, 426048u, 1056u, 6816321u },
  { &a350, 458816u, 1056u, 7340609u },
  { &a375, 491584u, 1056u, 7864897u },
  { &a400, 524352u, 1056u, 8389185u },
  { &a404, 397376u, 800u, 6357553u },
  { &a406, 266304u, 544u, 4260385u },
  { &a408, 401472u, 800u, 6423089u },
  { &a412, 270400u, 544u, 4325921u },
  { &a416, 409664u, 800u, 6554161u },
  { &a418, 274496u, 544u, 4391457u },
  { &a420, 413760u, 800u, 6619697u },
  { &a425, 278592u, 544u, 4456993u },
  { &a429, 421952u, 800u, 6750769u },
  { &a431, 282688u, 544u, 4522529u },
  { &a433, 426048u, 800u, 6816305u },
  { &a437, 286784u, 544u, 4588065u },
  { &a441, 434240u, 800u, 6947377u },
  { &a443, 290880u, 544u, 4653601u },
  { &a445, 438336u, 800u, 7012913u },
  { &a450, 294976u, 544u, 4719137u },
  { &a454, 446528u, 800u, 7143985u },
  { &a456, 299072u, 544u, 4784673u },
  { &a458, 450624u, 800u, 7209521u },
  { &a462, 303168u, 544u, 4850209u },
  { &a466, 458816u, 800u, 7340593u },
  { &a468, 307264u, 544u, 4915745u },
  { &a470, 462912u, 800u, 7406129u },
  { &a475, 311360u, 544u, 4981281u },
  { &a479, 471104u, 800u, 7537201u },
  { &a481, 315456u, 544u, 5046817u },
  { &a483, 475200u, 800u, 7602737u },
  { &a487, 319552u, 544u, 5112353u },
  { &a491, 483392u, 800u, 7733809u },
  { &a493, 323648u, 544u, 5177889u },
  { &a495, 487488u, 800u, 7799345u },
  { &a500, 327744u, 544u, 5243425u },
  { &a504, 495680u, 800u, 7930417u },
  { &a506, 331840u, 544u, 5308961u },
  { &a508, 499776u, 800u, 7995953u },
  { &a512, 335936u, 544u, 5374497u },
  { &a516, 507968u, 800u, 8127025u },
  { &a518, 340032u, 544u, 5440033u },
  { &a520, 512064u, 800u, 8192561u },
  { &a525, 344128u, 544u, 5505569u },
  { &a529, 520256u, 800u, 8323633u },
  { &a531, 348224u, 544u, 5571105u },
  { &a533, 524352u, 800u, 8389169u },
  { &a537, 352320u, 544u, 5636641u },
  { &a543, 356416u, 544u, 5702177u },
  { &a550, 360512u, 544u, 5767713u },
  { &a556, 364608u, 544u, 5833249u },
  { &a562, 368704u, 544u, 5898785u },
  { &a568, 372800u, 544u, 5964321u },
  { &a575, 376896u, 544u, 6029857u },
  { &a581, 380992u, 544u, 6095393u },
  { &a587, 385088u, 544u, 6160929u },
  { &a593, 389184u, 544u, 6226465u },
  { &a600, 393280u, 544u, 6292001u },
  { &a606, 397376u, 544u, 6357537u },
  { &a612, 401472u, 544u, 6423073u },
  { &a618, 405568u, 544u, 6488609u },
  { &a625, 409664u, 544u, 6554145u },
  { &a631, 413760u, 544u, 6619681u },
  { &a637, 417856u, 544u, 6685217u },
  { &a643, 421952u, 544u, 6750753u },
  { &a650, 426048u, 544u, 6816289u },
  { &a656, 430144u, 544u, 6881825u },
  { &a662, 434240u, 544u, 6947361u },
  { &a668, 438336u, 544u, 7012897u },
  { &a675, 442432u, 544u, 7078433u },
  { &a681, 446528u, 544u, 7143969u },
  { &a687, 450624u, 544u, 7209505u },
  { &a693, 454720u, 544u, 7275041u },
  { &a700, 458816u, 544u, 7340577u },
  { &a706, 462912u, 544u, 7406113u },
  { &a712, 467008u, 544u, 7471649u },
  { &a718, 471104u, 544u, 7537185u },
  { &a725, 475200u, 544u, 7602721u },
  { &a731, 479296u, 544u, 7668257u },
  { &a737, 483392u, 544u, 7733793u },
  { &a743, 487488u, 544u, 7799329u },
  { &a750, 491584u, 544u, 7864865u },
  { &a756, 495680u, 544u, 7930401u },
  { &a762, 499776u, 544u, 7995937u },
  { &a768, 503872u, 544u, 8061473u },
  { &a775, 507968u, 544u, 8127009u },
  { &a781, 512064u, 544u, 8192545u },
  { &a787, 516160u, 544u, 8258081u },
  { &a793, 520256u, 544u, 8323617u },
  { &a800, 524352u, 544u, 8389153u },
  { &a825, 270400u, 288u, 4325905u },
  { &a850, 278592u, 288u, 4456977u },
  { &a875, 286784u, 288u, 4588065u },
  { &a900, 294976u, 288u, 4719137u },
  { &a925, 303168u, 288u, 4850209u },
  { &a950, 311360u, 288u, 4981281u },
  { &a975, 319552u, 288u, 5112353u },
  { &a1000, 327744u, 288u, 5243425u },
  { &a1025, 335936u, 288u, 5374497u },
  { &a1050, 344128u, 288u, 5505569u },
  { &a1075, 352320u, 288u, 5636641u },
  { &a1100, 360512u, 288u, 5767713u },
  { &a1125, 368704u, 288u, 5898785u },
  { &a1150, 376896u, 288u, 6029857u },
  { &a1175, 385088u, 288u, 6160929u }
}; // idb
unsigned __int8 *Single_BM1385_WorkDataPathPrefix = &aMntCardSingleB; // idb
unsigned int gBM1391_MISC_CONTROL_reg = 14849u; // idb
unsigned __int8 *Single_BM1391_WorkDataPathPrefix = &aMntCardSingleB_0; // idb
unsigned __int8 lcd_output[4][16] =
{
  { 32u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u },
  { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }
}; // idb
unsigned __int8 lcd_buffer[16] =
{
  32u,
  32u,
  32u,
  76u,
  101u,
  118u,
  101u,
  108u,
  58u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u
}; // idb
unsigned __int8 *BHB91603_WorkDataPathPrefix = &aMntCardMinerte_0; // idb
unsigned __int8 *V9_WorkDataPathPrefix = &aMntCardMinerte_1; // idb
uint16_t g_power_type = 1u; // idb
uint32_t sha256_k[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
uint32_t sha256_h0[8] =
{
  1779033703u,
  3144134277u,
  1013904242u,
  2773480762u,
  1359893119u,
  2600822924u,
  528734635u,
  1541459225u
}; // idb
unsigned __int8 *BHB91601_WorkDataPathPrefix = &aMntCardMinerte; // idb
unsigned __int8 *BHB07601_WorkDataFilePrefix = &a07601Pattern48; // idb
unsigned __int8 *BHB07601_WorkDataPathPrefix = &aMntCard; // idb
unsigned __int8 gChain = 255u; // idb
unsigned __int8 Sensor1_OK = 1u; // idb
unsigned __int8 Sensor2_OK = 1u; // idb
unsigned __int8 Sensor3_OK = 1u; // idb
unsigned __int8 Sensor4_OK = 1u; // idb
bool gSensor_OK[4][4] =
{
  { true, false, false, false },
  { false, false, false, false },
  { false, false, false, false },
  { false, false, false, false }
}; // idb
unsigned __int8 bit_swap_table[256] =
{
  0u,
  128u,
  64u,
  192u,
  32u,
  160u,
  96u,
  224u,
  16u,
  144u,
  80u,
  208u,
  48u,
  176u,
  112u,
  240u,
  8u,
  136u,
  72u,
  200u,
  40u,
  168u,
  104u,
  232u,
  24u,
  152u,
  88u,
  216u,
  56u,
  184u,
  120u,
  248u,
  4u,
  132u,
  68u,
  196u,
  36u,
  164u,
  100u,
  228u,
  20u,
  148u,
  84u,
  212u,
  52u,
  180u,
  116u,
  244u,
  12u,
  140u,
  76u,
  204u,
  44u,
  172u,
  108u,
  236u,
  28u,
  156u,
  92u,
  220u,
  60u,
  188u,
  124u,
  252u,
  2u,
  130u,
  66u,
  194u,
  34u,
  162u,
  98u,
  226u,
  18u,
  146u,
  82u,
  210u,
  50u,
  178u,
  114u,
  242u,
  10u,
  138u,
  74u,
  202u,
  42u,
  170u,
  106u,
  234u,
  26u,
  154u,
  90u,
  218u,
  58u,
  186u,
  122u,
  250u,
  6u,
  134u,
  70u,
  198u,
  38u,
  166u,
  102u,
  230u,
  22u,
  150u,
  86u,
  214u,
  54u,
  182u,
  118u,
  246u,
  14u,
  142u,
  78u,
  206u,
  46u,
  174u,
  110u,
  238u,
  30u,
  158u,
  94u,
  222u,
  62u,
  190u,
  126u,
  254u,
  1u,
  129u,
  65u,
  193u,
  33u,
  161u,
  97u,
  225u,
  17u,
  145u,
  81u,
  209u,
  49u,
  177u,
  113u,
  241u,
  9u,
  137u,
  73u,
  201u,
  41u,
  169u,
  105u,
  233u,
  25u,
  153u,
  89u,
  217u,
  57u,
  185u,
  121u,
  249u,
  5u,
  133u,
  69u,
  197u,
  37u,
  165u,
  101u,
  229u,
  21u,
  149u,
  85u,
  213u,
  53u,
  181u,
  117u,
  245u,
  13u,
  141u,
  77u,
  205u,
  45u,
  173u,
  109u,
  237u,
  29u,
  157u,
  93u,
  221u,
  61u,
  189u,
  125u,
  253u,
  3u,
  131u,
  67u,
  195u,
  35u,
  163u,
  99u,
  227u,
  19u,
  147u,
  83u,
  211u,
  51u,
  179u,
  115u,
  243u,
  11u,
  139u,
  75u,
  203u,
  43u,
  171u,
  107u,
  235u,
  27u,
  155u,
  91u,
  219u,
  59u,
  187u,
  123u,
  251u,
  7u,
  135u,
  71u,
  199u,
  39u,
  167u,
  103u,
  231u,
  23u,
  151u,
  87u,
  215u,
  55u,
  183u,
  119u,
  247u,
  15u,
  143u,
  79u,
  207u,
  47u,
  175u,
  111u,
  239u,
  31u,
  159u,
  95u,
  223u,
  63u,
  191u,
  127u,
  255u
}; // idb
unsigned __int8 *BTC_WorkDataFilePrefix = &aBtcCore; // idb
unsigned __int8 gAT24C02_data_map[256] =
{
  255u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
unsigned int gBM1397_MISC_CONTROL_reg = 14849u; // idb
unsigned __int8 *Single_BM1397_WorkDataFilePrefix = &a07601Pattern48; // idb
unsigned __int8 *Single_BM1397_WorkDataPathPrefix = &aMntCard; // idb
char _bss_start; // weak
int lcd_fd; // idb
pthread_mutex_t uart_send_mutex[4]; // idb
pthread_mutex_t uart_receive_mutex[4]; // idb
unsigned int BHB91603_ASIC_NUMBER; // idb
int power_control_fd; // idb
unsigned int BHB91601_ASIC_NUMBER; // idb
int key_fd; // idb
unsigned int BHB07601_ASIC_NUMBER; // idb
unsigned int gName_len; // idb
pthread_mutex_t reg_mutex; // idb
unsigned int gAsic_Core_Nonce_Num[4][128][1024]; // idb
unsigned __int8 pattern_test_time; // idb
unsigned int time_counter; // idb
unsigned int gHighest_Temp; // idb
unsigned __int8 gWork_Num_For_Hw_Check; // idb
int Sensor1_temp; // idb
int Sensor2_temp; // idb
int Sensor3_temp; // idb
int Sensor4_temp; // idb
int last_Sensor1_temp; // idb
int last_Sensor2_temp; // idb
int last_Sensor3_temp; // idb
int last_Sensor4_temp; // idb
int highest_temp; // idb
int lowest_temp; // idb
int gGlobalHighestTemp; // idb
int temp_change; // idb
bool gNotReadOutTemp; // idb
bool gIsOpenCoreEnd; // idb
char gT1_offset_value; // idb
char gT2_offset_value; // idb
char gT3_offset_value; // idb
char gT4_offset_value; // idb
bool gHigherThanMaxTempGap; // idb
int gMaxTempGap_value; // idb
bool gIsReadTemp; // idb
bool gReadingTemp; // idb
bool gEEPROM_error; // idb
bool gStartTest; // idb
bool gBegin_Get_Nonce; // idb
bool start_receive; // idb
unsigned int gValid_Nonce_Num[4]; // idb
unsigned int gHw_Nonce_Num[4]; // idb
unsigned int gRepeated_Nonce_Id[4]; // idb
unsigned int gSensor_read_ok_counter[4][4]; // idb
pthread_mutex_t HW_check_mutex[4]; // idb
unsigned int gSensor_number; // idb
unsigned int gSend_Work_Num[4]; // idb
bool gHigherThanAlarmTemp; // idb
bool gIsOpeningCore; // idb
unsigned int gPattern_number; // idb
unsigned int gChain_Asic_Interval; // idb
unsigned __int8 gHowManyVoltageLevel; // idb
unsigned int gSensor_i2c_addr_high_4_bit; // idb
unsigned int gPic_addr_high_4_bit; // idb
unsigned __int8 gI2c; // idb
bool gHashBoard_BHB07601; // idb
bool gHashBoard_BHB91603P; // idb
bool gHashBoard_BHB91603S; // idb
bool gHashBoard_BHB91601S; // idb
bool gHashBoard_BHB91601P; // idb
bool gHashBoard_V9; // idb
int red_led_fd; // idb
int green_led_fd; // idb
pthread_mutex_t i2c_mutex; // idb
unsigned int *axi_fpga_addr; // idb
unsigned int *fpga_mem_addr; // idb
cgpu_info cgpu; // idb
chain_info chain_info_0[4]; // idb
reg_buf *reg_value_buf; // idb
configuration Conf; // idb
work gWorks_For_Hw_Check[4][128]; // idb
bad_chip gBad_Chip; // idb
int fd_fpga_mem; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (000109EC) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (000109F8) --------------------------------------------------------
void sub_109F8()
{
  JUMPOUT(0);
}
// 10A04: control flows out of bounds to 0

//----- (00010A0C) --------------------------------------------------------
// attributes: thunk
int j_pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (00010A40) --------------------------------------------------------
// attributes: thunk
int j_printf(const char *format, ...)
{
  return printf(format);
}

//----- (00010A98) --------------------------------------------------------
// attributes: thunk
void *j_memcpy(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (00010AD8) --------------------------------------------------------
// attributes: thunk
int j_usleep(__useconds_t useconds)
{
  return usleep(useconds);
}

//----- (00010B18) --------------------------------------------------------
// attributes: thunk
int j_puts(const char *s)
{
  return puts(s);
}

//----- (00010B94) --------------------------------------------------------
// attributes: thunk
void *j_memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (00010BBC) --------------------------------------------------------
// attributes: thunk
ssize_t j_write(int fd, const void *buf, size_t n)
{
  return write(fd, buf, n);
}

//----- (00010C20) --------------------------------------------------------
// attributes: thunk
int j_close(int fd)
{
  return close(fd);
}

//----- (00010C30) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // r0
  unsigned __int8 command; // [sp+7h] [bp-9h] BYREF

  puts("--- version:");
  puts("last commit version: 4e0ba0e commit time: 2019-05-06 17:16:11 build: 2019-08-17 11:22:48");
  result = cgpu_init();
  if ( result >= 0 )
  {
    result = configMiner();
    if ( result >= 0 )
    {
      display_arguments();
      puts("\n\nReady begin test\n");
      while ( 1 )
      {
        while ( read_key(&command) <= 0 )
          ;
        if ( command == 48 )
        {
          hash_board_test();
          puts("\nPress 'test' key to continue");
        }
      }
    }
  }
  return result;
}

//----- (00010C98) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    _libc_csu_fini,
    a1,
    va);
  abort();
}
// 10CA2: positive sp value 4 has been found
// 10CB4: variable 'v4' is possibly undefined

//----- (00010CC8) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 10B4C: using guessed type int _gmon_start__(void);

//----- (00010CEC) --------------------------------------------------------
char *deregister_tm_clones()
{
  return &_bss_start;
}
// 30D4C: using guessed type char _bss_start;

//----- (00010D10) --------------------------------------------------------
int register_tm_clones()
{
  return 200012;
}

//----- (00010D3C) --------------------------------------------------------
char *_do_global_dtors_aux()
{
  char *result; // r0

  if ( !_bss_start )
  {
    result = deregister_tm_clones();
    _bss_start = 1;
  }
  return result;
}
// 30D4C: using guessed type char _bss_start;

//----- (00010D54) --------------------------------------------------------
int frame_dummy()
{
  return register_tm_clones();
}

//----- (00010D78) --------------------------------------------------------
void *__fastcall __noreturn single_BM1385_show_status_func(void *arg)
{
  unsigned int v1; // r10
  int v2; // r9

  v1 = 0;
  v2 = *(unsigned __int8 *)arg;
  for ( time_counter = 0; ; v1 = time_counter )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    sprintf((char *)lcd_output[1], "   time %ds", v1);
    sprintf((char *)lcd_output[2], "   nonce=%d", gValid_Nonce_Num[v2]);
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    set_fan_speed(0xAu);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  }
}

//----- (00010E04) --------------------------------------------------------
void *__fastcall single_BM1385_send_func(void *arg)
{
  int v1; // r8
  unsigned int OpenCoreNum1; // r0
  unsigned int OpenCoreNum2; // r1
  unsigned int OpenCoreNum3; // r2
  unsigned int OpenCoreNum4; // r3
  int v6; // r5
  int v7; // r4
  bool v8; // zf
  unsigned int pattern_number; // r2
  int v10; // r6
  int v11; // r6
  unsigned int v12; // r7
  unsigned __int8 *v13; // r3
  int v14; // r2
  unsigned __int8 v15; // t1
  int v16; // r1
  int v17; // r3
  unsigned __int8 *v18; // r2
  unsigned __int8 v19; // t1
  work *v20; // r0
  work (*v21)[128]; // r11
  unsigned int v22; // r3
  unsigned int timeout; // r0
  unsigned int v24; // r3
  pthread_mutex_t *mutex; // [sp+Ch] [bp-84h]
  work *work; // [sp+10h] [bp-80h]
  unsigned int test_core_index; // [sp+20h] [bp-70h]
  unsigned __int8 *v29; // [sp+24h] [bp-6Ch] BYREF
  unsigned __int8 data_fil[64]; // [sp+28h] [bp-68h] BYREF

  v1 = *(unsigned __int8 *)arg;
  memset(data_fil, 0, sizeof(data_fil));
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  v6 = 32;
  data_fil[0] = -1;
  v7 = 0;
  do
  {
    v8 = (OpenCoreNum1 & 1) == 0;
    OpenCoreNum1 >>= 1;
    if ( !v8 )
      ++v7;
    v8 = (OpenCoreNum2 & 1) == 0;
    OpenCoreNum2 >>= 1;
    if ( !v8 )
      ++v7;
    v8 = (OpenCoreNum3 & 1) == 0;
    OpenCoreNum3 >>= 1;
    if ( !v8 )
      ++v7;
    v8 = (OpenCoreNum4 & 1) == 0;
    OpenCoreNum4 >>= 1;
    if ( !v8 )
      ++v7;
    --v6;
  }
  while ( v6 );
  printf("%s: There are %d cores should be test\n\n", (const char *)_FUNCTION___8222, v7);
  if ( v7 )
  {
    pattern_number = Conf.pattern_number;
    v29 = &cgpu.workdataFilePrefix[60];
    mutex = &HW_check_mutex[v1];
    test_core_index = 0;
    do
    {
      v10 = *((_DWORD *)v29 + 1);
      v29 += 4;
      if ( pattern_number )
      {
        v11 = v10 + 19;
        v12 = 0;
        do
        {
          work = (work *)(v11 - 19);
          memset(data_fil, 0, sizeof(data_fil));
          v13 = (unsigned __int8 *)&v29 + 3;
          v14 = v11;
          do
          {
            v15 = *(_BYTE *)++v14;
            *++v13 = v15;
          }
          while ( v13 != &data_fil[31] );
          v16 = *(_DWORD *)(v11 - 15);
          v17 = v11 - 12;
          v18 = &data_fil[51];
          data_fil[51] = v12;
          data_fil[47] = v16;
          data_fil[44] = HIBYTE(v16);
          data_fil[45] = BYTE2(v16);
          data_fil[46] = BYTE1(v16);
          do
          {
            v19 = *(_BYTE *)++v17;
            *++v18 = v19;
          }
          while ( v17 != v11 );
          uart_send(v1, data_fil, 0x40u);
          pthread_mutex_lock(mutex);
          v20 = &gWorks_For_Hw_Check[v1][127];
          do
          {
            v21 = (work (*)[128])&v20[-1];
            memcpy(v20, &v20[-1], sizeof(work));
            v20 = (work *)v21;
          }
          while ( gWorks_For_Hw_Check[v1] != (work *)v21 );
          ++v12;
          v11 += 68;
          v22 = (unsigned __int8)(gWork_Num_For_Hw_Check + 1);
          if ( v22 > 0x7E )
            LOBYTE(v22) = 127;
          gWork_Num_For_Hw_Check = v22;
          memcpy(gWorks_For_Hw_Check[v1], work, 0x44u);
          pthread_mutex_unlock(mutex);
          timeout = Conf.timeout;
          ++gSend_Work_Num[v1];
          usleep(timeout);
          pattern_number = Conf.pattern_number;
        }
        while ( Conf.pattern_number > v12 );
      }
      v8 = v7 == ++test_core_index;
    }
    while ( !v8 );
    v24 = gSend_Work_Num[v1];
    if ( pattern_number * v7 > v24 )
    {
      do
      {
        printf(
          "\n\n---%s: Chain%d send work num : %d, less than %d\n",
          (const char *)_FUNCTION___8222,
          v1,
          v24,
          50 * pattern_number);
        pattern_number = Conf.pattern_number;
        v24 = gSend_Work_Num[v1];
      }
      while ( v24 < Conf.pattern_number * v7 );
    }
  }
  else
  {
    v24 = gSend_Work_Num[v1];
  }
  printf("\n\n---%s: Chain%d send work num : %d\n", (const char *)_FUNCTION___8222, v1, v24);
  puts("\nsend test pattern done");
  system("date");
  putchar(10);
  usleep(0xC350u);
  start_receive = 0;
  puts("to stop receive");
  return 0;
}

//----- (00011070) --------------------------------------------------------
void __fastcall get_BM1385_plldata(unsigned int freq, uint32_t *reg_data, uint16_t *reg_data2, uint32_t *vil_data)
{
  unsigned int v8; // r2
  int v9; // r4
  int v10; // r5
  size_t v11; // r0
  freq_pll *v12; // r5
  unsigned int fildiv2; // r3
  uint32_t vilpll; // r4
  unsigned __int8 freq_str[10]; // [sp+Ch] [bp-94h] BYREF
  unsigned __int8 plldivider1[32]; // [sp+18h] [bp-88h] BYREF
  unsigned __int8 plldivider2[32]; // [sp+38h] [bp-68h] BYREF
  unsigned __int8 vildivider[32]; // [sp+58h] [bp-48h] BYREF

  memset(plldivider1, 0, sizeof(plldivider1));
  memset(plldivider2, 0, sizeof(plldivider2));
  memset(vildivider, 0, sizeof(vildivider));
  v8 = freq;
  v9 = 0;
  sprintf((char *)freq_str, "%d", v8);
  do
  {
    v10 = v9;
    v11 = strlen((const char *)freq_pll_1385[v9].freq);
    if ( !memcmp(freq_pll_1385[v9].freq, freq_str, v11) )
    {
      printf(
        "%s: i = %d, sizeof(freq_pll_1385)/sizeof(freq_pll_1385[0]) = %d\n",
        (const char *)_FUNCTION___7992,
        v9,
        124);
      goto LABEL_5;
    }
    ++v9;
  }
  while ( v9 != 124 );
  v10 = 4;
  printf("%s: i = %d, sizeof(freq_pll_1385)/sizeof(freq_pll_1385[0]) = %d\n", (const char *)_FUNCTION___7992, 124, 124);
  printf("%s: Freq set Err!!!!\n", (const char *)_FUNCTION___7992);
  printf("%s: Using 200M\n", (const char *)_FUNCTION___7992);
LABEL_5:
  v12 = &freq_pll_1385[v10];
  sprintf((char *)plldivider1, "%08x", v12->fildiv1);
  sprintf((char *)plldivider2, "%04x", v12->fildiv2);
  sprintf((char *)vildivider, "%04x", v12->vilpll);
  printf(
    "%s: Freq %s, PLL1 %s, PLL2 %s, vilpll %s\n",
    (const char *)_FUNCTION___7992,
    (const char *)freq_str,
    (const char *)plldivider1,
    (const char *)plldivider2,
    (const char *)vildivider);
  *reg_data = v12->fildiv1;
  fildiv2 = v12->fildiv2;
  vilpll = v12->vilpll;
  *reg_data2 = fildiv2;
  *vil_data = vilpll;
  printf(
    "%s: PLL1 %#x, PLL2 %#x, vilpll %#x\n",
    (const char *)_FUNCTION___7992,
    *reg_data,
    (unsigned __int16)fildiv2,
    vilpll);
}

//----- (0001119C) --------------------------------------------------------
void __fastcall read_BM1385_asic_register(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 reg_addr,
        bool mode)
{
  int v5; // r0
  unsigned __int8 ptr[4]; // [sp+Ch] [bp-14h] BYREF

  ptr[3] = 0;
  ptr[1] = chip_addr;
  ptr[2] = reg_addr;
  ptr[0] = 4;
  if ( mode )
    ptr[0] = -124;
  v5 = CRC5(ptr, 0x1Bu);
  ptr[3] = v5;
  printf(
    "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
    (const char *)_FUNCTION___8000,
    ptr[0],
    ptr[1],
    ptr[2],
    v5);
  uart_send(which_chain, ptr, 4u);
}

//----- (000111FC) --------------------------------------------------------
void __fastcall set_BM1385_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode)
{
  _BOOL4 v7; // r7
  unsigned __int8 v8; // r0
  unsigned __int8 v9; // r7
  unsigned __int8 v10; // r0
  uint16_t reg_data_pll2; // [sp+6h] [bp-32h] BYREF
  unsigned __int8 buf[4]; // [sp+8h] [bp-30h] BYREF
  unsigned int reg_data_pll; // [sp+Ch] [bp-2Ch] BYREF
  unsigned int reg_data_vil; // [sp+10h] [bp-28h] BYREF
  unsigned int cmd_buf[3]; // [sp+14h] [bp-24h] BYREF

  v7 = mode;
  *(_DWORD *)buf = 0;
  reg_data_pll = 0;
  reg_data_vil = 0;
  reg_data_pll2 = 0;
  printf("\n--- %s\n", (const char *)_FUNCTION___8012);
  get_BM1385_plldata(freq, &reg_data_pll, &reg_data_pll2, &reg_data_vil);
  buf[0] = 7;
  buf[3] = reg_data_pll;
  buf[1] = BYTE2(reg_data_pll);
  buf[2] = BYTE1(reg_data_pll);
  v8 = CRC5(buf, 0x1Bu);
  buf[3] |= v8;
  uart_send(which_chain, buf, 4u);
  usleep(0xBB8u);
  if ( v7 )
    v9 = -126;
  else
    v9 = 2;
  buf[3] = reg_data_pll2;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  buf[1] = chip_addr;
  buf[2] = HIBYTE(reg_data_pll2);
  buf[0] = v9;
  v10 = CRC5(buf, 0x1Bu);
  buf[3] |= v10;
  uart_send(which_chain, buf, 4u);
  usleep(0x1388u);
}

//----- (000112C0) --------------------------------------------------------
void __fastcall check_BM1385_asic_reg(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 reg,
        bool mode)
{
  int v5; // r8
  int v6; // r7
  int v7; // r6
  int i; // r4
  unsigned int reg_value_num; // r8
  int v10; // r4
  unsigned int v11; // r1
  unsigned int v12; // r3
  reg_buf *v13; // r2
  unsigned int p_rd; // r3
  unsigned int reg_value; // r3
  int v16; // r0
  reg_buf *v17; // r3
  unsigned int v18; // r2
  char *v19; // r1
  unsigned int v20; // r1
  unsigned int v21; // r2
  int v22; // r0
  unsigned int v23; // r1
  unsigned int v24; // r2
  bool v25; // zf
  unsigned int v26; // r1
  int v27; // [sp+8h] [bp-38h]
  int v28; // [sp+Ch] [bp-34h]
  unsigned __int8 reg_buf[5]; // [sp+10h] [bp-30h] BYREF

  v5 = reg;
  v6 = which_chain + 1;
  v7 = which_chain;
  v28 = which_chain + 1;
  v27 = reg;
  memset(reg_buf, 0, sizeof(reg_buf));
  clear_register_value_buf();
  printf("%s: check chain J%d \n", (const char *)_FUNCTION___8023, v6);
  read_BM1385_asic_register(v7, 0, v5, mode);
  if ( !v5 )
    cgpu.chain_asic_num[v7] = 0;
  for ( i = 0; i != 3; printf(
                         "%s: no asic address register come back for %d time.\n",
                         (const char *)_FUNCTION___8023,
                         i) )
  {
LABEL_4:
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
    pthread_mutex_lock(&reg_mutex);
    reg_value_num = reg_value_buf->reg_value_num;
    pthread_mutex_unlock(&reg_mutex);
    if ( reg_value_num )
    {
      v10 = 0;
      while ( 1 )
      {
        pthread_mutex_lock(&reg_mutex);
        v13 = reg_value_buf;
        p_rd = reg_value_buf->p_rd;
        if ( reg_value_buf->reg_buffer[p_rd].chain_number != v7 )
          break;
        memset(reg_buf, 0, sizeof(reg_buf));
        reg_value = reg_value_buf->reg_buffer[reg_value_buf->p_rd].reg_value;
        reg_buf[2] = BYTE1(reg_value);
        reg_buf[3] = reg_value;
        reg_buf[1] = BYTE2(reg_value);
        reg_buf[0] = HIBYTE(reg_value);
        v16 = CRC5(reg_buf, 0x23u);
        v17 = reg_value_buf;
        v18 = reg_value_buf->p_rd;
        v19 = (char *)reg_value_buf + 8 * v18;
        if ( (unsigned __int8)v19[22] == v16 )
        {
          if ( v27 )
          {
            if ( v27 == 12 )
            {
              printf("%s: the asic freq is 0x%08x\n", (const char *)_FUNCTION___8023, *((_DWORD *)v19 + 4));
              v17 = reg_value_buf;
              v18 = reg_value_buf->p_rd;
            }
          }
          else
          {
            ++cgpu.chain_asic_num[v7];
            v18 = v17->p_rd;
          }
          v23 = v17->reg_value_num;
          v24 = v18 + 1;
          v25 = v24 == 512;
          v17->p_rd = v24;
          if ( v24 == 512 )
            v24 = 0;
          v26 = v23 - 1;
          if ( v25 )
            v17->p_rd = v24;
          v17->reg_value_num = v26;
          pthread_mutex_unlock(&reg_mutex);
LABEL_9:
          if ( reg_value_num == ++v10 )
            goto LABEL_15;
        }
        else
        {
          v20 = reg_value_buf->reg_value_num;
          v21 = v18 + 1;
          reg_value_buf->p_rd = v21;
          if ( v21 == 512 )
            v17->p_rd = 0;
          ++v10;
          v17->reg_value_num = v20 - 1;
          v22 = CRC5(reg_buf, 0x23u);
          printf(
            "%s: crc is 0x%x, but it should be 0x%x\n",
            (const char *)_FUNCTION___8023,
            v22,
            reg_value_buf->reg_buffer[reg_value_buf->p_rd].crc);
          pthread_mutex_unlock(&reg_mutex);
          if ( reg_value_num == v10 )
          {
LABEL_15:
            i = 0;
            goto LABEL_4;
          }
        }
      }
      v11 = reg_value_buf->reg_value_num;
      v12 = p_rd + 1;
      reg_value_buf->p_rd = v12;
      v13->reg_value_num = v11 - 1;
      if ( v12 == 512 )
      {
        v12 = 0;
        v13->p_rd = 0;
      }
      printf(
        "%s: the return data is from chain%d, but it should be from chain%d\n",
        _FUNCTION___8023,
        v13->reg_buffer[v12].chain_number,
        v7);
      pthread_mutex_unlock(&reg_mutex);
      goto LABEL_9;
    }
    ++i;
    usleep((__useconds_t)&loc_186A0);
  }
  if ( !v27 )
  {
    if ( cgpu.chain_asic_num[v7] > cgpu.max_asic_num_in_one_chain )
      cgpu.max_asic_num_in_one_chain = cgpu.chain_asic_num[v7];
    printf("%s: chain J%d has %d ASIC\n", _FUNCTION___8023, v28);
  }
  clear_register_value_buf();
}

//----- (000114EC) --------------------------------------------------------
void __fastcall BM1385_chain_inactive(unsigned __int8 which_chain)
{
  unsigned __int8 buf[4]; // [sp+4h] [bp-14h] BYREF

  *(_DWORD *)buf = 133;
  buf[3] = CRC5(buf, 0x1Bu);
  uart_send(which_chain, buf, 4u);
  usleep(0x1388u);
}

//----- (00011520) --------------------------------------------------------
void __fastcall BM1385_set_address(unsigned __int8 which_chain, unsigned __int8 address)
{
  unsigned __int8 ptr[4]; // [sp+4h] [bp-Ch] BYREF

  *(_WORD *)&ptr[2] = 0;
  ptr[1] = address;
  ptr[0] = 1;
  ptr[3] = CRC5(ptr, 0x1Bu);
  uart_send(which_chain, ptr, 4u);
}

//----- (00011550) --------------------------------------------------------
void __fastcall BM1385_set_baud(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 baud,
        bool mode)
{
  unsigned __int8 v5; // r2
  unsigned __int8 v6; // r3
  unsigned __int8 ptr[4]; // [sp+4h] [bp-Ch] BYREF

  v5 = baud & 0x1F;
  *(_DWORD *)ptr = 0;
  if ( mode )
    v6 = -122;
  else
    v6 = 6;
  ptr[1] = chip_addr;
  ptr[2] = v5;
  ptr[0] = v6;
  ptr[3] = CRC5(ptr, 0x1Bu);
  uart_send(which_chain, ptr, 4u);
}

//----- (00011590) --------------------------------------------------------
void __fastcall BM1385_set_gateblk(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode)
{
  unsigned __int8 v4; // r2
  unsigned __int8 v5; // r0
  unsigned __int8 gateblk[4]; // [sp+4h] [bp-14h] BYREF

  if ( mode )
    v4 = -122;
  else
    v4 = 6;
  *(_DWORD *)gateblk = v4;
  v5 = CRC5(gateblk, 0x1Bu);
  gateblk[3] |= v5 & 0x1F;
  uart_send(which_chain, gateblk, 4u);
  usleep(0x2710u);
}

//----- (000115E8) --------------------------------------------------------
void reset_single_BM1385_global_arg()
{
  int v0; // r5
  unsigned int OpenCoreNum1; // r8
  unsigned int OpenCoreNum2; // r7
  unsigned int OpenCoreNum3; // r6
  unsigned int OpenCoreNum4; // r4
  int v5; // r12
  bool v6; // zf
  unsigned int pattern_number; // r7
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *p_anon_0; // r11
  unsigned int *v9; // r10
  unsigned int *v10; // r9
  unsigned int *v11; // r8
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v12; // r4
  cgpu_info *v13; // r0
  FILE *v14; // t1
  char *v15; // r3
  char *v16; // r2
  int v17; // [sp+0h] [bp-30h]
  unsigned int v18; // [sp+4h] [bp-2Ch]

  v0 = 32;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  reset_global_arg();
  printf("\n--- %s\n", (const char *)_FUNCTION___8069);
  v5 = 0;
  do
  {
    v6 = (OpenCoreNum1 & 1) == 0;
    OpenCoreNum1 >>= 1;
    if ( !v6 )
      ++v5;
    v6 = (OpenCoreNum2 & 1) == 0;
    OpenCoreNum2 >>= 1;
    if ( !v6 )
      ++v5;
    v6 = (OpenCoreNum3 & 1) == 0;
    OpenCoreNum3 >>= 1;
    if ( !v6 )
      ++v5;
    v6 = (OpenCoreNum4 & 1) == 0;
    OpenCoreNum4 >>= 1;
    if ( !v6 )
      ++v5;
    --v0;
  }
  while ( v0 );
  pattern_number = Conf.pattern_number;
  p_anon_0 = &reg_mutex.__data._anon_0;
  v9 = gRepeated_Nonce_Id;
  v17 = 3347151;
  v10 = gValid_Nonce_Num;
  v11 = gSend_Work_Num;
  v18 = 68 * Conf.pattern_number;
  do
  {
    *v9++ = 0;
    *v10++ = 0;
    *(_BYTE *)(v17 + 1) = 0;
    *v11++ = 0;
    ++v17;
    if ( v5 )
    {
      v12 = p_anon_0;
      v13 = (cgpu_info *)&cgpu.workdataFilePrefix[60];
      do
      {
        v14 = v13->fps[1];
        v13 = (cgpu_info *)((char *)v13 + 4);
        v15 = (char *)v14 + v0;
        v16 = (char *)v14 + v0 + v18;
        if ( pattern_number )
        {
          do
          {
            *((_DWORD *)v15 + 13) = 0;
            v15 += 68;
          }
          while ( v15 != v16 );
        }
        v12[1].__spins = 0;
        ++v12;
      }
      while ( v13 != (cgpu_info *)&cgpu.workdataFilePrefix[4 * v5 + 60] );
    }
    v0 += 4;
    p_anon_0 += 0x20000;
  }
  while ( v0 != 16 );
}

//----- (000116F8) --------------------------------------------------------
void single_BM1385_calculate_timeout_and_baud()
{
  _DWORD *v0; // r4
  unsigned int v1; // r6
  unsigned int v2; // r5
  unsigned int v3; // r3
  unsigned int v4; // r0

  LOWORD(v0) = (unsigned __int16)&Conf;
  printf("\n--- %s\n", (const char *)_FUNCTION___8088);
  v1 = calculate_core_number(0x32u);
  switch ( pattern_test_time )
  {
    case 0u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[18];
      break;
    case 1u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[19];
      break;
    case 2u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[20];
      break;
    case 3u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[21];
      break;
    case 4u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[22];
      break;
    case 5u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[23];
      break;
    case 6u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[24];
      break;
    case 7u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[25];
      break;
    case 8u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[26];
      break;
    default:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = 0;
      printf("%s: pattern_test_time = %d, error!!! \n", (const char *)_FUNCTION___8088, pattern_test_time);
      break;
  }
  v3 = 95 * (gChain_Asic_Interval * (0x1000000 / v1) / v2) / 0x64;
  v0[69] = v3;
  v4 = (unsigned int)&cgpu.subid[75558] / ((((unsigned int)&gAsic_Core_Nonce_Num[2][102][9] + 2) / v3) << 9) - 1;
  v0[17] = v2;
  if ( v4 <= 0x1A )
    v0[67] = v4;
  else
    v3 = 26;
  if ( v4 > 0x1A )
    v0[67] = v3;
  v0[69] = 10000;
}

//----- (00011804) --------------------------------------------------------
void __fastcall single_BM1385_set_address(unsigned __int8 which_chain)
{
  unsigned int v2; // r4
  int v3; // r5

  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8105, which_chain);
  BM1385_chain_inactive(which_chain);
  if ( 0x100 / gChain_Asic_Interval )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      ++v2;
      BM1385_set_address(which_chain, v3);
      v3 += gChain_Asic_Interval;
      usleep(0x1388u);
    }
    while ( 0x100 / gChain_Asic_Interval > v2 );
  }
}

//----- (00011860) --------------------------------------------------------
void __fastcall single_BM1385_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", (const char *)_FUNCTION___8113, which_chain, baud);
  BM1385_set_baud(which_chain, 0, baud, 1);
  usleep(0xC350u);
  set_fpga_baud(baud);
}

//----- (0001189C) --------------------------------------------------------
void __fastcall single_BM1385_open_core(unsigned __int8 which_chain)
{
  int v1; // r7
  unsigned int OpenCoreNum1; // r8
  unsigned int OpenCoreNum2; // r9
  int v4; // r5
  unsigned int v5; // r4
  bool v6; // zf
  unsigned __int8 data[64]; // [sp+0h] [bp-68h] BYREF

  v1 = which_chain;
  memset(data, 0, sizeof(data));
  data[0] = -1;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  v4 = 50;
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8121, v1);
  gIsOpenCoreEnd = 0;
  memset(data, 0, sizeof(data));
  BM1385_set_gateblk(v1, 0, 1);
  do
  {
    uart_send(v1, data, 0x40u);
    usleep(Conf.OpenCoreGap);
    --v4;
  }
  while ( v4 );
  v5 = 0;
  memset(data, 0, sizeof(data));
  BM1385_set_gateblk(v1, 0, 1);
  do
  {
    if ( v5 <= 0x1F )
    {
      v6 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( v6 )
        goto LABEL_6;
LABEL_5:
      data[52] = -1;
      goto LABEL_6;
    }
    v6 = (OpenCoreNum2 & 1) == 0;
    OpenCoreNum2 >>= 1;
    if ( !v6 )
      goto LABEL_5;
LABEL_6:
    ++v5;
    uart_send(v1, data, 0x40u);
    usleep(Conf.OpenCoreGap);
  }
  while ( v5 != 50 );
  gIsOpenCoreEnd = 1;
}

//----- (00011970) --------------------------------------------------------
unsigned int __fastcall single_BM1385_get_result(unsigned __int8 which_chain)
{
  int v1; // r4
  configuration *v2; // r8
  unsigned int OpenCoreNum1; // r7
  unsigned int OpenCoreNum2; // r10
  unsigned int (*v5)[1024]; // r6
  unsigned int v6; // r11
  unsigned int *v7; // r4
  int v8; // r1
  unsigned int v9; // t1
  int v10; // r9
  unsigned int v11; // r4
  unsigned int v12; // r5
  work *v13; // r5
  char *v14; // r11
  configuration *v15; // r3
  unsigned int v16; // r5
  unsigned int v17; // r8
  configuration *v18; // r4
  int v19; // r3
  configuration *v20; // r3
  unsigned int v22; // r5
  char *v23; // r11
  int v24; // r3
  int v25; // [sp+Ch] [bp-34h]
  int v26; // [sp+10h] [bp-30h]
  work *works; // [sp+14h] [bp-2Ch]

  v1 = which_chain;
  v26 = which_chain;
  v2 = &Conf;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  v5 = gAsic_Core_Nonce_Num[v1];
  printf("every CORE require nonce number: %u\n\n", Conf.pattern_number);
  v6 = 0;
  printf("Open core number : Conf.OpenCoreNum1 = %u = 0x%08x\n", Conf.OpenCoreNum1, Conf.OpenCoreNum1);
  v7 = &(*v5)[-1];
  printf("Open core number : Conf.OpenCoreNum2 = %u = 0x%08x\n", Conf.OpenCoreNum2, Conf.OpenCoreNum2);
  printf("Open core number : Conf.OpenCoreNum3 = %u = 0x%08x\n", Conf.OpenCoreNum3, Conf.OpenCoreNum3);
  printf("Open core number : Conf.OpenCoreNum4 = %u = 0x%08x\n\n", Conf.OpenCoreNum4, Conf.OpenCoreNum4);
  do
  {
    if ( v6 == 10 * (v6 / 0xA) )
      putchar(10);
    v8 = v6;
    v9 = v7[1];
    ++v7;
    ++v6;
    printf("core[%02d]=%02d\t", v8, v9);
  }
  while ( v6 != 50 );
  v10 = 0;
  v11 = 0;
  v12 = 1;
  v25 = 4 * v26;
  puts("\n\n");
  do
  {
    if ( v11 <= 0x1F )
    {
      if ( (OpenCoreNum1 & 1) != 0 )
      {
        if ( (*v5)[0] < v2->pattern_number )
        {
          v13 = cgpu.works[v10];
          printf("core[%02d] = %d,      lost these nonce : ", v11);
          if ( v2->pattern_number )
          {
            v14 = (char *)v13 + v25;
            v15 = v2;
            v16 = 0;
            v17 = v11;
            v18 = v15;
            do
            {
              while ( 1 )
              {
                v19 = *((_DWORD *)v14 + 13);
                v14 += 68;
                if ( !v19 )
                  break;
                if ( v18->pattern_number <= ++v16 )
                  goto LABEL_21;
              }
              printf("%d  ", v16++);
            }
            while ( v18->pattern_number > v16 );
LABEL_21:
            v20 = v18;
            v11 = v17;
            v2 = v20;
          }
          v12 = 0;
          putchar(10);
        }
        OpenCoreNum1 >>= 1;
        ++v10;
      }
      else
      {
        OpenCoreNum1 >>= 1;
      }
    }
    else if ( (OpenCoreNum2 & 1) != 0 )
    {
      if ( (*v5)[0] < v2->pattern_number )
      {
        works = cgpu.works[v10];
        printf("core[%02d] = %d,      lost these nonce : ", v11);
        if ( v2->pattern_number )
        {
          v22 = 0;
          v23 = (char *)works + v25;
          do
          {
            v24 = *((_DWORD *)v23 + 13);
            v23 += 68;
            if ( !v24 )
              printf("%d  ", v22);
            ++v22;
          }
          while ( v2->pattern_number > v22 );
        }
        v12 = 0;
        putchar(10);
      }
      OpenCoreNum2 >>= 1;
      ++v10;
    }
    else
    {
      OpenCoreNum2 >>= 1;
    }
    ++v11;
    v5 = (unsigned int (*)[1024])((char *)v5 + 4);
  }
  while ( v11 != 50 );
  puts("\n------------------------------------------------------------------------------------------------------\n");
  printf("Chain%d total valid nonce number: %d\n\n", v26, gValid_Nonce_Num[v26]);
  if ( v12 )
    puts("Pattern OK\n");
  else
    puts("Pattern NG\n");
  printf("HW number = %d\n\n", gHw_Nonce_Num[v26]);
  return v12;
}

//----- (00011BD4) --------------------------------------------------------
void __fastcall single_BM1385_print_lcd(unsigned __int8 which_chain, unsigned int result)
{
  char v2; // r5
  unsigned __int8 *v3; // r1
  unsigned __int8 lcd_display_buf[16]; // [sp+0h] [bp-20h] BYREF

  v2 = result;
  qmemcpy(lcd_display_buf, "      HW        ", sizeof(lcd_display_buf));
  display_level_result_on_lcd();
  if ( (v2 & 1) != 0 )
    LOWORD(v3) = -25244;
  else
    LOWORD(v3) = -25224;
  HIWORD(v3) = 2;
  write_lcd_no_memset(2u, v3, 0x10u);
  sprintf((char *)&lcd_display_buf[10], "%d", gHw_Nonce_Num[gChain]);
  write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
}

//----- (00011C48) --------------------------------------------------------
int __fastcall BM1385_is_nonce_or_reg_value(unsigned __int8 data)
{
  return data >> 7;
}

//----- (00011C4C) --------------------------------------------------------
int __fastcall single_BM1385_check_nonce(unsigned __int8 which_chain, unsigned __int8 *nonce_data)
{
  int v3; // r6
  unsigned int v4; // r0
  int v5; // r2
  unsigned int v6; // r5
  int v7; // r4
  unsigned int v8; // r2
  unsigned int v9; // r7
  unsigned int OpenCoreNum2; // r0
  unsigned int OpenCoreNum1; // r1
  unsigned int v12; // r3
  unsigned int v13; // r3
  bool v14; // zf
  work *v15; // r7
  int v16; // r7
  work *v17; // r7
  unsigned int v18; // r8
  int v19; // r0
  int v20; // r11
  int result; // r0
  int *v22; // r7
  unsigned int v23; // r5
  unsigned int v24; // r4
  unsigned int v25; // r1

  v3 = which_chain;
  v4 = *nonce_data;
  v5 = nonce_data[3];
  v6 = v5 & 0x3F;
  v7 = (v4 << 24) | (nonce_data[1] << 16) | v5 | (nonce_data[2] << 8);
  v8 = v4 / gChain_Asic_Interval;
  if ( v4 / gChain_Asic_Interval )
  {
    printf("%s: received ASIC%02d nonce. error!!!\t", _FUNCTION___8184, v8);
    goto LABEL_31;
  }
  if ( v6 > 0x31 )
  {
    printf("%s: received core%02d nonce. error!!!\t", _FUNCTION___8184, v6);
    goto LABEL_31;
  }
  v9 = nonce_data[4] & 0x7F;
  if ( v9 >= Conf.pattern_number )
  {
    printf("%s: received work_id = %02d nonce. error!!!\t", _FUNCTION___8184, v9);
LABEL_31:
    printf(
      ",received data is : 0x%02x%02x%02x%02x%02x\n",
      *nonce_data,
      nonce_data[1],
      nonce_data[2],
      nonce_data[3],
      nonce_data[4]);
    return -1;
  }
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  if ( v6 > 0x1F )
  {
    v13 = 32;
    do
    {
      v14 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v14 )
        ++v8;
      --v13;
    }
    while ( v13 );
    do
    {
      ++v13;
      if ( (OpenCoreNum2 & 1) != 0 )
        ++v8;
      OpenCoreNum2 >>= 1;
    }
    while ( v13 < v6 - 31 );
  }
  else
  {
    v12 = 0;
    do
    {
      ++v12;
      if ( (OpenCoreNum1 & 1) != 0 )
        ++v8;
      OpenCoreNum1 >>= 1;
    }
    while ( v12 < v6 + 1 );
  }
  v15 = &cgpu.works[v8 - 1][v9];
  if ( v7 == v15->nonce )
  {
    v22 = &v15->id + v3;
    result = v22[13];
    if ( result )
    {
      v22[13] = result + 1;
      result = 0;
      ++gRepeated_Nonce_Id[v3];
    }
    else
    {
      v23 = v6 + (v3 << 17);
      v24 = gValid_Nonce_Num[v3];
      v22[13] = 1;
      v25 = gAsic_Core_Nonce_Num[0][0][v23];
      gValid_Nonce_Num[v3] = v24 + 1;
      gAsic_Core_Nonce_Num[0][0][v23] = v25 + 1;
    }
  }
  else
  {
    pthread_mutex_lock(&HW_check_mutex[v3]);
    v16 = gWork_Num_For_Hw_Check;
    if ( gWork_Num_For_Hw_Check )
    {
      v17 = gWorks_For_Hw_Check[v3];
      v18 = 0;
      do
      {
        ++v18;
        v19 = check_hw(v17++, v7, 0);
        v20 = v19;
        if ( !v19 )
        {
          pthread_mutex_unlock(&HW_check_mutex[v3]);
          return 0;
        }
      }
      while ( gWork_Num_For_Hw_Check > v18 );
      pthread_mutex_unlock(&HW_check_mutex[v3]);
      if ( v20 == 1 )
      {
        ++gHw_Nonce_Num[v3];
        printf(
          "%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n",
          (const char *)_FUNCTION___8184,
          v3,
          0,
          v6,
          v7);
      }
      return 0;
    }
    else
    {
      pthread_mutex_unlock(&HW_check_mutex[v3]);
      return v16;
    }
  }
  return result;
}

//----- (00011E80) --------------------------------------------------------
int __fastcall single_BM1385_check_register_value(unsigned __int8 which_chain, unsigned __int8 *register_data)
{
  reg_buf *v2; // r3
  unsigned int reg_value_num; // r6
  char *v4; // r5
  unsigned int v5; // r2
  unsigned __int8 v6; // r1
  int result; // r0

  v2 = reg_value_buf;
  reg_value_num = reg_value_buf->reg_value_num;
  if ( reg_value_num > 0x1FE )
  {
    printf("%s: reg_value_buf buffer is full!\n", (const char *)_FUNCTION___8201);
    return -1;
  }
  else
  {
    v4 = (char *)reg_value_buf + 8 * reg_value_buf->p_wr;
    v5 = reg_value_buf->p_wr + 1;
    *((_DWORD *)v4 + 4) = _byteswap_ulong(*(_DWORD *)register_data);
    v6 = register_data[4];
    v4[23] = which_chain;
    result = 0;
    v4[22] = v6 & 0x1F;
    v2->reg_value_num = reg_value_num + 1;
    v2->p_wr = v5;
    if ( v5 >= 0x200 )
      v2->p_wr = 0;
  }
  return result;
}

//----- (00011EEC) --------------------------------------------------------
void *__fastcall single_BM1385_receive_func(void *arg)
{
  int v1; // r4
  int v2; // r5
  unsigned int v3; // r6
  unsigned int v4; // r8
  void *result; // r0
  int v6; // r5
  unsigned int v7; // r0
  unsigned __int8 *v9; // r2
  unsigned __int8 *v10; // r3
  unsigned __int8 v11; // t1
  unsigned __int8 *v12; // r5
  unsigned __int8 *v13; // r3
  unsigned __int8 *v14; // r1
  unsigned __int8 v15; // t1
  unsigned int v16; // r5
  char *v17; // r2
  unsigned __int8 *v18; // r3
  char v19; // t1
  unsigned __int8 temp_buf[5]; // [sp+14h] [bp-60Ch] BYREF
  char v21; // [sp+19h] [bp-607h] BYREF
  char v22; // [sp+1Bh] [bp-605h] BYREF
  unsigned __int8 data_buf[500]; // [sp+1Ch] [bp-604h] BYREF
  unsigned __int8 receive_buf[1000]; // [sp+210h] [bp-410h] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  memset(receive_buf, 0, sizeof(receive_buf));
  memset(data_buf, 0, sizeof(data_buf));
  memset(temp_buf, 0, sizeof(temp_buf));
  v3 = 0;
  v4 = 0;
  printf("%s: which_chain = %d, which_i2c = %d\n", (const char *)_FUNCTION___8259, v1, v2);
  clear_uart_rx_fifo(v1);
LABEL_2:
  result = (void *)start_receive;
  if ( !start_receive )
    return result;
  do
  {
    v6 = 5000000;
    usleep(0x1388u);
    while ( 1 )
    {
      memset(receive_buf, 0, sizeof(receive_buf));
      v7 = uart_receive(v1, receive_buf, 0x3E8u);
      if ( v7 && v4 <= 2 )
        break;
      if ( !--v6 )
        goto LABEL_2;
    }
    v9 = &data_buf[v3 - 1];
    v10 = &data_buf[499];
    do
    {
      v11 = *++v10;
      *++v9 = v11;
    }
    while ( v10 != &receive_buf[v7 - 1] );
    v3 += v7;
    if ( v3 <= 4 )
      goto LABEL_2;
    v12 = data_buf;
    do
    {
      v13 = temp_buf;
      v14 = v12;
      memset(temp_buf, 0, sizeof(temp_buf));
      do
      {
        v15 = *v14++;
        *v13++ = v15;
      }
      while ( v13 != (unsigned __int8 *)&v21 );
      if ( (temp_buf[4] & 0x80u) == 0 )
      {
        if ( single_BM1385_check_register_value(v1, temp_buf) != -1 )
          goto LABEL_17;
LABEL_26:
        ++v4;
        goto LABEL_17;
      }
      if ( gStartTest && gIsOpenCoreEnd && single_BM1385_check_nonce(v1, temp_buf) == -1 )
        goto LABEL_26;
LABEL_17:
      v12 += 5;
    }
    while ( &data_buf[5 * (v3 / 5)] != v12 );
    v16 = 5 * (v3 / 5);
    v3 %= 5u;
    if ( !v3 )
      goto LABEL_2;
    v17 = &v22;
    v18 = &data_buf[v16 - 1];
    do
    {
      v19 = *++v18;
      *++v17 = v19;
    }
    while ( v18 != &data_buf[v3 - 1 + v16] );
    result = (void *)start_receive;
  }
  while ( start_receive );
  return result;
}

//----- (0001208C) --------------------------------------------------------
void singleAsicTest_BM1385()
{
  unsigned int axi_fpga; // r0
  unsigned int result; // r0
  unsigned __int8 lcd_display_buf[16]; // [sp+0h] [bp-30h] BYREF

  memset(lcd_display_buf, 32, sizeof(lcd_display_buf));
  printf("\nBegin %s test\n", (const char *)_FUNCTION___8283);
  system("date");
  putchar(10);
  memset(lcd_output, 32, sizeof(lcd_output));
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  axi_fpga = read_axi_fpga(0);
  write_axi_fpga(0, axi_fpga | 0x20000000);
  reset_single_BM1385_global_arg();
  check_chain();
  if ( gChain == 255 )
  {
    write_lcd(1u, "  no hash board ", 0x10u);
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    puts("\nNo hash board, please plug in it");
  }
  else
  {
    pthread_create(&cgpu.show_id, 0, single_BM1385_show_status_func, &chain_info_0[gChain]);
    reset_hash_board();
    start_receive = 1;
    pthread_create(&cgpu.receive_id, 0, single_BM1385_receive_func, &chain_info_0[gChain]);
    puts("\n--- check asic number");
    check_BM1385_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: asicNum = %d\n", cgpu.chain_asic_num[gChain]);
    if ( cgpu.chain_asic_num[gChain] == Conf.AsicNum )
    {
      single_BM1385_calculate_timeout_and_baud();
      set_BM1385_freq(gChain, 0, Conf.Freq, 1);
      single_BM1385_set_address(gChain);
      check_BM1385_asic_reg(gChain, 0, 0, 1);
      single_BM1385_set_baud(gChain, Conf.baud);
      single_BM1385_open_core(gChain);
      puts("\nBegin send test pattern");
      system("date");
      putchar(10);
      gStartTest = 1;
      pthread_create(&cgpu.send_id, 0, single_BM1385_send_func, &chain_info_0[gChain]);
      pthread_join(cgpu.send_id, 0);
      pthread_join(cgpu.receive_id, 0);
      pthread_cancel(cgpu.show_id);
      result = single_BM1385_get_result(gChain);
      single_BM1385_print_lcd(gChain, result);
      set_fan_speed(0);
      usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    }
    else
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
      write_lcd(0, "   Only have    ", 0x10u);
      write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
      write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
      printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8283, cgpu.chain_asic_num[gChain]);
      puts("----------------------------\n\n");
    }
  }
}

//----- (00012330) --------------------------------------------------------
unsigned __int8 __fastcall CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  int v2; // r7
  unsigned __int8 v3; // r6
  int v4; // r2
  char v5; // lr
  int v6; // r12
  int v7; // r8
  char v8; // r9
  unsigned int v9; // r5
  int v10; // r11
  unsigned int v11; // r3
  int v12; // r3
  int v13; // r4
  unsigned __int8 result; // r0

  if ( !len )
  {
    v12 = 1;
    result = 16;
    v13 = 1;
    v2 = 1;
LABEL_22:
    result |= 8u;
    goto LABEL_14;
  }
  v2 = 1;
  v3 = 0;
  LOBYTE(v4) = 0;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  v8 = 1;
  v9 = 128;
  while ( 1 )
  {
    v4 = (unsigned __int8)(v4 + 1);
    ++v3;
    v10 = v6;
    v11 = *ptr & v9;
    v9 >>= 1;
    if ( v11 )
      LOBYTE(v12) = v8 ^ 1;
    else
      LOBYTE(v12) = v8;
    v12 = (unsigned __int8)v12;
    if ( v4 == 8 )
    {
      ++ptr;
      LOBYTE(v4) = 0;
      v9 = 128;
    }
    v13 = (unsigned __int8)(v12 ^ v5);
    v8 = v7;
    v5 = v2;
    if ( len <= (unsigned int)v3 )
      break;
    v2 = (unsigned __int8)v12;
    v6 = v13;
    v7 = v10;
  }
  if ( v7 )
    result = 16;
  else
    result = 0;
  if ( v6 )
    goto LABEL_22;
LABEL_14:
  if ( v13 )
    result |= 4u;
  if ( v2 )
    result |= 2u;
  if ( v12 )
    result |= 1u;
  return result;
}

//----- (000123BC) --------------------------------------------------------
uint16_t __fastcall CRC16(const uint8_t *p_data, uint16_t w_len)
{
  int v2; // r3
  const uint8_t *v3; // r5
  const uint8_t *v4; // r2
  int v5; // r4
  int v6; // t1
  const uint8_t *v7; // r0

  if ( !w_len )
    return -1;
  v2 = 255;
  v3 = &p_data[(unsigned __int16)(w_len - 1)];
  v4 = p_data - 1;
  v5 = 255;
  do
  {
    v6 = *++v4;
    v7 = &chCRCHTalbe[v6 ^ v2];
    v2 = *v7 ^ v5;
    v5 = v7[256];
  }
  while ( v4 != v3 );
  return v2 | ((_WORD)v5 << 8);
}

//----- (000123F8) --------------------------------------------------------
void reset_hash_board()
{
  write_axi_fpga(0xDu, 0xFFFFu);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  write_axi_fpga(0xDu, 0);
  j_usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
}

//----- (00012428) --------------------------------------------------------
void *__fastcall single_BM1391_send_func(void *arg)
{
  int v1; // r7
  unsigned int OpenCoreNum1; // r5
  unsigned int OpenCoreNum2; // r6
  unsigned int OpenCoreNum5; // r9
  unsigned int OpenCoreNum6; // r10
  unsigned int OpenCoreNum7; // r11
  unsigned int v7; // r3
  unsigned int axi_fpga; // r0
  unsigned int v9; // r1
  int v10; // r4
  unsigned int v11; // r0
  unsigned int v12; // r2
  bool v13; // zf
  unsigned int v14; // r5
  unsigned int pattern_number; // r3
  unsigned int v16; // r5
  char *v17; // r6
  char *v18; // r3
  char *v19; // r2
  char *v20; // r1
  char v21; // t1
  vil_work_1391 *v22; // r3
  unsigned __int8 v23; // t1
  vil_work_1391 *p_work_vil_1391; // r3
  vil_work_1391 *v25; // r12
  unsigned int *v26; // r9
  int v27; // r1
  unsigned int *v28; // r12
  int v29; // r1
  work *v30; // r0
  work (*v31)[128]; // r9
  unsigned int v32; // r3
  unsigned int v33; // r2
  unsigned int v34; // r3
  unsigned int v35; // r5
  unsigned int v36; // r8
  unsigned int v37; // r6
  unsigned int OpenCoreNum3; // [sp+Ch] [bp-BCh]
  unsigned int OpenCoreNum4; // [sp+10h] [bp-B8h]
  pthread_mutex_t *OpenCoreNum4a; // [sp+10h] [bp-B8h]
  unsigned int OpenCoreNum8a; // [sp+14h] [bp-B4h]
  unsigned int OpenCoreNum8; // [sp+14h] [bp-B4h]
  unsigned int test_core_number; // [sp+2Ch] [bp-9Ch]
  unsigned int test_core_index; // [sp+30h] [bp-98h]
  unsigned __int8 *v46; // [sp+34h] [bp-94h]
  vil_work_1391 work_vil_1391; // [sp+38h] [bp-90h] BYREF
  unsigned int buf_vil[13]; // [sp+6Ch] [bp-5Ch] BYREF

  v1 = *(unsigned __int8 *)arg;
  memset(buf_vil, 0, sizeof(buf_vil));
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  v7 = Conf.OpenCoreNum8;
  if ( !gBegin_Get_Nonce )
  {
    OpenCoreNum8a = Conf.OpenCoreNum8;
    axi_fpga = read_axi_fpga(7u);
    write_axi_fpga(7u, axi_fpga | 0x10000);
    v7 = OpenCoreNum8a;
    gBegin_Get_Nonce = 1;
  }
  v9 = OpenCoreNum3;
  v10 = 32;
  v11 = OpenCoreNum4;
  v12 = 0;
  do
  {
    v13 = (OpenCoreNum1 & 1) == 0;
    OpenCoreNum1 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum2 & 1) == 0;
    OpenCoreNum2 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (v9 & 1) == 0;
    v9 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (v11 & 1) == 0;
    v11 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum5 & 1) == 0;
    OpenCoreNum5 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum6 & 1) == 0;
    OpenCoreNum6 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum7 & 1) == 0;
    OpenCoreNum7 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (v7 & 1) == 0;
    v7 >>= 1;
    if ( !v13 )
      ++v12;
    --v10;
  }
  while ( v10 );
  v14 = v12;
  test_core_number = v12;
  printf("%s: There are %d cores should be test\n", (const char *)_FUNCTION___8697, v12);
  if ( v14 )
  {
    OpenCoreNum4a = &HW_check_mutex[v1];
    pattern_number = Conf.pattern_number;
    v46 = &cgpu.workdataFilePrefix[60];
    test_core_index = 0;
    do
    {
      v16 = 0;
      OpenCoreNum8 = *((_DWORD *)v46 + 1);
      v46 += 4;
      if ( pattern_number )
      {
        do
        {
          if ( gReadingTemp )
            usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
          if ( ((1 << gChain) & read_axi_fpga(3u)) != 0 )
          {
            v17 = (char *)(OpenCoreNum8 + 68 * v16);
            memset(buf_vil, 0, sizeof(buf_vil));
            memset(&work_vil_1391, 0, sizeof(work_vil_1391));
            v18 = v17 + 7;
            v19 = v17 + 19;
            v20 = (char *)&work_vil_1391.work_count + 3;
            work_vil_1391.work_type = 1;
            work_vil_1391.chain_id = v1 | 0x80;
            work_vil_1391.work_count = v16;
            do
            {
              v21 = *++v18;
              *++v20 = v21;
            }
            while ( v19 != v18 );
            v22 = (vil_work_1391 *)&work_vil_1391.data[11];
            do
            {
              v23 = *++v19;
              v22->chain_id = v23;
              v22 = (vil_work_1391 *)((char *)v22 + 1);
            }
            while ( v22 != (vil_work_1391 *)&work_vil_1391.midstate[31] );
            p_work_vil_1391 = &work_vil_1391;
            v25 = &work_vil_1391;
            buf_vil[0] = ((v1 | 0x80) << 16) | 0x1000000;
            buf_vil[1] = v16;
            v26 = &buf_vil[1];
            do
            {
              v27 = v25->data[1];
              v25 = (vil_work_1391 *)((char *)v25 + 4);
              v26[1] = HIBYTE(v25->work_count) | (v27 << 16) | (LOBYTE(v25->work_count) << 24) | (BYTE2(v25->work_count) << 8);
              ++v26;
            }
            while ( v25 != (vil_work_1391 *)&work_vil_1391.data[4] );
            v28 = &buf_vil[4];
            do
            {
              v29 = p_work_vil_1391->midstate[1];
              p_work_vil_1391 = (vil_work_1391 *)((char *)p_work_vil_1391 + 4);
              v28[1] = p_work_vil_1391->data[11] | (v29 << 16) | (p_work_vil_1391->data[8] << 24) | (p_work_vil_1391->data[10] << 8);
              ++v28;
            }
            while ( p_work_vil_1391 != (vil_work_1391 *)&work_vil_1391.midstate[12] );
            set_TW_write_command(buf_vil);
            pthread_mutex_lock(OpenCoreNum4a);
            v30 = &gWorks_For_Hw_Check[v1][127];
            do
            {
              v31 = (work (*)[128])&v30[-1];
              memcpy(v30, &v30[-1], sizeof(work));
              v30 = (work *)v31;
            }
            while ( gWorks_For_Hw_Check[v1] != (work *)v31 );
            ++v16;
            v32 = (unsigned __int8)(gWork_Num_For_Hw_Check + 1);
            if ( v32 > 0x7E )
              LOBYTE(v32) = 127;
            gWork_Num_For_Hw_Check = v32;
            memcpy(gWorks_For_Hw_Check[v1], v17, 0x44u);
            pthread_mutex_unlock(OpenCoreNum4a);
            ++gSend_Work_Num[v1];
          }
          else
          {
            usleep(0x1388u);
          }
          pattern_number = Conf.pattern_number;
        }
        while ( v16 < Conf.pattern_number );
      }
      v13 = test_core_number == ++test_core_index;
    }
    while ( !v13 );
    v33 = pattern_number * test_core_number;
    v34 = gSend_Work_Num[v1];
    if ( v34 < v33 )
    {
      do
      {
        printf("\n\n---%s: Chain%d send work num : %d, less than %d\n", (const char *)_FUNCTION___8697, v1, v34, v33);
        v34 = gSend_Work_Num[v1];
        v33 = Conf.pattern_number * test_core_number;
      }
      while ( v34 < Conf.pattern_number * test_core_number );
    }
  }
  else
  {
    v34 = gSend_Work_Num[v1];
  }
  printf("\n\n---%s: Chain%d send work num : %d\n", (const char *)_FUNCTION___8697, v1, v34);
  puts("\nsend test pattern done");
  system("date");
  v35 = 1;
  putchar(10);
  v36 = gValid_Nonce_Num[v1];
  while ( v35 <= 2 )
  {
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    while ( 1 )
    {
      v37 = gValid_Nonce_Num[v1];
      ++v35;
      if ( v36 == v37 )
        break;
      usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
      v36 = v37;
      v35 = 0;
    }
  }
  while ( gReadingTemp )
    usleep(0x2710u);
  start_receive = 0;
  puts("to stop receive");
  return 0;
}

//----- (000127F4) --------------------------------------------------------
void __fastcall BM1391_set_config(
        unsigned __int8 which_chain,
        unsigned __int8 asic_addr,
        unsigned __int8 reg_addr,
        unsigned int reg_data,
        bool mode)
{
  int v5; // r5
  int v6; // r0
  unsigned int v7; // r0
  unsigned int v8; // [sp+0h] [bp-30h] BYREF
  unsigned int v9; // [sp+4h] [bp-2Ch]
  char v10; // [sp+8h] [bp-28h]
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-24h] BYREF

  v5 = which_chain;
  v10 = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    LOBYTE(v8) = 81;
  else
    LOBYTE(v8) = 65;
  BYTE2(v8) = asic_addr;
  HIBYTE(v8) = reg_addr;
  BYTE2(v9) = BYTE1(reg_data);
  HIBYTE(v9) = reg_data;
  BYTE1(v8) = 9;
  LOBYTE(v9) = HIBYTE(reg_data);
  BYTE1(v9) = BYTE2(reg_data);
  v6 = CRC5((unsigned __int8 *)&v8, 0x40u);
  v10 = v6;
  cmd_buf[2] = v6 << 24;
  cmd_buf[0] = bswap32(v8);
  cmd_buf[1] = bswap32(v9);
  set_BC_command_buffer(cmd_buf);
  v7 = get_BC_write_command();
  set_BC_write_command(v7 & 0xFFF0FFFF | (v5 << 16) | 0x80800000);
  usleep(0x2710u);
}

//----- (00012888) --------------------------------------------------------
void __fastcall BM1391_get_status(
        unsigned __int8 which_chain,
        unsigned __int8 asic_addr,
        unsigned __int8 reg_addr,
        unsigned __int8 mode)
{
  int v4; // r5
  int v5; // r0
  unsigned int v6; // r0
  unsigned __int8 buf[5]; // [sp+4h] [bp-24h] BYREF
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-1Ch] BYREF

  v4 = which_chain;
  buf[4] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    buf[0] = 82;
  else
    buf[0] = 66;
  buf[3] = reg_addr;
  buf[1] = 5;
  buf[2] = asic_addr;
  v5 = CRC5(buf, 0x20u);
  buf[4] = v5;
  cmd_buf[1] = v5 << 24;
  cmd_buf[0] = bswap32(*(unsigned int *)buf);
  set_BC_command_buffer(cmd_buf);
  v6 = get_BC_write_command();
  set_BC_write_command(v6 & 0xFFF0FFFF | (v4 << 16) | 0x80800000);
}

//----- (000128F4) --------------------------------------------------------
void __fastcall set_BM1391_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode)
{
  double v4; // d6
  int v6; // r2
  unsigned int v7; // r10
  float v8; // s11
  int v9; // r8
  float v10; // s20
  int v11; // r7
  float v12; // s26
  float v13; // s24
  float v14; // s13
  int v15; // r3
  float v16; // s15
  float v17; // s21
  int v18; // r4
  float v19; // s14
  unsigned int v20; // r5
  unsigned __int8 v21; // r3
  int v22; // r4
  unsigned __int8 v23; // r3
  int v24; // r11
  float v25; // s15
  int v26; // r3
  int v27; // r6
  int v28; // r2
  int v29; // r4
  int v30; // r10
  int v31; // r4
  _BOOL4 v32; // r3
  unsigned int reg_data; // [sp+1Ch] [bp-74h]
  unsigned int reg_dataa; // [sp+1Ch] [bp-74h]
  unsigned int reg_datab; // [sp+1Ch] [bp-74h]
  unsigned int v37; // [sp+24h] [bp-6Ch]

  v6 = 0;
  v7 = 0;
  v8 = 0.0;
  v9 = 0;
  v10 = 3200.0;
  v11 = 0;
  v12 = (float)freq;
  v13 = 25.0;
  while ( 1 )
  {
LABEL_2:
    v14 = 12.5;
    if ( v10 >= 3125.0 )
    {
      v15 = 1;
      LODWORD(v4) = 1.0;
    }
    else
    {
      v15 = 2;
    }
    if ( v10 >= 3125.0 )
      v14 = 25.0;
    else
      LODWORD(v4) = 2.0;
    if ( v6 )
    {
      v10 = v8 - v14;
      v13 = 25.0;
    }
    reg_data = (unsigned int)(float)(v10 / v12);
    v16 = (float)(v10 / v12) - (float)reg_data;
    if ( v16 < v13 )
    {
      *(float *)&v4 = v10 * *(float *)&v4;
      v9 = v15;
      v7 = (unsigned __int8)reg_data;
      v13 = (float)(v10 / v12) - (float)reg_data;
      v11 = (unsigned __int8)(unsigned int)(float)(*(float *)&v4 / 25.0);
      if ( v16 < 0.000001 )
        goto LABEL_15;
      v8 = v10;
    }
    v10 = v10 - v14;
    if ( v10 < 2000.0 )
      break;
    v6 = 0;
  }
  v10 = v8;
LABEL_15:
  if ( v7 <= 0x10 )
  {
    v28 = 1;
    v20 = v7;
    v27 = 1;
    v24 = 1;
    v29 = 16;
LABEL_27:
    v30 = v20;
    v31 = v29 | v27 | (v11 << 16) | (v9 << 8);
    reg_datab = v31 | 0xC0000000;
    v37 = v20 - 1;
    printf(
      "\n--- %s: Want freq %f  real freq %f\n",
      "BM1391_get_pllparam_divider",
      v12,
      (float)((float)((float)(25.0 / (float)v9) * (float)v11) / (float)(int)(v28 * v20)));
    printf(
      "\n--- %s: pll_vco %f, fbdiv %#x refdiv %#x postdiv1 %#x postdiv2 %#x, pll_divider %d ,{pll_value %#x}\n",
      "BM1391_get_pllparam_divider",
      v10,
      v11,
      v9,
      v24,
      v27,
      v20,
      v31);
  }
  else
  {
    v17 = (float)v7;
    v18 = 15;
    while ( 1 )
    {
      v19 = (float)v18;
      v20 = (unsigned __int8)v18--;
      v4 = (float)(v17 / v19);
      printf(
        "\n--- %s: pll_div decimals %f postdiv_f %f\n",
        "BM1391_get_pllparam_divider",
        (float)((float)(v17 / v19) - (float)(unsigned int)(float)(v17 / v19)),
        v4);
      v21 = v20 - 1;
      if ( (float)((float)(v17 / v19) - (float)(unsigned int)(float)(v17 / v19)) < 0.0001 )
        break;
      v20 = v21;
      if ( v18 == 1 )
      {
        if ( v21 != 2 )
          goto LABEL_20;
        goto LABEL_31;
      }
    }
    v7 = (unsigned __int8)(v7 / v20);
    if ( v20 != 2 )
      goto LABEL_20;
LABEL_31:
    if ( (v7 & 1) != 0 )
    {
      printf("\n--- %s: need recal 1\n", "BM1391_get_pllparam_divider");
      if ( v10 > 2000.0 )
      {
LABEL_33:
        v8 = v10;
        v6 = 1;
        goto LABEL_2;
      }
      v31 = 7864593;
      reg_datab = -1065877231;
      v37 = 14;
      printf("\n--- %s: !!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll\n", "BM1391_get_pllparam_divider");
      v30 = 15;
      goto LABEL_28;
    }
LABEL_20:
    if ( v7 <= 7 )
    {
      v24 = v7;
      v27 = 1;
      v29 = 16 * v7;
      v28 = v7;
      goto LABEL_27;
    }
    v22 = 6;
    while ( 1 )
    {
      v23 = v22 - 1;
      v24 = v22;
      v25 = (float)v7 / (float)v22;
      reg_dataa = (unsigned int)v25;
      if ( (float)(v25 - (float)(unsigned int)v25) < 0.0001 )
        break;
      v22 = v23;
      if ( v23 == 255 )
      {
        v26 = 255;
        v27 = 1;
        v24 = 255;
        goto LABEL_25;
      }
    }
    v27 = (unsigned __int8)reg_dataa;
    v32 = (unsigned __int8)reg_dataa > 7u;
    if ( v22 < (unsigned int)(unsigned __int8)reg_dataa )
      v32 = 1;
    if ( v32 )
    {
      printf("\n--- %s: need recal 2\n", "BM1391_get_pllparam_divider");
      if ( v10 > 2000.0 )
        goto LABEL_33;
    }
    v26 = (unsigned __int8)reg_dataa * v22;
LABEL_25:
    v28 = v7;
    if ( v7 == v26 )
    {
      v29 = 16 * v22;
      goto LABEL_27;
    }
    printf("\n--- %s: Don't find postdiv1 %d * postdiv2 %d = postdiv %d\n", "BM1391_get_pllparam_divider", v22, v27, v7);
    v31 = 7864593;
    reg_datab = -1065877231;
    printf("\n--- %s: !!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll\n", "BM1391_get_pllparam_divider");
    v30 = 15;
    v37 = 14;
  }
LABEL_28:
  printf("\n--- %s: freq = %d, pll_param = 0x%08x, divider = %d\n", (const char *)_FUNCTION___8200, freq, v31, v30);
  BM1391_set_config(which_chain, chip_addr, 8u, reg_datab, mode);
  usleep(0x2710u);
  BM1391_set_config(which_chain, chip_addr, 0x70u, v37, mode);
  usleep(0x2710u);
  BM1391_set_config(which_chain, chip_addr, 8u, reg_datab, mode);
  j_usleep(0x2710u);
}
// 12988: variable 'v4' is possibly undefined

//----- (00012C98) --------------------------------------------------------
unsigned int __fastcall check_BM1391_asic_reg(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 reg,
        bool mode)
{
  int v4; // r7
  int v5; // r6
  int v8; // r4
  unsigned int reg_value_num; // r8
  int v10; // r4
  unsigned int v11; // r1
  unsigned int v12; // r3
  reg_buf *v13; // r2
  unsigned int p_rd; // r3
  char *v15; // r3
  int v16; // r2
  unsigned __int8 v17; // lr
  int v18; // r0
  reg_buf *v19; // r1
  int v20; // r2
  unsigned int v21; // r0
  char *v22; // lr
  int v23; // r3
  reg_buf *v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r1
  unsigned int v27; // r3
  unsigned int reg_value; // r2
  unsigned int v29; // r0
  unsigned int v30; // r3
  unsigned int v32; // [sp+0h] [bp-38h]
  int v33; // [sp+4h] [bp-34h]
  unsigned __int8 reg_buf[7]; // [sp+8h] [bp-30h] BYREF

  v4 = reg;
  v5 = which_chain;
  v33 = reg;
  memset(reg_buf, 0, sizeof(reg_buf));
  clear_register_value_buf();
  BM1391_get_status(v5, chip_addr, v4, mode);
  if ( !v4 )
    cgpu.chain_asic_num[v5] = 0;
  v8 = 0;
  v32 = 0;
  do
  {
    while ( 1 )
    {
      usleep(0x7530u);
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf->reg_value_num;
      pthread_mutex_unlock(&reg_mutex);
      if ( !reg_value_num )
        break;
      v10 = 0;
      do
      {
        while ( 1 )
        {
          pthread_mutex_lock(&reg_mutex);
          v13 = reg_value_buf;
          p_rd = reg_value_buf->p_rd;
          if ( reg_value_buf->reg_buffer[p_rd].chain_number != v5 )
            break;
          memset(reg_buf, 0, sizeof(reg_buf));
          v15 = (char *)reg_value_buf + 8 * reg_value_buf->p_rd;
          v16 = *((_DWORD *)v15 + 4);
          v17 = v15[20];
          LOBYTE(v15) = v15[21];
          reg_buf[3] = v16;
          reg_buf[4] = v17;
          reg_buf[5] = (unsigned __int8)v15;
          reg_buf[1] = BYTE2(v16);
          reg_buf[0] = HIBYTE(v16);
          reg_buf[2] = BYTE1(v16);
          v18 = CRC5(reg_buf, 0x33u);
          v19 = reg_value_buf;
          v20 = v18;
          v21 = reg_value_buf->p_rd;
          v22 = (char *)reg_value_buf + 8 * v21;
          v23 = (unsigned __int8)v22[22];
          if ( v20 == v23 )
          {
            if ( !v33 )
            {
              if ( reg_buf[0] == 19 && reg_buf[1] == 145 )
              {
                ++cgpu.chain_asic_num[v5];
                v21 = v19->p_rd;
              }
              else
              {
                printf("%s: error asic address : 0x%08x\n", (const char *)_FUNCTION___8213, *((_DWORD *)v22 + 4));
                v19 = reg_value_buf;
                v21 = reg_value_buf->p_rd;
              }
            }
            v27 = v19->reg_value_num;
            reg_value = v19->reg_buffer[v21].reg_value;
            v29 = v21 + 1;
            v19->p_rd = v29;
            v30 = v27 - 1;
            v19->reg_value_num = v30;
            if ( v29 == 512 )
              v30 = 0;
            v32 = reg_value;
            if ( v29 == 512 )
              v19->p_rd = v30;
          }
          else
          {
            printf("%s: crc is 0x%x, but it should be 0x%x\n", (const char *)_FUNCTION___8213, v20, v23);
            v24 = reg_value_buf;
            v25 = reg_value_buf->p_rd + 1;
            v26 = reg_value_buf->reg_value_num - 1;
            reg_value_buf->p_rd = v25;
            v24->reg_value_num = v26;
            if ( v25 == 512 )
              v24->p_rd = 0;
          }
          ++v10;
          pthread_mutex_unlock(&reg_mutex);
          if ( reg_value_num == v10 )
            goto LABEL_14;
        }
        v11 = reg_value_buf->reg_value_num;
        v12 = p_rd + 1;
        reg_value_buf->p_rd = v12;
        ++v10;
        v13->reg_value_num = v11 - 1;
        if ( v12 == 512 )
        {
          v12 = 0;
          v13->p_rd = 0;
        }
        printf(
          "%s: the return data is from chain%d, but it should be from chain%d\n",
          _FUNCTION___8213,
          v13->reg_buffer[v12].chain_number,
          v5,
          v32);
        pthread_mutex_unlock(&reg_mutex);
      }
      while ( reg_value_num != v10 );
LABEL_14:
      v8 = 0;
    }
    ++v8;
    usleep(0x7530u);
  }
  while ( v8 != 3 );
  if ( !v33 && cgpu.chain_asic_num[v5] > cgpu.max_asic_num_in_one_chain )
    cgpu.max_asic_num_in_one_chain = cgpu.chain_asic_num[v5];
  clear_register_value_buf();
  return v32;
}
// 12D44: variable 'v32' is possibly undefined

//----- (00012E98) --------------------------------------------------------
void __fastcall BM1391_chain_inactive(unsigned __int8 which_chain)
{
  int v1; // r5
  int v2; // r0
  unsigned int v3; // r0
  unsigned __int8 buf[5]; // [sp+4h] [bp-24h] BYREF
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-1Ch] BYREF

  v1 = which_chain;
  buf[4] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  printf("\n--- %s\n", (const char *)_FUNCTION___8228);
  buf[0] = 83;
  buf[1] = 5;
  buf[2] = 0;
  buf[3] = 0;
  v2 = CRC5(buf, 0x20u);
  buf[4] = v2;
  cmd_buf[1] = v2 << 24;
  cmd_buf[0] = bswap32(*(unsigned int *)buf);
  set_BC_command_buffer(cmd_buf);
  v3 = get_BC_write_command();
  set_BC_write_command(v3 & 0xFFF0FFFF | (v1 << 16) | 0x80800000);
  usleep(0x1388u);
}

//----- (00012F14) --------------------------------------------------------
void __fastcall BM1391_set_address(unsigned __int8 which_chain, unsigned __int8 address)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r0
  unsigned __int8 ptr[4]; // [sp+4h] [bp-24h] BYREF
  char v6; // [sp+8h] [bp-20h]
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-1Ch] BYREF

  v2 = which_chain;
  ptr[3] = 0;
  ptr[2] = address;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  v6 = 0;
  ptr[1] = 5;
  ptr[0] = 64;
  v3 = CRC5(ptr, 0x20u);
  v6 = v3;
  cmd_buf[1] = v3 << 24;
  cmd_buf[0] = bswap32(*(unsigned int *)ptr);
  set_BC_command_buffer(cmd_buf);
  v4 = get_BC_write_command();
  set_BC_write_command(v4 & 0xFFF0FFFF | (v2 << 16) | 0x80800000);
}

//----- (00012F74) --------------------------------------------------------
void __fastcall single_BM1391_set_baud(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 asic_baud,
        bool mode)
{
  gBM1391_MISC_CONTROL_reg = gBM1391_MISC_CONTROL_reg & 0xFFFFE0FF | (asic_baud << 8);
  BM1391_set_config(which_chain, chip_addr, 0x18u, gBM1391_MISC_CONTROL_reg, mode);
}

//----- (00012F9C) --------------------------------------------------------
void __fastcall single_BM1391_set_IO_strength(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned int data,
        bool mode)
{
  printf("\n--- %s: IO strength is 0x%08x\n", (const char *)_FUNCTION___8249, data);
  BM1391_set_config(which_chain, chip_addr, 0x58u, data, mode);
}

//----- (00012FCC) --------------------------------------------------------
void reset_single_BM1391_global_arg()
{
  unsigned int OpenCoreNum1; // r11
  unsigned int OpenCoreNum2; // r10
  unsigned int OpenCoreNum3; // r9
  unsigned int OpenCoreNum4; // r8
  unsigned int OpenCoreNum5; // r5
  unsigned int OpenCoreNum6; // r7
  unsigned int OpenCoreNum7; // r6
  unsigned int OpenCoreNum8; // r4
  int v8; // r2
  int v9; // r12
  bool v10; // zf
  bool v11; // nf
  unsigned int pattern_number; // r7
  int v13; // r5
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *p_anon_0; // r11
  unsigned int *v15; // r10
  unsigned int *v16; // r9
  unsigned int *v17; // r8
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v18; // r4
  cgpu_info *v19; // r0
  FILE *v20; // t1
  char *v21; // r3
  char *v22; // r2
  int v23; // [sp+0h] [bp-30h]
  unsigned int v24; // [sp+4h] [bp-2Ch]

  gBM1391_MISC_CONTROL_reg = 14849;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  OpenCoreNum8 = Conf.OpenCoreNum8;
  reset_global_arg();
  printf("\n--- %s\n", (const char *)_FUNCTION___8269);
  v8 = 32;
  v9 = 0;
  do
  {
    v10 = (OpenCoreNum1 & 1) == 0;
    OpenCoreNum1 >>= 1;
    if ( !v10 )
      ++v9;
    v10 = (OpenCoreNum2 & 1) == 0;
    OpenCoreNum2 >>= 1;
    if ( !v10 )
      ++v9;
    v10 = (OpenCoreNum3 & 1) == 0;
    OpenCoreNum3 >>= 1;
    if ( !v10 )
      ++v9;
    v10 = (OpenCoreNum4 & 1) == 0;
    OpenCoreNum4 >>= 1;
    if ( !v10 )
      ++v9;
    v11 = (OpenCoreNum5 & 1) != 0;
    OpenCoreNum5 >>= 1;
    if ( v11 )
      ++v9;
    v11 = (OpenCoreNum6 & 1) != 0;
    OpenCoreNum6 >>= 1;
    if ( v11 )
      ++v9;
    v11 = (OpenCoreNum7 & 1) != 0;
    OpenCoreNum7 >>= 1;
    if ( v11 )
      ++v9;
    v11 = (OpenCoreNum8 & 1) != 0;
    OpenCoreNum8 >>= 1;
    if ( v11 )
      ++v9;
    --v8;
  }
  while ( v8 );
  pattern_number = Conf.pattern_number;
  v13 = 0;
  p_anon_0 = &reg_mutex.__data._anon_0;
  v15 = gRepeated_Nonce_Id;
  v16 = gValid_Nonce_Num;
  v23 = 3347151;
  v17 = gSend_Work_Num;
  v24 = 68 * Conf.pattern_number;
  do
  {
    *v15++ = 0;
    *v16++ = 0;
    *(_BYTE *)(v23 + 1) = 0;
    *v17++ = 0;
    ++v23;
    if ( v9 )
    {
      v18 = p_anon_0;
      v19 = (cgpu_info *)&cgpu.workdataFilePrefix[60];
      do
      {
        v20 = v19->fps[1];
        v19 = (cgpu_info *)((char *)v19 + 4);
        v21 = (char *)v20 + v13;
        v22 = (char *)v20 + v13 + v24;
        if ( pattern_number )
        {
          do
          {
            *((_DWORD *)v21 + 13) = 0;
            v21 += 68;
          }
          while ( v21 != v22 );
        }
        v18[1].__spins = 0;
        ++v18;
      }
      while ( v19 != (cgpu_info *)&cgpu.workdataFilePrefix[4 * v9 + 60] );
    }
    v13 += 4;
    p_anon_0 += 0x20000;
  }
  while ( v13 != 16 );
}

//----- (00013130) --------------------------------------------------------
void single_BM1391_calculate_timeout_and_baud()
{
  _DWORD *v0; // r6
  unsigned int v1; // r4
  unsigned int v2; // r5
  unsigned int v3; // r0
  unsigned int v4; // r3

  LOWORD(v0) = (unsigned __int16)&Conf;
  printf("\n--- %s\n", (const char *)_FUNCTION___8287);
  v1 = calculate_core_number(0x100u);
  switch ( pattern_test_time )
  {
    case 0u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[18];
      break;
    case 1u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[19];
      break;
    case 2u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[20];
      break;
    case 3u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[21];
      break;
    case 4u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[22];
      break;
    case 5u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[23];
      break;
    case 6u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[24];
      break;
    case 7u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[25];
      break;
    case 8u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[26];
      break;
    default:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = 0;
      printf("%s: pattern_test_time = %d, error!!! \n", (const char *)_FUNCTION___8287, pattern_test_time);
      break;
  }
  v3 = gChain_Asic_Interval * (0x1000000 / v1) / v2;
  v0[17] = v2;
  v0[67] = 0;
  v4 = 95 * v3 / 0x64;
  v0[69] = v4;
  j_printf("\n---%s: Baudrate = %d, timeout = %d us\n", (const char *)_FUNCTION___8287, 0, v4);
}

//----- (00013224) --------------------------------------------------------
void __fastcall BM1391_software_set_address(unsigned __int8 which_chain)
{
  unsigned int v2; // r4
  unsigned __int8 v3; // r5

  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8304, which_chain);
  BM1391_chain_inactive(which_chain);
  if ( BHB91601_ASIC_NUMBER )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      ++v2;
      BM1391_set_address(which_chain, v3);
      usleep(0x7D0u);
      v3 += gChain_Asic_Interval;
    }
    while ( BHB91601_ASIC_NUMBER > v2 );
  }
}

//----- (00013280) --------------------------------------------------------
void __fastcall BM1391_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
{
  int v3; // r6

  v3 = baud;
  printf("\n--- %s: Chain : %d, baud = %d\n", (const char *)_FUNCTION___8312, which_chain, baud);
  gBM1391_MISC_CONTROL_reg = gBM1391_MISC_CONTROL_reg & 0xFFFFE0FF | (v3 << 8);
  BM1391_set_config(which_chain, 0, 0x18u, gBM1391_MISC_CONTROL_reg, 1);
  usleep(0xC350u);
  set_fpga_baud(v3);
  j_usleep(0xC350u);
}

//----- (000132E0) --------------------------------------------------------
void __fastcall BM1391_set_TM(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned int tm, bool mode)
{
  int v4; // r5
  unsigned int v5; // r2
  unsigned __int8 v6; // r7
  unsigned __int8 v7; // r6
  unsigned __int8 v8; // r4
  int v9; // r0
  unsigned int v10; // r0
  unsigned int v11; // [sp+0h] [bp-30h] BYREF
  unsigned int v12; // [sp+4h] [bp-2Ch]
  char v13; // [sp+8h] [bp-28h]
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-24h] BYREF

  v4 = which_chain;
  v5 = bswap32(tm);
  v13 = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    LOBYTE(v11) = 81;
  else
    LOBYTE(v11) = 65;
  BYTE2(v11) = asic_addr;
  v6 = bit_swap_table[BYTE2(v5)];
  v7 = bit_swap_table[BYTE1(v5)];
  v8 = bit_swap_table[(unsigned __int8)v5];
  LOBYTE(v12) = bit_swap_table[HIBYTE(v5)];
  BYTE1(v11) = 9;
  HIBYTE(v12) = v8;
  HIBYTE(v11) = 20;
  BYTE1(v12) = v6;
  BYTE2(v12) = v7;
  v9 = CRC5((unsigned __int8 *)&v11, 0x40u);
  v13 = v9;
  cmd_buf[2] = v9 << 24;
  cmd_buf[0] = bswap32(v11);
  cmd_buf[1] = bswap32(v12);
  set_BC_command_buffer(cmd_buf);
  v10 = get_BC_write_command();
  set_BC_write_command(v10 & 0xFFF0FFFF | (v4 << 16) | 0x80800000);
  usleep(0x2710u);
}

//----- (0001338C) --------------------------------------------------------
void __fastcall BM1391_enable_read_temperature_from_asic(unsigned __int8 which_chain, unsigned __int8 asic_addr)
{
  BM1391_set_config(which_chain, asic_addr, 0x18u, gBM1391_MISC_CONTROL_reg | 0x4030, 0);
}

//----- (000133B4) --------------------------------------------------------
void __fastcall BM1391_enable_core_clock(
        unsigned __int8 which_chain,
        unsigned __int8 which_asic,
        unsigned __int8 core_id,
        unsigned __int8 mode)
{
  unsigned __int8 v4; // r4

  v4 = mode;
  if ( mode )
    v4 = 1;
  BM1391_set_config(which_chain, which_asic, 0x3Cu, (core_id << 16) | 0xBCAA, v4);
  j_usleep(0x1388u);
}

//----- (000133DC) --------------------------------------------------------
void __fastcall single_BM1391P_open_core(unsigned __int8 which_chain)
{
  int v1; // r9
  unsigned int OpenCoreNum1; // r7
  unsigned int OpenCoreNum8; // r5
  unsigned int v4; // r4
  unsigned int axi_fpga; // r0
  int v6; // r6
  unsigned int v7; // r0
  __useconds_t v8; // r0
  bool v9; // zf
  __useconds_t v10; // r0
  __useconds_t v11; // r0
  __useconds_t v12; // r0
  __useconds_t v13; // r0
  __useconds_t v14; // r0
  __useconds_t v15; // r0
  __useconds_t v16; // r0
  unsigned int OpenCoreNum2; // [sp+0h] [bp-78h]
  unsigned int OpenCoreNum3; // [sp+4h] [bp-74h]
  unsigned int OpenCoreNum4; // [sp+8h] [bp-70h]
  unsigned int OpenCoreNum5; // [sp+Ch] [bp-6Ch]
  unsigned int OpenCoreNum6; // [sp+10h] [bp-68h]
  unsigned int OpenCoreNum7; // [sp+14h] [bp-64h]
  unsigned int buf_vil_tw[13]; // [sp+1Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum8 = Conf.OpenCoreNum8;
  v4 = 0;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8350, v1);
  gIsOpenCoreEnd = 0;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  v6 = 1 << v1;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    while ( v4 > 0x1F )
    {
      if ( v4 - 32 <= 0x1F )
      {
        if ( (OpenCoreNum2 & 1) != 0 )
        {
          BM1391_enable_core_clock(v1, 0, v4, 1u);
          v11 = 5000;
          do
          {
            usleep(v11);
            v9 = (read_axi_fpga(3u) & v6) == 0;
            v11 = 3000;
          }
          while ( v9 );
          buf_vil_tw[0] = (v1 << 16) | 0x1000080;
          set_TW_write_command(buf_vil_tw);
          usleep(Conf.OpenCoreGap);
        }
        OpenCoreNum2 >>= 1;
      }
      else if ( v4 - 64 <= 0x1F )
      {
        if ( (OpenCoreNum3 & 1) != 0 )
        {
          BM1391_enable_core_clock(v1, 0, v4, 1u);
          v16 = 5000;
          do
          {
            usleep(v16);
            v9 = (read_axi_fpga(3u) & v6) == 0;
            v16 = 3000;
          }
          while ( v9 );
          buf_vil_tw[0] = (v1 << 16) | 0x1000080;
          set_TW_write_command(buf_vil_tw);
          usleep(Conf.OpenCoreGap);
        }
        OpenCoreNum3 >>= 1;
      }
      else if ( v4 - 96 <= 0x1F )
      {
        if ( (OpenCoreNum4 & 1) != 0 )
        {
          BM1391_enable_core_clock(v1, 0, v4, 1u);
          v15 = 5000;
          do
          {
            usleep(v15);
            v9 = (read_axi_fpga(3u) & v6) == 0;
            v15 = 3000;
          }
          while ( v9 );
          buf_vil_tw[0] = (v1 << 16) | 0x1000080;
          set_TW_write_command(buf_vil_tw);
          usleep(Conf.OpenCoreGap);
        }
        OpenCoreNum4 >>= 1;
      }
      else if ( v4 - 128 <= 0x1F )
      {
        if ( (OpenCoreNum5 & 1) != 0 )
        {
          BM1391_enable_core_clock(v1, 0, v4, 1u);
          v14 = 5000;
          do
          {
            usleep(v14);
            v9 = (read_axi_fpga(3u) & v6) == 0;
            v14 = 3000;
          }
          while ( v9 );
          buf_vil_tw[0] = (v1 << 16) | 0x1000080;
          set_TW_write_command(buf_vil_tw);
          usleep(Conf.OpenCoreGap);
        }
        OpenCoreNum5 >>= 1;
      }
      else if ( v4 - 160 <= 0x1F )
      {
        if ( (OpenCoreNum6 & 1) != 0 )
        {
          BM1391_enable_core_clock(v1, 0, v4, 1u);
          v13 = 5000;
          do
          {
            usleep(v13);
            v9 = (read_axi_fpga(3u) & v6) == 0;
            v13 = 3000;
          }
          while ( v9 );
          buf_vil_tw[0] = (v1 << 16) | 0x1000080;
          set_TW_write_command(buf_vil_tw);
          usleep(Conf.OpenCoreGap);
        }
        OpenCoreNum6 >>= 1;
      }
      else if ( v4 - 192 <= 0x1F )
      {
        if ( (OpenCoreNum7 & 1) != 0 )
        {
          BM1391_enable_core_clock(v1, 0, v4, 1u);
          v12 = 5000;
          do
          {
            usleep(v12);
            v9 = (read_axi_fpga(3u) & v6) == 0;
            v12 = 3000;
          }
          while ( v9 );
          buf_vil_tw[0] = (v1 << 16) | 0x1000080;
          set_TW_write_command(buf_vil_tw);
          usleep(Conf.OpenCoreGap);
        }
        OpenCoreNum7 >>= 1;
      }
      else
      {
        if ( (OpenCoreNum8 & 1) != 0 )
        {
          BM1391_enable_core_clock(v1, 0, v4, 1u);
          v10 = 5000;
          do
          {
            usleep(v10);
            v9 = (read_axi_fpga(3u) & v6) == 0;
            v10 = 3000;
          }
          while ( v9 );
          buf_vil_tw[0] = (v1 << 16) | 0x1000080;
          set_TW_write_command(buf_vil_tw);
          usleep(Conf.OpenCoreGap);
        }
        OpenCoreNum8 >>= 1;
      }
      if ( ++v4 == 256 )
        goto LABEL_12;
    }
    if ( (OpenCoreNum1 & 1) != 0 )
    {
      BM1391_enable_core_clock(v1, 0, v4, 1u);
      v8 = 5000;
      do
      {
        usleep(v8);
        v9 = (read_axi_fpga(3u) & v6) == 0;
        v8 = 3000;
      }
      while ( v9 );
      buf_vil_tw[0] = (v1 << 16) | 0x1000080;
      set_TW_write_command(buf_vil_tw);
      usleep(Conf.OpenCoreGap);
    }
    ++v4;
    OpenCoreNum1 >>= 1;
  }
  while ( v4 != 256 );
LABEL_12:
  v7 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v7 | 0x400000);
  gIsOpenCoreEnd = 1;
  printf("\n--- %s end: Chain : %d\n", (const char *)_FUNCTION___8350, v1);
}

//----- (00013704) --------------------------------------------------------
void __fastcall single_BM1391S_open_core(unsigned __int8 which_chain)
{
  int v1; // r7
  int v2; // r6
  unsigned int axi_fpga; // r0
  int i; // r4
  unsigned __int8 v5; // r2
  __useconds_t v6; // r0
  bool v7; // zf
  unsigned int v8; // r0
  unsigned int buf_vil_tw[13]; // [sp+4h] [bp-54h] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8379, v1);
  gIsOpenCoreEnd = 0;
  v2 = 0;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    for ( i = 0; i != 4; ++i )
    {
      usleep(0x3E8u);
      v5 = v2 + ((_BYTE)i << 6);
      BM1391_enable_core_clock(v1, 0, v5, 1u);
    }
    v6 = 5000;
    do
    {
      usleep(v6);
      v7 = (read_axi_fpga(3u) & (1 << v1)) == 0;
      v6 = 3000;
    }
    while ( v7 );
    buf_vil_tw[0] = (v1 << 16) | 0x1000080;
    ++v2;
    set_TW_write_command(buf_vil_tw);
    usleep(Conf.OpenCoreGap);
  }
  while ( v2 != 64 );
  v8 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v8 | 0x400000);
  gIsOpenCoreEnd = 1;
  printf("\n--- %s end: Chain : %d\n", (const char *)_FUNCTION___8379, v1);
}

//----- (000137F0) --------------------------------------------------------
unsigned int __fastcall single_BM1391_get_result(unsigned __int8 which_chain)
{
  configuration *v1; // r8
  unsigned int OpenCoreNum1; // r9
  unsigned int (*v3)[1024]; // r5
  unsigned int OpenCoreNum8; // r6
  int v5; // r10
  unsigned int *v6; // r4
  int v7; // r1
  unsigned int v8; // t1
  int v9; // r10
  unsigned int v10; // r4
  unsigned int v11; // r7
  const char *v12; // r0
  const char *v13; // r0
  work *v15; // r7
  char *v16; // r11
  configuration *v17; // r3
  unsigned int v18; // r7
  unsigned int v19; // r8
  configuration *v20; // r4
  int v21; // r3
  configuration *v22; // r3
  char *v23; // r7
  unsigned int v24; // r11
  int v25; // r3
  char *v26; // r7
  unsigned int v27; // r11
  int v28; // r3
  char *v29; // r7
  unsigned int v30; // r11
  int v31; // r3
  char *v32; // r7
  unsigned int v33; // r11
  int v34; // r3
  char *v35; // r7
  unsigned int v36; // r11
  int v37; // r3
  char *v38; // r7
  unsigned int v39; // r11
  int v40; // r3
  char *v41; // r7
  unsigned int v42; // r11
  int v43; // r3
  int v44; // [sp+4h] [bp-54h]
  int v45; // [sp+10h] [bp-48h]
  unsigned int OpenCoreNum2; // [sp+14h] [bp-44h]
  unsigned int OpenCoreNum3; // [sp+18h] [bp-40h]
  unsigned int OpenCoreNum4; // [sp+1Ch] [bp-3Ch]
  unsigned int OpenCoreNum5; // [sp+20h] [bp-38h]
  unsigned int OpenCoreNum6; // [sp+24h] [bp-34h]
  unsigned int OpenCoreNum7; // [sp+28h] [bp-30h]
  work *works; // [sp+2Ch] [bp-2Ch]
  work *worksa; // [sp+2Ch] [bp-2Ch]
  work *worksb; // [sp+2Ch] [bp-2Ch]
  work *worksc; // [sp+2Ch] [bp-2Ch]
  work *worksd; // [sp+2Ch] [bp-2Ch]
  work *workse; // [sp+2Ch] [bp-2Ch]
  work *worksf; // [sp+2Ch] [bp-2Ch]

  v1 = &Conf;
  v44 = which_chain;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  v3 = gAsic_Core_Nonce_Num[which_chain];
  OpenCoreNum8 = Conf.OpenCoreNum8;
  v5 = 0;
  v6 = &(*v3)[-1];
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every CORE require nonce number: %u\n\n", Conf.pattern_number);
  printf("Open core number : Conf.OpenCoreNum1 = %u = 0x%08x\n", Conf.OpenCoreNum1, Conf.OpenCoreNum1);
  printf("Open core number : Conf.OpenCoreNum2 = %u = 0x%08x\n", Conf.OpenCoreNum2, Conf.OpenCoreNum2);
  printf("Open core number : Conf.OpenCoreNum3 = %u = 0x%08x\n", Conf.OpenCoreNum3, Conf.OpenCoreNum3);
  printf("Open core number : Conf.OpenCoreNum4 = %u = 0x%08x\n", Conf.OpenCoreNum4, Conf.OpenCoreNum4);
  printf("Open core number : Conf.OpenCoreNum5 = %u = 0x%08x\n", Conf.OpenCoreNum5, Conf.OpenCoreNum5);
  printf("Open core number : Conf.OpenCoreNum6 = %u = 0x%08x\n", Conf.OpenCoreNum6, Conf.OpenCoreNum6);
  printf("Open core number : Conf.OpenCoreNum7 = %u = 0x%08x\n", Conf.OpenCoreNum7, Conf.OpenCoreNum7);
  printf("Open core number : Conf.OpenCoreNum8 = %u = 0x%08x\n\n", Conf.OpenCoreNum8, Conf.OpenCoreNum8);
  do
  {
    if ( (v5 & 7) == 0 )
      putchar(10);
    v7 = v5;
    v8 = v6[1];
    ++v6;
    ++v5;
    printf("core[%03d]=%02d\t", v7, v8);
  }
  while ( v5 != 256 );
  v9 = 0;
  v10 = 0;
  v11 = 3;
  v45 = 4 * v44;
  puts("\n\n");
  do
  {
    while ( 1 )
    {
      if ( v10 > 0x1F )
      {
        if ( v10 - 32 <= 0x1F )
        {
          if ( (OpenCoreNum2 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              works = cgpu.works[v9];
              printf("core[%03d] = %d,      lost these nonce : ", v10);
              if ( v1->pattern_number )
              {
                v23 = (char *)works + v45;
                v24 = 0;
                do
                {
                  v25 = *((_DWORD *)v23 + 13);
                  v23 += 68;
                  if ( !v25 )
                    printf("%d  ", v24);
                  ++v24;
                }
                while ( v1->pattern_number > v24 );
              }
              v11 = 2;
              putchar(10);
            }
            ++v9;
            OpenCoreNum2 >>= 1;
          }
          else
          {
            OpenCoreNum2 >>= 1;
          }
        }
        else if ( v10 - 64 <= 0x1F )
        {
          if ( (OpenCoreNum3 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksf = cgpu.works[v9];
              printf("core[%03d] = %d,      lost these nonce : ", v10);
              if ( v1->pattern_number )
              {
                v41 = (char *)worksf + v45;
                v42 = 0;
                do
                {
                  v43 = *((_DWORD *)v41 + 13);
                  v41 += 68;
                  if ( !v43 )
                    printf("%d  ", v42);
                  ++v42;
                }
                while ( v1->pattern_number > v42 );
              }
              v11 = 2;
              putchar(10);
            }
            ++v9;
            OpenCoreNum3 >>= 1;
          }
          else
          {
            OpenCoreNum3 >>= 1;
          }
        }
        else if ( v10 - 96 <= 0x1F )
        {
          if ( (OpenCoreNum4 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksd = cgpu.works[v9];
              printf("core[%03d] = %d,      lost these nonce : ", v10);
              if ( v1->pattern_number )
              {
                v35 = (char *)worksd + v45;
                v36 = 0;
                do
                {
                  v37 = *((_DWORD *)v35 + 13);
                  v35 += 68;
                  if ( !v37 )
                    printf("%d  ", v36);
                  ++v36;
                }
                while ( v1->pattern_number > v36 );
              }
              v11 = 2;
              putchar(10);
            }
            ++v9;
            OpenCoreNum4 >>= 1;
          }
          else
          {
            OpenCoreNum4 >>= 1;
          }
        }
        else if ( v10 - 128 <= 0x1F )
        {
          if ( (OpenCoreNum5 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksc = cgpu.works[v9];
              printf("core[%03d] = %d,      lost these nonce : ", v10);
              if ( v1->pattern_number )
              {
                v32 = (char *)worksc + v45;
                v33 = 0;
                do
                {
                  v34 = *((_DWORD *)v32 + 13);
                  v32 += 68;
                  if ( !v34 )
                    printf("%d  ", v33);
                  ++v33;
                }
                while ( v1->pattern_number > v33 );
              }
              v11 = 2;
              putchar(10);
            }
            ++v9;
            OpenCoreNum5 >>= 1;
          }
          else
          {
            OpenCoreNum5 >>= 1;
          }
        }
        else if ( v10 - 160 <= 0x1F )
        {
          if ( (OpenCoreNum6 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksb = cgpu.works[v9];
              printf("core[%03d] = %d,      lost these nonce : ", v10);
              if ( v1->pattern_number )
              {
                v29 = (char *)worksb + v45;
                v30 = 0;
                do
                {
                  v31 = *((_DWORD *)v29 + 13);
                  v29 += 68;
                  if ( !v31 )
                    printf("%d  ", v30);
                  ++v30;
                }
                while ( v1->pattern_number > v30 );
              }
              v11 = 2;
              putchar(10);
            }
            ++v9;
            OpenCoreNum6 >>= 1;
          }
          else
          {
            OpenCoreNum6 >>= 1;
          }
        }
        else if ( v10 - 192 <= 0x1F )
        {
          if ( (OpenCoreNum7 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              workse = cgpu.works[v9];
              printf("core[%03d] = %d,      lost these nonce : ", v10);
              if ( v1->pattern_number )
              {
                v38 = (char *)workse + v45;
                v39 = 0;
                do
                {
                  v40 = *((_DWORD *)v38 + 13);
                  v38 += 68;
                  if ( !v40 )
                    printf("%d  ", v39);
                  ++v39;
                }
                while ( v1->pattern_number > v39 );
              }
              v11 = 2;
              putchar(10);
            }
            ++v9;
            OpenCoreNum7 >>= 1;
          }
          else
          {
            OpenCoreNum7 >>= 1;
          }
        }
        else if ( (OpenCoreNum8 & 1) != 0 )
        {
          if ( (*v3)[0] < v1->pattern_number )
          {
            worksa = cgpu.works[v9];
            printf("core[%03d] = %d,      lost these nonce : ", v10);
            if ( v1->pattern_number )
            {
              v26 = (char *)worksa + v45;
              v27 = 0;
              do
              {
                v28 = *((_DWORD *)v26 + 13);
                v26 += 68;
                if ( !v28 )
                  printf("%d  ", v27);
                ++v27;
              }
              while ( v1->pattern_number > v27 );
            }
            v11 = 2;
            putchar(10);
          }
          OpenCoreNum8 >>= 1;
          ++v9;
        }
        else
        {
          OpenCoreNum8 >>= 1;
        }
        goto LABEL_17;
      }
      if ( (OpenCoreNum1 & 1) != 0 )
        break;
      OpenCoreNum1 >>= 1;
LABEL_17:
      ++v10;
      v3 = (unsigned int (*)[1024])((char *)v3 + 4);
      if ( v10 == 256 )
        goto LABEL_18;
    }
    if ( (*v3)[0] < v1->pattern_number )
    {
      v15 = cgpu.works[v9];
      printf("core[%03d] = %d,      lost these nonce : ", v10);
      if ( v1->pattern_number )
      {
        v16 = (char *)v15 + v45;
        v17 = v1;
        v18 = 0;
        v19 = v10;
        v20 = v17;
        do
        {
          while ( 1 )
          {
            v21 = *((_DWORD *)v16 + 13);
            v16 += 68;
            if ( !v21 )
              break;
            if ( v20->pattern_number <= ++v18 )
              goto LABEL_50;
          }
          printf("%d  ", v18++);
        }
        while ( v20->pattern_number > v18 );
LABEL_50:
        v22 = v20;
        v10 = v19;
        v1 = v22;
      }
      v11 = 2;
      putchar(10);
    }
    ++v10;
    OpenCoreNum1 >>= 1;
    ++v9;
    v3 = (unsigned int (*)[1024])((char *)v3 + 4);
  }
  while ( v10 != 256 );
LABEL_18:
  if ( v1->TempSensor1 )
  {
    if ( Sensor1_temp && Sensor1_OK && !gNotReadOutTemp )
    {
      printf("temperature1 = %d\n", Sensor1_temp);
    }
    else
    {
      v11 &= ~2u;
      puts("temperature1 check error");
    }
  }
  if ( v1->TempSensor2 )
  {
    if ( Sensor2_temp && Sensor2_OK && !gNotReadOutTemp )
    {
      printf("temperature2 = %d\n", Sensor2_temp);
    }
    else
    {
      v11 &= ~2u;
      puts("temperature2 check error");
    }
  }
  if ( v1->TempSensor3 )
  {
    if ( Sensor3_temp && Sensor3_OK && !gNotReadOutTemp )
    {
      printf("temperature3 = %d\n", Sensor3_temp);
    }
    else
    {
      v11 &= ~2u;
      puts("temperature3 check error");
    }
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  printf("Chain%d total valid nonce number: %d\n\n", v44, gValid_Nonce_Num[v44]);
  if ( (v11 & 1) != 0 )
    LOWORD(v12) = -25288;
  else
    LOWORD(v12) = -25276;
  HIWORD(v12) = 2;
  puts(v12);
  if ( (v11 & 2) != 0 )
    LOWORD(v13) = -21748;
  else
    LOWORD(v13) = -21736;
  HIWORD(v13) = 2;
  puts(v13);
  printf("HW number = %d\n\n", gHw_Nonce_Num[v44]);
  return v11;
}

//----- (00013EB0) --------------------------------------------------------
void __fastcall single_BM1391_print_lcd(unsigned __int8 which_chain, unsigned int result)
{
  char v2; // r5
  unsigned __int8 *v3; // r1
  unsigned __int8 *v4; // r1
  unsigned __int8 lcd_display_buf[16]; // [sp+0h] [bp-20h] BYREF

  v2 = result;
  qmemcpy(lcd_display_buf, "      HW        ", sizeof(lcd_display_buf));
  display_level_result_on_lcd();
  sprintf((char *)&lcd_display_buf[10], "%d", gHw_Nonce_Num[gChain]);
  write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
  if ( (v2 & 1) != 0 )
    LOWORD(v3) = -25244;
  else
    LOWORD(v3) = -25224;
  HIWORD(v3) = 2;
  write_lcd_no_memset(2u, v3, 0x10u);
  if ( (v2 & 2) != 0 )
    LOWORD(v4) = -21724;
  else
    LOWORD(v4) = -21704;
  HIWORD(v4) = 2;
  write_lcd_no_memset(3u, v4, 0x10u);
}

//----- (00013F44) --------------------------------------------------------
void __fastcall BM1391_soft_reset_sensor(unsigned __int8 which_chain)
{
  int v2; // r7
  unsigned int TempSensor2; // r5
  char v4; // r5
  unsigned int v5; // r4
  unsigned int v6; // r0
  unsigned int v7; // r4

  v2 = 0;
  printf("\n--- %s\n", (const char *)_FUNCTION___8451);
  do
  {
    if ( v2 )
    {
      if ( v2 == 1 )
      {
        TempSensor2 = Conf.TempSensor2;
      }
      else if ( v2 == 2 )
      {
        TempSensor2 = Conf.TempSensor3;
      }
      else
      {
        TempSensor2 = Conf.TempSensor4;
      }
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
    {
      v4 = TempSensor2 - 1;
      v5 = 0;
      BM1391_set_config(which_chain, gChain_Asic_Interval * v4, 0x18u, gBM1391_MISC_CONTROL_reg | 0x4030, 0);
      check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x18u, 0);
      while ( 1 )
      {
        ++v5;
        v6 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0);
        if ( (v6 & 0xC0000000) == 0 )
          break;
        if ( v5 >= 2 )
        {
          gNotReadOutTemp = 1;
          printf("%s: Can't read out GENERAL_I2C_COMMAND. ret = 0x%08x\n", (const char *)_FUNCTION___8451, v6);
          goto LABEL_9;
        }
      }
      v7 = 0;
      BM1391_set_config(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0x10006u, 0);
      do
        ++v7;
      while ( (check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0) & 0xC0000000) != 0 && v7 < 2 );
    }
LABEL_9:
    ++v2;
  }
  while ( v2 != 4 );
  j_usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
}

//----- (0001407C) --------------------------------------------------------
void __fastcall BM1391_enable_extended_mode_of_temperature_sensor(unsigned __int8 which_chain)
{
  int v2; // r9
  unsigned int TempSensor2; // r4
  char v4; // r4
  unsigned int v5; // r5
  unsigned int v6; // r0
  unsigned int v7; // r5
  unsigned int v8; // r5
  unsigned int v9; // r0

  v2 = 0;
  printf("\n--- %s\n", (const char *)_FUNCTION___8467);
  do
  {
    if ( v2 )
    {
      if ( v2 == 1 )
      {
        TempSensor2 = Conf.TempSensor2;
      }
      else if ( v2 == 2 )
      {
        TempSensor2 = Conf.TempSensor3;
      }
      else
      {
        TempSensor2 = Conf.TempSensor4;
      }
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
    {
      v4 = TempSensor2 - 1;
      v5 = 0;
      BM1391_set_config(which_chain, gChain_Asic_Interval * v4, 0x18u, gBM1391_MISC_CONTROL_reg | 0x4030, 0);
      check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x18u, 0);
      while ( 1 )
      {
        ++v5;
        v6 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0);
        if ( (v6 & 0xC0000000) == 0 )
          break;
        if ( v5 >= 2 )
        {
          gNotReadOutTemp = 1;
          printf("\n!!! %s: Can't read out GENERAL_I2C_COMMAND. ret = 0x%08x\n", (const char *)_FUNCTION___8467, v6);
          goto LABEL_9;
        }
      }
      v7 = 0;
      BM1391_set_config(which_chain, gChain_Asic_Interval * v4, 0x1Cu, gSensor_i2c_addr_high_4_bit | 0x1010904, 0);
      do
        ++v7;
      while ( (check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0) & 0xC0000000) != 0 && v7 < 2 );
      usleep(0x2710u);
      v8 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * v4,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFCFF | 0x1000300,
        0);
      do
      {
        ++v8;
        v9 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0);
      }
      while ( (v9 & 0xC0000000) != 0 && v8 < 2 );
      if ( (v9 & 0xC0000004) != 4 )
      {
        gNotReadOutTemp = 1;
        printf("\n!!! %s: Can't set extended mode. ret = 0x%08x\n", (const char *)_FUNCTION___8467, v9);
      }
    }
LABEL_9:
    ++v2;
  }
  while ( v2 != 4 );
}

//----- (00014258) --------------------------------------------------------
void __fastcall BM1391_get_temperature_offset_value_from_asic(unsigned __int8 which_chain)
{
  int v2; // r9
  unsigned int TempSensor2; // r11
  int v4; // r4
  char *v5; // r5
  int v6; // r1
  int v7; // t1
  char v8; // r4
  unsigned int v9; // r8
  unsigned int v10; // r10
  unsigned int v11; // r0
  unsigned int v12; // r8
  unsigned int v13; // r0
  char v14; // r3
  char v15; // r2
  int v16; // r1
  char local_temp; // [sp+Ch] [bp-3Ch]
  char remote_temp; // [sp+10h] [bp-38h]
  unsigned int *v19; // [sp+14h] [bp-34h] BYREF
  unsigned __int8 offset_value[8]; // [sp+18h] [bp-30h] BYREF

  v19 = &gBM1391_MISC_CONTROL_reg;
  remote_temp = 0;
  v2 = 0;
  local_temp = 0;
  memset(offset_value, 0, sizeof(offset_value));
  printf("\n--- %s\n", (const char *)_FUNCTION___8489);
  do
  {
    if ( v2 )
    {
      if ( v2 == 1 )
        TempSensor2 = Conf.TempSensor2;
      else
        TempSensor2 = Conf.TempSensor3;
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
    {
      v8 = TempSensor2 - 1;
      v9 = 0;
      BM1391_set_config(which_chain, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, *v19 | 0x4030, 0);
      check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, 0);
      do
        ++v9;
      while ( (check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v8, 0x1Cu, 0) & 0xC0000000) != 0 && v9 < 2 );
      v10 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * v8,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFEFF | 0x1000100,
        0);
      do
      {
        ++v10;
        v11 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v8, 0x1Cu, 0);
        if ( (v11 & 0xC0000000) == 0 )
        {
          remote_temp = v11 - 64;
          printf("\nASIC temperature is %d\n", (unsigned __int8)v11 - 64);
          goto LABEL_23;
        }
      }
      while ( v10 < 2 );
      gNotReadOutTemp = 1;
      printf("%s: Can't read out ASIC TEMP. ret = 0x%08x\n", (const char *)_FUNCTION___8489, v11);
LABEL_23:
      v12 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * v8,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFFFF | 0x1000000,
        0);
      do
      {
        ++v12;
        v13 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v8, 0x1Cu, 0);
        if ( (v13 & 0xC0000000) == 0 )
        {
          local_temp = v13 - 64;
          printf("\nPCB temperature is %d\n", (unsigned __int8)v13 - 64);
          goto LABEL_27;
        }
      }
      while ( v12 < 2 );
      gNotReadOutTemp = 1;
      printf("%s: Can't read out HASH BOARD TEMP. ret = 0x%08x\n", (const char *)_FUNCTION___8489, v13);
LABEL_27:
      if ( gNotReadOutTemp )
      {
        v16 = 0;
        v15 = 0;
        v14 = 0;
      }
      else
      {
        v14 = local_temp - remote_temp;
        v15 = local_temp - remote_temp;
        v16 = (char)(local_temp - remote_temp);
      }
      if ( v2 )
      {
        if ( v2 == 1 )
        {
          offset_value[2] = TempSensor2;
          gT2_offset_value = v15;
          cgpu.T2_offset_value += v14;
          offset_value[3] = cgpu.T2_offset_value;
        }
        else
        {
          offset_value[4] = TempSensor2;
          gT3_offset_value = v15;
          cgpu.T3_offset_value += v14;
          offset_value[5] = cgpu.T3_offset_value;
        }
      }
      else
      {
        offset_value[0] = TempSensor2;
        gT1_offset_value = v15;
        cgpu.T1_offset_value += v14;
        offset_value[1] = cgpu.T1_offset_value;
      }
      printf("\ntemp_offset_value = %d\n", v16);
    }
    ++v2;
  }
  while ( v2 != 3 );
  v4 = 0;
  v5 = (char *)&v19 + 3;
  offset_value[7] = 0;
  offset_value[6] = LOBYTE(Conf.sensor_model) | 0x20;
  putchar(10);
  do
  {
    v6 = v4;
    v7 = (unsigned __int8)*++v5;
    ++v4;
    printf("offset_value[%d] = %d\n", v6, v7);
  }
  while ( v4 != 8 );
  if ( !pattern_test_time && Conf.AsicNum != 1 )
  {
    if ( gHashBoard_BHB91601P || gHashBoard_BHB91601S )
      AT24C02_save_offset_value(gI2c, gChain, offset_value);
    else
      set_temperature_offset_value(gI2c, gChain, offset_value);
  }
}

//----- (00014584) --------------------------------------------------------
void __fastcall BM1391_set_default_temperature_offset_value(unsigned __int8 which_chain)
{
  int v2; // r11
  int v3; // r9
  unsigned int v4; // r10
  char v5; // r4
  unsigned int v6; // r8
  unsigned int v7; // r8
  unsigned int v8; // r8
  unsigned int v9; // r0
  unsigned int v10; // r3
  unsigned int TempSensor1; // r1
  unsigned __int8 v12; // r2
  unsigned int which_sensor; // [sp+8h] [bp-40h]
  int v14; // [sp+10h] [bp-38h]

  printf("\n--- %s\n", (const char *)_FUNCTION___8513);
  v2 = 1;
  v3 = 0;
  v14 = 0;
  which_sensor = 0;
  while ( 1 )
  {
    switch ( v3 )
    {
      case 0:
        v10 = gSensor_i2c_addr_high_4_bit;
        TempSensor1 = Conf.TempSensor1;
        v12 = gT1_offset_value;
        v14 = gT1_offset_value;
LABEL_26:
        which_sensor = TempSensor1;
        v4 = v10 | 0x1011100 | v12;
        break;
      case 1:
        v12 = gT2_offset_value;
        v10 = gSensor_i2c_addr_high_4_bit;
        TempSensor1 = Conf.TempSensor2;
        v14 = gT2_offset_value;
        goto LABEL_26;
      case 2:
        which_sensor = Conf.TempSensor3;
        v14 = gT3_offset_value;
        v4 = gSensor_i2c_addr_high_4_bit | 0x1011100 | (unsigned __int8)gT3_offset_value;
        break;
      default:
        v4 = 0;
        break;
    }
    if ( which_sensor )
    {
      v5 = which_sensor - 1;
      v6 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * (which_sensor - 1),
        0x18u,
        gBM1391_MISC_CONTROL_reg | 0x4030,
        0);
      check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * (which_sensor - 1), 0x18u, 0);
      do
        ++v6;
      while ( (check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v5, 0x1Cu, 0) & 0xC0000000) != 0 && v6 < 2 );
      v7 = 0;
      BM1391_set_config(which_chain, gChain_Asic_Interval * v5, 0x1Cu, v4, 0);
      do
        ++v7;
      while ( (check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v5, 0x1Cu, 0) & 0xC0000000) != 0 && v7 < 2 );
      v8 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * v5,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEEEFF | 0x1001100,
        0);
      do
      {
        ++v8;
        v9 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v5, 0x1Cu, 0);
      }
      while ( (v9 & 0xC0000000) != 0 && v8 < 2 );
      if ( v14 != (char)v9 )
      {
        if ( !v3 )
        {
          Sensor1_OK = 0;
          puts("!!! sensor1 is error!\n");
          goto LABEL_8;
        }
        if ( v3 == 1 )
        {
          Sensor2_OK = 0;
          puts("!!! sensor2 is error!\n");
          goto LABEL_9;
        }
        if ( v3 == 2 )
          break;
      }
    }
LABEL_8:
    if ( v2 == 3 )
      return;
LABEL_9:
    ++v3;
    ++v2;
  }
  Sensor3_OK = 0;
  j_puts("!!! sensor3 is error!\n");
}

//----- (00014800) --------------------------------------------------------
void __fastcall BM1391_read_asic_temperature_local_remote(unsigned __int8 which_chain)
{
  bool *v1; // r10
  int i; // r9
  unsigned int TempSensor2; // r3
  int v5; // r4
  int v6; // r5
  int v7; // r3
  int *v8; // r2
  bool v9; // cc
  bool v10; // cc
  unsigned int v11; // r3
  char v12; // r4
  unsigned int v13; // r8
  unsigned int v14; // r8
  unsigned int v15; // r0
  int *v16; // r3
  unsigned int v17; // r8
  unsigned int v18; // r0
  int v19; // r4
  unsigned int TempSensor1; // [sp+Ch] [bp-44h]
  int remote_temp; // [sp+18h] [bp-38h]

  v1 = gSensor_OK[3];
  LOBYTE(remote_temp) = 0;
  for ( i = 0; i != 3; ++i )
  {
    if ( i )
    {
      if ( i == 1 )
        TempSensor2 = Conf.TempSensor2;
      else
        TempSensor2 = Conf.TempSensor3;
      TempSensor1 = TempSensor2;
    }
    else
    {
      TempSensor1 = Conf.TempSensor1;
    }
    if ( TempSensor1 )
    {
      v12 = TempSensor1 - 1;
      v13 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * (TempSensor1 - 1),
        0x18u,
        gBM1391_MISC_CONTROL_reg | 0x4030,
        0);
      check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * (TempSensor1 - 1), 0x18u, 0);
      do
        ++v13;
      while ( (check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v12, 0x1Cu, 0) & 0xC0000000) != 0 && v13 < 2 );
      v14 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * v12,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFEFF | 0x1000100,
        0);
      while ( 1 )
      {
        ++v14;
        v15 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v12, 0x1Cu, 0);
        if ( (v15 & 0xC0000000) == 0 )
          break;
        if ( v14 >= 2 )
        {
          printf("\n!!! %s: do not read out ASIC %d temperature\n\n", (const char *)_FUNCTION___8539, TempSensor1);
          gNotReadOutTemp = 1;
          *v1 = 0;
          goto LABEL_49;
        }
      }
      remote_temp = (unsigned __int8)v15 - 64;
      printf("\nASIC %d TEMP is : %d\n", TempSensor1, remote_temp);
      if ( i )
      {
        if ( i == 1 )
          v16 = &Sensor2_temp;
        else
          v16 = &Sensor3_temp;
        *v16 = remote_temp;
      }
      else
      {
        Sensor1_temp = remote_temp;
      }
      if ( TempSensor1 == Conf.StartSensor )
      {
        if ( remote_temp < Conf.StartTemp )
        {
          if ( !gStartTest )
            printf(
              "\nASIC %d temperature is %d, waiting it raise to start temperature %d\n\n",
              TempSensor1,
              remote_temp,
              Conf.StartTemp);
        }
        else
        {
          if ( !gStartTest )
            printf("\nBegin test!!! Start sensor is %d, ASIC temperature is %d\n\n", TempSensor1, remote_temp);
          gStartTest = 1;
        }
      }
LABEL_49:
      v17 = 0;
      BM1391_set_config(
        which_chain,
        gChain_Asic_Interval * v12,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFFFF | 0x1000000,
        0);
      do
      {
        ++v17;
        v18 = check_BM1391_asic_reg(which_chain, gChain_Asic_Interval * v12, 0x1Cu, 0);
        if ( (v18 & 0xC0000000) == 0 )
        {
          v19 = (unsigned __int8)v18 - 64;
          printf("\nASIC %d Hash Board temperature is %d\n\n", TempSensor1, v19);
          printf("temp_offset_value = %d\n\n", (char)(v19 - remote_temp));
          goto LABEL_8;
        }
      }
      while ( v17 < 2 );
      printf(
        "\n!!! %s: do not read out ASIC %d Hash Board temperature\n\n",
        (const char *)_FUNCTION___8539,
        TempSensor1);
      gNotReadOutTemp = 1;
      *v1 = 0;
    }
LABEL_8:
    ++v1;
  }
  v5 = Sensor1_temp;
  v6 = Sensor3_temp;
  temp_change = (Sensor1_temp + Sensor2_temp + Sensor3_temp - last_Sensor1_temp - last_Sensor2_temp - last_Sensor3_temp)
              / gSensor_number;
  if ( temp_change )
  {
    last_Sensor1_temp = Sensor1_temp;
    last_Sensor2_temp = Sensor2_temp;
    last_Sensor3_temp = Sensor3_temp;
  }
  v7 = highest_temp;
  if ( Sensor1_temp > highest_temp )
  {
    v7 = Sensor1_temp;
    highest_temp = Sensor1_temp;
  }
  if ( Sensor2_temp > v7 )
  {
    v7 = Sensor2_temp;
    highest_temp = Sensor2_temp;
  }
  if ( Sensor3_temp > v7 )
  {
    highest_temp = Sensor3_temp;
    v7 = Sensor3_temp;
  }
  LOWORD(v8) = 3704;
  v9 = Sensor2_temp <= 0;
  if ( Sensor2_temp )
    v9 = Sensor1_temp <= Sensor2_temp;
  HIWORD(v8) = 35;
  if ( !v9 )
    v5 = Sensor2_temp;
  if ( v9 )
    *v8 = v5;
  else
    *v8 = Sensor2_temp;
  v10 = v6 < 0;
  if ( v6 )
    v10 = v6 < v5;
  if ( v10 )
    *v8 = v6;
  if ( v10 )
    v5 = v6;
  if ( gGlobalHighestTemp < v7 )
    gGlobalHighestTemp = v7;
  v9 = Conf.AlarmTemp < v7;
  v11 = v7 - v5;
  if ( v9 )
    gHigherThanAlarmTemp = 1;
  if ( Conf.MaxTempGap < v11 )
  {
    gHigherThanMaxTempGap = 1;
    if ( (int)v11 > gMaxTempGap_value )
    {
      gMaxTempGap_value = v11;
      j_printf("gMaxTempGap_value is %d\n\n", v11);
    }
  }
}

//----- (00014BB0) --------------------------------------------------------
void __fastcall BM1391_read_asic_temperature_local(unsigned __int8 which_chain)
{
  int v1; // r7
  int v2; // r8
  unsigned int TempSensor2; // r10
  char v4; // r5
  unsigned int v5; // r4
  unsigned int v6; // r4
  unsigned int v7; // r0
  int v8; // r4
  int v9; // r3
  int v10; // r3
  int v11; // r3
  unsigned int v12; // r3
  unsigned int *v13; // [sp+Ch] [bp-34h]
  bool *v14; // [sp+10h] [bp-30h]

  v13 = gSensor_read_ok_counter[which_chain];
  v1 = which_chain;
  v2 = 0;
  v14 = gSensor_OK[which_chain];
  while ( 1 )
  {
    if ( v2 )
    {
      if ( v2 == 1 )
        TempSensor2 = Conf.TempSensor2;
      else
        TempSensor2 = v2 == 2 ? Conf.TempSensor3 : Conf.TempSensor4;
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
      break;
LABEL_9:
    if ( ++v2 == 4 )
      return;
  }
  v4 = TempSensor2 - 1;
  v5 = 0;
  BM1391_set_config(v1, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, gBM1391_MISC_CONTROL_reg | 0x4030, 0);
  check_BM1391_asic_reg(v1, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, 0);
  do
    ++v5;
  while ( (check_BM1391_asic_reg(v1, gChain_Asic_Interval * v4, 0x1Cu, 0) & 0xC0000000) != 0 && v5 < 2 );
  v6 = 0;
  BM1391_set_config(v1, gChain_Asic_Interval * v4, 0x1Cu, gSensor_i2c_addr_high_4_bit & 0xFEFEFFFF | 0x1000000, 0);
  while ( 1 )
  {
    ++v6;
    v7 = check_BM1391_asic_reg(v1, gChain_Asic_Interval * v4, 0x1Cu, 0);
    if ( (v7 & 0xC0000000) == 0 )
      break;
    if ( v6 >= 2 )
    {
      printf(
        "%s: do not read out ASIC %d Hash Boardtemperature. ret = 0x%08x\n\n",
        (const char *)_FUNCTION___8558,
        TempSensor2,
        v7);
      gNotReadOutTemp = 1;
      goto LABEL_9;
    }
  }
  v8 = (unsigned __int8)v7 - 64;
  if ( v8 > highest_temp )
    highest_temp = (unsigned __int8)v7 - 64;
  switch ( v2 )
  {
    case 0:
      if ( (_BYTE)v7 )
      {
        Sensor1_temp = (unsigned __int8)v7 - 64;
        v10 = *v13 + 1;
        gSensor_OK[v1][0] = 1;
        *v13 = v10;
        goto LABEL_24;
      }
      goto LABEL_35;
    case 1:
      if ( (_BYTE)v7 )
      {
        Sensor2_temp = (unsigned __int8)v7 - 64;
        v12 = v13[1];
        v14[1] = 1;
        v13[1] = v12 + 1;
LABEL_24:
        printf("\nASIC %d Hash Board temperature is %d\n", TempSensor2, v8);
        if ( TempSensor2 != Conf.StartSensor )
          goto LABEL_9;
        goto LABEL_25;
      }
LABEL_35:
      v8 = 0;
      goto LABEL_24;
    case 2:
      if ( (_BYTE)v7 )
      {
        Sensor3_temp = (unsigned __int8)v7 - 64;
        v11 = v13[2] + 1;
        v14[2] = 1;
        v13[2] = v11;
        goto LABEL_24;
      }
      goto LABEL_35;
  }
  if ( (_BYTE)v7 )
  {
    Sensor4_temp = (unsigned __int8)v7 - 64;
    v9 = v13[3] + 1;
    v14[3] = 1;
    v13[3] = v9;
    goto LABEL_24;
  }
  printf("\nASIC %d Hash Board temperature is %d\n", TempSensor2, 0);
  if ( TempSensor2 == Conf.StartSensor )
  {
    v8 = 0;
LABEL_25:
    if ( Conf.StartTemp > v8 )
    {
      if ( !gStartTest )
        printf(
          "\nASIC %d Hash Board temperature is %d, waiting it raise to start temperature %d\n\n",
          TempSensor2,
          v8,
          Conf.StartTemp);
    }
    else
    {
      if ( !gStartTest )
        printf("\nBegin test!!! Start sensor is %d, Hash Board temperature is %d\n\n", TempSensor2, v8);
      gStartTest = 1;
    }
    goto LABEL_9;
  }
}

//----- (00014E44) --------------------------------------------------------
void *__fastcall __noreturn single_BM1391_show_status_func(void *arg)
{
  int v1; // r6

  v1 = *(unsigned __int8 *)arg;
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    if ( gIsReadTemp && gIsOpenCoreEnd )
    {
      gReadingTemp = 1;
      usleep(15 * Conf.timeout);
      if ( Conf.sensor_model - 1 <= 1 )
      {
        BM1391_read_asic_temperature_local_remote(v1);
      }
      else if ( Conf.sensor_model - 3 <= 5 )
      {
        BM1391_read_asic_temperature_local(v1);
      }
      else
      {
        printf("\n%s: please config sensor_model in Config.ini\n", (const char *)_FUNCTION___8567);
      }
      fan_control(6u);
      gReadingTemp = 0;
    }
    sprintf((char *)lcd_output, "   time %ds", time_counter);
    sprintf((char *)lcd_output[1], "   nonce=%d", gValid_Nonce_Num[v1]);
    sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( gStartTest )
      printf("\ngValid_Nonce_Num = %d\n", gValid_Nonce_Num[v1]);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][18][431]);
  }
}

//----- (00014F88) --------------------------------------------------------
int __fastcall BM1391_is_nonce_or_reg_value(unsigned int data)
{
  return data >> 31;
}

//----- (00014F8C) --------------------------------------------------------
int __fastcall BM1391_check_nonce_flag(unsigned int data)
{
  if ( (data & 0xE0) == 128 )
    return 1;
  printf("%s: data = 0x%08x\n", (const char *)_FUNCTION___8575, data);
  return 0;
}

//----- (00014FB4) --------------------------------------------------------
int __fastcall single_BM1391_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r6
  unsigned int v3; // r9
  int v4; // r8
  unsigned int OpenCoreNum1; // r4
  unsigned int v6; // r2
  unsigned int OpenCoreNum2; // r1
  unsigned int v8; // lr
  unsigned int OpenCoreNum3; // r0
  unsigned int OpenCoreNum5; // r12
  unsigned int OpenCoreNum6; // r10
  unsigned int OpenCoreNum7; // r11
  int v13; // r3
  bool v14; // zf
  work *v15; // lr
  int *v16; // lr
  int result; // r0
  unsigned int v18; // r3
  int v19; // r4
  work *v20; // r4
  unsigned int v21; // r5
  work *v22; // r0
  int v23; // r0
  unsigned int v24; // r3
  int v25; // r5
  unsigned int v26; // r4
  int v27; // r11
  int v28; // r3
  unsigned int v29; // r3
  int v30; // r5
  unsigned int OpenCoreNum4; // r3
  int v32; // r5
  unsigned int v33; // r3
  int v34; // r5
  unsigned int OpenCoreNum8; // r1

  v2 = buf[1];
  v3 = *buf;
  v4 = which_chain;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  v6 = HIBYTE(v2) / gChain_Asic_Interval;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  v8 = HIWORD(v3) & 0x7FFF;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  if ( v6 )
  {
    printf(
      "%s: received ASIC%02d nonce. error!!! data[0] = 0x%08x, received nonce = 0x%08x\n",
      (const char *)_FUNCTION___8600,
      v6,
      v3,
      v2);
    return -1;
  }
  else if ( v8 >= Conf.pattern_number )
  {
    printf(
      "%s: received work_id = %02d nonce. error!!! data[0] = 0x%08x, received nonce = 0x%08x\n",
      (const char *)_FUNCTION___8600,
      HIWORD(v3) & 0x7FFF,
      v3,
      v2);
    return -1;
  }
  else
  {
    if ( (unsigned __int8)v2 <= 0x1Fu )
    {
      v18 = HIBYTE(v2) / gChain_Asic_Interval;
      do
      {
        ++v18;
        if ( (OpenCoreNum1 & 1) != 0 )
          ++v6;
        OpenCoreNum1 >>= 1;
      }
      while ( (unsigned __int8)v2 + 1 != v18 );
    }
    else if ( (unsigned int)(unsigned __int8)v2 - 32 > 0x1F )
    {
      if ( (unsigned int)(unsigned __int8)v2 - 64 <= 0x1F )
      {
        v28 = 32;
        do
        {
          v14 = (OpenCoreNum1 & 1) == 0;
          OpenCoreNum1 >>= 1;
          if ( !v14 )
            ++v6;
          v14 = (OpenCoreNum2 & 1) == 0;
          OpenCoreNum2 >>= 1;
          if ( !v14 )
            ++v6;
          --v28;
        }
        while ( v28 );
        do
        {
          ++v28;
          if ( (OpenCoreNum3 & 1) != 0 )
            ++v6;
          OpenCoreNum3 >>= 1;
        }
        while ( v28 != (unsigned __int8)v2 - 63 );
      }
      else if ( (unsigned int)(unsigned __int8)v2 - 96 > 0x1F )
      {
        if ( (unsigned int)(unsigned __int8)v2 - 128 <= 0x1F )
        {
          OpenCoreNum4 = Conf.OpenCoreNum4;
          v32 = 32;
          do
          {
            v14 = (OpenCoreNum1 & 1) == 0;
            OpenCoreNum1 >>= 1;
            if ( !v14 )
              ++v6;
            v14 = (OpenCoreNum2 & 1) == 0;
            OpenCoreNum2 >>= 1;
            if ( !v14 )
              ++v6;
            v14 = (OpenCoreNum3 & 1) == 0;
            OpenCoreNum3 >>= 1;
            if ( !v14 )
              ++v6;
            v14 = (OpenCoreNum4 & 1) == 0;
            OpenCoreNum4 >>= 1;
            if ( !v14 )
              ++v6;
            --v32;
          }
          while ( v32 );
          do
          {
            ++v32;
            if ( (OpenCoreNum5 & 1) != 0 )
              ++v6;
            OpenCoreNum5 >>= 1;
          }
          while ( (unsigned __int8)v2 - 127 != v32 );
        }
        else if ( (unsigned int)(unsigned __int8)v2 - 160 > 0x1F )
        {
          v33 = Conf.OpenCoreNum4;
          v34 = 32;
          if ( (unsigned int)(unsigned __int8)v2 - 192 <= 0x1F )
          {
            do
            {
              v14 = (OpenCoreNum1 & 1) == 0;
              OpenCoreNum1 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum2 & 1) == 0;
              OpenCoreNum2 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum3 & 1) == 0;
              OpenCoreNum3 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (v33 & 1) == 0;
              v33 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum5 & 1) == 0;
              OpenCoreNum5 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum6 & 1) == 0;
              OpenCoreNum6 >>= 1;
              if ( !v14 )
                ++v6;
              --v34;
            }
            while ( v34 );
            do
            {
              ++v34;
              if ( (OpenCoreNum7 & 1) != 0 )
                ++v6;
              OpenCoreNum7 >>= 1;
            }
            while ( (unsigned __int8)v2 - 191 != v34 );
          }
          else
          {
            do
            {
              v14 = (OpenCoreNum1 & 1) == 0;
              OpenCoreNum1 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum2 & 1) == 0;
              OpenCoreNum2 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum3 & 1) == 0;
              OpenCoreNum3 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (v33 & 1) == 0;
              v33 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum5 & 1) == 0;
              OpenCoreNum5 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum6 & 1) == 0;
              OpenCoreNum6 >>= 1;
              if ( !v14 )
                ++v6;
              v14 = (OpenCoreNum7 & 1) == 0;
              OpenCoreNum7 >>= 1;
              if ( !v14 )
                ++v6;
              --v34;
            }
            while ( v34 );
            OpenCoreNum8 = Conf.OpenCoreNum8;
            do
            {
              ++v34;
              if ( (OpenCoreNum8 & 1) != 0 )
                ++v6;
              OpenCoreNum8 >>= 1;
            }
            while ( v34 != (unsigned __int8)v2 - 223 );
          }
        }
        else
        {
          v29 = Conf.OpenCoreNum4;
          v30 = 32;
          do
          {
            v14 = (OpenCoreNum1 & 1) == 0;
            OpenCoreNum1 >>= 1;
            if ( !v14 )
              ++v6;
            v14 = (OpenCoreNum2 & 1) == 0;
            OpenCoreNum2 >>= 1;
            if ( !v14 )
              ++v6;
            v14 = (OpenCoreNum3 & 1) == 0;
            OpenCoreNum3 >>= 1;
            if ( !v14 )
              ++v6;
            v14 = (v29 & 1) == 0;
            v29 >>= 1;
            if ( !v14 )
              ++v6;
            v14 = (OpenCoreNum5 & 1) == 0;
            OpenCoreNum5 >>= 1;
            if ( !v14 )
              ++v6;
            --v30;
          }
          while ( v30 );
          do
          {
            ++v30;
            if ( (OpenCoreNum6 & 1) != 0 )
              ++v6;
            OpenCoreNum6 >>= 1;
          }
          while ( v30 != (unsigned __int8)v2 - 159 );
        }
      }
      else
      {
        v24 = Conf.OpenCoreNum4;
        v25 = 32;
        do
        {
          v14 = (OpenCoreNum1 & 1) == 0;
          OpenCoreNum1 >>= 1;
          if ( !v14 )
            ++v6;
          v14 = (OpenCoreNum2 & 1) == 0;
          OpenCoreNum2 >>= 1;
          if ( !v14 )
            ++v6;
          v14 = (OpenCoreNum3 & 1) == 0;
          OpenCoreNum3 >>= 1;
          if ( !v14 )
            ++v6;
          --v25;
        }
        while ( v25 );
        do
        {
          ++v25;
          if ( (v24 & 1) != 0 )
            ++v6;
          v24 >>= 1;
        }
        while ( (unsigned __int8)v2 - 95 != v25 );
      }
    }
    else
    {
      v13 = 32;
      do
      {
        v14 = (OpenCoreNum1 & 1) == 0;
        OpenCoreNum1 >>= 1;
        if ( !v14 )
          ++v6;
        --v13;
      }
      while ( v13 );
      do
      {
        ++v13;
        if ( (OpenCoreNum2 & 1) != 0 )
          ++v6;
        OpenCoreNum2 >>= 1;
      }
      while ( v13 != (unsigned __int8)v2 - 31 );
    }
    v15 = &cgpu.works[v6 - 1][v8];
    if ( v2 == v15->nonce )
    {
      v16 = &v15->id + v4;
      result = v16[13];
      if ( result )
      {
        v16[13] = result + 1;
        result = 0;
        ++gRepeated_Nonce_Id[v4];
      }
      else
      {
        v16[13] = 1;
        v26 = gValid_Nonce_Num[v4] + 1;
        ++gAsic_Core_Nonce_Num[v4][0][(unsigned __int8)v2];
        gValid_Nonce_Num[v4] = v26;
      }
    }
    else
    {
      pthread_mutex_lock(&HW_check_mutex[v4]);
      v19 = gWork_Num_For_Hw_Check;
      if ( gWork_Num_For_Hw_Check )
      {
        v20 = gWorks_For_Hw_Check[v4];
        v21 = 0;
        do
        {
          v22 = v20;
          ++v21;
          ++v20;
          v23 = check_hw(v22, v2, 0);
          if ( !v23 )
          {
            pthread_mutex_unlock(&HW_check_mutex[v4]);
            return 0;
          }
        }
        while ( gWork_Num_For_Hw_Check > v21 );
        v27 = v23;
        pthread_mutex_unlock(&HW_check_mutex[v4]);
        if ( v27 == 1 )
        {
          ++gHw_Nonce_Num[v4];
          printf(
            "%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n",
            (const char *)_FUNCTION___8600,
            v4,
            0,
            (unsigned __int8)v2,
            v2);
        }
        return 0;
      }
      else
      {
        pthread_mutex_unlock(&HW_check_mutex[v4]);
        return v19;
      }
    }
  }
  return result;
}

//----- (00015408) --------------------------------------------------------
int __fastcall single_BM1391_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r4
  unsigned int v3; // r7
  reg_buf *v4; // r2
  char *v5; // r0
  unsigned int v6; // r1
  unsigned int reg_value_num; // r3

  if ( reg_value_buf->reg_value_num > 0x1FE )
  {
    printf("%s: reg_value_buf buffer is full!\n", (const char *)_FUNCTION___8654);
    return 0;
  }
  else
  {
    v2 = *buf;
    v3 = buf[1];
    if ( (*buf & 0x40) != 0 )
    {
      printf("%s: reg crc error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8654, *buf, buf[1]);
      return -1;
    }
    else if ( (v2 & 0x20000000) != 0 )
    {
      printf("%s: REG_TYPE error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8654, *buf, buf[1]);
      return -1;
    }
    else
    {
      pthread_mutex_lock(&reg_mutex);
      v4 = reg_value_buf;
      v5 = (char *)v4 + 8 * v4->p_wr;
      v6 = reg_value_buf->p_wr + 1;
      *((_DWORD *)v5 + 4) = v3;
      v5[22] = HIBYTE(v2) & 0x1F;
      v5[20] = BYTE2(v2);
      v5[23] = v2 & 0xF;
      v5[21] = BYTE1(v2);
      reg_value_num = v4->reg_value_num;
      v4->p_wr = v6;
      if ( v6 >= 0x200 )
        v4->p_wr = 0;
      v4->reg_value_num = reg_value_num + 1;
      pthread_mutex_unlock(&reg_mutex);
      return 0;
    }
  }
}

//----- (000154C0) --------------------------------------------------------
void *__fastcall single_BM1391_receive_func(void *arg)
{
  unsigned __int8 v1; // r7
  unsigned int v2; // r4
  void *result; // r0
  unsigned int i; // r5
  unsigned int buf[2]; // [sp+0h] [bp-28h] BYREF

  v1 = *(_BYTE *)arg;
  buf[0] = 0;
  buf[1] = 0;
  while ( 1 )
  {
    result = (void *)start_receive;
    if ( !start_receive )
      break;
    usleep(0x1388u);
    v2 = read_axi_fpga(6u) & 0x1FF;
    if ( v2 )
    {
      for ( i = 0; i < v2; ++i )
      {
        get_return_nonce(buf);
        if ( (buf[0] & 0x80000000) == 0 )
        {
          single_BM1391_check_register_value(v1, buf);
        }
        else if ( gBegin_Get_Nonce )
        {
          if ( (buf[0] & 0xE0) == 128 )
            single_BM1391_check_nonce(v1, buf);
          else
            printf("%s: data = 0x%08x\n", (const char *)_FUNCTION___8575, buf[0]);
        }
      }
    }
  }
  return result;
}

//----- (00015554) --------------------------------------------------------
void singleAsicTest_BM1391()
{
  unsigned int axi_fpga; // r0
  unsigned int v1; // r0
  unsigned int result; // r0
  unsigned __int8 lcd_display_buf[16]; // [sp+0h] [bp-30h] BYREF

  memset(lcd_display_buf, 32, sizeof(lcd_display_buf));
  printf("\nBegin %s test\n", (const char *)_FUNCTION___8732);
  system("date");
  putchar(10);
  memset(lcd_output, 32, sizeof(lcd_output));
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  write_axi_fpga(0x3Eu, 0);
  usleep((__useconds_t)&loc_186A0);
  axi_fpga = read_axi_fpga(0);
  write_axi_fpga(0, axi_fpga | 0x40000000);
  reset_single_BM1391_global_arg();
  check_chain();
  if ( gChain == 255 )
  {
    puts("\nNo hash board, please plug in it");
    write_lcd(1u, " no hash board  ", 0x10u);
    return;
  }
  if ( pthread_create(&cgpu.show_id, 0, single_BM1391_show_status_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "   Creat show   ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1391_show_status_func fail\n\n\n", (const char *)_FUNCTION___8732);
    return;
  }
  reset_hash_board();
  start_receive = 1;
  if ( pthread_create(&cgpu.receive_id, 0, single_BM1391_receive_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "  Creat receive ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1391_receive_func fail\n\n\n", (const char *)_FUNCTION___8732);
    return;
  }
  v1 = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, v1 & 0xFFFF7E1F | 0x8100);
  puts("\n--- check asic number");
  check_BM1391_asic_reg(gChain, 0, 0, 1);
  printf("\n--- check chain: asicNum = %d\n", cgpu.chain_asic_num[gChain]);
  if ( cgpu.chain_asic_num[gChain] != 1 )
  {
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
    write_lcd(0, "   Only have    ", 0x10u);
    write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
    write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
    printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8732, cgpu.chain_asic_num[gChain]);
    puts("----------------------------\n\n");
    return;
  }
  single_BM1391_calculate_timeout_and_baud();
  set_BM1391_freq(gChain, 0, Conf.Freq, 1);
  BM1391_software_set_address(gChain);
  BM1391_set_baud(gChain, Conf.baud);
  check_BM1391_asic_reg(gChain, 0, 0x18u, 1);
  write_axi_fpga(0x22u, Conf.timeout | 0x80000000);
  if ( Conf.sensor_model - 1 <= 1 )
  {
    if ( pattern_test_time )
    {
      BM1391_enable_extended_mode_of_temperature_sensor(gChain);
    }
    else
    {
      BM1391_soft_reset_sensor(gChain);
      BM1391_enable_extended_mode_of_temperature_sensor(gChain);
      BM1391_get_temperature_offset_value_from_asic(gChain);
    }
    BM1391_set_default_temperature_offset_value(gChain);
  }
  else
  {
    if ( Conf.sensor_model - 3 > 6 )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      write_lcd(0, "Sensor Model Err", 0x10u);
      printf("\n%s: please config sensor_model in Config.ini\n", (const char *)_FUNCTION___8732);
      return;
    }
    BM1391_enable_extended_mode_of_temperature_sensor(gChain);
  }
  gIsReadTemp = 1;
  if ( Conf.AsicType == 13911 )
  {
    single_BM1391P_open_core(gChain);
  }
  else
  {
    if ( Conf.AsicType != 13912 )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      write_lcd(1u, " Asic Type Err  ", 0x10u);
      printf("\n!!! %s: Conf.AsicType = %d, error\n", (const char *)_FUNCTION___8732, Conf.AsicType);
      return;
    }
    single_BM1391S_open_core(gChain);
  }
  puts("\nBegin send test pattern");
  putchar(10);
  if ( pthread_create(&cgpu.send_id, 0, single_BM1391_send_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.send_id);
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "   Creat send   ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1391_send_func fail\n\n\n", (const char *)_FUNCTION___8732);
  }
  else
  {
    pthread_join(cgpu.send_id, 0);
    pthread_join(cgpu.receive_id, 0);
    pthread_cancel(cgpu.show_id);
    result = single_BM1391_get_result(gChain);
    single_BM1391_print_lcd(gChain, result);
    set_fan_speed(0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  }
}

//----- (000159D8) --------------------------------------------------------
int check_chain()
{
  signed int axi_fpga; // r9
  int v1; // r4
  chain_info *v2; // r6
  unsigned int *chain_exist; // r5
  unsigned int v5; // r12

  printf("\n--- %s\n", (const char *)_FUNCTION___7893);
  cgpu.chain_num = 0;
  axi_fpga = read_axi_fpga(2u);
  v1 = (unsigned int)(axi_fpga - 1) > 1 && ((axi_fpga - 4) & 0xFFFFFFFB) != 0;
  if ( v1 )
  {
    printf("\n!!! %s: Test zhiju only support 1 plug, but now is 0x%08x\n", (const char *)_FUNCTION___7893, axi_fpga);
    return -1;
  }
  else
  {
    v2 = chain_info_0;
    chain_exist = cgpu.chain_exist;
    do
    {
      chain_info_0[v1].which_chain = 0;
      v2->which_i2c = 0;
      if ( ((axi_fpga >> v1) & 1) != 0 )
      {
        *chain_exist = 1;
        gI2c = 0;
        gChain = v1;
        v5 = cgpu.chain_num + 1;
        chain_info_0[v1].which_chain = v1;
        cgpu.chain_num = v5;
        printf("\n--- %s: gChain = %d, gI2c = %d\n", (const char *)_FUNCTION___7893, v1, 0);
      }
      else
      {
        *chain_exist = 0;
      }
      ++v1;
      ++v2;
      ++chain_exist;
    }
    while ( v1 != 4 );
    return 0;
  }
}

//----- (00015AC8) --------------------------------------------------------
int open_lcd()
{
  int result; // r0

  result = open("/dev/bitmain-lcd", 2178);
  lcd_fd = result;
  if ( result <= 0 )
  {
    puts("open lcd failed!!!");
    return lcd_fd;
  }
  return result;
}

//----- (00015AFC) --------------------------------------------------------
int close_lcd()
{
  int v0; // r4

  v0 = close(lcd_fd);
  if ( v0 )
  {
    puts("lcd close failed!!!");
    return v0;
  }
  else
  {
    puts("lcd closed!!!");
    return 0;
  }
}

//----- (00015B30) --------------------------------------------------------
void __fastcall write_lcd(unsigned int line, unsigned __int8 *buf, unsigned int size)
{
  unsigned int v3; // r5
  bool v4; // cc
  unsigned int v5; // r4
  __off_t v6; // r8
  __off_t v8; // r1
  unsigned int v9; // r10
  int v10; // r8
  int v11; // r12
  int v12; // lr
  int v13; // r9
  unsigned __int8 *v14; // r3

  if ( buf )
  {
    v3 = line;
    if ( lcd_fd > 0 )
    {
      v4 = size > 0x40;
      if ( size <= 0x40 )
        v4 = line > 3;
      v5 = size;
      v6 = v4;
      if ( v4 )
      {
        j_printf("%s: write_lcd's arg is overflow\n", (const char *)_FUNCTION___6339);
      }
      else
      {
        lseek(lcd_fd, v6, v6);
        memset(lcd_output, 32, sizeof(lcd_output));
        if ( v5 )
        {
          v8 = v6;
          if ( v5 > 0x10 )
          {
            v9 = v3;
            do
            {
              v10 = *(_DWORD *)&buf[v8 + 4];
              v5 -= 16;
              v11 = *(_DWORD *)&buf[v8 + 8];
              v12 = *(_DWORD *)&buf[v8 + 12];
              v13 = *(_DWORD *)&buf[v8];
              v14 = &lcd_output[v9][v8];
              ++v3;
              v8 += 16;
              *(_DWORD *)v14 = v13;
              *((_DWORD *)v14 + 1) = v10;
              *((_DWORD *)v14 + 2) = v11;
              *((_DWORD *)v14 + 3) = v12;
            }
            while ( v5 > 0x10 );
          }
          memcpy(lcd_output[v3], &buf[v8], v5);
        }
        j_write(lcd_fd, lcd_output, 0x40u);
      }
    }
  }
}

//----- (00015C00) --------------------------------------------------------
void __fastcall write_lcd_no_memset(unsigned int line, unsigned __int8 *buf, unsigned int size)
{
  int v3; // r8
  bool v4; // cc
  int v5; // r4
  unsigned int v6; // r10
  int v7; // r12
  int v8; // lr
  int v9; // r7
  int v10; // r9
  unsigned __int8 *v11; // r3

  if ( buf )
  {
    v3 = lcd_fd;
    if ( lcd_fd > 0 )
    {
      v4 = size > 0x40;
      if ( size <= 0x40 )
        v4 = line > 3;
      v5 = v4;
      if ( v4 )
      {
        j_printf("%s: write_lcd's arg is overflow\n", (const char *)_FUNCTION___6349);
      }
      else
      {
        if ( size )
        {
          if ( size > 0x10 )
          {
            v6 = line;
            do
            {
              v7 = *(_DWORD *)&buf[v5 + 4];
              size -= 16;
              v8 = *(_DWORD *)&buf[v5 + 8];
              v9 = *(_DWORD *)&buf[v5 + 12];
              v10 = *(_DWORD *)&buf[v5];
              v11 = &lcd_output[v6][v5];
              ++line;
              v5 += 16;
              *(_DWORD *)v11 = v10;
              *((_DWORD *)v11 + 1) = v7;
              *((_DWORD *)v11 + 2) = v8;
              *((_DWORD *)v11 + 3) = v9;
            }
            while ( size > 0x10 );
          }
          memcpy(lcd_output[line], &buf[v5], size);
        }
        j_write(v3, lcd_output, 0x40u);
      }
    }
  }
}

//----- (00015CA8) --------------------------------------------------------
unsigned int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 which_uart)
{
  unsigned int result; // r0

  switch ( which_uart )
  {
    case 0u:
      result = (read_axi_fpga(0x7Cu) >> 16) & 0x3FF;
      break;
    case 1u:
      result = read_axi_fpga(0x7Cu) & 0x3FF;
      break;
    case 2u:
      result = (read_axi_fpga(0x7Du) >> 16) & 0x3FF;
      break;
    case 3u:
      result = read_axi_fpga(0x7Du) & 0x3FF;
      break;
    case 4u:
      result = (read_axi_fpga(0x7Eu) >> 16) & 0x3FF;
      break;
    case 5u:
      result = read_axi_fpga(0x7Eu) & 0x3FF;
      break;
    case 6u:
      result = (read_axi_fpga(0x7Fu) >> 16) & 0x3FF;
      break;
    case 7u:
      result = read_axi_fpga(0x7Fu) & 0x3FF;
      break;
    case 8u:
      result = (read_axi_fpga(0x80u) >> 16) & 0x3FF;
      break;
    case 9u:
      result = read_axi_fpga(0x80u) & 0x3FF;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", (const char *)_FUNCTION___8008, which_uart);
      result = 0;
      break;
  }
  return result;
}

//----- (00015D50) --------------------------------------------------------
unsigned int __fastcall read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
{
  unsigned int v5; // r5
  unsigned int v6; // r0
  unsigned int v7; // r10
  unsigned int v8; // r8
  unsigned __int8 *v9; // r4
  unsigned int axi_fpga; // r0
  unsigned int v11; // r7
  unsigned int result; // r0
  unsigned int v13; // r0
  unsigned int v14; // r1
  unsigned int v15; // r3
  unsigned __int8 *v16; // r2
  unsigned int v17; // r3
  unsigned int v18; // r3

  switch ( which_uart )
  {
    case 0u:
      v5 = 133;
      v6 = 132;
      goto LABEL_3;
    case 1u:
      v5 = 135;
      v6 = 134;
      goto LABEL_3;
    case 2u:
      v5 = 137;
      v6 = 136;
      goto LABEL_3;
    case 3u:
      v5 = 139;
      v6 = 138;
      goto LABEL_3;
    case 4u:
      v5 = 141;
      v6 = 140;
      goto LABEL_3;
    case 5u:
      v5 = 143;
      v6 = 142;
      goto LABEL_3;
    case 6u:
      v5 = 145;
      v6 = 144;
      goto LABEL_3;
    case 7u:
      v5 = 147;
      v6 = 146;
      goto LABEL_3;
    case 8u:
      v5 = 149;
      v6 = 148;
      goto LABEL_3;
    case 9u:
      v5 = 151;
      v6 = 150;
LABEL_3:
      write_axi_fpga(v6, length & 0x3FF | 0x80000000);
      v7 = length >> 2;
      if ( length >> 2 )
      {
        v8 = 4 * v7;
        v9 = buf;
        do
        {
          v9 += 4;
          axi_fpga = read_axi_fpga(v5);
          *(v9 - 1) = axi_fpga;
          *(v9 - 4) = HIBYTE(axi_fpga);
          *(v9 - 3) = BYTE2(axi_fpga);
          *(v9 - 2) = BYTE1(axi_fpga);
        }
        while ( v9 != &buf[4 * v7] );
      }
      else
      {
        v8 = 0;
      }
      v11 = length & 3;
      if ( v11 )
      {
        v13 = read_axi_fpga(v5);
        if ( v11 == 2 )
        {
          v18 = HIWORD(v13);
          buf[4 * v7] = HIBYTE(v13);
          result = v8 + 2;
          buf[v8 + 1] = v18;
        }
        else if ( v11 == 3 )
        {
          v14 = HIWORD(v13);
          v15 = v13 >> 8;
          v16 = &buf[v8];
          buf[4 * v7] = HIBYTE(v13);
          result = v8 + 3;
          v16[1] = v14;
          v16[2] = v15;
        }
        else
        {
          v17 = HIBYTE(v13);
          result = v8 + 1;
          buf[4 * v7] = v17;
        }
      }
      else
      {
        result = v8;
      }
      break;
    default:
      printf("%s: The uart is not supported!!!\n", (const char *)_FUNCTION___8033);
      result = 0;
      break;
  }
  return result;
}

//----- (00015E58) --------------------------------------------------------
unsigned int __fastcall uart_send(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
{
  int v3; // r11
  char v5; // r8
  unsigned int v6; // r5
  unsigned int v7; // r10
  unsigned int v8; // r7
  int v9; // r4
  int v11; // r4
  unsigned int v12; // r7
  unsigned __int8 *v13; // r4
  int v14; // r8
  int v15; // r3
  int v16; // lr
  int v17; // r2
  unsigned int v18; // r3
  int v19; // r1
  unsigned __int8 send_buf[512]; // [sp+8h] [bp-228h] BYREF

  v3 = which_uart;
  memset(send_buf, 0, sizeof(send_buf));
  pthread_mutex_lock(&uart_send_mutex[v3]);
  switch ( v3 )
  {
    case 0:
      v5 = 24;
      v6 = 101;
      v7 = 100;
      v8 = 96;
      goto LABEL_3;
    case 1:
      v5 = 16;
      v6 = 103;
      v7 = 102;
      v8 = 96;
      goto LABEL_3;
    case 2:
      v5 = 8;
      v6 = 105;
      v7 = 104;
      v8 = 96;
      goto LABEL_3;
    case 3:
      v5 = 0;
      v6 = 107;
      v7 = 106;
      v8 = 96;
      goto LABEL_3;
    case 4:
      v5 = 24;
      v6 = 109;
      v7 = 108;
      v8 = 97;
      goto LABEL_3;
    case 5:
      v5 = 16;
      v6 = 111;
      v7 = 110;
      v8 = 97;
      goto LABEL_3;
    case 6:
      v5 = 8;
      v6 = 113;
      v7 = 112;
      v8 = 97;
      goto LABEL_3;
    case 7:
      v5 = 0;
      v6 = 115;
      v7 = 114;
      v8 = 97;
      goto LABEL_3;
    case 8:
      v5 = 24;
      v6 = 117;
      v7 = 116;
      v8 = 98;
      goto LABEL_3;
    case 9:
      v5 = 16;
      v6 = 119;
      v7 = 118;
      v8 = 98;
LABEL_3:
      v9 = 21;
      break;
    default:
      printf("%s: The uart is not supported!!!\n", (const char *)_FUNCTION___8070);
      return 0;
  }
  while ( length > (unsigned __int8)(read_axi_fpga(v8) >> v5) )
  {
    usleep(0xBB8u);
    if ( !--v9 )
    {
      pthread_mutex_unlock(&uart_send_mutex[v3]);
      printf("%s: uart%d always dose not has enough send fifo space, break\n", (const char *)_FUNCTION___8070, v3);
      return 0;
    }
  }
  v11 = 22;
  while ( (read_axi_fpga(v7) & 0x80000000) != 0 )
  {
    if ( !--v11 )
    {
      pthread_mutex_unlock(&uart_send_mutex[v3]);
      printf("%s: uart%d always busy, break\n", (const char *)_FUNCTION___8070, v3);
      return 0;
    }
    usleep(0xBB8u);
  }
  memcpy(send_buf, buf, length);
  v12 = length >> 2;
  if ( length >> 2 )
  {
    v13 = send_buf;
    v14 = 0;
    do
    {
      v15 = v13[1];
      ++v14;
      v16 = *v13;
      v17 = v13[3];
      v13 += 4;
      write_axi_fpga(v6, (v15 << 16) | (v16 << 24) | v17 | (*(v13 - 2) << 8));
    }
    while ( v12 != v14 );
  }
  v18 = length & 3;
  if ( (length & 3) != 0 )
  {
    if ( v18 == 2 )
    {
      v19 = (send_buf[4 * v12] << 24) | (send_buf[4 * v12 + 1] << 16);
    }
    else if ( v18 == 3 )
    {
      v19 = (send_buf[4 * v12 + 2] << 8) | (send_buf[4 * v12 + 1] << 16) | (send_buf[4 * v12] << 24);
    }
    else
    {
      v19 = send_buf[4 * v12] << 24;
    }
    write_axi_fpga(v6, v19);
  }
  write_axi_fpga(v7, length | 0x80000000);
  pthread_mutex_unlock(&uart_send_mutex[v3]);
  return length;
}

//----- (00016058) --------------------------------------------------------
unsigned int __fastcall uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length)
{
  pthread_mutex_t *v6; // r4
  unsigned int v7; // r2
  unsigned int uart_data_in_fpga; // r5
  unsigned int v10; // r7
  unsigned int v11; // r0

  v6 = &uart_receive_mutex[which_uart];
  pthread_mutex_lock(v6);
  if ( Conf.AsicType != 1385 )
  {
    if ( buf_length >= check_how_many_uart_data_in_fpga(which_uart) )
    {
      v7 = 0;
LABEL_5:
      uart_data_in_fpga = read_uart_data_in_fpga(which_uart, buf, v7);
      pthread_mutex_unlock(v6);
      return uart_data_in_fpga;
    }
    v10 = 0;
    goto LABEL_6;
  }
  v11 = check_how_many_uart_data_in_fpga(which_uart);
  v10 = 5;
  if ( v11 > buf_length )
  {
LABEL_6:
    printf("%s: nbytes > buf_length\n", (const char *)_FUNCTION___8092);
    v11 = buf_length;
  }
  if ( v11 >= v10 )
  {
    v7 = v10 * (v11 / v10);
    goto LABEL_5;
  }
  pthread_mutex_unlock(v6);
  return 0;
}

//----- (000160EC) --------------------------------------------------------
unsigned int __fastcall clear_uart_send_fifo(unsigned __int8 which_chain)
{
  int v1; // r6
  pthread_mutex_t *v2; // r10
  char v3; // r9
  int v4; // r3
  int v5; // r2
  unsigned int v6; // r8
  int v7; // r5
  unsigned int v8; // r4

  v1 = which_chain;
  v2 = &uart_send_mutex[which_chain];
  pthread_mutex_lock(v2);
  switch ( v1 )
  {
    case 0:
      v3 = 24;
      v4 = 101;
      v5 = 100;
      v6 = 96;
      goto LABEL_3;
    case 1:
      v3 = 16;
      v4 = 103;
      v5 = 102;
      v6 = 96;
      goto LABEL_3;
    case 2:
      v3 = 8;
      v4 = 105;
      v5 = 104;
      v6 = 96;
      goto LABEL_3;
    case 3:
      v3 = 0;
      v4 = 107;
      v5 = 106;
      v6 = 96;
      goto LABEL_3;
    case 4:
      v3 = 24;
      v4 = 109;
      v5 = 108;
      v6 = 97;
      goto LABEL_3;
    case 5:
      v3 = 16;
      v4 = 111;
      v5 = 110;
      v6 = 97;
      goto LABEL_3;
    case 6:
      v3 = 8;
      v4 = 113;
      v5 = 112;
      v6 = 97;
      goto LABEL_3;
    case 7:
      v3 = 0;
      v4 = 115;
      v5 = 114;
      v6 = 97;
      goto LABEL_3;
    case 8:
      v3 = 24;
      v4 = 117;
      v5 = 116;
      v6 = 98;
      goto LABEL_3;
    case 9:
      v3 = 16;
      v4 = 119;
      v5 = 118;
      v6 = 98;
LABEL_3:
      v7 = 21;
      printf("--- %s: chain_send_ready_addr %d, chain_send_buffer_addr %d\n", (const char *)_FUNCTION___8114, v5, v4);
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", (const char *)_FUNCTION___8114, v1);
      pthread_mutex_unlock(v2);
      return 1;
  }
  while ( 1 )
  {
    v8 = read_axi_fpga(v6) >> v3;
    if ( (unsigned __int8)v8 == 255 )
      break;
    printf("%s: waiting fpga uart%d clear send fifo space ...\n", (const char *)_FUNCTION___8114, v1);
    usleep(0xBB8u);
    if ( !--v7 )
    {
      printf("%s: uart%d always dose not has enough send fifo space, break\n", (const char *)_FUNCTION___8114, v1);
      pthread_mutex_unlock(v2);
      return (unsigned __int8)v8;
    }
  }
  pthread_mutex_unlock(v2);
  return 0;
}

//----- (0001622C) --------------------------------------------------------
unsigned int __fastcall clear_uart_rx_fifo(unsigned __int8 which_chain)
{
  int v1; // r5
  pthread_mutex_t *v2; // r4
  unsigned int v3; // r0
  unsigned int v4; // r6
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r7
  unsigned int uart_data_in_fpga; // r3

  v1 = which_chain;
  printf("--- %s\n", (const char *)_FUNCTION___8122);
  v2 = &uart_receive_mutex[v1];
  pthread_mutex_lock(v2);
  v3 = check_how_many_uart_data_in_fpga(v1);
  v4 = v3;
  if ( v3 )
  {
    v5 = (unsigned __int8 *)malloc(v3);
    v6 = v5;
    if ( v5 )
    {
      uart_data_in_fpga = read_uart_data_in_fpga(v1, v5, v4);
      if ( v4 != uart_data_in_fpga )
        printf(
          "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
          (const char *)_FUNCTION___8122,
          v1,
          v4,
          uart_data_in_fpga);
      free(v6);
      usleep(0x2710u);
      pthread_mutex_unlock(v2);
      return 1;
    }
    else
    {
      printf("%s: uart%d malloc buffer error\n", (const char *)_FUNCTION___8122, v1);
      usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
      pthread_mutex_unlock(v2);
      return 1;
    }
  }
  else
  {
    pthread_mutex_unlock(v2);
    return 0;
  }
}

//----- (000162DC) --------------------------------------------------------
void single_asic_test()
{
  if ( Conf.AsicType == 1385 )
  {
    puts("\nBegin singleAsicTest_BM1385\n");
    singleAsicTest_BM1385();
  }
  else if ( Conf.AsicType - 13911 <= 1 )
  {
    puts("\nBegin singleAsicTest_BM1391\n");
    singleAsicTest_BM1391();
  }
  else if ( Conf.AsicType == 1397 )
  {
    puts("\nBegin singleAsicTest_BM1397\n");
    singleAsicTest_BM1397();
  }
  else
  {
    j_printf("Single ASIC test: Can't find ASIC type!!! AsicType = %d\n", Conf.AsicType);
  }
}

//----- (00016350) --------------------------------------------------------
void hash_board_test()
{
  bool v0; // cc

  while ( 1 )
  {
    usleep(0x2710u);
    if ( gHashBoard_V9 )
    {
      singleBoardTest_V9_BM1385_45();
      goto LABEL_7;
    }
    if ( gHashBoard_BHB91601P || gHashBoard_BHB91601S )
    {
      singleBoardTest_BHB91601_BM1391();
      goto LABEL_7;
    }
    if ( gHashBoard_BHB91603S )
    {
      singleBoardTest_BHB91603_BM1391();
      goto LABEL_7;
    }
    if ( !gHashBoard_BHB07601 )
      break;
    singleBoardTest_BHB07601_BM1397();
LABEL_7:
    printf(
      "%s: pattern_test_time %d, gHowManyVoltageLevel %d\n",
      (const char *)_FUNCTION___8156,
      pattern_test_time,
      gHowManyVoltageLevel);
    v0 = pattern_test_time != 0;
    if ( pattern_test_time )
      v0 = gHowManyVoltageLevel > (unsigned int)pattern_test_time;
    if ( !v0 )
      goto LABEL_16;
  }
  printf("%s: Please config HashBoard name in Config.ini\n", (const char *)_FUNCTION___8156);
LABEL_16:
  pattern_test_time = 0;
}

//----- (00016408) --------------------------------------------------------
void *__fastcall __noreturn BHB91603_show_status_func(void *arg)
{
  int v1; // r8
  unsigned int v2; // r2
  unsigned int v3; // [sp+1Ch] [bp-34h]

  v1 = *(unsigned __int8 *)arg;
  printf(
    "\n--- %s: which_chain = %d, which_i2c = %d\n",
    (const char *)_FUNCTION___8281,
    v1,
    *((unsigned __int8 *)arg + 1));
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    fan_control(cgpu.fan_speed);
    v2 = time_counter;
    if ( gIsReadTemp && gIsOpenCoreEnd && time_counter == 10 * (time_counter / 0xA) )
    {
      v3 = time_counter % 0xA;
      gReadingTemp = 1;
      usleep(15 * Conf.timeout);
      BM1391_read_asic_temperature_local(v1);
      v2 = time_counter;
      gReadingTemp = v3;
    }
    sprintf((char *)lcd_output, "   time %ds", v2);
    sprintf((char *)lcd_output[1], "   nonce=%d", gValid_Nonce_Num[v1]);
    if ( Conf.TempSensor1 )
    {
      if ( Conf.TempSensor2 )
      {
        if ( Conf.TempSensor3 )
        {
          if ( Conf.TempSensor4 )
          {
            sprintf((char *)lcd_output[2], " T1:%d   T2:%d", Sensor1_temp, Sensor2_temp);
            sprintf((char *)lcd_output[3], " T3:%d   T4:%d", Sensor3_temp, Sensor4_temp);
          }
          else
          {
            sprintf((char *)lcd_output[2], " T1:%d   T2:%d", Sensor1_temp, Sensor2_temp);
            sprintf((char *)lcd_output[3], " T3:%d", Sensor3_temp);
          }
        }
        else
        {
          sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
          sprintf((char *)lcd_output[3], "   T2 %d `C", Sensor2_temp);
        }
      }
      else
      {
        sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
      }
    }
    else
    {
      strcpy((char *)lcd_output[2], "temp setting err!");
    }
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( gStartTest )
      printf("\ngValid_Nonce_Num = %d\n", gValid_Nonce_Num[v1]);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  }
}

//----- (00016648) --------------------------------------------------------
void *__fastcall BHB91603_send_func(void *arg)
{
  int v1; // r9
  int v2; // r5
  unsigned int axi_fpga; // r0
  unsigned int pattern_number; // r5
  unsigned int v5; // r6
  work *v6; // r5
  char *v7; // r3
  unsigned __int8 *v8; // r2
  char *v9; // r1
  char v10; // t1
  vil_work_1391 *v11; // r3
  unsigned __int8 v12; // t1
  vil_work_1391 *p_work_vil_1391; // r3
  vil_work_1391 *v14; // r12
  unsigned int *v15; // r10
  int v16; // r1
  unsigned int *v17; // r12
  int v18; // r1
  work *v19; // r0
  work (*v20)[128]; // r10
  unsigned int v21; // r3
  unsigned int v23; // r3
  unsigned int i; // r2
  unsigned int v25; // r5
  unsigned int v26; // r7
  unsigned int j; // r6
  pthread_mutex_t *mutex; // [sp+10h] [bp-B8h]
  unsigned int which_core; // [sp+14h] [bp-B4h]
  work *works; // [sp+18h] [bp-B0h]
  unsigned int which_asic; // [sp+2Ch] [bp-9Ch]
  unsigned __int8 *v33; // [sp+30h] [bp-98h]
  vil_work_1391 work_vil_1391; // [sp+38h] [bp-90h] BYREF
  unsigned int buf_vil[13]; // [sp+6Ch] [bp-5Ch] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  memset(buf_vil, 0, sizeof(buf_vil));
  printf("\n--- %s: which_chain = %d, which_i2c = %d\n", (const char *)_FUNCTION___8326, v1, v2);
  if ( !gBegin_Get_Nonce )
  {
    axi_fpga = read_axi_fpga(7u);
    write_axi_fpga(7u, axi_fpga | 0x10000);
    gBegin_Get_Nonce = 1;
  }
  if ( BHB91603_ASIC_NUMBER )
  {
    pattern_number = Conf.pattern_number;
    v33 = &cgpu.workdataFilePrefix[60];
    mutex = &HW_check_mutex[v1];
    which_asic = 0;
    do
    {
      works = (work *)*((_DWORD *)v33 + 1);
      v33 += 4;
      for ( which_core = 0; which_core != 256; ++which_core )
      {
        v5 = 0;
        if ( pattern_number )
        {
          do
          {
            if ( gReadingTemp )
              usleep(0x2710u);
            if ( ((1 << gChain) & read_axi_fpga(3u)) != 0 )
            {
              v6 = &works[v5 + pattern_number * which_core];
              memset(buf_vil, 0, sizeof(buf_vil));
              memset(&work_vil_1391, 0, sizeof(work_vil_1391));
              v7 = (char *)&v6->nonce + 3;
              v8 = &v6->data[11];
              v9 = (char *)&work_vil_1391.work_count + 3;
              work_vil_1391.work_type = 1;
              work_vil_1391.chain_id = v1 | 0x80;
              work_vil_1391.work_count = v5;
              do
              {
                v10 = *++v7;
                *++v9 = v10;
              }
              while ( v8 != (unsigned __int8 *)v7 );
              v11 = (vil_work_1391 *)&work_vil_1391.data[11];
              do
              {
                v12 = *++v8;
                v11->chain_id = v12;
                v11 = (vil_work_1391 *)((char *)v11 + 1);
              }
              while ( v11 != (vil_work_1391 *)&work_vil_1391.midstate[31] );
              p_work_vil_1391 = &work_vil_1391;
              v14 = &work_vil_1391;
              buf_vil[0] = ((v1 | 0x80) << 16) | 0x1000000;
              buf_vil[1] = v5;
              v15 = &buf_vil[1];
              do
              {
                v16 = v14->data[1];
                v14 = (vil_work_1391 *)((char *)v14 + 4);
                v15[1] = HIBYTE(v14->work_count) | (v16 << 16) | (LOBYTE(v14->work_count) << 24) | (BYTE2(v14->work_count) << 8);
                ++v15;
              }
              while ( v14 != (vil_work_1391 *)&work_vil_1391.data[4] );
              v17 = &buf_vil[4];
              do
              {
                v18 = p_work_vil_1391->midstate[1];
                p_work_vil_1391 = (vil_work_1391 *)((char *)p_work_vil_1391 + 4);
                v17[1] = p_work_vil_1391->data[11] | (v18 << 16) | (p_work_vil_1391->data[8] << 24) | (p_work_vil_1391->data[10] << 8);
                ++v17;
              }
              while ( p_work_vil_1391 != (vil_work_1391 *)&work_vil_1391.midstate[12] );
              set_TW_write_command(buf_vil);
              pthread_mutex_lock(mutex);
              v19 = &gWorks_For_Hw_Check[v1][127];
              do
              {
                v20 = (work (*)[128])&v19[-1];
                memcpy(v19, &v19[-1], sizeof(work));
                v19 = (work *)v20;
              }
              while ( gWorks_For_Hw_Check[v1] != (work *)v20 );
              ++v5;
              v21 = (unsigned __int8)(gWork_Num_For_Hw_Check + 1);
              if ( v21 > 0x7E )
                LOBYTE(v21) = 127;
              gWork_Num_For_Hw_Check = v21;
              memcpy(gWorks_For_Hw_Check[v1], v6, 0x44u);
              pthread_mutex_unlock(mutex);
              ++gSend_Work_Num[v1];
            }
            else
            {
              usleep(0x3E8u);
            }
            pattern_number = Conf.pattern_number;
          }
          while ( v5 < Conf.pattern_number );
        }
      }
    }
    while ( BHB91603_ASIC_NUMBER > ++which_asic );
    v23 = gSend_Work_Num[v1];
    for ( i = (pattern_number * BHB91603_ASIC_NUMBER) << 8; v23 < i; i = (BHB91603_ASIC_NUMBER * Conf.pattern_number) << 8 )
    {
      printf("\n\n---%s: Chain%d send work num : %d, less than %d\n", (const char *)_FUNCTION___8326, v1, v23, i);
      v23 = gSend_Work_Num[v1];
    }
  }
  else
  {
    v23 = gSend_Work_Num[v1];
  }
  printf("\n\n---%s: Chain%d send work num : %d\n", (const char *)_FUNCTION___8326, v1, v23);
  puts("\nsend test pattern done");
  system("date");
  v25 = 0;
  putchar(10);
  v26 = gValid_Nonce_Num[v1];
  for ( j = v26; ; j = gValid_Nonce_Num[v1] )
  {
    ++v25;
    if ( v26 == j )
      break;
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    v26 = j;
    v25 = 0;
LABEL_35:
    ;
  }
  if ( v25 <= 2 )
  {
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    goto LABEL_35;
  }
  while ( gReadingTemp )
    usleep(0x2710u);
  start_receive = 0;
  puts("to stop receive");
  return 0;
}

//----- (000169A0) --------------------------------------------------------
void reset_BHB91603_global_arg()
{
  unsigned int *v0; // r8
  int v1; // r7
  unsigned int pattern_number; // r5
  char *v3; // r11
  unsigned int *v4; // r12
  unsigned int *v5; // r9
  unsigned int *v6; // lr
  unsigned int v7; // r6
  unsigned int *v8; // r4
  unsigned __int8 *v9; // r10
  int v10; // t1
  unsigned int *v11; // r0
  int v12; // r3
  int v13; // r2
  unsigned int v14; // [sp+0h] [bp-30h]
  unsigned __int8 *v15; // [sp+4h] [bp-2Ch]

  v0 = gRepeated_Nonce_Id;
  gBM1391_MISC_CONTROL_reg = 14849;
  v1 = 0;
  reset_global_arg();
  pattern_number = Conf.pattern_number;
  v3 = (char *)&cgpu.timeout + 3;
  v4 = gValid_Nonce_Num;
  v5 = &gAsic_Core_Nonce_Num[0][0][255];
  v6 = gSend_Work_Num;
  v14 = BHB91603_ASIC_NUMBER;
  v7 = 68 * Conf.pattern_number;
  v15 = &cgpu.workdataFilePrefix[4 * BHB91603_ASIC_NUMBER + 60];
  do
  {
    v8 = v5;
    *++v3 = 0;
    *v0++ = 0;
    *v4++ = 0;
    *v6++ = 0;
    v9 = &cgpu.workdataFilePrefix[60];
    if ( v14 )
    {
      do
      {
        v10 = *((_DWORD *)v9 + 1);
        v9 += 4;
        v11 = v8 - 256;
        v12 = v10 + v1;
        do
        {
          v11[1] = 0;
          ++v11;
          v13 = v12 + v7;
          if ( pattern_number )
          {
            do
            {
              *(_DWORD *)(v12 + 52) = 0;
              v12 += 68;
            }
            while ( v12 != v13 );
          }
          v12 = v13;
        }
        while ( v11 != v8 );
        v8 += 1024;
      }
      while ( v9 != v15 );
    }
    v1 += 4;
    v5 += 0x20000;
  }
  while ( v1 != 16 );
}

//----- (00016A6C) --------------------------------------------------------
bool __fastcall BHB91603_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain)
{
  printf("\n--- %s\n", (const char *)_FUNCTION___8151);
  gAT24C02_data_map[122] = 4;
  gAT24C02_data_map[0] = 126;
  gAT24C02_data_map[123] = Conf.TempSensor1;
  gAT24C02_data_map[121] = Conf.sensor_model;
  gAT24C02_data_map[125] = Conf.TempSensor2;
  gAT24C02_data_map[251] = Conf.HashBoard_Hardware_Version_2;
  gAT24C02_data_map[1] = (5 * cgpu.voltage + 1000) / 0x64;
  gAT24C02_data_map[252] = Conf.HashBoard_Bom_Version_1;
  gAT24C02_data_map[124] = 0;
  gAT24C02_data_map[127] = Conf.TempSensor3;
  gAT24C02_data_map[126] = 0;
  gAT24C02_data_map[129] = Conf.TempSensor4;
  gAT24C02_data_map[253] = Conf.HashBoard_Bom_Version_2;
  gAT24C02_data_map[250] = Conf.HashBoard_Hardware_Version_1;
  gAT24C02_data_map[128] = 0;
  gAT24C02_data_map[130] = 0;
  *(_WORD *)&gAT24C02_data_map[254] = CRC16(gAT24C02_data_map, 0xFEu);
  AT24C02_write_bytes(0, gAT24C02_data_map, which_iic, which_chain, 0x100u);
  if ( gAT24C02_data_map[255] == AT24C02_read_one_byte(0xFFu, which_iic, which_chain) )
  {
    printf("--- %s: save data into EEPROM success! \n", (const char *)_FUNCTION___8151);
    return 1;
  }
  else
  {
    gEEPROM_error = 1;
    printf("!!! %s: save data into EEPROM fail! \n", (const char *)_FUNCTION___8151);
    return 0;
  }
}

//----- (00016B94) --------------------------------------------------------
int __fastcall BHB91603_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4

  v2 = Calibration_voltage(which_chain, which_i2c);
  if ( !v2 )
    return v2;
  pthread_cancel(cgpu.show_id);
  pthread_mutex_lock(&i2c_mutex);
  pthread_cancel(cgpu.pic_heart_beat_id);
  pthread_mutex_unlock(&i2c_mutex);
  switch ( v2 )
  {
    case -1:
      write_lcd(1u, "  Can not find  ", 0x10u);
      write_lcd_no_memset(2u, "  match voltage ", 0x10u);
      printf("\n!!! %s: Can't find match voltage!\n", (const char *)_FUNCTION___8157);
      return -1;
    case -2:
      write_lcd(0, " Maximum N value", 0x10u);
      write_lcd_no_memset(1u, " can not match  ", 0x10u);
      write_lcd_no_memset(2u, "    voltage     ", 0x10u);
      printf("\n!!! %s: Maximum N value can't match voltage!\n", (const char *)_FUNCTION___8157);
      return -2;
    case -3:
      write_lcd(0, " Minimum N value", 0x10u);
      write_lcd_no_memset(1u, " can not match  ", 0x10u);
      write_lcd_no_memset(2u, "    voltage     ", 0x10u);
      printf("\n!!! %s: Minimum N value can't match voltage!\n", (const char *)_FUNCTION___8157);
      return -3;
    default:
      return v2;
  }
}

//----- (00016C94) --------------------------------------------------------
void BHB91603_calculate_timeout_and_baud()
{
  _DWORD *v0; // r4
  unsigned int v1; // r6
  unsigned int v2; // r5
  unsigned int v3; // r0
  int v4; // r2
  unsigned int v5; // r3

  LOWORD(v0) = (unsigned __int16)&Conf;
  v1 = calculate_core_number(0x100u);
  switch ( pattern_test_time )
  {
    case 0u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[18];
      break;
    case 1u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[19];
      break;
    case 2u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[20];
      break;
    case 3u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[21];
      break;
    case 4u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[22];
      break;
    case 5u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[23];
      break;
    case 6u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[24];
      break;
    case 7u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[25];
      break;
    case 8u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[26];
      break;
    default:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = 0;
      printf("%s: pattern_test_time = %d, error!!! \n", (const char *)_FUNCTION___8174, pattern_test_time);
      break;
  }
  v3 = gChain_Asic_Interval * (0x1000000 / v1) / v2;
  v0[17] = v2;
  v4 = v0[67];
  v5 = cgpu.timeout_percent * v3 / 0x64;
  v0[69] = v5;
  printf("\n--- %s: baud = %d, timeout = 0x%08x = %d us, freq = %d\n", (const char *)_FUNCTION___8174, v4, v5, v5, v2);
}

//----- (00016D80) --------------------------------------------------------
void __fastcall BHB91603_set_address(unsigned __int8 which_chain)
{
  unsigned __int8 v2; // r4
  unsigned __int8 v3; // r5

  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8180, which_chain);
  BM1391_chain_inactive(which_chain);
  if ( BHB91603_ASIC_NUMBER )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      BM1391_set_address(which_chain, v3);
      ++v2;
      v3 += gChain_Asic_Interval;
      usleep(0x1388u);
    }
    while ( v2 < BHB91603_ASIC_NUMBER );
  }
}

//----- (00016DE0) --------------------------------------------------------
void __fastcall BHB91603_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", (const char *)_FUNCTION___8188, which_chain, baud);
  BM1391_set_baud(which_chain, baud);
  usleep(0xC350u);
  set_fpga_baud(baud);
}

//----- (00016E18) --------------------------------------------------------
void __fastcall BHB91603_P_open_core(unsigned __int8 which_chain)
{
  int v1; // r4
  unsigned int axi_fpga; // r0
  int v3; // r8
  unsigned int v4; // r3
  unsigned int v5; // r0
  unsigned int buf_vil_tw[13]; // [sp+Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8195, v1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  v3 = 0;
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    BM1391_enable_core_clock(v1, 0, v3, 1u);
    usleep(0x1388u);
    while ( 1 )
    {
      v4 = read_axi_fpga(3u);
      if ( (v4 & (1 << v1)) != 0 )
        break;
      printf("%s: chain%d work fifo not ready: 0x%x\n", (const char *)_FUNCTION___8195, v1, v4);
      usleep(0xBB8u);
    }
    buf_vil_tw[0] = (v1 << 16) | 0x1000080;
    ++v3;
    set_TW_write_command(buf_vil_tw);
    usleep(Conf.OpenCoreGap);
  }
  while ( v3 != 256 );
  v5 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v5 | 0x400000);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (00016F18) --------------------------------------------------------
void __fastcall BHB91603_P_pre_open_core(unsigned __int8 which_chain)
{
  int v1; // r4
  unsigned int v2; // r8
  unsigned int axi_fpga; // r0
  unsigned int v4; // r3
  unsigned int v5; // r0
  unsigned int buf_vil_tw[13]; // [sp+Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8207, v1);
  v2 = 0;
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  if ( Conf.OpenCoreNum2 )
  {
    do
    {
      BM1391_enable_core_clock(v1, 0, v2, 1u);
      usleep(0x1388u);
      while ( 1 )
      {
        v4 = read_axi_fpga(3u);
        if ( (v4 & (1 << v1)) != 0 )
          break;
        printf("%s: chain%d work fifo not ready: 0x%x\n", (const char *)_FUNCTION___8207, v1, v4);
        usleep(0xBB8u);
      }
      buf_vil_tw[0] = (v1 << 16) | 0x1000080;
      set_TW_write_command(buf_vil_tw);
      ++v2;
      usleep(Conf.OpenCoreGap);
    }
    while ( Conf.OpenCoreNum2 > v2 );
  }
  v5 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v5 | 0x400000);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (00017020) --------------------------------------------------------
void __fastcall BHB91603_S_open_core(unsigned __int8 which_chain)
{
  int v1; // r5
  unsigned int axi_fpga; // r0
  int v3; // r9
  int i; // r10
  unsigned __int8 v5; // r2
  unsigned int v6; // r0
  unsigned int buf_vil_tw[13]; // [sp+Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8222_0, v1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  axi_fpga = read_axi_fpga(0x40u);
  v3 = 0;
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    for ( i = 0; i != 4; ++i )
    {
      usleep(0x3E8u);
      v5 = v3 + ((_BYTE)i << 6);
      BM1391_enable_core_clock(v1, 0, v5, 1u);
    }
    usleep(0x1388u);
    while ( (read_axi_fpga(3u) & (1 << v1)) == 0 )
    {
      printf("%s: chain%d work fifo not ready: 0x%x\n", _FUNCTION___8222_0, v1);
      usleep(0xBB8u);
    }
    buf_vil_tw[0] = (v1 << 16) | 0x1000080;
    ++v3;
    set_TW_write_command(buf_vil_tw);
    usleep(Conf.OpenCoreGap);
  }
  while ( v3 != 64 );
  v6 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v6 | 0x400000);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (0001713C) --------------------------------------------------------
void __fastcall BHB91603_S_pre_open_core(unsigned __int8 which_chain)
{
  int v1; // r4
  unsigned int axi_fpga; // r0
  unsigned int v3; // r8
  int i; // r11
  unsigned __int8 v5; // r2
  unsigned int v6; // r3
  unsigned int buf_vil_tw[13]; // [sp+4h] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8240, v1);
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  if ( Conf.OpenCoreNum2 )
  {
    v3 = 0;
    do
    {
      for ( i = 0; i != 4; ++i )
      {
        usleep(0x3E8u);
        v5 = v3 + ((_BYTE)i << 6);
        BM1391_enable_core_clock(v1, 0, v5, 1u);
      }
      usleep(0x1388u);
      while ( 1 )
      {
        v6 = read_axi_fpga(3u);
        if ( (v6 & (1 << v1)) != 0 )
          break;
        printf("%s: chain%d work fifo not ready: 0x%x\n", (const char *)_FUNCTION___8240, v1, v6);
        usleep(0xBB8u);
      }
      buf_vil_tw[0] = (v1 << 16) | 0x1000080;
      set_TW_write_command(buf_vil_tw);
      ++v3;
      usleep(Conf.OpenCoreGap);
    }
    while ( Conf.OpenCoreNum2 > v3 );
  }
}

//----- (00017224) --------------------------------------------------------
unsigned int __fastcall BHB91603_get_result(unsigned __int8 which_chain)
{
  unsigned int v1; // r4
  unsigned int v2; // r0
  unsigned int v3; // r1
  unsigned int v5; // r2
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v6; // r9
  int v7; // r4
  work *v8; // r7
  unsigned int v9; // r2
  unsigned int spins; // t1
  unsigned int v11; // r10
  unsigned int pattern_number; // r3
  int v13; // r1
  int v14; // r3
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  unsigned int axi_fpga; // r0
  unsigned int v20; // [sp+0h] [bp-40h]
  unsigned int which_asic; // [sp+4h] [bp-3Ch]
  unsigned int ret; // [sp+8h] [bp-38h]
  unsigned int reta; // [sp+8h] [bp-38h]
  int v24; // [sp+Ch] [bp-34h]
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v25; // [sp+10h] [bp-30h]

  v24 = which_chain;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every ASIC require nonce number: %u\n", Conf.pattern_number << 8);
  if ( BHB91603_ASIC_NUMBER )
  {
    v1 = 0;
    do
    {
      if ( v1 == 10 * (v1 / 0xA) )
        putchar(10);
      v2 = calculate_how_many_nonce_per_asic_get(v24, v1, 0x100u);
      v3 = v1++;
      printf("asic[%02d]=%d\t", v3, v2);
    }
    while ( BHB91603_ASIC_NUMBER > v1 );
  }
  puts("\n");
  if ( BHB91603_ASIC_NUMBER )
  {
    ret = 7;
    which_asic = 0;
    v25 = &reg_mutex.__data._anon_0 + 0x20000 * v24;
    do
    {
      v5 = calculate_how_many_nonce_per_asic_get(v24, which_asic, 0x100u);
      if ( v5 < Conf.pattern_number << 8 )
      {
        printf("asic[%02d] = %d\n", which_asic, v5);
        v6 = v25;
        v7 = 0;
        v8 = cgpu.works[which_asic];
        v20 = 0;
        do
        {
          spins = v6[1].__spins;
          ++v6;
          v9 = spins;
          if ( spins < Conf.pattern_number )
          {
            v11 = 0;
            if ( v9 < Conf.Least_nonce_per_core )
              ++v20;
            printf("core[%03d] = %d,      lost these nonce : ", v7);
            pattern_number = Conf.pattern_number;
            if ( Conf.pattern_number )
            {
              do
              {
                while ( v8[v11 + pattern_number * v7].is_nonce_return_back[v24][0] )
                {
                  pattern_number = Conf.pattern_number;
                  if ( Conf.pattern_number <= ++v11 )
                    goto LABEL_20;
                }
                printf("%d  ", v11);
                pattern_number = Conf.pattern_number;
                ++v11;
              }
              while ( Conf.pattern_number > v11 );
            }
LABEL_20:
            putchar(10);
          }
          ++v7;
        }
        while ( v7 != 256 );
        if ( v20 > Conf.Invalid_Core_Num )
        {
          ret = 6;
          printf("\n error asic is %d\n", which_asic);
        }
        puts("\n");
      }
      v25 += 1024;
    }
    while ( BHB91603_ASIC_NUMBER > ++which_asic );
  }
  else
  {
    ret = 7;
  }
  printf("HW number = %d, Conf.Most_HW_Num = %d\n\n", gHw_Nonce_Num[v24], Conf.Most_HW_Num);
  v13 = ret;
  if ( gHw_Nonce_Num[v24] > Conf.Most_HW_Num )
    v13 = 6;
  reta = v13;
  puts("\n------------------------------------------------------------------------------------------------------\n");
  if ( Conf.TempSensor1 && gSensor_read_ok_counter[v24][0] <= 4 )
  {
    reta &= ~2u;
    puts("\nSensor 1 check error");
  }
  if ( Conf.TempSensor2 && gSensor_read_ok_counter[v24][1] <= 4 )
  {
    reta &= ~2u;
    puts("\nSensor 2 check error");
  }
  if ( Conf.TempSensor3 && gSensor_read_ok_counter[v24][2] <= 4 )
  {
    reta &= ~2u;
    puts("\nSensor 3 check error");
  }
  if ( Conf.TempSensor4 && gSensor_read_ok_counter[v24][3] <= 4 )
  {
    reta &= ~2u;
    puts("\nSensor 4 check error");
  }
  v14 = gGlobalHighestTemp;
  if ( Conf.TargetTemp < gGlobalHighestTemp )
    v14 = reta;
  if ( Conf.TargetTemp < gGlobalHighestTemp )
    reta = v14 & 0xFFFFFFFB;
  printf(
    "Chain%d total valid nonce number: %d, lost %d nonce\n\n",
    v24,
    gValid_Nonce_Num[v24],
    ((BHB91603_ASIC_NUMBER * Conf.pattern_number) << 8) - gValid_Nonce_Num[v24],
    v20);
  printf(
    "Nonce rate = %f \n\n",
    (float)((float)((float)gValid_Nonce_Num[v24] * 100.0)
          / (float)((float)((float)Conf.pattern_number * 256.0) * (float)BHB91603_ASIC_NUMBER)));
  if ( (reta & 1) != 0 )
    LOWORD(v15) = -25288;
  else
    LOWORD(v15) = -25276;
  HIWORD(v15) = 2;
  puts(v15);
  if ( (reta & 2) != 0 )
    LOWORD(v16) = -21748;
  else
    LOWORD(v16) = -21736;
  HIWORD(v16) = 2;
  puts(v16);
  if ( (reta & 4) != 0 )
    LOWORD(v17) = -17364;
  else
    LOWORD(v17) = -17348;
  HIWORD(v17) = 2;
  puts(v17);
  printf("HW number = %d\n\n", gHw_Nonce_Num[v24]);
  axi_fpga = read_axi_fpga(0x3Eu);
  printf("CRC error number = %d\n\n", axi_fpga);
  return reta;
}
// 174C4: variable 'v20' is possibly undefined

//----- (00017608) --------------------------------------------------------
void __fastcall BHB91603_print_lcd(unsigned int result)
{
  char v1; // r4
  unsigned __int8 *v2; // r1
  char *v3; // r1

  v1 = result;
  display_level_result_on_lcd();
  if ( (v1 & 1) != 0 )
  {
    write_lcd_no_memset(1u, "   Pattern OK   ", 0x10u);
    pattern_test_time = 0;
  }
  else
  {
    write_lcd_no_memset(1u, "   Pattern NG   ", 0x10u);
    ++pattern_test_time;
  }
  if ( (v1 & 2) != 0 )
    LOWORD(v2) = -17308;
  else
    LOWORD(v2) = -17288;
  HIWORD(v2) = 2;
  write_lcd_no_memset(2u, v2, 0x10u);
  if ( gEEPROM_error )
    v3 = "   EEPROM NG   ";
  else
    v3 = "   EEPROM OK   ";
  write_lcd_no_memset(3u, (unsigned __int8 *)v3, 0x10u);
}

//----- (000176A8) --------------------------------------------------------
int __fastcall BHB91603_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r5
  int v3; // r7
  unsigned int v4; // r6
  unsigned int v5; // r4
  work *v6; // r3
  int result; // r0
  int v8; // r4
  work *v9; // r4
  int v10; // r11
  work *v11; // r0
  int v12; // r0
  int *v13; // r3
  int v14; // r10
  unsigned int v15; // r3
  pthread_mutex_t *mutex; // [sp+8h] [bp-30h]
  int ret; // [sp+Ch] [bp-2Ch]

  v2 = buf[1];
  v3 = which_chain;
  v4 = HIBYTE(v2) / gChain_Asic_Interval;
  v5 = HIWORD(*buf) & 0x7FFF;
  if ( (*buf & 0x40) != 0 )
    printf(
      "\n!!! %s: nonce crc error! nonce = 0x%08x, which_asic = %d, which_core = %d, which_pattern = %d\n",
      (const char *)_FUNCTION___8298,
      v2,
      HIBYTE(v2) / gChain_Asic_Interval,
      (unsigned __int8)v2,
      HIWORD(*buf) & 0x7FFF);
  if ( v4 >= BHB91603_ASIC_NUMBER || v5 >= Conf.pattern_number )
    return -1;
  v6 = &cgpu.works[v4][v5 + Conf.pattern_number * (unsigned __int8)v2];
  if ( v2 == v6->nonce )
  {
    v13 = &v6->id + v3;
    result = v13[13];
    if ( result )
    {
      v13[13] = result + 1;
      result = 0;
      ++gRepeated_Nonce_Id[v3];
    }
    else
    {
      v14 = (unsigned __int8)v2 + ((v4 + (v3 << 7)) << 10);
      v13[13] = 1;
      v15 = gAsic_Core_Nonce_Num[0][0][v14] + 1;
      ++gValid_Nonce_Num[v3];
      gAsic_Core_Nonce_Num[0][0][v14] = v15;
    }
  }
  else
  {
    if ( gHw_Nonce_Num[v3] > Conf.Most_HW_Num )
      return 0;
    mutex = &HW_check_mutex[v3];
    pthread_mutex_lock(mutex);
    v8 = gWork_Num_For_Hw_Check;
    if ( gWork_Num_For_Hw_Check )
    {
      v9 = gWorks_For_Hw_Check[v3];
      v10 = 0;
      do
      {
        v11 = v9;
        ++v10;
        ++v9;
        v12 = check_hw(v11, v2, 0);
        if ( !v12 )
        {
          pthread_mutex_unlock(mutex);
          return 0;
        }
      }
      while ( gWork_Num_For_Hw_Check > v10 );
      ret = v12;
      pthread_mutex_unlock(mutex);
      if ( ret == 1 )
      {
        ++gHw_Nonce_Num[v3];
        printf(
          "%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n",
          (const char *)_FUNCTION___8298,
          v3,
          v4,
          (unsigned __int8)v2,
          v2);
      }
      return 0;
    }
    pthread_mutex_unlock(mutex);
    return v8;
  }
  return result;
}

//----- (00017864) --------------------------------------------------------
int __fastcall BHB91603_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r4
  unsigned int v3; // r7
  reg_buf *v4; // r2
  char *v5; // r0
  unsigned int v6; // r1
  unsigned int reg_value_num; // r3

  v2 = *buf;
  v3 = buf[1];
  if ( reg_value_buf->reg_value_num > 0x1FE )
  {
    printf("%s: reg_value_buf buffer is full!\n", (const char *)_FUNCTION___8307);
    return -1;
  }
  else if ( (v2 & 0x40) != 0 )
  {
    printf("%s: reg crc error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8307, *buf, buf[1]);
    return -1;
  }
  else if ( (v2 & 0x20000000) != 0 )
  {
    printf("%s: REG_TYPE error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8307, *buf, buf[1]);
    return -1;
  }
  else
  {
    pthread_mutex_lock(&reg_mutex);
    v4 = reg_value_buf;
    v5 = (char *)v4 + 8 * v4->p_wr;
    v6 = reg_value_buf->p_wr + 1;
    *((_DWORD *)v5 + 4) = v3;
    v5[22] = HIBYTE(v2) & 0x1F;
    v5[20] = BYTE2(v2);
    v5[23] = v2 & 0xF;
    v5[21] = BYTE1(v2);
    reg_value_num = v4->reg_value_num;
    v4->p_wr = v6;
    if ( v6 >= 0x200 )
      v4->p_wr = 0;
    v4->reg_value_num = reg_value_num + 1;
    pthread_mutex_unlock(&reg_mutex);
    return 0;
  }
}

//----- (0001791C) --------------------------------------------------------
void *__fastcall BHB91603_receive_func(void *arg)
{
  int v1; // r8
  int v2; // r5
  int priority_max; // r4
  pthread_t v4; // r6
  unsigned int v5; // r4
  void *result; // r0
  unsigned int v7; // r5
  sched_param sp; // [sp+4h] [bp-24h] BYREF
  unsigned int buf[2]; // [sp+8h] [bp-20h] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  buf[0] = 0;
  buf[1] = 0;
  priority_max = sched_get_priority_max(1);
  sp.__sched_priority = priority_max;
  v4 = pthread_self();
  if ( !pthread_setschedparam(v4, 1, &sp) )
    printf("\n--- %s: IO Thread #%lx using %d priority scheduler! ", (const char *)_FUNCTION___8371, v4, priority_max);
  printf("\n--- %s: which_chain = %d, which_i2c = %d\n\n", (const char *)_FUNCTION___8371, v1, v2);
  while ( 1 )
  {
    result = (void *)start_receive;
    if ( !start_receive )
      break;
    usleep(0x3E8u);
    v5 = read_axi_fpga(6u) & 0x1FF;
    if ( v5 )
    {
      v7 = 0;
      do
      {
        get_return_nonce(buf);
        if ( BM1391_is_nonce_or_reg_value(buf[0]) )
        {
          if ( gBegin_Get_Nonce )
          {
            if ( BM1391_check_nonce_flag(buf[0]) )
              BHB91603_check_nonce(v1, buf);
          }
        }
        else
        {
          BHB91603_check_register_value(v1, buf);
        }
        ++v7;
      }
      while ( v5 > v7 );
    }
  }
  return result;
}

//----- (000179E8) --------------------------------------------------------
void singleBoardTest_BHB91603_BM1391()
{
  unsigned int axi_fpga; // r0
  unsigned int v1; // r0
  unsigned int i; // r8
  unsigned int v3; // r9
  unsigned int result; // r0
  unsigned int v5; // r5
  _BOOL4 linea; // [sp+0h] [bp-40h]
  unsigned __int8 line; // [sp+0h] [bp-40h]
  unsigned __int8 lcd_display_buf[16]; // [sp+8h] [bp-38h] BYREF

  memset(lcd_display_buf, 32, sizeof(lcd_display_buf));
  printf("\nBegin %s test\n", (const char *)_FUNCTION___8385);
  system("date");
  putchar(10);
  memset(lcd_output, 32, sizeof(lcd_output));
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  set_fpga_baud(0x1Au);
  write_axi_fpga(0x3Eu, 0);
  axi_fpga = read_axi_fpga(0);
  write_axi_fpga(0, axi_fpga | 0x40000000);
  reset_BHB91603_global_arg();
  check_chain();
  if ( gChain == 255 )
  {
    write_lcd(1u, " no hash board  ", 0x10u);
    puts("\nNo hash board, please plug in it");
    return;
  }
  if ( pthread_create(&cgpu.show_id, 0, BHB91603_show_status_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "   Creat show   ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1391_show_status_func fail\n\n\n", (const char *)_FUNCTION___8385);
    return;
  }
  gEEPROM_error = 0;
  pthread_mutex_init(&i2c_mutex, 0);
  if ( Test_EEPROM_part_area() )
  {
    printf("\n!!! %s: Check EEPROM error!!!\n\n", (const char *)_FUNCTION___8385);
    gEEPROM_error = 1;
  }
  else
  {
    printf("\n--- %s: Check EEPROM ok!!!\n", (const char *)_FUNCTION___8385);
  }
  write_axi_fpga(0xDu, 0xFFFFu);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  reset_dsPIC33EP16GS202_pic(gChain, gI2c);
  jump_from_loader_to_app_dsPIC33EP16GS202(gChain, gI2c);
  if ( pthread_create(&cgpu.pic_heart_beat_id, 0, pic_heart_beat_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(cgpu.pic_heart_beat_id);
    pthread_mutex_unlock(&i2c_mutex);
    write_lcd(0, "Creat heart beat", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create pic_heart_beat_func fail\n\n\n", (const char *)_FUNCTION___8385);
    return;
  }
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  if ( !set_pre_open_core_voltage(gChain, gI2c) )
  {
    enable_dsPIC33EP16GS202_clamping_voltage(gChain, gI2c, 0);
    write_axi_fpga(0xDu, 0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
    start_receive = 1;
    usleep(0x2710u);
    if ( pthread_create(&cgpu.receive_id, 0, BHB91603_receive_func, &chain_info_0[gChain]) )
    {
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      pthread_cancel(cgpu.receive_id);
      write_lcd(0, "  Creat receive ", 0x10u);
      write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
      write_lcd_no_memset(3u, "   test again   ", 0x10u);
      printf("\n!!!%s: create BHB91603_receive_func fail\n\n\n", (const char *)_FUNCTION___8385);
      return;
    }
    v1 = read_axi_fpga(0x40u);
    write_axi_fpga(0x40u, v1 & 0xFFFF7E1F | 0x8100);
    printf(
      "\n---%s: Conf.OpenCoreNum1 = %d, Conf.OpenCoreNum2 = %d\n",
      (const char *)_FUNCTION___8385,
      Conf.OpenCoreNum1,
      Conf.OpenCoreNum2);
    if ( Conf.OpenCoreNum1 )
    {
      for ( i = 0; Conf.OpenCoreNum1 > i; ++i )
      {
        if ( gHashBoard_BHB91603P )
        {
          BHB91603_P_pre_open_core(gChain);
        }
        else
        {
          if ( !gHashBoard_BHB91603S )
          {
            linea = gHashBoard_BHB91603S;
            pthread_cancel(cgpu.show_id);
            pthread_mutex_lock(&i2c_mutex);
            pthread_cancel(cgpu.pic_heart_beat_id);
            pthread_mutex_unlock(&i2c_mutex);
            pthread_cancel(cgpu.receive_id);
            write_lcd(linea, "     Config     ", 0x10u);
            goto LABEL_27;
          }
          BHB91603_S_pre_open_core(gChain);
          usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
        }
      }
    }
    puts("\n--- BHB91603 check asic number");
    check_BM1391_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: J%d has asicNum = %d\n", gChain + 1, cgpu.chain_asic_num[gChain]);
    if ( cgpu.chain_asic_num[gChain] != BHB91603_ASIC_NUMBER )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
      write_lcd(0, "   Only have    ", 0x10u);
      write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
      write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
      printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8385, cgpu.chain_asic_num[gChain]);
      puts("----------------------------\n\n");
      sleep(Conf.close_power_delay);
LABEL_25:
      enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
      power_off();
      return;
    }
    BHB91603_set_baud(gChain, 0);
    reset_hash_board();
    set_fpga_baud(0x1Au);
    cgpu.chain_asic_num[gChain] = 0;
    puts("\n--- double check asic number");
    check_BM1391_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: J%d has asicNum = %d\n", gChain + 1, cgpu.chain_asic_num[gChain]);
    if ( cgpu.chain_asic_num[gChain] != BHB91603_ASIC_NUMBER )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
      write_lcd(0, "   Only have    ", 0x10u);
      write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
      write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
      printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8385, cgpu.chain_asic_num[gChain]);
      puts("----------------------------\n\n");
LABEL_30:
      sleep(Conf.close_power_delay);
      goto LABEL_25;
    }
    line = cgpu.Only_find_ASIC;
    if ( cgpu.Only_find_ASIC )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      write_lcd(1u, " find all ASIC  ", 0x10u);
      write_lcd_no_memset(2u, "       OK       ", 0x10u);
      printf("\nFind %d ASIC, OK\n", BHB91603_ASIC_NUMBER);
      goto LABEL_30;
    }
    BHB91603_calculate_timeout_and_baud();
    set_BM1391_freq(gChain, line, Conf.Freq, 1);
    BHB91603_set_address(gChain);
    BHB91603_set_baud(gChain, cgpu.baud);
    BM1391_set_TM(gChain, line, 0x3Fu, 1);
    write_axi_fpga(0x22u, Conf.timeout | 0x80000000);
    usleep(0x2710u);
    BM1391_soft_reset_sensor(gChain);
    BM1391_enable_extended_mode_of_temperature_sensor(gChain);
    gIsReadTemp = 1;
    if ( gHashBoard_BHB91603P )
    {
      BHB91603_P_open_core(gChain);
    }
    else
    {
      v3 = gHashBoard_BHB91603S;
      if ( !gHashBoard_BHB91603S )
      {
        pthread_cancel(cgpu.show_id);
        pthread_mutex_lock(&i2c_mutex);
        pthread_cancel(cgpu.pic_heart_beat_id);
        pthread_mutex_unlock(&i2c_mutex);
        pthread_cancel(cgpu.receive_id);
        write_lcd(v3, "     Config     ", 0x10u);
LABEL_27:
        write_lcd_no_memset(1u, " Hashboard Type ", 0x10u);
        write_lcd_no_memset(2u, " in Config.ini  ", 0x10u);
        printf("\n!!!%s: Can't find Hashboard type when open core, fail\n\n\n", (const char *)_FUNCTION___8385);
        goto LABEL_25;
      }
      BHB91603_S_open_core(gChain);
    }
    adjust_voltage(gChain, gI2c);
    puts("\nBegin send test pattern");
    if ( !gStartTest )
    {
      if ( time_counter >= Conf.HeatingUpTime )
      {
LABEL_45:
        pthread_cancel(cgpu.receive_id);
        pthread_cancel(cgpu.show_id);
        pthread_mutex_lock(&i2c_mutex);
        pthread_cancel(cgpu.pic_heart_beat_id);
        pthread_mutex_unlock(&i2c_mutex);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, "Can't open core ", 0x10u);
        write_lcd_no_memset(1u, "change  to  next", 0x10u);
        write_lcd_no_memset(2u, (unsigned __int8 *)"voltage and freq", 0x10u);
        ++pattern_test_time;
        enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
        power_off();
        return;
      }
      while ( 1 )
      {
        usleep(0x2710u);
        if ( gStartTest )
          break;
        if ( Conf.HeatingUpTime <= time_counter )
          goto LABEL_45;
      }
    }
    if ( pthread_create(&cgpu.send_id, 0, BHB91603_send_func, &chain_info_0[gChain]) )
    {
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      pthread_cancel(cgpu.receive_id);
      write_lcd(0, "   Creat send   ", 0x10u);
      write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
      write_lcd_no_memset(3u, "   test again   ", 0x10u);
      printf("\n!!!%s: create BHB91603_send_func fail\n\n\n", (const char *)_FUNCTION___8385);
      goto LABEL_25;
    }
    pthread_join(cgpu.send_id, 0);
    pthread_join(cgpu.receive_id, 0);
    pthread_cancel(cgpu.show_id);
    result = BHB91603_get_result(gChain);
    v5 = result;
    if ( (result & 1) != 0 )
    {
      if ( gEEPROM_error )
      {
        printf("\n!!!%s: Don't save data into EEPROM, because EEPROM test fail!!\n\n", (const char *)_FUNCTION___8385);
      }
      else if ( BHB91603_AT24C02_write_total_data(gI2c, gChain) )
      {
        puts("\nEEPROM OK\n");
      }
      else
      {
        puts("\nEEPROM NG\n");
      }
      BHB91603_print_lcd(v5);
      sleep(Conf.close_power_delay);
    }
    else
    {
      BHB91603_print_lcd(result);
      sleep(Conf.close_power_delay);
      if ( pattern_test_time < (unsigned int)gHowManyVoltageLevel )
        goto LABEL_52;
    }
    enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
    power_off();
LABEL_52:
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(cgpu.pic_heart_beat_id);
    pthread_mutex_unlock(&i2c_mutex);
    set_fan_speed(0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  }
}

//----- (000183E4) --------------------------------------------------------
void read_config()
{
  FILE *v0; // r5
  char *v1; // r0
  char *v2; // r1
  int v3; // r2
  char *v4; // r0
  int v5; // r3
  char v6; // t1
  int v7; // t1
  bool v8; // zf
  unsigned int v9; // lr
  int v10; // r0
  unsigned int AsicNum; // r5
  int v12; // r2
  char *v13; // r0
  unsigned int AsicType; // r5
  char *v15; // r0
  char *v16; // r0
  char *v17; // r0
  char *v18; // r0
  char *v19; // r0
  char *v20; // r0
  char *v21; // r0
  char *v22; // r0
  char *v23; // r0
  char *v24; // r0
  char *v25; // r0
  char *v26; // r0
  char *v27; // r0
  char *v28; // r0
  char *v29; // r0
  char *v30; // r0
  char *v31; // r0
  char *v32; // r0
  char *v33; // r0
  char *v34; // r0
  char *v35; // r0
  char *v36; // r0
  char *v37; // r0
  char *v38; // r0
  char *v39; // r0
  char *v40; // r0
  char *v41; // r0
  char *v42; // r0
  char *v43; // r0
  char *v44; // r0
  char *v45; // r0
  char *v46; // r0
  unsigned int v47; // r2
  char *v48; // r0
  char *v49; // r0
  char *v50; // r0
  char *v51; // r0
  char *v52; // r0
  char *v53; // r0
  char *v54; // r0
  int v55; // r1
  char *v56; // r0
  char *v57; // r0
  char *v58; // r0
  char *v59; // r0
  char *v60; // r0
  char *v61; // r0
  char *v62; // r0
  char *v63; // r0
  char *v64; // r0
  char *v65; // r0
  char *v66; // r0
  char *v67; // r0
  char *v68; // r0
  char *v69; // r0
  char *v70; // r0
  char *v71; // r0
  char *v72; // r0
  char *v73; // r0
  char *v74; // r0
  char *v75; // r0
  char *v76; // r0
  char *v77; // r0
  unsigned int io_strength; // r3
  char *v79; // r0
  char *v80; // r0
  char *v81; // r0
  char *v82; // r0
  char *v83; // r0
  unsigned __int8 *temp; // [sp+Ch] [bp-434h]
  int starttemp; // [sp+14h] [bp-42Ch] BYREF
  unsigned __int8 str[1024]; // [sp+18h] [bp-428h] BYREF

  memset(str, 0, sizeof(str));
  starttemp = 0;
  v0 = fopen("/mnt/card/Config.ini", "r");
LABEL_2:
  while ( fgets((char *)str, 1023, v0) )
  {
    while ( 1 )
    {
      if ( str[0] == 35 || str[1] == 35 )
        goto LABEL_2;
      v1 = strstr((const char *)str, "Name=");
      if ( !v1 )
        break;
      v2 = (char *)&reg_value_buf + 3;
      v3 = 0;
      v6 = v1[5];
      v4 = v1 + 5;
      LOBYTE(v5) = v6;
      do
      {
        *++v2 = v5;
        ++v3;
        v7 = (unsigned __int8)*++v4;
        v5 = v7;
        v8 = v7 == 13;
        if ( v7 != 13 )
          v8 = v5 == 10;
        if ( v8 )
        {
          v9 = v3;
          goto LABEL_13;
        }
      }
      while ( v3 != 64 );
      v9 = 65;
      v3 = 65;
LABEL_13:
      Conf.name[v3] = 0;
      v10 = *(_DWORD *)Conf.name;
      gHashBoard_BHB91601P = 0;
      gHashBoard_BHB91603S = 0;
      gHashBoard_V9 = 0;
      gHashBoard_BHB91601S = 0;
      gName_len = v9;
      if ( *(_DWORD *)Conf.name != 960645186 )
        goto LABEL_14;
      v12 = *(_DWORD *)&Conf.name[4];
      if ( *(_DWORD *)&Conf.name[4] == 825243185 )
      {
        if ( Conf.name[8] != 80 )
          goto LABEL_41;
        gHashBoard_BHB91601P = 1;
        printf("\n---%s: gHashBoard_BHB91601P\n\n", (const char *)_FUNCTION___8218);
        v10 = *(_DWORD *)Conf.name;
        if ( *(_DWORD *)Conf.name != 960645186 )
          goto LABEL_14;
        v12 = *(_DWORD *)&Conf.name[4];
        if ( *(_DWORD *)&Conf.name[4] == 825243185 )
        {
LABEL_41:
          if ( Conf.name[8] != 83 )
            goto LABEL_15;
          gHashBoard_BHB91601S = 1;
          printf("\n---%s: gHashBoard_BHB91601S\n\n", (const char *)_FUNCTION___8218);
          v10 = *(_DWORD *)Conf.name;
          if ( *(_DWORD *)Conf.name != 960645186 )
            goto LABEL_14;
          v12 = *(_DWORD *)&Conf.name[4];
        }
      }
      if ( v12 == 858797617 && Conf.name[8] == 83 )
      {
        gHashBoard_BHB91603S = 1;
        printf("\n---%s: gHashBoard_BHB91603S\n\n", (const char *)_FUNCTION___8218);
        v10 = *(_DWORD *)Conf.name;
LABEL_14:
        if ( v10 == 809650242 && *(_DWORD *)&Conf.name[4] == 825243191 )
        {
          gHashBoard_BHB07601 = 1;
          printf("\n---%s: gHashBoard_BHB07601\n\n", (const char *)_FUNCTION___8218);
        }
      }
LABEL_15:
      if ( *(unsigned __int16 *)Conf.name != 14678 )
        goto LABEL_2;
      gHashBoard_V9 = 1;
      printf("\n---%s: gHashBoard_V9\n\n", (const char *)_FUNCTION___8218);
      if ( !fgets((char *)str, 1023, v0) )
        goto LABEL_17;
    }
    v13 = strstr((const char *)str, "pattern_number=");
    if ( v13 )
    {
      _isoc99_sscanf(v13 + 15, "%d", &Conf.pattern_number);
      gPattern_number = Conf.pattern_number;
      printf("gPattern_number = %d\n", Conf.pattern_number);
      goto LABEL_2;
    }
    v15 = strstr((const char *)str, "AsicNum=");
    if ( v15 )
    {
      _isoc99_sscanf(v15 + 8, "%d", &Conf.AsicNum);
      if ( Conf.AsicNum == 1 )
        gChain_Asic_Interval = 256;
    }
    else
    {
      v16 = strstr((const char *)str, "AsicType=");
      if ( v16 )
      {
        _isoc99_sscanf(v16 + 9, "%x", &Conf.AsicType);
        goto LABEL_2;
      }
      v17 = strstr((const char *)str, "Freq1=");
      if ( v17 )
      {
        _isoc99_sscanf(v17 + 6, "%d", &Conf.Freq1);
        goto LABEL_2;
      }
      v18 = strstr((const char *)str, "Freq2=");
      if ( v18 )
      {
        _isoc99_sscanf(v18 + 6, "%d", &Conf.Freq2);
        goto LABEL_2;
      }
      v19 = strstr((const char *)str, "Freq3=");
      if ( v19 )
      {
        _isoc99_sscanf(v19 + 6, "%d", &Conf.Freq3);
        goto LABEL_2;
      }
      v20 = strstr((const char *)str, "Freq4=");
      if ( v20 )
      {
        _isoc99_sscanf(v20 + 6, "%d", &Conf.Freq4);
        goto LABEL_2;
      }
      v21 = strstr((const char *)str, "Freq5=");
      if ( v21 )
      {
        _isoc99_sscanf(v21 + 6, "%d", &Conf.Freq5);
        goto LABEL_2;
      }
      v22 = strstr((const char *)str, "Freq6=");
      if ( v22 )
      {
        _isoc99_sscanf(v22 + 6, "%d", &Conf.Freq6);
        goto LABEL_2;
      }
      v23 = strstr((const char *)str, "Freq7=");
      if ( v23 )
      {
        _isoc99_sscanf(v23 + 6, "%d", &Conf.Freq7);
        goto LABEL_2;
      }
      v24 = strstr((const char *)str, "Freq8=");
      if ( v24 )
      {
        _isoc99_sscanf(v24 + 6, "%d", &Conf.Freq8);
        goto LABEL_2;
      }
      v25 = strstr((const char *)str, "Freq9=");
      if ( v25 )
      {
        _isoc99_sscanf(v25 + 6, "%d", &Conf.Freq9);
        goto LABEL_2;
      }
      v26 = strstr((const char *)str, "Voltage1=");
      if ( v26 )
      {
        _isoc99_sscanf(v26 + 9, "%d", &Conf.Voltage1);
        if ( Conf.Voltage1 )
          ++gHowManyVoltageLevel;
        printf("Voltage1 = %d\n", Conf.Voltage1);
      }
      else
      {
        v27 = strstr((const char *)str, "Voltage2=");
        if ( v27 )
        {
          _isoc99_sscanf(v27 + 9, "%d", &Conf.Voltage2);
          if ( !Conf.Voltage2 )
            goto LABEL_2;
          goto LABEL_91;
        }
        v28 = strstr((const char *)str, "Voltage3=");
        if ( v28 )
        {
          _isoc99_sscanf(v28 + 9, "%d", &Conf.Voltage3);
          if ( !Conf.Voltage3 )
            goto LABEL_2;
          goto LABEL_91;
        }
        v29 = strstr((const char *)str, "Voltage4=");
        if ( v29 )
        {
          _isoc99_sscanf(v29 + 9, "%d", &Conf.Voltage4);
          if ( !Conf.Voltage4 )
            goto LABEL_2;
          goto LABEL_91;
        }
        v30 = strstr((const char *)str, "Voltage5=");
        if ( v30 )
        {
          _isoc99_sscanf(v30 + 9, "%d", &Conf.Voltage5);
          if ( !Conf.Voltage5 )
            goto LABEL_2;
          goto LABEL_91;
        }
        v31 = strstr((const char *)str, "Voltage6=");
        if ( v31 )
        {
          _isoc99_sscanf(v31 + 9, "%d", &Conf.Voltage6);
          if ( !Conf.Voltage6 )
            goto LABEL_2;
          goto LABEL_91;
        }
        v32 = strstr((const char *)str, "Voltage7=");
        if ( v32 )
        {
          _isoc99_sscanf(v32 + 9, "%d", &Conf.Voltage7);
          if ( !Conf.Voltage7 )
            goto LABEL_2;
          goto LABEL_91;
        }
        v33 = strstr((const char *)str, "Voltage8=");
        if ( v33 )
        {
          _isoc99_sscanf(v33 + 9, "%d", &Conf.Voltage8);
          if ( !Conf.Voltage8 )
            goto LABEL_2;
          goto LABEL_91;
        }
        v34 = strstr((const char *)str, "Voltage9=");
        if ( v34 )
        {
          _isoc99_sscanf(v34 + 9, "%d", &Conf.Voltage9);
          if ( !Conf.Voltage9 )
            goto LABEL_2;
LABEL_91:
          ++gHowManyVoltageLevel;
          goto LABEL_2;
        }
        v35 = strstr((const char *)str, "Voltage_accuracy=");
        if ( v35 )
        {
          _isoc99_sscanf(v35 + 17, "%d", &Conf.Voltage_accuracy);
          goto LABEL_2;
        }
        v36 = strstr((const char *)str, "OpenCoreGap=");
        if ( v36 )
        {
          _isoc99_sscanf(v36 + 12, "%d", &Conf.OpenCoreGap);
          goto LABEL_2;
        }
        v37 = strstr((const char *)str, "CheckTemp=");
        if ( v37 )
        {
          _isoc99_sscanf(v37 + 10, "%d", &Conf.checktemp);
          goto LABEL_2;
        }
        v38 = strstr((const char *)str, "Open_Core_Num1=");
        if ( v38 )
        {
          _isoc99_sscanf(v38 + 15, "%x", &Conf.OpenCoreNum1);
          goto LABEL_2;
        }
        v39 = strstr((const char *)str, "Open_Core_Num2=");
        if ( v39 )
        {
          _isoc99_sscanf(v39 + 15, "%x", &Conf.OpenCoreNum2);
          goto LABEL_2;
        }
        v40 = strstr((const char *)str, "Open_Core_Num3=");
        if ( v40 )
        {
          _isoc99_sscanf(v40 + 15, "%x", &Conf.OpenCoreNum3);
          goto LABEL_2;
        }
        v41 = strstr((const char *)str, "Open_Core_Num4=");
        if ( v41 )
        {
          _isoc99_sscanf(v41 + 15, "%x", &Conf.OpenCoreNum4);
          goto LABEL_2;
        }
        v42 = strstr((const char *)str, "Open_Core_Num5=");
        if ( v42 )
        {
          _isoc99_sscanf(v42 + 15, "%x", &Conf.OpenCoreNum5);
          goto LABEL_2;
        }
        v43 = strstr((const char *)str, "Open_Core_Num6=");
        if ( v43 )
        {
          _isoc99_sscanf(v43 + 15, "%x", &Conf.OpenCoreNum6);
          goto LABEL_2;
        }
        v44 = strstr((const char *)str, "Open_Core_Num7=");
        if ( v44 )
        {
          _isoc99_sscanf(v44 + 15, "%x", &Conf.OpenCoreNum7);
          goto LABEL_2;
        }
        v45 = strstr((const char *)str, "Open_Core_Num8=");
        if ( v45 )
        {
          _isoc99_sscanf(v45 + 15, "%x", &Conf.OpenCoreNum8);
          goto LABEL_2;
        }
        v46 = strstr((const char *)str, "sensor_model=");
        if ( v46 )
        {
          _isoc99_sscanf(v46 + 13, "%d", &Conf.sensor_model);
          if ( Conf.sensor_model == 6 )
          {
            gSensor_i2c_addr_high_4_bit = 10092544;
          }
          else
          {
            if ( Conf.sensor_model == 7 )
              v47 = 10223616;
            else
              v47 = 9961472;
            gSensor_i2c_addr_high_4_bit = v47;
          }
        }
        else
        {
          v48 = strstr((const char *)str, "remote_local_gap=");
          if ( v48 )
          {
            _isoc99_sscanf(v48 + 17, "%ud", &Conf.remote_local_gap);
            goto LABEL_2;
          }
          v49 = strstr((const char *)str, "TempSensor1=");
          if ( v49 )
          {
            _isoc99_sscanf(v49 + 12, "%d", &Conf.TempSensor1);
            if ( !Conf.TempSensor1 )
              goto LABEL_2;
            goto LABEL_146;
          }
          v50 = strstr((const char *)str, "TempSensor2=");
          if ( v50 )
          {
            _isoc99_sscanf(v50 + 12, "%d", &Conf.TempSensor2);
            if ( !Conf.TempSensor2 )
              goto LABEL_2;
            goto LABEL_146;
          }
          v51 = strstr((const char *)str, "TempSensor3=");
          if ( v51 )
          {
            _isoc99_sscanf(v51 + 12, "%d", &Conf.TempSensor3);
            if ( !Conf.TempSensor3 )
              goto LABEL_2;
            goto LABEL_146;
          }
          v52 = strstr((const char *)str, "TempSensor4=");
          if ( v52 )
          {
            _isoc99_sscanf(v52 + 12, "%d", &Conf.TempSensor4);
            if ( !Conf.TempSensor4 )
              goto LABEL_2;
LABEL_146:
            ++gSensor_number;
            goto LABEL_2;
          }
          v53 = strstr((const char *)str, "StartSensor=");
          if ( v53 )
          {
            _isoc99_sscanf(v53 + 12, "%d", &Conf.StartSensor);
          }
          else
          {
            v54 = strstr((const char *)str, "StartTemp=");
            if ( v54 )
            {
              temp = (unsigned __int8 *)(v54 + 10);
              _isoc99_sscanf(v54 + 10, "%d", &Conf.StartTemp);
              _isoc99_sscanf(temp, "%d", &starttemp);
              v55 = starttemp;
              if ( starttemp < 0 )
              {
                starttemp = -starttemp;
                v55 = -(char)starttemp;
              }
              Conf.StartTemp = v55;
              printf("StartTemp = %d\n");
            }
            else
            {
              v56 = strstr((const char *)str, "TargetTemp=");
              if ( v56 )
              {
                _isoc99_sscanf(v56 + 11, "%d", &Conf.TargetTemp);
                printf("TargetTemp = %d\n", Conf.TargetTemp);
              }
              else
              {
                v57 = strstr((const char *)str, "add_voltage_after_test_ok=");
                if ( v57 )
                {
                  _isoc99_sscanf(v57 + 26, "%d", &Conf.add_voltage_after_test_ok);
                }
                else
                {
                  v58 = strstr((const char *)str, "add_voltage_value=");
                  if ( v58 )
                  {
                    _isoc99_sscanf(v58 + 18, "%d", &Conf.add_voltage_value);
                  }
                  else
                  {
                    v59 = strstr((const char *)str, "AlarmTemp=");
                    if ( v59 )
                    {
                      _isoc99_sscanf(v59 + 10, "%d", &Conf.AlarmTemp);
                      printf("AlarmTemp = %d\n", Conf.AlarmTemp);
                    }
                    else
                    {
                      v60 = strstr((const char *)str, "HeatingUpTime=");
                      if ( v60 )
                      {
                        _isoc99_sscanf(v60 + 14, "%d", &Conf.HeatingUpTime);
                      }
                      else
                      {
                        v61 = strstr((const char *)str, "MaxTempGap=");
                        if ( v61 )
                        {
                          _isoc99_sscanf(v61 + 11, "%d", &Conf.MaxTempGap);
                        }
                        else
                        {
                          v62 = strstr((const char *)str, "Invalid_Asic_Num=");
                          if ( v62 )
                          {
                            _isoc99_sscanf(v62 + 17, "%d", &Conf.Invalid_Asic_Num);
                            printf("Invalid_Asic_Num = %d\n", Conf.Invalid_Asic_Num);
                          }
                          else
                          {
                            v63 = strstr((const char *)str, "Invalid_Core_Num=");
                            if ( v63 )
                            {
                              _isoc99_sscanf(v63 + 17, "%d", &Conf.Invalid_Core_Num);
                              printf("Invalid_Core_Num = %d\n", Conf.Invalid_Core_Num);
                            }
                            else
                            {
                              v64 = strstr((const char *)str, "Least_nonce_per_core=");
                              if ( v64 )
                              {
                                _isoc99_sscanf(v64 + 21, "%d", &Conf.Least_nonce_per_core);
                                printf("Least_nonce_per_core = %d\n", Conf.Least_nonce_per_core);
                              }
                              else
                              {
                                v65 = strstr((const char *)str, "Most_HW_Num=");
                                if ( v65 )
                                {
                                  _isoc99_sscanf(v65 + 12, "%d", &Conf.Most_HW_Num);
                                  printf("Most_HW_Num = %d\n", Conf.Most_HW_Num);
                                }
                                else
                                {
                                  v66 = strstr((const char *)str, "close_power_delay=");
                                  if ( v66 )
                                  {
                                    _isoc99_sscanf(v66 + 18, "%d", &Conf.close_power_delay);
                                  }
                                  else
                                  {
                                    v67 = strstr((const char *)str, "fan_speed=");
                                    if ( v67 )
                                    {
                                      _isoc99_sscanf(v67 + 10, "%d", &Conf.fan_speed);
                                      cgpu.fan_speed = Conf.fan_speed;
                                      printf("fan_speed = %d\n", Conf.fan_speed);
                                    }
                                    else
                                    {
                                      v68 = strstr((const char *)str, "HashBoard_Hardware_Version_1=");
                                      if ( v68 )
                                      {
                                        _isoc99_sscanf(v68 + 29, "%d", &Conf.HashBoard_Hardware_Version_1);
                                        printf("HashBoard_Hardware_Version_1 = %d\n", Conf.HashBoard_Hardware_Version_1);
                                      }
                                      else
                                      {
                                        v69 = strstr((const char *)str, "HashBoard_Hardware_Version_2=");
                                        if ( v69 )
                                        {
                                          _isoc99_sscanf(v69 + 29, "%d", &Conf.HashBoard_Hardware_Version_2);
                                          printf(
                                            "HashBoard_Hardware_Version_2 = %d\n",
                                            Conf.HashBoard_Hardware_Version_2);
                                        }
                                        else
                                        {
                                          v70 = strstr((const char *)str, "HashBoard_Bom_Version_1=");
                                          if ( v70 )
                                          {
                                            _isoc99_sscanf(v70 + 24, "%d", &Conf.HashBoard_Bom_Version_1);
                                            printf("HashBoard_Bom_Version_1 = %d\n", Conf.HashBoard_Bom_Version_1);
                                          }
                                          else
                                          {
                                            v71 = strstr((const char *)str, "HashBoard_Bom_Version_2=");
                                            if ( v71 )
                                            {
                                              _isoc99_sscanf(v71 + 24, "%d", &Conf.HashBoard_Bom_Version_2);
                                              printf("HashBoard_Bom_Version_2 = %d\n", Conf.HashBoard_Bom_Version_2);
                                            }
                                            else
                                            {
                                              v72 = strstr((const char *)str, "HashBoard_Product_ID=");
                                              if ( v72 )
                                              {
                                                _isoc99_sscanf(v72 + 21, "%d", &Conf.HashBoard_Product_ID);
                                                printf("HashBoard_Product_ID = %d\n", Conf.HashBoard_Product_ID);
                                              }
                                              else
                                              {
                                                v73 = strstr((const char *)str, "timeout_percent=");
                                                if ( v73 )
                                                {
                                                  _isoc99_sscanf(v73 + 16, "%d", &Conf.timeout_percent);
                                                  cgpu.timeout_percent = Conf.timeout_percent;
                                                  printf("timeout_percent = %d\n", LOBYTE(Conf.timeout_percent));
                                                }
                                                else
                                                {
                                                  v74 = strstr((const char *)str, "baudrate=");
                                                  if ( v74 )
                                                  {
                                                    _isoc99_sscanf(v74 + 9, "%d", &Conf.baud);
                                                    cgpu.baud = Conf.baud;
                                                    printf("baudrate = %d\n", LOBYTE(Conf.baud));
                                                  }
                                                  else
                                                  {
                                                    v75 = strstr((const char *)str, "Only_find_ASIC=");
                                                    if ( v75 )
                                                    {
                                                      _isoc99_sscanf(v75 + 15, "%d", &Conf.Only_find_ASIC);
                                                      cgpu.Only_find_ASIC = Conf.Only_find_ASIC;
                                                      printf("Only_find_ASIC = %d\n", LOBYTE(Conf.Only_find_ASIC));
                                                    }
                                                    else
                                                    {
                                                      v76 = strstr((const char *)str, "pre_open_core_voltage=");
                                                      if ( v76 )
                                                      {
                                                        _isoc99_sscanf(v76 + 22, "%d", &Conf.pre_open_core_voltage);
                                                        printf(
                                                          "pre_open_core_voltage = %d\n",
                                                          Conf.pre_open_core_voltage);
                                                      }
                                                      else
                                                      {
                                                        v77 = strstr((const char *)str, "io_strength=");
                                                        if ( v77 )
                                                        {
                                                          _isoc99_sscanf(v77 + 12, "%x", &Conf.io_strength);
                                                          io_strength = Conf.io_strength;
                                                          if ( !Conf.io_strength )
                                                          {
                                                            io_strength = 34677009;
                                                            Conf.io_strength = 34677009;
                                                          }
                                                          cgpu.io_strength = io_strength;
                                                          printf("io_strength = 0x%08x\n", io_strength);
                                                        }
                                                        else
                                                        {
                                                          v79 = strstr((const char *)str, "repair_mode=");
                                                          if ( v79 )
                                                          {
                                                            _isoc99_sscanf(v79 + 12, "%d", &Conf.repair_mode);
                                                            cgpu.repair_mode = Conf.repair_mode;
                                                            printf("repair_mode = %d\n", Conf.repair_mode);
                                                          }
                                                          else
                                                          {
                                                            v80 = strstr((const char *)str, "Dump_Lost_Nonce=");
                                                            if ( v80 )
                                                            {
                                                              _isoc99_sscanf(v80 + 16, "%d", &Conf.Dump_Lost_Nonce);
                                                              printf("Dump_Lost_Nonce = %d\n", Conf.Dump_Lost_Nonce);
                                                            }
                                                            else
                                                            {
                                                              v81 = strstr((const char *)str, "CoreClockDelay=");
                                                              if ( v81 )
                                                              {
                                                                _isoc99_sscanf(v81 + 15, "%x", &Conf.CoreClockDelay);
                                                                printf("CoreClockDelay = 0x%02x\n", Conf.CoreClockDelay);
                                                              }
                                                              else
                                                              {
                                                                v82 = strstr((const char *)str, "bad_chip_nonce_rate=");
                                                                if ( v82 )
                                                                {
                                                                  _isoc99_sscanf(
                                                                    v82 + 20,
                                                                    "%d",
                                                                    &Conf.bad_chip_nonce_rate);
                                                                  printf(
                                                                    "bad_chip_nonce_rate = %d\n",
                                                                    Conf.bad_chip_nonce_rate);
                                                                }
                                                                else
                                                                {
                                                                  v83 = strstr((const char *)str, "bad_chip_num=");
                                                                  if ( v83 )
                                                                  {
                                                                    _isoc99_sscanf(v83 + 13, "%d", &Conf.bad_chip_num);
                                                                    printf("bad_chip_num = %d\n", Conf.bad_chip_num);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_17:
  AsicNum = Conf.AsicNum;
  if ( Conf.AsicNum != 1 )
  {
    if ( !gHashBoard_V9 )
    {
      if ( gHashBoard_BHB91601P || gHashBoard_BHB91601S )
      {
        strcpy((char *)cgpu.workdataPathPrefix, (const char *)BHB91601_WorkDataPathPrefix);
        strcpy((char *)cgpu.workdataFilePrefix, (const char *)BTC_WorkDataFilePrefix);
        gPic_addr_high_4_bit = 0x400000;
        gChain_Asic_Interval = 3;
        Conf.CoreNum = 256;
        if ( AsicNum == 60 || AsicNum == 72 || AsicNum == 84 )
        {
          BHB91601_ASIC_NUMBER = AsicNum;
        }
        else
        {
LABEL_49:
          BHB91601_ASIC_NUMBER = 84;
          printf("\n!!! %s: Don't find AsicNum in Config.ini, please config it\n\n", (const char *)_FUNCTION___8218);
        }
      }
      goto LABEL_23;
    }
LABEL_46:
    strcpy((char *)cgpu.workdataPathPrefix, (const char *)V9_WorkDataPathPrefix);
    strcpy((char *)cgpu.workdataFilePrefix, (const char *)BTC_WorkDataFilePrefix);
    gPic_addr_high_4_bit = 10485760;
    gChain_Asic_Interval = 4;
    Conf.AsicNum = 45;
    Conf.CoreNum = 50;
    Conf.AsicType = 1385;
    if ( gHashBoard_BHB91601P || gHashBoard_BHB91601S )
    {
      strcpy((char *)cgpu.workdataPathPrefix, (const char *)BHB91601_WorkDataPathPrefix);
      strcpy((char *)cgpu.workdataFilePrefix, (const char *)BTC_WorkDataFilePrefix);
      Conf.CoreNum = 256;
      gPic_addr_high_4_bit = 0x400000;
      gChain_Asic_Interval = 3;
      goto LABEL_49;
    }
    goto LABEL_23;
  }
  AsicType = Conf.AsicType;
  if ( Conf.AsicType == 1385 )
  {
    strcpy((char *)cgpu.workdataPathPrefix, (const char *)Single_BM1385_WorkDataPathPrefix);
    strcpy((char *)cgpu.workdataFilePrefix, (const char *)BTC_WorkDataFilePrefix);
    Conf.CoreNum = 50;
    if ( gHashBoard_V9 )
      goto LABEL_46;
  }
  else
  {
    if ( gHashBoard_V9 )
      goto LABEL_46;
    if ( Conf.AsicType - 13911 <= 1 )
    {
      strcpy((char *)cgpu.workdataPathPrefix, (const char *)Single_BM1391_WorkDataPathPrefix);
      strcpy((char *)cgpu.workdataFilePrefix, (const char *)BTC_WorkDataFilePrefix);
      Conf.CoreNum = 256;
    }
    if ( AsicType == 5015 )
    {
      strcpy((char *)cgpu.workdataPathPrefix, (const char *)Single_BM1397_WorkDataPathPrefix);
      strcpy((char *)cgpu.workdataFilePrefix, (const char *)Single_BM1397_WorkDataFilePrefix);
      Conf.CoreNum = 672;
    }
  }
  if ( gHashBoard_BHB91601P || gHashBoard_BHB91601S )
  {
    strcpy((char *)cgpu.workdataPathPrefix, (const char *)BHB91601_WorkDataPathPrefix);
    strcpy((char *)cgpu.workdataFilePrefix, (const char *)BTC_WorkDataFilePrefix);
    gPic_addr_high_4_bit = 0x400000;
    gChain_Asic_Interval = 3;
    Conf.CoreNum = 256;
    goto LABEL_49;
  }
LABEL_23:
  if ( gHashBoard_BHB91603S )
  {
    strcpy((char *)cgpu.workdataPathPrefix, (const char *)BHB91603_WorkDataPathPrefix);
    strcpy((char *)cgpu.workdataFilePrefix, (const char *)BTC_WorkDataFilePrefix);
    gPic_addr_high_4_bit = 0x400000;
    gChain_Asic_Interval = 2;
    BHB91601_ASIC_NUMBER = 96;
    Conf.CoreNum = 256;
  }
  if ( gHashBoard_BHB07601 )
  {
    strcpy((char *)cgpu.workdataPathPrefix, (const char *)BHB07601_WorkDataPathPrefix);
    strcpy((char *)cgpu.workdataFilePrefix, (const char *)BHB07601_WorkDataFilePrefix);
    gPic_addr_high_4_bit = 0x400000;
    gChain_Asic_Interval = 5;
    BHB07601_ASIC_NUMBER = 48;
    Conf.CoreNum = 672;
  }
}
// 10B88: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00019638) --------------------------------------------------------
void *__fastcall __noreturn V9_show_status_func(void *arg)
{
  int v1; // r5
  int temperature_through_fpga_iic_register; // r4
  unsigned int which_i2c; // [sp+4h] [bp-34h]

  v1 = *(unsigned __int8 *)arg;
  which_i2c = *((unsigned __int8 *)arg + 1);
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    temperature_through_fpga_iic_register = read_temperature_through_fpga_iic_register(v1, which_i2c);
    sprintf((char *)lcd_output, "   time %ds", time_counter);
    sprintf((char *)lcd_output[1], "   nonce=%d", gValid_Nonce_Num[v1]);
    sprintf((char *)lcd_output[2], "   temp %d `C", temperature_through_fpga_iic_register);
    if ( temperature_through_fpga_iic_register > gHighest_Temp )
      gHighest_Temp = temperature_through_fpga_iic_register;
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( temperature_through_fpga_iic_register >= Conf.StartTemp )
    {
      if ( !gStartTest )
        printf("\nBegin test!!! Hash Board temperature is %d\n", temperature_through_fpga_iic_register);
      gStartTest = 1;
    }
    else if ( !gStartTest )
    {
      printf(
        "\nHash Board temperature is %d, waiting it raise to start temperature %d\n",
        temperature_through_fpga_iic_register,
        Conf.StartTemp);
    }
    set_fan_speed(0);
    printf(
      "\nChain%d get valid nonce number : %d. temperature is %d\n",
      v1,
      gValid_Nonce_Num[v1],
      temperature_through_fpga_iic_register);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  }
}

//----- (00019758) --------------------------------------------------------
void *__fastcall V9_send_func(void *arg)
{
  int v1; // r11
  unsigned int pattern_number; // r2
  unsigned int v3; // r7
  unsigned __int8 *v4; // r3
  work *v5; // r6
  unsigned __int8 *v6; // r2
  unsigned __int8 v7; // t1
  unsigned int nonce; // r1
  unsigned __int8 *v9; // r3
  unsigned __int8 *v10; // r2
  unsigned __int8 v11; // t1
  work *v12; // r0
  work (*v13)[128]; // r8
  unsigned int v14; // r3
  unsigned int v15; // r3
  unsigned int v16; // r2
  pthread_mutex_t *mutex; // [sp+8h] [bp-80h]
  unsigned int which_core; // [sp+Ch] [bp-7Ch]
  work *works; // [sp+14h] [bp-74h]
  cgpu_info *v21; // [sp+1Ch] [bp-6Ch] BYREF
  unsigned __int8 data_fil[64]; // [sp+20h] [bp-68h] BYREF

  v1 = *(unsigned __int8 *)arg;
  memset(data_fil, 0, sizeof(data_fil));
  pattern_number = Conf.pattern_number;
  v21 = (cgpu_info *)&cgpu.workdataFilePrefix[60];
  do
  {
    works = (work *)v21->fps[1];
    v21 = (cgpu_info *)((char *)v21 + 4);
    for ( which_core = 0; which_core != 50; ++which_core )
    {
      if ( pattern_number )
      {
        v3 = 0;
        mutex = &HW_check_mutex[v1];
        do
        {
          v4 = (unsigned __int8 *)&v21 + 3;
          v5 = &works[v3 + pattern_number * which_core];
          v6 = &v5->data[11];
          do
          {
            v7 = *++v6;
            *++v4 = v7;
          }
          while ( &data_fil[31] != v4 );
          nonce = v5->nonce;
          v9 = (unsigned __int8 *)&v5->nonce + 3;
          v10 = &data_fil[51];
          data_fil[51] = v3;
          data_fil[47] = nonce;
          data_fil[44] = HIBYTE(nonce);
          data_fil[45] = BYTE2(nonce);
          data_fil[46] = BYTE1(nonce);
          do
          {
            v11 = *++v9;
            *++v10 = v11;
          }
          while ( v9 != &v5->data[11] );
          uart_send(v1, data_fil, 0x40u);
          pthread_mutex_lock(mutex);
          v12 = &gWorks_For_Hw_Check[v1][127];
          do
          {
            v13 = (work (*)[128])&v12[-1];
            memcpy(v12, &v12[-1], sizeof(work));
            v12 = (work *)v13;
          }
          while ( v13 != (work (*)[128])gWorks_For_Hw_Check[v1] );
          ++v3;
          v14 = (unsigned __int8)(gWork_Num_For_Hw_Check + 1);
          if ( v14 > 0x7E )
            LOBYTE(v14) = 127;
          gWork_Num_For_Hw_Check = v14;
          memcpy(gWorks_For_Hw_Check[v1], v5, 0x44u);
          pthread_mutex_unlock(mutex);
          ++gSend_Work_Num[v1];
          usleep(0x7D0u);
          pattern_number = Conf.pattern_number;
        }
        while ( Conf.pattern_number > v3 );
      }
    }
  }
  while ( v21 != (cgpu_info *)&cgpu.works[44] );
  v15 = gSend_Work_Num[v1];
  v16 = 2250 * pattern_number;
  if ( v15 < v16 )
  {
    do
    {
      printf("\n\n---%s: Chain%d send work num : %d, less than %d\n", (const char *)_FUNCTION___8213_0, v1, v15, v16);
      v15 = gSend_Work_Num[v1];
      v16 = 2250 * Conf.pattern_number;
    }
    while ( v15 < 2250 * Conf.pattern_number );
  }
  printf("\n\n---%s: Chain%d send work num : %d\n", (const char *)_FUNCTION___8213_0, v1, v15);
  puts("\nsend test pattern done");
  system("date");
  putchar(10);
  usleep(0x9C40u);
  start_receive = 0;
  puts("to stop receive");
  return 0;
}

//----- (00019948) --------------------------------------------------------
void reset_V9_global_arg()
{
  unsigned int *v0; // r8
  unsigned int *v1; // r12
  char *v2; // r11
  unsigned int pattern_number; // r5
  unsigned int *v4; // lr
  unsigned int *v5; // r9
  int v6; // r7
  unsigned int v7; // r6
  cgpu_info *v8; // r10
  unsigned int *v9; // r4
  FILE *v10; // t1
  unsigned int *v11; // r0
  char *v12; // r3
  char *v13; // r2

  v0 = gRepeated_Nonce_Id;
  reset_global_arg();
  v1 = gValid_Nonce_Num;
  v2 = (char *)&cgpu.timeout + 3;
  pattern_number = Conf.pattern_number;
  v4 = gSend_Work_Num;
  v5 = &gAsic_Core_Nonce_Num[0][0][49];
  v6 = 0;
  v7 = 68 * Conf.pattern_number;
  do
  {
    v8 = (cgpu_info *)&cgpu.workdataFilePrefix[60];
    v9 = v5;
    *++v2 = 0;
    *v0++ = 0;
    *v1++ = 0;
    *v4++ = 0;
    do
    {
      v10 = v8->fps[1];
      v8 = (cgpu_info *)((char *)v8 + 4);
      v11 = v9 - 50;
      v12 = (char *)v10 + v6;
      do
      {
        v11[1] = 0;
        ++v11;
        v13 = &v12[v7];
        if ( pattern_number )
        {
          do
          {
            *((_DWORD *)v12 + 13) = 0;
            v12 += 68;
          }
          while ( v12 != v13 );
        }
        v12 = v13;
      }
      while ( v9 != v11 );
      v9 += 1024;
    }
    while ( v8 != (cgpu_info *)&cgpu.works[44] );
    v6 += 4;
    v5 += 0x20000;
  }
  while ( v6 != 16 );
}

//----- (000199E4) --------------------------------------------------------
void __fastcall V9_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c, bool whether_add_voltage)
{
  unsigned int v4; // r6
  unsigned int Voltage1; // r5
  _BOOL4 v6; // [sp+14h] [bp-1Ch]

  v4 = which_chain;
  switch ( pattern_test_time )
  {
    case 0u:
      Voltage1 = Conf.Voltage1;
      break;
    case 1u:
      Voltage1 = Conf.Voltage2;
      break;
    case 2u:
      Voltage1 = Conf.Voltage3;
      break;
    case 3u:
      Voltage1 = Conf.Voltage4;
      break;
    case 4u:
      Voltage1 = Conf.Voltage5;
      break;
    case 5u:
      Voltage1 = Conf.Voltage6;
      break;
    case 6u:
      Voltage1 = Conf.Voltage7;
      break;
    case 7u:
      Voltage1 = Conf.Voltage8;
      break;
    case 8u:
      Voltage1 = Conf.Voltage9;
      break;
    default:
      v6 = whether_add_voltage;
      Voltage1 = Conf.Voltage1;
      printf("\n--- Can't find voltage%d\n", pattern_test_time);
      *(_DWORD *)&whether_add_voltage = v6;
      break;
  }
  if ( whether_add_voltage )
    Voltage1 += Conf.add_voltage_value;
  printf(
    "\n--- %s: real voltage = %d, temp_voltage = %.6f, Pic_Voltage = %d\n",
    (const char *)_FUNCTION___8075,
    Voltage1,
    1742.06996 - (double)Voltage1 * 152.134146 / 100.0,
    (unsigned int)(1742.06996 - (double)Voltage1 * 152.134146 / 100.0));
  set_PIC16F1704_voltage(v4, which_i2c, (unsigned int)(1742.06996 - (double)Voltage1 * 152.134146 / 100.0));
  j_usleep(0x186A0u);
}

//----- (00019B24) --------------------------------------------------------
void V9_calculate_timeout_and_baud()
{
  _DWORD *v0; // r4
  unsigned int v1; // r5
  unsigned int v2; // r6
  unsigned int v3; // r5
  unsigned int v4; // r0
  int v5; // r2

  LOWORD(v0) = (unsigned __int16)&Conf;
  v1 = calculate_core_number(0x32u);
  switch ( pattern_test_time )
  {
    case 0u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[18];
      break;
    case 1u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[19];
      break;
    case 2u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[20];
      break;
    case 3u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[21];
      break;
    case 4u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[22];
      break;
    case 5u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[23];
      break;
    case 6u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[24];
      break;
    case 7u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[25];
      break;
    case 8u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[26];
      break;
    default:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = 0;
      printf("%s: pattern_test_time = %d, error!!! \n", (const char *)_FUNCTION___8093, pattern_test_time);
      break;
  }
  v3 = 95 * (gChain_Asic_Interval * (0x1000000 / v1) / v2) / 0x64;
  v0[69] = v3;
  v4 = (unsigned int)&cgpu.subid[75558] / ((((unsigned int)&gAsic_Core_Nonce_Num[2][102][9] + 2) / v3) << 9);
  v0[67] = v4 - 1;
  if ( v4 - 1 > 0x1A || v4 - 2 <= 0x19 )
  {
    v5 = 1;
    v0[67] = 1;
  }
  else
  {
    v5 = 0;
  }
  printf("\n--- %s: baud = %d, timeout = 0x%08x = %d\n", (const char *)_FUNCTION___8093, v5, v3, v3);
  v0[17] = v2;
}

//----- (00019C3C) --------------------------------------------------------
void __fastcall V9_set_address(unsigned __int8 which_chain)
{
  int v2; // r5
  unsigned __int8 v3; // r4

  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8099, which_chain);
  LOBYTE(v2) = 45;
  v3 = 0;
  BM1385_chain_inactive(which_chain);
  do
  {
    BM1385_set_address(which_chain, v3);
    v3 += gChain_Asic_Interval;
    usleep(0x1388u);
    v2 = (unsigned __int8)(v2 - 1);
  }
  while ( v2 );
}

//----- (00019C88) --------------------------------------------------------
void __fastcall V9_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", (const char *)_FUNCTION___8107, which_chain, baud);
  BM1385_set_baud(which_chain, 0, baud, 1);
  usleep(0xC350u);
  set_fpga_baud(baud);
}

//----- (00019CC4) --------------------------------------------------------
void __fastcall V9_open_core(unsigned __int8 which_chain)
{
  int v1; // r6
  int v2; // r4
  unsigned __int8 *v3; // r3
  int v4; // r4
  unsigned __int8 data[64]; // [sp+0h] [bp-68h] BYREF

  v1 = which_chain;
  memset(data, 0, sizeof(data));
  data[0] = -1;
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8114_0, v1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  memset(data, 0, sizeof(data));
  v2 = 50;
  BM1385_set_gateblk(v1, 0, 1);
  do
  {
    uart_send(v1, data, 0x40u);
    usleep(Conf.OpenCoreGap);
    --v2;
  }
  while ( v2 );
  memset(data, 0, sizeof(data));
  v3 = data;
  do
  {
    *v3 = (_BYTE)v3 - (unsigned __int8)data;
    ++v3;
  }
  while ( v3 != &data[52] );
  v4 = 60;
  data[52] = -1;
  BM1385_set_gateblk(v1, 0, 1);
  do
  {
    uart_send(v1, data, 0x40u);
    usleep(Conf.OpenCoreGap);
    --v4;
  }
  while ( v4 );
  clear_uart_rx_fifo(v1);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (00019D9C) --------------------------------------------------------
unsigned int __fastcall V9_get_result(unsigned __int8 which_chain)
{
  int v1; // r6
  unsigned int v2; // r4
  unsigned int v3; // r8
  unsigned int v4; // r11
  bool v5; // zf
  unsigned int v6; // r2
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v7; // r9
  work *v8; // r11
  int v9; // r4
  unsigned int v10; // r7
  unsigned int spins; // t1
  unsigned int v12; // r10
  unsigned int pattern_number; // r1
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  unsigned int how_many_core_not_receive_all_nonce_per_asic; // [sp+4h] [bp-3Ch]
  unsigned int which_asic; // [sp+Ch] [bp-34h]
  int v20; // [sp+10h] [bp-30h]
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v21; // [sp+14h] [bp-2Ch]

  v20 = which_chain;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  v1 = 0;
  v2 = 0;
  v3 = 7;
  printf("every ASIC require nonce number: %u\n", 50 * Conf.pattern_number);
  do
  {
    if ( v2 == 9 * (v2 / 9) )
      putchar(10);
    v4 = calculate_how_many_nonce_per_asic_get(v20, v2, 0x32u);
    printf("asic[%02d]=%d\t", v2++, v4);
    if ( v4 < 50 * Conf.pattern_number && ++v1 > Conf.Invalid_Asic_Num )
      v3 = 6;
  }
  while ( v2 != 45 );
  which_asic = 0;
  puts("\n");
  v21 = &reg_mutex.__data._anon_0 + 0x20000 * v20;
  do
  {
    v6 = calculate_how_many_nonce_per_asic_get(v20, which_asic, 0x32u);
    if ( v6 < 50 * Conf.pattern_number )
    {
      printf("asic[%02d] = %d\n", which_asic, v6);
      v7 = v21;
      v8 = cgpu.works[which_asic];
      v9 = 0;
      how_many_core_not_receive_all_nonce_per_asic = 0;
      do
      {
        spins = v7[1].__spins;
        ++v7;
        v10 = spins;
        if ( spins < Conf.pattern_number )
        {
          v12 = 0;
          if ( how_many_core_not_receive_all_nonce_per_asic + 1 > Conf.Invalid_Core_Num )
            v3 = 6;
          if ( v10 < Conf.Least_nonce_per_core )
            v3 = 6;
          ++how_many_core_not_receive_all_nonce_per_asic;
          printf("core[%02d] = %d,      lost these nonce : ", v9, v10);
          pattern_number = Conf.pattern_number;
          if ( Conf.pattern_number )
          {
            do
            {
              while ( v8[v12 + v9 * pattern_number].is_nonce_return_back[v20][0] )
              {
                pattern_number = Conf.pattern_number;
                if ( Conf.pattern_number <= ++v12 )
                  goto LABEL_22;
              }
              printf("%d  ", v12);
              pattern_number = Conf.pattern_number;
              ++v12;
            }
            while ( Conf.pattern_number > v12 );
          }
LABEL_22:
          putchar(10);
        }
        ++v9;
      }
      while ( v9 != 50 );
      puts("\n");
    }
    v5 = which_asic++ == 44;
    v21 += 1024;
  }
  while ( !v5 );
  if ( gHw_Nonce_Num[v20] > Conf.Most_HW_Num )
  {
    v3 = 6;
    printf("ret = %d\n", 6);
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  if ( !gSensor_OK[v20][0] )
    v3 &= ~2u;
  if ( gHigherThanAlarmTemp )
    v3 &= ~4u;
  printf("Chain%d total valid nonce number: %d\n\n", v20, gValid_Nonce_Num[v20]);
  if ( (v3 & 1) != 0 )
    LOWORD(v14) = -25288;
  else
    LOWORD(v14) = -25276;
  HIWORD(v14) = 2;
  puts(v14);
  if ( (v3 & 2) != 0 )
    LOWORD(v15) = -21748;
  else
    LOWORD(v15) = -21736;
  HIWORD(v15) = 2;
  puts(v15);
  if ( (v3 & 4) != 0 )
    LOWORD(v16) = -17364;
  else
    LOWORD(v16) = -17348;
  HIWORD(v16) = 2;
  puts(v16);
  printf("HW number = %d\n\n", gHw_Nonce_Num[v20]);
  return v3;
}

//----- (0001A024) --------------------------------------------------------
void __fastcall V9_print_lcd(unsigned int result)
{
  char v1; // r4
  unsigned __int8 *v2; // r1

  v1 = result;
  display_level_result_on_lcd();
  if ( (v1 & 1) != 0 )
  {
    write_lcd_no_memset(1u, "   Pattern OK   ", 0x10u);
    pattern_test_time = 0;
  }
  else
  {
    write_lcd_no_memset(1u, "   Pattern NG   ", 0x10u);
    ++pattern_test_time;
  }
  if ( (v1 & 2) != 0 )
    LOWORD(v2) = -17308;
  else
    LOWORD(v2) = -17288;
  HIWORD(v2) = 2;
  write_lcd_no_memset(2u, v2, 0x10u);
  if ( (v1 & 4) != 0 )
    write_lcd_no_memset(3u, " Temperature OK ", 0x10u);
  else
    write_lcd_no_memset(3u, " Temperature NG ", 0x10u);
}

//----- (0001A0BC) --------------------------------------------------------
int __fastcall v9_check_nonce(unsigned __int8 which_chain, unsigned __int8 *nonce_data)
{
  int v3; // r8
  unsigned int v4; // r0
  int v5; // r2
  unsigned int v6; // r11
  int v7; // r6
  unsigned int v8; // r0
  unsigned int v9; // r2
  unsigned int v10; // r9
  work *v11; // r3
  int v12; // r4
  work *v13; // r4
  int v14; // r5
  work *v15; // r0
  int v16; // r0
  int result; // r0
  int *v18; // r3
  unsigned int v19; // r11
  unsigned int v20; // r3
  int ret; // [sp+Ch] [bp-2Ch]

  v3 = which_chain;
  v4 = *nonce_data;
  v5 = nonce_data[3];
  v6 = v5 & 0x3F;
  v7 = (v4 << 24) | (nonce_data[1] << 16) | v5 | (nonce_data[2] << 8);
  v8 = v4 / gChain_Asic_Interval;
  if ( v8 > 0x2C )
    return -1;
  if ( v6 > 0x31 )
  {
    printf("%s: received core%02d nonce. error!!!\t", _FUNCTION___8173, v5 & 0x3F);
LABEL_18:
    printf(
      ",received data is : 0x%02x%02x%02x%02x%02x\n",
      *nonce_data,
      nonce_data[1],
      nonce_data[2],
      nonce_data[3],
      nonce_data[4]);
    return -1;
  }
  v9 = nonce_data[4] & 0x7F;
  if ( v9 >= Conf.pattern_number )
  {
    printf("%s: received work_id = %02d nonce. error!!!\t", _FUNCTION___8173, v9);
    goto LABEL_18;
  }
  v10 = v8;
  v11 = &cgpu.works[v8][v9 + Conf.pattern_number * v6];
  if ( v7 == v11->nonce )
  {
    v18 = &v11->id + v3;
    result = v18[13];
    if ( result )
    {
      v18[13] = result + 1;
      result = 0;
      ++gRepeated_Nonce_Id[v3];
    }
    else
    {
      v19 = v6 + ((v10 + (v3 << 7)) << 10);
      v18[13] = 1;
      v20 = gAsic_Core_Nonce_Num[0][0][v19] + 1;
      ++gValid_Nonce_Num[v3];
      gAsic_Core_Nonce_Num[0][0][v19] = v20;
    }
  }
  else
  {
    pthread_mutex_lock(&HW_check_mutex[v3]);
    v12 = gWork_Num_For_Hw_Check;
    if ( gWork_Num_For_Hw_Check )
    {
      v13 = gWorks_For_Hw_Check[v3];
      v14 = 0;
      do
      {
        v15 = v13;
        ++v14;
        ++v13;
        v16 = check_hw(v15, v7, 0);
        if ( !v16 )
        {
          pthread_mutex_unlock(&HW_check_mutex[v3]);
          return 0;
        }
      }
      while ( gWork_Num_For_Hw_Check > v14 );
      ret = v16;
      pthread_mutex_unlock(&HW_check_mutex[v3]);
      if ( ret == 1 )
      {
        ++gHw_Nonce_Num[v3];
        printf(
          "%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n",
          (const char *)_FUNCTION___8173,
          v3,
          v10,
          v6,
          v7);
      }
      return 0;
    }
    else
    {
      pthread_mutex_unlock(&HW_check_mutex[v3]);
      return v12;
    }
  }
  return result;
}

//----- (0001A284) --------------------------------------------------------
int __fastcall V9_check_register_value(unsigned __int8 which_chain, unsigned __int8 *register_data)
{
  reg_buf *v2; // r3
  unsigned int reg_value_num; // r6
  char *v4; // r5
  unsigned int v5; // r2
  unsigned __int8 v6; // r1
  int result; // r0

  v2 = reg_value_buf;
  reg_value_num = reg_value_buf->reg_value_num;
  if ( reg_value_num > 0x1FE )
  {
    printf("%s: reg_value_buf buffer is full!\n", (const char *)_FUNCTION___8181);
    return -1;
  }
  else
  {
    v4 = (char *)reg_value_buf + 8 * reg_value_buf->p_wr;
    v5 = reg_value_buf->p_wr + 1;
    *((_DWORD *)v4 + 4) = _byteswap_ulong(*(_DWORD *)register_data);
    v6 = register_data[4];
    v4[23] = which_chain;
    result = 0;
    v4[22] = v6 & 0x1F;
    v2->reg_value_num = reg_value_num + 1;
    v2->p_wr = v5;
    if ( v5 >= 0x200 )
      v2->p_wr = 0;
  }
  return result;
}

//----- (0001A2F0) --------------------------------------------------------
void *__fastcall V9_receive_func(void *arg)
{
  int v1; // r6
  int v2; // r4
  unsigned int v3; // r5
  void *result; // r0
  int v5; // r7
  unsigned int v6; // r0
  unsigned __int8 *v7; // r2
  unsigned __int8 *v8; // r1
  unsigned int i; // r3
  unsigned __int8 v10; // t1
  unsigned __int8 *v11; // r9
  unsigned int v12; // r7
  unsigned __int8 *v13; // r3
  unsigned __int8 *v14; // r2
  unsigned __int8 v15; // t1
  char *v16; // r2
  unsigned __int8 *v17; // r3
  char v18; // t1
  unsigned __int8 temp_buf[5]; // [sp+10h] [bp-640h] BYREF
  char v20; // [sp+15h] [bp-63Bh] BYREF
  char v21; // [sp+17h] [bp-639h] BYREF
  unsigned __int8 data_buf[500]; // [sp+18h] [bp-638h] BYREF
  unsigned __int8 receive_buf[1050]; // [sp+20Ch] [bp-444h] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  memset(receive_buf, 0, sizeof(receive_buf));
  v3 = 0;
  memset(data_buf, 0, sizeof(data_buf));
  memset(temp_buf, 0, sizeof(temp_buf));
  printf("%s: which_chain = %d, which_i2c = %d\n", (const char *)_FUNCTION___8235, v1, v2);
  clear_uart_rx_fifo(v1);
LABEL_2:
  result = (void *)start_receive;
  if ( start_receive )
  {
    while ( 2 )
    {
      v5 = 5000000;
      usleep(0x1388u);
      do
      {
        while ( gIsOpeningCore )
          usleep(0x4E20u);
        memset(receive_buf, 0, sizeof(receive_buf));
        v6 = uart_receive(v1, receive_buf, 0x3E8u);
        if ( v6 )
        {
          v7 = &data_buf[v3 - 1];
          v8 = &data_buf[499];
          for ( i = 0; i < v6; ++i )
          {
            v10 = *++v8;
            ++v3;
            *++v7 = v10;
          }
          if ( v3 > 4 )
          {
            v11 = data_buf;
            v12 = 5 * (v3 / 5);
            do
            {
              v13 = temp_buf;
              v14 = v11;
              memset(temp_buf, 0, sizeof(temp_buf));
              do
              {
                v15 = *v14++;
                *v13++ = v15;
              }
              while ( v13 != (unsigned __int8 *)&v20 );
              if ( BM1385_is_nonce_or_reg_value(temp_buf[4]) )
              {
                if ( gStartTest && gIsOpenCoreEnd )
                  v9_check_nonce(v1, temp_buf);
              }
              else
              {
                V9_check_register_value(v1, temp_buf);
              }
              v11 += 5;
            }
            while ( &data_buf[v12] != v11 );
            v3 %= 5u;
            if ( v3 )
            {
              v16 = &v21;
              v17 = &data_buf[v12 - 1];
              do
              {
                v18 = *++v17;
                *++v16 = v18;
              }
              while ( v17 != &data_buf[v12 - 1 + v3] );
            }
          }
          goto LABEL_2;
        }
        --v5;
      }
      while ( v5 );
      result = (void *)start_receive;
      if ( start_receive )
        continue;
      break;
    }
  }
  return result;
}

//----- (0001A468) --------------------------------------------------------
void singleBoardTest_V9_BM1385_45()
{
  unsigned int axi_fpga; // r0
  unsigned int result; // r8
  unsigned __int8 lcd_display_buf[16]; // [sp+0h] [bp-38h] BYREF

  memset(lcd_display_buf, 32, sizeof(lcd_display_buf));
  printf("\nBegin %s test\n", (const char *)_FUNCTION___8262);
  system("date");
  putchar(10);
  memset(lcd_output, 32, sizeof(lcd_output));
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  set_fpga_baud(0x1Au);
  axi_fpga = read_axi_fpga(0);
  write_axi_fpga(0, axi_fpga | 0x20000000);
  reset_V9_global_arg();
  check_chain();
  if ( gChain == 255 )
  {
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    write_lcd(1u, " no hash board  ", 0x10u);
    puts("\nNo hash board, please plug in it");
    return;
  }
  pthread_create(&cgpu.show_id, 0, V9_show_status_func, &chain_info_0[gChain]);
  write_axi_fpga(0xDu, 0xFFFFu);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  reset_PIC16F1704_pic(gChain, gI2c);
  jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
  V9_set_voltage(gChain, gI2c, 0);
  enable_PIC16F1704_dc_dc(gChain, gI2c, 1u);
  pthread_create(&cgpu.pic_heart_beat_id, 0, pic_heart_beat_func, &chain_info_0[gChain]);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  write_axi_fpga(0xDu, 0);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  start_receive = 1;
  pthread_create(&cgpu.receive_id, 0, V9_receive_func, &chain_info_0[gChain]);
  puts("\n--- V9 check asic number");
  check_BM1385_asic_reg(gChain, 0, 0, 1);
  printf("\n--- check chain: J%d has asicNum = %d\n", gChain, cgpu.chain_asic_num[gChain]);
  if ( cgpu.chain_asic_num[gChain] == Conf.AsicNum )
  {
    V9_set_baud(gChain, 1u);
    reset_hash_board();
    set_fpga_baud(0x1Au);
    cgpu.chain_asic_num[gChain] = 0;
    puts("\n--- double check asic number");
    check_BM1385_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: J%d has asicNum = %d\n", gChain + 1, cgpu.chain_asic_num[gChain]);
    if ( cgpu.chain_asic_num[gChain] != Conf.AsicNum )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
      write_lcd(0, "   Only have    ", 0x10u);
      write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
      write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
      printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8262, cgpu.chain_asic_num[gChain]);
      puts("----------------------------\n\n");
      sleep(Conf.close_power_delay);
      enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
      return;
    }
    V9_calculate_timeout_and_baud();
    set_BM1385_freq(gChain, 0, Conf.Freq, 1);
    V9_set_address(gChain);
    V9_set_baud(gChain, Conf.baud);
    V9_open_core(gChain);
    puts("\nBegin send test pattern");
    if ( !gStartTest )
    {
      if ( time_counter >= Conf.HeatingUpTime )
      {
LABEL_20:
        pthread_cancel(cgpu.receive_id);
        pthread_cancel(cgpu.show_id);
        pthread_cancel(cgpu.pic_heart_beat_id);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, "Can't open core ", 0x10u);
        write_lcd_no_memset(1u, "change  to  next", 0x10u);
        write_lcd_no_memset(2u, (unsigned __int8 *)"voltage and freq", 0x10u);
        ++pattern_test_time;
        return;
      }
      while ( 1 )
      {
        usleep(0x2710u);
        if ( gStartTest )
          break;
        if ( Conf.HeatingUpTime <= time_counter )
          goto LABEL_20;
      }
    }
    pthread_create(&cgpu.send_id, 0, V9_send_func, &chain_info_0[gChain]);
    pthread_join(cgpu.send_id, 0);
    pthread_cancel(cgpu.show_id);
    pthread_join(cgpu.receive_id, 0);
    result = V9_get_result(gChain);
    V9_print_lcd(result);
    if ( result == 7 )
    {
      if ( Conf.add_voltage_after_test_ok )
        V9_set_voltage(gChain, gI2c, 1);
    }
    else if ( (result & 1) == 0 && pattern_test_time < (unsigned int)gHowManyVoltageLevel )
    {
      goto LABEL_19;
    }
    enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
LABEL_19:
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(cgpu.pic_heart_beat_id);
    pthread_mutex_unlock(&i2c_mutex);
    set_fan_speed(0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    return;
  }
  pthread_cancel(cgpu.receive_id);
  pthread_cancel(cgpu.show_id);
  pthread_mutex_lock(&i2c_mutex);
  pthread_cancel(cgpu.pic_heart_beat_id);
  pthread_mutex_unlock(&i2c_mutex);
  sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
  write_lcd(0, "   Only have    ", 0x10u);
  write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
  write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
  printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8262, cgpu.chain_asic_num[gChain]);
  puts("----------------------------\n\n");
  sleep(Conf.close_power_delay);
  enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
}

//----- (0001A9B0) --------------------------------------------------------
void __fastcall i2c_write(unsigned int config_data)
{
  while ( (read_axi_fpga(0xCu) & 0x80000000) == 0 )
    usleep(0x1388u);
  write_axi_fpga(0xCu, config_data);
}

//----- (0001A9D4) --------------------------------------------------------
unsigned __int8 __fastcall i2c_read(unsigned int config_data)
{
  signed int axi_fpga; // r0

  i2c_write(config_data | 0x2000000);
  do
  {
    usleep(0x1388u);
    axi_fpga = read_axi_fpga(0xCu);
  }
  while ( axi_fpga >= 0 );
  return axi_fpga;
}

//----- (0001A9F8) --------------------------------------------------------
void power_check_type()
{
  int v0; // r4

  pthread_mutex_lock(&i2c_mutex);
  v0 = i2c_read(0x5200000u);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v0 == 245 )
  {
    puts("power type APW9 3600W");
    g_power_type = 2;
  }
  else
  {
    puts("power type APW8 2000W");
    g_power_type = 1;
  }
}

//----- (0001AA54) --------------------------------------------------------
int open_power_control()
{
  int result; // r0

  power_check_type();
  result = open("/sys/class/gpio/gpio907/value", 2049);
  power_control_fd = result;
  if ( result < 0 )
  {
    puts("open power control gpio failed!!!");
    return power_control_fd;
  }
  return result;
}

//----- (0001AA8C) --------------------------------------------------------
void close_power_control()
{
  close(power_control_fd);
  j_puts("power control gpio closed!!!");
}

//----- (0001AAAC) --------------------------------------------------------
void power_on()
{
  j_write(power_control_fd, "0", 1u);
}

//----- (0001AAC4) --------------------------------------------------------
void power_off()
{
  j_write(power_control_fd, "1", 1u);
}

//----- (0001AADC) --------------------------------------------------------
unsigned int get_target_voltage()
{
  unsigned int Voltage1; // r4

  switch ( pattern_test_time )
  {
    case 0u:
      Voltage1 = Conf.Voltage1;
      break;
    case 1u:
      Voltage1 = Conf.Voltage2;
      break;
    case 2u:
      Voltage1 = Conf.Voltage3;
      break;
    case 3u:
      Voltage1 = Conf.Voltage4;
      break;
    case 4u:
      Voltage1 = Conf.Voltage5;
      break;
    case 5u:
      Voltage1 = Conf.Voltage6;
      break;
    case 6u:
      Voltage1 = Conf.Voltage7;
      break;
    case 7u:
      Voltage1 = Conf.Voltage8;
      break;
    case 8u:
      Voltage1 = Conf.Voltage9;
      break;
    default:
      Voltage1 = Conf.Voltage1;
      printf(
        "!!!%s: not support Voltage%d, we use Voltage1 as default value\n",
        (const char *)_FUNCTION___8004,
        pattern_test_time);
      break;
  }
  cgpu.voltage = Voltage1;
  printf("\n--- %s: target voltage is %d\n", (const char *)_FUNCTION___8004, Voltage1);
  return Voltage1;
}

//----- (0001ABBC) --------------------------------------------------------
bool __fastcall power_check_reply(uint8_t *cmd, uint8_t *reply_buf, uint8_t reply_len)
{
  int v4; // r5
  uint8_t *v5; // r5
  uint8_t *v6; // r4
  int v7; // t1
  int v9; // r0
  int v10; // r1
  int v11; // r3
  __int16 v12; // r2
  int v13; // r2
  uint8_t *v14; // r5
  uint8_t *v15; // r4
  int v16; // t1

  v4 = reply_len;
  if ( *cmd != *reply_buf
    || cmd[1] != reply_buf[1]
    || cmd[3] != reply_buf[3]
    || (v9 = reply_buf[2], v9 + 2 != reply_len) )
  {
    puts("power reply data error:");
    if ( (_WORD)v4 )
    {
      v5 = &reply_buf[(unsigned __int16)(v4 - 1)];
      v6 = reply_buf - 1;
      do
      {
        v7 = *++v6;
        printf("%02x ", v7);
      }
      while ( v5 != v6 );
    }
    goto LABEL_5;
  }
  if ( reply_buf[2] > 2u )
  {
    v11 = 2;
    LOWORD(v10) = 0;
    do
    {
      v12 = reply_buf[v11];
      v11 = (unsigned __int16)(v11 + 1);
      v10 = (unsigned __int16)(v10 + v12);
    }
    while ( v9 > v11 );
  }
  else
  {
    v10 = 0;
  }
  v13 = (unsigned __int16)(reply_buf[v4 - 2] + (reply_buf[v4 - 1] << 8));
  if ( v13 != v10 )
  {
    printf("power reply crc error, crc %04x != crc_reply %04x:\n", v10, v13);
    if ( (_WORD)v4 )
    {
      v14 = &reply_buf[(unsigned __int16)(v4 - 1)];
      v15 = reply_buf - 1;
      do
      {
        v16 = *++v15;
        printf("%02x ", v16);
      }
      while ( v14 != v15 );
    }
LABEL_5:
    putchar(10);
    return 0;
  }
  return 1;
}

//----- (0001AC80) --------------------------------------------------------
bool __fastcall power_send_cmd(uint8_t *cmd, uint8_t len, uint8_t *reply_buf, uint8_t reply_len)
{
  int v4; // r10
  int v6; // r6
  uint8_t *v7; // r5
  int v9; // r8
  uint8_t *v10; // r4
  int v11; // t1
  uint8_t *v12; // r4
  _BOOL4 v13; // r4
  int v14; // r2

  v4 = len;
  v6 = 1;
  v7 = &cmd[(unsigned __int8)(len - 1)];
  v9 = reply_len;
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    if ( v4 )
    {
      v10 = cmd - 1;
      do
      {
        v11 = *++v10;
        i2c_write(v11 | 0x5201100);
      }
      while ( v10 != v7 );
    }
    v12 = reply_buf - 1;
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    if ( v9 )
    {
      do
        *++v12 = i2c_read(0x4200000u);
      while ( v12 != &reply_buf[(unsigned __int8)(v9 - 1)] );
    }
    v13 = power_check_reply(cmd, reply_buf, v9);
    if ( v13 )
      break;
    v14 = v6++;
    printf("power send cmd 0x%02x failed, retry for %d times\n", cmd[3], v14);
  }
  while ( v6 != 4 );
  pthread_mutex_unlock(&i2c_mutex);
  return v13;
}

//----- (0001AD28) --------------------------------------------------------
unsigned __int8 __fastcall APW8_calculate_voltage(unsigned int voltage)
{
  double v1; // d6
  float v2; // s16
  unsigned __int8 v3; // r4
  double v4; // d7
  int v5; // r3

  if ( gHashBoard_BHB91601S )
  {
LABEL_7:
    v2 = 1215.89444 - (double)voltage * 59.9315068 / 100.0;
    goto LABEL_8;
  }
  if ( !gHashBoard_BHB91601P )
  {
    if ( !gHashBoard_BHB07601 )
    {
      printf("\n!!! %s Please check Hashboard type!\n\n", (const char *)_FUNCTION___8046);
      v5 = 255;
      v4 = 255.0;
      v3 = -1;
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  v1 = (double)voltage;
  if ( BHB91601_ASIC_NUMBER == 84 )
  {
    v2 = 1925.73529 - v1 * 171.875 / 100.0;
  }
  else if ( BHB91601_ASIC_NUMBER == 60 )
  {
    v2 = 1336.07353 - v1 * 156.145833 / 100.0;
  }
  else
  {
    v2 = 1925.73529 - v1 * 171.875 / 100.0;
    printf("\n!!! %s Use BHB91601 84P power as default!\n\n", (const char *)_FUNCTION___8046);
  }
LABEL_8:
  v3 = (unsigned int)v2;
  if ( v2 >= 0.0 )
  {
    v4 = v2;
    v5 = (unsigned __int8)(unsigned int)v2;
LABEL_10:
    printf("\n--- %s: voltage_n = %f, N = %d\n", (const char *)_FUNCTION___8046, v4, v5);
    return v3;
  }
  printf("\n!!! %s: voltage_n = %f, we use N = %d as default\n", (const char *)_FUNCTION___8046, v2, 0);
  return 0;
}

//----- (0001AEB4) --------------------------------------------------------
void __fastcall APW8_set_voltage(unsigned __int8 N)
{
  i2c_write(N | 0x5200200);
}

//----- (0001AEC0) --------------------------------------------------------
unsigned __int8 __fastcall APW9_calculate_voltage(unsigned int voltage)
{
  float v1; // s14
  int v2; // r4
  double v3; // d7
  int v4; // r3

  if ( !gHashBoard_BHB07601 )
  {
    printf("\n!!! %s Please check Hashboard type!\n\n", (const char *)_FUNCTION___8056);
    v4 = 255;
    v3 = 255.0;
    LOBYTE(v2) = -1;
    goto LABEL_4;
  }
  v1 = 765.411764 - (double)voltage * 35.833333 / 100.0;
  if ( v1 >= 0.0 )
  {
    v2 = (unsigned __int8)(unsigned int)v1;
    v3 = v1;
    v4 = v2;
LABEL_4:
    printf("\n--- %s: voltage_n = %f, N = %d\n", (const char *)_FUNCTION___8056, v3, v4);
    return v2;
  }
  printf("\n!!! %s: voltage_n = %f, we use N = %d as default\n", (const char *)_FUNCTION___8056, v1, 0);
  return 0;
}

//----- (0001AF8C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall APW9_set_voltage(unsigned __int8 N)
{
  __int16 v1; // r6
  uint8_t cmd[8]; // [sp+0h] [bp-38h] BYREF
  uint8_t reply[32]; // [sp+8h] [bp-30h] BYREF

  v1 = N;
  *(_DWORD *)cmd = -2096715179;
  cmd[5] = 0;
  memset(reply, 0, sizeof(reply));
  cmd[4] = v1;
  *(_WORD *)&cmd[6] = v1 + 137;
  power_send_cmd(cmd, 8u, reply, 8u);
}
// 1AF8C: variables would overlap: r0.1 and r0.2

//----- (0001AFE4) --------------------------------------------------------
unsigned __int8 __fastcall power_calculate_voltage(unsigned int voltage)
{
  if ( g_power_type == 1 )
    return APW8_calculate_voltage(voltage);
  else
    return APW9_calculate_voltage(voltage);
}

//----- (0001B004) --------------------------------------------------------
void __fastcall power_set_voltage(unsigned __int8 N)
{
  if ( g_power_type == 1 )
    i2c_write(N | 0x5200200);
  else
    APW9_set_voltage(N);
}

//----- (0001B024) --------------------------------------------------------
int __fastcall Calibration_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic)
{
  unsigned int v3; // r6
  int v4; // r4
  unsigned int target_voltage; // r10
  float v6; // s30
  int v7; // r5
  float v8; // s31
  unsigned int vol0; // [sp+10h] [bp-78h] BYREF
  unsigned int vol1; // [sp+14h] [bp-74h] BYREF
  unsigned int vol2; // [sp+18h] [bp-70h] BYREF
  unsigned int vol3; // [sp+1Ch] [bp-6Ch] BYREF

  v3 = which_chain;
  vol0 = 0;
  vol1 = 0;
  vol2 = 0;
  v4 = 256;
  vol3 = 0;
  target_voltage = get_target_voltage();
  v6 = 0.0;
  v7 = power_calculate_voltage(target_voltage);
  power_set_voltage(v7);
  printf("\n--- %s: target_V0 = %d, N = %d\n", (const char *)_FUNCTION___8088_0, target_voltage, v7);
  write(power_control_fd, "0", 1u);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  enable_dsPIC33EP16GS202_dc_dc(v3, which_iic, 1u);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  while ( 1 )
  {
    while ( dsPIC33EP16GS202_read_out_4_voltage(which_iic, v3, &vol0, &vol1, &vol2, &vol3) != 1 )
    {
      if ( !--v4 )
        goto LABEL_15;
    }
    if ( gHashBoard_BHB91601P )
    {
      if ( BHB91601_ASIC_NUMBER == 60 )
      {
        v6 = (double)vol0 * 3.3 * 0.000244140625 * 43.0 / 10.0 * 100.0;
      }
      else if ( BHB91601_ASIC_NUMBER == 84 )
      {
        v6 = (double)vol0 * 3.3 * 0.000244140625 * 40.0 / 10.0 * 100.0;
      }
    }
    else if ( gHashBoard_BHB91601S )
    {
      v6 = (double)vol0 * 3.3 * 0.000244140625 * 73.0 / 10.0 * 100.0;
    }
    else
    {
      printf("\n!!! %s Please check Hashboard type!\n\n", (const char *)_FUNCTION___8088_0);
    }
    v8 = v6 - (float)target_voltage;
    printf(
      "\n--- %s: voltage_V0 = %f, target_V0 = %d, error_value = %f\n\n",
      (const char *)_FUNCTION___8088_0,
      v6,
      target_voltage,
      v8);
    if ( v8 < 0.0 )
      v8 = -v8;
    if ( v8 < (float)Conf.Voltage_accuracy )
    {
      printf(
        "\n--- %s: Calibration voltage done. voltage_V0 = %f, N = %d, Voltage_accuracy = %d\n",
        (const char *)_FUNCTION___8088_0,
        v6,
        v7,
        Conf.Voltage_accuracy);
      return 0;
    }
    if ( v6 > (float)target_voltage )
      break;
    if ( !v7 )
    {
      printf("\n!!! %s: N = %d, fail\n", (const char *)_FUNCTION___8088_0, 0);
      enable_dsPIC33EP16GS202_dc_dc(v3, which_iic, 0);
      write(power_control_fd, "1", 1u);
      return -3;
    }
    LOBYTE(v7) = v7 - 1;
LABEL_14:
    v7 = (unsigned __int8)v7;
    printf("\n--- %s: N = %d\n", (const char *)_FUNCTION___8088_0, (unsigned __int8)v7);
    power_set_voltage(v7);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    if ( !--v4 )
    {
LABEL_15:
      printf("\n!!! %s: calibration_counter = %d, fail\n", (const char *)_FUNCTION___8088_0, 256);
      return -1;
    }
  }
  if ( v7 != 255 )
  {
    LOBYTE(v7) = v7 + 1;
    goto LABEL_14;
  }
  printf("\n!!! %s: N = %d, fail\n", (const char *)_FUNCTION___8088_0, 255);
  enable_dsPIC33EP16GS202_dc_dc(v3, which_iic, 0);
  write(power_control_fd, "1", 1u);
  return -2;
}

//----- (0001B318) --------------------------------------------------------
int __fastcall set_pre_open_core_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic)
{
  unsigned int v2; // r7
  int v4; // r6

  v2 = which_chain;
  v4 = power_calculate_voltage(Conf.pre_open_core_voltage);
  power_set_voltage(v4);
  printf(
    "\n--- %s: Conf.pre_open_core_voltage = %d, N = %d\n",
    (const char *)_FUNCTION___8104,
    Conf.pre_open_core_voltage,
    v4);
  write(power_control_fd, "0", 1u);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  printf("%s line %d: Enter hash board power on flow:\n", (const char *)_FUNCTION___8104, 507);
  write_axi_fpga(0xDu, 0xFFFFu);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  printf("%s line %d: Reset hash board done\n", (const char *)_FUNCTION___8104, 511);
  enable_dsPIC33EP16GS202_dc_dc(v2, which_iic, 1u);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  printf("%s line %d: dc dc enable done\n", (const char *)_FUNCTION___8104, 515);
  write_axi_fpga(0xDu, 0);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  printf("%s line %d: release hash board reset done.\n", (const char *)_FUNCTION___8104, 519);
  return 0;
}

//----- (0001B3FC) --------------------------------------------------------
void __fastcall adjust_voltage(unsigned __int8 which_chain, unsigned __int8 which_iic)
{
  unsigned int target_voltage; // r0
  unsigned int v3; // r5
  int v4; // r0
  unsigned int v5; // r4
  unsigned __int8 v6; // r0

  target_voltage = get_target_voltage();
  v3 = power_calculate_voltage(target_voltage);
  v4 = power_calculate_voltage(Conf.pre_open_core_voltage);
  v5 = v4 + 20;
  printf("\n--- %s: target_N = %d, origin_N = %d\n", (const char *)_FUNCTION___8114_1, v3, v4);
  while ( v5 < v3 )
  {
    v6 = v5;
    v5 = (unsigned __int8)v5 + 20;
    power_set_voltage(v6);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  }
  power_set_voltage(v3);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  j_printf("\n--- %s: done\n", (const char *)_FUNCTION___8114_1);
}

//----- (0001B478) --------------------------------------------------------
unsigned int get_fan_speed()
{
  return read_axi_fpga(1u);
}

//----- (0001B480) --------------------------------------------------------
void __fastcall set_fan_speed(unsigned int speed)
{
  write_axi_fpga(0x21u, speed);
}

//----- (0001B488) --------------------------------------------------------
void __fastcall fan_control(unsigned __int8 level)
{
  unsigned int v1; // r1
  int v2; // r3

  if ( level > 0xAu )
    v1 = 6553600;
  else
    LOWORD(v2) = (unsigned __int16)"d";
  if ( level <= 0xAu )
  {
    HIWORD(v2) = (unsigned int)"d" >> 16;
    v1 = *(_DWORD *)(v2 + 4 * level);
  }
  write_axi_fpga(0x21u, v1);
}
// 1B498: variable 'v2' is possibly undefined
// 1B49E: variable 'v1' is possibly undefined

//----- (0001B4A4) --------------------------------------------------------
void __fastcall sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  uint32_t *v3; // r5
  int j; // r4
  unsigned int *v5; // r2
  uint32_t *v6; // r6
  uint32_t v7; // r4
  uint32_t *v8; // r1
  uint32_t v9; // t1
  sha256_ctx *v10; // r3
  uint32_t **p_h; // r2
  uint32_t *len; // t1
  uint32_t v13; // r3
  int v14; // lr
  uint32_t v15; // r6
  uint32_t v16; // r10
  uint32_t v17; // r9
  uint32_t v18; // r7
  uint32_t v19; // r8
  uint32_t v20; // r12
  uint32_t v21; // r11
  uint32_t v22; // r2
  uint32_t v23; // r4
  uint32_t v24; // r3
  uint32_t v25; // r5
  uint32_t v26; // r4
  uint32_t *v27; // r9
  sha256_ctx *v28; // lr
  uint32_t v29; // t1
  int i; // [sp+4h] [bp-164h]
  uint32_t *h; // [sp+1Ch] [bp-14Ch] BYREF
  uint32_t wv[8]; // [sp+20h] [bp-148h] BYREF
  uint32_t w[64]; // [sp+40h] [bp-128h] BYREF

  if ( (int)block_nb > 0 )
  {
    i = 0;
    h = ctx->h;
    do
    {
      v3 = &wv[7];
      for ( j = 0; j != 16; ++j )
      {
        v5 = (unsigned int *)&message[64 * i + 4 * j];
        v3[1] = _byteswap_ulong(*v5);
        ++v3;
      }
      v6 = w;
      do
      {
        v7 = v6[14];
        v8 = v6;
        v9 = v6[1];
        ++v6;
        v6[15] = (__ROR4__(v9, 18) ^ __ROR4__(v9, 7) ^ (v9 >> 3))
               + *v8
               + v8[9]
               + (__ROR4__(v7, 19) ^ __ROR4__(v7, 17) ^ (v7 >> 10));
      }
      while ( &w[48] != v6 );
      v10 = (sha256_ctx *)&ctx->block[124];
      p_h = &h;
      do
      {
        len = (uint32_t *)v10->len;
        v10 = (sha256_ctx *)((char *)v10 + 4);
        p_h[1] = len;
        ++p_h;
      }
      while ( &ctx->h[7] != (uint32_t *)v10 );
      v13 = wv[7];
      v14 = 0;
      v15 = wv[4];
      v16 = wv[5];
      v17 = wv[6];
      v18 = wv[0];
      v19 = wv[1];
      v20 = wv[2];
      v21 = wv[3];
      while ( 1 )
      {
        v22 = (v17 & ~v15 ^ v15 & v16) + (__ROR4__(v15, 11) ^ __ROR4__(v15, 6) ^ __ROR4__(v15, 25)) + w[v14];
        v23 = sha256_k[v14++];
        v24 = v13 + v22 + v23;
        v25 = v24 + v21;
        v26 = (__ROR4__(v18, 13) ^ __ROR4__(v18, 2) ^ __ROR4__(v18, 22)) + ((v20 ^ v19) & v18 ^ v19 & v20) + v24;
        v21 = v20;
        v13 = v17;
        if ( v14 == 64 )
          break;
        v20 = v19;
        v17 = v16;
        v19 = v18;
        v16 = v15;
        v18 = v26;
        v15 = v25;
      }
      wv[7] = v17;
      v27 = wv;
      v28 = (sha256_ctx *)h;
      wv[6] = v16;
      wv[5] = v15;
      wv[4] = v25;
      wv[3] = v20;
      wv[2] = v19;
      wv[1] = v18;
      wv[0] = v26;
      while ( 1 )
      {
        v28->tot_len += v26;
        v28 = (sha256_ctx *)((char *)v28 + 4);
        if ( v28 == &ctx[1] )
          break;
        v29 = v27[1];
        ++v27;
        v26 = v29;
      }
      ++i;
    }
    while ( i != block_nb );
  }
}

//----- (0001B620) --------------------------------------------------------
void __fastcall sha256_init(sha256_ctx *ctx)
{
  uint32_t *v1; // r2
  sha256_ctx *v2; // r3
  unsigned int v3; // t1

  v1 = &sha256_k[63];
  v2 = (sha256_ctx *)&ctx->block[124];
  do
  {
    v3 = v1[1];
    ++v1;
    v2->len = v3;
    v2 = (sha256_ctx *)((char *)v2 + 4);
  }
  while ( v2 != (sha256_ctx *)&ctx->h[7] );
  ctx->len = 0;
  ctx->tot_len = 0;
}

//----- (0001B648) --------------------------------------------------------
void __fastcall sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v4; // r0
  unsigned int v7; // r5
  unsigned __int8 *v8; // r0
  unsigned int v9; // r3
  unsigned int v10; // r6
  const unsigned __int8 *v11; // r5
  unsigned int v12; // r7
  int v13; // r6
  unsigned int tot_len; // r3

  v4 = ctx->len;
  v7 = 64 - v4;
  v8 = &ctx->block[v4];
  if ( v7 >= len )
    v7 = len;
  memcpy(v8, message, v7);
  v9 = ctx->len + len;
  if ( v9 > 0x3F )
  {
    v10 = len - v7;
    v11 = &message[v7];
    v12 = v10 >> 6;
    sha256_transf(ctx, ctx->block, 1u);
    v13 = v10 & 0x3F;
    sha256_transf(ctx, v11, v12);
    memcpy(ctx->block, &v11[64 * v12], v13);
    tot_len = ctx->tot_len;
    ctx->len = v13;
    ctx->tot_len = tot_len + ((v12 + 1) << 6);
  }
  else
  {
    ctx->len = v9;
  }
}

//----- (0001B6B4) --------------------------------------------------------
void __fastcall sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  unsigned int len; // r3
  unsigned __int8 *block; // r6
  bool v5; // cf
  int v7; // r2
  unsigned int v8; // r7
  size_t v9; // r2
  unsigned __int8 *v10; // r0
  int v11; // r3
  int v12; // r8
  int v13; // r9
  int v14; // r10
  unsigned int v15; // r11
  int v16; // r7
  sha256_ctx *v17; // r0
  uint32_t *h; // r4
  int i; // r3
  unsigned __int8 *v20; // r2
  uint32_t *v21; // r0
  int v22; // t1
  int v23; // [sp+4h] [bp-2Ch]

  len = ctx->len;
  block = ctx->block;
  v5 = (len & 0x3F) >= 0x38;
  if ( (len & 0x3F) >= 0x38 )
    v7 = 128;
  else
    v7 = 64;
  v8 = ctx->tot_len + len;
  v9 = v7 - len;
  v10 = &block[len];
  if ( (len & 0x3F) >= 0x38 )
    v11 = 124;
  else
    v11 = 60;
  if ( v5 )
    v12 = 125;
  else
    v12 = 61;
  if ( v5 )
    v13 = 126;
  else
    v13 = 62;
  if ( v5 )
    v14 = 127;
  else
    v14 = 63;
  if ( v5 )
    v15 = 2;
  else
    v15 = 1;
  v23 = v11;
  v16 = 8 * v8;
  memset(v10, 0, v9);
  ctx->block[ctx->len] = 0x80;
  block[v14] = v16;
  v17 = ctx;
  block[v13] = BYTE1(v16);
  h = ctx->h;
  block[v12] = BYTE2(v16);
  block[v23] = HIBYTE(v16);
  sha256_transf(v17, block, v15);
  for ( i = 0; i != 8; ++i )
  {
    v20 = &digest[4 * i];
    v21 = h;
    v20[3] = *h;
    v20[2] = BYTE1(*h);
    v22 = *h++;
    v20[1] = BYTE2(v22);
    *v20 = *((_BYTE *)v21 + 3);
  }
}

//----- (0001B76C) --------------------------------------------------------
void __fastcall sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  uint32_t *v3; // r3
  unsigned __int8 *v5; // r2
  uint32_t v6; // t1
  sha256_ctx ctx; // [sp+0h] [bp-B8h] BYREF

  v3 = &sha256_k[63];
  v5 = &ctx.block[124];
  do
  {
    v6 = v3[1];
    ++v3;
    *((_DWORD *)v5 + 1) = v6;
    v5 += 4;
  }
  while ( v3 != &sha256_h0[7] );
  ctx.tot_len = 0;
  ctx.len = 0;
  sha256_update(&ctx, message, len);
  sha256_final(&ctx, digest);
}

//----- (0001B7AC) --------------------------------------------------------
void *__fastcall __noreturn BHB91601_show_status_func(void *arg)
{
  int v1; // r8
  unsigned int v2; // r2
  unsigned int v3; // [sp+1Ch] [bp-34h]

  v1 = *(unsigned __int8 *)arg;
  printf(
    "\n--- %s: which_chain = %d, which_i2c = %d\n",
    (const char *)_FUNCTION___8285,
    v1,
    *((unsigned __int8 *)arg + 1));
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    fan_control(cgpu.fan_speed);
    v2 = time_counter;
    if ( gIsReadTemp && gIsOpenCoreEnd && time_counter == 10 * (time_counter / 0xA) )
    {
      v3 = time_counter % 0xA;
      gReadingTemp = 1;
      usleep(15 * Conf.timeout);
      BM1391_read_asic_temperature_local(v1);
      v2 = time_counter;
      gReadingTemp = v3;
    }
    sprintf((char *)lcd_output, "   time %ds", v2);
    sprintf((char *)lcd_output[1], "   nonce=%d", gValid_Nonce_Num[v1]);
    if ( Conf.TempSensor1 )
    {
      if ( Conf.TempSensor2 )
      {
        if ( Conf.TempSensor3 )
        {
          if ( Conf.TempSensor4 )
          {
            sprintf((char *)lcd_output[2], " T1:%d   T2:%d", Sensor1_temp, Sensor2_temp);
            sprintf((char *)lcd_output[3], " T3:%d   T4:%d", Sensor3_temp, Sensor4_temp);
          }
          else
          {
            sprintf((char *)lcd_output[2], " T1:%d   T2:%d", Sensor1_temp, Sensor2_temp);
            sprintf((char *)lcd_output[3], " T3:%d", Sensor3_temp);
          }
        }
        else
        {
          sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
          sprintf((char *)lcd_output[3], "   T2 %d `C", Sensor2_temp);
        }
      }
      else
      {
        sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
      }
    }
    else
    {
      strcpy((char *)lcd_output[2], "temp setting err!");
    }
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( gStartTest )
      printf("\ngValid_Nonce_Num = %d\n", gValid_Nonce_Num[v1]);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  }
}

//----- (0001B9EC) --------------------------------------------------------
void *__fastcall BHB91601_send_func(void *arg)
{
  int v1; // r9
  int v2; // r5
  unsigned int axi_fpga; // r0
  unsigned int pattern_number; // r5
  unsigned int v5; // r6
  work *v6; // r5
  char *v7; // r3
  unsigned __int8 *v8; // r2
  char *v9; // r1
  char v10; // t1
  vil_work_1391 *v11; // r3
  unsigned __int8 v12; // t1
  vil_work_1391 *p_work_vil_1391; // r3
  vil_work_1391 *v14; // r12
  unsigned int *v15; // r10
  int v16; // r1
  unsigned int *v17; // r12
  int v18; // r1
  work *v19; // r0
  work (*v20)[128]; // r10
  unsigned int v21; // r3
  unsigned int v23; // r3
  unsigned int i; // r2
  unsigned int v25; // r5
  unsigned int v26; // r7
  unsigned int j; // r6
  pthread_mutex_t *mutex; // [sp+10h] [bp-B8h]
  unsigned int which_core; // [sp+14h] [bp-B4h]
  work *works; // [sp+18h] [bp-B0h]
  unsigned int which_asic; // [sp+2Ch] [bp-9Ch]
  unsigned __int8 *v33; // [sp+30h] [bp-98h]
  vil_work_1391 work_vil_1391; // [sp+38h] [bp-90h] BYREF
  unsigned int buf_vil[13]; // [sp+6Ch] [bp-5Ch] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  memset(buf_vil, 0, sizeof(buf_vil));
  printf("\n--- %s: which_chain = %d, which_i2c = %d\n", (const char *)_FUNCTION___8330, v1, v2);
  if ( !gBegin_Get_Nonce )
  {
    axi_fpga = read_axi_fpga(7u);
    write_axi_fpga(7u, axi_fpga | 0x10000);
    gBegin_Get_Nonce = 1;
  }
  if ( BHB91601_ASIC_NUMBER )
  {
    pattern_number = Conf.pattern_number;
    v33 = &cgpu.workdataFilePrefix[60];
    mutex = &HW_check_mutex[v1];
    which_asic = 0;
    do
    {
      works = (work *)*((_DWORD *)v33 + 1);
      v33 += 4;
      for ( which_core = 0; which_core != 256; ++which_core )
      {
        v5 = 0;
        if ( pattern_number )
        {
          do
          {
            if ( gReadingTemp )
              usleep(0x2710u);
            if ( ((1 << gChain) & read_axi_fpga(3u)) != 0 )
            {
              v6 = &works[v5 + pattern_number * which_core];
              memset(buf_vil, 0, sizeof(buf_vil));
              memset(&work_vil_1391, 0, sizeof(work_vil_1391));
              v7 = (char *)&v6->nonce + 3;
              v8 = &v6->data[11];
              v9 = (char *)&work_vil_1391.work_count + 3;
              work_vil_1391.work_type = 1;
              work_vil_1391.chain_id = v1 | 0x80;
              work_vil_1391.work_count = v5;
              do
              {
                v10 = *++v7;
                *++v9 = v10;
              }
              while ( v8 != (unsigned __int8 *)v7 );
              v11 = (vil_work_1391 *)&work_vil_1391.data[11];
              do
              {
                v12 = *++v8;
                v11->chain_id = v12;
                v11 = (vil_work_1391 *)((char *)v11 + 1);
              }
              while ( v11 != (vil_work_1391 *)&work_vil_1391.midstate[31] );
              p_work_vil_1391 = &work_vil_1391;
              v14 = &work_vil_1391;
              buf_vil[0] = ((v1 | 0x80) << 16) | 0x1000000;
              buf_vil[1] = v5;
              v15 = &buf_vil[1];
              do
              {
                v16 = v14->data[1];
                v14 = (vil_work_1391 *)((char *)v14 + 4);
                v15[1] = HIBYTE(v14->work_count) | (v16 << 16) | (LOBYTE(v14->work_count) << 24) | (BYTE2(v14->work_count) << 8);
                ++v15;
              }
              while ( v14 != (vil_work_1391 *)&work_vil_1391.data[4] );
              v17 = &buf_vil[4];
              do
              {
                v18 = p_work_vil_1391->midstate[1];
                p_work_vil_1391 = (vil_work_1391 *)((char *)p_work_vil_1391 + 4);
                v17[1] = p_work_vil_1391->data[11] | (v18 << 16) | (p_work_vil_1391->data[8] << 24) | (p_work_vil_1391->data[10] << 8);
                ++v17;
              }
              while ( p_work_vil_1391 != (vil_work_1391 *)&work_vil_1391.midstate[12] );
              set_TW_write_command(buf_vil);
              pthread_mutex_lock(mutex);
              v19 = &gWorks_For_Hw_Check[v1][127];
              do
              {
                v20 = (work (*)[128])&v19[-1];
                memcpy(v19, &v19[-1], sizeof(work));
                v19 = (work *)v20;
              }
              while ( gWorks_For_Hw_Check[v1] != (work *)v20 );
              ++v5;
              v21 = (unsigned __int8)(gWork_Num_For_Hw_Check + 1);
              if ( v21 > 0x7E )
                LOBYTE(v21) = 127;
              gWork_Num_For_Hw_Check = v21;
              memcpy(gWorks_For_Hw_Check[v1], v6, 0x44u);
              pthread_mutex_unlock(mutex);
              ++gSend_Work_Num[v1];
            }
            else
            {
              usleep(0x3E8u);
            }
            pattern_number = Conf.pattern_number;
          }
          while ( v5 < Conf.pattern_number );
        }
      }
    }
    while ( BHB91601_ASIC_NUMBER > ++which_asic );
    v23 = gSend_Work_Num[v1];
    for ( i = (pattern_number * BHB91601_ASIC_NUMBER) << 8; v23 < i; i = (BHB91601_ASIC_NUMBER * Conf.pattern_number) << 8 )
    {
      printf("\n\n---%s: Chain%d send work num : %d, less than %d\n", (const char *)_FUNCTION___8330, v1, v23, i);
      v23 = gSend_Work_Num[v1];
    }
  }
  else
  {
    v23 = gSend_Work_Num[v1];
  }
  printf("\n\n---%s: Chain%d send work num : %d\n", (const char *)_FUNCTION___8330, v1, v23);
  puts("\nsend test pattern done");
  system("date");
  v25 = 0;
  putchar(10);
  v26 = gValid_Nonce_Num[v1];
  for ( j = v26; ; j = gValid_Nonce_Num[v1] )
  {
    ++v25;
    if ( v26 == j )
      break;
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    v26 = j;
    v25 = 0;
LABEL_35:
    ;
  }
  if ( v25 <= 2 )
  {
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    goto LABEL_35;
  }
  while ( gReadingTemp )
    usleep(0x2710u);
  start_receive = 0;
  puts("to stop receive");
  return 0;
}

//----- (0001BD44) --------------------------------------------------------
void reset_BHB91601_global_arg()
{
  unsigned int *v0; // r9
  unsigned int *v1; // r8
  unsigned int pattern_number; // r5
  unsigned int *v3; // r12
  unsigned int *v4; // r10
  bool (*v5)[4]; // r7
  int v6; // lr
  unsigned int v7; // r6
  unsigned int *v8; // r4
  unsigned __int8 *v9; // r11
  int v10; // t1
  unsigned int *v11; // r0
  int v12; // r3
  int v13; // r2
  int v14; // [sp+4h] [bp-34h]
  unsigned int v15; // [sp+8h] [bp-30h]
  unsigned __int8 *v16; // [sp+Ch] [bp-2Ch]

  v0 = gRepeated_Nonce_Id;
  gBM1391_MISC_CONTROL_reg = 14849;
  v1 = gValid_Nonce_Num;
  reset_global_arg();
  pattern_number = Conf.pattern_number;
  v3 = gSend_Work_Num;
  v4 = &gAsic_Core_Nonce_Num[0][0][255];
  v5 = gSensor_OK;
  v15 = BHB91601_ASIC_NUMBER;
  v14 = 3347151;
  v6 = 0;
  v7 = 68 * Conf.pattern_number;
  v16 = &cgpu.workdataFilePrefix[4 * BHB91601_ASIC_NUMBER + 60];
  do
  {
    v8 = v4;
    *v0++ = 0;
    *v1++ = 0;
    *(_BYTE *)++v14 = 0;
    *v3++ = 0;
    v9 = &cgpu.workdataFilePrefix[60];
    if ( v15 )
    {
      do
      {
        v10 = *((_DWORD *)v9 + 1);
        v9 += 4;
        v11 = v8 - 256;
        v12 = v10 + v6;
        do
        {
          v11[1] = 0;
          ++v11;
          v13 = v12 + v7;
          if ( pattern_number )
          {
            do
            {
              *(_DWORD *)(v12 + 52) = 0;
              v12 += 68;
            }
            while ( v12 != v13 );
          }
          v12 = v13;
        }
        while ( v11 != v8 );
        v8 += 1024;
      }
      while ( v9 != v16 );
    }
    v6 += 4;
    *(_BYTE *)v5 = 0;
    (*v5)[1] = 0;
    (*v5)[2] = 0;
    v4 += 0x20000;
    (*v5++)[3] = 0;
  }
  while ( v6 != 16 );
}

//----- (0001BE30) --------------------------------------------------------
bool __fastcall BHB91601_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain)
{
  printf("\n--- %s\n", (const char *)_FUNCTION___8155);
  gAT24C02_data_map[122] = 4;
  gAT24C02_data_map[0] = 126;
  gAT24C02_data_map[123] = Conf.TempSensor1;
  gAT24C02_data_map[121] = Conf.sensor_model;
  gAT24C02_data_map[125] = Conf.TempSensor2;
  gAT24C02_data_map[251] = Conf.HashBoard_Hardware_Version_2;
  gAT24C02_data_map[1] = (5 * cgpu.voltage + 1000) / 0x64;
  gAT24C02_data_map[252] = Conf.HashBoard_Bom_Version_1;
  gAT24C02_data_map[124] = 0;
  gAT24C02_data_map[127] = Conf.TempSensor3;
  gAT24C02_data_map[126] = 0;
  gAT24C02_data_map[129] = Conf.TempSensor4;
  gAT24C02_data_map[253] = Conf.HashBoard_Bom_Version_2;
  gAT24C02_data_map[250] = Conf.HashBoard_Hardware_Version_1;
  gAT24C02_data_map[128] = 0;
  gAT24C02_data_map[130] = 0;
  *(_WORD *)&gAT24C02_data_map[254] = CRC16(gAT24C02_data_map, 0xFEu);
  AT24C02_write_bytes(0, gAT24C02_data_map, which_iic, which_chain, 0x100u);
  if ( gAT24C02_data_map[255] == AT24C02_read_one_byte(0xFFu, which_iic, which_chain) )
  {
    printf("--- %s: save data into EEPROM success! \n", (const char *)_FUNCTION___8155);
    return 1;
  }
  else
  {
    gEEPROM_error = 1;
    printf("!!! %s: save data into EEPROM fail! \n", (const char *)_FUNCTION___8155);
    return 0;
  }
}

//----- (0001BF58) --------------------------------------------------------
int __fastcall BHB91601_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4

  v2 = Calibration_voltage(which_chain, which_i2c);
  if ( !v2 )
    return v2;
  pthread_cancel(cgpu.show_id);
  pthread_mutex_lock(&i2c_mutex);
  pthread_cancel(cgpu.pic_heart_beat_id);
  pthread_mutex_unlock(&i2c_mutex);
  switch ( v2 )
  {
    case -1:
      write_lcd(1u, "  Can not find  ", 0x10u);
      write_lcd_no_memset(2u, "  match voltage ", 0x10u);
      printf("\n!!! %s: Can't find match voltage!\n", (const char *)_FUNCTION___8161);
      return -1;
    case -2:
      write_lcd(0, " Maximum N value", 0x10u);
      write_lcd_no_memset(1u, " can not match  ", 0x10u);
      write_lcd_no_memset(2u, "    voltage     ", 0x10u);
      printf("\n!!! %s: Maximum N value can't match voltage!\n", (const char *)_FUNCTION___8161);
      return -2;
    case -3:
      write_lcd(0, " Minimum N value", 0x10u);
      write_lcd_no_memset(1u, " can not match  ", 0x10u);
      write_lcd_no_memset(2u, "    voltage     ", 0x10u);
      printf("\n!!! %s: Minimum N value can't match voltage!\n", (const char *)_FUNCTION___8161);
      return -3;
    default:
      return v2;
  }
}

//----- (0001C058) --------------------------------------------------------
void BHB91601_calculate_timeout_and_baud()
{
  _DWORD *v0; // r4
  unsigned int v1; // r6
  unsigned int v2; // r5
  unsigned int v3; // r0
  int v4; // r2
  unsigned int v5; // r3

  LOWORD(v0) = (unsigned __int16)&Conf;
  v1 = calculate_core_number(0x100u);
  switch ( pattern_test_time )
  {
    case 0u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[18];
      break;
    case 1u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[19];
      break;
    case 2u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[20];
      break;
    case 3u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[21];
      break;
    case 4u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[22];
      break;
    case 5u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[23];
      break;
    case 6u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[24];
      break;
    case 7u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[25];
      break;
    case 8u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[26];
      break;
    default:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = 0;
      printf("%s: pattern_test_time = %d, error!!! \n", (const char *)_FUNCTION___8178, pattern_test_time);
      break;
  }
  v3 = gChain_Asic_Interval * (0x1000000 / v1) / v2;
  v0[17] = v2;
  v4 = v0[67];
  v5 = cgpu.timeout_percent * v3 / 0x64;
  v0[69] = v5;
  printf("\n--- %s: baud = %d, timeout = 0x%08x = %d us, freq = %d\n", (const char *)_FUNCTION___8178, v4, v5, v5, v2);
}

//----- (0001C144) --------------------------------------------------------
void __fastcall BHB91601_set_address(unsigned __int8 which_chain)
{
  unsigned __int8 v2; // r4
  unsigned __int8 v3; // r5

  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8184_0, which_chain);
  BM1391_chain_inactive(which_chain);
  if ( BHB91601_ASIC_NUMBER )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      BM1391_set_address(which_chain, v3);
      ++v2;
      v3 += gChain_Asic_Interval;
      usleep(0x1388u);
    }
    while ( v2 < BHB91601_ASIC_NUMBER );
  }
}

//----- (0001C1A4) --------------------------------------------------------
void __fastcall BHB91601_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", (const char *)_FUNCTION___8192, which_chain, baud);
  BM1391_set_baud(which_chain, baud);
  usleep(0xC350u);
  set_fpga_baud(baud);
}

//----- (0001C1DC) --------------------------------------------------------
void __fastcall BHB91601_P_open_core(unsigned __int8 which_chain)
{
  int v1; // r4
  unsigned int axi_fpga; // r0
  int v3; // r8
  unsigned int v4; // r3
  unsigned int v5; // r0
  unsigned int buf_vil_tw[13]; // [sp+Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8199, v1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  v3 = 0;
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    BM1391_enable_core_clock(v1, 0, v3, 1u);
    usleep(0x1388u);
    while ( 1 )
    {
      v4 = read_axi_fpga(3u);
      if ( (v4 & (1 << v1)) != 0 )
        break;
      printf("%s: chain%d work fifo not ready: 0x%x\n", (const char *)_FUNCTION___8199, v1, v4);
      usleep(0xBB8u);
    }
    buf_vil_tw[0] = (v1 << 16) | 0x1000080;
    ++v3;
    set_TW_write_command(buf_vil_tw);
    usleep(Conf.OpenCoreGap);
  }
  while ( v3 != 256 );
  v5 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v5 | 0x400000);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (0001C2DC) --------------------------------------------------------
void __fastcall BHB91601_P_pre_open_core(unsigned __int8 which_chain)
{
  int v1; // r4
  unsigned int v2; // r8
  unsigned int axi_fpga; // r0
  unsigned int v4; // r3
  unsigned int v5; // r0
  unsigned int buf_vil_tw[13]; // [sp+Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8211, v1);
  v2 = 0;
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  if ( Conf.OpenCoreNum2 )
  {
    do
    {
      BM1391_enable_core_clock(v1, 0, v2, 1u);
      usleep(0x1388u);
      while ( 1 )
      {
        v4 = read_axi_fpga(3u);
        if ( (v4 & (1 << v1)) != 0 )
          break;
        printf("%s: chain%d work fifo not ready: 0x%x\n", (const char *)_FUNCTION___8211, v1, v4);
        usleep(0xBB8u);
      }
      buf_vil_tw[0] = (v1 << 16) | 0x1000080;
      set_TW_write_command(buf_vil_tw);
      ++v2;
      usleep(Conf.OpenCoreGap);
    }
    while ( Conf.OpenCoreNum2 > v2 );
  }
  v5 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v5 | 0x400000);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (0001C3E4) --------------------------------------------------------
void __fastcall BHB91601_S_open_core(unsigned __int8 which_chain)
{
  int v1; // r5
  unsigned int axi_fpga; // r0
  int v3; // r9
  int i; // r10
  unsigned __int8 v5; // r2
  unsigned int v6; // r0
  unsigned int buf_vil_tw[13]; // [sp+Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8226, v1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  axi_fpga = read_axi_fpga(0x40u);
  v3 = 0;
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    for ( i = 0; i != 4; ++i )
    {
      usleep(0x3E8u);
      v5 = v3 + ((_BYTE)i << 6);
      BM1391_enable_core_clock(v1, 0, v5, 1u);
    }
    usleep(0x1388u);
    while ( (read_axi_fpga(3u) & (1 << v1)) == 0 )
    {
      printf("%s: chain%d work fifo not ready: 0x%x\n", _FUNCTION___8226, v1);
      usleep(0xBB8u);
    }
    buf_vil_tw[0] = (v1 << 16) | 0x1000080;
    ++v3;
    set_TW_write_command(buf_vil_tw);
    usleep(Conf.OpenCoreGap);
  }
  while ( v3 != 64 );
  v6 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v6 | 0x400000);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (0001C500) --------------------------------------------------------
void __fastcall BHB91601_S_pre_open_core(unsigned __int8 which_chain)
{
  int v1; // r4
  unsigned int axi_fpga; // r0
  unsigned int v3; // r8
  int i; // r11
  unsigned __int8 v5; // r2
  unsigned int v6; // r3
  unsigned int buf_vil_tw[13]; // [sp+4h] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8244, v1);
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  if ( Conf.OpenCoreNum2 )
  {
    v3 = 0;
    do
    {
      for ( i = 0; i != 4; ++i )
      {
        usleep(0x3E8u);
        v5 = v3 + ((_BYTE)i << 6);
        BM1391_enable_core_clock(v1, 0, v5, 1u);
      }
      usleep(0x1388u);
      while ( 1 )
      {
        v6 = read_axi_fpga(3u);
        if ( (v6 & (1 << v1)) != 0 )
          break;
        printf("%s: chain%d work fifo not ready: 0x%x\n", (const char *)_FUNCTION___8244, v1, v6);
        usleep(0xBB8u);
      }
      buf_vil_tw[0] = (v1 << 16) | 0x1000080;
      set_TW_write_command(buf_vil_tw);
      ++v3;
      usleep(Conf.OpenCoreGap);
    }
    while ( Conf.OpenCoreNum2 > v3 );
  }
}

//----- (0001C5E8) --------------------------------------------------------
unsigned int __fastcall BHB91601_get_result(unsigned __int8 which_chain)
{
  unsigned int v1; // r4
  unsigned int v2; // r0
  unsigned int v3; // r1
  unsigned int v5; // r2
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v6; // r9
  int v7; // r4
  work *v8; // r7
  unsigned int v9; // r2
  unsigned int spins; // t1
  unsigned int v11; // r10
  unsigned int pattern_number; // r3
  int v13; // r1
  int v14; // r7
  bool *v15; // r1
  _BOOL4 v16; // r3
  bool v17; // zf
  int v18; // r3
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  unsigned int axi_fpga; // r0
  unsigned int v24; // [sp+0h] [bp-40h]
  unsigned int which_asic; // [sp+4h] [bp-3Ch]
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v26; // [sp+8h] [bp-38h]
  int v27; // [sp+Ch] [bp-34h]
  unsigned int ret; // [sp+10h] [bp-30h]
  unsigned int reta; // [sp+10h] [bp-30h]

  v27 = which_chain;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every ASIC require nonce number: %u\n", Conf.pattern_number << 8);
  if ( BHB91601_ASIC_NUMBER )
  {
    v1 = 0;
    do
    {
      if ( v1 == 10 * (v1 / 0xA) )
        putchar(10);
      v2 = calculate_how_many_nonce_per_asic_get(v27, v1, 0x100u);
      v3 = v1++;
      printf("asic[%02d]=%d\t", v3, v2);
    }
    while ( BHB91601_ASIC_NUMBER > v1 );
  }
  puts("\n");
  if ( BHB91601_ASIC_NUMBER )
  {
    ret = 7;
    which_asic = 0;
    v26 = &reg_mutex.__data._anon_0 + 0x20000 * v27;
    do
    {
      v5 = calculate_how_many_nonce_per_asic_get(v27, which_asic, 0x100u);
      if ( v5 < Conf.pattern_number << 8 )
      {
        printf("asic[%02d] = %d\n", which_asic, v5);
        v6 = v26;
        v7 = 0;
        v8 = cgpu.works[which_asic];
        v24 = 0;
        do
        {
          spins = v6[1].__spins;
          ++v6;
          v9 = spins;
          if ( spins < Conf.pattern_number )
          {
            v11 = 0;
            if ( v9 < Conf.Least_nonce_per_core )
              ++v24;
            printf("core[%03d] = %d,      lost these nonce : ", v7);
            pattern_number = Conf.pattern_number;
            if ( Conf.pattern_number )
            {
              do
              {
                while ( v8[v11 + pattern_number * v7].is_nonce_return_back[v27][0] )
                {
                  pattern_number = Conf.pattern_number;
                  if ( Conf.pattern_number <= ++v11 )
                    goto LABEL_20;
                }
                printf("%d  ", v11);
                pattern_number = Conf.pattern_number;
                ++v11;
              }
              while ( Conf.pattern_number > v11 );
            }
LABEL_20:
            putchar(10);
          }
          ++v7;
        }
        while ( v7 != 256 );
        if ( v24 > Conf.Invalid_Core_Num )
        {
          ret = 6;
          printf("\n error asic is %d\n", which_asic);
        }
        puts("\n");
      }
      v26 += 1024;
    }
    while ( BHB91601_ASIC_NUMBER > ++which_asic );
  }
  else
  {
    ret = 7;
  }
  printf("HW number = %d, Conf.Most_HW_Num = %d\n\n", gHw_Nonce_Num[v27], Conf.Most_HW_Num);
  v13 = ret;
  if ( gHw_Nonce_Num[v27] > Conf.Most_HW_Num )
    v13 = 6;
  v14 = v13;
  reta = v13;
  puts("\n------------------------------------------------------------------------------------------------------\n");
  v15 = gSensor_OK[v27];
  v16 = v15[2] && v15[1] && *v15;
  v17 = !v16 || !v15[3];
  if ( !v16 || !v15[3] )
    v16 = v14;
  if ( v17 )
    reta = v16 & 0xFFFFFFFD;
  v18 = gGlobalHighestTemp;
  if ( Conf.TargetTemp < gGlobalHighestTemp )
    v18 = reta;
  if ( Conf.TargetTemp < gGlobalHighestTemp )
    reta = v18 & 0xFFFFFFFB;
  printf(
    "Chain%d total valid nonce number: %d, lost %d nonce\n\n",
    v27,
    gValid_Nonce_Num[v27],
    ((BHB91601_ASIC_NUMBER * Conf.pattern_number) << 8) - gValid_Nonce_Num[v27],
    v24);
  printf(
    "Nonce rate = %f \n\n",
    (float)((float)((float)gValid_Nonce_Num[v27] * 100.0)
          / (float)((float)((float)Conf.pattern_number * 256.0) * (float)BHB91601_ASIC_NUMBER)));
  if ( (reta & 1) != 0 )
    LOWORD(v19) = -25288;
  else
    LOWORD(v19) = -25276;
  HIWORD(v19) = 2;
  puts(v19);
  if ( (reta & 2) != 0 )
    LOWORD(v20) = -21748;
  else
    LOWORD(v20) = -21736;
  HIWORD(v20) = 2;
  puts(v20);
  if ( (reta & 4) != 0 )
    LOWORD(v21) = -17364;
  else
    LOWORD(v21) = -17348;
  HIWORD(v21) = 2;
  puts(v21);
  printf("HW number = %d\n\n", gHw_Nonce_Num[v27]);
  axi_fpga = read_axi_fpga(0x3Eu);
  printf("CRC error number = %d\n\n", axi_fpga);
  return reta;
}
// 1C846: variable 'v24' is possibly undefined

//----- (0001C930) --------------------------------------------------------
void __fastcall BHB91601_print_lcd(unsigned int result)
{
  char v1; // r4
  unsigned __int8 *v2; // r1
  char *v3; // r1

  v1 = result;
  display_level_result_on_lcd();
  if ( (v1 & 1) != 0 )
  {
    write_lcd_no_memset(1u, "   Pattern OK   ", 0x10u);
    pattern_test_time = 0;
  }
  else
  {
    write_lcd_no_memset(1u, "   Pattern NG   ", 0x10u);
    ++pattern_test_time;
  }
  if ( (v1 & 2) != 0 )
    LOWORD(v2) = -17308;
  else
    LOWORD(v2) = -17288;
  HIWORD(v2) = 2;
  write_lcd_no_memset(2u, v2, 0x10u);
  if ( gEEPROM_error )
    v3 = "   EEPROM NG   ";
  else
    v3 = "   EEPROM OK   ";
  write_lcd_no_memset(3u, (unsigned __int8 *)v3, 0x10u);
}

//----- (0001C9D0) --------------------------------------------------------
int __fastcall BHB91601_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r5
  int v3; // r7
  unsigned int v4; // r6
  unsigned int v5; // r4
  work *v6; // r3
  int result; // r0
  int v8; // r4
  work *v9; // r4
  int v10; // r11
  work *v11; // r0
  int v12; // r0
  int *v13; // r3
  int v14; // r10
  unsigned int v15; // r3
  pthread_mutex_t *mutex; // [sp+8h] [bp-30h]
  int ret; // [sp+Ch] [bp-2Ch]

  v2 = buf[1];
  v3 = which_chain;
  v4 = HIBYTE(v2) / gChain_Asic_Interval;
  v5 = HIWORD(*buf) & 0x7FFF;
  if ( (*buf & 0x40) != 0 )
    printf(
      "\n!!! %s: nonce crc error! nonce = 0x%08x, which_asic = %d, which_core = %d, which_pattern = %d\n",
      (const char *)_FUNCTION___8302,
      v2,
      HIBYTE(v2) / gChain_Asic_Interval,
      (unsigned __int8)v2,
      HIWORD(*buf) & 0x7FFF);
  if ( v4 >= BHB91601_ASIC_NUMBER || v5 >= Conf.pattern_number )
    return -1;
  v6 = &cgpu.works[v4][v5 + Conf.pattern_number * (unsigned __int8)v2];
  if ( v2 == v6->nonce )
  {
    v13 = &v6->id + v3;
    result = v13[13];
    if ( result )
    {
      v13[13] = result + 1;
      result = 0;
      ++gRepeated_Nonce_Id[v3];
    }
    else
    {
      v14 = (unsigned __int8)v2 + ((v4 + (v3 << 7)) << 10);
      v13[13] = 1;
      v15 = gAsic_Core_Nonce_Num[0][0][v14] + 1;
      ++gValid_Nonce_Num[v3];
      gAsic_Core_Nonce_Num[0][0][v14] = v15;
    }
  }
  else
  {
    if ( gHw_Nonce_Num[v3] > Conf.Most_HW_Num )
      return 0;
    mutex = &HW_check_mutex[v3];
    pthread_mutex_lock(mutex);
    v8 = gWork_Num_For_Hw_Check;
    if ( gWork_Num_For_Hw_Check )
    {
      v9 = gWorks_For_Hw_Check[v3];
      v10 = 0;
      do
      {
        v11 = v9;
        ++v10;
        ++v9;
        v12 = check_hw(v11, v2, 0);
        if ( !v12 )
        {
          pthread_mutex_unlock(mutex);
          return 0;
        }
      }
      while ( gWork_Num_For_Hw_Check > v10 );
      ret = v12;
      pthread_mutex_unlock(mutex);
      if ( ret == 1 )
      {
        ++gHw_Nonce_Num[v3];
        printf(
          "%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n",
          (const char *)_FUNCTION___8302,
          v3,
          v4,
          (unsigned __int8)v2,
          v2);
      }
      return 0;
    }
    pthread_mutex_unlock(mutex);
    return v8;
  }
  return result;
}

//----- (0001CB8C) --------------------------------------------------------
int __fastcall BHB91601_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r4
  unsigned int v3; // r7
  reg_buf *v4; // r2
  char *v5; // r0
  unsigned int v6; // r1
  unsigned int reg_value_num; // r3

  v2 = *buf;
  v3 = buf[1];
  if ( reg_value_buf->reg_value_num > 0x1FE )
  {
    printf("%s: reg_value_buf buffer is full!\n", (const char *)_FUNCTION___8311);
    return -1;
  }
  else if ( (v2 & 0x40) != 0 )
  {
    printf("%s: reg crc error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8311, *buf, buf[1]);
    return -1;
  }
  else if ( (v2 & 0x20000000) != 0 )
  {
    printf("%s: REG_TYPE error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8311, *buf, buf[1]);
    return -1;
  }
  else
  {
    pthread_mutex_lock(&reg_mutex);
    v4 = reg_value_buf;
    v5 = (char *)v4 + 8 * v4->p_wr;
    v6 = reg_value_buf->p_wr + 1;
    *((_DWORD *)v5 + 4) = v3;
    v5[22] = HIBYTE(v2) & 0x1F;
    v5[20] = BYTE2(v2);
    v5[23] = v2 & 0xF;
    v5[21] = BYTE1(v2);
    reg_value_num = v4->reg_value_num;
    v4->p_wr = v6;
    if ( v6 >= 0x200 )
      v4->p_wr = 0;
    v4->reg_value_num = reg_value_num + 1;
    pthread_mutex_unlock(&reg_mutex);
    return 0;
  }
}

//----- (0001CC44) --------------------------------------------------------
void *__fastcall BHB91601_receive_func(void *arg)
{
  int v1; // r8
  int v2; // r5
  int priority_max; // r4
  pthread_t v4; // r6
  unsigned int v5; // r4
  void *result; // r0
  unsigned int v7; // r5
  sched_param sp; // [sp+4h] [bp-24h] BYREF
  unsigned int buf[2]; // [sp+8h] [bp-20h] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  buf[0] = 0;
  buf[1] = 0;
  priority_max = sched_get_priority_max(1);
  sp.__sched_priority = priority_max;
  v4 = pthread_self();
  if ( !pthread_setschedparam(v4, 1, &sp) )
    printf("\n--- %s: IO Thread #%lx using %d priority scheduler! ", (const char *)_FUNCTION___8375, v4, priority_max);
  printf("\n--- %s: which_chain = %d, which_i2c = %d\n\n", (const char *)_FUNCTION___8375, v1, v2);
  while ( 1 )
  {
    result = (void *)start_receive;
    if ( !start_receive )
      break;
    usleep(0x3E8u);
    v5 = read_axi_fpga(6u) & 0x1FF;
    if ( v5 )
    {
      v7 = 0;
      do
      {
        get_return_nonce(buf);
        if ( BM1391_is_nonce_or_reg_value(buf[0]) )
        {
          if ( gBegin_Get_Nonce )
          {
            if ( BM1391_check_nonce_flag(buf[0]) )
              BHB91601_check_nonce(v1, buf);
          }
        }
        else
        {
          BHB91601_check_register_value(v1, buf);
        }
        ++v7;
      }
      while ( v5 > v7 );
    }
  }
  return result;
}

//----- (0001CD10) --------------------------------------------------------
void singleBoardTest_BHB91601_BM1391()
{
  unsigned int axi_fpga; // r0
  unsigned int v1; // r0
  unsigned int i; // r10
  int Only_find_ASIC; // r8
  int v4; // r7
  int v5; // r2
  _BYTE *v6; // lr
  unsigned int v7; // r9
  unsigned int result; // r0
  unsigned int v9; // r5
  _BOOL4 line; // [sp+8h] [bp-40h]
  unsigned __int8 lcd_display_buf[16]; // [sp+10h] [bp-38h] BYREF

  memset(lcd_display_buf, 32, sizeof(lcd_display_buf));
  printf("\nBegin %s test\n", (const char *)_FUNCTION___8389);
  system("date");
  putchar(10);
  memset(lcd_output, 32, sizeof(lcd_output));
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  set_fpga_baud(0x1Au);
  write_axi_fpga(0x3Eu, 0);
  axi_fpga = read_axi_fpga(0);
  write_axi_fpga(0, axi_fpga | 0x40000000);
  reset_BHB91601_global_arg();
  check_chain();
  if ( gChain == 255 )
  {
    write_lcd(1u, " no hash board  ", 0x10u);
    puts("\nNo hash board, please plug in it");
    return;
  }
  if ( pthread_create(&cgpu.show_id, 0, BHB91601_show_status_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "   Creat show   ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1391_show_status_func fail\n\n\n", (const char *)_FUNCTION___8389);
    return;
  }
  gEEPROM_error = 0;
  pthread_mutex_init(&i2c_mutex, 0);
  if ( cgpu.repair_mode )
  {
    if ( Test_EEPROM_part_area() )
    {
      printf("\n!!! %s: Test_EEPROM_part_area: Check EEPROM error!!!\n\n", (const char *)_FUNCTION___8389);
      gEEPROM_error = 1;
    }
    else
    {
      printf("\n--- %s: Test_EEPROM_part_area: Check EEPROM ok!!!\n", (const char *)_FUNCTION___8389);
    }
  }
  else if ( Test_EEPROM() )
  {
    printf("\n!!! %s: Test_EEPROM: Check EEPROM error!!!\n\n", (const char *)_FUNCTION___8389);
    gEEPROM_error = 1;
  }
  else
  {
    printf("\n--- %s: Test_EEPROM: Check EEPROM ok!!!\n", (const char *)_FUNCTION___8389);
  }
  write_axi_fpga(0xDu, 0xFFFFu);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  reset_dsPIC33EP16GS202_pic(gChain, gI2c);
  jump_from_loader_to_app_dsPIC33EP16GS202(gChain, gI2c);
  if ( pthread_create(&cgpu.pic_heart_beat_id, 0, pic_heart_beat_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(cgpu.pic_heart_beat_id);
    pthread_mutex_unlock(&i2c_mutex);
    write_lcd(0, "Creat heart beat", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create pic_heart_beat_func fail\n\n\n", (const char *)_FUNCTION___8389);
    return;
  }
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  if ( !set_pre_open_core_voltage(gChain, gI2c) )
  {
    enable_dsPIC33EP16GS202_clamping_voltage(gChain, gI2c, 0);
    write_axi_fpga(0xDu, 0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
    start_receive = 1;
    usleep(0x2710u);
    if ( pthread_create(&cgpu.receive_id, 0, BHB91601_receive_func, &chain_info_0[gChain]) )
    {
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      pthread_cancel(cgpu.receive_id);
      write_lcd(0, "  Creat receive ", 0x10u);
      write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
      write_lcd_no_memset(3u, "   test again   ", 0x10u);
      printf("\n!!!%s: create BHB91601_receive_func fail\n\n\n", (const char *)_FUNCTION___8389);
      return;
    }
    v1 = read_axi_fpga(0x40u);
    write_axi_fpga(0x40u, v1 & 0xFFFF7E1F | 0x8100);
    printf(
      "\n---%s: Conf.OpenCoreNum1 = %d, Conf.OpenCoreNum2 = %d\n",
      (const char *)_FUNCTION___8389,
      Conf.OpenCoreNum1,
      Conf.OpenCoreNum2);
    if ( Conf.OpenCoreNum1 )
    {
      for ( i = 0; Conf.OpenCoreNum1 > i; ++i )
      {
        if ( gHashBoard_BHB91601P )
        {
          BHB91601_P_pre_open_core(gChain);
        }
        else
        {
          if ( !gHashBoard_BHB91601S )
          {
            line = gHashBoard_BHB91601S;
            pthread_cancel(cgpu.show_id);
            pthread_mutex_lock(&i2c_mutex);
            pthread_cancel(cgpu.pic_heart_beat_id);
            pthread_mutex_unlock(&i2c_mutex);
            pthread_cancel(cgpu.receive_id);
            write_lcd(line, "     Config     ", 0x10u);
            goto LABEL_31;
          }
          BHB91601_S_pre_open_core(gChain);
          usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
        }
      }
    }
    puts("\n--- BHB91601 check asic number");
    check_BM1391_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: J%d has asicNum = %d\n", gChain + 1, cgpu.chain_asic_num[gChain]);
    if ( cgpu.chain_asic_num[gChain] != BHB91601_ASIC_NUMBER )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
      write_lcd(0, "   Only have    ", 0x10u);
      write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
      write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
      printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8389, cgpu.chain_asic_num[gChain]);
      puts("----------------------------\n\n");
      sleep(Conf.close_power_delay);
LABEL_29:
      enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
      power_off();
      return;
    }
    BHB91601_set_baud(gChain, 0);
    reset_hash_board();
    set_fpga_baud(0x1Au);
    cgpu.chain_asic_num[gChain] = 0;
    puts("\n--- double check asic number");
    check_BM1391_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: J%d has asicNum = %d\n", gChain + 1, cgpu.chain_asic_num[gChain]);
    if ( cgpu.chain_asic_num[gChain] != BHB91601_ASIC_NUMBER )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
      write_lcd(0, "   Only have    ", 0x10u);
      write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
      write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
      printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8389, cgpu.chain_asic_num[gChain]);
      puts("----------------------------\n\n");
LABEL_34:
      sleep(Conf.close_power_delay);
      goto LABEL_29;
    }
    Only_find_ASIC = cgpu.Only_find_ASIC;
    if ( cgpu.Only_find_ASIC )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      write_lcd(1u, " find all ASIC  ", 0x10u);
      write_lcd_no_memset(2u, "       OK       ", 0x10u);
      printf("\nFind %d ASIC, OK\n", BHB91601_ASIC_NUMBER);
      goto LABEL_34;
    }
    BHB91601_calculate_timeout_and_baud();
    set_BM1391_freq(gChain, Only_find_ASIC, Conf.Freq, 1);
    BHB91601_set_address(gChain);
    BHB91601_set_baud(gChain, cgpu.baud);
    BM1391_set_TM(gChain, Only_find_ASIC, 0x3Fu, 1);
    write_axi_fpga(0x22u, Conf.timeout | 0x80000000);
    usleep(0x2710u);
    BM1391_soft_reset_sensor(gChain);
    BM1391_enable_extended_mode_of_temperature_sensor(gChain);
    v4 = Only_find_ASIC;
    while ( 1 )
    {
      v5 = v4++;
      v6 = (_BYTE *)(4 * gChain + 199468);
      if ( *v6 )
      {
        if ( v6[1] && v6[2] && v6[3] )
          break;
      }
      printf("\n---%s: check sensor %d time\n", _FUNCTION___8389, v5);
      BM1391_read_asic_temperature_local(gChain);
      if ( v4 == 3 )
        goto LABEL_43;
    }
    printf("\n---%s: check sensor ok\n", (const char *)_FUNCTION___8389);
LABEL_43:
    gIsReadTemp = 1;
    if ( gHashBoard_BHB91601P )
    {
      BHB91601_P_open_core(gChain);
    }
    else
    {
      v7 = gHashBoard_BHB91601S;
      if ( !gHashBoard_BHB91601S )
      {
        pthread_cancel(cgpu.show_id);
        pthread_mutex_lock(&i2c_mutex);
        pthread_cancel(cgpu.pic_heart_beat_id);
        pthread_mutex_unlock(&i2c_mutex);
        pthread_cancel(cgpu.receive_id);
        write_lcd(v7, "     Config     ", 0x10u);
LABEL_31:
        write_lcd_no_memset(1u, " Hashboard Type ", 0x10u);
        write_lcd_no_memset(2u, " in Config.ini  ", 0x10u);
        printf("\n!!!%s: Can't find Hashboard type when open core, fail\n\n\n", (const char *)_FUNCTION___8389);
        goto LABEL_29;
      }
      BHB91601_S_open_core(gChain);
    }
    adjust_voltage(gChain, gI2c);
    puts("\nBegin send test pattern");
    if ( !gStartTest )
    {
      if ( time_counter >= Conf.HeatingUpTime )
      {
LABEL_54:
        pthread_cancel(cgpu.receive_id);
        pthread_cancel(cgpu.show_id);
        pthread_mutex_lock(&i2c_mutex);
        pthread_cancel(cgpu.pic_heart_beat_id);
        pthread_mutex_unlock(&i2c_mutex);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, "Can't open core ", 0x10u);
        write_lcd_no_memset(1u, "change  to  next", 0x10u);
        write_lcd_no_memset(2u, (unsigned __int8 *)"voltage and freq", 0x10u);
        ++pattern_test_time;
        enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
        power_off();
        return;
      }
      while ( 1 )
      {
        usleep(0x2710u);
        if ( gStartTest )
          break;
        if ( Conf.HeatingUpTime <= time_counter )
          goto LABEL_54;
      }
    }
    if ( pthread_create(&cgpu.send_id, 0, BHB91601_send_func, &chain_info_0[gChain]) )
    {
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      pthread_cancel(cgpu.receive_id);
      write_lcd(0, "   Creat send   ", 0x10u);
      write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
      write_lcd_no_memset(3u, "   test again   ", 0x10u);
      printf("\n!!!%s: create BHB91601_send_func fail\n\n\n", (const char *)_FUNCTION___8389);
      goto LABEL_29;
    }
    pthread_join(cgpu.send_id, 0);
    pthread_join(cgpu.receive_id, 0);
    pthread_cancel(cgpu.show_id);
    result = BHB91601_get_result(gChain);
    v9 = result;
    if ( (result & 1) != 0 )
    {
      if ( gEEPROM_error )
      {
        printf("\n!!!%s: Don't save data into EEPROM, because EEPROM test fail!!\n\n", (const char *)_FUNCTION___8389);
      }
      else if ( BHB91601_AT24C02_write_total_data(gI2c, gChain) )
      {
        puts("\nEEPROM OK\n");
      }
      else
      {
        puts("\nEEPROM NG\n");
      }
      BHB91601_print_lcd(v9);
      sleep(Conf.close_power_delay);
    }
    else
    {
      BHB91601_print_lcd(result);
      sleep(Conf.close_power_delay);
      if ( pattern_test_time < (unsigned int)gHowManyVoltageLevel )
        goto LABEL_62;
    }
    enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
    power_off();
LABEL_62:
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(cgpu.pic_heart_beat_id);
    pthread_mutex_unlock(&i2c_mutex);
    set_fan_speed(0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  }
}

//----- (0001D7D8) --------------------------------------------------------
int open_key()
{
  int result; // r0

  result = open("/sys/class/gpio/gpio943/value", 2048);
  key_fd = result;
  if ( result < 0 )
  {
    puts("open key failed!!!");
    return key_fd;
  }
  return result;
}

//----- (0001D80C) --------------------------------------------------------
void close_key()
{
  close(key_fd);
  j_puts("key closed!!!");
}

//----- (0001D82C) --------------------------------------------------------
ssize_t __fastcall read_key(unsigned __int8 *value)
{
  ssize_t result; // r0

  lseek(key_fd, 0, 0);
  result = read(key_fd, value, 1u);
  if ( result != 1 )
  {
    printf("%s: can't read out key value\n", (const char *)_FUNCTION___5378);
    return -1;
  }
  return result;
}

//----- (0001D86C) --------------------------------------------------------
void __fastcall sha2_starts(sha2_context *ctx)
{
  ctx->state[0] = 1779033703;
  ctx->state[1] = -1150833019;
  ctx->state[2] = 1013904242;
  ctx->state[3] = -1521486534;
  ctx->state[4] = 1359893119;
  ctx->state[5] = -1694144372;
  ctx->state[6] = 528734635;
  ctx->state[7] = 1541459225;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
}

//----- (0001D8C8) --------------------------------------------------------
void __fastcall sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int v2; // r12
  unsigned int v3; // r8
  int v4; // r2
  int v5; // r12
  int v6; // r11
  uint32_t v7; // r3
  uint32_t v8; // r1
  int v9; // r0
  uint32_t v10; // r4
  uint32_t v11; // r0
  int v12; // lr
  uint32_t v13; // lr
  int v14; // r9
  uint32_t v15; // r12
  int v16; // r11
  uint32_t v17; // r1
  uint32_t v18; // r11
  int v19; // r6
  uint32_t v20; // r4
  uint32_t v21; // r6
  int v22; // r5
  uint32_t v23; // r7
  int v24; // r5
  int v25; // r8
  uint32_t v26; // r12
  int v27; // r8
  int v28; // r9
  uint32_t v29; // r11
  int v30; // r9
  int v31; // r1
  int v32; // r4
  int v33; // r7
  int v34; // r6
  int v35; // r0
  int v36; // r7
  int v37; // r12
  int v38; // r8
  int v39; // r12
  int v40; // lr
  int v41; // r9
  int v42; // lr
  int v43; // r3
  int v44; // r4
  int v45; // r3
  int v46; // r2
  uint32_t v47; // r5
  int v48; // r11
  int v49; // r2
  int v50; // r11
  int v51; // r12
  int v52; // r6
  int v53; // r5
  uint32_t v54; // r0
  int v55; // lr
  int v56; // r9
  int v57; // r4
  int v58; // r8
  uint32_t v59; // r9
  int v60; // r3
  int v61; // r10
  uint32_t v62; // r3
  int v63; // r8
  int v64; // r11
  uint32_t v65; // r8
  int v66; // r0
  uint32_t v67; // r5
  int v68; // r0
  int v69; // r2
  uint32_t v70; // r9
  int v71; // r2
  int v72; // lr
  uint32_t v73; // r3
  int v74; // lr
  int v75; // r10
  uint32_t v76; // r8
  int v77; // r10
  unsigned int v78; // r11
  int v79; // r7
  int v80; // r0
  int v81; // r7
  int v82; // r0
  int v83; // r2
  int v84; // r12
  int v85; // r5
  int v86; // lr
  int v87; // r4
  int v88; // r10
  uint32_t v89; // r4
  int v90; // r6
  int v91; // r7
  uint32_t v92; // r6
  int v93; // r3
  int v94; // r0
  uint32_t v95; // r8
  int v96; // r9
  int v97; // r9
  int v98; // r2
  uint32_t v99; // r4
  int v100; // r12
  uint32_t v101; // lr
  int v102; // r3
  uint32_t v103; // r8
  uint32_t v104; // r0
  int v105; // r10
  int v106; // r9
  uint32_t v107; // r10
  int v108; // r7
  uint32_t v109; // r2
  int v110; // r6
  uint32_t v111; // lr
  uint32_t v112; // r6
  int v113; // r4
  uint32_t v114; // r8
  int v115; // r4
  uint32_t v116; // r10
  uint32_t v117; // r9
  unsigned int v118; // r0
  int v119; // r1
  uint32_t v120; // r7
  int v121; // r1
  int v122; // r2
  uint32_t v123; // r6
  int v124; // r5
  uint32_t v125; // r8
  int v126; // r5
  int v127; // r0
  uint32_t v128; // r9
  int v129; // r0
  int v130; // r11
  int v131; // r1
  int v132; // r11
  int v133; // r12
  int v134; // r2
  int v135; // r12
  int v136; // r10
  int v137; // r5
  int v138; // r10
  int v139; // r7
  int v140; // r0
  int v141; // lr
  int v142; // r11
  int v143; // lr
  int v144; // r8
  int v145; // r12
  int v146; // r8
  unsigned int v147; // r2
  int v148; // r1
  int v149; // r10
  int v150; // r1
  int v151; // r7
  int v152; // r4
  int v153; // r9
  int v154; // r7
  int v155; // r0
  int v156; // lr
  int v157; // r0
  int v158; // r9
  int v159; // r8
  int v160; // r9
  int v161; // r11
  int v162; // r5
  int v163; // r10
  int v164; // r4
  int v165; // r3
  int v166; // r4
  int v167; // r11
  int v168; // r4
  int v169; // r11
  int v170; // r0
  int v171; // r2
  unsigned int v172; // r3
  int v173; // r1
  unsigned int v174; // r12
  int v175; // r2
  int v176; // r9
  int v177; // r1
  int v178; // r4
  int v179; // r10
  unsigned int v180; // r11
  int v181; // r8
  int v182; // r0
  int v183; // r3
  unsigned int v184; // r6
  unsigned int v185; // r5
  int v186; // r9
  int v187; // r0
  unsigned int v188; // r11
  int v189; // r2
  int v190; // r9
  int v191; // r4
  int v192; // r5
  int v193; // r6
  int v194; // r5
  unsigned int v195; // lr
  uint32_t F; // [sp+4h] [bp-A4h]
  uint32_t Fa; // [sp+4h] [bp-A4h]
  uint32_t Fb; // [sp+4h] [bp-A4h]
  uint32_t Fc; // [sp+4h] [bp-A4h]
  uint32_t Fd; // [sp+4h] [bp-A4h]
  uint32_t Fe; // [sp+4h] [bp-A4h]
  uint32_t Ff; // [sp+4h] [bp-A4h]
  uint32_t G; // [sp+8h] [bp-A0h]
  unsigned int Ga; // [sp+8h] [bp-A0h]
  uint32_t Gb; // [sp+8h] [bp-A0h]
  uint32_t Gc; // [sp+8h] [bp-A0h]
  uint32_t Gd; // [sp+8h] [bp-A0h]
  uint32_t Ge; // [sp+8h] [bp-A0h]
  int v209; // [sp+Ch] [bp-9Ch]
  unsigned int v210; // [sp+Ch] [bp-9Ch]
  uint32_t v211; // [sp+Ch] [bp-9Ch]
  int v212; // [sp+Ch] [bp-9Ch]
  unsigned int v213; // [sp+Ch] [bp-9Ch]
  unsigned int v214; // [sp+10h] [bp-98h]
  unsigned int v215; // [sp+10h] [bp-98h]
  int v216; // [sp+10h] [bp-98h]
  int v217; // [sp+10h] [bp-98h]
  int v218; // [sp+10h] [bp-98h]
  int v219; // [sp+10h] [bp-98h]
  unsigned int v220; // [sp+14h] [bp-94h]
  unsigned int v221; // [sp+14h] [bp-94h]
  unsigned int v222; // [sp+14h] [bp-94h]
  int v223; // [sp+14h] [bp-94h]
  unsigned int v224; // [sp+18h] [bp-90h]
  unsigned int v225; // [sp+18h] [bp-90h]
  unsigned int v226; // [sp+18h] [bp-90h]
  unsigned int v227; // [sp+1Ch] [bp-8Ch]
  unsigned int v228; // [sp+1Ch] [bp-8Ch]
  unsigned int v229; // [sp+1Ch] [bp-8Ch]
  int v230; // [sp+1Ch] [bp-8Ch]
  unsigned int v231; // [sp+20h] [bp-88h]
  unsigned int v232; // [sp+20h] [bp-88h]
  unsigned int v233; // [sp+20h] [bp-88h]
  unsigned int v234; // [sp+20h] [bp-88h]
  uint32_t B; // [sp+24h] [bp-84h]
  uint32_t Ba; // [sp+24h] [bp-84h]
  uint32_t Bb; // [sp+24h] [bp-84h]
  uint32_t Bc; // [sp+24h] [bp-84h]
  uint32_t H; // [sp+28h] [bp-80h]
  uint32_t Ha; // [sp+28h] [bp-80h]
  uint32_t Hb; // [sp+28h] [bp-80h]
  uint32_t Hc; // [sp+28h] [bp-80h]
  uint32_t Hd; // [sp+28h] [bp-80h]
  uint32_t E; // [sp+2Ch] [bp-7Ch]
  unsigned int v245; // [sp+30h] [bp-78h]
  int v246; // [sp+30h] [bp-78h]
  unsigned int v247; // [sp+30h] [bp-78h]
  unsigned int v248; // [sp+30h] [bp-78h]
  unsigned int v249; // [sp+34h] [bp-74h]
  unsigned int v250; // [sp+34h] [bp-74h]
  unsigned int v251; // [sp+34h] [bp-74h]
  int v252; // [sp+34h] [bp-74h]
  unsigned int v253; // [sp+38h] [bp-70h]
  unsigned int v254; // [sp+38h] [bp-70h]
  unsigned int v255; // [sp+38h] [bp-70h]
  unsigned int v256; // [sp+3Ch] [bp-6Ch]
  unsigned int v257; // [sp+3Ch] [bp-6Ch]
  int v258; // [sp+3Ch] [bp-6Ch]
  unsigned int v259; // [sp+40h] [bp-68h]
  unsigned int v260; // [sp+40h] [bp-68h]
  unsigned int v261; // [sp+40h] [bp-68h]
  int v262; // [sp+40h] [bp-68h]
  unsigned int v263; // [sp+44h] [bp-64h]
  unsigned int v264; // [sp+44h] [bp-64h]
  unsigned int v265; // [sp+44h] [bp-64h]
  unsigned int v266; // [sp+48h] [bp-60h]
  unsigned int v267; // [sp+48h] [bp-60h]
  unsigned int v268; // [sp+48h] [bp-60h]
  uint32_t D; // [sp+4Ch] [bp-5Ch]
  uint32_t Da; // [sp+4Ch] [bp-5Ch]
  int v271; // [sp+50h] [bp-58h]
  unsigned int v272; // [sp+50h] [bp-58h]
  unsigned int v273; // [sp+50h] [bp-58h]
  int v274; // [sp+54h] [bp-54h]
  unsigned int v275; // [sp+54h] [bp-54h]
  uint32_t v276; // [sp+58h] [bp-50h]
  uint32_t v277; // [sp+5Ch] [bp-4Ch]
  uint32_t v278; // [sp+60h] [bp-48h]
  unsigned int v280; // [sp+68h] [bp-40h]
  unsigned int v281; // [sp+6Ch] [bp-3Ch]
  uint32_t v282; // [sp+70h] [bp-38h]
  uint32_t v283; // [sp+74h] [bp-34h]
  uint32_t v284; // [sp+78h] [bp-30h]
  uint32_t v285; // [sp+7Ch] [bp-2Ch]

  v214 = _byteswap_ulong(*(_DWORD *)data);
  v224 = _byteswap_ulong(*((_DWORD *)data + 2));
  v220 = _byteswap_ulong(*((_DWORD *)data + 1));
  v227 = _byteswap_ulong(*((_DWORD *)data + 3));
  v2 = _byteswap_ulong(*((_DWORD *)data + 4));
  v3 = v2 + 961987163;
  v231 = v2;
  H = _byteswap_ulong(*((_DWORD *)data + 6));
  B = _byteswap_ulong(*((_DWORD *)data + 5));
  v245 = _byteswap_ulong(*((_DWORD *)data + 8));
  v266 = _byteswap_ulong(*((_DWORD *)data + 7));
  v271 = data[58];
  G = data[59];
  v249 = _byteswap_ulong(*((_DWORD *)data + 9));
  v253 = _byteswap_ulong(*((_DWORD *)data + 10));
  v209 = data[60];
  v256 = _byteswap_ulong(*((_DWORD *)data + 11));
  v4 = data[61];
  v5 = (data[57] << 16) | (data[56] << 24);
  v274 = data[63];
  v259 = _byteswap_ulong(*((_DWORD *)data + 12));
  v6 = data[62];
  v283 = ctx->state[6];
  E = ctx->state[4];
  v277 = ctx->state[1];
  v278 = ctx->state[5];
  v285 = ctx->state[7];
  v282 = ctx->state[2];
  v284 = ctx->state[3];
  v263 = _byteswap_ulong(*((_DWORD *)data + 13));
  v276 = ctx->state[0];
  v7 = (__ROR4__(E, 11) ^ __ROR4__(E, 6) ^ __ROR4__(E, 25)) + v285 + 1116352408 + ((v278 ^ v283) & E ^ v283) + v214;
  v8 = (__ROR4__(v276, 13) ^ __ROR4__(v276, 2) ^ __ROR4__(v276, 22)) + (v276 & v277 | (v276 | v277) & v282) + v7;
  v9 = (__ROR4__(v7 + v284, 11) ^ __ROR4__(v7 + v284, 6) ^ __ROR4__(v7 + v284, 25))
     + ((E ^ v278) & (v7 + v284) ^ v278)
     + v283
     + 1899447441
     + v220;
  v10 = (__ROR4__(v8, 13) ^ __ROR4__(v8, 2) ^ __ROR4__(v8, 22)) + ((v276 | v8) & v277 | v276 & v8) + v9;
  Ga = v5 | G | (v271 << 8);
  v11 = v9 + v282;
  v210 = (v4 << 16) | (v209 << 24) | v274 | (v6 << 8);
  v12 = v278
      - 1245643825
      + v224
      + ((E ^ (v7 + v284)) & v11 ^ E)
      + (__ROR4__(v11, 11) ^ __ROR4__(v11, 6) ^ __ROR4__(v11, 25));
  F = (__ROR4__(v10, 13) ^ __ROR4__(v10, 2) ^ __ROR4__(v10, 22)) + ((v8 | v10) & v276 | v8 & v10) + v12;
  v215 = (__ROR4__(v220, 18) ^ __ROR4__(v220, 7) ^ (v220 >> 3))
       + v214
       + v249
       + (__ROR4__(Ga, 19) ^ __ROR4__(Ga, 17) ^ (Ga >> 10));
  v13 = v12 + v277;
  v14 = (__ROR4__(v13, 11) ^ __ROR4__(v13, 6) ^ __ROR4__(v13, 25))
      + ((v7 + v284) ^ ((v7 + v284) ^ v11) & v13)
      + E
      - 373957723
      + v227;
  v15 = (__ROR4__(F, 13) ^ __ROR4__(F, 2) ^ __ROR4__(F, 22)) + ((v10 | F) & v8 | F & v10) + v14;
  v221 = (__ROR4__(v210, 19) ^ __ROR4__(v210, 17) ^ (v210 >> 10))
       + v220
       + v253
       + (__ROR4__(v224, 18) ^ __ROR4__(v224, 7) ^ (v224 >> 3));
  v16 = (__ROR4__(v276 + v14, 11) ^ __ROR4__(v276 + v14, 6) ^ __ROR4__(v276 + v14, 25))
      + ((v11 ^ v13) & (v276 + v14) ^ v11)
      + v3
      + v7
      + v284;
  v17 = v8 + v16;
  v18 = v16 + (F & v15 | (F | v15) & v10) + (__ROR4__(v15, 13) ^ __ROR4__(v15, 2) ^ __ROR4__(v15, 22));
  v19 = (__ROR4__(v17, 11) ^ __ROR4__(v17, 6) ^ __ROR4__(v17, 25))
      + ((v13 ^ (v276 + v14)) & v17 ^ v13)
      + v11
      + B
      + 1508970993;
  v20 = v10 + v19;
  v21 = v19 + ((v15 | v18) & F | v15 & v18) + (__ROR4__(v18, 13) ^ __ROR4__(v18, 2) ^ __ROR4__(v18, 22));
  v225 = v224
       + v256
       + (__ROR4__(v227, 18) ^ __ROR4__(v227, 7) ^ (v227 >> 3))
       + (__ROR4__(v215, 19) ^ __ROR4__(v215, 17) ^ (v215 >> 10));
  v22 = (__ROR4__(v20, 11) ^ __ROR4__(v20, 6) ^ __ROR4__(v20, 25))
      + v13
      + H
      - 1841331548
      + (((v276 + v14) ^ v17) & v20 ^ (v276 + v14));
  v23 = F + v22;
  v24 = v22 + (__ROR4__(v21, 13) ^ __ROR4__(v21, 2) ^ __ROR4__(v21, 22)) + ((v18 | v21) & v15 | v18 & v21);
  v25 = (__ROR4__(v23, 11) ^ __ROR4__(v23, 6) ^ __ROR4__(v23, 25))
      + ((v17 ^ v20) & v23 ^ v17)
      + v276
      + v14
      + v266
      - 1424204075;
  v26 = v15 + v25;
  v27 = v25 + (__ROR4__(v24, 13) ^ __ROR4__(v24, 2) ^ __ROR4__(v24, 22)) + ((v21 | v24) & v18 | v21 & v24);
  v28 = (__ROR4__(v26, 11) ^ __ROR4__(v26, 6) ^ __ROR4__(v26, 25)) + v17 + v245 - 670586216 + ((v20 ^ v23) & v26 ^ v20);
  v29 = v18 + v28;
  v30 = v28 + (__ROR4__(v27, 13) ^ __ROR4__(v27, 2) ^ __ROR4__(v27, 22)) + ((v24 | v27) & v21 | v24 & v27);
  v228 = (__ROR4__(v221, 19) ^ __ROR4__(v221, 17) ^ (v221 >> 10))
       + (__ROR4__(v231, 18) ^ __ROR4__(v231, 7) ^ (v231 >> 3))
       + v227
       + v259;
  v31 = (__ROR4__(v29, 11) ^ __ROR4__(v29, 6) ^ __ROR4__(v29, 25)) + v20 + v249 + 310598401 + ((v23 ^ v26) & v29 ^ v23);
  v32 = (v27 & v30 | (v27 | v30) & v24) + (__ROR4__(v30, 13) ^ __ROR4__(v30, 2) ^ __ROR4__(v30, 22)) + v31;
  Fa = v21 + v31;
  v33 = v23
      + v253
      + 607225278
      + ((v26 ^ v29) & Fa ^ v26)
      + (__ROR4__(v21 + v31, 11) ^ __ROR4__(v21 + v31, 6) ^ __ROR4__(Fa, 25));
  v34 = v24 + v33;
  v35 = __ROR4__(v24 + v33, 11);
  v36 = v33 + ((v30 | v32) & v27 | v30 & v32) + (__ROR4__(v32, 13) ^ __ROR4__(v32, 2) ^ __ROR4__(v32, 22));
  v37 = v26 + v256 + 1426881987 + ((v29 ^ Fa) & v34 ^ v29) + (v35 ^ __ROR4__(v34, 6) ^ __ROR4__(v34, 25));
  v38 = v27 + v37;
  v39 = v37 + (__ROR4__(v36, 13) ^ __ROR4__(v36, 2) ^ __ROR4__(v36, 22)) + ((v32 | v36) & v30 | v32 & v36);
  v40 = (__ROR4__(v38, 11) ^ __ROR4__(v38, 6) ^ __ROR4__(v38, 25)) + ((Fa ^ v34) & v38 ^ Fa) + v29 + v259 + 1925078388;
  v41 = v30 + v40;
  v42 = v40 + (__ROR4__(v39, 13) ^ __ROR4__(v39, 2) ^ __ROR4__(v39, 22)) + ((v36 | v39) & v32 | v36 & v39);
  v232 = v231
       + v263
       + (__ROR4__(B, 18) ^ __ROR4__(B, 7) ^ (B >> 3))
       + (__ROR4__(v225, 19) ^ __ROR4__(v225, 17) ^ (v225 >> 10));
  v43 = Fa + v263 - 2132889090 + ((v34 ^ v38) & v41 ^ v34) + (__ROR4__(v41, 11) ^ __ROR4__(v41, 6) ^ __ROR4__(v41, 25));
  v44 = v32 + v43;
  v45 = v43 + (__ROR4__(v42, 13) ^ __ROR4__(v42, 2) ^ __ROR4__(v42, 22)) + (v39 & v42 | (v39 | v42) & v36);
  v46 = v34 + Ga - 1680079193 + ((v38 ^ v41) & v44 ^ v38) + (__ROR4__(v44, 11) ^ __ROR4__(v44, 6) ^ __ROR4__(v44, 25));
  v47 = v36 + v46;
  v48 = __ROR4__(v36 + v46, 11);
  v49 = v46 + ((v42 | v45) & v39 | v42 & v45) + (__ROR4__(v45, 13) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22));
  Fb = v47;
  v50 = (v48 ^ __ROR4__(v47, 6) ^ __ROR4__(Fb, 25)) + v38 + v210 - 1046744716 + ((v41 ^ v44) & Fb ^ v41);
  v51 = v39 + v50;
  v52 = (v45 & v49 | (v45 | v49) & v42) + (__ROR4__(v49, 13) ^ __ROR4__(v49, 2) ^ __ROR4__(v49, 22)) + v50;
  Ba = B + Ga + (__ROR4__(H, 18) ^ __ROR4__(H, 7) ^ (H >> 3)) + (__ROR4__(v228, 19) ^ __ROR4__(v228, 17) ^ (v228 >> 10));
  v53 = v41 + v215 - 459576895 + ((v44 ^ v47) & v51 ^ v44) + (__ROR4__(v51, 11) ^ __ROR4__(v51, 6) ^ __ROR4__(v51, 25));
  v54 = H + v210;
  v55 = v42 + v53;
  Ha = v53 + (__ROR4__(v52, 13) ^ __ROR4__(v52, 2) ^ __ROR4__(v52, 22)) + ((v49 | v52) & v45 | v49 & v52);
  v56 = ((Fb ^ v51) & v55 ^ Fb) + v44 + v221 - 272742522 + (__ROR4__(v55, 11) ^ __ROR4__(v55, 6) ^ __ROR4__(v55, 25));
  v57 = v45 + v56;
  v58 = __ROR4__(v45 + v56, 11);
  v59 = v56 + ((v52 | Ha) & v49 | v52 & Ha) + (__ROR4__(Ha, 13) ^ __ROR4__(Ha, 2) ^ __ROR4__(Ha, 22));
  v60 = ((v51 ^ v55) & v57 ^ v51) + Fb + v225 + 264347078 + (v58 ^ __ROR4__(v57, 6) ^ __ROR4__(v57, 25));
  v61 = v49 + v60;
  v62 = v60 + (__ROR4__(v59, 13) ^ __ROR4__(v59, 2) ^ __ROR4__(v59, 22)) + ((Ha | v59) & v52 | Ha & v59);
  v63 = ((v55 ^ v57) & v61 ^ v55) + v51 + v228 + 604807628 + (__ROR4__(v61, 11) ^ __ROR4__(v61, 6) ^ __ROR4__(v61, 25));
  v64 = v52 + v63;
  v65 = v63 + ((v59 | v62) & Ha | v59 & v62) + (__ROR4__(v62, 13) ^ __ROR4__(v62, 2) ^ __ROR4__(v62, 22));
  D = v54
    + (__ROR4__(v266, 18) ^ __ROR4__(v266, 7) ^ (v266 >> 3))
    + (__ROR4__(v232, 19) ^ __ROR4__(v232, 17) ^ (v232 >> 10));
  v66 = v55 + v232 + 770255983 + ((v57 ^ v61) & v64 ^ v57) + (__ROR4__(v64, 11) ^ __ROR4__(v64, 6) ^ __ROR4__(v64, 25));
  v67 = Ha + v66;
  v68 = v66 + (v62 & v65 | (v62 | v65) & v59) + (__ROR4__(v65, 13) ^ __ROR4__(v65, 2) ^ __ROR4__(v65, 22));
  v69 = ((v61 ^ v64) & v67 ^ v61) + v57 + Ba + 1249150122 + (__ROR4__(v67, 11) ^ __ROR4__(v67, 6) ^ __ROR4__(v67, 25));
  v70 = v59 + v69;
  v71 = v69 + ((v65 | v68) & v62 | v65 & v68) + (__ROR4__(v68, 13) ^ __ROR4__(v68, 2) ^ __ROR4__(v68, 22));
  v72 = (__ROR4__(v70, 11) ^ __ROR4__(v70, 6) ^ __ROR4__(v70, 25)) + ((v64 ^ v67) & v70 ^ v64) + D + 1555081692 + v61;
  v73 = v62 + v72;
  v74 = v72 + ((v68 | v71) & v65 | v68 & v71) + (__ROR4__(v71, 13) ^ __ROR4__(v71, 2) ^ __ROR4__(v71, 22));
  Hb = (__ROR4__(v245, 18) ^ __ROR4__(v245, 7) ^ (v245 >> 3))
     + v266
     + v215
     + (__ROR4__(Ba, 19) ^ __ROR4__(Ba, 17) ^ (Ba >> 10));
  v75 = ((v67 ^ v70) & v73 ^ v67) + Hb + 1996064986 + v64 + (__ROR4__(v73, 11) ^ __ROR4__(v73, 6) ^ __ROR4__(v73, 25));
  v76 = v65 + v75;
  v77 = v75 + (__ROR4__(v74, 13) ^ __ROR4__(v74, 2) ^ __ROR4__(v74, 22)) + ((v71 | v74) & v68 | v71 & v74);
  v78 = (__ROR4__(D, 19) ^ __ROR4__(D, 17) ^ (D >> 10))
      + (__ROR4__(v249, 18) ^ __ROR4__(v249, 7) ^ (v249 >> 3))
      + v245
      + v221;
  v79 = ((v70 ^ v73) & v76 ^ v70) + v67 + v78 - 1740746414 + (__ROR4__(v76, 11) ^ __ROR4__(v76, 6) ^ __ROR4__(v76, 25));
  v246 = v68 + v79;
  v80 = __ROR4__(v68 + v79, 11);
  v81 = v79 + ((v74 | v77) & v71 | v74 & v77) + (__ROR4__(v77, 13) ^ __ROR4__(v77, 2) ^ __ROR4__(v77, 22));
  v250 = (__ROR4__(Hb, 19) ^ __ROR4__(Hb, 17) ^ (Hb >> 10))
       + (__ROR4__(v253, 18) ^ __ROR4__(v253, 7) ^ (v253 >> 3))
       + v249
       + v225;
  v82 = (v80 ^ __ROR4__(v246, 6) ^ __ROR4__(v246, 25)) + ((v73 ^ v76) & v246 ^ v73) + v70 + v250 - 1473132947;
  v83 = v71 + v82;
  v84 = ((v77 | v81) & v74 | v77 & v81) + (__ROR4__(v81, 13) ^ __ROR4__(v81, 2) ^ __ROR4__(v81, 22)) + v82;
  v254 = (__ROR4__(v256, 18) ^ __ROR4__(v256, 7) ^ (v256 >> 3))
       + v253
       + v228
       + (__ROR4__(v78, 19) ^ __ROR4__(v78, 17) ^ (v78 >> 10));
  v85 = ((v76 ^ v246) & v83 ^ v76)
      + v73
      + v254
      - 1341970488
      + (__ROR4__(v83, 11) ^ __ROR4__(v83, 6) ^ __ROR4__(v83, 25));
  Fc = v85 + (__ROR4__(v84, 13) ^ __ROR4__(v84, 2) ^ __ROR4__(v84, 22)) + ((v81 | v84) & v77 | v81 & v84);
  v86 = v74 + v85;
  v280 = (__ROR4__(v250, 19) ^ __ROR4__(v250, 17) ^ (v250 >> 10))
       + (__ROR4__(v259, 18) ^ __ROR4__(v259, 7) ^ (v259 >> 3))
       + v256
       + v232;
  v87 = ((v246 ^ v83) & v86 ^ v246)
      + v76
      + v280
      - 1084653625
      + (__ROR4__(v86, 11) ^ __ROR4__(v86, 6) ^ __ROR4__(v86, 25));
  v88 = v77 + v87;
  v89 = v87 + ((v84 | Fc) & v81 | v84 & Fc) + (__ROR4__(Fc, 13) ^ __ROR4__(Fc, 2) ^ __ROR4__(Fc, 22));
  v257 = (__ROR4__(v263, 18) ^ __ROR4__(v263, 7) ^ (v263 >> 3))
       + v259
       + Ba
       + (__ROR4__(v254, 19) ^ __ROR4__(v254, 17) ^ (v254 >> 10));
  v90 = ((v83 ^ v86) & v88 ^ v83) + v257 - 958395405 + v246 + (__ROR4__(v88, 11) ^ __ROR4__(v88, 6) ^ __ROR4__(v88, 25));
  v91 = v81 + v90;
  v92 = v90 + (Fc & v89 | (Fc | v89) & v84) + (__ROR4__(v89, 13) ^ __ROR4__(v89, 2) ^ __ROR4__(v89, 22));
  v247 = (__ROR4__(v280, 19) ^ __ROR4__(v280, 17) ^ (v280 >> 10))
       + (__ROR4__(Ga, 18) ^ __ROR4__(Ga, 7) ^ (Ga >> 3))
       + v263
       + D;
  v93 = (__ROR4__(v91, 11) ^ __ROR4__(v91, 6) ^ __ROR4__(v91, 25)) + ((v86 ^ v88) & v91 ^ v86) + v83 + v247 - 710438585;
  v94 = v84 + v93;
  v95 = ((v89 | v92) & Fc | v89 & v92) + (__ROR4__(v92, 13) ^ __ROR4__(v92, 2) ^ __ROR4__(v92, 22)) + v93;
  v260 = (__ROR4__(v210, 18) ^ __ROR4__(v210, 7) ^ (v210 >> 3))
       + Ga
       + Hb
       + (__ROR4__(v257, 19) ^ __ROR4__(v257, 17) ^ (v257 >> 10));
  v96 = ((v88 ^ v91) & v94 ^ v88)
      + v86
      + v260
      + 113926993
      + (__ROR4__(v84 + v93, 11) ^ __ROR4__(v94, 6) ^ __ROR4__(v94, 25));
  Gb = Fc + v96;
  v97 = v96 + (__ROR4__(v95, 13) ^ __ROR4__(v95, 2) ^ __ROR4__(v95, 22)) + ((v92 | v95) & v89 | v92 & v95);
  v264 = (__ROR4__(v215, 18) ^ __ROR4__(v215, 7) ^ (v215 >> 3))
       + v210
       + v78
       + (__ROR4__(v247, 19) ^ __ROR4__(v247, 17) ^ (v247 >> 10));
  v98 = ((v91 ^ (v84 + v93)) & Gb ^ v91)
      + v88
      + v264
      + 338241895
      + (__ROR4__(Gb, 11) ^ __ROR4__(Gb, 6) ^ __ROR4__(Gb, 25));
  v99 = v89 + v98;
  Fd = v98 + (__ROR4__(v97, 13) ^ __ROR4__(v97, 2) ^ __ROR4__(v97, 22)) + ((v95 | v97) & v92 | v95 & v97);
  v267 = (__ROR4__(v221, 18) ^ __ROR4__(v221, 7) ^ (v221 >> 3))
       + v215
       + v250
       + (__ROR4__(v260, 19) ^ __ROR4__(v260, 17) ^ (v260 >> 10));
  v100 = (__ROR4__(v99, 11) ^ __ROR4__(v99, 6) ^ __ROR4__(v99, 25)) + ((v94 ^ Gb) & v99 ^ v94) + v91 + v267 + 666307205;
  v101 = ((v97 | Fd) & v95 | v97 & Fd) + (__ROR4__(Fd, 13) ^ __ROR4__(Fd, 2) ^ __ROR4__(Fd, 22)) + v100;
  v211 = v92 + v100;
  v281 = (__ROR4__(v225, 18) ^ __ROR4__(v225, 7) ^ (v225 >> 3))
       + v221
       + v254
       + (__ROR4__(v264, 19) ^ __ROR4__(v264, 17) ^ (v264 >> 10));
  v102 = (__ROR4__(v92 + v100, 11) ^ __ROR4__(v92 + v100, 6) ^ __ROR4__(v211, 25))
       + ((Gb ^ v99) & v211 ^ Gb)
       + v281
       + 773529912
       + v94;
  v103 = v95 + v102;
  v104 = ((Fd | v101) & v97 | Fd & v101) + (__ROR4__(v101, 13) ^ __ROR4__(v101, 2) ^ __ROR4__(v101, 22)) + v102;
  v222 = (__ROR4__(v267, 19) ^ __ROR4__(v267, 17) ^ (v267 >> 10))
       + (__ROR4__(v228, 18) ^ __ROR4__(v228, 7) ^ (v228 >> 3))
       + v225
       + v280;
  v105 = ((v99 ^ (v92 + v100)) & v103 ^ v99)
       + Gb
       + v222
       + 1294757372
       + (__ROR4__(v103, 11) ^ __ROR4__(v103, 6) ^ __ROR4__(v103, 25));
  v106 = v97 + v105;
  v107 = v105 + (__ROR4__(v104, 13) ^ __ROR4__(v104, 2) ^ __ROR4__(v104, 22)) + ((v101 | v104) & Fd | v101 & v104);
  v229 = v228
       + (__ROR4__(v232, 18) ^ __ROR4__(v232, 7) ^ (v232 >> 3))
       + v257
       + (__ROR4__(v281, 19) ^ __ROR4__(v281, 17) ^ (v281 >> 10));
  v108 = ((v211 ^ v103) & v106 ^ v211)
       + v99
       + v229
       + 1396182291
       + (__ROR4__(v106, 11) ^ __ROR4__(v106, 6) ^ __ROR4__(v106, 25));
  v109 = Fd + v108;
  Fe = v108 + (__ROR4__(v107, 13) ^ __ROR4__(v107, 2) ^ __ROR4__(v107, 22)) + ((v104 | v107) & v101 | v104 & v107);
  v233 = (__ROR4__(Ba, 18) ^ __ROR4__(Ba, 7) ^ (Ba >> 3))
       + v232
       + v247
       + (__ROR4__(v222, 19) ^ __ROR4__(v222, 17) ^ (v222 >> 10));
  v110 = ((v103 ^ v106) & v109 ^ v103)
       + v233
       + 1695183700
       + v92
       + v100
       + (__ROR4__(v109, 11) ^ __ROR4__(v109, 6) ^ __ROR4__(v109, 25));
  v111 = v101 + v110;
  v112 = v110 + (__ROR4__(Fe, 13) ^ __ROR4__(Fe, 2) ^ __ROR4__(Fe, 22)) + ((v107 | Fe) & v104 | v107 & Fe);
  v272 = (__ROR4__(D, 18) ^ __ROR4__(D, 7) ^ (D >> 3))
       + Ba
       + v260
       + (__ROR4__(v229, 19) ^ __ROR4__(v229, 17) ^ (v229 >> 10));
  v113 = (__ROR4__(v111, 11) ^ __ROR4__(v111, 6) ^ __ROR4__(v111, 25))
       + ((v106 ^ v109) & v111 ^ v106)
       + v272
       + 1986661051
       + v103;
  Gc = v104 + v113;
  v114 = ((Fe | v112) & v107 | Fe & v112) + (__ROR4__(v112, 13) ^ __ROR4__(v112, 2) ^ __ROR4__(v112, 22)) + v113;
  Bb = (__ROR4__(Hb, 18) ^ __ROR4__(Hb, 7) ^ (Hb >> 3))
     + D
     + v264
     + (__ROR4__(v233, 19) ^ __ROR4__(v233, 17) ^ (v233 >> 10));
  v115 = (__ROR4__(v104 + v113, 11) ^ __ROR4__(v104 + v113, 6) ^ __ROR4__(v104 + v113, 25))
       + ((v109 ^ v111) & (v104 + v113) ^ v109)
       + Bb
       - 2117940946
       + v106;
  v116 = v107 + v115;
  v117 = ((v112 | v114) & Fe | v112 & v114) + (__ROR4__(v114, 13) ^ __ROR4__(v114, 2) ^ __ROR4__(v114, 22)) + v115;
  v118 = Hb
       + (__ROR4__(v78, 18) ^ __ROR4__(v78, 7) ^ (v78 >> 3))
       + v267
       + (__ROR4__(v272, 19) ^ __ROR4__(v272, 17) ^ (v272 >> 10));
  v119 = ((v111 ^ Gc) & v116 ^ v111)
       + v109
       + v118
       - 1838011259
       + (__ROR4__(v116, 11) ^ __ROR4__(v116, 6) ^ __ROR4__(v116, 25));
  v120 = Fe + v119;
  v121 = v119 + (__ROR4__(v117, 13) ^ __ROR4__(v117, 2) ^ __ROR4__(v117, 22)) + ((v114 | v117) & v112 | v114 & v117);
  Da = v78
     + (__ROR4__(v250, 18) ^ __ROR4__(v250, 7) ^ (v250 >> 3))
     + v281
     + (__ROR4__(Bb, 19) ^ __ROR4__(Bb, 17) ^ (Bb >> 10));
  Hc = v118;
  v122 = ((Gc ^ v116) & v120 ^ Gc)
       + v111
       + Da
       - 1564481375
       + (__ROR4__(v120, 11) ^ __ROR4__(v120, 6) ^ __ROR4__(v120, 25));
  v123 = v112 + v122;
  v212 = v122 + (__ROR4__(v121, 13) ^ __ROR4__(v121, 2) ^ __ROR4__(v121, 22)) + ((v117 | v121) & v114 | v117 & v121);
  v251 = (__ROR4__(v118, 19) ^ __ROR4__(v118, 17) ^ (v118 >> 10))
       + (__ROR4__(v254, 18) ^ __ROR4__(v254, 7) ^ (v254 >> 3))
       + v250
       + v222;
  v124 = ((v116 ^ v120) & v123 ^ v116)
       + Gc
       + v251
       - 1474664885
       + (__ROR4__(v123, 11) ^ __ROR4__(v123, 6) ^ __ROR4__(v123, 25));
  v125 = v114 + v124;
  v126 = v124 + (__ROR4__(v212, 13) ^ __ROR4__(v212, 2) ^ __ROR4__(v212, 22)) + ((v121 | v212) & v117 | v121 & v212);
  v275 = (__ROR4__(Da, 19) ^ __ROR4__(Da, 17) ^ (Da >> 10))
       + (__ROR4__(v280, 18) ^ __ROR4__(v280, 7) ^ (v280 >> 3))
       + v254
       + v229;
  v127 = ((v120 ^ v123) & v125 ^ v120)
       + v116
       + v275
       - 1035236496
       + (__ROR4__(v125, 11) ^ __ROR4__(v125, 6) ^ __ROR4__(v125, 25));
  v128 = v117 + v127;
  v129 = v127 + (__ROR4__(v126, 13) ^ __ROR4__(v126, 2) ^ __ROR4__(v126, 22)) + ((v212 | v126) & v121 | v212 & v126);
  Ff = (__ROR4__(v251, 19) ^ __ROR4__(v251, 17) ^ (v251 >> 10))
     + (__ROR4__(v257, 18) ^ __ROR4__(v257, 7) ^ (v257 >> 3))
     + v280
     + v233;
  v130 = ((v123 ^ v125) & v128 ^ v123)
       + v120
       + Ff
       - 949202525
       + (__ROR4__(v128, 11) ^ __ROR4__(v128, 6) ^ __ROR4__(v128, 25));
  v131 = v121 + v130;
  v132 = v130 + (__ROR4__(v129, 13) ^ __ROR4__(v129, 2) ^ __ROR4__(v129, 22)) + ((v126 | v129) & v212 | v126 & v129);
  Gd = (__ROR4__(v275, 19) ^ __ROR4__(v275, 17) ^ (v275 >> 10))
     + (__ROR4__(v247, 18) ^ __ROR4__(v247, 7) ^ (v247 >> 3))
     + v257
     + v272;
  v133 = ((v125 ^ v128) & v131 ^ v125)
       + v123
       + Gd
       - 778901479
       + (__ROR4__(v131, 11) ^ __ROR4__(v131, 6) ^ __ROR4__(v131, 25));
  v134 = v212 + v133;
  v135 = v133 + (__ROR4__(v132, 13) ^ __ROR4__(v132, 2) ^ __ROR4__(v132, 22)) + ((v129 | v132) & v126 | v129 & v132);
  v213 = (__ROR4__(v260, 18) ^ __ROR4__(v260, 7) ^ (v260 >> 3))
       + v247
       + Bb
       + (__ROR4__(Ff, 19) ^ __ROR4__(Ff, 17) ^ (Ff >> 10));
  v136 = ((v128 ^ v131) & v134 ^ v128)
       + v213
       - 694614492
       + v125
       + (__ROR4__(v134, 11) ^ __ROR4__(v134, 6) ^ __ROR4__(v134, 25));
  v137 = v126 + v136;
  v138 = v136 + (__ROR4__(v135, 13) ^ __ROR4__(v135, 2) ^ __ROR4__(v135, 22)) + ((v132 | v135) & v129 | v132 & v135);
  v226 = (__ROR4__(v264, 18) ^ __ROR4__(v264, 7) ^ (v264 >> 3))
       + v260
       + Hc
       + (__ROR4__(Gd, 19) ^ __ROR4__(Gd, 17) ^ (Gd >> 10));
  v139 = ((v131 ^ v134) & v137 ^ v131)
       + v226
       - 200395387
       + v128
       + (__ROR4__(v137, 11) ^ __ROR4__(v137, 6) ^ __ROR4__(v137, 25));
  v140 = v129 + v139;
  v216 = v139 + (__ROR4__(v138, 13) ^ __ROR4__(v138, 2) ^ __ROR4__(v138, 22)) + ((v135 | v138) & v132 | v135 & v138);
  v248 = (__ROR4__(v267, 18) ^ __ROR4__(v267, 7) ^ (v267 >> 3))
       + v264
       + Da
       + (__ROR4__(v213, 19) ^ __ROR4__(v213, 17) ^ (v213 >> 10));
  v141 = ((v134 ^ v137) & v140 ^ v134)
       + v131
       + v248
       + 275423344
       + (__ROR4__(v140, 11) ^ __ROR4__(v140, 6) ^ __ROR4__(v140, 25));
  v142 = v132 + v141;
  v255 = (__ROR4__(v281, 18) ^ __ROR4__(v281, 7) ^ (v281 >> 3))
       + v267
       + v251
       + (__ROR4__(v226, 19) ^ __ROR4__(v226, 17) ^ (v226 >> 10));
  v143 = v141 + (__ROR4__(v216, 13) ^ __ROR4__(v216, 2) ^ __ROR4__(v216, 22)) + ((v138 | v216) & v135 | v138 & v216);
  v144 = ((v137 ^ v140) & v142 ^ v137)
       + v255
       + 430227734
       + v134
       + (__ROR4__(v142, 11) ^ __ROR4__(v142, 6) ^ __ROR4__(v142, 25));
  v145 = v135 + v144;
  v146 = v144 + (__ROR4__(v143, 13) ^ __ROR4__(v143, 2) ^ __ROR4__(v143, 22)) + ((v216 | v143) & v138 | v216 & v143);
  v147 = (__ROR4__(v248, 19) ^ __ROR4__(v248, 17) ^ (v248 >> 10))
       + (__ROR4__(v222, 18) ^ __ROR4__(v222, 7) ^ (v222 >> 3))
       + v281
       + v275;
  v148 = ((v140 ^ v142) & v145 ^ v140)
       + v147
       + 506948616
       + v137
       + (__ROR4__(v145, 11) ^ __ROR4__(v145, 6) ^ __ROR4__(v145, 25));
  v149 = v138 + v148;
  v150 = v148 + ((v143 | v146) & v216 | v143 & v146) + (__ROR4__(v146, 13) ^ __ROR4__(v146, 2) ^ __ROR4__(v146, 22));
  v151 = (__ROR4__(v255, 19) ^ __ROR4__(v255, 17) ^ (v255 >> 10))
       + (__ROR4__(v229, 18) ^ __ROR4__(v229, 7) ^ (v229 >> 3))
       + v222
       + Ff;
  v152 = ((v142 ^ v145) & v149 ^ v142)
       + v140
       + v151
       + 659060556
       + (__ROR4__(v149, 11) ^ __ROR4__(v149, 6) ^ __ROR4__(v149, 25));
  v261 = v151;
  v153 = v216 + v152;
  v217 = v152 + (__ROR4__(v150, 13) ^ __ROR4__(v150, 2) ^ __ROR4__(v150, 22)) + ((v146 | v150) & v143 | v146 & v150);
  v154 = v153;
  v265 = (__ROR4__(v233, 18) ^ __ROR4__(v233, 7) ^ (v233 >> 3))
       + v229
       + Gd
       + (__ROR4__(v147, 19) ^ __ROR4__(v147, 17) ^ (v147 >> 10));
  v155 = ((v145 ^ v149) & v154 ^ v145)
       + v142
       + v265
       + 883997877
       + (__ROR4__(v154, 11) ^ __ROR4__(v154, 6) ^ __ROR4__(v154, 25));
  v156 = v143 + v155;
  v157 = v155 + ((v150 | v217) & v146 | v150 & v217) + (__ROR4__(v217, 13) ^ __ROR4__(v217, 2) ^ __ROR4__(v217, 22));
  v268 = (__ROR4__(v261, 19) ^ __ROR4__(v261, 17) ^ (v261 >> 10))
       + (__ROR4__(v272, 18) ^ __ROR4__(v272, 7) ^ (v272 >> 3))
       + v233
       + v213;
  v158 = ((v149 ^ v153) & v156 ^ v149)
       + v145
       + v268
       + 958139571
       + (__ROR4__(v156, 11) ^ __ROR4__(v156, 6) ^ __ROR4__(v156, 25));
  v159 = v146 + v158;
  v160 = v158 + (__ROR4__(v157, 13) ^ __ROR4__(v157, 2) ^ __ROR4__(v157, 22)) + ((v217 | v157) & v150 | v217 & v157);
  v273 = (__ROR4__(v265, 19) ^ __ROR4__(v265, 17) ^ (v265 >> 10))
       + (__ROR4__(Bb, 18) ^ __ROR4__(Bb, 7) ^ (Bb >> 3))
       + v272
       + v226;
  v161 = (__ROR4__(v159, 11) ^ __ROR4__(v159, 6) ^ __ROR4__(v159, 25))
       + ((v154 ^ v156) & v159 ^ v154)
       + v273
       + 1322822218
       + v149;
  v162 = v150 + v161;
  v163 = ((v157 | v160) & v217 | v157 & v160) + (__ROR4__(v160, 13) ^ __ROR4__(v160, 2) ^ __ROR4__(v160, 22)) + v161;
  v164 = (__ROR4__(Hc, 18) ^ __ROR4__(Hc, 7) ^ (Hc >> 3))
       + Bb
       + v248
       + (__ROR4__(v268, 19) ^ __ROR4__(v268, 17) ^ (v268 >> 10));
  v165 = v164 + 1537002063;
  Bc = v164;
  v166 = v217;
  v167 = (__ROR4__(v150 + v161, 11) ^ __ROR4__(v162, 6) ^ __ROR4__(v162, 25))
       + ((v156 ^ v159) & v162 ^ v156)
       + v165
       + v154;
  v218 = (v160 & v163 | (v160 | v163) & v157) + (__ROR4__(v163, 13) ^ __ROR4__(v163, 2) ^ __ROR4__(v163, 22)) + v167;
  v168 = v166 + v167;
  Hd = (__ROR4__(Da, 18) ^ __ROR4__(Da, 7) ^ (Da >> 3))
     + Hc
     + v255
     + (__ROR4__(v273, 19) ^ __ROR4__(v273, 17) ^ (v273 >> 10));
  v169 = (__ROR4__(v168, 11) ^ __ROR4__(v168, 6) ^ __ROR4__(v168, 25))
       + Hd
       + 1747873779
       + v156
       + ((v159 ^ v162) & v168 ^ v159);
  v170 = v157 + v169;
  v234 = (__ROR4__(v251, 18) ^ __ROR4__(v251, 7) ^ (v251 >> 3))
       + Da
       + v147
       + (__ROR4__(Bc, 19) ^ __ROR4__(Bc, 17) ^ (Bc >> 10));
  v171 = (__ROR4__(v170, 11) ^ __ROR4__(v170, 6) ^ __ROR4__(v170, 25))
       + ((v162 ^ v168) & v170 ^ v162)
       + v159
       + v234
       + 1955562222;
  v258 = (__ROR4__(v218, 13) ^ __ROR4__(v218, 2) ^ __ROR4__(v218, 22)) + ((v163 | v218) & v160 | v163 & v218) + v169;
  v223 = v160 + v171;
  v230 = v171 + ((v218 | v258) & v163 | v218 & v258) + (__ROR4__(v258, 13) ^ __ROR4__(v258, 2) ^ __ROR4__(v258, 22));
  v172 = (__ROR4__(Hd, 19) ^ __ROR4__(Hd, 17) ^ (Hd >> 10))
       + v261
       + (__ROR4__(v275, 18) ^ __ROR4__(v275, 7) ^ (v275 >> 3))
       + v251;
  v173 = ((v168 ^ v170) & (v160 + v171) ^ v168)
       + v172
       + 2024104815
       + v162
       + (__ROR4__(v160 + v171, 11) ^ __ROR4__(v160 + v171, 6) ^ __ROR4__(v160 + v171, 25));
  v174 = (__ROR4__(Ff, 18) ^ __ROR4__(Ff, 7) ^ (Ff >> 3))
       + v275
       + v265
       + (__ROR4__(v234, 19) ^ __ROR4__(v234, 17) ^ (v234 >> 10));
  v175 = v163 + v173;
  v176 = __ROR4__(v163 + v173, 11);
  v177 = v173 + ((v258 | v230) & v218 | v230 & v258) + (__ROR4__(v230, 13) ^ __ROR4__(v230, 2) ^ __ROR4__(v230, 22));
  v252 = v175;
  v178 = v168 + v174 - 2067236844 + ((v170 ^ v223) & v175 ^ v170) + (v176 ^ __ROR4__(v175, 6) ^ __ROR4__(v175, 25));
  v179 = (__ROR4__(v177, 13) ^ __ROR4__(v177, 2) ^ __ROR4__(v177, 22)) + (v230 & v177 | (v230 | v177) & v258) + v178;
  v180 = (__ROR4__(v172, 19) ^ __ROR4__(v172, 17) ^ (v172 >> 10))
       + Ff
       + (__ROR4__(Gd, 18) ^ __ROR4__(Gd, 7) ^ (Gd >> 3))
       + v268;
  v181 = __ROR4__(v218 + v178, 11) ^ __ROR4__(v218 + v178, 6);
  v219 = v218 + v178;
  v262 = __ROR4__(v180, 19) ^ __ROR4__(v180, 17) ^ (v180 >> 10);
  v182 = v170 + v180 - 1933114872 + ((v223 ^ v175) & v219 ^ v223) + (v181 ^ __ROR4__(v219, 25));
  v183 = (__ROR4__(v179, 13) ^ __ROR4__(v179, 2) ^ __ROR4__(v179, 22)) + ((v177 | v179) & v230 | v177 & v179) + v182;
  v184 = (__ROR4__(v213, 18) ^ __ROR4__(v213, 7) ^ (v213 >> 3)) + Gd;
  Ge = v258 + v182;
  v185 = (__ROR4__(v174, 19) ^ __ROR4__(v174, 17) ^ (v174 >> 10)) + v184 + v273;
  v186 = v185
       - 1866530822
       + v223
       + ((v175 ^ v219) & (v258 + v182) ^ v175)
       + (__ROR4__(v258 + v182, 11) ^ __ROR4__(v258 + v182, 6) ^ __ROR4__(v258 + v182, 25));
  v187 = ((v179 | v183) & v177 | v179 & v183) + (__ROR4__(v183, 13) ^ __ROR4__(v183, 2) ^ __ROR4__(v183, 22)) + v186;
  v188 = (__ROR4__(v226, 18) ^ __ROR4__(v226, 7) ^ (v226 >> 3)) + v213 + Bc;
  v189 = v230 + v186;
  v190 = v188
       + v262
       - 1538233109
       + v252
       + ((Ge ^ v219) & v189 ^ v219)
       + (__ROR4__(v230 + v186, 11) ^ __ROR4__(v189, 6) ^ __ROR4__(v189, 25));
  v191 = ((v183 | v187) & v179 | v183 & v187) + (__ROR4__(v187, 13) ^ __ROR4__(v187, 2) ^ __ROR4__(v187, 22)) + v190;
  v192 = (__ROR4__(v177 + v190, 11) ^ __ROR4__(v177 + v190, 6) ^ __ROR4__(v177 + v190, 25))
       + ((Ge ^ v189) & (v177 + v190) ^ Ge)
       + v226
       - 1090935817
       + (__ROR4__(v248, 18) ^ __ROR4__(v248, 7) ^ (v248 >> 3))
       + Hd
       + (__ROR4__(v185, 19) ^ __ROR4__(v185, 17) ^ (v185 >> 10))
       + v219;
  v193 = ((v187 | v191) & v183 | v187 & v191) + (__ROR4__(v191, 13) ^ __ROR4__(v191, 2) ^ __ROR4__(v191, 22)) + v192;
  v194 = v192 + v179;
  v195 = v248
       - 965641998
       + (__ROR4__(v255, 18) ^ __ROR4__(v255, 7) ^ (v255 >> 3))
       + v234
       + (__ROR4__(v188 + v262, 19) ^ __ROR4__(v188 + v262, 17) ^ ((v188 + v262) >> 10))
       + Ge
       + ((v189 ^ (v177 + v190)) & v194 ^ v189)
       + (__ROR4__(v194, 11) ^ __ROR4__(v194, 6) ^ __ROR4__(v194, 25));
  ctx->state[7] = v285 + v189;
  ctx->state[3] = v187 + v284;
  ctx->state[6] = v177 + v190 + v283;
  ctx->state[2] = v191 + v282;
  ctx->state[1] = v193 + v277;
  ctx->state[5] = v194 + v278;
  ctx->state[0] = ((v191 | v193) & v187 | v191 & v193)
                + (__ROR4__(v193, 13) ^ __ROR4__(v193, 2) ^ __ROR4__(v193, 22))
                + v276
                + v195;
  ctx->state[4] = v183 + E + v195;
}

//----- (0001F760) --------------------------------------------------------
void __fastcall sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  int v3; // r4
  const unsigned __int8 *v5; // r5
  uint32_t v6; // r7
  uint32_t v7; // r3
  bool v8; // cc
  int v9; // lr
  int v10; // r3
  const unsigned __int8 *v11; // r1
  unsigned __int8 *buffer; // r8
  size_t v13; // r2
  unsigned __int8 *v14; // r0

  v3 = ilen;
  if ( ilen <= 0 )
    return;
  v5 = input;
  v6 = ctx->total[0] & 0x3F;
  v7 = ctx->total[0] + ilen;
  v8 = ilen > v7;
  ctx->total[0] = v7;
  if ( ilen > v7 )
    v7 = ctx->total[1];
  v9 = 64 - v6;
  if ( v8 )
    ctx->total[1] = v7 + 1;
  v10 = v6;
  if ( v6 )
    v10 = 1;
  if ( ilen < v9 )
    v10 = 0;
  if ( v10 )
  {
    buffer = ctx->buffer;
    v13 = 64 - v6;
    v14 = &ctx->buffer[v6];
    v3 -= v9;
    v5 = &input[v9];
    v6 = 0;
    memcpy(v14, input, v13);
    sha2_process(ctx, buffer);
    if ( v3 <= 63 )
      goto LABEL_13;
  }
  else if ( ilen <= 63 )
  {
LABEL_14:
    j_memcpy(&ctx->buffer[v6], v5, v3);
    return;
  }
  do
  {
    v11 = v5;
    v3 -= 64;
    v5 += 64;
    sha2_process(ctx, v11);
  }
  while ( v3 > 63 );
LABEL_13:
  if ( v3 > 0 )
    goto LABEL_14;
}

//----- (0001F7E4) --------------------------------------------------------
void __fastcall sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  uint32_t v4; // r2
  uint32_t v5; // r3
  uint32_t v6; // r0
  uint32_t v7; // r6
  unsigned int v8; // lr
  unsigned int v9; // r7
  uint32_t v10; // r3
  unsigned int v11; // r1
  int v12; // r2
  unsigned __int8 msglen[8]; // [sp+0h] [bp-20h] BYREF

  v4 = ctx->total[0] & 0x3F;
  v11 = *(_QWORD *)ctx->total >> 29;
  v5 = 8 * ctx->total[0];
  v6 = HIWORD(v5);
  v7 = HIBYTE(v5);
  msglen[7] = v5;
  v8 = HIBYTE(v11);
  msglen[3] = v11;
  v9 = HIWORD(v11);
  v10 = v5 >> 8;
  msglen[5] = v6;
  msglen[2] = BYTE1(v11);
  LOWORD(v11) = -11396;
  if ( v4 > 0x37 )
    v12 = 120 - v4;
  else
    v12 = 56 - v4;
  HIWORD(v11) = 2;
  msglen[6] = v10;
  msglen[0] = v8;
  msglen[1] = v9;
  msglen[4] = v7;
  sha2_update(ctx, (const unsigned __int8 *)v11, v12);
  sha2_update(ctx, msglen, 8);
  *output = HIBYTE(ctx->state[0]);
  output[1] = HIWORD(ctx->state[0]);
  output[2] = BYTE1(ctx->state[0]);
  output[3] = ctx->state[0];
  output[4] = HIBYTE(ctx->state[1]);
  output[5] = HIWORD(ctx->state[1]);
  output[6] = BYTE1(ctx->state[1]);
  output[7] = ctx->state[1];
  output[8] = HIBYTE(ctx->state[2]);
  output[9] = HIWORD(ctx->state[2]);
  output[10] = BYTE1(ctx->state[2]);
  output[11] = ctx->state[2];
  output[12] = HIBYTE(ctx->state[3]);
  output[13] = HIWORD(ctx->state[3]);
  output[14] = BYTE1(ctx->state[3]);
  output[15] = ctx->state[3];
  output[16] = HIBYTE(ctx->state[4]);
  output[17] = HIWORD(ctx->state[4]);
  output[18] = BYTE1(ctx->state[4]);
  output[19] = ctx->state[4];
  output[20] = HIBYTE(ctx->state[5]);
  output[21] = HIWORD(ctx->state[5]);
  output[22] = BYTE1(ctx->state[5]);
  output[23] = ctx->state[5];
  output[24] = HIBYTE(ctx->state[6]);
  output[25] = HIWORD(ctx->state[6]);
  output[26] = BYTE1(ctx->state[6]);
  output[27] = ctx->state[6];
  output[28] = HIBYTE(ctx->state[7]);
  output[29] = HIWORD(ctx->state[7]);
  output[30] = BYTE1(ctx->state[7]);
  output[31] = ctx->state[7];
}

//----- (0001F8E8) --------------------------------------------------------
void __fastcall sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  sha2_context ctx; // [sp+0h] [bp-100h] BYREF

  ctx.state[0] = 1779033703;
  ctx.state[1] = -1150833019;
  ctx.state[2] = 1013904242;
  ctx.state[5] = -1694144372;
  ctx.total[0] = 0;
  ctx.total[1] = 0;
  ctx.state[3] = -1521486534;
  ctx.state[4] = 1359893119;
  ctx.state[6] = 528734635;
  ctx.state[7] = 1541459225;
  sha2_update(&ctx, input, ilen);
  sha2_finish(&ctx, output);
}

//----- (0001F960) --------------------------------------------------------
uint32_t __fastcall swab32(uint32_t v)
{
  return bswap32(v);
}

//----- (0001F964) --------------------------------------------------------
void __fastcall flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int v3; // r2
  char *v4; // r2
  char *v5; // r0
  unsigned int v6; // t1

  v3 = length >> 2;
  if ( v3 )
  {
    v4 = (char *)src_p + 4 * v3;
    v5 = (char *)dest_p - 4;
    do
    {
      v6 = *(_DWORD *)src_p;
      src_p = (char *)src_p + 4;
      *((_DWORD *)v5 + 1) = bswap32(v6);
      v5 += 4;
    }
    while ( src_p != v4 );
  }
}

//----- (0001F980) --------------------------------------------------------
void __fastcall flip32(void *dest_p, const void *src_p)
{
  char *v2; // r2
  char *v3; // r0
  char *v4; // r1
  unsigned int v5; // t1

  v2 = (char *)src_p - 4;
  v3 = (char *)dest_p - 4;
  v4 = (char *)src_p + 28;
  do
  {
    v5 = *((_DWORD *)v2 + 1);
    v2 += 4;
    *((_DWORD *)v3 + 1) = bswap32(v5);
    v3 += 4;
  }
  while ( v2 != v4 );
}

//----- (0001F998) --------------------------------------------------------
void *__fastcall BHB07601_send_func(void *arg)
{
  int v1; // r6
  int v2; // r5
  unsigned int axi_fpga; // r0
  unsigned int pattern_number; // r9
  unsigned int v5; // r4
  unsigned int v6; // r5
  work *v7; // r9
  char *v8; // r3
  unsigned __int8 *v9; // r1
  char *v10; // r0
  char v11; // t1
  vil_work_1397 *v12; // r3
  unsigned __int8 v13; // t1
  vil_work_1397 *p_work_vil_1397; // r3
  vil_work_1397 *v15; // r12
  unsigned int *v16; // r10
  int v17; // r1
  unsigned int *v18; // r12
  int v19; // r1
  unsigned int v20; // r3
  unsigned int v22; // r3
  unsigned int i; // r2
  __useconds_t v24; // r9
  unsigned int v25; // r5
  unsigned int v26; // r10
  unsigned int j; // r7
  unsigned int which_core; // [sp+10h] [bp-B0h]
  work *works; // [sp+14h] [bp-ACh]
  unsigned int which_asic; // [sp+24h] [bp-9Ch]
  unsigned __int8 *v32; // [sp+28h] [bp-98h]
  vil_work_1397 work_vil_1397; // [sp+30h] [bp-90h] BYREF
  unsigned int buf_vil[13]; // [sp+64h] [bp-5Ch] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  memset(buf_vil, 0, sizeof(buf_vil));
  printf("\n--- %s: which_chain = %d, which_i2c = %d\n", (const char *)_FUNCTION___8427, v1, v2);
  if ( !gBegin_Get_Nonce )
  {
    axi_fpga = read_axi_fpga(7u);
    write_axi_fpga(7u, axi_fpga | 0x10000);
    gBegin_Get_Nonce = 1;
  }
  if ( BHB07601_ASIC_NUMBER )
  {
    pattern_number = Conf.pattern_number;
    v5 = 0;
    v32 = &cgpu.workdataFilePrefix[60];
    which_asic = 0;
    do
    {
      works = (work *)*((_DWORD *)v32 + 1);
      v32 += 4;
      for ( which_core = 0; which_core != 672; ++which_core )
      {
        v6 = 0;
        if ( pattern_number )
        {
          do
          {
            if ( gReadingTemp )
              usleep(0x2710u);
            if ( ((1 << gChain) & read_axi_fpga(3u)) != 0 )
            {
              v7 = &works[v6 + pattern_number * which_core];
              memset(buf_vil, 0, sizeof(buf_vil));
              memset(&work_vil_1397, 0, sizeof(work_vil_1397));
              v8 = (char *)&v7->nonce + 3;
              v9 = &v7->data[11];
              work_vil_1397.work_type = 1;
              v10 = (char *)&work_vil_1397.work_count + 3;
              work_vil_1397.chain_id = v1 | 0x80;
              work_vil_1397.work_count = v5 & 0x7F | (v6 << 7);
              do
              {
                v11 = *++v8;
                *++v10 = v11;
              }
              while ( v9 != (unsigned __int8 *)v8 );
              v12 = (vil_work_1397 *)&work_vil_1397.data[11];
              do
              {
                v13 = *++v9;
                v12->chain_id = v13;
                v12 = (vil_work_1397 *)((char *)v12 + 1);
              }
              while ( v12 != (vil_work_1397 *)&work_vil_1397.midstate[31] );
              p_work_vil_1397 = &work_vil_1397;
              v15 = &work_vil_1397;
              buf_vil[0] = ((v1 | 0x80) << 16) | 0x1000000;
              buf_vil[1] = v5 & 0x7F | (v6 << 7);
              v16 = &buf_vil[1];
              do
              {
                v17 = v15->data[1];
                v15 = (vil_work_1397 *)((char *)v15 + 4);
                v16[1] = HIBYTE(v15->work_count) | (v17 << 16) | (LOBYTE(v15->work_count) << 24) | (BYTE2(v15->work_count) << 8);
                ++v16;
              }
              while ( v15 != (vil_work_1397 *)&work_vil_1397.data[4] );
              v18 = &buf_vil[4];
              do
              {
                v19 = p_work_vil_1397->midstate[1];
                p_work_vil_1397 = (vil_work_1397 *)((char *)p_work_vil_1397 + 4);
                v18[1] = p_work_vil_1397->data[11] | (v19 << 16) | (p_work_vil_1397->data[8] << 24) | (p_work_vil_1397->data[10] << 8);
                ++v18;
              }
              while ( &work_vil_1397.midstate[12] != (unsigned __int8 *)p_work_vil_1397 );
              ++v6;
              set_TW_write_command(buf_vil);
              v20 = v5++;
              memcpy(&gWorks_For_Hw_Check[v1][v20], v7, sizeof(gWorks_For_Hw_Check[v1][v20]));
              if ( v5 >= 0x80 )
                v5 = 0;
              ++gSend_Work_Num[v1];
            }
            else
            {
              usleep(0x3E8u);
            }
            pattern_number = Conf.pattern_number;
          }
          while ( v6 < Conf.pattern_number );
        }
      }
    }
    while ( BHB07601_ASIC_NUMBER > ++which_asic );
    v22 = gSend_Work_Num[v1];
    for ( i = 672 * pattern_number * BHB07601_ASIC_NUMBER;
          v22 < i;
          i = which_core * BHB07601_ASIC_NUMBER * Conf.pattern_number )
    {
      printf("\n\n---%s: Chain%d send work num : %d, less than %d\n", (const char *)_FUNCTION___8427, v1, v22, i);
      v22 = gSend_Work_Num[v1];
    }
  }
  else
  {
    v22 = gSend_Work_Num[v1];
  }
  printf("\n\n---%s: Chain%d send work num : %d\n", (const char *)_FUNCTION___8427, v1, v22);
  LOWORD(v24) = (unsigned __int16)&gAsic_Core_Nonce_Num[1][67][255];
  puts("\nsend test pattern done");
  v25 = 0;
  system("date");
  putchar(10);
  v26 = gValid_Nonce_Num[v1];
  for ( j = v26; ; j = gValid_Nonce_Num[v1] )
  {
    ++v25;
    HIWORD(v24) = (unsigned int)&gAsic_Core_Nonce_Num[1][67][255] >> 16;
    if ( v26 == j )
      break;
    usleep(v24);
    v26 = j;
    v25 = 0;
LABEL_33:
    ;
  }
  if ( v25 <= 2 )
  {
    usleep(v24);
    goto LABEL_33;
  }
  while ( gReadingTemp )
    usleep(0x2710u);
  start_receive = 0;
  puts("to stop receive");
  return 0;
}

//----- (0001FCCC) --------------------------------------------------------
void reset_BHB07601_global_arg()
{
  unsigned int *v0; // r9
  unsigned int *v1; // r8
  unsigned int pattern_number; // r5
  unsigned int *v3; // r12
  unsigned int *v4; // r10
  bool (*v5)[4]; // r7
  int v6; // lr
  unsigned int v7; // r6
  unsigned int *v8; // r4
  unsigned __int8 *v9; // r11
  int v10; // t1
  unsigned int *v11; // r0
  int v12; // r3
  int v13; // r2
  int v14; // [sp+4h] [bp-34h]
  unsigned int v15; // [sp+8h] [bp-30h]
  unsigned __int8 *v16; // [sp+Ch] [bp-2Ch]

  v0 = gRepeated_Nonce_Id;
  gBM1397_MISC_CONTROL_reg = 14849;
  v1 = gValid_Nonce_Num;
  reset_global_arg();
  pattern_number = Conf.pattern_number;
  v3 = gSend_Work_Num;
  v4 = &gAsic_Core_Nonce_Num[0][0][671];
  v5 = gSensor_OK;
  v15 = BHB07601_ASIC_NUMBER;
  v14 = 3347151;
  v6 = 0;
  v7 = 68 * Conf.pattern_number;
  v16 = &cgpu.workdataFilePrefix[4 * BHB07601_ASIC_NUMBER + 60];
  do
  {
    v8 = v4;
    *v0++ = 0;
    *v1++ = 0;
    *(_BYTE *)++v14 = 0;
    *v3++ = 0;
    v9 = &cgpu.workdataFilePrefix[60];
    if ( v15 )
    {
      do
      {
        v10 = *((_DWORD *)v9 + 1);
        v9 += 4;
        v11 = v8 - 672;
        v12 = v10 + v6;
        do
        {
          v11[1] = 0;
          ++v11;
          v13 = v12 + v7;
          if ( pattern_number )
          {
            do
            {
              *(_DWORD *)(v12 + 52) = 0;
              v12 += 68;
            }
            while ( v12 != v13 );
          }
          v12 = v13;
        }
        while ( v11 != v8 );
        v8 += 1024;
      }
      while ( v9 != v16 );
    }
    v6 += 4;
    *(_BYTE *)v5 = 0;
    (*v5)[1] = 0;
    (*v5)[2] = 0;
    v4 += 0x20000;
    (*v5++)[3] = 0;
  }
  while ( v6 != 16 );
}

//----- (0001FDB8) --------------------------------------------------------
void __cdecl dump_eeprom_info(eeprom_layout_t eeprom)
{
  eeprom_layout_t *v1; // r4
  int fixture_header_high; // t1

  v1 = (eeprom_layout_t *)((char *)&eeprom.fixture_version + 1);
  puts("\n--- dump eeprom info:");
  printf("fixture_header:      0x%04x\n", eeprom.fixture_header);
  printf("fixture_version:     0x%04x\n", eeprom.fixture_version);
  printf("hash_board_sn:       0x");
  do
  {
    fixture_header_high = HIBYTE(v1->fixture_header);
    v1 = (eeprom_layout_t *)((char *)v1 + 1);
    printf("%02x", fixture_header_high);
  }
  while ( v1 != (eeprom_layout_t *)&eeprom.hash_board_sn[19] );
  putchar(10);
  printf("pcb_version:         0x%04x\n", eeprom.pcb_version);
  printf("bom_version:         0x%04x\n", eeprom.bom_version);
  printf("temp_sensor_type:    0x%02x\n", eeprom.temp_sensor_type);
  printf("product_id:          0x%02x\n", eeprom.product_id);
  printf("crc_test_fixture:    0x%04x\n", eeprom.crc_test_fixture);
}

//----- (0001FE78) --------------------------------------------------------
bool __fastcall BHB07601_AT24C02_write_total_data(unsigned __int8 which_iic, unsigned __int8 which_chain)
{
  int v2; // r8
  int v3; // r9
  uint16_t v4; // r0
  unsigned __int8 v5; // r3
  _BOOL4 v6; // r9
  unsigned __int8 *v7; // r6
  uint8_t *v8; // r5
  int v9; // r4
  int v10; // lr
  int v11; // t1
  int v12; // r2
  int v13; // r12
  int v14; // t1
  unsigned __int8 v16[4]; // [sp+F0h] [bp-230h]
  unsigned __int8 v17[4]; // [sp+F4h] [bp-22Ch] BYREF
  eeprom_layout_t eeprom; // [sp+F8h] [bp-228h] BYREF
  eeprom_layout_t eeprom_rb; // [sp+1F8h] [bp-128h] BYREF
  eeprom_layout_t v20; // 0:r0.16,16:^0.240 BYREF

  v2 = which_iic;
  v3 = which_chain;
  memset(&eeprom, 0, sizeof(eeprom));
  eeprom.fixture_header = 255;
  memset(&eeprom_rb, 0, sizeof(eeprom_rb));
  eeprom_rb.fixture_header = 255;
  printf("\n--- %s\n", (const char *)_FUNCTION___8242);
  eeprom.fixture_header = 5015;
  eeprom.pcb_version = LOWORD(Conf.HashBoard_Hardware_Version_2) | (LOWORD(Conf.HashBoard_Hardware_Version_1) << 8);
  eeprom.temp_sensor_type = Conf.sensor_model;
  eeprom.product_id = Conf.HashBoard_Product_ID;
  eeprom.bom_version = LOWORD(Conf.HashBoard_Bom_Version_2) | (LOWORD(Conf.HashBoard_Bom_Version_1) << 8);
  eeprom.fixture_version = 1;
  memset(eeprom.hash_board_sn, 0, sizeof(eeprom.hash_board_sn));
  v4 = CRC16((const uint8_t *)&eeprom, 0x1Eu);
  v5 = v3;
  eeprom.crc_test_fixture = v4;
  *(_DWORD *)v17 = v3;
  *(_DWORD *)v16 = v2;
  v6 = 1;
  qmemcpy(eeprom.reserved_0, "ZZZZZZZZ", sizeof(eeprom.reserved_0));
  v7 = &v17[3];
  AT24C02_write_bytes(0, (unsigned __int8 *)&eeprom, v2, v5, 0x28u);
  memcpy(&v20.hash_board_sn[12], &eeprom.hash_board_sn[12], 0xF0u);
  *(_QWORD *)&v20.fixture_header = *(_QWORD *)&eeprom.fixture_header;
  *(_QWORD *)&v20.hash_board_sn[4] = *(_QWORD *)&eeprom.hash_board_sn[4];
  v8 = &eeprom.reserved_1[215];
  dump_eeprom_info(v20);
  v9 = 0;
  sleep(1u);
  AT24C02_read_bytes(0, (unsigned __int8 *)&eeprom_rb, v16[0], v17[0], 0x28u);
  do
  {
    v11 = *++v7;
    v10 = v11;
    v12 = v9;
    v14 = *++v8;
    v13 = v14;
    ++v9;
    if ( v10 != v14 )
    {
      v6 = 0;
      printf("!!! %s: eeprom[0x%x] 0x%x != 0x%x!\n", (const char *)_FUNCTION___8242, v12, v10, v13);
      gEEPROM_error = 1;
    }
  }
  while ( v9 != 40 );
  if ( v6 )
  {
    printf("--- %s: save data into EEPROM success! \n", (const char *)_FUNCTION___8242);
    return v6;
  }
  else
  {
    printf("!!! %s: save data into EEPROM fail! \n", (const char *)_FUNCTION___8242);
    printf("!!! %s: clear EEPROM data! \n", (const char *)_FUNCTION___8242);
    memset(&eeprom_rb, 255, 0x28u);
    AT24C02_write_bytes(0, (unsigned __int8 *)&eeprom_rb, v16[0], v17[0], 0x28u);
    return 0;
  }
}

//----- (00020008) --------------------------------------------------------
int __fastcall BHB07601_set_voltage(unsigned __int8 which_chain, unsigned __int8 which_i2c)
{
  int v2; // r4

  v2 = Calibration_voltage(which_chain, which_i2c);
  if ( !v2 )
    return v2;
  pthread_cancel(cgpu.show_id);
  pthread_mutex_lock(&i2c_mutex);
  pthread_cancel(cgpu.pic_heart_beat_id);
  pthread_mutex_unlock(&i2c_mutex);
  switch ( v2 )
  {
    case -1:
      write_lcd(1u, "  Can not find  ", 0x10u);
      write_lcd_no_memset(2u, "  match voltage ", 0x10u);
      printf("\n!!! %s: Can't find match voltage!\n", (const char *)_FUNCTION___8252);
      return -1;
    case -2:
      write_lcd(0, " Maximum N value", 0x10u);
      write_lcd_no_memset(1u, " can not match  ", 0x10u);
      write_lcd_no_memset(2u, "    voltage     ", 0x10u);
      printf("\n!!! %s: Maximum N value can't match voltage!\n", (const char *)_FUNCTION___8252);
      return -2;
    case -3:
      write_lcd(0, " Minimum N value", 0x10u);
      write_lcd_no_memset(1u, " can not match  ", 0x10u);
      write_lcd_no_memset(2u, "    voltage     ", 0x10u);
      printf("\n!!! %s: Minimum N value can't match voltage!\n", (const char *)_FUNCTION___8252);
      return -3;
    default:
      return v2;
  }
}

//----- (00020108) --------------------------------------------------------
void BHB07601_calculate_timeout_and_baud()
{
  _DWORD *v0; // r4
  unsigned int v1; // r6
  unsigned int v2; // r5
  unsigned int v3; // r0
  int v4; // r2
  unsigned int v5; // r3

  LOWORD(v0) = (unsigned __int16)&Conf;
  v1 = calculate_core_number(0x2A0u);
  switch ( pattern_test_time )
  {
    case 0u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[18];
      break;
    case 1u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[19];
      break;
    case 2u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[20];
      break;
    case 3u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[21];
      break;
    case 4u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[22];
      break;
    case 5u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[23];
      break;
    case 6u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[24];
      break;
    case 7u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[25];
      break;
    case 8u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[26];
      break;
    default:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = 0;
      printf("%s: pattern_test_time = %d, error!!! \n", (const char *)_FUNCTION___8269_0, pattern_test_time);
      break;
  }
  v3 = gChain_Asic_Interval * (0x1000000 / v1) / v2;
  v0[17] = v2;
  v4 = v0[67];
  v5 = cgpu.timeout_percent * v3 / 0x64;
  v0[69] = v5;
  printf("\n--- %s: baud = %d, timeout = 0x%08x = %d us, freq = %d\n", (const char *)_FUNCTION___8269_0, v4, v5, v5, v2);
}

//----- (000201F4) --------------------------------------------------------
void __fastcall BHB07601_set_address(unsigned __int8 which_chain)
{
  unsigned __int8 v2; // r4
  unsigned __int8 v3; // r5

  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8275, which_chain);
  BM1397_chain_inactive(which_chain);
  if ( BHB07601_ASIC_NUMBER )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      BM1397_set_address(which_chain, v3);
      ++v2;
      v3 += gChain_Asic_Interval;
      usleep(0x1388u);
    }
    while ( v2 < BHB07601_ASIC_NUMBER );
  }
}

//----- (00020254) --------------------------------------------------------
void __fastcall BHB07601_set_baud(unsigned __int8 which_chain, unsigned __int8 baud)
{
  unsigned int v3; // r5

  v3 = baud;
  printf("\n--- %s: Chain : %d, baud = %d\n", (const char *)_FUNCTION___8283_0, which_chain, baud);
  BM1397_set_baud(which_chain, v3);
}

//----- (0002027C) --------------------------------------------------------
void __fastcall BHB07601_open_core(unsigned __int8 which_chain)
{
  int v1; // r5
  unsigned int v2; // r9
  unsigned int axi_fpga; // r0
  unsigned int v4; // r4
  unsigned int v5; // r2
  unsigned int v6; // r0
  unsigned int buf_vil_tw[13]; // [sp+14h] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8293, v1);
  gIsOpenCoreEnd = 0;
  gIsOpeningCore = 1;
  v2 = 0;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    v4 = v2;
    do
    {
      usleep(0x3E8u);
      v5 = v4;
      v4 += 84;
      BM1397_enable_core_clock(v1, 0, v5, 1u);
    }
    while ( v4 != v2 + 336 );
    usleep(0x1388u);
    while ( ((1 << v1) & read_axi_fpga(3u)) == 0 )
    {
      printf("%s: chain%d work fifo not ready: 0x%x\n", _FUNCTION___8293, v1);
      usleep(0xBB8u);
    }
    ++v2;
    buf_vil_tw[0] = (v1 << 16) | 0x1000080;
    set_TW_write_command(buf_vil_tw);
    usleep(Conf.OpenCoreGap);
  }
  while ( v2 != 84 );
  v6 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v6 | 0x400000);
  gIsOpeningCore = 0;
  gIsOpenCoreEnd = 1;
}

//----- (00020394) --------------------------------------------------------
void __fastcall BHB07601_pre_open_core(unsigned __int8 which_chain)
{
  int v1; // r5
  unsigned int axi_fpga; // r0
  unsigned int v3; // r9
  unsigned int v4; // r4
  unsigned int v5; // r2
  unsigned int v6; // r3
  unsigned int buf_vil_tw[13]; // [sp+Ch] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8311_0, v1);
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  if ( Conf.OpenCoreNum2 )
  {
    v3 = 0;
    do
    {
      v4 = v3;
      do
      {
        usleep(0x3E8u);
        v5 = v4;
        v4 += 84;
        BM1397_enable_core_clock(v1, 0, v5, 1u);
      }
      while ( v3 + 336 != v4 );
      usleep(0x1388u);
      while ( 1 )
      {
        v6 = read_axi_fpga(3u);
        if ( ((1 << v1) & v6) != 0 )
          break;
        printf("%s: chain%d work fifo not ready: 0x%x\n", (const char *)_FUNCTION___8311_0, v1, v6);
        usleep(0xBB8u);
      }
      ++v3;
      buf_vil_tw[0] = (v1 << 16) | 0x1000080;
      set_TW_write_command(buf_vil_tw);
      usleep(Conf.OpenCoreGap);
    }
    while ( Conf.OpenCoreNum2 > v3 );
  }
}

//----- (00020478) --------------------------------------------------------
void __fastcall dump_core_lost_nonce(unsigned __int8 which_chain, unsigned __int8 which_asic)
{
  work *v2; // r10
  int v3; // r6
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v4; // r7
  int i; // r4
  unsigned int v6; // r2
  unsigned int spins; // t1
  unsigned int pattern_number; // r3
  unsigned int j; // r11

  v2 = cgpu.works[which_asic];
  v3 = 4 * (which_chain + 12);
  v4 = &reg_mutex.__data._anon_0 + 1024 * (which_asic + (which_chain << 7));
  for ( i = 0; i != 672; ++i )
  {
    while ( 1 )
    {
      spins = v4[1].__spins;
      ++v4;
      v6 = spins;
      if ( spins < Conf.pattern_number )
        break;
      if ( ++i == 672 )
        return;
    }
    printf("core[%03d] = %d,      lost these nonce : ", i, v6);
    pattern_number = Conf.pattern_number;
    for ( j = 0; Conf.pattern_number > j; ++j )
    {
      while ( *(unsigned int *)((char *)&v2[j + pattern_number * i].nonce + v3) )
      {
        pattern_number = Conf.pattern_number;
        if ( Conf.pattern_number <= ++j )
          goto LABEL_9;
      }
      printf("%d  ", j);
      pattern_number = Conf.pattern_number;
    }
LABEL_9:
    putchar(10);
  }
}

//----- (00020528) --------------------------------------------------------
unsigned int __fastcall BHB07601_get_result(unsigned __int8 which_chain)
{
  int v1; // r4
  int v2; // r6
  unsigned int v3; // r10
  unsigned int v4; // r3
  unsigned int v5; // lr
  unsigned int v6; // r1
  int v7; // r3
  unsigned int v8; // r10
  unsigned int *v9; // r6
  unsigned int v10; // r11
  unsigned int *v11; // r3
  unsigned int v12; // lr
  unsigned int v13; // r1
  unsigned int v14; // t1
  unsigned int v15; // r6
  unsigned int v16; // r7
  unsigned int v17; // r11
  unsigned int v18; // r0
  unsigned int v19; // r2
  unsigned int v20; // r1
  int v21; // r1
  int v22; // r6
  bool *v23; // r1
  bool v24; // r2
  bool v25; // r3
  _BOOL4 v26; // r1
  int v27; // r3
  bool v28; // zf
  int v29; // r3
  unsigned int v30; // r9
  unsigned int v31; // r7
  unsigned int v32; // r0
  unsigned int v33; // r3
  unsigned int v34; // r2
  unsigned int v35; // r2
  unsigned int v36; // r2
  unsigned int bad_chip_num; // r3
  int v39; // r6
  const char *v40; // r0
  const char *v41; // r0
  const char *v42; // r0
  const char *v43; // r0
  unsigned int axi_fpga; // r0
  unsigned int ret; // [sp+4h] [bp-34h]
  unsigned int reta; // [sp+4h] [bp-34h]

  v1 = which_chain;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  v2 = 0;
  v3 = 0;
  printf("every ASIC require nonce number: %u\n", 672 * Conf.pattern_number);
  ret = 15;
  while ( 1 )
  {
    v4 = BHB07601_ASIC_NUMBER;
    if ( v3 >= BHB07601_ASIC_NUMBER )
      break;
    v5 = calculate_how_many_nonce_per_asic_get(v1, v3, 0x2A0u);
    v6 = v3++;
    if ( v5 < 672 * Conf.pattern_number )
    {
      v7 = ret;
      if ( ++v2 > Conf.Invalid_Asic_Num )
        v7 = 14;
      ret = v7;
    }
    printf("IC[%02d]=%-10d", v6, v5);
    if ( (v3 & 3) == 0 )
      putchar(10);
  }
  if ( BHB07601_ASIC_NUMBER )
  {
    v8 = 0;
    v9 = &gAsic_Core_Nonce_Num[v1][0][671];
    do
    {
      v10 = calculate_how_many_nonce_per_asic_get(v1, v8, 0x2A0u);
      if ( v10 < 672 * Conf.pattern_number )
      {
        v11 = v9 - 672;
        v12 = 0;
        do
        {
          v14 = v11[1];
          ++v11;
          v13 = v14;
          if ( Conf.pattern_number > v14 && v13 < Conf.Least_nonce_per_core )
            ++v12;
        }
        while ( v9 != v11 );
        if ( v12 > Conf.Invalid_Core_Num )
        {
          ret = 14;
          printf("\nerror asic is %d\n", v8);
        }
        if ( Conf.Dump_Lost_Nonce )
        {
          printf("asic[%02d] = %d\n", v8, v10);
          dump_core_lost_nonce(v1, v8);
          puts("\n");
        }
      }
      v4 = BHB07601_ASIC_NUMBER;
      ++v8;
      v9 += 1024;
    }
    while ( BHB07601_ASIC_NUMBER > v8 );
  }
  v15 = 1;
  printf("\nevery Domain require nonce number: %u\n", v4 / 0xC * 168 * Conf.pattern_number);
  v16 = calculate_how_many_nonce_per_domain_get(v1, 0);
  printf("D[%02d]:%-10d ", 0, v16);
  do
  {
    while ( 1 )
    {
      v17 = v15 + 1;
      v18 = calculate_how_many_nonce_per_domain_get(v1, v15);
      v16 += v18;
      printf("D[%02d]:%-10d ", v15, v18);
      if ( ((v15 + 1) & 3) == 0 )
        break;
      ++v15;
      if ( v17 == 48 )
        goto LABEL_26;
    }
    v19 = v16;
    v20 = v15++ >> 2;
    v16 = 0;
    printf("D_BIG[%02d]:%-10d\n", v20, v19);
  }
  while ( v17 != 48 );
LABEL_26:
  printf("\nHW number = %d, Conf.Most_HW_Num = %d\n\n", gHw_Nonce_Num[v1], Conf.Most_HW_Num);
  v21 = ret;
  if ( gHw_Nonce_Num[v1] > Conf.Most_HW_Num )
    v21 = 14;
  v22 = v21;
  reta = v21;
  puts("\n------------------------------------------------------------------------------------------------------\n");
  v23 = gSensor_OK[v1];
  v24 = v23[1];
  v25 = v23[2];
  v26 = v23[3];
  v27 = v25 && v24 && gSensor_OK[v1][0];
  v28 = (v27 & v26) == 0;
  if ( (v27 & v26) == 0 )
    v27 = v22;
  if ( v28 )
    v27 &= ~2u;
  if ( v28 )
    reta = v27;
  v29 = gHigherThanAlarmTemp;
  if ( Conf.TargetTemp < gGlobalHighestTemp )
    v29 = gHigherThanAlarmTemp | 1;
  if ( v29 )
    reta &= ~4u;
  gBad_Chip.idx[0] = 0;
  gBad_Chip.idx[1] = 0;
  gBad_Chip.idx[2] = 0;
  gBad_Chip.idx[3] = 0;
  gBad_Chip.nonce_num[0] = 672 * Conf.pattern_number;
  gBad_Chip.nonce_num[1] = 672 * Conf.pattern_number;
  gBad_Chip.nonce_num[2] = 672 * Conf.pattern_number;
  gBad_Chip.nonce_num[3] = 672 * Conf.pattern_number;
  if ( BHB07601_ASIC_NUMBER )
  {
    v30 = 0;
    v31 = 1;
    do
    {
      v32 = calculate_how_many_nonce_per_asic_get(v1, v31 - 1, 0x2A0u);
      if ( v32 < 672 * Conf.pattern_number * Conf.bad_chip_nonce_rate / 0x64 )
      {
        v33 = gBad_Chip.nonce_num[0];
        ++v30;
        if ( v32 <= gBad_Chip.nonce_num[0] )
        {
          gBad_Chip.nonce_num[0] = v32;
          v34 = gBad_Chip.idx[2];
          gBad_Chip.idx[2] = gBad_Chip.idx[1];
          gBad_Chip.idx[3] = v34;
          v35 = gBad_Chip.nonce_num[2];
          gBad_Chip.nonce_num[2] = gBad_Chip.nonce_num[1];
          gBad_Chip.nonce_num[1] = v33;
          gBad_Chip.nonce_num[3] = v35;
          v36 = gBad_Chip.idx[0];
          gBad_Chip.idx[0] = v31;
          gBad_Chip.idx[1] = v36;
        }
      }
    }
    while ( BHB07601_ASIC_NUMBER > v31++ );
  }
  else
  {
    v30 = 0;
  }
  bad_chip_num = Conf.bad_chip_num;
  gBad_Chip.total_badchip = v30;
  LOWORD(v39) = (unsigned __int16)gValid_Nonce_Num;
  if ( Conf.bad_chip_num <= v30 )
    bad_chip_num = reta;
  HIWORD(v39) = (unsigned int)gValid_Nonce_Num >> 16;
  if ( Conf.bad_chip_num <= v30 )
    reta = bad_chip_num & 0xFFFFFFF7;
  printf("Chain%d total bad number: %d\n\n", v1, v30);
  printf(
    "Chain%d total valid nonce number: %d, lost %d nonce\n\n",
    v1,
    *(_DWORD *)(v39 + 4 * v1),
    672 * BHB07601_ASIC_NUMBER * Conf.pattern_number - *(_DWORD *)(v39 + 4 * v1));
  printf(
    "Nonce rate = %f%% \n\n",
    (float)((float)((float)*(unsigned int *)(v39 + 4 * v1) * 100.0)
          / (float)((float)((float)Conf.pattern_number * 672.0) * (float)BHB07601_ASIC_NUMBER)));
  if ( (reta & 1) != 0 )
    LOWORD(v40) = -25288;
  else
    LOWORD(v40) = -25276;
  HIWORD(v40) = 2;
  puts(v40);
  if ( (reta & 2) != 0 )
    LOWORD(v41) = -21748;
  else
    LOWORD(v41) = -21736;
  HIWORD(v41) = 2;
  puts(v41);
  if ( (reta & 4) != 0 )
    LOWORD(v42) = -17364;
  else
    LOWORD(v42) = -17348;
  HIWORD(v42) = 2;
  puts(v42);
  if ( (reta & 8) != 0 )
    LOWORD(v43) = -10412;
  else
    LOWORD(v43) = -10392;
  HIWORD(v43) = 2;
  puts(v43);
  printf("HW number = %d\n\n", gHw_Nonce_Num[v1]);
  axi_fpga = read_axi_fpga(0x3Eu);
  printf("CRC error number = %d\n\n", axi_fpga);
  return reta;
}

//----- (0002096C) --------------------------------------------------------
void __fastcall BHB07601_print_lcd(unsigned int result)
{
  char v1; // r6
  int v2; // r5
  unsigned __int8 *v3; // r1
  bad_chip *v4; // r4
  unsigned int v5; // r7
  int v6; // r0
  unsigned __int8 badchip_info[16]; // [sp+8h] [bp-30h] BYREF

  v1 = result;
  display_level_result_on_lcd();
  v2 = v1 & 8;
  memset(badchip_info, 32, sizeof(badchip_info));
  if ( (v1 & 8) != 0 )
  {
    puts("Bad Chip Check OK\n");
    if ( (v1 & 1) != 0 )
    {
      write_lcd_no_memset(1u, "   Pattern OK   ", 0x10u);
      pattern_test_time = 0;
    }
    else
    {
      write_lcd_no_memset(1u, "   Pattern NG   ", 0x10u);
      ++pattern_test_time;
    }
    if ( (v1 & 2) != 0 )
      LOWORD(v3) = -17308;
    else
      LOWORD(v3) = -17288;
    HIWORD(v3) = 2;
    write_lcd_no_memset(2u, v3, 0x10u);
    if ( gEEPROM_error )
      write_lcd_no_memset(3u, "   EEPROM NG   ", 0x10u);
    else
      write_lcd_no_memset(3u, "   EEPROM OK   ", 0x10u);
  }
  else
  {
    v4 = &gBad_Chip;
    memset(badchip_info, 32, sizeof(badchip_info));
    printf("BadChip Num=%2d ", gBad_Chip.total_badchip);
    sprintf((char *)badchip_info, "BadChip Num=%2d ", gBad_Chip.total_badchip);
    write_lcd_no_memset(1u, badchip_info, 0x10u);
    do
    {
      printf("%2d-%4d  %2d-%4d\n", v4->idx[0], v4->nonce_num[0], v4->idx[1], v4->nonce_num[1]);
      v5 = v4->idx[0];
      memset(badchip_info, 32, sizeof(badchip_info));
      if ( v5 )
      {
        if ( v4->idx[1] )
          sprintf(
            (char *)badchip_info,
            "%2d-%4d %2d-%4d ",
            v5,
            v4->nonce_num[0],
            v4->idx[1],
            v4->nonce_num[1],
            *(_DWORD *)badchip_info,
            *(_DWORD *)&badchip_info[4],
            *(_DWORD *)&badchip_info[8],
            *(_DWORD *)&badchip_info[12]);
        else
          sprintf((char *)badchip_info, "%2d-%4d ", v5, v4->nonce_num[0]);
      }
      v6 = v2 >> 1;
      v2 += 2;
      write_lcd_no_memset(v6 + 2, badchip_info, 0x10u);
      v4 = (bad_chip *)((char *)v4 + 8);
    }
    while ( v2 != 4 );
    pattern_test_time = 0;
  }
}

//----- (00020AF8) --------------------------------------------------------
void kill_hashboard()
{
  unsigned int axi_fpga; // r0

  puts("\npower off hashboard");
  enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
  power_off();
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFBF);
}

//----- (00020B38) --------------------------------------------------------
void *__fastcall __noreturn BHB07601_show_status_func(void *arg)
{
  int v1; // r8
  unsigned int v2; // r2

  v1 = *(unsigned __int8 *)arg;
  printf(
    "\n--- %s: which_chain = %d, which_i2c = %d\n",
    (const char *)_FUNCTION___8385_0,
    v1,
    *((unsigned __int8 *)arg + 1));
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    fan_control(cgpu.fan_speed);
    v2 = time_counter;
    if ( gIsReadTemp && gIsOpenCoreEnd && time_counter == 10 * (time_counter / 0xA) )
    {
      gReadingTemp = 1;
      usleep(15 * Conf.timeout);
      if ( Conf.sensor_model - 1 <= 1 )
      {
        BM1397_read_asic_temperature_local_remote(v1);
      }
      else if ( Conf.sensor_model - 3 <= 5 )
      {
        BM1397_read_asic_temperature_local(v1);
      }
      else
      {
        printf("\n%s: please config sensor_model in Config.ini\n", (const char *)_FUNCTION___8385_0);
      }
      v2 = time_counter;
      gReadingTemp = 0;
    }
    sprintf((char *)lcd_output, "   time %ds", v2);
    sprintf((char *)lcd_output[1], "   nonce=%d", gValid_Nonce_Num[v1]);
    if ( Conf.TempSensor1 )
    {
      if ( Conf.TempSensor2 )
      {
        if ( Conf.TempSensor3 )
        {
          if ( Conf.TempSensor4 )
          {
            sprintf((char *)lcd_output[2], " T1:%d   T2:%d", Sensor1_temp, Sensor2_temp);
            sprintf((char *)lcd_output[3], " T3:%d   T4:%d", Sensor3_temp, Sensor4_temp);
          }
          else
          {
            sprintf((char *)lcd_output[2], " T1:%d   T2:%d", Sensor1_temp, Sensor2_temp);
            sprintf((char *)lcd_output[3], " T3:%d", Sensor3_temp);
          }
        }
        else
        {
          sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
          sprintf((char *)lcd_output[3], "   T2 %d `C", Sensor2_temp);
        }
      }
      else
      {
        sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
      }
    }
    else
    {
      strcpy((char *)lcd_output[2], "temp setting err!");
    }
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( gStartTest )
      printf("\ngValid_Nonce_Num = %d\n", gValid_Nonce_Num[v1]);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    if ( gHigherThanAlarmTemp )
    {
      printf("Temp is higer than AlarmTemp %d\n", Conf.AlarmTemp);
      kill_hashboard();
    }
  }
}

//----- (00020DC4) --------------------------------------------------------
int __fastcall BHB07601_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
{
  uint32_t v2; // r9
  int v4; // r8
  unsigned int v5; // r11
  unsigned int v6; // r5
  uint32_t core_id; // r0
  unsigned int v8; // r6
  unsigned int v9; // r7
  unsigned int v10; // r10
  bool v11; // cf
  int v12; // r4
  work *v13; // r3
  int result; // r0
  int *v15; // r3
  unsigned int v16; // r4

  v2 = buf[1];
  v4 = which_chain;
  v5 = *buf;
  v6 = (unsigned __int8)(v2 >> 14) / gChain_Asic_Interval;
  core_id = BM1397_get_core_id(v2);
  v8 = *buf;
  v9 = core_id;
  v10 = (unsigned __int8)(*buf >> 23);
  if ( (v5 & 0x40) != 0 )
    printf(
      "\n!!! %s: nonce crc error! nonce = 0x%08x, which_asic = %d, which_core = %d, which_pattern = %d\n",
      (const char *)_FUNCTION___8401,
      v2,
      v6,
      core_id,
      v10);
  v11 = v9 >= 0x2A0;
  if ( v9 < 0x2A0 )
    v11 = v6 >= BHB07601_ASIC_NUMBER;
  v12 = v11;
  if ( v11 || v10 >= Conf.pattern_number )
    return -1;
  v13 = &cgpu.works[v6][v10 + Conf.pattern_number * v9];
  if ( v2 == v13->nonce )
  {
    v15 = &v13->id + v4;
    result = v15[13];
    if ( result )
    {
      v15[13] = result + 1;
      result = v12;
      ++gRepeated_Nonce_Id[v4];
    }
    else
    {
      v15[13] = 1;
      v16 = gValid_Nonce_Num[v4] + 1;
      ++gAsic_Core_Nonce_Num[0][v6 + (v4 << 7)][v9];
      gValid_Nonce_Num[v4] = v16;
    }
  }
  else
  {
    if ( check_hw(&gWorks_For_Hw_Check[v4][HIWORD(v8) & 0x7F], v2, v12) == 1 )
    {
      ++gHw_Nonce_Num[v4];
      printf("%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n", (const char *)_FUNCTION___8401, v4, v6, v9, v2);
    }
    return v12;
  }
  return result;
}

//----- (00020F2C) --------------------------------------------------------
int __fastcall BHB07601_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r4
  unsigned int v3; // r7
  reg_buf *v4; // r2
  char *v5; // r0
  unsigned int v6; // r1
  unsigned int reg_value_num; // r3

  v2 = *buf;
  v3 = buf[1];
  if ( reg_value_buf->reg_value_num > 0x1FE )
  {
    printf("%s: reg_value_buf buffer is full!\n", (const char *)_FUNCTION___8407);
    return -1;
  }
  else if ( (v2 & 0x40) != 0 )
  {
    printf("%s: reg crc error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8407, *buf, buf[1]);
    return -1;
  }
  else if ( (v2 & 0x20000000) != 0 )
  {
    printf("%s: REG_TYPE error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8407, *buf, buf[1]);
    return -1;
  }
  else
  {
    pthread_mutex_lock(&reg_mutex);
    v4 = reg_value_buf;
    v5 = (char *)v4 + 8 * v4->p_wr;
    v6 = reg_value_buf->p_wr + 1;
    *((_DWORD *)v5 + 4) = v3;
    v5[22] = HIBYTE(v2) & 0x1F;
    v5[20] = BYTE2(v2);
    v5[23] = v2 & 0xF;
    v5[21] = BYTE1(v2);
    reg_value_num = v4->reg_value_num;
    v4->p_wr = v6;
    if ( v6 >= 0x200 )
      v4->p_wr = 0;
    v4->reg_value_num = reg_value_num + 1;
    pthread_mutex_unlock(&reg_mutex);
    return 0;
  }
}

//----- (00020FE4) --------------------------------------------------------
void *__fastcall BHB07601_receive_func(void *arg)
{
  int v1; // r8
  int v2; // r5
  int priority_max; // r4
  pthread_t v4; // r6
  unsigned int v5; // r4
  void *result; // r0
  unsigned int v7; // r5
  sched_param sp; // [sp+4h] [bp-24h] BYREF
  unsigned int buf[2]; // [sp+8h] [bp-20h] BYREF

  v1 = *(unsigned __int8 *)arg;
  v2 = *((unsigned __int8 *)arg + 1);
  buf[0] = 0;
  buf[1] = 0;
  priority_max = sched_get_priority_max(1);
  sp.__sched_priority = priority_max;
  v4 = pthread_self();
  if ( !pthread_setschedparam(v4, 1, &sp) )
    printf("\n--- %s: IO Thread #%lx using %d priority scheduler! ", (const char *)_FUNCTION___8469, v4, priority_max);
  printf("\n--- %s: which_chain = %d, which_i2c = %d\n\n", (const char *)_FUNCTION___8469, v1, v2);
  while ( 1 )
  {
    result = (void *)start_receive;
    if ( !start_receive )
      break;
    usleep(0x3E8u);
    v5 = read_axi_fpga(6u) & 0x1FF;
    if ( v5 )
    {
      v7 = 0;
      do
      {
        get_return_nonce(buf);
        if ( BM1397_is_nonce_or_reg_value(buf[0]) )
        {
          if ( gBegin_Get_Nonce )
          {
            if ( BM1397_check_nonce_flag(buf[0]) )
              BHB07601_check_nonce(v1, buf);
          }
        }
        else
        {
          BHB07601_check_register_value(v1, buf);
        }
        ++v7;
      }
      while ( v5 > v7 );
    }
  }
  return result;
}

//----- (000210B0) --------------------------------------------------------
void singleBoardTest_BHB07601_BM1397()
{
  unsigned __int16 axi_fpga; // r0
  unsigned int v1; // r0
  unsigned int v2; // r0
  int v3; // r9
  int v4; // r2
  bool *v5; // lr
  unsigned int result; // r5
  int chip_addr; // [sp+0h] [bp-40h]
  unsigned __int8 lcd_display_buf[16]; // [sp+8h] [bp-38h] BYREF

  memset(lcd_display_buf, 32, sizeof(lcd_display_buf));
  printf("\nBegin %s test\n", (const char *)_FUNCTION___8483);
  system("date");
  putchar(10);
  memset(lcd_output, 32, sizeof(lcd_output));
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  set_fpga_baud(0x1Au);
  write_axi_fpga(0x3Eu, 0);
  axi_fpga = read_axi_fpga(0);
  printf("FPGA version 0x%04x\n", axi_fpga);
  v1 = read_axi_fpga(0);
  write_axi_fpga(0, v1 | 0x40000000);
  reset_BHB07601_global_arg();
  check_chain();
  if ( gChain == 255 )
  {
    write_lcd(1u, " no hash board  ", 0x10u);
    puts("\nNo hash board, please plug in it");
    return;
  }
  if ( pthread_create(&cgpu.show_id, 0, BHB07601_show_status_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "   Creat show   ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1397_show_status_func fail\n\n\n", (const char *)_FUNCTION___8483);
    return;
  }
  gEEPROM_error = 0;
  pthread_mutex_init(&i2c_mutex, 0);
  if ( cgpu.repair_mode )
  {
    if ( Test_EEPROM_part_area() )
    {
      printf("\n!!! %s: Test_EEPROM_part_area: Check EEPROM error!!!\n\n", (const char *)_FUNCTION___8483);
      gEEPROM_error = 1;
    }
    else
    {
      printf("\n--- %s: Test_EEPROM_part_area: Check EEPROM ok!!!\n", (const char *)_FUNCTION___8483);
    }
  }
  else if ( Test_EEPROM() )
  {
    printf("\n!!! %s: Test_EEPROM: Check EEPROM error!!!\n\n", (const char *)_FUNCTION___8483);
    gEEPROM_error = 1;
  }
  else
  {
    printf("\n--- %s: Test_EEPROM: Check EEPROM ok!!!\n", (const char *)_FUNCTION___8483);
  }
  write_axi_fpga(0xDu, 0xFFFFu);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  reset_dsPIC33EP16GS202_pic(gChain, gI2c);
  jump_from_loader_to_app_dsPIC33EP16GS202(gChain, gI2c);
  if ( pthread_create(&cgpu.pic_heart_beat_id, 0, pic_heart_beat_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    pthread_mutex_lock(&i2c_mutex);
    pthread_cancel(cgpu.pic_heart_beat_id);
    pthread_mutex_unlock(&i2c_mutex);
    write_lcd(0, "Creat heart beat", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create pic_heart_beat_func fail\n\n\n", (const char *)_FUNCTION___8483);
    return;
  }
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  if ( !set_pre_open_core_voltage(gChain, gI2c) )
  {
    start_receive = 1;
    usleep(0x2710u);
    if ( pthread_create(&cgpu.receive_id, 0, BHB07601_receive_func, &chain_info_0[gChain]) )
    {
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      pthread_cancel(cgpu.receive_id);
      write_lcd(0, "  Creat receive ", 0x10u);
      write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
      write_lcd_no_memset(3u, "   test again   ", 0x10u);
      printf("\n!!!%s: create BHB07601_receive_func fail\n\n\n", (const char *)_FUNCTION___8483);
      return;
    }
    v2 = read_axi_fpga(0x40u);
    write_axi_fpga(0x40u, v2 & 0xFFFF7E1F | 0x8100);
    BM1397_set_clock_order(gChain, 0, 1);
    puts("\n--- BHB07601 check asic number");
    check_BM1397_asic_reg(gChain, 0, 0, 1);
    printf("\n--- check chain: J%d has asicNum = %d\n", gChain + 1, cgpu.chain_asic_num[gChain]);
    if ( cgpu.chain_asic_num[gChain] != BHB07601_ASIC_NUMBER
      || (set_fpga_baud(0x1Au),
          cgpu.chain_asic_num[gChain] = 0,
          puts("\n--- double check asic number"),
          check_BM1397_asic_reg(gChain, 0, 0, 1),
          printf("\n--- check chain: J%d has asicNum = %d\n", gChain + 1, cgpu.chain_asic_num[gChain]),
          cgpu.chain_asic_num[gChain] != BHB07601_ASIC_NUMBER) )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
      write_lcd(0, "   Only have    ", 0x10u);
      write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
      write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
      printf("\n\n---%s: Only have %d ASIC\n", _FUNCTION___8483, cgpu.chain_asic_num[gChain]);
      puts("----------------------------\n\n");
LABEL_19:
      sleep(Conf.close_power_delay);
      enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
      power_off();
      return;
    }
    chip_addr = cgpu.Only_find_ASIC;
    if ( cgpu.Only_find_ASIC )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      write_lcd(1u, " find all ASIC  ", 0x10u);
      write_lcd_no_memset(2u, "       OK       ", 0x10u);
      printf("\nFind %d ASIC, OK\n", BHB07601_ASIC_NUMBER);
      goto LABEL_19;
    }
    BHB07601_calculate_timeout_and_baud();
    set_BM1397_freq_slowly(gChain, chip_addr, Conf.Freq, 1);
    BHB07601_set_address(gChain);
    BHB07601_set_baud(gChain, cgpu.baud);
    v3 = chip_addr;
    BM1397_set_TM(gChain, chip_addr, 0x3Fu, 1);
    write_axi_fpga(0x22u, Conf.timeout | 0x80000000);
    usleep(0x2710u);
    BM1397_set_core_clock_delay_all(gChain, chip_addr, Conf.CoreClockDelay, 1u);
    BM1397_soft_reset_sensor(gChain);
    BM1397_enable_extended_mode_of_temperature_sensor(gChain);
    while ( 1 )
    {
      v4 = v3++;
      v5 = gSensor_OK[gChain];
      if ( *v5 && v5[1] && v5[2] && v5[3] )
        break;
      printf("\n---%s: check sensor %d time\n", _FUNCTION___8483, v4);
      BM1397_read_asic_temperature_local(gChain);
      if ( v3 == 3 )
        goto LABEL_32;
    }
    printf("\n---%s: check sensor ok\n", (const char *)_FUNCTION___8483);
LABEL_32:
    gIsReadTemp = 1;
    BHB07601_open_core(gChain);
    adjust_voltage(gChain, gI2c);
    puts("\nBegin send test pattern");
    if ( !gStartTest )
    {
      if ( time_counter >= Conf.HeatingUpTime )
      {
LABEL_39:
        pthread_cancel(cgpu.receive_id);
        pthread_cancel(cgpu.show_id);
        pthread_mutex_lock(&i2c_mutex);
        pthread_cancel(cgpu.pic_heart_beat_id);
        pthread_mutex_unlock(&i2c_mutex);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, "Can't open core ", 0x10u);
        write_lcd_no_memset(1u, "change  to  next", 0x10u);
        write_lcd_no_memset(2u, (unsigned __int8 *)"voltage and freq", 0x10u);
        ++pattern_test_time;
        enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
        power_off();
        return;
      }
      while ( 1 )
      {
        usleep(0x2710u);
        if ( gStartTest )
          break;
        if ( Conf.HeatingUpTime <= time_counter )
          goto LABEL_39;
      }
    }
    if ( pthread_create(&cgpu.send_id, 0, BHB07601_send_func, &chain_info_0[gChain]) )
    {
      pthread_cancel(cgpu.show_id);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      pthread_cancel(cgpu.receive_id);
      write_lcd(0, "   Creat send   ", 0x10u);
      write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
      write_lcd_no_memset(3u, "   test again   ", 0x10u);
      printf("\n!!!%s: create BHB07601_send_func fail\n\n\n", (const char *)_FUNCTION___8483);
      enable_dsPIC33EP16GS202_dc_dc(gChain, gI2c, 0);
      power_off();
    }
    else
    {
      pthread_join(cgpu.send_id, 0);
      pthread_join(cgpu.receive_id, 0);
      pthread_cancel(cgpu.show_id);
      result = BHB07601_get_result(gChain);
      if ( (result & 1) != 0 )
      {
        if ( gEEPROM_error )
        {
          printf("\n!!!%s: Don't save data into EEPROM, because EEPROM test fail!!\n\n", (const char *)_FUNCTION___8483);
        }
        else if ( BHB07601_AT24C02_write_total_data(gI2c, gChain) )
        {
          puts("\nEEPROM OK\n");
        }
        else
        {
          puts("\nEEPROM NG\n");
        }
      }
      BHB07601_print_lcd(result);
      sleep(Conf.close_power_delay);
      power_off();
      sleep(0x1Eu);
      pthread_mutex_lock(&i2c_mutex);
      pthread_cancel(cgpu.pic_heart_beat_id);
      pthread_mutex_unlock(&i2c_mutex);
      set_fan_speed(0);
      usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    }
  }
}

//----- (00021998) --------------------------------------------------------
int cgpu_init()
{
  printf("\n--- %s\n", (const char *)_FUNCTION___8274);
  memset(&cgpu, 0, (size_t)&gAsic_Core_Nonce_Num[1][79][315]);
  memset(&Conf, 0, sizeof(Conf));
  if ( open_lcd() <= 0 )
  {
    printf("!!! %s: open lcd driver error\n", (const char *)_FUNCTION___8274);
  }
  else
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    write(lcd_fd, lcd_output, 0x40u);
    if ( open_key() <= 0 )
    {
      printf("!!! %s: open start key error\n", (const char *)_FUNCTION___8274);
    }
    else
    {
      if ( open_red_led() <= 0 )
      {
        printf("!!! %s: open red led error\n", (const char *)_FUNCTION___8274);
      }
      else
      {
        if ( open_green_led() <= 0 )
        {
          printf("!!! %s: open green led error\n", (const char *)_FUNCTION___8274);
        }
        else
        {
          if ( bitmain_axi_init() < 0 )
          {
            bitmain_axi_close();
          }
          else
          {
            if ( open_power_control() > 0 )
              return 0;
            printf("!!! %s: open power control gpio error\n", (const char *)_FUNCTION___8274);
          }
          close_power_control();
        }
        close_green_led();
      }
      close_red_led();
    }
    close_key();
  }
  close_lcd();
  return -1;
}

//----- (00021AC4) --------------------------------------------------------
void malloc_register_buf()
{
  reg_value_buf = (reg_buf *)calloc(0x1008u, 1u);
  if ( !reg_value_buf )
    j_printf("%s: malloc reg_value_buf failed\n", (const char *)_FUNCTION___8287_0);
}

//----- (00021AF4) --------------------------------------------------------
int get_works()
{
  int works_v2; // r0
  timeval t0; // [sp+0h] [bp-18h] BYREF
  timeval t1; // [sp+8h] [bp-10h] BYREF

  gettimeofday(&t0, 0);
  if ( Conf.AsicType == 5015 )
    works_v2 = get_works_v2();
  else
    works_v2 = get_works_v1();
  if ( works_v2 < 0 )
    return -14;
  gettimeofday(&t1, 0);
  printf(
    "get_works took %.3fs\n",
    (float)((float)((float)(t1.tv_usec - t0.tv_usec) / 1000000.0) + (float)(t1.tv_sec - t0.tv_sec)));
  return 0;
}

//----- (00021B78) --------------------------------------------------------
int configMiner()
{
  int result; // r0

  read_config();
  result = get_works();
  if ( !result )
  {
    malloc_register_buf();
    return 0;
  }
  return result;
}

//----- (00021B94) --------------------------------------------------------
void display_arguments()
{
  unsigned __int8 output[4][16]; // [sp+0h] [bp-50h] BYREF

  memset(output, 0, sizeof(output));
  lseek(lcd_fd, 0, 0);
  memset(output, 32, sizeof(output));
  memcpy(output, &Conf, gName_len);
  sprintf((char *)output[1], "IC:%2d P:%2d", Conf.AsicNum, Conf.pattern_number);
  sprintf((char *)output[2], "FREQ: %d", Conf.Freq1);
  sprintf((char *)output[3], "Voltage: %d", Conf.Voltage1);
  write(lcd_fd, output, 0x40u);
}

//----- (00021C1C) --------------------------------------------------------
void clear_register_value_buf()
{
  reg_buf *v0; // r3

  pthread_mutex_lock(&reg_mutex);
  v0 = reg_value_buf;
  reg_value_buf->p_wr = 0;
  v0->p_rd = 0;
  v0->reg_value_num = 0;
  v0->loop_back = 0;
  pthread_mutex_unlock(&reg_mutex);
  j_memset(reg_value_buf->reg_buffer, 0, sizeof(reg_value_buf->reg_buffer));
}

//----- (00021C58) --------------------------------------------------------
int __fastcall calculate_core_number(unsigned int actual_core_number)
{
  unsigned int i; // r3

  if ( actual_core_number )
  {
    if ( actual_core_number <= 1 )
    {
      return 1;
    }
    else
    {
      for ( i = 1; i < actual_core_number; i *= 2 )
        ;
      return i;
    }
  }
  else
  {
    printf("%s line %d: Note actual_core_num is 0!\n", (const char *)_FUNCTION___8309, 314);
    return 0;
  }
}

//----- (00021C90) --------------------------------------------------------
unsigned int __fastcall calculate_how_many_nonce_per_asic_get(
        unsigned __int8 which_chain,
        unsigned __int8 which_asic,
        unsigned int core_number)
{
  int v3; // r3
  unsigned int result; // r0
  unsigned int *v5; // r1
  unsigned int *v6; // r3
  unsigned int v7; // t1

  if ( !core_number )
    return 0;
  v3 = which_asic + (which_chain << 7);
  result = 0;
  v5 = &gAsic_Core_Nonce_Num[0][v3][core_number - 1];
  v6 = &gAsic_Core_Nonce_Num[0][v3 - 1][1023];
  do
  {
    v7 = v6[1];
    ++v6;
    result += v7;
  }
  while ( v6 != v5 );
  return result;
}

//----- (00021CC8) --------------------------------------------------------
unsigned int __fastcall calculate_how_many_nonce_per_domain_get(
        unsigned __int8 which_chain,
        unsigned __int8 which_domain)
{
  unsigned int v2; // r4
  unsigned int v3; // r1
  unsigned int v4; // r3
  int v5; // r6
  unsigned int result; // r0
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v7; // r5
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v8; // r3
  int spins; // t1

  v2 = 4 * (which_domain / (BHB07601_ASIC_NUMBER / 0xC));
  v3 = 168 * (which_domain % (BHB07601_ASIC_NUMBER / 0xC));
  if ( v2 >= v2 + 4 )
    return 0;
  v4 = v2 + (which_chain << 7);
  v5 = 4;
  result = 0;
  v7 = &reg_mutex.__data._anon_0 + 1024 * v4 + v3;
  do
  {
    if ( v3 < v3 + 168 )
    {
      v8 = v7;
      do
      {
        spins = v8[1].__spins;
        ++v8;
        result += spins;
      }
      while ( v8 != &v7[168] );
    }
    --v5;
    v7 += 1024;
  }
  while ( v5 );
  return result;
}

//----- (00021D40) --------------------------------------------------------
void display_level_result_on_lcd()
{
  unsigned __int8 Voltage_char[5]; // [sp+0h] [bp-20h] BYREF

  qmemcpy(Voltage_char, "     ", sizeof(Voltage_char));
  sprintf((char *)Voltage_char, "%2d", pattern_test_time + 1);
  lcd_buffer[10] = Voltage_char[0];
  lcd_buffer[11] = Voltage_char[1];
  lcd_buffer[12] = Voltage_char[2];
  write_lcd(0, lcd_buffer, 0x10u);
  printf("Level: %d\n\n", pattern_test_time + 1);
}

//----- (00021DB0) --------------------------------------------------------
void reset_global_arg()
{
  bool (*v0)[4]; // r6
  int v1; // r7
  pthread_mutex_t *v2; // r0

  printf("\n--- %s\n", (const char *)_FUNCTION___8353);
  gChain = -1;
  time_counter = 0;
  gHighest_Temp = 0;
  gWork_Num_For_Hw_Check = 0;
  Sensor1_temp = 0;
  v0 = gSensor_OK;
  Sensor2_temp = 0;
  Sensor3_temp = 0;
  Sensor4_temp = 0;
  last_Sensor1_temp = 0;
  last_Sensor2_temp = 0;
  last_Sensor3_temp = 0;
  last_Sensor4_temp = 0;
  highest_temp = 0;
  lowest_temp = 0;
  gGlobalHighestTemp = 0;
  temp_change = 0;
  gNotReadOutTemp = 0;
  gIsOpenCoreEnd = 0;
  gT1_offset_value = 0;
  gT2_offset_value = 0;
  gT3_offset_value = 0;
  gT4_offset_value = 0;
  gHigherThanMaxTempGap = 0;
  gMaxTempGap_value = 0;
  gIsReadTemp = 0;
  gReadingTemp = 0;
  gEEPROM_error = 0;
  gStartTest = 0;
  Sensor1_OK = 1;
  Sensor2_OK = 1;
  Sensor3_OK = 1;
  Sensor4_OK = 1;
  gBegin_Get_Nonce = 0;
  gValid_Nonce_Num[0] = 0;
  gHw_Nonce_Num[0] = 0;
  gRepeated_Nonce_Id[0] = 0;
  gValid_Nonce_Num[1] = 0;
  gValid_Nonce_Num[2] = 0;
  gValid_Nonce_Num[3] = 0;
  gHw_Nonce_Num[1] = 0;
  gHw_Nonce_Num[2] = 0;
  gHw_Nonce_Num[3] = 0;
  gRepeated_Nonce_Id[1] = 0;
  gRepeated_Nonce_Id[2] = 0;
  gRepeated_Nonce_Id[3] = 0;
  start_receive = 0;
  memset(reg_value_buf, 0, sizeof(reg_buf));
  memset(gWorks_For_Hw_Check, 0, 0x2200u);
  memset(gAT24C02_data_map, 255, sizeof(gAT24C02_data_map));
  memset(gSensor_read_ok_counter, 0, sizeof(gSensor_read_ok_counter));
  memset(lcd_output, 32, sizeof(lcd_output));
  write(lcd_fd, lcd_output, 0x40u);
  v1 = 0;
  pthread_mutex_init(&reg_mutex, 0);
  do
  {
    pthread_mutex_init(&uart_send_mutex[v1], 0);
    pthread_mutex_init(&uart_receive_mutex[v1], 0);
    v2 = &HW_check_mutex[v1++];
    ++v0;
    pthread_mutex_init(v2, 0);
    (*v0)[-4] = 1;
    (*v0)[-3] = 1;
    (*v0)[-2] = 1;
    (*v0)[-1] = 1;
  }
  while ( v1 != 4 );
  clear_register_value_buf();
}

//----- (00021F60) --------------------------------------------------------
void __fastcall rev(unsigned __int8 *s, unsigned __int8 l)
{
  unsigned int v2; // r1
  unsigned int v3; // r3
  unsigned __int8 v4; // r4

  v2 = (unsigned __int8)(l - 1);
  if ( v2 )
  {
    v3 = 0;
    do
    {
      v4 = s[v3];
      s[v3] = s[v2];
      v3 = (unsigned __int8)(v3 + 1);
      s[v2] = v4;
      v2 = (unsigned __int8)(v2 - 1);
    }
    while ( v3 < v2 );
  }
}

//----- (00021F84) --------------------------------------------------------
int __fastcall check_hw(work *work, unsigned int nonce, bool print)
{
  _BOOL4 v5; // r9
  unsigned int v6; // r6
  _BYTE *v7; // r5
  sha2_context *state; // r4
  uint32_t v9; // r1
  uint32_t v10; // r2
  uint32_t v11; // r3
  uint32_t v12; // r1
  uint32_t v13; // r2
  uint32_t v14; // r3
  char v15; // r3
  int v16; // r0
  unsigned __int8 *v17; // r3
  unsigned __int8 *v18; // r4
  int v19; // r1
  int v20; // r2
  unsigned __int8 v21; // r2
  int result; // r0
  unsigned __int8 *v23; // r4
  int v24; // t1
  work *v25; // r4
  int v26; // t1
  work *v27; // r4
  int v28; // t1
  char v29; // [sp+0h] [bp-149h] BYREF
  unsigned __int8 hash1[32]; // [sp+1h] [bp-148h] BYREF
  unsigned __int8 hash2[32]; // [sp+21h] [bp-128h] BYREF
  sha2_context ctx; // [sp+41h] [bp-108h] BYREF

  v5 = print;
  v6 = bswap32(nonce);
  memset(hash1, 0, sizeof(hash1));
  v7 = (char *)&ctx.state[7] + 3;
  memset(hash2, 0, sizeof(hash2));
  state = (sha2_context *)ctx.state;
  v9 = *(_DWORD *)&work->midstate[4];
  v10 = *(_DWORD *)&work->midstate[8];
  v11 = *(_DWORD *)&work->midstate[12];
  ctx.state[0] = *(_DWORD *)work->midstate;
  ctx.state[1] = v9;
  ctx.state[2] = v10;
  ctx.state[3] = v11;
  v12 = *(_DWORD *)&work->midstate[20];
  v13 = *(_DWORD *)&work->midstate[24];
  v14 = *(_DWORD *)&work->midstate[28];
  ctx.state[4] = *(_DWORD *)&work->midstate[16];
  ctx.state[5] = v12;
  ctx.state[6] = v13;
  ctx.state[7] = v14;
  do
  {
    v15 = state->total[0];
    LOBYTE(state->total[0]) = *v7;
    state = (sha2_context *)((char *)state + 1);
    *v7-- = v15;
  }
  while ( &ctx.state[4] != (uint32_t *)state );
  v16 = *(_DWORD *)work->data;
  v17 = hash1;
  v18 = &hash1[11];
  v19 = *(_DWORD *)&work->data[4];
  v20 = *(_DWORD *)&work->data[8];
  ctx.total[0] = 80;
  *(_DWORD *)hash1 = v16;
  *(_DWORD *)&hash1[4] = v19;
  *(_DWORD *)&hash1[8] = v20;
  ctx.total[1] = 0;
  do
  {
    v21 = *v17;
    *v17++ = *v18;
    *v18-- = v21;
  }
  while ( &hash1[6] != v17 );
  flip_swab(ctx.buffer, hash1, 0xCu);
  hash1[2] = BYTE1(v6);
  hash1[0] = HIBYTE(v6);
  hash1[1] = BYTE2(v6);
  hash1[3] = v6;
  flip_swab(&ctx.buffer[12], hash1, 4u);
  sha2_finish(&ctx, hash1);
  memset(&ctx, 0, sizeof(ctx));
  sha2(hash1, 32, hash2);
  flip32(hash1, hash2);
  result = *(_DWORD *)&hash1[28];
  if ( *(_DWORD *)&hash1[28] )
  {
    result = 1;
    if ( v5 )
    {
      printf("\n%s: Got a HW!\n", (const char *)_FUNCTION___8381);
      v23 = (unsigned __int8 *)&v29;
      printf("hash1=0x");
      do
      {
        v24 = *++v23;
        printf("%02x", v24);
      }
      while ( v23 != &hash1[31] );
      putchar(10);
      v25 = (work *)&work->data[11];
      printf("midstate=0x");
      do
      {
        v26 = BYTE1(v25->id);
        v25 = (work *)((char *)v25 + 1);
        printf("%02x", v26);
      }
      while ( &work->midstate[31] != (unsigned __int8 *)v25 );
      v27 = (work *)((char *)&work->nonce + 3);
      printf("\tdata2=0x");
      do
      {
        v28 = BYTE1(v27->id);
        v27 = (work *)((char *)v27 + 1);
        printf("%02x", v28);
      }
      while ( &work->data[11] != (unsigned __int8 *)v27 );
      printf("\treturn nonce=0x%08x, but it should be nonce=0x%08x\n", nonce, work->nonce);
      return 1;
    }
  }
  return result;
}

//----- (00022134) --------------------------------------------------------
int open_red_led()
{
  int result; // r0

  result = open("/sys/class/gpio/gpio941/value", 2049);
  red_led_fd = result;
  if ( result < 0 )
  {
    puts("open red led failed!!!");
    return red_led_fd;
  }
  return result;
}

//----- (00022168) --------------------------------------------------------
void close_red_led()
{
  close(red_led_fd);
  j_puts("red led closed!!!");
}

//----- (00022188) --------------------------------------------------------
void red_led_on()
{
  j_write(red_led_fd, "1", 1u);
}

//----- (000221A0) --------------------------------------------------------
void red_led_off()
{
  j_write(red_led_fd, "0", 1u);
}

//----- (000221B8) --------------------------------------------------------
int open_green_led()
{
  int result; // r0

  result = open("/sys/class/gpio/gpio942/value", 2049);
  green_led_fd = result;
  if ( result < 0 )
  {
    puts("open green led failed!!!");
    return green_led_fd;
  }
  return result;
}

//----- (000221EC) --------------------------------------------------------
void close_green_led()
{
  close(green_led_fd);
  j_puts("green led closed!!!");
}

//----- (0002220C) --------------------------------------------------------
void green_led_on()
{
  j_write(green_led_fd, "1", 1u);
}

//----- (00022224) --------------------------------------------------------
void green_led_off()
{
  j_write(green_led_fd, "0", 1u);
}

//----- (0002223C) --------------------------------------------------------
void __fastcall write_pic1704(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data)
{
  i2c_write(data | 0xA00000 | (which_chain << 16) | (which_i2c << 26));
}

//----- (0002224C) --------------------------------------------------------
unsigned __int8 __fastcall read_pic1704(unsigned __int8 which_i2c, unsigned __int8 which_chain)
{
  return i2c_read((which_chain << 16) | 0xA00000 | (which_i2c << 26));
}

//----- (0002225C) --------------------------------------------------------
void __fastcall write_dspic33ep16gs202(unsigned __int8 which_i2c, unsigned __int8 which_chain, unsigned __int8 data)
{
  i2c_write(data | 0x400000 | (which_chain << 16) | (which_i2c << 26));
}

//----- (0002226C) --------------------------------------------------------
unsigned __int8 __fastcall read_dspic33ep16gs202(unsigned __int8 which_i2c, unsigned __int8 which_chain)
{
  return i2c_read((which_chain << 16) | 0x400000 | (which_i2c << 26));
}

//----- (0002227C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall set_PIC16F1704_flash_pointer(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 flash_addr_h,
        unsigned __int8 flash_addr_l)
{
  int v5; // r6
  char *v6; // r4
  int v7; // r0
  unsigned int v8; // r5
  int v9; // t1
  int v10; // r6
  int v11; // r4
  const char *v12; // r1
  char v14[4]; // [sp+0h] [bp-8h] BYREF
  unsigned __int8 flash_addr_ha; // [sp+4h] [bp-4h]
  unsigned __int8 flash_addr_la; // [sp+5h] [bp-3h]
  char v17; // [sp+6h] [bp-2h]
  char v18; // [sp+7h] [bp-1h] BYREF

  v5 = which_chain << 16;
  flash_addr_ha = flash_addr_h;
  flash_addr_la = flash_addr_l;
  v14[0] = 85;
  v18 = flash_addr_h + flash_addr_l + 7;
  v6 = v14;
  v17 = (unsigned __int16)(flash_addr_h + flash_addr_l + 7) >> 8;
  v14[1] = -86;
  v14[2] = 6;
  v14[3] = 1;
  pthread_mutex_lock(&i2c_mutex);
  v7 = 85;
  v8 = v5 | 0xA00000 | (which_i2c << 26);
  while ( 1 )
  {
    i2c_write(v7 | v8);
    if ( &v18 == v6 )
      break;
    v9 = (unsigned __int8)*++v6;
    v7 = v9;
  }
  usleep(0x186A0u);
  v10 = i2c_read(v5 | 0xA00000 | (which_i2c << 26));
  v11 = i2c_read(v8);
  pthread_mutex_unlock(&i2c_mutex);
  LOWORD(v12) = (unsigned __int16)_FUNCTION___8002;
  if ( v10 == 1 && v11 == 1 )
  {
    HIWORD(v12) = (unsigned int)_FUNCTION___8002 >> 16;
    printf("\n--- %s ok\n\n", v12);
    return 1;
  }
  else
  {
    HIWORD(v12) = (unsigned int)_FUNCTION___8002 >> 16;
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n", v12, v10, v11);
    return 0;
  }
}
// 2227C: variables would overlap: r2.1 and r2.2
// 2227C: variables would overlap: r3.1 and r3.2

//----- (0002234C) --------------------------------------------------------
int __fastcall send_data_to_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  unsigned __int8 *v3; // r4
  unsigned __int8 *v5; // r2
  unsigned __int8 *v6; // r0
  __int16 v7; // r3
  __int16 v8; // t1
  unsigned __int8 *v9; // r2
  unsigned __int8 v10; // t1
  unsigned __int8 *v11; // r4
  unsigned int v12; // r5
  int v13; // t1
  int v14; // r6
  int v15; // r4
  char v17; // [sp+0h] [bp-31h] BYREF
  unsigned __int8 send_data[22]; // [sp+1h] [bp-30h] BYREF

  v3 = buf - 1;
  v5 = buf + 15;
  v6 = v3;
  v7 = 22;
  memset(&send_data[4], 0, 16);
  do
  {
    v8 = *++v6;
    v7 += v8;
  }
  while ( v6 != v5 );
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = 20;
  send_data[3] = 2;
  v9 = &send_data[3];
  do
  {
    v10 = *++v3;
    *++v9 = v10;
  }
  while ( v9 != &send_data[19] );
  send_data[20] = HIBYTE(v7);
  send_data[21] = v7;
  v11 = (unsigned __int8 *)&v17;
  v12 = (which_chain << 16) | 0xA00000 | (which_i2c << 26);
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    v13 = *++v11;
    i2c_write(v13 | v12);
  }
  while ( &send_data[21] != v11 );
  usleep(0x186A0u);
  v14 = i2c_read(v12);
  v15 = i2c_read(v12);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v14 == 2 && v15 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8026);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8026,
      v14,
      v15);
    return 0;
  }
}

//----- (00022434) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_pointer(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *flash_addr_h,
        unsigned __int8 *flash_addr_l)
{
  unsigned __int8 *v6; // r4
  unsigned int v7; // r5
  int i; // r0
  int v9; // t1
  unsigned __int8 *v10; // r4
  int v12; // r2
  __int16 v13; // r3
  unsigned __int8 read_back_data[6]; // [sp+10h] [bp-38h] BYREF
  char v15; // [sp+16h] [bp-32h] BYREF
  unsigned __int8 send_data[6]; // [sp+18h] [bp-30h] BYREF

  send_data[2] = 4;
  *(_DWORD *)read_back_data = 255;
  v6 = send_data;
  *(_WORD *)&send_data[4] = 3072;
  v7 = (which_chain << 16) | 0xA00000 | (which_i2c << 26);
  *(_WORD *)&read_back_data[4] = 0;
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[3] = 8;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v9 )
  {
    i2c_write(i | v7);
    if ( v6 == &send_data[5] )
      break;
    v9 = *++v6;
  }
  v10 = read_back_data;
  usleep((__useconds_t)&loc_186A0);
  do
    *v10++ = i2c_read(v7);
  while ( &v15 != (char *)v10 );
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] == 8 && read_back_data[0] == 6 )
  {
    v12 = read_back_data[3];
    v13 = read_back_data[2] + read_back_data[3] + 14;
    if ( HIBYTE(v13) == read_back_data[4] && (unsigned __int8)v13 == read_back_data[5] )
    {
      *flash_addr_h = read_back_data[2];
      *flash_addr_l = v12;
      printf(
        "\n--- %s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x\n\n",
        (const char *)_FUNCTION___8045,
        *flash_addr_h,
        v12);
      return 1;
    }
    else
    {
      printf(
        "\n"
        "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] ="
        " 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
        "\n",
        (const char *)_FUNCTION___8045,
        6,
        8,
        read_back_data[2],
        read_back_data[3],
        read_back_data[4],
        read_back_data[5]);
      return 0;
    }
  }
  else
  {
    printf(
      "\n"
      "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0"
      "x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
      "\n",
      (const char *)_FUNCTION___8045,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5]);
    return 0;
  }
}

//----- (00022570) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_data(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  unsigned __int8 *v3; // r6
  unsigned int v4; // r5
  int i; // r0
  int v6; // t1
  unsigned __int8 *v7; // r4
  int v8; // r7
  __int16 v9; // r4
  int v10; // r6
  __int16 v11; // r5
  __int16 v12; // r11
  __int16 v13; // r10
  __int16 v14; // r9
  __int16 v15; // r8
  bool v16; // zf
  unsigned int v18; // r2
  unsigned __int8 *v19; // r2
  unsigned __int8 *v20; // r3
  char v21; // t1
  __int16 v22; // [sp+4Ch] [bp-54h]
  __int16 v23; // [sp+50h] [bp-50h]
  __int16 v24; // [sp+54h] [bp-4Ch]
  __int16 v25; // [sp+58h] [bp-48h]
  __int16 v26; // [sp+5Ch] [bp-44h]
  __int16 v27; // [sp+60h] [bp-40h]
  __int16 v28; // [sp+64h] [bp-3Ch]
  __int16 v29; // [sp+68h] [bp-38h]
  __int16 v30; // [sp+6Ch] [bp-34h]
  int v31; // [sp+70h] [bp-30h]
  int v32; // [sp+74h] [bp-2Ch]
  __int16 v33; // [sp+78h] [bp-28h]
  unsigned __int8 send_data[6]; // [sp+84h] [bp-1Ch] BYREF
  char v36; // [sp+8Bh] [bp-15h] BYREF
  unsigned __int8 read_back_data[20]; // [sp+8Ch] [bp-14h] BYREF

  send_data[1] = -86;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&send_data[4] = 1792;
  memset(&read_back_data[4], 0, 16);
  send_data[0] = 85;
  send_data[2] = 4;
  v3 = send_data;
  send_data[3] = 3;
  v4 = (which_chain << 16) | 0xA00000 | (which_i2c << 26);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v6 )
  {
    i2c_write(i | v4);
    if ( &send_data[5] == v3 )
      break;
    v6 = *++v3;
  }
  v7 = (unsigned __int8 *)&v36;
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  do
    *++v7 = i2c_read(v4);
  while ( &read_back_data[19] != v7 );
  pthread_mutex_unlock(&i2c_mutex);
  v33 = read_back_data[8];
  v23 = read_back_data[10];
  v22 = read_back_data[9];
  v24 = read_back_data[11];
  v25 = read_back_data[12];
  v26 = read_back_data[13];
  v27 = read_back_data[14];
  v28 = read_back_data[15];
  v8 = read_back_data[1];
  v29 = read_back_data[16];
  v30 = read_back_data[17];
  v31 = read_back_data[18];
  v32 = read_back_data[19];
  v9 = read_back_data[2];
  v10 = read_back_data[0];
  v11 = read_back_data[3];
  v12 = read_back_data[4];
  v13 = read_back_data[5];
  v14 = read_back_data[6];
  v15 = read_back_data[7];
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,     "
    "    read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,         "
    "read_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,         re"
    "ad_back_data[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x,         re"
    "ad_back_data[16] = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
    (const char *)_FUNCTION___8063,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4],
    read_back_data[5],
    read_back_data[6],
    read_back_data[7],
    read_back_data[8],
    read_back_data[9],
    read_back_data[10],
    read_back_data[11],
    read_back_data[12],
    read_back_data[13],
    read_back_data[14],
    read_back_data[15],
    read_back_data[16],
    read_back_data[17],
    read_back_data[18],
    read_back_data[19]);
  usleep(0x186A0u);
  v16 = v10 == 20;
  if ( v10 == 20 )
    v16 = v8 == 3;
  if ( v16 )
  {
    v18 = (unsigned __int16)(v9
                           + v11
                           + 23
                           + v12
                           + v13
                           + v14
                           + v15
                           + v33
                           + v22
                           + v23
                           + v24
                           + v25
                           + v26
                           + v27
                           + v28
                           + v29
                           + v30);
    if ( v31 == v18 >> 8
      && v32 == (unsigned __int8)(v9
                                + v11
                                + 23
                                + v12
                                + v13
                                + v14
                                + v15
                                + v33
                                + v22
                                + v23
                                + v24
                                + v25
                                + v26
                                + v27
                                + v28
                                + v29
                                + v30) )
    {
      v19 = &read_back_data[2];
      v20 = buf - 1;
      while ( 1 )
      {
        *++v20 = v9;
        if ( v19 == &read_back_data[17] )
          break;
        v21 = *++v19;
        LOBYTE(v9) = v21;
      }
      printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8063);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___8063, v18);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8063);
    return 0;
  }
}

//----- (00022780) --------------------------------------------------------
int __fastcall erase_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  int v3; // r6
  unsigned __int8 *v4; // r4
  int v5; // r0
  unsigned int v6; // r5
  int v7; // t1
  int v8; // r6
  int v9; // r4
  unsigned __int8 send_data[6]; // [sp+0h] [bp-20h] BYREF

  v3 = which_chain << 16;
  *(_WORD *)&send_data[4] = 2048;
  send_data[0] = 85;
  v4 = send_data;
  send_data[1] = -86;
  send_data[2] = 4;
  send_data[3] = 4;
  pthread_mutex_lock(&i2c_mutex);
  v5 = 85;
  v6 = v3 | 0xA00000 | (which_i2c << 26);
  while ( 1 )
  {
    i2c_write(v5 | v6);
    if ( &send_data[5] == v4 )
      break;
    v7 = *++v4;
    v5 = v7;
  }
  usleep(0x186A0u);
  v8 = i2c_read(v3 | 0xA00000 | (which_i2c << 26));
  v9 = i2c_read(v6);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( v8 == 4 && v9 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8083);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8083,
      v8,
      v9);
    return 0;
  }
}

//----- (0002284C) --------------------------------------------------------
int __fastcall write_data_into_PIC16F1704_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  int v3; // r6
  unsigned __int8 *v4; // r4
  int v5; // r0
  unsigned int v6; // r5
  int v7; // t1
  int v8; // r6
  int v9; // r4
  unsigned __int8 send_data[6]; // [sp+0h] [bp-8h] BYREF

  v3 = which_chain << 16;
  *(_WORD *)&send_data[4] = 2304;
  send_data[1] = -86;
  send_data[0] = 85;
  v4 = send_data;
  send_data[2] = 4;
  send_data[3] = 5;
  pthread_mutex_lock(&i2c_mutex);
  v5 = 85;
  v6 = v3 | 0xA00000 | (which_i2c << 26);
  while ( 1 )
  {
    i2c_write(v5 | v6);
    if ( &send_data[5] == v4 )
      break;
    v7 = *++v4;
    v5 = v7;
  }
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v8 = i2c_read(v3 | 0xA00000 | (which_i2c << 26));
  v9 = i2c_read(v6);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( v8 == 5 && v9 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8100);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8100,
      v8,
      v9);
    return 0;
  }
}

//----- (00022918) --------------------------------------------------------
int __fastcall jump_from_loader_to_app_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r8
  int v3; // r6
  unsigned __int8 *v4; // r4
  int v5; // r0
  int v6; // r5
  int v7; // t1
  int v8; // r6
  int v9; // r4
  unsigned __int8 send_data[6]; // [sp+0h] [bp-8h] BYREF

  v2 = (unsigned __int8)which_chain;
  *(_WORD *)&send_data[4] = 2560;
  send_data[1] = -86;
  v3 = (which_i2c << 26) | 0xA00000;
  send_data[0] = 85;
  send_data[2] = 4;
  v4 = send_data;
  send_data[3] = 6;
  pthread_mutex_lock(&i2c_mutex);
  v5 = 85;
  v6 = v3 | (v2 << 16);
  while ( 1 )
  {
    i2c_write(v5 | v6);
    if ( &send_data[5] == v4 )
      break;
    v7 = *++v4;
    v5 = v7;
  }
  usleep(0x186A0u);
  v8 = i2c_read(v3 | (v2 << 16));
  v9 = i2c_read(v6);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  if ( v8 == 6 && v9 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8117);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8117,
      v8,
      v9);
    return 0;
  }
}

//----- (000229E8) --------------------------------------------------------
int __fastcall reset_PIC16F1704_pic(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r8
  int v3; // r6
  unsigned __int8 *v4; // r4
  int v5; // r0
  int v6; // r5
  int v7; // t1
  int v8; // r6
  int v9; // r4
  unsigned __int8 send_data[6]; // [sp+0h] [bp-8h] BYREF

  v2 = (unsigned __int8)which_chain;
  *(_WORD *)&send_data[4] = 2816;
  send_data[1] = -86;
  v3 = (which_i2c << 26) | 0xA00000;
  send_data[0] = 85;
  send_data[2] = 4;
  v4 = send_data;
  send_data[3] = 7;
  pthread_mutex_lock(&i2c_mutex);
  v5 = 85;
  v6 = v3 | (v2 << 16);
  while ( 1 )
  {
    i2c_write(v5 | v6);
    if ( &send_data[5] == v4 )
      break;
    v7 = *++v4;
    v5 = v7;
  }
  usleep(0x186A0u);
  v8 = i2c_read(v3 | (v2 << 16));
  v9 = i2c_read(v6);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  if ( v8 == 7 && v9 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8134);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8134,
      v8,
      v9);
    return 0;
  }
}

//----- (00022AB8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall set_PIC16F1704_voltage(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 voltage)
{
  __int16 v3; // r5
  int v4; // r8
  int v5; // r6
  unsigned __int8 *v6; // r4
  int v7; // r0
  int v8; // r5
  int v9; // t1
  int v10; // r6
  int v11; // r4
  unsigned __int8 send_data[7]; // [sp+0h] [bp-8h] BYREF

  v3 = voltage;
  v4 = (unsigned __int8)which_chain;
  v5 = (which_i2c << 26) | 0xA00000;
  printf("\n--- %s\n", (const char *)_FUNCTION___8146);
  send_data[4] = v3;
  send_data[6] = v3 + 21;
  send_data[5] = (unsigned __int16)(v3 + 21) >> 8;
  send_data[0] = 85;
  send_data[1] = -86;
  v6 = send_data;
  send_data[2] = 5;
  send_data[3] = 16;
  pthread_mutex_lock(&i2c_mutex);
  v7 = 85;
  v8 = v5 | ((unsigned __int8)v4 << 16);
  while ( 1 )
  {
    i2c_write(v7 | v8);
    if ( &send_data[6] == v6 )
      break;
    v9 = *++v6;
    v7 = v9;
  }
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v10 = i2c_read(v5 | (v4 << 16));
  v11 = i2c_read(v8);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( v10 == 16 && v11 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8146);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8146,
      v10,
      v11);
    return 0;
  }
}
// 22AB8: variables would overlap: r2.1 and r2.2

//----- (00022BA4) --------------------------------------------------------
int __fastcall write_hash_ID_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 *buf)
{
  unsigned __int8 v3; // r7
  unsigned __int8 *v4; // r0
  __int16 v5; // r3
  unsigned __int8 *v6; // r2
  unsigned __int8 *v7; // r4
  __int16 v8; // t1
  unsigned __int8 *v9; // r4
  unsigned __int8 v10; // t1
  int v11; // r5
  unsigned __int8 *v12; // r4
  int v13; // t1
  int v14; // r6
  int v15; // r4
  char v17; // [sp+3h] [bp-2Dh] BYREF
  unsigned __int8 send_data[18]; // [sp+4h] [bp-2Ch] BYREF

  v3 = which_chain;
  v4 = buf - 1;
  v5 = 34;
  v6 = buf + 11;
  v7 = v4;
  memset(&send_data[4], 0, 12);
  do
  {
    v8 = *++v7;
    v5 += v8;
  }
  while ( v7 != v6 );
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = 16;
  send_data[3] = 18;
  v9 = &send_data[3];
  do
  {
    v10 = *++v4;
    *++v9 = v10;
  }
  while ( v6 != v4 );
  send_data[16] = HIBYTE(v5);
  send_data[17] = v5;
  v11 = (which_i2c << 26) | 0xA00000 | (v3 << 16);
  v12 = (unsigned __int8 *)&v17;
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    v13 = *++v12;
    i2c_write(v13 | v11);
  }
  while ( &send_data[17] != v12 );
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][48][783]);
  v14 = i2c_read(v11);
  v15 = i2c_read(v11);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( v14 == 18 && v15 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8176);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8176,
      v14,
      v15);
    return 0;
  }
}

//----- (00022C94) --------------------------------------------------------
int __fastcall read_hash_id_PIC16F1704(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  unsigned __int8 *v3; // r6
  unsigned int v4; // r5
  int i; // r0
  int v6; // t1
  unsigned __int8 *v7; // r4
  __int16 v8; // r5
  __int16 v9; // r6
  int v10; // r7
  int v11; // r8
  __int16 v12; // r11
  __int16 v13; // r9
  int v14; // r10
  bool v15; // zf
  unsigned int v17; // r2
  unsigned __int8 *v18; // r1
  unsigned __int8 *v19; // r3
  char v20; // t1
  __int16 v21; // [sp+38h] [bp-40h]
  __int16 v22; // [sp+3Ch] [bp-3Ch]
  __int16 v23; // [sp+40h] [bp-38h]
  __int16 v24; // [sp+44h] [bp-34h]
  __int16 v25; // [sp+48h] [bp-30h]
  __int16 v26; // [sp+4Ch] [bp-2Ch]
  __int16 v27; // [sp+50h] [bp-28h]
  int v28; // [sp+54h] [bp-24h]
  __int16 v29; // [sp+58h] [bp-20h]
  unsigned __int8 send_data[6]; // [sp+60h] [bp-18h] BYREF
  char v32; // [sp+67h] [bp-11h] BYREF
  unsigned __int8 read_back_data[16]; // [sp+68h] [bp-10h] BYREF

  send_data[1] = -86;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&send_data[4] = 5888;
  memset(&read_back_data[4], 0, 12);
  send_data[0] = 85;
  v3 = send_data;
  send_data[2] = 4;
  v4 = (which_chain << 16) | 0xA00000 | (which_i2c << 26);
  send_data[3] = 19;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v6 )
  {
    i2c_write(i | v4);
    if ( &send_data[5] == v3 )
      break;
    v6 = *++v3;
  }
  v7 = (unsigned __int8 *)&v32;
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  do
    *++v7 = i2c_read(v4);
  while ( &read_back_data[15] != v7 );
  pthread_mutex_unlock(&i2c_mutex);
  v23 = read_back_data[7];
  v21 = read_back_data[5];
  v24 = read_back_data[8];
  v25 = read_back_data[9];
  v22 = read_back_data[6];
  v8 = read_back_data[2];
  v9 = read_back_data[3];
  v26 = read_back_data[10];
  v10 = read_back_data[0];
  v11 = read_back_data[1];
  v29 = read_back_data[4];
  v12 = read_back_data[11];
  v13 = read_back_data[12];
  v27 = read_back_data[13];
  v14 = read_back_data[14];
  v28 = read_back_data[15];
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,     "
    "   read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,        re"
    "ad_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,        read_"
    "back_data[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
    (const char *)_FUNCTION___8194,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4],
    read_back_data[5],
    read_back_data[6],
    read_back_data[7],
    read_back_data[8],
    read_back_data[9],
    read_back_data[10],
    read_back_data[11],
    read_back_data[12],
    read_back_data[13],
    read_back_data[14],
    read_back_data[15]);
  v15 = v10 == 16;
  if ( v10 == 16 )
    v15 = v11 == 19;
  if ( v15 )
  {
    v17 = (unsigned __int16)(v29 + v8 + v9 + 35 + v21 + v22 + v23 + v24 + v25 + v26 + v12 + v13 + v27);
    if ( v14 == v17 >> 8
      && v28 == (unsigned __int8)(v29 + v8 + v9 + 35 + v21 + v22 + v23 + v24 + v25 + v26 + v12 + v13 + v27) )
    {
      v18 = &read_back_data[2];
      v19 = buf - 1;
      while ( 1 )
      {
        *++v19 = v8;
        if ( buf + 11 == v19 )
          break;
        v20 = *++v18;
        LOBYTE(v8) = v20;
      }
      printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8194);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___8194, v17);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8194);
    return 0;
  }
}

//----- (00022E6C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall enable_PIC16F1704_dc_dc(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int8 enable)
{
  __int16 v3; // r5
  int v4; // r8
  int v5; // r6
  unsigned __int8 *v6; // r4
  int v7; // r0
  int v8; // r5
  int v9; // t1
  int v10; // r6
  int v11; // r4
  unsigned __int8 send_data[7]; // [sp+0h] [bp-8h] BYREF

  v3 = enable;
  v4 = (unsigned __int8)which_chain;
  v5 = (which_i2c << 26) | 0xA00000;
  printf("\n--- %s\n", (const char *)_FUNCTION___8209);
  send_data[4] = v3;
  send_data[6] = v3 + 26;
  send_data[5] = (unsigned __int16)(v3 + 26) >> 8;
  send_data[0] = 85;
  send_data[1] = -86;
  v6 = send_data;
  send_data[2] = 5;
  send_data[3] = 21;
  pthread_mutex_lock(&i2c_mutex);
  v7 = 85;
  v8 = v5 | ((unsigned __int8)v4 << 16);
  while ( 1 )
  {
    i2c_write(v7 | v8);
    if ( &send_data[6] == v6 )
      break;
    v9 = *++v6;
    v7 = v9;
  }
  usleep(0x186A0u);
  v10 = i2c_read(v5 | (v4 << 16));
  v11 = i2c_read(v8);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v10 == 21 && v11 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8209);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8209,
      v10,
      v11);
    return 0;
  }
}
// 22E6C: variables would overlap: r2.1 and r2.2

//----- (00022F58) --------------------------------------------------------
int __fastcall heart_beat_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c)
{
  unsigned __int8 *v2; // r4
  int v3; // r5
  int i; // r0
  int v5; // t1
  unsigned __int8 *v6; // r4
  unsigned __int8 read_back_data[6]; // [sp+0h] [bp-30h] BYREF
  char v9; // [sp+6h] [bp-2Ah] BYREF
  unsigned __int8 send_data[6]; // [sp+8h] [bp-28h] BYREF

  send_data[1] = -86;
  *(_WORD *)&send_data[4] = 6656;
  memset(read_back_data, 0, sizeof(read_back_data));
  send_data[0] = 85;
  v2 = send_data;
  send_data[2] = 4;
  v3 = (which_i2c << 26) | 0xA00000 | ((unsigned __int8)which_chain << 16);
  send_data[3] = 22;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v5 )
  {
    i2c_write(i | v3);
    if ( v2 == &send_data[5] )
      break;
    v5 = *++v2;
  }
  v6 = read_back_data;
  usleep((__useconds_t)&loc_186A0);
  do
    *v6++ = i2c_read(v3);
  while ( &v9 != (char *)v6 );
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] == 22 && read_back_data[2] == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8232);
    return 1;
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8232);
    return 0;
  }
}

//----- (0002302C) --------------------------------------------------------
int __fastcall get_PIC16F1704_software_version(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *version)
{
  unsigned __int8 *v4; // r4
  unsigned int v5; // r5
  int i; // r0
  int v7; // t1
  unsigned __int8 *v8; // r4
  int v9; // r5
  int v10; // r4
  int v11; // r6
  __int64 v12; // r8
  bool v13; // zf
  unsigned __int8 read_back_data[5]; // [sp+10h] [bp-30h] BYREF
  char v16; // [sp+15h] [bp-2Bh] BYREF
  unsigned __int8 send_data[6]; // [sp+18h] [bp-28h] BYREF

  send_data[1] = -86;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&send_data[4] = 6912;
  read_back_data[4] = 0;
  send_data[0] = 85;
  v4 = send_data;
  send_data[2] = 4;
  v5 = (which_chain << 16) | 0xA00000 | (which_i2c << 26);
  send_data[3] = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v7 )
  {
    i2c_write(i | v5);
    if ( v4 == &send_data[5] )
      break;
    v7 = *++v4;
  }
  v8 = read_back_data;
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  do
    *v8++ = i2c_read(v5);
  while ( v8 != (unsigned __int8 *)&v16 );
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v9 = read_back_data[0];
  v10 = read_back_data[1];
  v11 = read_back_data[2];
  LODWORD(v12) = read_back_data[3];
  HIDWORD(v12) = read_back_data[4];
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    (const char *)_FUNCTION___8250,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4]);
  v13 = v10 == 23;
  if ( v10 == 23 )
    v13 = v9 == 5;
  if ( v13 )
  {
    if ( v12 == __PAIR64__((unsigned __int8)(v11 + 28), (unsigned __int8)((unsigned __int16)(v11 + 28) >> 8)) )
    {
      *version = v11;
      printf("\n--- %s ok, version = 0x%02x\n\n", (const char *)_FUNCTION___8250, v11);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___8250, v11 + 28);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8250);
    return 0;
  }
}

//----- (0002315C) --------------------------------------------------------
int __fastcall get_PIC16F1704_voltage(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *voltage)
{
  unsigned __int8 *v4; // r4
  unsigned int v5; // r5
  int i; // r0
  int v7; // t1
  unsigned __int8 *v8; // r4
  int v9; // r5
  int v10; // r4
  int v11; // r6
  __int64 v12; // r8
  bool v13; // zf
  unsigned __int8 read_back_data[5]; // [sp+10h] [bp-30h] BYREF
  char v16; // [sp+15h] [bp-2Bh] BYREF
  unsigned __int8 send_data[6]; // [sp+18h] [bp-28h] BYREF

  send_data[1] = -86;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&send_data[4] = 7168;
  read_back_data[4] = 0;
  send_data[0] = 85;
  v4 = send_data;
  send_data[2] = 4;
  v5 = (which_chain << 16) | 0xA00000 | (which_i2c << 26);
  send_data[3] = 24;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v7 )
  {
    i2c_write(i | v5);
    if ( v4 == &send_data[5] )
      break;
    v7 = *++v4;
  }
  v8 = read_back_data;
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  do
    *v8++ = i2c_read(v5);
  while ( v8 != (unsigned __int8 *)&v16 );
  pthread_mutex_unlock(&i2c_mutex);
  v9 = read_back_data[0];
  v10 = read_back_data[1];
  v11 = read_back_data[2];
  LODWORD(v12) = read_back_data[3];
  HIDWORD(v12) = read_back_data[4];
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    (const char *)_FUNCTION___8268,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4]);
  v13 = v10 == 24;
  if ( v10 == 24 )
    v13 = v9 == 5;
  if ( v13 )
  {
    if ( v12 == __PAIR64__((unsigned __int8)(v11 + 29), (unsigned __int8)((unsigned __int16)(v11 + 29) >> 8)) )
    {
      *voltage = v11;
      printf("\n--- %s ok, voltage = 0x%02x\n\n", (const char *)_FUNCTION___8268, v11);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___8268, v11 + 29);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8268);
    return 0;
  }
}

//----- (00023280) --------------------------------------------------------
int __fastcall write_temperature_offset_PIC16F1704(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf)
{
  unsigned __int8 *v4; // r0
  __int16 v5; // r3
  unsigned __int8 *v6; // r2
  unsigned __int8 *v7; // r4
  int v8; // r6
  __int16 v9; // t1
  unsigned __int8 *v10; // r1
  unsigned __int8 v11; // t1
  unsigned __int8 *v12; // r4
  unsigned int v13; // r5
  int v14; // t1
  int v15; // r6
  int v16; // r4
  char v18; // [sp+0h] [bp-29h] BYREF
  unsigned __int8 send_data[14]; // [sp+1h] [bp-28h] BYREF

  v4 = buf - 1;
  v5 = 46;
  v6 = buf + 7;
  v7 = v4;
  v8 = which_chain;
  *(_DWORD *)&send_data[4] = 0;
  *(_DWORD *)&send_data[8] = 0;
  do
  {
    v9 = *++v7;
    v5 += v9;
  }
  while ( v7 != v6 );
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = 12;
  send_data[3] = 34;
  v10 = &send_data[3];
  do
  {
    v11 = *++v4;
    *++v10 = v11;
  }
  while ( v6 != v4 );
  send_data[12] = HIBYTE(v5);
  send_data[13] = v5;
  v12 = (unsigned __int8 *)&v18;
  v13 = (v8 << 16) | 0xA00000 | (which_i2c << 26);
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    v14 = *++v12;
    i2c_write(v14 | v13);
  }
  while ( &send_data[13] != v12 );
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v15 = i2c_read(v13);
  v16 = i2c_read(v13);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( v15 == 34 && v16 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8292);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8292,
      v15,
      v16);
    return 0;
  }
}

//----- (0002336C) --------------------------------------------------------
int __fastcall read_temperature_offset_PIC16F1704(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *buf)
{
  unsigned __int8 *v3; // r6
  unsigned int v4; // r5
  int i; // r0
  int v6; // t1
  unsigned __int8 *v7; // r4
  __int16 v8; // r6
  __int16 v9; // r10
  __int16 v10; // r9
  __int16 v11; // r8
  __int16 v12; // r7
  int v13; // r11
  int v14; // r5
  bool v15; // zf
  unsigned int v17; // r2
  unsigned __int8 v18; // r7
  unsigned __int8 *v19; // r2
  unsigned __int8 *j; // r1
  unsigned __int8 v21; // t1
  int v22; // [sp+2Ch] [bp-34h]
  __int16 v23; // [sp+34h] [bp-2Ch]
  int v24; // [sp+38h] [bp-28h]
  __int16 v25; // [sp+3Ch] [bp-24h]
  __int16 v26; // [sp+40h] [bp-20h]
  unsigned __int8 send_data[6]; // [sp+4Ch] [bp-14h] BYREF
  unsigned __int8 read_back_data[12]; // [sp+54h] [bp-Ch] BYREF
  char v30; // [sp+60h] [bp+0h] BYREF

  send_data[1] = -86;
  *(_DWORD *)read_back_data = 255;
  send_data[5] = 39;
  *(_DWORD *)&read_back_data[4] = 0;
  *(_DWORD *)&read_back_data[8] = 0;
  send_data[0] = 85;
  send_data[2] = 4;
  v3 = send_data;
  strcpy((char *)&send_data[3], "#");
  v4 = (which_chain << 16) | 0xA00000 | (which_i2c << 26);
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v6 )
  {
    i2c_write(i | v4);
    if ( &send_data[5] == v3 )
      break;
    v6 = *++v3;
  }
  v7 = read_back_data;
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  do
    *v7++ = i2c_read(v4);
  while ( v7 != (unsigned __int8 *)&v30 );
  pthread_mutex_unlock(&i2c_mutex);
  v8 = read_back_data[3];
  v9 = read_back_data[4];
  v23 = read_back_data[2];
  v25 = read_back_data[7];
  v10 = read_back_data[5];
  v11 = read_back_data[6];
  v12 = read_back_data[9];
  v13 = read_back_data[10];
  v14 = read_back_data[11];
  v22 = read_back_data[1];
  v24 = read_back_data[0];
  v26 = read_back_data[8];
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,     "
    "    read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,         "
    "read_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
    (const char *)_FUNCTION___8310,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4],
    read_back_data[5],
    read_back_data[6],
    read_back_data[7],
    read_back_data[8],
    read_back_data[9],
    read_back_data[10],
    read_back_data[11]);
  v15 = v24 == 12;
  if ( v24 == 12 )
    v15 = v22 == 35;
  if ( v15 )
  {
    v17 = (unsigned __int16)(v8 + v23 + 47 + v9 + v10 + v11 + v25 + v26 + v12);
    if ( v13 == v17 >> 8 && v14 == (unsigned __int8)(v8 + v23 + 47 + v9 + v10 + v11 + v25 + v26 + v12) )
    {
      v18 = v23;
      v19 = buf - 1;
      for ( j = &read_back_data[2]; ; ++j )
      {
        *++v19 = v18;
        if ( buf + 7 == v19 )
          break;
        v21 = j[1];
        v18 = v21;
      }
      printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8310);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___8310, v17);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8310);
    return 0;
  }
}

//----- (00023500) --------------------------------------------------------
unsigned __int8 __fastcall erase_PIC16F1704_app_flash(unsigned int which_i2c, unsigned __int8 which_chain)
{
  int v4; // r4

  v4 = 76;
  set_PIC16F1704_flash_pointer(which_i2c, which_chain, 6u, 0);
  printf("%s: erase_loop = %d\n", (const char *)_FUNCTION___8326_0, 76);
  do
  {
    erase_PIC16F1704_flash(which_i2c, which_chain);
    --v4;
  }
  while ( v4 );
  return -1;
}

//----- (00023534) --------------------------------------------------------
int __fastcall PIC1704_update_pic_app_program(unsigned int which_i2c, unsigned __int8 which_chain)
{
  FILE *v4; // r0
  FILE *v5; // r5
  unsigned __int8 *v6; // r4
  __int16 v7; // r0
  int v8; // r10
  char *v9; // r5
  unsigned __int8 *v10; // r3
  int v11; // r4
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r1
  int v17; // t1
  unsigned __int8 data_read[5]; // [sp+0h] [bp-13C8h] BYREF
  char v20; // [sp+7h] [bp-13C1h] BYREF
  unsigned __int8 buf[16]; // [sp+8h] [bp-13C0h] BYREF
  unsigned __int8 program_data[5000]; // [sp+18h] [bp-13B0h] BYREF

  memset(program_data, 0, sizeof(program_data));
  memset(buf, 0, sizeof(buf));
  memset(data_read, 0, sizeof(data_read));
  puts("\n--- update pic program");
  v4 = fopen("/mnt/card/pic16f1704_app.txt", "r");
  v5 = v4;
  if ( v4 )
  {
    fseek(v4, 0, 0);
    v6 = program_data;
    memset(program_data, 0, sizeof(program_data));
    printf("pic_flash_length = %d\n", 2432);
    do
    {
      v6 += 2;
      fgets((char *)data_read, 1023, v5);
      v7 = strtoul((const char *)data_read, 0, 16);
      *(v6 - 1) = v7;
      *(v6 - 2) = HIBYTE(v7);
    }
    while ( &program_data[4864] != v6 );
    fclose(v5);
    if ( !reset_PIC16F1704_pic(which_i2c, which_chain) )
    {
LABEL_14:
      printf("!!! %s: reset pic error!\n\n", (const char *)_FUNCTION___8347);
      return 0;
    }
    if ( !erase_PIC16F1704_app_flash(which_i2c, which_chain) )
    {
      printf("!!! %s: erase flash error!\n\n", (const char *)_FUNCTION___8347);
      return 0;
    }
    if ( set_PIC16F1704_flash_pointer(which_i2c, which_chain, 6u, 0) )
    {
      v8 = 0;
      do
      {
        v9 = &v20;
        v10 = &program_data[16 * v8];
        v11 = 0;
        v12 = *(_DWORD *)v10;
        v13 = *((_DWORD *)v10 + 1);
        v14 = *((_DWORD *)v10 + 2);
        v15 = *((_DWORD *)v10 + 3);
        *(_DWORD *)buf = v12;
        *(_DWORD *)&buf[4] = v13;
        *(_DWORD *)&buf[8] = v14;
        *(_DWORD *)&buf[12] = v15;
        printf("send pic program time: %d\n", v8);
        do
        {
          v16 = v11;
          v17 = (unsigned __int8)*++v9;
          ++v11;
          printf("buf[%d] = 0x%02x\n", v16, v17);
        }
        while ( v11 != 16 );
        ++v8;
        putchar(10);
        send_data_to_PIC16F1704(which_i2c, which_chain, buf);
        write_data_into_PIC16F1704_flash(which_i2c, which_chain);
      }
      while ( v8 != 304 );
      if ( reset_PIC16F1704_pic(which_i2c, which_chain) )
        return 1;
      goto LABEL_14;
    }
    printf("!!! %s: set flash pointer error!\n\n", (const char *)_FUNCTION___8347);
    return 0;
  }
  else
  {
    printf("\n%s: open pic16f1704_app.txt failed\n", (const char *)_FUNCTION___8347);
    return 0;
  }
}

//----- (000236F0) --------------------------------------------------------
int __fastcall save_freq_PIC16F1704(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 freq)
{
  int v3; // r8
  int v4; // r6
  unsigned __int8 *v5; // r4
  int v6; // r0
  int v7; // r5
  int v8; // t1
  int v9; // r6
  int v10; // r4
  unsigned __int8 send_data[8]; // [sp+0h] [bp-8h] BYREF

  send_data[5] = freq;
  v3 = (unsigned __int8)which_chain;
  send_data[4] = HIBYTE(freq);
  send_data[6] = (unsigned __int16)((unsigned __int8)freq + HIBYTE(freq) + 42) >> 8;
  send_data[7] = freq + HIBYTE(freq) + 42;
  v4 = (which_i2c << 26) | 0xA00000;
  send_data[0] = 85;
  v5 = send_data;
  send_data[1] = -86;
  send_data[2] = 6;
  send_data[3] = 36;
  pthread_mutex_lock(&i2c_mutex);
  v6 = 85;
  v7 = v4 | (v3 << 16);
  while ( 1 )
  {
    i2c_write(v6 | v7);
    if ( &send_data[7] == v5 )
      break;
    v8 = *++v5;
    v6 = v8;
  }
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  v9 = i2c_read(v4 | (v3 << 16));
  v10 = i2c_read(v7);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( v9 == 36 && v10 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8374);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8374,
      v9,
      v10);
    return 0;
  }
}

//----- (000237CC) --------------------------------------------------------
int __fastcall get_PIC16F1704_freq(unsigned int which_chain, unsigned __int8 which_i2c, unsigned __int16 *freq)
{
  unsigned __int8 *v4; // r4
  int v5; // r5
  int i; // r0
  int v7; // t1
  unsigned __int8 *v8; // r4
  int v9; // r5
  int v10; // r4
  int v11; // r8
  int v12; // r6
  int v13; // r9
  int v14; // r10
  bool v15; // zf
  int v17; // r2
  int v18; // r2
  unsigned __int8 read_back_data[6]; // [sp+10h] [bp-30h] BYREF
  char v20; // [sp+16h] [bp-2Ah] BYREF
  unsigned __int8 send_data[6]; // [sp+18h] [bp-28h] BYREF

  send_data[1] = -86;
  *(_DWORD *)read_back_data = 255;
  send_data[5] = 41;
  *(_WORD *)&read_back_data[4] = 0;
  v4 = send_data;
  send_data[0] = 85;
  v5 = (which_i2c << 26) | 0xA00000 | ((unsigned __int8)which_chain << 16);
  send_data[2] = 4;
  strcpy((char *)&send_data[3], "%");
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v7 )
  {
    i2c_write(i | v5);
    if ( v4 == &send_data[5] )
      break;
    v7 = *++v4;
  }
  v8 = read_back_data;
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  do
    *v8++ = i2c_read(v5);
  while ( v8 != (unsigned __int8 *)&v20 );
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v9 = read_back_data[0];
  v10 = read_back_data[1];
  v11 = read_back_data[2];
  v12 = read_back_data[3];
  v13 = read_back_data[4];
  v14 = read_back_data[5];
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
    (const char *)_FUNCTION___8392,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4],
    read_back_data[5]);
  v15 = v10 == 37;
  if ( v10 == 37 )
    v15 = v9 == 6;
  if ( v15 )
  {
    v17 = v11 + v12 + 43;
    if ( BYTE1(v17) == v13 && v14 == (unsigned __int8)v17 )
    {
      v18 = v12 | (v11 << 8);
      *freq = v18;
      printf("\n--- %s ok, freq = %d\n\n", (const char *)_FUNCTION___8392, v18);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___8392, v17);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8392);
    return 0;
  }
}

//----- (00023914) --------------------------------------------------------
void __fastcall set_temperature_offset_value(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *value)
{
  printf("\n--- %s\n", (const char *)_FUNCTION___8398);
  write_temperature_offset_PIC16F1704(which_i2c, which_chain, value);
  j_usleep((__useconds_t)&loc_186A0);
}

//----- (00023948) --------------------------------------------------------
void __fastcall write_sensor_info_into_pic(unsigned int which_i2c, unsigned __int8 which_chain)
{
  unsigned __int8 offset_value[8]; // [sp+0h] [bp-20h] BYREF

  printf("\n--- %s\n", (const char *)_FUNCTION___8404);
  offset_value[1] = 0;
  offset_value[3] = 0;
  offset_value[5] = 0;
  offset_value[6] = LOBYTE(Conf.sensor_model) | 0x20;
  offset_value[0] = Conf.TempSensor1;
  offset_value[2] = Conf.TempSensor2;
  offset_value[4] = Conf.TempSensor3;
  offset_value[7] = Conf.remote_local_gap;
  set_temperature_offset_value(which_i2c, which_chain, offset_value);
}

//----- (000239B8) --------------------------------------------------------
int __fastcall send_data_to_dsPIC33EP16GS202(unsigned int which_i2c, unsigned __int8 which_chain, unsigned __int8 *buf)
{
  unsigned __int8 *v3; // r4
  unsigned __int8 *v5; // r2
  unsigned __int8 *v6; // r0
  __int16 v7; // r3
  __int16 v8; // t1
  unsigned __int8 *v9; // r2
  unsigned __int8 v10; // t1
  unsigned __int8 *v11; // r4
  unsigned int v12; // r5
  int v13; // t1
  int v14; // r6
  int v15; // r4
  char v17; // [sp+0h] [bp-31h] BYREF
  unsigned __int8 send_data[22]; // [sp+1h] [bp-30h] BYREF

  v3 = buf - 1;
  v5 = buf + 15;
  v6 = v3;
  v7 = 22;
  memset(&send_data[4], 0, 16);
  do
  {
    v8 = *++v6;
    v7 += v8;
  }
  while ( v6 != v5 );
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = 20;
  send_data[3] = 2;
  v9 = &send_data[3];
  do
  {
    v10 = *++v3;
    *++v9 = v10;
  }
  while ( v9 != &send_data[19] );
  send_data[20] = HIBYTE(v7);
  send_data[21] = v7;
  v11 = (unsigned __int8 *)&v17;
  v12 = (which_chain << 16) | 0x400000 | (which_i2c << 26);
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    v13 = *++v11;
    i2c_write(v13 | v12);
  }
  while ( &send_data[21] != v11 );
  usleep(0x186A0u);
  v14 = i2c_read(v12);
  v15 = i2c_read(v12);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v14 == 2 && v15 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8428);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8428,
      v14,
      v15);
    return 0;
  }
}

//----- (00023AA0) --------------------------------------------------------
int __fastcall jump_from_loader_to_app_dsPIC33EP16GS202(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r8
  int v3; // r6
  unsigned __int8 *v4; // r4
  int v5; // r0
  int v6; // r5
  int v7; // t1
  int v8; // r6
  int v9; // r4
  unsigned __int8 send_data[6]; // [sp+0h] [bp-8h] BYREF

  v2 = (unsigned __int8)which_chain;
  *(_WORD *)&send_data[4] = 2560;
  send_data[1] = -86;
  v3 = (which_i2c << 26) | 0x400000;
  send_data[0] = 85;
  send_data[2] = 4;
  v4 = send_data;
  send_data[3] = 6;
  pthread_mutex_lock(&i2c_mutex);
  v5 = 85;
  v6 = v3 | (v2 << 16);
  while ( 1 )
  {
    i2c_write(v5 | v6);
    if ( &send_data[5] == v4 )
      break;
    v7 = *++v4;
    v5 = v7;
  }
  usleep(0x186A0u);
  v8 = i2c_read(v3 | (v2 << 16));
  v9 = i2c_read(v6);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  if ( v8 == 6 && v9 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8445);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8445,
      v8,
      v9);
    return 0;
  }
}

//----- (00023B70) --------------------------------------------------------
int __fastcall reset_dsPIC33EP16GS202_pic(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r8
  int v3; // r6
  unsigned __int8 *v4; // r4
  int v5; // r0
  int v6; // r5
  int v7; // t1
  int v8; // r6
  int v9; // r4
  unsigned __int8 send_data[6]; // [sp+0h] [bp-8h] BYREF

  v2 = (unsigned __int8)which_chain;
  *(_WORD *)&send_data[4] = 2816;
  send_data[1] = -86;
  v3 = (which_i2c << 26) | 0x400000;
  send_data[0] = 85;
  send_data[2] = 4;
  v4 = send_data;
  send_data[3] = 7;
  pthread_mutex_lock(&i2c_mutex);
  v5 = 85;
  v6 = v3 | (v2 << 16);
  while ( 1 )
  {
    i2c_write(v5 | v6);
    if ( &send_data[5] == v4 )
      break;
    v7 = *++v4;
    v5 = v7;
  }
  usleep(0x186A0u);
  v8 = i2c_read(v3 | (v2 << 16));
  v9 = i2c_read(v6);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
  if ( v8 == 7 && v9 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8462);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8462,
      v8,
      v9);
    return 0;
  }
}

//----- (00023C40) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_erase_pic_app_program(unsigned int which_chain, unsigned __int8 which_i2c)
{
  int v2; // r6
  int v3; // r8
  int v4; // r6
  unsigned __int8 *v5; // r4
  int i; // r0
  int v7; // t1
  int v8; // r4
  int v9; // r5
  bool v10; // zf
  unsigned __int8 send_data[6]; // [sp+0h] [bp-20h] BYREF

  send_data[4] = 0;
  v2 = which_i2c << 26;
  v3 = (unsigned __int8)which_chain;
  printf("\n--- %s\n", (const char *)_FUNCTION___8473);
  printf("--- %s: crc_data[0] = 0x%x, crc_data[1] = 0x%x\n", (const char *)_FUNCTION___8473, 0, 13);
  send_data[1] = -86;
  v4 = v2 | 0x400000;
  send_data[0] = 85;
  v5 = send_data;
  send_data[2] = 4;
  send_data[3] = 9;
  send_data[5] = 13;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v7 )
  {
    i2c_write(i | v4 | ((unsigned __int8)v3 << 16));
    if ( &send_data[5] == v5 )
      break;
    v7 = *++v5;
  }
  usleep(0x186A0u);
  v8 = i2c_read(v4 | (v3 << 16));
  v9 = i2c_read(v4 | (v3 << 16));
  pthread_mutex_unlock(&i2c_mutex);
  printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n", (const char *)_FUNCTION___8473, v8, v9);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v10 = v8 == 9;
  if ( v8 == 9 )
    v10 = v9 == 1;
  if ( v10 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8473);
    return 1;
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8473);
    return 0;
  }
}

//----- (00023D40) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall set_dsPIC33EP16GS202_voltage(
        unsigned int which_chain,
        unsigned __int8 which_i2c,
        unsigned __int8 voltage)
{
  __int16 v3; // r5
  int v4; // r8
  int v5; // r6
  unsigned __int8 *v6; // r4
  int v7; // r0
  int v8; // r5
  int v9; // t1
  int v10; // r6
  int v11; // r4
  unsigned __int8 send_data[9]; // [sp+4h] [bp-Ch] BYREF

  v3 = voltage;
  v4 = (unsigned __int8)which_chain;
  v5 = (which_i2c << 26) | 0x400000;
  printf("\n--- %s\n", (const char *)_FUNCTION___8491);
  *(_DWORD *)&send_data[4] = (unsigned __int8)v3;
  send_data[8] = v3 + 23;
  send_data[7] = (unsigned __int16)(v3 + 23) >> 8;
  send_data[0] = 85;
  send_data[1] = -86;
  v6 = send_data;
  send_data[2] = 7;
  send_data[3] = 16;
  pthread_mutex_lock(&i2c_mutex);
  v7 = 85;
  v8 = v5 | ((unsigned __int8)v4 << 16);
  while ( 1 )
  {
    i2c_write(v7 | v8);
    if ( &send_data[8] == v6 )
      break;
    v9 = *++v6;
    v7 = v9;
  }
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v10 = i2c_read(v5 | (v4 << 16));
  v11 = i2c_read(v8);
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( v10 == 16 && v11 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8491);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8491,
      v10,
      v11);
    return 0;
  }
}
// 23D40: variables would overlap: r2.1 and r2.2

//----- (00023E30) --------------------------------------------------------
int __fastcall set_dsPIC33EP16GS202_threshold_voltage(
        unsigned int which_chain,
        unsigned __int8 which_i2c,
        unsigned __int16 vol,
        unsigned __int16 vol1,
        unsigned __int16 vol2,
        unsigned __int16 vol3,
        unsigned __int16 vol_p)
{
  int v7; // r10
  int v8; // r11
  int v9; // r8
  int v10; // r6
  __int16 v11; // r1
  bool v12; // r10
  bool v13; // r11
  unsigned __int8 v14; // r12
  unsigned __int8 v15; // r1
  unsigned __int8 *v16; // r4
  int v17; // r0
  int v18; // r5
  int v19; // t1
  int v20; // r6
  int v21; // r4
  unsigned __int8 send_data[16]; // [sp+0h] [bp-38h] BYREF

  v7 = vol;
  v8 = vol1;
  *(_DWORD *)send_data = 0;
  v9 = (unsigned __int8)which_chain;
  *(_DWORD *)&send_data[12] = 0;
  v10 = (which_i2c << 26) | 0x400000;
  printf("\n--- %s\n", (const char *)_FUNCTION___8513_0);
  *(_DWORD *)&send_data[4] = BYTE1(v7);
  *(_DWORD *)&send_data[8] = HIBYTE(vol2);
  v11 = vol_p + 65 + vol3 + vol2 + v8 + v7;
  v12 = v7 != 0;
  send_data[6] = BYTE1(v8);
  v13 = v8 != 0;
  v14 = vol2;
  send_data[14] = HIBYTE(v11);
  if ( vol2 )
    v14 = 1;
  send_data[15] = v11;
  v15 = vol_p;
  if ( vol_p )
    v15 = 1;
  send_data[9] = v14;
  send_data[10] = HIBYTE(vol3);
  send_data[0] = 85;
  v16 = send_data;
  send_data[5] = v12;
  send_data[7] = v13;
  send_data[11] = vol3 != 0;
  send_data[12] = HIBYTE(vol_p);
  send_data[13] = v15;
  send_data[1] = -86;
  send_data[2] = 14;
  send_data[3] = 51;
  pthread_mutex_lock(&i2c_mutex);
  v17 = 85;
  v18 = v10 | ((unsigned __int8)v9 << 16);
  while ( 1 )
  {
    i2c_write(v17 | v18);
    if ( &send_data[15] == v16 )
      break;
    v19 = *++v16;
    v17 = v19;
  }
  usleep(0x186A0u);
  v20 = i2c_read(v10 | (v9 << 16));
  v21 = i2c_read(v18);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v20 == 51 && v21 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8513_0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8513_0,
      v20,
      v21);
    return 0;
  }
}

//----- (00023FA4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall enable_dsPIC33EP16GS202_dc_dc(
        unsigned int which_chain,
        unsigned __int8 which_i2c,
        unsigned __int8 enable)
{
  __int16 v3; // r5
  int v4; // r8
  int v5; // r6
  unsigned __int8 *v6; // r4
  int v7; // r0
  int v8; // r5
  int v9; // t1
  int v10; // r6
  int v11; // r4
  unsigned __int8 send_data[7]; // [sp+0h] [bp-8h] BYREF

  v3 = enable;
  v4 = (unsigned __int8)which_chain;
  v5 = (which_i2c << 26) | 0x400000;
  printf("\n--- %s\n", (const char *)_FUNCTION___8531);
  send_data[4] = v3;
  send_data[6] = v3 + 26;
  send_data[5] = (unsigned __int16)(v3 + 26) >> 8;
  send_data[0] = 85;
  send_data[1] = -86;
  v6 = send_data;
  send_data[2] = 5;
  send_data[3] = 21;
  pthread_mutex_lock(&i2c_mutex);
  v7 = 85;
  v8 = v5 | ((unsigned __int8)v4 << 16);
  while ( 1 )
  {
    i2c_write(v7 | v8);
    if ( &send_data[6] == v6 )
      break;
    v9 = *++v6;
    v7 = v9;
  }
  usleep(0x186A0u);
  v10 = i2c_read(v5 | (v4 << 16));
  v11 = i2c_read(v8);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v10 == 21 && v11 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8531);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8531,
      v10,
      v11);
    return 0;
  }
}
// 23FA4: variables would overlap: r2.1 and r2.2

//----- (00024090) --------------------------------------------------------
int __fastcall enable_dsPIC33EP16GS202_clamping_voltage(
        unsigned int which_chain,
        unsigned __int8 which_i2c,
        unsigned __int8 enable)
{
  unsigned __int8 v3; // r8
  int v4; // r6
  __int16 v5; // r4
  int v6; // r6
  unsigned __int8 *v7; // r4
  int v8; // r0
  int v9; // r5
  int v10; // t1
  int v11; // r6
  int v12; // r4
  unsigned __int8 send_data[7]; // [sp+0h] [bp-20h] BYREF

  v3 = which_chain;
  v4 = which_i2c;
  v5 = enable;
  memset(send_data, 0, sizeof(send_data));
  if ( enable )
    printf("\n--- %s on\n", (const char *)_FUNCTION___8549);
  else
    printf("\n--- %s off\n", (const char *)_FUNCTION___8549);
  send_data[5] = (unsigned __int16)(v5 + 54) >> 8;
  send_data[6] = v5 + 54;
  v6 = (v4 << 26) | 0x400000;
  send_data[4] = v5;
  v7 = send_data;
  send_data[0] = 85;
  send_data[1] = -86;
  send_data[2] = 5;
  send_data[3] = 49;
  pthread_mutex_lock(&i2c_mutex);
  v8 = 85;
  v9 = v6 | (v3 << 16);
  while ( 1 )
  {
    i2c_write(v8 | v9);
    if ( &send_data[6] == v7 )
      break;
    v10 = *++v7;
    v8 = v10;
  }
  usleep(0x186A0u);
  v11 = i2c_read(v6 | (v3 << 16));
  v12 = i2c_read(v9);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v11 == 49 && v12 == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8549);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      (const char *)_FUNCTION___8549,
      v11,
      v12);
    return 0;
  }
}

//----- (00024190) --------------------------------------------------------
int __fastcall heart_beat_dsPIC33EP16GS202(unsigned int which_chain, unsigned __int8 which_i2c)
{
  unsigned __int8 *v2; // r4
  int v3; // r5
  int i; // r0
  int v5; // t1
  unsigned __int8 *v6; // r4
  unsigned __int8 read_back_data[6]; // [sp+0h] [bp-30h] BYREF
  char v9; // [sp+6h] [bp-2Ah] BYREF
  unsigned __int8 send_data[6]; // [sp+8h] [bp-28h] BYREF

  send_data[1] = -86;
  *(_WORD *)&send_data[4] = 6656;
  memset(read_back_data, 0, sizeof(read_back_data));
  send_data[0] = 85;
  v2 = send_data;
  send_data[2] = 4;
  v3 = (which_i2c << 26) | 0x400000 | ((unsigned __int8)which_chain << 16);
  send_data[3] = 22;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v5 )
  {
    i2c_write(i | v3);
    if ( v2 == &send_data[5] )
      break;
    v5 = *++v2;
  }
  v6 = read_back_data;
  usleep((__useconds_t)&loc_186A0);
  do
    *v6++ = i2c_read(v3);
  while ( &v9 != (char *)v6 );
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] == 22 && read_back_data[2] == 1 )
  {
    printf("\n--- %s ok\n\n", (const char *)_FUNCTION___8572);
    return 1;
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8572);
    return 0;
  }
}

//----- (00024264) --------------------------------------------------------
int __fastcall get_dsPIC33EP16GS202_software_version(
        unsigned int which_i2c,
        unsigned __int8 which_chain,
        unsigned __int8 *version)
{
  unsigned __int8 *v4; // r4
  unsigned int v5; // r5
  int i; // r0
  int v7; // t1
  unsigned __int8 *v8; // r4
  int v9; // r5
  int v10; // r4
  int v11; // r6
  __int64 v12; // r8
  bool v13; // zf
  unsigned __int8 read_back_data[5]; // [sp+10h] [bp-30h] BYREF
  char v16; // [sp+15h] [bp-2Bh] BYREF
  unsigned __int8 send_data[6]; // [sp+18h] [bp-28h] BYREF

  send_data[1] = -86;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&send_data[4] = 6912;
  read_back_data[4] = 0;
  send_data[0] = 85;
  v4 = send_data;
  send_data[2] = 4;
  v5 = (which_chain << 16) | 0x400000 | (which_i2c << 26);
  send_data[3] = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v7 )
  {
    i2c_write(i | v5);
    if ( v4 == &send_data[5] )
      break;
    v7 = *++v4;
  }
  v8 = read_back_data;
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  do
    *v8++ = i2c_read(v5);
  while ( v8 != (unsigned __int8 *)&v16 );
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  v9 = read_back_data[0];
  v10 = read_back_data[1];
  v11 = read_back_data[2];
  LODWORD(v12) = read_back_data[3];
  HIDWORD(v12) = read_back_data[4];
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    (const char *)_FUNCTION___8590,
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4]);
  v13 = v10 == 23;
  if ( v10 == 23 )
    v13 = v9 == 5;
  if ( v13 )
  {
    if ( v12 == __PAIR64__((unsigned __int8)(v11 + 28), (unsigned __int8)((unsigned __int16)(v11 + 28) >> 8)) )
    {
      *version = v11;
      printf("\n--- %s ok, version = 0x%02x\n\n", (const char *)_FUNCTION___8590, v11);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", (const char *)_FUNCTION___8590, v11 + 28);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8590);
    return 0;
  }
}

//----- (00024394) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_read_out_4_voltage(
        unsigned __int8 which_iic,
        unsigned __int8 which_chain,
        unsigned int *vol0,
        unsigned int *vol1,
        unsigned int *vol2,
        unsigned int *vol3)
{
  unsigned __int8 *v8; // r6
  int v9; // r5
  int i; // r0
  int v11; // t1
  unsigned __int8 *v12; // r4
  int v14; // lr
  int v15; // r3
  int v16; // r6
  int v17; // r2
  int v18; // r5
  int v19; // r5
  unsigned __int8 send_data[6]; // [sp+8h] [bp-40h] BYREF
  unsigned __int8 read_back_data[13]; // [sp+10h] [bp-38h] BYREF
  char v22; // [sp+1Dh] [bp-2Bh] BYREF

  send_data[2] = 4;
  send_data[5] = 44;
  memset(read_back_data, 0, sizeof(read_back_data));
  v8 = send_data;
  v9 = (which_chain << 16) | 0x400000 | (which_iic << 26);
  send_data[0] = 85;
  send_data[1] = -86;
  strcpy((char *)&send_data[3], "(");
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v11 )
  {
    i2c_write(i | v9);
    if ( v8 == &send_data[5] )
      break;
    v11 = *++v8;
  }
  v12 = read_back_data;
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
  do
    *v12++ = i2c_read(v9);
  while ( &v22 != (char *)v12 );
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&gBM1397_MISC_CONTROL_reg);
  if ( read_back_data[1] == 40 && read_back_data[2] == 1 )
  {
    v14 = read_back_data[7];
    v15 = read_back_data[8];
    v16 = read_back_data[9];
    v17 = read_back_data[6] | (read_back_data[5] << 8);
    v18 = read_back_data[10];
    *vol0 = read_back_data[4] | (read_back_data[3] << 8);
    *vol1 = v17;
    v19 = v18 | (v16 << 8);
    *vol2 = v15 | (v14 << 8);
    *vol3 = v19;
    printf(
      "\n--- %s ADC0 = %d, ADC1 = %d, ADC2 = %d, ADC3 = %d\n",
      (const char *)_FUNCTION___8611,
      *vol0,
      *vol1,
      *vol2,
      v19);
    return 1;
  }
  else
  {
    printf("\n--- %s failed!\n\n", (const char *)_FUNCTION___8611);
    return 0;
  }
}

//----- (000244C8) --------------------------------------------------------
void *__fastcall __noreturn pic_heart_beat_func(void *arg)
{
  unsigned int v1; // r5
  unsigned __int8 v2; // r4

  v1 = *(unsigned __int8 *)arg;
  v2 = *((_BYTE *)arg + 1);
  while ( 1 )
  {
    if ( gHashBoard_V9 )
    {
      heart_beat_PIC16F1704(v1, v2);
    }
    else if ( gHashBoard_BHB91601P || gHashBoard_BHB91601S || gHashBoard_BHB07601 )
    {
      heart_beat_dsPIC33EP16GS202(v1, v2);
    }
    else
    {
      printf("\n!!! %s Please check Hashboard type!\n\n", (const char *)_FUNCTION___8618);
    }
    sleep(0xAu);
  }
}

//----- (00024538) --------------------------------------------------------
void __fastcall __noreturn dsPIC33EP16GS202_test(unsigned __int8 which_chain, unsigned __int8 which_i2c)
{
  unsigned int v2; // r4

  v2 = which_chain;
  printf("\n--- %s\n", (const char *)_FUNCTION___8624);
  power_on();
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[3][55][399]);
  power_set_voltage(0x14u);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  reset_dsPIC33EP16GS202_pic(v2, which_i2c);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  jump_from_loader_to_app_dsPIC33EP16GS202(v2, which_i2c);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  enable_dsPIC33EP16GS202_dc_dc(v2, which_i2c, 1u);
  usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  while ( 1 )
  {
    heart_beat_dsPIC33EP16GS202(v2, which_i2c);
    enable_dsPIC33EP16GS202_clamping_voltage(v2, which_i2c, 1u);
    sleep(0x32u);
    heart_beat_dsPIC33EP16GS202(v2, which_i2c);
    enable_dsPIC33EP16GS202_clamping_voltage(v2, which_i2c, 0);
    sleep(0x32u);
  }
}

//----- (000245E4) --------------------------------------------------------
unsigned __int8 __fastcall read_temperature_from_fpga_register(unsigned __int8 which_chain)
{
  int v1; // r5
  int v2; // r4
  int v3; // r6
  unsigned __int8 result; // r0

  v1 = which_chain;
  switch ( which_chain )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
      v2 = (unsigned __int8)(read_axi_fpga(8u) >> (8 * which_chain));
      goto LABEL_3;
    case 4u:
    case 5u:
    case 6u:
    case 7u:
      v2 = (unsigned __int8)(read_axi_fpga(9u) >> (8 * (which_chain - 4)));
      goto LABEL_3;
    case 8u:
    case 9u:
    case 0xAu:
    case 0xBu:
      v2 = (unsigned __int8)(read_axi_fpga(0xAu) >> (8 * (which_chain - 8)));
      goto LABEL_3;
    case 0xCu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
      v2 = (unsigned __int8)(read_axi_fpga(0xBu) >> (8 * (which_chain - 12)));
LABEL_3:
      v3 = v2;
      printf("\n%s: Chain%d temperature is %d\n\n", (const char *)_FUNCTION___7971, v1, v2);
      if ( v2 )
        gSensor_OK[v1][0] = 1;
      break;
    default:
      v3 = 0;
      printf("%s: which_chain = %d, but it is wrong! \n", (const char *)_FUNCTION___7971, gChain);
      printf("\n%s: Chain%d temperature is %d\n\n", (const char *)_FUNCTION___7971, v1, 0);
      LOBYTE(v2) = 0;
      break;
  }
  result = v2;
  if ( Conf.StartTemp <= v3 )
    gStartTest = 1;
  if ( Conf.AlarmTemp < v3 )
    gHigherThanAlarmTemp = 1;
  return result;
}

//----- (000246DC) --------------------------------------------------------
unsigned __int8 __fastcall read_temperature_through_fpga_iic_register(
        unsigned __int8 which_chain,
        unsigned int which_i2c)
{
  int v2; // r7
  int v3; // r4
  unsigned int v4; // r4
  int v5; // r6
  unsigned __int8 result; // r0

  v2 = which_chain;
  v3 = gHashBoard_V9;
  if ( gHashBoard_V9 )
  {
    if ( Conf.sensor_model == 1 )
      v3 = 9437184;
    else
      v3 = 0;
  }
  v4 = v3 | (which_i2c << 26) | 0x1000000 | (which_chain << 16);
  pthread_mutex_lock(&i2c_mutex);
  v5 = i2c_read(v4);
  i2c_read(v4);
  pthread_mutex_unlock(&i2c_mutex);
  result = v5;
  if ( v5 == 255 )
    gSensor_OK[v2][0] = 0;
  if ( v5 >= Conf.StartTemp )
    gStartTest = 1;
  if ( v5 > Conf.AlarmTemp )
    gHigherThanAlarmTemp = 1;
  return result;
}

//----- (00024774) --------------------------------------------------------
void __fastcall write_EEPROM_iic(
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 which_iic,
        unsigned __int8 which_chain,
        unsigned __int8 data)
{
  if ( reg_addr_valid )
    *(_DWORD *)&reg_addr_valid = (reg_addr << 8) | 0x1000000;
  i2c_write(reg_addr_valid | data | 0xA00000 | (which_chain << 16) | (which_iic << 26));
}

//----- (00024798) --------------------------------------------------------
unsigned __int8 __fastcall read_EEPROM_iic(
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 which_iic,
        unsigned __int8 which_chain)
{
  if ( reg_addr_valid )
    *(_DWORD *)&reg_addr_valid = (reg_addr << 8) | 0x1000000;
  return i2c_read(reg_addr_valid | (which_chain << 16) | 0xA00000 | (which_iic << 26));
}

//----- (000247B0) --------------------------------------------------------
void __fastcall AT24C02_write_one_byte(
        unsigned __int8 address,
        unsigned __int8 data,
        unsigned __int8 which_iic,
        unsigned __int8 which_chain)
{
  int v4; // r4
  int v5; // r6
  int v6; // r7
  int v7; // r8

  v4 = data;
  v5 = address;
  v6 = which_iic;
  v7 = which_chain;
  pthread_mutex_lock(&i2c_mutex);
  i2c_write(v4 | 0x1A00000 | (v7 << 16) | (v6 << 26) | (v5 << 8));
  j_pthread_mutex_unlock(&i2c_mutex);
}

//----- (000247E8) --------------------------------------------------------
unsigned __int8 __fastcall AT24C02_read_one_byte(
        unsigned __int8 address,
        unsigned __int8 which_iic,
        unsigned __int8 which_chain)
{
  int v3; // r4
  int v4; // r6
  int v5; // r7

  v3 = which_chain;
  v4 = address;
  v5 = which_iic;
  pthread_mutex_lock(&i2c_mutex);
  LOBYTE(v3) = i2c_read((v3 << 16) | 0x1A00000 | (v5 << 26) | (v4 << 8));
  pthread_mutex_unlock(&i2c_mutex);
  return v3;
}

//----- (0002481C) --------------------------------------------------------
void __fastcall AT24C02_write_bytes(
        unsigned __int8 address,
        unsigned __int8 *buf,
        unsigned __int8 which_iic,
        unsigned __int8 which_chain,
        unsigned int length)
{
  unsigned __int8 *v7; // r5
  unsigned __int8 v8; // r4
  unsigned __int8 *v9; // r8
  unsigned __int8 v10; // t1

  if ( address + length > 0x100 )
  {
    j_printf(
      "\n--- %s: address + length = %d > EEPROM_LENGTH(%d)\n",
      (const char *)_FUNCTION___7777,
      address + length,
      256);
  }
  else if ( length )
  {
    v7 = buf;
    v8 = address;
    v9 = &buf[length];
    do
    {
      v10 = *v7++;
      AT24C02_write_one_byte(v8++, v10, which_iic, which_chain);
    }
    while ( v7 != v9 );
  }
}

//----- (0002487C) --------------------------------------------------------
void __fastcall AT24C02_read_bytes(
        unsigned __int8 address,
        unsigned __int8 *buf,
        unsigned __int8 which_iic,
        unsigned __int8 which_chain,
        unsigned int length)
{
  unsigned __int8 *v7; // r5
  unsigned __int8 v8; // r4
  unsigned __int8 *v9; // r8

  if ( address + length > 0x100 )
  {
    j_printf(
      "\n--- %s: address + length = %d > EEPROM_LENGTH(%d)\n",
      (const char *)_FUNCTION___7789,
      address + length,
      256);
  }
  else if ( length )
  {
    v7 = buf;
    v8 = address;
    v9 = &buf[length];
    do
      *v7++ = AT24C02_read_one_byte(v8++, which_iic, which_chain);
    while ( v7 != v9 );
  }
}

//----- (000248D8) --------------------------------------------------------
int Test_EEPROM()
{
  char *v0; // r3
  unsigned __int8 *v1; // r4
  unsigned __int8 *v2; // r3
  int v3; // r5
  int v4; // r3
  char *v5; // r2
  int v6; // t1
  char v8; // [sp+7h] [bp-1h] BYREF
  unsigned __int8 buf1[256]; // [sp+8h] [bp+0h] BYREF
  char v10; // [sp+108h] [bp+100h] BYREF

  memset(buf1, 0, sizeof(buf1));
  v0 = (char *)buf1;
  do
  {
    *v0 = v0 - (char *)buf1;
    ++v0;
  }
  while ( v0 != &v10 );
  v1 = (unsigned __int8 *)&v8;
  AT24C02_write_bytes(0, buf1, gI2c, gChain, 0x100u);
  v2 = (unsigned __int8 *)&v8;
  do
    *++v2 = 0;
  while ( v2 != &buf1[255] );
  v3 = 0;
  AT24C02_read_bytes(0, buf1, gI2c, gChain, 0x100u);
  v4 = 0;
  v5 = &v8;
  do
  {
    v6 = (unsigned __int8)*++v5;
    if ( v6 != v4 )
      v3 = 1;
    ++v4;
  }
  while ( v4 != 256 );
  do
    *++v1 = -1;
  while ( v1 != &buf1[255] );
  AT24C02_write_bytes(0, buf1, gI2c, gChain, 0x100u);
  return v3;
}

//----- (0002498C) --------------------------------------------------------
int Test_EEPROM_part_area()
{
  unsigned __int8 *v0; // r5
  int v1; // r4
  char *v2; // r3
  unsigned __int8 *v3; // r3
  int v4; // r4
  int v5; // r3
  char *v6; // r2
  int v7; // t1
  char v9; // [sp+7h] [bp-21h] BYREF
  unsigned __int8 buf1[8]; // [sp+8h] [bp-20h] BYREF

  v0 = (unsigned __int8 *)&v9;
  v1 = 0;
  v2 = &v9;
  memset(buf1, 0, sizeof(buf1));
  do
    *++v2 = v1++;
  while ( v1 != 8 );
  puts("\n");
  AT24C02_write_bytes(0, buf1, 0, gChain, 8u);
  v3 = (unsigned __int8 *)&v9;
  do
    *++v3 = 0;
  while ( v3 != &buf1[7] );
  v4 = 0;
  puts("\n");
  AT24C02_read_bytes(0, buf1, 0, gChain, 8u);
  v5 = 0;
  v6 = &v9;
  do
  {
    v7 = (unsigned __int8)*++v6;
    if ( v7 != v5 )
      v4 = 1;
    ++v5;
  }
  while ( v5 != 8 );
  do
    *++v0 = -1;
  while ( v0 != &buf1[7] );
  puts("\n");
  AT24C02_write_bytes(0, buf1, 0, gChain, 8u);
  return v4;
}

//----- (00024A3C) --------------------------------------------------------
void __fastcall AT24C02_save_offset_value(
        unsigned __int8 which_iic,
        unsigned __int8 which_chain,
        unsigned __int8 *offset_value)
{
  unsigned __int8 v6; // r2
  unsigned __int8 *v7; // r4
  int v8; // r2
  int v9; // t1

  printf("\n--- %s\n", (const char *)_FUNCTION___7835);
  v6 = which_iic;
  v7 = offset_value;
  AT24C02_write_bytes(0x98u, offset_value, v6, which_chain, 8u);
  do
  {
    v8 = v7 - offset_value;
    v9 = *v7++;
    printf("%s: offset_value[%d] = %d\n", _FUNCTION___7835, v8, v9);
  }
  while ( v7 != offset_value + 8 );
}

//----- (00024A94) --------------------------------------------------------
void __fastcall AT24C02_save_voltage(unsigned __int8 which_iic, unsigned __int8 which_chain, unsigned int voltage)
{
  printf("\n--- %s\n", (const char *)_FUNCTION___7844);
  AT24C02_write_one_byte(0x90u, voltage, which_iic, which_chain);
  AT24C02_write_one_byte(0x91u, BYTE1(voltage), which_iic, which_chain);
  j_printf("%s: voltage = 0x%02x\n", (const char *)_FUNCTION___7844, voltage);
}

//----- (00024AE0) --------------------------------------------------------
unsigned __int8 __fastcall c2hex(unsigned __int8 value)
{
  int v1; // r3

  if ( (unsigned int)(value - 48) <= 9 )
    return value & 0xF;
  v1 = value & 0xDF;
  switch ( v1 )
  {
    case 'A':
      return 10;
    case 'B':
      return 11;
    case 'C':
      return 12;
    case 'D':
      return 13;
    case 'E':
      return 14;
    case 'F':
      return 15;
  }
  printf("input value error: %c\n", value);
  return -1;
}

//----- (00024B38) --------------------------------------------------------
unsigned __int8 __fastcall twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  char v3; // r4

  v3 = 16 * c2hex(high);
  return c2hex(low) ^ v3;
}

//----- (00024B54) --------------------------------------------------------
int __fastcall s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen)
{
  bool v3; // cc
  int v4; // r4
  int v6; // r7
  int v7; // r8
  const unsigned __int8 *v8; // r6
  const unsigned __int8 *v9; // r4
  unsigned __int8 *v10; // r11
  unsigned __int8 v11; // r10
  unsigned __int8 v12; // t1
  unsigned __int8 v13; // r5
  unsigned __int8 v15; // r4

  v3 = (int)dst <= 0;
  if ( dst )
    v3 = inlen <= 0;
  v4 = v3;
  if ( !src )
    v4 |= 1u;
  if ( v4 )
  {
    printf("s2hex para error dst(%p), src(%p), inlen(%d)\n", dst, src, inlen);
    return -1;
  }
  else
  {
    v6 = inlen >> 1;
    v7 = inlen & 1;
    if ( inlen >> 1 )
    {
      v8 = &src[2 * v6];
      v9 = src;
      v10 = dst - 1;
      do
      {
        v11 = v9[1];
        v12 = *v9;
        v9 += 2;
        v13 = c2hex(v12);
        *++v10 = c2hex(v11) ^ (16 * v13);
      }
      while ( v9 != v8 );
    }
    if ( v7 )
    {
      v15 = c2hex(src[2 * v6]);
      printf("input value error: %c\n", 0);
      dst[v6] = ~(16 * v15);
    }
    return v6 + v7;
  }
}

//----- (00024BF4) --------------------------------------------------------
void print_works()
{
  unsigned int v0; // r10
  unsigned int pattern_number; // r3
  unsigned int mm; // r9
  unsigned int v3; // r8
  unsigned int v4; // r4
  int v5; // t1
  unsigned int v6; // r4
  int v7; // t1
  int v8; // r8
  unsigned int v9; // r7
  unsigned __int8 *i; // r5
  unsigned __int8 *v11; // r6
  int v12; // t1
  unsigned __int8 *v13; // r6
  int v14; // t1
  unsigned int v15; // r7
  unsigned __int8 *j; // r5
  unsigned __int8 *v17; // r6
  int v18; // t1
  unsigned __int8 *v19; // r6
  int v20; // t1
  unsigned int v21; // r7
  unsigned __int8 *k; // r5
  unsigned __int8 *v23; // r6
  int v24; // t1
  unsigned __int8 *v25; // r6
  int v26; // t1
  unsigned int v27; // r7
  unsigned __int8 *m; // r5
  unsigned __int8 *v29; // r6
  int v30; // t1
  unsigned __int8 *v31; // r6
  int v32; // t1
  unsigned int v33; // r7
  unsigned __int8 *n; // r5
  unsigned __int8 *v35; // r6
  int v36; // t1
  unsigned __int8 *v37; // r6
  int v38; // t1
  unsigned int v39; // r7
  unsigned __int8 *ii; // r5
  unsigned __int8 *v41; // r6
  int v42; // t1
  unsigned __int8 *v43; // r6
  int v44; // t1
  unsigned int v45; // r7
  unsigned __int8 *jj; // r5
  unsigned __int8 *v47; // r6
  int v48; // t1
  unsigned __int8 *v49; // r6
  int v50; // t1
  unsigned int v51; // r7
  unsigned __int8 *kk; // r5
  unsigned __int8 *v53; // r6
  int v54; // t1
  unsigned __int8 *v55; // r6
  int v56; // t1
  unsigned int which_asic; // [sp+4h] [bp-54h]
  unsigned int which_asica; // [sp+4h] [bp-54h]
  unsigned int OpenCoreNum1; // [sp+8h] [bp-50h]
  unsigned int OpenCoreNum1a; // [sp+8h] [bp-50h]
  unsigned int OpenCoreNum2; // [sp+Ch] [bp-4Ch]
  unsigned int OpenCoreNum3; // [sp+10h] [bp-48h]
  unsigned int OpenCoreNum4; // [sp+14h] [bp-44h]
  unsigned int OpenCoreNum5; // [sp+18h] [bp-40h]
  unsigned __int8 *OpenCoreNum5a; // [sp+18h] [bp-40h]
  unsigned int OpenCoreNum6; // [sp+1Ch] [bp-3Ch]
  unsigned int OpenCoreNum7; // [sp+20h] [bp-38h]
  unsigned int OpenCoreNum8; // [sp+24h] [bp-34h]

  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  OpenCoreNum8 = Conf.OpenCoreNum8;
  printf("\n--- %s begin\n\n", (const char *)_FUNCTION___8187);
  if ( Conf.AsicNum == 1 )
  {
    v8 = 0;
    which_asica = 0;
    do
    {
      if ( (OpenCoreNum1 & 1) != 0 )
      {
        v9 = 0;
        for ( i = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v9; i += 68 )
        {
          v11 = i;
          printf("core[%02d][%02d].midstate=0x", v8, v9);
          do
          {
            v12 = *++v11;
            printf("%02x", v12);
          }
          while ( v11 != i + 32 );
          v13 = i - 12;
          printf(" data2=");
          do
          {
            v14 = *++v13;
            printf("%02x", v14);
          }
          while ( v13 != i );
          ++v9;
          printf(" nonce=0x%08x\n", *(_DWORD *)(i - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum1 >>= 1;
    }
    while ( v8 != 32 );
    do
    {
      if ( (OpenCoreNum2 & 1) != 0 )
      {
        v15 = 0;
        for ( j = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v15; j += 68 )
        {
          v17 = j;
          printf("core[%02d][%02d].midstate=0x", v8, v15);
          do
          {
            v18 = *++v17;
            printf("%02x", v18);
          }
          while ( v17 != j + 32 );
          v19 = j - 12;
          printf(" data2=");
          do
          {
            v20 = *++v19;
            printf("%02x", v20);
          }
          while ( v19 != j );
          ++v15;
          printf(" nonce=0x%08x\n", *(_DWORD *)(j - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum2 >>= 1;
    }
    while ( v8 != 64 );
    do
    {
      if ( (OpenCoreNum3 & 1) != 0 )
      {
        v21 = 0;
        for ( k = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v21; k += 68 )
        {
          v23 = k;
          printf("core[%02d][%02d].midstate=0x", v8, v21);
          do
          {
            v24 = *++v23;
            printf("%02x", v24);
          }
          while ( v23 != k + 32 );
          v25 = k - 12;
          printf(" data2=");
          do
          {
            v26 = *++v25;
            printf("%02x", v26);
          }
          while ( v25 != k );
          ++v21;
          printf(" nonce=0x%08x\n", *(_DWORD *)(k - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum3 >>= 1;
    }
    while ( v8 != 96 );
    do
    {
      if ( (OpenCoreNum4 & 1) != 0 )
      {
        v27 = 0;
        for ( m = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v27; m += 68 )
        {
          v29 = m;
          printf("core[%02d][%02d].midstate=0x", v8, v27);
          do
          {
            v30 = *++v29;
            printf("%02x", v30);
          }
          while ( v29 != m + 32 );
          v31 = m - 12;
          printf(" data2=");
          do
          {
            v32 = *++v31;
            printf("%02x", v32);
          }
          while ( v31 != m );
          ++v27;
          printf(" nonce=0x%08x\n", *(_DWORD *)(m - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum4 >>= 1;
    }
    while ( v8 != 128 );
    do
    {
      if ( (OpenCoreNum5 & 1) != 0 )
      {
        v33 = 0;
        for ( n = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v33; n += 68 )
        {
          v35 = n;
          printf("core[%02d][%02d].midstate=0x", v8, v33);
          do
          {
            v36 = *++v35;
            printf("%02x", v36);
          }
          while ( v35 != n + 32 );
          v37 = n - 12;
          printf(" data2=");
          do
          {
            v38 = *++v37;
            printf("%02x", v38);
          }
          while ( v37 != n );
          ++v33;
          printf(" nonce=0x%08x\n", *(_DWORD *)(n - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum5 >>= 1;
    }
    while ( v8 != 160 );
    do
    {
      if ( (OpenCoreNum6 & 1) != 0 )
      {
        v39 = 0;
        for ( ii = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v39; ii += 68 )
        {
          v41 = ii;
          printf("core[%02d][%02d].midstate=0x", v8, v39);
          do
          {
            v42 = *++v41;
            printf("%02x", v42);
          }
          while ( ii + 32 != v41 );
          v43 = ii - 12;
          printf(" data2=");
          do
          {
            v44 = *++v43;
            printf("%02x", v44);
          }
          while ( v43 != ii );
          ++v39;
          printf(" nonce=0x%08x\n", *(_DWORD *)(ii - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum6 >>= 1;
    }
    while ( v8 != 192 );
    do
    {
      if ( (OpenCoreNum7 & 1) != 0 )
      {
        v45 = 0;
        for ( jj = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v45; jj += 68 )
        {
          v47 = jj;
          printf("core[%02d][%02d].midstate=0x", v8, v45);
          do
          {
            v48 = *++v47;
            printf("%02x", v48);
          }
          while ( jj + 32 != v47 );
          v49 = jj - 12;
          printf(" data2=");
          do
          {
            v50 = *++v49;
            printf("%02x", v50);
          }
          while ( v49 != jj );
          ++v45;
          printf(" nonce=0x%08x\n", *(_DWORD *)(jj - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum7 >>= 1;
    }
    while ( v8 != 224 );
    do
    {
      if ( (OpenCoreNum8 & 1) != 0 )
      {
        v51 = 0;
        for ( kk = &cgpu.works[which_asica]->data[11]; Conf.pattern_number > v51; kk += 68 )
        {
          v53 = kk;
          printf("core[%02d][%02d].midstate=0x", v8, v51);
          do
          {
            v54 = *++v53;
            printf("%02x", v54);
          }
          while ( kk + 32 != v53 );
          v55 = kk - 12;
          printf(" data2=");
          do
          {
            v56 = *++v55;
            printf("%02x", v56);
          }
          while ( v55 != kk );
          ++v51;
          printf(" nonce=0x%08x\n", *(_DWORD *)(kk - 15));
        }
        ++which_asica;
        putchar(10);
      }
      ++v8;
      OpenCoreNum8 >>= 1;
    }
    while ( v8 != 256 );
  }
  else if ( Conf.AsicNum )
  {
    OpenCoreNum5a = &cgpu.workdataFilePrefix[60];
    which_asic = 0;
    do
    {
      v0 = 0;
      OpenCoreNum1a = *((_DWORD *)OpenCoreNum5a + 1);
      OpenCoreNum5a += 4;
      if ( Conf.CoreNum )
      {
        do
        {
          pattern_number = Conf.pattern_number;
          for ( mm = 0; Conf.pattern_number > mm; pattern_number = Conf.pattern_number )
          {
            v3 = OpenCoreNum1a + 68 * (mm + pattern_number * v0);
            v4 = v3 + 19;
            printf("asic[%02d][%02d][%02d].midstate=0x", which_asic, v0, mm);
            do
            {
              v5 = *(unsigned __int8 *)++v4;
              printf("%02x", v5);
            }
            while ( v4 != v3 + 51 );
            v6 = v3 + 7;
            printf(" data2=");
            do
            {
              v7 = *(unsigned __int8 *)++v6;
              printf("%02x", v7);
            }
            while ( v3 + 19 != v6 );
            ++mm;
            printf(" nonce=0x%08x\n", *(_DWORD *)(v3 + 4));
          }
          ++v0;
        }
        while ( Conf.CoreNum > v0 );
      }
      ++which_asic;
      putchar(10);
    }
    while ( Conf.AsicNum > which_asic );
  }
  j_printf("\n--- %s end\n\n", (const char *)_FUNCTION___8187);
}

//----- (000252F4) --------------------------------------------------------
int __fastcall get_work(int id, int count)
{
  int v4; // r5
  int v5; // r4
  void *v6; // r0
  unsigned __int8 *v7; // r6
  unsigned __int8 *v8; // r11
  char *v9; // r0
  const unsigned __int8 *v10; // r1
  int v11; // t1
  char *v12; // r0
  const unsigned __int8 *v13; // r1
  int v14; // t1
  char *v15; // r0
  const unsigned __int8 *v16; // r1
  int v17; // t1
  unsigned __int8 str[1024]; // [sp+0h] [bp-428h] BYREF

  memset(str, 0, sizeof(str));
  v4 = 0;
  v5 = 0;
  v6 = malloc(68 * count);
  v7 = &cgpu.workdataFilePrefix[4 * id + 60];
  *((_DWORD *)v7 + 1) = v6;
  if ( v6 )
  {
    while ( 1 )
    {
      if ( !fgets((char *)str, 1023, cgpu.fps[id]) )
        return v5;
      v8 = (unsigned __int8 *)(*((_DWORD *)v7 + 1) + v4);
      v9 = strstr((const char *)str, "nonce");
      if ( !v9 )
        break;
      v10 = (const unsigned __int8 *)(v9 + 5);
      if ( v9[5] == 32 )
      {
        do
          v11 = *++v10;
        while ( v11 == 32 );
      }
      s2hex(v8 + 4, v10, 8);
      *((_DWORD *)v8 + 1) = bswap32(*((_DWORD *)v8 + 1));
      v12 = strstr((const char *)str, "midstate");
      if ( !v12 )
        break;
      v13 = (const unsigned __int8 *)(v12 + 8);
      if ( v12[8] == 32 )
      {
        do
          v14 = *++v13;
        while ( v14 == 32 );
      }
      s2hex(v8 + 20, v13, 64);
      v15 = strstr((const char *)str, "data");
      if ( !v15 )
        break;
      v16 = (const unsigned __int8 *)(v15 + 4);
      if ( v15[4] == 32 )
      {
        do
          v17 = *++v16;
        while ( v17 == 32 );
      }
      s2hex(v8 + 8, v16, 24);
      *(_DWORD *)v8 = v5++;
      v4 += 68;
      *((_DWORD *)v8 + 13) = 0;
      *((_DWORD *)v8 + 14) = 0;
      *((_DWORD *)v8 + 15) = 0;
      *((_DWORD *)v8 + 16) = 0;
      if ( count <= v5 )
        return v5;
    }
    free(v8);
    puts("get work err");
    return v5;
  }
  else
  {
    puts("malloc struct work err");
    return 0;
  }
}

//----- (00025434) --------------------------------------------------------
int __fastcall get_work_hash_board(int which_asic, int which_core, FILE *stream, int count)
{
  int v5; // r5
  unsigned __int8 *v8; // r6
  int v9; // r5
  unsigned int v10; // r4
  unsigned __int8 *v11; // r10
  char *v12; // r0
  const unsigned __int8 *v13; // r1
  int v14; // t1
  char *v15; // r0
  const unsigned __int8 *v16; // r1
  int v17; // t1
  char *v18; // r0
  const unsigned __int8 *v19; // r1
  int v20; // t1
  unsigned __int8 str[1024]; // [sp+0h] [bp-420h] BYREF

  v5 = count * which_core;
  memset(str, 0, sizeof(str));
  v8 = &cgpu.workdataFilePrefix[4 * which_asic + 60];
  v9 = 68 * v5;
  v10 = 0;
  while ( 1 )
  {
    if ( !fgets((char *)str, 1023, stream) )
      return v10;
    v11 = (unsigned __int8 *)(*((_DWORD *)v8 + 1) + v9);
    v12 = strstr((const char *)str, "nonce");
    if ( !v12 )
      break;
    v13 = (const unsigned __int8 *)(v12 + 5);
    if ( v12[5] == 32 )
    {
      do
        v14 = *++v13;
      while ( v14 == 32 );
    }
    s2hex(v11 + 4, v13, 8);
    *((_DWORD *)v11 + 1) = bswap32(*((_DWORD *)v11 + 1));
    v15 = strstr((const char *)str, "midstate");
    if ( !v15 )
      break;
    v16 = (const unsigned __int8 *)(v15 + 8);
    if ( v15[8] == 32 )
    {
      do
        v17 = *++v16;
      while ( v17 == 32 );
    }
    s2hex(v11 + 20, v16, 64);
    v18 = strstr((const char *)str, "data");
    if ( !v18 )
      break;
    v19 = (const unsigned __int8 *)(v18 + 4);
    if ( v18[4] == 32 )
    {
      do
        v20 = *++v19;
      while ( v20 == 32 );
    }
    s2hex(v11 + 8, v19, 24);
    *(_DWORD *)v11 = v10++;
    v9 += 68;
    *((_DWORD *)v11 + 13) = 0;
    *((_DWORD *)v11 + 14) = 0;
    *((_DWORD *)v11 + 15) = 0;
    *((_DWORD *)v11 + 16) = 0;
    if ( v10 >= count )
      return v10;
  }
  free(v11);
  puts("get work err");
  return v10;
}

//----- (0002555C) --------------------------------------------------------
int __fastcall skip_rows(FILE *stream, int count)
{
  unsigned __int8 str[1024]; // [sp+0h] [bp-410h] BYREF

  memset(str, 0, sizeof(str));
  for ( ; count; --count )
    fgets((char *)str, 1023, stream);
  return 0;
}

//----- (0002558C) --------------------------------------------------------
int get_works_v1()
{
  unsigned int v0; // r11
  unsigned int v1; // r6
  void *v2; // r0
  cgpu_info *v3; // r5
  unsigned int v4; // r4
  work **v5; // r7
  FILE **v6; // r8
  FILE *v7; // r3
  int v8; // r1
  int v9; // r6
  int v10; // r11
  int v11; // r7
  int *subid; // r1
  int v13; // r3
  int v14; // r5
  unsigned int v15; // r0
  unsigned int v16; // r2
  signed int v17; // t1
  unsigned __int8 *v19; // [sp+Ch] [bp-13Ch]
  cgpu_info *v20; // [sp+10h] [bp-138h]
  unsigned int v21; // [sp+14h] [bp-134h]
  int asic_num; // [sp+1Ch] [bp-12Ch]
  unsigned __int8 strFilePath[256]; // [sp+20h] [bp-128h] BYREF

  memset(strFilePath, 0, sizeof(strFilePath));
  printf("\n--- %s\n", (const char *)_FUNCTION___8380);
  if ( Conf.AsicType == 1385 )
  {
    v0 = 50;
  }
  else if ( Conf.AsicType - 13911 <= 1 )
  {
    v0 = 256;
  }
  else
  {
    if ( Conf.AsicType != 5015 )
    {
      write_lcd(0, " AsicType Error ", 0x10u);
      printf("\n!!!%s: AsicType error\n", (const char *)_FUNCTION___8380);
      return -1;
    }
    v0 = 672;
  }
  if ( gHashBoard_V9 )
  {
    v21 = 45;
    asic_num = 45;
LABEL_8:
    v1 = 0;
    v19 = &cgpu.workdataFilePrefix[60];
    v20 = &cgpu;
    while ( 2 )
    {
      v2 = malloc(v0 * 68 * Conf.pattern_number);
      *((_DWORD *)v19 + 1) = v2;
      v19 += 4;
      if ( !v2 )
      {
        printf("%s: malloc struct work err!\n", (const char *)_FUNCTION___8380);
        return -1;
      }
      v3 = v20;
      v4 = 0;
      v5 = &v20->works[127];
      do
      {
        v6 = (FILE **)v3;
        sprintf((char *)strFilePath, "%s%02i%s%03i.txt", cgpu.workdataPathPrefix, v1, cgpu.workdataFilePrefix, v4);
        v7 = fopen((const char *)strFilePath, "r");
        v8 = v4;
        v3->fps[0] = v7;
        ++v4;
        v3 = (cgpu_info *)((char *)v3 + 4);
        if ( !v7 )
        {
          write_lcd(1u, "   Get pattern  ", 0x10u);
          write_lcd_no_memset(2u, "      Error     ", 0x10u);
          printf("%s: Open test file %s error\n", (const char *)_FUNCTION___8380, (const char *)strFilePath);
          return -1;
        }
        v5[1] = (work *)get_work_hash_board(v1, v8, v7, Conf.pattern_number);
        ++v5;
        fclose(*v6);
      }
      while ( v0 > v4 );
      ++v1;
      v20 = (cgpu_info *)((char *)v20 + 4 * v0);
      if ( v1 < v21 )
        continue;
      break;
    }
    goto LABEL_14;
  }
  if ( gHashBoard_BHB91601P || gHashBoard_BHB91601S )
  {
    asic_num = BHB91601_ASIC_NUMBER;
  }
  else
  {
    if ( !gHashBoard_BHB07601 )
    {
      write_lcd(1u, "   Board Name   ", 0x10u);
      write_lcd_no_memset(2u, "      Error     ", 0x10u);
      printf("\n!!!%s: Board Name is: %s, error\n", (const char *)_FUNCTION___8380, (const char *)&Conf);
      return -1;
    }
    asic_num = BHB07601_ASIC_NUMBER;
  }
  v21 = asic_num;
  if ( asic_num )
    goto LABEL_8;
LABEL_14:
  v9 = cgpu.subid[0];
  cgpu.min_work_subid = cgpu.subid[0];
  if ( Conf.AsicNum == 1 || (v10 = asic_num * v0, v10 <= 0) )
  {
    v15 = cgpu.subid[0];
    v14 = 0;
  }
  else
  {
    v11 = 0;
    subid = cgpu.subid;
    v13 = 0;
    v14 = 0;
    v15 = cgpu.subid[0];
    while ( v10 != ++v13 )
    {
      v17 = subid[1];
      ++subid;
      v16 = v17;
      if ( v17 < (int)v15 )
      {
        v9 = v16;
        v14 = v13;
        v15 = v16;
        v11 = 1;
      }
    }
    if ( v11 )
      cgpu.min_work_subid = v9;
  }
  if ( Conf.pattern_number <= v15 )
    return 0;
  write_lcd(1u, "Get Less Work", 0xDu);
  printf(
    "%s: cgpu.subid[%d] = %d, is the least pattern number\n",
    (const char *)_FUNCTION___8380,
    v14,
    cgpu.min_work_subid);
  return -1;
}

//----- (00025844) --------------------------------------------------------
int get_works_v2()
{
  _BOOL4 v0; // r10
  FILE *v1; // r0
  unsigned int pattern_number; // r3
  unsigned __int8 *v3; // r11
  int v4; // r8
  work **v5; // r9
  void *v6; // r0
  int v7; // r3
  work **v8; // r6
  int v9; // r4
  int v10; // r1
  int work_hash_board; // r0
  unsigned int v12; // r1
  int v14; // lr
  unsigned int v15; // r0
  int v16; // r6
  _BOOL4 v17; // r12
  int *subid; // r1
  int v19; // r3
  unsigned int v20; // r2
  signed int v21; // t1
  int v22; // [sp+4h] [bp-134h]
  int asic_num; // [sp+8h] [bp-130h]
  unsigned __int8 strFilePath[256]; // [sp+10h] [bp-128h] BYREF

  memset(strFilePath, 0, sizeof(strFilePath));
  printf("\n--- %s\n", (const char *)_FUNCTION___8412);
  if ( Conf.AsicType == 5015 )
  {
    v0 = gHashBoard_BHB07601;
    if ( gHashBoard_BHB07601 )
    {
      asic_num = Conf.AsicNum;
      sprintf(
        (char *)strFilePath,
        "%s%s.txt",
        (const char *)cgpu.workdataPathPrefix,
        (const char *)cgpu.workdataFilePrefix);
      v1 = fopen((const char *)strFilePath, "r");
      cgpu.fps[0] = v1;
      if ( v1 )
      {
        pattern_number = Conf.pattern_number;
        if ( Conf.pattern_number > 8 )
        {
          printf("%s: pattern_num %d too large\n", (const char *)_FUNCTION___8412, Conf.pattern_number);
          return -1;
        }
        else
        {
          if ( asic_num )
          {
            v3 = &cgpu.workdataFilePrefix[60];
            v4 = 0;
            v5 = &cgpu.works[127];
            while ( 1 )
            {
              v22 = pattern_number;
              v6 = malloc(45696 * pattern_number);
              v7 = v22;
              *((_DWORD *)v3 + 1) = v6;
              v3 += 4;
              if ( !v6 )
              {
                printf("%s: malloc struct work err!\n", (const char *)_FUNCTION___8412);
                return -1;
              }
              v8 = v5;
              v9 = 0;
              while ( 1 )
              {
                v10 = v9++;
                work_hash_board = get_work_hash_board(v4, v10, cgpu.fps[0], v7);
                v12 = Conf.pattern_number;
                v8[1] = (work *)work_hash_board;
                ++v8;
                skip_rows(cgpu.fps[0], 8 - v12);
                if ( v9 == 672 )
                  break;
                v7 = Conf.pattern_number;
              }
              ++v4;
              v5 += 672;
              if ( asic_num == v4 )
                break;
              pattern_number = Conf.pattern_number;
            }
            fclose(cgpu.fps[0]);
            v14 = cgpu.subid[0];
            cgpu.min_work_subid = cgpu.subid[0];
            if ( 672 * asic_num > 0 )
            {
              v17 = 0;
              subid = cgpu.subid;
              v19 = 0;
              v16 = 0;
              v15 = cgpu.subid[0];
              while ( 672 * asic_num != ++v19 )
              {
                v21 = subid[1];
                ++subid;
                v20 = v21;
                if ( v21 < (int)v15 )
                {
                  v14 = v20;
                  v17 = v0;
                  v15 = v20;
                  v16 = v19;
                }
              }
              if ( v17 )
                cgpu.min_work_subid = v14;
            }
            else
            {
              v15 = cgpu.subid[0];
              v16 = 0;
            }
          }
          else
          {
            fclose(v1);
            v15 = cgpu.subid[0];
            v16 = 0;
            cgpu.min_work_subid = cgpu.subid[0];
          }
          if ( Conf.pattern_number > v15 )
          {
            write_lcd(1u, "Get Less Work", 0xDu);
            printf(
              "%s: cgpu.subid[%d] = %d, is the least pattern number\n",
              (const char *)_FUNCTION___8412,
              v16,
              cgpu.min_work_subid);
            return -1;
          }
          else
          {
            return 0;
          }
        }
      }
      else
      {
        write_lcd(1u, "   Get pattern  ", 0x10u);
        write_lcd_no_memset(2u, "      Error     ", 0x10u);
        printf("%s: Open test file %s error\n", (const char *)_FUNCTION___8412, (const char *)strFilePath);
        return -1;
      }
    }
    else
    {
      write_lcd(1u, "   Board Name   ", 0x10u);
      write_lcd_no_memset(2u, "      Error     ", 0x10u);
      printf("\n!!!%s: Board Name is: %s, error\n", (const char *)_FUNCTION___8412, (const char *)&Conf);
      return -1;
    }
  }
  else
  {
    write_lcd(0, " AsicType Error ", 0x10u);
    printf("\n!!!%s: AsicType error\n", (const char *)_FUNCTION___8412);
    return -1;
  }
}

//----- (00025AA8) --------------------------------------------------------
void clear_nonce_return_flag()
{
  unsigned int OpenCoreNum1; // r4
  unsigned int OpenCoreNum2; // r7
  unsigned int OpenCoreNum3; // r8
  unsigned int OpenCoreNum4; // r9
  unsigned int AsicNum; // r3
  int v5; // r5
  int v6; // r4
  unsigned int pattern_number; // r6
  cgpu_info *v8; // r7
  unsigned int v9; // r5
  FILE *v10; // r3
  FILE *v11; // t1
  int i; // r0
  FILE *v13; // r1
  unsigned int v14; // r4
  int v15; // r2
  unsigned int v16; // r0
  work *v17; // r3
  work *v18; // r7
  int v19; // r3
  bool v20; // zf

  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  puts((const char *)_FUNCTION___8440);
  AsicNum = Conf.AsicNum;
  if ( Conf.AsicNum == 1 )
  {
    v19 = 32;
    v5 = 0;
    do
    {
      v20 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v20 )
        ++v5;
      v20 = (OpenCoreNum2 & 1) == 0;
      OpenCoreNum2 >>= 1;
      if ( !v20 )
        ++v5;
      v20 = (OpenCoreNum3 & 1) == 0;
      OpenCoreNum3 >>= 1;
      if ( !v20 )
        ++v5;
      v20 = (OpenCoreNum4 & 1) == 0;
      OpenCoreNum4 >>= 1;
      if ( !v20 )
        ++v5;
      --v19;
    }
    while ( v19 );
    printf("%s: single ASIC get_pattern_loop = %d\n", (const char *)_FUNCTION___8440, v5);
    AsicNum = Conf.AsicNum;
  }
  else
  {
    v5 = 0;
  }
  if ( Conf.AsicType == 1385 )
    v6 = 50;
  else
    v6 = 0;
  if ( gHashBoard_V9 )
  {
    if ( AsicNum != 1 )
    {
      pattern_number = Conf.pattern_number;
      v8 = (cgpu_info *)&cgpu.workdataFilePrefix[60];
      v9 = 68 * Conf.pattern_number;
      do
      {
        v11 = v8->fps[1];
        v8 = (cgpu_info *)((char *)v8 + 4);
        v10 = v11;
        if ( v6 )
        {
          for ( i = 0; i != v6; ++i )
          {
            v13 = (FILE *)((char *)v10 + v9);
            if ( pattern_number )
            {
              do
              {
                v10->_chain = 0;
                v10 = (FILE *)((char *)v10 + 68);
                *(_DWORD *)&v10[-1]._unused2[28] = 0;
                *(_DWORD *)&v10[-1]._unused2[32] = 0;
                *(_DWORD *)&v10[-1]._unused2[36] = 0;
              }
              while ( v13 != v10 );
            }
            v10 = v13;
          }
        }
      }
      while ( &cgpu.works[44] != (work **)v8 );
      return;
    }
  }
  else if ( AsicNum != 1 )
  {
    return;
  }
  if ( v5 )
  {
    v14 = Conf.pattern_number;
    v15 = 0;
    v16 = Conf.pattern_number;
    do
    {
      if ( v14 )
      {
        v17 = cgpu.works[v15];
        v18 = &v17[v16];
        do
        {
          v17->is_nonce_return_back[0][0] = 0;
          ++v17;
          v17[-1].is_nonce_return_back[1][0] = 0;
          v17[-1].is_nonce_return_back[2][0] = 0;
          v17[-1].is_nonce_return_back[3][0] = 0;
        }
        while ( v18 != v17 );
      }
      ++v15;
    }
    while ( v5 != v15 );
  }
}

//----- (00025BC4) --------------------------------------------------------
int bitmain_axi_init()
{
  int fd; // r0
  unsigned int *v1; // r1
  int v2; // r0
  unsigned int *v3; // r1

  fd = open("/dev/axi_fpga_dev", 2);
  cgpu.fpga_fd = fd;
  if ( fd < 0 )
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", fd);
    return -1;
  }
  else
  {
    v1 = (unsigned int *)mmap(0, 0x400u, 3, 1, fd, 0);
    axi_fpga_addr = v1;
    if ( v1 )
    {
      printf("mmap axi_fpga_addr = %p\n", v1);
      printf("axi_fpga_addr data = 0x%x\n", *(unsigned __int16 *)axi_fpga_addr);
      v2 = open("/dev/fpga_mem", 2);
      fd_fpga_mem = v2;
      if ( v2 < 0 )
      {
        printf("/dev/fpga_mem open failed. fd_fpga_mem = %d\n", v2);
        return -1;
      }
      else
      {
        v3 = (unsigned int *)mmap(0, 0x1000000u, 3, 1, v2, 0);
        fpga_mem_addr = v3;
        if ( v3 )
        {
          printf("mmap fpga_mem_addr = %p\n", v3);
          return 0;
        }
        else
        {
          printf("mmap fpga_mem_addr failed. fpga_mem_addr = %p\n", 0);
          return -1;
        }
      }
    }
    else
    {
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = %p\n", 0);
      return -1;
    }
  }
}

//----- (00025CB4) --------------------------------------------------------
void bitmain_axi_close()
{
  printf("\n\n--- %s\n", (const char *)_FUNCTION___7923);
  if ( munmap(axi_fpga_addr, 0x400u) < 0 )
    puts("munmap failed!");
  if ( munmap(fpga_mem_addr, 0x1000000u) < 0 )
    puts("munmap failed!");
  close(cgpu.fpga_fd);
  j_close(fd_fpga_mem);
}

//----- (00025D28) --------------------------------------------------------
unsigned int __fastcall read_axi_fpga(unsigned int address)
{
  return axi_fpga_addr[address];
}

//----- (00025D38) --------------------------------------------------------
void __fastcall write_axi_fpga(unsigned int address, unsigned int data)
{
  axi_fpga_addr[address] = data;
}

//----- (00025D48) --------------------------------------------------------
void init_fpga()
{
  printf("\n--- %s\n", (const char *)_FUNCTION___7936);
  axi_fpga_addr[32] = -2147450880;
  do
    usleep(0x2710u);
  while ( (axi_fpga_addr[32] & 0x80000000) != 0 );
  j_usleep((__useconds_t)&loc_186A0);
}

//----- (00025D90) --------------------------------------------------------
void __fastcall get_return_nonce(unsigned int *buf)
{
  unsigned int *v1; // r3

  v1 = axi_fpga_addr;
  *buf = axi_fpga_addr[4];
  buf[1] = v1[5];
}

//----- (00025DA4) --------------------------------------------------------
void __fastcall set_BC_command_buffer(unsigned int *value)
{
  unsigned int *v1; // r3

  v1 = axi_fpga_addr;
  axi_fpga_addr[49] = *value;
  v1[50] = value[1];
  v1[51] = value[2];
}

//----- (00025DC4) --------------------------------------------------------
unsigned int get_BC_write_command()
{
  return axi_fpga_addr[48];
}

//----- (00025DD4) --------------------------------------------------------
void __fastcall set_BC_write_command(unsigned int value)
{
  unsigned int *v2; // r3
  int v3; // r4

  if ( (value & 0x80000000) != 0 )
  {
    LOBYTE(v3) = 101;
    while ( 1 )
    {
      v2 = axi_fpga_addr;
      if ( (axi_fpga_addr[48] & 0x80000000) == 0 )
        break;
      usleep(0x3E8u);
      v3 = (unsigned __int8)(v3 - 1);
      if ( !v3 )
      {
        printf("\n%s: timeout\n\n", (const char *)_FUNCTION___7954);
        v2 = axi_fpga_addr;
        break;
      }
    }
  }
  else
  {
    v2 = axi_fpga_addr;
  }
  v2[48] = value;
}

//----- (00025E24) --------------------------------------------------------
void __fastcall set_TW_write_command(unsigned int *value)
{
  unsigned int *v1; // r1
  unsigned int *v2; // r2
  unsigned int v3; // t1

  v1 = value + 12;
  v2 = axi_fpga_addr;
  axi_fpga_addr[16] = *value;
  do
  {
    v3 = value[1];
    ++value;
    v2[17] = v3;
  }
  while ( value != v1 );
}

//----- (00025E48) --------------------------------------------------------
void __fastcall set_fpga_baud(unsigned __int8 asic_baud)
{
  axi_fpga_addr[15] = axi_fpga_addr[15] & 0xFFC0FFFF | ((asic_baud & 0x3F) << 16);
}

//----- (00025E60) --------------------------------------------------------
void *__fastcall single_BM1397_send_func(void *arg)
{
  int v1; // r7
  unsigned int OpenCoreNum1; // r5
  unsigned int OpenCoreNum2; // r6
  unsigned int OpenCoreNum5; // r9
  unsigned int OpenCoreNum6; // r10
  unsigned int OpenCoreNum7; // r11
  unsigned int v7; // r3
  unsigned int axi_fpga; // r0
  unsigned int v9; // r1
  int v10; // r4
  unsigned int v11; // r0
  unsigned int v12; // r2
  bool v13; // zf
  unsigned int v14; // r5
  unsigned int pattern_number; // r3
  unsigned int v16; // r5
  char *v17; // r6
  char *v18; // r3
  char *v19; // r2
  char *v20; // r1
  char v21; // t1
  vil_work_1397 *v22; // r3
  unsigned __int8 v23; // t1
  vil_work_1397 *p_work_vil_1397; // r3
  vil_work_1397 *v25; // r12
  unsigned int *v26; // r9
  int v27; // r1
  unsigned int *v28; // r12
  int v29; // r1
  work *v30; // r0
  work (*v31)[128]; // r9
  unsigned int v32; // r3
  unsigned int v33; // r2
  unsigned int v34; // r3
  unsigned int v35; // r5
  unsigned int v36; // r8
  unsigned int v37; // r6
  unsigned int OpenCoreNum3; // [sp+Ch] [bp-BCh]
  unsigned int OpenCoreNum4; // [sp+10h] [bp-B8h]
  pthread_mutex_t *OpenCoreNum4a; // [sp+10h] [bp-B8h]
  unsigned int OpenCoreNum8a; // [sp+14h] [bp-B4h]
  unsigned int OpenCoreNum8; // [sp+14h] [bp-B4h]
  unsigned int test_core_number; // [sp+2Ch] [bp-9Ch]
  unsigned int test_core_index; // [sp+30h] [bp-98h]
  unsigned __int8 *v46; // [sp+34h] [bp-94h]
  vil_work_1397 work_vil_1397; // [sp+38h] [bp-90h] BYREF
  unsigned int buf_vil[13]; // [sp+6Ch] [bp-5Ch] BYREF

  v1 = *(unsigned __int8 *)arg;
  memset(buf_vil, 0, sizeof(buf_vil));
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  v7 = Conf.OpenCoreNum8;
  if ( !gBegin_Get_Nonce )
  {
    OpenCoreNum8a = Conf.OpenCoreNum8;
    axi_fpga = read_axi_fpga(7u);
    write_axi_fpga(7u, axi_fpga | 0x10000);
    v7 = OpenCoreNum8a;
    gBegin_Get_Nonce = 1;
  }
  v9 = OpenCoreNum3;
  v10 = 32;
  v11 = OpenCoreNum4;
  v12 = 0;
  do
  {
    v13 = (OpenCoreNum1 & 1) == 0;
    OpenCoreNum1 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum2 & 1) == 0;
    OpenCoreNum2 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (v9 & 1) == 0;
    v9 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (v11 & 1) == 0;
    v11 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum5 & 1) == 0;
    OpenCoreNum5 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum6 & 1) == 0;
    OpenCoreNum6 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (OpenCoreNum7 & 1) == 0;
    OpenCoreNum7 >>= 1;
    if ( !v13 )
      ++v12;
    v13 = (v7 & 1) == 0;
    v7 >>= 1;
    if ( !v13 )
      ++v12;
    --v10;
  }
  while ( v10 );
  v14 = v12;
  test_core_number = v12;
  printf("%s: There are %d cores should be test\n", (const char *)_FUNCTION___8795, v12);
  if ( v14 )
  {
    OpenCoreNum4a = &HW_check_mutex[v1];
    pattern_number = Conf.pattern_number;
    v46 = &cgpu.workdataFilePrefix[60];
    test_core_index = 0;
    do
    {
      v16 = 0;
      OpenCoreNum8 = *((_DWORD *)v46 + 1);
      v46 += 4;
      if ( pattern_number )
      {
        do
        {
          if ( gReadingTemp )
            usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
          if ( ((1 << gChain) & read_axi_fpga(3u)) != 0 )
          {
            v17 = (char *)(OpenCoreNum8 + 68 * v16);
            memset(buf_vil, 0, sizeof(buf_vil));
            memset(&work_vil_1397, 0, sizeof(work_vil_1397));
            v18 = v17 + 7;
            v19 = v17 + 19;
            v20 = (char *)&work_vil_1397.work_count + 3;
            work_vil_1397.work_type = 1;
            work_vil_1397.chain_id = v1 | 0x80;
            work_vil_1397.work_count = v16;
            do
            {
              v21 = *++v18;
              *++v20 = v21;
            }
            while ( v19 != v18 );
            v22 = (vil_work_1397 *)&work_vil_1397.data[11];
            do
            {
              v23 = *++v19;
              v22->chain_id = v23;
              v22 = (vil_work_1397 *)((char *)v22 + 1);
            }
            while ( v22 != (vil_work_1397 *)&work_vil_1397.midstate[31] );
            p_work_vil_1397 = &work_vil_1397;
            v25 = &work_vil_1397;
            buf_vil[0] = ((v1 | 0x80) << 16) | 0x1000000;
            buf_vil[1] = v16;
            v26 = &buf_vil[1];
            do
            {
              v27 = v25->data[1];
              v25 = (vil_work_1397 *)((char *)v25 + 4);
              v26[1] = HIBYTE(v25->work_count) | (v27 << 16) | (LOBYTE(v25->work_count) << 24) | (BYTE2(v25->work_count) << 8);
              ++v26;
            }
            while ( v25 != (vil_work_1397 *)&work_vil_1397.data[4] );
            v28 = &buf_vil[4];
            do
            {
              v29 = p_work_vil_1397->midstate[1];
              p_work_vil_1397 = (vil_work_1397 *)((char *)p_work_vil_1397 + 4);
              v28[1] = p_work_vil_1397->data[11] | (v29 << 16) | (p_work_vil_1397->data[8] << 24) | (p_work_vil_1397->data[10] << 8);
              ++v28;
            }
            while ( p_work_vil_1397 != (vil_work_1397 *)&work_vil_1397.midstate[12] );
            set_TW_write_command(buf_vil);
            pthread_mutex_lock(OpenCoreNum4a);
            v30 = &gWorks_For_Hw_Check[v1][127];
            do
            {
              v31 = (work (*)[128])&v30[-1];
              memcpy(v30, &v30[-1], sizeof(work));
              v30 = (work *)v31;
            }
            while ( gWorks_For_Hw_Check[v1] != (work *)v31 );
            ++v16;
            v32 = (unsigned __int8)(gWork_Num_For_Hw_Check + 1);
            if ( v32 > 0x7E )
              LOBYTE(v32) = 127;
            gWork_Num_For_Hw_Check = v32;
            memcpy(gWorks_For_Hw_Check[v1], v17, 0x44u);
            pthread_mutex_unlock(OpenCoreNum4a);
            ++gSend_Work_Num[v1];
          }
          else
          {
            usleep(0x1388u);
          }
          pattern_number = Conf.pattern_number;
        }
        while ( v16 < Conf.pattern_number );
      }
      v13 = test_core_number == ++test_core_index;
    }
    while ( !v13 );
    v33 = pattern_number * test_core_number;
    v34 = gSend_Work_Num[v1];
    if ( v34 < v33 )
    {
      do
      {
        printf("\n\n---%s: Chain%d send work num : %d, less than %d\n", (const char *)_FUNCTION___8795, v1, v34, v33);
        v34 = gSend_Work_Num[v1];
        v33 = Conf.pattern_number * test_core_number;
      }
      while ( v34 < Conf.pattern_number * test_core_number );
    }
  }
  else
  {
    v34 = gSend_Work_Num[v1];
  }
  printf("\n\n---%s: Chain%d send work num : %d\n", (const char *)_FUNCTION___8795, v1, v34);
  puts("\nsend test pattern done");
  system("date");
  v35 = 1;
  putchar(10);
  v36 = gValid_Nonce_Num[v1];
  while ( v35 <= 2 )
  {
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
    while ( 1 )
    {
      v37 = gValid_Nonce_Num[v1];
      ++v35;
      if ( v36 == v37 )
        break;
      usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][67][255]);
      v36 = v37;
      v35 = 0;
    }
  }
  while ( gReadingTemp )
    usleep(0x2710u);
  start_receive = 0;
  puts("to stop receive");
  return 0;
}

//----- (0002622C) --------------------------------------------------------
uint32_t __fastcall BM1397_get_core_id(uint32_t nonce)
{
  return (nonce >> 31) | (2 * ((nonce >> 22) & 0x1FF));
}

//----- (00026238) --------------------------------------------------------
void __fastcall BM1397_set_config(
        unsigned __int8 which_chain,
        unsigned __int8 asic_addr,
        unsigned __int8 reg_addr,
        unsigned int reg_data,
        bool mode)
{
  int v5; // r5
  int v6; // r0
  unsigned int v7; // r0
  unsigned int v8; // [sp+0h] [bp-30h] BYREF
  unsigned int v9; // [sp+4h] [bp-2Ch]
  char v10; // [sp+8h] [bp-28h]
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-24h] BYREF

  v5 = which_chain;
  v10 = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    LOBYTE(v8) = 81;
  else
    LOBYTE(v8) = 65;
  BYTE2(v8) = asic_addr;
  HIBYTE(v8) = reg_addr;
  BYTE2(v9) = BYTE1(reg_data);
  HIBYTE(v9) = reg_data;
  BYTE1(v8) = 9;
  LOBYTE(v9) = HIBYTE(reg_data);
  BYTE1(v9) = BYTE2(reg_data);
  v6 = CRC5((unsigned __int8 *)&v8, 0x40u);
  v10 = v6;
  cmd_buf[2] = v6 << 24;
  cmd_buf[0] = bswap32(v8);
  cmd_buf[1] = bswap32(v9);
  set_BC_command_buffer(cmd_buf);
  v7 = get_BC_write_command();
  set_BC_write_command(v7 & 0xFFF0FFFF | (v5 << 16) | 0x80800000);
  usleep(0x2710u);
}

//----- (000262CC) --------------------------------------------------------
void __fastcall BM1397_get_status(
        unsigned __int8 which_chain,
        unsigned __int8 asic_addr,
        unsigned __int8 reg_addr,
        unsigned __int8 mode)
{
  int v4; // r5
  int v5; // r0
  unsigned int v6; // r0
  unsigned __int8 buf[5]; // [sp+4h] [bp-24h] BYREF
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-1Ch] BYREF

  v4 = which_chain;
  buf[4] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    buf[0] = 82;
  else
    buf[0] = 66;
  buf[3] = reg_addr;
  buf[1] = 5;
  buf[2] = asic_addr;
  v5 = CRC5(buf, 0x20u);
  buf[4] = v5;
  cmd_buf[1] = v5 << 24;
  cmd_buf[0] = bswap32(*(unsigned int *)buf);
  set_BC_command_buffer(cmd_buf);
  v6 = get_BC_write_command();
  set_BC_write_command(v6 & 0xFFF0FFFF | (v4 << 16) | 0x80800000);
}

//----- (00026338) --------------------------------------------------------
void __fastcall BM1397_set_clock_order(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode)
{
  printf("chain[%d]: set order clock, stragegy 3\n", which_chain);
  BM1397_set_config(which_chain, chip_addr, 0x80u, 0, mode);
  BM1397_set_config(which_chain, chip_addr, 0x84u, 0, mode);
  usleep(0x186A0u);
  BM1397_set_config(which_chain, chip_addr, 0x20u, 1u, mode);
}

//----- (0002638C) --------------------------------------------------------
void __fastcall set_BM1397_freq(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned int freq, bool mode)
{
  float v4; // s13
  int v5; // r4
  unsigned int v8; // r11
  float v9; // s19
  int v10; // r8
  float v11; // s11
  int v12; // r7
  float v13; // s23
  float v14; // s26
  float v15; // s14
  int v16; // r2
  float v17; // s15
  int v18; // r2
  int v19; // s15
  unsigned int v20; // r4
  unsigned __int8 v21; // r1
  int v22; // r5
  unsigned __int8 v23; // r2
  float v24; // s14
  int v25; // r2
  int v26; // r6
  int v27; // r1
  int v28; // r5
  int v29; // r1
  unsigned int v30; // r4
  unsigned int v31; // r5
  bool v32; // cc
  unsigned int v33; // [sp+8h] [bp-60h]
  unsigned int v34; // [sp+8h] [bp-60h]

  v5 = 0;
  v8 = 0;
  v9 = (float)freq;
  v10 = 0;
  v11 = 0.0;
  v12 = 0;
  v13 = 3200.0;
  v14 = 25.0;
  while ( 1 )
  {
LABEL_2:
    v15 = 12.5;
    if ( v13 >= 3125.0 )
    {
      v16 = 1;
      v4 = 1.0;
    }
    else
    {
      v16 = 2;
    }
    if ( v13 >= 3125.0 )
      v15 = 25.0;
    else
      v4 = 2.0;
    if ( v5 )
    {
      v13 = v11 - v15;
      v14 = 25.0;
    }
    v33 = (unsigned int)(float)(v13 / v9);
    v17 = (float)(v13 / v9) - (float)v33;
    if ( v17 < v14 )
    {
      v10 = v16;
      v8 = (unsigned __int8)v33;
      v14 = (float)(v13 / v9) - (float)v33;
      LODWORD(v4) = (unsigned int)(float)((float)(v13 * v4) / 25.0);
      v12 = LOBYTE(v4);
      if ( v17 < 0.000001 )
        goto LABEL_15;
      v11 = v13;
    }
    v13 = v13 - v15;
    if ( v13 < 2000.0 )
      break;
    v5 = 0;
  }
  v13 = v11;
LABEL_15:
  if ( v8 <= 0x10 )
  {
    v27 = 1;
    v20 = v8;
    v26 = 1;
    v28 = 16;
LABEL_27:
    v29 = v27 * v20;
    v30 = v20 - 1;
    v31 = v28 | v26 | (v12 << 16) | (v10 << 8) | 0xC0000000;
    printf(
      "\n--- %s: Want freq %f  real freq %f\n",
      "BM1397_get_pllparam_divider",
      v9,
      (float)((float)((float)(25.0 / (float)v10) * (float)v12) / (float)v29));
  }
  else
  {
    v18 = 15;
    v4 = (float)v8;
    while ( 1 )
    {
      v19 = v18;
      v20 = (unsigned __int8)v18--;
      v21 = v20 - 1;
      if ( (float)((float)(v4 / (float)v19) - (float)(unsigned int)(float)(v4 / (float)v19)) < 0.0001 )
        break;
      v20 = v21;
      if ( v18 == 1 )
      {
        if ( v21 != 2 )
          goto LABEL_20;
        goto LABEL_31;
      }
    }
    v8 = (unsigned __int8)(v8 / v20);
    if ( v20 != 2 )
      goto LABEL_20;
LABEL_31:
    if ( (v8 & 1) != 0 )
    {
      printf("\n--- %s: need recal 1\n", "BM1397_get_pllparam_divider");
      if ( v13 > 2000.0 )
      {
LABEL_33:
        v11 = v13;
        v5 = 1;
        goto LABEL_2;
      }
      v31 = -1065877231;
      v30 = 14;
      printf("\n--- %s: !!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll\n", "BM1397_get_pllparam_divider");
      goto LABEL_28;
    }
LABEL_20:
    if ( v8 <= 7 )
    {
      v27 = v8;
      v26 = 1;
      v28 = 16 * v8;
      goto LABEL_27;
    }
    v22 = 6;
    v4 = (float)v8;
    while ( 1 )
    {
      v23 = v22 - 1;
      v24 = v4 / (float)v22;
      v34 = (unsigned int)v24;
      if ( (float)(v24 - (float)(unsigned int)v24) < 0.0001 )
        break;
      v22 = v23;
      if ( v23 == 255 )
      {
        v25 = 255;
        v26 = 1;
        goto LABEL_25;
      }
    }
    v26 = (unsigned __int8)v34;
    v32 = (unsigned __int8)v34 > 7u;
    if ( (unsigned __int8)v34 <= 7u )
      v32 = (unsigned __int8)v34 > (unsigned int)v22;
    if ( v32 )
    {
      printf("\n--- %s: need recal 2\n", "BM1397_get_pllparam_divider");
      if ( v13 > 2000.0 )
        goto LABEL_33;
    }
    v25 = (unsigned __int8)v34 * v22;
LABEL_25:
    v27 = v8;
    if ( v8 == v25 )
    {
      v28 = 16 * v22;
      goto LABEL_27;
    }
    printf("\n--- %s: Don't find postdiv1 %d * postdiv2 %d = postdiv %d\n", "BM1397_get_pllparam_divider", v22, v26, v8);
    v31 = -1065877231;
    printf("\n--- %s: !!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll\n", "BM1397_get_pllparam_divider");
    v30 = 14;
  }
LABEL_28:
  BM1397_set_config(which_chain, chip_addr, 8u, v31, mode);
  usleep(0x2710u);
  BM1397_set_config(which_chain, chip_addr, 0x70u, v30, mode);
  usleep(0x2710u);
  BM1397_set_config(which_chain, chip_addr, 8u, v31, mode);
  j_usleep(0x2710u);
}
// 2641E: variable 'v4' is possibly undefined

//----- (00026694) --------------------------------------------------------
void __fastcall set_BM1397_freq_slowly(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned int freq,
        bool mode)
{
  unsigned int v7; // r4
  unsigned int v8; // r3

  v7 = 50;
  do
  {
    set_BM1397_freq(which_chain, chip_addr, v7, 1);
    v8 = v7 + 50;
    v7 += 25;
  }
  while ( freq > v8 );
  set_BM1397_freq(which_chain, chip_addr, freq, 1);
}

//----- (000266C8) --------------------------------------------------------
unsigned int __fastcall check_BM1397_asic_reg(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 reg,
        bool mode)
{
  int v4; // r7
  int v5; // r6
  int v8; // r4
  unsigned int reg_value_num; // r8
  int v10; // r4
  unsigned int v11; // r1
  unsigned int v12; // r3
  reg_buf *v13; // r2
  unsigned int p_rd; // r3
  char *v15; // r3
  int v16; // r2
  unsigned __int8 v17; // lr
  int v18; // r0
  reg_buf *v19; // r1
  int v20; // r2
  unsigned int v21; // r0
  char *v22; // lr
  int v23; // r3
  reg_buf *v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r1
  unsigned int v27; // r3
  unsigned int reg_value; // r2
  unsigned int v29; // r0
  unsigned int v30; // r3
  unsigned int v32; // [sp+0h] [bp-38h]
  int v33; // [sp+4h] [bp-34h]
  unsigned __int8 reg_buf[7]; // [sp+8h] [bp-30h] BYREF

  v4 = reg;
  v5 = which_chain;
  v33 = reg;
  memset(reg_buf, 0, sizeof(reg_buf));
  clear_register_value_buf();
  BM1397_get_status(v5, chip_addr, v4, mode);
  if ( !v4 )
    cgpu.chain_asic_num[v5] = 0;
  v8 = 0;
  v32 = 0;
  do
  {
    while ( 1 )
    {
      usleep(0x7530u);
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf->reg_value_num;
      pthread_mutex_unlock(&reg_mutex);
      if ( !reg_value_num )
        break;
      v10 = 0;
      do
      {
        while ( 1 )
        {
          pthread_mutex_lock(&reg_mutex);
          v13 = reg_value_buf;
          p_rd = reg_value_buf->p_rd;
          if ( reg_value_buf->reg_buffer[p_rd].chain_number != v5 )
            break;
          memset(reg_buf, 0, sizeof(reg_buf));
          v15 = (char *)reg_value_buf + 8 * reg_value_buf->p_rd;
          v16 = *((_DWORD *)v15 + 4);
          v17 = v15[20];
          LOBYTE(v15) = v15[21];
          reg_buf[3] = v16;
          reg_buf[4] = v17;
          reg_buf[5] = (unsigned __int8)v15;
          reg_buf[1] = BYTE2(v16);
          reg_buf[0] = HIBYTE(v16);
          reg_buf[2] = BYTE1(v16);
          v18 = CRC5(reg_buf, 0x33u);
          v19 = reg_value_buf;
          v20 = v18;
          v21 = reg_value_buf->p_rd;
          v22 = (char *)reg_value_buf + 8 * v21;
          v23 = (unsigned __int8)v22[22];
          if ( v20 == v23 )
          {
            if ( !v33 )
            {
              if ( reg_buf[0] == 19 && reg_buf[1] == 151 )
              {
                ++cgpu.chain_asic_num[v5];
                v21 = v19->p_rd;
              }
              else
              {
                printf("%s: error asic address : 0x%08x\n", (const char *)_FUNCTION___8312_0, *((_DWORD *)v22 + 4));
                v19 = reg_value_buf;
                v21 = reg_value_buf->p_rd;
              }
            }
            v27 = v19->reg_value_num;
            reg_value = v19->reg_buffer[v21].reg_value;
            v29 = v21 + 1;
            v19->p_rd = v29;
            v30 = v27 - 1;
            v19->reg_value_num = v30;
            if ( v29 == 512 )
              v30 = 0;
            v32 = reg_value;
            if ( v29 == 512 )
              v19->p_rd = v30;
          }
          else
          {
            printf("%s: crc is 0x%x, but it should be 0x%x\n", (const char *)_FUNCTION___8312_0, v20, v23);
            v24 = reg_value_buf;
            v25 = reg_value_buf->p_rd + 1;
            v26 = reg_value_buf->reg_value_num - 1;
            reg_value_buf->p_rd = v25;
            v24->reg_value_num = v26;
            if ( v25 == 512 )
              v24->p_rd = 0;
          }
          ++v10;
          pthread_mutex_unlock(&reg_mutex);
          if ( reg_value_num == v10 )
            goto LABEL_14;
        }
        v11 = reg_value_buf->reg_value_num;
        v12 = p_rd + 1;
        reg_value_buf->p_rd = v12;
        ++v10;
        v13->reg_value_num = v11 - 1;
        if ( v12 == 512 )
        {
          v12 = 0;
          v13->p_rd = 0;
        }
        printf(
          "%s: the return data is from chain%d, but it should be from chain%d\n",
          _FUNCTION___8312_0,
          v13->reg_buffer[v12].chain_number,
          v5,
          v32);
        pthread_mutex_unlock(&reg_mutex);
      }
      while ( reg_value_num != v10 );
LABEL_14:
      v8 = 0;
    }
    ++v8;
    usleep(0x7530u);
  }
  while ( v8 != 3 );
  if ( !v33 && cgpu.chain_asic_num[v5] > cgpu.max_asic_num_in_one_chain )
    cgpu.max_asic_num_in_one_chain = cgpu.chain_asic_num[v5];
  clear_register_value_buf();
  return v32;
}
// 26774: variable 'v32' is possibly undefined

//----- (000268C8) --------------------------------------------------------
void __fastcall BM1397_chain_inactive(unsigned __int8 which_chain)
{
  int v1; // r5
  int v2; // r0
  unsigned int v3; // r0
  unsigned __int8 buf[5]; // [sp+4h] [bp-24h] BYREF
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-1Ch] BYREF

  v1 = which_chain;
  buf[4] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  printf("\n--- %s\n", (const char *)_FUNCTION___8327);
  buf[0] = 83;
  buf[1] = 5;
  buf[2] = 0;
  buf[3] = 0;
  v2 = CRC5(buf, 0x20u);
  buf[4] = v2;
  cmd_buf[1] = v2 << 24;
  cmd_buf[0] = bswap32(*(unsigned int *)buf);
  set_BC_command_buffer(cmd_buf);
  v3 = get_BC_write_command();
  set_BC_write_command(v3 & 0xFFF0FFFF | (v1 << 16) | 0x80800000);
  usleep(0x1388u);
}

//----- (00026944) --------------------------------------------------------
void __fastcall BM1397_set_address(unsigned __int8 which_chain, unsigned __int8 address)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r0
  unsigned __int8 ptr[4]; // [sp+4h] [bp-24h] BYREF
  char v6; // [sp+8h] [bp-20h]
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-1Ch] BYREF

  v2 = which_chain;
  ptr[3] = 0;
  ptr[2] = address;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  v6 = 0;
  ptr[1] = 5;
  ptr[0] = 64;
  v3 = CRC5(ptr, 0x20u);
  v6 = v3;
  cmd_buf[1] = v3 << 24;
  cmd_buf[0] = bswap32(*(unsigned int *)ptr);
  set_BC_command_buffer(cmd_buf);
  v4 = get_BC_write_command();
  set_BC_write_command(v4 & 0xFFF0FFFF | (v2 << 16) | 0x80800000);
}

//----- (000269A4) --------------------------------------------------------
void __fastcall set_baud_ext(unsigned __int8 which_chain, unsigned __int8 chip_addr, bool mode)
{
  printf("\n--- %s: set baud ext\n", (const char *)_FUNCTION___8355);
  BM1397_set_config(which_chain, chip_addr, 0x68u, 0xC0700111, mode);
  BM1397_set_config(which_chain, chip_addr, 0x28u, 0x600000Fu, mode);
}

//----- (000269FC) --------------------------------------------------------
void __fastcall single_BM1397_set_baud(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned int asic_baud,
        bool mode)
{
  char v7; // r1
  unsigned int v8; // r3
  unsigned int v9; // r4
  char v10; // r3

  if ( asic_baud != 4 )
  {
    if ( asic_baud == 5 )
    {
      v10 = 1;
    }
    else
    {
      if ( asic_baud != 3 )
      {
        v7 = asic_baud & 0x1F;
        v8 = (asic_baud >> 5) & 0xF;
        goto LABEL_5;
      }
      v10 = 7;
    }
    v9 = gBM1397_MISC_CONTROL_reg & 0xF0FFE0FF | ((v10 & 0x1F) << 8);
    goto LABEL_9;
  }
  LOBYTE(v8) = 0;
  v7 = 3;
LABEL_5:
  v9 = gBM1397_MISC_CONTROL_reg & 0xF0FFE0FF | ((v7 & 0x1F) << 8) | ((v8 & 0xF) << 24);
  if ( asic_baud - 3 <= 2 )
  {
LABEL_9:
    v9 |= 0x10000u;
    set_baud_ext(which_chain, chip_addr, mode);
  }
  gBM1397_MISC_CONTROL_reg = v9;
  BM1397_set_config(which_chain, chip_addr, 0x18u, v9, mode);
}

//----- (00026A7C) --------------------------------------------------------
void __fastcall single_BM1397_set_IO_strength(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned int data,
        bool mode)
{
  printf("\n--- %s: IO strength is 0x%08x\n", (const char *)_FUNCTION___8370, data);
  BM1397_set_config(which_chain, chip_addr, 0x58u, data, mode);
}

//----- (00026AAC) --------------------------------------------------------
void reset_single_BM1397_global_arg()
{
  unsigned int OpenCoreNum1; // r11
  unsigned int OpenCoreNum2; // r10
  unsigned int OpenCoreNum3; // r9
  unsigned int OpenCoreNum4; // r8
  unsigned int OpenCoreNum5; // r5
  unsigned int OpenCoreNum6; // r7
  unsigned int OpenCoreNum7; // r6
  unsigned int OpenCoreNum8; // r4
  int v8; // r2
  int v9; // r12
  bool v10; // zf
  bool v11; // nf
  unsigned int pattern_number; // r7
  int v13; // r5
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *p_anon_0; // r11
  unsigned int *v15; // r10
  unsigned int *v16; // r9
  unsigned int *v17; // r8
  $0BD8A1A0B142CC6BF06E3D3E9C4F6678 *v18; // r4
  cgpu_info *v19; // r0
  FILE *v20; // t1
  char *v21; // r3
  char *v22; // r2
  int v23; // [sp+0h] [bp-30h]
  unsigned int v24; // [sp+4h] [bp-2Ch]

  gBM1397_MISC_CONTROL_reg = 14849;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  OpenCoreNum8 = Conf.OpenCoreNum8;
  reset_global_arg();
  printf("\n--- %s\n", (const char *)_FUNCTION___8390);
  v8 = 32;
  v9 = 0;
  do
  {
    v10 = (OpenCoreNum1 & 1) == 0;
    OpenCoreNum1 >>= 1;
    if ( !v10 )
      ++v9;
    v10 = (OpenCoreNum2 & 1) == 0;
    OpenCoreNum2 >>= 1;
    if ( !v10 )
      ++v9;
    v10 = (OpenCoreNum3 & 1) == 0;
    OpenCoreNum3 >>= 1;
    if ( !v10 )
      ++v9;
    v10 = (OpenCoreNum4 & 1) == 0;
    OpenCoreNum4 >>= 1;
    if ( !v10 )
      ++v9;
    v11 = (OpenCoreNum5 & 1) != 0;
    OpenCoreNum5 >>= 1;
    if ( v11 )
      ++v9;
    v11 = (OpenCoreNum6 & 1) != 0;
    OpenCoreNum6 >>= 1;
    if ( v11 )
      ++v9;
    v11 = (OpenCoreNum7 & 1) != 0;
    OpenCoreNum7 >>= 1;
    if ( v11 )
      ++v9;
    v11 = (OpenCoreNum8 & 1) != 0;
    OpenCoreNum8 >>= 1;
    if ( v11 )
      ++v9;
    --v8;
  }
  while ( v8 );
  pattern_number = Conf.pattern_number;
  v13 = 0;
  p_anon_0 = &reg_mutex.__data._anon_0;
  v15 = gRepeated_Nonce_Id;
  v16 = gValid_Nonce_Num;
  v23 = 3347151;
  v17 = gSend_Work_Num;
  v24 = 68 * Conf.pattern_number;
  do
  {
    *v15++ = 0;
    *v16++ = 0;
    *(_BYTE *)(v23 + 1) = 0;
    *v17++ = 0;
    ++v23;
    if ( v9 )
    {
      v18 = p_anon_0;
      v19 = (cgpu_info *)&cgpu.workdataFilePrefix[60];
      do
      {
        v20 = v19->fps[1];
        v19 = (cgpu_info *)((char *)v19 + 4);
        v21 = (char *)v20 + v13;
        v22 = (char *)v20 + v13 + v24;
        if ( pattern_number )
        {
          do
          {
            *((_DWORD *)v21 + 13) = 0;
            v21 += 68;
          }
          while ( v21 != v22 );
        }
        v18[1].__spins = 0;
        ++v18;
      }
      while ( v19 != (cgpu_info *)&cgpu.workdataFilePrefix[4 * v9 + 60] );
    }
    v13 += 4;
    p_anon_0 += 0x20000;
  }
  while ( v13 != 16 );
}

//----- (00026C10) --------------------------------------------------------
void single_BM1397_calculate_timeout_and_baud()
{
  _DWORD *v0; // r6
  unsigned int v1; // r4
  unsigned int v2; // r5
  unsigned int v3; // r0
  unsigned int v4; // r3

  LOWORD(v0) = (unsigned __int16)&Conf;
  printf("\n--- %s\n", (const char *)_FUNCTION___8408);
  v1 = calculate_core_number(0x2A0u);
  switch ( pattern_test_time )
  {
    case 0u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[18];
      break;
    case 1u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[19];
      break;
    case 2u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[20];
      break;
    case 3u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[21];
      break;
    case 4u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[22];
      break;
    case 5u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[23];
      break;
    case 6u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[24];
      break;
    case 7u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[25];
      break;
    case 8u:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = v0[26];
      break;
    default:
      HIWORD(v0) = (unsigned int)&Conf >> 16;
      v2 = 0;
      printf("%s: pattern_test_time = %d, error!!! \n", (const char *)_FUNCTION___8408, pattern_test_time);
      break;
  }
  v3 = gChain_Asic_Interval * (0x1000000 / v1) / v2;
  v0[17] = v2;
  v0[67] = 0;
  v4 = 95 * v3 / 0x64;
  v0[69] = v4;
  j_printf("\n---%s: Baudrate = %d, timeout = %d us\n", (const char *)_FUNCTION___8408, 0, v4);
}

//----- (00026D04) --------------------------------------------------------
void __fastcall BM1397_software_set_address(unsigned __int8 which_chain)
{
  unsigned int v2; // r4
  unsigned __int8 v3; // r5

  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8425, which_chain);
  BM1397_chain_inactive(which_chain);
  if ( BHB07601_ASIC_NUMBER )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      ++v2;
      BM1397_set_address(which_chain, v3);
      usleep(0x7D0u);
      v3 += gChain_Asic_Interval;
    }
    while ( BHB07601_ASIC_NUMBER > v2 );
  }
}

//----- (00026D60) --------------------------------------------------------
void __fastcall BM1397_set_baud(unsigned __int8 which_chain, unsigned int baud)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", (const char *)_FUNCTION___8433, which_chain, baud);
  single_BM1397_set_baud(which_chain, 0, baud, 1);
  usleep(0xC350u);
  set_fpga_baud(baud);
  j_usleep(0xC350u);
}

//----- (00026DA4) --------------------------------------------------------
void __fastcall BM1397_set_TM(unsigned __int8 which_chain, unsigned __int8 asic_addr, unsigned int tm, bool mode)
{
  int v4; // r5
  unsigned __int8 v5; // r7
  unsigned __int8 v6; // r6
  unsigned __int8 v7; // r4
  int v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // [sp+0h] [bp-30h] BYREF
  unsigned int v11; // [sp+4h] [bp-2Ch]
  char v12; // [sp+8h] [bp-28h]
  unsigned int cmd_buf[3]; // [sp+Ch] [bp-24h] BYREF

  v4 = which_chain;
  v12 = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  if ( mode )
    LOBYTE(v10) = 81;
  else
    LOBYTE(v10) = 65;
  BYTE2(v10) = asic_addr;
  v5 = bit_swap_table[BYTE2(tm)];
  v6 = bit_swap_table[BYTE1(tm)];
  v7 = bit_swap_table[(unsigned __int8)tm];
  LOBYTE(v11) = bit_swap_table[HIBYTE(tm)];
  BYTE1(v10) = 9;
  HIBYTE(v11) = v7;
  HIBYTE(v10) = 20;
  BYTE1(v11) = v5;
  BYTE2(v11) = v6;
  v8 = CRC5((unsigned __int8 *)&v10, 0x40u);
  v12 = v8;
  cmd_buf[2] = v8 << 24;
  cmd_buf[0] = bswap32(v10);
  cmd_buf[1] = bswap32(v11);
  set_BC_command_buffer(cmd_buf);
  v9 = get_BC_write_command();
  set_BC_write_command(v9 & 0xFFF0FFFF | (v4 << 16) | 0x80800000);
  usleep(0x2710u);
}

//----- (00026E50) --------------------------------------------------------
void __fastcall BM1397_enable_read_temperature_from_asic(unsigned __int8 which_chain, unsigned __int8 asic_addr)
{
  BM1397_set_config(which_chain, asic_addr, 0x18u, gBM1397_MISC_CONTROL_reg | 0x4030, 0);
}

//----- (00026E78) --------------------------------------------------------
void __fastcall BM1397_set_core_clock_delay_all(
        unsigned __int8 which_chain,
        unsigned __int8 which_asic,
        unsigned __int8 reg_data,
        unsigned __int8 mode)
{
  unsigned __int8 v4; // r4

  v4 = mode;
  if ( mode )
    v4 = 1;
  BM1397_set_config(which_chain, which_asic, 0, reg_data | 0x80008000, v4);
  j_usleep(0x1388u);
}

//----- (00026E9C) --------------------------------------------------------
void __fastcall BM1397_enable_core_clock(
        unsigned __int8 which_chain,
        unsigned __int8 which_asic,
        unsigned int core_id,
        unsigned __int8 mode)
{
  unsigned __int8 v4; // r4

  v4 = mode;
  if ( mode )
    v4 = 1;
  BM1397_set_config(which_chain, which_asic, 0x3Cu, (core_id << 16) | 0x84AA, v4);
  j_usleep(0x1388u);
}

//----- (00026EC4) --------------------------------------------------------
void __fastcall single_BM1397_open_core(unsigned __int8 which_chain)
{
  int v1; // r8
  unsigned int v2; // r6
  unsigned int axi_fpga; // r0
  unsigned int v4; // r4
  unsigned int v5; // r2
  __useconds_t v6; // r0
  bool v7; // zf
  unsigned int v8; // r0
  unsigned int buf_vil_tw[13]; // [sp+4h] [bp-5Ch] BYREF

  v1 = which_chain;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  printf("\n--- %s: Chain : %d\n", (const char *)_FUNCTION___8472, v1);
  gIsOpenCoreEnd = 0;
  v2 = 0;
  axi_fpga = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, axi_fpga & 0xFFFFFFDF);
  write_axi_fpga(0x24u, 0);
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  do
  {
    v4 = v2;
    do
    {
      usleep(0x3E8u);
      v5 = v4;
      v4 += 84;
      BM1397_enable_core_clock(v1, 0, v5, 1u);
    }
    while ( v4 != v2 + 336 );
    v6 = 5000;
    do
    {
      usleep(v6);
      v7 = ((1 << v1) & read_axi_fpga(3u)) == 0;
      v6 = 3000;
    }
    while ( v7 );
    buf_vil_tw[0] = (v1 << 16) | 0x1000080;
    ++v2;
    set_TW_write_command(buf_vil_tw);
    usleep(Conf.OpenCoreGap);
  }
  while ( v2 != 84 );
  v8 = read_axi_fpga(0x30u);
  write_axi_fpga(0x30u, v8 | 0x400000);
  gIsOpenCoreEnd = 1;
  printf("\n--- %s end: Chain : %d\n", (const char *)_FUNCTION___8472, v1);
}

//----- (00026FB0) --------------------------------------------------------
unsigned int __fastcall single_BM1397_get_result(unsigned __int8 which_chain)
{
  configuration *v1; // r8
  unsigned int OpenCoreNum1; // r9
  unsigned int (*v3)[1024]; // r5
  int v4; // r7
  unsigned int *v5; // r4
  int v6; // r1
  unsigned int v7; // t1
  int v8; // r10
  const char *v9; // r6
  unsigned int v10; // r4
  unsigned int v11; // r11
  const char *v12; // r0
  const char *v13; // r0
  work *v15; // r11
  const char *v16; // r3
  char *v17; // r2
  configuration *v18; // r6
  unsigned int v19; // r11
  char *v20; // r5
  const char *v21; // r8
  int v22; // r1
  const char *v23; // r3
  work *v24; // r3
  char *v25; // r11
  unsigned int v26; // r4
  int v27; // r1
  work *v28; // r3
  char *v29; // r11
  unsigned int v30; // r4
  int v31; // r1
  work *v32; // r3
  char *v33; // r11
  unsigned int v34; // r4
  int v35; // r1
  work *v36; // r3
  char *v37; // r11
  unsigned int v38; // r4
  int v39; // r1
  work *v40; // r3
  char *v41; // r11
  unsigned int v42; // r4
  int v43; // r1
  work *v44; // r3
  char *v45; // r11
  unsigned int v46; // r4
  int v47; // r1
  work *v48; // r3
  char *v49; // r11
  unsigned int v50; // r4
  int v51; // r1
  int v52; // [sp+0h] [bp-58h]
  int v53; // [sp+4h] [bp-54h]
  unsigned int OpenCoreNum2; // [sp+Ch] [bp-4Ch]
  unsigned int OpenCoreNum3; // [sp+10h] [bp-48h]
  unsigned int OpenCoreNum4; // [sp+14h] [bp-44h]
  unsigned int OpenCoreNum5; // [sp+18h] [bp-40h]
  unsigned int OpenCoreNum6; // [sp+1Ch] [bp-3Ch]
  unsigned int OpenCoreNum7; // [sp+20h] [bp-38h]
  unsigned int OpenCoreNum8; // [sp+24h] [bp-34h]
  work *works; // [sp+28h] [bp-30h]
  work *worksh; // [sp+28h] [bp-30h]
  work *worksa; // [sp+28h] [bp-30h]
  work *worksi; // [sp+28h] [bp-30h]
  work *worksb; // [sp+28h] [bp-30h]
  work *worksj; // [sp+28h] [bp-30h]
  work *worksc; // [sp+28h] [bp-30h]
  work *worksk; // [sp+28h] [bp-30h]
  work *worksd; // [sp+28h] [bp-30h]
  work *worksl; // [sp+28h] [bp-30h]
  work *workse; // [sp+28h] [bp-30h]
  work *worksm; // [sp+28h] [bp-30h]
  work *worksf; // [sp+28h] [bp-30h]
  work *worksn; // [sp+28h] [bp-30h]
  work *worksg; // [sp+28h] [bp-30h]

  v1 = &Conf;
  v52 = which_chain;
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  v3 = gAsic_Core_Nonce_Num[which_chain];
  v4 = 0;
  v5 = &(*v3)[-1];
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum4 = Conf.OpenCoreNum4;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  OpenCoreNum8 = Conf.OpenCoreNum8;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every CORE require nonce number: %u\n\n", Conf.pattern_number);
  printf("Open core number : Conf.OpenCoreNum1 = %u = 0x%08x\n", Conf.OpenCoreNum1, Conf.OpenCoreNum1);
  printf("Open core number : Conf.OpenCoreNum2 = %u = 0x%08x\n", Conf.OpenCoreNum2, Conf.OpenCoreNum2);
  printf("Open core number : Conf.OpenCoreNum3 = %u = 0x%08x\n", Conf.OpenCoreNum3, Conf.OpenCoreNum3);
  printf("Open core number : Conf.OpenCoreNum4 = %u = 0x%08x\n", Conf.OpenCoreNum4, Conf.OpenCoreNum4);
  printf("Open core number : Conf.OpenCoreNum5 = %u = 0x%08x\n", Conf.OpenCoreNum5, Conf.OpenCoreNum5);
  printf("Open core number : Conf.OpenCoreNum6 = %u = 0x%08x\n", Conf.OpenCoreNum6, Conf.OpenCoreNum6);
  printf("Open core number : Conf.OpenCoreNum7 = %u = 0x%08x\n", Conf.OpenCoreNum7, Conf.OpenCoreNum7);
  printf("Open core number : Conf.OpenCoreNum8 = %u = 0x%08x\n\n", Conf.OpenCoreNum8, Conf.OpenCoreNum8);
  do
  {
    if ( !(v4 << 29) )
      putchar(10);
    v6 = v4;
    v7 = v5[1];
    ++v5;
    ++v4;
    printf("core[%03d]=%02d\t", v6, v7);
  }
  while ( v4 != 672 );
  v8 = 0;
  v9 = "%s: which_core = %d, error!!!\n";
  v10 = 0;
  v53 = 4 * v52;
  v11 = 3;
  puts("\n\n");
  do
  {
    while ( 1 )
    {
      if ( v10 > 0x1F )
      {
        if ( v10 - 32 <= 0x1F )
        {
          if ( (OpenCoreNum2 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksj = cgpu.works[v8];
              printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
              v32 = worksj;
              if ( v1->pattern_number )
              {
                worksc = (work *)v10;
                v33 = (char *)v32 + v53;
                v34 = 0;
                do
                {
                  v35 = *((_DWORD *)v33 + 13);
                  v33 += 68;
                  if ( !v35 )
                    printf("%d  ", v34);
                  ++v34;
                }
                while ( v1->pattern_number > v34 );
                v10 = (unsigned int)worksc;
              }
              v11 = 2;
              putchar(10);
            }
            ++v8;
            OpenCoreNum2 >>= 1;
          }
          else
          {
            OpenCoreNum2 >>= 1;
          }
        }
        else if ( v10 - 64 <= 0x1F )
        {
          if ( (OpenCoreNum3 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksn = cgpu.works[v8];
              printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
              v48 = worksn;
              if ( v1->pattern_number )
              {
                worksg = (work *)v10;
                v49 = (char *)v48 + v53;
                v50 = 0;
                do
                {
                  v51 = *((_DWORD *)v49 + 13);
                  v49 += 68;
                  if ( !v51 )
                    printf("%d  ", v50);
                  ++v50;
                }
                while ( v1->pattern_number > v50 );
                v10 = (unsigned int)worksg;
              }
              v11 = 2;
              putchar(10);
            }
            ++v8;
            OpenCoreNum3 >>= 1;
          }
          else
          {
            OpenCoreNum3 >>= 1;
          }
        }
        else if ( v10 - 96 <= 0x1F )
        {
          if ( (OpenCoreNum4 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksk = cgpu.works[v8];
              printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
              v36 = worksk;
              if ( v1->pattern_number )
              {
                worksd = (work *)v10;
                v37 = (char *)v36 + v53;
                v38 = 0;
                do
                {
                  v39 = *((_DWORD *)v37 + 13);
                  v37 += 68;
                  if ( !v39 )
                    printf("%d  ", v38);
                  ++v38;
                }
                while ( v1->pattern_number > v38 );
                v10 = (unsigned int)worksd;
              }
              v11 = 2;
              putchar(10);
            }
            ++v8;
            OpenCoreNum4 >>= 1;
          }
          else
          {
            OpenCoreNum4 >>= 1;
          }
        }
        else if ( v10 - 128 <= 0x1F )
        {
          if ( (OpenCoreNum5 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksm = cgpu.works[v8];
              printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
              v44 = worksm;
              if ( v1->pattern_number )
              {
                worksf = (work *)v10;
                v45 = (char *)v44 + v53;
                v46 = 0;
                do
                {
                  v47 = *((_DWORD *)v45 + 13);
                  v45 += 68;
                  if ( !v47 )
                    printf("%d  ", v46);
                  ++v46;
                }
                while ( v1->pattern_number > v46 );
                v10 = (unsigned int)worksf;
              }
              v11 = 2;
              putchar(10);
            }
            ++v8;
            OpenCoreNum5 >>= 1;
          }
          else
          {
            OpenCoreNum5 >>= 1;
          }
        }
        else if ( v10 - 160 <= 0x1F )
        {
          if ( (OpenCoreNum6 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksi = cgpu.works[v8];
              printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
              v28 = worksi;
              if ( v1->pattern_number )
              {
                worksb = (work *)v10;
                v29 = (char *)v28 + v53;
                v30 = 0;
                do
                {
                  v31 = *((_DWORD *)v29 + 13);
                  v29 += 68;
                  if ( !v31 )
                    printf("%d  ", v30);
                  ++v30;
                }
                while ( v1->pattern_number > v30 );
                v10 = (unsigned int)worksb;
              }
              v11 = 2;
              putchar(10);
            }
            ++v8;
            OpenCoreNum6 >>= 1;
          }
          else
          {
            OpenCoreNum6 >>= 1;
          }
        }
        else if ( v10 - 192 <= 0x1F )
        {
          if ( (OpenCoreNum7 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksl = cgpu.works[v8];
              printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
              v40 = worksl;
              if ( v1->pattern_number )
              {
                workse = (work *)v10;
                v41 = (char *)v40 + v53;
                v42 = 0;
                do
                {
                  v43 = *((_DWORD *)v41 + 13);
                  v41 += 68;
                  if ( !v43 )
                    printf("%d  ", v42);
                  ++v42;
                }
                while ( v1->pattern_number > v42 );
                v10 = (unsigned int)workse;
              }
              v11 = 2;
              putchar(10);
            }
            ++v8;
            OpenCoreNum7 >>= 1;
          }
          else
          {
            OpenCoreNum7 >>= 1;
          }
        }
        else if ( v10 - 224 <= 0x1F )
        {
          if ( (OpenCoreNum8 & 1) != 0 )
          {
            if ( (*v3)[0] < v1->pattern_number )
            {
              worksh = cgpu.works[v8];
              printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
              v24 = worksh;
              if ( v1->pattern_number )
              {
                worksa = (work *)v10;
                v25 = (char *)v24 + v53;
                v26 = 0;
                do
                {
                  v27 = *((_DWORD *)v25 + 13);
                  v25 += 68;
                  if ( !v27 )
                    printf("%d  ", v26);
                  ++v26;
                }
                while ( v1->pattern_number > v26 );
                v10 = (unsigned int)worksa;
              }
              v11 = 2;
              putchar(10);
            }
            ++v8;
            OpenCoreNum8 >>= 1;
          }
          else
          {
            OpenCoreNum8 >>= 1;
          }
        }
        else
        {
          printf(v9, _FUNCTION___8526, v10);
        }
        goto LABEL_14;
      }
      if ( (OpenCoreNum1 & 1) != 0 )
        break;
      OpenCoreNum1 >>= 1;
LABEL_14:
      ++v10;
      v3 = (unsigned int (*)[1024])((char *)v3 + 4);
      if ( v10 == 672 )
        goto LABEL_20;
    }
    if ( (*v3)[0] < v1->pattern_number )
    {
      v15 = cgpu.works[v8];
      printf("core[%03d] = %d,      lost these nonce : ", v10, (*v3)[0]);
      if ( v1->pattern_number )
      {
        v16 = v9;
        v17 = (char *)v15 + v53;
        works = (work *)v3;
        v18 = v1;
        v19 = 0;
        v20 = v17;
        v21 = v16;
        do
        {
          while ( 1 )
          {
            v22 = *((_DWORD *)v20 + 13);
            v20 += 68;
            if ( !v22 )
              break;
            if ( v18->pattern_number <= ++v19 )
              goto LABEL_47;
          }
          printf("%d  ", v19++);
        }
        while ( v18->pattern_number > v19 );
LABEL_47:
        v3 = (unsigned int (*)[1024])works;
        v23 = v21;
        v1 = v18;
        v9 = v23;
      }
      v11 = 2;
      putchar(10);
    }
    ++v10;
    OpenCoreNum1 >>= 1;
    ++v8;
    v3 = (unsigned int (*)[1024])((char *)v3 + 4);
  }
  while ( v10 != 672 );
LABEL_20:
  if ( v1->TempSensor1 )
  {
    if ( Sensor1_temp && Sensor1_OK && !gNotReadOutTemp )
    {
      printf("temperature1 = %d\n", Sensor1_temp);
    }
    else
    {
      v11 &= ~2u;
      puts("temperature1 check error");
    }
  }
  if ( v1->TempSensor2 )
  {
    if ( Sensor2_temp && Sensor2_OK && !gNotReadOutTemp )
    {
      printf("temperature2 = %d\n", Sensor2_temp);
    }
    else
    {
      v11 &= ~2u;
      puts("temperature2 check error");
    }
  }
  if ( v1->TempSensor3 )
  {
    if ( Sensor3_temp && Sensor3_OK && !gNotReadOutTemp )
    {
      printf("temperature3 = %d\n", Sensor3_temp);
    }
    else
    {
      v11 &= ~2u;
      puts("temperature3 check error");
    }
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  printf("Chain%d total valid nonce number: %d\n\n", v52, gValid_Nonce_Num[v52]);
  if ( (v11 & 1) != 0 )
    LOWORD(v12) = -25288;
  else
    LOWORD(v12) = -25276;
  HIWORD(v12) = 2;
  puts(v12);
  if ( (v11 & 2) != 0 )
    LOWORD(v13) = -21748;
  else
    LOWORD(v13) = -21736;
  HIWORD(v13) = 2;
  puts(v13);
  printf("HW number = %d\n\n", gHw_Nonce_Num[v52]);
  return v11;
}

//----- (0002779C) --------------------------------------------------------
void __fastcall single_BM1397_print_lcd(unsigned __int8 which_chain, unsigned int result)
{
  char v2; // r5
  unsigned __int8 *v3; // r1
  unsigned __int8 *v4; // r1
  unsigned __int8 lcd_display_buf[16]; // [sp+0h] [bp-20h] BYREF

  v2 = result;
  qmemcpy(lcd_display_buf, "      HW        ", sizeof(lcd_display_buf));
  display_level_result_on_lcd();
  sprintf((char *)&lcd_display_buf[10], "%d", gHw_Nonce_Num[gChain]);
  write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
  if ( (v2 & 1) != 0 )
    LOWORD(v3) = -25244;
  else
    LOWORD(v3) = -25224;
  HIWORD(v3) = 2;
  write_lcd_no_memset(2u, v3, 0x10u);
  if ( (v2 & 2) != 0 )
    LOWORD(v4) = -21724;
  else
    LOWORD(v4) = -21704;
  HIWORD(v4) = 2;
  write_lcd_no_memset(3u, v4, 0x10u);
}

//----- (00027830) --------------------------------------------------------
void __fastcall BM1397_soft_reset_sensor(unsigned __int8 which_chain)
{
  int v2; // r7
  unsigned int TempSensor2; // r5
  char v4; // r5
  unsigned int v5; // r4
  unsigned int v6; // r0
  unsigned int v7; // r4

  v2 = 0;
  printf("\n--- %s\n", (const char *)_FUNCTION___8544);
  do
  {
    if ( v2 )
    {
      if ( v2 == 1 )
      {
        TempSensor2 = Conf.TempSensor2;
      }
      else if ( v2 == 2 )
      {
        TempSensor2 = Conf.TempSensor3;
      }
      else
      {
        TempSensor2 = Conf.TempSensor4;
      }
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
    {
      v4 = TempSensor2 - 1;
      v5 = 0;
      BM1397_set_config(which_chain, gChain_Asic_Interval * v4, 0x18u, gBM1397_MISC_CONTROL_reg | 0x4030, 0);
      check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x18u, 0);
      while ( 1 )
      {
        ++v5;
        v6 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0);
        if ( (v6 & 0xC0000000) == 0 )
          break;
        if ( v5 >= 2 )
        {
          gNotReadOutTemp = 1;
          printf("%s: Can't read out GENERAL_I2C_COMMAND. ret = 0x%08x\n", (const char *)_FUNCTION___8544, v6);
          goto LABEL_9;
        }
      }
      v7 = 0;
      BM1397_set_config(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0x10006u, 0);
      do
        ++v7;
      while ( (check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0) & 0xC0000000) != 0 && v7 < 2 );
    }
LABEL_9:
    ++v2;
  }
  while ( v2 != 4 );
  j_usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][24][359]);
}

//----- (00027968) --------------------------------------------------------
void __fastcall BM1397_enable_extended_mode_of_temperature_sensor(unsigned __int8 which_chain)
{
  int v2; // r9
  unsigned int TempSensor2; // r4
  char v4; // r4
  unsigned int v5; // r5
  unsigned int v6; // r0
  unsigned int v7; // r5
  unsigned int v8; // r5
  unsigned int v9; // r0

  v2 = 0;
  printf("\n--- %s\n", (const char *)_FUNCTION___8560);
  do
  {
    if ( v2 )
    {
      if ( v2 == 1 )
      {
        TempSensor2 = Conf.TempSensor2;
      }
      else if ( v2 == 2 )
      {
        TempSensor2 = Conf.TempSensor3;
      }
      else
      {
        TempSensor2 = Conf.TempSensor4;
      }
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
    {
      v4 = TempSensor2 - 1;
      v5 = 0;
      BM1397_set_config(which_chain, gChain_Asic_Interval * v4, 0x18u, gBM1397_MISC_CONTROL_reg | 0x4030, 0);
      check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x18u, 0);
      while ( 1 )
      {
        ++v5;
        v6 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0);
        if ( (v6 & 0xC0000000) == 0 )
          break;
        if ( v5 >= 2 )
        {
          gNotReadOutTemp = 1;
          printf("\n!!! %s: Can't read out GENERAL_I2C_COMMAND. ret = 0x%08x\n", (const char *)_FUNCTION___8560, v6);
          goto LABEL_9;
        }
      }
      v7 = 0;
      BM1397_set_config(which_chain, gChain_Asic_Interval * v4, 0x1Cu, gSensor_i2c_addr_high_4_bit | 0x1010904, 0);
      do
        ++v7;
      while ( (check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0) & 0xC0000000) != 0 && v7 < 2 );
      usleep(0x2710u);
      v8 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * v4,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFCFF | 0x1000300,
        0);
      do
      {
        ++v8;
        v9 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v4, 0x1Cu, 0);
      }
      while ( (v9 & 0xC0000000) != 0 && v8 < 2 );
      if ( (v9 & 0xC0000004) != 4 )
      {
        gNotReadOutTemp = 1;
        printf("\n!!! %s: Can't set extended mode. ret = 0x%08x\n", (const char *)_FUNCTION___8560, v9);
      }
    }
LABEL_9:
    ++v2;
  }
  while ( v2 != 4 );
}

//----- (00027B44) --------------------------------------------------------
void __fastcall BM1397_get_temperature_offset_value_from_asic(unsigned __int8 which_chain)
{
  int v2; // r9
  unsigned int TempSensor2; // r11
  int v4; // r4
  char *v5; // r5
  int v6; // r1
  int v7; // t1
  char v8; // r4
  unsigned int v9; // r8
  unsigned int v10; // r10
  unsigned int v11; // r0
  unsigned int v12; // r8
  unsigned int v13; // r0
  char v14; // r3
  char v15; // r2
  int v16; // r1
  char local_temp; // [sp+Ch] [bp-3Ch]
  char remote_temp; // [sp+10h] [bp-38h]
  unsigned int *v19; // [sp+14h] [bp-34h] BYREF
  unsigned __int8 offset_value[8]; // [sp+18h] [bp-30h] BYREF

  v19 = &gBM1397_MISC_CONTROL_reg;
  remote_temp = 0;
  v2 = 0;
  local_temp = 0;
  memset(offset_value, 0, sizeof(offset_value));
  printf("\n--- %s\n", (const char *)_FUNCTION___8582);
  do
  {
    if ( v2 )
    {
      if ( v2 == 1 )
        TempSensor2 = Conf.TempSensor2;
      else
        TempSensor2 = Conf.TempSensor3;
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
    {
      v8 = TempSensor2 - 1;
      v9 = 0;
      BM1397_set_config(which_chain, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, *v19 | 0x4030, 0);
      check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, 0);
      do
        ++v9;
      while ( (check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v8, 0x1Cu, 0) & 0xC0000000) != 0 && v9 < 2 );
      v10 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * v8,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFEFF | 0x1000100,
        0);
      do
      {
        ++v10;
        v11 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v8, 0x1Cu, 0);
        if ( (v11 & 0xC0000000) == 0 )
        {
          remote_temp = v11 - 64;
          printf("\nASIC temperature is %d\n", (unsigned __int8)v11 - 64);
          goto LABEL_21;
        }
      }
      while ( v10 < 2 );
      gNotReadOutTemp = 1;
      printf("%s: Can't read out ASIC TEMP. ret = 0x%08x\n", (const char *)_FUNCTION___8582, v11);
LABEL_21:
      v12 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * v8,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFFFF | 0x1000000,
        0);
      do
      {
        ++v12;
        v13 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v8, 0x1Cu, 0);
        if ( (v13 & 0xC0000000) == 0 )
        {
          local_temp = v13 - 64;
          printf("\nPCB temperature is %d\n", (unsigned __int8)v13 - 64);
          goto LABEL_25;
        }
      }
      while ( v12 < 2 );
      gNotReadOutTemp = 1;
      printf("%s: Can't read out HASH BOARD TEMP. ret = 0x%08x\n", (const char *)_FUNCTION___8582, v13);
LABEL_25:
      if ( gNotReadOutTemp )
      {
        v16 = 0;
        v15 = 0;
        v14 = 0;
      }
      else
      {
        v14 = local_temp - remote_temp;
        v15 = local_temp - remote_temp;
        v16 = (char)(local_temp - remote_temp);
      }
      if ( v2 )
      {
        if ( v2 == 1 )
        {
          offset_value[2] = TempSensor2;
          gT2_offset_value = v15;
          cgpu.T2_offset_value += v14;
          offset_value[3] = cgpu.T2_offset_value;
        }
        else
        {
          offset_value[4] = TempSensor2;
          gT3_offset_value = v15;
          cgpu.T3_offset_value += v14;
          offset_value[5] = cgpu.T3_offset_value;
        }
      }
      else
      {
        offset_value[0] = TempSensor2;
        gT1_offset_value = v15;
        cgpu.T1_offset_value += v14;
        offset_value[1] = cgpu.T1_offset_value;
      }
      printf("\ntemp_offset_value = %d\n", v16);
    }
    ++v2;
  }
  while ( v2 != 3 );
  v4 = 0;
  v5 = (char *)&v19 + 3;
  offset_value[7] = 0;
  offset_value[6] = LOBYTE(Conf.sensor_model) | 0x20;
  putchar(10);
  do
  {
    v6 = v4;
    v7 = (unsigned __int8)*++v5;
    ++v4;
    printf("offset_value[%d] = %d\n", v6, v7);
  }
  while ( v4 != 8 );
  if ( !pattern_test_time && Conf.AsicNum != 1 )
    AT24C02_save_offset_value(gI2c, gChain, offset_value);
}

//----- (00027E34) --------------------------------------------------------
void __fastcall BM1397_set_default_temperature_offset_value(unsigned __int8 which_chain)
{
  int v2; // r11
  int v3; // r9
  unsigned int v4; // r10
  char v5; // r4
  unsigned int v6; // r8
  unsigned int v7; // r8
  unsigned int v8; // r8
  unsigned int v9; // r0
  unsigned int v10; // r3
  unsigned int TempSensor1; // r1
  unsigned __int8 v12; // r2
  unsigned int which_sensor; // [sp+8h] [bp-40h]
  int v14; // [sp+10h] [bp-38h]

  printf("\n--- %s\n", (const char *)_FUNCTION___8606);
  v2 = 1;
  v3 = 0;
  v14 = 0;
  which_sensor = 0;
  while ( 1 )
  {
    switch ( v3 )
    {
      case 0:
        v10 = gSensor_i2c_addr_high_4_bit;
        TempSensor1 = Conf.TempSensor1;
        v12 = gT1_offset_value;
        v14 = gT1_offset_value;
LABEL_26:
        which_sensor = TempSensor1;
        v4 = v10 | 0x1011100 | v12;
        break;
      case 1:
        v12 = gT2_offset_value;
        v10 = gSensor_i2c_addr_high_4_bit;
        TempSensor1 = Conf.TempSensor2;
        v14 = gT2_offset_value;
        goto LABEL_26;
      case 2:
        which_sensor = Conf.TempSensor3;
        v14 = gT3_offset_value;
        v4 = gSensor_i2c_addr_high_4_bit | 0x1011100 | (unsigned __int8)gT3_offset_value;
        break;
      default:
        v4 = 0;
        break;
    }
    if ( which_sensor )
    {
      v5 = which_sensor - 1;
      v6 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * (which_sensor - 1),
        0x18u,
        gBM1397_MISC_CONTROL_reg | 0x4030,
        0);
      check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * (which_sensor - 1), 0x18u, 0);
      do
        ++v6;
      while ( (check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v5, 0x1Cu, 0) & 0xC0000000) != 0 && v6 < 2 );
      v7 = 0;
      BM1397_set_config(which_chain, gChain_Asic_Interval * v5, 0x1Cu, v4, 0);
      do
        ++v7;
      while ( (check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v5, 0x1Cu, 0) & 0xC0000000) != 0 && v7 < 2 );
      v8 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * v5,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEEEFF | 0x1001100,
        0);
      do
      {
        ++v8;
        v9 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v5, 0x1Cu, 0);
      }
      while ( (v9 & 0xC0000000) != 0 && v8 < 2 );
      if ( v14 != (char)v9 )
      {
        if ( !v3 )
        {
          Sensor1_OK = 0;
          puts("!!! sensor1 is error!\n");
          goto LABEL_8;
        }
        if ( v3 == 1 )
        {
          Sensor2_OK = 0;
          puts("!!! sensor2 is error!\n");
          goto LABEL_9;
        }
        if ( v3 == 2 )
          break;
      }
    }
LABEL_8:
    if ( v2 == 3 )
      return;
LABEL_9:
    ++v3;
    ++v2;
  }
  Sensor3_OK = 0;
  j_puts("!!! sensor3 is error!\n");
}

//----- (000280B0) --------------------------------------------------------
void __fastcall BM1397_read_asic_temperature_local_remote(unsigned __int8 which_chain)
{
  int i; // r9
  unsigned int TempSensor3; // r10
  int v4; // r4
  int v5; // r5
  int v6; // r7
  int *v7; // r1
  int v8; // r3
  bool v9; // cc
  char v10; // r2
  bool v11; // cc
  int v12; // r2
  unsigned int v13; // r4
  char v14; // r4
  unsigned int v15; // r8
  unsigned int v16; // r8
  unsigned int v17; // r0
  int v18; // r8
  int *v19; // r3
  unsigned int v20; // r8
  unsigned int v21; // r0
  bool *v22; // [sp+8h] [bp-48h]

  v22 = gSensor_OK[3];
  for ( i = 0; i != 4; ++i )
  {
    switch ( i )
    {
      case 2:
        TempSensor3 = Conf.TempSensor3;
        break;
      case 3:
        TempSensor3 = Conf.TempSensor4;
        break;
      case 1:
        TempSensor3 = Conf.TempSensor2;
        break;
      default:
        TempSensor3 = Conf.TempSensor1;
        break;
    }
    if ( TempSensor3 )
    {
      v14 = TempSensor3 - 1;
      v15 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * (TempSensor3 - 1),
        0x18u,
        gBM1397_MISC_CONTROL_reg | 0x4030,
        0);
      check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * (TempSensor3 - 1), 0x18u, 0);
      do
        ++v15;
      while ( (check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v14, 0x1Cu, 0) & 0xC0000000) != 0 && v15 < 2 );
      v16 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * v14,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFEFF | 0x1000100,
        0);
      while ( 1 )
      {
        ++v16;
        v17 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v14, 0x1Cu, 0);
        if ( (v17 & 0xC0000000) == 0 )
          break;
        if ( v16 >= 2 )
        {
          printf("\n!!! %s: do not read out ASIC %d temperature\n\n", (const char *)_FUNCTION___8637, TempSensor3);
          gNotReadOutTemp = 1;
          *v22 = 0;
          goto LABEL_58;
        }
      }
      v18 = (unsigned __int8)v17 - 64;
      printf("\nASIC %d TEMP is : %d\n", TempSensor3, v18);
      if ( i )
      {
        if ( i == 1 )
        {
          Sensor2_temp = v18;
        }
        else
        {
          if ( i == 2 )
            v19 = &Sensor3_temp;
          else
            v19 = &Sensor4_temp;
          *v19 = v18;
        }
      }
      else
      {
        Sensor1_temp = v18;
      }
      if ( TempSensor3 == Conf.StartSensor )
      {
        if ( v18 < Conf.StartTemp )
        {
          if ( !gStartTest )
            printf(
              "\nASIC %d temperature is %d, waiting it raise to start temperature %d\n\n",
              TempSensor3,
              v18,
              Conf.StartTemp);
        }
        else
        {
          if ( !gStartTest )
            printf("\nBegin test!!! Start sensor is %d, ASIC temperature is %d\n\n", TempSensor3, v18);
          gStartTest = 1;
        }
      }
LABEL_58:
      v20 = 0;
      BM1397_set_config(
        which_chain,
        gChain_Asic_Interval * v14,
        0x1Cu,
        gSensor_i2c_addr_high_4_bit & 0xFEFEFFFF | 0x1000000,
        0);
      do
      {
        ++v20;
        v21 = check_BM1397_asic_reg(which_chain, gChain_Asic_Interval * v14, 0x1Cu, 0);
        if ( (v21 & 0xC0000000) == 0 )
        {
          printf("\nASIC %d Hash Board temperature is %d\n\n", TempSensor3, (unsigned __int8)v21 - 64);
          goto LABEL_8;
        }
      }
      while ( v20 < 2 );
      printf(
        "\n!!! %s: do not read out ASIC %d Hash Board temperature\n\n",
        (const char *)_FUNCTION___8637,
        TempSensor3);
      gNotReadOutTemp = 1;
      *v22 = 0;
    }
LABEL_8:
    ++v22;
  }
  v4 = Sensor1_temp;
  v5 = Sensor3_temp;
  v6 = Sensor4_temp;
  temp_change = (Sensor1_temp
               + Sensor2_temp
               + Sensor3_temp
               + Sensor4_temp
               - last_Sensor1_temp
               - last_Sensor2_temp
               - last_Sensor3_temp
               - last_Sensor4_temp)
              / gSensor_number;
  if ( temp_change )
  {
    last_Sensor1_temp = Sensor1_temp;
    last_Sensor2_temp = Sensor2_temp;
    last_Sensor3_temp = Sensor3_temp;
    last_Sensor4_temp = Sensor4_temp;
  }
  LOWORD(v7) = 3704;
  v8 = highest_temp;
  if ( Sensor1_temp > highest_temp )
  {
    v8 = Sensor1_temp;
    highest_temp = Sensor1_temp;
  }
  if ( Sensor2_temp > v8 )
  {
    v8 = Sensor2_temp;
    highest_temp = Sensor2_temp;
  }
  if ( Sensor3_temp > v8 )
  {
    v8 = Sensor3_temp;
    highest_temp = Sensor3_temp;
  }
  if ( Sensor4_temp > v8 )
  {
    highest_temp = Sensor4_temp;
    v8 = Sensor4_temp;
  }
  v9 = Sensor2_temp <= 0;
  if ( Sensor2_temp )
    v9 = Sensor1_temp <= Sensor2_temp;
  HIWORD(v7) = 35;
  if ( !v9 )
    v4 = Sensor2_temp;
  if ( v9 )
    *v7 = v4;
  else
    *v7 = Sensor2_temp;
  v10 = v5;
  if ( v5 )
    v10 = 1;
  v11 = v5 < 0;
  if ( v5 )
    v11 = v5 < v4;
  if ( v11 )
  {
    v4 = v5;
    *v7 = v5;
  }
  if ( v6 < v4 )
    v12 = v10 & 1;
  else
    v12 = 0;
  if ( v12 )
  {
    v4 = v6;
    *v7 = v6;
  }
  v13 = v8 - v4;
  if ( gGlobalHighestTemp < v8 )
    gGlobalHighestTemp = v8;
  if ( Conf.AlarmTemp < v8 )
    gHigherThanAlarmTemp = 1;
  if ( Conf.MaxTempGap < v13 )
  {
    gHigherThanMaxTempGap = 1;
    if ( (int)v13 > gMaxTempGap_value )
    {
      gMaxTempGap_value = v13;
      j_printf("gMaxTempGap_value is %d\n\n", v13);
    }
  }
}

//----- (000284A0) --------------------------------------------------------
void __fastcall BM1397_read_asic_temperature_local(unsigned __int8 which_chain)
{
  int v1; // r7
  int v2; // r8
  unsigned int TempSensor2; // r10
  char v4; // r5
  unsigned int v5; // r4
  unsigned int v6; // r4
  unsigned int v7; // r0
  int v8; // r4
  int v9; // r3
  int v10; // r3
  int v11; // r3
  unsigned int v12; // r3
  unsigned int *v13; // [sp+Ch] [bp-34h]
  bool *v14; // [sp+10h] [bp-30h]

  v13 = gSensor_read_ok_counter[which_chain];
  v1 = which_chain;
  v2 = 0;
  v14 = gSensor_OK[which_chain];
  while ( 1 )
  {
    if ( v2 )
    {
      if ( v2 == 1 )
        TempSensor2 = Conf.TempSensor2;
      else
        TempSensor2 = v2 == 2 ? Conf.TempSensor3 : Conf.TempSensor4;
    }
    else
    {
      TempSensor2 = Conf.TempSensor1;
    }
    if ( TempSensor2 )
      break;
LABEL_9:
    if ( ++v2 == 4 )
      return;
  }
  v4 = TempSensor2 - 1;
  v5 = 0;
  BM1397_set_config(v1, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, gBM1397_MISC_CONTROL_reg | 0x4030, 0);
  check_BM1397_asic_reg(v1, gChain_Asic_Interval * (TempSensor2 - 1), 0x18u, 0);
  do
    ++v5;
  while ( (check_BM1397_asic_reg(v1, gChain_Asic_Interval * v4, 0x1Cu, 0) & 0xC0000000) != 0 && v5 < 2 );
  v6 = 0;
  BM1397_set_config(v1, gChain_Asic_Interval * v4, 0x1Cu, gSensor_i2c_addr_high_4_bit & 0xFEFEFFFF | 0x1000000, 0);
  while ( 1 )
  {
    ++v6;
    v7 = check_BM1397_asic_reg(v1, gChain_Asic_Interval * v4, 0x1Cu, 0);
    if ( (v7 & 0xC0000000) == 0 )
      break;
    if ( v6 >= 2 )
    {
      printf(
        "%s: do not read out ASIC %d Hash Boardtemperature. ret = 0x%08x\n\n",
        (const char *)_FUNCTION___8656,
        TempSensor2,
        v7);
      gNotReadOutTemp = 1;
      goto LABEL_9;
    }
  }
  v8 = (unsigned __int8)v7 - 64;
  if ( v8 > highest_temp )
    highest_temp = (unsigned __int8)v7 - 64;
  switch ( v2 )
  {
    case 0:
      if ( (_BYTE)v7 )
      {
        Sensor1_temp = (unsigned __int8)v7 - 64;
        v10 = *v13 + 1;
        gSensor_OK[v1][0] = 1;
        *v13 = v10;
        goto LABEL_24;
      }
      goto LABEL_35;
    case 1:
      if ( (_BYTE)v7 )
      {
        Sensor2_temp = (unsigned __int8)v7 - 64;
        v12 = v13[1];
        v14[1] = 1;
        v13[1] = v12 + 1;
LABEL_24:
        printf("\nASIC %d Hash Board temperature is %d\n", TempSensor2, v8);
        if ( TempSensor2 != Conf.StartSensor )
          goto LABEL_9;
        goto LABEL_25;
      }
LABEL_35:
      v8 = 0;
      goto LABEL_24;
    case 2:
      if ( (_BYTE)v7 )
      {
        Sensor3_temp = (unsigned __int8)v7 - 64;
        v11 = v13[2] + 1;
        v14[2] = 1;
        v13[2] = v11;
        goto LABEL_24;
      }
      goto LABEL_35;
  }
  if ( (_BYTE)v7 )
  {
    Sensor4_temp = (unsigned __int8)v7 - 64;
    v9 = v13[3] + 1;
    v14[3] = 1;
    v13[3] = v9;
    goto LABEL_24;
  }
  printf("\nASIC %d Hash Board temperature is %d\n", TempSensor2, 0);
  if ( TempSensor2 == Conf.StartSensor )
  {
    v8 = 0;
LABEL_25:
    if ( Conf.StartTemp > v8 )
    {
      if ( !gStartTest )
        printf(
          "\nASIC %d Hash Board temperature is %d, waiting it raise to start temperature %d\n\n",
          TempSensor2,
          v8,
          Conf.StartTemp);
    }
    else
    {
      if ( !gStartTest )
        printf("\nBegin test!!! Start sensor is %d, Hash Board temperature is %d\n\n", TempSensor2, v8);
      gStartTest = 1;
    }
    goto LABEL_9;
  }
}

//----- (00028734) --------------------------------------------------------
void *__fastcall __noreturn single_BM1397_show_status_func(void *arg)
{
  int v1; // r6

  v1 = *(unsigned __int8 *)arg;
  time_counter = 0;
  while ( 1 )
  {
    memset(lcd_output, 32, sizeof(lcd_output));
    if ( gIsReadTemp && gIsOpenCoreEnd )
    {
      printf("%s 1: start_receive = %d\n", (const char *)_FUNCTION___8665, start_receive);
      printf("%s 1: gIsReadTemp = %d\n", (const char *)_FUNCTION___8665, gIsReadTemp);
      printf("%s 1: Conf.sensor_model = %d\n", (const char *)_FUNCTION___8665, Conf.sensor_model);
      gReadingTemp = 1;
      usleep(15 * Conf.timeout);
      if ( Conf.sensor_model - 1 <= 1 )
      {
        printf("%s %d\n", (const char *)_FUNCTION___8665, 2263);
        BM1397_read_asic_temperature_local_remote(v1);
      }
      else if ( Conf.sensor_model - 3 <= 5 )
      {
        printf("%s %d\n", (const char *)_FUNCTION___8665, 2269);
        BM1397_read_asic_temperature_local(v1);
      }
      else
      {
        printf("\n%s: please config sensor_model in Config.ini\n", (const char *)_FUNCTION___8665);
      }
      fan_control(6u);
      gReadingTemp = 0;
    }
    sprintf((char *)lcd_output, "   time %ds", time_counter);
    sprintf((char *)lcd_output[1], "   nonce=%d", gValid_Nonce_Num[v1]);
    sprintf((char *)lcd_output[2], "   T1 %d `C", Sensor1_temp);
    ++time_counter;
    write(lcd_fd, lcd_output, 0x40u);
    if ( gStartTest )
      printf("\ngValid_Nonce_Num = %d\n", gValid_Nonce_Num[v1]);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[1][18][431]);
  }
}

//----- (000288E4) --------------------------------------------------------
int __fastcall BM1397_is_nonce_or_reg_value(unsigned int data)
{
  return data >> 31;
}

//----- (000288E8) --------------------------------------------------------
int __fastcall BM1397_check_nonce_flag(unsigned int data)
{
  if ( (data & 0xE0) == 128 )
    return 1;
  printf("%s: data = 0x%08x\n", (const char *)_FUNCTION___8673, data);
  return 0;
}

//----- (00028910) --------------------------------------------------------
int __fastcall single_BM1397_check_nonce(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r5
  int v3; // r8
  unsigned int v4; // r10
  unsigned int v5; // r7
  unsigned int v6; // r2
  int v7; // r6
  unsigned int OpenCoreNum1; // r1
  unsigned int OpenCoreNum2; // r0
  unsigned int OpenCoreNum3; // r4
  unsigned int OpenCoreNum5; // lr
  unsigned int OpenCoreNum6; // r12
  unsigned int OpenCoreNum7; // r11
  int v14; // r3
  bool v15; // zf
  int v16; // r2
  work *v17; // r7
  int *v18; // r7
  int result; // r0
  unsigned int v20; // r3
  int v21; // r4
  work *v22; // r4
  unsigned int v23; // r7
  work *v24; // r0
  int v25; // r0
  unsigned int OpenCoreNum4; // r3
  int v27; // lr
  int v28; // r6
  unsigned int v29; // r4
  unsigned int v30; // r1
  int v31; // r11
  int v32; // r3
  unsigned int v33; // r3
  int v34; // r9
  unsigned int v35; // r3
  int v36; // r12
  unsigned int v37; // r3
  int v38; // r9
  unsigned int v39; // r3
  int v40; // r9
  unsigned int OpenCoreNum8; // r1

  v2 = buf[1];
  v3 = which_chain;
  v4 = *buf;
  v5 = HIWORD(*buf) & 0x7FFF;
  v6 = (unsigned __int8)(v2 >> 14) / gChain_Asic_Interval;
  v7 = (v2 >> 31) | (2 * ((v2 >> 22) & 0x1FF));
  OpenCoreNum1 = Conf.OpenCoreNum1;
  OpenCoreNum2 = Conf.OpenCoreNum2;
  OpenCoreNum3 = Conf.OpenCoreNum3;
  OpenCoreNum5 = Conf.OpenCoreNum5;
  OpenCoreNum6 = Conf.OpenCoreNum6;
  OpenCoreNum7 = Conf.OpenCoreNum7;
  if ( v6 )
  {
    printf(
      "%s: received ASIC%02d nonce. error!!! data[0] = 0x%08x, received nonce = 0x%08x\n",
      (const char *)_FUNCTION___8698,
      v6,
      v4,
      v2);
    return -1;
  }
  if ( v7 >= 672 )
  {
    printf(
      "%s: received core%02d nonce. error!!! data[0] = 0x%08x, received nonce = 0x%08x\n",
      (const char *)_FUNCTION___8698,
      (v2 >> 31) | (2 * ((v2 >> 22) & 0x1FF)),
      v4,
      v2);
    return -1;
  }
  if ( v5 >= Conf.pattern_number )
  {
    printf(
      "%s: received work_id = %02d nonce. error!!! data[0] = 0x%08x, received nonce = 0x%08x\n",
      (const char *)_FUNCTION___8698,
      v5,
      v4,
      v2);
    return -1;
  }
  if ( v7 <= 31 )
  {
    v20 = (unsigned __int8)(v2 >> 14) / gChain_Asic_Interval;
    do
    {
      ++v20;
      if ( (OpenCoreNum1 & 1) != 0 )
        ++v6;
      OpenCoreNum1 >>= 1;
    }
    while ( v20 != v7 + 1 );
    goto LABEL_13;
  }
  if ( (unsigned int)(v7 - 32) <= 0x1F )
  {
    v14 = 32;
    do
    {
      v15 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v15 )
        ++v6;
      --v14;
    }
    while ( v14 );
    do
    {
      ++v14;
      if ( (OpenCoreNum2 & 1) != 0 )
        ++v6;
      OpenCoreNum2 >>= 1;
    }
    while ( v7 - 31 != v14 );
LABEL_13:
    v16 = v6 - 1;
    goto LABEL_14;
  }
  if ( (unsigned int)(v7 - 64) <= 0x1F )
  {
    v32 = 32;
    do
    {
      v15 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum2 & 1) == 0;
      OpenCoreNum2 >>= 1;
      if ( !v15 )
        ++v6;
      --v32;
    }
    while ( v32 );
    do
    {
      ++v32;
      if ( (OpenCoreNum3 & 1) != 0 )
        ++v6;
      OpenCoreNum3 >>= 1;
    }
    while ( v7 - 63 != v32 );
    goto LABEL_13;
  }
  if ( (unsigned int)(v7 - 96) <= 0x1F )
  {
    OpenCoreNum4 = Conf.OpenCoreNum4;
    v27 = 32;
    do
    {
      v15 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum2 & 1) == 0;
      OpenCoreNum2 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum3 & 1) == 0;
      OpenCoreNum3 >>= 1;
      if ( !v15 )
        ++v6;
      --v27;
    }
    while ( v27 );
    do
    {
      ++v27;
      if ( (OpenCoreNum4 & 1) != 0 )
        ++v6;
      OpenCoreNum4 >>= 1;
    }
    while ( v27 != v7 - 95 );
    goto LABEL_13;
  }
  if ( (unsigned int)(v7 - 128) <= 0x1F )
  {
    v35 = Conf.OpenCoreNum4;
    v36 = 32;
    do
    {
      v15 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum2 & 1) == 0;
      OpenCoreNum2 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum3 & 1) == 0;
      OpenCoreNum3 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (v35 & 1) == 0;
      v35 >>= 1;
      if ( !v15 )
        ++v6;
      --v36;
    }
    while ( v36 );
    do
    {
      ++v36;
      if ( (OpenCoreNum5 & 1) != 0 )
        ++v6;
      OpenCoreNum5 >>= 1;
    }
    while ( v36 != v7 - 127 );
    goto LABEL_13;
  }
  if ( (unsigned int)(v7 - 160) <= 0x1F )
  {
    v33 = Conf.OpenCoreNum4;
    v34 = 32;
    do
    {
      v15 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum2 & 1) == 0;
      OpenCoreNum2 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum3 & 1) == 0;
      OpenCoreNum3 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (v33 & 1) == 0;
      v33 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum5 & 1) == 0;
      OpenCoreNum5 >>= 1;
      if ( !v15 )
        ++v6;
      --v34;
    }
    while ( v34 );
    do
    {
      ++v34;
      if ( (OpenCoreNum6 & 1) != 0 )
        ++v6;
      OpenCoreNum6 >>= 1;
    }
    while ( v7 - 159 != v34 );
    goto LABEL_13;
  }
  if ( (unsigned int)(v7 - 192) <= 0x1F )
  {
    v37 = Conf.OpenCoreNum4;
    v38 = 32;
    v6 = 0;
    do
    {
      v15 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum2 & 1) == 0;
      OpenCoreNum2 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum3 & 1) == 0;
      OpenCoreNum3 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (v37 & 1) == 0;
      v37 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum5 & 1) == 0;
      OpenCoreNum5 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum6 & 1) == 0;
      OpenCoreNum6 >>= 1;
      if ( !v15 )
        ++v6;
      --v38;
    }
    while ( v38 );
    do
    {
      ++v38;
      if ( (OpenCoreNum7 & 1) != 0 )
        ++v6;
      OpenCoreNum7 >>= 1;
    }
    while ( v38 != v7 - 191 );
    goto LABEL_13;
  }
  if ( (unsigned int)(v7 - 224) <= 0x1F )
  {
    v39 = Conf.OpenCoreNum4;
    v40 = 32;
    v6 = 0;
    do
    {
      v15 = (OpenCoreNum1 & 1) == 0;
      OpenCoreNum1 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum2 & 1) == 0;
      OpenCoreNum2 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum3 & 1) == 0;
      OpenCoreNum3 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (v39 & 1) == 0;
      v39 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum5 & 1) == 0;
      OpenCoreNum5 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum6 & 1) == 0;
      OpenCoreNum6 >>= 1;
      if ( !v15 )
        ++v6;
      v15 = (OpenCoreNum7 & 1) == 0;
      OpenCoreNum7 >>= 1;
      if ( !v15 )
        ++v6;
      --v40;
    }
    while ( v40 );
    OpenCoreNum8 = Conf.OpenCoreNum8;
    do
    {
      ++v40;
      if ( (OpenCoreNum8 & 1) != 0 )
        ++v6;
      OpenCoreNum8 >>= 1;
    }
    while ( v40 != v7 - 223 );
    goto LABEL_13;
  }
  printf("%s: which_core = %d, error!!!\n", (const char *)_FUNCTION___8698, (v2 >> 31) | (2 * ((v2 >> 22) & 0x1FF)));
  v16 = -1;
LABEL_14:
  v17 = &cgpu.works[v16][v5];
  if ( v2 == v17->nonce )
  {
    v18 = &v17->id + v3;
    result = v18[13];
    if ( result )
    {
      v18[13] = result + 1;
      result = 0;
      ++gRepeated_Nonce_Id[v3];
    }
    else
    {
      v28 = v7 + (v3 << 17);
      v29 = gValid_Nonce_Num[v3];
      v18[13] = 1;
      v30 = gAsic_Core_Nonce_Num[0][0][v28];
      gValid_Nonce_Num[v3] = v29 + 1;
      gAsic_Core_Nonce_Num[0][0][v28] = v30 + 1;
    }
  }
  else
  {
    pthread_mutex_lock(&HW_check_mutex[v3]);
    v21 = gWork_Num_For_Hw_Check;
    if ( gWork_Num_For_Hw_Check )
    {
      v22 = gWorks_For_Hw_Check[v3];
      v23 = 0;
      do
      {
        v24 = v22;
        ++v23;
        ++v22;
        v25 = check_hw(v24, v2, 0);
        if ( !v25 )
        {
          pthread_mutex_unlock(&HW_check_mutex[v3]);
          return 0;
        }
      }
      while ( gWork_Num_For_Hw_Check > v23 );
      v31 = v25;
      pthread_mutex_unlock(&HW_check_mutex[v3]);
      if ( v31 == 1 )
      {
        ++gHw_Nonce_Num[v3];
        printf(
          "%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n",
          (const char *)_FUNCTION___8698,
          v3,
          0,
          v7,
          v2);
      }
      return 0;
    }
    else
    {
      pthread_mutex_unlock(&HW_check_mutex[v3]);
      return v21;
    }
  }
  return result;
}

//----- (00028DCC) --------------------------------------------------------
int __fastcall single_BM1397_check_register_value(unsigned __int8 which_chain, unsigned int *buf)
{
  unsigned int v2; // r4
  unsigned int v3; // r7
  reg_buf *v4; // r2
  char *v5; // r0
  unsigned int v6; // r1
  unsigned int reg_value_num; // r3

  if ( reg_value_buf->reg_value_num > 0x1FE )
  {
    printf("%s: reg_value_buf buffer is full!\n", (const char *)_FUNCTION___8752);
    return 0;
  }
  else
  {
    v2 = *buf;
    v3 = buf[1];
    if ( (*buf & 0x40) != 0 )
    {
      printf("%s: reg crc error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8752, *buf, buf[1]);
      return -1;
    }
    else if ( (v2 & 0x20000000) != 0 )
    {
      printf("%s: REG_TYPE error. data[0] = 0x%08x, reg_value = 0x%08x\n", (const char *)_FUNCTION___8752, *buf, buf[1]);
      return -1;
    }
    else
    {
      pthread_mutex_lock(&reg_mutex);
      v4 = reg_value_buf;
      v5 = (char *)v4 + 8 * v4->p_wr;
      v6 = reg_value_buf->p_wr + 1;
      *((_DWORD *)v5 + 4) = v3;
      v5[22] = HIBYTE(v2) & 0x1F;
      v5[20] = BYTE2(v2);
      v5[23] = v2 & 0xF;
      v5[21] = BYTE1(v2);
      reg_value_num = v4->reg_value_num;
      v4->p_wr = v6;
      if ( v6 >= 0x200 )
        v4->p_wr = 0;
      v4->reg_value_num = reg_value_num + 1;
      pthread_mutex_unlock(&reg_mutex);
      return 0;
    }
  }
}

//----- (00028E84) --------------------------------------------------------
void *__fastcall single_BM1397_receive_func(void *arg)
{
  unsigned __int8 v1; // r7
  unsigned int v2; // r4
  void *result; // r0
  unsigned int i; // r5
  unsigned int buf[2]; // [sp+0h] [bp-28h] BYREF

  v1 = *(_BYTE *)arg;
  buf[0] = 0;
  buf[1] = 0;
  while ( 1 )
  {
    result = (void *)start_receive;
    if ( !start_receive )
      break;
    usleep(0x1388u);
    v2 = read_axi_fpga(6u) & 0x1FF;
    if ( v2 )
    {
      for ( i = 0; i < v2; ++i )
      {
        get_return_nonce(buf);
        if ( (buf[0] & 0x80000000) == 0 )
        {
          single_BM1397_check_register_value(v1, buf);
        }
        else if ( gBegin_Get_Nonce )
        {
          if ( (buf[0] & 0xE0) == 128 )
            single_BM1397_check_nonce(v1, buf);
          else
            printf("%s: data = 0x%08x\n", (const char *)_FUNCTION___8673, buf[0]);
        }
      }
    }
  }
  return result;
}

//----- (00028F18) --------------------------------------------------------
void singleAsicTest_BM1397()
{
  unsigned int axi_fpga; // r0
  unsigned int v1; // r0
  unsigned int result; // r0
  unsigned __int8 lcd_display_buf[16]; // [sp+0h] [bp-30h] BYREF

  memset(lcd_display_buf, 32, sizeof(lcd_display_buf));
  printf("\nBegin %s test\n", (const char *)_FUNCTION___8830);
  system("date");
  putchar(10);
  memset(lcd_output, 32, sizeof(lcd_output));
  if ( lcd_fd > 0 )
  {
    lseek(lcd_fd, 0, 0);
    write(lcd_fd, lcd_output, 0x40u);
  }
  init_fpga();
  write_axi_fpga(0x3Eu, 0);
  usleep((__useconds_t)&loc_186A0);
  axi_fpga = read_axi_fpga(0);
  write_axi_fpga(0, axi_fpga | 0x40000000);
  reset_single_BM1397_global_arg();
  check_chain();
  if ( gChain == 255 )
  {
    puts("\nNo hash board, please plug in it");
    write_lcd(1u, " no hash board  ", 0x10u);
    return;
  }
  if ( pthread_create(&cgpu.show_id, 0, single_BM1397_show_status_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "   Creat show   ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1397_show_status_func fail\n\n\n", (const char *)_FUNCTION___8830);
    return;
  }
  reset_hash_board();
  start_receive = 1;
  if ( pthread_create(&cgpu.receive_id, 0, single_BM1397_receive_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "  Creat receive ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1397_receive_func fail\n\n\n", (const char *)_FUNCTION___8830);
    return;
  }
  v1 = read_axi_fpga(0x40u);
  write_axi_fpga(0x40u, v1 & 0xFFFF7E1F | 0x8100);
  puts("\n--- check asic number");
  check_BM1397_asic_reg(gChain, 0, 0, 1);
  printf("\n--- check chain: asicNum = %d\n", cgpu.chain_asic_num[gChain]);
  if ( cgpu.chain_asic_num[gChain] != 1 )
  {
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    sprintf((char *)&lcd_display_buf[7], "%d", cgpu.chain_asic_num[gChain]);
    write_lcd(0, "   Only have    ", 0x10u);
    write_lcd_no_memset(1u, lcd_display_buf, 0x10u);
    write_lcd_no_memset(2u, "      ASIC      ", 0x10u);
    printf("\n\n---%s: Only have %d ASIC\n", (const char *)_FUNCTION___8830, cgpu.chain_asic_num[gChain]);
    puts("----------------------------\n\n");
    return;
  }
  single_BM1397_calculate_timeout_and_baud();
  set_BM1397_freq(gChain, 0, Conf.Freq, 1);
  BM1397_software_set_address(gChain);
  BM1397_set_baud(gChain, Conf.baud);
  check_BM1397_asic_reg(gChain, 0, 0x18u, 1);
  write_axi_fpga(0x22u, Conf.timeout | 0x80000000);
  if ( Conf.sensor_model - 1 <= 1 )
  {
    if ( pattern_test_time )
    {
      BM1397_enable_extended_mode_of_temperature_sensor(gChain);
    }
    else
    {
      BM1397_soft_reset_sensor(gChain);
      BM1397_enable_extended_mode_of_temperature_sensor(gChain);
      BM1397_get_temperature_offset_value_from_asic(gChain);
    }
    BM1397_set_default_temperature_offset_value(gChain);
  }
  else
  {
    if ( Conf.sensor_model - 3 > 6 )
    {
      pthread_cancel(cgpu.receive_id);
      pthread_cancel(cgpu.show_id);
      write_lcd(0, "Sensor Model Err", 0x10u);
      printf("\n%s: please config sensor_model in Config.ini\n", (const char *)_FUNCTION___8830);
      return;
    }
    BM1397_enable_extended_mode_of_temperature_sensor(gChain);
  }
  gIsReadTemp = 1;
  single_BM1397_open_core(gChain);
  puts("\nBegin send test pattern");
  putchar(10);
  if ( pthread_create(&cgpu.send_id, 0, single_BM1397_send_func, &chain_info_0[gChain]) )
  {
    pthread_cancel(cgpu.send_id);
    pthread_cancel(cgpu.receive_id);
    pthread_cancel(cgpu.show_id);
    write_lcd(0, "   Creat send   ", 0x10u);
    write_lcd_no_memset(1u, "   thread fail  ", 0x10u);
    write_lcd_no_memset(3u, "   test again   ", 0x10u);
    printf("\n!!!%s: create single_BM1397_send_func fail\n\n\n", (const char *)_FUNCTION___8830);
  }
  else
  {
    pthread_join(cgpu.send_id, 0);
    pthread_join(cgpu.receive_id, 0);
    pthread_cancel(cgpu.show_id);
    result = single_BM1397_get_result(gChain);
    single_BM1397_print_lcd(gChain, result);
    set_fan_speed(0);
    usleep((__useconds_t)&gAsic_Core_Nonce_Num[0][73][183]);
  }
}

//----- (000295C8) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (000295D4) --------------------------------------------------------
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp)
{
  int i; // r4
  void (__fastcall *v4)(); // r3

  init_proc();
  for ( i = 0; i != 1; ++i )
  {
    v4 = (void (__fastcall *)())*(&_frame_dummy_init_array_entry + i);
    v4();
  }
}
// 30000: using guessed type void *_frame_dummy_init_array_entry;

//----- (00029618) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=420 queued=330 decompiled=330 lumina nreq=0 worse=0 better=0
// ALL OK, 330 function(s) have been successfully decompiled
