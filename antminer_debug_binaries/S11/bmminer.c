/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>
#include <pthread.h>
#include <sys/time.h>
#include <stdio.h>
#include <semaphore.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>

//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_11F50();
int j_pthread_mutex_unlock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// FILE *fdopen(int fd, const char *modes);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int sem_wait(sem_t *sem);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
int j_strcmp(const char *s1, const char *s2);
// int strcmp(const char *s1, const char *s2);
int j_strtol(const char *nptr, char **endptr, int base);
// int strtol(const char *nptr, char **endptr, int base);
// int sem_post(sem_t *sem);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
void j_free(void *ptr);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int inet_pton(int af, const char *cp, void *buf);
// pthread_t pthread_self(void);
void *j_memcpy(void *dest, const void *src, size_t n);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int setlogmask(int mask);
// __off_t lseek(int fd, __off_t offset, int whence);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int ftell(FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
unsigned int j_sleep(unsigned int seconds);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int sysconf(int name);
// int dup2(int fd, int fd2);
// int _isinf(double value);
// void *realloc(void *ptr, size_t size);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int _xstat(int ver, const char *filename, struct stat *stat_buf);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
char *j_strcpy(char *dest, const char *src);
// char *strcpy(char *dest, const char *src);
int j_gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
int j_pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// double floor(double x);
// int __fastcall strtof(_DWORD, _DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo(struct sysinfo *info);
void *j_malloc(size_t size);
// void *malloc(size_t size);
// double log10(double x);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// char *strerror(int errnum);
int j_system(const char *command);
// int system(const char *command);
// struct tm *localtime(const time_t *timer);
// const __int32_t **_ctype_tolower_loc(void);
// char *dirname(char *path);
// const __int32_t **_ctype_toupper_loc(void);
// int _gmon_start__(void); weak
// int sem_trywait(sem_t *sem);
// int open(const char *file, int oflag, ...);
// int kill(__pid_t pid, int sig);
// const unsigned __int16 **_ctype_b_loc(void);
// void exit(int status);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// int round(void); weak
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int nice(int inc);
// int fprintf(FILE *stream, const char *format, ...);
int j_fcntl(int fd, int cmd, ...);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
int j_snprintf(char *s, size_t maxlen, const char *format, ...);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
char *j___strdup(const char *s);
// char *_strdup(const char *s);
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
void *j_memset(void *s, int c, size_t n);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int scandir(const char *dir, struct dirent ***namelist, int (*selector)(const struct dirent *), int (*cmp)(const void *, const void *));
char *j_strncpy(char *dest, const char *src, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// int fileno(FILE *stream);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int _isnan(double value);
// int access(const char *name, int type);
int j_fclose(FILE *stream);
// int fclose(FILE *stream);
// int pipe(int pipedes[2]);
// int munmap(void *addr, size_t len);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int shutdown(int fd, int how);
// int sigemptyset(sigset_t *set);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// __pid_t fork(void);
// void errx(int status, const char *format, ...);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int execl(const char *path, const char *arg, ...);
// int listen(int fd, int n);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __fastcall lldiv(_DWORD); weak
// int fputc(int c, FILE *stream);
void j_syslog(int pri, const char *fmt, ...);
// void syslog(int pri, const char *fmt, ...);
// int sscanf(const char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int alphasort(const void *e1, const void *e2);
int j_sprintf(char *s, const char *format, ...);
// int sprintf(char *s, const char *format, ...);
// void openlog(const char *ident, int option, int facility);
// double exp(double x);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
int j_clock_gettime(clockid_t clock_id, struct timespec *tp);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// int fseek(FILE *stream, int off, int whence);
// char *strncat(char *dest, const char *src, size_t n);
int j_sem_destroy(sem_t *sem);
// int sem_destroy(sem_t *sem);
// int isatty(int fd);
// int fputs(const char *s, FILE *stream);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
int __fastcall calculate_core_number_part_11(int a1);
int __cdecl main(int argc, const char **argv, const char **envp);
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...);
int call_weak_fn();
int *deregister_tm_clones();
__int64 register_tm_clones();
int *_do_global_dtors_aux();
__int64 frame_dummy();
_DWORD *__fastcall api_add_data_full(_DWORD *a1, const char *a2, int a3, const char *a4, char a5);
int __fastcall io_add(unsigned int *a1, char *s);
int __fastcall doquit(int a1, int a2, int a3, int a4);
int __fastcall dorestart(int a1, int a2, int a3, int a4);
const char *__fastcall escape_string(const char *result, int a2);
void __fastcall head_join(unsigned int *a1, const char *a2, int a3, _BYTE *a4);
int __fastcall check_connect(const struct sockaddr *a1, const char **a2, _BYTE *a3);
int mcast();
void *__fastcall mcast_thread(void *userdata);
int __fastcall tail_join(int result, int a2);
void *__fastcall add_item_buf_isra_2(void ***a1, char *s);
void __fastcall send_result_isra_6(char *s, _BYTE *a2, int a3, int a4);
int __fastcall copyadvanceafter_constprop_20(unsigned __int8 **a1, int *a2);
int __fastcall pooldetails(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __fastcall rd_lock_constprop_25(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall __noreturn mutex_lock_part_3_constprop_27(const char *a1, int a2);
void __fastcall __noreturn rw_unlock_part_4_constprop_30(const char *a1, int a2);
void __fastcall __noreturn mutex_unlock_noyield_part_5_constprop_32(const char *a1, int a2);
int __fastcall tidyup(int *a1);
int restart_thread_0();
void __noreturn quit_thread();
int __fastcall print_data(unsigned int *a1, char **a2, int a3, int a4);
int __fastcall message(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5);
int __fastcall privileged(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
void __fastcall dosave(unsigned int *a1, int a2, char *filename, int a4);
int __fastcall lockstats(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall dohotplug(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall dozero(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall usbstats(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall setconfig(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall failoveronly(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4);
void __fastcall removepool(unsigned int *a1, int a2, char *nptr, int a4, int a5);
int __fastcall disablepool(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall enablepool(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall poolquota(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall poolpriority(unsigned int *a1, int a2, char *s, int a4);
void __fastcall addpool(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall switchpool(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall edevstatus(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall devstatus(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall asccount(int a1, int a2, int a3, int a4);
int __fastcall debugstate(int a1, int a2, _BYTE *a3, int a4);
int __fastcall checkcommand(int, int, char *s2, int, char); // idb
int __fastcall devdetails(int a1, int a2, int a3, int a4);
int __fastcall pgacount(int a1, int a2, int a3, int a4);
int __fastcall noncenum(int a1, int a2, int a3, int a4);
int __fastcall minerconfig(int a1, int a2, int a3, int a4);
int __fastcall apiversion(int a1, int a2, int a3, int a4);
int __fastcall minecoin(int a1, int a2, int a3, int a4);
int __fastcall poolstatus(int a1, int a2, int a3, int a4);
int __fastcall lcddisplay(int a1, int a2, int a3, int a4);
int __fastcall itemstats_isra_17(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6);
int __fastcall minerestats(int a1, int a2, int a3, int a4);
int __fastcall minerstats(int a1, int a2, int a3, int a4);
_DWORD *__fastcall api_add_escape(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_string(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_const(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_uint8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_int16(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_uint16(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_int(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_uint(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_uint32(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_hex32(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_uint64(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_int64(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_double(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_elapsed(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_bool(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_timeval(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_time(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_mhs(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_mhtotal(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_temp(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_utility(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_freq(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_volts(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_hs(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_diff(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_percent(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall api_add_avg(_DWORD *a1, const char *a2, const char *a3, char a4);
void getAVGhashrate();
void __fastcall summary_stub(_DWORD **a1);
int __fastcall summary(int a1, int a2, int a3, int a4);
int __fastcall notifystatus(unsigned int *a1, int a2, int a3, int a4);
int __fastcall notify(int a1, int a2, int a3, int a4);
int mcast_init();
__int64 reCalculateAVG();
void api();
int __fastcall set_balance(_DWORD *a1);
int __fastcall set_loadbalance(_DWORD *a1);
int __fastcall set_rr(_DWORD *a1);
int __fastcall enable_debug(_BYTE *a1);
int noop_get_statline(); // weak
__int64 noop_can_limit_work();
int noop_thread_init();
int noop_prepare_work();
int noop_detect(); // weak
int noop_get_api_stats();
int noop_hash_work(); // weak
int __fastcall generic_zero_stats(int result);
int should_run();
void __fastcall thread_reportout(thr_info *thr);
void __fastcall benchfile_dspwork(unsigned __int8 *a1, unsigned int a2);
int __fastcall suffix_string(unsigned __int64 a1, char *s, size_t maxlen, int a4);
int __fastcall calc_diff(int a1);
int __fastcall set_logfile_path(int a1);
int __fastcall set_logwork_asicnum(int a1);
int __fastcall set_logwork_path(int a1);
int __fastcall set_logfile_openflag(int a1);
int __fastcall set_version_path(int a1);
int __fastcall set_default_config(int a1);
int __fastcall set_sharelog(int a1);
_BYTE *__fastcall json_escape(const char *a1);
void __fastcall get_benchmark_work(int a1);
int *__fastcall regen_hash(int a1);
void __fastcall calc_midstate(int a1);
int submit_work_thread();
int __fastcall miner_thread(_DWORD *a1);
void __noreturn killall_thread();
void __noreturn applog_and_exit(const char *a1, ...);
void __fastcall __noreturn opt_verusage_and_exit(char *a1);
int __fastcall pool_unusable_part_4(unsigned __int8 *a1);
int __fastcall select_balanced(int a1);
int __fastcall priority_pool_part_9(int a1);
int __fastcall priority_pool(int a1);
int __fastcall new_nonce_isra_10(_DWORD *a1, int a2);
char *__fastcall set_float_100_to_250(const char *a1, float *a2);
char *__fastcall set_float_125_to_500(const char *a1, float *a2);
int __fastcall mt_disable_isra_16(int a1, int a2, int (__fastcall **a3)(int));
void set_lowprio_part_17();
void set_lowprio();
int __fastcall api_thread(int a1);
char *__fastcall load_config(char *a1);
char *__fastcall parse_config(_DWORD *a1, int a2);
char *__fastcall set_int_42_to_65(const char *a1, _DWORD *a2);
char *__fastcall set_int_22_to_55(const char *a1, _DWORD *a2);
char *__fastcall set_int_42_to_85(const char *a1, _DWORD *a2);
char *__fastcall set_int_22_to_75(const char *a1, _DWORD *a2);
char *__fastcall set_int_32_to_63(const char *a1, _DWORD *a2);
char *__fastcall set_int_0_to_4(const char *a1, _DWORD *a2);
char *__fastcall set_int_0_to_200(const char *a1, _DWORD *a2);
char *__fastcall set_int_0_to_7680(const char *a1, _DWORD *a2);
char *__fastcall set_int_1_to_255(const char *a1, _DWORD *a2);
char *__fastcall set_int_0_to_255(const char *a1, _DWORD *a2);
char *__fastcall set_int_0_to_100(const char *a1, _DWORD *a2);
char *__fastcall set_int_1_to_10(const char *a1, _DWORD *a2);
char *__fastcall set_int_0_to_10(const char *a1, _DWORD *a2);
char *__fastcall set_int_1_to_65535(const char *a1, _DWORD *a2);
char *__fastcall set_int_0_to_9999(const char *a1, _DWORD *a2);
char *__fastcall set_rotate(const char *a1);
void __fastcall free_work_part_36(const char *a1, const char *a2, int a3);
double __fastcall decay_time_part_37(double a1);
int __fastcall reinit_device_part_38(int a1);
int blank_get_statline_before(); // weak
int noop_get_stats();
int noop_thread_prepare();
int set_null();
int noop_thread_shutdown(); // weak
int noop_thread_enable(); // weak
int noop_hw_error(); // weak
int noop_reinit_device(); // weak
const char *__fastcall set_sched_start(const char *a1);
const char *__fastcall set_sched_stop(const char *a1);
int __fastcall get_datestamp(char *a1, size_t a2, time_t *a3);
void adjust_quota_gcd();
char *__fastcall set_int_range(const char *a1, _DWORD *a2, int a3, int a4);
int __fastcall get_intrange(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall detect_stratum(int a1, const char *a2);
int __fastcall setup_url(int a1, char *a2);
const char *__fastcall set_temp_cutoff(const char *a1);
void *__fastcall clean_work(void **a1);
char *__fastcall copy_work(int a1, int a2, int a3);
void __fastcall free_work(void ***a1, const char *a2, const char *a3, int a4);
int __fastcall decay_time(double a1);
void __fastcall cgpu_runtime(int a1);
void tsince_restart();
void tsince_update();
_BYTE *__fastcall set_work_ntime(_BYTE *result, unsigned int a2);
unsigned __int64 __fastcall share_ndiff(unsigned __int64 *a1);
void __fastcall discard_work(void ***a1, const char *a2, const char *a3, int a4);
int __fastcall remove_pool(int result);
void __fastcall write_config(FILE *s);
int zero_bestshare();
char *__fastcall default_save_file(char *a1);
void __fastcall set_target(void *a1);
int __fastcall share_work_tdiff(int a1);
bool __fastcall test_nonce(int a1, int a2);
bool __fastcall test_nonce_diff(int a1, int a2);
void __fastcall cg_savelogwork(int a1, unsigned __int8 *a2);
void __fastcall cg_savelogwork_uint32(int a1, int a2);
void __fastcall savelog_nonce(int a1, int a2);
unsigned int __fastcall _add_queued(int a1, int a2);
int __fastcall _find_work_bymidstate(int a1, void *s2, size_t n, const void *a4, int a5, size_t na);
int __fastcall _find_work_byid(int result, int a2);
void __fastcall _work_completed(int a1, _DWORD *a2);
int __fastcall reinit_device(int a1);
void __fastcall __noreturn _quit(int a1, int a2);
void __noreturn kill_work();
void __noreturn sighandler(); // weak
int __fastcall get_statline(char *a1, size_t a2, int a3);
void __noreturn restart_threads_part_59();
int restart_threads();
int __fastcall benchfile_get_work(_BYTE *a1);
int __fastcall get_benchfile_work(int a1);
void __fastcall __noreturn mutex_init_part_42_constprop_67(const char *a1, int a2);
int __fastcall mutex_init_constprop_66(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall __noreturn rwlock_init_part_43_constprop_69(const char *a1, int a2);
int __fastcall rwlock_init_constprop_68(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall cglock_init_constprop_65(int a1, const char *a2, int a3);
void __fastcall __noreturn wr_lock_part_54_constprop_73(const char *a1, int a2);
void __fastcall __noreturn mutex_lock_part_47_constprop_75(const char *a1, int a2);
void __fastcall __noreturn mutex_unlock_noyield_part_48_constprop_77(const char *a1, int a2);
int __fastcall mutex_unlock_constprop_76(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall pool_tset(int a1, _BYTE *a2);
int __fastcall inc_dev_status(int a1, int a2);
int __fastcall pool_tclear(int a1, _BYTE *a2);
int __fastcall pool_active(_DWORD *a1, int a2);
int wake_gws();
int __fastcall restart_wait(int a1, unsigned int a2);
void __fastcall __noreturn rw_unlock_part_40_constprop_79(const char *a1, int a2);
int __fastcall wr_unlock_constprop_78(pthread_rwlock_t *a1, const char *a2, int a3);
int total_work_inc();
int __fastcall roll_work(int a1);
_DWORD *make_work();
_DWORD *__fastcall copy_work_noffset(int a1, int a2);
_DWORD *__fastcall make_clone(int a1);
int __fastcall add_queued(pthread_rwlock_t *a1, int a2);
void __fastcall work_completed(pthread_rwlock_t *a1, void **a2);
_DWORD *__fastcall take_queued_work_bymidstate(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall age_queued_work(pthread_rwlock_t *a1);
void __fastcall __noreturn rd_lock_part_39_constprop_80(const char *a1, int a2);
_DWORD *__fastcall clone_queued_work_byid(pthread_rwlock_t *a1, int a2);
_DWORD *__fastcall clone_queued_work_bymidstate(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall find_queued_work_byid(pthread_rwlock_t *a1, int a2);
int __fastcall find_queued_work_bymidstate(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall get_devices(int a1);
int print_summary();
int __fastcall clean_up(int a1);
void app_restart();
int __fastcall get_thread(int a1);
int __fastcall dev_from_id(int a1);
bool _kill_work_part_41();
bool _kill_work();
void kill_mining();
int current_pool();
int __fastcall inc_work_stats(int a1, int a2, int a3);
int cp_prio();
void __fastcall pool_resus(_DWORD *a1);
void __fastcall stratum_resumed_part_50(_DWORD *a1);
void __fastcall stratum_resumed(int a1);
int __fastcall cnx_needed(int a1);
char *add_pool();
const char *__fastcall set_userpass(char *s);
const char *__fastcall set_user(int a1);
int add_url();
int __fastcall set_url(char *a1);
const char *__fastcall set_quota(const char *a1);
const char *__fastcall set_pass(int a1);
int set_extranonce_subscribe();
int zero_stats();
void __fastcall flush_queue(pthread_rwlock_t *a1);
int __fastcall inc_hw_errors_with_diff(int a1, int a2);
int __fastcall inc_hw_errors(int a1);
unsigned __int64 __fastcall share_diff(int a1);
int __fastcall update_work_stats_isra_55(int *a1, int a2);
int __fastcall submit_nonce_1(int a1, _DWORD *a2, int a3, _DWORD *a4);
void __fastcall clear_pool_work(_DWORD *a1);
int __fastcall switch_pools(int a1);
void __fastcall pool_died(int a1);
void __noreturn watchpool_thread(); // weak
int *__fastcall clear_stratum_shares(int a1);
void __fastcall sharelog(const char *a1, int a2);
int __fastcall hash_pop(int a1);
int __fastcall test_pool_thread(_DWORD *a1);
int __fastcall gen_stratum_work(int a1, int a2);
int __fastcall get_work_by_nonce2(int *a1, int *a2, int a3, int a4, int a5, int a6, unsigned int a7);
int __fastcall stale_work(int a1, unsigned int a2);
void **__fastcall get_work(int a1, void *a2);
void **__fastcall get_queue_work(int a1, pthread_rwlock_t *a2, void *a3);
void **__fastcall _get_queued(int a1);
void **__fastcall get_queued(pthread_rwlock_t *a1);
void discard_stale();
int restart_thread(); // weak
int __fastcall stratum_sthread(_DWORD *a1);
void __fastcall hashmeter(int a1, unsigned __int64 a2);
void __fastcall hash_queued_work(int a1);
void __fastcall hash_driver_work(int a1);
void __fastcall hash_sole_work(int a1);
void __noreturn watchdog_thread(); // weak
int __fastcall test_work_current(int a1);
int __fastcall stratum_rthread(_DWORD *a1);
int __fastcall stage_work(int a1);
void __fastcall submit_work_async(struct timeval *a1);
int __fastcall submit_tested_work(int a1, int a2);
int __fastcall submit_nonce(int a1, int a2, unsigned int a3);
void __fastcall submit_nonce_2(int a1);
int __fastcall submit_nonce_direct(int a1, int a2, int a3);
int __fastcall submit_noffset_nonce(int a1, int a2, void *a3, int a4);
void __fastcall __noreturn quit(int a1);
int are_pools_active();
int __fastcall add_pool_details(int a1, int a2, char *a3, const char *a4, const char *a5);
int __fastcall fill_device_drv(int result);
int __fastcall null_device_drv(int result);
int __fastcall enable_device(pthread_rwlock_t *a1);
int __fastcall add_cgpu(_DWORD *a1);
_BYTE *__fastcall copy_drv(const void *a1);
int setStartTimePoint();
char *read_config(); // idb
int receive_func();
int doTestBoard_isra_0();
int process_config();
int get_works();
int configMiner();
int __fastcall clement_doTestBoard(char a1);
int __fastcall clement_doTestBoardOnce(char a1);
unsigned int __fastcall crc16(unsigned __int8 *a1, int a2);
int bitmain_c5_shutdown();
__int64 __fastcall bitmain_c5_scanhash(void *arg);
int bitmain_c5_reinit_device();
int bitmain_c5_detect();
void __noreturn pic_heart_beat_func();
int __fastcall chainHasDisabledCore_part_5(int a1);
void __fastcall check_chain_part_9(int a1, int a2, int a3, const char *a4);
int GetTotalRate_part_12();
int __fastcall suffix_string_c5_constprop_16(unsigned __int64 a1, char *s, size_t maxlen, int a4);
int __fastcall get_plldata_constprop_17(int a1, _DWORD *a2, __int16 *a3, _DWORD *a4);
int __fastcall rwlock_init_constprop_22(pthread_rwlock_t *a1, int a2);
void __fastcall __noreturn mutex_init_part_3_constprop_28(int a1);
int __fastcall bitmain_scanhash(int *a1);
int __fastcall copy_pool_stratum(int result, int a2);
int __fastcall isDisabledCore(int a1, int a2, int a3);
int hasDisabledCore();
int __fastcall chainHasDisabledCore(int a1);
int __fastcall getMeddleOffsetForTestPatten(int a1);
int isFixedFreqMode();
int isC5_Board();
bool is7007_Board();
int __fastcall CRC16(int a1, int a2);
int __fastcall CRC5(_BYTE *a1, unsigned int a2);
int __fastcall getPICvoltageFromValue(int a1);
int __fastcall getVolValueFromPICvoltage(int a1);
int getVoltageLimitedFromHashrate();
int getBoardVoltageLimitedFromHashrate();
int getFixedFreqVoltageValue();
unsigned int __fastcall getPICChainIndexOffset(int a1, unsigned int *a2, int *a3);
int __fastcall getChainAsicFreqIndex(int a1, int a2);
int get_pic_iic();
int __fastcall set_pic_iic(int a1);
int __fastcall write_pic_iic(int a1, int a2, int a3, char a4, unsigned __int8 a5);
int __fastcall send_pic_command(char a1);
int __fastcall send_data_to_pic_iic(char a1, int a2, unsigned __int8 *a3, int a4);
int __fastcall get_data_from_pic_iic(char a1, int a2, _BYTE *a3, int a4);
int __fastcall send_data_to_pic_flash(char a1, unsigned __int8 *a2);
int __fastcall get_data_from_pic_flash(char a1, _BYTE *a2);
int __fastcall erase_pic_flash(char a1);
int __fastcall set_temperature_offset_value(char a1, unsigned __int8 *a2);
int __fastcall write_data_into_pic_flash(char a1);
int __fastcall jump_to_app_CheckAndRestorePIC_T9_18(int a1);
int reset_iic_pic();
int __fastcall get_pic_iic_flash_addr_pointer(char a1, _BYTE *a2, _BYTE *a3);
int __fastcall set_pic_iic_flash_addr_pointer(int a1, int a2, int a3);
int __fastcall erase_pic_flash_all(int a1);
int __fastcall write_EEPROM_iic(int a1, int a2, int a3, char a4, unsigned __int8 a5);
int __fastcall AT24C02_read_bytes_part_7(int result, _BYTE *a2, char a3, int a4);
int __fastcall get_temperature_offset_value(char a1, _BYTE *a2);
int __fastcall AT24C02_write_one_byte(int a1, unsigned __int8 a2, char a3);
int __fastcall AT24C02_read_one_byte(int a1, char a2);
int __fastcall AT24C02_write_bytes(int result, int a2, char a3, int a4);
int __fastcall AT24C02_read_bytes(int result, _BYTE *a2, char a3, int a4);
int __fastcall read_disabled_cores(char a1, _BYTE *a2);
int __fastcall get_chain_data_file_path(int, char *s); // idb
FILE *__fastcall save_chain_data_to_file(FILE *result, const void *a2, size_t a3);
FILE *__fastcall read_chain_data_from_file(FILE *result, void *a2, size_t a3);
int __fastcall read_freq_badcores(char a1, _BYTE *a2);
int __fastcall save_freq_badcores(char a1, int a2);
int __fastcall AT24C02_save_voltage(char a1, unsigned __int8 a2);
int __fastcall set_Voltage_S9_plus_plus_BM1387_54(int a1, unsigned __int8 a2);
int __fastcall get_pic_voltage(char a1);
int __fastcall get_pll_index_for_lowpower_mode(int a1);
int __fastcall set_voltage_setting_time(char a1, unsigned __int8 *a2);
int __fastcall set_hash_board_id_number(char a1, unsigned __int8 *a2);
int __fastcall get_hash_board_id_number(char a1, _BYTE *a2);
int __fastcall write_host_MAC_and_time(char a1, unsigned __int8 *a2);
int __fastcall enable_pic_dc_dc(char a1);
int enable_pic_dc_dc_all();
int __fastcall getChainPICMagicNumber(int a1);
int __fastcall enable_pic_dac(int a1);
int __fastcall disable_pic_dac(int a1);
bool __fastcall pic_heart_beat_each_chain(char a1);
void check_chain();
unsigned int *check_fan();
unsigned int check_fan_beforeInit();
int __fastcall set_PWM(int a1);
int isTempTooLow();
int CheckChainTempTooLowFlag();
int setChainTempTooLowFlag();
int set_PWM_according_to_temperature();
int __fastcall set_frequency_with_addr_plldatai(int a1, int a2, int a3, int a4);
int __fastcall get_pll_index(int a1);
int __fastcall get_freqvalue_by_index(int a1);
int get_total_rate_from_eeprom();
int GetTotalRate();
int __fastcall GetRealBoardRate(int a1);
int __fastcall GetBoardRate(int a1);
bool isChainEnough();
int __fastcall writeInitLogFile(const char *a1);
int clearInitLogFile();
int __fastcall set_frequency(int a1);
int __fastcall set_frequency_with_addr(int a1, int a2, int a3, int a4);
int clear_nonce_fifo();
int clear_register_value_buf();
void __noreturn get_nonce_and_register();
int __fastcall read_asic_register(int a1, int a2, int a3, int a4);
int __fastcall read_temp(int result, unsigned __int8 a2, int a3, int a4, unsigned __int8 a5, int a6);
unsigned int __fastcall reset_one_hashboard(int a1);
int __fastcall check_asic_reg_oneChain(int a1, int a2);
int __fastcall check_asic_reg_oneChain_test(int a1, int a2);
int __fastcall check_asic_reg_with_addr(int a1, int a2, unsigned __int8 a3);
int __fastcall wait_iic_ok(int a1, unsigned __int8 a2);
int __fastcall check_reg_temp(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6);
int __fastcall calc_offset(int a1, int a2);
int __fastcall get_remote(__int16 a1);
int __fastcall get_local(__int16 a1);
int __fastcall do_calibration_sensor_offset(int a1, int a2, int a3, int a4);
int __fastcall set_baud_with_addr(char a1, int a2, char a3, int a4, int a5, int a6, int a7);
int __fastcall calibration_sensor_offset(int a1, int a2);
FILE *clearTempLogFile();
FILE *__fastcall writeLogFile(const char *a1);
FILE *showAllBadRTInfo();
int __fastcall check_asic_reg(int a1);
int updateLogFile();
FILE *__fastcall saveTestID(int a1);
FILE *readTestID();
int __fastcall fakeMiddleTempFromPCB(int a1);
void __noreturn check_temp_func();
int __fastcall chain_inactive(int a1);
int __fastcall set_address(int a1, int a2, int a3);
int __fastcall calculate_asic_number(int result);
int __fastcall calculate_core_number(int result);
unsigned int __fastcall software_set_address_onChain(unsigned __int8 a1);
unsigned int software_set_address();
int __fastcall set_asic_ticket_mask(unsigned int a1);
int __fastcall set_sno(unsigned int a1);
int __fastcall set_hcnt(unsigned int a1);
int __fastcall set_baud(char a1);
int init_uart_baud();
int __fastcall set_led(int a1);
int change_pic_voltage_old();
int __fastcall get_asic_nonce_num(int a1, int a2, int a3);
size_t __fastcall get_lastn_nonce_num(char *a1, int a2);
bool if_hashrate_ok();
bool if_avg_hash_ok();
int get_runtime_hash_rate();
bool check_hashrate_maybe_ok();
int __fastcall saveRebootTestNum(int a1);
int readRebootTestNum();
int __fastcall saveRestartNum(int a1);
FILE *readRestartNum();
int __fastcall saveRetryFlag(int a1);
FILE *readRetryFlag();
int __fastcall saveTestPattenHighestTemp(int a1);
FILE *readTestPattenHighestTemp();
int __fastcall saveChainTestPattenResult(int a1, int a2);
FILE *__fastcall readChainTestPattenResult(int a1);
int __fastcall down_freq_n_steps(int a1, int *a2, int a3);
void print_freq_table();
int check_avg_rate();
void xadc_check();
void *__fastcall close_bad_core(int a1, char a2);
int __fastcall open_core(char a1);
int __fastcall open_core_one_chain(int a1, char a2);
int bitmain_reinit_test();
int __fastcall open_core_onChain(int a1, int a2, unsigned int a3, char a4);
int __fastcall opencore_onebyone_onChain(int a1);
int __fastcall insert_reg_data(int a1);
int __fastcall getChainAsicNum(int a1);
int __fastcall getChainExistFlag(int a1);
int __fastcall saveSearchFailedFlagInfo(const char *a1);
int ClearWorkFIFOAndResetRegisters();
int is_S9();
int is_S9_plus();
int is_T9_plus();
int is_T9();
int is_S9i();
int is_R4();
int is_S9_Hydro();
int is_S11();
int bitmain_axi_init();
int check_config_file();
int __fastcall slowly_downgrade_voltage(int a1, int a2);
int __fastcall slowly_downgrade_voltage_all_chain(int result);
int set_working_voltage();
int set_higher_voltage();
int init_exist_chain_table();
int __fastcall bitmain_c5_init(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall bitmain_c5_prepare(int a1);
size_t __fastcall parse_job_to_c5(_DWORD *a1, int a2, int a3);
int __fastcall send_job(unsigned __int8 *a1);
int __fastcall bitmain_c5_update(int a1);
int re_send_last_job_part_15();
int re_send_last_job();
int do8xPattenTest();
int doReInitTest();
int __fastcall re_open_core(int a1);
void __noreturn check_system_work(); // weak
int bitmain_core_reInit();
void processTEST();
void __noreturn read_temp_func(); // weak
void __fastcall __noreturn stop_mining(const char *a1);
char *__fastcall remove_dot_char(char *a1);
char *__fastcall add_dot_number(char *a1);
_DWORD *__fastcall get_api_stats_stub(int *a1);
_DWORD *bitmain_api_stats();
bool is_network_error();
int __fastcall dsPIC33EP16GS202_reset_pic_part_0(int a1);
int __fastcall dsPIC33EP16GS202_erase_pic_app_program_part_1(int a1);
int __fastcall dsPIC33EP16GS202_get_pic_sw_version(int a1, _BYTE *a2);
int __fastcall dsPIC33EP16GS202_jump_to_app_from_loader(int a1);
int __fastcall dsPIC33EP16GS202_reset_pic(_DWORD); // weak
int __fastcall dsPIC33EP16GS202_enable_pic_dc_dc(int a1, __int16 a2);
int __fastcall dsPIC33EP16GS202_send_data_to_pic(int a1, unsigned __int8 *a2);
int __fastcall dsPIC33EP16GS202_pic_heart_beat(char a1);
int __fastcall dsPIC33EP16GS202_update_pic_app_program(int a1);
void *__fastcall k_alloc_items(const char **a1, const char *a2, const char *a3, int a4);
_DWORD *__fastcall k_new_store(const char **a1);
_BYTE *__fastcall k_new_list(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8);
int __fastcall k_unlink_head(int a1, const char *a2, const char *a3, int a4);
int __fastcall k_unlink_head_zero(int a1, const char *a2, const char *a3, int a4);
int __fastcall k_unlink_tail(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall k_add_head(int a1, int a2, const char *a3, const char *a4, int a5);
int __fastcall k_add_tail(const char **a1, const char *a2, const char *a3, const char *a4, int a5);
int __fastcall k_insert_before(const char **a1, const char *a2, int a3, const char *a4, const char *a5, int a6);
int __fastcall k_insert_after(const char **a1, const char *a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall k_unlink_item(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall k_list_transfer_to_head(const char **a1, const char **a2, const char *a3, const char *a4, int a5);
const char *__fastcall k_list_transfer_to_tail(const char **a1, int a2, const char *a3, const char *a4, int a5);
int __fastcall k_free_list(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall k_free_store(void *ptr, const char *a2, const char *a3, int a4);
int __fastcall dump_mem(int result, unsigned __int8 *a2, int a3);
void __fastcall applog(int a1, const char *a2, int a3);
int __fastcall mutex_unlock_noyield_constprop_3(int a1);
int mutex_lock_constprop_4();
int __fastcall my_log_curses_part_2(const char *a1, const char *a2, int a3);
void __fastcall simplelog(int a1, const char *a2, int a3);
int check_pool_for_validation();
int check_pool_worker();
_DWORD *__fastcall dupalloc(int a1, int a2);
int __fastcall dupcounters(__int64 a1, _QWORD *a2);
int __fastcall isdupnonce(_DWORD *a1, int a2, int a3);
int __fastcall znyq_set_iic(unsigned int a1, char a2, int a3, int a4, unsigned __int8 a5, unsigned __int8 a6);
int power_check_protocal_type();
__int64 power_init();
int __fastcall sub_417FC(int a1, int a2);
void set_fixed_voltage();
void get_fixed_voltage();
FILE *__fastcall save_power_working_iic_date(char a1);
FILE *__fastcall save_power_max_iic_date(char a1);
unsigned __int8 *__fastcall check_pic_crc(unsigned __int8 *result);
int __fastcall get_power_iic_value_from_voltage(_DWORD *a1);
unsigned __int8 *__fastcall decode_an_voltage_buf(unsigned __int8 *result);
unsigned __int8 *__fastcall dsPIC33EP16GS202_pic_get_an_voltage2(int a1);
void get_avg_voltage();
void set_iic_power_to_working_voltage_part_2();
void get_min_voltage();
int power_off_all_chain();
int power_on_all_chain();
int __fastcall power_set_da_value_simple(unsigned __int8 a1);
bool power_is_support_cmd_package();
int __fastcall power_check_reply(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall power_send_cmd(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int a4);
int __fastcall power_set_da_value(__int16 a1);
int __fastcall power_set_voltage(__int16 a1);
int __fastcall write_iic_of_S9_plus_power(int a1, int a2);
int __fastcall voltage_tunning(int a1, int a2);
int __fastcall set_iic_power_voltage(int a1, int a2);
int set_iic_power_to_working_voltage();
int set_iic_power_to_highest_voltage();
int set_iic_power_to_higher_voltage();
int power_tuning();
int quickly_set_to_working_voltage();
int quickly_set_to_highest_voltage();
int __fastcall sha256_transf(int result, int a2, int a3);
_DWORD *__fastcall sha256_init(_DWORD *result);
void *__fastcall sha256_update(int *a1, const void *a2, size_t n);
int *__fastcall sha256_final(_DWORD *a1, int a2);
int *__fastcall sha256(const void *a1, size_t n, int a3);
_DWORD *__fastcall sha2_starts(_DWORD *result);
int __fastcall sha2_process(_DWORD *a1, int a2);
unsigned int *__fastcall sha2_update(unsigned int *result, void *src, int a3);
unsigned int *__fastcall sha2_finish(int a1, _BYTE *a2);
unsigned int *__fastcall sha2(void *src, int a2, _BYTE *a3);
int no_yield();
int __fastcall _stratum_send(int a1, char *a2, int a3);
int __fastcall http_negotiate(const char **a1, int a2, int a3);
int __fastcall _suspend_stratum(int a1);
int __fastcall block_socket(int a1);
bool __fastcall socket_full_isra_2(int a1, int a2);
_DWORD *__fastcall _json_array_string(_DWORD *a1, unsigned int a2);
char *__fastcall json_array_string(_DWORD *a1, unsigned int a2);
void __fastcall process_version_mask_part_6(int a1);
void __fastcall process_version_mask(int a1, char *nptr);
void __fastcall __noreturn cgsem_post_part_7(const void *a1, const char *a2, const char *a3, int a4);
int __fastcall valid_hex_constprop_10(const char *a1, int a2, int a3);
int __fastcall wr_lock_constprop_12(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall rw_unlock_constprop_14(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall mutex_unlock_noyield_constprop_15(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall __noreturn mutex_lock_part_1_constprop_16(const char *a1, int a2);
int __fastcall clear_sock(int a1);
int __fastcall tq_freezethaw(int a1, char a2);
void *__fastcall cgmalloc(unsigned int a1, const char *a2, const char *a3, int a4);
void *__fastcall cgcalloc(size_t a1, unsigned int a2, const char *a3, const char *a4, int a5);
void *__fastcall cgrealloc(void *a1, unsigned int a2, const char *a3, const char *a4, int a5);
char *__fastcall proxytype(char *a1);
_BYTE *__fastcall _bin2hex(_BYTE *result, unsigned __int8 *a2, int a3);
_BYTE *__fastcall bin2hex(unsigned __int8 *a1, int a2);
bool __fastcall hex2bin(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall b58tobin(_BYTE *a1, char *s);
int __fastcall ser_number(int a1, int a2);
int __fastcall fulltest(unsigned int *a1, unsigned int *a2);
thread_q *tq_new(); // idb
void __fastcall tq_free(char *a1);
int __fastcall tq_freeze(int a1);
int __fastcall tq_thaw(int a1);
int __fastcall tq_push(int a1, int a2);
int __fastcall tq_pop(int a1, const struct timespec *a2);
int __fastcall thr_info_cancel(int result);
int __fastcall subtime(int *a1, _DWORD *a2);
int __fastcall addtime(int *a1, _DWORD *a2);
bool __fastcall time_more(_DWORD *a1, _DWORD *a2);
bool __fastcall time_less(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall timespec_to_val(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall timeval_to_spec(_DWORD *result, _DWORD *a2);
int __fastcall us_to_timeval(_DWORD *a1);
int __fastcall us_to_timespec(_DWORD *a1);
int __fastcall ms_to_timespec(_DWORD *a1);
int __fastcall ms_to_timeval(_DWORD *a1);
int *__fastcall timeraddspec(int *result, int *a2);
const char *__fastcall Strcasestr(const char *a1, const char *a2);
const char *__fastcall Strsep(const char **a1, const char *a2);
int __fastcall cgtime(struct timeval *a1);
int __fastcall cgtimer_to_ms(_DWORD *a1);
int __fastcall cgtimer_sub(_DWORD *a1, int *a2, _DWORD *a3);
int __fastcall cgtimer_time(struct timespec *tp); // idb
int __fastcall cgsleep_ms_r(_DWORD *a1);
int __fastcall cgsleep_us_r(_DWORD *a1);
int cgsleep_ms();
int cgsleep_us();
_DWORD *__fastcall us_tdiff(_DWORD *result, _DWORD *a2);
void *__fastcall ms_tdiff(_DWORD *a1, _DWORD *a2);
void tdiff();
int __fastcall extract_sockaddr(const char *a1, _DWORD *a2, char **a3);
char *__fastcall get_proxy(char *s1, int a2);
bool __fastcall sock_full(int a1);
void **__fastcall recalloc(void **result, unsigned int a2, unsigned int a3, const char *a4, const char *a5, int a6);
int __fastcall real_mask(unsigned int a1, int a2);
int __fastcall parse_version_rolling_mask(int a1, int a2);
int __fastcall suspend_stratum(int a1);
int __fastcall stratum_send(int a1, char *a2, int a3);
char *__fastcall recv_line(int a1);
time_t __fastcall dev_error(_DWORD *a1, int a2);
char *__fastcall realloc_strcat(char *a1, char *s);
char *__fastcall str_text(char *s);
int __fastcall RenameThread(const char *a1);
int __fastcall cgsem_init(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall thr_info_create(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall cgsem_post(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall completion_thread(int a1);
int __fastcall cgsem_wait(sem_t *sem, const char *a2, const char *a3, int a4);
int __fastcall cgsem_mswait(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
int *__fastcall cgsem_reset(sem_t *sem);
bool __fastcall cg_completion_timeout(int a1, int a2, int a3);
void __fastcall cg_memcpy(void *a1, const void *a2, size_t a3, int a4, int a5, int a6);
void __fastcall address_to_pubkeyhash(_BYTE *a1, char *a2);
_BYTE *__fastcall ser_string(const char *a1, _DWORD *a2);
void __fastcall copy_time(timeval *dest, const timeval *src);
_DWORD *__fastcall parse_notify(int a1, _DWORD *a2);
int __fastcall socks4_negotiate(const char **a1, int a2, int a3);
int __fastcall setup_stratum_socket(int a1);
int __fastcall config_asicboost(int a1);
int __fastcall initiate_stratum(_DWORD *a1);
int __fastcall restart_stratum(int a1);
int __fastcall parse_reconnect(_DWORD *a1, _DWORD *a2);
int __fastcall parse_method(_DWORD *a1, int a2);
int __fastcall subscribe_extranonce(_DWORD *a1);
int __fastcall auth_stratum(_DWORD *a1);
int __fastcall cg_timeval_subtract(_DWORD *a1, int *a2, int *a3);
char *__fastcall rev(char *result, int a2);
int __fastcall check_asicnum(int a1, char a2);
void __fastcall cg_logwork(int a1, unsigned __int8 *a2, int a3);
void __fastcall cg_logwork_uint32(int a1, int a2, int a3);
int __fastcall conv_voltage(int result);
int __fastcall conv_voltage_ext_ch(int result);
int __fastcall conv_temperature(int result);
int __fastcall get_iio_node(int a1, int a2);
int __fastcall write_log_file(const char *a1, const char *a2);
int __fastcall check_voltage(int result, int a2);
int __fastcall process_true_data(int result, int a2);
int __fastcall get_work_nonce2_part_1(_DWORD *a1);
int __fastcall read_fpga_id(char *a1);
int get_iic();
int __fastcall set_iic(int a1);
int get_nonce2_and_job_id_store_address();
int __fastcall set_nonce2_and_job_id_store_address(int a1);
int get_job_start_address();
int __fastcall set_job_start_address(int a1);
int __fastcall set_bmc_counter(int result);
int read_bmc_counter();
int get_QN_write_data_command();
int __fastcall set_QN_write_data_command(int a1);
int __fastcall set_reset_hashboard(char a1, int a2);
int __fastcall set_reset_allhashboard(int result);
int __fastcall znyq7010_axi_init(_DWORD *a1);
int znyq7010_axi_Reinit();
int znyq7010_axi_close();
int get_fan_control();
int __fastcall set_fan_control(int a1);
int get_hash_on_plug();
int get_crc_count();
int __fastcall reset_crc_count(int result);
int get_hardware_version();
int __fastcall set_Hardware_version(int result);
int __fastcall get_fan_speed(unsigned __int8 *a1, _DWORD *a2);
int get_temperature_0_3();
int get_temperature_4_7();
int get_temperature_8_11();
int get_temperature_12_15();
int get_time_out_control();
int __fastcall set_time_out_control(int a1);
int __fastcall get_BC_command_buffer(_DWORD *a1);
int __fastcall set_BC_command_buffer(_DWORD *a1);
int get_nonce_number_in_fifo();
int __fastcall get_return_nonce(_DWORD *a1);
int get_BC_write_command();
int __fastcall set_BC_write_command(int a1);
int get_ticket_mask();
int __fastcall set_ticket_mask(int a1);
int get_job_id();
int __fastcall set_job_id(int a1);
int get_job_length();
int __fastcall set_job_length(int a1);
int get_block_header_version();
int __fastcall set_block_header_version(int a1);
int get_block_header_version0_ab();
int __fastcall set_block_header_version0_ab(int a1);
int get_block_header_version1_ab();
int __fastcall set_block_header_version1_ab(int a1);
int get_block_header_version2_ab();
int __fastcall set_block_header_version2_ab(int a1);
int get_block_header_version3_ab();
int __fastcall set_block_header_version3_ab(int a1);
int get_time_stamp();
int __fastcall set_time_stamp(int a1);
int get_target_bits();
int __fastcall set_target_bits(int a1);
int __fastcall get_pre_header_hash(_DWORD *a1);
_DWORD *__fastcall set_pre_header_hash(_DWORD *result);
int get_coinbase_length_and_nonce2_length();
int __fastcall set_coinbase_length_and_nonce2_length(int a1);
int __fastcall get_work_nonce2(_DWORD *a1);
_DWORD *__fastcall set_work_nonce2(_DWORD *result);
int get_merkle_bin_number();
int __fastcall set_merkle_bin_number(unsigned __int16 a1);
int get_nonce_fifo_interrupt();
int __fastcall set_nonce_fifo_interrupt(int a1);
int get_dhash_acc_control();
int __fastcall set_dhash_acc_control(int a1);
int __fastcall set_TW_write_command(int a1);
int __fastcall set_TW_write_command_vil(_DWORD *a1);
int get_buffer_space();
int get_hash_counting_number();
int __fastcall set_hash_counting_number(int a1);
int __fastcall T9_plus_write_pic_iic(int a1, int a2, int a3, char a4, unsigned __int8 a5);
char *__fastcall arg_bad(const char *a1, const char *a2);
int __fastcall opt_set_bool(_BYTE *a1);
int __fastcall opt_set_false(_BYTE *a1);
int __fastcall opt_set_invbool(_BYTE *a1);
unsigned __int8 *__fastcall opt_set_bool_arg(const unsigned __int8 *a1, _BYTE *a2);
unsigned __int8 *__fastcall opt_set_invbool_arg(const unsigned __int8 *a1, _BYTE *a2);
int __fastcall opt_set_charp(int a1, _DWORD *a2);
char *__fastcall opt_set_floatval(const char *a1, _DWORD *a2);
char *__fastcall opt_set_longval(const char *a1, int *a2);
char *__fastcall opt_set_intval(const char *a1, _DWORD *a2);
char *__fastcall opt_set_uintval(const char *a1, _DWORD *a2);
char *__fastcall opt_set_ulongval(const char *a1, _DWORD *a2);
int __fastcall opt_inc_intval(_DWORD *a1);
void __fastcall __noreturn opt_version_and_exit(const char *a1);
unsigned __int8 *__fastcall opt_usage_and_exit(const unsigned __int8 *extra);
char *__fastcall opt_show_bool(char *a1, unsigned __int8 *a2);
char *__fastcall opt_show_invbool(char *a1, unsigned __int8 *a2);
char *__fastcall opt_show_charp(_BYTE *a1, const char **a2);
int __fastcall opt_show_intval(char *a1, _DWORD *a2);
int __fastcall opt_show_floatval(char *a1, float *a2);
int __fastcall opt_show_uintval(char *a1, _DWORD *a2);
int __fastcall opt_show_longval(char *a1, _DWORD *a2);
int __fastcall opt_show_ulongval(char *a1, _DWORD *a2);
int __fastcall next_name(int a1, int *a2);
int __fastcall first_opt(unsigned int *a1, _DWORD *a2);
int __fastcall next_opt(int a1, unsigned int *a2, int *a3);
_BYTE *__fastcall check_opt(const char **a1);
int __fastcall add_opt(int *a1);
_BYTE *__fastcall first_lopt(unsigned int *a1, _DWORD *a2);
_BYTE *__fastcall next_lopt(int a1, unsigned int *a2, int *a3);
_BYTE *__fastcall first_sopt(unsigned int *a1);
_BYTE *__fastcall next_sopt(int a1, unsigned int *a2);
int __fastcall opt_register(const char *a1, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6, const char *a7);
int __fastcall opt_register_table(int result, int a2);
bool __fastcall opt_parse(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void opt_free_table();
void opt_log_stderr(const unsigned __int8 *fmt, ...);
void __noreturn opt_log_stderr_exit(const char *a1, ...);
unsigned __int8 *__fastcall opt_invalid_argument(const unsigned __int8 *arg);
void *__fastcall consume_option(_DWORD *a1, int a2, int a3);
int __fastcall parse_one(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall opt_usage(const char *a1, char *a2);
int __fastcall dump_to_strbuffer(void *src, size_t n, const void **a3);
size_t __fastcall dump_to_file(const void *a1, size_t a2, FILE *s);
int __fastcall compare_keys(const char **a1, const char **a2);
int __fastcall dump_string(char *a1, int a2, int (__fastcall *a3)(char *, int, int), int a4, unsigned int a5);
int __fastcall dump_indent(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall do_dump(_DWORD *a1, unsigned int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, __int16 a4);
void *__fastcall json_dumps(_DWORD *a1, __int16 a2);
int __fastcall json_dumpf(_DWORD *a1, int a2, __int16 a3);
int __fastcall json_dump_file(_DWORD *a1, char *filename, __int16 a3);
char *__fastcall jsonp_error_set_source_part_0(int a1, char *s);
int __fastcall jsonp_error_init(int a1, char *s);
int __fastcall jsonp_error_set_source(int a1, char *s);
int jsonp_error_set(int result, int a2, int a3, int a4, const char *arg, ...);
int jsonp_error_vset(int, int, int, int, char *format, __gnuc_va_list arg); // idb
int __fastcall hashlittle(unsigned __int8 *a1, unsigned int a2, int a3);
int __fastcall hashtable_find_pair(int a1, int *a2, char *s2, int a4);
int __fastcall hashtable_do_clear(int result);
int __fastcall hashtable_init(_DWORD *a1);
int __fastcall hashtable_close(int a1);
int __fastcall hashtable_set(int *a1, char *s, int a3);
int __fastcall hashtable_get(int, char *s); // idb
int __fastcall hashtable_del(_DWORD *a1, char *s);
int __fastcall hashtable_clear(_DWORD *a1);
int __fastcall hashtable_iter(int a1);
int __fastcall hashtable_iter_at(int, char *s); // idb
int __fastcall hashtable_iter_next(int a1, int a2);
int __fastcall hashtable_iter_key(int a1);
int __fastcall hashtable_iter_value(int a1);
_DWORD *__fastcall hashtable_iter_set(int a1, int a2);
time_t __fastcall json_object_seed(time_t result);
int __fastcall string_get(_DWORD *a1);
int __fastcall buffer_get(_DWORD *a1);
int __fastcall callback_get(_DWORD *a1);
int error_set(int result, _DWORD *a2, const char *a3, ...);
int __fastcall lex_close(int *a1);
int __fastcall decode_unicode_escape(_BYTE *a1);
_DWORD *__fastcall stream_unget(_DWORD *result, int a2);
int __fastcall stream_get_part_3(int a1, int a2);
int __fastcall lex_get_save(int a1, int a2);
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2);
int __fastcall lex_scan(_DWORD *a1, int a2);
_DWORD *__fastcall parse_value(double a1, int a2);
int __fastcall parse_json(_DWORD *a1, unsigned int a2, int a3);
int __fastcall json_loads(int a1, unsigned int a2, int a3);
int __fastcall json_loadb(int a1, int a2, unsigned int a3, int a4);
int __fastcall json_loadf(int a1, unsigned int a2, int a3);
int __fastcall json_load_file(char *a1, unsigned int a2, int a3);
int __fastcall json_load_callback(int a1, int a2, unsigned int a3, int a4);
int __fastcall jsonp_malloc(int result);
int __fastcall jsonp_free(int result);
void *__fastcall jsonp_strndup(const void *a1, size_t a2);
void *__fastcall jsonp_strdup(const char *a1);
int (__fastcall *__fastcall json_set_alloc_funcs(int (__fastcall *result)(_DWORD), int (*a2)(void)))(_DWORD);
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2);
int set_error(int *a1, char *a2, char *format, ...);
unsigned __int8 *__fastcall next_token(_DWORD *a1);
int __fastcall read_string(int a1, size_t **a2, const char *a3, unsigned int *a4, _DWORD *a5);
int __fastcall unpack(double a1, _QWORD ***a2);
_DWORD *__fastcall pack(double a1);
_DWORD *__fastcall json_vpack_ex(int a1, int a2, _BYTE *a3, int a4);
_DWORD *json_pack_ex(int a1, int a2, _BYTE *a3, ...);
_DWORD *json_pack(_BYTE *a1, ...);
int __fastcall json_vunpack_ex(int a1, int a2, int a3, _BYTE *a4, _QWORD **a5);
int json_unpack_ex(int a1, int a2, int a3, _BYTE *a4, ...);
int json_unpack(int a1, _BYTE *a2, ...);
int __fastcall strbuffer_init(_DWORD *a1);
int __fastcall strbuffer_close(int *a1);
int __fastcall strbuffer_clear(int result);
int __fastcall strbuffer_value(int a1);
int __fastcall strbuffer_steal_value(int *a1);
int __fastcall strbuffer_append_bytes(const void **a1, void *src, size_t n);
int __fastcall strbuffer_append_byte(const void **a1, char a2);
int __fastcall strbuffer_pop(int *a1);
int __fastcall jsonp_strtod(int a1, double *a2);
int __fastcall jsonp_dtostr(char *a1, size_t a2, int a3);
int __fastcall utf8_encode(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall utf8_check_first(int a1);
int __fastcall utf8_check_full(char *a1, unsigned int a2, int *a3);
char *__fastcall utf8_iterate(char *result, int a2, _DWORD *a3);
int __fastcall utf8_check_string(int a1, unsigned int a2);
int __fastcall json_integer_copy(int a1);
void *__fastcall json_array_grow(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall string_create(void *a1, size_t a2, int a3);
int json_object();
_DWORD *__fastcall json_object_size(_DWORD *result);
int __fastcall json_object_get(_DWORD *a1, char *a2);
bool __fastcall json_equal_part_3(int a1, int a2);
int __fastcall json_object_del(_DWORD *a1, char *a2);
int __fastcall json_object_clear(_DWORD *a1);
int __fastcall json_object_iter(_DWORD *a1);
int __fastcall json_object_iter_at(_DWORD *a1, char *a2);
int __fastcall json_object_iter_next(_DWORD *a1, int a2);
int __fastcall json_object_iter_key(int a1);
int __fastcall json_object_iter_value(int a1);
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, int a3);
int __fastcall json_object_key_to_iter(int result);
_DWORD *json_array();
_DWORD *__fastcall json_array_size(_DWORD *result);
_DWORD *__fastcall json_array_get(_DWORD *result, unsigned int a2);
int __fastcall json_array_extend(_DWORD *a1, _DWORD *a2);
const char *__fastcall json_string_nocheck(const char *result);
_DWORD *__fastcall json_stringn_nocheck(void *a1, size_t a2);
_DWORD *__fastcall jsonp_stringn_nocheck_own(void *a1, size_t a2);
_DWORD *__fastcall json_stringn(void *a1, size_t a2);
const char *__fastcall json_string(const char *result);
_DWORD *__fastcall json_string_value(_DWORD *result);
_DWORD *__fastcall json_string_length(_DWORD *result);
int __fastcall json_string_setn_nocheck(_DWORD *a1, const void *a2, size_t a3);
int __fastcall json_string_set_nocheck(_DWORD *a1, char *s);
int __fastcall json_string_setn(_DWORD *a1, const void *a2, size_t a3);
int __fastcall json_string_set(_DWORD *a1, char *s);
int __fastcall json_integer(__int64 a1);
__int64 __fastcall json_integer_value(int a1);
int __fastcall json_integer_set(int a1, __int64 a2);
int __fastcall json_real(double a1);
void json_real_value();
int __fastcall json_real_set(double a1);
int __fastcall json_number_value(double a1);
void *json_true();
void *json_false();
void *json_null();
_DWORD *__fastcall json_delete(_DWORD *result);
int __fastcall json_array_clear(_DWORD *a1);
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2);
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, _DWORD *a3);
int __fastcall json_array_insert_new(_DWORD *a1, unsigned int a2, _DWORD *a3);
int __fastcall json_object_set_new_nocheck(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall json_object_update(_DWORD *a1, _DWORD *a2);
int __fastcall json_object_update_existing(_DWORD *a1, _DWORD *a2);
int __fastcall json_object_update_missing(_DWORD *a1, _DWORD *a2);
int __fastcall json_object_set_new(_DWORD *a1, char *s, _DWORD *a3);
int __fastcall json_array_append_new(_DWORD *a1, _DWORD *a2);
bool __fastcall json_equal(int a1, int a2);
int __fastcall json_copy(double a1);
int __fastcall json_deep_copy(double a1);
unsigned int __fastcall rpl_memchr(unsigned int result, unsigned __int8 a2, unsigned int a3);
unsigned int __fastcall critical_factorization_part_0(int a1, unsigned int a2, int *a3);
int __fastcall two_way_long_needle(int a1, int a2, void *s1, unsigned int a4);
int __fastcall memmem(unsigned int a1, unsigned int a2, _BYTE *a3, unsigned int a4);
int __fastcall uncompress(int a1, int *a2, unsigned int a3, int a4);
int __fastcall updatewindow(int, int, size_t n); // idb
int __fastcall inflateResetKeep(_DWORD *a1);
int __fastcall inflateReset(_DWORD *a1);
int __fastcall inflateReset2(int a1, int a2);
int __fastcall inflateInit2_(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __fastcall inflateInit_(_DWORD *a1, _BYTE *a2, int a3);
int __fastcall inflatePrime(int a1, int a2, int a3);
int __fastcall inflate(unsigned int *a1, int a2);
int __fastcall inflateEnd(_DWORD *a1);
int __fastcall inflateGetDictionary(int a1, void *dest, _DWORD *a3);
int __fastcall inflateSetDictionary(int a1, unsigned __int8 *a2, size_t n);
int __fastcall inflateGetHeader(int a1, int a2);
int __fastcall inflateSync(int *a1);
int __fastcall inflateSyncPoint(int a1);
int __fastcall inflateCopy(_DWORD *a1, int *a2);
int __fastcall inflateUndermine(int a1);
int __fastcall inflateMark(int a1);
int __fastcall inflate_table(int a1, int a2, unsigned int a3, int *a4, unsigned int *a5, void **a6);
const char *zlibVersion();
int zlibCompileFlags();
char *__fastcall zError(int a1);
void *__fastcall zcalloc(int a1, int a2, int a3);
void __fastcall zcfree(int a1, void *ptr);
int __fastcall adler32(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall adler32_combine(unsigned int a1, unsigned int a2, int a3);
int __fastcall adler32_combine64(unsigned int a1, unsigned int a2, __int64 a3);
int __fastcall crc32_combine_(int result, int a2, __int64 a3);
void *get_crc_table();
int __fastcall crc32(int a1, char *a2, unsigned int a3);
int __fastcall crc32_combine(int a1, int a2, int a3);
int __fastcall inflate_fast(unsigned int *a1, int a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2);
int _aeabi_ldiv0();
UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp);
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp);
void _libc_csu_fini(); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_12B3E; // weak
_UNKNOWN loc_1869E; // weak
_UNKNOWN loc_30D40; // weak
_UNKNOWN loc_3E3B0; // weak
_UNKNOWN loc_3E3B8; // weak
_UNKNOWN loc_40040; // weak
_UNKNOWN loc_57068; // weak
char _func___14516[12] = "json_escape"; // weak
_DWORD benchfile_data[10] = { 1, 394184, 64, 394192, 64, 394204, 8, 394216, 10, 379600 }; // weak
char bench_hidiffs[321] = "000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4"; // weak
char bench_lodiffs[321] = "00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f"; // weak
_UNKNOWN unk_5CB68; // weak
const char a02d02d02d03d[] = "[%02d:%02d:%02d.%03d"; // idb
__int16 word_5E060 = 93; // weak
__int16 word_603C4 = 48; // weak
char _PRETTY_FUNCTION___14958[18] = "bitmain_c5_detect"; // weak
char *off_60FF8 = "125"; // weak
char fan_spend_temp_arg[2] = "d"; // weak
_UNKNOWN sha2_padding; // weak
_DWORD hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char *proxynames = "http:"; // weak
_UNKNOWN unk_67614; // weak
const char aIdDMethodMinin_6[] = "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"bmminer/2.0.0\"]"; // idb
__int16 word_67AC8 = 125; // weak
char *type_names = "object"; // weak
void *distfix_6142 = (void *)0x10510; // weak
__int16 order_6170[7] = { 16, 17, 18, 0, 8, 7, 9 }; // weak
_UNKNOWN unk_6A91E; // weak
_UNKNOWN unk_6A934; // weak
_UNKNOWN unk_6A950; // weak
_UNKNOWN unk_6A95E; // weak
void *dext_6056 = &unk_100010; // weak
_UNKNOWN dbase_6055; // weak
char *z_errmsg[2] = { "need dictionary", "stream end" }; // weak
_DWORD crc_table[2048] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  0,
  421212481,
  842424962,
  724390851,
  1684849924,
  2105013317,
  1448781702,
  1329698503,
  -925267448,
  -775767223,
  -84940662,
  -470492725,
  -1397403892,
  -1246855603,
  -1635570290,
  -2020074289,
  1254232657,
  1406739216,
  2029285587,
  1643069842,
  783210325,
  934667796,
  479770071,
  92505238,
  -2112120743,
  -1694455528,
  -1339163941,
  -1456026726,
  -428384931,
  -9671652,
  -733921313,
  -849736034,
  -1786501982,
  -1935731229,
  -1481488864,
  -1096190111,
  -236396122,
  -386674457,
  -1008827612,
  -624577947,
  1566420650,
  1145479147,
  1869335592,
  1987116393,
  959540142,
  539646703,
  185010476,
  303839341,
  -549046541,
  -966981710,
  -311405455,
  -194288336,
  -1154812937,
  -1573797194,
  -1994616459,
  -1878548428,
  396344571,
  243568058,
  631889529,
  1018359608,
  1945336319,
  1793607870,
  1103436669,
  1490954812,
  -260485371,
  -379421116,
  -1034998393,
  -615244602,
  -1810527743,
  -1928414400,
  -1507596157,
  -1086793278,
  950060301,
  565965900,
  177645455,
  328046286,
  1556873225,
  1171730760,
  1861902987,
  2011255754,
  -1162125996,
  -1549767659,
  -2004009002,
  -1852436841,
  -556296112,
  -942888687,
  -320734510,
  -168113261,
  1919080284,
  1803150877,
  1079293406,
  1498383519,
  370020952,
  253043481,
  607678682,
  1025720731,
  1711106983,
  2095471334,
  1472923941,
  1322268772,
  26324643,
  411738082,
  866634785,
  717028704,
  -1390091857,
  -1270886162,
  -1626176723,
  -2046184852,
  -918018901,
  -799861270,
  -75610583,
  -496666776,
  792689142,
  908347575,
  487136116,
  68299317,
  1263779058,
  1380486579,
  2036719216,
  1618931505,
  -404294658,
  -16923969,
  -707751556,
  -859070403,
  -2088093958,
  -1701771333,
  -1313057672,
  -1465424583,
  998479947,
  580430090,
  162921161,
  279890824,
  1609522511,
  1190423566,
  1842954189,
  1958874764,
  -212200893,
  -364829950,
  -1049857855,
  -663273088,
  -1758013625,
  -1909594618,
  -1526680123,
  -1139047292,
  1900120602,
  1750776667,
  1131931800,
  1517083097,
  355290910,
  204897887,
  656092572,
  1040194781,
  -1181220846,
  -1602014893,
  -1951505776,
  -1833610287,
  -571161322,
  -990907305,
  -272455788,
  -153512235,
  -1375224599,
  -1222865496,
  -1674453397,
  -2060783830,
  -898926099,
  -747616084,
  -128115857,
  -515495378,
  1725839073,
  2143618976,
  1424512099,
  1307796770,
  45282277,
  464110244,
  813994343,
  698327078,
  -456806728,
  -35741703,
  -688665542,
  -806814341,
  -2136380484,
  -1716364547,
  -1298200258,
  -1417398145,
  740041904,
  889656817,
  506086962,
  120682355,
  1215357364,
  1366020341,
  2051441462,
  1667084919,
  -872753330,
  -756947441,
  -104024628,
  -522746739,
  -1349119414,
  -1232264437,
  -1650429752,
  -2068102775,
  52649286,
  439905287,
  823476164,
  672009861,
  1733269570,
  2119477507,
  1434057408,
  1281543041,
  -2126985953,
  -1742474146,
  -1290885219,
  -1441425700,
  -447479781,
  -61918886,
  -681418087,
  -830909480,
  1239502615,
  1358593622,
  2077699477,
  1657543892,
  764250643,
  882293586,
  532408465,
  111204816,
  1585378284,
  1197851309,
  1816695150,
  1968414767,
  974272232,
  587794345,
  136598634,
  289367339,
  -1767409180,
  -1883486043,
  -1533994138,
  -1115018713,
  -221528864,
  -338653791,
  -1057104286,
  -639176925,
  347922877,
  229101820,
  646611775,
  1066513022,
  1892689081,
  1774917112,
  1122387515,
  1543337850,
  -597333067,
  -981574924,
  -296548041,
  -146261898,
  -1207325007,
  -1592614928,
  -1975530445,
  -1826292366,
  0,
  29518391,
  59036782,
  38190681,
  118073564,
  114017003,
  76381362,
  89069189,
  236147128,
  265370511,
  228034006,
  206958561,
  152762724,
  148411219,
  178138378,
  190596925,
  472294256,
  501532999,
  530741022,
  509615401,
  456068012,
  451764635,
  413917122,
  426358261,
  305525448,
  334993663,
  296822438,
  275991697,
  356276756,
  352202787,
  381193850,
  393929805,
  944588512,
  965684439,
  1003065998,
  973863097,
  1061482044,
  1049003019,
  1019230802,
  1023561829,
  912136024,
  933002607,
  903529270,
  874031361,
  827834244,
  815125939,
  852716522,
  856752605,
  611050896,
  631869351,
  669987326,
  640506825,
  593644876,
  580921211,
  551983394,
  556069653,
  712553512,
  733666847,
  704405574,
  675154545,
  762387700,
  749958851,
  787859610,
  792175277,
  1889177024,
  1901651959,
  1931368878,
  1927033753,
  2006131996,
  1985040171,
  1947726194,
  1976933189,
  2122964088,
  2135668303,
  2098006038,
  2093965857,
  2038461604,
  2017599123,
  2047123658,
  2076625661,
  1824272048,
  1836991623,
  1866005214,
  1861914857,
  1807058540,
  1786244187,
  1748062722,
  1777547317,
  1655668488,
  1668093247,
  1630251878,
  1625932113,
  1705433044,
  1684323811,
  1713505210,
  1742760333,
  1222101792,
  1226154263,
  1263738702,
  1251046777,
  1339974652,
  1310460363,
  1281013650,
  1301863845,
  1187289752,
  1191637167,
  1161842422,
  1149379777,
  1103966788,
  1074747507,
  1112139306,
  1133218845,
  1425107024,
  1429406311,
  1467333694,
  1454888457,
  1408811148,
  1379576507,
  1350309090,
  1371438805,
  1524775400,
  1528845279,
  1499917702,
  1487177649,
  1575719220,
  1546255107,
  1584350554,
  1605185389,
  -516613248,
  -520654409,
  -491663378,
  -478960167,
  -432229540,
  -402728597,
  -440899790,
  -461763323,
  -282703304,
  -287039473,
  -324886954,
  -312413087,
  -399514908,
  -370308909,
  -341100918,
  -362193731,
  -49039120,
  -53357881,
  -23630690,
  -11204951,
  -98955220,
  -69699045,
  -107035582,
  -128143755,
  -218044088,
  -222133377,
  -259769050,
  -247048431,
  -200719980,
  -171234397,
  -141715974,
  -162529331,
  -646423200,
  -658884777,
  -620984050,
  -616635591,
  -562956868,
  -541876341,
  -571137582,
  -600355867,
  -680850216,
  -693541137,
  -722478922,
  -718425471,
  -798841852,
  -777990605,
  -739872662,
  -769385891,
  -983630320,
  -996371417,
  -958780802,
  -954711991,
  -1034463540,
  -1013629701,
  -1043103070,
  -1072568171,
  -884101208,
  -896547425,
  -926319674,
  -922021391,
  -867956876,
  -846828221,
  -809446630,
  -838682323,
  -1850763712,
  -1871840137,
  -1842658770,
  -1813436391,
  -1767489892,
  -1755032405,
  -1792873742,
  -1797226299,
  -1615017992,
  -1635865137,
  -1674046570,
  -1644529247,
  -1732939996,
  -1720253165,
  -1691239606,
  -1695297155,
  -1920387792,
  -1941217529,
  -1911692962,
  -1882223767,
  -1971282452,
  -1958545445,
  -1996207742,
  -2000280651,
  -2087033720,
  -2108158273,
  -2145472282,
  -2116232495,
  -2070688684,
  -2058246557,
  -2028529606,
  -2032831987,
  -1444753248,
  -1474250089,
  -1436154674,
  -1415287047,
  -1360299908,
  -1356262837,
  -1385190382,
  -1397897691,
  -1477345000,
  -1506546897,
  -1535814282,
  -1514717375,
  -1594349116,
  -1590017037,
  -1552089686,
  -1564567651,
  -1245416496,
  -1274668569,
  -1237276738,
  -1216164471,
  -1295131892,
  -1290817221,
  -1320611998,
  -1333041835,
  -1143528856,
  -1173010337,
  -1202457082,
  -1181639631,
  -1126266188,
  -1122180989,
  -1084596518,
  -1097321235,
  0,
  -1195612315,
  -1442199413,
  313896942,
  -1889364137,
  937357362,
  627793884,
  -1646839623,
  -978048785,
  2097696650,
  1874714724,
  -687765759,
  1255587768,
  -227878691,
  -522225869,
  1482887254,
  1343838111,
  -391827206,
  -99573996,
  1118632049,
  -545537848,
  1741137837,
  1970407491,
  -842109146,
  -1783791760,
  756094997,
  1067759611,
  -2028416866,
  449832999,
  -1569484990,
  -1329192788,
  142231497,
  -1607291074,
  412010587,
  171665333,
  -1299775280,
  793786473,
  -1746116852,
  -2057703198,
  1038456711,
  1703315409,
  -583343948,
  -812691622,
  1999841343,
  -354152314,
  1381529571,
  1089329165,
  -128860312,
  -265553759,
  1217896388,
  1512189994,
  -492939441,
  2135519222,
  -940242797,
  -717183107,
  1845280792,
  899665998,
  -1927039189,
  -1617553211,
  657096608,
  -1157806311,
  37822588,
  284462994,
  -1471616777,
  -1693165507,
  598228824,
  824021174,
  -1985873965,
  343330666,
  -1396004849,
  -1098971167,
  113467524,
  1587572946,
  -434366537,
  -190203815,
  1276501820,
  -775755899,
  1769898208,
  2076913422,
  -1015592853,
  -888336478,
  1941006535,
  1627703081,
  -642211764,
  1148164341,
  -53215344,
  -295284610,
  1457141531,
  247015245,
  -1241169880,
  -1531908154,
  470583459,
  -2116308966,
  963106687,
  735213713,
  -1821499404,
  992409347,
  -2087022490,
  -1859174520,
  697522413,
  -1270587308,
  217581361,
  508405983,
  -1494102086,
  -23928852,
  1177467017,
  1419450215,
  -332959742,
  1911572667,
  -917753890,
  -604405712,
  1665525589,
  1799331996,
  -746338311,
  -1053399017,
  2039091058,
  -463652917,
  1558270126,
  1314193216,
  -152528859,
  -1366587277,
  372764438,
  75645176,
  -1136777315,
  568925988,
  -1722451903,
  -1948198993,
  861712586,
  -312887749,
  1441124702,
  1196457648,
  -1304107,
  1648042348,
  -628668919,
  -936187417,
  1888390786,
  686661332,
  -1873675855,
  -2098964897,
  978858298,
  -1483798141,
  523464422,
  226935048,
  -1254447507,
  -1119821404,
  100435649,
  390670639,
  -1342878134,
  841119475,
  -1969352298,
  -1741963656,
  546822429,
  2029308235,
  -1068978642,
  -755170880,
  1782671013,
  -141140452,
  1328167289,
  1570739863,
  -450629134,
  1298864389,
  -170426784,
  -412954226,
  1608431339,
  -1039561134,
  2058742071,
  1744848601,
  -792976964,
  -1998638614,
  811816591,
  584513889,
  -1704288764,
  129869501,
  -1090403880,
  -1380684234,
  352848211,
  494030490,
  -1513215489,
  -1216641519,
  264757620,
  -1844389427,
  715964072,
  941166918,
  -2136639965,
  -658086283,
  1618608400,
  1926213374,
  -898381413,
  1470427426,
  -283601337,
  -38979159,
  1158766284,
  1984818694,
  -823031453,
  -599513459,
  1693991400,
  -114329263,
  1100160564,
  1395044826,
  -342174017,
  -1275476247,
  189112716,
  435162722,
  -1588827897,
  1016811966,
  -2077804837,
  -1768777419,
  774831696,
  643086745,
  -1628905732,
  -1940033262,
  887166583,
  -1456066866,
  294275499,
  54519365,
  -1149009632,
  -471821962,
  1532818963,
  1240029693,
  -246071656,
  1820460577,
  -734109372,
  -963916118,
  2117577167,
  -696303304,
  1858283101,
  2088143283,
  -993333546,
  1495127663,
  -509497078,
  -216785180,
  1269332353,
  332098007,
  -1418260814,
  -1178427044,
  25085497,
  -1666580864,
  605395429,
  916469259,
  -1910746770,
  -2040129881,
  1054503362,
  745528876,
  -1798063799,
  151290352,
  -1313282411,
  -1559410309,
  464596510,
  1137851976,
  -76654291,
  -371460413,
  1365741990,
  -860837601,
  1946996346,
  1723425172,
  -570095887,
  0,
  -1775237257,
  744558318,
  -1169094247,
  432303367,
  -1879807376,
  900031465,
  -1550490466,
  847829774,
  -1531388807,
  518641120,
  -1998990697,
  726447625,
  -1115901570,
  120436967,
  -1860321392,
  1678817053,
  -232738710,
  1215412723,
  -566116732,
  2111101466,
  -337322643,
  1370871028,
  -947530877,
  1452829715,
  -1062704284,
  2063164157,
  -322345590,
  1331429652,
  -647231901,
  1664946170,
  -183695219,
  -937398725,
  1578133836,
  -465477419,
  1920034722,
  -773586116,
  1205077067,
  -41611822,
  1807026853,
  -89606859,
  1821946434,
  -691422245,
  1090108588,
  -479406030,
  1969020741,
  -821176612,
  1497223595,
  -1406084826,
  973135441,
  -2142119992,
  375509183,
  -1242254303,
  600093526,
  -1718240561,
  262520248,
  -1632107992,
  143131999,
  -1294398266,
  619252657,
  -2021888209,
  290220120,
  -1424137791,
  1026385590,
  -1874731914,
  108124929,
  -1138699624,
  705746415,
  -1987726991,
  532002310,
  -1511735393,
  869578984,
  -1563883656,
  888733711,
  -1901590122,
  412618465,
  -1156748673,
  759000328,
  -1754504047,
  22832102,
  -195990677,
  1650551836,
  -667916923,
  1308648178,
  -309000596,
  2074411291,
  -1040971646,
  1472466933,
  -958812059,
  1357494034,
  -356991349,
  2089335292,
  -551690910,
  1227741717,
  -209923188,
  1699534075,
  1482797645,
  -833505990,
  1946205347,
  -500122668,
  1101389642,
  -678045635,
  1841615268,
  -67840301,
  1793681731,
  -52859340,
  1183344557,
  -793222950,
  1932330052,
  -451083469,
  1598818986,
  -914616867,
  1014039888,
  -1438580185,
  269487038,
  -2044719927,
  632645719,
  -1283100896,
  164914873,
  -1612422706,
  251256414,
  -1731602135,
  580440240,
  -1264003129,
  389919577,
  -2129808338,
  995933623,
  -1385383232,
  545503469,
  -1229733990,
  216184323,
  -1697468044,
  961009130,
  -1351101795,
  354867972,
  -2095653773,
  302736355,
  -2076482412,
  1047162125,
  -1470469510,
  198119140,
  -1644230253,
  665714698,
  -1315043459,
  1150488560,
  -761067385,
  1760690462,
  -20838807,
  1566008055,
  -882416256,
  1899392025,
  -419009682,
  1981535486,
  -533998711,
  1518000656,
  -867508889,
  1876933113,
  -101728626,
  1136572183,
  -712069024,
  -391915818,
  2123616673,
  -993863624,
  1391648591,
  -244859951,
  1733803174,
  -586762945,
  1261875784,
  -634712616,
  1276840623,
  -162921674,
  1618609217,
  -1007722273,
  1440704424,
  -275878351,
  2042521926,
  -1934401077,
  444819132,
  -1596821723,
  920807506,
  -1787360052,
  54987707,
  -1189739998,
  791020885,
  -1103381819,
  671858098,
  -1839549397,
  74101596,
  -1476405310,
  835702965,
  -1952523988,
  497999451,
  -1329437541,
  653419500,
  -1667011979,
  177433858,
  -1459222116,
  1060507371,
  -2056845454,
  324468741,
  -2109030507,
  343587042,
  -1372868229,
  941340172,
  -1685138798,
  230610405,
  -1209017220,
  568318731,
  -724380794,
  1122161905,
  -122430104,
  1854134815,
  -854147455,
  1529264630,
  -512249745,
  2001188632,
  -430307192,
  1885999103,
  -902101402,
  1544225041,
  -6396529,
  1773036280,
  -738235551,
  1171221526,
  2028079776,
  -288223785,
  1417872462,
  -1028455623,
  1629906855,
  -149528368,
  1296525641,
  -612929986,
  1248514478,
  -598026535,
  1712054080,
  -264513481,
  1403960489,
  -979452962,
  2144318023,
  -369117904,
  485670333,
  -1966949686,
  814986067,
  -1499220956,
  87478458,
  -1828268083,
  693624404,
  -1083713245,
  779773619,
  -1203084860,
  35350621,
  -1809092822,
  935201716,
  -1584526141,
  467600730,
  -1913716179,
  0,
  1093737241,
  -2107492814,
  -1017959125,
  80047204,
  1173649277,
  -2035852714,
  -946454193,
  143317448,
  1237041873,
  -1964445702,
  -874908445,
  206550444,
  1300147893,
  -1909619810,
  -820209529,
  1360183882,
  270784851,
  -747572104,
  -1841172639,
  1440198190,
  350663991,
  -675964900,
  -1769700603,
  1503140738,
  413728923,
  -604361296,
  -1697958231,
  1566406630,
  476867839,
  -549502508,
  -1643226419,
  -1574665067,
  -485122164,
  541504167,
  1635232190,
  -1495144207,
  -405736472,
  612622019,
  1706214874,
  -1431413411,
  -341883324,
  684485487,
  1778217078,
  -1368706759,
  -279303648,
  738789131,
  1832393746,
  -214546721,
  -1308140090,
  1901359341,
  811953140,
  -135058757,
  -1228787294,
  1972444297,
  882902928,
  -71524585,
  -1165130738,
  2044635429,
  955232828,
  -8785037,
  -1102518166,
  2098971969,
  1009442392,
  89094640,
  1149133545,
  -2027073598,
  -971221797,
  25826708,
  1086000781,
  -2081938522,
  -1025951553,
  231055416,
  1291107105,
  -1884842486,
  -828994285,
  151047260,
  1211225925,
  -1956447634,
  -900472457,
  1415429050,
  359440547,
  -700478072,
  -1760651631,
  1352194014,
  296340679,
  -755310100,
  -1815348491,
  1557619314,
  501643627,
  -558541760,
  -1618718887,
  1477578262,
  421729551,
  -630179804,
  -1690229955,
  -1486095003,
  -430250372,
  621398871,
  1681444942,
  -1548840703,
  -492860904,
  567060275,
  1627241514,
  -1344199507,
  -288342092,
  763564703,
  1823607174,
  -1423685431,
  -367701040,
  692485883,
  1752655330,
  -159826129,
  -1220008906,
  1947928861,
  891949572,
  -222538933,
  -1282586542,
  1893623161,
  837779040,
  -17570073,
  -1077740034,
  2089930965,
  1033948108,
  -97088893,
  -1157131878,
  2018819249,
  962963368,
  1268286267,
  178886690,
  -906316535,
  -1999917552,
  1331556191,
  242021446,
  -851453587,
  -1945189772,
  1125276403,
  35865066,
  -1049596735,
  -2143193128,
  1205286551,
  115748238,
  -977993563,
  -2071716932,
  445268337,
  1539005032,
  -1729595581,
  -640062374,
  508505365,
  1602106892,
  -1674765529,
  -585367490,
  302028985,
  1395753888,
  -1872580981,
  -783043182,
  382072029,
  1475669956,
  -1800944913,
  -711534090,
  -373553234,
  -1467147081,
  1809723804,
  720317061,
  -310809654,
  -1404538669,
  1864064504,
  774522593,
  -516497818,
  -1610103425,
  1666508884,
  577106765,
  -437014014,
  -1530746597,
  1737589808,
  648060713,
  -1196505628,
  -106963203,
  986510294,
  2080237775,
  -1133794944,
  -44387687,
  1040818098,
  2134410411,
  -1339810772,
  -250280139,
  843459102,
  1937191175,
  -1260294072,
  -170890415,
  914572922,
  2008178019,
  1322777291,
  266789330,
  -860500743,
  -1920673824,
  1242732207,
  186879414,
  -932142947,
  -1992180860,
  1180508931,
  124532762,
  -1002498767,
  -2062676440,
  1117278055,
  61428862,
  -1057326763,
  -2117377460,
  533018753,
  1593058200,
  -1649996109,
  -594143830,
  453006565,
  1513181180,
  -1721605417,
  -665617970,
  391110985,
  1451162192,
  -1792157829,
  -736310174,
  327847213,
  1388025396,
  -1847018721,
  -791044090,
  -319586722,
  -1379769017,
  1855015020,
  799036277,
  -399109574,
  -1459156701,
  1783899144,
  728055569,
  -461789290,
  -1521959793,
  1713082788,
  657099453,
  -524497934,
  -1584541461,
  1658781120,
  602924761,
  -1109279724,
  -53434611,
  1065585190,
  2125631807,
  -1188769680,
  -132789399,
  994502210,
  2054683995,
  -1251252772,
  -195395899,
  923358190,
  1983400183,
  -1313994312,
  -258010463,
  869023626,
  1929192595,
  0,
  929743361,
  1859421187,
  1505641986,
  -592967417,
  -339555578,
  -1300460284,
  -2062135547,
  -1202646258,
  -1891905265,
  -695888115,
  -504408820,
  1694046729,
  1402198024,
  170761738,
  1028086795,
  1889740316,
  1204413469,
  511156767,
  689791006,
  -1408553189,
  -1688081126,
  -1025529064,
  -172660455,
  -923650798,
  -6752493,
  -1507413743,
  -1857260784,
  341457941,
  590413332,
  2056173590,
  1306819095,
  -532263624,
  -684945607,
  -1902982853,
  -1174926534,
  1022247999,
  193234494,
  1379582012,
  1699742269,
  1477926454,
  1870502967,
  918805045,
  27858996,
  -2067835087,
  -1277848272,
  -362032334,
  -587132621,
  -1864013020,
  -1483757275,
  -30281945,
  -916771546,
  1280139811,
  2066194466,
  580511264,
  368256033,
  682915882,
  534690347,
  1180761129,
  1896496680,
  -199462611,
  -1015631060,
  -1698106066,
  -1381877969,
  -1064461712,
  -135833487,
  -1369891213,
  -1724654478,
  472224631,
  726618486,
  1928402804,
  1167840629,
  2027719038,
  1337346943,
  369626493,
  560123772,
  -1535868807,
  -1826733448,
  -895482758,
  -37042565,
  -1339114388,
  -2025554323,
  -554026897,
  -376374674,
  1820767595,
  1542223722,
  38941032,
  892924777,
  142585698,
  1058368867,
  1722493793,
  1371662688,
  -724064667,
  -474127260,
  -1174199706,
  -1922441113,
  550229832,
  396432713,
  1310675787,
  2037748042,
  -60563889,
  -888595378,
  -1833477556,
  -1512204211,
  -1734687674,
  -1343224249,
  -162643899,
  -1054571964,
  1144180033,
  1935150912,
  719735106,
  495749955,
  1349054804,
  1728197461,
  1052538199,
  165066582,
  -1933510573,
  -1146471854,
  -501973936,
  -713114031,
  -398859686,
  -548200357,
  -2031262119,
  -1316510632,
  881978205,
  66791772,
  1514499934,
  1831841119,
  -2145700383,
  -1217267744,
  -288378398,
  -643468317,
  1555250406,
  1809448679,
  845658341,
  84769508,
  944383727,
  253813998,
  1453236972,
  1643405549,
  -454938648,
  -746000919,
  -1976128533,
  -1118017046,
  -256371715,
  -942484996,
  -1637050370,
  -1459202561,
  739252986,
  461035771,
  1120182009,
  1974361336,
  1223229683,
  2139341554,
  641565936,
  290932465,
  -1807676940,
  -1557410827,
  -90862089,
  -838905866,
  1616738521,
  1463270104,
  243924186,
  971194075,
  -1124765218,
  -1952468001,
  -769526307,
  -448055332,
  -670274601,
  -278484522,
  -1227296812,
  -2119029291,
  77882064,
  869179601,
  1785784019,
  1561994450,
  285105861,
  664050884,
  2116737734,
  1228937415,
  -866756670,
  -79915581,
  -1568484415,
  -1779953216,
  -1464906293,
  -1614442550,
  -964965944,
  -250541111,
  1946633420,
  1131251405,
  450085071,
  767099598,
  1083617169,
  2013031824,
  776088466,
  422111635,
  -1673615722,
  -1420532585,
  -219536747,
  -981409644,
  -121127777,
  -810713442,
  -1777125220,
  -1585841507,
  611300760,
  319125401,
  1253781915,
  2110911386,
  808814989,
  123685772,
  1591807374,
  1770770319,
  -325222262,
  -604552565,
  -2109143927,
  -1255946616,
  -2006672765,
  -1089578878,
  -424665472,
  -774185855,
  1422693252,
  1671844229,
  974657415,
  225629574,
  -1596923223,
  -1749409624,
  -838572374,
  -110189397,
  2088299438,
  1259481519,
  313290669,
  633777580,
  411169191,
  803943334,
  1985312164,
  1094694821,
  -1003882336,
  -213697887,
  -1426228061,
  -1650999646,
  -797719371,
  -417790284,
  -1096335178,
  -1983020361,
  215731634,
  1001459635,
  1645169073,
  1432718256,
  1747113915,
  1598559674,
  116806584,
  832344505,
  -1265967428,
  -2082464579,
  -631350593,
  -315320130,
  0,
  1701297336,
  -1949824598,
  -290474734,
  1469538959,
  854646327,
  -597726427,
  -1187457123,
  -282544955,
  -1974531971,
  1692450159,
  25625047,
  -1195387318,
  -573019406,
  863494112,
  1443914584,
  -1621681840,
  -97475096,
  345968890,
  1912122434,
  -926909473,
  -1381513369,
  1124627061,
  644861645,
  1887415701,
  353898797,
  -71850945,
  -1630529401,
  669568794,
  1116697506,
  -1407138128,
  -918062584,
  1051669152,
  1539870232,
  -1251525878,
  -805271630,
  1765298223,
  207613079,
  -487564923,
  -2020088515,
  -779647387,
  -1260373283,
  1515163599,
  1059599223,
  -2045713174,
  -478717870,
  232320320,
  1757368824,
  -1577571344,
  -996174008,
  707797594,
  1331142370,
  -160478849,
  -1828129337,
  2108113109,
  415300717,
  1322295093,
  733422477,
  -988244321,
  -1602278873,
  424148410,
  2082488578,
  -1836059632,
  -135771992,
  1029182619,
  1480566819,
  -1232069327,
  -738745975,
  1791981076,
  262720172,
  -519602242,
  -2074033402,
  -764370850,
  -1223222042,
  1505274356,
  1021252940,
  -2048408879,
  -528449943,
  238013307,
  1799911363,
  -1576071733,
  -949440141,
  700908641,
  1285601497,
  -174559420,
  -1862282244,
  2119198446,
  456645206,
  1294448910,
  675284406,
  -957370204,
  -1551365092,
  447798145,
  2144823097,
  -1854352853,
  -199266669,
  66528827,
  1720752771,
  -2009124975,
  -312962263,
  1415595188,
  822605836,
  -542618338,
  -1160777306,
  -320892162,
  -1984418234,
  1729600340,
  40904684,
  -1152847759,
  -567325495,
  813758939,
  1441219939,
  -1667219605,
  -104365101,
  392705729,
  1913621113,
  -885563932,
  -1370431140,
  1090475086,
  630778102,
  1938328494,
  384775958,
  -129990140,
  -1658372420,
  606071073,
  1098405273,
  -1344806773,
  -894411725,
  1001806317,
  1590814037,
  -1333899193,
  -719721217,
  1814117218,
  155617242,
  -404147512,
  -2104586640,
  -727782104,
  -1309060720,
  1599530114,
  976312378,
  -2096525401,
  -428985569,
  146900493,
  1839610549,
  -1528741699,
  -1048118267,
  791234839,
  1246688687,
  -210361806,
  -1777230198,
  2025728920,
  500799264,
  1271526520,
  783173824,
  -1073611310,
  -1520025238,
  475961079,
  2033789519,
  -1751736483,
  -219077659,
  85551949,
  1618925557,
  -1898880281,
  -340337057,
  1385040322,
  938063226,
  -649723800,
  -1138639664,
  -365830264,
  -1890163920,
  1643763234,
  77490842,
  -1113146105,
  -658439745,
  913224877,
  1393100821,
  -1706135011,
  -14037339,
  294026167,
  1960953615,
  -841412462,
  -1463899094,
  1175525688,
  594978176,
  1969669848,
  268532320,
  -22098062,
  -1681296438,
  586261591,
  1201019119,
  -1455837699,
  -866250427,
  116280694,
  1669984718,
  -1926871844,
  -398329756,
  1366896633,
  874419009,
  -625924525,
  -1076454677,
  -372835917,
  -1935588085,
  1645146137,
  124341409,
  -1101948100,
  -617207932,
  899256982,
  1358835246,
  -1715907546,
  -52500322,
  309419404,
  1997988148,
  -835832151,
  -1421243887,
  1172717315,
  545358779,
  1989271779,
  334912603,
  -44439223,
  -1740745231,
  554074732,
  1147223764,
  -1429304378,
  -810993794,
  943816662,
  1562821486,
  -1282836868,
  -688993596,
  1876303193,
  179413473,
  -467790605,
  -2122733493,
  -680932589,
  -1307674709,
  1554105017,
  969309697,
  -2130794084,
  -442952412,
  188129334,
  1850809486,
  -1491704186,
  -1032725954,
  752774956,
  1236915092,
  -259980279,
  -1780041551,
  2068385187,
  506376475,
  1212076611,
  760835835,
  -1007232023,
  -1500420271,
  531214540,
  2060323956,
  -1805534874,
  -251263522
}; // weak
void *_frame_dummy_init_array_entry = (void *)0x14CED; // weak
int codes[] = { 3 }; // weak
int dword_7D0C4 = 7; // weak
void *cmds = (void *)0x601CC; // weak
char *opt_config_table = "--version-file"; // weak
int dword_7D6AC = 2; // weak
char *off_7D6C4 = "--logfile-openflag"; // weak
int global_quota_gcd = 1; // weak
double total_secs = 1.0; // weak
char best_share[] = { '0', '\0', '\0', '\0' }; // idb
int dword_7DED4 = 0; // weak
int opt_log_interval = 5; // weak
char *curly = ":D"; // weak
double new_total_secs = 1.0; // weak
double last_total_secs = 1.0; // weak
double current_diff = 1.84467441e19; // weak
int opt_pool_fallback = 120; // weak
int opt_scantime = -1; // weak
int opt_expiry = 120; // weak
char opt_restart = '\x01'; // weak
char opt_submit_stale = '\x01'; // weak
char *opt_cmdline_table = "--config|-c"; // weak
char *workpadding = "000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"; // weak
int opt_multi_version = 1; // weak
char opt_bitmain_ab = '\x01'; // weak
int opt_api_mcast_port = 4028; // weak
void *opt_api_mcast_des = (void *)0x609EC; // weak
char *opt_api_mcast_code[3] = { "FTW", "224.0.0.75", "0.0.0.0" }; // weak
char *opt_api_mcast_addr[2] = { "224.0.0.75", "0.0.0.0" }; // weak
char *opt_api_host = "0.0.0.0"; // weak
int opt_api_port = 4028; // weak
void *opt_api_description = &unk_603B8; // weak
int opt_queue = 1; // weak
char *strategies[5] = { "Failover", "Round Robin", "Rotate", "Load Balance", "Balance" }; // weak
char showLogToKernelLog = '\x01'; // weak
int init_once = 1; // weak
unsigned __int16 crc16_table[512] =
{
  0u,
  0u,
  4129u,
  0u,
  8258u,
  0u,
  12387u,
  0u,
  16516u,
  0u,
  20645u,
  0u,
  24774u,
  0u,
  28903u,
  0u,
  33032u,
  0u,
  37161u,
  0u,
  41290u,
  0u,
  45419u,
  0u,
  49548u,
  0u,
  53677u,
  0u,
  57806u,
  0u,
  61935u,
  0u,
  4657u,
  0u,
  528u,
  0u,
  12915u,
  0u,
  8786u,
  0u,
  21173u,
  0u,
  17044u,
  0u,
  29431u,
  0u,
  25302u,
  0u,
  37689u,
  0u,
  33560u,
  0u,
  45947u,
  0u,
  41818u,
  0u,
  54205u,
  0u,
  50076u,
  0u,
  62463u,
  0u,
  58334u,
  0u,
  9314u,
  0u,
  13379u,
  0u,
  1056u,
  0u,
  5121u,
  0u,
  25830u,
  0u,
  29895u,
  0u,
  17572u,
  0u,
  21637u,
  0u,
  42346u,
  0u,
  46411u,
  0u,
  34088u,
  0u,
  38153u,
  0u,
  58862u,
  0u,
  62927u,
  0u,
  50604u,
  0u,
  54669u,
  0u,
  13907u,
  0u,
  9842u,
  0u,
  5649u,
  0u,
  1584u,
  0u,
  30423u,
  0u,
  26358u,
  0u,
  22165u,
  0u,
  18100u,
  0u,
  46939u,
  0u,
  42874u,
  0u,
  38681u,
  0u,
  34616u,
  0u,
  63455u,
  0u,
  59390u,
  0u,
  55197u,
  0u,
  51132u,
  0u,
  18628u,
  0u,
  22757u,
  0u,
  26758u,
  0u,
  30887u,
  0u,
  2112u,
  0u,
  6241u,
  0u,
  10242u,
  0u,
  14371u,
  0u,
  51660u,
  0u,
  55789u,
  0u,
  59790u,
  0u,
  63919u,
  0u,
  35144u,
  0u,
  39273u,
  0u,
  43274u,
  0u,
  47403u,
  0u,
  23285u,
  0u,
  19156u,
  0u,
  31415u,
  0u,
  27286u,
  0u,
  6769u,
  0u,
  2640u,
  0u,
  14899u,
  0u,
  10770u,
  0u,
  56317u,
  0u,
  52188u,
  0u,
  64447u,
  0u,
  60318u,
  0u,
  39801u,
  0u,
  35672u,
  0u,
  47931u,
  0u,
  43802u,
  0u,
  27814u,
  0u,
  31879u,
  0u,
  19684u,
  0u,
  23749u,
  0u,
  11298u,
  0u,
  15363u,
  0u,
  3168u,
  0u,
  7233u,
  0u,
  60846u,
  0u,
  64911u,
  0u,
  52716u,
  0u,
  56781u,
  0u,
  44330u,
  0u,
  48395u,
  0u,
  36200u,
  0u,
  40265u,
  0u,
  32407u,
  0u,
  28342u,
  0u,
  24277u,
  0u,
  20212u,
  0u,
  15891u,
  0u,
  11826u,
  0u,
  7761u,
  0u,
  3696u,
  0u,
  65439u,
  0u,
  61374u,
  0u,
  57309u,
  0u,
  53244u,
  0u,
  48923u,
  0u,
  44858u,
  0u,
  40793u,
  0u,
  36728u,
  0u,
  37256u,
  0u,
  33193u,
  0u,
  45514u,
  0u,
  41451u,
  0u,
  53516u,
  0u,
  49453u,
  0u,
  61774u,
  0u,
  57711u,
  0u,
  4224u,
  0u,
  161u,
  0u,
  12482u,
  0u,
  8419u,
  0u,
  20484u,
  0u,
  16421u,
  0u,
  28742u,
  0u,
  24679u,
  0u,
  33721u,
  0u,
  37784u,
  0u,
  41979u,
  0u,
  46042u,
  0u,
  49981u,
  0u,
  54044u,
  0u,
  58239u,
  0u,
  62302u,
  0u,
  689u,
  0u,
  4752u,
  0u,
  8947u,
  0u,
  13010u,
  0u,
  16949u,
  0u,
  21012u,
  0u,
  25207u,
  0u,
  29270u,
  0u,
  46570u,
  0u,
  42443u,
  0u,
  38312u,
  0u,
  34185u,
  0u,
  62830u,
  0u,
  58703u,
  0u,
  54572u,
  0u,
  50445u,
  0u,
  13538u,
  0u,
  9411u,
  0u,
  5280u,
  0u,
  1153u,
  0u,
  29798u,
  0u,
  25671u,
  0u,
  21540u,
  0u,
  17413u,
  0u,
  42971u,
  0u,
  47098u,
  0u,
  34713u,
  0u,
  38840u,
  0u,
  59231u,
  0u,
  63358u,
  0u,
  50973u,
  0u,
  55100u,
  0u,
  9939u,
  0u,
  14066u,
  0u,
  1681u,
  0u,
  5808u,
  0u,
  26199u,
  0u,
  30326u,
  0u,
  17941u,
  0u,
  22068u,
  0u,
  55628u,
  0u,
  51565u,
  0u,
  63758u,
  0u,
  59695u,
  0u,
  39368u,
  0u,
  35305u,
  0u,
  47498u,
  0u,
  43435u,
  0u,
  22596u,
  0u,
  18533u,
  0u,
  30726u,
  0u,
  26663u,
  0u,
  6336u,
  0u,
  2273u,
  0u,
  14466u,
  0u,
  10403u,
  0u,
  52093u,
  0u,
  56156u,
  0u,
  60223u,
  0u,
  64286u,
  0u,
  35833u,
  0u,
  39896u,
  0u,
  43963u,
  0u,
  48026u,
  0u,
  19061u,
  0u,
  23124u,
  0u,
  27191u,
  0u,
  31254u,
  0u,
  2801u,
  0u,
  6864u,
  0u,
  10931u,
  0u,
  14994u,
  0u,
  64814u,
  0u,
  60687u,
  0u,
  56684u,
  0u,
  52557u,
  0u,
  48554u,
  0u,
  44427u,
  0u,
  40424u,
  0u,
  36297u,
  0u,
  31782u,
  0u,
  27655u,
  0u,
  23652u,
  0u,
  19525u,
  0u,
  15522u,
  0u,
  11395u,
  0u,
  7392u,
  0u,
  3265u,
  0u,
  61215u,
  0u,
  65342u,
  0u,
  53085u,
  0u,
  57212u,
  0u,
  44955u,
  0u,
  49082u,
  0u,
  36825u,
  0u,
  40952u,
  0u,
  28183u,
  0u,
  32310u,
  0u,
  20053u,
  0u,
  24180u,
  0u,
  11923u,
  0u,
  16050u,
  0u,
  3793u,
  0u,
  7920u,
  0u
}; // weak
_UNKNOWN bitmain_c5_drv; // weak
void *off_7E3EC = (void *)0x2CE11; // weak
char disabledcore_pos_buf[] = { '\xFF' }; // weak
_UNKNOWN unk_7E466; // weak
int given_id = 2; // weak
int is7007_ctrl_board = -1; // weak
int fan_mode_13087 = -1; // weak
char blink_14032 = '\x01'; // weak
char algn_7E565[3] = { '\0', '\0', '\0' }; // weak
char chain_voltage_pic[16] =
{
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char de_voltage = '\xB0'; // weak
int ticket_mask = 63; // weak
int PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608; // weak
int opt_bitmain_c5_voltage = 176; // weak
char is_using_voltage_from_config = '\x01'; // weak
_UNKNOWN is_scan_based_on_domain; // weak
_UNKNOWN opt_pre_heat; // weak
int opt_bitmain_c5_freq = 600; // weak
char last_job_buffer[4573] =
{
  '\x17',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_7F76D; // weak
char enable_read_temp = '\x01'; // weak
int log_level = 4; // weak
char *log_file = "/tmp/freq"; // weak
int opt_log_level = 5; // weak
char power_iic_addr = '\x10'; // weak
char power_iic_no = '\x01'; // weak
__int16 power_protocal_type = 1; // weak
int minus_n_number = 3; // weak
_DWORD sha256_k[7] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548
}; // weak
_UNKNOWN unk_806B0; // weak
_UNKNOWN unk_806D0; // weak
int (__fastcall *selective_yield)(_DWORD) = (int (__fastcall *)(_DWORD))0x453C1; // weak
unsigned __int8 bit_swap_table[256] =
{
  0u,
  128u,
  64u,
  192u,
  32u,
  160u,
  96u,
  224u,
  16u,
  144u,
  80u,
  208u,
  48u,
  176u,
  112u,
  240u,
  8u,
  136u,
  72u,
  200u,
  40u,
  168u,
  104u,
  232u,
  24u,
  152u,
  88u,
  216u,
  56u,
  184u,
  120u,
  248u,
  4u,
  132u,
  68u,
  196u,
  36u,
  164u,
  100u,
  228u,
  20u,
  148u,
  84u,
  212u,
  52u,
  180u,
  116u,
  244u,
  12u,
  140u,
  76u,
  204u,
  44u,
  172u,
  108u,
  236u,
  28u,
  156u,
  92u,
  220u,
  60u,
  188u,
  124u,
  252u,
  2u,
  130u,
  66u,
  194u,
  34u,
  162u,
  98u,
  226u,
  18u,
  146u,
  82u,
  210u,
  50u,
  178u,
  114u,
  242u,
  10u,
  138u,
  74u,
  202u,
  42u,
  170u,
  106u,
  234u,
  26u,
  154u,
  90u,
  218u,
  58u,
  186u,
  122u,
  250u,
  6u,
  134u,
  70u,
  198u,
  38u,
  166u,
  102u,
  230u,
  22u,
  150u,
  86u,
  214u,
  54u,
  182u,
  118u,
  246u,
  14u,
  142u,
  78u,
  206u,
  46u,
  174u,
  110u,
  238u,
  30u,
  158u,
  94u,
  222u,
  62u,
  190u,
  126u,
  254u,
  1u,
  129u,
  65u,
  193u,
  33u,
  161u,
  97u,
  225u,
  17u,
  145u,
  81u,
  209u,
  49u,
  177u,
  113u,
  241u,
  9u,
  137u,
  73u,
  201u,
  41u,
  169u,
  105u,
  233u,
  25u,
  153u,
  89u,
  217u,
  57u,
  185u,
  121u,
  249u,
  5u,
  133u,
  69u,
  197u,
  37u,
  165u,
  101u,
  229u,
  21u,
  149u,
  85u,
  213u,
  53u,
  181u,
  117u,
  245u,
  13u,
  141u,
  77u,
  205u,
  45u,
  173u,
  109u,
  237u,
  29u,
  157u,
  93u,
  221u,
  61u,
  189u,
  125u,
  253u,
  3u,
  131u,
  67u,
  195u,
  35u,
  163u,
  99u,
  227u,
  19u,
  147u,
  83u,
  211u,
  51u,
  179u,
  115u,
  243u,
  11u,
  139u,
  75u,
  203u,
  43u,
  171u,
  107u,
  235u,
  27u,
  155u,
  91u,
  219u,
  59u,
  187u,
  123u,
  251u,
  7u,
  135u,
  71u,
  199u,
  39u,
  167u,
  103u,
  231u,
  23u,
  151u,
  87u,
  215u,
  55u,
  183u,
  119u,
  247u,
  15u,
  143u,
  79u,
  207u,
  47u,
  175u,
  111u,
  239u,
  31u,
  159u,
  95u,
  223u,
  63u,
  191u,
  127u,
  255u
}; // weak
char first_time_6468 = '\x01'; // weak
int (__fastcall *do_malloc)(_DWORD) = &malloc; // weak
int (*do_free)(void) = &free; // weak
_UNKNOWN the_true_7785; // weak
_UNKNOWN the_false_7789; // weak
_UNKNOWN the_null_7793; // weak
int _bss_start; // weak
int stdin; // weak
int stdout; // weak
char completed_9251; // weak
char bye; // weak
char do_a_quit; // weak
char do_a_restart; // weak
int ips; // weak
int ipaccess; // weak
pthread_mutex_t quit_restart_lock; // idb
int io_head; // weak
int strbufs; // weak
char when[8]; // weak
_DWORD opt_logfile_path; // weak
_DWORD opt_logwork_asicnum; // weak
int opt_logwork_path; // weak
_DWORD opt_logfile_openflag; // weak
_DWORD opt_version_path; // weak
int default_config; // weak
int sharelog_file; // weak
int jedata; // weak
_UNKNOWN bench_target; // weak
char exit_buf[512]; // idb
char packagename[256]; // idb
int api_thr_id; // weak
int cnfbuf; // weak
int include_count; // weak
char config_loaded; // weak
char err_buf_13672[200]; // idb
int fileconf_load; // weak
int pool_strategy; // weak
int temp_cutoff_str; // weak
struct timeval restart_tv_start; // weak
struct timeval update_tv_start; // weak
_UNKNOWN opt_set_null; // weak
__int64 best_diff; // weak
int fd_log; // weak
int forkpid; // weak
int benchfile_in; // weak
int opt_benchfile; // weak
int benchfile_line; // weak
int benchfile_work; // weak
char opt_fix_protocol; // weak
int stgd_lock; // weak
int total_work; // weak
int total_tv_end; // weak
int dword_80FB8; // weak
int total_tv_start; // weak
int dword_80FC0; // weak
char datestamp[40]; // weak
int opt_shares; // weak
int initial_args; // weak
int watchpool_thr_id; // weak
int watchdog_thr_id; // weak
int currentpool; // weak
char no_work; // weak
int total_users; // weak
int total_passes; // weak
int total_userpasses; // weak
int total_urls; // weak
int total_extranonce; // weak
struct timeval tv_hashmeter; // weak
double g_local_mhashes_dones[12]; // weak
int g_local_mhashes_index; // weak
int staged_work; // weak
pthread_mutex_t lp_lock; // idb
pthread_cond_t lp_cond; // idb
char opt_benchmark; // weak
pthread_mutex_t sshare_lock; // idb
int stratum_shares; // weak
int rotate_tv; // weak
pthread_mutex_t sharelog_lock; // idb
int staged_rollable; // weak
char pools_active; // weak
int local_work_lasttime; // weak
int local_work_last; // weak
int work_block; // weak
_UNKNOWN bench_hidiff_bins; // weak
_UNKNOWN bench_lodiff_bins; // weak
_UNKNOWN unk_81C48; // weak
int hashdisplay_t; // weak
char g_displayed_rolling[8]; // weak
char statusline[256]; // weak
pthread_rwlock_t blk_lock; // idb
int blocks; // weak
char block_diff[8]; // idb
_UNKNOWN current_block; // weak
char blocktime[32]; // idb
char prev_block[12]; // idb
char opt_benchfile_display; // weak
int cgminer_id_count; // weak
int new_threads; // weak
int devids_15749; // weak
int new_devices; // weak
int most_devices; // weak
char g_miner_compiletime[256]; // idb
char g_miner_type[256]; // idb
int g_logwork_asicnum; // weak
int g_logwork_file; // weak
int g_logwork_files[]; // weak
char opt_logwork_diff; // weak
int g_logwork_diffs[65]; // weak
int opt_socks_proxy; // weak
_UNKNOWN mined_time_record; // weak
char displayed_hash_rate[16]; // weak
char g_miner_version[256]; // weak
int opt_api_allow; // weak
int cgpu[150]; // weak
pthread_t dword_82E10[22]; // weak
_UNKNOWN unk_82E6B; // weak
char byte_82E6C; // weak
_UNKNOWN unk_830A8; // weak
_UNKNOWN unk_A0028; // weak
_UNKNOWN unk_F423F; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_200080; // weak
_UNKNOWN unk_271974; // weak
_UNKNOWN unk_2D5B20; // weak
_UNKNOWN unk_2E2E2E; // weak
_UNKNOWN unk_2F36A8; // weak
_UNKNOWN unk_2F40A8; // weak
_UNKNOWN unk_2F42A8; // weak
_DWORD dword_2F42AC; // weak
_UNKNOWN unk_2F44AC; // weak
int dword_2F44B0; // weak
_UNKNOWN unk_2F44B4; // weak
_UNKNOWN unk_2F44B8; // weak
_UNKNOWN unk_2F44BC; // weak
int dword_2F44D0; // weak
_UNKNOWN unk_2F44D4; // weak
_UNKNOWN unk_2F44D8; // weak
_UNKNOWN unk_2F44EC; // weak
int dword_2F44F8; // weak
_UNKNOWN unk_2F4538; // weak
char byte_2F4540; // weak
char algn_2F4541[63]; // weak
char byte_2F4580; // weak
char algn_2F4581[3]; // weak
int dword_2F458C; // weak
int dword_2F4590; // weak
int dword_2F4594; // weak
int dword_2F4598; // weak
int dword_2F459C; // weak
int dword_2F45A0; // weak
int dword_2F45B0; // weak
int dword_2F45B4; // weak
int dword_2F45B8; // weak
_UNKNOWN unk_2F45BC; // weak
int dword_2F45C0; // weak
int dword_2F45C4; // weak
int dword_2F45C8; // weak
int dword_2F45CC; // weak
int dword_2F45D0; // weak
int dword_2F45D4; // weak
int dword_2F45D8; // weak
int dword_2F45DC; // weak
int dword_2F45E0; // weak
int dword_2F45E4; // weak
int dword_2F45E8; // weak
_UNKNOWN unk_2F45EC; // weak
_UNKNOWN unk_2F45F0; // weak
_UNKNOWN unk_2F45F4; // weak
_UNKNOWN unk_2F45F8; // weak
int dword_2F45FC; // weak
int dword_2F4600; // weak
int dword_2F4604; // weak
int dword_2F4608; // weak
int dword_2F460C; // weak
int dword_2F4610; // weak
int dword_2F4614; // weak
int dword_2F4618; // weak
int dword_2F461C; // weak
int dword_2F4620; // weak
int dword_2F4624; // weak
int dword_2F4628; // weak
int dword_2F462C; // weak
int dword_2F4630; // weak
char byte_2F4634; // weak
int dword_2F4638; // weak
int dword_2F463C; // weak
int dword_2F4640; // weak
int dword_2F4644; // weak
int dword_2F4648; // weak
int dword_2F464C; // weak
int dword_2F4650; // weak
int dword_2F4654; // weak
int dword_2F4658; // weak
int dword_2F465C; // weak
int dword_2F4660; // weak
int dword_2F4664; // weak
int dword_2F4668; // weak
int dword_2F466C; // weak
_UNKNOWN repeated_nonce_id; // weak
_UNKNOWN unk_2F7A88; // weak
_UNKNOWN last_nonce; // weak
_UNKNOWN llast_nonce; // weak
_UNKNOWN work_id; // weak
_UNKNOWN m_nonce; // weak
char start_receive; // weak
char gBegin_get_nonce; // weak
_DWORD last_nonce_num[16]; // weak
int conf; // weak
int dword_2F87B8; // weak
int dword_2F87BC; // weak
int dword_2F87C0; // weak
int dword_2F87C4; // weak
int dword_2F87C8; // weak
int dword_2F87CC; // weak
int dword_2F87D0; // weak
int dword_2F87DC; // weak
int dword_2F87E0; // weak
int dword_2F87E4; // weak
int dword_2F87E8; // weak
int dword_2F87EC; // weak
int dword_2F87F0; // weak
int dword_2F87F4; // weak
int dword_2F87F8; // weak
int dword_2F87FC; // weak
int dword_2F8800; // weak
int dword_2F8804; // weak
int dword_2F8808; // weak
int dword_2F880C; // weak
int dword_2F8810; // weak
int dword_2F8814; // weak
int dword_2F8820; // weak
int dword_2F8824; // weak
int dword_2F8828; // weak
int dword_2F882C; // weak
int dword_2F8830; // weak
int dword_2F8834; // weak
int dword_2F8838; // weak
char byte_2F883C; // weak
char byte_2F883D; // weak
char byte_2F883E; // weak
char byte_2F883F; // weak
char byte_2F8840; // weak
int dword_2F8844; // weak
int dword_2F8848; // weak
int dword_2F884C; // weak
int dword_2F8850; // weak
int dword_2F8854; // weak
int dword_2F8858; // weak
char byte_2F885C; // weak
char byte_2F885D; // weak
int dword_2F8860; // weak
int dword_2F8864; // weak
int dword_2F8868; // weak
int dword_2F886C; // weak
int dword_2F8870; // weak
int dword_2F8874; // weak
_UNKNOWN asic_nonce_num; // weak
_UNKNOWN unk_2FBE68; // weak
_DWORD valid_nonce_num[16]; // weak
int total_valid_nonce_num; // weak
_UNKNOWN asic_core_nonce_num; // weak
_UNKNOWN unk_313A46; // weak
_UNKNOWN unk_320000; // weak
_UNKNOWN unk_36EE80; // weak
_UNKNOWN unk_400004; // weak
_UNKNOWN unk_400005; // weak
_UNKNOWN unk_400241; // weak
_UNKNOWN unk_6FC638; // weak
_DWORD repeated_nonce_num[16]; // weak
_DWORD err_nonce_num[16]; // weak
char ExitFlag; // weak
int send_work_num[]; // weak
char algn_6FC944[60]; // weak
char chain_need_opencore[15]; // weak
_UNKNOWN unk_6FC98F; // weak
char StartSendFlag[12]; // weak
_UNKNOWN unk_6FC99C; // weak
_UNKNOWN unk_6FC99F; // weak
int chain_DataCount[15]; // weak
_UNKNOWN unk_6FC9DC; // weak
int chain_ValidNonce[15]; // weak
_UNKNOWN unk_6FCA1C; // weak
int last_result; // weak
_UNKNOWN unk_6FCE1C; // weak
_UNKNOWN unk_700A1C; // weak
int last_result_opencore; // weak
_UNKNOWN unk_700B6C; // weak
_UNKNOWN unk_704A1C; // weak
int chain_PassCount[16]; // weak
_UNKNOWN unk_704A5F; // weak
char search_freq_result[12]; // weak
_UNKNOWN unk_704A6C; // weak
_UNKNOWN unk_704A6F; // weak
int testModeOKCounter; // weak
_UNKNOWN unk_704AAC; // weak
int h; // weak
char status_error; // weak
pthread_mutex_t iic_mutex; // idb
int chain_badcore_num[]; // weak
_UNKNOWN unk_704C24; // weak
_UNKNOWN unk_707D98; // weak
char chain_pic_buf[]; // weak
char byte_708AD5; // weak
char byte_708AD6; // weak
_UNKNOWN unk_708E90; // weak
pthread_mutex_t nonce_mutex; // idb
int last_nonce3_15022; // weak
int last_workid_15023; // weak
__int64 pool_diff_14987; // weak
__int64 pool_diff_bit_14989; // weak
__int64 net_diff_14988; // weak
_UNKNOWN net_diff_bit_14990; // weak
char middle_Offset[128]; // weak
char opt_fixed_freq; // weak
int print_num_13028; // weak
int chain_temp_toolow[16]; // weak
int lowest_testOK_temp[]; // weak
int force_mode_timepoint_13088; // weak
char is_working_in_low_temperature; // weak
char opt_economic_mode; // weak
int ideal_total_hash_rate; // weak
_UNKNOWN chip_last_freq; // weak
pthread_mutex_t init_log_mutex; // idb
_UNKNOWN isUseDefaultFreq; // weak
unsigned __int8 base_freq_index[12]; // weak
_UNKNOWN unk_70A46C; // weak
_UNKNOWN freq_table; // weak
_UNKNOWN show_last_freq; // weak
_UNKNOWN unk_70F46C; // weak
int last_record_freq; // weak
_UNKNOWN unk_712748; // weak
_UNKNOWN unk_71346C; // weak
pthread_mutex_t reg_mutex; // idb
char doTestPatten; // weak
char gBegin_get_nonce_0; // weak
char test_show_register; // weak
_QWORD rate[16]; // weak
_UNKNOWN rate_error; // weak
pthread_mutex_t temp_mutex; // idb
char is218_Temp; // weak
char chip_hasNoMiddle; // weak
_QWORD chain_asic_RT[1176]; // weak
_UNKNOWN global_stop; // weak
_UNKNOWN once_error; // weak
char isC5_CtrlBoard; // weak
int nonce_times; // weak
_DWORD nonce_num[245098]; // weak
_UNKNOWN unk_805520; // weak
char config_parameter; // weak
char byte_805F7C; // weak
_UNKNOWN unk_805F80; // weak
char byte_805F82; // weak
__int16 word_805F84; // weak
_UNKNOWN unk_805F88; // weak
__int16 word_805F8A; // weak
_UNKNOWN unk_805F8C; // weak
_UNKNOWN unk_805F90; // weak
_UNKNOWN unk_805F94; // weak
_UNKNOWN unk_805F95; // weak
__int16 word_805F96; // weak
int total_exist_chain_num; // weak
int adjust_num_14198; // weak
int offset_14197; // weak
int chain_voltage_value; // weak
char ENABLE_LIMIT_ON_SINGLE_BOARD; // weak
int exist_chain; // weak
char is_certification; // weak
struct timeval tv_send_job; // weak
struct timeval tv_send; // weak
char startCheckNetworkJob; // weak
char opt_bitmain_fan_ctrl; // weak
int opt_bitmain_fan_pwm; // weak
int pool_send_nu_14834; // weak
int last_version_num_14890; // weak
_UNKNOWN l_coinbase_padding; // weak
_UNKNOWN c_coinbase_padding; // weak
_UNKNOWN l_merkles_num; // weak
_UNKNOWN c_merkles_num; // weak
pthread_mutex_t reinit_mutex; // idb
_UNKNOWN bring_up_pcb_temp; // weak
_UNKNOWN ok_num_14263; // weak
int last_testpatten_highest_pcb_temp; // weak
_UNKNOWN check_temp_offside; // weak
_UNKNOWN x_time; // weak
pthread_mutex_t opencore_readtemp_mutex; // idb
_DWORD temp_offside[16]; // weak
int last_temperature; // weak
int FatalErrorValue; // weak
char isChainAllCoresOpened[16]; // weak
_UNKNOWN is_first_job; // weak
char someBoardUpVoltage; // weak
char g_logfile_enable; // weak
int g_log_file; // weak
__int16 g_logfile_openflag; // weak
int g_logfile_path; // weak
char opt_log_output; // weak
char opt_debug; // weak
int power_info; // weak
char byte_80B6D4; // weak
double dbl_80B6D8; // weak
_UNKNOWN unk_80B6E0; // weak
int dword_80B6E8; // weak
int dword_80B6EC; // weak
int dword_80B6F0; // weak
char successful_connect; // weak
char gNodeName[256]; // weak
int axi_fpga_addr; // weak
int fpga_mem_addr; // weak
int nonce2_jobid_address; // weak
int job_start_address_1; // weak
int job_start_address_2; // weak
pthread_mutex_t fpga_mutex; // idb
int hashtable_seed; // weak
_UNKNOWN bitmain_drv; // weak
int dword_80B83C; // weak
_UNKNOWN apigroups; // weak
_UNKNOWN modminer_drv; // weak
int dword_80B91C; // weak
_UNKNOWN bitforce_drv; // weak
int opt_api_groups; // weak
char schedstop; // weak
int dword_80BA0C; // weak
int dword_80BA10; // weak
int total_stale; // weak
int dword_80BA3C; // weak
int total_tv_start_sys; // weak
char current_hash[68]; // weak
int hw_errors; // weak
double total_diff_accepted; // weak
char opt_quiet; // weak
int total_discarded; // weak
int dword_80BAA4; // weak
char want_per_device_stats; // weak
double total_diff_rejected; // weak
char opt_protocol; // weak
char schedstart; // weak
int dword_80BAC4; // weak
int dword_80BAC8; // weak
int total_pools; // weak
struct sigaction abrthandler; // idb
int found_blocks; // weak
_UNKNOWN sched_paused; // weak
int opt_rotate_period; // weak
int devices; // weak
_UNKNOWN global_hashrate; // weak
char hotplug_mode; // weak
char opt_api_mcast; // weak
int opt_suggest_diff; // weak
char nonce_num60_string[4096]; // weak
int total_tv_end_sys; // weak
char use_curses; // weak
int swork_id; // weak
int total_ro; // weak
int zombie_devs; // weak
char opt_worktime; // weak
int last_getwork; // weak
int mining_thr; // weak
pthread_rwlock_t mining_thr_lock; // weak
int pools; // weak
pthread_cond_t gws_cond; // weak
char use_syslog; // weak
char opt_delaynet; // weak
char have_longpoll; // weak
pthread_mutex_t ch_lock; // weak
pthread_rwlock_t stru_80CC34; // idb
pthread_mutex_t control_lock; // weak
pthread_rwlock_t rwlock; // idb
int enabled_pools; // weak
char nonce_num30_string[4096]; // weak
int cgminer_path; // weak
int g_max_fan; // weak
int g_max_temp; // weak
int mining_threads; // weak
double total_rolling; // weak
int control_thr; // weak
char opt_realquiet; // weak
pthread_rwlock_t netacc_lock; // weak
int total_devices; // weak
int opt_kernel_path; // weak
int total_go; // weak
char opt_fail_only; // weak
int total_accepted; // weak
int dword_80DCF4; // weak
int getq; // weak
int total_getworks; // weak
int dword_80DD04; // weak
int block_timeval; // weak
int dword_80DD0C; // weak
struct sigaction termhandler; // idb
char opt_lowmem; // weak
char opt_api_listen; // weak
double rolling5; // weak
double rolling1; // weak
double rolling15; // weak
char total_mhashes_done[8]; // weak
char opt_compact; // weak
char nonce_num10_string[4100]; // weak
char total_diff_stale[8]; // weak
pthread_mutex_t stats_lock; // weak
int new_blocks; // weak
char opt_disable_pool; // weak
pthread_mutex_t console_lock; // weak
pthread_cond_t restart_cond; // weak
struct sigaction inthandler; // idb
char opt_api_network; // weak
int scan_devices; // weak
int dword_80EED4; // weak
pthread_mutex_t update_job_lock; // weak
int local_work; // weak
__int64 total_rejected; // weak
char opt_work_update; // weak
pthread_mutex_t restart_lock; // weak
pthread_rwlock_t devices_lock; // weak
_UNKNOWN new_total_mhashes_done; // weak
pthread_mutex_t hash_lock; // weak
int total_diff1; // weak
int dword_80EF64; // weak
int fd; // weak
int fd_fpga_mem; // weak
int nonce_read_out[]; // weak
int dword_80EF78; // weak
int dword_80EF7C; // weak
int reg_value_buf[]; // weak
int dword_816748; // weak
int dword_81674C; // weak
int pcb_version; // weak
int pic_heart_beat; // weak
char FPGA_ID_str[32]; // weak
char displayed_rate[512]; // weak
int read_nonce_reg_id; // weak
int check_system_work_id; // weak
int fpga_major_version; // weak
int dev; // weak
unsigned __int8 DEVICEADDR[16]; // weak
int read_temp_id; // weak
int fpga_version; // weak
int opt_num_short_arg; // weak
int opt_num_long; // weak
int opt_num_short; // weak
int opt_table; // weak
int opt_argv0; // weak
int opt_count; // weak
_UNKNOWN opt_hidden; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00011F44) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (00011F50) --------------------------------------------------------
void sub_11F50()
{
  JUMPOUT(0);
}
// 11F5C: control flows out of bounds to 0

//----- (00011F64) --------------------------------------------------------
// attributes: thunk
int j_pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (00011FC8) --------------------------------------------------------
// attributes: thunk
int j_strcmp(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}

//----- (00011FD8) --------------------------------------------------------
// attributes: thunk
int j_strtol(const char *nptr, char **endptr, int base)
{
  return strtol(nptr, endptr, base);
}

//----- (00012054) --------------------------------------------------------
// attributes: thunk
void j_free(void *ptr)
{
  free(ptr);
}

//----- (000120AC) --------------------------------------------------------
// attributes: thunk
void *j_memcpy(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (00012128) --------------------------------------------------------
// attributes: thunk
unsigned int j_sleep(unsigned int seconds)
{
  return sleep(seconds);
}

//----- (00012240) --------------------------------------------------------
// attributes: thunk
char *j_strcpy(char *dest, const char *src)
{
  return strcpy(dest, src);
}

//----- (00012250) --------------------------------------------------------
// attributes: thunk
int j_gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
{
  return gettimeofday(tv, tz);
}

//----- (00012278) --------------------------------------------------------
// attributes: thunk
int j_pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
{
  return pthread_create(newthread, attr, start_routine, arg);
}

//----- (000122C4) --------------------------------------------------------
// attributes: thunk
void *j_malloc(size_t size)
{
  return malloc(size);
}

//----- (000122F8) --------------------------------------------------------
// attributes: thunk
int j_system(const char *command)
{
  return system(command);
}

//----- (000123EC) --------------------------------------------------------
// attributes: thunk
int j_fcntl(int fd, int cmd, ...)
{
  return fcntl(fd, cmd);
}

//----- (00012420) --------------------------------------------------------
// attributes: thunk
int j_snprintf(char *s, size_t maxlen, const char *format, ...)
{
  return snprintf(s, maxlen, format);
}

//----- (00012430) --------------------------------------------------------
// attributes: thunk
char *j___strdup(const char *s)
{
  return _strdup(s);
}

//----- (00012464) --------------------------------------------------------
// attributes: thunk
void *j_memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (00012498) --------------------------------------------------------
// attributes: thunk
char *j_strncpy(char *dest, const char *src, size_t n)
{
  return strncpy(dest, src, n);
}

//----- (00012508) --------------------------------------------------------
// attributes: thunk
int j_fclose(FILE *stream)
{
  return fclose(stream);
}

//----- (000125F0) --------------------------------------------------------
// attributes: thunk
void j_syslog(int pri, const char *fmt, ...)
{
  syslog(pri, fmt);
}

//----- (00012624) --------------------------------------------------------
// attributes: thunk
int j_sprintf(char *s, const char *format, ...)
{
  return sprintf(s, format);
}

//----- (000126AC) --------------------------------------------------------
// attributes: thunk
int j_clock_gettime(clockid_t clock_id, struct timespec *tp)
{
  return clock_gettime(clock_id, tp);
}

//----- (000126EC) --------------------------------------------------------
// attributes: thunk
int j_sem_destroy(sem_t *sem)
{
  return sem_destroy(sem);
}

//----- (00012778) --------------------------------------------------------
int __fastcall calculate_core_number_part_11(int a1)
{
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(v2, 2048u, "actual_core_number = %d, but it is error\n", a1);
  applog(7, v2, 0);
  return -1;
}

//----- (000127A8) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // r0
  int (*v4)(void); // r2
  int (**v5)(void); // r3
  bool v6; // zf
  int v7; // r0
  char *v8; // r0
  int v9; // r3
  char *v10; // r5
  char *v11; // r6
  int v12; // r4
  const char **v13; // r8
  const char *v14; // t1
  char *v15; // r0
  thread_q *v16; // r0
  const char *v17; // r0
  char *v18; // r0
  char *v19; // r8
  char *v20; // r6
  char *v21; // r0
  int v22; // r4
  char *v23; // r6
  size_t v24; // r0
  int v25; // r4
  unsigned int v26; // r2
  bool v27; // cc
  int v28; // r3
  int v29; // r0
  unsigned int v30; // r5
  char *v31; // lr
  int v32; // r6
  int v33; // r9
  int v34; // r1
  int v35; // r11
  unsigned int v36; // r5
  unsigned int v37; // r3
  int v38; // r2
  unsigned int v39; // r1
  unsigned int v40; // r3
  int v41; // r2
  unsigned int v42; // r1
  unsigned int v43; // r3
  unsigned int v44; // r4
  char *v45; // r6
  int v46; // r2
  unsigned int v47; // r3
  unsigned int v48; // r1
  int v49; // r2
  unsigned int v50; // r3
  unsigned int v51; // r1
  unsigned int v52; // r2
  unsigned int v53; // r4
  size_t v54; // r0
  _DWORD *v55; // r3
  int v56; // r5
  char *v57; // r0
  char *v58; // r6
  int v59; // r3
  int v60; // r1
  char *v61; // r0
  int *v62; // r5
  int v63; // r2
  int v64; // r4
  int v65; // r5
  unsigned int v66; // r3
  int v67; // r0
  char *v68; // r4
  int v69; // r3
  _DWORD *v70; // r8
  int v71; // r11
  int v72; // r2
  unsigned int v73; // r0
  int v74; // r3
  unsigned int v75; // r3
  unsigned int v76; // r10
  int *v77; // r0
  char *v78; // r3
  char *v79; // r2
  _DWORD *v80; // r5
  _DWORD *v81; // r9
  int v82; // r4
  char *v83; // r6
  unsigned int v84; // r0
  int v85; // r3
  int v86; // r3
  _DWORD *v87; // r4
  unsigned int v88; // r0
  unsigned int v89; // r1
  int v90; // r2
  int v91; // r3
  unsigned int v92; // r3
  int v93; // r4
  char *v94; // r9
  _DWORD *v95; // r0
  _DWORD *v96; // r3
  _DWORD *v97; // r2
  const char *v98; // r3
  int v99; // r0
  int v100; // r1
  __int16 v101; // r3
  int v102; // r3
  int v103; // r3
  char *v104; // r10
  _BYTE *v105; // r4
  int v106; // r9
  _BYTE *v107; // r0
  unsigned __int8 *v108; // r1
  const char *v109; // r0
  FILE *v110; // r5
  signed int v111; // r0
  char *v112; // r0
  char *v113; // r5
  int v114; // r5
  char *v115; // r0
  char *v116; // r11
  size_t v117; // r3
  size_t v118; // r3
  size_t v119; // r3
  size_t v120; // r0
  void *v121; // r4
  const char *v122; // r1
  const char *v123; // r1
  const char *v124; // r5
  const char *v125; // r0
  int v126; // r0
  char *v127; // r4
  int *v128; // r5
  int v129; // r0
  int v130; // r1
  int v131; // r2
  int v132; // r3
  _DWORD *v133; // r4
  _DWORD *v134; // r5
  int v135; // r1
  const char *v136; // r1
  FILE *v137; // r0
  int v138; // r3
  int v139; // r3
  signed int v140; // r5
  int *v141; // r8
  _DWORD *v142; // r10
  _DWORD *v143; // r9
  FILE *v144; // r0
  int v145; // r3
  char *v146; // r8
  int v147; // r5
  FILE *v148; // r0
  int v149; // r3
  const char *v150; // r3
  int v151; // r3
  _DWORD *v152; // r4
  int v153; // r2
  int v154; // r8
  int v155; // r5
  int v156; // r4
  pthread_rwlock_t *v157; // r0
  char *v158; // r0
  int v159; // r4
  char *v160; // r9
  char *i; // r0
  char *v162; // r0
  const char **v163; // r5
  _DWORD *v164; // r5
  unsigned __int8 *v165; // r8
  unsigned int v166; // r12
  _DWORD *v167; // r3
  void *v168; // r0
  char *v169; // r9
  _DWORD *v170; // r8
  void *v171; // r0
  FILE *v172; // r0
  int v173; // r3
  int v174; // r0
  int v175; // r4
  int j; // r3
  int v177; // r2
  int v178; // r6
  int v179; // r4
  int v180; // r3
  const char *v181; // r0
  size_t v182; // r5
  unsigned int v183; // r5
  char *v184; // r0
  const char *v185; // r3
  int v186; // r3
  int v187; // r0
  int v188; // r4
  int v189; // r2
  char *v190; // r9
  int v191; // r3
  char *v192; // r10
  __sighandler_t v193; // r4
  __sighandler_t v194; // r0
  __pid_t v195; // r0
  __pid_t v196; // r4
  int *v197; // r0
  size_t v198; // r0
  int k; // r4
  int v200; // r5
  int v201; // r11
  _DWORD *v202; // r5
  int v203; // r4
  _DWORD *v204; // r0
  int v205; // r2
  sem_t *thread; // r0
  int v207; // r3
  sem_t *v208; // r8
  int (*v209)(void); // r3
  int v210; // r3
  char *v211; // r6
  char *v212; // r6
  char *v213; // r6
  char *v214; // r11
  int v215; // r2
  int *v216; // r3
  int v217; // r5
  int v218; // r3
  int v219; // r4
  int v220; // r2
  int v221; // r5
  int v222; // r5
  int v223; // r3
  int v224; // r3
  int v225; // r1
  char *v226; // r3
  int v227; // r2
  int v228; // r0
  _DWORD *v229; // r11
  pthread_mutex_t *v230; // r0
  int v231; // r3
  void **work; // r0
  int v233; // r0
  unsigned __int8 *v234; // r8
  int v235; // r3
  int v236; // r0
  unsigned __int8 *v237; // r4
  int v238; // r3
  const char *v239; // r9
  int v240; // r3
  char *v241; // r2
  int n; // r3
  int v243; // r1
  int v244; // r3
  int v245; // r4
  int v246; // r3
  int v247; // r0
  int v248; // r4
  _DWORD *v249; // r3
  int v250; // r4
  const char **v251; // r9
  int v252; // r0
  int v253; // r3
  const char *v254; // r9
  int v255; // r3
  _DWORD *v256; // r2
  int m; // r3
  int v258; // r1
  int v259; // r3
  int v260; // r8
  int v261; // r3
  int v262; // r0
  int v263; // r8
  int v264; // r3
  int v265; // r8
  const char **v266; // r9
  int v267; // r0
  int v268; // r3
  const char *v269; // r5
  const char *v270; // r5
  char *v271; // r4
  int v272; // r0
  int v273; // r1
  int v274; // r2
  int v275; // r3
  _DWORD *v276; // r5
  _DWORD *v277; // r4
  int v278; // r1
  int v279; // r2
  int v280; // r0
  const char *v281; // lr
  char *v282; // r12
  int v283; // r1
  int v284; // r4
  int v285; // r3
  int *v286; // r0
  signed int v287; // r3
  signed int v288; // r0
  int v289; // r1
  int v290; // r4
  int *v291; // r0
  int *v292; // r0
  int *v293; // r0
  void *v294; // r4
  int v295; // r3
  pthread_mutex_t *v296; // r0
  int v297; // r4
  int jj; // r4
  int v299; // r3
  int v300; // r4
  _BYTE *v301; // r9
  const char *v302; // r5
  int kk; // r3
  int v304; // r4
  char v306; // [sp+10h] [bp-2010h] BYREF
  char v307[4088]; // [sp+1018h] [bp-1008h] BYREF
  const char *v308; // [sp+2010h] [bp-10h]
  const char **v309; // [sp+2020h] [bp+0h]
  void *(*v310)(void *); // [sp+2024h] [bp+4h]
  char *v311; // [sp+2028h] [bp+8h]
  char *v312; // [sp+202Ch] [bp+Ch]
  int *v313; // [sp+2030h] [bp+10h]
  char *v314; // [sp+2034h] [bp+14h]
  const char **v315; // [sp+2038h] [bp+18h]
  _DWORD *ii; // [sp+203Ch] [bp+1Ch]
  char *v317; // [sp+2040h] [bp+20h]
  char *s; // [sp+2044h] [bp+24h]
  unsigned __int8 *v319; // [sp+2048h] [bp+28h]
  char *format; // [sp+204Ch] [bp+2Ch]
  unsigned int v321; // [sp+2050h] [bp+30h]
  int v322; // [sp+2054h] [bp+34h] BYREF
  void **v323; // [sp+2058h] [bp+38h] BYREF
  struct sigaction v324; // [sp+205Ch] [bp+3Ch] BYREF
  char v325[256]; // [sp+20E8h] [bp+C8h] BYREF
  int v326[513]; // [sp+21E8h] [bp+1C8h] BYREF

  v315 = argv;
  v322 = argc;
  strcpy((char *)&g_logfile_path, "bmminer.log");
  v312 = &g_logfile_enable;
  strcpy((char *)&g_logfile_openflag, "a+");
  g_logfile_enable = 0;
  v323 = 0;
  v310 = (void *(*)(void *))&g_logfile_openflag;
  v3 = sysconf(84);
  v6 = v3 == 1;
  if ( v3 == 1 )
  {
    v5 = (int (**)(void))&selective_yield;
    v4 = sched_yield;
  }
  v7 = v322 + 1;
  if ( v6 )
    *v5 = v4;
  v319 = (unsigned __int8 *)&opt_logfile_path;
  v8 = (char *)cgmalloc(4 * v7, "cgminer.c", "main", 11459);
  v9 = v322;
  v10 = v8;
  initial_args = (int)v8;
  if ( v322 > 0 )
  {
    v11 = v8 - 4;
    v12 = 0;
    v13 = v315 - 1;
    do
    {
      v14 = v13[1];
      ++v13;
      ++v12;
      v15 = _strdup(v14);
      v9 = v322;
      *((_DWORD *)v11 + 1) = v15;
      v11 += 4;
    }
    while ( v9 > v12 );
  }
  *(_DWORD *)&v10[4 * v9] = 0;
  mutex_init_constprop_66(&hash_lock, "main", 11468);
  mutex_init_constprop_66(&update_job_lock, "main", 11469);
  mutex_init_constprop_66(&console_lock, "main", 11470);
  cglock_init_constprop_65((int)&control_lock, "main", 11471);
  mutex_init_constprop_66(&stats_lock, "main", 11472);
  ii = &unk_81C48;
  mutex_init_constprop_66(&sharelog_lock, "main", 11473);
  cglock_init_constprop_65((int)&ch_lock, "main", 11474);
  mutex_init_constprop_66(&sshare_lock, "main", 11475);
  rwlock_init_constprop_68(&blk_lock, "main", 11476);
  rwlock_init_constprop_68(&netacc_lock, "main", 11477);
  rwlock_init_constprop_68(&mining_thr_lock, "main", 11478);
  rwlock_init_constprop_68(&devices_lock, "main", 11479);
  mutex_init_constprop_66(&lp_lock, "main", 11481);
  if ( pthread_cond_init(&lp_cond, 0) )
  {
    strcpy((char *)v326, "Failed to pthread_cond_init lp_cond");
    applog(3, (const char *)v326, 1);
    _quit(1, 0);
  }
  mutex_init_constprop_66(&restart_lock, "main", 11488);
  if ( pthread_cond_init(&restart_cond, 0) )
  {
    strcpy((char *)v326, "Failed to pthread_cond_init restart_cond");
    applog(3, (const char *)v326, 1);
    _quit(1, 0);
  }
  if ( pthread_cond_init(&gws_cond, 0) )
  {
    strcpy((char *)v326, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v16 = tq_new();
    getq = (int)v16;
    if ( v16 )
    {
      v308 = "2.0.0";
      *((_DWORD *)v319 + 279) = (char *)v16 + 12;
      snprintf(packagename, 256u, "%s %s", "bmminer", v308);
      v324.sa_flags = 0;
      v324.sa_handler = (__sighandler_t)sighandler;
      sigemptyset(&v324.sa_mask);
      sigaction(15, &v324, &termhandler);
      sigaction(2, &v324, &inthandler);
      sigaction(6, &v324, &abrthandler);
      opt_kernel_path = (int)v307;
      strcpy(v307, "/usr/bin");
      cgminer_path = (int)&v306;
      v17 = *v315;
      v311 = "/";
      v309 = (const char **)&opt_kernel_path;
      v18 = _strdup(v17);
      v19 = (char *)cgminer_path;
      v20 = v18;
      v21 = dirname(v18);
      strcpy(v19, v21);
      free(v20);
      v22 = 36;
      *(_WORD *)(cgminer_path + strlen((const char *)cgminer_path)) = *(_WORD *)v311;
      ii[670] = 9;
      v23 = (char *)cgcalloc(104u, 1u, "cgminer.c", "main", 11535);
      s = v23;
      do
      {
        v24 = strlen(v23);
        --v22;
        *(_WORD *)&v23[v24] = 48;
      }
      while ( v22 );
      v25 = -17973521;
      v26 = v24 + 1;
      v321 = v24 + 1;
      v27 = v24 + 1 > 11;
      v28 = -1640531527;
      v29 = -1640531527;
      if ( v27 )
      {
        v166 = v26;
        v30 = -1640531527;
        v31 = s + 12;
        do
        {
          v32 = (unsigned __int8)*(v31 - 6);
          v166 -= 12;
          v33 = (unsigned __int8)*(v31 - 7);
          v34 = (unsigned __int8)*(v31 - 10);
          v165 = (unsigned __int8 *)v31;
          v35 = (unsigned __int8)*(v31 - 11);
          v31 += 12;
          v36 = v30 + (v32 << 16) + (v33 << 8) + (unsigned __int8)*(v31 - 20) + ((unsigned __int8)*(v31 - 17) << 24);
          v37 = ((unsigned __int8)*(v31 - 14) << 16)
              + ((unsigned __int8)*(v31 - 15) << 8)
              + (unsigned __int8)*(v31 - 16)
              + ((unsigned __int8)*(v31 - 13) << 24)
              + v25;
          v38 = ((unsigned __int8)*(v31 - 24)
               + (v34 << 16)
               + (v35 << 8)
               + ((unsigned __int8)*(v31 - 21) << 24)
               - v36
               - v37
               + v29) ^ (v37 >> 13);
          v39 = (v36 - v37 - v38) ^ (v38 << 8);
          v40 = (v37 - v38 - v39) ^ (v39 >> 13);
          v41 = (v38 - v39 - v40) ^ (v40 >> 12);
          v42 = (v39 - v40 - v41) ^ (v41 << 16);
          v43 = (v40 - v41 - v42) ^ (v42 >> 5);
          v29 = (v41 - v42 - v43) ^ (v43 >> 3);
          v30 = (v42 - v43 - v29) ^ (v29 << 10);
          v25 = (v43 - v29 - v30) ^ (v30 >> 15);
        }
        while ( v166 > 11 );
        v28 = (v42 - v43 - v29) ^ (v29 << 10);
      }
      else
      {
        v165 = (unsigned __int8 *)s;
        v166 = v321;
      }
      v44 = v321 + v25;
      switch ( v166 )
      {
        case 1u:
          goto LABEL_30;
        case 2u:
          goto LABEL_29;
        case 3u:
          goto LABEL_28;
        case 4u:
          goto LABEL_27;
        case 5u:
          goto LABEL_26;
        case 6u:
          goto LABEL_25;
        case 7u:
          goto LABEL_24;
        case 8u:
          goto LABEL_23;
        case 9u:
          goto LABEL_22;
        case 10u:
          goto LABEL_21;
        case 11u:
          v44 += v165[10] << 24;
LABEL_21:
          v44 += v165[9] << 16;
LABEL_22:
          v44 += v165[8] << 8;
LABEL_23:
          v28 += v165[7] << 24;
LABEL_24:
          v28 += v165[6] << 16;
LABEL_25:
          v28 += v165[5] << 8;
LABEL_26:
          v28 += v165[4];
LABEL_27:
          v29 += v165[3] << 24;
LABEL_28:
          v29 += v165[2] << 16;
LABEL_29:
          v29 += v165[1] << 8;
LABEL_30:
          v29 += *v165;
          break;
        default:
          break;
      }
      v45 = s;
      *((_DWORD *)s + 22) = s;
      v46 = (v29 - v28 - v44) ^ (v44 >> 13);
      v47 = (v28 - v44 - v46) ^ (v46 << 8);
      v48 = (v44 - v46 - v47) ^ (v47 >> 13);
      v49 = (v46 - v47 - v48) ^ (v48 >> 12);
      v50 = (v47 - v48 - v49) ^ (v49 << 16);
      v51 = (v48 - v49 - v50) ^ (v50 >> 5);
      v52 = v49 - v50 - v51;
      v53 = (v51 - (v52 ^ (v51 >> 3)) - ((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10))) ^ (((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10)) >> 15);
      *((_DWORD *)v45 + 24) = v53;
      v54 = strlen(v45);
      v55 = ii;
      *((_DWORD *)v45 + 23) = v54;
      v56 = v55[642];
      if ( v56 )
      {
        v57 = s;
        *((_DWORD *)s + 17) = *(_DWORD *)(v56 + 68);
        v58 = v57 + 68;
        v59 = *(_DWORD *)(v56 + 68);
        *((_DWORD *)v57 + 19) = 0;
        v60 = *(_DWORD *)(v59 + 16);
        *((_DWORD *)v57 + 18) = v60 - *(_DWORD *)(v59 + 20);
        *(_DWORD *)(v60 + 8) = v57;
        *(_DWORD *)(v59 + 16) = v57 + 68;
      }
      else
      {
        v167 = ii;
        *((_DWORD *)v45 + 19) = 0;
        *((_DWORD *)v45 + 18) = 0;
        v167[642] = v45;
        v168 = malloc(44u);
        *((_DWORD *)v45 + 17) = v168;
        if ( !v168 )
          goto LABEL_183;
        v169 = s;
        memset(v168, 0, 44u);
        v58 = v169 + 68;
        v170 = (_DWORD *)*((_DWORD *)v169 + 17);
        v170[4] = v169 + 68;
        v170[1] = 32;
        v170[2] = 5;
        v170[5] = 68;
        v171 = malloc(384u);
        *v170 = v171;
        if ( !v171 )
          goto LABEL_183;
        memset(v171, 0, 384u);
        *(_DWORD *)(*((_DWORD *)v169 + 17) + 40) = -1609490463;
      }
      v61 = s;
      v62 = *(int **)(ii[642] + 68);
      v63 = *v62;
      v64 = 3 * (v53 & (v62[1] - 1));
      ++v62[3];
      v65 = *(_DWORD *)(v63 + 4 * v64);
      v66 = *(_DWORD *)(v63 + 4 * v64 + 4) + 1;
      *(_DWORD *)(v63 + 4 * v64 + 4) = v66;
      *((_DWORD *)v61 + 21) = v65;
      *((_DWORD *)v61 + 20) = 0;
      if ( v65 )
        *(_DWORD *)(v65 + 12) = v58;
      v67 = *(_DWORD *)(v63 + 4 * v64 + 8);
      *(_DWORD *)(v63 + 4 * v64) = v58;
      if ( v66 < 10 * (v67 + 1) || (v68 = s, v69 = *((_DWORD *)s + 17), *(_DWORD *)(v69 + 36) == 1) )
      {
LABEL_54:
        strcpy(current_hash, s);
        scan_devices = (int)&scan_devices;
        dword_80EED4 = (int)&scan_devices;
        opt_register_table((int)&opt_config_table, (int)"Options for both config file and command line");
        opt_register_table((int)&opt_cmdline_table, (int)"Options for command line only");
        opt_parse(&v322, v315, (void (*)(const char *, ...))applog_and_exit);
        if ( v322 != 1 )
        {
          strcpy((char *)v326, "Unexpected extra commandline arguments");
          applog(3, (const char *)v326, 1);
          _quit(1, 0);
        }
        v93 = v319[844];
        if ( !v319[844] )
        {
          v162 = (char *)cgmalloc(4096u, "cgminer.c", "load_default_config", 2089);
          v163 = (const char **)v319;
          *((_DWORD *)v319 + 209) = v162;
          default_save_file(v162);
          if ( access(v163[209], 4) )
          {
            v164 = v319;
            free(*((void **)v319 + 209));
            v164[209] = v93;
          }
          else
          {
            load_config(*((char **)v319 + 209));
          }
        }
        if ( v319[1408] || *((_DWORD *)v319 + 275) )
        {
          v94 = add_pool();
          v95 = cgmalloc(255u, "cgminer.c", "main", 11571);
          v96 = v319;
          v97 = v95;
          *((_DWORD *)v94 + 41) = v95;
          if ( v96[275] )
            v98 = "Benchfile";
          else
            v98 = "Benchmark";
          v99 = *(_DWORD *)v98;
          v100 = *((_DWORD *)v98 + 1);
          v101 = *((_WORD *)v98 + 4);
          *v97 = v99;
          v97[1] = v100;
          *((_WORD *)v97 + 4) = v101;
          v102 = *((_DWORD *)v94 + 41);
          *((_DWORD *)v94 + 43) = v102;
          *((_DWORD *)v94 + 44) = v102;
          *((_DWORD *)v94 + 42) = v102;
          *((_DWORD *)v94 + 150) = v102;
          strncpy(v94 + 48, "?", 7u);
          v103 = *((_DWORD *)v94 + 25);
          v94[55] = 0;
          if ( v103 != 1 )
          {
            *((_DWORD *)v94 + 25) = 1;
            ++enabled_pools;
          }
          v104 = (char *)&bench_hidiff_bins;
          v105 = &bench_lodiff_bins;
          v94[97] = 0;
          v106 = 0;
          successful_connect = 1;
          do
          {
            v107 = v104;
            v104 += 160;
            hex2bin(v107, (unsigned __int8 *)&bench_hidiffs[v106], 160);
            v108 = (unsigned __int8 *)&bench_lodiffs[v106];
            v106 += 324;
            hex2bin(v105, v108, 160);
            v105 += 160;
          }
          while ( v104 != (char *)&bench_lodiff_bins );
          set_target(&bench_target);
        }
        v109 = (const char *)*((_DWORD *)v319 + 4);
        if ( !v109 )
          goto LABEL_83;
        v110 = fopen(v109, "rb");
        memset(v325, 0, sizeof(v325));
        if ( v110 )
        {
          v111 = fread(v325, 1u, 256u, v110);
          if ( v111 <= 0 )
          {
            v116 = &use_syslog;
            if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
              goto LABEL_180;
            snprintf((char *)v326, 2048u, "Read miner version file %s error %d", *((const char **)v319 + 4), v111);
            applog(3, (const char *)v326, 0);
          }
          else
          {
            v112 = strchr(v325, 10);
            v113 = v112;
            if ( v112 )
            {
              cg_memcpy(g_miner_compiletime, v325, v112 - v325, (int)"cgminer.c", (int)"main", 11630);
              v114 = stpcpy(v325, v113 + 1);
              v115 = strchr(v325, 10);
              if ( v115 )
                cg_memcpy(g_miner_type, v325, v115 - v325, (int)"cgminer.c", (int)"main", 11639);
              else
                memcpy(g_miner_type, v325, v114 - (_DWORD)v325 + 1);
            }
            else
            {
              strcpy(g_miner_compiletime, v325);
            }
            LOWORD(v116) = -13288;
            v117 = (size_t)ii + strlen(g_miner_compiletime) - 1;
            if ( *(_BYTE *)(v117 + 2684) == 10 )
              *(_BYTE *)(v117 + 2684) = 0;
            v118 = (size_t)ii + strlen(g_miner_compiletime) - 1;
            if ( *(_BYTE *)(v118 + 2684) == 13 )
              *(_BYTE *)(v118 + 2684) = 0;
            v119 = (size_t)ii + strlen(g_miner_type) - 1;
            if ( *(_BYTE *)(v119 + 2940) == 10 )
              *(_BYTE *)(v119 + 2940) = 0;
            v120 = strlen(g_miner_type) - 1;
            HIWORD(v116) = 128;
            if ( *((_BYTE *)ii + v120 + 2940) == 13 )
              *((_BYTE *)ii + v120 + 2940) = 0;
          }
        }
        else
        {
          v116 = &use_syslog;
          if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
            goto LABEL_180;
          snprintf((char *)v326, 2048u, "Open miner version file %s error", *((const char **)v319 + 4));
          applog(3, (const char *)v326, 0);
        }
        if ( *v116 || opt_log_output )
          goto LABEL_82;
LABEL_180:
        if ( opt_log_level > 2 )
        {
LABEL_82:
          snprintf((char *)v326, 2048u, "Miner compile time: %s type: %s", g_miner_compiletime, g_miner_type);
          applog(3, (const char *)v326, 0);
        }
LABEL_83:
        v121 = v319;
        v122 = *(const char **)v319;
        if ( *(_DWORD *)v319 )
        {
          *v312 = 1;
          strcpy((char *)&g_logfile_path, v122);
          v123 = (const char *)*((_DWORD *)v121 + 3);
          if ( v123 )
            strcpy((char *)&g_logfile_openflag, v123);
          if ( !use_syslog )
          {
            v321 = (unsigned int)&opt_log_output;
            if ( !opt_log_output && opt_log_level <= 2 )
            {
              v124 = (const char *)*((_DWORD *)v319 + 2);
              if ( !v124 )
              {
LABEL_128:
                if ( opt_log_level <= 3 )
                {
                  v150 = (const char *)*((_DWORD *)v319 + 209);
                  if ( !v150 )
                  {
LABEL_140:
                    *(_WORD *)&(*v309)[strlen(*v309)] = *(_WORD *)v311;
                    if ( want_per_device_stats )
                    {
                      *(_BYTE *)v321 = 1;
                    }
                    else if ( !*(_BYTE *)v321 )
                    {
                      setlogmask(63);
                      goto LABEL_143;
                    }
                    setlogmask(255);
LABEL_143:
                    v153 = opt_scantime;
                    LOWORD(v154) = (unsigned __int16)&bitforce_drv;
                    s = (char *)&control_thr;
                    if ( opt_scantime < 0 )
                      v153 = 60;
                    if ( opt_scantime < 0 )
                      opt_scantime = v153;
                    ii[932] = 8;
                    HIWORD(v154) = (unsigned int)&bitforce_drv >> 16;
                    control_thr = (int)cgcalloc(8u, 64u, "cgminer.c", "main", 11795);
                    fill_device_drv(v154);
                    fill_device_drv((int)&modminer_drv);
                    fill_device_drv((int)&bitmain_drv);
                    fill_device_drv((int)&bitmain_c5_drv);
                    (*(void (__fastcall **)(_DWORD))(v154 + 12))(0);
                    ((void (__fastcall *)(_DWORD))dword_80B91C)(0);
                    ((void (__fastcall *)(_DWORD))dword_80B83C)(0);
                    v155 = 0;
                    ((void (__fastcall *)())off_7E3EC)();
                    v156 = total_devices;
                    format = (char *)&mining_threads;
                    mining_threads = 0;
                    if ( total_devices > 0 )
                    {
                      do
                      {
                        v157 = *(pthread_rwlock_t **)(devices + 4 * v155++);
                        enable_device(v157);
                        v156 = total_devices;
                      }
                      while ( total_devices > v155 );
                    }
                    if ( !v156 )
                    {
                      strcpy((char *)v326, "All devices disabled, cannot mint!");
                      applog(3, (const char *)v326, 1);
                      _quit(1, 0);
                    }
                    v158 = (char *)*((_DWORD *)v319 + 264);
                    ii[669] = v156;
                    if ( v158 )
                    {
                      v159 = 0;
                      v160 = 0;
                      for ( i = strtok(v158, ","); i; i = strtok(v317, ",") )
                      {
                        if ( total_devices <= v159 )
                        {
                          strcpy((char *)v326, "Too many values passed to set temp cutoff");
                          applog(3, (const char *)v326, 1);
                          _quit(1, 1);
                        }
                        v160 = (char *)strtol(i, 0, 10);
                        if ( (unsigned int)v160 > 200 )
                        {
                          v127 = "ssed to set temp cutoff";
                          qmemcpy(v326, "Invalid value pa", 16);
                          v128 = &v326[4];
                          goto LABEL_102;
                        }
                        if ( pthread_rwlock_rdlock(&devices_lock) )
                          rd_lock_part_39_constprop_80("load_temp_cutoffs", 1315);
                        *(_DWORD *)(*(_DWORD *)(devices + 4 * v159) + 184) = v160;
                        if ( pthread_rwlock_unlock(&devices_lock) )
                        {
                          v197 = _errno_location();
                          snprintf(
                            (char *)v326,
                            2048u,
                            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                            *v197,
                            "cgminer.c",
                            "load_temp_cutoffs",
                            1317);
                          v136 = (const char *)v326;
                          goto LABEL_103;
                        }
                        ++v159;
                        v317 = 0;
                        selective_yield(0);
                      }
                      if ( v159 <= 1 )
                      {
                        v317 = v160;
                        if ( pthread_rwlock_rdlock(&devices_lock) )
                          rd_lock_part_39_constprop_80("load_temp_cutoffs", 1338);
                        v225 = total_devices;
                        v226 = v317;
                        v227 = devices;
                        while ( v159 < v225 )
                        {
                          v228 = *(_DWORD *)(v227 + 4 * v159++);
                          *(_DWORD *)(v228 + 184) = v226;
                        }
                        wr_unlock_constprop_78(&devices_lock, "load_temp_cutoffs", 1344);
                      }
                    }
                    else
                    {
                      if ( pthread_rwlock_rdlock(&devices_lock) )
                        rd_lock_part_39_constprop_80("load_temp_cutoffs", 1322);
                      v186 = 0;
                      v187 = total_devices;
                      v188 = devices;
                      while ( v186 < v187 )
                      {
                        v189 = *(_DWORD *)(v188 + 4 * v186);
                        if ( !*(_DWORD *)(v189 + 184) )
                          *(_DWORD *)(v189 + 184) = 95;
                        ++v186;
                      }
                      wr_unlock_constprop_78(&devices_lock, "load_temp_cutoffs", 1331);
                    }
                    v174 = total_devices;
                    v175 = devices;
                    for ( j = 0; j < v174; ++j )
                    {
                      v177 = *(_DWORD *)(v175 + 4 * j);
                      *(_DWORD *)(v177 + 312) = 99999999;
                    }
                    if ( !opt_compact )
                      ii[670] += ii[669];
                    v315 = (const char **)&total_pools;
                    if ( !total_pools )
                    {
                      if ( use_syslog || *(_BYTE *)v321 || opt_log_level > 3 )
                      {
                        strcpy((char *)v326, "Need to specify at least one pool server.");
                        applog(4, (const char *)v326, 0);
                      }
                      strcpy((char *)v326, "Pool setup failed");
                      applog(3, (const char *)v326, 1);
                      _quit(1, 0);
                    }
                    v313 = &devices;
                    v312 = (char *)&total_devices;
                    v317 = (char *)&pools;
                    v178 = 0;
                    v314 = "cgminer.c";
                    while ( v178 < total_pools )
                    {
                      v179 = *(_DWORD *)(pools + 4 * v178);
                      v180 = *(_DWORD *)(v179 + 168);
                      *(_DWORD *)(v179 + 404) = 99999999;
                      *(_DWORD *)(v179 + 440) = 99999999;
                      if ( !v180 )
                      {
                        if ( !*(_DWORD *)(v179 + 176) )
                          *(_DWORD *)(v179 + 176) = calloc(1u, 1u);
                        v181 = *(const char **)(v179 + 172);
                        if ( !v181 )
                        {
                          snprintf(
                            (char *)v326,
                            2048u,
                            "No login credentials supplied for pool %u %s",
                            v178,
                            *(const char **)(v179 + 164));
                          applog(3, (const char *)v326, 1);
                          _quit(1, 0);
                        }
                        v182 = strlen(v181);
                        v183 = strlen(*(const char **)(v179 + 176)) + v182 + 2;
                        v184 = (char *)cgmalloc(v183, v314, "main", 11904);
                        v185 = *(const char **)(v179 + 176);
                        *(_DWORD *)(v179 + 168) = v184;
                        snprintf(v184, v183, "%s:%s", *(const char **)(v179 + 172), v185);
                      }
                      ++v178;
                    }
                    v190 = (char *)v313;
                    v191 = (unsigned __int8)use_syslog;
                    v192 = v312;
                    *((_DWORD *)v319 + 299) = **(_DWORD **)v317;
                    if ( v191 )
                      openlog("bmminer", 1, 8);
                    if ( ii[933] )
                    {
                      if ( pipe(v326) < 0 )
                      {
                        perror("pipe - failed to create pipe for --monitor");
                        exit(1);
                      }
                      fflush((FILE *)_bss_start);
                      if ( dup2(v326[1], 2) < 0 )
                      {
                        perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                        exit(1);
                      }
                      if ( close(v326[1]) < 0 )
                      {
                        perror("close - failed to close write end of pipe for --monitor");
                        exit(1);
                      }
                      v193 = signal(13, (__sighandler_t)1);
                      v194 = signal(13, (__sighandler_t)1);
                      if ( v193 == (__sighandler_t)-1 || v194 == (__sighandler_t)-1 )
                      {
                        perror("signal - failed to edit signal mask for --monitor");
                        exit(1);
                      }
                      v195 = fork();
                      v196 = v195;
                      *((_DWORD *)v319 + 273) = v195;
                      if ( v195 < 0 )
                      {
                        perror("fork - failed to fork child process for --monitor");
                        exit(1);
                      }
                      if ( !v195 )
                      {
                        if ( dup2(v326[0], 0) >= 0 )
                        {
                          close(v326[0]);
                          execl("/bin/bash", "/bin/bash", "-c", ii[933], v196);
                          perror("execl - in child failed to exec user specified command for --monitor");
                          exit(1);
                        }
                        perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                        exit(1);
                      }
                      if ( close(v326[0]) < 0 )
                      {
                        perror("close - failed to close read end of pipe for --monitor");
                        exit(1);
                      }
                    }
                    v198 = *(_DWORD *)format;
                    v313 = &mining_thr;
                    mining_thr = (int)cgcalloc(v198, 4u, "cgminer.c", "main", 11921);
                    for ( k = 0; k < *(_DWORD *)format; ++k )
                    {
                      v200 = *v313;
                      *(_DWORD *)(v200 + 4 * k) = cgcalloc(1u, 64u, "cgminer.c", "main", 11925);
                    }
                    v311 = &use_syslog;
                    v201 = 0;
                    v314 = 0;
                    v309 = (const char **)&opt_debug;
                    v312 = (char *)v326;
                    while ( (int)v314 < *(_DWORD *)v192 )
                    {
                      v202 = *(_DWORD **)(*(_DWORD *)v190 + 4 * (_DWORD)v314);
                      v310 = (void *(*)(void *))miner_thread;
                      v203 = 0;
                      v204 = cgmalloc(4 * (v202[37] + 1), "cgminer.c", "main", 11934);
                      v205 = v202[37];
                      v202[38] = v204;
                      v204[v205] = 0;
                      v202[24] = 4;
                      while ( v203 < v205 )
                      {
                        thread = (sem_t *)get_thread(v201 + v203);
                        v207 = v202[1];
                        v208 = thread;
                        thread->__align = v201 + v203;
                        *(&thread[2].__align + 1) = (int)v202;
                        v209 = *(int (**)(void))(v207 + 44);
                        *(&thread->__align + 1) = v203;
                        if ( v209() )
                        {
                          if ( thr_info_create((int)v208, 0, v310, v208) )
                          {
                            v212 = v312;
                            snprintf(v312, 2048u, "thread %d create failed", v208->__align);
                            applog(3, v212, 1);
                            _quit(1, 0);
                          }
                          v210 = v202[8];
                          *(_DWORD *)(v202[38] + 4 * v203) = v208;
                          if ( v210 != 1 )
                          {
                            if ( *(_BYTE *)v309 && (*v311 || *(_BYTE *)v321 || opt_log_level > 6) )
                            {
                              v211 = v312;
                              snprintf(v312, 2048u, "Pushing sem post to thread %d", v208->__align);
                              applog(7, v211, 0);
                            }
                            cgsem_post(v208 + 1, "cgminer.c", "main", 11962);
                          }
                        }
                        v205 = v202[37];
                        ++v203;
                      }
                      v201 += v203;
                      ++v314;
                    }
                    v213 = v312;
                    v214 = v311;
                    v215 = v319[1408];
                    if ( v319[1408] || *((_DWORD *)v319 + 275) )
                    {
LABEL_281:
                      v216 = (int *)&g_local_mhashes_dones;
                      total_mhashes_done = 0LL;
                      do
                      {
                        *(_QWORD *)v216 = 0LL;
                        v216 += 2;
                      }
                      while ( v216 != &g_local_mhashes_index );
                      v217 = *(_DWORD *)v192;
                      v218 = 0;
                      v219 = *(_DWORD *)v190;
                      *((_DWORD *)v319 + 332) = 0;
                      while ( v218 < v217 )
                      {
                        v220 = *(_DWORD *)(v219 + 4 * v218++);
                        *(_QWORD *)(v220 + 80) = 0LL;
                        *(_QWORD *)(v220 + 48) = 0LL;
                      }
                      cgtime((struct timeval *)&total_tv_start);
                      cgtime((struct timeval *)&total_tv_end);
                      cgtime(&tv_hashmeter);
                      get_datestamp(datestamp, 40u, &total_tv_start);
                      v221 = *(_DWORD *)s;
                      *((_DWORD *)v319 + 297) = 2;
                      if ( thr_info_create(v221 + 128, 0, (void *(*)(void *))watchpool_thread, 0) )
                      {
                        strcpy(v213, "watchpool thread create failed");
                        applog(3, v213, 1);
                        _quit(1, 0);
                      }
                      pthread_detach(*(_DWORD *)(v221 + 140));
                      v222 = *(_DWORD *)s;
                      *((_DWORD *)v319 + 298) = 3;
                      if ( thr_info_create(v222 + 192, 0, (void *(*)(void *))watchdog_thread, 0) )
                      {
                        strcpy(v213, "watchdog thread create failed");
                        applog(3, v213, 1);
                        _quit(1, 0);
                      }
                      pthread_detach(*(_DWORD *)(v222 + 204));
                      v223 = *(_DWORD *)s;
                      *((_DWORD *)v319 + 208) = 5;
                      if ( thr_info_create(v223 + 320, 0, (void *(*)(void *))api_thread, (void *)(v223 + 320)) )
                      {
                        strcpy(v213, "API thread create failed");
                        applog(3, v213, 1);
                        _quit(1, 0);
                      }
                      v224 = ii[932];
                      if ( v224 != 8 )
                      {
                        snprintf(v213, 2048u, "incorrect total_control_threads (%d) should be 8", v224);
                        applog(3, v213, 1);
                        _quit(1, 0);
                      }
                      if ( !nice(-10) && opt_debug && (*v214 || *(_BYTE *)v321 || opt_log_level > 6) )
                      {
                        strcpy(v213, "Unable to set thread to high priority");
                        applog(7, v213, 0);
                      }
                      s = v214;
                      v229 = ii;
                      v312 = &opt_work_update;
                      while ( 1 )
                      {
                        if ( *v312 )
                        {
                          if ( *s || *(_BYTE *)v321 || opt_log_level > 5 )
                          {
                            strcpy(v213, "Work update message received");
                            applog(6, v213, 0);
                          }
                          cgtime(&update_tv_start);
                          if ( pthread_rwlock_rdlock(&mining_thr_lock) )
                          {
                            v292 = _errno_location();
                            snprintf(
                              v213,
                              2048u,
                              "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                              *v292,
                              "cgminer.c",
                              "signal_work_update",
                              5425);
                            goto LABEL_427;
                          }
                          v287 = 0;
                          v288 = *(_DWORD *)format;
                          v289 = *v313;
                          while ( v287 < v288 )
                          {
                            v290 = *(_DWORD *)(v289 + 4 * v287++);
                            *(_BYTE *)(v290 + 63) = 1;
                          }
                          if ( pthread_rwlock_unlock(&mining_thr_lock) )
                          {
                            v293 = _errno_location();
                            snprintf(
                              v213,
                              2048u,
                              "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                              *v293,
                              "cgminer.c",
                              "signal_work_update",
                              5432);
LABEL_427:
                            v136 = v213;
LABEL_103:
                            applog(3, v136, 1);
                            _quit(1, 1);
                          }
                          selective_yield(0);
                        }
                        v230 = (pthread_mutex_t *)*((_DWORD *)v319 + 279);
                        *v312 = 0;
                        if ( pthread_mutex_lock(v230) )
                        {
                          v286 = _errno_location();
                          snprintf(
                            v213,
                            2048u,
                            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                            *v286,
                            "cgminer.c",
                            "main",
                            12128);
                          goto LABEL_427;
                        }
                        v231 = *((_DWORD *)v319 + 333);
                        if ( !v231 )
                          break;
                        if ( *(int *)(*(_DWORD *)(v231 + 344) + 12) <= 1 )
                          break;
                        v294 = v319;
                        pthread_cond_wait(&gws_cond, *((pthread_mutex_t **)v319 + 279));
                        v295 = *((_DWORD *)v294 + 333);
                        if ( !v295 )
                          break;
                        v296 = (pthread_mutex_t *)*((_DWORD *)v294 + 279);
                        v297 = *(_DWORD *)(*(_DWORD *)(v295 + 344) + 12);
                        if ( pthread_mutex_unlock(v296) )
                        {
LABEL_438:
                          v291 = _errno_location();
                          snprintf(
                            v213,
                            2048u,
                            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                            *v291,
                            "cgminer.c",
                            "main",
                            12139);
                          goto LABEL_427;
                        }
                        selective_yield(0);
                        if ( v297 <= 1 )
                        {
LABEL_314:
                          if ( v323 )
                            discard_work(&v323, "cgminer.c", "main", 12159);
                          work = (void **)make_work();
                          v314 = &opt_debug;
                          v323 = work;
                          while ( 1 )
                          {
                            v236 = current_pool();
                            v237 = (unsigned __int8 *)v236;
                            v238 = *((_DWORD *)v319 + 263);
                            if ( v238 == 4 )
                            {
                              v237 = (unsigned __int8 *)select_balanced(v236);
                            }
                            else if ( v238 == 3 )
                            {
                              v254 = *v315;
                              v255 = 0;
                              v256 = *(_DWORD **)v317;
                              while ( v255 < (int)v254 )
                              {
                                if ( *(_DWORD *)(v256[v255] + 64) < *(_DWORD *)(v256[v255] + 60) )
                                  goto LABEL_372;
                                ++v255;
                              }
                              for ( m = 0; (int)v254 > m; ++m )
                              {
                                v258 = v256[m];
                                *(_DWORD *)(v258 + 64) = 0;
                              }
                              v259 = v229[934] + 1;
                              if ( (int)v254 <= v259 )
                                v259 = 0;
                              v229[934] = v259;
LABEL_372:
                              v311 = *(char **)v317;
                              ii = 0;
                              while ( (int)v254 > (int)ii )
                              {
                                v260 = v229[934];
                                v261 = *(_DWORD *)&v311[4 * v260];
                                v262 = *(_DWORD *)(v261 + 64);
                                *(_DWORD *)(v261 + 64) = v262 + 1;
                                if ( v262 < *(_DWORD *)(v261 + 60)
                                  && !*(_BYTE *)(v261 + 97)
                                  && *(_DWORD *)(v261 + 100) == 1 )
                                {
                                  v310 = (void *(*)(void *))v261;
                                  if ( !pool_unusable_part_4((unsigned __int8 *)v261) )
                                  {
                                    v237 = (unsigned __int8 *)v310;
                                    goto LABEL_318;
                                  }
                                }
                                v263 = v260 + 1;
                                ii = (_DWORD *)((char *)ii + 1);
                                if ( (int)v254 > v263 )
                                  v264 = v263;
                                else
                                  v264 = 0;
                                v229[934] = v264;
                              }
                              v265 = 0;
                              v266 = v315;
                              while ( 1 )
                              {
                                if ( v265 >= (int)*v266 )
                                  goto LABEL_318;
                                v267 = priority_pool(v265);
                                v268 = *(unsigned __int8 *)(v267 + 97);
                                ii = (_DWORD *)v267;
                                if ( !v268
                                  && *(_DWORD *)(v267 + 100) == 1
                                  && !pool_unusable_part_4((unsigned __int8 *)v267) )
                                {
                                  break;
                                }
                                ++v265;
                              }
                              v237 = (unsigned __int8 *)ii;
                            }
LABEL_318:
                            if ( *v314 && (*s || *(_BYTE *)v321 || opt_log_level > 6) )
                            {
                              snprintf(v213, 2048u, "Selecting pool %d for work", *(_DWORD *)v237);
                              applog(7, v213, 0);
                            }
                            if ( !v237[97] && *((_DWORD *)v237 + 25) == 1 && !pool_unusable_part_4(v237) )
                              break;
                            switch_pools(0);
                            v233 = current_pool();
                            v234 = (unsigned __int8 *)v233;
                            v235 = *((_DWORD *)v319 + 263);
                            if ( v235 == 4 )
                            {
                              v234 = (unsigned __int8 *)select_balanced(v233);
                            }
                            else if ( v235 == 3 )
                            {
                              v239 = *v315;
                              v240 = 0;
                              v241 = *(char **)v317;
                              while ( v240 < (int)v239 )
                              {
                                if ( *(_DWORD *)(*(_DWORD *)&v241[4 * v240] + 64) < *(_DWORD *)(*(_DWORD *)&v241[4 * v240]
                                                                                              + 60) )
                                  goto LABEL_347;
                                ++v240;
                              }
                              for ( n = 0; (int)v239 > n; ++n )
                              {
                                v243 = *(_DWORD *)&v241[4 * n];
                                *(_DWORD *)(v243 + 64) = 0;
                              }
                              v244 = v229[934] + 1;
                              if ( (int)v239 <= v244 )
                                v244 = 0;
                              v229[934] = v244;
LABEL_347:
                              v311 = *(char **)v317;
                              for ( ii = 0; (int)v239 > (int)ii; ii = v249 )
                              {
                                v245 = v229[934];
                                v246 = *(_DWORD *)&v311[4 * v245];
                                v247 = *(_DWORD *)(v246 + 64);
                                *(_DWORD *)(v246 + 64) = v247 + 1;
                                if ( v247 < *(_DWORD *)(v246 + 60)
                                  && !*(_BYTE *)(v246 + 97)
                                  && *(_DWORD *)(v246 + 100) == 1 )
                                {
                                  v310 = (void *(*)(void *))v246;
                                  if ( !pool_unusable_part_4((unsigned __int8 *)v246) )
                                  {
                                    v234 = (unsigned __int8 *)v310;
                                    goto LABEL_327;
                                  }
                                }
                                v248 = v245 + 1;
                                if ( (int)v239 <= v248 )
                                  v248 = 0;
                                v249 = (_DWORD *)((char *)ii + 1);
                                v229[934] = v248;
                              }
                              v250 = 0;
                              v251 = v315;
                              while ( 1 )
                              {
                                if ( v250 >= (int)*v251 )
                                  goto LABEL_327;
                                v252 = priority_pool(v250);
                                v253 = *(unsigned __int8 *)(v252 + 97);
                                ii = (_DWORD *)v252;
                                if ( !v253
                                  && *(_DWORD *)(v252 + 100) == 1
                                  && !pool_unusable_part_4((unsigned __int8 *)v252) )
                                {
                                  break;
                                }
                                ++v250;
                              }
                              v234 = (unsigned __int8 *)ii;
                            }
LABEL_327:
                            if ( *v314 && (*s || *(_BYTE *)v321 || opt_log_level > 6) )
                            {
                              snprintf(v213, 2048u, "Selecting pool %d for work", *(_DWORD *)v234);
                              applog(7, v213, 0);
                            }
                            if ( v234[97] || *((_DWORD *)v234 + 25) != 1 || pool_unusable_part_4(v234) )
                              cgsleep_ms();
                          }
                          v269 = v314;
                          if ( v237[640] )
                          {
                            gen_stratum_work((int)v237, (int)v323);
                            if ( *v269 && (*s || *(_BYTE *)v321 || opt_log_level > 6) )
                            {
                              strcpy(v213, "Generated stratum work");
                              applog(7, v213, 0);
                            }
                            goto LABEL_399;
                          }
                          if ( *((_DWORD *)v319 + 275) )
                          {
                            get_benchfile_work((int)v323);
                            if ( *v269 && (*s || *(_BYTE *)v321 || opt_log_level > 6) )
                            {
                              v270 = "Generated benchfile work";
                              v271 = v213;
LABEL_398:
                              v272 = *(_DWORD *)v270;
                              v273 = *((_DWORD *)v270 + 1);
                              v274 = *((_DWORD *)v270 + 2);
                              v275 = *((_DWORD *)v270 + 3);
                              v276 = v270 + 16;
                              *(_DWORD *)v271 = v272;
                              *((_DWORD *)v271 + 1) = v273;
                              *((_DWORD *)v271 + 2) = v274;
                              *((_DWORD *)v271 + 3) = v275;
                              v277 = v271 + 16;
                              v278 = v276[1];
                              v279 = v276[2];
                              *v277 = *v276;
                              v277[1] = v278;
                              *((_BYTE *)v277 + 8) = v279;
                              applog(7, v213, 0);
                              goto LABEL_399;
                            }
                            goto LABEL_399;
                          }
                          if ( v319[1408] )
                          {
                            get_benchmark_work((int)v323);
                            if ( *v269 && (*s || *(_BYTE *)v321 || opt_log_level > 6) )
                            {
                              v270 = "Generated benchmark work";
                              v271 = v213;
                              goto LABEL_398;
                            }
LABEL_399:
                            stage_work((int)v323);
                            v323 = 0;
                          }
                        }
                        else
                        {
                          v323 = (void **)hash_pop(0);
                          if ( v323 )
                            discard_work(&v323, "cgminer.c", "main", 12151);
                        }
                      }
                      if ( pthread_mutex_unlock(*((pthread_mutex_t **)v319 + 279)) )
                        goto LABEL_438;
                      selective_yield(0);
                      goto LABEL_314;
                    }
                    v280 = enabled_pools;
                    v281 = *v315;
                    v282 = *(char **)v317;
                    v283 = v319[1408];
                    while ( v283 < (int)v281 )
                    {
                      v284 = *(_DWORD *)&v282[4 * v283++];
                      v285 = *(_DWORD *)(v284 + 100);
                      *(_BYTE *)(v284 + 97) = 1;
                      if ( v285 != 1 )
                      {
                        ++v280;
                        v215 = 1;
                        *(_DWORD *)(v284 + 100) = 1;
                      }
                    }
                    if ( v215 )
                      enabled_pools = v280;
                    if ( *v214 || *(_BYTE *)v321 || opt_log_level > 4 )
                    {
                      strcpy(v213, "Probing for an alive pool");
                      applog(5, v213, 0);
                    }
                    for ( jj = 0; jj < (int)*v315; ++jj )
                    {
                      v299 = *(_DWORD *)(*(_DWORD *)v317 + 4 * jj);
                      *(_BYTE *)(v299 + 284) = 1;
                      pthread_create((pthread_t *)(v299 + 280), 0, (void *(*)(void *))test_pool_thread, (void *)v299);
                    }
                    v300 = 0;
                    do
                    {
                      ++v300;
                      sleep(1u);
                    }
                    while ( (v300 != 180) > (unsigned int)v319[1476] );
                    v312 = v190;
                    v301 = (_BYTE *)v321;
                    v302 = (const char *)&opt_log_level;
                    for ( kk = 0; ; kk = 1 )
                    {
                      if ( v319[1476] )
                      {
                        v190 = v312;
                        goto LABEL_281;
                      }
                      if ( kk )
                        goto LABEL_463;
                      if ( ((*v214 || *v301 || *(int *)v302 > 2)
                         && ((strcpy(v213, "No servers were found that could be used to get work from."),
                              applog(3, v213, 0),
                              *v214)
                          || *v301)
                         || *(int *)v302 > 2)
                        && ((strcpy(v213, "Please check the details from the list below of the servers you have input"),
                             applog(3, v213, 0),
                             *v214)
                         || *v301)
                        || *(int *)v302 > 2 )
                      {
                        strcpy(
                          v213,
                          "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                        applog(3, v213, 0);
                      }
                      v304 = 0;
                      v314 = (char *)v302;
                      while ( v304 < (int)*v315 )
                      {
                        if ( *v214 || *v301 || *(int *)v314 > 3 )
                        {
                          snprintf(
                            v213,
                            2048u,
                            "Pool: %d  URL: %s  User: %s  Password: %s",
                            v304,
                            *(const char **)(*(_DWORD *)(*(_DWORD *)v317 + 4 * v304) + 164),
                            *(const char **)(*(_DWORD *)(*(_DWORD *)v317 + 4 * v304) + 172),
                            *(const char **)(*(_DWORD *)(*(_DWORD *)v317 + 4 * v304) + 176));
                          applog(4, v213, 0);
                        }
                        ++v304;
                      }
                      v302 = v314;
                      if ( !use_curses )
                      {
LABEL_466:
                        strcpy(v213, "No servers could be used! Exiting.");
                        applog(3, v213, 1);
                        _quit(0, 0);
                      }
                      if ( *v214 || *v301 || *(int *)v314 > 2 )
                        break;
LABEL_464:
                      ;
                    }
                    strcpy(v213, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                    applog(3, v213, 0);
LABEL_463:
                    if ( !use_curses )
                      goto LABEL_466;
                    goto LABEL_464;
                  }
LABEL_187:
                  if ( opt_log_level <= 4 )
                  {
                    v151 = *((_DWORD *)v319 + 262);
                    if ( v151 != -1 )
                      goto LABEL_133;
LABEL_159:
                    if ( !*(_BYTE *)v321 && opt_log_level <= 3 )
                    {
                      if ( !use_curses )
                        goto LABEL_139;
                      goto LABEL_162;
                    }
LABEL_168:
                    strcpy((char *)v326, "Error in configuration file, partially loaded.");
                    applog(4, (const char *)v326, 0);
                    if ( !use_curses )
                      goto LABEL_139;
                    if ( use_syslog || *(_BYTE *)v321 )
                      goto LABEL_163;
LABEL_162:
                    if ( opt_log_level > 3 )
                    {
LABEL_163:
                      strcpy((char *)v326, "Start cgminer with -T to see what failed to load.");
                      applog(4, (const char *)v326, 0);
                    }
LABEL_139:
                    v152 = v319;
                    free(*((void **)v319 + 209));
                    v152[209] = 0;
                    goto LABEL_140;
                  }
LABEL_132:
                  snprintf((char *)v326, 2048u, "Loaded configuration file %s", v150);
                  applog(5, (const char *)v326, 0);
                  v151 = *((_DWORD *)v319 + 262);
                  if ( v151 != -1 )
                  {
LABEL_133:
                    if ( !v151 )
                    {
                      if ( (use_syslog || *(_BYTE *)v321 || opt_log_level > 3)
                        && ((strcpy((char *)v326, "Fatal JSON error in configuration file."),
                             applog(4, (const char *)v326, 0),
                             use_syslog)
                         || *(_BYTE *)v321)
                        || opt_log_level > 3 )
                      {
                        strcpy((char *)v326, "Configuration file could not be used.");
                        applog(4, (const char *)v326, 0);
                      }
                    }
                    goto LABEL_139;
                  }
                  if ( use_syslog )
                    goto LABEL_168;
                  goto LABEL_159;
                }
LABEL_129:
                snprintf((char *)v326, 2048u, "Started %s", packagename);
                applog(4, (const char *)v326, 0);
                v150 = (const char *)*((_DWORD *)v319 + 209);
                if ( !v150 )
                  goto LABEL_140;
                if ( use_syslog || *(_BYTE *)v321 )
                  goto LABEL_132;
                goto LABEL_187;
              }
              goto LABEL_91;
            }
          }
          snprintf(
            (char *)v326,
            2048u,
            "Log file path: %s Open flag: %s",
            (const char *)&g_logfile_path,
            (const char *)v310);
          applog(3, (const char *)v326, 0);
        }
        v124 = (const char *)*((_DWORD *)v319 + 2);
        if ( !v124 )
        {
          v321 = (unsigned int)&opt_log_output;
          goto LABEL_126;
        }
LABEL_91:
        memset(v325, 0, sizeof(v325));
        v125 = (const char *)*((_DWORD *)v319 + 1);
        if ( v125 )
        {
          if ( !*v125 )
          {
            v127 = "Log work asic num empty";
            v128 = v326;
LABEL_102:
            v129 = *(_DWORD *)v127;
            v130 = *((_DWORD *)v127 + 1);
            v131 = *((_DWORD *)v127 + 2);
            v132 = *((_DWORD *)v127 + 3);
            v133 = v127 + 16;
            *v128 = v129;
            v128[1] = v130;
            v128[2] = v131;
            v128[3] = v132;
            v134 = v128 + 4;
            v135 = v133[1];
            *v134 = *v133;
            v134[1] = v135;
            v136 = (const char *)v326;
            goto LABEL_103;
          }
          v126 = strtol(v125, 0, 10);
          ii[799] = v126;
          if ( ((v126 - 32) & 0xFFFFFFDF) != 0 && v126 != 1 )
          {
            strcpy((char *)v326, "Log work asic num must be 1, 32, 64");
            applog(3, (const char *)v326, 1);
            _quit(1, 1);
          }
          if ( use_syslog )
          {
            v321 = (unsigned int)&opt_log_output;
          }
          else
          {
            v321 = (unsigned int)&opt_log_output;
            if ( !opt_log_output && opt_log_level <= 2 )
              goto LABEL_107;
          }
          snprintf(
            (char *)v326,
            2048u,
            "Log work path: %s Asic num: %s",
            *((const char **)v319 + 2),
            *((const char **)v319 + 1));
          applog(3, (const char *)v326, 0);
        }
        else
        {
          if ( use_syslog )
          {
            v321 = (unsigned int)&opt_log_output;
          }
          else
          {
            v321 = (unsigned int)&opt_log_output;
            if ( !opt_log_output && opt_log_level <= 2 )
              goto LABEL_107;
          }
          snprintf((char *)v326, 2048u, "Log work path: %s", v124);
          applog(3, (const char *)v326, 0);
        }
LABEL_107:
        sprintf(v325, "%s.txt", *((const char **)v319 + 2));
        v137 = fopen(v325, "a+");
        v138 = (unsigned __int8)use_syslog;
        ii[800] = v137;
        if ( v138 || *(_BYTE *)v321 || opt_log_level > 2 )
        {
          snprintf((char *)v326, 2048u, "Log work open file %s", v325);
          applog(3, (const char *)v326, 0);
        }
        v139 = ii[799];
        if ( v139 == 1 )
        {
          sprintf(v325, "%s%02d.txt", *((const char **)v319 + 2), 1);
          v172 = fopen(v325, "a+");
          v173 = (unsigned __int8)use_syslog;
          ii[801] = v172;
          if ( v173 || *(_BYTE *)v321 || opt_log_level > 2 )
          {
            snprintf((char *)v326, 2048u, "Log work open asic %d file %s", ii[799], v325);
            applog(3, (const char *)v326, 0);
          }
        }
        else
        {
          v140 = (v139 - 32) & 0xFFFFFFDF;
          if ( !v140 && v139 >= 0 )
          {
            format = "%s%02d_%02d.txt";
            s = "a+";
            v141 = &g_logwork_file;
            v142 = v319;
            v143 = ii;
            v317 = "Log work open asic %d file %s";
            do
            {
              sprintf(v325, format, v142[2]);
              v144 = fopen(v325, s);
              v145 = (unsigned __int8)use_syslog;
              v141[1] = (int)v144;
              ++v141;
              if ( v145 || *(_BYTE *)v321 || opt_log_level > 2 )
              {
                snprintf((char *)v326, 2048u, v317, v143[799], v325);
                applog(3, (const char *)v326, 0);
              }
              ++v140;
            }
            while ( v143[799] >= v140 );
          }
        }
        if ( *((_BYTE *)ii + 3464) )
        {
          v146 = &opt_logwork_diff;
          v147 = 0;
          format = "Log work open diff file %s";
          do
          {
            sprintf(v325, "%s_diff_%02d.txt", *((const char **)v319 + 2), v147);
            v148 = fopen(v325, "a+");
            v149 = (unsigned __int8)use_syslog;
            *((_DWORD *)v146 + 1) = v148;
            v146 += 4;
            if ( v149 || *(_BYTE *)v321 || opt_log_level > 2 )
            {
              snprintf((char *)v326, 2048u, format, v325);
              applog(3, (const char *)v326, 0);
            }
            ++v147;
          }
          while ( v147 != 65 );
        }
LABEL_126:
        if ( use_syslog || *(_BYTE *)v321 )
          goto LABEL_129;
        goto LABEL_128;
      }
      v70 = calloc(24 * *(_DWORD *)(v69 + 4), 1u);
      if ( v70 )
      {
        v71 = *((_DWORD *)v68 + 17);
        v72 = *(_DWORD *)(v71 + 4);
        v73 = *(_DWORD *)(v71 + 12);
        v74 = *(_DWORD *)(v71 + 8);
        *(_DWORD *)(v71 + 28) = 0;
        v75 = v73 >> (v74 + 1);
        v321 = 2 * v72 - 1;
        if ( (v73 & v321) != 0 )
          v76 = v75 + 1;
        else
          v76 = v75;
        *(_DWORD *)(v71 + 24) = v76;
        if ( v72 )
        {
          v77 = *(int **)v71;
          v78 = (char *)(12 * v72);
          v79 = 0;
          v317 = 0;
          v313 = v77;
          v314 = v78;
          do
          {
            v80 = *(_DWORD **)&v317[(_DWORD)v313];
            if ( v80 )
            {
              do
              {
                v81 = (_DWORD *)v80[4];
                v82 = 3 * (v80[7] & v321);
                v83 = (char *)&v70[3 * (v80[7] & v321)];
                v84 = *((_DWORD *)v83 + 1) + 1;
                *((_DWORD *)v83 + 1) = v84;
                if ( v76 < v84 )
                {
                  v85 = *(_DWORD *)(v71 + 28);
                  format = v79;
                  *(_DWORD *)(v71 + 28) = v85 + 1;
                  v79 = format;
                  *((_DWORD *)v83 + 2) = v84 / v76;
                }
                v86 = v70[v82];
                v80[3] = v79;
                v80[4] = v86;
                if ( v86 )
                  *(_DWORD *)(v86 + 12) = v80;
                v70[v82] = v80;
                v80 = v81;
              }
              while ( v81 );
            }
            v6 = v314 == v317 + 12;
            v317 += 12;
          }
          while ( !v6 );
        }
        free(*(void **)v71);
        v87 = (_DWORD *)*((_DWORD *)s + 17);
        v88 = v87[3];
        v89 = v87[7];
        v90 = v87[1];
        v91 = v87[2];
        *v87 = v70;
        v87[2] = v91 + 1;
        v87[1] = 2 * v90;
        if ( v89 <= v88 >> 1 )
        {
          v87[8] = 0;
        }
        else
        {
          v92 = v87[8] + 1;
          v87[8] = v92;
          if ( v92 > 1 )
            v87[9] = 1;
        }
        goto LABEL_54;
      }
LABEL_183:
      exit(-1);
    }
    strcpy((char *)v326, "Failed to create getq");
  }
  applog(3, (const char *)v326, 1);
  _quit(1, 0);
}
// 12828: variable 'v4' is possibly undefined
// 12828: variable 'v5' is possibly undefined
// 12138: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 1BCA0: using guessed type int miner_thread();
// 1BDA4: using guessed type void __noreturn applog_and_exit();
// 1C1C8: using guessed type int api_thread();
// 1DE6C: using guessed type void __noreturn sighandler();
// 22288: using guessed type void __noreturn watchpool_thread();
// 23014: using guessed type int test_pool_thread();
// 25E50: using guessed type void __noreturn watchdog_thread();
// 603C4: using guessed type __int16 word_603C4;
// 7D6A8: using guessed type char *opt_config_table;
// 7DEFC: using guessed type int opt_scantime;
// 7DF08: using guessed type char *opt_cmdline_table;
// 7E3EC: using guessed type void *off_7E3EC;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B08: using guessed type int _bss_start;
// 80F7C: using guessed type struct timeval update_tv_start;
// 80FB4: using guessed type int total_tv_end;
// 80FBC: using guessed type int total_tv_start;
// 80FF0: using guessed type int initial_args;
// 81018: using guessed type struct timeval tv_hashmeter;
// 81080: using guessed type int g_local_mhashes_index;
// 828C8: using guessed type int g_logwork_file;
// 829D0: using guessed type char opt_logwork_diff;
// 80B5A0: using guessed type char g_logfile_enable;
// 80B5A8: using guessed type __int16 g_logfile_openflag;
// 80B5C8: using guessed type int g_logfile_path;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80B6F8: using guessed type char successful_connect;
// 80B83C: using guessed type int dword_80B83C;
// 80B91C: using guessed type int dword_80B91C;
// 80BAA8: using guessed type char want_per_device_stats;
// 80BAEC: using guessed type int total_pools;
// 80BB8C: using guessed type int devices;
// 80CBA4: using guessed type char use_curses;
// 80CBC0: using guessed type int mining_thr;
// 80CBC4: using guessed type pthread_rwlock_t mining_thr_lock;
// 80CBE4: using guessed type int pools;
// 80CBE8: using guessed type pthread_cond_t gws_cond;
// 80CC18: using guessed type char use_syslog;
// 80CC1C: using guessed type pthread_mutex_t ch_lock;
// 80CC54: using guessed type pthread_mutex_t control_lock;
// 80CC90: using guessed type int enabled_pools;
// 80DC94: using guessed type int cgminer_path;
// 80DCA0: using guessed type int mining_threads;
// 80DCB0: using guessed type int control_thr;
// 80DCB8: using guessed type pthread_rwlock_t netacc_lock;
// 80DCD8: using guessed type int total_devices;
// 80DCDC: using guessed type int opt_kernel_path;
// 80DCF8: using guessed type int getq;
// 80DDC8: using guessed type char opt_compact;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;
// 80EDF8: using guessed type pthread_mutex_t console_lock;
// 80EE10: using guessed type pthread_cond_t restart_cond;
// 80EED0: using guessed type int scan_devices;
// 80EED4: using guessed type int dword_80EED4;
// 80EED8: using guessed type pthread_mutex_t update_job_lock;
// 80EF00: using guessed type char opt_work_update;
// 80EF04: using guessed type pthread_mutex_t restart_lock;
// 80EF1C: using guessed type pthread_rwlock_t devices_lock;
// 80EF48: using guessed type pthread_mutex_t hash_lock;
// 127A8: using guessed type int anonymous_0[513];

//----- (00014C30) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)(void))init,
    _libc_csu_fini,
    a1,
    va);
  abort();
}
// 14C3A: positive sp value 4 has been found
// 14C4C: variable 'v4' is possibly undefined

//----- (00014C60) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 12338: using guessed type int _gmon_start__(void);

//----- (00014C84) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &_bss_start;
}
// 80B08: using guessed type int _bss_start;

//----- (00014CA8) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &_bss_start;
  HIDWORD(result) = 0;
  return result;
}
// 80B08: using guessed type int _bss_start;

//----- (00014CD4) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !completed_9251 )
  {
    result = deregister_tm_clones();
    completed_9251 = 1;
  }
  return result;
}
// 80B18: using guessed type char completed_9251;

//----- (00014CEC) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (00014D10) --------------------------------------------------------
_DWORD *__fastcall api_add_data_full(_DWORD *a1, const char *a2, int a3, const char *a4, char a5)
{
  _DWORD *v9; // r4
  char *v10; // r0
  int v11; // r3
  _DWORD *result; // r0
  _DWORD *v13; // r0
  int v14; // r3
  _QWORD *v15; // r0
  __int64 v16; // r2
  _WORD *v17; // r0
  __int16 v18; // r3
  size_t v19; // r7
  void *v20; // r0
  _DWORD *v21; // r0
  int v22; // r3
  _BYTE *v23; // r0
  char v24; // r3
  _DWORD *v25; // r0
  int v26; // r1
  _DWORD *v27; // r2
  int v28; // r0
  _BYTE *v29; // r0
  char v30; // r3
  char v31[2080]; // [sp+0h] [bp-820h] BYREF

  v9 = malloc(24u);
  v10 = _strdup(a2);
  *v9 = a3;
  v9[1] = v10;
  if ( a1 )
  {
    v11 = a1[4];
    v9[5] = a1;
    a1[4] = v9;
    v9[4] = v11;
    *(_DWORD *)(v11 + 20) = v9;
  }
  else
  {
    v9[4] = v9;
    a1 = v9;
    v9[5] = v9;
  }
  *((_BYTE *)v9 + 12) = a5;
  if ( !a4 )
  {
    *((_BYTE *)v9 + 12) = 0;
    a4 = "(null)";
    *v9 = 2;
LABEL_7:
    v9[2] = a4;
    return a1;
  }
  if ( !a5 )
    goto LABEL_7;
  switch ( a3 )
  {
    case 0:
    case 1:
    case 2:
      v19 = strlen(a4) + 1;
      v20 = malloc(v19);
      v9[2] = v20;
      memcpy(v20, a4, v19);
      return a1;
    case 3:
      v29 = malloc(4u);
      v30 = *a4;
      v9[2] = v29;
      *v29 = v30;
      return a1;
    case 4:
    case 5:
      v17 = malloc(4u);
      v18 = *(_WORD *)a4;
      v9[2] = v17;
      *v17 = v18;
      return a1;
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
      v13 = malloc(4u);
      v14 = *(_DWORD *)a4;
      v9[2] = v13;
      *v13 = v14;
      result = a1;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      v15 = malloc(8u);
      v16 = *(_QWORD *)a4;
      v9[2] = v15;
      *v15 = v16;
      return a1;
    case 14:
      v23 = malloc(1u);
      v24 = *a4;
      v9[2] = v23;
      *v23 = v24;
      return a1;
    case 15:
      v25 = malloc(8u);
      v26 = *((_DWORD *)a4 + 1);
      v27 = v25;
      v28 = *(_DWORD *)a4;
      v9[2] = v27;
      *v27 = v28;
      v27[1] = v26;
      return a1;
    case 19:
    case 22:
    case 26:
      v21 = malloc(4u);
      v22 = *(_DWORD *)a4;
      v9[2] = v21;
      *v21 = v22;
      return a1;
    default:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v31, 2048u, "API: unknown1 data type %d ignored", a3);
        applog(3, v31, 0);
      }
      v9[2] = "Unknown";
      *v9 = 1;
      *((_BYTE *)v9 + 12) = 0;
      return a1;
  }
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00014E90) --------------------------------------------------------
int __fastcall io_add(unsigned int *a1, char *s)
{
  size_t v4; // r0
  char *v5; // r2
  size_t v6; // r5
  _BYTE *v7; // r0
  unsigned int v8; // r1
  int v9; // r8
  unsigned int v10; // r3
  size_t v11; // r6
  char *v12; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = (char *)a1[2];
  v6 = v4;
  v7 = (_BYTE *)a1[1];
  v8 = *a1;
  v9 = v5 - v7;
  v10 = v5 - v7 + 12 + v6;
  if ( v10 > *a1 )
  {
    v11 = v8 + 131072;
    if ( v10 > v8 + 131072 )
      v11 = ((unsigned int)vcvts_n_f32_u32(v10, 16u) + 2) << 16;
    v12 = (char *)realloc(v7, v11);
    v5 = &v12[v9];
    a1[1] = (unsigned int)v12;
    a1[2] = (unsigned int)&v12[v9];
    *a1 = v11;
  }
  memcpy(v5, s, v6 + 1);
  result = 1;
  a1[2] += v6;
  return result;
}

//----- (00014EF8) --------------------------------------------------------
int __fastcall doquit(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // r4
  int result; // r0

  v4 = *(_BYTE **)(a1 + 4);
  *(_DWORD *)(a1 + 8) = v4;
  *v4 = 0;
  *(_BYTE *)(a1 + 13) = 0;
  if ( a4 )
    result = io_add((unsigned int *)a1, "{\"STATUS\":\"BYE\"");
  else
    result = io_add((unsigned int *)a1, "BYE");
  bye = 1;
  do_a_quit = 1;
  return result;
}
// 80B1C: using guessed type char bye;
// 80B1D: using guessed type char do_a_quit;

//----- (00014F38) --------------------------------------------------------
int __fastcall dorestart(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // r4
  int result; // r0

  v4 = *(_BYTE **)(a1 + 4);
  *(_DWORD *)(a1 + 8) = v4;
  *v4 = 0;
  *(_BYTE *)(a1 + 13) = 0;
  if ( a4 )
    result = io_add((unsigned int *)a1, "{\"STATUS\":\"RESTART\"");
  else
    result = io_add((unsigned int *)a1, "RESTART");
  bye = 1;
  do_a_restart = 1;
  return result;
}
// 80B1C: using guessed type char bye;
// 80B1E: using guessed type char do_a_restart;

//----- (00014F78) --------------------------------------------------------
const char *__fastcall escape_string(const char *result, int a2)
{
  unsigned int v2; // r4
  unsigned int v3; // r3
  const char *v4; // r2
  int v5; // r5
  unsigned int v6; // t1
  unsigned int v7; // t1
  const char *v9; // r6
  size_t v10; // r5
  unsigned __int8 *v11; // r2
  char *v12; // r3
  unsigned int v13; // t1
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v2 = *(unsigned __int8 *)result;
  if ( *result )
  {
    v3 = *(unsigned __int8 *)result;
    v4 = result;
    v5 = 0;
    while ( 1 )
    {
      if ( v3 == 61 )
        goto LABEL_11;
      if ( v3 <= 61 )
      {
        if ( v3 != 34 )
        {
          if ( v3 != 44 )
            goto LABEL_6;
          if ( a2 )
            goto LABEL_12;
LABEL_5:
          ++v5;
          goto LABEL_6;
        }
        if ( a2 )
          goto LABEL_5;
LABEL_6:
        v6 = *(unsigned __int8 *)++v4;
        v3 = v6;
        if ( !v6 )
          goto LABEL_13;
      }
      else
      {
        if ( v3 == 92 )
          goto LABEL_5;
        if ( v3 != 124 )
          goto LABEL_6;
LABEL_11:
        if ( !a2 )
          goto LABEL_5;
LABEL_12:
        v7 = *(unsigned __int8 *)++v4;
        v3 = v7;
        if ( !v7 )
        {
LABEL_13:
          if ( !v5 )
            return result;
          v9 = result;
          v10 = v5 + 1 + strlen(result);
          result = (const char *)malloc(v10);
          if ( !result )
          {
            snprintf(s, 2048u, "Failed to malloc escape buf %d in %s %s():%d", v10, "api.c", "escape_string", 843);
            applog(3, s, 1);
            quit(1);
          }
          v11 = (unsigned __int8 *)(v9 + 1);
          v12 = (char *)result;
          if ( !v2 )
          {
LABEL_27:
            *v12 = v2;
            return result;
          }
          while ( 2 )
          {
            if ( v2 == 61 )
              goto LABEL_31;
            if ( v2 > 61 )
            {
              if ( v2 == 92 )
              {
                *v12 = 92;
                v12[1] = 92;
                v12 += 2;
                goto LABEL_26;
              }
              if ( v2 == 124 )
                goto LABEL_31;
            }
            else
            {
              if ( v2 == 34 )
              {
                if ( a2 )
                  *v12++ = 92;
                *v12++ = 34;
LABEL_26:
                v13 = *v11++;
                v2 = v13;
                if ( !v13 )
                  goto LABEL_27;
                continue;
              }
              if ( v2 == 44 )
              {
LABEL_31:
                if ( !a2 )
                  *v12++ = 92;
              }
            }
            break;
          }
          *v12++ = v2;
          goto LABEL_26;
        }
      }
    }
  }
  return result;
}

//----- (00015078) --------------------------------------------------------
void __fastcall head_join(unsigned int *a1, const char *a2, int a3, _BYTE *a4)
{
  char *v6; // r5

  if ( *a4 )
  {
    if ( !a3 )
    {
      *a4 = 0;
LABEL_4:
      v6 = (char *)escape_string(a2, a3);
      io_add(a1, "CMD=");
      io_add(a1, v6);
      io_add(a1, "|");
      goto LABEL_5;
    }
    io_add(a1, "{");
    *a4 = 0;
    v6 = (char *)escape_string(a2, 1);
  }
  else
  {
    if ( !a3 )
      goto LABEL_4;
    io_add(a1, ",");
    v6 = (char *)escape_string(a2, 1);
  }
  io_add(a1, "\"");
  io_add(a1, v6);
  io_add(a1, "\":[");
LABEL_5:
  if ( a2 != v6 )
    j_free(v6);
}

//----- (0001512C) --------------------------------------------------------
int __fastcall check_connect(const struct sockaddr *a1, const char **a2, _BYTE *a3)
{
  char *v6; // r0
  int v7; // r12
  int v8; // lr
  char *v9; // r2
  int v10; // r0
  int v11; // r1
  int v12; // r5
  int v13; // t1
  int v14; // r3
  int v15; // t1
  int v16; // t1
  int result; // r0
  int v18; // r4
  char v19; // [sp+Fh] [bp-51h] BYREF
  int buf; // [sp+10h] [bp-50h] BYREF
  int v21; // [sp+14h] [bp-4Ch]
  int v22; // [sp+18h] [bp-48h]
  int v23; // [sp+1Ch] [bp-44h] BYREF
  char s[64]; // [sp+20h] [bp-40h] BYREF

  v6 = (char *)malloc(46u);
  *a2 = v6;
  getnameinfo(a1, 128u, v6, 46u, 0, 0, 1u);
  if ( a1->sa_family == 2 )
  {
    sprintf(s, "::ffff:%s", *a2);
    inet_pton(10, s, &buf);
  }
  else
  {
    inet_pton(10, *a2, &buf);
  }
  *a3 = (*_ctype_toupper_loc())[82];
  if ( opt_api_allow )
  {
    if ( ips > 0 )
    {
      v7 = 0;
      v8 = ipaccess - 1;
      do
      {
        v9 = &v19;
        v10 = v8 + 16;
        v11 = v8;
        while ( 1 )
        {
          v13 = (unsigned __int8)*++v9;
          v12 = v13;
          v15 = *(unsigned __int8 *)++v10;
          v14 = v15;
          v16 = *(unsigned __int8 *)++v11;
          if ( v16 != (v14 & v12) )
            break;
          if ( (char *)&v23 + 3 == v9 )
          {
            result = 1;
            *a3 = *(_BYTE *)(v8 + 33);
            return result;
          }
        }
        ++v7;
        v8 += 36;
      }
      while ( v7 != ips );
    }
    return 0;
  }
  else
  {
    v18 = (unsigned __int8)opt_api_network;
    if ( opt_api_network || !strcmp(*a2, "127.0.0.1") )
    {
      return 1;
    }
    else
    {
      result = v18;
      if ( !buf )
      {
        result = v21;
        if ( v21 )
        {
          return buf;
        }
        else if ( !v22 )
        {
          return v23 == 16777216;
        }
      }
    }
  }
  return result;
}
// 80B20: using guessed type int ips;
// 80B24: using guessed type int ipaccess;
// 82C08: using guessed type int opt_api_allow;
// 80EECC: using guessed type char opt_api_network;

//----- (0001524C) --------------------------------------------------------
int mcast()
{
  struct addrinfo *v0; // r4
  struct addrinfo *i; // r3
  int v2; // r0
  time_t v3; // r6
  int ai_family; // r3
  struct sockaddr *ai_addr; // r3
  int v6; // t1
  int v7; // r1
  int v8; // r2
  int v9; // r3
  const char *v10; // r9
  size_t v11; // r0
  size_t v12; // r4
  int v13; // r6
  ssize_t v14; // r4
  int v15; // r9
  const char *v16; // r1
  socklen_t v17; // r1
  const char *v18; // r4
  int v19; // r0
  int *v20; // r0
  char *v21; // r5
  struct addrinfo *v22; // r0
  int *v23; // r0
  char *v24; // r0
  int *v26; // r0
  char *v27; // r0
  struct addrinfo *v28; // r3
  struct addrinfo *v29; // r4
  int v30; // r0
  size_t v31; // r0
  ssize_t v32; // r4
  int *v33; // r0
  char *v34; // r0
  int *v35; // r0
  char *v36; // r0
  int fd; // [sp+10h] [bp-1138h]
  size_t n; // [sp+1Ch] [bp-112Ch]
  char *v39; // [sp+24h] [bp-1124h]
  int v40; // [sp+28h] [bp-1120h]
  struct addrinfo *v41; // [sp+2Ch] [bp-111Ch]
  char v42; // [sp+4Bh] [bp-10FDh] BYREF
  socklen_t addr_len; // [sp+4Ch] [bp-10FCh] BYREF
  void *ptr; // [sp+50h] [bp-10F8h] BYREF
  struct addrinfo *pai; // [sp+54h] [bp-10F4h] BYREF
  int optval; // [sp+58h] [bp-10F0h] BYREF
  char v47[12]; // [sp+5Ch] [bp-10ECh] BYREF
  char s[12]; // [sp+68h] [bp-10E0h] BYREF
  char serv[12]; // [sp+74h] [bp-10D4h] BYREF
  struct addrinfo req; // [sp+80h] [bp-10C8h] BYREF
  struct sockaddr v51[8]; // [sp+A0h] [bp-10A8h] BYREF
  char v52[1024]; // [sp+120h] [bp-1028h] BYREF
  int v53; // [sp+520h] [bp-C28h] BYREF
  int v54; // [sp+524h] [bp-C24h]
  int v55; // [sp+528h] [bp-C20h]
  int v56; // [sp+52Ch] [bp-C1Ch]
  int v57; // [sp+530h] [bp-C18h]
  char v58[2088]; // [sp+920h] [bp-828h] BYREF

  ptr = 0;
  strcpy(v47, "bmminer-");
  sprintf(s, "%d", opt_api_mcast_port);
  memset(&req, 0, sizeof(req));
  if ( getaddrinfo(opt_api_mcast_addr[0], s, &req, &pai) )
  {
    strcpy(v58, "Invalid API Multicast Address");
    applog(3, v58, 1);
    quit(1);
  }
  v0 = pai;
  if ( !pai )
  {
    v22 = 0;
LABEL_44:
    freeaddrinfo(v22);
    strcpy(v58, "API mcast could not open socket");
    applog(3, v58, 1);
    quit(1);
  }
  for ( i = pai; ; i = pai )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      fd = v2;
      goto LABEL_8;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  fd = v2;
  if ( v2 == -1 )
  {
    v22 = pai;
    goto LABEL_44;
  }
LABEL_8:
  optval = 1;
  if ( setsockopt(fd, 1, 2, &optval, 4u) < 0 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return close(fd);
    v23 = _errno_location();
    v24 = strerror(*v23);
    snprintf(
      v58,
      2048u,
      "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
      v24,
      " - API multicast listener will not be available");
    goto LABEL_48;
  }
  v3 = time(0);
  while ( 1 )
  {
    if ( bind(fd, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        v53 = 0;
        v54 = 0;
        v53 = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(fd, 0, 35, &v53, 8u) >= 0 )
        {
LABEL_14:
          freeaddrinfo(pai);
          v10 = opt_api_mcast_code[0];
          v11 = strlen(opt_api_mcast_code[0]);
          v12 = v11 + 10;
          n = v11 + 9;
          v39 = (char *)malloc(v11 + 10);
          if ( !v39 )
          {
            strcpy(v58, "Failed to malloc mcast expect_code");
            applog(3, v58, 1);
            quit(1);
          }
          v40 = -1;
          v13 = 0;
          snprintf(v39, v12, "%s%s-", v47, v10);
          while ( 1 )
          {
            do
            {
              while ( 1 )
              {
                cgsleep_ms();
                addr_len = 128;
                ++v13;
                v14 = recvfrom(fd, v52, 1023u, 0, v51, &addr_len);
                if ( v14 >= 0 )
                  break;
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  v26 = _errno_location();
                  v27 = strerror(*v26);
                  snprintf(v58, 2048u, "API mcast failed count=%d (%s) (%d)", v13, v27, fd);
                  applog(7, v58, 0);
                }
              }
              if ( ptr )
              {
                free(ptr);
                ptr = 0;
              }
              v15 = check_connect(v51, (const char **)&ptr, &v42);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                v16 = "Ignored";
                if ( v15 )
                  v16 = "Accepted";
                snprintf(v58, 2048u, "API mcast from %s - %s", (const char *)ptr, v16);
                applog(7, v58, 0);
              }
            }
            while ( !v15 );
            v52[v14] = 0;
            if ( v14 )
            {
              v17 = addr_len;
              if ( v52[v14 - 1] == 10 )
                v52[--v14] = 0;
              getnameinfo(v51, v17, 0, 0, serv, 10u, 1u);
              if ( opt_debug )
              {
LABEL_58:
                if ( use_syslog || opt_log_output || opt_log_level > 6 )
                {
                  snprintf(v58, 2048u, "API mcast request rep=%d (%s) from [%s]:%s", v14, v52, (const char *)ptr, serv);
                  applog(7, v58, 0);
                }
                if ( v14 > n && !memcmp(v52, v39, n) )
                  goto LABEL_33;
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  strcpy(v58, "API mcast request was no good");
                  applog(7, v58, 0);
                }
              }
              else if ( n < v14 && !memcmp(v52, v39, n) )
              {
LABEL_33:
                v18 = &v52[n];
                v19 = strtol(&v52[n], 0, 10);
                if ( (unsigned int)(v19 - 1) <= 65534 )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(v58, 2048u, "API mcast request OK port %s=%d", v18, v19);
                    applog(7, v58, 0);
                  }
                  if ( getaddrinfo((const char *)ptr, v18, &req, &pai) )
                  {
                    if ( use_syslog || opt_log_output || opt_log_level > 2 )
                    {
                      snprintf(v58, 2048u, "Invalid client address %s", ptr);
                      goto LABEL_79;
                    }
                  }
                  else
                  {
                    v28 = pai;
                    if ( pai )
                    {
                      v29 = pai;
                      while ( 1 )
                      {
                        v30 = socket(v28->ai_family, 2, 0);
                        if ( fd > 0 )
                          break;
                        v29 = v29->ai_next;
                        if ( !v29 )
                          break;
                        v28 = pai;
                      }
                      v40 = v30;
                      v41 = v29;
                    }
                    else
                    {
                      v41 = 0;
                    }
                    if ( v40 == -1 )
                    {
                      freeaddrinfo(pai);
                      if ( use_syslog || opt_log_output || opt_log_level > 2 )
                      {
                        snprintf(v58, 2048u, "API mcast could not open socket to client %s", ptr);
LABEL_79:
                        applog(3, v58, 0);
                      }
                    }
                    else
                    {
                      snprintf((char *)&v53, 1024u, "cgm-FTW-%d-%s", opt_api_port, opt_api_mcast_des);
                      v31 = strlen((const char *)&v53);
                      v32 = sendto(v40, &v53, v31 + 1, 0, v41->ai_addr, v41->ai_addrlen);
                      freeaddrinfo(pai);
                      if ( v32 < 0 )
                      {
                        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                        {
                          v33 = _errno_location();
                          v34 = strerror(*v33);
                          snprintf(v58, 2048u, "API mcast send reply failed (%s) (%d)", v34, v40);
                          applog(7, v58, 0);
                        }
                      }
                      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                      {
                        snprintf(v58, 2048u, "API mcast send reply (%s) succeeded (%d) (%d)", &v53, v32, v40);
                        applog(7, v58, 0);
                      }
                      close(v40);
                    }
                  }
                }
                else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf(v58, 2048u, "API mcast request ignored - invalid port (%s)", v18);
                  applog(7, v58, 0);
                }
              }
            }
            else
            {
              getnameinfo(v51, addr_len, 0, 0, serv, 10u, 1u);
              if ( opt_debug )
                goto LABEL_58;
            }
          }
        }
      }
      else
      {
        if ( ai_family != 10 )
          goto LABEL_14;
        ai_addr = v0->ai_addr;
        v6 = *(_DWORD *)&ai_addr->sa_data[6];
        ai_addr = (struct sockaddr *)((char *)ai_addr + 8);
        v7 = *(_DWORD *)&ai_addr->sa_data[2];
        v8 = *(_DWORD *)&ai_addr->sa_data[6];
        v9 = *(_DWORD *)&ai_addr->sa_data[10];
        v53 = v6;
        v54 = v7;
        v55 = v8;
        v56 = v9;
        v57 = 0;
        if ( setsockopt(fd, 41, 20, &v53, 20u) >= 0 )
          goto LABEL_14;
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        return close(fd);
      v35 = _errno_location();
      v36 = strerror(*v35);
      snprintf(v58, 2048u, "API mcast join failed (%s)%s", v36, " - API multicast listener will not be available");
LABEL_48:
      applog(3, v58, 0);
      return close(fd);
    }
    v20 = _errno_location();
    v21 = strerror(*v20);
    if ( time(0) - v3 > 61 )
      break;
    cgsleep_ms();
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      v58,
      2048u,
      "API mcast bind to port %d failed (%s)%s",
      opt_api_mcast_port,
      v21,
      " - API multicast listener will not be available");
    applog(3, v58, 0);
  }
  return close(fd);
}
// 1560E: conditional instruction was optimized away because %ptr.4==0
// 7DFA4: using guessed type int opt_api_mcast_port;
// 7DFA8: using guessed type void *opt_api_mcast_des;
// 7DFAC: using guessed type char *opt_api_mcast_code[3];
// 7DFB0: using guessed type char *opt_api_mcast_addr[2];
// 7DFB8: using guessed type int opt_api_port;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 1524C: using guessed type char var_1028[1024];

//----- (00015A14) --------------------------------------------------------
void *__fastcall mcast_thread(void *userdata)
{
  pthread_t v2; // r0
  void *result; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  RenameThread("APIMcast");
  mcast();
  result = 0;
  *((_DWORD *)userdata + 3) = 0;
  return result;
}

//----- (00015A40) --------------------------------------------------------
int __fastcall tail_join(int result, int a2)
{
  int v2; // r4

  v2 = result;
  if ( !*(_BYTE *)(result + 13) )
  {
    if ( !a2 )
      return result;
LABEL_5:
    io_add((unsigned int *)v2, ",\"id\":1}");
    return io_add((unsigned int *)v2, (char *)&word_5E060);
  }
  result = io_add((unsigned int *)result, (char *)&word_5E060);
  *(_BYTE *)(v2 + 13) = 0;
  if ( a2 )
    goto LABEL_5;
  return result;
}
// 5E060: using guessed type __int16 word_5E060;

//----- (00015A84) --------------------------------------------------------
void *__fastcall add_item_buf_isra_2(void ***a1, char *s)
{
  void **v3; // r7
  size_t v5; // r0
  char *v6; // r9
  size_t v7; // r4
  unsigned int v8; // r1
  size_t v9; // r11
  char *v10; // r5
  void *result; // r0
  int v12; // r6
  char sa[2088]; // [sp+18h] [bp-828h] BYREF

  v3 = *a1;
  v5 = strlen(s);
  v6 = (char *)v3[1];
  v7 = v5;
  v8 = (unsigned int)v3[2];
  v9 = v5 + 1;
  v10 = (char *)*v3;
  if ( (unsigned int)&v6[v5 + 1] > v8 )
  {
    v12 = v5 + 4097 - (v9 & 0xFFF);
    v10 = (char *)realloc(*v3, v8 + v12);
    *v3 = v10;
    if ( !v10 )
    {
      snprintf(
        sa,
        2048u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v7,
        (*a1)[2],
        v12,
        "api.c",
        "add_item_buf",
        1182);
      applog(3, sa, 1);
      quit(1);
    }
    (*a1)[2] = (char *)(*a1)[2] + v12;
  }
  result = memcpy(&v6[(_DWORD)v10], s, v9);
  (*a1)[1] = (char *)(*a1)[1] + v7;
  return result;
}

//----- (00015B3C) --------------------------------------------------------
void __fastcall send_result_isra_6(char *s, _BYTE *a2, int a3, int a4)
{
  char *v6; // r9
  signed int v7; // r0
  const char *v8; // r3
  int v9; // r3
  int v10; // r6
  signed int v11; // r4
  int v12; // r8
  int v13; // r6
  int v14; // r10
  _BOOL4 v15; // r3
  fd_set *p_tv_usec; // r3
  int v17; // r0
  ssize_t v18; // r0
  ssize_t v19; // r5
  int v20; // r0
  char *v21; // r0
  signed int v22; // r3
  int v23; // [sp+Ch] [bp-8C4h]
  signed int v24; // [sp+10h] [bp-8C0h]
  struct timeval timeout; // [sp+20h] [bp-8B0h] BYREF
  fd_set writefds; // [sp+28h] [bp-8A8h] BYREF
  char sa[2088]; // [sp+A8h] [bp-828h] BYREF

  v6 = s;
  if ( *a2 )
  {
    *(_WORD *)&s[strlen(s)] = 93;
    if ( !a4 )
      goto LABEL_3;
  }
  else if ( !a4 )
  {
    goto LABEL_3;
  }
  strcat(v6, ",\"id\":1}");
LABEL_3:
  v7 = strlen(v6);
  v24 = v7 + 1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v8 = "";
    if ( v7 > 10 )
      v8 = "...";
    snprintf(sa, 2048u, "API: send reply: (%d) '%.10s%s'", v24, v6, v8);
    applog(7, sa, 0);
  }
  LOBYTE(v9) = a3 & 0x1F;
  v10 = (a3 + 31) & (a3 >> 31);
  if ( a3 >= 0 )
    v10 = a3;
  if ( a3 <= 0 )
    v9 = -(-a3 & 0x1F);
  v11 = v24;
  v12 = 0;
  v13 = v10 >> 5;
  v23 = 1 << v9;
  v14 = 0;
  while ( 1 )
  {
    v15 = v14 <= 4;
    if ( v11 <= 0 )
      v15 = 0;
    if ( !v15 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
    writefds.__fds_bits[v13] |= v23;
    v17 = select(a3 + 1, 0, &writefds, 0, &timeout);
    if ( v17 <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(sa, 2048u, "API: send select failed (%d)", v17);
        applog(4, sa, 0);
      }
      return;
    }
    v18 = send(a3, v6, v11, 0);
    v19 = v18;
    ++v12;
    if ( v18 < 0 )
    {
      v20 = *_errno_location();
      if ( v20 != 11 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          v21 = strerror(v20);
          snprintf(sa, 2048u, "API: send (%d:%d) failed: %s", v24, v24 - v11, v21);
          applog(4, sa, 0);
        }
        return;
      }
LABEL_27:
      ++v14;
    }
    else if ( v12 == 1 )
    {
      if ( v11 != v18 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(sa, 2048u, "API: sent %d of %d first go", v18, v11);
          applog(7, sa, 0);
        }
        goto LABEL_26;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        v22 = v11;
        v11 -= v18;
        snprintf(sa, 2048u, "API: sent all of %d first go", v22);
        v6 += v19;
        applog(7, sa, 0);
      }
      else
      {
LABEL_42:
        v11 -= v19;
        v6 += v19;
      }
    }
    else
    {
      if ( v11 == v18 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(sa, 2048u, "API: sent all of remaining %d (sendc=%d)", v11, v12);
          applog(7, sa, 0);
        }
        goto LABEL_42;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(sa, 2048u, "API: sent %d of remaining %d (sendc=%d)", v18, v11, v12);
        applog(7, sa, 0);
      }
LABEL_26:
      v11 -= v19;
      v6 += v19;
      if ( !v19 )
        goto LABEL_27;
    }
  }
}
// 5E060: using guessed type __int16 word_5E060;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00015EBC) --------------------------------------------------------
int __fastcall copyadvanceafter_constprop_20(unsigned __int8 **a1, int *a2)
{
  _BYTE *v2; // r2
  int v3; // r3
  unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r2
  int v6; // r3
  unsigned __int8 *v7; // r2
  _BYTE *v8; // r3
  int result; // r0

  v2 = *a1;
  v3 = **a1;
  if ( **a1 )
  {
    while ( v3 != 44 )
    {
      if ( v3 == 92 )
      {
        v6 = (unsigned __int8)v2[1];
        v7 = v2 + 1;
        if ( v6 )
          *a1 = v7;
      }
      v4 = (unsigned __int8 *)(*a2)++;
      v5 = (*a1)++;
      *v4 = *v5;
      v2 = *a1;
      v3 = **a1;
      if ( !**a1 )
        goto LABEL_9;
    }
    *a1 = v2 + 1;
  }
LABEL_9:
  v8 = (_BYTE *)*a2;
  result = *a2 + 1;
  *a2 = result;
  *v8 = 0;
  return result;
}

//----- (00015F04) --------------------------------------------------------
int __fastcall pooldetails(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  size_t v7; // r0
  void *v8; // r0
  void *v9; // r4
  unsigned __int8 *v11[2]; // [sp+4h] [bp-824h] BYREF
  void *v12; // [sp+Ch] [bp-81Ch] BYREF
  char v13[2072]; // [sp+10h] [bp-818h] BYREF

  v11[0] = a1;
  v7 = strlen((const char *)a1);
  v8 = malloc(v7 + 1);
  v9 = v8;
  v12 = v8;
  if ( !v8 )
  {
    strcpy(v13, "Failed to malloc pooldetails buf");
    applog(3, v13, 1);
    quit(1);
  }
  *a2 = v8;
  copyadvanceafter_constprop_20(v11, (int *)&v12);
  if ( *v11[0] && (*a3 = v12, copyadvanceafter_constprop_20(v11, (int *)&v12), *v11[0]) )
  {
    *a4 = v12;
    copyadvanceafter_constprop_20(v11, (int *)&v12);
    return 1;
  }
  else
  {
    free(v9);
    return 0;
  }
}

//----- (00015FA4) --------------------------------------------------------
int __fastcall rd_lock_constprop_25(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_rwlock_rdlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "api.c", a2, a3);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (00015FF4) --------------------------------------------------------
void __fastcall __noreturn mutex_lock_part_3_constprop_27(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  applog(3, s, 1);
  quit(1);
}

//----- (00016038) --------------------------------------------------------
void __fastcall __noreturn rw_unlock_part_4_constprop_30(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  applog(3, s, 1);
  quit(1);
}

//----- (0001607C) --------------------------------------------------------
void __fastcall __noreturn mutex_unlock_noyield_part_5_constprop_32(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  applog(3, s, 1);
  quit(1);
}

//----- (000160C0) --------------------------------------------------------
int __fastcall tidyup(int *a1)
{
  int v2; // r0
  int v3; // r6
  void **v4; // r4
  void **v5; // r5
  void **v6; // r0

  if ( pthread_mutex_lock(&quit_restart_lock) )
    mutex_lock_part_3_constprop_27("tidyup", 4701);
  v2 = *a1;
  bye = 1;
  if ( v2 != -1 )
  {
    shutdown(v2, 2);
    close(*a1);
    *a1 = -1;
  }
  if ( ipaccess )
  {
    free((void *)ipaccess);
    ipaccess = 0;
  }
  v3 = io_head;
  if ( io_head )
  {
    v4 = (void **)io_head;
    do
    {
      v5 = (void **)v4[2];
      free(*((void **)*v4 + 1));
      free(*v4);
      v6 = v4;
      v4 = v5;
      free(v6);
    }
    while ( (void **)v3 != v5 );
    io_head = 0;
  }
  if ( pthread_mutex_unlock(&quit_restart_lock) )
    mutex_unlock_noyield_part_5_constprop_32("tidyup", 4722);
  return selective_yield(0);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B1C: using guessed type char bye;
// 80B24: using guessed type int ipaccess;
// 80B40: using guessed type int io_head;

//----- (00016160) --------------------------------------------------------
int restart_thread_0()
{
  int *v1; // r0
  int *v2; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  if ( pthread_mutex_lock(&quit_restart_lock) )
  {
    v1 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "api.c", "restart_thread", 5032);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(&quit_restart_lock) )
  {
    v2 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v2, "api.c", "restart_thread", 5033);
    applog(3, s, 1);
    quit(1);
  }
  selective_yield(0);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(s, "API: restarting bmminer");
    applog(7, s, 0);
    app_restart();
    return 0;
  }
  else
  {
    app_restart();
    return 0;
  }
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00016280) --------------------------------------------------------
void __noreturn quit_thread()
{
  int *v0; // r0
  int *v1; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  if ( !pthread_mutex_lock(&quit_restart_lock) )
  {
    if ( !pthread_mutex_unlock(&quit_restart_lock) )
    {
      selective_yield(0);
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        kill_work();
      strcpy(s, "API: killing bmminer");
      applog(7, s, 0);
      kill_work();
    }
    v1 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v1, "api.c", "quit_thread", 5019);
    applog(3, s, 1);
    quit(1);
  }
  v0 = _errno_location();
  snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v0, "api.c", "quit_thread", 5018);
  applog(3, s, 1);
  quit(1);
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (000163A0) --------------------------------------------------------
int __fastcall print_data(unsigned int *a1, char **a2, int a3, int a4)
{
  int v7; // r6
  int v8; // r11
  int v9; // r6
  void ***v10; // r5
  char *v11; // r3
  unsigned __int8 *v12; // r3
  unsigned __int8 *v13; // r2
  char **v14; // r0
  int v15; // r4
  int v16; // r4
  char *v18; // r6
  char *v19; // r3
  const char *v20; // r2
  const char *v21; // r3
  char *v22; // r1
  void ***v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  int *v28; // r0
  int *v29; // r0
  int *v30; // r0
  int *v31; // r0
  const char *v33; // [sp+24h] [bp-874h]
  const char *v34; // [sp+24h] [bp-874h]
  char s[64]; // [sp+28h] [bp-870h] BYREF
  char v36[2096]; // [sp+68h] [bp-830h] BYREF

  v7 = *(_DWORD *)(strbufs + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v7) )
  {
    v28 = _errno_location();
    snprintf(v36, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v28, "api.c", "print_data", 1199);
    applog(3, v36, 1);
    quit(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 24)) )
  {
    v29 = _errno_location();
    snprintf(v36, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v29, "api.c", "print_data", 1199);
    applog(3, v36, 1);
    quit(1);
  }
  v8 = k_unlink_head(strbufs, "api.c", "print_data", 1200);
  v9 = *(_DWORD *)(strbufs + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v9 + 24)) )
  {
    v31 = _errno_location();
    snprintf(v36, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v31, "api.c", "print_data", 1201);
    applog(3, v36, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v9) )
  {
    v30 = _errno_location();
    snprintf(v36, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v30, "api.c", "print_data", 1201);
    applog(3, v36, 1);
    quit(1);
  }
  selective_yield(0);
  *(_DWORD *)(*(_DWORD *)(v8 + 12) + 4) = 0;
  if ( a4 )
  {
    v10 = (void ***)(v8 + 12);
    add_item_buf_isra_2((void ***)(v8 + 12), ",");
  }
  else
  {
    v10 = (void ***)(v8 + 12);
  }
  if ( a3 )
  {
    add_item_buf_isra_2(v10, "{");
    if ( !a2 )
      goto LABEL_60;
  }
  else if ( !a2 )
  {
    goto LABEL_19;
  }
  if ( a3 )
  {
LABEL_16:
    add_item_buf_isra_2(v10, "\"");
    add_item_buf_isra_2(v10, a2[1]);
    add_item_buf_isra_2(v10, "\"");
    add_item_buf_isra_2(v10, ":");
    v11 = *a2;
    switch ( (unsigned int)*a2 )
    {
      case 0u:
        v34 = a2[2];
        v18 = (char *)escape_string(v34, 1);
        add_item_buf_isra_2(v10, "\"");
        add_item_buf_isra_2(v10, v18);
        add_item_buf_isra_2(v10, "\"");
        v19 = (char *)v34;
        goto LABEL_26;
      case 1u:
      case 2u:
        add_item_buf_isra_2(v10, "\"");
        v22 = a2[2];
        v23 = v10;
        goto LABEL_52;
      case 3u:
        goto LABEL_48;
      case 4u:
        goto LABEL_47;
      case 5u:
        goto LABEL_46;
      case 6u:
        goto LABEL_45;
      case 7u:
      case 8u:
        goto LABEL_11;
      case 9u:
        add_item_buf_isra_2(v10, "\"");
        snprintf(s, 64u, "0x%08x", *(_DWORD *)a2[2]);
        v22 = s;
        v23 = v10;
        goto LABEL_52;
      case 10u:
        goto LABEL_43;
      case 11u:
        goto LABEL_42;
      case 12u:
        goto LABEL_41;
      case 13u:
        goto LABEL_40;
      case 14u:
        goto LABEL_37;
      case 15u:
        goto LABEL_36;
      case 16u:
        goto LABEL_35;
      case 17u:
      case 20u:
      case 21u:
        goto LABEL_34;
      case 18u:
        goto LABEL_33;
      case 19u:
        goto LABEL_32;
      case 22u:
      case 26u:
        goto LABEL_30;
      case 23u:
        goto LABEL_29;
      case 24u:
        goto LABEL_28;
      case 25u:
        goto LABEL_44;
      default:
        goto LABEL_54;
    }
  }
  while ( 1 )
  {
    add_item_buf_isra_2(v10, a2[1]);
    add_item_buf_isra_2(v10, "=");
    v11 = *a2;
    switch ( (unsigned int)*a2 )
    {
      case 0u:
        v33 = a2[2];
        v18 = (char *)escape_string(v33, 0);
        add_item_buf_isra_2(v10, v18);
        v19 = (char *)v33;
LABEL_26:
        if ( v19 != v18 )
          free(v18);
        break;
      case 1u:
      case 2u:
        add_item_buf_isra_2(v10, a2[2]);
        break;
      case 3u:
LABEL_48:
        snprintf(s, 64u, "%u", (unsigned __int8)*a2[2]);
        goto LABEL_12;
      case 4u:
LABEL_47:
        snprintf(s, 64u, "%d", *(__int16 *)a2[2]);
        goto LABEL_12;
      case 5u:
LABEL_46:
        snprintf(s, 64u, "%u", *(unsigned __int16 *)a2[2]);
        goto LABEL_12;
      case 6u:
LABEL_45:
        snprintf(s, 64u, "%d", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 7u:
      case 8u:
LABEL_11:
        snprintf(s, 64u, "%u", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 9u:
        snprintf(s, 64u, "0x%08x", *(_DWORD *)a2[2]);
        add_item_buf_isra_2(v10, s);
        break;
      case 10u:
LABEL_43:
        snprintf(s, 64u, "%llu", *(_QWORD *)a2[2]);
        goto LABEL_12;
      case 11u:
LABEL_42:
        snprintf(s, 64u, "%lld", *(_QWORD *)a2[2]);
        goto LABEL_12;
      case 12u:
LABEL_41:
        snprintf(s, 64u, "%f", *(double *)a2[2]);
        goto LABEL_12;
      case 13u:
LABEL_40:
        snprintf(s, 64u, "%.0f", *(double *)a2[2]);
        goto LABEL_12;
      case 14u:
LABEL_37:
        v21 = "false";
        if ( *a2[2] )
          v21 = "true";
        snprintf(s, 64u, "%s", v21);
        goto LABEL_12;
      case 15u:
LABEL_36:
        snprintf(s, 64u, "%ld.%06ld", *(_DWORD *)a2[2], *((_DWORD *)a2[2] + 1));
        goto LABEL_12;
      case 16u:
LABEL_35:
        snprintf(s, 64u, "%lu", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 17u:
      case 20u:
      case 21u:
LABEL_34:
        snprintf(s, 64u, "%.2f", *(double *)a2[2]);
        goto LABEL_12;
      case 18u:
LABEL_33:
        snprintf(s, 64u, "%.4f", *(double *)a2[2]);
        goto LABEL_12;
      case 19u:
LABEL_32:
        v20 = "%.2f";
        goto LABEL_31;
      case 22u:
      case 26u:
LABEL_30:
        v20 = "%.3f";
LABEL_31:
        snprintf(s, 64u, v20);
        goto LABEL_12;
      case 23u:
LABEL_29:
        snprintf(s, 64u, "%.15f", *(double *)a2[2]);
        goto LABEL_12;
      case 24u:
LABEL_28:
        snprintf(s, 64u, "%.8f", *(double *)a2[2]);
        goto LABEL_12;
      case 25u:
LABEL_44:
        snprintf(s, 64u, "%.4f", *(double *)a2[2] * 100.0);
LABEL_12:
        add_item_buf_isra_2(v10, s);
        break;
      default:
LABEL_54:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(v36, 2048u, "API: unknown2 data type %d ignored", v11);
          applog(3, v36, 0);
        }
        if ( a3 )
        {
          add_item_buf_isra_2(v10, "\"");
          v22 = "Unknown";
          v23 = v10;
LABEL_52:
          add_item_buf_isra_2(v23, v22);
          add_item_buf_isra_2(v10, "\"");
        }
        else
        {
          add_item_buf_isra_2(v10, "Unknown");
        }
        break;
    }
    free(a2[1]);
    if ( !*((_BYTE *)a2 + 12) )
    {
      v12 = (unsigned __int8 *)a2[5];
      if ( a2 == (char **)v12 )
        break;
      goto LABEL_15;
    }
    free(a2[2]);
    v12 = (unsigned __int8 *)a2[5];
    if ( a2 == (char **)v12 )
      break;
LABEL_15:
    v13 = (unsigned __int8 *)a2[4];
    v14 = a2;
    a2 = (char **)v12;
    *((_DWORD *)v12 + 4) = v13;
    *((_DWORD *)v13 + 5) = v12;
    free(v14);
    add_item_buf_isra_2(v10, ",");
    if ( a3 )
      goto LABEL_16;
  }
  free(a2);
  if ( !a3 )
  {
LABEL_19:
    add_item_buf_isra_2(v10, "|");
    goto LABEL_20;
  }
LABEL_60:
  add_item_buf_isra_2(v10, (char *)&word_67AC8);
LABEL_20:
  io_add(a1, **(char ***)(v8 + 12));
  v15 = *(_DWORD *)(strbufs + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v15) )
  {
    v24 = _errno_location();
    snprintf(v36, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "api.c", "print_data", 1371);
    applog(3, v36, 1);
    quit(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v15 + 24)) )
  {
    v25 = _errno_location();
    snprintf(v36, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v25, "api.c", "print_data", 1371);
    applog(3, v36, 1);
    quit(1);
  }
  k_add_head(strbufs, v8, "api.c", "print_data", 1372);
  v16 = *(_DWORD *)(strbufs + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v16 + 24)) )
  {
    v26 = _errno_location();
    snprintf(v36, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v26, "api.c", "print_data", 1373);
    applog(3, v36, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v16) )
  {
    v27 = _errno_location();
    snprintf(v36, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v27, "api.c", "print_data", 1373);
    applog(3, v36, 1);
    quit(1);
  }
  ((void (*)(void))selective_yield)();
  return 0;
}
// 67AC8: using guessed type __int16 word_67AC8;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B44: using guessed type int strbufs;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00016BF0) --------------------------------------------------------
int __fastcall message(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  int v8; // r2
  int *v9; // r3
  int v10; // r1
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r7
  const char *v14; // r1
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  char **v17; // r0
  int result; // r0
  int v19; // r1
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  const char *v22; // r2
  const char *v23; // r1
  int v24; // [sp+Ch] [bp-2024h] BYREF
  int v25; // [sp+14h] [bp-201Ch] BYREF
  char s[8168]; // [sp+18h] [bp-2018h] BYREF

  v24 = a2;
  if ( a5 )
    io_add(a1, "{\"STATUS\":[");
  v8 = codes[0];
  if ( codes[0] == 4 )
  {
LABEL_9:
    v11 = api_add_data_full(0, "STATUS", 1, "F", 0);
    v12 = api_add_data_full(v11, "When", 16, when, 0);
    v25 = -1;
    v13 = api_add_data_full(v12, "Code", 6, (const char *)&v25, 0);
    sprintf(s, "%d", v24);
    LOWORD(v14) = (unsigned __int16)"Msg";
    v15 = v13;
    goto LABEL_10;
  }
  if ( v24 != dword_7D0C4 )
  {
    v9 = codes;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[4];
      ++v10;
      v9 += 4;
      if ( v8 == 4 )
        goto LABEL_9;
      if ( v9[1] == v24 )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case 2:
      LOBYTE(v25) = 73;
      break;
    case 3:
      LOBYTE(v25) = 83;
      break;
    case 1:
      LOBYTE(v25) = 87;
      break;
    default:
      LOBYTE(v25) = 69;
      break;
  }
  v19 = 4 * v10;
  BYTE1(v25) = 0;
  switch ( codes[v19 + 2] )
  {
    case 0:
    case 1:
    case 2:
    case 14:
      sprintf(s, (const char *)codes[v19 + 3], a3);
      break;
    case 5:
      sprintf(s, (const char *)codes[v19 + 3], total_pools);
      break;
    case 6:
      sprintf(s, (const char *)codes[v19 + 3], a3, total_pools - 1);
      break;
    case 7:
      sprintf(s, (const char *)codes[v19 + 3]);
      break;
    case 8:
      sprintf(s, (const char *)codes[v19 + 3], "command");
      break;
    case 9:
      sprintf(s, (const char *)codes[v19 + 3], a3, *(_DWORD *)(*(_DWORD *)(pools + 4 * a3) + 164));
      break;
    case 10:
      sprintf(s, (const char *)codes[v19 + 3], a4);
      break;
    case 11:
      sprintf(s, (const char *)codes[v19 + 3], a3, a4);
      break;
    case 12:
      v22 = "true";
      v23 = (const char *)codes[v19 + 3];
      if ( !a3 )
        v22 = "false";
      sprintf(s, v23, v22, "false");
      break;
    case 13:
      sprintf(s, (const char *)codes[v19 + 3], a4, a3);
      break;
    default:
      strcpy(s, (const char *)codes[v19 + 3]);
      break;
  }
  v20 = api_add_data_full(0, "STATUS", 1, (const char *)&v25, 0);
  v21 = api_add_data_full(v20, "When", 16, when, 0);
  v15 = api_add_data_full(v21, "Code", 6, (const char *)&v24, 0);
  LOWORD(v14) = -32716;
LABEL_10:
  HIWORD(v14) = (unsigned int)"Msg" >> 16;
  v16 = api_add_data_full(v15, v14, 0, s, 0);
  v17 = (char **)api_add_data_full(v16, "Description", 0, (const char *)opt_api_description, 0);
  result = print_data(a1, v17, a5, 0);
  if ( a5 )
    return io_add(a1, (char *)&word_5E060);
  return result;
}
// 5E060: using guessed type __int16 word_5E060;
// 7D0C0: using guessed type int codes[];
// 7D0C4: using guessed type int dword_7D0C4;
// 7DFBC: using guessed type void *opt_api_description;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00016E70) --------------------------------------------------------
int __fastcall privileged(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return message(a1, 46, 0, 0, a4);
}

//----- (00016E7C) --------------------------------------------------------
void __fastcall dosave(unsigned int *a1, int a2, char *filename, int a4)
{
  char *v6; // r4
  FILE *v7; // r0
  FILE *v8; // r5
  char *v9; // r5
  char *v10; // r8
  char v11[4120]; // [sp+8h] [bp-1018h] BYREF

  if ( !filename || (v6 = filename, !*filename) )
  {
    v6 = v11;
    default_save_file(v11);
  }
  v7 = fopen(v6, "w");
  v8 = v7;
  if ( v7 )
  {
    write_config(v7);
    fclose(v8);
    v9 = (char *)escape_string(v6, a4);
    message(a1, 44, 0, (int)v9, a4);
    if ( v6 != v9 )
      free(v9);
  }
  else
  {
    v10 = (char *)escape_string(v6, a4);
    message(a1, 43, 0, (int)v10, a4);
    if ( v6 != v10 )
      free(v10);
  }
}

//----- (00016F10) --------------------------------------------------------
int __fastcall lockstats(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return message(a1, 124, 0, 0, a4);
}

//----- (00016F1C) --------------------------------------------------------
int __fastcall dohotplug(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return message(a1, 102, 0, 0, a4);
}

//----- (00016F28) --------------------------------------------------------
int __fastcall dozero(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  unsigned int *v7; // r6
  char *v9; // r0
  char *v10; // r5
  int v11; // r8
  int v12; // r10
  int v13; // r9
  int v14; // r4
  bool v15; // zf
  char *v17; // r3
  int v18; // r1
  unsigned __int8 v19; // [sp+20h] [bp+0h]

  if ( !s || !*s )
  {
    v17 = 0;
    v19 = a4;
    v18 = 94;
    return message(a1, v18, 0, (int)v17, v19);
  }
  v7 = a1;
  v9 = strchr(s, 44);
  v10 = v9;
  if ( !v9 || (*v9 = 0, v9 == (char *)-1) || (v11 = (unsigned __int8)v9[1], !v9[1]) )
  {
    v17 = 0;
    v19 = a4;
    a1 = v7;
    v18 = 75;
    return message(a1, v18, 0, (int)v17, v19);
  }
  if ( !strcasecmp(s, "all") )
  {
    v13 = 0;
    v12 = 1;
  }
  else
  {
    if ( strcasecmp(s, "bestshare") )
    {
      v19 = a4;
      v17 = s;
      a1 = v7;
      v18 = 95;
      return message(a1, v18, 0, (int)v17, v19);
    }
    v12 = 0;
    v13 = 1;
  }
  v14 = LOBYTE((*_ctype_tolower_loc())[v11]);
  v15 = v14 == 116;
  if ( v14 != 116 )
    v15 = v14 == 102;
  v10[1] = v14;
  if ( !v15 )
  {
    v17 = 0;
    v19 = a4;
    a1 = v7;
    v18 = 76;
    return message(a1, v18, 0, (int)v17, v19);
  }
  if ( v14 == 116 )
  {
    print_summary();
    if ( !v12 )
      goto LABEL_15;
    goto LABEL_25;
  }
  if ( v12 )
LABEL_25:
    zero_stats();
LABEL_15:
  if ( v13 )
    zero_bestshare();
  v17 = "BestShare";
  if ( v12 )
    v17 = "All";
  v19 = a4;
  a1 = v7;
  if ( v14 == 116 )
    v18 = 96;
  else
    v18 = 97;
  return message(a1, v18, 0, (int)v17, v19);
}

//----- (00017044) --------------------------------------------------------
int __fastcall usbstats(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return message(a1, 88, 0, 0, a4);
}

//----- (00017050) --------------------------------------------------------
int __fastcall setconfig(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  unsigned int *v7; // r5
  char *v9; // r0
  unsigned int v10; // r0
  int v11; // r7
  char *v12; // r3
  int v13; // r2
  int v14; // r1
  unsigned __int8 v16; // [sp+18h] [bp+0h]

  if ( s && *s )
  {
    v7 = a1;
    v9 = strchr(s, 44);
    if ( v9 )
    {
      *v9 = 0;
      v10 = strtol(v9 + 1, 0, 10);
      v11 = v10;
      if ( v10 > 9999 )
      {
        v16 = a4;
        v12 = s;
        v13 = v10;
        v14 = 84;
        a1 = v7;
      }
      else
      {
        if ( !strcasecmp(s, "queue") )
        {
          opt_queue = v11;
        }
        else if ( !strcasecmp(s, "scantime") )
        {
          opt_scantime = v11;
        }
        else
        {
          if ( strcasecmp(s, "expiry") )
          {
            v16 = a4;
            v12 = s;
            v13 = 0;
            a1 = v7;
            v14 = 83;
            return message(a1, v14, v13, (int)v12, v16);
          }
          opt_expiry = v11;
        }
        v16 = a4;
        v12 = s;
        v13 = v11;
        a1 = v7;
        v14 = 82;
      }
    }
    else
    {
      v16 = a4;
      v12 = s;
      v13 = 0;
      v14 = 86;
      a1 = v7;
    }
  }
  else
  {
    v12 = 0;
    v16 = a4;
    v13 = 0;
    v14 = 85;
  }
  return message(a1, v14, v13, (int)v12, v16);
}
// 7DEFC: using guessed type int opt_scantime;
// 7DF00: using guessed type int opt_expiry;
// 7DFC0: using guessed type int opt_queue;

//----- (00017128) --------------------------------------------------------
int __fastcall failoveronly(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4)
{
  int v5; // r5
  unsigned int *v8; // r6
  int v9; // r1
  bool v10; // zf
  int v11; // r3
  int v12; // r2
  int v13; // r1
  unsigned __int8 v15; // [sp+18h] [bp+0h]

  if ( a3 && *a3 )
  {
    v8 = a1;
    v5 = (unsigned __int8)*a3;
    v9 = LOBYTE((*_ctype_tolower_loc())[v5]);
    v10 = v9 == 116;
    if ( v9 != 116 )
      v10 = v9 == 102;
    *a3 = v9;
    v11 = !v10;
    if ( v10 )
    {
      v15 = a4;
      a1 = v8;
      v12 = v9 == 116;
      opt_fail_only = v9 == 116;
      v13 = 77;
    }
    else
    {
      v11 = 0;
      v15 = a4;
      a1 = v8;
      v12 = 0;
      v13 = 76;
    }
  }
  else
  {
    v11 = 0;
    v15 = a4;
    v12 = 0;
    v13 = 75;
  }
  return message(a1, v13, v12, v11, v15);
}
// 80DCEC: using guessed type char opt_fail_only;

//----- (00017194) --------------------------------------------------------
void __fastcall removepool(unsigned int *a1, int a2, char *nptr, int a4, int a5)
{
  int v6; // r3
  int v7; // r2
  int v8; // r1
  unsigned int *v9; // r6
  int v10; // r5
  int v11; // r0
  int v12; // r7
  int v13; // r4
  char *v14; // r8
  unsigned __int8 v15; // [sp+20h] [bp+0h]

  v6 = total_pools;
  if ( !total_pools )
  {
    v15 = a4;
    v7 = total_pools;
    v8 = 8;
    goto LABEL_5;
  }
  if ( !nptr || !*nptr )
  {
    v6 = 0;
    v15 = a4;
    v7 = 0;
    v8 = 25;
LABEL_5:
    message(a1, v8, v7, v6, v15);
    return;
  }
  v9 = a1;
  v10 = a4;
  v11 = strtol(nptr, 0, 10);
  v12 = v11;
  if ( v11 < 0 || v11 >= total_pools )
  {
    v15 = v10;
    v7 = v11;
    a1 = v9;
    v6 = 0;
    v8 = 26;
    goto LABEL_5;
  }
  if ( total_pools <= 1 )
  {
    v15 = v10;
    v7 = v11;
    a1 = v9;
    v6 = 0;
    v8 = 66;
    goto LABEL_5;
  }
  v13 = *(_DWORD *)(pools + 4 * v11);
  if ( v13 == current_pool() )
    switch_pools(0);
  if ( v13 == current_pool() )
  {
    v15 = v10;
    v7 = v12;
    a1 = v9;
    v6 = 0;
    v8 = 67;
    goto LABEL_5;
  }
  *(_DWORD *)(v13 + 100) = 0;
  v14 = (char *)escape_string(*(const char **)(v13 + 164), v10);
  if ( v14 == *(char **)(v13 + 164) )
  {
    remove_pool(v13);
    v15 = v10;
    v6 = (int)v14;
    v7 = v12;
    a1 = v9;
    v8 = 68;
    goto LABEL_5;
  }
  remove_pool(v13);
  message(v9, 68, v12, (int)v14, v10);
  j_free(v14);
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00017288) --------------------------------------------------------
int __fastcall disablepool(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  int v6; // r3
  int v7; // r2
  int v8; // r1
  unsigned int *v9; // r6
  unsigned __int8 v10; // r5
  int v11; // r0
  int v12; // r7
  int v13; // r4
  unsigned __int8 v15; // [sp+18h] [bp+0h]

  v6 = total_pools;
  if ( total_pools )
  {
    if ( nptr && *nptr )
    {
      v9 = a1;
      v10 = a4;
      v11 = strtol(nptr, 0, 10);
      v12 = v11;
      if ( v11 < 0 || v11 >= total_pools )
      {
        v15 = v10;
        v7 = v11;
        a1 = v9;
        v6 = 0;
        v8 = 26;
      }
      else
      {
        v13 = *(_DWORD *)(pools + 4 * v11);
        v6 = *(_DWORD *)(v13 + 100);
        if ( v6 )
        {
          if ( enabled_pools <= 1 )
          {
            v15 = v10;
            v7 = v11;
            a1 = v9;
            v6 = 0;
            v8 = 51;
          }
          else
          {
            *(_DWORD *)(v13 + 100) = 0;
            if ( v13 == current_pool() )
              switch_pools(0);
            v15 = v10;
            v7 = v12;
            a1 = v9;
            v6 = 0;
            v8 = 48;
          }
        }
        else
        {
          v15 = v10;
          v7 = v11;
          a1 = v9;
          v8 = 50;
        }
      }
    }
    else
    {
      v6 = 0;
      v15 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v15 = a4;
    v7 = total_pools;
    v8 = 8;
  }
  return message(a1, v8, v7, v6, v15);
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;
// 80CC90: using guessed type int enabled_pools;

//----- (00017350) --------------------------------------------------------
int __fastcall enablepool(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  int v6; // r3
  int v7; // r2
  int v8; // r1
  unsigned int *v9; // r6
  unsigned __int8 v10; // r5
  int v11; // r0
  int v12; // r7
  int v13; // r4
  int v14; // r8
  unsigned __int8 v16; // [sp+18h] [bp+0h]

  v6 = total_pools;
  if ( total_pools )
  {
    if ( nptr && *nptr )
    {
      v9 = a1;
      v10 = a4;
      v11 = strtol(nptr, 0, 10);
      v12 = v11;
      if ( v11 < 0 || v11 >= total_pools )
      {
        v16 = v10;
        v7 = v11;
        a1 = v9;
        v6 = 0;
        v8 = 26;
      }
      else
      {
        v13 = *(_DWORD *)(pools + 4 * v11);
        if ( *(_DWORD *)(v13 + 100) == 1 )
        {
          v16 = v10;
          v7 = v11;
          a1 = v9;
          v6 = 0;
          v8 = 49;
        }
        else
        {
          v14 = *(_DWORD *)(v13 + 4);
          *(_DWORD *)(v13 + 100) = 1;
          if ( v14 < *(_DWORD *)(current_pool() + 4) )
            switch_pools(v13);
          v16 = v10;
          v7 = v12;
          a1 = v9;
          v6 = 0;
          v8 = 47;
        }
      }
    }
    else
    {
      v6 = 0;
      v16 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v16 = a4;
    v7 = total_pools;
    v8 = 8;
  }
  return message(a1, v8, v7, v6, v16);
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00017400) --------------------------------------------------------
int __fastcall poolquota(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  char *v6; // r3
  unsigned int *v7; // r7
  unsigned __int8 v8; // r6
  char *v10; // r8
  int v11; // r0
  int v12; // r2
  int v13; // r1
  int v15; // r5
  int v16; // r0
  int v17; // r4
  unsigned __int8 v18; // [sp+20h] [bp+0h]

  v6 = (char *)total_pools;
  if ( total_pools )
  {
    if ( s && *s )
    {
      v7 = a1;
      v8 = a4;
      v10 = strchr(s, 44);
      if ( v10 )
      {
        *v10 = 0;
        v11 = strtol(s, 0, 10);
        if ( v11 >= 0 && v11 < total_pools )
        {
          v15 = *(_DWORD *)(pools + 4 * v11);
          v16 = strtol(v10 + 1, 0, 10);
          v17 = v16;
          if ( v16 < 0 )
          {
            v6 = *(char **)(v15 + 164);
            v12 = v16;
            v18 = v8;
            a1 = v7;
            v13 = 121;
          }
          else
          {
            *(_DWORD *)(v15 + 56) = v16;
            adjust_quota_gcd();
            v6 = *(char **)(v15 + 164);
            v12 = v17;
            v18 = v8;
            a1 = v7;
            v13 = 122;
          }
        }
        else
        {
          v18 = v8;
          v12 = v11;
          a1 = v7;
          v6 = 0;
          v13 = 26;
        }
      }
      else
      {
        v18 = v8;
        v6 = s;
        v12 = 0;
        v13 = 86;
        a1 = v7;
      }
    }
    else
    {
      v6 = 0;
      v18 = a4;
      v12 = 0;
      v13 = 25;
    }
  }
  else
  {
    v18 = a4;
    v12 = total_pools;
    v13 = 8;
  }
  return message(a1, v13, v12, (int)v6, v18);
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (000174DC) --------------------------------------------------------
int __fastcall poolpriority(unsigned int *a1, int a2, char *s, int a4)
{
  unsigned int **v6; // r9
  unsigned int **v7; // r2
  unsigned int **v8; // r3
  unsigned int *v9; // r5
  char *v10; // r10
  char *v11; // r0
  char *v12; // r4
  const char *v13; // r0
  int v14; // r0
  char *v15; // lr
  int v16; // r1
  unsigned int **v17; // r0
  int v18; // r6
  int v19; // r4
  int v20; // t1
  int v21; // r5
  char *v22; // r2
  int v23; // r3
  int v25; // r0
  char v26; // [sp+7h] [bp-1h] BYREF
  unsigned int *v27; // [sp+8h] [bp+0h] BYREF
  int v28; // [sp+Ch] [bp+4h]

  v28 = a4;
  v27 = a1;
  if ( !total_pools )
    return message(a1, 8, total_pools, total_pools, v28);
  if ( !s || !*s )
    return message(v27, 25, 0, 0, v28);
  v6 = &v27;
  if ( total_pools > 0 )
  {
    v7 = (unsigned int **)((char *)&v27 + total_pools);
    v8 = &v27;
    do
    {
      *(_BYTE *)v8 = 0;
      v8 = (unsigned int **)((char *)v8 + 1);
    }
    while ( v8 != v7 );
  }
  v9 = 0;
  v10 = s;
  do
  {
    v11 = strchr(v10, 44);
    v12 = v11;
    if ( v11 )
    {
      v12 = v11 + 1;
      *v11 = 0;
    }
    v13 = v10;
    v10 = v12;
    v14 = strtol(v13, 0, 10);
    v15 = (char *)v9 + 1;
    if ( v14 < 0 )
      return message(v27, 26, v14, 0, v28);
    v16 = total_pools;
    if ( total_pools <= v14 )
      return message(v27, 26, v14, 0, v28);
    if ( *((_BYTE *)&v27 + v14) )
      return message(v27, 74, v14, 0, v28);
    (&v27)[v14] = v9;
    v9 = (unsigned int *)((char *)v9 + 1);
    *((_BYTE *)&v27 + v14) = 1;
  }
  while ( v12 && *v12 );
  v17 = &v27;
  v18 = pools;
  v19 = pools;
  do
  {
    v20 = *(unsigned __int8 *)v17;
    v17 = (unsigned int **)((char *)v17 + 1);
    if ( v20 )
      *(_DWORD *)(*(_DWORD *)v19 + 4) = *v6;
    v19 += 4;
    ++v6;
  }
  while ( (unsigned int **)((char *)&v27 + v16) != v17 );
  v21 = 0;
LABEL_22:
  while ( 2 )
  {
    v22 = &v26;
    v23 = 0;
    while ( 1 )
    {
      if ( !*++v22 )
      {
        v25 = *(_DWORD *)(v18 + 4 * v23);
        if ( *(_DWORD *)(v25 + 4) == v21 )
          break;
      }
      if ( v16 == ++v23 )
      {
        if ( v16 != ++v21 )
          goto LABEL_22;
        goto LABEL_27;
      }
    }
    ++v21;
    *(_DWORD *)(v25 + 4) = v15++;
    *((_BYTE *)&v27 + v23) = 1;
    if ( v16 != v21 )
      continue;
    break;
  }
LABEL_27:
  if ( *(_DWORD *)(current_pool() + 4) )
    switch_pools(0);
  return message(v27, 73, 0, 0, v28);
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (0001765C) --------------------------------------------------------
void __fastcall addpool(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v7; // r8
  int *v8; // r7
  char *v9; // r4
  char *v10; // [sp+Ch] [bp-24h] BYREF
  const char *v11; // [sp+10h] [bp-20h] BYREF
  const char *v12; // [sp+14h] [bp-1Ch] BYREF

  if ( a3 && *a3 )
  {
    if ( pooldetails((unsigned __int8 *)a3, &v10, &v11, &v12) )
    {
      v8 = (int *)add_pool();
      detect_stratum((int)v8, v10);
      add_pool_details((int)v8, 1, v10, v11, v12);
      v9 = (char *)escape_string(v10, a4);
      message(a1, 55, *v8, (int)v9, a4);
      if ( v9 != v10 )
        free(v9);
    }
    else
    {
      v7 = (char *)escape_string(a3, a4);
      message(a1, 53, 0, (int)v7, a4);
      if ( a3 != v7 )
        free(v7);
    }
  }
  else
  {
    message(a1, 52, 0, 0, a4);
  }
}

//----- (000176FC) --------------------------------------------------------
int __fastcall switchpool(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  int v6; // r3
  int v7; // r2
  int v8; // r1
  unsigned int *v9; // r6
  unsigned __int8 v10; // r5
  int v11; // r7
  int v13; // r4
  unsigned __int8 v14; // [sp+18h] [bp+0h]

  v6 = total_pools;
  if ( total_pools )
  {
    if ( nptr && *nptr )
    {
      v9 = a1;
      v10 = a4;
      v11 = strtol(nptr, 0, 10);
      if ( pthread_mutex_lock(&control_lock) )
        mutex_lock_part_3_constprop_27("switchpool", 2981);
      rd_lock_constprop_25(&rwlock, "switchpool", 2981);
      if ( pthread_mutex_unlock(&control_lock) )
        mutex_unlock_noyield_part_5_constprop_32("switchpool", 2981);
      if ( v11 >= 0 && v11 < total_pools )
      {
        v13 = *(_DWORD *)(pools + 4 * v11);
        *(_DWORD *)(v13 + 100) = 1;
        if ( pthread_rwlock_unlock(&rwlock) )
          rw_unlock_part_4_constprop_30("switchpool", 2991);
        selective_yield(0);
        switch_pools(v13);
        v14 = v10;
        v7 = v11;
        a1 = v9;
        v6 = 0;
        v8 = 27;
      }
      else
      {
        if ( pthread_rwlock_unlock(&rwlock) )
          rw_unlock_part_4_constprop_30("switchpool", 2984);
        selective_yield(0);
        v14 = v10;
        v7 = v11;
        a1 = v9;
        v6 = 0;
        v8 = 26;
      }
    }
    else
    {
      v6 = 0;
      v14 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v14 = a4;
    v7 = total_pools;
    v8 = 8;
  }
  return message(a1, v8, v7, v6, v14);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;
// 80CC54: using guessed type pthread_mutex_t control_lock;

//----- (0001781C) --------------------------------------------------------
int __fastcall edevstatus(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return message(a1, 10, 0, 0, a4);
}

//----- (00017828) --------------------------------------------------------
int __fastcall devstatus(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return message(a1, 10, 0, 0, a4);
}

//----- (00017834) --------------------------------------------------------
int __fastcall asccount(int a1, int a2, int a3, int a4)
{
  int v6; // r5
  char **v7; // r0
  int result; // r0
  char **v9; // r0
  int v10[5]; // [sp+Ch] [bp-14h] BYREF

  v10[0] = 0;
  message((unsigned int *)a1, 104, 0, 0, a4);
  if ( a4 )
  {
    v6 = io_add((unsigned int *)a1, ",\"ASCS\":[");
    v7 = (char **)api_add_data_full(0, "Count", 6, (const char *)v10, 0);
    result = print_data((unsigned int *)a1, v7, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    io_add((unsigned int *)a1, "ASCS,");
    v9 = (char **)api_add_data_full(0, "Count", 6, (const char *)v10, 0);
    return print_data((unsigned int *)a1, v9, 0, 0);
  }
  return result;
}

//----- (000178BC) --------------------------------------------------------
int __fastcall debugstate(int a1, int a2, _BYTE *a3, int a4)
{
  int v7; // r2
  int v8; // r3
  int v9; // r6
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  char **v16; // r0
  int result; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  char **v24; // r1
  int v25; // r3
  int v26; // r3

  if ( a3 )
  {
    v7 = LOBYTE((*_ctype_tolower_loc())[(unsigned __int8)*a3]);
    *a3 = v7;
    switch ( v7 )
    {
      case 'd':
        v8 = (unsigned __int8)opt_debug ^ 1;
        opt_debug = v8;
        opt_log_output = v8;
        if ( v8 )
          goto LABEL_4;
        break;
      case 'n':
        opt_log_output = 0;
        opt_debug = 0;
        opt_quiet = 0;
        opt_protocol = 0;
        want_per_device_stats = 0;
        opt_worktime = 0;
        break;
      case 'p':
        want_per_device_stats ^= 1u;
        opt_log_output = want_per_device_stats;
        break;
      case 'q':
        opt_quiet ^= 1u;
        break;
      case 'r':
        v25 = (unsigned __int8)opt_protocol ^ 1;
        opt_protocol ^= 1u;
        if ( v25 )
          goto LABEL_4;
        break;
      case 's':
        opt_realquiet = 1;
        break;
      case 'v':
        v26 = (unsigned __int8)opt_log_output ^ 1;
        opt_log_output ^= 1u;
        if ( v26 )
LABEL_4:
          opt_quiet = 0;
        break;
      case 'w':
        opt_worktime ^= 1u;
        break;
      default:
        break;
    }
  }
  message((unsigned int *)a1, 79, 0, 0, a4);
  if ( a4 )
  {
    v9 = io_add((unsigned int *)a1, ",\"DEBUG\":[");
    v10 = api_add_data_full(0, "Silent", 14, &opt_realquiet, 0);
    v11 = api_add_data_full(v10, "Quiet", 14, &opt_quiet, 0);
    v12 = api_add_data_full(v11, "Verbose", 14, &opt_log_output, 0);
    v13 = api_add_data_full(v12, "Debug", 14, &opt_debug, 0);
    v14 = api_add_data_full(v13, "RPCProto", 14, &opt_protocol, 0);
    v15 = api_add_data_full(v14, "PerDevice", 14, &want_per_device_stats, 0);
    v16 = (char **)api_add_data_full(v15, "WorkTime", 14, &opt_worktime, 0);
    result = print_data((unsigned int *)a1, v16, 1, 0);
    if ( v9 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    io_add((unsigned int *)a1, "DEBUG,");
    v18 = api_add_data_full(0, "Silent", 14, &opt_realquiet, 0);
    v19 = api_add_data_full(v18, "Quiet", 14, &opt_quiet, 0);
    v20 = api_add_data_full(v19, "Verbose", 14, &opt_log_output, 0);
    v21 = api_add_data_full(v20, "Debug", 14, &opt_debug, 0);
    v22 = api_add_data_full(v21, "RPCProto", 14, &opt_protocol, 0);
    v23 = api_add_data_full(v22, "PerDevice", 14, &want_per_device_stats, 0);
    v24 = (char **)api_add_data_full(v23, "WorkTime", 14, &opt_worktime, 0);
    return print_data((unsigned int *)a1, v24, 0, 0);
  }
  return result;
}
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA98: using guessed type char opt_quiet;
// 80BAA8: using guessed type char want_per_device_stats;
// 80BAB8: using guessed type char opt_protocol;
// 80CBB8: using guessed type char opt_worktime;
// 80DCB4: using guessed type char opt_realquiet;

//----- (00017BA0) --------------------------------------------------------
int __fastcall checkcommand(int a1, int a2, char *s2, int a4, char a5)
{
  const char *v8; // r0
  void **v9; // r4
  const char *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r3
  _BOOL4 v13; // r4
  int v14; // r5
  _DWORD *v15; // r0
  const char *v16; // r3
  int result; // r0
  int v18; // r0
  const char *v19; // r3
  const char *v20; // r1
  char **v21; // r0
  char s[124]; // [sp+Ch] [bp-7Ch] BYREF

  if ( !s2 || !*s2 )
    return message((unsigned int *)a1, 71, 0, 0, a4);
  v8 = (const char *)cmds;
  if ( cmds )
  {
    v9 = &cmds;
    while ( strcmp(v8, s2) )
    {
      v10 = (const char *)v9[3];
      v9 += 3;
      v8 = v10;
      if ( !v10 )
        goto LABEL_16;
    }
    sprintf(s, "|%s|", s2);
    v11 = _ctype_toupper_loc();
    v12 = (*v11)[(unsigned __int8)a5];
    v13 = v12 == (*v11)[87] || strstr(*((const char **)&apigroups + v12 - (*v11)[65]), s) != 0;
    message((unsigned int *)a1, 72, 0, 0, a4);
    if ( a4 )
      v14 = io_add((unsigned int *)a1, ",\"CHECK\":[");
    else
      v14 = io_add((unsigned int *)a1, "CHECK,");
    v15 = api_add_data_full(0, "Exists", 2, "Y", 0);
    v16 = "Y";
    if ( !v13 )
      v16 = "N";
  }
  else
  {
LABEL_16:
    message((unsigned int *)a1, 72, 0, 0, a4);
    if ( a4 )
    {
      v14 = io_add((unsigned int *)a1, ",\"CHECK\":[");
      LOWORD(v19) = -32528;
      LOWORD(v20) = -32516;
    }
    else
    {
      v18 = io_add((unsigned int *)a1, "CHECK,");
      LOWORD(v19) = (unsigned __int16)"N";
      v14 = v18;
      LOWORD(v20) = (unsigned __int16)"Exists";
    }
    HIWORD(v19) = (unsigned int)"N" >> 16;
    HIWORD(v20) = (unsigned int)"Exists" >> 16;
    v15 = api_add_data_full(0, v20, 2, v19, 0);
    v16 = "N";
  }
  v21 = (char **)api_add_data_full(v15, "Access", 2, v16, 0);
  result = print_data((unsigned int *)a1, v21, a4, 0);
  if ( (a4 & v14) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7D500: using guessed type void *cmds;

//----- (00017D2C) --------------------------------------------------------
int __fastcall devdetails(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r10
  _DWORD *v8; // r11
  int devices; // r5
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  const char *v14; // r3
  _DWORD *v15; // r0
  const char *v16; // r3
  _DWORD *v17; // r0
  const char *v18; // r3
  char **v19; // r0
  int v20; // r3
  int v21; // [sp+Ch] [bp-2Ch] BYREF

  if ( !total_devices )
    return message((unsigned int *)a1, 10, total_devices, total_devices, a4);
  result = message((unsigned int *)a1, 69, 0, 0, a4);
  if ( !a4 )
  {
    v21 = 0;
    if ( total_devices <= 0 )
      return result;
    v7 = 0;
    goto LABEL_6;
  }
  result = io_add((unsigned int *)a1, ",\"DEVDETAILS\":[");
  v21 = 0;
  v7 = result;
  if ( total_devices > 0 )
  {
LABEL_6:
    v8 = 0;
    result = 0;
    do
    {
      devices = get_devices(result);
      v10 = api_add_data_full(v8, "DEVDETAILS", 6, (const char *)&v21, 0);
      v11 = api_add_data_full(v10, "Name", 1, *(const char **)(*(_DWORD *)(devices + 4) + 8), 0);
      v12 = api_add_data_full(v11, "ID", 6, (const char *)(devices + 8), 0);
      v13 = api_add_data_full(v12, "Driver", 1, *(const char **)(*(_DWORD *)(devices + 4) + 4), 0);
      v14 = *(const char **)(devices + 168);
      if ( !v14 )
        v14 = "";
      v15 = api_add_data_full(v13, "Kernel", 2, v14, 0);
      v16 = *(const char **)(devices + 12);
      if ( !v16 )
        v16 = "";
      v17 = api_add_data_full(v15, "Model", 2, v16, 0);
      v18 = *(const char **)(devices + 16);
      if ( !v18 )
        v18 = "";
      v19 = (char **)api_add_data_full(v17, "Device Path", 2, v18, 0);
      v20 = a4;
      if ( a4 )
        v20 = v21 > 0;
      v8 = (_DWORD *)print_data((unsigned int *)a1, v19, a4, v20);
      result = ++v21;
    }
    while ( v21 < total_devices );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 80DCD8: using guessed type int total_devices;

//----- (00017E84) --------------------------------------------------------
int __fastcall pgacount(int a1, int a2, int a3, int a4)
{
  int v6; // r5
  char **v7; // r0
  int result; // r0
  char **v9; // r0
  int v10[5]; // [sp+Ch] [bp-14h] BYREF

  v10[0] = 0;
  message((unsigned int *)a1, 59, 0, 0, a4);
  if ( a4 )
  {
    v6 = io_add((unsigned int *)a1, ",\"PGAS\":[");
    v7 = (char **)api_add_data_full(0, "Count", 6, (const char *)v10, 0);
    result = print_data((unsigned int *)a1, v7, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    io_add((unsigned int *)a1, "PGAS,");
    v9 = (char **)api_add_data_full(0, "Count", 6, (const char *)v10, 0);
    return print_data((unsigned int *)a1, v9, 0, 0);
  }
  return result;
}

//----- (00017F0C) --------------------------------------------------------
int __fastcall noncenum(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  char **v9; // r0
  int result; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  char **v13; // r1

  message((unsigned int *)a1, 16, 0, 0, a4);
  if ( a4 )
  {
    v6 = io_add((unsigned int *)a1, ",\"NONCENUM\":[");
    v7 = api_add_data_full(0, "10min nonce", 1, nonce_num10_string, 0);
    v8 = api_add_data_full(v7, "30min nonce", 1, nonce_num30_string, 0);
    v9 = (char **)api_add_data_full(v8, "60min nonce", 1, nonce_num60_string, 0);
    result = print_data((unsigned int *)a1, v9, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    io_add((unsigned int *)a1, "NONCENUM,");
    v11 = api_add_data_full(0, "10min nonce", 1, nonce_num10_string, 0);
    v12 = api_add_data_full(v11, "30min nonce", 1, nonce_num30_string, 0);
    v13 = (char **)api_add_data_full(v12, "60min nonce", 1, nonce_num60_string, 0);
    return print_data((unsigned int *)a1, v13, 0, 0);
  }
  return result;
}

//----- (00018000) --------------------------------------------------------
int __fastcall minerconfig(int a1, int a2, int a3, int a4)
{
  char *v6; // r1
  int v7; // r7
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  char **v19; // r0
  int result; // r0
  int v21; // [sp+8h] [bp-20h] BYREF
  int v22; // [sp+Ch] [bp-1Ch] BYREF

  v21 = 0;
  v22 = 0;
  message((unsigned int *)a1, 33, 0, 0, a4);
  v6 = ",\"CONFIG\":[";
  if ( !a4 )
    v6 = "CONFIG,";
  v7 = io_add((unsigned int *)a1, v6);
  v8 = api_add_data_full(0, "ASC Count", 6, (const char *)&v21, 0);
  v9 = api_add_data_full(v8, "PGA Count", 6, (const char *)&v22, 0);
  v10 = api_add_data_full(v9, "Pool Count", 6, (const char *)&total_pools, 0);
  v11 = api_add_data_full(v10, "Strategy", 2, strategies[pool_strategy], 0);
  v12 = api_add_data_full(v11, "Log Interval", 6, (const char *)&opt_log_interval, 0);
  v13 = api_add_data_full(v12, "Device Code", 2, "", 0);
  v14 = api_add_data_full(v13, "OS", 2, "Linux", 0);
  v15 = api_add_data_full(v14, "Failover-Only", 14, &opt_fail_only, 0);
  v16 = api_add_data_full(v15, "ScanTime", 6, (const char *)&opt_scantime, 0);
  v17 = api_add_data_full(v16, "Queue", 6, (const char *)&opt_queue, 0);
  v18 = api_add_data_full(v17, "Expiry", 6, (const char *)&opt_expiry, 0);
  v19 = (char **)api_add_data_full(v18, "Hotplug", 2, "None", 0);
  result = print_data((unsigned int *)a1, v19, a4, 0);
  if ( (a4 & v7) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7DED8: using guessed type int opt_log_interval;
// 7DEFC: using guessed type int opt_scantime;
// 7DF00: using guessed type int opt_expiry;
// 7DFC0: using guessed type int opt_queue;
// 7DFC4: using guessed type char *strategies[5];
// 80F6C: using guessed type int pool_strategy;
// 80BAEC: using guessed type int total_pools;
// 80DCEC: using guessed type char opt_fail_only;

//----- (00018178) --------------------------------------------------------
int __fastcall apiversion(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  char **v11; // r0
  int result; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  char **v17; // r1

  message((unsigned int *)a1, 22, 0, 0, a4);
  if ( a4 )
  {
    v6 = io_add((unsigned int *)a1, ",\"VERSION\":[");
    v7 = api_add_data_full(0, "BMMiner", 1, "2.0.0", 0);
    v8 = api_add_data_full(v7, "API", 2, "3.1", 0);
    v9 = api_add_data_full(v8, "Miner", 1, g_miner_version, 0);
    v10 = api_add_data_full(v9, "CompileTime", 1, g_miner_compiletime, 0);
    v11 = (char **)api_add_data_full(v10, "Type", 1, g_miner_type, 0);
    result = print_data((unsigned int *)a1, v11, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    io_add((unsigned int *)a1, "VERSION,");
    v13 = api_add_data_full(0, "BMMiner", 1, "2.0.0", 0);
    v14 = api_add_data_full(v13, "API", 2, "3.1", 0);
    v15 = api_add_data_full(v14, "Miner", 1, g_miner_version, 0);
    v16 = api_add_data_full(v15, "CompileTime", 1, g_miner_compiletime, 0);
    v17 = (char **)api_add_data_full(v16, "Type", 1, g_miner_type, 0);
    return print_data((unsigned int *)a1, v17, 0, 0);
  }
  return result;
}

//----- (000182CC) --------------------------------------------------------
int __fastcall minecoin(int a1, int a2, int a3, int a4)
{
  char *v6; // r1
  int v7; // r8
  _DWORD *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r9
  _DWORD *v11; // r0
  char **v12; // r0
  int result; // r0

  message((unsigned int *)a1, 78, 0, 0, a4);
  v6 = ",\"COIN\":[";
  if ( !a4 )
    v6 = "COIN,";
  v7 = io_add((unsigned int *)a1, v6);
  v8 = api_add_data_full(0, "Hash Method", 2, "sha256", 0);
  if ( pthread_mutex_lock(&ch_lock) )
    mutex_lock_part_3_constprop_27("minecoin", 3777);
  rd_lock_constprop_25(&stru_80CC34, "minecoin", 3777);
  if ( pthread_mutex_unlock(&ch_lock) )
    mutex_unlock_noyield_part_5_constprop_32("minecoin", 3777);
  v9 = api_add_data_full(v8, "Current Block Time", 15, (const char *)&block_timeval, 1);
  v10 = api_add_data_full(v9, "Current Block Hash", 1, current_hash, 1);
  if ( pthread_rwlock_unlock(&stru_80CC34) )
    rw_unlock_part_4_constprop_30("minecoin", 3780);
  selective_yield(0);
  v11 = api_add_data_full(v10, "LP", 14, &have_longpoll, 0);
  v12 = (char **)api_add_data_full(v11, "Network Difficulty", 24, (const char *)&current_diff, 1);
  result = print_data((unsigned int *)a1, v12, a4, 0);
  if ( (a4 & v7) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7DEF0: using guessed type double current_diff;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80CC1A: using guessed type char have_longpoll;
// 80CC1C: using guessed type pthread_mutex_t ch_lock;
// 80DD08: using guessed type int block_timeval;

//----- (00018410) --------------------------------------------------------
int __fastcall poolstatus(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v5; // r3
  int v6; // r3
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  double v10; // d5
  double v11; // d7
  double v12; // d6
  _DWORD *v13; // r0
  double v14; // d5
  double v15; // d7
  double v16; // d6
  char **v17; // r0
  int v18; // r5
  int v20; // r4
  int v21; // r3
  const char *v22; // r3
  time_t v23; // r0
  int v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r0
  _DWORD *v34; // r0
  _DWORD *v35; // r0
  _DWORD *v36; // r0
  _DWORD *v37; // r0
  _DWORD *v38; // r0
  _DWORD *v39; // r0
  _DWORD *v40; // r0
  _DWORD *v41; // r0
  _DWORD *v42; // r11
  char *v43; // r0
  _DWORD *v44; // r0
  _DWORD *v45; // r0
  _DWORD *v46; // r0
  _DWORD *v47; // r0
  _DWORD *v48; // r0
  _DWORD *v49; // r0
  _DWORD *v50; // r0
  _DWORD *v51; // r0
  const char *v52; // r7
  _DWORD *v53; // r0
  _DWORD *v55; // [sp+10h] [bp-160h]
  const char *v56; // [sp+14h] [bp-15Ch]
  int v58; // [sp+24h] [bp-14Ch]
  int v59; // [sp+2Ch] [bp-144h] BYREF
  double v60; // [sp+30h] [bp-140h] BYREF
  double v61; // [sp+38h] [bp-138h] BYREF
  __int16 s[128]; // [sp+40h] [bp-130h] BYREF

  memset(s, 0, sizeof(s));
  if ( !total_pools )
    return message((unsigned int *)a1, 8, 0, 0, a4);
  result = message((unsigned int *)a1, 7, 0, 0, a4);
  if ( a4 )
  {
    result = io_add((unsigned int *)a1, ",\"POOLS\":[");
    v59 = 0;
    v58 = result;
    if ( total_pools <= 0 )
    {
LABEL_36:
      if ( v58 )
        *(_BYTE *)(a1 + 13) = 1;
      return result;
    }
LABEL_8:
    v6 = 0;
    v55 = 0;
    do
    {
      v20 = *(_DWORD *)(pools + 4 * v6);
      v18 = *(unsigned __int8 *)(v20 + 105);
      if ( !*(_BYTE *)(v20 + 105) )
      {
        v21 = *(_DWORD *)(v20 + 100);
        if ( v21 == 1 )
        {
          v52 = "Alive";
          if ( *(_BYTE *)(v20 + 97) )
            v52 = "Dead";
        }
        else if ( v21 )
        {
          v52 = "Rejecting";
          if ( v21 != 2 )
            v52 = "Unknown";
        }
        else
        {
          v52 = "Disabled";
        }
        v22 = "Y";
        if ( !*(_DWORD *)(v20 + 108) )
          v22 = "N";
        v56 = v22;
        if ( *(int *)(v20 + 352) > 0 )
        {
          v23 = time(0);
          v24 = (v23 - *(_DWORD *)(v20 + 352)) & ~((v23 - *(_DWORD *)(v20 + 352)) >> 31);
          sprintf((char *)s, "%d:%02d:%02d", v24 / 3600, v24 % 3600 / 60, v24 % 3600 % 60);
        }
        else
        {
          s[0] = 48;
        }
        v25 = api_add_data_full(v55, "POOL", 6, (const char *)&v59, 0);
        v26 = api_add_data_full(v25, "URL", 0, *(const char **)(v20 + 164), 0);
        v27 = api_add_data_full(v26, "Status", 1, v52, 0);
        v28 = api_add_data_full(v27, "Priority", 6, (const char *)(v20 + 4), 0);
        v29 = api_add_data_full(v28, "Quota", 6, (const char *)(v20 + 56), 0);
        v30 = api_add_data_full(v29, "Long Poll", 1, v56, 0);
        v31 = api_add_data_full(v30, "Getworks", 7, (const char *)(v20 + 116), 0);
        v32 = api_add_data_full(v31, "Accepted", 11, (const char *)(v20 + 8), 0);
        v33 = api_add_data_full(v32, "Rejected", 11, (const char *)(v20 + 16), 0);
        v34 = api_add_data_full(v33, "Discarded", 7, (const char *)(v20 + 124), 0);
        v35 = api_add_data_full(v34, "Stale", 7, (const char *)(v20 + 120), 0);
        v36 = api_add_data_full(v35, "Get Failures", 7, (const char *)(v20 + 128), 0);
        v37 = api_add_data_full(v36, "Remote Failures", 7, (const char *)(v20 + 132), 0);
        v38 = api_add_data_full(v37, "User", 0, *(const char **)(v20 + 172), 0);
        v39 = api_add_data_full(v38, "Last Share Time", 1, (const char *)s, 0);
        v40 = api_add_data_full(v39, "Diff", 1, (const char *)(v20 + 48), 0);
        v41 = api_add_data_full(v40, "Diff1 Shares", 11, (const char *)(v20 + 40), 0);
        v42 = v41;
        if ( *(_DWORD *)(v20 + 184) )
        {
          v43 = proxytype(*(char **)(v20 + 180));
          v44 = api_add_data_full(v42, "Proxy Type", 2, v43, 0);
          v45 = api_add_data_full(v44, "Proxy", 0, *(const char **)(v20 + 184), 0);
        }
        else
        {
          v53 = api_add_data_full(v41, "Proxy Type", 2, "", 0);
          v45 = api_add_data_full(v53, "Proxy", 2, "", 0);
        }
        v46 = api_add_data_full(v45, "Difficulty Accepted", 24, (const char *)(v20 + 72), 0);
        v47 = api_add_data_full(v46, "Difficulty Rejected", 24, (const char *)(v20 + 80), 0);
        v48 = api_add_data_full(v47, "Difficulty Stale", 24, (const char *)(v20 + 88), 0);
        v49 = api_add_data_full(v48, "Last Share Difficulty", 24, (const char *)(v20 + 360), 0);
        v50 = api_add_data_full(v49, "Has Stratum", 14, (const char *)(v20 + 640), 0);
        v51 = api_add_data_full(v50, "Stratum Active", 14, (const char *)(v20 + 641), 0);
        if ( *(_BYTE *)(v20 + 641) )
          v7 = api_add_data_full(v51, "Stratum URL", 0, *(const char **)(v20 + 576), 0);
        else
          v7 = api_add_data_full(v51, "Stratum URL", 2, "", *(_BYTE *)(v20 + 641));
        v8 = api_add_data_full(v7, "Has GBT", 14, (const char *)(v20 + 736), 0);
        v9 = api_add_data_full(v8, "Best Share", 10, (const char *)(v20 + 368), 1);
        v10 = *(double *)(v20 + 80);
        v11 = v10 + *(double *)(v20 + 72) + *(double *)(v20 + 88);
        if ( v11 == 0.0 )
          v12 = 0.0;
        else
          v12 = v10 / v11;
        v60 = v12;
        v13 = api_add_data_full(v9, "Pool Rejected%", 25, (const char *)&v60, 0);
        v14 = *(double *)(v20 + 88);
        v15 = *(double *)(v20 + 72) + *(double *)(v20 + 80) + v14;
        if ( v15 == 0.0 )
          v16 = 0.0;
        else
          v16 = v14 / v15;
        v61 = v16;
        v17 = (char **)api_add_data_full(v13, "Pool Stale%", 25, (const char *)&v61, 0);
        if ( a4 )
          v18 = v59 > 0;
        result = print_data((unsigned int *)a1, v17, a4, v18);
        v55 = (_DWORD *)result;
      }
      v6 = v59 + 1;
    }
    while ( total_pools > ++v59 );
    goto LABEL_36;
  }
  v5 = total_pools;
  if ( total_pools > 0 )
    v5 = 0;
  v59 = 0;
  if ( total_pools > 0 )
  {
    v58 = v5;
    goto LABEL_8;
  }
  return result;
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (0001894C) --------------------------------------------------------
int __fastcall lcddisplay(int a1, int a2, int a3, int a4)
{
  int v6; // r8
  int v7; // r6
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r9
  _DWORD *v11; // r9
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  char **v14; // r1
  int result; // r0
  _DWORD *v16; // r0
  double v17; // [sp+8h] [bp-C8h] BYREF
  __int16 s[16]; // [sp+10h] [bp-C0h] BYREF
  char v19[32]; // [sp+30h] [bp-A0h] BYREF
  char v20[32]; // [sp+50h] [bp-80h] BYREF
  char v21[32]; // [sp+70h] [bp-60h] BYREF
  char v22[64]; // [sp+90h] [bp-40h] BYREF

  memset(s, 0, sizeof(s));
  v6 = a4;
  memset(v19, 0, sizeof(v19));
  memset(v20, 0, sizeof(v20));
  memset(v21, 0, sizeof(v21));
  memset(v22, 0, 32u);
  v7 = current_pool();
  message((unsigned int *)a1, 7, 0, 0, a4);
  if ( a4 )
    v6 = io_add((unsigned int *)a1, ",\"POOLS\":[");
  s[0] = 48;
  v17 = (total_mhashes_done - new_total_mhashes_done) / 1000.0 / (total_secs - new_total_secs);
  v8 = api_add_data_full(0, "LCD", 1, (const char *)s, 0);
  v9 = api_add_data_full(v8, "GHS5s", 17, g_displayed_rolling, 0);
  v10 = api_add_data_full(v9, "GHSavg", 17, (const char *)&v17, 0);
  sprintf(v19, "%d", g_max_fan);
  v11 = api_add_data_full(v10, "fan", 1, v19, 0);
  sprintf(v20, "%d", g_max_temp);
  v12 = api_add_data_full(v11, "temp", 1, v20, 0);
  if ( v7 )
  {
    v13 = api_add_data_full(v12, "pool", 1, *(const char **)(v7 + 164), 0);
    v14 = (char **)api_add_data_full(v13, "user", 1, *(const char **)(v7 + 172), 0);
  }
  else
  {
    strcpy(v21, "no");
    strcpy(v22, "no");
    v16 = api_add_data_full(v12, "pool", 1, v21, 0);
    v14 = (char **)api_add_data_full(v16, "user", 1, v22, 0);
  }
  result = print_data((unsigned int *)a1, v14, a4, a4);
  if ( v6 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7DEC8: using guessed type double total_secs;
// 7DEE0: using guessed type double new_total_secs;
// 80DC98: using guessed type int g_max_fan;
// 80DC9C: using guessed type int g_max_temp;

//----- (00018B38) --------------------------------------------------------
int __fastcall itemstats_isra_17(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6)
{
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  char **v17; // r0
  char **v18; // r1
  int v19; // r3
  int v20; // r3
  int v22; // [sp+Ch] [bp-34h] BYREF
  double v23; // [sp+10h] [bp-30h] BYREF
  double v24; // [sp+18h] [bp-28h] BYREF

  v22 = a2;
  v23 = (total_mhashes_done - new_total_mhashes_done) / 1000.0 / (total_secs - new_total_secs);
  v9 = api_add_data_full(0, "STATS", 6, (const char *)&v22, 0);
  v10 = api_add_data_full(v9, "ID", 1, a3, 0);
  v24 = (double)mined_time_record + total_secs;
  v11 = api_add_data_full(v10, "Elapsed", 13, (const char *)&v24, 0);
  v12 = api_add_data_full(v11, "Calls", 8, a4, 0);
  v13 = api_add_data_full(v12, "Wait", 15, a4 + 4, 0);
  v14 = api_add_data_full(v13, "Max", 15, a4 + 12, 0);
  v15 = api_add_data_full(v14, "Min", 15, a4 + 20, 0);
  v16 = api_add_data_full(v15, "GHS 5s", 1, displayed_hash_rate, 0);
  v17 = (char **)api_add_data_full(v16, "GHS av", 17, (const char *)&v23, 0);
  v18 = v17;
  if ( a5 )
  {
    if ( v17 )
    {
      v19 = *(_DWORD *)(a5 + 16);
      *(_DWORD *)(a5 + 16) = v17[4];
      *((_DWORD *)v17[4] + 5) = a5;
      *(_DWORD *)(v19 + 20) = v17;
      v17[4] = (char *)v19;
    }
    else
    {
      v18 = (char **)a5;
    }
  }
  v20 = a6;
  if ( a6 )
    v20 = v22 > 0;
  print_data(a1, v18, a6, v20);
  return v22 + 1;
}
// 7DEC8: using guessed type double total_secs;
// 7DEE0: using guessed type double new_total_secs;

//----- (00018CA8) --------------------------------------------------------
int __fastcall minerestats(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r4
  int v8; // r7
  int v9; // r5
  int v10; // r3
  int (*v11)(void); // r6
  int v12; // r0
  int v13; // [sp+Ch] [bp-44h]
  char s[60]; // [sp+14h] [bp-3Ch] BYREF

  result = message((unsigned int *)a1, 70, 0, 0, a4);
  if ( !a4 )
  {
    if ( total_devices <= 0 )
      return result;
    v13 = 0;
    goto LABEL_5;
  }
  result = io_add((unsigned int *)a1, ",\"STATS\":[");
  v13 = result;
  if ( total_devices > 0 )
  {
LABEL_5:
    v7 = 0;
    v8 = 0;
    do
    {
      result = get_devices(v7);
      v9 = result;
      if ( result )
      {
        v10 = *(_DWORD *)(result + 4);
        if ( v10 )
        {
          v11 = *(int (**)(void))(v10 + 28);
          if ( v11 )
          {
            v12 = v11();
            v10 = *(_DWORD *)(v9 + 4);
            v11 = (int (*)(void))v12;
          }
          sprintf(s, "%s%d", *(const char **)(v10 + 8), *(_DWORD *)(v9 + 8));
          result = itemstats_isra_17((unsigned int *)a1, v8, s, (const char *)(v9 + 292), (int)v11, a4);
          v8 = result;
        }
      }
      ++v7;
    }
    while ( total_devices > v7 );
  }
  if ( v13 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 80DCD8: using guessed type int total_devices;

//----- (00018D60) --------------------------------------------------------
int __fastcall minerstats(int a1, int a2, int a3, int a4)
{
  _DWORD *v6; // r0
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  char **v9; // r0
  int result; // r0
  int v11; // r4
  int v12; // r8
  int v13; // r5
  int v14; // r3
  int (*v15)(void); // r6
  int v16; // r0
  int v17; // r5
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  char **v21; // r0
  int v22; // [sp+Ch] [bp-44h]
  char s[60]; // [sp+14h] [bp-3Ch] BYREF

  message((unsigned int *)a1, 70, 0, 0, a4);
  if ( !a4 )
  {
    v6 = api_add_data_full(0, "BMMiner", 1, "2.0.0", 0);
    v7 = api_add_data_full(v6, "Miner", 1, g_miner_version, 0);
    v8 = api_add_data_full(v7, "CompileTime", 1, g_miner_compiletime, 0);
    v9 = (char **)api_add_data_full(v8, "Type", 1, g_miner_type, 0);
    result = print_data((unsigned int *)a1, v9, 0, 0);
    if ( total_devices <= 0 )
      return result;
    v22 = 0;
    goto LABEL_5;
  }
  v17 = io_add((unsigned int *)a1, ",\"STATS\":[");
  v18 = api_add_data_full(0, "BMMiner", 1, "2.0.0", 0);
  v19 = api_add_data_full(v18, "Miner", 1, g_miner_version, 0);
  v20 = api_add_data_full(v19, "CompileTime", 1, g_miner_compiletime, 0);
  v21 = (char **)api_add_data_full(v20, "Type", 1, g_miner_type, 0);
  result = print_data((unsigned int *)a1, v21, 1, 0);
  v22 = v17;
  if ( total_devices > 0 )
  {
LABEL_5:
    v11 = 0;
    v12 = 0;
    do
    {
      result = get_devices(v11);
      v13 = result;
      if ( result )
      {
        v14 = *(_DWORD *)(result + 4);
        if ( v14 )
        {
          v15 = *(int (**)(void))(v14 + 28);
          if ( v15 )
          {
            v16 = v15();
            v14 = *(_DWORD *)(v13 + 4);
            v15 = (int (*)(void))v16;
          }
          sprintf(s, "%s%d", *(const char **)(v14 + 8), *(_DWORD *)(v13 + 8));
          result = itemstats_isra_17((unsigned int *)a1, v12, s, (const char *)(v13 + 292), (int)v15, a4);
          v12 = result;
        }
      }
      ++v11;
    }
    while ( total_devices > v11 );
  }
  if ( v22 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 80DCD8: using guessed type int total_devices;

//----- (00018EF0) --------------------------------------------------------
_DWORD *__fastcall api_add_escape(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 0, a3, a4);
}

//----- (00018F04) --------------------------------------------------------
_DWORD *__fastcall api_add_string(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 1, a3, a4);
}

//----- (00018F18) --------------------------------------------------------
_DWORD *__fastcall api_add_const(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 2, a3, a4);
}

//----- (00018F2C) --------------------------------------------------------
_DWORD *__fastcall api_add_uint8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 3, a3, a4);
}

//----- (00018F40) --------------------------------------------------------
_DWORD *__fastcall api_add_int16(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 4, a3, a4);
}

//----- (00018F54) --------------------------------------------------------
_DWORD *__fastcall api_add_uint16(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 5, a3, a4);
}

//----- (00018F68) --------------------------------------------------------
_DWORD *__fastcall api_add_int(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 6, a3, a4);
}

//----- (00018F7C) --------------------------------------------------------
_DWORD *__fastcall api_add_uint(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 7, a3, a4);
}

//----- (00018F90) --------------------------------------------------------
_DWORD *__fastcall api_add_uint32(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 8, a3, a4);
}

//----- (00018FA4) --------------------------------------------------------
_DWORD *__fastcall api_add_hex32(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 9, a3, a4);
}

//----- (00018FB8) --------------------------------------------------------
_DWORD *__fastcall api_add_uint64(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 10, a3, a4);
}

//----- (00018FCC) --------------------------------------------------------
_DWORD *__fastcall api_add_int64(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 11, a3, a4);
}

//----- (00018FE0) --------------------------------------------------------
_DWORD *__fastcall api_add_double(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 12, a3, a4);
}

//----- (00018FF4) --------------------------------------------------------
_DWORD *__fastcall api_add_elapsed(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 13, a3, a4);
}

//----- (00019008) --------------------------------------------------------
_DWORD *__fastcall api_add_bool(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 14, a3, a4);
}

//----- (0001901C) --------------------------------------------------------
_DWORD *__fastcall api_add_timeval(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 15, a3, a4);
}

//----- (00019030) --------------------------------------------------------
_DWORD *__fastcall api_add_time(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 16, a3, a4);
}

//----- (00019044) --------------------------------------------------------
_DWORD *__fastcall api_add_mhs(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 17, a3, a4);
}

//----- (00019058) --------------------------------------------------------
_DWORD *__fastcall api_add_mhtotal(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 18, a3, a4);
}

//----- (0001906C) --------------------------------------------------------
_DWORD *__fastcall api_add_temp(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 19, a3, a4);
}

//----- (00019080) --------------------------------------------------------
_DWORD *__fastcall api_add_utility(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 20, a3, a4);
}

//----- (00019094) --------------------------------------------------------
_DWORD *__fastcall api_add_freq(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 21, a3, a4);
}

//----- (000190A8) --------------------------------------------------------
_DWORD *__fastcall api_add_volts(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 22, a3, a4);
}

//----- (000190BC) --------------------------------------------------------
_DWORD *__fastcall api_add_hs(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 23, a3, a4);
}

//----- (000190D0) --------------------------------------------------------
_DWORD *__fastcall api_add_diff(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 24, a3, a4);
}

//----- (000190E4) --------------------------------------------------------
_DWORD *__fastcall api_add_percent(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 25, a3, a4);
}

//----- (000190F8) --------------------------------------------------------
_DWORD *__fastcall api_add_avg(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return api_add_data_full(a1, a2, 26, a3, a4);
}

//----- (0001910C) --------------------------------------------------------
void getAVGhashrate()
{
  ;
}

//----- (00019160) --------------------------------------------------------
void __fastcall summary_stub(_DWORD **a1)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r0
  _DWORD *v4; // r0
  _DWORD *v5; // r0
  _DWORD *v6; // r0
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  int v29; // [sp+8h] [bp-848h] BYREF
  int v30; // [sp+Ch] [bp-844h] BYREF
  double v31; // [sp+10h] [bp-840h] BYREF
  int v32; // [sp+18h] [bp-838h] BYREF
  int v33; // [sp+1Ch] [bp-834h]
  __int64 v34; // [sp+20h] [bp-830h] BYREF
  char s[2088]; // [sp+28h] [bp-828h] BYREF

  v2 = *a1;
  v32 = 0;
  v33 = 0;
  v34 = 0LL;
  v29 = 0;
  v30 = 0;
  v3 = api_add_data_full(v2, "Elapsed", 13, (const char *)&total_secs, 1);
  *a1 = v3;
  v4 = api_add_data_full(v3, "GHS 5s", 1, "14189.74", 0);
  *a1 = v4;
  v31 = 14274.51;
  v5 = api_add_data_full(v4, "GHS av", 17, (const char *)&v31, 1);
  *a1 = v5;
  v6 = api_add_data_full(v5, "Found Blocks", 7, (const char *)&v29, 1);
  *a1 = v6;
  v32 = 20;
  v33 = 0;
  v7 = api_add_data_full(v6, "Getworks", 11, (const char *)&v32, 1);
  *a1 = v7;
  v32 = 82;
  v33 = 0;
  v8 = api_add_data_full(v7, "Accepted", 11, (const char *)&v32, 1);
  *a1 = v8;
  v32 = 0;
  v33 = 0;
  v9 = api_add_data_full(v8, "Rejected", 11, (const char *)&v32, 1);
  *a1 = v9;
  v10 = api_add_data_full(v9, "Hardware Errors", 6, (const char *)&v30, 1);
  *a1 = v10;
  v31 = 5.91;
  v11 = api_add_data_full(v10, "Utility", 20, (const char *)&v31, 0);
  *a1 = v11;
  v32 = 0;
  v33 = 0;
  v12 = api_add_data_full(v11, "Discarded", 11, (const char *)&v32, 1);
  *a1 = v12;
  v32 = 0;
  v33 = 0;
  v13 = api_add_data_full(v12, "Stale", 11, (const char *)&v32, 1);
  *a1 = v13;
  v14 = api_add_data_full(v13, "Get Failures", 7, (const char *)&v29, 1);
  *a1 = v14;
  v15 = api_add_data_full(v14, "Local Work", 7, (const char *)&local_work, 1);
  *a1 = v15;
  v16 = api_add_data_full(v15, "Remote Failures", 7, (const char *)&v29, 1);
  *a1 = v16;
  v17 = api_add_data_full(v16, "Network Blocks", 7, (const char *)&new_blocks, 1);
  *a1 = v17;
  v18 = api_add_data_full(v17, "Total MH", 18, total_mhashes_done, 1);
  *a1 = v18;
  v31 = 0.0;
  v19 = api_add_data_full(v18, "Work Utility", 20, (const char *)&v31, 0);
  *a1 = v19;
  v31 = 1343488.0;
  v20 = api_add_data_full(v19, "Difficulty Accepted", 24, (const char *)&v31, 1);
  *a1 = v20;
  v31 = 16384.0;
  v21 = api_add_data_full(v20, "Difficulty Rejected", 24, (const char *)&v31, 1);
  *a1 = v21;
  v22 = api_add_data_full(v21, "Difficulty Stale", 24, total_diff_stale, 1);
  *a1 = v22;
  v34 = 3432989LL;
  v23 = api_add_data_full(v22, "Best Share", 10, (const char *)&v34, 1);
  *a1 = v23;
  v31 = 0.0;
  v24 = api_add_data_full(v23, "Device Hardware%", 25, (const char *)&v31, 0);
  *a1 = v24;
  v25 = api_add_data_full(v24, "Device Rejected%", 25, (const char *)&v31, 0);
  *a1 = v25;
  v26 = api_add_data_full(v25, "Pool Rejected%", 25, (const char *)&v31, 0);
  *a1 = v26;
  v27 = api_add_data_full(v26, "Pool Stale%", 25, (const char *)&v31, 0);
  *a1 = v27;
  v28 = api_add_data_full(v27, "Last getwork", 16, (const char *)&last_getwork, 0);
  *a1 = v28;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(s, 2048u, "root %d", v28);
    applog(5, s, 0);
  }
}
// 7DEC8: using guessed type double total_secs;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CBBC: using guessed type int last_getwork;
// 80CC18: using guessed type char use_syslog;
// 80EDF0: using guessed type int new_blocks;
// 80EEF0: using guessed type int local_work;

//----- (000194B0) --------------------------------------------------------
int __fastcall summary(int a1, int a2, int a3, int a4)
{
  char *v6; // r1
  int result; // r0
  double v8; // d4
  double v9; // d7
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  char **v29; // r0
  __int64 v30; // kr08_8
  double v31; // d7
  char **v32; // r4
  double v33; // d7
  char **v34; // r0
  double v35; // d7
  double v36; // d5
  char **v37; // r0
  double v38; // d7
  double v39; // d5
  _DWORD *v40; // r0
  int v41; // [sp+8h] [bp-88h]
  __int64 v42; // [sp+10h] [bp-80h]
  char **v43; // [sp+1Ch] [bp-74h] BYREF
  double v44; // [sp+20h] [bp-70h] BYREF
  double v45; // [sp+28h] [bp-68h] BYREF
  double v46; // [sp+30h] [bp-60h] BYREF
  double v47; // [sp+38h] [bp-58h] BYREF
  double v48; // [sp+40h] [bp-50h] BYREF
  double v49; // [sp+48h] [bp-48h] BYREF
  double v50; // [sp+50h] [bp-40h] BYREF
  double v51; // [sp+58h] [bp-38h] BYREF

  v43 = 0;
  message((unsigned int *)a1, 11, 0, 0, a4);
  v6 = ",\"SUMMARY\":[";
  if ( !a4 )
    v6 = "SUMMARY,";
  v41 = io_add((unsigned int *)a1, v6);
  if ( is_certification )
  {
    summary_stub(&v43);
  }
  else
  {
    if ( pthread_mutex_lock(&hash_lock) )
      mutex_lock_part_3_constprop_27("summary", 2866);
    *(_QWORD *)&total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + *(double *)total_diff_stale);
    v42 = (__int64)(total_diff_accepted + total_diff_rejected + *(double *)total_diff_stale);
    v8 = (double)*(__int64 *)&total_accepted;
    if ( total_secs == 0.0 )
    {
      v44 = v8 * 60.0;
      v45 = (*(double *)total_mhashes_done - new_total_mhashes_done) / 1000.0 / (total_secs - new_total_secs);
      v9 = 1.0;
    }
    else
    {
      v44 = v8 / total_secs * 60.0;
      v45 = (*(double *)total_mhashes_done - new_total_mhashes_done) / 1000.0 / (total_secs - new_total_secs);
      v9 = total_secs;
    }
    v47 = (double)mined_time_record + total_secs;
    v46 = (double)v42 / v9 * 60.0;
    v10 = api_add_data_full(v43, "Elapsed", 13, (const char *)&v47, 1);
    v11 = api_add_data_full(v10, "GHS 5s", 1, displayed_hash_rate, 0);
    v12 = api_add_data_full(v11, "GHS av", 17, (const char *)&v45, 0);
    v13 = api_add_data_full(v12, "Found Blocks", 7, (const char *)&found_blocks, 1);
    v14 = api_add_data_full(v13, "Getworks", 11, (const char *)&total_getworks, 1);
    v15 = api_add_data_full(v14, "Accepted", 11, (const char *)&total_accepted, 1);
    v16 = api_add_data_full(v15, "Rejected", 11, (const char *)&total_rejected, 1);
    v17 = api_add_data_full(v16, "Hardware Errors", 6, (const char *)&hw_errors, 1);
    v18 = api_add_data_full(v17, "Utility", 20, (const char *)&v44, 0);
    v19 = api_add_data_full(v18, "Discarded", 11, (const char *)&total_discarded, 1);
    v20 = api_add_data_full(v19, "Stale", 11, (const char *)&total_stale, 1);
    v21 = api_add_data_full(v20, "Get Failures", 7, (const char *)&total_go, 1);
    v22 = api_add_data_full(v21, "Local Work", 7, (const char *)&local_work, 1);
    v23 = api_add_data_full(v22, "Remote Failures", 7, (const char *)&total_ro, 1);
    v24 = api_add_data_full(v23, "Network Blocks", 7, (const char *)&new_blocks, 1);
    v25 = api_add_data_full(v24, "Total MH", 18, total_mhashes_done, 1);
    v26 = api_add_data_full(v25, "Work Utility", 20, (const char *)&v46, 0);
    v27 = api_add_data_full(v26, "Difficulty Accepted", 24, (const char *)&total_diff_accepted, 1);
    v28 = api_add_data_full(v27, "Difficulty Rejected", 24, (const char *)&total_diff_rejected, 1);
    v43 = (char **)api_add_data_full(v28, "Difficulty Stale", 24, total_diff_stale, 1);
    v29 = (char **)api_add_data_full(v43, "Best Share", 10, (const char *)&best_diff, 1);
    v43 = v29;
    v30 = *(_QWORD *)&total_diff1 + hw_errors;
    if ( v30 )
      v31 = (double)hw_errors / (double)v30;
    else
      v31 = 0.0;
    v48 = v31;
    v32 = (char **)api_add_data_full(v29, "Device Hardware%", 25, (const char *)&v48, 0);
    v43 = v32;
    if ( *(_QWORD *)&total_diff1 )
      v33 = total_diff_rejected / (double)*(__int64 *)&total_diff1;
    else
      v33 = 0.0;
    v49 = v33;
    v34 = (char **)api_add_data_full(v32, "Device Rejected%", 25, (const char *)&v49, 0);
    v43 = v34;
    v35 = total_diff_rejected + total_diff_accepted + *(double *)total_diff_stale;
    if ( v35 == 0.0 )
      v36 = 0.0;
    else
      v36 = total_diff_rejected / v35;
    v50 = v36;
    v37 = (char **)api_add_data_full(v34, "Pool Rejected%", 25, (const char *)&v50, 0);
    v43 = v37;
    v38 = total_diff_accepted + total_diff_rejected + *(double *)total_diff_stale;
    if ( v38 == 0.0 )
      v39 = 0.0;
    else
      v39 = *(double *)total_diff_stale / v38;
    v51 = v39;
    v40 = api_add_data_full(v37, "Pool Stale%", 25, (const char *)&v51, 0);
    v43 = (char **)api_add_data_full(v40, "Last getwork", 16, (const char *)&last_getwork, 0);
    if ( pthread_mutex_unlock(&hash_lock) )
      mutex_unlock_noyield_part_5_constprop_32("summary", 2917);
    selective_yield(0);
  }
  result = print_data((unsigned int *)a1, v43, a4, 0);
  if ( (a4 & v41) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7DEC8: using guessed type double total_secs;
// 7DEE0: using guessed type double new_total_secs;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80F88: using guessed type int best_diff;
// 806028: using guessed type char is_certification;
// 80BA38: using guessed type int total_stale;
// 80BA88: using guessed type int hw_errors;
// 80BA90: using guessed type double total_diff_accepted;
// 80BAA0: using guessed type int total_discarded;
// 80BAB0: using guessed type double total_diff_rejected;
// 80BB7C: using guessed type int found_blocks;
// 80CBB0: using guessed type int total_ro;
// 80CBBC: using guessed type int last_getwork;
// 80DCE8: using guessed type int total_go;
// 80DCF0: using guessed type int total_accepted;
// 80DD00: using guessed type int total_getworks;
// 80EDF0: using guessed type int new_blocks;
// 80EEF0: using guessed type int local_work;
// 80EEF8: using guessed type __int64 total_rejected;
// 80EF48: using guessed type pthread_mutex_t hash_lock;
// 80EF60: using guessed type int total_diff1;

//----- (00019A40) --------------------------------------------------------
int __fastcall notifystatus(unsigned int *a1, int a2, int a3, int a4)
{
  int v5; // r2
  const char *v6; // r7
  int v8; // r6
  unsigned int v9; // r2
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  char **v25; // r0
  int v26; // r3
  int v28; // [sp+Ch] [bp-1Ch] BYREF

  v5 = *(_DWORD *)(a3 + 244);
  v6 = "None";
  v8 = a4;
  v28 = a2;
  if ( v5 )
  {
    v9 = *(_DWORD *)(a3 + 248);
    if ( v9 > 8 )
      v6 = (const char *)(unsigned __int16)"Unknown reason - code bug";
    else
      a4 = (unsigned __int16)"escape_string";
    if ( v9 > 8 )
      HIWORD(v6) = (unsigned int)"Unknown reason - code bug" >> 16;
    else
      HIWORD(a4) = (unsigned int)"escape_string" >> 16;
    if ( v9 <= 8 )
      v6 = *(const char **)(a4 + 4 * v9 + 112);
  }
  v10 = api_add_data_full(0, "NOTIFY", 6, (const char *)&v28, 0);
  v11 = api_add_data_full(v10, "Name", 1, *(const char **)(*(_DWORD *)(a3 + 4) + 8), 0);
  v12 = api_add_data_full(v11, "ID", 6, (const char *)(a3 + 8), 0);
  v13 = api_add_data_full(v12, "Last Well", 16, (const char *)(a3 + 240), 0);
  v14 = api_add_data_full(v13, "Last Not Well", 16, (const char *)(a3 + 244), 0);
  v15 = api_add_data_full(v14, "Reason Not Well", 1, v6, 0);
  v16 = api_add_data_full(v15, "*Thread Fail Init", 6, (const char *)(a3 + 252), 0);
  v17 = api_add_data_full(v16, "*Thread Zero Hash", 6, (const char *)(a3 + 256), 0);
  v18 = api_add_data_full(v17, "*Thread Fail Queue", 6, (const char *)(a3 + 260), 0);
  v19 = api_add_data_full(v18, "*Dev Sick Idle 60s", 6, (const char *)(a3 + 264), 0);
  v20 = api_add_data_full(v19, "*Dev Dead Idle 600s", 6, (const char *)(a3 + 268), 0);
  v21 = api_add_data_full(v20, "*Dev Nostart", 6, (const char *)(a3 + 272), 0);
  v22 = api_add_data_full(v21, "*Dev Over Heat", 6, (const char *)(a3 + 276), 0);
  v23 = api_add_data_full(v22, "*Dev Thermal Cutoff", 6, (const char *)(a3 + 280), 0);
  v24 = api_add_data_full(v23, "*Dev Comms Error", 6, (const char *)(a3 + 284), 0);
  v25 = (char **)api_add_data_full(v24, "*Dev Throttle", 6, (const char *)(a3 + 288), 0);
  v26 = v8;
  if ( v8 )
    v26 = v28 > 0;
  return print_data(a1, v25, v8, v26);
}

//----- (00019BDC) --------------------------------------------------------
int __fastcall notify(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r9
  int v8; // r4
  int devices; // r0
  int v10; // r1

  if ( !total_devices )
    return message((unsigned int *)a1, 10, total_devices, total_devices, a4);
  result = message((unsigned int *)a1, 60, 0, 0, a4);
  if ( !a4 )
  {
    if ( total_devices <= 0 )
      return result;
    v7 = 0;
    goto LABEL_6;
  }
  result = io_add((unsigned int *)a1, ",\"NOTIFY\":[");
  v7 = result;
  if ( total_devices > 0 )
  {
LABEL_6:
    v8 = 0;
    do
    {
      devices = get_devices(v8);
      v10 = v8++;
      result = notifystatus((unsigned int *)a1, v10, devices, a4);
    }
    while ( total_devices > v8 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 80DCD8: using guessed type int total_devices;

//----- (00019C68) --------------------------------------------------------
int mcast_init()
{
  void *v0; // r0
  int result; // r0
  char v2[2064]; // [sp+0h] [bp-810h] BYREF

  v0 = calloc(1u, 64u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc mcast thr");
    applog(3, v2, 1);
    quit(1);
  }
  result = thr_info_create((int)v0, 0, mcast_thread, v0);
  if ( result )
  {
    strcpy(v2, "API mcast thread create failed");
    applog(3, v2, 1);
    quit(1);
  }
  return result;
}

//----- (00019CF0) --------------------------------------------------------
__int64 reCalculateAVG()
{
  __int64 result; // r0

  result = total_mhashes_done;
  new_total_mhashes_done = total_mhashes_done;
  if ( total_secs <= 0.0 )
    new_total_secs = total_secs;
  else
    new_total_secs = total_secs - 1.0;
  return result;
}
// 7DEC8: using guessed type double total_secs;
// 7DEE0: using guessed type double new_total_secs;

//----- (00019D44) --------------------------------------------------------
void api()
{
  double v0; // d0
  int v1; // r3
  _DWORD *v2; // r4
  _BYTE *v3; // r0
  _DWORD *v4; // r0
  int v5; // r2
  int v6; // r3
  const char *v7; // r6
  size_t v8; // r0
  unsigned __int8 *v9; // r4
  char *v10; // r0
  char *v11; // r0
  const __int32_t **v12; // r0
  const __int32_t *v13; // r2
  int v14; // r9
  __int32_t v15; // r1
  unsigned __int8 *v16; // r6
  char *v17; // r0
  char *v18; // r7
  int v19; // r4
  void **v20; // r8
  const char *v21; // r5
  const char *v22; // t1
  const char *v23; // r4
  size_t v24; // r0
  char *v25; // r3
  const char *v26; // r2
  void **v27; // r4
  char *v28; // r6
  const char *v29; // t1
  const char *v30; // r7
  size_t v31; // r0
  char *v32; // r3
  const char *v33; // t1
  int v34; // r5
  size_t v35; // r0
  char *v36; // r0
  const __int32_t **v37; // r0
  const char *v38; // r5
  const __int32_t **v39; // r11
  void **v40; // r4
  char *v41; // r8
  const char *v42; // t1
  size_t v43; // r0
  const char *v44; // t1
  size_t v45; // r3
  char *v46; // r0
  const __int32_t *v47; // r2
  __int32_t v48; // r3
  int v49; // r4
  size_t v50; // r0
  char *v51; // r0
  const char *v52; // r4
  size_t v53; // r0
  char *v54; // r2
  size_t v55; // r0
  int v56; // r3
  int v57; // t1
  char *v58; // r6
  int v59; // r7
  int v60; // r3
  bool v61; // zf
  char *v62; // r5
  int v63; // t1
  bool v64; // zf
  char *v65; // r0
  const unsigned __int16 **v66; // r0
  int v67; // r1
  const __int32_t *v68; // r3
  char v69; // r2
  _BYTE *v70; // r4
  int v71; // r10
  char *v72; // r0
  int v73; // r10
  _BYTE *v74; // r3
  _BYTE *v75; // r3
  _BYTE *v76; // r0
  _BYTE *v77; // r4
  char v78; // t1
  _BYTE *v79; // r3
  _BYTE *v80; // r1
  _BYTE *v81; // r3
  __int32_t v82; // r1
  int v83; // r0
  int v84; // r2
  int v85; // r0
  _BYTE *v86; // r1
  int v87; // r2
  int i; // lr
  bool v89; // cf
  struct addrinfo *v90; // r4
  struct addrinfo *j; // r3
  int v92; // r0
  time_t v93; // r10
  int v94; // r8
  void *v95; // r4
  int v96; // r0
  int v97; // r4
  const char *v98; // r1
  ssize_t v99; // r0
  int v100; // r4
  int v101; // r3
  int v102; // r6
  const char *v103; // r5
  time_t v104; // r0
  _BYTE *v105; // r3
  int v106; // r3
  char *v107; // r0
  char *v108; // r9
  int v109; // r8
  size_t v110; // r0
  const char *v111; // r2
  const char *v112; // r11
  int v113; // r5
  const char *v114; // r8
  char *v115; // r0
  int v116; // r3
  const char *v117; // r1
  void **v118; // r9
  int v119; // r4
  const char *v120; // t1
  int v121; // r6
  int *v122; // r0
  char *v123; // r0
  size_t v124; // r0
  int *v125; // r3
  int v126; // r11
  __int32_t v127; // r3
  int *v128; // r0
  char *v129; // r6
  int *v130; // r0
  int *v131; // r0
  char *v132; // r0
  int *v133; // r0
  char *v134; // r0
  int *v135; // r0
  char *v136; // r0
  int v137; // r3
  int v138; // r3
  _DWORD *v139; // r0
  _DWORD *v140; // r4
  int v141; // r3
  int v142; // r1
  _DWORD *v143; // r0
  char *v144; // r0
  int v145; // r3
  int v146; // r0
  int *v147; // r0
  char *v148; // r0
  const char *v149; // r3
  int v150; // [sp+10h] [bp-16490h]
  unsigned __int8 *v151; // [sp+18h] [bp-16488h]
  const __int32_t **v152; // [sp+1Ch] [bp-16484h]
  char *v153; // [sp+20h] [bp-16480h]
  _DWORD *ptr; // [sp+24h] [bp-1647Ch]
  _DWORD *v155; // [sp+28h] [bp-16478h]
  int fd; // [sp+34h] [bp-1646Ch]
  __int16 v157; // [sp+3Ch] [bp-16464h]
  char *haystack; // [sp+40h] [bp-16460h]
  char *v159; // [sp+50h] [bp-16450h]
  char *dest; // [sp+54h] [bp-1644Ch]
  int v161; // [sp+64h] [bp-1643Ch]
  const __int32_t **v162; // [sp+6Ch] [bp-16434h]
  char *v163; // [sp+70h] [bp-16430h]
  unsigned __int8 v164; // [sp+7Eh] [bp-16422h] BYREF
  char v165; // [sp+7Fh] [bp-16421h] BYREF
  void *v166; // [sp+80h] [bp-16420h] BYREF
  socklen_t addr_len; // [sp+84h] [bp-1641Ch] BYREF
  struct addrinfo *ai; // [sp+88h] [bp-16418h] BYREF
  int optval; // [sp+8Ch] [bp-16414h] BYREF
  char service[12]; // [sp+90h] [bp-16410h] BYREF
  char cp[32]; // [sp+9Ch] [bp-16404h] BYREF
  struct addrinfo req; // [sp+BCh] [bp-163E4h] BYREF
  char v173[12]; // [sp+DCh] [bp-163C4h] BYREF
  pthread_t th; // [sp+E8h] [bp-163B8h]
  char v175[100]; // [sp+11Ch] [bp-16384h] BYREF
  char needle[100]; // [sp+180h] [bp-16320h] BYREF
  struct sockaddr addr; // [sp+1E4h] [bp-162BCh] BYREF
  char v178[20]; // [sp+264h] [bp-1623Ch] BYREF
  struct __jmp_buf_tag env; // [sp+360h] [bp-16140h] BYREF
  char s[2048]; // [sp+478h] [bp-16028h] BYREF
  char v181[2024]; // [sp+C78h] [bp-15828h] BYREF
  char v182[2024]; // [sp+1478h] [bp-15028h] BYREF
  char v183[1992]; // [sp+1C78h] [bp-14828h] BYREF
  char v184[1992]; // [sp+2478h] [bp-14028h] BYREF
  char v185[1992]; // [sp+2C78h] [bp-13828h] BYREF
  char v186[1992]; // [sp+3478h] [bp-13028h] BYREF
  char v187[1928]; // [sp+3C78h] [bp-12828h] BYREF
  char v188[1928]; // [sp+4478h] [bp-12028h] BYREF
  char v189[1928]; // [sp+4C78h] [bp-11828h] BYREF
  char v190[1928]; // [sp+5478h] [bp-11028h] BYREF
  char v191[1928]; // [sp+5C78h] [bp-10828h] BYREF
  char v192[1928]; // [sp+6478h] [bp-10028h] BYREF
  char v193[1928]; // [sp+6C78h] [bp-F828h] BYREF
  char v194[1928]; // [sp+7478h] [bp-F028h] BYREF
  char v195[1928]; // [sp+7C78h] [bp-E828h] BYREF
  char v196[1928]; // [sp+8478h] [bp-E028h] BYREF
  char v197[1928]; // [sp+8C78h] [bp-D828h] BYREF
  char v198[1928]; // [sp+9478h] [bp-D028h] BYREF
  char v199[1928]; // [sp+9C78h] [bp-C828h] BYREF
  char v200[1928]; // [sp+A478h] [bp-C028h] BYREF
  char v201[1928]; // [sp+AC78h] [bp-B828h] BYREF
  char v202[1928]; // [sp+B478h] [bp-B028h] BYREF
  char v203[1928]; // [sp+BC78h] [bp-A828h] BYREF
  char v204[1928]; // [sp+C478h] [bp-A028h] BYREF
  char v205[1928]; // [sp+CC78h] [bp-9828h] BYREF
  char v206[1928]; // [sp+D478h] [bp-9028h] BYREF
  char v207[1928]; // [sp+DC78h] [bp-8828h] BYREF
  char v208[1928]; // [sp+E478h] [bp-8028h] BYREF
  char v209[1928]; // [sp+EC78h] [bp-7828h] BYREF
  char v210[1928]; // [sp+F478h] [bp-7028h] BYREF
  char v211[1928]; // [sp+FC78h] [bp-6828h] BYREF
  char v212[8072]; // [sp+10478h] [bp-6028h] BYREF
  char v213[8072]; // [sp+12478h] [bp-4028h] BYREF
  __int16 v214[4116]; // [sp+14478h] [bp-2028h] BYREF

  v166 = 0;
  v155 = 0;
  v157 = opt_api_port;
  ptr = malloc(4u);
  v1 = (unsigned __int8)opt_api_listen;
  *ptr = -1;
  if ( !v1 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "API not running%s", " - API will not be available");
      applog(7, s, 0);
    }
LABEL_6:
    free(ptr);
    return;
  }
  v2 = malloc(16u);
  v3 = malloc(65536u);
  v2[1] = v3;
  v2[2] = v3;
  *v3 = 0;
  *((_BYTE *)v2 + 12) = 1;
  *((_BYTE *)v2 + 13) = 0;
  *v2 = 65536;
  v4 = malloc(12u);
  *v4 = v2;
  v5 = io_head;
  if ( io_head )
  {
    v6 = *(_DWORD *)(io_head + 4);
    v4[2] = io_head;
    v4[1] = v6;
    *(_DWORD *)(v5 + 4) = v4;
    *(_DWORD *)(v4[1] + 8) = v4;
  }
  else
  {
    v4[1] = v4;
    v4[2] = v4;
    io_head = (int)v4;
  }
  v161 = (int)v2;
  if ( pthread_mutex_init(&quit_restart_lock, 0) )
  {
    v130 = _errno_location();
    snprintf(v200, 2048u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v130, "api.c", "api", 5393);
    applog(3, v200, 1);
    quit(1);
  }
  if ( _sigsetjmp(&env, 0) )
  {
    tidyup(ptr);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&env);
    goto LABEL_247;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&env);
  v7 = (const char *)opt_api_groups;
  if ( opt_api_groups )
  {
    v8 = strlen((const char *)opt_api_groups) + 1;
  }
  else
  {
    v7 = "";
    v8 = 1;
  }
  dest = (char *)malloc(v8);
  if ( !dest )
  {
    strcpy(v201, "Failed to malloc ipgroups buf");
    applog(3, v201, 1);
    quit(1);
  }
  v9 = (unsigned __int8 *)dest;
  strcpy(dest, v7);
  if ( !*dest )
    goto LABEL_55;
  do
  {
    v10 = strchr((const char *)v9, 44);
    if ( v10 )
    {
      v151 = (unsigned __int8 *)(v10 + 1);
      *v10 = 0;
    }
    else
    {
      v151 = 0;
    }
    if ( v9[1] != 58 )
    {
      v11 = strchr((const char *)v9, 58);
      if ( v11 )
        *v11 = 0;
      snprintf(v202, 2048u, "API invalid group name '%s'", v9);
      applog(3, v202, 1);
      quit(1);
    }
    v12 = _ctype_toupper_loc();
    v13 = *v12;
    v152 = v12;
    v14 = LOBYTE((*v12)[*v9]);
    v15 = (*v12)[v14];
    if ( v15 < (*v12)[65] || v15 > v13[90] )
    {
      snprintf(v203, 2048u, "API invalid group name '%c'");
      applog(3, v203, 1);
      quit(1);
    }
    if ( v14 == v13[87] )
    {
      snprintf(v204, 2048u, "API group name can't be '%c'", v14);
      applog(3, v204, 1);
      quit(1);
    }
    if ( v14 == v13[82] )
    {
      snprintf(v205, 2048u, "API group name can't be '%c'", v14);
      applog(3, v205, 1);
      quit(1);
    }
    if ( *((_DWORD *)&apigroups + v13[v14] - v13[65]) )
    {
      snprintf(v206, 2048u, "API duplicate group name '%c'", *v9);
      applog(3, v206, 1);
      quit(1);
    }
    v16 = v9 + 2;
    v214[0] = 124;
    if ( v9 == (unsigned __int8 *)-2 || !v9[2] )
      goto LABEL_52;
    v150 = 0;
    v153 = (char *)v214 + 1;
    while ( 1 )
    {
      v17 = strchr((const char *)v16, 58);
      v18 = v17;
      if ( v17 )
      {
        v18 = v17 + 1;
        *v17 = 0;
      }
      if ( *v16 == 42 && !v16[1] )
      {
        v150 = 1;
        goto LABEL_36;
      }
      if ( !cmds )
      {
LABEL_101:
        snprintf(v207, 2048u, "API unknown command '%s' in group '%c'", v16, v14);
        applog(3, v207, 1);
        quit(1);
      }
      v19 = 0;
      v20 = &cmds;
      v21 = (const char *)cmds;
      while ( strcasecmp((const char *)v16, v21) )
      {
        v22 = (const char *)v20[3];
        v20 += 3;
        v21 = v22;
        ++v19;
        if ( !v22 )
          goto LABEL_101;
      }
      sprintf(needle, "|%s|", v21);
      if ( !strstr((const char *)v214, needle) )
        break;
LABEL_36:
      if ( !v18 )
        goto LABEL_45;
LABEL_37:
      if ( !*v18 )
        goto LABEL_45;
      v16 = (unsigned __int8 *)v18;
    }
    v23 = (const char *)codes[3 * v19 + 272];
    strcpy(v153, v23);
    v24 = strlen(v23);
    v25 = &v153[v24];
    v25[1] = 0;
    v153 += v24 + 1;
    *v25 = 124;
    if ( v18 )
      goto LABEL_37;
LABEL_45:
    if ( v150 )
    {
      v26 = (const char *)cmds;
      if ( cmds )
      {
        v27 = &cmds;
        v28 = v153;
        do
        {
          while ( 1 )
          {
            if ( !*((_BYTE *)v27 + 8) )
            {
              sprintf(needle, "|%s|", v26);
              if ( !strstr((const char *)v214, needle) )
                break;
            }
            v29 = (const char *)v27[3];
            v27 += 3;
            v26 = v29;
            if ( !v29 )
              goto LABEL_52;
          }
          v30 = (const char *)*v27;
          strcpy(v28, (const char *)*v27);
          v31 = strlen(v30);
          v32 = &v28[v31];
          v28 += v31 + 1;
          *v32 = 124;
          v33 = (const char *)v27[3];
          v27 += 3;
          v26 = v33;
          v32[1] = 0;
        }
        while ( v33 );
      }
    }
LABEL_52:
    v34 = (*v152)[v14] - (*v152)[65];
    v35 = strlen((const char *)v214);
    v36 = (char *)malloc(v35 + 1);
    *((_DWORD *)&apigroups + v34) = v36;
    if ( !v36 )
    {
      strcpy(v208, "Failed to malloc group commands buf");
      applog(3, v208, 1);
      quit(1);
    }
    strcpy(v36, (const char *)v214);
    if ( !v151 )
      break;
    v9 = v151;
  }
  while ( *v151 );
LABEL_55:
  v37 = _ctype_toupper_loc();
  v38 = (const char *)cmds;
  v214[0] = 124;
  v39 = v37;
  v40 = &cmds;
  v41 = (char *)v214 + 1;
  if ( cmds )
  {
    do
    {
      while ( *((_BYTE *)v40 + 8) )
      {
        v42 = (const char *)v40[3];
        v40 += 3;
        v38 = v42;
        if ( !v42 )
          goto LABEL_60;
      }
      strcpy(v41, v38);
      v43 = strlen(v38);
      v44 = (const char *)v40[3];
      v40 += 3;
      v38 = v44;
      v45 = v43 + 1;
      v46 = &v41[v43];
      v41 += v45;
      *v46 = 124;
      v46[1] = 0;
    }
    while ( v44 );
  }
LABEL_60:
  v47 = *v39;
  v48 = (*v39)[82];
  if ( (unsigned int)(v48 + 128) < 384 )
    v48 = v47[v48];
  v49 = v48 - v47[65];
  v50 = strlen((const char *)v214);
  v51 = (char *)malloc(v50 + 1);
  *((_DWORD *)&apigroups + v49) = v51;
  if ( !v51 )
  {
LABEL_247:
    strcpy(v209, "Failed to malloc noprivgroup commands buf");
    applog(3, v209, 1);
    quit(1);
  }
  strcpy(v51, (const char *)v214);
  free(dest);
  v52 = (const char *)opt_api_allow;
  if ( !opt_api_allow )
    goto LABEL_141;
  v53 = strlen((const char *)opt_api_allow);
  v159 = (char *)malloc(v53 + 1);
  if ( !v159 )
  {
    strcpy(v210, "Failed to malloc ipaccess buf");
    applog(3, v210, 1);
    quit(1);
  }
  strcpy(v159, v52);
  v54 = v159 - 1;
  v55 = 1;
  while ( 1 )
  {
    v57 = (unsigned __int8)*++v54;
    v56 = v57;
    if ( !v57 )
      break;
    if ( v56 == 44 )
      ++v55;
  }
  ipaccess = (int)calloc(v55, 36u);
  if ( !ipaccess )
  {
    strcpy(v211, "Failed to calloc ipaccess");
    applog(3, v211, 1);
    quit(1);
  }
  v58 = v159;
  v59 = 0;
  ips = 0;
  while ( 2 )
  {
    v60 = (unsigned __int8)*v58;
    if ( *v58 )
    {
      v61 = v60 == 9;
      if ( v60 != 9 )
        v61 = v60 == 32;
      v62 = v58;
      if ( v61 )
      {
        do
        {
          v63 = (unsigned __int8)*++v62;
          v60 = v63;
          v64 = v63 == 9;
          if ( v63 != 9 )
            v64 = v60 == 32;
        }
        while ( v64 );
      }
      if ( v60 == 44 )
      {
        v58 = v62 + 1;
LABEL_95:
        if ( !v58 )
          break;
        continue;
      }
      v65 = strchr(v62, 44);
      v58 = v65;
      if ( v65 )
      {
        v58 = v65 + 1;
        *v65 = 0;
      }
      v66 = _ctype_b_loc();
      v67 = (unsigned __int8)*v62;
      v68 = *v39;
      v69 = *((_BYTE *)*v39 + 328);
      if ( ((*v66)[v67] & 0x400) != 0 && v62[1] == 58 )
      {
        v82 = v68[v67];
        if ( v82 == v68[87] || *((_DWORD *)&apigroups + v82 - v68[65]) )
          v69 = v82;
        v62 += 2;
      }
      v70 = (_BYTE *)(ipaccess + 36 * v59);
      v70[32] = v69;
      v71 = (unsigned __int8)*v62;
      if ( v71 != 48 )
      {
        v72 = strchr(v62, 47);
        if ( v72 )
          goto LABEL_87;
        goto LABEL_119;
      }
      if ( v62[1] == 47 && v62[2] == 48 && !v62[3] )
      {
        v79 = v70 - 1;
        v80 = v70 + 15;
        do
        {
          *++v79 = 0;
          *++v80 = 0;
        }
        while ( v70 + 15 != v79 );
        ips = ++v59;
LABEL_110:
        if ( !v58 )
          break;
        continue;
      }
      v72 = strchr(v62, 47);
      if ( v72 )
      {
LABEL_89:
        v73 = 0;
      }
      else
      {
LABEL_119:
        v81 = v70 + 15;
        do
          *++v81 = -1;
        while ( v81 != v70 + 31 );
        v71 = (unsigned __int8)*v62;
        v72 = &v62[strlen(v62)];
LABEL_87:
        if ( v71 != 91 || *(v72 - 1) != 93 )
          goto LABEL_89;
        v73 = 1;
        *v62++ = 0;
        *(v72 - 1) = 0;
      }
      if ( *v72 )
      {
        *v72 = 0;
        v83 = strtol(v72 + 1, 0, 10);
        if ( v83 <= 0 )
          goto LABEL_95;
        v84 = v73 ? 0 : 96;
        v85 = v83 + v84;
        if ( v85 > 128 )
          goto LABEL_95;
        v86 = v70 + 15;
        do
          *++v86 = 0;
        while ( v70 + 31 != v86 );
        v87 = 0;
        for ( i = 7; ; i = 7 )
        {
          v89 = v85-- != 0;
          if ( !v89 )
            break;
          while ( 1 )
          {
            v70[v87 + 16] |= 1 << i;
            if ( !i )
              break;
            v89 = v85-- != 0;
            --i;
            if ( !v89 )
              goto LABEL_91;
          }
          ++v87;
        }
      }
LABEL_91:
      v74 = v70 - 1;
      do
        *++v74 = 0;
      while ( v74 != v70 + 15 );
      if ( v73 )
      {
        if ( inet_pton(10, v62, v70) != 1 )
          goto LABEL_95;
      }
      else
      {
        sprintf(cp, "::ffff:%s", v62);
        v59 = ips;
        v70 = (_BYTE *)(ipaccess + 36 * ips);
        if ( inet_pton(10, cp, v70) != 1 )
          goto LABEL_95;
      }
      v75 = v70;
      v76 = v70 + 15;
      v77 = v70 + 16;
      do
      {
        v78 = *++v76;
        *v75++ &= v78;
      }
      while ( v75 != v77 );
      ips = ++v59;
      goto LABEL_110;
    }
    break;
  }
  free(v159);
  if ( !v59 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(v181, 2048u, "API not running (no valid IPs specified)%s", " - API will not be available");
      applog(4, v181, 0);
    }
    goto LABEL_6;
  }
LABEL_141:
  cgsleep_ms();
  sprintf(service, "%d", v157);
  memset(&req, 0, sizeof(req));
  req.ai_flags = 1;
  if ( getaddrinfo(opt_api_host, service, &req, &ai) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(v182, 2048u, "API failed to resolve %s", opt_api_host);
      applog(3, v182, 0);
    }
    goto LABEL_6;
  }
  v90 = ai;
  if ( ai )
  {
    for ( j = ai; ; j = ai )
    {
      v92 = socket(j->ai_family, 1, 0);
      *ptr = v92;
      if ( v92 > 0 )
        break;
      v90 = v90->ai_next;
      if ( !v90 )
        goto LABEL_212;
    }
  }
  else
  {
    v92 = *ptr;
LABEL_212:
    if ( v92 == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        v122 = _errno_location();
        v123 = strerror(*v122);
        snprintf(v183, 2048u, "API initialisation failed (%s)%s", v123, " - API will not be available");
        applog(3, v183, 0);
      }
      freeaddrinfo(ai);
      free(ptr);
      return;
    }
    v90 = 0;
  }
  optval = 1;
  if ( setsockopt(v92, 1, 2, &optval, 4u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v131 = _errno_location();
    v132 = strerror(*v131);
    snprintf(v184, 2048u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v132);
    applog(7, v184, 0);
  }
  v93 = time(0);
  while ( bind(*ptr, v90->ai_addr, v90->ai_addrlen) < 0 )
  {
    v128 = _errno_location();
    v129 = strerror(*v128);
    if ( time(0) - v93 > 61 )
    {
      freeaddrinfo(ai);
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v186, 2048u, "API bind to port %d failed (%s)%s", v157, v129, " - API will not be available");
        applog(3, v186, 0);
      }
      goto LABEL_6;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(v185, 2048u, "API bind to port %d failed - trying again in 30sec", v157);
      applog(4, v185, 0);
    }
    cgsleep_ms();
  }
  freeaddrinfo(ai);
  if ( listen(*ptr, 100) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v135 = _errno_location();
      v136 = strerror(*v135);
      snprintf(v187, 2048u, "API3 initialisation failed (%s)%s", v136, " - API will not be available");
      applog(3, v187, 0);
    }
    close(*ptr);
    free(ptr);
    return;
  }
  if ( opt_api_allow )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(v188, 2048u, "API running in IP access mode on port %d (%d)", v157, *ptr);
      applog(4, v188, 0);
    }
  }
  else if ( opt_api_network )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(v189, 2048u, "API running in UNRESTRICTED read access mode on port %d (%d)", v157, *ptr);
      applog(4, v189, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(v190, 2048u, "API running in local read access mode on port %d (%d)", v157, *ptr);
    applog(4, v190, 0);
  }
  if ( opt_api_mcast )
    mcast_init();
  v94 = 0;
  strbufs = (int)k_new_list("StrBufs", 12, 2, 0, 0, "api.c", "api", 5505);
  v162 = v39;
  while ( 2 )
  {
    v95 = (void *)(unsigned __int8)bye;
    if ( bye )
      goto LABEL_312;
    addr_len = 128;
    fd = accept(*ptr, &addr, &addr_len);
    if ( fd >= 0 )
    {
      if ( v166 )
      {
        free(v166);
        v166 = v95;
      }
      v96 = check_connect(&addr, (const char **)&v166, &v164);
      v97 = v96;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        v98 = "Accepted";
        if ( !v96 )
          v98 = "Ignored";
        snprintf(v192, 2048u, "API: connection from %s - %s", (const char *)v166, v98);
        applog(7, v192, 0);
      }
      if ( !v97 )
        goto LABEL_209;
      v99 = recv(fd, v212, 8191u, 0);
      v100 = v99;
      v101 = (unsigned __int8)opt_debug;
      if ( v99 < 0 )
      {
        v212[0] = 0;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          v133 = _errno_location();
          v134 = strerror(*v133);
          snprintf(v193, 2048u, "API: recv failed: %s", v134);
          applog(7, v193, 0);
        }
        goto LABEL_209;
      }
      v212[v99] = 0;
      if ( v101 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(v194, 2048u, "API: recv command: (%d) '%s'", v99, v212);
        applog(7, v194, 0);
      }
      v102 = 0;
      v103 = v212;
      v104 = time(0);
      v105 = *(_BYTE **)(v161 + 4);
      *(_DWORD *)(v161 + 8) = v105;
      *(_DWORD *)when = v104;
      *v105 = 0;
      v106 = (unsigned __int8)v212[0];
      *(_BYTE *)(v161 + 13) = 0;
      if ( v106 == 123 )
      {
        v139 = (_DWORD *)json_loadb((int)v212, v100, 0, (int)v178);
        v155 = v139;
        v140 = v139;
        if ( v139 && !*v139 )
        {
          v143 = (_DWORD *)json_object_get(v139, "command");
          v141 = (int)v143;
          if ( v143 )
          {
            if ( *v143 == 2 )
            {
              v103 = (const char *)json_string_value(v143);
              v144 = (char *)json_object_get(v155, "parameter");
              v108 = v144;
              if ( v144 )
              {
                v145 = *(_DWORD *)v144;
                if ( *(_DWORD *)v144 == 2 )
                {
                  v102 = 1;
                  v108 = (char *)json_string_value(v144);
                }
                else if ( v145 == 3 )
                {
                  v146 = json_integer_value((int)v144);
                  v102 = 1;
                  v108 = v213;
                  sprintf(v213, "%d", v146);
                }
                else if ( v145 == 4 )
                {
                  json_real_value();
                  v108 = v213;
                  v102 = 1;
                  sprintf(v213, "%f", v0);
                }
                else
                {
                  v108 = 0;
                  v102 = 1;
                }
              }
              else
              {
                v102 = 1;
              }
              goto LABEL_185;
            }
            v141 = 0;
            v142 = 14;
          }
          else
          {
            v142 = 24;
          }
        }
        else
        {
          v141 = 0;
          v142 = 23;
        }
        v102 = 1;
        message((unsigned int *)v161, v142, 0, v141, 1u);
        send_result_isra_6(*(char **)(v161 + 4), (_BYTE *)(v161 + 13), fd, 1);
        v155 = v140;
        goto LABEL_269;
      }
      v107 = strchr(v212, 124);
      v108 = v107;
      if ( v107 )
      {
        v108 = v107 + 1;
        *v107 = 0;
      }
      else
      {
        v102 = 0;
      }
LABEL_185:
      if ( strchr(v103, 43) )
      {
        v109 = 1;
        v165 = 1;
        v110 = strlen(v103);
        haystack = (char *)malloc(v110 + 3);
        if ( !haystack )
        {
          snprintf(v195, 2048u, "OOM cmdsbuf in %s %s():%d", "api.c", "api", 5620);
          applog(3, v195, 1);
          quit(1);
        }
        v108 = 0;
        *(_WORD *)haystack = 124;
      }
      else
      {
        v109 = 0;
        haystack = 0;
        v165 = 0;
      }
      v111 = v103;
      v112 = v103;
      v113 = v109;
      v114 = v111;
      v163 = v108;
      if ( !v113 )
      {
        v117 = (const char *)cmds;
        if ( cmds )
          goto LABEL_197;
        goto LABEL_229;
      }
LABEL_189:
      v115 = strchr(v112, 43);
      if ( v115 )
      {
        v114 = v115 + 1;
        *v115 = 0;
        if ( !*v112 )
        {
LABEL_191:
          if ( v114 )
            v116 = v113 & 1;
          else
            v116 = 0;
          if ( !v116 )
          {
LABEL_268:
            v94 = v113;
LABEL_269:
            if ( v94 )
              send_result_isra_6(*(char **)(v161 + 4), (_BYTE *)(v161 + 13), fd, v102);
LABEL_204:
            if ( v155 )
              v121 = v102 & 1;
            else
              v121 = 0;
            if ( v121 )
            {
              if ( !*v155 )
              {
                v137 = v155[1];
                if ( v137 != -1 )
                {
                  v138 = v137 - 1;
                  v155[1] = v138;
                  if ( !v138 )
                    json_delete(v155);
                }
              }
            }
LABEL_209:
            close(fd);
            continue;
          }
          v112 = v114;
          goto LABEL_189;
        }
      }
      else
      {
        if ( !*v112 )
          goto LABEL_268;
        v114 = 0;
      }
      v117 = (const char *)cmds;
      if ( cmds )
      {
LABEL_197:
        v118 = &cmds;
        v119 = 0;
        while ( strcmp(v112, v117) )
        {
          v120 = (const char *)v118[3];
          v118 += 3;
          v117 = v120;
          ++v119;
          if ( !v120 )
          {
            if ( !v113 )
              goto LABEL_229;
            goto LABEL_228;
          }
        }
        sprintf(v175, "|%s|", v112);
        if ( v113 )
        {
          if ( strstr(haystack, v175) )
            goto LABEL_202;
          v124 = strlen(haystack);
          strcpy((char *)stpcpy(&haystack[v124], v112), "|");
          head_join((unsigned int *)v161, v112, v102, &v165);
          v125 = &codes[3 * v119];
          if ( !*((_BYTE *)v125 + 1097) )
          {
            message((unsigned int *)v161, 45, *((unsigned __int8 *)v125 + 1097), v125[272], v102);
            tail_join(v161, v102);
            goto LABEL_202;
          }
        }
        v126 = v164;
        v127 = (*v162)[v164];
        if ( v127 == (*v162)[87] || strstr(*((const char **)&apigroups + v127 - (*v162)[65]), v175) )
        {
          ((void (__fastcall *)(int, int, char *, int, int))codes[3 * v119 + 273])(v161, fd, v163, v102, v126);
        }
        else
        {
          message((unsigned int *)v161, 45, 0, codes[3 * v119 + 272], v102);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              v196,
              2048u,
              "API: access denied to '%s' for '%s' command",
              (const char *)v166,
              (const char *)codes[3 * v119 + 272]);
            applog(7, v196, 0);
          }
        }
        if ( !v113 )
          goto LABEL_230;
      }
      else
      {
LABEL_228:
        head_join((unsigned int *)v161, v112, v102, &v165);
LABEL_229:
        message((unsigned int *)v161, 14, 0, 0, v102);
        if ( !v113 )
        {
LABEL_230:
          send_result_isra_6(*(char **)(v161 + 4), (_BYTE *)(v161 + 13), fd, v102);
LABEL_202:
          if ( !v113 )
          {
            v94 = 0;
            goto LABEL_204;
          }
          goto LABEL_191;
        }
      }
      tail_join(v161, v102);
      goto LABEL_202;
    }
    break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v147 = _errno_location();
    v148 = strerror(*v147);
    snprintf(v191, 2048u, "API failed (%s)%s (%d)", v148, " - API will not be available", *ptr);
    applog(3, v191, 0);
  }
LABEL_312:
  if ( v166 )
  {
    free(v166);
    v166 = 0;
  }
  _pthread_unregister_cancel((__pthread_unwind_buf_t *)&env);
  tidyup(ptr);
  free(ptr);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( do_a_quit )
    {
      v149 = "QUIT";
    }
    else if ( do_a_restart )
    {
      v149 = "RESTART";
    }
    else
    {
      v149 = "UNKNOWN!";
      if ( bye )
        v149 = "BYE";
    }
    snprintf(v197, 2048u, "API: terminating due to: %s", v149);
    applog(7, v197, 0);
  }
  if ( pthread_mutex_lock(&quit_restart_lock) )
    mutex_lock_part_3_constprop_27("api", 5723);
  if ( do_a_restart )
  {
    if ( thr_info_create((int)v173, 0, (void *(*)(void *))restart_thread_0, v173) )
    {
      if ( pthread_mutex_unlock(&quit_restart_lock) )
        mutex_unlock_noyield_part_5_constprop_32("api", 5729);
      selective_yield(0);
      strcpy(v198, "API failed to initiate a restart - aborting");
      applog(3, v198, 1);
      quit(1);
    }
  }
  else
  {
    if ( !do_a_quit )
      goto LABEL_327;
    if ( thr_info_create(
           (int)v173,
           (const pthread_attr_t *)(unsigned __int8)do_a_restart,
           (void *(*)(void *))quit_thread,
           v173) )
    {
      if ( pthread_mutex_unlock(&quit_restart_lock) )
        mutex_unlock_noyield_part_5_constprop_32("api", 5738);
      selective_yield(0);
      strcpy(v199, "API failed to initiate a clean quit - aborting");
      applog(3, v199, 1);
      quit(1);
    }
  }
  pthread_detach(th);
LABEL_327:
  if ( pthread_mutex_unlock(&quit_restart_lock) )
    mutex_unlock_noyield_part_5_constprop_32("api", 5744);
  selective_yield(0);
}
// 1A98A: conditional instruction was optimized away because r5.4==1
// 1B122: variable 'v0' is possibly undefined
// 12138: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 7D0C0: using guessed type int codes[];
// 7D500: using guessed type void *cmds;
// 7DED8: using guessed type int opt_log_interval;
// 7DFB4: using guessed type char *opt_api_host;
// 7DFB8: using guessed type int opt_api_port;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B1C: using guessed type char bye;
// 80B1D: using guessed type char do_a_quit;
// 80B1E: using guessed type char do_a_restart;
// 80B20: using guessed type int ips;
// 80B24: using guessed type int ipaccess;
// 80B40: using guessed type int io_head;
// 80B44: using guessed type int strbufs;
// 82C08: using guessed type int opt_api_allow;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA00: using guessed type int opt_api_groups;
// 80BB99: using guessed type char opt_api_mcast;
// 80CC18: using guessed type char use_syslog;
// 80DD9D: using guessed type char opt_api_listen;
// 80EECC: using guessed type char opt_api_network;
// 19D44: using guessed type char var_1623C[20];

//----- (0001B3D0) --------------------------------------------------------
int __fastcall set_balance(_DWORD *a1)
{
  *a1 = 4;
  return 0;
}

//----- (0001B3D8) --------------------------------------------------------
int __fastcall set_loadbalance(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (0001B3E0) --------------------------------------------------------
int __fastcall set_rr(_DWORD *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0001B3E8) --------------------------------------------------------
int __fastcall enable_debug(_BYTE *a1)
{
  int result; // r0

  *a1 = 0;
  result = 0;
  opt_log_output = 0;
  return result;
}
// 80B6C8: using guessed type char opt_log_output;

//----- (0001B400) --------------------------------------------------------
__int64 noop_can_limit_work()
{
  return 4294967295LL;
}

//----- (0001B408) --------------------------------------------------------
int noop_thread_init()
{
  return 1;
}

//----- (0001B40C) --------------------------------------------------------
int noop_prepare_work()
{
  return 1;
}

//----- (0001B414) --------------------------------------------------------
int noop_get_api_stats()
{
  return 0;
}

//----- (0001B41C) --------------------------------------------------------
int __fastcall generic_zero_stats(int result)
{
  *(_QWORD *)(result + 208) = 0LL;
  *(_DWORD *)(result + 44) = 0;
  *(_QWORD *)(result + 200) = 0LL;
  return result;
}

//----- (0001B430) --------------------------------------------------------
int should_run()
{
  struct tm *v0; // r0
  int v1; // r2
  struct tm *v2; // r3
  int result; // r0
  int tm_hour; // r5
  _BOOL4 v5; // r3
  int v6; // r1
  _BOOL4 v7; // r4
  int v8; // r4
  int tm_min; // r3
  _BOOL4 v10; // r0
  int v11; // r4
  int v12; // r3
  _BOOL4 v13; // r6
  time_t tv_sec; // [sp+4h] [bp-1Ch] BYREF
  struct timeval v15; // [sp+8h] [bp-18h] BYREF

  if ( !schedstart && !schedstop )
    return 1;
  cgtime(&v15);
  tv_sec = v15.tv_sec;
  v0 = localtime(&tv_sec);
  v1 = (unsigned __int8)schedstart;
  v2 = v0;
  if ( schedstart )
  {
    result = (unsigned __int8)schedstop;
    if ( !schedstop )
    {
      tm_hour = v2->tm_hour;
      if ( tm_hour >= dword_80BAC8 )
      {
        v5 = v2->tm_min < dword_80BAC4;
        if ( tm_hour != dword_80BAC8 )
          v5 = 0;
        if ( !v5 )
        {
          schedstart = schedstop;
          return v1;
        }
      }
      return result;
    }
    if ( dword_80BAC8 < dword_80BA10 )
      goto LABEL_17;
    v7 = dword_80BAC4 < dword_80BA0C;
    if ( dword_80BAC8 != dword_80BA10 )
      v7 = 0;
    if ( v7 )
    {
LABEL_17:
      v8 = v2->tm_hour;
      tm_min = v2->tm_min;
      if ( dword_80BA10 > v8 || (dword_80BA0C > tm_min ? (result = dword_80BA10 == v8) : (result = 0), result) )
      {
        if ( dword_80BAC8 <= v8 )
        {
          v10 = dword_80BAC4 > tm_min;
          if ( dword_80BAC8 != v8 )
            v10 = 0;
          return !v10;
        }
        else
        {
          return 0;
        }
      }
      return result;
    }
    v11 = v2->tm_hour;
    v12 = v2->tm_min;
    if ( dword_80BAC8 > v11 )
      goto LABEL_31;
    v13 = dword_80BAC4 > v12;
    if ( dword_80BAC8 != v11 )
      v13 = 0;
    if ( v13 )
    {
LABEL_31:
      if ( dword_80BA10 <= v11 )
        return dword_80BA0C > v12 && dword_80BA10 == v11;
    }
    return 1;
  }
  v6 = v0->tm_hour;
  if ( v6 < dword_80BA10 )
    return 1;
  result = v0->tm_min < dword_80BA0C;
  if ( v6 != dword_80BA10 )
    return 0;
  return result;
}
// 1B4C8: masking with 0x1 was optimized away because r1.4 <= 0x1
// 80BA04: using guessed type char schedstop;
// 80BA0C: using guessed type int dword_80BA0C;
// 80BA10: using guessed type int dword_80BA10;
// 80BABC: using guessed type char schedstart;
// 80BAC4: using guessed type int dword_80BAC4;
// 80BAC8: using guessed type int dword_80BAC8;

//----- (0001B534) --------------------------------------------------------
void __fastcall thread_reportout(thr_info *thr)
{
  int v2; // r4

  *((_BYTE *)thr + 61) = 1;
  cgtime((struct timeval *)((char *)thr + 44));
  v2 = *((_DWORD *)thr + 9);
  *(_DWORD *)(v2 + 96) = 0;
  *(_DWORD *)(v2 + 240) = time(0);
}

//----- (0001B558) --------------------------------------------------------
void __fastcall benchfile_dspwork(unsigned __int8 *a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r4
  int v4; // r3
  char v5[1024]; // [sp+8h] [bp-C08h] BYREF
  char s[2056]; // [sp+408h] [bp-808h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    v4 = (unsigned __int8)a2;
    --v2;
    a2 >>= 8;
    v3 = v4 + (v3 << 8);
  }
  while ( v2 );
  _bin2hex(v5, a1, 128);
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(s, 2048u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, v5);
    applog(3, s, 0);
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0001B5D4) --------------------------------------------------------
int __fastcall suffix_string(unsigned __int64 a1, char *s, size_t maxlen, int a4)
{
  double v6; // d9
  double v7; // d0
  double v8; // r0
  __int16 v10[26]; // [sp+1Ch] [bp-34h] BYREF

  v10[0] = 0;
  if ( a1 > 999999999999999999LL )
  {
    a1 /= 1000000000000000uLL;
    v10[0] = 69;
    v6 = (double)(int)a1 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 999999999999999LL )
  {
    a1 /= 1000000000000uLL;
    v10[0] = 80;
    v6 = (double)(int)a1 / 1000.0;
    if ( a4 )
      goto LABEL_4;
    return snprintf(s, maxlen, "%.3g%s", v6, (const char *)v10);
  }
  if ( a1 > 999999999999LL )
  {
    a1 /= 1000000000uLL;
    v10[0] = 84;
    v6 = (double)(int)a1 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 999999999 )
  {
    a1 /= (unsigned int)&unk_F4240;
    v10[0] = 71;
    v6 = (double)(int)a1 / 1000.0;
    goto LABEL_3;
  }
  if ( (unsigned int)&unk_F423F < a1 )
  {
    a1 /= 1000uLL;
    v10[0] = 77;
    v6 = (double)(int)a1 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 >= 1000 )
  {
    v10[0] = 75;
    v6 = (double)(int)a1 / 1000.0;
LABEL_3:
    if ( a4 )
      goto LABEL_4;
    return snprintf(s, maxlen, "%.3g%s", v6, (const char *)v10);
  }
  if ( !a4 )
    return snprintf(s, maxlen, "%d%s", (_DWORD)a1, (const char *)v10);
  v6 = (double)(int)a1;
LABEL_4:
  if ( v6 <= 0.0 )
  {
    v7 = 0.0;
  }
  else
  {
    v7 = v6;
    v8 = log10(*(double *)&a1);
    floor(v8);
  }
  return snprintf(s, maxlen, "%*.*f%s", a4 + 1, (int)((double)(a4 - 1) - v7), v6, (const char *)v10);
}

//----- (0001B7F8) --------------------------------------------------------
int __fastcall calc_diff(int a1)
{
  double v1; // d0
  int v3; // r4
  double v4; // d8
  unsigned __int64 v5; // r0
  int result; // r0
  double v7; // d7
  double v8; // d7
  double v9; // d7

  v3 = *(_DWORD *)(a1 + 260);
  if ( v1 == 0.0 )
  {
    v9 = (double)*(unsigned __int64 *)(a1 + 184) * 6.27710174e57
       + (double)*(unsigned __int64 *)(a1 + 176) * 3.40282367e38
       + (double)*(unsigned __int64 *)(a1 + 168) * 1.84467441e19
       + (double)*(unsigned __int64 *)(a1 + 160);
    if ( v9 == 0.0 )
    {
      v4 = 2.69595353e67;
      v5 = -1LL;
    }
    else
    {
      v4 = 2.69595353e67 / v9;
      round();
      v5 = (unsigned __int64)(2.69595353e67 / v9);
    }
    *(double *)(a1 + 376) = v4;
  }
  else
  {
    *(double *)(a1 + 376) = v1;
    v4 = v1;
    round();
    v5 = (unsigned __int64)v1;
  }
  *(double *)(v3 + 480) = v4;
  result = suffix_string(v5, (char *)(v3 + 48), 8u, 0);
  v7 = *(double *)(v3 + 464);
  if ( v7 == v4 )
  {
    ++*(_DWORD *)(v3 + 488);
    goto LABEL_5;
  }
  if ( v7 <= v4 )
  {
    if ( v7 != 0.0 )
    {
LABEL_5:
      v8 = *(double *)(v3 + 472);
      if ( v8 != v4 )
        goto LABEL_6;
LABEL_12:
      ++*(_DWORD *)(v3 + 492);
      return result;
    }
    *(double *)(v3 + 464) = v4;
    *(_DWORD *)(v3 + 488) = 1;
  }
  else
  {
    *(double *)(v3 + 464) = v4;
    *(_DWORD *)(v3 + 488) = 1;
  }
  v8 = *(double *)(v3 + 472);
  if ( v8 == v4 )
    goto LABEL_12;
LABEL_6:
  if ( v8 < v4 )
  {
    *(double *)(v3 + 472) = v4;
    *(_DWORD *)(v3 + 492) = 1;
  }
  return result;
}
// 1B80E: variable 'v1' is possibly undefined
// 123A4: using guessed type int round(void);

//----- (0001B968) --------------------------------------------------------
int __fastcall set_logfile_path(int a1)
{
  opt_set_charp(a1, &opt_logfile_path);
  return 0;
}
// 80B50: using guessed type _DWORD opt_logfile_path;

//----- (0001B97C) --------------------------------------------------------
int __fastcall set_logwork_asicnum(int a1)
{
  opt_set_charp(a1, &opt_logwork_asicnum);
  return 0;
}
// 80B54: using guessed type _DWORD opt_logwork_asicnum;

//----- (0001B98C) --------------------------------------------------------
int __fastcall set_logwork_path(int a1)
{
  opt_set_charp(a1, &opt_logwork_path);
  return 0;
}
// 80B58: using guessed type int opt_logwork_path;

//----- (0001B99C) --------------------------------------------------------
int __fastcall set_logfile_openflag(int a1)
{
  opt_set_charp(a1, &opt_logfile_openflag);
  return 0;
}
// 80B5C: using guessed type _DWORD opt_logfile_openflag;

//----- (0001B9AC) --------------------------------------------------------
int __fastcall set_version_path(int a1)
{
  opt_set_charp(a1, &opt_version_path);
  return 0;
}
// 80B60: using guessed type _DWORD opt_version_path;

//----- (0001B9BC) --------------------------------------------------------
int __fastcall set_default_config(int a1)
{
  opt_set_charp(a1, &default_config);
  return 0;
}
// 80B64: using guessed type int default_config;

//----- (0001B9CC) --------------------------------------------------------
int __fastcall set_sharelog(int a1)
{
  int v2; // r0
  bool v3; // zf
  int v4; // r5
  char *endptr; // [sp+4h] [bp-814h] BYREF
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  endptr = "";
  v2 = strtol((const char *)a1, &endptr, 10);
  v3 = v2 == 0;
  if ( v2 >= 0 )
    v3 = *endptr == 0;
  if ( v3 )
  {
    v4 = v2;
    sharelog_file = (int)fdopen(v2, "a");
    if ( sharelog_file || !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(s, 2048u, "Failed to open fd %u for share log", v4);
LABEL_19:
    applog(3, s, 0);
    return 0;
  }
  if ( *(_BYTE *)a1 != 45 || *(_BYTE *)(a1 + 1) )
  {
    sharelog_file = (int)fopen((const char *)a1, "a");
    if ( sharelog_file || !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(s, 2048u, "Failed to open %s for share log", a1);
    goto LABEL_19;
  }
  sharelog_file = stdout;
  if ( !stdout && (use_syslog || opt_log_output || opt_log_level > 2) )
  {
    strcpy(s, "Standard output missing for share log");
    applog(3, s, 0);
  }
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 80B14: using guessed type int stdout;
// 80B68: using guessed type int sharelog_file;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0001BB20) --------------------------------------------------------
_BYTE *__fastcall json_escape(const char *a1)
{
  const char *v1; // r4
  size_t v2; // r0
  _BYTE *v3; // r5
  _DWORD *v4; // r0
  int v5; // r2
  _BYTE *v6; // r2
  int i; // r3
  bool v8; // zf
  _BYTE *v9; // r3
  char v10; // t1
  _BYTE *result; // r0

  v1 = a1;
  v2 = strlen(a1);
  v3 = cgmalloc(2 * v2 + 1, "cgminer.c", "json_escape", 5839);
  v4 = cgmalloc(8u, "cgminer.c", "json_escape", 5840);
  *v4 = v3;
  v5 = jedata;
  jedata = (int)v4;
  v4[1] = v5;
  v6 = v3;
  for ( i = *(unsigned __int8 *)v1; *v1; i = *(unsigned __int8 *)v1 )
  {
    v8 = i == 34;
    if ( i != 34 )
      v8 = i == 92;
    v9 = v6;
    if ( v8 )
    {
      *v6 = 92;
      v9 = v6 + 1;
    }
    v10 = *v1++;
    v6 = v9 + 1;
    *v9 = v10;
  }
  result = v3;
  *v6 = 0;
  return result;
}
// 80B6C: using guessed type int jedata;

//----- (0001BB9C) --------------------------------------------------------
void __fastcall get_benchmark_work(int a1)
{
  _DWORD *v2; // r3

  *(_QWORD *)(a1 + 376) = 4629700416936869888LL;
  cg_memcpy((void *)(a1 + 160), &bench_target, 32u, (int)"cgminer.c", (int)"get_benchmark_work", 4188);
  v2 = (_DWORD *)pools;
  *(_DWORD *)(a1 + 244) = 0;
  *(_BYTE *)(a1 + 282) = 1;
  *(_DWORD *)(a1 + 260) = *v2;
  cgtime((struct timeval *)(a1 + 400));
  copy_time((timeval *)(a1 + 408), (const timeval *)(a1 + 400));
  *(_BYTE *)(a1 + 440) = 66;
}
// 80CBE4: using guessed type int pools;

//----- (0001BC0C) --------------------------------------------------------
int *__fastcall regen_hash(int a1)
{
  int v2; // r1
  char *v3; // r2
  unsigned int v4; // t1
  _BYTE v6[28]; // [sp+0h] [bp-78h] BYREF
  char v7; // [sp+1Ch] [bp-5Ch] BYREF
  char v8[76]; // [sp+20h] [bp-58h] BYREF
  char v9; // [sp+6Ch] [bp-Ch] BYREF

  v2 = a1 - 4;
  v3 = &v7;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    *((_DWORD *)v3 + 1) = bswap32(v4);
    v3 += 4;
  }
  while ( v3 != &v9 );
  sha256(v8, 80u, (int)v6);
  return sha256(v6, 32u, a1 + 192);
}
// 1BC0C: using guessed type char var_58[76];

//----- (0001BC40) --------------------------------------------------------
void __fastcall calc_midstate(int a1)
{
  int v2; // r1
  int *v3; // r2
  unsigned int v4; // t1
  int v5; // [sp+4h] [bp-F4h] BYREF
  char v6[60]; // [sp+8h] [bp-F0h] BYREF
  char v7; // [sp+44h] [bp-B4h] BYREF
  int v8[34]; // [sp+48h] [bp-B0h] BYREF
  char v9; // [sp+D0h] [bp-28h] BYREF

  v2 = a1 - 4;
  v3 = &v5;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    v3[1] = bswap32(v4);
    ++v3;
  }
  while ( v3 != (int *)&v7 );
  sha256_init(v8);
  sha256_update(v8, v6, 64u);
  cg_memcpy((void *)(a1 + 128), &v9, 32u, (int)"cgminer.c", (int)"calc_midstate", 2196);
}
// 1BC40: using guessed type int var_B0[34];
// 1BC40: using guessed type char var_F0[60];

//----- (0001BC90) --------------------------------------------------------
int submit_work_thread()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  return 0;
}

//----- (0001BCA0) --------------------------------------------------------
int __fastcall miner_thread(_DWORD *a1)
{
  _DWORD *v1; // r8
  int v3; // r7
  time_t v4; // r0
  void (__fastcall *v5)(_DWORD *); // r3
  char v7[16]; // [sp+0h] [bp-828h] BYREF
  char v8[2072]; // [sp+10h] [bp-818h] BYREF

  v1 = (_DWORD *)a1[9];
  v3 = v1[1];
  snprintf(v7, 16u, "%d/Miner", *a1);
  RenameThread(v7);
  thread_reportout((thr_info *)a1);
  if ( (*(int (__fastcall **)(_DWORD *))(v3 + 52))(a1) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(v8, "Waiting on sem in miner thread");
      applog(7, v8, 0);
    }
    cgsem_wait((sem_t *)a1 + 1, "cgminer.c", "miner_thread", 9689);
    v4 = time(0);
    v5 = *(void (__fastcall **)(_DWORD *))(v3 + 60);
    v1[58] = v4;
    v5(a1);
    (*(void (__fastcall **)(_DWORD *))(v3 + 88))(a1);
    return 0;
  }
  else
  {
    dev_error(v1, 0);
    return 0;
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (0001BD84) --------------------------------------------------------
void __noreturn killall_thread()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (0001BDA4) --------------------------------------------------------
void __noreturn applog_and_exit(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  vsnprintf(exit_buf, 512u, a1, varg_r1);
  applog(3, exit_buf, 1);
  exit(1);
}

//----- (0001BDD4) --------------------------------------------------------
void __fastcall __noreturn opt_verusage_and_exit(char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", packagename);
  v2 = opt_usage((const char *)opt_argv0, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 80B14: using guessed type int stdout;
// 817D14: using guessed type int opt_argv0;

//----- (0001BE1C) --------------------------------------------------------
int __fastcall pool_unusable_part_4(unsigned __int8 *a1)
{
  int v1; // r3

  v1 = a1[640];
  if ( a1[640] && a1[641] )
    return a1[643] ^ 1;
  return v1;
}

//----- (0001BE34) --------------------------------------------------------
int __fastcall select_balanced(int a1)
{
  int v1; // r7
  int v2; // r6
  int *v3; // r4
  int v4; // r5
  int v5; // r1
  int v6; // t1
  int v7; // r1
  int result; // r0

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 156);
  if ( total_pools > 0 )
  {
    v3 = (int *)pools;
    v4 = pools + 4 * total_pools;
    do
    {
      while ( 1 )
      {
        v6 = *v3++;
        v5 = v6;
        if ( !*(_BYTE *)(v6 + 97) && *(_DWORD *)(v5 + 100) == 1 && !pool_unusable_part_4((unsigned __int8 *)v5) )
          break;
        if ( v3 == (int *)v4 )
          goto LABEL_10;
      }
      if ( *(_DWORD *)(v7 + 156) < v2 )
      {
        v1 = v7;
        v2 = *(_DWORD *)(v7 + 156);
      }
    }
    while ( v3 != (int *)v4 );
LABEL_10:
    v2 = *(_DWORD *)(v1 + 156);
  }
  result = v1;
  *(_DWORD *)(v1 + 156) = v2 + 1;
  return result;
}
// 1BE7A: variable 'v7' is possibly undefined
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (0001BE98) --------------------------------------------------------
int __fastcall priority_pool_part_9(int a1)
{
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(v3, 2048u, "WTF No pool %d found!", a1);
    applog(3, v3, 0);
  }
  return *(_DWORD *)(pools + 4 * a1);
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;

//----- (0001BEFC) --------------------------------------------------------
int __fastcall priority_pool(int a1)
{
  int v1; // r2
  int v2; // r1
  int v3; // r3
  int v4; // t1

  if ( total_pools <= 0 )
    return priority_pool_part_9(a1);
  v1 = pools;
  v2 = *(_DWORD *)pools;
  if ( a1 != *(_DWORD *)(*(_DWORD *)pools + 4) )
  {
    v3 = 0;
    while ( ++v3 != total_pools )
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      v2 = v4;
      if ( *(_DWORD *)(v4 + 4) == a1 )
        return v2;
    }
    return priority_pool_part_9(a1);
  }
  return v2;
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (0001BF3C) --------------------------------------------------------
int __fastcall new_nonce_isra_10(_DWORD *a1, int a2)
{
  int result; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  if ( a1[59] == a2 )
  {
    if ( use_syslog || (result = (unsigned __int8)opt_log_output, opt_log_output) || opt_log_level > 5 )
    {
      snprintf(s, 2048u, "%s %d duplicate share detected as HW error", *(const char **)(a1[1] + 8), a1[2]);
      applog(6, s, 0);
      return 0;
    }
  }
  else
  {
    result = 1;
    a1[59] = a2;
  }
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0001BFA8) --------------------------------------------------------
char *__fastcall set_float_100_to_250(const char *a1, float *a2)
{
  char *result; // r0

  result = opt_set_floatval(a1, a2);
  if ( !result )
  {
    if ( *a2 < 100.0 )
    {
      return "Value out of range";
    }
    else
    {
      result = "Value out of range";
      if ( *a2 <= 250.0 )
        return 0;
    }
  }
  return result;
}

//----- (0001BFF4) --------------------------------------------------------
char *__fastcall set_float_125_to_500(const char *a1, float *a2)
{
  char *result; // r0

  result = opt_set_floatval(a1, a2);
  if ( !result )
  {
    if ( *a2 < 125.0 )
    {
      return "Value out of range";
    }
    else
    {
      result = "Value out of range";
      if ( *a2 <= 500.0 )
        return 0;
    }
  }
  return result;
}

//----- (0001C040) --------------------------------------------------------
int __fastcall mt_disable_isra_16(int a1, int a2, int (__fastcall **a3)(int))
{
  int v6; // r3
  char v8[2080]; // [sp+0h] [bp-820h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(v8, 2048u, "Thread %d being disabled", a2);
    applog(4, v8, 0);
  }
  v6 = (unsigned __int8)opt_debug;
  *(_QWORD *)(*(_DWORD *)(a1 + 36) + 48) = 0LL;
  if ( v6 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(v8, "Waiting on sem in miner thread");
    applog(7, v8, 0);
  }
  cgsem_wait((sem_t *)(a1 + 16), "cgminer.c", "mt_disable", 9049);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(v8, 2048u, "Thread %d being re-enabled", a2);
    applog(4, v8, 0);
  }
  return (*a3)(a1);
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (0001C15C) --------------------------------------------------------
void set_lowprio_part_17()
{
  char v0[2064]; // [sp+0h] [bp-810h] BYREF

  strcpy(v0, "Unable to set thread to low priority");
  applog(6, v0, 0);
}

//----- (0001C190) --------------------------------------------------------
void set_lowprio()
{
  if ( !nice(10) && (use_syslog || opt_log_output || opt_log_level > 5) )
    set_lowprio_part_17();
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0001C1C8) --------------------------------------------------------
int __fastcall api_thread(int a1)
{
  pthread_t v2; // r0
  int result; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  RenameThread("API");
  set_lowprio();
  api();
  result = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (0001C204) --------------------------------------------------------
char *__fastcall load_config(char *a1)
{
  bool v2; // nf
  _DWORD *file; // r0
  size_t v5; // r6
  unsigned int v6; // r6
  char *v7; // r4
  char v8[92]; // [sp+Ch] [bp-114h] BYREF
  char v9[184]; // [sp+68h] [bp-B8h] BYREF

  if ( !cnfbuf )
    cnfbuf = (int)_strdup(a1);
  v2 = include_count - 9 < 0;
  ++include_count;
  if ( !(v2 ^ __OFSUB__(include_count, 10) | (include_count == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  file = (_DWORD *)json_load_file(a1, 0, (int)v8);
  if ( file && !*file )
  {
    config_loaded = 1;
    return parse_config(file, 1);
  }
  else
  {
    v5 = strlen(a1);
    v6 = strlen(v9) + v5 + 35;
    v7 = (char *)cgmalloc(v6, "cgminer.c", "load_config", 2064);
    snprintf(v7, v6, "JSON decode of file '%s' failed\n %s", a1, v9);
    return v7;
  }
}
// 80E94: using guessed type int cnfbuf;
// 80E98: using guessed type int include_count;
// 80E9C: using guessed type char config_loaded;
// 1C204: using guessed type char var_114[92];

//----- (0001C2A8) --------------------------------------------------------
char *__fastcall parse_config(_DWORD *a1, int a2)
{
  char **v3; // r8
  const char *v4; // r0
  char *v5; // r4
  _DWORD *v6; // r0
  _DWORD *v7; // r7
  int v8; // r3
  unsigned int i; // r6
  char *v10; // r0
  char *v11; // r9
  char *v12; // r3
  int v13; // r3
  _DWORD *v14; // r0
  char *result; // r0
  _DWORD *v16; // r9
  int v17; // r0
  _DWORD *v18; // r6
  _DWORD *v19; // r0
  char *ptr; // [sp+14h] [bp-834h]
  int v22; // [sp+1Ch] [bp-82Ch]
  char s[2088]; // [sp+20h] [bp-828h] BYREF

  if ( a2 && !fileconf_load )
    fileconf_load = 1;
  if ( dword_7D6AC == 16 )
    goto LABEL_47;
  if ( (dword_7D6AC & 8) != 0 )
    goto LABEL_31;
  v3 = &off_7D6C4;
  while ( 2 )
  {
    v4 = *(v3 - 7);
    if ( !v4 )
      goto LABEL_29;
    ptr = _strdup(v4);
    v5 = strtok(ptr, "|");
    if ( !v5 )
      goto LABEL_28;
    do
    {
      while ( 1 )
      {
        if ( v5[1] != 45 )
          goto LABEL_10;
        v6 = (_DWORD *)json_object_get(a1, v5 + 2);
        v7 = v6;
        if ( !v6 )
          goto LABEL_10;
        v8 = (int)*(v3 - 6);
        if ( (v8 & 6) != 0 )
        {
          if ( *v6 == 2 )
          {
            v18 = json_string_value(v6);
            v11 = (char *)((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v18, *(v3 - 2));
            if ( *(v3 - 6) == (char *)4 )
              opt_set_charp((int)v18, *(v3 - 2));
LABEL_21:
            if ( v11 )
            {
              if ( !a2 )
                goto LABEL_40;
              goto LABEL_23;
            }
            goto LABEL_10;
          }
          if ( *v6 == 1 )
            break;
        }
        if ( (v8 & 1) != 0 && *v6 == 5 )
        {
          v11 = (char *)((int (__fastcall *)(_DWORD))*(v3 - 5))(*(v3 - 2));
          goto LABEL_21;
        }
        v10 = (char *)malloc(14u);
        if ( v10 )
        {
          v11 = v10;
          strcpy(v10, "Invalid value");
          goto LABEL_21;
        }
LABEL_10:
        v5 = strtok(0, "|");
        if ( !v5 )
          goto LABEL_28;
      }
      for ( i = 0; ; ++i )
      {
        if ( i >= (unsigned int)json_array_size(v7) )
          goto LABEL_10;
        v14 = json_array_get(v7, i);
        if ( !v14 )
          goto LABEL_10;
        if ( *v14 != 2 )
        {
          if ( *v14 )
            continue;
          v13 = parse_config();
          goto LABEL_32;
        }
        v16 = json_string_value(v14);
        v17 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v16, *(v3 - 2));
        v13 = v17;
        if ( *(v3 - 6) == (char *)4 )
          break;
LABEL_32:
        if ( v13 )
          goto LABEL_39;
LABEL_33:
        ;
      }
      v22 = v17;
      opt_set_charp((int)v16, *(v3 - 2));
      v13 = v22;
      if ( !v22 )
        goto LABEL_33;
LABEL_39:
      v11 = (char *)v13;
      if ( !a2 )
      {
LABEL_40:
        snprintf(err_buf_13672, 200u, "Parsing JSON option %s: %s", v5, v11);
        return err_buf_13672;
      }
LABEL_23:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(s, 2048u, "Invalid config option %s: %s", v5, v11);
        applog(3, s, 0);
      }
      free(v11);
      fileconf_load = -1;
      v5 = strtok(0, "|");
    }
    while ( v5 );
LABEL_28:
    free(ptr);
LABEL_29:
    v12 = v3[1];
    if ( v12 != (char *)16 )
    {
      v3 += 7;
      if ( ((unsigned __int8)v12 & 8) != 0 )
LABEL_31:
        _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 1909u, "parse_config");
      continue;
    }
    break;
  }
LABEL_47:
  result = (char *)json_object_get(a1, "include");
  if ( result )
  {
    if ( *(_DWORD *)result == 2 )
    {
      v19 = json_string_value(result);
      return (char *)load_config(v19, 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 1C204: using guessed type int __fastcall load_config(_DWORD, _DWORD);
// 7D6AC: using guessed type int dword_7D6AC;
// 7D6C4: using guessed type char *;
// 805A8: using guessed type int opt_log_level;
// 80F68: using guessed type int fileconf_load;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0001C518) --------------------------------------------------------
char *__fastcall set_int_42_to_65(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 42) <= 20 )
      return 0;
  }
  return result;
}

//----- (0001C538) --------------------------------------------------------
char *__fastcall set_int_22_to_55(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 22) <= 33 )
      return 0;
  }
  return result;
}

//----- (0001C558) --------------------------------------------------------
char *__fastcall set_int_42_to_85(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 42) <= 43 )
      return 0;
  }
  return result;
}

//----- (0001C578) --------------------------------------------------------
char *__fastcall set_int_22_to_75(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 22) <= 53 )
      return 0;
  }
  return result;
}

//----- (0001C598) --------------------------------------------------------
char *__fastcall set_int_32_to_63(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 32) <= 31 )
      return 0;
  }
  return result;
}

//----- (0001C5B8) --------------------------------------------------------
char *__fastcall set_int_0_to_4(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( *a2 <= 4u )
      return 0;
  }
  return result;
}

//----- (0001C5D8) --------------------------------------------------------
char *__fastcall set_int_0_to_200(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( *a2 <= 200u )
      return 0;
  }
  return result;
}

//----- (0001C5F8) --------------------------------------------------------
char *__fastcall set_int_0_to_7680(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( *a2 <= 7680u )
      return 0;
  }
  return result;
}

//----- (0001C618) --------------------------------------------------------
char *__fastcall set_int_1_to_255(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 1) <= 254 )
      return 0;
  }
  return result;
}

//----- (0001C638) --------------------------------------------------------
char *__fastcall set_int_0_to_255(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( *a2 <= 255u )
      return 0;
  }
  return result;
}

//----- (0001C658) --------------------------------------------------------
char *__fastcall set_int_0_to_100(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( *a2 <= 100u )
      return 0;
  }
  return result;
}

//----- (0001C678) --------------------------------------------------------
char *__fastcall set_int_1_to_10(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 1) <= 9 )
      return 0;
  }
  return result;
}

//----- (0001C698) --------------------------------------------------------
char *__fastcall set_int_0_to_10(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( *a2 <= 10u )
      return 0;
  }
  return result;
}

//----- (0001C6B8) --------------------------------------------------------
char *__fastcall set_int_1_to_65535(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)(*a2 - 1) <= 65534 )
      return 0;
  }
  return result;
}

//----- (0001C6DC) --------------------------------------------------------
char *__fastcall set_int_0_to_9999(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    if ( *a2 <= 9999u )
      return 0;
  }
  return result;
}

//----- (0001C700) --------------------------------------------------------
char *__fastcall set_rotate(const char *a1)
{
  char *result; // r0

  pool_strategy = 2;
  result = opt_set_intval(a1, &opt_rotate_period);
  if ( !result )
  {
    result = "Value out of range";
    if ( (unsigned int)opt_rotate_period <= 9999 )
      return 0;
  }
  return result;
}
// 80F6C: using guessed type int pool_strategy;
// 80BB84: using guessed type int opt_rotate_period;

//----- (0001C738) --------------------------------------------------------
void __fastcall free_work_part_36(const char *a1, const char *a2, int a3)
{
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  snprintf(s, 2048u, "Free work called with NULL work from %s %s:%d", a1, a2, a3);
  applog(3, s, 0);
}

//----- (0001C768) --------------------------------------------------------
double __fastcall decay_time_part_37(double a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double *v4; // r4
  double result; // r0

  v4 = (double *)LODWORD(a1);
  result = exp(a1);
  *v4 = (*v4 + v1 / v2 * (1.0 - 1.0 / (v2 / v3))) / (1.0 - 1.0 / (v2 / v3) + 1.0);
  return result;
}
// 1C784: variable 'v1' is possibly undefined
// 1C784: variable 'v2' is possibly undefined
// 1C774: variable 'v3' is possibly undefined

//----- (0001C7AC) --------------------------------------------------------
int __fastcall reinit_device_part_38(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 16))();
}

//----- (0001C7B8) --------------------------------------------------------
int noop_get_stats()
{
  return 1;
}

//----- (0001C7BC) --------------------------------------------------------
int noop_thread_prepare()
{
  return 1;
}

//----- (0001C7C0) --------------------------------------------------------
int set_null()
{
  return 0;
}

//----- (0001C7D4) --------------------------------------------------------
const char *__fastcall set_sched_start(const char *a1)
{
  const char *result; // r0

  if ( sscanf(a1, "%d:%d", &dword_80BAC8, &dword_80BAC4) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_80BAC8 > 23 || (unsigned int)dword_80BAC4 > 59 )
    return "Invalid time set.";
  result = 0;
  schedstart = 1;
  return result;
}
// 80BABC: using guessed type char schedstart;
// 80BAC4: using guessed type int dword_80BAC4;
// 80BAC8: using guessed type int dword_80BAC8;

//----- (0001C820) --------------------------------------------------------
const char *__fastcall set_sched_stop(const char *a1)
{
  const char *result; // r0

  if ( sscanf(a1, "%d:%d", &dword_80BA10, &dword_80BA0C) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_80BA10 > 23 || (unsigned int)dword_80BA0C > 59 )
    return "Invalid time set.";
  result = 0;
  schedstop = 1;
  return result;
}
// 80BA04: using guessed type char schedstop;
// 80BA0C: using guessed type int dword_80BA0C;
// 80BA10: using guessed type int dword_80BA10;

//----- (0001C86C) --------------------------------------------------------
int __fastcall get_datestamp(char *a1, size_t a2, time_t *a3)
{
  time_t v3; // r3
  int v6; // r5
  struct tm *v7; // r0
  time_t v9; // [sp+1Ch] [bp-1Ch] BYREF

  v3 = a3[1];
  v9 = *a3;
  v6 = v3 / 1000;
  v7 = localtime(&v9);
  return snprintf(
           a1,
           a2,
           "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
           v7->tm_year + 1900,
           v7->tm_mon + 1,
           v7->tm_mday,
           v7->tm_hour,
           v7->tm_min,
           v7->tm_sec,
           v6);
}

//----- (0001C8CC) --------------------------------------------------------
void adjust_quota_gcd()
{
  int v0; // r7
  unsigned int v1; // r4
  int v2; // r8
  int *v3; // r6
  int *v4; // r2
  int v5; // r9
  int v6; // t1
  unsigned int v7; // r3
  bool v8; // cf
  int v9; // t1
  unsigned int v10; // r5
  int v11; // r8
  int v12; // r6
  int v13; // r10
  _DWORD *v14; // t1
  char v15[2080]; // [sp+0h] [bp-820h] BYREF

  v0 = total_pools;
  if ( total_pools <= 0 )
  {
    v1 = 1;
  }
  else
  {
    v1 = -1;
    v2 = pools;
    v3 = (int *)pools;
    v4 = (int *)pools;
    v5 = pools + 4 * total_pools;
    do
    {
      v6 = *v4++;
      v7 = *(_DWORD *)(v6 + 56);
      v8 = 1;
      if ( v7 )
        v8 = v7 >= v1;
      if ( !v8 )
        v1 = v7;
    }
    while ( v4 != (int *)v5 );
    if ( v1 == -1 )
    {
      v2 = pools;
      v1 = 1;
    }
    else
    {
      do
      {
        v9 = *v3++;
        v10 = *(_DWORD *)(v9 + 56);
        if ( v10 && v10 % v1 )
        {
          do
            --v1;
          while ( v10 % v1 );
        }
      }
      while ( v3 != (int *)v5 );
    }
    v11 = v2 - 4;
    v12 = 0;
    v13 = global_quota_gcd;
    do
    {
      v14 = *(_DWORD **)(v11 + 4);
      v11 += 4;
      ++v12;
      v14[16] = v14[16] * v13 / v1;
      v14[15] = v14[14] / v1;
    }
    while ( v12 < v0 );
  }
  global_quota_gcd = v1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(v15, 2048u, "Global quota greatest common denominator set to %lu", v1);
    applog(7, v15, 0);
  }
}
// 7DEC0: using guessed type int global_quota_gcd;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;

//----- (0001C9DC) --------------------------------------------------------
char *__fastcall set_int_range(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0
  _BOOL4 v8; // r4
  int v9; // r2

  result = opt_set_intval(a1, a2);
  if ( !result )
  {
    result = "Value out of range";
    v8 = *a2 > a4;
    if ( *a2 < a3 )
      v9 = v8 | 1;
    else
      v9 = v8;
    if ( !v9 )
      return 0;
  }
  return result;
}

//----- (0001CA10) --------------------------------------------------------
int __fastcall get_intrange(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (0001CA30) --------------------------------------------------------
int __fastcall detect_stratum(int a1, const char *a2)
{
  int sockaddr; // r5
  int result; // r0
  char *v6; // r0
  int v7; // r3

  sockaddr = extract_sockaddr(a2, (_DWORD *)(a1 + 600), (char **)(a1 + 584));
  if ( !sockaddr )
    return sockaddr;
  if ( strncasecmp(a2, "stratum+tcp://", 14u) )
    return 0;
  v6 = _strdup(a2);
  v7 = *(_DWORD *)(a1 + 600);
  *(_DWORD *)(a1 + 164) = v6;
  result = sockaddr;
  *(_BYTE *)(a1 + 640) = 1;
  *(_DWORD *)(a1 + 576) = v7;
  return result;
}

//----- (0001CA7C) --------------------------------------------------------
int __fastcall setup_url(int a1, char *a2)
{
  char *proxy; // r5
  char *v5; // r6

  proxy = get_proxy(a2, a1);
  if ( !detect_stratum(a1, proxy) )
  {
    opt_set_charp((int)proxy, (_DWORD *)(a1 + 164));
    if ( strncmp(proxy, "http://", 7u) )
    {
      if ( strncmp(proxy, "https://", 8u) )
      {
        v5 = (char *)cgmalloc(256u, "cgminer.c", "setup_url", 1020);
        strcpy(v5, "stratum+tcp://");
        strncat(v5, proxy, 242u);
        detect_stratum(a1, v5);
        free(v5);
      }
    }
  }
  return *(_DWORD *)(a1 + 164);
}

//----- (0001CB1C) --------------------------------------------------------
const char *__fastcall set_temp_cutoff(const char *a1)
{
  const char *result; // r0

  if ( !a1 || !*a1 )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(a1, 0, 10) > 200 )
    return "Invalid value passed to set temp cutoff";
  result = 0;
  temp_cutoff_str = (int)a1;
  return result;
}
// 80F70: using guessed type int temp_cutoff_str;

//----- (0001CB58) --------------------------------------------------------
void *__fastcall clean_work(void **a1)
{
  free(a1[72]);
  free(a1[77]);
  free(a1[82]);
  free(a1[80]);
  return j_memset(a1, 0, 448u);
}

//----- (0001CB8C) --------------------------------------------------------
char *__fastcall copy_work(int a1, int a2, int a3)
{
  int v6; // r7
  const char *v7; // r0
  const char *v8; // r0
  unsigned __int8 *v9; // r1
  char *result; // r0
  unsigned int v11[7]; // [sp+Ch] [bp-1Ch] BYREF

  v6 = *(_DWORD *)(a1 + 340);
  clean_work((void **)a1);
  cg_memcpy((void *)a1, (const void *)a2, 448u, (int)"cgminer.c", (int)"_copy_work", 4874);
  v7 = *(const char **)(a2 + 288);
  *(_DWORD *)(a1 + 340) = v6;
  if ( v7 )
    *(_DWORD *)(a1 + 288) = _strdup(v7);
  v8 = *(const char **)(a2 + 320);
  if ( v8 )
    *(_DWORD *)(a1 + 320) = _strdup(v8);
  v9 = *(unsigned __int8 **)(a2 + 308);
  if ( v9 )
  {
    if ( a3 )
    {
      *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
      hex2bin(v11, v9, 4);
      v11[0] = bswap32(bswap32(v11[0]) + a3);
      *(_DWORD *)(a1 + 308) = bin2hex((unsigned __int8 *)v11, 4);
    }
    else
    {
      *(_DWORD *)(a1 + 308) = _strdup(*(const char **)(a2 + 308));
    }
  }
  else if ( a3 )
  {
    *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
  }
  result = *(char **)(a2 + 328);
  if ( result )
  {
    result = _strdup(result);
    *(_DWORD *)(a1 + 328) = result;
  }
  *(_DWORD *)(a1 + 444) = *(_DWORD *)(a2 + 444);
  return result;
}

//----- (0001CC48) --------------------------------------------------------
void __fastcall free_work(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v4; // r5

  v4 = *a1;
  if ( *a1 )
  {
    clean_work(*a1);
    free(v4);
    *a1 = 0;
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    free_work_part_36(a2, a3, a4);
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0001CC98) --------------------------------------------------------
int __fastcall decay_time(double a1)
{
  double v1; // d1

  if ( v1 > 0.0 )
    a1 = decay_time_part_37(a1);
  return LODWORD(a1);
}
// 1CCA0: variable 'v1' is possibly undefined

//----- (0001CCA8) --------------------------------------------------------
void __fastcall cgpu_runtime(int a1)
{
  struct timeval v1; // [sp+0h] [bp-10h] BYREF

  if ( *(_DWORD *)(a1 + 368) )
  {
    cgtime(&v1);
    tdiff();
  }
}
// 7DEC8: using guessed type double total_secs;

//----- (0001CCE8) --------------------------------------------------------
void tsince_restart()
{
  struct timeval v0; // [sp+0h] [bp-10h] BYREF

  cgtime(&v0);
  tdiff();
}

//----- (0001CD04) --------------------------------------------------------
void tsince_update()
{
  struct timeval v0; // [sp+0h] [bp-10h] BYREF

  cgtime(&v0);
  tdiff();
}

//----- (0001CD20) --------------------------------------------------------
_BYTE *__fastcall set_work_ntime(_BYTE *result, unsigned int a2)
{
  void *v2; // r3
  unsigned __int8 *v3; // r5
  _BYTE *v4; // r4

  v2 = (void *)*((_DWORD *)result + 77);
  *((_DWORD *)result + 17) = bswap32(a2);
  if ( v2 )
  {
    v3 = result + 68;
    v4 = result;
    free(v2);
    result = bin2hex(v3, 4);
    *((_DWORD *)v4 + 77) = result;
  }
  return result;
}

//----- (0001CD48) --------------------------------------------------------
unsigned __int64 __fastcall share_ndiff(unsigned __int64 *a1)
{
  double v1; // d7

  if ( !a1 )
    return 0LL;
  v1 = (double)a1[27] * 6.27710174e57 + (double)a1[26] * 3.40282367e38 + (double)a1[25] * 1.84467441e19 + (double)a1[24];
  if ( v1 == 0.0 )
    return 0LL;
  else
    return (unsigned __int64)(2.69595353e67 / v1);
}

//----- (0001CDF0) --------------------------------------------------------
void __fastcall discard_work(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v5; // r1
  _DWORD *v9; // r3
  int v10; // r2
  int v11; // r1
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  v5 = *a1;
  if ( *a1 )
  {
    if ( *((_BYTE *)v5 + 273) || v5[60] || *((_BYTE *)v5 + 272) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(s, "Discarded cloned or rolled work");
        applog(7, s, 0);
      }
    }
    else
    {
      v9 = v5[65];
      if ( v9 )
      {
        v10 = v9[17];
        v11 = v9[16] - 1;
        ++v9[31];
        v9[16] = v11;
        v9[17] = v10 - 1;
      }
      ++*(_QWORD *)&total_discarded;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(s, "Discarded work");
        applog(7, s, 0);
      }
    }
    free_work(a1, a2, a3, a4);
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(s, 2048u, "Discard work called with NULL work from %s %s:%d", a2, a3, a4);
    applog(3, s, 0);
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BAA0: using guessed type int total_discarded;
// 80CC18: using guessed type char use_syslog;

//----- (0001CF5C) --------------------------------------------------------
int __fastcall remove_pool(int result)
{
  int v1; // r7
  int v2; // lr
  int *v3; // r2
  int v4; // r5
  int v5; // r1
  int v6; // t1
  int v7; // r3
  bool v8; // cc
  int v9; // r3
  int v10; // r2
  _DWORD *v11; // r1

  v1 = total_pools;
  v2 = total_pools - 1;
  if ( total_pools > 0 )
  {
    v3 = (int *)pools;
    v4 = pools + 4 * total_pools;
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= *(_DWORD *)(result + 4);
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != (int *)v4 );
  }
  if ( v2 > *(_DWORD *)result )
  {
    v10 = pools;
    v11 = *(_DWORD **)(pools + 4 * v2);
    *v11 = *(_DWORD *)result;
    *(_DWORD *)(v10 + 4 * *(_DWORD *)result) = v11;
  }
  *(_DWORD *)result = v1;
  *(_BYTE *)(result + 105) = 1;
  total_pools = v2;
  return result;
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (0001CFC0) --------------------------------------------------------
void __fastcall write_config(FILE *s)
{
  int v2; // r6
  const char *v3; // r0
  const char *v4; // r0
  int v5; // r0
  int v6; // r3
  int v7; // r4
  char *v8; // r1
  const char *v9; // r9
  char *v10; // r0
  const char *v11; // r10
  const char *v12; // r0
  const char *v13; // r0
  char *v14; // r2
  const char *v15; // r8
  const char *v16; // r0
  char *v17; // r2
  const char *v18; // r8
  const char *v19; // r10
  char *v20; // r0
  const char *v21; // r9
  const char *v22; // r0
  char *v23; // r3
  const char *v24; // r0
  const char *v25; // r0
  char **v26; // r4
  char *v27; // r8
  char *v28; // r11
  int v29; // r1
  int (__fastcall *v30)(_BYTE *); // r2
  bool v31; // zf
  int (*v32)(); // r2
  bool v33; // zf
  int v34; // r3
  bool v35; // zf
  const char **v36; // r3
  const char *v37; // r0
  int v38; // r1
  int v39; // r4
  int v40; // r5
  void *v41; // r0
  const char *v42; // [sp+14h] [bp-34h]
  const char *v43; // [sp+14h] [bp-34h]
  int v44; // [sp+18h] [bp-30h]

  fwrite("{\n\"pools\" : [", 1u, 13u, s);
  if ( total_pools > 0 )
  {
    v2 = 0;
    do
    {
      v5 = priority_pool(v2);
      v6 = *(_DWORD *)(v5 + 56);
      v7 = v5;
      if ( v6 == 1 )
      {
        v17 = ",";
        if ( v2 <= 0 )
          v17 = "";
        v18 = v17;
        if ( *(_DWORD *)(v5 + 184) )
        {
          v19 = "";
          v20 = proxytype(*(char **)(v5 + 180));
          v21 = json_escape(v20);
          v22 = *(const char **)(v7 + 184);
          v23 = "";
          if ( v22 )
          {
            v24 = json_escape(v22);
            v23 = "|";
            v19 = v24;
            if ( !*(_DWORD *)(v7 + 184) )
              v23 = "";
          }
        }
        else
        {
          v19 = "";
          v21 = "";
          v23 = "";
        }
        v43 = v23;
        v25 = json_escape(*(const char **)(v7 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v18, v21, v19, v43, v25);
      }
      else
      {
        v8 = ",";
        if ( v2 <= 0 )
          v8 = "";
        v9 = v8;
        if ( *(_DWORD *)(v5 + 184) )
        {
          v10 = proxytype(*(char **)(v5 + 180));
          v11 = json_escape(v10);
          v12 = *(const char **)(v7 + 184);
          if ( v12 )
          {
            v13 = json_escape(v12);
            v14 = "|";
            v6 = *(_DWORD *)(v7 + 56);
            v15 = v13;
            if ( !*(_DWORD *)(v7 + 184) )
              v14 = "";
          }
          else
          {
            v6 = *(_DWORD *)(v7 + 56);
            v15 = "";
            v14 = "";
          }
        }
        else
        {
          v15 = "";
          v11 = "";
          v14 = "";
        }
        v44 = v6;
        v42 = v14;
        v16 = json_escape(*(const char **)(v7 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v9, v11, v15, v42, v44, v16);
      }
      if ( *(_BYTE *)(v7 + 580) )
        fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 33u, s);
      ++v2;
      v3 = json_escape(*(const char **)(v7 + 172));
      fprintf(s, "\n\t\t\"user\" : \"%s\",", v3);
      v4 = json_escape(*(const char **)(v7 + 176));
      fprintf(s, "\n\t\t\"pass\" : \"%s\"\n\t}", v4);
    }
    while ( total_pools > v2 );
  }
  fwrite("\n]\n", 1u, 3u, s);
  if ( dword_7D6AC != 16 )
  {
    v26 = &off_7D6C4;
    while ( 1 )
    {
      v27 = _strdup(*(v26 - 7));
      v28 = strtok(v27, "|");
      if ( v28 )
        break;
LABEL_75:
      v26 += 7;
      free(v27);
      if ( *(v26 - 6) == (char *)16 )
        goto LABEL_76;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v28[1] != 45 || *(v26 - 1) == (char *)&opt_hidden )
          goto LABEL_26;
        v29 = (int)*(v26 - 6);
        if ( (v29 & 1) != 0 )
        {
          v30 = (int (__fastcall *)(_BYTE *))*(v26 - 5);
          v31 = v30 == opt_set_bool;
          if ( v30 != opt_set_bool )
            v31 = v30 == opt_set_invbool;
          if ( v31 && **(v26 - 2) == (v30 == opt_set_bool) )
          {
            fprintf(s, ",\n\"%s\" : true", v28 + 2);
            goto LABEL_26;
          }
        }
        if ( (v29 & 2) != 0 )
          break;
LABEL_71:
        if ( (v29 & 6) == 0 )
          goto LABEL_26;
        v36 = (const char **)*(v26 - 2);
        if ( v36 == (const char **)&opt_set_null || !*v36 )
          goto LABEL_26;
        v37 = json_escape(*v36);
        fprintf(s, ",\n\"%s\" : \"%s\"", v28 + 2, v37);
        v28 = strtok(0, "|");
        if ( !v28 )
          goto LABEL_75;
      }
      v32 = (int (*)())*(v26 - 4);
      v33 = v32 == opt_set_intval;
      if ( v32 != opt_set_intval )
        v33 = v32 == set_int_0_to_9999;
      v34 = v33;
      if ( v32 == set_int_1_to_65535 )
        v34 |= 1u;
      if ( v32 == set_int_0_to_10 )
        v34 |= 1u;
      if ( v32 == set_int_1_to_10 )
        v34 |= 1u;
      if ( v32 == set_int_0_to_100 )
        v34 |= 1u;
      if ( v32 == set_int_0_to_255 )
        v34 |= 1u;
      if ( v32 == set_int_1_to_255 )
        v34 |= 1u;
      if ( v32 == set_int_0_to_7680 )
        v34 |= 1u;
      if ( v32 == set_int_0_to_200 )
        v34 |= 1u;
      if ( v32 == set_int_0_to_4 )
        v34 |= 1u;
      if ( v32 == set_int_32_to_63 )
        v34 |= 1u;
      if ( v32 == set_int_22_to_75 )
        v34 |= 1u;
      if ( v32 == set_int_42_to_85 )
        v34 |= 1u;
      if ( v32 == set_int_22_to_55 )
        v34 |= 1u;
      if ( v32 == set_int_42_to_65 )
        v34 |= 1u;
      if ( !v34 )
      {
        v35 = v32 == set_float_100_to_250;
        if ( v32 != set_float_100_to_250 )
          v35 = v32 == set_float_125_to_500;
        if ( v35 )
        {
          fprintf(s, ",\n\"%s\" : \"%.1f\"", v28 + 2, *(float *)*(v26 - 2));
          goto LABEL_26;
        }
        goto LABEL_71;
      }
      fprintf(s, ",\n\"%s\" : \"%d\"", v28 + 2, *(_DWORD *)*(v26 - 2));
LABEL_26:
      v28 = strtok(0, "|");
      if ( !v28 )
        goto LABEL_75;
    }
  }
LABEL_76:
  v38 = pool_strategy;
  if ( pool_strategy == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 18u, s);
    v38 = pool_strategy;
    if ( pool_strategy != 3 )
      goto LABEL_78;
  }
  else if ( pool_strategy != 3 )
  {
    goto LABEL_78;
  }
  fwrite(",\n\"load-balance\" : true", 1u, 23u, s);
  v38 = pool_strategy;
LABEL_78:
  if ( v38 == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 22u, s);
    v38 = pool_strategy;
  }
  if ( v38 == 2 )
    fprintf(s, ",\n\"rotate\" : \"%d\"", opt_rotate_period);
  fwrite("\n}\n", 1u, 3u, s);
  v39 = jedata;
  jedata = 0;
  if ( v39 )
  {
    do
    {
      v40 = *(_DWORD *)(v39 + 4);
      free(*(void **)v39);
      v41 = (void *)v39;
      v39 = v40;
      free(v41);
    }
    while ( v40 );
  }
}
// 1BFA8: using guessed type int set_float_100_to_250();
// 1BFF4: using guessed type int set_float_125_to_500();
// 1C518: using guessed type int set_int_42_to_65();
// 1C538: using guessed type int set_int_22_to_55();
// 1C558: using guessed type int set_int_42_to_85();
// 1C578: using guessed type int set_int_22_to_75();
// 1C598: using guessed type int set_int_32_to_63();
// 1C5B8: using guessed type int set_int_0_to_4();
// 1C5D8: using guessed type int set_int_0_to_200();
// 1C5F8: using guessed type int set_int_0_to_7680();
// 1C618: using guessed type int set_int_1_to_255();
// 1C638: using guessed type int set_int_0_to_255();
// 1C658: using guessed type int set_int_0_to_100();
// 1C678: using guessed type int set_int_1_to_10();
// 1C698: using guessed type int set_int_0_to_10();
// 1C6B8: using guessed type int set_int_1_to_65535();
// 1C6DC: using guessed type int set_int_0_to_9999();
// 4DF20: using guessed type int opt_set_intval();
// 7D6AC: using guessed type int dword_7D6AC;
// 7D6C4: using guessed type char *off_7D6C4;
// 80B6C: using guessed type int jedata;
// 80F6C: using guessed type int pool_strategy;
// 80BAEC: using guessed type int total_pools;
// 80BB84: using guessed type int opt_rotate_period;

//----- (0001D488) --------------------------------------------------------
int zero_bestshare()
{
  int result; // r0
  int *v1; // r2
  int v2; // r4
  int v3; // t1

  *(_DWORD *)best_share = 0;
  dword_7DED4 = 0;
  best_diff = 0;
  dword_80F8C = 0;
  result = suffix_string(0LL, best_share, 8u, 0);
  if ( total_pools > 0 )
  {
    result = 0;
    v1 = (int *)pools;
    v2 = pools + 4 * total_pools;
    do
    {
      v3 = *v1++;
      *(_DWORD *)(v3 + 368) = 0;
      *(_DWORD *)(v3 + 372) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  return result;
}
// 7DED4: using guessed type int dword_7DED4;
// 80F88: using guessed type int best_diff;
// 80F8C: using guessed type int dword_80F8C;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (0001D4F0) --------------------------------------------------------
char *__fastcall default_save_file(char *a1)
{
  size_t v2; // r0
  char *v3; // r5
  size_t v4; // r6
  char *result; // r0
  char *v6; // r0

  if ( default_config && *(_BYTE *)default_config )
    return j_strcpy(a1, (const char *)default_config);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    strcpy((char *)stpcpy(a1, v6), "/");
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".bmminer/");
  mkdir(a1, 511u);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  result = *(char **)"bmminer.conf";
  *(_DWORD *)&a1[v4] = *(_DWORD *)"bmminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return result;
}
// 12138: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 80B64: using guessed type int default_config;

//----- (0001D598) --------------------------------------------------------
void __fastcall set_target(void *a1)
{
  double v1; // d0
  unsigned __int64 v3; // r6
  double v4; // d8
  int v5; // r10
  int v6; // r11
  unsigned __int64 v7; // kr00_8
  double v8; // d8
  int v9; // r8
  int v10; // r9
  unsigned __int64 v11; // kr08_8
  unsigned __int64 v12; // r0
  char *v13; // r6
  unsigned __int64 v14; // [sp+8h] [bp-850h] BYREF
  int v15; // [sp+10h] [bp-848h]
  int v16; // [sp+14h] [bp-844h]
  int v17; // [sp+18h] [bp-840h]
  int v18; // [sp+1Ch] [bp-83Ch]
  unsigned __int64 v19; // [sp+20h] [bp-838h]
  char s[2096]; // [sp+28h] [bp-830h] BYREF

  if ( v1 == 0.0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v3 = 4294901760LL;
      strcpy(s, "Diff zero passed to set_target");
      applog(3, s, 0);
      v12 = 0LL;
      v10 = 0;
      v6 = 0;
      v9 = 0;
      v5 = 0;
    }
    else
    {
      v12 = 0LL;
      v3 = 4294901760LL;
      v10 = 0;
      v6 = 0;
      v9 = 0;
      v5 = 0;
    }
  }
  else
  {
    v3 = (unsigned __int64)(2.69595353e67 / v1 * 1.59309191e-58);
    v4 = 2.69595353e67 / v1 - (double)v3 * 6.27710174e57;
    v7 = (unsigned __int64)(v4 * 2.93873588e-39);
    v5 = HIDWORD(v7);
    v6 = v7;
    v8 = v4 - (double)v7 * 3.40282367e38;
    v11 = (unsigned __int64)(v8 * 5.42101086e-20);
    v9 = HIDWORD(v11);
    v10 = v11;
    v12 = (unsigned __int64)(v8 - (double)v11 * 1.84467441e19);
  }
  v19 = v3;
  v17 = v6;
  v18 = v5;
  v15 = v10;
  v16 = v9;
  v14 = v12;
  if ( opt_debug )
  {
    v13 = bin2hex((unsigned __int8 *)&v14, 32);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "Generated target %s", v13);
      applog(7, s, 0);
    }
    free(v13);
  }
  cg_memcpy(a1, &v14, 32u, (int)"cgminer.c", (int)"set_target", 8219);
}
// 1D5AE: variable 'v1' is possibly undefined
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (0001D794) --------------------------------------------------------
int __fastcall share_work_tdiff(int a1)
{
  return last_getwork - *(_DWORD *)(a1 + 232);
}
// 80CBBC: using guessed type int last_getwork;

//----- (0001D7A8) --------------------------------------------------------
bool __fastcall test_nonce(int a1, int a2)
{
  *(_DWORD *)(a1 + 76) = a2;
  regen_hash(a1);
  return *(_DWORD *)(a1 + 220) == 0;
}

//----- (0001D7C0) --------------------------------------------------------
bool __fastcall test_nonce_diff(int a1, int a2)
{
  double v2; // d0

  *(_DWORD *)(a1 + 76) = a2;
  regen_hash(a1);
  return (unsigned __int64)(4294901760.0 / v2) >= *(_QWORD *)(a1 + 216);
}
// 1D7DA: variable 'v2' is possibly undefined

//----- (0001D800) --------------------------------------------------------
void __fastcall cg_savelogwork(int a1, unsigned __int8 *a2)
{
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int v10; // r5
  size_t v11; // r4
  int v12; // r1
  int v13; // r2
  char *v14; // r6
  int v15; // r1
  int v16; // r3
  int v17; // r2
  int v18; // r1
  int v19; // r2
  int v20; // r3
  char *v21; // r10
  char *v22; // r9
  _BYTE *v23; // r11
  int v24; // r2
  int v25; // t1
  unsigned int v26; // r1
  unsigned int v27; // r3
  unsigned int v28; // r0
  char v29; // r2
  bool v30; // zf
  char v31; // r2
  size_t v32; // r0
  char *v33; // [sp+Ch] [bp-4A4h]
  _BYTE *ptr; // [sp+10h] [bp-4A0h]
  _BYTE *v35; // [sp+14h] [bp-49Ch]
  char v36[4]; // [sp+18h] [bp-498h]
  char v37[12]; // [sp+1Ch] [bp-494h] BYREF
  _DWORD v38[8]; // [sp+28h] [bp-488h] BYREF
  _DWORD v39[8]; // [sp+48h] [bp-468h] BYREF
  _DWORD v40[8]; // [sp+68h] [bp-448h] BYREF
  char s[1064]; // [sp+88h] [bp-428h] BYREF

  if ( !fd_log )
    fd_log = (int)fopen("/etc/config/worklog.txt", "wb");
  memset(s, 0, 1024u);
  memset(v39, 0, sizeof(v39));
  v4 = *(_DWORD *)(a1 + 132);
  v5 = *(_DWORD *)(a1 + 136);
  v6 = *(_DWORD *)(a1 + 140);
  v38[0] = *(_DWORD *)(a1 + 128);
  v38[1] = v4;
  v38[2] = v5;
  v38[3] = v6;
  v7 = *(_DWORD *)(a1 + 148);
  v8 = *(_DWORD *)(a1 + 152);
  v9 = *(_DWORD *)(a1 + 156);
  v10 = 0;
  v38[4] = *(_DWORD *)(a1 + 144);
  v38[5] = v7;
  v38[6] = v8;
  v38[7] = v9;
  v11 = 0;
  v12 = *(_DWORD *)(a1 + 68);
  v13 = *(_DWORD *)(a1 + 72);
  v14 = v37;
  v39[0] = *(_DWORD *)(a1 + 64);
  v39[1] = v12;
  v39[2] = v13;
  v15 = *(_DWORD *)(a1 + 196);
  v16 = *(_DWORD *)(a1 + 204);
  v17 = *(_DWORD *)(a1 + 200);
  v40[0] = *(_DWORD *)(a1 + 192);
  v40[1] = v15;
  v40[2] = v17;
  v40[3] = v16;
  v18 = *(_DWORD *)(a1 + 212);
  v19 = *(_DWORD *)(a1 + 216);
  v20 = *(_DWORD *)(a1 + 220);
  v40[4] = *(_DWORD *)(a1 + 208);
  v40[5] = v18;
  v40[6] = v19;
  v40[7] = v20;
  rev((char *)v38, 32);
  rev((char *)v39, 12);
  rev((char *)v40, 32);
  ptr = bin2hex((unsigned __int8 *)a1, 128);
  v21 = bin2hex((unsigned __int8 *)v38, 32);
  v22 = bin2hex((unsigned __int8 *)v39, 12);
  v33 = bin2hex(a2, 4);
  v35 = bin2hex(a2, 5);
  v23 = bin2hex((unsigned __int8 *)v40, 32);
  while ( v11 < strlen(v37) )
  {
    v25 = (unsigned __int8)*v14++;
    v24 = v25;
    v26 = v25 - 97;
    v27 = (unsigned __int8)(v25 - 48);
    if ( v27 > 9 )
    {
      LOBYTE(v27) = v24 - 55;
      v28 = v24 - 65;
      v29 = v24 - 87;
      if ( v26 > 5 )
      {
        if ( v28 > 5 )
          break;
      }
      else
      {
        LOBYTE(v27) = v29;
      }
    }
    v30 = (v11 & 1) == 0;
    v31 = 16 * v27;
    if ( (v11 & 1) != 0 )
      v31 = v36[v10];
    ++v11;
    if ( v30 )
      v36[v10] = v31;
    else
      v36[v10++] = v27 + v31;
  }
  sprintf(s, "midstate %s data %s nonce %s \r\n", v21, v22, v33);
  v32 = strlen(s);
  fwrite(s, v32, 1u, (FILE *)fd_log);
  fflush((FILE *)fd_log);
  if ( ptr )
    free(ptr);
  if ( v21 )
    free(v21);
  if ( v22 )
    free(v22);
  if ( v33 )
    free(v33);
  if ( v35 )
    free(v35);
  if ( v23 )
    free(v23);
}
// 80F90: using guessed type int fd_log;
// 1D800: using guessed type char var_498[4];

//----- (0001D9CC) --------------------------------------------------------
void __fastcall cg_savelogwork_uint32(int a1, int a2)
{
  int v2; // [sp+0h] [bp-10h] BYREF
  char v3; // [sp+4h] [bp-Ch]

  v2 = a2;
  v3 = 0;
  cg_savelogwork(a1, (unsigned __int8 *)&v2);
}

//----- (0001D9E4) --------------------------------------------------------
void __fastcall savelog_nonce(int a1, int a2)
{
  int v4; // [sp+0h] [bp-18h] BYREF
  char v5; // [sp+4h] [bp-14h]

  *(_DWORD *)(a1 + 76) = a2;
  regen_hash(a1);
  if ( !*(_DWORD *)(a1 + 220) )
  {
    v4 = a2;
    v5 = 0;
    cg_savelogwork(a1, (unsigned __int8 *)&v4);
  }
}

//----- (0001DA0C) --------------------------------------------------------
unsigned int __fastcall _add_queued(int a1, int a2)
{
  int v4; // r7
  int v5; // r5
  int v6; // r0
  int v7; // r7
  int v8; // r5
  int v9; // r0
  unsigned int v10; // r1
  unsigned int v11; // r3
  unsigned int v12; // r2
  int v13; // r1
  unsigned int v14; // r3
  unsigned int v15; // r2
  int v16; // r1
  unsigned int v17; // r5
  int v18; // r6
  int v19; // r3
  int v20; // r1
  unsigned int *v21; // r2
  unsigned int result; // r0
  int v23; // r3
  int v24; // r3
  int v25; // r5
  unsigned int v26; // r1
  int v27; // r2
  void **v28; // r10
  _DWORD *v29; // r7
  char *v30; // r3
  unsigned int v31; // r1
  char *v32; // r2
  unsigned int v33; // r9
  int v34; // r11
  _DWORD *v35; // r5
  _DWORD *v36; // r8
  int v37; // r4
  char *v38; // r6
  unsigned int v39; // r0
  int v40; // r3
  bool v41; // zf
  _DWORD *v42; // r3
  int v43; // r1
  int v44; // r2
  unsigned int v45; // r4
  int v46; // r2
  int v47; // r1
  unsigned int v48; // r2
  _DWORD *v49; // r0
  _DWORD *v50; // r7
  void *v51; // r0
  int v52; // [sp+8h] [bp-38h]
  char *ptr; // [sp+10h] [bp-30h]
  int v55; // [sp+14h] [bp-2Ch]

  ++*(_DWORD *)(a1 + 360);
  v4 = *(unsigned __int8 *)(a2 + 340);
  v5 = *(unsigned __int8 *)(a2 + 343);
  *(_DWORD *)(a2 + 364) = a2 + 340;
  v6 = v4 + 17973517;
  v7 = *(unsigned __int8 *)(a2 + 342);
  *(_DWORD *)(a2 + 368) = 4;
  v8 = v6 + (v5 << 24);
  v9 = *(_DWORD *)(a1 + 352);
  v10 = (unsigned int)&unk_7F76D ^ (v8 + (v7 << 16) + (*(unsigned __int8 *)(a2 + 341) << 8));
  v11 = (-1622558010 - v10) ^ (v10 << 8);
  v12 = (-17973517 - v10 - v11) ^ (v11 >> 13);
  v13 = (v10 - v11 - v12) ^ (v12 >> 12);
  v14 = (v11 - v12 - v13) ^ (v13 << 16);
  v15 = (v12 - v13 - v14) ^ (v14 >> 5);
  v16 = (v13 - v14 - v15) ^ (v15 >> 3);
  v17 = (v15 - v16 - ((v14 - v15 - v16) ^ (v16 << 10))) ^ (((v14 - v15 - v16) ^ (v16 << 10)) >> 15);
  *(_DWORD *)(a2 + 372) = v17;
  if ( v9 )
  {
    *(_DWORD *)(a2 + 344) = *(_DWORD *)(v9 + 344);
    v18 = a2 + 344;
    v19 = *(_DWORD *)(v9 + 344);
    *(_DWORD *)(a2 + 352) = 0;
    v20 = *(_DWORD *)(v19 + 16);
    *(_DWORD *)(a2 + 348) = v20 - *(_DWORD *)(v19 + 20);
    *(_DWORD *)(v20 + 8) = a2;
    *(_DWORD *)(v19 + 16) = a2 + 344;
  }
  else
  {
    *(_DWORD *)(a2 + 352) = 0;
    *(_DWORD *)(a2 + 348) = 0;
    *(_DWORD *)(a1 + 352) = a2;
    v49 = calloc(44u, 1u);
    v50 = v49;
    *(_DWORD *)(a2 + 344) = v49;
    if ( !v49 )
      goto LABEL_32;
    v49[1] = 32;
    v18 = a2 + 344;
    v49[4] = a2 + 344;
    v49[2] = 5;
    v49[5] = 344;
    v51 = calloc(384u, 1u);
    *v50 = v51;
    if ( !v51 )
      goto LABEL_32;
    v9 = *(_DWORD *)(a1 + 352);
    v50[10] = -1609490463;
  }
  v21 = *(unsigned int **)(v9 + 344);
  result = *v21;
  v23 = 3 * ((v21[1] - 1) & v17);
  ++v21[3];
  v24 = 4 * v23;
  v25 = *(_DWORD *)(result + v24);
  v26 = *(_DWORD *)(result + v24 + 4) + 1;
  *(_DWORD *)(result + v24 + 4) = v26;
  *(_DWORD *)(a2 + 360) = v25;
  *(_DWORD *)(a2 + 356) = 0;
  if ( v25 )
    *(_DWORD *)(v25 + 12) = v18;
  v27 = *(_DWORD *)(result + v24 + 8);
  *(_DWORD *)(result + v24) = v18;
  if ( v26 >= 10 * (v27 + 1) )
  {
    v28 = *(void ***)(a2 + 344);
    if ( v28[9] != (void *)1 )
    {
      v29 = calloc(24 * (_DWORD)v28[1], 1u);
      if ( v29 )
      {
        v30 = (char *)v28[1];
        v31 = (unsigned int)v28[3];
        v32 = (char *)v28[2];
        v28[7] = 0;
        v33 = v31 >> ((_BYTE)v32 + 1);
        v34 = 2 * (_DWORD)v30 - 1;
        if ( (v31 & v34) != 0 )
          ++v33;
        v28[6] = (void *)v33;
        if ( v30 )
        {
          v52 = 0;
          ptr = (char *)*v28;
          v55 = 12 * (_DWORD)v30;
          do
          {
            v35 = *(_DWORD **)&ptr[v52];
            if ( v35 )
            {
              do
              {
                v36 = (_DWORD *)v35[4];
                v37 = 3 * (v34 & v35[7]);
                v38 = (char *)&v29[3 * (v34 & v35[7])];
                v39 = *((_DWORD *)v38 + 1) + 1;
                *((_DWORD *)v38 + 1) = v39;
                if ( v33 < v39 )
                {
                  v28[7] = (char *)v28[7] + 1;
                  *((_DWORD *)v38 + 2) = v39 / v33;
                }
                v40 = v29[v37];
                v35[3] = 0;
                v35[4] = v40;
                if ( v40 )
                  *(_DWORD *)(v40 + 12) = v35;
                v29[v37] = v35;
                v35 = v36;
              }
              while ( v36 );
            }
            v41 = v55 == v52 + 12;
            v52 += 12;
          }
          while ( !v41 );
          free(ptr);
        }
        else
        {
          free(*v28);
        }
        v42 = *(_DWORD **)(a2 + 344);
        result = v42[7];
        v43 = v42[1];
        v44 = v42[2];
        v45 = v42[3];
        *v42 = v29;
        v46 = v44 + 1;
        v47 = 2 * v43;
        v42[2] = v46;
        if ( result <= v45 >> 1 )
          v46 = 0;
        v42[1] = v47;
        if ( result > v45 >> 1 )
        {
          v48 = v42[8] + 1;
          v42[8] = v48;
          if ( v48 > 1 )
            v42[9] = 1;
        }
        else
        {
          v42[8] = v46;
        }
        return result;
      }
LABEL_32:
      exit(-1);
    }
  }
  return result;
}

//----- (0001DC8C) --------------------------------------------------------
int __fastcall _find_work_bymidstate(int a1, void *s2, size_t n, const void *a4, int a5, size_t na)
{
  int v6; // r5
  int v9; // r4

  v6 = a1;
  if ( a1 )
  {
    v9 = *(_DWORD *)(a1 + 352);
    while ( memcmp((const void *)(v6 + 128), s2, n) || memcmp((const void *)(v6 + a5), a4, na) )
    {
      if ( !v9 )
        return v9;
      v6 = v9;
      v9 = *(_DWORD *)(v9 + 352);
    }
  }
  return v6;
}

//----- (0001DCD0) --------------------------------------------------------
int __fastcall _find_work_byid(int result, int a2)
{
  int v2; // r3
  int v3; // r0

  if ( result )
  {
    v2 = *(_DWORD *)(result + 352);
    if ( a2 != *(_DWORD *)(result + 340) )
    {
      if ( v2 )
      {
        do
        {
          v3 = *(_DWORD *)(v2 + 352);
          if ( *(_DWORD *)(v2 + 340) == a2 )
            break;
          v2 = *(_DWORD *)(v2 + 352);
        }
        while ( v3 );
      }
      return v2;
    }
  }
  return result;
}

//----- (0001DCFC) --------------------------------------------------------
void __fastcall _work_completed(int a1, _DWORD *a2)
{
  int v2; // r5
  int v3; // r3
  _DWORD *v4; // r4
  int v5; // r6
  int v6; // r2
  _DWORD *v7; // r0
  int v8; // r2
  int v9; // r0
  int *v10; // r2
  int v11; // r5
  int v12; // r3
  _DWORD *v13; // r7
  int v14; // r0
  int v15; // r3
  int v16; // r6
  int v17; // r2
  int v18; // r7

  v2 = a2[87];
  --*(_DWORD *)(a1 + 360);
  if ( v2 )
  {
    v3 = *(_DWORD *)(a1 + 352);
    v4 = a2 + 86;
    v5 = *(_DWORD *)(v3 + 344);
    v6 = *(_DWORD *)(v5 + 20);
    v7 = (_DWORD *)(*(_DWORD *)(v5 + 16) - v6);
    v8 = v6 + v2;
    if ( a2 == v7 )
      *(_DWORD *)(v5 + 16) = v8;
    *(_DWORD *)(v8 + 8) = a2[88];
  }
  else
  {
    v16 = a2[88];
    if ( !v16 )
    {
      free(**(void ***)(*(_DWORD *)(a1 + 352) + 344));
      free(*(void **)(*(_DWORD *)(a1 + 352) + 344));
      *(_DWORD *)(a1 + 352) = 0;
      return;
    }
    v4 = a2 + 86;
    v17 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 344);
    v18 = *(_DWORD *)(v17 + 20);
    v3 = a2[88];
    if ( a2 == (_DWORD *)(*(_DWORD *)(v17 + 16) - v18) )
      *(_DWORD *)(v17 + 16) = v18;
    *(_DWORD *)(a1 + 352) = v16;
  }
  v9 = a2[88];
  v10 = *(int **)(v3 + 344);
  if ( v9 )
    *(_DWORD *)(v10[5] + v9 + 4) = v2;
  v11 = *v10;
  v12 = 12 * (a2[93] & (v10[1] - 1));
  v13 = *(_DWORD **)(*v10 + v12);
  --*(_DWORD *)(*v10 + v12 + 4);
  v14 = a2[90];
  if ( v13 == v4 )
    *(_DWORD *)(v11 + v12) = v14;
  v15 = a2[89];
  if ( v15 )
  {
    *(_DWORD *)(v15 + 16) = v14;
    v14 = a2[90];
  }
  if ( v14 )
    *(_DWORD *)(v14 + 12) = v15;
  --v10[3];
}

//----- (0001DDCC) --------------------------------------------------------
int __fastcall reinit_device(int a1)
{
  if ( *(_DWORD *)(a1 + 32) != 1 )
    return reinit_device_part_38(a1);
  return a1;
}

//----- (0001DDD8) --------------------------------------------------------
void __fastcall __noreturn _quit(int a1, int a2)
{
  pthread_t newthread; // [sp+4h] [bp-Ch] BYREF

  if ( !pthread_create(&newthread, 0, (void *(*)(void *))killall_thread, 0) )
  {
    if ( a2 )
      clean_up(0);
    if ( forkpid > 0 )
    {
      kill(forkpid, 15);
      forkpid = 0;
    }
    pthread_cancel(newthread);
    exit(a1);
  }
  exit(1);
}
// 80F94: using guessed type int forkpid;

//----- (0001DE2C) --------------------------------------------------------
void __noreturn kill_work()
{
  char v0[2056]; // [sp+0h] [bp-808h] BYREF

  cg_completion_timeout((int)_kill_work, 0, 5000);
  strcpy(v0, "Shutdown signal received.");
  applog(3, v0, 1);
  _quit(0, 1);
}
// 20794: using guessed type int _kill_work();

//----- (0001DE6C) --------------------------------------------------------
void __noreturn sighandler()
{
  sigaction(15, &termhandler, 0);
  sigaction(2, &inthandler, 0);
  sigaction(6, &abrthandler, 0);
  kill_work();
}
// 1DE6C: using guessed type void __noreturn sighandler();

//----- (0001DEA4) --------------------------------------------------------
int __fastcall get_statline(char *a1, size_t a2, int a3)
{
  double v3; // d0
  double v7; // d8
  unsigned __int64 v8; // r8
  char v10[16]; // [sp+28h] [bp-8A0h] BYREF
  char v11[16]; // [sp+38h] [bp-890h] BYREF
  char s[64]; // [sp+48h] [bp-880h] BYREF
  char v13[2112]; // [sp+88h] [bp-840h] BYREF

  cgpu_runtime(a3);
  v7 = (double)*(__int64 *)(a3 + 192) / v3 * 60.0;
  v8 = (unsigned __int64)(*(double *)(a3 + 48) * 1000000.0);
  suffix_string((unsigned __int64)(*(double *)(a3 + 80) / v3 * 1000000.0), v10, 16u, 4);
  suffix_string(v8, v11, 16u, 4);
  snprintf(a1, a2, "%s%d ", *(const char **)(*(_DWORD *)(a3 + 4) + 8), *(_DWORD *)(a3 + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 20))(a1, a2, a3);
  LODWORD(v8) = strlen(a1);
  snprintf(
    s,
    64u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    opt_log_interval,
    v11,
    v10,
    *(double *)(a3 + 200),
    *(double *)(a3 + 208),
    *(_DWORD *)(a3 + 44),
    v7);
  if ( a2 <= strlen(s) + (unsigned int)v8 )
  {
    snprintf(v13, 2048u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3057);
    applog(3, v13, 1);
    _quit(1);
  }
  strcat(a1, s);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 24))(a1, a2, a3);
}
// 1DEDE: variable 'v3' is possibly undefined
// 1DDD8: using guessed type void __fastcall __noreturn _quit(_DWORD);
// 40CA0: using guessed type int __fastcall applog(_DWORD, _DWORD, _DWORD);
// 7DED8: using guessed type int opt_log_interval;

//----- (0001E00C) --------------------------------------------------------
void __noreturn restart_threads_part_59()
{
  char v0[2056]; // [sp+0h] [bp-808h] BYREF

  strcpy(v0, "Failed to create restart thread");
  applog(3, v0, 1);
  _quit(1, 1);
}

//----- (0001E03C) --------------------------------------------------------
int restart_threads()
{
  int result; // r0
  pthread_t newthread; // [sp+4h] [bp-Ch] BYREF

  cgtime(&restart_tv_start);
  result = pthread_create(&newthread, 0, (void *(*)(void *))restart_thread, 0);
  if ( result )
    restart_threads_part_59();
  return result;
}
// 24020: using guessed type int restart_thread();
// 80F74: using guessed type struct timeval restart_tv_start;

//----- (0001E068) --------------------------------------------------------
int __fastcall benchfile_get_work(_BYTE *a1)
{
  int v2; // r4
  bool v3; // zf
  bool v4; // r4
  _BOOL4 v5; // r4
  int v6; // r5
  char *v7; // r0
  char **v8; // r11
  int v9; // r9
  char *v10; // r2
  int v11; // r1
  int v12; // r6
  char *v13; // r0
  int v14; // r9
  char *v15; // r6
  bool v16; // zf
  int result; // r0
  signed int v18; // r0
  size_t v19; // r10
  char *v20; // r9
  const char *v21; // r5
  const char *v22; // r6
  const char *v23; // r2
  char *v24; // r9
  const char *v25; // r5
  const char *v26; // r6
  const char *v27; // r2
  int v28; // r0
  FILE *v29; // r2
  const char *nptr; // [sp+14h] [bp-C44h]
  char *v31; // [sp+1Ch] [bp-C3Ch] BYREF
  int v32; // [sp+20h] [bp-C38h]
  int v33; // [sp+24h] [bp-C34h]
  char *src; // [sp+28h] [bp-C30h]
  char *v35; // [sp+2Ch] [bp-C2Ch]
  char s[1024]; // [sp+30h] [bp-C28h] BYREF
  char v37[2088]; // [sp+430h] [bp-828h] BYREF

  v2 = benchfile_in;
  if ( benchfile_in )
  {
    if ( fgets(s, 1024, (FILE *)benchfile_in) )
      goto LABEL_5;
LABEL_22:
    if ( benchfile_work )
    {
      fclose((FILE *)benchfile_in);
      benchfile_in = 0;
      return benchfile_get_work(a1);
    }
    snprintf(v37, 2048u, "BENCHFILE No work in benchfile '%s'", opt_benchfile);
LABEL_21:
    applog(3, v37, 1);
    _quit(1, 1);
  }
  if ( !opt_benchfile )
  {
    strcpy(v37, "BENCHFILE Invalid benchfile NULL");
    applog(3, v37, 1);
    _quit(1, 1);
  }
  v29 = fopen((const char *)opt_benchfile, "r");
  benchfile_in = (int)v29;
  if ( !v29 )
  {
    snprintf(v37, 2048u, "BENCHFILE Failed to open benchfile '%s'", opt_benchfile);
    goto LABEL_21;
  }
  benchfile_line = v2;
  if ( !fgets(s, 1024, v29) )
  {
    snprintf(v37, 2048u, "BENCHFILE Failed to read benchfile '%s'", opt_benchfile);
    goto LABEL_21;
  }
  benchfile_work = v2;
  while ( 1 )
  {
LABEL_5:
    v3 = s[0] == 0;
    if ( s[0] )
      v3 = s[0] == 35;
    v4 = !v3;
    v5 = s[0] != 47 && v4;
    v6 = ++benchfile_line;
    if ( v5 )
      break;
    if ( !fgets(s, 1024, (FILE *)benchfile_in) )
      goto LABEL_22;
  }
  v7 = s;
  v8 = &v31;
  v9 = 0;
  v31 = s;
  do
  {
    v10 = strchr(v7, 44);
    v8[1] = v10;
    v11 = v9 + 1;
    if ( !v10 )
    {
      snprintf(v37, 2048u, "BENCHFILE Invalid input file line %d - field count is %d but should be %d", v6, v9 + 1, 5);
      goto LABEL_21;
    }
    v12 = (int)*v8++;
    v13 = (char *)benchfile_data[2 * v9];
    v14 = 8 * v9;
    v15 = &v10[-v12];
    v16 = v15 == v13;
    if ( v15 != v13 )
      v16 = v13 == 0;
    if ( !v16 )
    {
      snprintf(
        v37,
        2048u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
        v6,
        v11,
        *(const char **)&_func___14516[v14 + 160],
        v15,
        v13);
      goto LABEL_21;
    }
    v7 = v10 + 1;
    v9 = v11;
    *v10 = 0;
    *v8 = v10 + 1;
  }
  while ( v11 != 4 );
  nptr = v35;
  v18 = strlen(v35);
  if ( v18 <= 9 )
  {
    snprintf(
      v37,
      2048u,
      "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
      v6,
      5,
      "NonceTime",
      v18,
      10);
    goto LABEL_21;
  }
  sprintf(v37, "0000000%c", (unsigned __int8)*v31);
  v19 = strlen(v37);
  v20 = &v37[v19];
  v21 = (const char *)(v33 + 56);
  v22 = (const char *)(v33 - 8);
  do
  {
    v23 = v21;
    v21 -= 8;
    sprintf(v20, "%.8s", v23);
    v20 += 8;
  }
  while ( v22 != v21 );
  v24 = &v37[v19 + 64];
  v25 = (const char *)(v32 + 56);
  v26 = (const char *)(v32 - 8);
  do
  {
    v27 = v25;
    v25 -= 8;
    sprintf(v24, "%.8s", v27);
    v24 += 8;
  }
  while ( v26 != v25 );
  v28 = strtol(nptr, 0, 10);
  sprintf(&v37[v19 + 128], "%08lx", v28);
  strcpy(&v37[v19 + 136], src);
  memset(a1, 0, 448u);
  hex2bin(a1, (unsigned __int8 *)v37, (int)(v19 + 144) >> 1);
  calc_midstate((int)a1);
  result = v5;
  ++benchfile_work;
  return result;
}
// 59528: using guessed type _DWORD benchfile_data[10];
// 80F98: using guessed type int benchfile_in;
// 80F9C: using guessed type int opt_benchfile;
// 80FA0: using guessed type int benchfile_line;
// 80FA4: using guessed type int benchfile_work;
// 1E068: using guessed type char var_828[2088];

//----- (0001E378) --------------------------------------------------------
int __fastcall get_benchfile_work(int a1)
{
  _DWORD *v2; // r3

  benchfile_get_work((_BYTE *)a1);
  v2 = (_DWORD *)pools;
  *(_BYTE *)(a1 + 282) = 1;
  *(_DWORD *)(a1 + 260) = *v2;
  cgtime((struct timeval *)(a1 + 400));
  copy_time((timeval *)(a1 + 408), (const timeval *)(a1 + 400));
  *(_BYTE *)(a1 + 440) = 66;
  return calc_diff(a1);
}
// 80CBE4: using guessed type int pools;

//----- (0001E3C8) --------------------------------------------------------
void __fastcall __noreturn mutex_init_part_42_constprop_67(const char *a1, int a2)
{
  int *v4; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  applog(3, s, 1);
  _quit(1, 1);
}

//----- (0001E408) --------------------------------------------------------
int __fastcall mutex_init_constprop_66(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_mutex_init(a1, 0);
  if ( result )
    mutex_init_part_42_constprop_67(a2, a3);
  return result;
}

//----- (0001E420) --------------------------------------------------------
void __fastcall __noreturn rwlock_init_part_43_constprop_69(const char *a1, int a2)
{
  int *v4; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  applog(3, s, 1);
  _quit(1, 1);
}

//----- (0001E460) --------------------------------------------------------
int __fastcall rwlock_init_constprop_68(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_init(a1, 0);
  if ( result )
    rwlock_init_part_43_constprop_69(a2, a3);
  return result;
}

//----- (0001E478) --------------------------------------------------------
int __fastcall cglock_init_constprop_65(int a1, const char *a2, int a3)
{
  int result; // r0

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    mutex_init_part_42_constprop_67(a2, a3);
  result = pthread_rwlock_init((pthread_rwlock_t *)(a1 + 24), 0);
  if ( result )
    rwlock_init_part_43_constprop_69(a2, a3);
  return result;
}

//----- (0001E4A8) --------------------------------------------------------
void __fastcall __noreturn wr_lock_part_54_constprop_73(const char *a1, int a2)
{
  int *v4; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  applog(3, s, 1);
  _quit(1, 1);
}

//----- (0001E4E8) --------------------------------------------------------
void __fastcall __noreturn mutex_lock_part_47_constprop_75(const char *a1, int a2)
{
  int *v4; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  applog(3, s, 1);
  _quit(1, 1);
}

//----- (0001E528) --------------------------------------------------------
void __fastcall __noreturn mutex_unlock_noyield_part_48_constprop_77(const char *a1, int a2)
{
  int *v4; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  applog(3, s, 1);
  _quit(1, 1);
}

//----- (0001E568) --------------------------------------------------------
int __fastcall mutex_unlock_constprop_76(pthread_mutex_t *a1, const char *a2, int a3)
{
  if ( pthread_mutex_unlock(a1) )
    mutex_unlock_noyield_part_48_constprop_77(a2, a3);
  return selective_yield(0);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001E58C) --------------------------------------------------------
int __fastcall pool_tset(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    mutex_lock_part_47_constprop_75("pool_tset", 786);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v4) )
    mutex_unlock_noyield_part_48_constprop_77("pool_tset", 791);
  selective_yield(0);
  return v5;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001E5D4) --------------------------------------------------------
int __fastcall inc_dev_status(int a1, int a2)
{
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_part_47_constprop_75("inc_dev_status", 8692);
  g_max_fan = a1;
  g_max_temp = a2;
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_part_48_constprop_77("inc_dev_status", 8695);
  return selective_yield(0);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80DC98: using guessed type int g_max_fan;
// 80DC9C: using guessed type int g_max_temp;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;

//----- (0001E634) --------------------------------------------------------
int __fastcall pool_tclear(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    mutex_lock_part_47_constprop_75("pool_tclear", 801);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v4) )
    mutex_unlock_noyield_part_48_constprop_77("pool_tclear", 806);
  selective_yield(0);
  return v5;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001E67C) --------------------------------------------------------
int __fastcall pool_active(_DWORD *a1, int a2)
{
  int v4; // r6
  int v5; // r3
  int v6; // r2
  const char *v7; // r0
  const char *v9; // r1
  size_t v10; // r2
  int v11; // r2
  const char *v12; // r4
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int *v17; // r4
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r4
  struct timeval v23; // [sp+8h] [bp-828h] BYREF
  struct timeval v24; // [sp+10h] [bp-820h] BYREF
  char s[2072]; // [sp+18h] [bp-818h] BYREF

  if ( *((_BYTE *)a1 + 736) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "Retrieving block template from pool %s", (const char *)a1[41]);
      applog(7, s, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(s, 2048u, "Testing pool %s", (const char *)a1[41]);
    applog(6, s, 0);
  }
  v4 = *((unsigned __int8 *)a1 + 640);
  if ( *((_BYTE *)a1 + 640) )
    goto LABEL_38;
  if ( curly )
  {
    if ( *((_BYTE *)a1 + 99) )
      goto LABEL_15;
    v5 = (unsigned __int8)opt_debug;
    if ( !opt_debug )
    {
      *((_BYTE *)a1 + 99) = v4;
      goto LABEL_15;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy(s, "Probing for GBT support");
      applog(7, s, 0);
      v6 = *((unsigned __int8 *)a1 + 736);
      v5 = (unsigned __int8)opt_debug;
      *((_BYTE *)a1 + 99) = 0;
      if ( !v6 )
      {
        if ( !*((_BYTE *)a1 + 900) )
        {
LABEL_56:
          if ( v5 && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            v9 = "No GBT coinbase + append support found, pool unusable if it has no stratum";
            v10 = 75;
            goto LABEL_60;
          }
          goto LABEL_15;
        }
        if ( !v5 )
          goto LABEL_15;
LABEL_47:
        if ( use_syslog || opt_log_output || opt_log_level > 6 )
        {
          v9 = "GBT coinbase without append found, switching to GBT solo protocol";
          v10 = 66;
LABEL_60:
          memcpy(s, v9, v10);
          applog(7, s, 0);
        }
LABEL_15:
        cgtime(&v23);
        cgtime(&v24);
        v7 = (const char *)a1[144];
        if ( !v7 || opt_fix_protocol )
          goto LABEL_96;
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf(s, 2048u, "Testing pool %d stratum %s", *a1, (const char *)a1[144]);
          applog(6, s, 0);
          v7 = (const char *)a1[144];
        }
        if ( !extract_sockaddr(v7, a1 + 150, (char **)a1 + 146) || !initiate_stratum(a1) )
        {
LABEL_96:
          if ( *((_BYTE *)a1 + 640) || *((_BYTE *)a1 + 900) || *((_BYTE *)a1 + 736) )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(s, 2048u, "FAILED to retrieve work from pool %u %s", *a1, (const char *)a1[41]);
              applog(7, s, 0);
            }
            if ( !a2 && !*((_BYTE *)a1 + 97) && (use_syslog || opt_log_output || opt_log_level > 3) )
            {
              snprintf(s, 2048u, "Pool %u slow/down or URL or credentials invalid", *a1);
              v4 = 0;
              applog(4, s, 0);
            }
          }
          else if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            v4 = 0;
            snprintf(s, 2048u, "No Stratum, GBT or Solo support in pool %d %s unable to use", *a1, (const char *)a1[41]);
            applog(4, s, 0);
          }
          return v4;
        }
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(s, 2048u, "Switching pool %d %s to %s", *a1, (const char *)a1[41], (const char *)a1[144]);
          applog(5, s, 0);
        }
        if ( !a1[41] )
          a1[41] = _strdup((const char *)a1[144]);
        *((_BYTE *)a1 + 640) = 1;
LABEL_38:
        if ( pool_tset((int)a1, (_BYTE *)a1 + 642) )
          return *((unsigned __int8 *)a1 + 641);
        if ( !initiate_stratum(a1) || *((_BYTE *)a1 + 580) && !subscribe_extranonce(a1) || (v4 = auth_stratum(a1)) == 0 )
        {
          pool_tclear((int)a1, (_BYTE *)a1 + 642);
          return 0;
        }
        have_longpoll = 1;
        if ( pthread_create(a1 + 174, 0, (void *(*)(void *))stratum_sthread, a1) )
        {
          v12 = (const char *)&unk_5CB68;
        }
        else
        {
          if ( !pthread_create(a1 + 175, 0, (void *(*)(void *))stratum_rthread, a1) )
            return v4;
          v12 = "Failed to create stratum rthread";
        }
        v13 = *(_DWORD *)v12;
        v14 = *((_DWORD *)v12 + 1);
        v15 = *((_DWORD *)v12 + 2);
        v16 = *((_DWORD *)v12 + 3);
        v17 = (int *)(v12 + 16);
        *(_DWORD *)s = v13;
        *(_DWORD *)&s[4] = v14;
        *(_DWORD *)&s[8] = v15;
        *(_DWORD *)&s[12] = v16;
        v18 = *v17;
        v19 = v17[1];
        v20 = v17[2];
        v21 = v17[3];
        v22 = v17[4];
        *(_DWORD *)&s[16] = v18;
        *(_DWORD *)&s[20] = v19;
        *(_DWORD *)&s[24] = v20;
        *(_DWORD *)&s[28] = v21;
        s[32] = v22;
        applog(3, s, 1);
        _quit(1, 1);
      }
      if ( !v5 )
        goto LABEL_15;
    }
    else
    {
      v11 = *((unsigned __int8 *)a1 + 736);
      *((_BYTE *)a1 + 99) = v4;
      if ( !v11 )
      {
        if ( !*((_BYTE *)a1 + 900) )
          goto LABEL_56;
        goto LABEL_47;
      }
    }
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy(s, "GBT coinbase + append support found, switching to GBT protocol");
      applog(7, s, 0);
    }
    goto LABEL_15;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
    return v4;
  strcpy(s, "CURL initialisation failed");
  applog(3, s, 0);
  return v4;
}
// 24110: using guessed type int stratum_sthread();
// 27598: using guessed type int stratum_rthread();
// 7DEDC: using guessed type char *curly;
// 805A8: using guessed type int opt_log_level;
// 80FA8: using guessed type char opt_fix_protocol;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80CC1A: using guessed type char have_longpoll;

//----- (0001EC04) --------------------------------------------------------
int wake_gws()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)stgd_lock) )
    mutex_lock_part_47_constprop_75("wake_gws", 5291);
  pthread_cond_signal(&gws_cond);
  if ( pthread_mutex_unlock((pthread_mutex_t *)stgd_lock) )
    mutex_unlock_noyield_part_48_constprop_77("wake_gws", 5293);
  return selective_yield(0);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FAC: using guessed type int stgd_lock;
// 80CBE8: using guessed type pthread_cond_t gws_cond;

//----- (0001EC58) --------------------------------------------------------
int __fastcall restart_wait(int a1, unsigned int a2)
{
  __int64 v2; // r6
  __time_t v5; // r3
  int v6; // r1
  int v7; // r3
  int v8; // r4
  struct timeval v10; // [sp+0h] [bp-28h] BYREF
  struct timespec abstime; // [sp+8h] [bp-20h] BYREF

  v2 = 274877907LL * a2;
  cgtime(&v10);
  v5 = v10.tv_sec + (HIDWORD(v2) >> 6);
  v6 = v10.tv_usec + 1000 * a2 - (_DWORD)&unk_F4240 * (HIDWORD(v2) >> 6);
  if ( v6 > (int)&unk_F423F )
  {
    ++v5;
    v6 -= 1000000;
  }
  abstime.tv_sec = v5;
  abstime.tv_nsec = 1000 * v6;
  if ( pthread_mutex_lock(&restart_lock) )
    mutex_lock_part_47_constprop_75("restart_wait", 5344);
  v7 = *(unsigned __int8 *)(a1 + 62);
  v8 = 0;
  if ( !v7 )
    v8 = pthread_cond_timedwait(&restart_cond, &restart_lock, &abstime);
  if ( pthread_mutex_unlock(&restart_lock) )
    mutex_unlock_noyield_part_48_constprop_77("restart_wait", 5354);
  selective_yield(0);
  return v8;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80EE10: using guessed type pthread_cond_t restart_cond;
// 80EF04: using guessed type pthread_mutex_t restart_lock;

//----- (0001ED18) --------------------------------------------------------
void __fastcall __noreturn rw_unlock_part_40_constprop_79(const char *a1, int a2)
{
  int *v4; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  applog(3, s, 1);
  _quit(1);
}
// 1DDD8: using guessed type void __fastcall __noreturn _quit(_DWORD);
// 40CA0: using guessed type int __fastcall applog(_DWORD, _DWORD, _DWORD);

//----- (0001ED58) --------------------------------------------------------
int __fastcall wr_unlock_constprop_78(pthread_rwlock_t *a1, const char *a2, int a3)
{
  if ( pthread_rwlock_unlock(a1) )
    rw_unlock_part_40_constprop_79(a2, a3);
  return selective_yield(0);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001ED7C) --------------------------------------------------------
int total_work_inc()
{
  int v0; // r4

  if ( pthread_mutex_lock(&control_lock) )
    mutex_lock_part_47_constprop_75("total_work_inc", 2205);
  if ( pthread_rwlock_wrlock(&rwlock) )
    wr_lock_part_54_constprop_73("total_work_inc", 2205);
  v0 = total_work++;
  if ( pthread_rwlock_unlock(&rwlock) )
    rw_unlock_part_40_constprop_79("total_work_inc", 2207);
  if ( pthread_mutex_unlock(&control_lock) )
    mutex_unlock_noyield_part_48_constprop_77("total_work_inc", 2207);
  selective_yield(0);
  return v0;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FB0: using guessed type int total_work;
// 80CC54: using guessed type pthread_mutex_t control_lock;

//----- (0001EDFC) --------------------------------------------------------
int __fastcall roll_work(int a1)
{
  int v2; // r5
  unsigned int v3; // r3
  int v4; // r0
  int v5; // r1
  _BYTE *v6; // r5
  int result; // r0
  unsigned int v8[516]; // [sp+0h] [bp-810h] BYREF

  v2 = (unsigned __int8)opt_debug;
  v3 = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + 1);
  v4 = *(_DWORD *)(a1 + 240) + 1;
  v5 = local_work + 1;
  *(_DWORD *)(a1 + 68) = v3;
  *(_DWORD *)(a1 + 240) = v4;
  *(_DWORD *)(a1 + 248) = 0;
  local_work = v5;
  if ( v2 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)v8, "Successfully rolled work");
    applog(7, (const char *)v8, 0);
  }
  v6 = *(_BYTE **)(a1 + 308);
  if ( v6 )
  {
    hex2bin(v8, *(unsigned __int8 **)(a1 + 308), 4);
    v8[0] = bswap32(bswap32(v8[0]) + 1);
    _bin2hex(v6, (unsigned __int8 *)v8, 4);
  }
  result = total_work_inc();
  *(_DWORD *)(a1 + 340) = result;
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80EEF0: using guessed type int local_work;
// 1EDFC: using guessed type unsigned int var_810[516];

//----- (0001EEB4) --------------------------------------------------------
_DWORD *make_work()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  char v3[2064]; // [sp+8h] [bp-810h] BYREF

  v0 = cgcalloc(1u, 448u, "cgminer.c", "make_work", 2214);
  if ( !v0 )
  {
    strcpy(v3, "Failed to calloc work in make_work");
    applog(3, v3, 1);
    _quit(1, 1);
  }
  v1 = v0;
  v0[85] = total_work_inc();
  return v1;
}

//----- (0001EF1C) --------------------------------------------------------
_DWORD *__fastcall copy_work_noffset(int a1, int a2)
{
  _DWORD *work; // r4

  work = make_work();
  copy_work((int)work, a1, a2);
  return work;
}

//----- (0001EF34) --------------------------------------------------------
_DWORD *__fastcall make_clone(int a1)
{
  _DWORD *work; // r4
  int v3; // r3
  _DWORD *result; // r0

  work = make_work();
  copy_work((int)work, a1, 0);
  *((_BYTE *)work + 273) = 1;
  cgtime((struct timeval *)work + 52);
  v3 = work[66];
  *((_BYTE *)work + 280) = 0;
  result = work;
  *((_BYTE *)work + 282) = 0;
  work[66] = v3 - 1;
  return result;
}

//----- (0001EF6C) --------------------------------------------------------
int __fastcall add_queued(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    wr_lock_part_54_constprop_73("add_queued", 9345);
  _add_queued((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    rw_unlock_part_40_constprop_79("add_queued", 9347);
  return selective_yield(0);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001EFB8) --------------------------------------------------------
void __fastcall work_completed(pthread_rwlock_t *a1, void **a2)
{
  pthread_rwlock_t *v2; // r4
  void **v4; // [sp+4h] [bp-14h] BYREF

  v2 = a1 + 10;
  v4 = a2;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    wr_lock_part_54_constprop_73("work_completed", 9497);
  _work_completed((int)a1, v4);
  if ( pthread_rwlock_unlock(v2) )
    rw_unlock_part_40_constprop_79("work_completed", 9499);
  selective_yield(0);
  free_work(&v4, "cgminer.c", "work_completed", 9501);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001F018) --------------------------------------------------------
_DWORD *__fastcall take_queued_work_bymidstate(
        pthread_rwlock_t *a1,
        void *a2,
        size_t a3,
        const void *a4,
        int a5,
        size_t a6)
{
  pthread_rwlock_t *v6; // r6
  _DWORD *work_bymidstate; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    wr_lock_part_54_constprop_73("take_queued_work_bymidstate", 9510);
  work_bymidstate = (_DWORD *)_find_work_bymidstate(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( work_bymidstate )
    _work_completed((int)a1, work_bymidstate);
  if ( pthread_rwlock_unlock(v6) )
    rw_unlock_part_40_constprop_79("take_queued_work_bymidstate", 9514);
  selective_yield(0);
  return work_bymidstate;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001F088) --------------------------------------------------------
int __fastcall age_queued_work(pthread_rwlock_t *a1)
{
  int lock; // r1
  int v3; // r5
  int i; // r4
  int v5; // r3
  int v7; // [sp+4h] [bp-34h]
  struct timeval v8; // [sp+8h] [bp-30h] BYREF

  cgtime(&v8);
  if ( pthread_rwlock_wrlock(a1 + 10) )
    wr_lock_part_54_constprop_73("age_queued_work", 9476);
  lock = a1[11].__lock;
  v7 = lock;
  v3 = lock;
  if ( lock )
  {
    v3 = 0;
    for ( i = *(_DWORD *)(lock + 352); ; i = v5 )
    {
      tdiff();
      v7 = i;
      v5 = i;
      if ( i )
        v5 = *(_DWORD *)(i + 352);
      if ( !i )
        break;
    }
  }
  if ( pthread_rwlock_unlock(a1 + 10) )
    rw_unlock_part_40_constprop_79("age_queued_work", 9487);
  selective_yield(0);
  return v3;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001F140) --------------------------------------------------------
void __fastcall __noreturn rd_lock_part_39_constprop_80(const char *a1, int a2)
{
  int *v4; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  applog(3, s, 1);
  _quit(1);
}
// 1DDD8: using guessed type void __fastcall __noreturn _quit(_DWORD);
// 40CA0: using guessed type int __fastcall applog(_DWORD, _DWORD, _DWORD);

//----- (0001F180) --------------------------------------------------------
_DWORD *__fastcall clone_queued_work_byid(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r0
  int v6; // r4
  int v7; // r2
  _DWORD *work; // r5

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    rd_lock_part_39_constprop_80("clone_queued_work_byid", 9450);
  lock = a1[11].__lock;
  if ( lock )
  {
    v6 = *(_DWORD *)(lock + 352);
    if ( a2 == *(_DWORD *)(lock + 340) )
    {
      v6 = lock;
    }
    else
    {
      if ( !v6 )
      {
LABEL_7:
        work = (_DWORD *)v6;
        goto LABEL_8;
      }
      while ( 1 )
      {
        v7 = *(_DWORD *)(v6 + 352);
        if ( a2 == *(_DWORD *)(v6 + 340) )
          break;
        v6 = *(_DWORD *)(v6 + 352);
        if ( !v7 )
          goto LABEL_7;
      }
    }
    work = make_work();
    copy_work((int)work, v6, 0);
  }
  else
  {
    work = 0;
  }
LABEL_8:
  if ( pthread_rwlock_unlock(v2) )
    rw_unlock_part_40_constprop_79("clone_queued_work_byid", 9454);
  selective_yield(0);
  return work;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001F200) --------------------------------------------------------
_DWORD *__fastcall clone_queued_work_bymidstate(
        pthread_rwlock_t *a1,
        void *a2,
        size_t a3,
        const void *a4,
        int a5,
        size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int work_bymidstate; // r5
  _DWORD *work; // r7

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    rd_lock_part_39_constprop_80("clone_queued_work_bymidstate", 9403);
  work_bymidstate = _find_work_bymidstate(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( work_bymidstate )
  {
    work = make_work();
    copy_work((int)work, work_bymidstate, 0);
  }
  else
  {
    work = 0;
  }
  if ( pthread_rwlock_unlock(v6) )
    rw_unlock_part_40_constprop_79("clone_queued_work_bymidstate", 9407);
  selective_yield(0);
  return work;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001F27C) --------------------------------------------------------
int __fastcall find_queued_work_byid(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r3
  int v6; // r4
  int v7; // r2

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    rd_lock_part_39_constprop_80("find_queued_work_byid", 9438);
  lock = a1[11].__lock;
  if ( !lock || (v6 = *(_DWORD *)(lock + 352), a2 == *(_DWORD *)(lock + 340)) )
  {
    v6 = lock;
  }
  else if ( v6 )
  {
    do
    {
      v7 = *(_DWORD *)(v6 + 352);
      if ( a2 == *(_DWORD *)(v6 + 340) )
        break;
      v6 = *(_DWORD *)(v6 + 352);
    }
    while ( v7 );
  }
  if ( pthread_rwlock_unlock(v2) )
    rw_unlock_part_40_constprop_79("find_queued_work_byid", 9440);
  selective_yield(0);
  return v6;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001F2E8) --------------------------------------------------------
int __fastcall find_queued_work_bymidstate(
        pthread_rwlock_t *a1,
        void *a2,
        size_t a3,
        const void *a4,
        int a5,
        size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int work_bymidstate; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    rd_lock_part_39_constprop_80("find_queued_work_bymidstate", 9391);
  work_bymidstate = _find_work_bymidstate(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( pthread_rwlock_unlock(v6) )
    rw_unlock_part_40_constprop_79("find_queued_work_bymidstate", 9393);
  selective_yield(0);
  return work_bymidstate;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0001F350) --------------------------------------------------------
int __fastcall get_devices(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&devices_lock) )
    rd_lock_part_39_constprop_80("get_devices", 607);
  v2 = *(_DWORD *)(devices + 4 * a1);
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock_part_40_constprop_79("get_devices", 609);
  selective_yield();
  return v2;
}
// 806D4: using guessed type int (*selective_yield)(void);
// 80BB8C: using guessed type int devices;
// 80EF1C: using guessed type pthread_rwlock_t devices_lock;

//----- (0001F3A8) --------------------------------------------------------
int print_summary()
{
  int v0; // r4
  int v1; // r2
  int v2; // r5
  int v3; // r9
  double v4; // d10
  double v5; // d8
  double v6; // d7
  __int64 v7; // r8
  int v8; // r9
  int v9; // r3
  int v10; // r4
  int devices; // r0
  int v12; // r3
  int v13; // r1
  double v14; // d7
  int v15; // r3
  const char *v17; // r1
  __int64 v18; // [sp+18h] [bp-960h]
  int i; // [sp+20h] [bp-958h]
  char v20[256]; // [sp+38h] [bp-940h] BYREF
  char s[2112]; // [sp+138h] [bp-840h] BYREF

  v0 = total_tv_end - total_tv_start;
  LOWORD(v1) = -30583;
  if ( dword_80FB8 - dword_80FC0 < 0 )
    --v0;
  HIWORD(v1) = -30584;
  v2 = v0 - 60 * (((int)(v0 + ((unsigned __int64)(v0 * (__int64)v1) >> 32)) >> 5) - (v0 >> 31));
  v3 = ((int)(v0 % 3600 + ((unsigned __int64)(v0 % 3600 * (__int64)v1) >> 32)) >> 5) - ((v0 % 3600) >> 31);
  v4 = (double)*(__int64 *)&total_accepted / total_secs * 60.0;
  v5 = (double)*(__int64 *)&total_diff1 / total_secs * 60.0;
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3
    || (strcpy(s, "\nSummary of runtime statistics:\n"), applog(4, s, 0), !use_syslog)
    && !opt_log_output
    && opt_log_level <= 3 )
  {
    if ( total_pools == 1 )
      goto LABEL_135;
LABEL_8:
    if ( use_syslog || opt_log_output )
      goto LABEL_10;
    goto LABEL_141;
  }
  snprintf(s, 2048u, "Started at %s", datestamp);
  applog(4, s, 0);
  if ( total_pools != 1 )
    goto LABEL_8;
  if ( use_syslog || opt_log_output )
    goto LABEL_136;
LABEL_135:
  if ( opt_log_level > 3 )
  {
LABEL_136:
    snprintf(s, 2048u, "Pool: %s", *(const char **)(*(_DWORD *)pools + 164));
    applog(4, s, 0);
    goto LABEL_8;
  }
LABEL_141:
  if ( opt_log_level <= 3 )
  {
    v6 = total_mhashes_done / total_secs;
    goto LABEL_143;
  }
LABEL_10:
  snprintf(s, 2048u, "Runtime: %d hrs : %d mins : %d secs", v0 / 3600, v3, v2);
  applog(4, s, 0);
  v6 = total_mhashes_done / total_secs;
  if ( use_syslog || opt_log_output )
  {
LABEL_12:
    snprintf(s, 2048u, "Average hashrate: %.1f Mhash/s", v6);
    applog(4, s, 0);
    if ( use_syslog || opt_log_output )
      goto LABEL_14;
    goto LABEL_172;
  }
LABEL_143:
  if ( opt_log_level > 3 )
    goto LABEL_12;
LABEL_172:
  if ( opt_log_level <= 3 )
    goto LABEL_173;
LABEL_14:
  snprintf(s, 2048u, "Solved blocks: %d", found_blocks);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output )
  {
LABEL_173:
    if ( opt_log_level <= 3 )
      goto LABEL_174;
  }
  snprintf(s, 2048u, "Best share difficulty: %s", best_share);
  applog(4, s, 0);
  if ( use_syslog || opt_log_output )
  {
LABEL_18:
    snprintf(s, 2048u, "Share submissions: %lld", *(_QWORD *)&total_accepted + total_rejected);
    applog(4, s, 0);
    if ( use_syslog || opt_log_output )
      goto LABEL_20;
    goto LABEL_163;
  }
LABEL_174:
  if ( opt_log_level > 3 )
    goto LABEL_18;
LABEL_163:
  if ( opt_log_level <= 3 )
    goto LABEL_164;
LABEL_20:
  snprintf(s, 2048u, "Accepted shares: %lld", *(_QWORD *)&total_accepted);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output )
  {
LABEL_164:
    if ( opt_log_level <= 3 )
      goto LABEL_165;
  }
  snprintf(s, 2048u, "Rejected shares: %lld", total_rejected);
  applog(4, s, 0);
  if ( use_syslog || opt_log_output )
  {
LABEL_24:
    snprintf(s, 2048u, "Accepted difficulty shares: %1.f", total_diff_accepted);
    applog(4, s, 0);
    if ( use_syslog || opt_log_output )
      goto LABEL_26;
    goto LABEL_166;
  }
LABEL_165:
  if ( opt_log_level > 3 )
    goto LABEL_24;
LABEL_166:
  if ( opt_log_level <= 3 )
  {
    v7 = *(_QWORD *)&total_accepted;
    if ( *(_QWORD *)&total_accepted )
      goto LABEL_168;
    goto LABEL_88;
  }
LABEL_26:
  snprintf(s, 2048u, "Rejected difficulty shares: %1.f", total_diff_rejected);
  applog(4, s, 0);
  v7 = *(_QWORD *)&total_accepted;
  if ( *(_QWORD *)&total_accepted )
  {
    if ( !use_syslog )
      goto LABEL_28;
LABEL_29:
    snprintf(s, 2048u, "Reject ratio: %.1f%%", (double)(100 * total_rejected) / (double)(total_rejected + v7));
    applog(4, s, 0);
LABEL_30:
    if ( use_syslog || opt_log_output )
      goto LABEL_32;
    goto LABEL_145;
  }
LABEL_88:
  if ( !total_rejected )
    goto LABEL_30;
  v7 = 0LL;
  if ( use_syslog )
    goto LABEL_29;
LABEL_28:
  if ( opt_log_output )
    goto LABEL_29;
LABEL_168:
  if ( opt_log_level > 3 )
    goto LABEL_29;
LABEL_145:
  if ( opt_log_level <= 3 )
    goto LABEL_146;
LABEL_32:
  snprintf(s, 2048u, "Hardware errors: %d", hw_errors);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_146:
    if ( opt_log_level <= 3 )
      goto LABEL_147;
    goto LABEL_36;
  }
  snprintf(s, 2048u, "Utility (accepted shares / min): %.2f/min", v4);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_147:
    if ( opt_log_level <= 3 )
      goto LABEL_148;
    goto LABEL_38;
  }
LABEL_36:
  snprintf(s, 2048u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v5);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_148:
    if ( opt_log_level <= 3 )
      goto LABEL_149;
    goto LABEL_40;
  }
LABEL_38:
  snprintf(s, 2048u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&total_stale);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_149:
    if ( opt_log_level <= 3 )
      goto LABEL_150;
    goto LABEL_42;
  }
LABEL_40:
  snprintf(s, 2048u, "Unable to get work from server occasions: %d", total_go);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_150:
    if ( opt_log_level <= 3 )
      goto LABEL_151;
    goto LABEL_44;
  }
LABEL_42:
  snprintf(s, 2048u, "Work items generated locally: %d", local_work);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_151:
    if ( opt_log_level <= 3 )
      goto LABEL_152;
    goto LABEL_46;
  }
LABEL_44:
  snprintf(s, 2048u, "Submitting work remotely delay occasions: %d", total_ro);
  applog(4, s, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_152:
    if ( total_pools <= 1 )
      goto LABEL_139;
    goto LABEL_47;
  }
LABEL_46:
  snprintf(s, 2048u, "New blocks detected on network: %d\n", new_blocks);
  applog(4, s, 0);
  if ( total_pools > 1 )
  {
LABEL_47:
    for ( i = 0; total_pools > i; ++i )
    {
      v8 = *(_DWORD *)(pools + 4 * i);
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(s, 2048u, "Pool: %s", *(const char **)(v8 + 164));
        applog(4, s, 0);
        v9 = *(_DWORD *)(v8 + 32);
        if ( !v9 )
          goto LABEL_96;
        if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
          goto LABEL_53;
      }
      else
      {
        v9 = *(_DWORD *)(v8 + 32);
        if ( !v9 )
          goto LABEL_97;
        if ( opt_log_level <= 3 )
          goto LABEL_53;
      }
      v17 = "S";
      if ( v9 <= 1 )
        v17 = "";
      snprintf(s, 2048u, "SOLVED %d BLOCK%s!", v9, v17);
      applog(4, s, 0);
LABEL_96:
      if ( use_syslog )
        goto LABEL_98;
LABEL_97:
      if ( opt_log_output )
      {
LABEL_98:
        snprintf(s, 2048u, " Share submissions: %lld", *(_QWORD *)(v8 + 8) + *(_QWORD *)(v8 + 16));
        applog(4, s, 0);
        if ( use_syslog || opt_log_output )
          goto LABEL_100;
        goto LABEL_54;
      }
LABEL_53:
      if ( opt_log_level > 3 )
        goto LABEL_98;
LABEL_54:
      if ( opt_log_level <= 3 )
        goto LABEL_55;
LABEL_100:
      snprintf(s, 2048u, " Accepted shares: %lld", *(_QWORD *)(v8 + 8));
      applog(4, s, 0);
      if ( !use_syslog && !opt_log_output )
      {
LABEL_55:
        if ( opt_log_level <= 3 )
          goto LABEL_56;
      }
      snprintf(s, 2048u, " Rejected shares: %lld", *(_QWORD *)(v8 + 16));
      applog(4, s, 0);
      if ( use_syslog || opt_log_output )
      {
LABEL_104:
        snprintf(s, 2048u, " Accepted difficulty shares: %1.f", *(double *)(v8 + 72));
        applog(4, s, 0);
        if ( use_syslog || opt_log_output )
          goto LABEL_106;
        goto LABEL_57;
      }
LABEL_56:
      if ( opt_log_level > 3 )
        goto LABEL_104;
LABEL_57:
      if ( opt_log_level <= 3 )
      {
        v18 = *(_QWORD *)(v8 + 8);
        if ( v18 )
          goto LABEL_59;
        goto LABEL_107;
      }
LABEL_106:
      snprintf(s, 2048u, " Rejected difficulty shares: %1.f", *(double *)(v8 + 80));
      applog(4, s, 0);
      v18 = *(_QWORD *)(v8 + 8);
      if ( v18 )
        goto LABEL_109;
LABEL_107:
      if ( *(_QWORD *)(v8 + 16) )
      {
        v18 = 0LL;
LABEL_109:
        if ( !use_syslog && !opt_log_output )
        {
LABEL_59:
          if ( opt_log_level <= 3 )
            goto LABEL_60;
        }
        snprintf(
          s,
          2048u,
          " Reject ratio: %.1f%%",
          (double)(100LL * *(_QWORD *)(v8 + 16)) / (double)(v18 + *(_QWORD *)(v8 + 16)));
        applog(4, s, 0);
      }
      if ( use_syslog || opt_log_output )
      {
LABEL_114:
        snprintf(s, 2048u, " Items worked on: %d", *(_DWORD *)(v8 + 68));
        applog(4, s, 0);
        if ( use_syslog || opt_log_output )
          goto LABEL_116;
        goto LABEL_61;
      }
LABEL_60:
      if ( opt_log_level > 3 )
        goto LABEL_114;
LABEL_61:
      if ( opt_log_level <= 3 )
        goto LABEL_62;
LABEL_116:
      snprintf(s, 2048u, " Stale submissions discarded due to new blocks: %d", *(_DWORD *)(v8 + 120));
      applog(4, s, 0);
      if ( !use_syslog && !opt_log_output )
      {
LABEL_62:
        if ( opt_log_level <= 3 )
          goto LABEL_63;
      }
      snprintf(s, 2048u, " Unable to get work from server occasions: %d", *(_DWORD *)(v8 + 128));
      applog(4, s, 0);
      if ( use_syslog || opt_log_output )
      {
LABEL_64:
        snprintf(s, 2048u, " Submitting work remotely delay occasions: %d\n", *(_DWORD *)(v8 + 132));
        applog(4, s, 0);
        continue;
      }
LABEL_63:
      if ( opt_log_level > 3 )
        goto LABEL_64;
    }
  }
  if ( use_syslog || opt_log_output )
    goto LABEL_68;
LABEL_139:
  if ( opt_log_level > 3 )
  {
LABEL_68:
    strcpy(s, "Summary of per device statistics:\n");
    applog(4, s, 0);
  }
  if ( total_devices > 0 )
  {
    v10 = 0;
    do
    {
      devices = get_devices(v10);
      v12 = *(_DWORD *)(devices + 4);
      ++v10;
      *(_DWORD *)(v12 + 20) = blank_get_statline_before;
      *(_DWORD *)(v12 + 24) = noop_get_statline;
      get_statline(v20, 255u, devices);
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(s, 2048u, "%s", v20);
        applog(4, s, 0);
      }
    }
    while ( total_devices > v10 );
  }
  v13 = opt_shares;
  if ( !opt_shares )
    goto LABEL_83;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(s, 2048u, "Mined %.0f accepted shares of %d requested\n", total_diff_accepted, opt_shares);
    applog(4, s, 0);
    v14 = total_diff_accepted;
    v13 = opt_shares;
    v15 = (unsigned __int8)use_syslog;
    if ( (double)opt_shares <= total_diff_accepted )
      goto LABEL_84;
    if ( use_syslog || opt_log_output )
      goto LABEL_82;
  }
  else
  {
    v14 = total_diff_accepted;
    if ( (double)opt_shares <= total_diff_accepted )
    {
LABEL_85:
      if ( opt_log_output )
        goto LABEL_86;
LABEL_137:
      if ( opt_log_level <= 3 )
        goto LABEL_87;
      goto LABEL_86;
    }
  }
  if ( opt_log_level <= 3 )
    goto LABEL_137;
LABEL_82:
  snprintf(s, 2048u, "WARNING - Mined only %.0f shares of %d requested.", v14, v13);
  applog(4, s, 0);
LABEL_83:
  v15 = (unsigned __int8)use_syslog;
LABEL_84:
  if ( !v15 )
    goto LABEL_85;
LABEL_86:
  strcpy(s, " ");
  applog(4, s, 0);
LABEL_87:
  fflush((FILE *)_bss_start);
  return fflush((FILE *)stdout);
}
// 1B3FC: using guessed type int noop_get_statline();
// 1C7B4: using guessed type int blank_get_statline_before();
// 40CA0: using guessed type int __fastcall applog(_DWORD, _DWORD, _DWORD);
// 7DEC8: using guessed type double total_secs;
// 805A8: using guessed type int opt_log_level;
// 80B08: using guessed type int _bss_start;
// 80B14: using guessed type int stdout;
// 80FB4: using guessed type int total_tv_end;
// 80FB8: using guessed type int dword_80FB8;
// 80FBC: using guessed type int total_tv_start;
// 80FC0: using guessed type int dword_80FC0;
// 80FEC: using guessed type int opt_shares;
// 80B6C8: using guessed type char opt_log_output;
// 80BA38: using guessed type int total_stale;
// 80BA88: using guessed type int hw_errors;
// 80BAEC: using guessed type int total_pools;
// 80BB7C: using guessed type int found_blocks;
// 80CBB0: using guessed type int total_ro;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;
// 80DCD8: using guessed type int total_devices;
// 80DCE8: using guessed type int total_go;
// 80DCF0: using guessed type int total_accepted;
// 80EDF0: using guessed type int new_blocks;
// 80EEF0: using guessed type int local_work;
// 80EEF8: using guessed type __int64 total_rejected;
// 80EF60: using guessed type int total_diff1;

//----- (00020334) --------------------------------------------------------
int __fastcall clean_up(int a1)
{
  int v2; // r5
  char *v3; // r0
  int result; // r0
  struct sysinfo v5; // [sp+8h] [bp-850h] BYREF
  char s[2064]; // [sp+48h] [bp-810h] BYREF

  if ( !sysinfo(&v5) )
  {
    total_tv_end_sys = v5.uptime;
    result = cgtime((struct timeval *)&total_tv_end);
    if ( a1 )
      return result;
    goto LABEL_8;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    v2 = *_errno_location();
    v3 = strerror(v2);
    snprintf(s, 2048u, "Failed to get sysinfo, errno:%u, reason:%s\n", v2, v3);
    applog(6, s, 0);
  }
  total_tv_end_sys = time(0);
  result = cgtime((struct timeval *)&total_tv_end);
  if ( !a1 )
  {
LABEL_8:
    if ( !opt_realquiet )
    {
      if ( successful_connect )
        return print_summary();
    }
  }
  return result;
}
// 40CA0: using guessed type int __fastcall applog(_DWORD, _DWORD, _DWORD);
// 805A8: using guessed type int opt_log_level;
// 80FB4: using guessed type int total_tv_end;
// 80B6C8: using guessed type char opt_log_output;
// 80B6F8: using guessed type char successful_connect;
// 80CBA0: using guessed type int total_tv_end_sys;
// 80CC18: using guessed type char use_syslog;
// 80DCB4: using guessed type char opt_realquiet;

//----- (000203F8) --------------------------------------------------------
void app_restart()
{
  char v0[2064]; // [sp+0h] [bp-810h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(v0, 2048u, "Attempting to restart %s", packagename);
    applog(4, v0, 0);
  }
  cg_completion_timeout((int)_kill_work, 0, 5000);
  clean_up(1);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  execv(*(const char **)initial_args, (char *const *)initial_args);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy(v0, "Failed to restart application");
    applog(4, v0, 0);
  }
}
// 20794: using guessed type int _kill_work();
// 805A8: using guessed type int opt_log_level;
// 80F94: using guessed type int forkpid;
// 80FF0: using guessed type int initial_args;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (000204D4) --------------------------------------------------------
int __fastcall get_thread(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&mining_thr_lock) )
    rd_lock_part_39_constprop_80("get_thread", 587);
  v2 = *(_DWORD *)(mining_thr + 4 * a1);
  if ( pthread_rwlock_unlock(&mining_thr_lock) )
    rw_unlock_part_40_constprop_79("get_thread", 589);
  selective_yield(0);
  return v2;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80CBC0: using guessed type int mining_thr;
// 80CBC4: using guessed type pthread_rwlock_t mining_thr_lock;

//----- (0002052C) --------------------------------------------------------
int __fastcall dev_from_id(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(get_thread(a1) + 36) + 8);
}

//----- (00020538) --------------------------------------------------------
bool _kill_work_part_41()
{
  int v0; // r4
  int v1; // r0
  int thread; // r0
  int v3; // r3
  char v5[2080]; // [sp+0h] [bp-820h] BYREF

  if ( !use_syslog && !opt_log_output && opt_log_level <= 5 )
  {
    if ( !opt_debug )
      goto LABEL_7;
    goto LABEL_29;
  }
  strcpy(v5, "Received kill message");
  applog(6, v5, 1);
  if ( opt_debug )
  {
    if ( use_syslog || opt_log_output )
    {
LABEL_6:
      strcpy(v5, "Killing off watchpool thread");
      applog(7, v5, 1);
      goto LABEL_7;
    }
LABEL_29:
    if ( opt_log_level <= 6 )
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_7:
  cg_completion_timeout((int)thr_info_cancel, control_thr + (watchpool_thr_id << 6), 1000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(v5, "Killing off watchdog thread");
    applog(7, v5, 1);
  }
  cg_completion_timeout((int)thr_info_cancel, control_thr + (watchdog_thr_id << 6), 1000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(v5, "Shutting down mining threads");
    applog(7, v5, 1);
  }
  if ( mining_threads > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      thread = get_thread(v1);
      if ( thread )
      {
        v3 = *(_DWORD *)(thread + 36);
        if ( v3 )
          *(_BYTE *)(v3 + 364) = 1;
      }
    }
    while ( v0 < mining_threads );
  }
  sleep(1u);
  cg_completion_timeout((int)kill_mining, 0, 3000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(v5, "Killing off API thread");
    applog(7, v5, 1);
  }
  return cg_completion_timeout((int)thr_info_cancel, control_thr + (api_thr_id << 6), 1000);
}
// 207A4: using guessed type int kill_mining();
// 464A4: using guessed type int thr_info_cancel();
// 805A8: using guessed type int opt_log_level;
// 80E90: using guessed type int api_thr_id;
// 80FF4: using guessed type int watchpool_thr_id;
// 80FF8: using guessed type int watchdog_thr_id;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80DCA0: using guessed type int mining_threads;
// 80DCB0: using guessed type int control_thr;

//----- (00020794) --------------------------------------------------------
bool _kill_work()
{
  _BOOL4 result; // r0

  if ( successful_connect )
    return _kill_work_part_41();
  return result;
}
// 80B6F8: using guessed type char successful_connect;

//----- (000207A4) --------------------------------------------------------
void kill_mining()
{
  int i; // r4
  int thread; // r0
  int v2; // r5
  pthread_t v3; // r0
  char v4[2064]; // [sp+0h] [bp-810h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(v4, "Killing off mining threads");
    applog(7, v4, 1);
  }
  if ( mining_threads > 0 )
  {
    for ( i = 0; mining_threads > i; ++i )
    {
      while ( 1 )
      {
        thread = get_thread(i);
        v2 = thread;
        if ( thread )
        {
          if ( *(_DWORD *)(thread + 12) )
            break;
        }
        thr_info_cancel(thread);
LABEL_8:
        if ( mining_threads <= ++i )
          return;
      }
      thr_info_cancel(thread);
      v3 = *(_DWORD *)(v2 + 12);
      if ( !v3 )
        goto LABEL_8;
      pthread_join(v3, 0);
    }
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80DCA0: using guessed type int mining_threads;

//----- (00020858) --------------------------------------------------------
int current_pool()
{
  int v0; // r4

  if ( pthread_mutex_lock(&control_lock) )
    mutex_lock_part_47_constprop_75("current_pool", 816);
  if ( pthread_rwlock_rdlock(&rwlock) )
    rd_lock_part_39_constprop_80("current_pool", 816);
  if ( pthread_mutex_unlock(&control_lock) )
    mutex_unlock_noyield_part_48_constprop_77("current_pool", 816);
  v0 = currentpool;
  if ( pthread_rwlock_unlock(&rwlock) )
    rw_unlock_part_40_constprop_79("current_pool", 820);
  selective_yield(0);
  return v0;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FFC: using guessed type int currentpool;
// 80CC54: using guessed type pthread_mutex_t control_lock;

//----- (000208D4) --------------------------------------------------------
int __fastcall inc_work_stats(int a1, int a2, int a3)
{
  int v6; // r6
  __int64 v7; // r0
  int v9; // r0

  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_part_47_constprop_75("inc_work_stats", 8755);
  v6 = *(_DWORD *)(a1 + 36);
  v7 = *(_QWORD *)(v6 + 192) + a3;
  *(_QWORD *)&total_diff1 += a3;
  *(_QWORD *)(v6 + 192) = v7;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v9 = current_pool();
    v6 = *(_DWORD *)(a1 + 36);
    *(_QWORD *)(v9 + 40) += a3;
  }
  *(_DWORD *)(v6 + 232) = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_part_48_constprop_77("inc_work_stats", 8769);
  return selective_yield(0);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80EDD8: using guessed type pthread_mutex_t stats_lock;
// 80EF60: using guessed type int total_diff1;

//----- (00020978) --------------------------------------------------------
int cp_prio()
{
  int v0; // r4

  if ( pthread_mutex_lock(&control_lock) )
    mutex_lock_part_47_constprop_75("cp_prio", 7331);
  if ( pthread_rwlock_rdlock(&rwlock) )
    rd_lock_part_39_constprop_80("cp_prio", 7331);
  if ( pthread_mutex_unlock(&control_lock) )
    mutex_unlock_noyield_part_48_constprop_77("cp_prio", 7331);
  v0 = *(_DWORD *)(currentpool + 4);
  if ( pthread_rwlock_unlock(&rwlock) )
    rw_unlock_part_40_constprop_79("cp_prio", 7333);
  selective_yield(0);
  return v0;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FFC: using guessed type int currentpool;
// 80CC54: using guessed type pthread_mutex_t control_lock;

//----- (000209F4) --------------------------------------------------------
void __fastcall pool_resus(_DWORD *a1)
{
  int v1; // r3
  int v3; // r5
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  v1 = pool_strategy;
  a1[7] = 0;
  if ( v1 || (v3 = a1[1], v3 >= cp_prio()) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(s, 2048u, "Pool %d %s alive", *a1, (const char *)a1[41]);
      applog(6, s, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(s, 2048u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[41]);
    applog(4, s, 0);
  }
}
// 805A8: using guessed type int opt_log_level;
// 80F6C: using guessed type int pool_strategy;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00020AC0) --------------------------------------------------------
void __fastcall stratum_resumed_part_50(_DWORD *a1)
{
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(v2, 2048u, "Stratum connection to pool %d resumed", *a1);
    applog(6, v2, 0);
    pool_resus(a1);
  }
  else
  {
    pool_resus(a1);
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00020B24) --------------------------------------------------------
void __fastcall stratum_resumed(int a1)
{
  if ( pool_tclear(a1, (_BYTE *)(a1 + 97)) )
    stratum_resumed_part_50((_DWORD *)a1);
}

//----- (00020B3C) --------------------------------------------------------
int __fastcall cnx_needed(int a1)
{
  int v3; // r4

  if ( *(_DWORD *)(a1 + 100) != 1 )
    return 0;
  if ( (unsigned int)(pool_strategy - 3) <= 1 || *(_BYTE *)(a1 + 640) && *(_BYTE *)(a1 + 97) )
    return 1;
  if ( a1 == current_pool() )
    return 1;
  if ( *(_DWORD *)(a1 + 732) )
    return 1;
  if ( !pool_strategy )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 < cp_prio() )
      return 1;
  }
  return (unsigned __int8)no_work;
}
// 80F6C: using guessed type int pool_strategy;
// 81000: using guessed type char no_work;

//----- (00020B90) --------------------------------------------------------
char *add_pool()
{
  char *v0; // r0
  int v1; // r3
  char *v2; // r4
  void *v3; // r0
  int v4; // r1
  _DWORD *v5; // r0
  int v6; // r2
  char *result; // r0
  int v8; // r3
  int v9; // r1
  int *v10; // r0
  int *v11; // r0
  int v12; // r3
  int v13; // r1
  int *v14; // r0
  int *v15; // r0
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v0 = (char *)cgcalloc(1848u, 1u, "cgminer.c", "add_pool", 740);
  v1 = total_pools;
  v2 = v0;
  v3 = (void *)pools;
  v4 = total_pools + 2;
  *((_DWORD *)v2 + 1) = total_pools;
  *(_DWORD *)v2 = v1;
  v2[644] = 0;
  v5 = cgrealloc(v3, 4 * v4, "cgminer.c", "add_pool", 752);
  v6 = total_pools;
  pools = (int)v5;
  ++total_pools;
  v5[v6] = v2;
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 188), 0) )
  {
    v10 = _errno_location();
    v9 = 755;
    v8 = *v10;
    goto LABEL_10;
  }
  if ( pthread_cond_init((pthread_cond_t *)(v2 + 296), 0) )
  {
    strcpy(s, "Failed to pthread_cond_init in add_pool");
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 212), 0) )
  {
    v11 = _errno_location();
    v9 = 762;
    v8 = *v11;
    goto LABEL_10;
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 236), 0) )
  {
    v12 = *_errno_location();
    v13 = 762;
LABEL_16:
    snprintf(s, 2048u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", v12, "cgminer.c", "add_pool", v13);
LABEL_11:
    applog(3, s, 1);
    _quit(1, 1);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 704), 0) )
  {
    v14 = _errno_location();
    v9 = 763;
    v8 = *v14;
    goto LABEL_10;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 740), 0) )
  {
    v8 = *_errno_location();
    v9 = 764;
LABEL_10:
    snprintf(s, 2048u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", v8, "cgminer.c", "add_pool", v9);
    goto LABEL_11;
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 764), 0) )
  {
    v15 = _errno_location();
    v13 = 764;
    v12 = *v15;
    goto LABEL_16;
  }
  *((_DWORD *)v2 + 34) = -1;
  *((_DWORD *)v2 + 46) = 0;
  *((_DWORD *)v2 + 40) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *((_DWORD *)v2 + 86) = v2 + 344;
  *((_DWORD *)v2 + 87) = v2 + 344;
  *((_DWORD *)v2 + 14) = 1;
  adjust_quota_gcd();
  result = v2;
  v2[580] = 0;
  return result;
}
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00020D4C) --------------------------------------------------------
const char *__fastcall set_userpass(char *s)
{
  int v2; // r3
  _DWORD *v3; // r6
  char *v4; // r4
  char *v5; // r0
  char *v6; // r4

  if ( total_users || total_passes )
    return "Use only user + pass or userpass, but not both";
  v2 = total_userpasses + 1;
  total_userpasses = v2;
  if ( v2 > total_pools )
  {
    add_pool();
    v2 = total_userpasses;
  }
  v3 = *(_DWORD **)(pools + 4 * (v2 + 1073741823));
  v4 = _strdup(s);
  opt_set_charp((int)s, v3 + 42);
  v5 = strtok(v4, ":");
  v3[43] = v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v3[44] = v6;
  if ( v6 )
    return 0;
  v3[44] = calloc(1u, 1u);
  return v6;
}
// 81004: using guessed type int total_users;
// 81008: using guessed type int total_passes;
// 8100C: using guessed type int total_userpasses;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00020E00) --------------------------------------------------------
const char *__fastcall set_user(int a1)
{
  int v3; // r3

  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  v3 = total_users + 1;
  total_users = v3;
  if ( v3 > total_pools )
  {
    add_pool();
    v3 = total_users;
  }
  opt_set_charp(a1, (_DWORD *)(*(_DWORD *)(pools + 4 * (v3 + 1073741823)) + 172));
  return 0;
}
// 81004: using guessed type int total_users;
// 8100C: using guessed type int total_userpasses;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00020E60) --------------------------------------------------------
int add_url()
{
  int v0; // r3

  v0 = ++total_urls;
  if ( total_urls > total_pools )
  {
    add_pool();
    v0 = total_urls;
  }
  return *(_DWORD *)(pools + 4 * (v0 + 1073741823));
}
// 81010: using guessed type int total_urls;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00020EA0) --------------------------------------------------------
int __fastcall set_url(char *a1)
{
  int v2; // r4
  const char *v3; // r5
  char v5[2064]; // [sp+0h] [bp-810h] BYREF

  v2 = add_url();
  setup_url(v2, a1);
  v3 = *(const char **)(v2 + 164);
  if ( strstr(v3, ".nicehash.com") || strstr(v3, "#xnsub") )
  {
    *(_BYTE *)(v2 + 580) = 1;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(v5, 2048u, "Pool %d extranonce subscribing enabled.", *(_DWORD *)v2);
      applog(7, v5, 0);
    }
  }
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00020F3C) --------------------------------------------------------
const char *__fastcall set_quota(const char *a1)
{
  char *v2; // r0
  char *v3; // r4
  size_t v4; // r0
  size_t v5; // r6
  size_t v6; // r0
  size_t v7; // r4
  int v8; // r6
  char *v10; // r4
  _DWORD *v11; // r5
  char s[2072]; // [sp+8h] [bp-818h] BYREF

  v2 = strchr(a1, 59);
  if ( !v2 )
    return "No semicolon separated quota;URL pair found";
  v3 = v2;
  v4 = strlen(a1);
  *v3 = 0;
  v5 = v4;
  v6 = strlen(a1);
  if ( !v6 )
    return "No parameter for quota found";
  v7 = v6 + 1;
  if ( (int)(v5 - (v6 + 1)) <= 0 )
    return "No parameter for URL found";
  v8 = strtol(a1, 0, 10);
  if ( v8 < 0 )
    return "Invalid negative parameter for quota set";
  v10 = (char *)&a1[v7];
  v11 = (_DWORD *)add_url();
  setup_url((int)v11, v10);
  v11[14] = v8;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(s, 2048u, "Setting pool %d to quota %d", *v11, v8);
    applog(6, s, 0);
  }
  adjust_quota_gcd();
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00021010) --------------------------------------------------------
const char *__fastcall set_pass(int a1)
{
  int v3; // r3

  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  v3 = total_passes + 1;
  total_passes = v3;
  if ( v3 > total_pools )
  {
    add_pool();
    v3 = total_passes;
  }
  opt_set_charp(a1, (_DWORD *)(*(_DWORD *)(pools + 4 * (v3 + 1073741823)) + 176));
  return 0;
}
// 81008: using guessed type int total_passes;
// 8100C: using guessed type int total_userpasses;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (00021070) --------------------------------------------------------
int set_extranonce_subscribe()
{
  int v0; // r3
  int v1; // r4
  char v3[2056]; // [sp+0h] [bp-808h] BYREF

  v0 = ++total_extranonce;
  if ( total_extranonce > total_pools )
  {
    add_pool();
    v0 = total_extranonce;
  }
  v1 = *(_DWORD *)(pools + 4 * (v0 + 1073741823));
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(v3, 2048u, "Enable extranonce subscribe on %d", *(_DWORD *)v1);
    applog(7, v3, 0);
  }
  opt_set_bool((_BYTE *)(v1 + 580));
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 81014: using guessed type int total_extranonce;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;

//----- (00021114) --------------------------------------------------------
int zero_stats()
{
  int v0; // r4
  char *v1; // r0
  int *v2; // r3
  int *v3; // r6
  int v4; // r7
  int v5; // t1
  int result; // r0
  int v7; // r5
  int devices; // r4
  int *v9; // r0
  int *v10; // r0
  struct sysinfo v11; // [sp+10h] [bp-868h] BYREF
  char s[2088]; // [sp+50h] [bp-828h] BYREF

  if ( sysinfo(&v11) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v0 = *_errno_location();
      v1 = strerror(v0);
      snprintf(s, 2048u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
      applog(6, s, 0);
    }
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_start_sys = v11.uptime;
  }
  cgtime((struct timeval *)&total_tv_start);
  copy_time(&tv_hashmeter, (const timeval *)&total_tv_start);
  v2 = (int *)&g_local_mhashes_dones;
  total_rolling = 0LL;
  rolling1 = 0LL;
  rolling5 = 0LL;
  rolling15 = 0LL;
  total_mhashes_done = 0LL;
  new_total_mhashes_done = 0LL;
  do
  {
    *(_QWORD *)v2 = 0LL;
    v2 += 2;
  }
  while ( v2 != &g_local_mhashes_index );
  last_total_secs = 4607182418800017408LL;
  total_secs = 1.0;
  new_total_secs = 1.0;
  hw_errors = 0;
  g_local_mhashes_index = 0;
  local_work = 0;
  found_blocks = 0;
  total_getworks = 0;
  dword_80DD04 = 0;
  total_accepted = 0;
  dword_80DCF4 = 0;
  total_rejected = 0LL;
  g_max_fan = 0;
  g_max_temp = 0;
  total_stale = 0;
  dword_80BA3C = 0;
  total_discarded = 0;
  dword_80BAA4 = 0;
  total_diff1 = 0;
  dword_80EF64 = 0;
  total_go = 0;
  total_ro = 0;
  total_diff_accepted = 0LL;
  total_diff_rejected = 0LL;
  total_diff_stale = 0LL;
  if ( total_pools > 0 )
  {
    v3 = (int *)pools;
    v4 = pools + 4 * total_pools;
    do
    {
      v5 = *v3++;
      *(_DWORD *)(v5 + 116) = 0;
      *(_DWORD *)(v5 + 8) = 0;
      *(_DWORD *)(v5 + 12) = 0;
      *(_DWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v5 + 20) = 0;
      *(_DWORD *)(v5 + 120) = 0;
      *(_DWORD *)(v5 + 124) = 0;
      *(_DWORD *)(v5 + 128) = 0;
      *(_DWORD *)(v5 + 132) = 0;
      *(_DWORD *)(v5 + 352) = 0;
      *(_DWORD *)(v5 + 40) = 0;
      *(_DWORD *)(v5 + 44) = 0;
      *(_QWORD *)(v5 + 72) = 0LL;
      *(_QWORD *)(v5 + 80) = 0LL;
      *(_QWORD *)(v5 + 88) = 0LL;
      *(_QWORD *)(v5 + 360) = 0LL;
    }
    while ( v3 != (int *)v4 );
  }
  result = zero_bestshare();
  if ( total_devices > 0 )
  {
    v7 = 0;
    while ( 1 )
    {
      devices = get_devices(v7);
      copy_time((timeval *)(devices + 368), (const timeval *)&total_tv_start);
      if ( pthread_mutex_lock(&hash_lock) )
        break;
      *(_DWORD *)(devices + 36) = 0;
      *(_QWORD *)(devices + 80) = 0LL;
      *(_DWORD *)(devices + 40) = 0;
      *(_DWORD *)(devices + 44) = 0;
      *(_QWORD *)(devices + 88) = 0LL;
      *(_DWORD *)(devices + 220) = 0;
      *(_QWORD *)(devices + 200) = 0LL;
      *(_QWORD *)(devices + 208) = 0LL;
      *(_QWORD *)(devices + 224) = 0LL;
      *(_QWORD *)(devices + 192) = 0LL;
      if ( pthread_mutex_unlock(&hash_lock) )
      {
        v10 = _errno_location();
        snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v10, "cgminer.c", "zero_stats", 6106);
LABEL_19:
        applog(3, s, 1);
        _quit(1, 1);
      }
      ++v7;
      selective_yield(0);
      result = (*(int (__fastcall **)(int))(*(_DWORD *)(devices + 4) + 96))(devices);
      if ( total_devices <= v7 )
        return result;
    }
    v9 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "cgminer.c", "zero_stats", 6093);
    goto LABEL_19;
  }
  return result;
}
// 7DEC8: using guessed type double total_secs;
// 7DEE0: using guessed type double new_total_secs;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FBC: using guessed type int total_tv_start;
// 81018: using guessed type struct timeval tv_hashmeter;
// 81080: using guessed type int g_local_mhashes_index;
// 80B6C8: using guessed type char opt_log_output;
// 80BA38: using guessed type int total_stale;
// 80BA3C: using guessed type int dword_80BA3C;
// 80BA40: using guessed type int total_tv_start_sys;
// 80BA88: using guessed type int hw_errors;
// 80BAA0: using guessed type int total_discarded;
// 80BAA4: using guessed type int dword_80BAA4;
// 80BAEC: using guessed type int total_pools;
// 80BB7C: using guessed type int found_blocks;
// 80CBB0: using guessed type int total_ro;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;
// 80DC98: using guessed type int g_max_fan;
// 80DC9C: using guessed type int g_max_temp;
// 80DCD8: using guessed type int total_devices;
// 80DCE8: using guessed type int total_go;
// 80DCF0: using guessed type int total_accepted;
// 80DCF4: using guessed type int dword_80DCF4;
// 80DD00: using guessed type int total_getworks;
// 80DD04: using guessed type int dword_80DD04;
// 80EEF0: using guessed type int local_work;
// 80EEF8: using guessed type __int64 total_rejected;
// 80EF48: using guessed type pthread_mutex_t hash_lock;
// 80EF60: using guessed type int total_diff1;
// 80EF64: using guessed type int dword_80EF64;

//----- (00021460) --------------------------------------------------------
void __fastcall flush_queue(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r5
  void **nr_readers; // r2
  int *v4; // r0
  void **v5; // [sp+14h] [bp-814h] BYREF
  char s[2064]; // [sp+18h] [bp-810h] BYREF

  v5 = 0;
  if ( a1 )
  {
    v1 = a1 + 10;
    if ( !pthread_rwlock_trywrlock(a1 + 10) )
    {
      nr_readers = (void **)a1[11].__nr_readers;
      a1[11].__nr_readers = 0;
      v5 = nr_readers;
      if ( pthread_rwlock_unlock(v1) )
      {
        v4 = _errno_location();
        snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", "flush_queue", 9537);
        applog(3, s, 1);
        _quit(1, 1);
      }
      selective_yield(0);
      if ( v5 )
      {
        free_work(&v5, "cgminer.c", "flush_queue", 9541);
        if ( opt_debug )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 6 )
          {
            strcpy(s, "Discarded queued work item");
            applog(7, s, 0);
          }
        }
      }
    }
  }
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (0002155C) --------------------------------------------------------
int __fastcall inc_hw_errors_with_diff(int a1, int a2)
{
  int v4; // r1
  int v5; // r2
  int v6; // r4
  int *v8; // r0
  int *v9; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      s,
      2048u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    applog(3, s, 0);
    if ( pthread_mutex_lock(&stats_lock) )
    {
LABEL_8:
      v8 = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v8,
        "cgminer.c",
        "inc_hw_errors_with_diff",
        8680);
      goto LABEL_9;
    }
  }
  else if ( pthread_mutex_lock(&stats_lock) )
  {
    goto LABEL_8;
  }
  v4 = *(_DWORD *)(a1 + 36);
  v5 = hw_errors + a2;
  v6 = a2 + *(_DWORD *)(v4 + 44);
  hw_errors = v5;
  *(_DWORD *)(v4 + 44) = v6;
  if ( pthread_mutex_unlock(&stats_lock) )
  {
    v9 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v9,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8683);
LABEL_9:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80BA88: using guessed type int hw_errors;
// 80CC18: using guessed type char use_syslog;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;

//----- (00021680) --------------------------------------------------------
int __fastcall inc_hw_errors(int a1)
{
  int v2; // r5
  int v3; // r2
  int *v5; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(
      s,
      2048u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    applog(6, s, 0);
    if ( pthread_mutex_lock(&stats_lock) )
    {
LABEL_8:
      v5 = _errno_location();
      snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v5, "cgminer.c", "inc_hw_errors", 8667);
      goto LABEL_9;
    }
  }
  else if ( pthread_mutex_lock(&stats_lock) )
  {
    goto LABEL_8;
  }
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)(v2 + 44) + 1;
  ++hw_errors;
  *(_DWORD *)(v2 + 44) = v3;
  if ( pthread_mutex_unlock(&stats_lock) )
  {
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "cgminer.c", "inc_hw_errors", 8670);
LABEL_9:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80BA88: using guessed type int hw_errors;
// 80CC18: using guessed type char use_syslog;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;

//----- (000217A0) --------------------------------------------------------
unsigned __int64 __fastcall share_diff(int a1)
{
  double v2; // d7
  unsigned __int64 v3; // r6
  int v4; // r5
  int v5; // r3
  unsigned __int64 *v6; // r3
  unsigned __int64 v7; // t1
  int *v9; // r0
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v2 = (double)*(unsigned __int64 *)(a1 + 216) * 6.27710174e57
     + (double)*(unsigned __int64 *)(a1 + 208) * 3.40282367e38
     + (double)*(unsigned __int64 *)(a1 + 200) * 1.84467441e19
     + (double)*(unsigned __int64 *)(a1 + 192);
  if ( v2 == 0.0 )
    v2 = 0.0;
  round();
  v3 = (unsigned __int64)(2.69595353e67 / v2);
  if ( pthread_mutex_lock(&control_lock) )
  {
    v9 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "cgminer.c", "share_diff", 5073);
    goto LABEL_15;
  }
  if ( pthread_rwlock_wrlock(&rwlock) )
  {
    v10 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v10, "cgminer.c", "share_diff", 5073);
    goto LABEL_15;
  }
  if ( best_diff < v3 )
  {
    best_diff = (unsigned __int64)(2.69595353e67 / v2);
    v4 = 1;
    suffix_string(v3, best_share, 8u, 0);
  }
  else
  {
    v4 = 0;
  }
  v5 = *(_DWORD *)(a1 + 260);
  v7 = *(_QWORD *)(v5 + 368);
  v6 = (unsigned __int64 *)(v5 + 368);
  if ( v7 < v3 )
    *v6 = v3;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v11 = _errno_location();
    snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v11, "cgminer.c", "share_diff", 5087);
    goto LABEL_15;
  }
  if ( pthread_mutex_unlock(&control_lock) )
  {
    v12 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v12, "cgminer.c", "share_diff", 5087);
LABEL_15:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  if ( v4 && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf(s, 2048u, "New best share: %s", best_share);
    applog(6, s, 0);
  }
  return (unsigned __int64)(2.69595353e67 / v2);
}
// 123A4: using guessed type int round(void);
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80F88: using guessed type __int64 best_diff;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;
// 80CC54: using guessed type pthread_mutex_t control_lock;

//----- (000219E8) --------------------------------------------------------
int __fastcall update_work_stats_isra_55(int *a1, int a2)
{
  double v4; // d8
  unsigned __int64 v5; // r0
  double v6; // d8
  int v7; // r6
  int v8; // r4
  _DWORD *v10; // r5
  int v11; // r2
  int v12; // r0
  int v13; // r1
  int *v14; // r0
  int *v15; // r0
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v4 = current_diff;
  v5 = share_diff(a2);
  *(_QWORD *)(a2 + 232) = v5;
  if ( v4 <= (double)v5 )
  {
    v10 = *(_DWORD **)(a2 + 260);
    v11 = v10[8];
    v12 = (unsigned __int8)use_syslog;
    v13 = found_blocks + 1;
    *(_BYTE *)(a2 + 283) = 1;
    found_blocks = v13;
    v10[8] = v11 + 1;
    *(_BYTE *)(a2 + 282) = 1;
    if ( v12 || opt_log_output || opt_log_level > 4 )
    {
      snprintf(s, 2048u, "Found block for pool %d!", *v10);
      applog(5, s, 0);
    }
  }
  if ( pthread_mutex_lock(&stats_lock) )
  {
    v14 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v14, "cgminer.c", "update_work_stats", 8745);
    goto LABEL_9;
  }
  v6 = *(double *)(a2 + 224);
  v7 = *a1;
  *(_QWORD *)&total_diff1 = (__int64)((double)*(__int64 *)&total_diff1 + v6);
  v8 = *(_DWORD *)(a2 + 260);
  *(_QWORD *)(v7 + 192) = (__int64)((double)*(__int64 *)(v7 + 192) + v6);
  *(_QWORD *)(v8 + 40) = (__int64)((double)*(__int64 *)(v8 + 40) + v6);
  *(_DWORD *)(v7 + 232) = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
  {
    v15 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v15,
      "cgminer.c",
      "update_work_stats",
      8750);
LABEL_9:
    applog(3, s, 1);
    _quit(1, 1);
  }
  return selective_yield(0);
}
// 7DEF0: using guessed type double current_diff;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80BB7C: using guessed type int found_blocks;
// 80CC18: using guessed type char use_syslog;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;
// 80EF60: using guessed type int total_diff1;

//----- (00021B9C) --------------------------------------------------------
int __fastcall submit_nonce_1(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int v7; // r4
  char v9[2064]; // [sp+0h] [bp-810h] BYREF

  if ( a4 )
    *a4 = 0;
  a2[19] = a3;
  regen_hash((int)a2);
  if ( a2[55] )
  {
    inc_hw_errors(a1);
    return 0;
  }
  else
  {
    update_work_stats_isra_55((int *)(a1 + 36), (int)a2);
    v7 = fulltest(a2 + 48, a2 + 40);
    if ( !v7 )
    {
      if ( a4 )
        *a4 = 1;
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        strcpy(v9, "Share above target");
        applog(6, v9, 0);
      }
      else
      {
        return (unsigned __int8)opt_log_output;
      }
    }
    return v7;
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00021C44) --------------------------------------------------------
void __fastcall clear_pool_work(_DWORD *a1)
{
  _DWORD *v2; // r2
  int i; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r0
  _DWORD *v7; // lr
  int v8; // r10
  int v9; // r12
  int v10; // r1
  int v11; // r12
  int *v12; // r0
  int v13; // r12
  int v14; // r3
  _DWORD *v15; // r1
  _DWORD *v16; // r10
  int v17; // r1
  int v18; // r3
  int v19; // r1
  int v20; // r10
  int v21; // r11
  int *v22; // r0
  int *v23; // r0
  int v24; // [sp+10h] [bp-838h]
  void **v25; // [sp+1Ch] [bp-82Ch] BYREF
  char s[2088]; // [sp+20h] [bp-828h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)stgd_lock) )
  {
    v22 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v22, "cgminer.c", "clear_pool_work", 7311);
    goto LABEL_38;
  }
  v2 = (_DWORD *)staged_work;
  v25 = (void **)staged_work;
  if ( !staged_work )
  {
    if ( !pthread_mutex_unlock((pthread_mutex_t *)stgd_lock) )
    {
      selective_yield(0);
      return;
    }
    goto LABEL_39;
  }
  v24 = 0;
  for ( i = *(_DWORD *)(staged_work + 352); ; i = v4 )
  {
    if ( (_DWORD *)v2[65] != a1 )
      goto LABEL_4;
    v5 = v2[87];
    if ( v5 )
    {
      v6 = staged_work;
      v7 = v2 + 86;
      v8 = *(_DWORD *)(staged_work + 344);
      v9 = *(_DWORD *)(v8 + 20);
      v10 = v5 + v9;
      if ( v2 == (_DWORD *)(*(_DWORD *)(v8 + 16) - v9) )
        *(_DWORD *)(v8 + 16) = v10;
      *(_DWORD *)(v10 + 8) = v2[88];
      v11 = v2[88];
LABEL_13:
      v12 = *(int **)(v6 + 344);
      if ( v11 )
        *(_DWORD *)(v12[5] + v11 + 4) = v5;
      v13 = *v12;
      v14 = 3 * (v2[93] & (v12[1] - 1));
      v15 = (_DWORD *)(*v12 + 12 * (v2[93] & (v12[1] - 1)));
      v16 = (_DWORD *)*v15;
      --v15[1];
      v17 = v2[90];
      if ( v16 == v7 )
        *(_DWORD *)(v13 + 4 * v14) = v17;
      v18 = v2[89];
      if ( v18 )
      {
        *(_DWORD *)(v18 + 16) = v17;
        v17 = v2[90];
      }
      if ( v17 )
        *(_DWORD *)(v17 + 12) = v18;
      --v12[3];
      goto LABEL_22;
    }
    v19 = v2[88];
    v11 = v19;
    if ( v19 )
    {
      v7 = v2 + 86;
      v20 = *(_DWORD *)(staged_work + 344);
      v21 = *(_DWORD *)(v20 + 20);
      if ( v2 == (_DWORD *)(*(_DWORD *)(v20 + 16) - v21) )
      {
        *(_DWORD *)(v20 + 16) = v21;
        v11 = v19;
      }
      v6 = v19;
      staged_work = v19;
      goto LABEL_13;
    }
    free(**(void ***)(staged_work + 344));
    free(*(void **)(staged_work + 344));
    staged_work = 0;
LABEL_22:
    ++v24;
    free_work(&v25, "cgminer.c", "clear_pool_work", 7317);
LABEL_4:
    v25 = (void **)i;
    v4 = i;
    if ( i )
      v4 = *(_DWORD *)(i + 352);
    v2 = (_DWORD *)i;
    if ( !i )
      break;
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)stgd_lock) )
  {
LABEL_39:
    v23 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v23, "cgminer.c", "clear_pool_work", 7321);
LABEL_38:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  if ( v24 && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf(s, 2048u, "Cleared %d work items due to stratum disconnect on pool %d", v24, *a1);
    applog(6, s, 0);
  }
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FAC: using guessed type int stgd_lock;
// 81084: using guessed type int staged_work;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00021E94) --------------------------------------------------------
int __fastcall switch_pools(int a1)
{
  _DWORD *v2; // r6
  int v3; // r9
  int v4; // r0
  int *v5; // r2
  int v6; // r7
  int v7; // r1
  int v8; // t1
  int v9; // r3
  int v10; // r4
  int v11; // r0
  _DWORD *v12; // r4
  int v14; // r7
  int v15; // r10
  int v16; // r1
  int v17; // r8
  int v18; // r3
  _DWORD *v19; // r1
  int v20; // r3
  int v21; // r4
  int *v22; // r0
  int *v23; // r0
  int v24; // r3
  int v25; // r4
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  if ( pthread_mutex_lock(&control_lock) )
  {
    v20 = *_errno_location();
    v21 = 5166;
LABEL_47:
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v20, "cgminer.c", "switch_pools", v21);
    goto LABEL_48;
  }
  if ( pthread_rwlock_wrlock(&rwlock) )
  {
    v22 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v22, "cgminer.c", "switch_pools", 5166);
    goto LABEL_48;
  }
  v2 = (_DWORD *)currentpool;
  v3 = *(_DWORD *)currentpool;
  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 4);
    if ( v4 )
    {
      if ( total_pools > 0 )
      {
        v5 = (int *)pools;
        v6 = pools + 4 * total_pools;
        while ( 1 )
        {
          v8 = *v5++;
          v7 = v8;
          v9 = *(_DWORD *)(v8 + 4);
          if ( v9 < v4 )
            *(_DWORD *)(v7 + 4) = v9 + 1;
          if ( (int *)v6 == v5 )
            break;
          v4 = *(_DWORD *)(a1 + 4);
        }
      }
      *(_DWORD *)(a1 + 4) = 0;
    }
    switch ( pool_strategy )
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_13;
      case 1:
      case 2:
        if ( *(_BYTE *)(a1 + 97) )
          goto LABEL_31;
        v12 = *(_DWORD **)(pools + 4 * *(_DWORD *)a1);
        break;
      default:
        goto LABEL_18;
    }
  }
  else
  {
    switch ( pool_strategy )
    {
      case 0:
      case 3:
      case 4:
LABEL_13:
        if ( total_pools <= 0 )
          goto LABEL_18;
        v10 = 0;
        while ( 1 )
        {
          v11 = priority_pool(v10);
          if ( !*(_BYTE *)(v11 + 97) && *(_DWORD *)(v11 + 100) == 1 && !pool_unusable_part_4((unsigned __int8 *)v11) )
            break;
          if ( total_pools <= ++v10 )
            goto LABEL_18;
        }
        v12 = *(_DWORD **)(pools + 4 * *v19);
        break;
      case 1:
      case 2:
LABEL_31:
        v14 = total_pools;
        if ( total_pools <= 1 )
        {
LABEL_18:
          v12 = *(_DWORD **)(pools + 4 * v3);
        }
        else
        {
          v15 = pools;
          v16 = v3;
          v17 = 1;
          while ( 1 )
          {
            if ( v14 <= ++v16 )
            {
              v16 = 0;
              v18 = 0;
            }
            else
            {
              v18 = 4 * v16;
            }
            v12 = *(_DWORD **)(v15 + v18);
            if ( !*((_BYTE *)v12 + 97) && v12[25] == 1 && !pool_unusable_part_4((unsigned __int8 *)v12) )
              break;
            if ( v14 == ++v17 )
            {
              v12 = *(_DWORD **)(v15 + 4 * v3);
              goto LABEL_19;
            }
          }
        }
        break;
      default:
        v12 = *(_DWORD **)(pools + 4 * v3);
        break;
    }
  }
LABEL_19:
  currentpool = (int)v12;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v23 = _errno_location();
    snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v23, "cgminer.c", "switch_pools", 5247);
    goto LABEL_48;
  }
  if ( pthread_mutex_unlock(&control_lock) )
  {
    v24 = *_errno_location();
    v25 = 5247;
LABEL_52:
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v24, "cgminer.c", "switch_pools", v25);
LABEL_48:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  if ( v2 != v12 && (unsigned int)(pool_strategy - 3) > 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(s, 2048u, "Switching to pool %d %s", *v12, (const char *)v12[41]);
      applog(4, s, 0);
    }
    clear_pool_work(v2);
  }
  if ( pthread_mutex_lock(&lp_lock) )
  {
    v20 = *_errno_location();
    v21 = 5255;
    goto LABEL_47;
  }
  pthread_cond_broadcast(&lp_cond);
  if ( pthread_mutex_unlock(&lp_lock) )
  {
    v24 = *_errno_location();
    v25 = 5257;
    goto LABEL_52;
  }
  return selective_yield(0);
}
// 2202E: variable 'v16' is possibly undefined
// 22080: variable 'v19' is possibly undefined
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80F6C: using guessed type int pool_strategy;
// 80FFC: using guessed type int currentpool;
// 80B6C8: using guessed type char opt_log_output;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;
// 80CC54: using guessed type pthread_mutex_t control_lock;

//----- (000221C4) --------------------------------------------------------
void __fastcall pool_died(int a1)
{
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  if ( !pool_tset(a1, (_BYTE *)(a1 + 97)) )
  {
    cgtime((struct timeval *)(a1 + 136));
    if ( a1 == current_pool() )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(s, 2048u, "Pool %d %s not responding!", *(_DWORD *)a1, *(const char **)(a1 + 164));
        applog(4, s, 0);
      }
      switch_pools(0);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(s, 2048u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 164));
      applog(6, s, 0);
    }
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00022288) --------------------------------------------------------
void __noreturn watchpool_thread()
{
  int v0; // r11
  int v1; // r5
  _DWORD *v2; // r4
  __int64 v3; // r6
  double v4; // r0
  double v5; // d7
  double v6; // d6
  int v7; // r6
  _DWORD *v8; // r3
  int v9; // r7
  int v10; // r5
  _DWORD *v11; // r6
  int v12; // r1
  _DWORD *v13; // r0
  int v14; // r2
  _DWORD *v15; // r3
  int v16; // r2
  int v17; // r6
  char *v18; // r0
  int v19; // r7
  int v20; // r6
  int v21; // r1
  int **v22; // r0
  int v23; // r3
  int v24; // r2
  int v25; // r3
  int v26; // r3
  int *v27; // r2
  int v28; // r0
  int v29; // r3
  int *v30; // lr
  int v31; // r12
  int v32; // r1
  int v33; // r3
  __int64 v34; // r2
  const char *v35; // r4
  int *v36; // r0
  int v37; // r1
  int *v38; // r0
  int v39; // r3
  int v40; // lr
  int *v41; // r0
  int v42; // [sp+14h] [bp-86Ch]
  int v43; // [sp+14h] [bp-86Ch]
  pthread_mutex_t *mutex; // [sp+18h] [bp-868h]
  pthread_mutex_t *mutexa; // [sp+18h] [bp-868h]
  void **v46; // [sp+28h] [bp-858h]
  struct timespec tp; // [sp+30h] [bp-850h] BYREF
  struct timeval v48; // [sp+38h] [bp-848h] BYREF
  struct timeval v49; // [sp+40h] [bp-840h] BYREF
  char s[2104]; // [sp+48h] [bp-838h] BYREF

  pthread_setcanceltype(1, 0);
  RenameThread("Watchpool");
  set_lowprio();
  cgtimer_time(&tp);
  v0 = 0;
  while ( 1 )
  {
    if ( ++v0 >= 121 )
      v0 = 0;
    cgtime(&v48);
    if ( total_pools > 0 )
    {
      v1 = 0;
      while ( 1 )
      {
        v2 = *(_DWORD **)(pools + 4 * v1);
        if ( !opt_benchmark && !opt_benchfile )
          break;
LABEL_14:
        if ( v0 == 120 )
        {
          v3 = *((_QWORD *)v2 + 5);
          v4 = (double)(v3 - (int)v2[38]);
          v5 = *((double *)v2 + 18);
          v2[38] = v3;
          v6 = (v5 + v4 * 0.63) / 1.63;
          *((double *)v2 + 18) = v6;
          v2[39] = (int)v6;
        }
        if ( !v2[25] || *((_BYTE *)v2 + 284) )
          goto LABEL_11;
        if ( pool_active(v2, 1) )
        {
          if ( pool_tclear((int)v2, (_BYTE *)v2 + 97) )
            pool_resus(v2);
        }
        else
        {
          cgtime((struct timeval *)v2 + 17);
        }
        if ( *((_BYTE *)v2 + 97)
          || pool_strategy
          || (v7 = v2[1], v7 >= cp_prio())
          || v48.tv_sec - v2[34] <= opt_pool_fallback )
        {
LABEL_11:
          if ( total_pools <= ++v1 )
            goto LABEL_27;
        }
        else
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(s, 2048u, "Pool %d %s stable for >%d seconds", *v2, (const char *)v2[41], opt_pool_fallback);
            applog(4, s, 0);
          }
          ++v1;
          switch_pools(0);
          if ( total_pools <= v1 )
            goto LABEL_27;
        }
      }
      mutex = (pthread_mutex_t *)(v2 + 47);
      cgtime(&v49);
      if ( pthread_mutex_lock((pthread_mutex_t *)(v2 + 47)) )
      {
        v38 = _errno_location();
        snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v38, "cgminer.c", "reap_curl", 10046);
        goto LABEL_85;
      }
      v8 = (_DWORD *)v2[86];
      v9 = *v8 - 4;
      if ( v2 + 86 != v8 )
      {
        if ( (int)v2[72] <= 1 )
          goto LABEL_46;
        v42 = v1;
        v10 = 0;
        v11 = v2 + 86;
        v12 = v2[72];
        v13 = v8 - 1;
        while ( 1 )
        {
          if ( v49.tv_sec - v13[3] <= 300 )
          {
            v14 = *(_DWORD *)(v9 + 4) - 4;
            if ( v11 == (_DWORD *)(v9 + 4) )
              goto LABEL_39;
          }
          else
          {
            v15 = (_DWORD *)v13[2];
            v16 = v13[1];
            ++v10;
            v2[72] = v12 - 1;
            *(_DWORD *)(v16 + 4) = v15;
            *v15 = v16;
            free(v13);
            v14 = *(_DWORD *)(v9 + 4) - 4;
            if ( v11 == (_DWORD *)(v9 + 4) )
            {
LABEL_39:
              v17 = v10;
              v1 = v42;
              if ( pthread_mutex_unlock(mutex) )
                goto LABEL_92;
              ((void (*)(void))selective_yield)();
              if ( v17 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                v18 = "s";
                if ( v17 == 1 )
                  v18 = "";
                snprintf(s, 2048u, "Reaped %d curl%s from pool %d", v17, v18, *v2);
                applog(7, s, 0);
              }
              goto LABEL_46;
            }
          }
          v12 = v2[72];
          v13 = (_DWORD *)v9;
          if ( v12 <= 1 )
          {
            v1 = v42;
            goto LABEL_46;
          }
          v9 = v14;
        }
      }
      if ( pthread_mutex_unlock(mutex) )
      {
LABEL_92:
        v36 = _errno_location();
        v35 = "reap_curl";
        v37 = 10064;
LABEL_84:
        snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v36, "cgminer.c", v35, v37);
LABEL_85:
        applog(3, s, 1);
        _quit(1, 1);
      }
      ((void (*)(void))selective_yield)();
LABEL_46:
      mutexa = (pthread_mutex_t *)time(0);
      if ( pthread_mutex_lock(&sshare_lock) )
      {
        v41 = _errno_location();
        snprintf(
          s,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v41,
          "cgminer.c",
          "prune_stratum_shares",
          10082);
        goto LABEL_85;
      }
      v19 = stratum_shares;
      if ( !stratum_shares )
      {
        if ( pthread_mutex_unlock(&sshare_lock) )
        {
LABEL_83:
          v35 = "prune_stratum_shares";
          v36 = _errno_location();
          v37 = 10095;
          goto LABEL_84;
        }
        ((void (*)(void))selective_yield)();
        goto LABEL_14;
      }
      v20 = *(_DWORD *)(stratum_shares + 8);
      v43 = 0;
      if ( v2 == *(_DWORD **)(*(_DWORD *)(stratum_shares + 36) + 260) )
        goto LABEL_51;
      while ( 2 )
      {
        while ( 2 )
        {
          if ( !v20 )
          {
LABEL_66:
            if ( pthread_mutex_unlock(&sshare_lock) )
              goto LABEL_83;
            ((void (*)(void))selective_yield)();
            if ( v43 )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 3 )
              {
                snprintf(s, 2048u, "Lost %d shares due to no stratum share response from pool %d", v43, *v2);
                applog(4, s, 0);
              }
              v34 = *(_QWORD *)&total_stale;
              v2[30] += v43;
              *(_QWORD *)&total_stale = v34 + v43;
            }
            goto LABEL_14;
          }
LABEL_50:
          v19 = v20;
          v20 = *(_DWORD *)(v20 + 8);
          if ( v2 != *(_DWORD **)(*(_DWORD *)(v19 + 36) + 260) )
            continue;
          break;
        }
LABEL_51:
        if ( (int)mutexa <= *(_DWORD *)(v19 + 44) + 120 )
          continue;
        break;
      }
      v21 = *(_DWORD *)(v19 + 4);
      if ( v21 )
      {
        v22 = (int **)stratum_shares;
        v23 = *(_DWORD *)(*(_DWORD *)stratum_shares + 20);
        v24 = *(_DWORD *)(*(_DWORD *)stratum_shares + 16) - v23;
        v25 = v23 + v21;
        if ( v19 == v24 )
          *(_DWORD *)(*(_DWORD *)stratum_shares + 16) = v25;
        *(_DWORD *)(v25 + 8) = *(_DWORD *)(v19 + 8);
        goto LABEL_56;
      }
      v39 = *(_DWORD *)(v19 + 8);
      if ( v39 )
      {
        v40 = *(_DWORD *)(*(_DWORD *)stratum_shares + 20);
        if ( v19 == *(_DWORD *)(*(_DWORD *)stratum_shares + 16) - v40 )
          *(_DWORD *)(*(_DWORD *)stratum_shares + 16) = v40;
        v22 = (int **)v39;
        stratum_shares = v39;
LABEL_56:
        v26 = *(_DWORD *)(v19 + 8);
        v27 = *v22;
        if ( v26 )
          *(_DWORD *)(v26 + v27[5] + 4) = v21;
        v28 = *v27;
        v29 = 3 * (*(_DWORD *)(v19 + 28) & (v27[1] - 1));
        v30 = (int *)(*v27 + 12 * (*(_DWORD *)(v19 + 28) & (v27[1] - 1)));
        v31 = *v30;
        --v30[1];
        v32 = *(_DWORD *)(v19 + 16);
        if ( v31 == v19 )
          *(_DWORD *)(v28 + 4 * v29) = v32;
        v33 = *(_DWORD *)(v19 + 12);
        if ( v33 )
        {
          *(_DWORD *)(v33 + 16) = v32;
          v32 = *(_DWORD *)(v19 + 16);
        }
        if ( v32 )
          *(_DWORD *)(v32 + 12) = v33;
        --v27[3];
      }
      else
      {
        v46 = (void **)stratum_shares;
        free(**(void ***)stratum_shares);
        free(*v46);
        stratum_shares = 0;
      }
      ++v43;
      free_work((void ***)(v19 + 36), "cgminer.c", "prune_stratum_shares", 10089);
      free((void *)v19);
      if ( !v20 )
        goto LABEL_66;
      goto LABEL_50;
    }
LABEL_27:
    if ( *(_BYTE *)(current_pool() + 97) )
    {
      switch_pools(0);
      if ( pool_strategy != 2 )
        goto LABEL_29;
    }
    else if ( pool_strategy != 2 )
    {
      goto LABEL_29;
    }
    if ( v48.tv_sec - rotate_tv > 60 * opt_rotate_period )
    {
      cgtime((struct timeval *)&rotate_tv);
      switch_pools(0);
    }
LABEL_29:
    cgsleep_ms_r(&tp);
    cgtimer_time(&tp);
  }
}
// 22288: using guessed type void __noreturn watchpool_thread();
// 7DEF8: using guessed type int opt_pool_fallback;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80F6C: using guessed type int pool_strategy;
// 80F9C: using guessed type int opt_benchfile;
// 810D0: using guessed type char opt_benchmark;
// 810EC: using guessed type int stratum_shares;
// 810F0: using guessed type int rotate_tv;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA38: using guessed type int total_stale;
// 80BAEC: using guessed type int total_pools;
// 80BB84: using guessed type int opt_rotate_period;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;

//----- (00022848) --------------------------------------------------------
int *__fastcall clear_stratum_shares(int a1)
{
  int v2; // r4
  int v3; // r3
  int v4; // r5
  int v5; // r7
  double v6; // d8
  int *v7; // r1
  int **v8; // lr
  int v9; // r2
  int v10; // r0
  int v11; // r2
  bool v12; // zf
  int v13; // r0
  int **v14; // r2
  int *v15; // r1
  int v16; // r0
  int v17; // lr
  int v18; // r2
  int *v19; // r12
  int v20; // r11
  int v21; // r0
  int v22; // r2
  int *result; // r0
  double v24; // d6
  double v25; // d8
  __int64 v26; // r2
  int v27; // r7
  int v28; // r0
  int v29; // r12
  int *v30; // r0
  int *v31; // r0
  void **v32; // r11
  char s[2096]; // [sp+18h] [bp-830h] BYREF

  if ( pthread_mutex_lock(&sshare_lock) )
  {
    v30 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v30,
      "cgminer.c",
      "clear_stratum_shares",
      7280);
    goto LABEL_35;
  }
  v2 = stratum_shares;
  if ( !stratum_shares )
  {
    if ( !pthread_mutex_unlock(&sshare_lock) )
      return (int *)selective_yield(0);
    goto LABEL_36;
  }
  v3 = *(_DWORD *)(stratum_shares + 36);
  v4 = *(_DWORD *)(stratum_shares + 8);
  v5 = 0;
  v6 = 0.0;
  if ( *(_DWORD *)(v3 + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  if ( v4 )
  {
    while ( 1 )
    {
      v2 = v4;
      v4 = *(_DWORD *)(v4 + 8);
      v3 = *(_DWORD *)(v2 + 36);
      if ( *(_DWORD *)(v3 + 260) != a1 )
        goto LABEL_4;
LABEL_6:
      v7 = *(int **)(v2 + 4);
      if ( v7 )
        break;
      v14 = *(int ***)(v2 + 8);
      if ( v14 )
      {
        v28 = stratum_shares;
        stratum_shares = *(_DWORD *)(v2 + 8);
        v29 = *(_DWORD *)(*(_DWORD *)v28 + 20);
        if ( v2 == *(_DWORD *)(*(_DWORD *)v28 + 16) - v29 )
          *(_DWORD *)(*(_DWORD *)v28 + 16) = v29;
        v8 = v14;
LABEL_10:
        *(int **)((char *)v14 + (*v8)[5] + 4) = v7;
LABEL_11:
        v15 = *v8;
        v16 = (*v8)[1];
        v17 = **v8;
        v18 = 3 * (*(_DWORD *)(v2 + 28) & (v16 - 1));
        v19 = (int *)(v17 + 12 * (*(_DWORD *)(v2 + 28) & (v16 - 1)));
        v20 = *v19;
        --v19[1];
        v21 = *(_DWORD *)(v2 + 16);
        if ( v20 == v2 )
          *(_DWORD *)(v17 + 4 * v18) = v21;
        v22 = *(_DWORD *)(v2 + 12);
        if ( v22 )
        {
          *(_DWORD *)(v22 + 16) = v21;
          v21 = *(_DWORD *)(v2 + 16);
        }
        if ( v21 )
          *(_DWORD *)(v21 + 12) = v22;
        --v15[3];
        goto LABEL_18;
      }
      v32 = (void **)stratum_shares;
      free(**(void ***)stratum_shares);
      free(*v32);
      v3 = *(_DWORD *)(v2 + 36);
      stratum_shares = 0;
LABEL_18:
      ++v5;
      v6 = v6 + *(double *)(v3 + 376);
      free_work((void ***)(v2 + 36), "cgminer.c", "clear_stratum_shares", 7288);
      --*(_DWORD *)(a1 + 732);
      free((void *)v2);
      if ( !v4 )
        goto LABEL_19;
    }
    v8 = (int **)stratum_shares;
    v9 = *(_DWORD *)(*(_DWORD *)stratum_shares + 20);
    v10 = *(_DWORD *)(*(_DWORD *)stratum_shares + 16) - v9;
    v11 = (int)v7 + v9;
    v12 = v2 == v10;
    v13 = *(_DWORD *)(v2 + 8);
    if ( v12 )
      *(_DWORD *)(*(_DWORD *)stratum_shares + 16) = v11;
    *(_DWORD *)(v11 + 8) = v13;
    v14 = *(int ***)(v2 + 8);
    if ( v14 )
      goto LABEL_10;
    goto LABEL_11;
  }
LABEL_19:
  if ( pthread_mutex_unlock(&sshare_lock) )
  {
LABEL_36:
    v31 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v31,
      "cgminer.c",
      "clear_stratum_shares",
      7294);
LABEL_35:
    applog(3, s, 1);
    _quit(1, 1);
  }
  result = (int *)selective_yield(0);
  if ( v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(s, 2048u, "Lost %d shares due to stratum disconnect on pool %d", v5, *(_DWORD *)a1);
      applog(4, s, 0);
    }
    result = &total_stale;
    v24 = *(double *)(a1 + 88) + v6;
    v25 = *(double *)total_diff_stale + v6;
    v26 = *(_QWORD *)&total_stale + v5;
    v27 = v5 + *(_DWORD *)(a1 + 120);
    *(double *)(a1 + 88) = v24;
    *(_QWORD *)&total_stale = v26;
    *(_DWORD *)(a1 + 120) = v27;
    *(double *)total_diff_stale = v25;
  }
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 810EC: using guessed type int stratum_shares;
// 80B6C8: using guessed type char opt_log_output;
// 80BA38: using guessed type int total_stale;
// 80CC18: using guessed type char use_syslog;

//----- (00022AE0) --------------------------------------------------------
void __fastcall sharelog(const char *a1, int a2)
{
  int v2; // r6
  int v4; // r11
  int v5; // r10
  char *v6; // r8
  char *v7; // r7
  char *v8; // r9
  int v9; // r4
  size_t v10; // r4
  const char *v11; // r4
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int *v16; // r4
  int v17; // r1
  int *v18; // r0
  int *v19; // r0
  int v21; // [sp+24h] [bp-C2Ch]
  char s[1024]; // [sp+28h] [bp-C28h] BYREF
  int v23[5]; // [sp+428h] [bp-828h] BYREF
  __int16 v24; // [sp+43Ch] [bp-814h]

  if ( sharelog_file )
  {
    v2 = *(_DWORD *)(a2 + 256);
    v4 = *(_DWORD *)(get_thread(v2) + 36);
    v5 = *(_DWORD *)(a2 + 260);
    v21 = *(_DWORD *)(a2 + 432);
    v6 = bin2hex((unsigned __int8 *)(a2 + 160), 32);
    v7 = bin2hex((unsigned __int8 *)(a2 + 192), 32);
    v8 = bin2hex((unsigned __int8 *)a2, 128);
    v9 = snprintf(
           s,
           1024u,
           "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
           v21,
           a1,
           v6,
           *(const char **)(v5 + 164),
           *(const char **)(*(_DWORD *)(v4 + 4) + 8),
           *(_DWORD *)(v4 + 8),
           v2,
           v7,
           v8);
    free(v6);
    free(v7);
    free(v8);
    if ( v9 >= 1024 )
    {
      s[1023] = 0;
      goto LABEL_5;
    }
    if ( v9 >= 0 )
    {
LABEL_5:
      if ( pthread_mutex_lock(&sharelog_lock) )
      {
        v19 = _errno_location();
        snprintf(
          (char *)v23,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v19,
          "cgminer.c",
          "sharelog",
          655);
      }
      else
      {
        v10 = fwrite(s, v9, 1u, (FILE *)sharelog_file);
        fflush((FILE *)sharelog_file);
        if ( !pthread_mutex_unlock(&sharelog_lock) )
        {
          selective_yield(0);
          if ( v10 == 1 || !use_syslog && !opt_log_output && opt_log_level <= 2 )
            return;
          v11 = "sharelog fwrite error";
LABEL_11:
          v12 = *(_DWORD *)v11;
          v13 = *((_DWORD *)v11 + 1);
          v14 = *((_DWORD *)v11 + 2);
          v15 = *((_DWORD *)v11 + 3);
          v16 = (int *)(v11 + 16);
          v23[0] = v12;
          v23[1] = v13;
          v23[2] = v14;
          v23[3] = v15;
          v17 = v16[1];
          v23[4] = *v16;
          v24 = v17;
          applog(3, (const char *)v23, 0);
          return;
        }
        v18 = _errno_location();
        snprintf(
          (char *)v23,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v18,
          "cgminer.c",
          "sharelog",
          658);
      }
      applog(3, (const char *)v23, 1);
      _quit(1, 1);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v11 = "sharelog printf error";
      goto LABEL_11;
    }
  }
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B68: using guessed type int sharelog_file;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00022CCC) --------------------------------------------------------
int __fastcall hash_pop(int a1)
{
  int v2; // r1
  int v3; // r3
  int v4; // r2
  int v5; // r6
  int v6; // r1
  int v7; // r0
  int v8; // r7
  int v9; // r1
  int v10; // r1
  int *v11; // r2
  int v12; // r6
  int v13; // r3
  int v14; // lr
  int v15; // r1
  int v16; // r3
  int v18; // r7
  int *v19; // r0
  int *v20; // r0
  struct timespec abstime; // [sp+18h] [bp-828h] BYREF
  struct timeval v22; // [sp+20h] [bp-820h] BYREF
  char s[2072]; // [sp+28h] [bp-818h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)stgd_lock) )
  {
    v19 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v19, "cgminer.c", "hash_pop", 8085);
    goto LABEL_57;
  }
  if ( !staged_work || !*(_DWORD *)(*(_DWORD *)(staged_work + 344) + 12) )
  {
    if ( !a1 )
      goto LABEL_33;
    do
    {
      cgtime(&v22);
      abstime.tv_sec = v22.tv_sec + 10;
      abstime.tv_nsec = 1000 * v22.tv_usec;
      pthread_cond_signal(&gws_cond);
      if ( pthread_cond_timedwait((pthread_cond_t *)(getq + 40), (pthread_mutex_t *)stgd_lock, &abstime) )
      {
        if ( !no_work )
        {
          no_work = 1;
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy(s, "Waiting for work to be available from pools.");
            applog(4, s, 0);
          }
        }
      }
    }
    while ( !staged_work || !*(_DWORD *)(*(_DWORD *)(staged_work + 344) + 12) );
  }
  if ( no_work )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy(s, "Work available from pools, resuming.");
      applog(4, s, 0);
    }
    v2 = staged_work;
    no_work = 0;
    if ( !staged_work )
    {
      if ( staged_rollable >= 0 )
      {
        v4 = MEMORY[0x160];
        a1 = 0;
        v3 = MEMORY[0x158];
        goto LABEL_17;
      }
LABEL_47:
      __und(255u);
    }
  }
  else
  {
    v2 = staged_work;
  }
  v3 = *(_DWORD *)(v2 + 344);
  if ( staged_rollable >= *(_DWORD *)(v3 + 12) )
  {
    v4 = *(_DWORD *)(v2 + 352);
    a1 = v2;
    goto LABEL_17;
  }
  a1 = *(_DWORD *)(v2 + 352);
  if ( !*(_BYTE *)(v2 + 273) && *(_DWORD *)(v2 + 276) )
  {
    if ( a1 )
    {
      while ( 1 )
      {
        v4 = *(_DWORD *)(a1 + 352);
        if ( *(_BYTE *)(a1 + 273) || !*(_DWORD *)(a1 + 276) )
          break;
        a1 = *(_DWORD *)(a1 + 352);
        if ( !v4 )
          goto LABEL_47;
      }
      v3 = *(_DWORD *)(v2 + 344);
LABEL_17:
      v5 = *(_DWORD *)(a1 + 348);
      if ( v5 )
        goto LABEL_18;
      goto LABEL_49;
    }
    goto LABEL_47;
  }
  v4 = *(_DWORD *)(v2 + 352);
  a1 = v2;
  v5 = *(_DWORD *)(v2 + 348);
  if ( v5 )
  {
LABEL_18:
    v6 = *(_DWORD *)(v3 + 20);
    v7 = a1 + 344;
    v8 = *(_DWORD *)(v3 + 16) - v6;
    v9 = v6 + v5;
    if ( a1 == v8 )
      *(_DWORD *)(v3 + 16) = v9;
    *(_DWORD *)(v9 + 8) = v4;
    v4 = *(_DWORD *)(a1 + 352);
    v10 = staged_work;
    if ( !v4 )
      goto LABEL_22;
    goto LABEL_21;
  }
LABEL_49:
  if ( v4 )
  {
    v18 = *(_DWORD *)(v3 + 20);
    v7 = a1 + 344;
    if ( a1 == *(_DWORD *)(v3 + 16) - v18 )
      *(_DWORD *)(v3 + 16) = v18;
    v10 = v4;
    staged_work = v4;
LABEL_21:
    *(_DWORD *)(v4 + *(_DWORD *)(*(_DWORD *)(v10 + 344) + 20) + 4) = v5;
LABEL_22:
    v11 = *(int **)(v10 + 344);
    v12 = *v11;
    v13 = 12 * (*(_DWORD *)(a1 + 372) & (v11[1] - 1));
    v14 = *(_DWORD *)(*v11 + v13);
    --*(_DWORD *)(*v11 + v13 + 4);
    v15 = *(_DWORD *)(a1 + 360);
    if ( v14 == v7 )
      *(_DWORD *)(v12 + v13) = v15;
    v16 = *(_DWORD *)(a1 + 356);
    if ( v16 )
    {
      *(_DWORD *)(v16 + 16) = v15;
      v15 = *(_DWORD *)(a1 + 360);
    }
    if ( v15 )
      *(_DWORD *)(v15 + 12) = v16;
    --v11[3];
    goto LABEL_29;
  }
  free(*(void **)v3);
  free(*(void **)(staged_work + 344));
  staged_work = 0;
LABEL_29:
  if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
    --staged_rollable;
  pthread_cond_signal(&gws_cond);
  pthread_cond_signal((pthread_cond_t *)(getq + 40));
  last_getwork = time(0);
LABEL_33:
  if ( pthread_mutex_unlock((pthread_mutex_t *)stgd_lock) )
  {
    v20 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v20, "cgminer.c", "hash_pop", 8157);
LABEL_57:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  return a1;
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FAC: using guessed type int stgd_lock;
// 81000: using guessed type char no_work;
// 81084: using guessed type int staged_work;
// 81110: using guessed type int staged_rollable;
// 80B6C8: using guessed type char opt_log_output;
// 80CBBC: using guessed type int last_getwork;
// 80CBE8: using guessed type pthread_cond_t gws_cond;
// 80CC18: using guessed type char use_syslog;
// 80DCF8: using guessed type int getq;

//----- (00023014) --------------------------------------------------------
int __fastcall test_pool_thread(_DWORD *a1)
{
  int result; // r0
  int v3; // r5
  int v4; // r0
  pthread_t v5; // r0
  int *v6; // r0
  int *v7; // r0
  int *v8; // r0
  int *v9; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  if ( !*((_BYTE *)a1 + 107) )
  {
    v5 = pthread_self();
    pthread_detach(v5);
  }
  while ( 1 )
  {
    if ( *((_BYTE *)a1 + 105) )
      return 0;
    if ( pool_active(a1, 0) )
      break;
    pool_died((int)a1);
    if ( *((_BYTE *)a1 + 107) )
      goto LABEL_21;
    sleep(30u);
  }
  pool_tclear((int)a1, (_BYTE *)a1 + 97);
  if ( pthread_mutex_lock(&control_lock) )
  {
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "cgminer.c", "test_pool_thread", 10662);
    goto LABEL_23;
  }
  if ( pthread_rwlock_wrlock(&rwlock) )
  {
    v7 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v7, "cgminer.c", "test_pool_thread", 10662);
    goto LABEL_23;
  }
  v3 = 0;
  if ( !pools_active )
  {
    v4 = *a1;
    currentpool = (int)a1;
    pools_active = 1;
    v3 = v4;
    if ( v4 )
      v3 = 1;
  }
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v8,
      "cgminer.c",
      "test_pool_thread",
      10676);
    goto LABEL_23;
  }
  if ( pthread_mutex_unlock(&control_lock) )
  {
    v9 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v9, "cgminer.c", "test_pool_thread", 10676);
LABEL_23:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  if ( v3 && (use_syslog || opt_log_output || opt_log_level > 4) )
  {
    snprintf(s, 2048u, "Switching to pool %d %s - first alive pool", *a1, (const char *)a1[41]);
    applog(5, s, 0);
  }
  pool_resus(a1);
  switch_pools(0);
LABEL_21:
  result = 0;
  *((_BYTE *)a1 + 284) = 0;
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FFC: using guessed type int currentpool;
// 81114: using guessed type char pools_active;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;
// 80CC54: using guessed type pthread_mutex_t control_lock;

//----- (000231E8) --------------------------------------------------------
int __fastcall gen_stratum_work(int a1, int a2)
{
  void *v4; // r0
  size_t v5; // r2
  __int64 v6; // r2
  int v7; // r1
  int v8; // r7
  const void *v9; // r1
  char *v10; // r2
  char *v11; // r1
  unsigned int v12; // t1
  const char *v13; // r0
  int v14; // r0
  char *v16; // r7
  const char *v17; // r0
  char *v18; // r5
  int *v19; // r0
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  int *v23; // r0
  int *v24; // r0
  pthread_mutex_t *mutex; // [sp+10h] [bp-898h]
  __int64 v26; // [sp+18h] [bp-890h] BYREF
  unsigned __int8 v27[28]; // [sp+20h] [bp-888h] BYREF
  char v28; // [sp+3Ch] [bp-86Ch] BYREF
  char v29[28]; // [sp+40h] [bp-868h] BYREF
  char v30; // [sp+5Ch] [bp-84Ch] BYREF
  char v31[32]; // [sp+60h] [bp-848h] BYREF
  char s[2088]; // [sp+80h] [bp-828h] BYREF

  mutex = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
  {
    v19 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v19, "cgminer.c", "gen_stratum_work", 8266);
    goto LABEL_30;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v20 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v20, "cgminer.c", "gen_stratum_work", 8266);
    goto LABEL_30;
  }
  v4 = (void *)(*(_DWORD *)(a1 + 1568) + *(_DWORD *)(a1 + 1576));
  v5 = *(_DWORD *)(a1 + 632);
  v26 = *(_QWORD *)(a1 + 624);
  cg_memcpy(v4, &v26, v5, (int)"cgminer.c", (int)"gen_stratum_work", 8271);
  v6 = *(_QWORD *)(a1 + 624);
  v7 = *(_DWORD *)(a1 + 632);
  *(_QWORD *)(a1 + 624) = v6 + 1;
  *(_QWORD *)(a2 + 296) = v6;
  *(_DWORD *)(a2 + 304) = v7;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v21 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v21,
      "cgminer.c",
      "gen_stratum_work",
      8277);
    goto LABEL_30;
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v22 = _errno_location();
    snprintf(s, 2048u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v22, "cgminer.c", "gen_stratum_work", 8277);
    goto LABEL_30;
  }
  v8 = pthread_mutex_unlock(mutex);
  if ( v8 )
  {
    v23 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v23, "cgminer.c", "gen_stratum_work", 8277);
    goto LABEL_30;
  }
  sha256(*(const void **)(a1 + 1568), *(_DWORD *)(a1 + 1572), (int)s);
  sha256(s, 32u, (int)v27);
  cg_memcpy(v29, v27, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8281);
  if ( *(int *)(a1 + 1708) > 0 )
  {
    do
    {
      v9 = *(const void **)(*(_DWORD *)(a1 + 676) + 4 * v8++);
      cg_memcpy(v31, v9, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8285);
      sha256(v29, 64u, (int)s);
      sha256(s, 32u, (int)v27);
      cg_memcpy(v29, v27, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8287);
    }
    while ( *(_DWORD *)(a1 + 1708) > v8 );
  }
  v10 = &v28;
  v11 = (char *)&v26 + 4;
  do
  {
    v12 = *((_DWORD *)v10 + 1);
    v10 += 4;
    *((_DWORD *)v11 + 1) = bswap32(v12);
    v11 += 4;
  }
  while ( v10 != &v30 );
  cg_memcpy((void *)a2, (const void *)(a1 + 1580), 112u, (int)"cgminer.c", (int)"gen_stratum_work", 8296);
  cg_memcpy((void *)(a2 + 36), v27, 32u, (int)"cgminer.c", (int)"gen_stratum_work", 8297);
  v13 = *(const char **)(a1 + 672);
  *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 1824);
  *(_DWORD *)(a2 + 288) = _strdup(v13);
  *(_DWORD *)(a2 + 320) = _strdup(*(const char **)(a1 + 612));
  *(_DWORD *)(a2 + 308) = _strdup((const char *)(a1 + 1804));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v24 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v24,
      "cgminer.c",
      "gen_stratum_work",
      8308);
LABEL_30:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  if ( !opt_debug )
    goto LABEL_12;
  v16 = bin2hex((unsigned __int8 *)a2, 112);
  v17 = bin2hex(v27, 32);
  v18 = (char *)v17;
  if ( opt_debug )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
    {
LABEL_20:
      if ( !opt_log_output && opt_log_level <= 6 )
      {
LABEL_22:
        if ( !opt_log_output && opt_log_level <= 6 )
          goto LABEL_25;
LABEL_24:
        snprintf(
          s,
          2048u,
          "Work job_id %s nonce2 %llu ntime %s",
          *(const char **)(a2 + 288),
          *(_QWORD *)(a2 + 296),
          *(const char **)(a2 + 308));
        applog(7, s, 0);
        goto LABEL_25;
      }
LABEL_26:
      snprintf(s, 2048u, "Generated stratum header %s", v16);
      applog(7, s, 0);
      if ( !opt_debug )
        goto LABEL_25;
      if ( use_syslog )
        goto LABEL_24;
      goto LABEL_22;
    }
    snprintf(s, 2048u, "Generated stratum merkle %s", v17);
    applog(7, s, 0);
    if ( opt_debug )
    {
      if ( use_syslog )
        goto LABEL_26;
      goto LABEL_20;
    }
  }
LABEL_25:
  free(v16);
  free(v18);
LABEL_12:
  calc_midstate(a2);
  set_target((void *)(a2 + 160));
  ++local_work;
  if ( time(0) - local_work_lasttime > 5 )
  {
    local_work_lasttime = time(0);
    local_work_last = local_work;
  }
  v14 = work_block;
  *(_DWORD *)(a2 + 248) = 0;
  *(_DWORD *)(a2 + 336) = v14;
  *(_BYTE *)(a2 + 280) = 0;
  *(_BYTE *)(a2 + 440) = 83;
  *(_DWORD *)(a2 + 244) = 60;
  *(_DWORD *)(a2 + 260) = a1;
  *(_BYTE *)(a2 + 284) = 1;
  calc_diff(a2);
  return cgtime((struct timeval *)(a2 + 264));
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 81118: using guessed type int local_work_lasttime;
// 8111C: using guessed type int local_work_last;
// 81120: using guessed type int work_block;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80EEF0: using guessed type int local_work;
// 231E8: using guessed type char var_848[32];

//----- (0002364C) --------------------------------------------------------
int __fastcall get_work_by_nonce2(int *a1, int *a2, int a3, int a4, int a5, int a6, unsigned int a7)
{
  pthread_mutex_t *v8; // r6
  int v12; // r9
  unsigned int v13; // r2
  unsigned int v14; // r1
  int v15; // r2
  int v16; // r3
  int result; // r0

  v8 = (pthread_mutex_t *)(a3 + 212);
  *a2 = (int)make_work();
  v12 = *a1;
  if ( pthread_mutex_lock(v8) )
    mutex_lock_part_47_constprop_75("get_work_by_nonce2", 8235);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a3 + 236)) )
    wr_lock_part_54_constprop_73("get_work_by_nonce2", 8235);
  v13 = bswap32(a7);
  *(_DWORD *)(a3 + 624) = a5;
  *(_DWORD *)(a3 + 628) = a6;
  a7 = v13;
  cg_memcpy((void *)(a3 + 1580), &a7, 4u, (int)"cgminer.c", (int)"get_work_by_nonce2", 8239);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 236)) )
    rw_unlock_part_40_constprop_79("get_work_by_nonce2", 8240);
  if ( pthread_mutex_unlock(v8) )
    mutex_unlock_noyield_part_48_constprop_77("get_work_by_nonce2", 8240);
  selective_yield(0);
  gen_stratum_work(a3, *a2);
  v14 = a7;
  v15 = work_block;
  *(_DWORD *)(*a2 + 260) = a4;
  v16 = *a2;
  result = *(_DWORD *)(*a2 + 260);
  *(_DWORD *)(v16 + 336) = v15;
  *(_DWORD *)(v16 + 256) = v12;
  ++*(_DWORD *)(result + 68);
  *(_BYTE *)(v16 + 272) = 1;
  *(_DWORD *)(v16 + 444) = v14;
  return result;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 81120: using guessed type int work_block;
// 2364C: using guessed type _DWORD arg_0;

//----- (0002373C) --------------------------------------------------------
int __fastcall stale_work(int a1, unsigned int a2)
{
  int v2; // r5
  int v6; // r8
  int v7; // r9
  int v8; // r8
  const char *v9; // r6
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // r6
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  int *v21; // r0
  int *v22; // r0
  struct timeval v23; // [sp+10h] [bp-830h] BYREF
  _DWORD s[10]; // [sp+18h] [bp-828h] BYREF
  __int16 v25; // [sp+40h] [bp-800h]

  v2 = (unsigned __int8)opt_benchmark;
  if ( !opt_benchmark )
  {
    if ( opt_benchfile )
      return v2;
    if ( *(_DWORD *)(a1 + 336) != work_block )
    {
      v2 = (unsigned __int8)opt_debug;
      if ( opt_debug )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 6 )
        {
          strcpy((char *)s, "Work stale due to block mismatch");
          applog(7, (const char *)s, 0);
        }
        return v2;
      }
      return 1;
    }
    v6 = *(_DWORD *)(a1 + 276);
    v7 = *(_DWORD *)(a1 + 260);
    if ( v6 <= opt_scantime )
      v6 = opt_expiry;
    if ( !a2 && *(_BYTE *)(v7 + 640) )
    {
      if ( !*(_BYTE *)(v7 + 641) || !*(_BYTE *)(v7 + 643) )
      {
        v2 = (unsigned __int8)opt_debug;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)s, "Work stale due to stratum inactive");
          applog(7, (const char *)s, 0);
          return v2;
        }
        return 1;
      }
      if ( pthread_mutex_lock((pthread_mutex_t *)(v7 + 212)) )
        mutex_lock_part_47_constprop_75("stale_work", 5012);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v7 + 236)) )
        rd_lock_part_39_constprop_80("stale_work", 5012);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(v7 + 212)) )
      {
        v22 = _errno_location();
        snprintf(
          (char *)s,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v22,
          "cgminer.c",
          "stale_work",
          5012);
LABEL_54:
        applog(3, (const char *)s, 1);
        _quit(1, 1);
      }
      if ( strcmp(*(const char **)(a1 + 288), *(const char **)(v7 + 672)) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
        {
          selective_yield(0);
          v2 = (unsigned __int8)opt_debug;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            v9 = "Work stale due to stratum job_id mismatch";
            goto LABEL_42;
          }
          return 1;
        }
        goto LABEL_53;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
      {
LABEL_53:
        v21 = _errno_location();
        snprintf(
          (char *)s,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v21,
          "cgminer.c",
          "stale_work",
          5019);
        goto LABEL_54;
      }
      selective_yield(0);
    }
    v8 = v6 - (int)(*(double *)(v7 + 448) * 5.0 + 1.0);
    cgtime(&v23);
    if ( v8 < 5 )
      v8 = 5;
    if ( v23.tv_sec - *(_DWORD *)(a1 + 264) >= v8 )
    {
      v2 = (unsigned __int8)opt_debug;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)s, "Work stale due to expiry");
        applog(7, (const char *)s, 0);
        return v2;
      }
      return 1;
    }
    if ( (unsigned __int8)opt_fail_only <= a2
      || v7 == current_pool()
      || *(_BYTE *)(a1 + 282)
      || (unsigned int)(pool_strategy - 3) <= 1 )
    {
      return v2;
    }
    v2 = (unsigned __int8)opt_debug;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      v9 = "Work stale due to fail only pool mismatch";
LABEL_42:
      v10 = *(_DWORD *)v9;
      v11 = *((_DWORD *)v9 + 1);
      v12 = *((_DWORD *)v9 + 2);
      v13 = *((_DWORD *)v9 + 3);
      v14 = (int *)(v9 + 16);
      s[0] = v10;
      s[1] = v11;
      s[2] = v12;
      s[3] = v13;
      v15 = *v14;
      v16 = v14[1];
      v17 = v14[2];
      v18 = v14[3];
      v14 += 4;
      s[4] = v15;
      s[5] = v16;
      s[6] = v17;
      s[7] = v18;
      v19 = v14[1];
      v20 = v14[2];
      s[8] = *v14;
      s[9] = v19;
      v25 = v20;
      applog(7, (const char *)s, 0);
      return v2;
    }
    return 1;
  }
  return 0;
}
// 7DEFC: using guessed type int opt_scantime;
// 7DF00: using guessed type int opt_expiry;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80F6C: using guessed type int pool_strategy;
// 80F9C: using guessed type int opt_benchfile;
// 810D0: using guessed type char opt_benchmark;
// 81120: using guessed type int work_block;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80DCEC: using guessed type char opt_fail_only;

//----- (00023AA4) --------------------------------------------------------
void **__fastcall get_work(int a1, void *a2)
{
  _DWORD *v4; // r7
  time_t v5; // r10
  time_t v6; // r0
  int v7; // r4
  int v8; // r3
  void **v9; // r0
  int v10; // r3
  int v11; // r5
  time_t v12; // r0
  int v13; // r2
  void **v14; // r3
  double v15; // d7
  double v16; // d5
  void **result; // r0
  double v18; // d6
  int v19; // r3
  int v20; // r3
  int v21; // r2
  char *v22; // r4
  int v23; // r3
  int v24; // r1
  int v25; // r3
  void **v26; // [sp+Ch] [bp-82Ch] BYREF
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  v26 = 0;
  v4 = *(_DWORD **)(a1 + 36);
  thread_reportout((thr_info *)a1);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(s, "Popping work from get queue to get work");
    applog(7, s, 0);
  }
  v5 = time(0);
  while ( !v26 )
  {
    v26 = (void **)hash_pop(1);
    if ( stale_work((int)v26, 0) )
    {
      discard_work(&v26, "cgminer.c", "get_work", 8552);
      wake_gws();
    }
  }
  v6 = time(0);
  v7 = v6 - v5;
  v8 = (unsigned __int8)opt_debug;
  if ( v6 - v5 > 0 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "Get work blocked for %d seconds", v6 - v5);
      applog(7, s, 0);
      v8 = (unsigned __int8)opt_debug;
    }
    v4[58] += v7;
  }
  if ( v8 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "Got work from get queue to get work for thread %d", a2);
    applog(7, s, 0);
  }
  v9 = v26;
  v10 = (unsigned __int8)opt_benchmark;
  v26[64] = a2;
  if ( v10 )
  {
    v19 = v4[96] + v4[95];
    v4[95] = v19;
    if ( v19 > 0 )
    {
      if ( v19 > 15 )
      {
        v20 = v4[94];
        v21 = -1;
        v4[96] = -1;
        v22 = (char *)&bench_hidiff_bins;
        v23 = v20 + 1;
        if ( v23 <= 15 )
          v4[94] = v23;
        else
          v21 = 0;
        if ( v23 > 15 )
        {
          v23 = v21;
          v4[94] = v21;
        }
        v24 = 5 * v23;
        v25 = 8529;
        goto LABEL_34;
      }
    }
    else
    {
      v4[96] = 1;
    }
    v24 = 5 * v19;
    v22 = (char *)&bench_lodiff_bins;
    v25 = 8533;
LABEL_34:
    cg_memcpy(v9, &v22[32 * v24], 160u, (int)"cgminer.c", (int)"set_benchmark_work", v25);
  }
  *(_BYTE *)(a1 + 61) = 0;
  cgtime((struct timeval *)(a1 + 44));
  v11 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v11 + 96) = 0;
  v12 = time(0);
  v13 = v4[1];
  v14 = v26;
  *(_DWORD *)(v11 + 240) = v12;
  v15 = *(double *)(v13 + 104);
  v16 = *((double *)v14 + 47);
  result = v14;
  v18 = *(double *)(v13 + 112);
  *((_BYTE *)v14 + 272) = 1;
  if ( v15 > v16 )
    v15 = v16;
  if ( v15 < v18 )
    v15 = v18;
  *((double *)v14 + 28) = v15;
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 810D0: using guessed type char opt_benchmark;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00023D08) --------------------------------------------------------
void **__fastcall get_queue_work(int a1, pthread_rwlock_t *a2, void *a3)
{
  void **work; // r4

  work = get_work(a1, a3);
  add_queued(a2, (int)work);
  return work;
}

//----- (00023D20) --------------------------------------------------------
void **__fastcall _get_queued(int a1)
{
  void **v1; // r3
  int v3; // r0
  void **v4; // r3
  void **v6; // [sp+4h] [bp-Ch] BYREF

  v1 = *(void ***)(a1 + 356);
  if ( !v1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 356);
  v6 = v1;
  if ( stale_work(v3, 0) )
  {
    discard_work(&v6, "cgminer.c", "__get_queued", 9315);
    wake_gws();
  }
  else
  {
    _add_queued(a1, (int)v6);
  }
  v4 = v6;
  *(_DWORD *)(a1 + 356) = 0;
  return v4;
}

//----- (00023D70) --------------------------------------------------------
void **__fastcall get_queued(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r4
  void **queued; // r5

  v1 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    wr_lock_part_54_constprop_73("get_queued", 9336);
  queued = _get_queued((int)a1);
  if ( pthread_rwlock_unlock(v1) )
    rw_unlock_part_40_constprop_79("get_queued", 9338);
  selective_yield(0);
  return queued;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (00023DB8) --------------------------------------------------------
void discard_stale()
{
  int v0; // r5
  int v1; // r0
  int i; // r4
  void **v3; // r3
  char *v4; // r0
  int v5; // r9
  void **v6; // r12
  int v7; // lr
  int v8; // r2
  void **v9; // r1
  char *v10; // r2
  char *v11; // lr
  int *v12; // r1
  int v13; // lr
  int v14; // r2
  void ***v15; // r9
  void **v16; // r10
  _DWORD *v17; // r0
  _DWORD *v18; // r2
  int v19; // r3
  char *v20; // r2
  int v21; // r9
  int v22; // r10
  int *v23; // r0
  int *v24; // r0
  void **v25; // [sp+1Ch] [bp-824h] BYREF
  char s[2080]; // [sp+20h] [bp-820h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)stgd_lock) )
  {
    v23 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "cgminer.c", "discard_stale", 5301);
    goto LABEL_39;
  }
  v0 = 0;
  v1 = staged_work;
  v25 = (void **)staged_work;
  if ( !staged_work )
  {
    pthread_cond_signal(&gws_cond);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)stgd_lock) )
    {
      selective_yield(0);
      return;
    }
    goto LABEL_40;
  }
  for ( i = *(_DWORD *)(staged_work + 352); ; i = v19 )
  {
    if ( !stale_work(v1, 0) )
      goto LABEL_19;
    v3 = v25;
    v4 = (char *)v25[87];
    if ( v4 )
    {
      v5 = staged_work;
      v6 = v25 + 86;
      v7 = *(_DWORD *)(staged_work + 344);
      v8 = *(_DWORD *)(v7 + 20);
      v9 = (void **)(*(_DWORD *)(v7 + 16) - v8);
      v10 = &v4[v8];
      if ( v25 == v9 )
        *(_DWORD *)(v7 + 16) = v10;
      *((_DWORD *)v10 + 2) = v3[88];
      v11 = (char *)v3[88];
LABEL_9:
      v12 = *(int **)(v5 + 344);
      if ( v11 )
        *(_DWORD *)&v11[v12[5] + 4] = v4;
      v13 = *v12;
      v14 = 3 * ((unsigned int)v3[93] & (v12[1] - 1));
      v15 = (void ***)(*v12 + 12 * ((unsigned int)v3[93] & (v12[1] - 1)));
      v16 = *v15;
      v15[1] = (void **)((char *)v15[1] - 1);
      v17 = v3[90];
      if ( v16 == v6 )
        *(_DWORD *)(v13 + 4 * v14) = v17;
      v18 = v3[89];
      if ( v18 )
      {
        v18[4] = v17;
        v17 = v3[90];
      }
      if ( v17 )
        v17[3] = v18;
      --v12[3];
      goto LABEL_18;
    }
    v20 = (char *)v25[88];
    v11 = v20;
    if ( v20 )
    {
      v6 = v25 + 86;
      v21 = *(_DWORD *)(staged_work + 344);
      v22 = *(_DWORD *)(v21 + 20);
      if ( v25 == (void **)(*(_DWORD *)(v21 + 16) - v22) )
      {
        *(_DWORD *)(v21 + 16) = v22;
        v11 = v20;
      }
      v5 = (int)v20;
      staged_work = (int)v20;
      goto LABEL_9;
    }
    free(**(void ***)(staged_work + 344));
    free(*(void **)(staged_work + 344));
    staged_work = 0;
LABEL_18:
    ++v0;
    discard_work(&v25, "cgminer.c", "discard_stale", 5308);
LABEL_19:
    v25 = (void **)i;
    v19 = i;
    if ( i )
      v19 = *(_DWORD *)(i + 352);
    v1 = i;
    if ( !i )
      break;
  }
  pthread_cond_signal(&gws_cond);
  if ( pthread_mutex_unlock((pthread_mutex_t *)stgd_lock) )
  {
LABEL_40:
    v24 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v24, "cgminer.c", "discard_stale", 5314);
LABEL_39:
    applog(3, s, 1);
    _quit(1, 1);
  }
  selective_yield(0);
  if ( v0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "Discarded %d stales that didn't match current hash", v0);
    applog(7, s, 0);
  }
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FAC: using guessed type int stgd_lock;
// 81084: using guessed type int staged_work;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CBE8: using guessed type pthread_cond_t gws_cond;
// 80CC18: using guessed type char use_syslog;

//----- (00024020) --------------------------------------------------------
int restart_thread()
{
  pthread_t v0; // r0
  int v1; // r9
  int v2; // r4
  int v3; // r3
  pthread_rwlock_t *v4; // r5

  v0 = pthread_self();
  pthread_detach(v0);
  discard_stale();
  if ( pthread_rwlock_rdlock(&mining_thr_lock) )
    rd_lock_part_39_constprop_80("restart_thread", 5367);
  v1 = mining_threads;
  v2 = pthread_rwlock_unlock(&mining_thr_lock);
  if ( v2 )
    rw_unlock_part_40_constprop_79("restart_thread", 5369);
  selective_yield(0);
  if ( v1 > 0 )
  {
    do
    {
      while ( 1 )
      {
        v3 = *(_DWORD *)(mining_thr + 4 * v2);
        v4 = *(pthread_rwlock_t **)(v3 + 36);
        if ( v4 )
        {
          if ( !v4[1].__lock )
            break;
        }
        if ( v1 == ++v2 )
          goto LABEL_9;
      }
      *(_BYTE *)(v3 + 62) = 1;
      flush_queue(v4);
      ++v2;
      (*(void (__fastcall **)(pthread_rwlock_t *))(v4->__nr_readers + 76))(v4);
    }
    while ( v1 != v2 );
  }
LABEL_9:
  if ( pthread_mutex_lock(&restart_lock) )
    mutex_lock_part_47_constprop_75("restart_thread", 5390);
  pthread_cond_broadcast(&restart_cond);
  if ( pthread_mutex_unlock(&restart_lock) )
    mutex_unlock_noyield_part_48_constprop_77("restart_thread", 5392);
  selective_yield(0);
  return 0;
}
// 24020: using guessed type int restart_thread();
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80CBC0: using guessed type int mining_thr;
// 80CBC4: using guessed type pthread_rwlock_t mining_thr_lock;
// 80DCA0: using guessed type int mining_threads;
// 80EE10: using guessed type pthread_cond_t restart_cond;
// 80EF04: using guessed type pthread_mutex_t restart_lock;

//----- (00024110) --------------------------------------------------------
int __fastcall stratum_sthread(_DWORD *a1)
{
  pthread_t v2; // r0
  thread_q *v3; // r0
  const struct timespec *v4; // r1
  __int64 v5; // r6
  int v6; // r5
  int v7; // r0
  unsigned int v8; // r1
  int v9; // r2
  __int64 v10; // kr08_8
  _BOOL4 v11; // r4
  void **v12; // r5
  time_t v13; // r0
  void **v14; // r3
  int v15; // r2
  time_t v16; // r6
  int v17; // r0
  void ***v18; // r5
  int v19; // r2
  unsigned int v20; // r3
  unsigned int v21; // r2
  unsigned int v22; // r1
  int v23; // r3
  unsigned int v24; // r2
  unsigned int v25; // r1
  int v26; // r3
  unsigned int v27; // r4
  int *v28; // r3
  int v29; // r1
  int v30; // r0
  int v31; // r4
  int *v32; // r2
  int v33; // r1
  unsigned int v34; // r3
  int v35; // r2
  _DWORD *v36; // r7
  void **v37; // r10
  void *v38; // r3
  unsigned int v39; // r4
  void *v40; // r2
  unsigned int v41; // r9
  int v42; // r11
  _DWORD *v43; // r5
  _DWORD *v44; // r8
  int v45; // r4
  char *v46; // r6
  unsigned int v47; // r0
  int v48; // r3
  bool v49; // zf
  void **v50; // r4
  unsigned int v51; // r0
  unsigned int v52; // r1
  void *v53; // r2
  char *v54; // r3
  void *v55; // r3
  int v56; // r2
  time_t v57; // r0
  int v58; // r3
  void **v59; // r2
  int v60; // r0
  unsigned int v62; // r3
  char *v63; // r5
  char *v64; // r4
  int v65; // r0
  int v66; // r1
  int v67; // r2
  int v68; // r3
  _DWORD *v69; // r5
  char *v70; // r4
  int v71; // r1
  int v72; // r2
  int v73; // r3
  int v74; // r3
  int v75; // r1
  int v76; // r3
  int v77; // r1
  pthread_rwlock_t *v78; // r7
  const char *v79; // r1
  int v80; // r3
  int *v81; // r0
  int *v82; // r0
  void **v83; // r0
  void **v84; // r6
  void *v85; // r0
  int v86; // r3
  __int64 v87; // r0
  int v88; // r3
  int *v89; // r0
  int *v90; // r0
  void ***v91; // [sp+20h] [bp-CB0h]
  int v93; // [sp+28h] [bp-CA8h]
  char *ptr; // [sp+2Ch] [bp-CA4h]
  int v95; // [sp+30h] [bp-CA0h]
  int v96; // [sp+40h] [bp-C90h]
  int v97; // [sp+64h] [bp-C6Ch] BYREF
  void **v98; // [sp+68h] [bp-C68h] BYREF
  int v99; // [sp+6Ch] [bp-C64h] BYREF
  __int64 v100; // [sp+70h] [bp-C60h] BYREF
  char v101[12]; // [sp+78h] [bp-C58h] BYREF
  char s[16]; // [sp+84h] [bp-C4Ch] BYREF
  char v103[20]; // [sp+94h] [bp-C3Ch] BYREF
  char v104[1024]; // [sp+A8h] [bp-C28h] BYREF
  char v105[2088]; // [sp+4A8h] [bp-828h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 16u, "%d/SStratum", *a1);
  RenameThread(s);
  v3 = tq_new();
  a1[182] = v3;
  if ( !v3 )
  {
    v63 = " stratum_q in stratum_sthread";
    qmemcpy(v105, "Failed to create", 16);
    v64 = &v105[16];
LABEL_75:
    v65 = *(_DWORD *)v63;
    v66 = *((_DWORD *)v63 + 1);
    v67 = *((_DWORD *)v63 + 2);
    v68 = *((_DWORD *)v63 + 3);
    v69 = v63 + 16;
    *(_DWORD *)v64 = v65;
    *((_DWORD *)v64 + 1) = v66;
    *((_DWORD *)v64 + 2) = v67;
    *((_DWORD *)v64 + 3) = v68;
    v70 = v64 + 16;
    v71 = v69[1];
    v72 = v69[2];
    v73 = v69[3];
    *(_DWORD *)v70 = *v69;
    *((_DWORD *)v70 + 1) = v71;
    *((_DWORD *)v70 + 2) = v72;
    *((_WORD *)v70 + 6) = v73;
    applog(3, v105, 1);
    _quit(1, 1);
  }
  v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
  v5 = 0LL;
  v6 = 0;
  if ( *((_BYTE *)a1 + 105) )
    goto LABEL_58;
  do
  {
    v7 = tq_pop((int)v3, v4);
    v98 = (void **)v7;
    if ( !v7 )
    {
      v63 = "Stratum q returned empty work";
      v64 = v105;
      goto LABEL_75;
    }
    v8 = *(_DWORD *)(v7 + 304);
    if ( v8 > 8 )
    {
      if ( (use_syslog || opt_log_output || opt_log_level > 2)
        && ((snprintf(v105, 2048u, "Pool %d asking for inappropriately long nonce2 length %d", *a1, v8),
             applog(3, v105, 0),
             use_syslog)
         || opt_log_output)
        || opt_log_level > 2 )
      {
        strcpy(v105, "Not attempting to submit shares");
        applog(3, v105, 0);
      }
      free_work(&v98, "cgminer.c", "stratum_sthread", 7565);
      goto LABEL_57;
    }
    v9 = *(_DWORD *)(v7 + 76);
    v10 = *(_QWORD *)(v7 + 296);
    v96 = v9;
    v100 = v10;
    v11 = v6 == v9 && v5 == v10;
    v97 = v9;
    if ( v11 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(v105, 2048u, "Filtering duplicate share to pool %d", *a1);
        applog(6, v105, 0);
      }
      free_work(&v98, "cgminer.c", "stratum_sthread", 7577);
      goto LABEL_57;
    }
    _bin2hex(v101, (unsigned __int8 *)&v97, 4);
    _bin2hex(v103, (unsigned __int8 *)&v100, (int)v98[76]);
    v91 = (void ***)cgcalloc(52u, 1u, "cgminer.c", "stratum_sthread", 7586);
    v12 = v98;
    v13 = time(0);
    v14 = v98;
    v91[11] = (void **)v13;
    v91[9] = v14;
    memset(v104, 0, sizeof(v104));
    if ( pthread_mutex_lock(&sshare_lock) )
    {
      v74 = *_errno_location();
      v75 = 7595;
      goto LABEL_86;
    }
    v15 = swork_id;
    v91[10] = (void **)swork_id;
    swork_id = v15 + 1;
    if ( pthread_mutex_unlock(&sshare_lock) )
    {
      v76 = *_errno_location();
      v77 = 7598;
      goto LABEL_89;
    }
    selective_yield(0);
    v99 = 0;
    hex2bin(&v99, (unsigned __int8 *)a1 + 1780, 4);
    if ( *((_BYTE *)a1 + 644) )
      snprintf(
        v104,
        1024u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v98[72],
        v103,
        (const char *)v98[77],
        v101,
        bswap32((unsigned int)v98[111] & ~v99),
        v91[10]);
    else
      snprintf(
        v104,
        1024u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v98[72],
        v103,
        (const char *)v98[77],
        v101,
        v91[10]);
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(v105, 2048u, "Submitting share %08lx to pool %d", v12[54], *a1);
      applog(6, v105, 0);
    }
    while ( 1 )
    {
      v16 = (time_t)v91[11] + 119;
      if ( v16 < time(0) )
        goto LABEL_114;
      v17 = strlen(v104);
      if ( stratum_send((int)a1, v104, v17) )
      {
        if ( !pthread_mutex_lock(&sshare_lock) )
        {
          v18 = (void ***)stratum_shares;
          v19 = *((unsigned __int8 *)v91 + 40)
              + 17973517
              + (*((unsigned __int8 *)v91 + 43) << 24)
              + (*((unsigned __int8 *)v91 + 42) << 16)
              + (*((unsigned __int8 *)v91 + 41) << 8);
          v91[6] = (void **)4;
          v20 = (unsigned int)&unk_7F76D ^ v19;
          v91[5] = (void **)(v91 + 10);
          v21 = (-1622558010 - v20) ^ (v20 << 8);
          v22 = (-17973517 - v20 - v21) ^ (v21 >> 13);
          v23 = (v20 - v21 - v22) ^ (v22 >> 12);
          v24 = (v21 - v22 - v23) ^ (v23 << 16);
          v25 = (v22 - v23 - v24) ^ (v24 >> 5);
          v26 = (v23 - v24 - v25) ^ (v25 >> 3);
          v27 = (v25 - v26 - ((v24 - v25 - v26) ^ (v26 << 10))) ^ (((v24 - v25 - v26) ^ (v26 << 10)) >> 15);
          v91[7] = (void **)v27;
          if ( v18 )
          {
            *v91 = *v18;
            v28 = (int *)*v18;
            v91[2] = 0;
            v29 = v28[4];
            v91[1] = (void **)(v29 - v28[5]);
            *(_DWORD *)(v29 + 8) = v91;
            v28[4] = (int)v91;
          }
          else
          {
            v91[2] = 0;
            v91[1] = 0;
            stratum_shares = (int)v91;
            v83 = (void **)malloc(44u);
            *v91 = v83;
            if ( !v83 )
              goto LABEL_133;
            memset(v83, 0, 44u);
            v84 = *v91;
            v84[4] = v91;
            v84[5] = 0;
            v84[1] = (void *)32;
            v84[2] = (void *)5;
            v85 = malloc(384u);
            *v84 = v85;
            if ( !v85 )
              goto LABEL_133;
            memset(v85, 0, 384u);
            v28 = (int *)*v91;
            (*v91)[10] = (void *)-1609490463;
          }
          v30 = *v28;
          v31 = 3 * (v27 & (v28[1] - 1));
          ++v28[3];
          v32 = (int *)(v30 + 4 * v31);
          v33 = *v32;
          v34 = v32[1] + 1;
          v32[1] = v34;
          v91[4] = (void **)v33;
          v91[3] = 0;
          if ( v33 )
            *(_DWORD *)(v33 + 12) = v91;
          v35 = 5 * (v32[2] + 1);
          *(_DWORD *)(v30 + 4 * v31) = v91;
          if ( v34 < 2 * v35 || (*v91)[9] == (void *)1 )
            goto LABEL_44;
          v36 = calloc(24 * (_DWORD)(*v91)[1], 1u);
          if ( v36 )
          {
            v37 = *v91;
            v38 = (*v91)[1];
            v39 = (unsigned int)(*v91)[3];
            v40 = (*v91)[2];
            (*v91)[7] = 0;
            v41 = v39 >> ((_BYTE)v40 + 1);
            v42 = 2 * (_DWORD)v38 - 1;
            if ( (v39 & v42) != 0 )
              ++v41;
            v37[6] = (void *)v41;
            if ( v38 )
            {
              v93 = 0;
              ptr = (char *)*v37;
              v95 = 12 * (_DWORD)v38;
              do
              {
                v43 = *(_DWORD **)&ptr[v93];
                if ( v43 )
                {
                  do
                  {
                    v44 = (_DWORD *)v43[4];
                    v45 = 3 * (v42 & v43[7]);
                    v46 = (char *)&v36[3 * (v42 & v43[7])];
                    v47 = *((_DWORD *)v46 + 1) + 1;
                    *((_DWORD *)v46 + 1) = v47;
                    if ( v41 < v47 )
                    {
                      v37[7] = (char *)v37[7] + 1;
                      *((_DWORD *)v46 + 2) = v47 / v41;
                    }
                    v48 = v36[v45];
                    v43[3] = 0;
                    v43[4] = v48;
                    if ( v48 )
                      *(_DWORD *)(v48 + 12) = v43;
                    v36[v45] = v43;
                    v43 = v44;
                  }
                  while ( v44 );
                }
                v49 = v95 == v93 + 12;
                v93 += 12;
              }
              while ( !v49 );
              free(ptr);
            }
            else
            {
              free(*v37);
            }
            v50 = *v91;
            v51 = (unsigned int)(*v91)[3];
            v52 = (unsigned int)(*v91)[7];
            v53 = (*v91)[1];
            v54 = (char *)(*v91)[2];
            *v50 = v36;
            v55 = v54 + 1;
            v56 = 2 * (_DWORD)v53;
            v50[2] = v55;
            if ( v52 <= v51 >> 1 )
              v55 = 0;
            v50[1] = (void *)v56;
            if ( v52 > v51 >> 1 )
            {
              v62 = (unsigned int)v50[8] + 1;
              v50[8] = (void *)v62;
              if ( v62 > 1 )
                v50[9] = (void *)1;
            }
            else
            {
              v50[8] = v55;
            }
LABEL_44:
            ++a1[183];
            if ( !pthread_mutex_unlock(&sshare_lock) )
            {
              ((void (*)(void))selective_yield)();
              if ( pool_tclear((int)a1, (_BYTE *)a1 + 96) )
              {
                if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
                {
                  if ( !opt_debug )
                  {
LABEL_50:
                    v57 = time(0);
                    v58 = (unsigned __int8)opt_debug;
                    v59 = v91[11];
                    v91[12] = (void **)v57;
                    v60 = v57 - (_DWORD)v59;
                    if ( v60 > 0 )
                      v58 |= 1u;
                    if ( v58 && (use_syslog || opt_log_output || opt_log_level > 5) )
                    {
                      snprintf(v105, 2048u, "Pool %d stratum share submission lag time %d seconds", *a1, v60);
                      applog(6, v105, 0);
                    }
                    goto LABEL_56;
                  }
                  goto LABEL_72;
                }
                snprintf(v105, 2048u, "Pool %d communication resumed, submitting work", *a1);
                applog(4, v105, 0);
              }
              if ( !opt_debug )
                goto LABEL_50;
              if ( use_syslog || opt_log_output )
              {
LABEL_63:
                strcpy(v105, "Successfully submitted, adding to stratum_shares db");
                applog(7, v105, 0);
                goto LABEL_50;
              }
LABEL_72:
              if ( opt_log_level <= 6 )
                goto LABEL_50;
              goto LABEL_63;
            }
            v82 = _errno_location();
            v77 = 7639;
            v76 = *v82;
            goto LABEL_89;
          }
LABEL_133:
          exit(-1);
        }
        v81 = _errno_location();
        v75 = 7636;
        v74 = *v81;
LABEL_86:
        snprintf(
          v105,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          v74,
          "cgminer.c",
          "stratum_sthread",
          v75);
        goto LABEL_87;
      }
      if ( !pool_tset((int)a1, (_BYTE *)a1 + 96) && cnx_needed((int)a1) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(v105, 2048u, "Pool %d stratum share submission failure", *a1);
          applog(4, v105, 0);
        }
        v86 = a1[33] + 1;
        ++total_ro;
        a1[33] = v86;
      }
      if ( opt_lowmem )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v89 = _errno_location();
        v75 = 7661;
        v74 = *v89;
        goto LABEL_86;
      }
      v78 = (pthread_rwlock_t *)(a1 + 59);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v88 = *_errno_location();
        snprintf(
          v105,
          2048u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          v88,
          "cgminer.c",
          "stratum_sthread",
          7661);
        goto LABEL_87;
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v90 = _errno_location();
        v77 = 7661;
        v76 = *v90;
LABEL_89:
        snprintf(
          v105,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v76,
          "cgminer.c",
          "stratum_sthread",
          v77);
        goto LABEL_87;
      }
      v79 = (const char *)a1[153];
      if ( !v79 || strcmp((const char *)v98[80], v79) )
      {
        if ( !pthread_rwlock_unlock(v78) )
        {
          ((void (*)(void))selective_yield)();
          if ( opt_debug )
          {
            if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
              goto LABEL_116;
            strcpy(v105, "No matching session id for resubmitting stratum share");
            applog(7, v105, 0);
LABEL_114:
            if ( opt_debug )
            {
              if ( !use_syslog )
                goto LABEL_116;
              goto LABEL_118;
            }
          }
          goto LABEL_119;
        }
LABEL_100:
        v80 = *_errno_location();
        snprintf(
          v105,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v80,
          "cgminer.c",
          "stratum_sthread",
          7663);
LABEL_87:
        applog(3, v105, 1);
        _quit(1, 1);
      }
      if ( pthread_rwlock_unlock(v78) )
        goto LABEL_100;
      ((void (*)(void))selective_yield)();
      sleep(2u);
    }
    if ( opt_debug )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        strcpy(v105, "Lowmem option prevents resubmitting stratum share");
        applog(7, v105, 0);
        goto LABEL_114;
      }
LABEL_116:
      if ( opt_log_output || opt_log_level > 6 )
      {
LABEL_118:
        strcpy(v105, "Failed to submit stratum share, discarding");
        applog(7, v105, 0);
      }
    }
LABEL_119:
    free_work(&v98, "cgminer.c", "stratum_sthread", 7678);
    free(v91);
    v87 = *(_QWORD *)&total_stale + 1LL;
    ++a1[30];
    *(_QWORD *)&total_stale = v87;
LABEL_56:
    v6 = v96;
    v5 = v10;
LABEL_57:
    v3 = (thread_q *)a1[182];
    v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
  }
  while ( !*((_BYTE *)a1 + 105) );
LABEL_58:
  tq_freeze((int)v3);
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 810EC: using guessed type int stratum_shares;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA38: using guessed type int total_stale;
// 80CBA8: using guessed type int swork_id;
// 80CBB0: using guessed type int total_ro;
// 80CC18: using guessed type char use_syslog;
// 80DD9C: using guessed type char opt_lowmem;

//----- (00024BCC) --------------------------------------------------------
void __fastcall hashmeter(int a1, unsigned __int64 a2)
{
  double v3; // d0
  int v5; // r4
  char *v6; // r0
  int v7; // r6
  double v8; // d9
  int v9; // r11
  int thread; // r0
  int v11; // r4
  double v12; // r0
  double v13; // d10
  double v14; // r0
  double v15; // r0
  double v16; // r0
  int v17; // r3
  double v18; // d6
  double v19; // d10
  double v20; // d6
  double v21; // d7
  double v22; // d5
  double v23; // d7
  int v24; // r3
  int v25; // r6
  int v26; // r4
  double v27; // d13
  double v28; // r0
  double v29; // r0
  double v30; // r0
  double v31; // r0
  int v32; // r6
  double v33; // r0
  int v34; // r3
  int *v35; // r11
  double v36; // d8
  double v37; // r0
  double v38; // r0
  double v39; // r0
  int v40; // r3
  int v41; // r4
  int *v42; // r0
  int v43; // r3
  int v44; // r4
  char v46[16]; // [sp+28h] [bp-8D8h] BYREF
  char v47[16]; // [sp+38h] [bp-8C8h] BYREF
  char v48[16]; // [sp+48h] [bp-8B8h] BYREF
  char v49[16]; // [sp+58h] [bp-8A8h] BYREF
  struct sysinfo v50; // [sp+68h] [bp-898h] BYREF
  char s[2136]; // [sp+A8h] [bp-858h] BYREF

  if ( sysinfo(&v50) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v5 = *_errno_location();
      v6 = strerror(v5);
      snprintf(s, 2048u, "Failed to get sysinfo, errno:%u, reason:%s\n", v5, v6);
      applog(6, s, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = v50.uptime;
  }
  cgtime((struct timeval *)&total_tv_end);
  tdiff();
  v7 = total_tv_end;
  v8 = v3;
  if ( total_tv_end - hashdisplay_t >= opt_log_interval )
  {
    hashdisplay_t = total_tv_end;
    copy_time(&tv_hashmeter, (const timeval *)&total_tv_end);
    if ( a1 < 0 )
    {
      if ( pthread_mutex_lock(&hash_lock) )
      {
        v40 = *_errno_location();
        v41 = 7009;
        goto LABEL_76;
      }
      if ( mining_threads > 0 )
      {
        v25 = 0;
        do
        {
          v26 = *(_DWORD *)(get_thread(v25) + 36);
          tdiff();
          v27 = v3;
          copy_time((timeval *)(v26 + 140), (const timeval *)&total_tv_end);
          if ( v3 > 0.0 )
          {
            LODWORD(v28) = v26 + 48;
            v3 = 0.0;
            v29 = decay_time_part_37(v28);
            if ( v27 > 0.0 )
            {
              v3 = 0.0;
              LODWORD(v29) = v26 + 56;
              v30 = decay_time_part_37(v29);
              if ( v27 > 0.0 )
              {
                LODWORD(v30) = v26 + 64;
                v3 = 0.0;
                v31 = decay_time_part_37(v30);
                if ( v27 > 0.0 )
                {
                  v3 = 0.0;
                  LODWORD(v31) = v26 + 72;
                  decay_time_part_37(v31);
                }
              }
            }
          }
          ++v25;
        }
        while ( mining_threads > v25 );
      }
      if ( pthread_mutex_unlock(&hash_lock) )
      {
        v43 = *_errno_location();
        v44 = 7024;
        goto LABEL_81;
      }
      selective_yield(0);
      if ( !pthread_mutex_lock(&hash_lock) )
      {
        v13 = (double)a2;
        *(double *)total_mhashes_done = *(double *)total_mhashes_done + (double)a2;
        goto LABEL_51;
      }
LABEL_75:
      v40 = *_errno_location();
      v41 = 7027;
      goto LABEL_76;
    }
    v9 = 1;
LABEL_11:
    thread = get_thread(a1);
    v11 = *(_DWORD *)(thread + 36);
    copy_time((timeval *)(thread + 44), (const timeval *)&total_tv_end);
    *(_DWORD *)(v11 + 240) = v7;
    tdiff();
    copy_time((timeval *)(v11 + 140), (const timeval *)&total_tv_end);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "[thread %d: %llu hashes, %.1f mhash/sec]", a1, a2, (double)a2 / v3 / 1000000.0);
      applog(7, s, 0);
    }
    a2 /= (unsigned int)&unk_F4240;
    if ( pthread_mutex_lock(&hash_lock) )
    {
      v40 = *_errno_location();
      v41 = 6980;
      goto LABEL_76;
    }
    v12 = (double)a2;
    v13 = (double)a2;
    *(double *)(v11 + 80) = *(double *)(v11 + 80) + (double)a2;
    if ( v3 > 0.0 )
    {
      LODWORD(v12) = v11 + 48;
      v14 = decay_time_part_37(v12);
      if ( v3 > 0.0 )
      {
        LODWORD(v14) = v11 + 56;
        v15 = decay_time_part_37(v14);
        if ( v3 > 0.0 )
        {
          LODWORD(v15) = v11 + 64;
          v16 = decay_time_part_37(v15);
          if ( v3 > 0.0 )
          {
            LODWORD(v16) = v11 + 72;
            decay_time_part_37(v16);
          }
        }
      }
    }
    if ( pthread_mutex_unlock(&hash_lock) )
    {
      v43 = *_errno_location();
      v44 = 6987;
      goto LABEL_81;
    }
    selective_yield(0);
    if ( ((unsigned __int8)v9 & (unsigned __int8)want_per_device_stats) != 0 )
    {
      get_statline(s, 256u, v11);
      printf("%s          \r", s);
      fflush((FILE *)stdout);
    }
    if ( !pthread_mutex_lock(&hash_lock) )
    {
      *(double *)total_mhashes_done = *(double *)total_mhashes_done + v13;
      if ( !v9 )
      {
        v17 = g_local_mhashes_index;
        v18 = g_local_mhashes_dones[g_local_mhashes_index];
LABEL_27:
        v19 = v13 + v18;
        v20 = (double)total_tv_end_sys;
        v21 = (double)total_tv_start_sys;
        v22 = last_total_secs;
        g_local_mhashes_dones[v17] = v19;
        v23 = v20 - v21;
        total_secs = v23;
        if ( v23 - v22 <= 86400.0 )
        {
          last_total_secs = v23;
          if ( !v9 )
          {
LABEL_34:
            if ( !pthread_mutex_unlock(&hash_lock) )
            {
              selective_yield(0);
              return;
            }
            goto LABEL_78;
          }
LABEL_67:
          suffix_string((unsigned __int64)(*(double *)total_mhashes_done / total_secs * 1000000.0), v46, 16u, 4);
          *(double *)g_displayed_rolling = (double)((int)total_rolling / 10) / 100.0;
          suffix_string((unsigned __int64)(total_rolling * 1000000.0), v47, 16u, 4);
          suffix_string((unsigned __int64)(rolling1 * 1000000.0), v48, 16u, 4);
          suffix_string((unsigned __int64)(rolling5 * 1000000.0), v49, 16u, 4);
          suffix_string((unsigned __int64)(rolling15 * 1000000.0), s, 16u, 4);
          snprintf(
            statusline,
            256u,
            "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
            opt_log_interval,
            v47,
            v48,
            v49,
            s,
            v46);
          if ( !pthread_mutex_unlock(&hash_lock) )
          {
            selective_yield(0);
            printf("%s          \r", statusline);
            fflush((FILE *)stdout);
            return;
          }
LABEL_78:
          v42 = _errno_location();
          snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v42, "cgminer.c", "hashmeter", 7118);
          goto LABEL_77;
        }
        v24 = (unsigned __int8)use_syslog;
        if ( use_syslog
          || (v24 = (unsigned __int8)opt_log_output, opt_log_output)
          || (v24 = opt_log_level, opt_log_level > 2) )
        {
          snprintf(s, 2048u, "cgminer time error total_secs = %d last_total_secs = %d", v24, LODWORD(v23));
          applog(3, s, 0);
        }
        if ( !pthread_mutex_unlock(&hash_lock) )
        {
          selective_yield(0);
          zero_stats();
          if ( !pthread_mutex_lock(&hash_lock) )
          {
            if ( !v9 )
              goto LABEL_34;
            goto LABEL_67;
          }
          v40 = *_errno_location();
          v41 = 7077;
LABEL_76:
          snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v40, "cgminer.c", "hashmeter", v41);
          goto LABEL_77;
        }
        v43 = *_errno_location();
        v44 = 7075;
LABEL_81:
        snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v43, "cgminer.c", "hashmeter", v44);
LABEL_77:
        applog(3, s, 1);
        _quit(1, 1);
      }
LABEL_51:
      v32 = 0;
      v33 = 0.0;
      v34 = g_local_mhashes_index + 1;
      if ( g_local_mhashes_index + 1 > 11 )
        v34 = 0;
      g_local_mhashes_index = v34;
      v35 = (int *)g_local_mhashes_dones;
      do
      {
        v36 = *(double *)v35;
        v35 += 2;
        if ( v36 >= 0.0 )
        {
          ++v32;
          *(_QWORD *)&v33 = (unsigned __int64)((double)*(unsigned __int64 *)&v33 + v36);
        }
      }
      while ( &g_local_mhashes_index != v35 );
      if ( v32 )
      {
        *(_QWORD *)&v33 /= (unsigned __int64)v32;
        a2 = *(_QWORD *)&v33;
      }
      if ( (double)opt_log_interval > 0.0 )
      {
        v37 = (double)a2;
        LODWORD(v37) = &total_rolling;
        v33 = decay_time_part_37(v37);
      }
      if ( v8 > 0.0 )
      {
        LODWORD(v33) = &rolling1;
        v38 = decay_time_part_37(v33);
        if ( v8 > 0.0 )
        {
          LODWORD(v38) = &rolling5;
          v39 = decay_time_part_37(v38);
          if ( v8 > 0.0 )
          {
            LODWORD(v39) = &rolling15;
            decay_time_part_37(v39);
          }
        }
      }
      v9 = 1;
      global_hashrate = (unsigned __int64)(total_rolling * 1000000.0);
      v17 = g_local_mhashes_index;
      v18 = 0.0;
      g_local_mhashes_dones[g_local_mhashes_index] = 0.0;
      goto LABEL_27;
    }
    goto LABEL_75;
  }
  if ( a1 >= 0 )
  {
    copy_time(&tv_hashmeter, (const timeval *)&total_tv_end);
    v9 = 0;
    goto LABEL_11;
  }
}
// 24C8A: variable 'v3' is possibly undefined
// 2502E: variable 'v28' is possibly undefined
// 7DEC8: using guessed type double total_secs;
// 7DED8: using guessed type int opt_log_interval;
// 7DEE8: using guessed type double last_total_secs;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B14: using guessed type int stdout;
// 80FB4: using guessed type int total_tv_end;
// 81018: using guessed type struct timeval tv_hashmeter;
// 81020: using guessed type double g_local_mhashes_dones[12];
// 81080: using guessed type int g_local_mhashes_index;
// 82524: using guessed type int hashdisplay_t;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA40: using guessed type int total_tv_start_sys;
// 80BAA8: using guessed type char want_per_device_stats;
// 80CBA0: using guessed type int total_tv_end_sys;
// 80CC18: using guessed type char use_syslog;
// 80DCA0: using guessed type int mining_threads;
// 80DCA8: using guessed type double total_rolling;
// 80DDA0: using guessed type double rolling5;
// 80DDA8: using guessed type double rolling1;
// 80DDB0: using guessed type double rolling15;
// 80EF48: using guessed type pthread_mutex_t hash_lock;

//----- (00025530) --------------------------------------------------------
void __fastcall hash_queued_work(int a1)
{
  pthread_rwlock_t *v1; // r4
  unsigned __int64 v3; // r10
  unsigned int nr_readers; // r5
  char v5; // r3
  __int64 v6; // r0
  bool v7; // zf
  int v8; // r3
  int v9; // r2
  bool v10; // cc
  unsigned __int64 v11; // r2
  int *v12; // r0
  int *v13; // r0
  void *v14; // [sp+14h] [bp-844h]
  void **work; // [sp+1Ch] [bp-83Ch] BYREF
  timeval v16; // [sp+20h] [bp-838h] BYREF
  struct timeval v17; // [sp+28h] [bp-830h] BYREF
  char s[2088]; // [sp+30h] [bp-828h] BYREF

  v1 = *(pthread_rwlock_t **)(a1 + 36);
  v3 = 0LL;
  nr_readers = v1->__nr_readers;
  v14 = *(void **)a1;
  v16.tv_sec = 0;
  v16.tv_usec = 0;
LABEL_2:
  v5 = v1[11].__size[12];
  if ( v5 )
  {
LABEL_19:
    v1[1].__lock = 1;
    return;
  }
  while ( 1 )
  {
    *(_BYTE *)(a1 + 63) = v5;
    do
    {
      if ( !v1[11].__nr_readers )
      {
        work = get_work(a1, v14);
        if ( pthread_rwlock_wrlock(v1 + 10) )
        {
          v12 = _errno_location();
          snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v12, "cgminer.c", "fill_queue", 9272);
          goto LABEL_33;
        }
        if ( v1[11].__nr_readers )
        {
          if ( pthread_rwlock_unlock(v1 + 10) )
          {
LABEL_36:
            v13 = _errno_location();
            snprintf(
              s,
              2048u,
              "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *v13,
              "cgminer.c",
              "fill_queue",
              9283);
LABEL_33:
            applog(3, s, 1);
            _quit(1, 1);
          }
          selective_yield(0);
          discard_work(&work, "cgminer.c", "fill_queue", 9287);
        }
        else
        {
          v1[11].__nr_readers = (unsigned int)work;
          if ( pthread_rwlock_unlock(v1 + 10) )
            goto LABEL_36;
          selective_yield(0);
        }
      }
    }
    while ( !(*(int (__fastcall **)(pthread_rwlock_t *))(nr_readers + 72))(v1) );
    LODWORD(v6) = (*(int (__fastcall **)(int))(nr_readers + 68))(a1);
    *(_BYTE *)(a1 + 62) = 0;
    v7 = HIDWORD(v6) == -1;
    if ( HIDWORD(v6) == -1 )
      v7 = (_DWORD)v6 == -1;
    if ( v7 )
      break;
    v3 += v6;
    cgtime(&v17);
    v8 = v17.tv_usec - v16.tv_usec;
    v9 = v17.tv_sec - v16.tv_sec;
    if ( v17.tv_usec - v16.tv_usec < 0 )
    {
      --v9;
      v8 += 1000000;
    }
    if ( v3 )
    {
      v10 = v9 <= 0;
      if ( v9 <= 0 )
        v10 = v8 <= 200000;
      if ( !v10 )
        goto LABEL_15;
    }
    if ( v9 >= opt_log_interval )
    {
LABEL_15:
      v11 = v3;
      v3 = 0LL;
      hashmeter((int)v14, v11);
      copy_time(&v16, &v17);
      if ( *(_BYTE *)(a1 + 60) )
        goto LABEL_22;
    }
    else if ( *(_BYTE *)(a1 + 60) )
    {
LABEL_22:
      mt_disable_isra_16(a1, (int)v14, (int (__fastcall **)(int))(nr_readers + 92));
      goto LABEL_17;
    }
    if ( v1[1].__lock )
      goto LABEL_22;
LABEL_17:
    if ( !*(_BYTE *)(a1 + 63) )
      goto LABEL_2;
    (*(void (__fastcall **)(pthread_rwlock_t *))(nr_readers + 80))(v1);
    v5 = v1[11].__size[12];
    if ( v5 )
      goto LABEL_19;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(s, 2048u, "%s %d failure, disabling!", *(const char **)(nr_readers + 8), v1->__readers_wakeup);
    applog(3, s, 0);
  }
  v1[1].__lock = 1;
  dev_error(v1, 1);
  v1[1].__lock = 1;
}
// 2558A: variable 'v6' is possibly undefined
// 7DED8: using guessed type int opt_log_interval;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00025758) --------------------------------------------------------
void __fastcall hash_driver_work(int a1)
{
  int v1; // r5
  unsigned __int64 v3; // r6
  int v4; // r8
  char v5; // r10
  __int64 v6; // r0
  bool v7; // zf
  int v8; // r3
  int v9; // r2
  bool v10; // cc
  unsigned __int64 v11; // r2
  int *v12; // r0
  int *v13; // r0
  int v14; // [sp+10h] [bp-840h]
  timeval v15; // [sp+18h] [bp-838h] BYREF
  struct timeval v16; // [sp+20h] [bp-830h] BYREF
  char s[2088]; // [sp+28h] [bp-828h] BYREF

  v1 = *(_DWORD *)(a1 + 36);
  v3 = 0LL;
  v4 = *(_DWORD *)(v1 + 4);
  v14 = *(_DWORD *)a1;
  v15.tv_sec = 0;
  v15.tv_usec = 0;
LABEL_2:
  v5 = *(_BYTE *)(v1 + 364);
  if ( v5 )
  {
LABEL_18:
    *(_DWORD *)(v1 + 32) = 1;
    return;
  }
  while ( 1 )
  {
    *(_BYTE *)(a1 + 63) = v5;
    LODWORD(v6) = (*(int (__fastcall **)(int))(v4 + 68))(a1);
    v7 = HIDWORD(v6) == -1;
    *(_BYTE *)(a1 + 62) = v5;
    if ( HIDWORD(v6) == -1 )
      v7 = (_DWORD)v6 == -1;
    if ( v7 )
      break;
    v3 += v6;
    cgtime(&v16);
    v8 = v16.tv_usec - v15.tv_usec;
    v9 = v16.tv_sec - v15.tv_sec;
    if ( v16.tv_usec - v15.tv_usec < 0 )
    {
      --v9;
      v8 += 1000000;
    }
    if ( v3 )
    {
      v10 = v9 <= 0;
      if ( v9 <= 0 )
        v10 = v8 <= (int)&loc_30D40;
      if ( !v10 )
        goto LABEL_12;
    }
    if ( v9 >= opt_log_interval )
    {
LABEL_12:
      v11 = v3;
      v3 = 0LL;
      hashmeter(v14, v11);
      copy_time(&v15, &v16);
      if ( !*(_BYTE *)(a1 + 60) )
        goto LABEL_13;
    }
    else if ( !*(_BYTE *)(a1 + 60) )
    {
LABEL_13:
      if ( !*(_DWORD *)(v1 + 32) )
        goto LABEL_14;
    }
    mt_disable_isra_16(a1, v14, (int (__fastcall **)(int))(v4 + 92));
LABEL_14:
    if ( !*(_BYTE *)(a1 + 63) )
      goto LABEL_2;
    if ( pthread_mutex_lock(&update_job_lock) )
    {
      v12 = _errno_location();
      snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v12, "cgminer.c", "hash_driver_work", 9660);
      goto LABEL_29;
    }
    (*(void (__fastcall **)(int))(v4 + 80))(v1);
    if ( pthread_mutex_unlock(&update_job_lock) )
    {
      v13 = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v13,
        "cgminer.c",
        "hash_driver_work",
        9662);
LABEL_29:
      applog(3, s, 1);
      _quit(1, 1);
    }
    selective_yield(0);
    v5 = *(_BYTE *)(v1 + 364);
    if ( v5 )
      goto LABEL_18;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(s, 2048u, "%s %d failure, disabling!", *(const char **)(v4 + 8), *(_DWORD *)(v1 + 8));
    applog(3, s, 0);
  }
  *(_DWORD *)(v1 + 32) = 1;
  dev_error((_DWORD *)v1, 1);
  *(_DWORD *)(v1 + 32) = 1;
}
// 257A6: variable 'v6' is possibly undefined
// 7DED8: using guessed type int opt_log_interval;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;
// 80EED8: using guessed type pthread_mutex_t update_job_lock;

//----- (00025934) --------------------------------------------------------
void __fastcall hash_sole_work(int a1)
{
  int v1; // r10
  int v3; // r4
  int v4; // r3
  int v5; // r5
  int v6; // r11
  int v7; // r9
  int v8; // r3
  int (__fastcall *v9)(int); // r3
  double v10; // d7
  int v11; // r6
  char *v12; // r5
  struct timeval *v13; // r0
  int v14; // r4
  time_t v15; // r0
  void **v16; // r1
  __int64 v17; // r4
  bool v18; // zf
  int v19; // r2
  int v20; // r7
  int v21; // r5
  int v22; // r4
  bool v23; // cc
  _BOOL4 v24; // r1
  int v25; // r1
  int v26; // r3
  unsigned __int64 v27; // [sp+8h] [bp-8A0h]
  timeval *v28; // [sp+10h] [bp-898h]
  timeval *v29; // [sp+14h] [bp-894h]
  unsigned int v30; // [sp+18h] [bp-890h]
  int v31; // [sp+2Ch] [bp-87Ch]
  void *v32; // [sp+30h] [bp-878h]
  int remaining; // [sp+40h] [bp-868h]
  int v34; // [sp+48h] [bp-860h]
  unsigned int v35; // [sp+54h] [bp-854h]
  void **work; // [sp+5Ch] [bp-84Ch] BYREF
  struct timeval v37; // [sp+60h] [bp-848h] BYREF
  struct timeval v38; // [sp+68h] [bp-840h] BYREF
  struct timeval v39; // [sp+70h] [bp-838h] BYREF
  struct timeval v40; // [sp+78h] [bp-830h] BYREF
  struct timespec s[261]; // [sp+80h] [bp-828h] BYREF

  v1 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)(v1 + 4);
  v32 = *(void **)a1;
  v4 = opt_log_interval / 5;
  if ( (int)((unsigned __int64)(1717986919LL * opt_log_interval) >> 32) >> 1 == opt_log_interval >> 31 )
    v4 = 1;
  v31 = v4;
  if ( *(_DWORD *)(a1 + 4) )
    remaining = *(unsigned __int8 *)(a1 + 8);
  else
    remaining = 1;
  v30 = (*(int (__fastcall **)(int))(v3 + 48))(a1);
  cgtime(&v37);
  cgtime(&v40);
  if ( *(_BYTE *)(v1 + 364) )
    goto LABEL_56;
  v5 = *(unsigned __int8 *)(v1 + 364);
  v27 = 0LL;
  v6 = v5;
  v7 = v3;
  v8 = ((_DWORD)&unk_F4240 * v31 + 1023) & (((int)&unk_F4240 * v31) >> 31);
  if ( (int)&unk_F4240 * v31 >= 0 )
    v8 = (_DWORD)&unk_F4240 * v31;
  v34 = v8 >> 10;
  while ( 1 )
  {
    work = get_work(a1, v32);
    *(_BYTE *)(a1 + 62) = 0;
    *(_BYTE *)(v1 + 172) = 1;
    cgtime(&v39);
    v9 = *(int (__fastcall **)(int))(v7 + 56);
    work[62] = 0;
    *(_DWORD *)(v1 + 160) = 0;
    *(_DWORD *)(v1 + 164) = 0;
    if ( !v9(a1) )
      break;
    v10 = *(double *)(v7 + 104);
    v11 = v5;
    v28 = (timeval *)(v1 + 304);
    v29 = (timeval *)(v1 + 312);
    if ( v10 > *((double *)work + 47) )
      v10 = *((double *)work + 47);
    if ( v10 < *(double *)(v7 + 112) )
      v10 = *(double *)(v7 + 112);
    *((double *)work + 28) = v10;
    while ( 1 )
    {
      cgtime(&v38);
      subtime(&v38.tv_sec, &v37);
      addtime(&v37.tv_sec, (_DWORD *)(v1 + 296));
      if ( time_more(&v37, v28) )
        copy_time(v28, &v37);
      if ( time_less(&v37, v29) )
        copy_time(v29, &v37);
      v12 = (char *)work[65];
      ++*(_DWORD *)(v1 + 292);
      addtime(&v37.tv_sec, (_DWORD *)v12 + 97);
      if ( time_more(&v37, (_DWORD *)v12 + 99) )
        copy_time((timeval *)(v12 + 396), &v37);
      if ( time_less(&v37, (_DWORD *)v12 + 101) )
        copy_time((timeval *)(v12 + 404), &v37);
      v13 = (struct timeval *)work;
      ++*((_DWORD *)v12 + 96);
      cgtime(v13 + 53);
      pthread_setcancelstate(1, 0);
      *(_BYTE *)(a1 + 61) = 0;
      cgtime((struct timeval *)(a1 + 44));
      v14 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(v14 + 96) = 0;
      v15 = time(0);
      v16 = work;
      *(_DWORD *)(v14 + 240) = v15;
      v17 = ((__int64 (__fastcall *)(int, void **, char *, _DWORD))*(_DWORD *)(v7 + 64))(
              a1,
              v16,
              (char *)v16[62] + v30,
              0);
      thread_reportout((thr_info *)a1);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      cgtime(&v37);
      v18 = HIDWORD(v17) == -1;
      if ( HIDWORD(v17) == -1 )
        v18 = (_DWORD)v17 == -1;
      if ( v18 )
        break;
      v27 += v17;
      if ( *(_QWORD *)(v1 + 160) < v17 )
        *(_QWORD *)(v1 + 160) = v17;
      v19 = v37.tv_sec - v38.tv_sec;
      v6 += v37.tv_usec - v38.tv_usec + (v37.tv_usec - v38.tv_usec < 0 ? 1000000 : 0);
      if ( v37.tv_usec - v38.tv_usec < 0 )
        --v19;
      v11 += v19;
      if ( v6 > (int)&unk_F4240 )
      {
        ++v11;
        v6 -= 1000000;
      }
      v20 = v37.tv_sec - v39.tv_sec;
      if ( v37.tv_usec - v39.tv_usec < 0 )
        --v20;
      if ( v31 > v11 )
      {
        if ( v30 == -1 )
          goto LABEL_50;
        v25 = v6 + 2047;
        if ( v6 + 1024 >= 0 )
          v25 = v6 + 1024;
        v35 = ((int)&unk_F4240 / (v25 >> 10) + 16) * v31;
        if ( v30 <= 4294966272 / v35 )
          v30 = (v35 * v30) >> 10;
        else
          v30 = -1;
      }
      else if ( v31 < v11 )
      {
        v30 = v31 * v30 / v11;
      }
      else if ( v6 > 100000 )
      {
        v30 = (v30 << 10) / ((v6 + (int)&unk_F4240 * v31) / v34);
      }
      v21 = v37.tv_sec - v40.tv_sec;
      v22 = v37.tv_usec - v40.tv_usec;
      if ( v37.tv_usec - v40.tv_usec < 0 )
      {
        --v21;
        v22 += 1000000;
      }
      if ( v27 )
      {
        v23 = v21 <= 0;
        if ( v21 <= 0 )
          v23 = v22 <= (int)&loc_30D40;
        if ( !v23 )
          goto LABEL_46;
      }
      if ( v21 >= opt_log_interval )
      {
LABEL_46:
        hashmeter((int)v32, v27);
        v27 = 0LL;
        copy_time(&v40, &v37);
      }
      if ( *(_BYTE *)(a1 + 62) )
      {
        v5 = v11;
        if ( !remaining )
        {
          v26 = *(_DWORD *)(a1 + 4);
          s[0].tv_sec = 0;
          s[0].tv_nsec = 250000000 * v26;
          nanosleep(s, 0);
        }
        goto LABEL_55;
      }
      if ( *(_BYTE *)(a1 + 60) || (v6 = *(_DWORD *)(v1 + 32), (v11 = v6) != 0) )
      {
        v6 = 0;
        mt_disable_isra_16(a1, (int)v32, (int (__fastcall **)(int))(v7 + 92));
        v11 = 0;
      }
LABEL_50:
      v24 = v20 > opt_scantime || *(_QWORD *)(v1 + 160) > 4294967293uLL;
      if ( v24 || stale_work((int)work, 0) )
      {
        v5 = v11;
        goto LABEL_55;
      }
    }
    v5 = v11;
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)s, 2048u, "%s %d failure, disabling!", *(const char **)(v7 + 8), *(_DWORD *)(v1 + 8));
      applog(3, (const char *)s, 0);
    }
    *(_DWORD *)(v1 + 32) = 1;
    dev_error((_DWORD *)v1, 1);
    *(_BYTE *)(v1 + 364) = 1;
LABEL_55:
    free_work(&work, "cgminer.c", "hash_sole_work", 9247);
    if ( *(_BYTE *)(v1 + 364) )
    {
LABEL_56:
      *(_DWORD *)(v1 + 32) = 1;
      return;
    }
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
    goto LABEL_56;
  snprintf((char *)s, 2048u, "work prepare failed, exiting mining thread %d", v32);
  applog(3, (const char *)s, 0);
  *(_DWORD *)(v1 + 32) = 1;
}
// 7DED8: using guessed type int opt_log_interval;
// 7DEFC: using guessed type int opt_scantime;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00025E50) --------------------------------------------------------
void __noreturn watchdog_thread()
{
  int v0; // r4
  int thread; // r0
  sem_t *v2; // r5
  int v3; // r3
  int v4; // r5
  int v5; // r3
  int devices; // r0
  int v7; // r4
  int v8; // r6
  int v9; // r3
  int v10; // r2
  int *v11; // r3
  int v12; // r1
  int v13; // t1
  int v14; // r3
  int *v15; // r0
  int *v16; // r0
  struct timeval v17; // [sp+30h] [bp-840h] BYREF
  char v18[8]; // [sp+38h] [bp-838h] BYREF
  char s[2096]; // [sp+40h] [bp-830h] BYREF

  pthread_setcanceltype(1, 0);
  RenameThread("Watchdog");
  set_lowprio();
  cgtime((struct timeval *)&rotate_tv);
LABEL_2:
  while ( 1 )
  {
    sleep(2u);
    discard_stale();
    hashmeter(-1, 0LL);
    cgtime(&v17);
    if ( sched_paused )
      goto LABEL_87;
    if ( !should_run() )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      {
        if ( !schedstart )
          goto LABEL_82;
        goto LABEL_55;
      }
      snprintf(s, 2048u, "Pausing execution as per stop time %02d:%02d scheduled", dword_80BA10, dword_80BA0C);
      applog(4, s, 0);
      if ( !schedstart )
      {
LABEL_82:
        strcpy(s, "Terminating execution as planned");
        applog(3, s, 1);
        _quit(0, 1);
      }
      if ( use_syslog || opt_log_output )
      {
LABEL_56:
        snprintf(s, 2048u, "Will restart execution as scheduled at %02d:%02d", dword_80BAC8, dword_80BAC4);
        applog(4, s, 0);
      }
      else
      {
LABEL_55:
        if ( opt_log_level > 3 )
          goto LABEL_56;
      }
      sched_paused = 1;
      if ( pthread_rwlock_rdlock(&mining_thr_lock) )
      {
        v15 = _errno_location();
        snprintf(
          s,
          2048u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v15,
          "cgminer.c",
          "watchdog_thread",
          10313);
        applog(3, s, 1);
        _quit(1, 1);
      }
      if ( mining_threads > 0 )
      {
        v11 = (int *)mining_thr;
        v12 = mining_thr + 4 * mining_threads;
        do
        {
          v13 = *v11++;
          *(_BYTE *)(v13 + 60) = 1;
        }
        while ( v11 != (int *)v12 );
      }
      if ( pthread_rwlock_unlock(&mining_thr_lock) )
      {
        v16 = _errno_location();
        snprintf(
          s,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v16,
          "cgminer.c",
          "watchdog_thread",
          10320);
        applog(3, s, 1);
        _quit(1, 1);
      }
      selective_yield(0);
      goto LABEL_20;
    }
    if ( sched_paused )
    {
LABEL_87:
      if ( should_run() )
        break;
    }
LABEL_20:
    if ( total_devices > 0 )
    {
      v4 = 0;
      while ( 1 )
      {
        devices = get_devices(v4);
        v7 = devices;
        v8 = **(_DWORD **)(devices + 152);
        if ( !v8 )
          goto LABEL_34;
        (*(void (**)(void))(*(_DWORD *)(devices + 4) + 32))();
        snprintf(v18, 8u, "%s %d", *(const char **)(*(_DWORD *)(v7 + 4) + 8), *(_DWORD *)(v7 + 8));
        if ( *(_BYTE *)(v8 + 61) || *(_DWORD *)(v7 + 32) == 1 )
          goto LABEL_34;
        v9 = *(_DWORD *)(v7 + 96);
        if ( !v9 )
        {
          if ( v17.tv_sec - *(_DWORD *)(v8 + 44) <= 120 )
            goto LABEL_34;
          v5 = (unsigned __int8)use_syslog;
          *(_QWORD *)(v7 + 48) = 0LL;
          *(_DWORD *)(v7 + 96) = 1;
          if ( v5 || opt_log_output || opt_log_level > 2 )
          {
            snprintf(s, 2048u, "%s: Idle for more than 60 seconds, declaring SICK!", v18);
            applog(3, s, 0);
          }
          cgtime((struct timeval *)(v8 + 52));
          dev_error((_DWORD *)v7, 3);
          if ( !opt_restart )
            goto LABEL_34;
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf(s, 2048u, "%s: Attempting to restart", v18);
            applog(3, s, 0);
          }
LABEL_32:
          if ( *(_DWORD *)(v7 + 32) != 1 )
            reinit_device_part_38(v7);
          goto LABEL_34;
        }
        v10 = v17.tv_sec - *(_DWORD *)(v8 + 44);
        if ( v10 <= 119 )
        {
          if ( v9 != 4 && (use_syslog || opt_log_output || opt_log_level > 2) )
          {
            snprintf(s, 2048u, "%s: Recovered, declaring WELL!", v18);
            applog(3, s, 0);
          }
          *(_DWORD *)(v7 + 96) = 0;
          *(_DWORD *)(v7 + 240) = time(0);
          goto LABEL_34;
        }
        if ( v9 == 1 )
        {
          if ( v10 > 600 )
          {
            v14 = (unsigned __int8)use_syslog;
            *(_DWORD *)(v7 + 96) = 2;
            if ( v14 || opt_log_output || opt_log_level > 2 )
            {
              snprintf(s, 2048u, "%s: Not responded for more than 10 minutes, declaring DEAD!", v18);
              applog(3, s, 0);
            }
            cgtime((struct timeval *)(v8 + 52));
            dev_error((_DWORD *)v7, 4);
            goto LABEL_34;
          }
          if ( v17.tv_sec - *(_DWORD *)(v8 + 52) <= 60 )
            goto LABEL_34;
        }
        else if ( v17.tv_sec - *(_DWORD *)(v8 + 52) <= 60 || v9 != 2 )
        {
          goto LABEL_34;
        }
        cgtime((struct timeval *)(v8 + 52));
        if ( opt_restart )
          goto LABEL_32;
LABEL_34:
        if ( total_devices <= ++v4 )
          goto LABEL_2;
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(s, 2048u, "Restarting execution as per start time %02d:%02d scheduled", dword_80BAC8, dword_80BAC4);
    applog(4, s, 0);
    if ( !schedstop )
      goto LABEL_11;
    if ( use_syslog || opt_log_output )
      goto LABEL_10;
  }
  else if ( !schedstop )
  {
    goto LABEL_11;
  }
  if ( opt_log_level > 3 )
  {
LABEL_10:
    snprintf(s, 2048u, "Will pause execution as scheduled at %02d:%02d", dword_80BA10, dword_80BA0C);
    applog(4, s, 0);
  }
LABEL_11:
  v0 = 0;
  for ( sched_paused = 0; mining_threads > v0; ++v0 )
  {
    thread = get_thread(v0);
    v2 = (sem_t *)thread;
    if ( *(_DWORD *)(*(_DWORD *)(thread + 36) + 32) != 1 )
    {
      v3 = (unsigned __int8)opt_debug;
      *(_BYTE *)(thread + 60) = 0;
      if ( v3 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(s, 2048u, "Pushing sem post to thread %d", *(_DWORD *)thread);
        applog(7, s, 0);
      }
      cgsem_post(v2 + 1, "cgminer.c", "watchdog_thread", 10347);
    }
  }
  goto LABEL_20;
}
// 25E50: using guessed type void __noreturn watchdog_thread();
// 7DF04: using guessed type char opt_restart;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 810F0: using guessed type int rotate_tv;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA04: using guessed type char schedstop;
// 80BA0C: using guessed type int dword_80BA0C;
// 80BA10: using guessed type int dword_80BA10;
// 80BABC: using guessed type char schedstart;
// 80BAC4: using guessed type int dword_80BAC4;
// 80BAC8: using guessed type int dword_80BAC8;
// 80CBC0: using guessed type int mining_thr;
// 80CBC4: using guessed type pthread_rwlock_t mining_thr_lock;
// 80CC18: using guessed type char use_syslog;
// 80DCA0: using guessed type int mining_threads;
// 80DCD8: using guessed type int total_devices;

//----- (00026410) --------------------------------------------------------
int __fastcall test_work_current(int a1)
{
  int v1; // r3
  int v2; // r4
  size_t v3; // r6
  int result; // r0
  int v6; // r0
  int v7; // r3
  int v8; // r2
  int v9; // r5
  int v10; // r3
  int v11; // r5
  int v12; // r3
  size_t v13; // r5
  int v14; // r3
  int v15; // r0
  int v16; // r6
  char *v17; // lr
  unsigned int v18; // r4
  int v19; // r7
  int v20; // r9
  int v21; // r2
  int v22; // r11
  unsigned int v23; // r4
  unsigned int v24; // r3
  int v25; // r2
  unsigned int v26; // r1
  unsigned int v27; // r3
  int v28; // r2
  unsigned int v29; // r1
  unsigned int v30; // r3
  size_t v31; // r0
  int v32; // r2
  size_t v33; // r4
  unsigned int v34; // r0
  unsigned int v35; // r4
  int v36; // r3
  unsigned int v37; // r2
  unsigned int v38; // r0
  int v39; // r3
  unsigned int v40; // r6
  _DWORD *v41; // r1
  int v42; // r4
  int v43; // r7
  int v44; // r4
  int v45; // r4
  char *v46; // r0
  int v47; // r11
  int v48; // r2
  _DWORD *v49; // r10
  int v50; // r4
  int v51; // r7
  int v52; // r6
  int v53; // r3
  int v54; // r2
  unsigned int v55; // lr
  int v56; // r11
  int v57; // r1
  int i; // r0
  int v59; // r8
  int v60; // r5
  bool v61; // zf
  int v62; // r1
  int v63; // r7
  bool v64; // zf
  int v65; // r4
  bool v66; // cc
  int v67; // r5
  int v68; // r7
  int v69; // r1
  int v70; // r8
  int v71; // r4
  int v72; // r2
  int v73; // r5
  int v74; // r1
  int v75; // r0
  int v76; // r3
  int v77; // r0
  int v78; // r6
  int *v79; // r0
  int v80; // r5
  int v81; // r3
  int v82; // r7
  int v83; // r2
  int v84; // r3
  int v85; // r4
  size_t v86; // r0
  int v87; // r3
  unsigned int v88; // r2
  size_t v89; // r10
  int v90; // r0
  unsigned __int8 *v91; // r7
  unsigned int v92; // r1
  int v93; // r8
  int v94; // r3
  int v95; // r2
  int v96; // r9
  unsigned int v97; // r1
  unsigned int v98; // r3
  int v99; // r2
  unsigned int v100; // r1
  unsigned int v101; // r3
  int v102; // r2
  unsigned int v103; // r1
  unsigned int v104; // r3
  size_t v105; // r4
  int v106; // r2
  unsigned int v107; // r3
  unsigned int v108; // r1
  int v109; // r2
  unsigned int v110; // r3
  unsigned int v111; // r1
  unsigned int v112; // r2
  unsigned int v113; // r4
  char *v114; // r5
  int *v115; // r6
  int v116; // r2
  int v117; // r2
  int v118; // r4
  int v119; // r6
  unsigned int v120; // r3
  int v121; // r0
  int v122; // r3
  _DWORD *v123; // r7
  void **v124; // r10
  char *v125; // r3
  unsigned int v126; // r4
  char *v127; // r2
  unsigned int v128; // r9
  int v129; // r11
  _DWORD *v130; // r5
  _DWORD *v131; // r8
  int v132; // r4
  char *v133; // r6
  unsigned int v134; // r0
  int v135; // r3
  _DWORD *v136; // r4
  unsigned int v137; // r0
  unsigned int v138; // r1
  int v139; // r2
  int v140; // r3
  int v141; // r3
  int v142; // r2
  unsigned int v143; // r3
  int v144; // r3
  unsigned __int64 v145; // r0
  double v146; // d6
  double v147; // d8
  int v148; // r7
  struct tm *v149; // r0
  int v150; // r1
  char *v151; // r3
  int v152; // t1
  int v153; // r1
  const char *v154; // r2
  int v155; // r5
  char *v156; // r3
  int *v157; // r0
  const char *v158; // r5
  int v159; // r3
  int v160; // r4
  int *v161; // r0
  int *v162; // r0
  int *v163; // r0
  unsigned int v164; // r12
  unsigned __int8 *v165; // r8
  char *v166; // r3
  int *v167; // r0
  int *v168; // r0
  int *v169; // r0
  int *v170; // r0
  int v171; // r5
  int v172; // r0
  int v173; // r7
  unsigned int v174; // lr
  unsigned __int8 *v175; // r12
  void *v176; // r0
  _DWORD *v177; // r6
  void *v178; // r0
  _DWORD *v179; // [sp+14h] [bp-8C4h]
  int v180; // [sp+18h] [bp-8C0h]
  char *v181; // [sp+20h] [bp-8B8h]
  int v182; // [sp+2Ch] [bp-8ACh]
  int v183; // [sp+30h] [bp-8A8h]
  char *ptr; // [sp+34h] [bp-8A4h]
  int v185; // [sp+38h] [bp-8A0h]
  int v186; // [sp+40h] [bp-898h] BYREF
  int s2[8]; // [sp+44h] [bp-894h] BYREF
  char s[12]; // [sp+64h] [bp-874h] BYREF
  char v189; // [sp+70h] [bp-868h] BYREF
  time_t v190[524]; // [sp+A8h] [bp-830h] BYREF

  v179 = *(_DWORD **)(a1 + 260);
  v1 = *(unsigned __int8 *)(a1 + 282);
  v2 = v179[392];
  v186 = 0;
  v3 = *(unsigned __int8 *)(v2 + 42);
  if ( v1 )
    return 1;
  v6 = *(_DWORD *)(a1 + 32);
  v7 = *(_DWORD *)(a1 + 20);
  v8 = *(_DWORD *)(a1 + 28);
  s2[2] = *(_DWORD *)(a1 + 24);
  s2[3] = v7;
  v9 = *(_DWORD *)(a1 + 16);
  v10 = *(_DWORD *)(a1 + 12);
  s2[0] = v6;
  s2[4] = v9;
  s2[5] = v10;
  v11 = *(_DWORD *)(a1 + 8);
  v12 = *(_DWORD *)(a1 + 4);
  s2[1] = v8;
  v180 = a1;
  s2[6] = v11;
  s2[7] = v12;
  _bin2hex(s, (unsigned __int8 *)s2, 32);
  if ( v3 <= 4 )
  {
    cg_memcpy(&v186, (const void *)(v2 + 43), v3, (int)"cgminer.c", (int)"test_work_current", 5568);
    --v186;
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(v179 + 53)) )
  {
    v157 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v157,
      "cgminer.c",
      "test_work_current",
      5573);
    goto LABEL_204;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v179 + 59)) )
  {
    v158 = "test_work_current";
    v159 = *_errno_location();
    v160 = 5573;
LABEL_206:
    snprintf((char *)v190, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v159, "cgminer.c", v158, v160);
    goto LABEL_204;
  }
  if ( *((_BYTE *)v179 + 680) )
  {
    *((_BYTE *)v179 + 680) = 0;
    *(_BYTE *)(a1 + 280) = 1;
  }
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v179 + 59)) )
  {
    v161 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v161,
      "cgminer.c",
      "test_work_current",
      5581);
    goto LABEL_204;
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(v179 + 53)) )
  {
    v162 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v162,
      "cgminer.c",
      "test_work_current",
      5581);
    goto LABEL_204;
  }
  selective_yield(0);
  if ( pthread_rwlock_wrlock(&blk_lock) )
  {
    v158 = "block_exists";
    v159 = *_errno_location();
    v160 = 5494;
    goto LABEL_206;
  }
  v13 = strlen(s);
  v14 = -1640531527;
  v15 = -17973521;
  v16 = -1640531527;
  if ( v13 > 11 )
  {
    v17 = &v189;
    v164 = v13;
    v18 = -1640531527;
    do
    {
      v19 = (unsigned __int8)*(v17 - 6);
      v164 -= 12;
      v20 = (unsigned __int8)*(v17 - 7);
      v21 = (unsigned __int8)*(v17 - 10);
      v165 = (unsigned __int8 *)v17;
      v22 = (unsigned __int8)*(v17 - 11);
      v17 += 12;
      v23 = v18 + (v19 << 16) + (v20 << 8) + (unsigned __int8)*(v17 - 20) + ((unsigned __int8)*(v17 - 17) << 24);
      v24 = ((unsigned __int8)*(v17 - 14) << 16)
          + ((unsigned __int8)*(v17 - 15) << 8)
          + (unsigned __int8)*(v17 - 16)
          + ((unsigned __int8)*(v17 - 13) << 24)
          + v15;
      v25 = ((unsigned __int8)*(v17 - 24)
           + (v21 << 16)
           + (v22 << 8)
           + ((unsigned __int8)*(v17 - 21) << 24)
           - v23
           - v24
           + v16) ^ (v24 >> 13);
      v26 = (v23 - v24 - v25) ^ (v25 << 8);
      v27 = (v24 - v25 - v26) ^ (v26 >> 13);
      v28 = (v25 - v26 - v27) ^ (v27 >> 12);
      v29 = (v26 - v27 - v28) ^ (v28 << 16);
      v30 = (v27 - v28 - v29) ^ (v29 >> 5);
      v16 = (v28 - v29 - v30) ^ (v30 >> 3);
      v18 = (v29 - v30 - v16) ^ (v16 << 10);
      v15 = (v30 - v16 - v18) ^ (v18 >> 15);
    }
    while ( v164 > 11 );
    v14 = (v29 - v30 - v16) ^ (v16 << 10);
  }
  else
  {
    v164 = v13;
    v165 = (unsigned __int8 *)s;
  }
  v31 = v15 + v13;
  switch ( v164 )
  {
    case 1u:
      goto LABEL_28;
    case 2u:
      goto LABEL_27;
    case 3u:
      goto LABEL_26;
    case 4u:
      goto LABEL_25;
    case 5u:
      goto LABEL_24;
    case 6u:
      goto LABEL_23;
    case 7u:
      goto LABEL_22;
    case 8u:
      goto LABEL_21;
    case 9u:
      goto LABEL_20;
    case 10u:
      goto LABEL_19;
    case 11u:
      v31 += v165[10] << 24;
LABEL_19:
      v31 += v165[9] << 16;
LABEL_20:
      v31 += v165[8] << 8;
LABEL_21:
      v14 += v165[7] << 24;
LABEL_22:
      v14 += v165[6] << 16;
LABEL_23:
      v14 += v165[5] << 8;
LABEL_24:
      v14 += v165[4];
LABEL_25:
      v16 += v165[3] << 24;
LABEL_26:
      v16 += v165[2] << 16;
LABEL_27:
      v16 += v165[1] << 8;
LABEL_28:
      v16 += *v165;
      break;
    default:
      break;
  }
  v32 = (v16 - v14 - v31) ^ (v31 >> 13);
  v33 = v31 - v32;
  v34 = (v14 - v31 - v32) ^ (v32 << 8);
  v35 = (v33 - v34) ^ (v34 >> 13);
  v36 = (v32 - v34 - v35) ^ (v35 >> 12);
  v37 = (v34 - v35 - v36) ^ (v36 << 16);
  v38 = (v35 - v36 - v37) ^ (v37 >> 5);
  v39 = (v36 - v37 - v38) ^ (v38 >> 3);
  v40 = (v38 - v39 - ((v37 - v38 - v39) ^ (v39 << 10))) ^ (((v37 - v38 - v39) ^ (v39 << 10)) >> 15);
  if ( blocks )
  {
    v41 = *(_DWORD **)(blocks + 68);
    v42 = *(_DWORD *)(*v41 + 12 * ((v41[1] - 1) & v40));
    if ( v42 )
    {
      v43 = -v41[5];
      v44 = v42 - v41[5];
      if ( v44 )
      {
        while ( v40 != *(_DWORD *)(v44 + 96)
             || v13 != *(_DWORD *)(v44 + 92)
             || memcmp(*(const void **)(v44 + 88), s, v13) )
        {
          v45 = *(_DWORD *)(v44 + 84);
          if ( v45 )
          {
            v44 = v45 + v43;
            if ( v44 )
              continue;
          }
          goto LABEL_35;
        }
        if ( !pthread_rwlock_unlock(&blk_lock) )
        {
          ((void (*)(void))selective_yield)();
          if ( !memcmp(v179 + 136, s2, 32u) )
          {
            v65 = 1;
          }
          else if ( !memcmp(s2, &current_block, 32u) )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 5 )
            {
              snprintf((char *)v190, 2048u, "Pool %d now up to date at height %d", *v179, v186);
              applog(6, (const char *)v190, 0);
            }
            v65 = 1;
            cg_memcpy(v179 + 136, s2, 32u, (int)"cgminer.c", (int)"test_work_current", 5639);
          }
          else
          {
            v65 = (unsigned __int8)opt_debug;
            if ( opt_debug )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 6 )
              {
                v65 = 0;
                snprintf((char *)v190, 2048u, "Stale data from pool %d at height %d", *v179, v186);
                applog(7, (const char *)v190, 0);
              }
              else
              {
                v65 = 0;
              }
            }
          }
          if ( *(_BYTE *)(v180 + 280) )
          {
            v66 = (unsigned int)(pool_strategy - 3) > 1;
            *(_DWORD *)(v180 + 336) = ++work_block;
            if ( !v66 || (v67 = *(_DWORD *)(v180 + 260), v67 == current_pool()) )
            {
              if ( *(_BYTE *)(v180 + 284) )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 4 )
                {
                  snprintf((char *)v190, 2048u, "Stratum from pool %d requested work restart", *v179);
                  applog(5, (const char *)v190, 0);
                }
              }
              else if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                v166 = "";
                if ( *(_BYTE *)(v180 + 324) )
                  v166 = "GBT ";
                snprintf(
                  (char *)v190,
                  2048u,
                  "%sLONGPOLL from pool %d requested work restart",
                  v166,
                  **(_DWORD **)(v180 + 260));
                applog(5, (const char *)v190, 0);
              }
              restart_threads();
            }
          }
          goto LABEL_88;
        }
        goto LABEL_210;
      }
    }
  }
LABEL_35:
  v46 = (char *)cgcalloc(104u, 1u, "cgminer.c", "block_exists", 5498);
  v181 = v46;
  if ( !v46 )
  {
    strcpy((char *)v190, "block_exists OOM");
    applog(3, (const char *)v190, 1);
    _quit(1, 1);
  }
  strcpy(v46, s);
  v47 = blocks;
  v48 = new_blocks + 1;
  *((_DWORD *)v181 + 25) = new_blocks;
  new_blocks = v48;
  if ( v47 )
  {
    v49 = *(_DWORD **)(v47 + 68);
    if ( v49[3] <= 3u )
    {
      v183 = 0;
      goto LABEL_124;
    }
    v50 = v49[5];
    v51 = v47 + 68;
    v52 = 1;
    while ( 1 )
    {
      v53 = v51;
      v54 = 0;
      v55 = 0;
      v56 = 0;
      do
      {
        ++v55;
        if ( v52 )
        {
          v57 = *(_DWORD *)(v53 + 8);
          for ( i = 1; v57; ++i )
          {
            v57 += v50;
            if ( !v57 )
              break;
            if ( i == v52 )
              break;
            v57 = *(_DWORD *)(v57 + 8);
          }
        }
        else
        {
          v57 = v53;
          i = 0;
        }
        v59 = v53;
        v60 = v52;
        v53 = v57;
LABEL_47:
        while ( i )
        {
          while ( 1 )
          {
            v64 = v53 == 0;
            if ( v53 )
              v64 = v60 == 0;
            if ( !v64 && *(_DWORD *)(v59 - v50 + 100) - *(_DWORD *)(v53 - v50 + 100) > 0 )
            {
              v62 = *(_DWORD *)(v53 + 8);
              if ( !v62 )
              {
                --v60;
                if ( v54 )
                  goto LABEL_54;
LABEL_63:
                v54 = v53;
                v53 = v62;
                goto LABEL_64;
              }
LABEL_52:
              v62 += v50;
LABEL_53:
              --v60;
              if ( v54 )
                goto LABEL_54;
              goto LABEL_63;
            }
            v68 = v59;
            if ( v59 )
            {
              v69 = *(_DWORD *)(v59 + 8);
              v68 = v69 + v50;
              if ( !v69 )
                v68 = 0;
            }
            --i;
            if ( v54 )
              break;
            v54 = v59;
            v59 = v68;
LABEL_64:
            v56 = v54;
            v63 = 0;
            if ( !v54 )
              goto LABEL_47;
LABEL_56:
            *(_DWORD *)(v54 + 4) = v63;
            if ( !i )
              goto LABEL_48;
          }
          if ( v59 )
          {
            v62 = v53;
            v53 = v59;
            v59 = v68;
LABEL_54:
            *(_DWORD *)(v54 + 8) = v53 - v50;
            if ( v53 )
            {
              v63 = v54 - v50;
              v54 = v53;
              v53 = v62;
              goto LABEL_56;
            }
            v54 = 0;
            v53 = v62;
          }
          else
          {
            *(_DWORD *)(v54 + 8) = 0;
            v54 = 0;
            v59 = v68;
          }
        }
LABEL_48:
        v61 = v60 == 0;
        if ( v60 )
          v61 = v53 == 0;
        if ( !v61 )
        {
          v62 = *(_DWORD *)(v53 + 8);
          if ( v62 )
            goto LABEL_52;
          v62 = i;
          goto LABEL_53;
        }
      }
      while ( v53 );
      v51 = v56;
      if ( v54 )
        *(_DWORD *)(v54 + 8) = 0;
      if ( v55 <= 1 )
        break;
      v52 *= 2;
      if ( !v56 )
      {
        v70 = 0;
        v54 = 0;
        goto LABEL_110;
      }
    }
    v70 = v56;
LABEL_110:
    v71 = v70 - v50;
    v49[4] = v54;
    v72 = *(_DWORD *)(v71 + 72);
    blocks = v71;
    v183 = *(_DWORD *)(v71 + 100);
    if ( v72 )
    {
      v73 = *(_DWORD *)(v71 + 68);
      v74 = v71 + 68;
      v75 = *(_DWORD *)(v73 + 20);
      v76 = *(_DWORD *)(v73 + 16) - v75;
      v77 = v75 + v72;
      if ( v71 == v76 )
        *(_DWORD *)(v73 + 16) = v77;
      v47 = v71;
      *(_DWORD *)(v77 + 8) = *(_DWORD *)(v71 + 76);
      v78 = *(_DWORD *)(v71 + 76);
    }
    else
    {
      v171 = *(_DWORD *)(v71 + 76);
      v78 = v171;
      if ( !v171 )
      {
        v47 = 0;
        free(**(void ***)(v71 + 68));
        free(*(void **)(v71 + 68));
        blocks = 0;
LABEL_123:
        free((void *)v71);
        goto LABEL_124;
      }
      v172 = *(_DWORD *)(v71 + 68);
      v74 = v71 + 68;
      v173 = *(_DWORD *)(v172 + 20);
      if ( v71 == *(_DWORD *)(v172 + 16) - v173 )
      {
        *(_DWORD *)(v172 + 16) = v173;
        v78 = v171;
      }
      v47 = v171;
      blocks = v171;
    }
    v79 = *(int **)(v47 + 68);
    if ( v78 )
      *(_DWORD *)(v79[5] + v78 + 4) = v72;
    v80 = *v79;
    v81 = 12 * (*(_DWORD *)(v71 + 96) & (v79[1] - 1));
    v82 = *(_DWORD *)(*v79 + v81);
    --*(_DWORD *)(*v79 + v81 + 4);
    v83 = *(_DWORD *)(v71 + 84);
    if ( v82 == v74 )
      *(_DWORD *)(v80 + v81) = v83;
    v84 = *(_DWORD *)(v71 + 80);
    if ( v84 )
    {
      *(_DWORD *)(v84 + 16) = v83;
      v83 = *(_DWORD *)(v71 + 84);
    }
    if ( v83 )
      *(_DWORD *)(v83 + 12) = v84;
    --v79[3];
    goto LABEL_123;
  }
  v183 = 0;
LABEL_124:
  v85 = -17973521;
  v86 = strlen(v181);
  v87 = -1640531527;
  v66 = v86 > 11;
  v88 = v86;
  v89 = v86;
  v90 = -1640531527;
  if ( v66 )
  {
    v91 = (unsigned __int8 *)(v181 + 12);
    v174 = v88;
    v92 = -1640531527;
    do
    {
      v93 = *(v91 - 6);
      v174 -= 12;
      v94 = *(v91 - 2);
      v95 = *(v91 - 10);
      v175 = v91;
      v96 = *(v91 - 7);
      v91 += 12;
      v97 = v92 + (v93 << 16) + (v96 << 8) + *(v91 - 20) + (*(v91 - 17) << 24);
      v98 = *(v91 - 16) + (v94 << 16) + (*(v91 - 15) << 8) + (*(v91 - 13) << 24) + v85;
      v99 = (*(v91 - 24) + (v95 << 16) + (*(v91 - 23) << 8) + (*(v91 - 21) << 24) - v97 - v98 + v90) ^ (v98 >> 13);
      v100 = (v97 - v98 - v99) ^ (v99 << 8);
      v101 = (v98 - v99 - v100) ^ (v100 >> 13);
      v102 = (v99 - v100 - v101) ^ (v101 >> 12);
      v103 = (v100 - v101 - v102) ^ (v102 << 16);
      v104 = (v101 - v102 - v103) ^ (v103 >> 5);
      v90 = (v102 - v103 - v104) ^ (v104 >> 3);
      v92 = (v103 - v104 - v90) ^ (v90 << 10);
      v85 = (v104 - v90 - v92) ^ (v92 >> 15);
    }
    while ( v174 > 11 );
    v87 = v92;
  }
  else
  {
    v174 = v88;
    v175 = (unsigned __int8 *)v181;
  }
  v105 = v89 + v85;
  switch ( v174 )
  {
    case 1u:
      goto LABEL_140;
    case 2u:
      goto LABEL_139;
    case 3u:
      goto LABEL_138;
    case 4u:
      goto LABEL_137;
    case 5u:
      goto LABEL_136;
    case 6u:
      goto LABEL_135;
    case 7u:
      goto LABEL_134;
    case 8u:
      goto LABEL_133;
    case 9u:
      goto LABEL_132;
    case 10u:
      goto LABEL_131;
    case 11u:
      v105 += v175[10] << 24;
LABEL_131:
      v105 += v175[9] << 16;
LABEL_132:
      v105 += v175[8] << 8;
LABEL_133:
      v87 += v175[7] << 24;
LABEL_134:
      v87 += v175[6] << 16;
LABEL_135:
      v87 += v175[5] << 8;
LABEL_136:
      v87 += v175[4];
LABEL_137:
      v90 += v175[3] << 24;
LABEL_138:
      v90 += v175[2] << 16;
LABEL_139:
      v90 += v175[1] << 8;
LABEL_140:
      v90 += *v175;
      break;
    default:
      break;
  }
  v106 = (v90 - v87 - v105) ^ (v105 >> 13);
  *((_DWORD *)v181 + 22) = v181;
  v107 = (v87 - v105 - v106) ^ (v106 << 8);
  v108 = (v105 - v106 - v107) ^ (v107 >> 13);
  v109 = (v106 - v107 - v108) ^ (v108 >> 12);
  v110 = (v107 - v108 - v109) ^ (v109 << 16);
  v111 = (v108 - v109 - v110) ^ (v110 >> 5);
  v112 = v109 - v110 - v111;
  v113 = (v111 - (v112 ^ (v111 >> 3)) - ((v110 - v111 - (v112 ^ (v111 >> 3))) ^ ((v112 ^ (v111 >> 3)) << 10))) ^ (((v110 - v111 - (v112 ^ (v111 >> 3))) ^ ((v112 ^ (v111 >> 3)) << 10)) >> 15);
  *((_DWORD *)v181 + 24) = v113;
  *((_DWORD *)v181 + 23) = strlen(v181);
  if ( v47 )
  {
    *((_DWORD *)v181 + 17) = *(_DWORD *)(v47 + 68);
    v114 = v181 + 68;
    v115 = *(int **)(v47 + 68);
    *((_DWORD *)v181 + 19) = 0;
    v116 = v115[4];
    *((_DWORD *)v181 + 18) = v116 - v115[5];
    *(_DWORD *)(v116 + 8) = v181;
    v115[4] = (int)(v181 + 68);
  }
  else
  {
    *((_DWORD *)v181 + 19) = 0;
    *((_DWORD *)v181 + 18) = 0;
    blocks = (int)v181;
    v176 = malloc(44u);
    *((_DWORD *)v181 + 17) = v176;
    if ( !v176 )
      goto LABEL_256;
    memset(v176, 0, 44u);
    v114 = v181 + 68;
    v177 = (_DWORD *)*((_DWORD *)v181 + 17);
    v177[4] = v181 + 68;
    v177[1] = 32;
    v177[2] = 5;
    v177[5] = 68;
    v178 = malloc(384u);
    *v177 = v178;
    if ( !v178 )
      goto LABEL_256;
    memset(v178, 0, 384u);
    v115 = (int *)*((_DWORD *)v181 + 17);
    v115[10] = -1609490463;
  }
  v117 = *v115;
  v118 = 3 * (v113 & (v115[1] - 1));
  ++v115[3];
  v119 = *(_DWORD *)(v117 + 4 * v118);
  v120 = *(_DWORD *)(v117 + 4 * v118 + 4) + 1;
  *(_DWORD *)(v117 + 4 * v118 + 4) = v120;
  *((_DWORD *)v181 + 21) = v119;
  *((_DWORD *)v181 + 20) = 0;
  if ( v119 )
    *(_DWORD *)(v119 + 12) = v114;
  v121 = *(_DWORD *)(v117 + 4 * v118 + 8);
  *(_DWORD *)(v117 + 4 * v118) = v114;
  if ( v120 >= 10 * (v121 + 1) )
  {
    v122 = *((_DWORD *)v181 + 17);
    if ( *(_DWORD *)(v122 + 36) != 1 )
    {
      v123 = calloc(24 * *(_DWORD *)(v122 + 4), 1u);
      if ( v123 )
      {
        v124 = (void **)*((_DWORD *)v181 + 17);
        v125 = (char *)v124[1];
        v126 = (unsigned int)v124[3];
        v127 = (char *)v124[2];
        v124[7] = 0;
        v128 = v126 >> ((_BYTE)v127 + 1);
        v129 = 2 * (_DWORD)v125 - 1;
        if ( (v126 & v129) != 0 )
          ++v128;
        v124[6] = (void *)v128;
        if ( v125 )
        {
          v182 = 0;
          ptr = (char *)*v124;
          v185 = 12 * (_DWORD)v125;
          do
          {
            v130 = *(_DWORD **)&ptr[v182];
            if ( v130 )
            {
              do
              {
                v131 = (_DWORD *)v130[4];
                v132 = 3 * (v129 & v130[7]);
                v133 = (char *)&v123[3 * (v129 & v130[7])];
                v134 = *((_DWORD *)v133 + 1) + 1;
                *((_DWORD *)v133 + 1) = v134;
                if ( v128 < v134 )
                {
                  v124[7] = (char *)v124[7] + 1;
                  *((_DWORD *)v133 + 2) = v134 / v128;
                }
                v135 = v123[v132];
                v130[3] = 0;
                v130[4] = v135;
                if ( v135 )
                  *(_DWORD *)(v135 + 12) = v130;
                v123[v132] = v130;
                v130 = v131;
              }
              while ( v131 );
            }
            v182 += 12;
          }
          while ( v182 != v185 );
          free(ptr);
        }
        else
        {
          free(*v124);
        }
        v136 = (_DWORD *)*((_DWORD *)v181 + 17);
        v137 = v136[3];
        v138 = v136[7];
        v139 = v136[1];
        v140 = v136[2];
        *v136 = v123;
        v141 = v140 + 1;
        v142 = 2 * v139;
        v136[2] = v141;
        if ( v138 <= v137 >> 1 )
          v141 = 0;
        v136[1] = v142;
        if ( v138 > v137 >> 1 )
        {
          v143 = v136[8] + 1;
          v136[8] = v143;
          if ( v143 > 1 )
            v136[9] = 1;
        }
        else
        {
          v136[8] = v141;
        }
        goto LABEL_166;
      }
LABEL_256:
      exit(-1);
    }
  }
LABEL_166:
  v144 = 8 * (29 - *(unsigned __int8 *)(v180 + 72));
  if ( v144 <= 7 )
  {
    v146 = 16776960.0;
  }
  else
  {
    LODWORD(v145) = 65535 << v144;
    HIDWORD(v145) = (65535 << (v144 - 32)) | (65535u >> (32 - v144));
    v146 = (double)v145;
  }
  v147 = v146 / (double)(bswap32(*(_DWORD *)(v180 + 72)) & 0xFFFFFF);
  if ( v147 != current_diff )
  {
    suffix_string((unsigned __int64)v147, block_diff, 8u, 0);
    current_diff = v147;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)v190, 2048u, "Network diff set to %s", block_diff);
      applog(5, (const char *)v190, 0);
    }
  }
  if ( v183 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)v190, 2048u, "Deleted block %d from database", v183);
    applog(7, (const char *)v190, 0);
  }
  if ( pthread_rwlock_unlock(&blk_lock) )
  {
LABEL_210:
    v163 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v163,
      "cgminer.c",
      "block_exists",
      5532);
    goto LABEL_204;
  }
  ((void (*)(void))selective_yield)();
  if ( pthread_mutex_lock(&ch_lock) )
  {
    v170 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v170,
      "cgminer.c",
      "set_curblock",
      5439);
LABEL_204:
    applog(3, (const char *)v190, 1);
    _quit(1, 1);
  }
  if ( pthread_rwlock_wrlock(&stru_80CC34) )
  {
    v169 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v169,
      "cgminer.c",
      "set_curblock",
      5439);
    goto LABEL_204;
  }
  cgtime((struct timeval *)&block_timeval);
  strcpy(current_hash, s);
  cg_memcpy(&current_block, s2, 32u, (int)"cgminer.c", (int)"set_curblock", 5442);
  v190[0] = block_timeval;
  v148 = dword_80DD0C / 1000;
  v149 = localtime(v190);
  snprintf(blocktime, 32u, a02d02d02d03d, v149->tm_hour, v149->tm_min, v149->tm_sec, v148);
  if ( pthread_rwlock_unlock(&stru_80CC34) )
  {
    v168 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v168,
      "cgminer.c",
      "set_curblock",
      5444);
    goto LABEL_204;
  }
  if ( pthread_mutex_unlock(&ch_lock) )
  {
    v167 = _errno_location();
    snprintf(
      (char *)v190,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v167,
      "cgminer.c",
      "set_curblock",
      5444);
    goto LABEL_204;
  }
  ((void (*)(void))selective_yield)();
  v150 = 0;
  v151 = (char *)&total_tv_start_sys + 3;
  do
  {
    v152 = (unsigned __int8)*++v151;
    if ( v152 != 48 )
      break;
    ++v150;
  }
  while ( v150 != 57 );
  strncpy(prev_block, &current_hash[v150], 8u);
  prev_block[8] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)v190, 2048u, "New block: %s... diff %s", current_hash, block_diff);
    applog(6, (const char *)v190, 0);
  }
  if ( v183 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)v190, 2048u, "Deleted block %d from database", v183);
    applog(7, (const char *)v190, 0);
  }
  cg_memcpy(v179 + 136, s2, 32u, (int)"cgminer.c", (int)"test_work_current", 5589);
  if ( new_blocks == 1 )
  {
    v65 = 0;
    goto LABEL_88;
  }
  v153 = *(unsigned __int8 *)(v180 + 280);
  *(_DWORD *)(v180 + 336) = ++work_block;
  if ( !v153 )
  {
    if ( have_longpoll )
    {
      if ( !*((_BYTE *)v179 + 900) && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        strcpy((char *)v190, "New block detected on network before pool notification");
        applog(5, (const char *)v190, 0);
      }
    }
    else if ( !*((_BYTE *)v179 + 900) && (use_syslog || opt_log_output || opt_log_level > 4) )
    {
      strcpy((char *)v190, "New block detected on network");
      applog(5, (const char *)v190, 0);
    }
    goto LABEL_201;
  }
  if ( *(_BYTE *)(v180 + 284) )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
      goto LABEL_201;
    v154 = "Stratum from pool %d detected new block at height %d";
    v155 = v186;
    v156 = (char *)*v179;
  }
  else
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
      goto LABEL_201;
    v156 = "";
    v155 = **(_DWORD **)(v180 + 260);
    LOWORD(v154) = (unsigned __int16)"%sLONGPOLL from pool %d detected new block";
    if ( *(_BYTE *)(v180 + 324) )
      v156 = "GBT ";
    HIWORD(v154) = (unsigned int)"%sLONGPOLL from pool %d detected new block" >> 16;
  }
  snprintf((char *)v190, 2048u, v154, v156, v155);
  applog(5, (const char *)v190, 0);
LABEL_201:
  restart_threads();
  v65 = 1;
LABEL_88:
  result = v65;
  *(_BYTE *)(v180 + 280) = 0;
  return result;
}
// 7DEF0: using guessed type double current_diff;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80F6C: using guessed type int pool_strategy;
// 81120: using guessed type int work_block;
// 82650: using guessed type int blocks;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA40: using guessed type int total_tv_start_sys;
// 80CC18: using guessed type char use_syslog;
// 80CC1A: using guessed type char have_longpoll;
// 80CC1C: using guessed type pthread_mutex_t ch_lock;
// 80DD08: using guessed type int block_timeval;
// 80DD0C: using guessed type int dword_80DD0C;
// 80EDF0: using guessed type int new_blocks;
// 26410: using guessed type time_t var_830[524];

//----- (00027598) --------------------------------------------------------
int __fastcall stratum_rthread(_DWORD *a1)
{
  int v2; // r9
  pthread_t v3; // r0
  int v4; // r10
  int v5; // r7
  int v6; // r0
  fd_set *v7; // r3
  int v8; // r3
  int v9; // r2
  bool v10; // nf
  int v11; // r2
  int v12; // r0
  int v13; // r0
  char *v14; // r6
  int v16; // r2
  int v17; // r4
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  int v20; // r4
  int v21; // r3
  int v22; // r4
  void **work; // r0
  void **v24; // r0
  char *v25; // r5
  const char *v26; // r5
  int v27; // r3
  int v28; // r4
  const char *v29; // r5
  int v30; // r3
  int v31; // r4
  int *v32; // r0
  int *v33; // r0
  char *v34; // r0
  void **v35; // r5
  unsigned int v36; // r3
  unsigned int v37; // r2
  unsigned int v38; // r1
  int v39; // r3
  unsigned int v40; // r2
  unsigned int v41; // r1
  int v42; // r3
  unsigned int v43; // r2
  int v44; // r2
  int v45; // r3
  int v46; // r10
  int v47; // r9
  int v48; // r7
  int v49; // r11
  int i; // r4
  int v51; // r4
  double v52; // d8
  __int64 *v53; // r1
  double v54; // d6
  double v55; // d7
  int v56; // r2
  __int64 v57; // r4
  double v58; // d6
  double v59; // d7
  int v60; // r3
  int v61; // r4
  void **v62; // r1
  int v63; // r3
  void **v64; // r2
  int v65; // r2
  _DWORD *v66; // r1
  int v67; // r0
  int v68; // r3
  void ****v69; // r4
  void ***v70; // r5
  void ***v71; // r2
  void **v72; // r3
  time_t v73; // r0
  int v74; // r3
  int v75; // lr
  char *v76; // r1
  int v77; // r3
  double v79; // d0
  unsigned int v80; // r4
  const char *v81; // r1
  unsigned int v82; // r4
  double v83; // d4
  double v84; // d7
  double v85; // d5
  double v86; // d6
  __int64 v87; // r2
  __int64 v88; // kr08_8
  const char *v89; // r5
  size_t v90; // r0
  size_t v91; // r4
  char *v92; // lr
  int v93; // r3
  int v94; // r3
  int v95; // r3
  _DWORD *v96; // r0
  const char *v97; // r0
  double v98; // d7
  double v99; // d4
  double v100; // d6
  double v101; // d5
  __int64 v102; // r2
  int v103; // r3
  time_t v104; // r0
  __int64 v105; // r2
  int v106; // r1
  _DWORD *v107; // [sp+1Ch] [bp-A9Ch]
  unsigned int v108; // [sp+20h] [bp-A98h]
  double *v109; // [sp+20h] [bp-A98h]
  int v110; // [sp+28h] [bp-A90h]
  int v111; // [sp+28h] [bp-A90h]
  int v112; // [sp+30h] [bp-A88h]
  void ***v113; // [sp+30h] [bp-A88h]
  _DWORD *v114; // [sp+34h] [bp-A84h]
  int v115; // [sp+34h] [bp-A84h]
  _DWORD *ptr; // [sp+38h] [bp-A80h]
  double *ptra; // [sp+38h] [bp-A80h]
  time_t *timer; // [sp+3Ch] [bp-A7Ch]
  __int64 v119; // [sp+40h] [bp-A78h]
  int s2; // [sp+50h] [bp-A68h] BYREF
  struct timeval timeout; // [sp+54h] [bp-A64h] BYREF
  char s[16]; // [sp+5Ch] [bp-A5Ch] BYREF
  char v123[20]; // [sp+6Ch] [bp-A4Ch] BYREF
  char v124[2]; // [sp+80h] [bp-A38h] BYREF
  char v125[30]; // [sp+82h] [bp-A36h] BYREF
  char v126[36]; // [sp+A0h] [bp-A18h] BYREF
  char v127[60]; // [sp+C4h] [bp-9F4h] BYREF
  char v128; // [sp+100h] [bp-9B8h] BYREF
  fd_set v129; // [sp+104h] [bp-9B4h] BYREF
  int v130[23]; // [sp+184h] [bp-934h] BYREF
  char v131[159]; // [sp+1E0h] [bp-8D8h] BYREF
  char v132; // [sp+27Fh] [bp-839h] BYREF
  void **v133[526]; // [sp+280h] [bp-838h] BYREF

  v2 = -1622558010;
  v3 = pthread_self();
  pthread_detach(v3);
  v4 = -17973517;
  v5 = 17973517;
  snprintf(s, 16u, "%d/RStratum", *a1);
  RenameThread(s);
  do
  {
LABEL_2:
    v6 = (int)a1;
    if ( *((_BYTE *)a1 + 105) )
    {
LABEL_17:
      suspend_stratum(v6);
      return 0;
    }
    while ( 1 )
    {
      if ( !sock_full(v6) && !cnx_needed((int)a1) )
      {
        suspend_stratum((int)a1);
        clear_stratum_shares((int)a1);
        clear_pool_work(a1);
        if ( cnx_needed((int)a1) )
          goto LABEL_63;
        while ( !a1[25] || a1 != (_DWORD *)current_pool() && (unsigned int)(pool_strategy - 3) > 1 )
        {
          if ( pthread_mutex_lock(&lp_lock) )
          {
            v26 = "wait_lpcurrent";
            v27 = *_errno_location();
            v28 = 9801;
            goto LABEL_79;
          }
          pthread_cond_wait(&lp_cond, &lp_lock);
          if ( pthread_mutex_unlock(&lp_lock) )
          {
            v29 = "wait_lpcurrent";
            v30 = *_errno_location();
            v31 = 9803;
            goto LABEL_82;
          }
          ((void (__fastcall *)())selective_yield)();
          if ( cnx_needed((int)a1) )
            break;
        }
LABEL_63:
        while ( !restart_stratum((int)a1) )
        {
          pool_died((int)a1);
          if ( *((_BYTE *)a1 + 105) )
            return 0;
          cgsleep_ms();
        }
      }
      v7 = (fd_set *)&v128;
      do
      {
        v7->__fds_bits[1] = 0;
        v7 = (fd_set *)((char *)v7 + 4);
      }
      while ( &v129.__fds_bits[31] != (__fd_mask *)v7 );
      v8 = a1[147];
      timeout.tv_usec = 0;
      timeout.tv_sec = 90;
      v9 = (v8 + 31) & (v8 >> 31);
      if ( v8 >= 0 )
        v9 = v8;
      v10 = -v8 < 0;
      v11 = v9 >> 5;
      v12 = -v8 & 0x1F;
      LOBYTE(v8) = v8 & 0x1F;
      if ( !v10 )
        v8 = -v12;
      v129.__fds_bits[v11] |= 1 << v8;
      if ( !sock_full((int)a1) )
      {
        v13 = select(a1[147] + 1, &v129, 0, 0, &timeout);
        if ( v13 <= 0 )
          break;
      }
      v14 = recv_line((int)a1);
      if ( !v14 )
        goto LABEL_33;
      stratum_resumed((int)a1);
      if ( parse_method(a1, (int)v14) )
        goto LABEL_14;
      v18 = (_DWORD *)json_loads((int)v14, 0, (int)v130);
      v107 = v18;
      if ( v18 )
      {
        v114 = (_DWORD *)json_object_get(v18, "result");
        timer = (time_t *)json_object_get(v107, "error");
        v19 = (_DWORD *)json_object_get(v107, "id");
        v20 = (int)v19;
        if ( !v19 || *v19 == 7 )
        {
          if ( timer )
          {
            v25 = (char *)json_dumps(timer, 3);
          }
          else
          {
            v34 = (char *)malloc(17u);
            v25 = v34;
            if ( v34 )
              strcpy(v34, "(unknown reason)");
          }
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)v133, 2048u, "JSON-RPC non method decode failed: %s", v25);
            applog(6, (const char *)v133, 0);
          }
          free(v25);
        }
        else if ( !json_object_get(v114, "version-rolling.mask")
               && !strstr(v14, "mining.configure")
               && !strstr(v14, "mining.set_version_mask") )
        {
          s2 = json_integer_value(v20);
          if ( pthread_mutex_lock(&sshare_lock) )
            mutex_lock_part_47_constprop_75("parse_stratum_response", 7205);
          v35 = (void **)stratum_shares;
          v36 = (unsigned int)&unk_7F76D ^ ((unsigned __int8)s2
                                          + v5
                                          + (HIBYTE(s2) << 24)
                                          + (BYTE2(s2) << 16)
                                          + (BYTE1(s2) << 8));
          v37 = (v2 - v36) ^ (v36 << 8);
          v38 = (v4 - v36 - v37) ^ (v37 >> 13);
          v39 = (v36 - v37 - v38) ^ (v38 >> 12);
          v40 = (v37 - v38 - v39) ^ (v39 << 16);
          v41 = (v38 - v39 - v40) ^ (v40 >> 5);
          v42 = (v39 - v40 - v41) ^ (v41 >> 3);
          v43 = (v41 - v42 - ((v40 - v41 - v42) ^ (v42 << 10))) ^ (((v40 - v41 - v42) ^ (v42 << 10)) >> 15);
          v108 = v43;
          if ( stratum_shares )
          {
            ptr = **(_DWORD ***)stratum_shares;
            v44 = ptr[3 * ((*(_DWORD *)(*(_DWORD *)stratum_shares + 4) - 1) & v43)];
            if ( v44 )
            {
              v45 = *(_DWORD *)(*(_DWORD *)stratum_shares + 20);
              v110 = v4;
              v46 = v2;
              v47 = v5;
              v48 = *(_DWORD *)stratum_shares;
              v49 = -v45;
              v112 = v45;
              for ( i = v44 - v45; ; i = v51 + v49 )
              {
                if ( !i )
                {
LABEL_101:
                  v5 = v47;
                  v2 = v46;
                  v4 = v110;
                  goto LABEL_102;
                }
                if ( v108 == *(_DWORD *)(i + 28)
                  && *(_DWORD *)(i + 24) == 4
                  && !memcmp(*(const void **)(i + 20), &s2, 4u) )
                {
                  break;
                }
                v51 = *(_DWORD *)(i + 16);
                if ( !v51 )
                  goto LABEL_101;
              }
              v60 = v112;
              v113 = (void ***)i;
              v61 = v48;
              v5 = v47;
              v2 = v46;
              v4 = v110;
              v62 = v113[1];
              if ( v62 )
              {
                v63 = (int)v62 + v60;
                v64 = v113[2];
                if ( v113 == (void ***)(*(_DWORD *)(v61 + 16) + v49) )
                  *(_DWORD *)(v61 + 16) = v63;
                *(_DWORD *)(v63 + 8) = v64;
                v65 = (int)v113[2];
                if ( v65 )
                  goto LABEL_126;
                goto LABEL_127;
              }
              v65 = (int)v113[2];
              if ( v65 )
              {
                if ( v113 == (void ***)(v49 + *(_DWORD *)(v61 + 16)) )
                  *(_DWORD *)(v61 + 16) = v60;
                v35 = (void **)v65;
                stratum_shares = v65;
LABEL_126:
                *(_DWORD *)(v65 + *((_DWORD *)*v35 + 5) + 4) = v62;
LABEL_127:
                v66 = *v35;
                v67 = *(_DWORD *)*v35;
                v68 = 3 * ((*((_DWORD *)*v35 + 1) - 1) & v108);
                v69 = (void ****)(v67 + 12 * ((*((_DWORD *)*v35 + 1) - 1) & v108));
                v70 = *v69;
                v69[1] = (void ***)((char *)v69[1] - 1);
                if ( v70 == v113 )
                  v71 = v113;
                else
                  v71 = (void ***)v113[4];
                if ( v70 == v113 )
                {
                  v71 = (void ***)v71[4];
                  *(_DWORD *)(v67 + 4 * v68) = v71;
                }
                v72 = v113[3];
                if ( v72 )
                {
                  v72[4] = v71;
                  v71 = (void ***)v113[4];
                }
                if ( v71 )
                  v71[3] = v72;
                --v66[3];
              }
              else
              {
                free(ptr);
                free(*v35);
                stratum_shares = 0;
              }
              --a1[183];
              mutex_unlock_constprop_76(&sshare_lock, "parse_stratum_response", 7213);
              v111 = (int)v113[9];
              v73 = time(0);
              v74 = (unsigned __int8)opt_debug;
              v75 = v73 - (_DWORD)v113[12];
              if ( v75 > 0 )
                v74 = (unsigned __int8)opt_debug | 1;
              if ( v74 && (use_syslog || opt_log_output || opt_log_level > 5) )
              {
                snprintf(
                  (char *)v133,
                  2048u,
                  "Pool %d stratum share result lag time %d seconds",
                  **(_DWORD **)(v111 + 260),
                  v75);
                applog(6, (const char *)v133, 0);
              }
              v76 = &v132;
              v77 = 0;
              v133[0] = (void **)bswap32(*(_DWORD *)(v111 + 220));
              v133[1] = (void **)bswap32(*(_DWORD *)(v111 + 216));
              v133[2] = (void **)bswap32(*(_DWORD *)(v111 + 212));
              v133[3] = (void **)bswap32(*(_DWORD *)(v111 + 208));
              v133[4] = (void **)bswap32(*(_DWORD *)(v111 + 204));
              v133[5] = (void **)bswap32(*(_DWORD *)(v111 + 200));
              v133[6] = (void **)bswap32(*(_DWORD *)(v111 + 196));
              v133[7] = (void **)bswap32(*(_DWORD *)(v111 + 192));
              do
              {
                if ( *++v76 )
                  break;
                ++v77;
              }
              while ( v77 != 29 );
              v79 = *(double *)(v111 + 376);
              v80 = *(unsigned int *)((char *)v133 + v77);
              round();
              suffix_string(*(_QWORD *)(v111 + 232), v126, 16u, 0);
              v81 = " BLOCK!";
              v82 = bswap32(v80);
              if ( !*(_BYTE *)(v111 + 283) )
                v81 = "";
              snprintf(v127, 64u, "%08lx Diff %s/%llu%s", v82, v126, (unsigned __int64)v79, v81);
              v109 = *(double **)(v111 + 260);
              ptra = *(double **)(get_thread(*(_DWORD *)(v111 + 256)) + 36);
              if ( v114 && (*v114 == 5 || *(_BYTE *)(v111 + 324) && *v114 == 7) )
              {
                if ( pthread_mutex_lock(&stats_lock) )
                  mutex_lock_part_47_constprop_75("share_result", 3467);
                v98 = *(double *)(v111 + 376);
                v99 = ptra[25];
                v100 = total_diff_accepted;
                v101 = v109[9];
                v102 = *((_QWORD *)v109 + 1);
                ++*((_DWORD *)ptra + 9);
                *((_QWORD *)v109 + 1) = v102 + 1;
                total_diff_accepted = v100 + v98;
                ++*(_QWORD *)&total_accepted;
                ptra[25] = v99 + v98;
                v109[9] = v101 + v98;
                mutex_unlock_constprop_76(&stats_lock, "share_result", 3477);
                v103 = *(_DWORD *)v109;
                *((_DWORD *)v109 + 6) = 0;
                *((_DWORD *)ptra + 54) = v103;
                v104 = time(0);
                v105 = *(_QWORD *)(v111 + 376);
                v106 = (unsigned __int8)opt_debug;
                *((_DWORD *)ptra + 55) = v104;
                *((_QWORD *)ptra + 28) = v105;
                *((_DWORD *)v109 + 88) = v104;
                *((_QWORD *)v109 + 45) = v105;
                if ( v106 && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  strcpy((char *)v133, "PROOF OF WORK RESULT: true (yay!!!)");
                  applog(7, (const char *)v133, 0);
                }
                if ( !opt_quiet && !opt_realquiet )
                {
                  if ( total_pools <= 1 )
                  {
                    if ( use_syslog || opt_log_output || opt_log_level > 4 )
                    {
                      snprintf(
                        (char *)v133,
                        2048u,
                        "Accepted %s %s %d %s%s",
                        v127,
                        *(const char **)(*((_DWORD *)ptra + 1) + 8),
                        *((_DWORD *)ptra + 2),
                        "",
                        "");
                      applog(5, (const char *)v133, 0);
                    }
                  }
                  else if ( use_syslog || opt_log_output || opt_log_level > 4 )
                  {
                    snprintf(
                      (char *)v133,
                      2048u,
                      "Accepted %s %s %d pool %d %s%s",
                      v127,
                      *(const char **)(*((_DWORD *)ptra + 1) + 8),
                      *((_DWORD *)ptra + 2),
                      **(_DWORD **)(v111 + 260),
                      "",
                      "");
                    applog(5, (const char *)v133, 0);
                  }
                }
                sharelog("accept", v111);
                if ( opt_shares && (double)opt_shares <= total_diff_accepted )
                {
                  if ( use_syslog || opt_log_output || opt_log_level > 3 )
                  {
                    snprintf(
                      (char *)v133,
                      2048u,
                      "Successfully mined %d accepted shares as requested and exiting.",
                      opt_shares);
                    applog(4, (const char *)v133, 0);
                  }
                  kill_work();
                }
                if ( *((_DWORD *)v109 + 25) == 2 )
                {
                  if ( !use_syslog && !opt_log_output && opt_log_level <= 3
                    || (snprintf(
                          (char *)v133,
                          2048u,
                          "Rejecting pool %d now accepting shares, re-enabling!",
                          *(_DWORD *)v109),
                        applog(4, (const char *)v133, 0),
                        *((_DWORD *)v109 + 25) != 1) )
                  {
                    *((_DWORD *)v109 + 25) = 1;
                    ++enabled_pools;
                  }
                  switch_pools(0);
                }
                if ( *(_BYTE *)(v111 + 283) )
                  restart_threads();
              }
              else
              {
                if ( pthread_mutex_lock(&stats_lock) )
                  mutex_lock_part_47_constprop_75("share_result", 3530);
                v83 = ptra[26];
                v84 = *(double *)(v111 + 376);
                v85 = v109[10];
                v86 = total_diff_rejected;
                v87 = *((_QWORD *)v109 + 2);
                ++*((_DWORD *)ptra + 10);
                v119 = v87 + 1;
                LODWORD(v87) = *((_DWORD *)v109 + 6) + 1;
                total_diff_rejected = v86 + v84;
                *((_QWORD *)v109 + 2) = v119;
                ptra[26] = v83 + v84;
                v88 = total_rejected;
                *((_DWORD *)v109 + 6) = v87;
                v109[10] = v85 + v84;
                total_rejected = v88 + 1;
                mutex_unlock_constprop_76(&stats_lock, "share_result", 3538);
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  strcpy((char *)v133, "PROOF OF WORK RESULT: false (booooo)");
                  applog(7, (const char *)v133, 0);
                }
                if ( !opt_quiet && !opt_realquiet )
                {
                  strcpy(v126, "reject");
                  memset(&v126[7], (unsigned __int8)opt_realquiet, 29u);
                  v124[0] = opt_realquiet;
                  if ( total_pools <= 1 )
                    v123[0] = opt_realquiet;
                  else
                    snprintf(v123, 20u, "pool %d", **(_DWORD **)(v111 + 260));
                  if ( !*(_BYTE *)(v111 + 324) )
                    v114 = (_DWORD *)json_object_get(v107, "reject-reason");
                  if ( v114 )
                  {
                    v89 = (const char *)json_string_value(v114);
                    v90 = strlen(v89);
                    if ( v90 >= 28 )
                      v90 = 28;
                    v91 = v90;
                    qmemcpy(v124, " (", sizeof(v124));
                    cg_memcpy(v125, v89, v90, (int)"cgminer.c", (int)"share_result", 3578);
                    v92 = &v124[v91];
                    v92[2] = 41;
                    v92[3] = 0;
                    cg_memcpy(&v126[7], v89, v91, (int)"cgminer.c", (int)"share_result", 3583);
                    v126[6] = 58;
                    v126[v91 + 7] = 0;
                  }
                  else
                  {
                    if ( timer )
                      v95 = *(_BYTE *)(v111 + 284) & 1;
                    else
                      v95 = 0;
                    if ( v95 )
                    {
                      if ( *timer == 1 )
                      {
                        v96 = json_array_get(timer, 1u);
                        if ( !v96 || *v96 != 2 )
                          goto LABEL_169;
                      }
                      else
                      {
                        if ( *timer != 2 )
                          goto LABEL_169;
                        v96 = timer;
                      }
                      v97 = (const char *)json_string_value(v96);
                      snprintf(v124, 31u, " (%s)", v97);
                    }
                  }
LABEL_169:
                  if ( use_syslog || opt_log_output || opt_log_level > 4 )
                  {
                    snprintf(
                      (char *)v133,
                      2048u,
                      "Rejected %s %s %d %s%s %s%s",
                      v127,
                      *(const char **)(*((_DWORD *)ptra + 1) + 8),
                      *((_DWORD *)ptra + 2),
                      v123,
                      v124,
                      "",
                      "");
                    applog(5, (const char *)v133, 0);
                  }
                  sharelog(v126, v111);
                }
                v115 = *((_DWORD *)v109 + 6);
                if ( v115 > 10
                  && !*(_BYTE *)(v111 + 281)
                  && opt_disable_pool
                  && enabled_pools > 1
                  && (double)v115 > (double)*(__int64 *)&total_accepted / total_secs * 60.0 * 3.0 )
                {
                  if ( use_syslog || opt_log_output || opt_log_level > 3 )
                  {
                    snprintf(
                      (char *)v133,
                      2048u,
                      "Pool %d rejected %d sequential shares, disabling!",
                      *(_DWORD *)v109,
                      v115);
                    applog(4, (const char *)v133, 0);
                  }
                  if ( *((_DWORD *)v109 + 25) == 1 )
                    --enabled_pools;
                  *((_DWORD *)v109 + 25) = 2;
                  if ( v109 == (double *)current_pool() )
                    switch_pools(0);
                  *((_DWORD *)v109 + 6) = 0;
                }
              }
              free_work(v113 + 9, "cgminer.c", "parse_stratum_response", 7258);
              free(v113);
              v93 = v107[1];
              if ( v93 == -1 )
                goto LABEL_14;
              v94 = v93 - 1;
              v107[1] = v94;
              if ( v94 )
                goto LABEL_14;
              v22 = 1;
LABEL_55:
              json_delete(v107);
              if ( v22 )
                goto LABEL_14;
LABEL_56:
              if ( !parse_version_rolling_mask((int)a1, (int)v14) )
                goto LABEL_57;
              goto LABEL_14;
            }
          }
LABEL_102:
          mutex_unlock_constprop_76(&sshare_lock, "parse_stratum_response", 7213);
          if ( v114 )
          {
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
              mutex_lock_part_47_constprop_75("parse_stratum_response", 7225);
            if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
              rd_lock_part_39_constprop_80("parse_stratum_response", 7225);
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
              mutex_unlock_noyield_part_48_constprop_77("parse_stratum_response", 7225);
            v52 = *((double *)a1 + 228);
            wr_unlock_constprop_78((pthread_rwlock_t *)(a1 + 59), "parse_stratum_response", 7227);
            if ( *v114 == 5 )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)v133, 2048u, "Accepted untracked stratum share from pool %d", *a1);
                applog(5, (const char *)v133, 0);
              }
              if ( pthread_mutex_lock(&stats_lock) )
                mutex_lock_part_47_constprop_75("parse_stratum_response", 7235);
              v53 = (__int64 *)&total_accepted;
              v58 = *((double *)a1 + 9) + v52;
              v59 = total_diff_accepted + v52;
              v56 = 7240;
              ++*((_QWORD *)a1 + 1);
              *((double *)a1 + 9) = v58;
              v57 = *(_QWORD *)&total_accepted;
              total_diff_accepted = v59;
            }
            else
            {
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)v133, 2048u, "Rejected untracked stratum share from pool %d", *a1);
                applog(5, (const char *)v133, 0);
              }
              if ( pthread_mutex_lock(&stats_lock) )
                mutex_lock_part_47_constprop_75("parse_stratum_response", 7246);
              v53 = &total_rejected;
              v54 = *((double *)a1 + 10) + v52;
              v55 = total_diff_rejected + v52;
              v56 = 7251;
              ++*((_QWORD *)a1 + 2);
              v57 = total_rejected;
              *((double *)a1 + 10) = v54;
              total_diff_rejected = v55;
            }
            *v53 = v57 + 1;
            mutex_unlock_constprop_76(&stats_lock, "parse_stratum_response", v56);
          }
        }
        v21 = v107[1];
        if ( v21 != -1 )
        {
          v22 = v21 - 1;
          v107[1] = v21 - 1;
          if ( v21 == 1 )
            goto LABEL_55;
        }
        goto LABEL_56;
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 5 )
        goto LABEL_56;
      snprintf((char *)v133, 2048u, "JSON decode failed(%d): %s", v130[0], v131);
      applog(6, (const char *)v133, 0);
      if ( !parse_version_rolling_mask((int)a1, (int)v14) )
      {
LABEL_57:
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)v133, 2048u, "Unknown stratum msg: %s", v14);
          applog(6, (const char *)v133, 0);
        }
        goto LABEL_16;
      }
LABEL_14:
      if ( *((_BYTE *)a1 + 680) )
      {
        work = (void **)make_work();
        *((_BYTE *)a1 + 680) = 0;
        v133[0] = work;
        gen_stratum_work((int)a1, (int)work);
        v24 = v133[0];
        *((_BYTE *)v133[0] + 280) = 1;
        test_work_current((int)v24);
        free_work(v133, "cgminer.c", "stratum_rthread", 7510);
      }
LABEL_16:
      free(v14);
      v6 = (int)a1;
      if ( *((_BYTE *)a1 + 105) )
        goto LABEL_17;
    }
    if ( !opt_debug )
    {
LABEL_33:
      if ( !use_syslog && !opt_log_output )
        goto LABEL_60;
LABEL_35:
      snprintf((char *)v133, 2048u, "Stratum connection to pool %d interrupted", *a1);
      applog(5, (const char *)v133, 0);
      goto LABEL_36;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      snprintf((char *)v133, 2048u, "Stratum select failed on pool %d with value %d", *a1, v13);
      applog(7, (const char *)v133, 0);
      goto LABEL_33;
    }
LABEL_60:
    if ( opt_log_level > 4 )
      goto LABEL_35;
LABEL_36:
    v16 = total_go;
    ++a1[32];
    total_go = v16 + 1;
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
    {
      v26 = "supports_resume";
      v27 = *_errno_location();
      v28 = 7396;
LABEL_79:
      snprintf((char *)v133, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v27, "cgminer.c", v26, v28);
LABEL_80:
      applog(3, (const char *)v133, 1);
      _quit(1, 1);
    }
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v32 = _errno_location();
      snprintf(
        (char *)v133,
        2048u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v32,
        "cgminer.c",
        "supports_resume",
        7396);
      goto LABEL_80;
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
    {
      v29 = "supports_resume";
      v30 = *_errno_location();
      v31 = 7396;
LABEL_82:
      snprintf((char *)v133, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v30, "cgminer.c", v29, v31);
      goto LABEL_80;
    }
    v17 = a1[159];
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v33 = _errno_location();
      snprintf(
        (char *)v133,
        2048u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v33,
        "cgminer.c",
        "supports_resume",
        7398);
      goto LABEL_80;
    }
    selective_yield(0);
    if ( !v17 || opt_lowmem )
      clear_stratum_shares((int)a1);
    clear_pool_work(a1);
    if ( a1 == (_DWORD *)current_pool() )
      restart_threads();
  }
  while ( restart_stratum((int)a1) );
  while ( 1 )
  {
    pool_died((int)a1);
    if ( *((_BYTE *)a1 + 105) )
      return 0;
    cgsleep_ms();
    if ( restart_stratum((int)a1) )
      goto LABEL_2;
  }
}
// 123A4: using guessed type int round(void);
// 7DEC8: using guessed type double total_secs;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80F6C: using guessed type int pool_strategy;
// 80FEC: using guessed type int opt_shares;
// 810EC: using guessed type int stratum_shares;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA90: using guessed type double total_diff_accepted;
// 80BA98: using guessed type char opt_quiet;
// 80BAB0: using guessed type double total_diff_rejected;
// 80BAEC: using guessed type int total_pools;
// 80CC18: using guessed type char use_syslog;
// 80CC90: using guessed type int enabled_pools;
// 80DCB4: using guessed type char opt_realquiet;
// 80DCE8: using guessed type int total_go;
// 80DCF0: using guessed type int total_accepted;
// 80DD9C: using guessed type char opt_lowmem;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;
// 80EDF4: using guessed type char opt_disable_pool;
// 80EEF8: using guessed type __int64 total_rejected;
// 27598: using guessed type int var_934[23];
// 27598: using guessed type char var_8D8[159];
// 27598: using guessed type char var_A36[30];

//----- (00028848) --------------------------------------------------------
int __fastcall stage_work(int a1)
{
  int v1; // r8
  pthread_mutex_t *v2; // r0
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r0
  unsigned int v7; // r4
  int v8; // r0
  unsigned int v9; // r3
  unsigned int v10; // r2
  int v11; // r4
  unsigned int v12; // r3
  unsigned int v13; // r2
  int v14; // r5
  unsigned int v15; // r4
  int v16; // r3
  int v17; // r5
  char **v18; // r1
  char *v19; // r7
  int v20; // r3
  char *v21; // r6
  int *v22; // r1
  int v23; // r3
  unsigned int v24; // r2
  int v25; // r3
  int v26; // r2
  _DWORD *v27; // r7
  char **v28; // r2
  char *v29; // r3
  unsigned int v30; // r4
  char *v31; // r1
  unsigned int v32; // r9
  int v33; // r11
  _DWORD *v34; // r5
  _DWORD *v35; // r8
  int v36; // r4
  char *v37; // r6
  unsigned int v38; // r0
  int v39; // r3
  _DWORD *v40; // r3
  unsigned int v41; // r0
  unsigned int v42; // r1
  int v43; // r4
  int v44; // r2
  unsigned int v45; // r2
  int v46; // r6
  int v47; // r12
  int v48; // r3
  int v49; // r1
  unsigned int v50; // lr
  int v51; // r0
  int v52; // r4
  int v53; // r2
  int i; // r0
  int v55; // r4
  int v56; // r5
  bool v57; // zf
  int v58; // r0
  int v59; // r8
  int v60; // r0
  bool v61; // zf
  int v62; // r0
  int v63; // r11
  int v64; // r0
  int *v66; // r0
  int *v67; // r0
  char **v68; // r0
  char **v69; // r7
  char *v70; // r0
  char **v71; // [sp+10h] [bp-840h]
  int v72; // [sp+10h] [bp-840h]
  int v73; // [sp+10h] [bp-840h]
  char *ptr; // [sp+14h] [bp-83Ch]
  int v75; // [sp+1Ch] [bp-834h]
  int v76; // [sp+20h] [bp-830h]
  char s[2088]; // [sp+28h] [bp-828h] BYREF

  v1 = a1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "Pushing work from pool %d to hash queue", **(_DWORD **)(a1 + 260));
    applog(7, s, 0);
  }
  *(_DWORD *)(v1 + 336) = work_block;
  test_work_current(v1);
  v2 = (pthread_mutex_t *)stgd_lock;
  ++*(_DWORD *)(*(_DWORD *)(v1 + 260) + 68);
  if ( pthread_mutex_lock(v2) )
  {
    v67 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v67, "cgminer.c", "hash_push", 5695);
LABEL_92:
    applog(3, s, 1);
    _quit(1, 1);
  }
  if ( !*(_BYTE *)(v1 + 273) && *(_DWORD *)(v1 + 276) )
    ++staged_rollable;
  v3 = getq;
  v4 = *(unsigned __int8 *)(getq + 8);
  if ( *(_BYTE *)(getq + 8) )
    goto LABEL_83;
  v5 = *(unsigned __int8 *)(v1 + 341);
  v6 = *(unsigned __int8 *)(v1 + 340)
     + 17973517
     + (*(unsigned __int8 *)(v1 + 343) << 24)
     + (*(unsigned __int8 *)(v1 + 342) << 16);
  *(_DWORD *)(v1 + 364) = v1 + 340;
  *(_DWORD *)(v1 + 368) = 4;
  v7 = (unsigned int)&unk_7F76D ^ (v6 + (v5 << 8));
  v8 = staged_work;
  v9 = (-1622558010 - v7) ^ (v7 << 8);
  v10 = (-17973517 - v7 - v9) ^ (v9 >> 13);
  v11 = (v7 - v9 - v10) ^ (v10 >> 12);
  v12 = (v9 - v10 - v11) ^ (v11 << 16);
  v13 = (v10 - v11 - v12) ^ (v12 >> 5);
  v14 = (v11 - v12 - v13) ^ (v13 >> 3);
  v15 = (v13 - v14 - ((v12 - v13 - v14) ^ (v14 << 10))) ^ (((v12 - v13 - v14) ^ (v14 << 10)) >> 15);
  *(_DWORD *)(v1 + 372) = v15;
  if ( v8 )
  {
    v16 = *(_DWORD *)(v8 + 344);
    v17 = v1 + 344;
    *(_DWORD *)(v1 + 352) = v4;
    *(_DWORD *)(v1 + 344) = v16;
    v18 = *(char ***)(v8 + 344);
    v19 = v18[4];
    v20 = (int)(v18[1] - 1);
    v21 = *v18;
    *(_DWORD *)(v1 + 348) = v19 - v18[5];
    *((_DWORD *)v19 + 2) = v1;
    v18[4] = (char *)(v1 + 344);
  }
  else
  {
    *(_DWORD *)(v1 + 352) = 0;
    *(_DWORD *)(v1 + 348) = 0;
    staged_work = v1;
    v68 = (char **)calloc(44u, 1u);
    v69 = v68;
    *(_DWORD *)(v1 + 344) = v68;
    if ( !v68 )
      goto LABEL_94;
    v17 = v1 + 344;
    v68[1] = (char *)32;
    v68[4] = (char *)(v1 + 344);
    v68[2] = (char *)5;
    v68[5] = (char *)344;
    v70 = (char *)calloc(384u, 1u);
    *v69 = v70;
    if ( !v70 )
      goto LABEL_94;
    v21 = v70;
    v18 = v69;
    v69[10] = (char *)-1609490463;
    v8 = v1;
    v20 = 31;
  }
  ++v18[3];
  v22 = (int *)&v21[12 * (v20 & v15)];
  v23 = *v22;
  v24 = v22[1] + 1;
  v22[1] = v24;
  *(_DWORD *)(v1 + 360) = v23;
  *(_DWORD *)(v1 + 356) = 0;
  if ( v23 )
    *(_DWORD *)(v23 + 12) = v17;
  v25 = v22[2];
  *v22 = v17;
  if ( v24 >= 10 * (v25 + 1) )
  {
    v26 = *(_DWORD *)(v1 + 344);
    if ( *(_DWORD *)(v26 + 36) != 1 )
    {
      v71 = *(char ***)(v1 + 344);
      v27 = calloc(24 * *(_DWORD *)(v26 + 4), 1u);
      if ( v27 )
      {
        v28 = v71;
        v29 = v71[1];
        v30 = (unsigned int)v71[3];
        v31 = v71[2];
        v71[7] = 0;
        v32 = v30 >> ((_BYTE)v31 + 1);
        if ( (v30 & (2 * (_DWORD)v29 - 1)) != 0 )
          ++v32;
        v71[6] = (char *)v32;
        if ( v29 )
        {
          v33 = 2 * (_DWORD)v29 - 1;
          v72 = 0;
          ptr = *v28;
          v75 = 12 * (_DWORD)v29;
          v76 = v1;
          do
          {
            v34 = *(_DWORD **)&ptr[v72];
            if ( v34 )
            {
              do
              {
                v35 = (_DWORD *)v34[4];
                v36 = 3 * (v33 & v34[7]);
                v37 = (char *)&v27[3 * (v33 & v34[7])];
                v38 = *((_DWORD *)v37 + 1) + 1;
                *((_DWORD *)v37 + 1) = v38;
                if ( v32 < v38 )
                {
                  ++v28[7];
                  *((_DWORD *)v37 + 2) = v38 / v32;
                }
                v39 = v27[v36];
                v34[3] = 0;
                v34[4] = v39;
                if ( v39 )
                  *(_DWORD *)(v39 + 12) = v34;
                v27[v36] = v34;
                v34 = v35;
              }
              while ( v35 );
            }
            v72 += 12;
          }
          while ( v72 != v75 );
          v1 = v76;
          free(ptr);
        }
        else
        {
          free(*v71);
        }
        v40 = *(_DWORD **)(v1 + 344);
        v41 = v40[3];
        v42 = v40[7];
        v43 = v40[1];
        v44 = v40[2];
        *v40 = v27;
        v40[2] = v44 + 1;
        v40[1] = 2 * v43;
        if ( v42 <= v41 >> 1 )
        {
          v8 = staged_work;
          v40[8] = 0;
          if ( v8 )
            goto LABEL_33;
        }
        else
        {
          v8 = staged_work;
          v45 = v40[8] + 1;
          v40[8] = v45;
          if ( v45 > 1 )
            v40[9] = 1;
          if ( v8 )
            goto LABEL_33;
        }
        v3 = getq;
        goto LABEL_83;
      }
LABEL_94:
      exit(-1);
    }
  }
LABEL_33:
  v46 = *(_DWORD *)(v8 + 344);
  v47 = v8 + 344;
  v73 = 1;
  while ( 2 )
  {
    v48 = v47;
    v47 = 0;
    v49 = 0;
    v50 = 0;
    do
    {
      ++v50;
      if ( v73 )
      {
        v51 = *(_DWORD *)(v48 + 8);
        if ( v51 )
        {
          v52 = *(_DWORD *)(v46 + 20);
          v53 = 1;
          for ( i = v51 + v52; i; i += v52 )
          {
            if ( v53 == v73 )
              break;
            i = *(_DWORD *)(i + 8);
            ++v53;
            if ( !i )
              break;
          }
          v55 = v73;
          v56 = v48;
          v48 = i;
        }
        else
        {
          v56 = v48;
          v53 = 1;
          v55 = v73;
          v48 = 0;
        }
      }
      else
      {
        v56 = v48;
        v53 = 0;
        v55 = 0;
      }
LABEL_43:
      while ( v53 )
      {
        while ( 1 )
        {
          v61 = v48 == 0;
          if ( v48 )
            v61 = v55 == 0;
          if ( v61 )
          {
            if ( v56 )
            {
              v62 = *(_DWORD *)(v56 + 8);
              if ( v62 )
                v62 += *(_DWORD *)(v46 + 20);
            }
            else
            {
LABEL_75:
              v62 = v56;
            }
LABEL_60:
            --v53;
            if ( v49 )
              goto LABEL_61;
            goto LABEL_74;
          }
          v63 = *(_DWORD *)(v46 + 20);
          if ( *(_DWORD *)(v56 - v63 + 264) - *(_DWORD *)(v48 - v63 + 264) > 0 )
            break;
          if ( !v56 )
            goto LABEL_75;
          v62 = *(_DWORD *)(v56 + 8);
          if ( !v62 )
            goto LABEL_60;
          v62 += v63;
          --v53;
          if ( v49 )
          {
LABEL_61:
            if ( v56 )
            {
              v59 = v48;
              v48 = v56;
              v56 = v62;
              *(_DWORD *)(v49 + 8) = v48 - *(_DWORD *)(v46 + 20);
              goto LABEL_51;
            }
            *(_DWORD *)(v49 + 8) = 0;
            v49 = 0;
            v56 = v62;
            goto LABEL_43;
          }
LABEL_74:
          v47 = v56;
          v56 = v62;
LABEL_68:
          v49 = v47;
          v60 = 0;
          if ( !v47 )
            goto LABEL_43;
LABEL_52:
          *(_DWORD *)(v49 + 4) = v60;
          if ( !v53 )
            goto LABEL_44;
        }
        v64 = *(_DWORD *)(v48 + 8);
        v59 = v64 + v63;
        if ( v64 )
          goto LABEL_49;
        v59 = 0;
        --v55;
        if ( !v49 )
        {
LABEL_67:
          v47 = v48;
          v48 = v59;
          goto LABEL_68;
        }
LABEL_50:
        *(_DWORD *)(v49 + 8) = v48 - *(_DWORD *)(v46 + 20);
        if ( v48 )
        {
LABEL_51:
          v60 = v49 - *(_DWORD *)(v46 + 20);
          v49 = v48;
          v48 = v59;
          goto LABEL_52;
        }
        v49 = v48;
        v48 = v59;
      }
LABEL_44:
      v57 = v55 == 0;
      if ( v55 )
        v57 = v48 == 0;
      if ( !v57 )
      {
        v58 = *(_DWORD *)(v48 + 8);
        v59 = v53;
        if ( v58 )
          v59 = v58 + *(_DWORD *)(v46 + 20);
LABEL_49:
        --v55;
        if ( !v49 )
          goto LABEL_67;
        goto LABEL_50;
      }
    }
    while ( v48 );
    if ( v49 )
      *(_DWORD *)(v49 + 8) = 0;
    if ( v50 > 1 )
    {
      v73 *= 2;
      if ( !v47 )
      {
        v49 = 0;
        break;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(v46 + 16) = v49;
  v3 = getq;
  staged_work = v47 - *(_DWORD *)(v46 + 20);
LABEL_83:
  pthread_cond_broadcast((pthread_cond_t *)(v3 + 40));
  if ( pthread_mutex_unlock((pthread_mutex_t *)stgd_lock) )
  {
    v66 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v66, "cgminer.c", "hash_push", 5713);
    goto LABEL_92;
  }
  return selective_yield(0);
}
// 28BA0: conditional instruction was optimized away because r3.4!=0
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80FAC: using guessed type int stgd_lock;
// 81084: using guessed type int staged_work;
// 81110: using guessed type int staged_rollable;
// 81120: using guessed type int work_block;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80DCF8: using guessed type int getq;

//----- (00028D74) --------------------------------------------------------
void __fastcall submit_work_async(struct timeval *a1)
{
  double *tv_usec; // r4
  int v2; // r5
  double v3; // d6
  double v4; // d4
  double v5; // d7
  double v6; // d5
  __int64 v7; // r2
  __int64 v8; // r2
  void *v9; // r3
  int v10; // r0
  int v11; // r3
  int v12; // r4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  __int64 v16; // r6
  int v17; // r3
  int v18; // r4
  void *arg[2]; // [sp+14h] [bp-824h] BYREF
  pthread_t newthread; // [sp+1Ch] [bp-81Ch] BYREF
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  arg[0] = a1;
  tv_usec = (double *)a1[32].tv_usec;
  cgtime(a1 + 54);
  if ( opt_benchmark )
  {
    v2 = *(_DWORD *)(get_thread(*((_DWORD *)arg[0] + 64)) + 36);
    if ( !pthread_mutex_lock(&stats_lock) )
    {
      v3 = tv_usec[9];
      v4 = *((double *)arg[0] + 47);
      v5 = total_diff_accepted;
      v6 = *(double *)(v2 + 200) + v4;
      v7 = *((_QWORD *)tv_usec + 1) + 1LL;
      ++*(_DWORD *)(v2 + 36);
      *((_QWORD *)tv_usec + 1) = v7;
      v8 = *(_QWORD *)&total_accepted;
      *(double *)(v2 + 200) = v6;
      tv_usec[9] = v3 + v4;
      total_diff_accepted = v5 + v4;
      *(_QWORD *)&total_accepted = v8 + 1;
      if ( !pthread_mutex_unlock(&stats_lock) )
      {
        selective_yield(0);
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            s,
            2048u,
            "Accepted %s %d benchmark share nonce %08x",
            *(const char **)(*(_DWORD *)(v2 + 4) + 8),
            *(_DWORD *)(v2 + 8),
            *((_DWORD *)arg[0] + 19));
          applog(5, s, 0);
        }
        return;
      }
      v17 = *_errno_location();
      v18 = 8603;
      goto LABEL_68;
    }
    v11 = *_errno_location();
    v12 = 8596;
    goto LABEL_46;
  }
  if ( stale_work((int)arg[0], 1u) )
  {
    if ( opt_submit_stale )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
        goto LABEL_15;
      snprintf(s, 2048u, "Pool %d stale share detected, submitting as user requested", *(_DWORD *)tv_usec);
    }
    else
    {
      if ( !*((_BYTE *)tv_usec + 104) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(s, 2048u, "Pool %d stale share detected, discarding", *(_DWORD *)tv_usec);
          applog(5, s, 0);
        }
        sharelog("discard", (int)arg[0]);
        if ( !pthread_mutex_lock(&stats_lock) )
        {
          v13 = *((double *)arg[0] + 47);
          v14 = tv_usec[11] + v13;
          v15 = *(double *)total_diff_stale + v13;
          v16 = *(_QWORD *)&total_stale + 1LL;
          ++*((_DWORD *)tv_usec + 30);
          *(_QWORD *)&total_stale = v16;
          tv_usec[11] = v14;
          *(double *)total_diff_stale = v15;
          if ( !pthread_mutex_unlock(&stats_lock) )
          {
            selective_yield(0);
            free_work((void ***)arg, "cgminer.c", "submit_work_async", 8633);
            return;
          }
          v17 = *_errno_location();
          v18 = 8631;
LABEL_68:
          snprintf(
            s,
            2048u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            v17,
            "cgminer.c",
            "submit_work_async",
            v18);
LABEL_47:
          applog(3, s, 1);
          _quit(1, 1);
        }
        v11 = *_errno_location();
        v12 = 8624;
LABEL_46:
        snprintf(
          s,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          v11,
          "cgminer.c",
          "submit_work_async",
          v12);
        goto LABEL_47;
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
        goto LABEL_15;
      snprintf(s, 2048u, "Pool %d stale share detected, submitting as pool requested", *(_DWORD *)tv_usec);
    }
    applog(5, s, 0);
LABEL_15:
    *((_BYTE *)arg[0] + 281) = 1;
  }
  if ( is_network_error() )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(s, "Work stale due to network error");
      applog(7, s, 0);
    }
    free_work((void ***)arg, "cgminer.c", "submit_work_async", 8642);
    return;
  }
  v9 = arg[0];
  if ( *((_BYTE *)arg[0] + 284) )
  {
    if ( opt_debug )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        snprintf(s, 2048u, "Pushing pool %d work to stratum queue", *(_DWORD *)tv_usec);
        applog(7, s, 0);
        v10 = *((_DWORD *)tv_usec + 182);
        v9 = arg[0];
        if ( !v10 )
          goto LABEL_64;
      }
      else
      {
        v10 = *((_DWORD *)tv_usec + 182);
        if ( !v10 )
        {
LABEL_28:
          if ( !opt_log_output && opt_log_level <= 6 )
            goto LABEL_31;
LABEL_30:
          strcpy(s, "Discarding work from removed pool");
          applog(7, s, 0);
LABEL_31:
          free_work((void ***)arg, "cgminer.c", "submit_work_async", 8650);
          return;
        }
      }
    }
    else
    {
      v10 = *((_DWORD *)tv_usec + 182);
      if ( !v10 )
        goto LABEL_31;
    }
    if ( tq_push(v10, (int)v9) )
      return;
LABEL_64:
    if ( !opt_debug )
      goto LABEL_31;
    if ( use_syslog )
      goto LABEL_30;
    goto LABEL_28;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(s, "Pushing submit work to work thread");
    applog(7, s, 0);
    v9 = arg[0];
  }
  if ( pthread_create(&newthread, 0, (void *(*)(void *))submit_work_thread, v9) )
  {
    strcpy(s, "Failed to create submit_work_thread");
    applog(3, s, 1);
    _quit(1, 1);
  }
}
// 7DF05: using guessed type char opt_submit_stale;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 810D0: using guessed type char opt_benchmark;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BA38: using guessed type int total_stale;
// 80BA90: using guessed type double total_diff_accepted;
// 80CC18: using guessed type char use_syslog;
// 80DCF0: using guessed type int total_accepted;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;

//----- (000292C4) --------------------------------------------------------
int __fastcall submit_tested_work(int a1, int a2)
{
  int v4; // r5
  struct timeval *work; // r6
  char s[2064]; // [sp+8h] [bp-810h] BYREF

  update_work_stats_isra_55((int *)(a1 + 36), a2);
  v4 = fulltest((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160));
  if ( v4 )
  {
    work = (struct timeval *)make_work();
    copy_work((int)work, a2, 0);
    submit_work_async(work);
    return v4;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        s,
        2048u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
      applog(6, s, 0);
    }
    return 0;
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0002935C) --------------------------------------------------------
int __fastcall submit_nonce(int a1, int a2, unsigned int a3)
{
  int v6; // r0
  int v7; // r4

  v6 = new_nonce_isra_10(*(_DWORD **)(a1 + 36), a3);
  if ( v6 && (v7 = v6, *(_DWORD *)(a2 + 76) = a3, regen_hash(a2), !*(_DWORD *)(a2 + 220)) )
  {
    submit_tested_work(a1, a2);
    if ( opt_benchfile && opt_benchfile_display )
    {
      v7 = (unsigned __int8)opt_benchfile_display;
      benchfile_dspwork((unsigned __int8 *)a2, a3);
    }
  }
  else
  {
    v7 = 0;
    inc_hw_errors(a1);
  }
  return v7;
}
// 80F9C: using guessed type int opt_benchfile;
// 826A8: using guessed type char opt_benchfile_display;

//----- (000293C0) --------------------------------------------------------
void __fastcall submit_nonce_2(int a1)
{
  struct timeval *work; // r4

  work = (struct timeval *)make_work();
  copy_work((int)work, a1, 0);
  submit_work_async(work);
}

//----- (000293DC) --------------------------------------------------------
int __fastcall submit_nonce_direct(int a1, int a2, int a3)
{
  struct timeval *work; // r5

  *(_DWORD *)(a2 + 76) = a3;
  work = (struct timeval *)make_work();
  copy_work((int)work, a2, 0);
  submit_work_async(work);
  return 1;
}

//----- (000293FC) --------------------------------------------------------
int __fastcall submit_noffset_nonce(int a1, int a2, void *a3, int a4)
{
  void **v8; // r4
  void **work; // [sp+Ch] [bp-81Ch] BYREF
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  work = (void **)make_work();
  copy_work((int)work, a2, a4);
  v8 = work;
  work[19] = a3;
  regen_hash((int)v8);
  if ( v8[55] )
  {
    free_work(&work, "cgminer.c", "submit_noffset_nonce", 9007);
    inc_hw_errors(a1);
    return 0;
  }
  else
  {
    update_work_stats_isra_55((int *)(a1 + 36), (int)work);
    if ( opt_benchfile && opt_benchfile_display )
      benchfile_dspwork((unsigned __int8 *)work, (unsigned int)a3);
    if ( fulltest((unsigned int *)work + 48, (unsigned int *)work + 40) )
    {
      submit_work_async((struct timeval *)work);
      return 1;
    }
    else
    {
      free_work(&work, "cgminer.c", "submit_noffset_nonce", 9023);
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(
          s,
          2048u,
          "%s %d: Share above target",
          *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
          *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
        applog(6, s, 0);
        return 1;
      }
      else
      {
        return 1;
      }
    }
  }
}
// 805A8: using guessed type int opt_log_level;
// 80F9C: using guessed type int opt_benchfile;
// 826A8: using guessed type char opt_benchfile_display;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0002950C) --------------------------------------------------------
void __fastcall __noreturn quit(int a1)
{
  _quit(a1, 1);
}

//----- (00029514) --------------------------------------------------------
int are_pools_active()
{
  return (unsigned __int8)pools_active;
}
// 81114: using guessed type char pools_active;

//----- (00029524) --------------------------------------------------------
int __fastcall add_pool_details(int a1, int a2, char *a3, const char *a4, const char *a5)
{
  char *proxy; // r0
  size_t v9; // r5
  unsigned int v10; // r5
  char *v11; // r0
  const char *v12; // r7
  const char *v13; // r3
  int v14; // r2
  int result; // r0

  proxy = get_proxy(a3, a1);
  *(_DWORD *)(a1 + 172) = a4;
  *(_DWORD *)(a1 + 164) = proxy;
  *(_DWORD *)(a1 + 176) = a5;
  v9 = strlen(a4);
  v10 = strlen(a5) + v9 + 2;
  v11 = (char *)cgmalloc(v10, "cgminer.c", "add_pool_details", 10715);
  v12 = *(const char **)(a1 + 176);
  v13 = *(const char **)(a1 + 172);
  *(_DWORD *)(a1 + 168) = v11;
  snprintf(v11, v10, "%s:%s", v13, v12);
  v14 = *(_DWORD *)(a1 + 100);
  *(_BYTE *)(a1 + 284) = 1;
  *(_BYTE *)(a1 + 107) = a2 ^ 1;
  *(_BYTE *)(a1 + 97) = 1;
  if ( v14 != 1 )
  {
    *(_DWORD *)(a1 + 100) = 1;
    ++enabled_pools;
  }
  pthread_create((pthread_t *)(a1 + 280), 0, (void *(*)(void *))test_pool_thread, (void *)a1);
  result = 1;
  if ( !a2 )
  {
    pthread_join(*(_DWORD *)(a1 + 280), 0);
    return (unsigned __int8)pools_active;
  }
  return result;
}
// 23014: using guessed type int test_pool_thread();
// 81114: using guessed type char pools_active;
// 80CC90: using guessed type int enabled_pools;

//----- (000295E4) --------------------------------------------------------
int __fastcall fill_device_drv(int result)
{
  if ( *(_DWORD *)(result + 12) )
  {
    if ( *(_DWORD *)(result + 16) )
      goto LABEL_3;
  }
  else
  {
    *(_DWORD *)(result + 12) = noop_detect;
    if ( *(_DWORD *)(result + 16) )
    {
LABEL_3:
      if ( *(_DWORD *)(result + 20) )
        goto LABEL_4;
      goto LABEL_22;
    }
  }
  *(_DWORD *)(result + 16) = noop_reinit_device;
  if ( *(_DWORD *)(result + 20) )
  {
LABEL_4:
    if ( *(_DWORD *)(result + 24) )
      goto LABEL_5;
    goto LABEL_23;
  }
LABEL_22:
  *(_DWORD *)(result + 20) = blank_get_statline_before;
  if ( *(_DWORD *)(result + 24) )
  {
LABEL_5:
    if ( *(_DWORD *)(result + 32) )
      goto LABEL_6;
    goto LABEL_24;
  }
LABEL_23:
  *(_DWORD *)(result + 24) = noop_get_statline;
  if ( *(_DWORD *)(result + 32) )
  {
LABEL_6:
    if ( *(_DWORD *)(result + 44) )
      goto LABEL_7;
    goto LABEL_25;
  }
LABEL_24:
  *(_DWORD *)(result + 32) = noop_get_stats;
  if ( *(_DWORD *)(result + 44) )
  {
LABEL_7:
    if ( *(_DWORD *)(result + 52) )
      goto LABEL_8;
    goto LABEL_26;
  }
LABEL_25:
  *(_DWORD *)(result + 44) = noop_thread_prepare;
  if ( *(_DWORD *)(result + 52) )
  {
LABEL_8:
    if ( *(_DWORD *)(result + 56) )
      goto LABEL_9;
    goto LABEL_27;
  }
LABEL_26:
  *(_DWORD *)(result + 52) = noop_thread_init;
  if ( *(_DWORD *)(result + 56) )
  {
LABEL_9:
    if ( *(_DWORD *)(result + 84) )
      goto LABEL_10;
    goto LABEL_28;
  }
LABEL_27:
  *(_DWORD *)(result + 56) = noop_prepare_work;
  if ( *(_DWORD *)(result + 84) )
  {
LABEL_10:
    if ( *(_DWORD *)(result + 88) )
      goto LABEL_11;
    goto LABEL_29;
  }
LABEL_28:
  *(_DWORD *)(result + 84) = noop_hw_error;
  if ( *(_DWORD *)(result + 88) )
  {
LABEL_11:
    if ( *(_DWORD *)(result + 92) )
      goto LABEL_12;
    goto LABEL_30;
  }
LABEL_29:
  *(_DWORD *)(result + 88) = noop_thread_shutdown;
  if ( *(_DWORD *)(result + 92) )
  {
LABEL_12:
    if ( *(_DWORD *)(result + 60) )
      goto LABEL_13;
    goto LABEL_31;
  }
LABEL_30:
  *(_DWORD *)(result + 92) = noop_thread_enable;
  if ( *(_DWORD *)(result + 60) )
  {
LABEL_13:
    if ( *(_DWORD *)(result + 76) )
      goto LABEL_14;
    goto LABEL_32;
  }
LABEL_31:
  *(_DWORD *)(result + 60) = hash_sole_work;
  if ( *(_DWORD *)(result + 76) )
  {
LABEL_14:
    if ( *(_DWORD *)(result + 80) )
      goto LABEL_15;
    goto LABEL_33;
  }
LABEL_32:
  *(_DWORD *)(result + 76) = noop_reinit_device;
  if ( *(_DWORD *)(result + 80) )
  {
LABEL_15:
    if ( *(_DWORD *)(result + 72) )
      goto LABEL_16;
LABEL_34:
    *(_DWORD *)(result + 72) = noop_get_stats;
    if ( *(_DWORD *)(result + 96) )
      goto LABEL_17;
    goto LABEL_35;
  }
LABEL_33:
  *(_DWORD *)(result + 80) = noop_reinit_device;
  if ( !*(_DWORD *)(result + 72) )
    goto LABEL_34;
LABEL_16:
  if ( *(_DWORD *)(result + 96) )
    goto LABEL_17;
LABEL_35:
  *(_DWORD *)(result + 96) = generic_zero_stats;
LABEL_17:
  if ( *(double *)(result + 104) == 0.0 )
    *(_QWORD *)(result + 104) = 4607182418800017408LL;
  return result;
}
// 1B3FC: using guessed type int noop_get_statline();
// 1B410: using guessed type int noop_detect();
// 1C7B4: using guessed type int blank_get_statline_before();
// 1C7C4: using guessed type int noop_thread_shutdown();
// 1C7C8: using guessed type int noop_thread_enable();
// 1C7CC: using guessed type int noop_hw_error();
// 1C7D0: using guessed type int noop_reinit_device();
// 25934: using guessed type int hash_sole_work();

//----- (00029764) --------------------------------------------------------
int __fastcall null_device_drv(int result)
{
  *(_DWORD *)(result + 12) = noop_detect;
  *(_DWORD *)(result + 28) = noop_get_api_stats;
  *(_DWORD *)(result + 20) = blank_get_statline_before;
  *(_DWORD *)(result + 24) = noop_get_statline;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = noop_thread_prepare;
  *(_DWORD *)(result + 48) = noop_can_limit_work;
  *(_DWORD *)(result + 52) = noop_thread_init;
  *(_DWORD *)(result + 56) = noop_prepare_work;
  *(_DWORD *)(result + 60) = noop_hash_work;
  *(_DWORD *)(result + 84) = noop_hw_error;
  *(_DWORD *)(result + 88) = noop_thread_shutdown;
  *(_DWORD *)(result + 92) = noop_thread_enable;
  *(_QWORD *)(result + 104) = 4607182418800017408LL;
  *(_QWORD *)(result + 112) = 4607182418800017408LL;
  *(_DWORD *)(result + 96) = generic_zero_stats;
  *(_DWORD *)(result + 16) = noop_reinit_device;
  *(_DWORD *)(result + 36) = noop_reinit_device;
  *(_DWORD *)(result + 76) = noop_reinit_device;
  *(_DWORD *)(result + 80) = noop_reinit_device;
  *(_DWORD *)(result + 32) = noop_get_stats;
  *(_DWORD *)(result + 72) = noop_get_stats;
  return result;
}
// 1B3FC: using guessed type int noop_get_statline();
// 1B410: using guessed type int noop_detect();
// 1B418: using guessed type int noop_hash_work();
// 1C7B4: using guessed type int blank_get_statline_before();
// 1C7C4: using guessed type int noop_thread_shutdown();
// 1C7C8: using guessed type int noop_thread_enable();
// 1C7CC: using guessed type int noop_hw_error();
// 1C7D0: using guessed type int noop_reinit_device();

//----- (00029824) --------------------------------------------------------
int __fastcall enable_device(pthread_rwlock_t *a1)
{
  int v2; // r1
  int v3; // r3
  int result; // r0

  a1[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&devices_lock) )
    wr_lock_part_54_constprop_73("enable_device", 11125);
  v2 = devices;
  v3 = cgminer_id_count;
  a1->__lock = cgminer_id_count;
  *(_DWORD *)(v2 + 4 * v3) = a1;
  cgminer_id_count = v3 + 1;
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock_part_40_constprop_79("enable_device", 11127);
  selective_yield(0);
  if ( hotplug_mode )
    new_threads += a1[4].__nr_writers_queued;
  else
    mining_threads += a1[4].__nr_writers_queued;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    rwlock_init_part_43_constprop_69("enable_device", 11138);
  a1[11].__lock = 0;
  return result;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 826AC: using guessed type int cgminer_id_count;
// 826B0: using guessed type int new_threads;
// 80BB8C: using guessed type int devices;
// 80BB98: using guessed type char hotplug_mode;
// 80DCA0: using guessed type int mining_threads;
// 80EF1C: using guessed type pthread_rwlock_t devices_lock;

//----- (000298DC) --------------------------------------------------------
int __fastcall add_cgpu(_DWORD *a1)
{
  unsigned int v1; // r7
  const char *v2; // r4
  size_t v3; // r0
  bool v4; // cc
  int v5; // r3
  size_t v6; // r8
  int v7; // r0
  unsigned __int8 *v8; // r9
  int v9; // lr
  int v10; // r1
  int v11; // r4
  int v12; // r12
  unsigned int v13; // r7
  unsigned int v14; // r3
  int v15; // r2
  unsigned int v16; // r1
  unsigned int v17; // r3
  int v18; // r2
  unsigned int v19; // r1
  unsigned int v20; // r3
  size_t v21; // r3
  int v22; // r2
  unsigned int v23; // r1
  unsigned int v24; // r5
  int v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r1
  int v28; // r3
  unsigned int v29; // r6
  _DWORD *v30; // r1
  int v31; // r5
  int v32; // r7
  int v33; // r5
  int v34; // r5
  unsigned __int8 *v35; // r8
  int v36; // r7
  size_t v37; // r0
  unsigned int v38; // r3
  int v39; // r5
  unsigned __int8 *v40; // r1
  unsigned __int8 *v41; // r12
  int v42; // r1
  int v43; // lr
  int v44; // r10
  unsigned __int8 *v45; // r2
  int v46; // r9
  unsigned int v47; // lr
  unsigned int v48; // r7
  int v49; // r1
  unsigned int v50; // r5
  unsigned int v51; // r3
  int v52; // r1
  unsigned int v53; // r5
  unsigned int v54; // r3
  unsigned int v55; // r6
  unsigned int v56; // r7
  size_t v57; // r7
  int v58; // r3
  int v59; // r2
  int v60; // r3
  int result; // r0
  int v62; // r3
  int v63; // r0
  int v64; // r2
  unsigned int v65; // r1
  unsigned int v66; // r3
  int v67; // r2
  unsigned int v68; // r1
  unsigned int v69; // r3
  int v70; // r2
  unsigned int v71; // r5
  int v72; // r7
  char *v73; // r6
  int *v74; // r1
  int v75; // r2
  int v76; // r0
  int v77; // r3
  int v78; // r3
  int v79; // r5
  unsigned int v80; // r1
  int v81; // r2
  int v82; // r3
  _DWORD *v83; // r8
  void **v84; // r10
  char *v85; // r3
  unsigned int v86; // r0
  char *v87; // r2
  unsigned int v88; // r11
  int v89; // r2
  _DWORD *v90; // r5
  _DWORD *v91; // r7
  int v92; // r4
  char *v93; // r6
  unsigned int v94; // r0
  int v95; // r3
  bool v96; // zf
  _DWORD *v97; // r3
  unsigned int v98; // r0
  unsigned int v99; // r1
  int v100; // r5
  int v101; // r2
  int v102; // r2
  int v103; // r5
  unsigned int v104; // r2
  unsigned __int8 *v105; // r11
  unsigned int v106; // r10
  void *v107; // r0
  _DWORD *v108; // r8
  void *v109; // r0
  const char *s2; // [sp+Ch] [bp-3Ch]
  unsigned __int8 *s2a; // [sp+Ch] [bp-3Ch]
  int v113; // [sp+10h] [bp-38h]
  char *ptr; // [sp+14h] [bp-34h]
  int v115; // [sp+18h] [bp-30h]

  v1 = -1640531527;
  v2 = *(const char **)(a1[1] + 8);
  s2 = v2;
  v3 = strlen(v2);
  v4 = v3 > 11;
  v5 = -17973521;
  v6 = v3;
  v7 = -1640531527;
  if ( v4 )
  {
    v8 = (unsigned __int8 *)(v2 + 12);
    v106 = v6;
    do
    {
      v9 = *(v8 - 6);
      v106 -= 12;
      v10 = *(v8 - 10);
      v11 = *(v8 - 7);
      v105 = v8;
      v12 = *(v8 - 11);
      v8 += 12;
      v13 = v1 + *(v8 - 20) + (v9 << 16) + (v11 << 8) + (*(v8 - 17) << 24);
      v14 = v5 + *(v8 - 16) + (*(v8 - 14) << 16) + (*(v8 - 15) << 8) + (*(v8 - 13) << 24);
      v15 = (*(v8 - 24) + (v10 << 16) + (v12 << 8) + (*(v8 - 21) << 24) - v13 - v14 + v7) ^ (v14 >> 13);
      v16 = (v13 - v14 - v15) ^ (v15 << 8);
      v17 = (v14 - v15 - v16) ^ (v16 >> 13);
      v18 = (v15 - v16 - v17) ^ (v17 >> 12);
      v19 = (v16 - v17 - v18) ^ (v18 << 16);
      v20 = (v17 - v18 - v19) ^ (v19 >> 5);
      v7 = (v18 - v19 - v20) ^ (v20 >> 3);
      v1 = (v19 - v20 - v7) ^ (v7 << 10);
      v5 = (v20 - v7 - v1) ^ (v1 >> 15);
    }
    while ( v106 > 11 );
  }
  else
  {
    v105 = (unsigned __int8 *)v2;
    v106 = v6;
  }
  v21 = v5 + v6;
  switch ( v106 )
  {
    case 1u:
      goto LABEL_16;
    case 2u:
      goto LABEL_15;
    case 3u:
      goto LABEL_14;
    case 4u:
      goto LABEL_13;
    case 5u:
      goto LABEL_12;
    case 6u:
      goto LABEL_11;
    case 7u:
      goto LABEL_10;
    case 8u:
      goto LABEL_9;
    case 9u:
      goto LABEL_8;
    case 10u:
      goto LABEL_7;
    case 11u:
      v21 += v105[10] << 24;
LABEL_7:
      v21 += v105[9] << 16;
LABEL_8:
      v21 += v105[8] << 8;
LABEL_9:
      v1 += v105[7] << 24;
LABEL_10:
      v1 += v105[6] << 16;
LABEL_11:
      v1 += v105[5] << 8;
LABEL_12:
      v1 += v105[4];
LABEL_13:
      v7 += v105[3] << 24;
LABEL_14:
      v7 += v105[2] << 16;
LABEL_15:
      v7 += v105[1] << 8;
LABEL_16:
      v7 += *v105;
      break;
    default:
      break;
  }
  v22 = (v7 - v1 - v21) ^ (v21 >> 13);
  v23 = (v1 - v21 - v22) ^ (v22 << 8);
  v24 = (v21 - v22 - v23) ^ (v23 >> 13);
  v25 = (v22 - v23 - v24) ^ (v24 >> 12);
  v26 = (v23 - v24 - v25) ^ (v25 << 16);
  v27 = (v24 - v25 - v26) ^ (v26 >> 5);
  v28 = (v25 - v26 - v27) ^ (v27 >> 3);
  v29 = (v27 - v28 - ((v26 - v27 - v28) ^ (v28 << 10))) ^ (((v26 - v27 - v28) ^ (v28 << 10)) >> 15);
  if ( !devids_15749
    || (v30 = *(_DWORD **)(devids_15749 + 8), (v31 = *(_DWORD *)(*v30 + 12 * ((v30[1] - 1) & v29))) == 0)
    || (v32 = -v30[5], (v33 = v31 - v30[5]) == 0) )
  {
LABEL_23:
    v35 = (unsigned __int8 *)cgmalloc(40u, "cgminer.c", "add_cgpu", 11172);
    s2a = v35;
    cg_memcpy(v35, *(const void **)(a1[1] + 8), 4u, (int)"cgminer.c", (int)"add_cgpu", 11173);
    *((_DWORD *)v35 + 1) = 0;
    a1[2] = 0;
    v36 = -17973521;
    v37 = strlen((const char *)v35);
    v38 = -1640531527;
    if ( v37 <= 11 )
      v35 = (unsigned __int8 *)v37;
    v39 = -1640531527;
    if ( v37 > 11 )
    {
      v41 = s2a + 12;
      v35 = (unsigned __int8 *)v37;
      do
      {
        v42 = *(v41 - 6);
        v35 -= 12;
        v43 = *(v41 - 7);
        v44 = *(v41 - 2);
        v45 = v41;
        v46 = *(v41 - 10);
        v41 += 12;
        v47 = *(v41 - 20) + (v42 << 16) + (v43 << 8) + (*(v41 - 17) << 24) + v38;
        v48 = v36 + (v44 << 16) + (*(v41 - 15) << 8) + *(v41 - 16) + (*(v41 - 13) << 24);
        v49 = (*(v41 - 24) + (v46 << 16) + (*(v41 - 23) << 8) + (*(v41 - 21) << 24) - v47 - v48 + v39) ^ (v48 >> 13);
        v50 = (v47 - v48 - v49) ^ (v49 << 8);
        v51 = (v48 - v49 - v50) ^ (v50 >> 13);
        v52 = (v49 - v50 - v51) ^ (v51 >> 12);
        v53 = (v50 - v51 - v52) ^ (v52 << 16);
        v54 = (v51 - v52 - v53) ^ (v53 >> 5);
        v55 = v53 - v54;
        v39 = (v52 - v53 - v54) ^ (v54 >> 3);
        v56 = v54 - v39;
        v38 = (v55 - v39) ^ (v39 << 10);
        v36 = (v56 - v38) ^ (v38 >> 15);
      }
      while ( (unsigned int)v35 > 11 );
      v40 = v45;
    }
    else
    {
      v40 = s2a;
    }
    v57 = v36 + v37;
    switch ( (unsigned int)v35 )
    {
      case 1u:
        goto LABEL_54;
      case 2u:
        goto LABEL_53;
      case 3u:
        goto LABEL_52;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_50;
      case 6u:
        goto LABEL_49;
      case 7u:
        goto LABEL_48;
      case 8u:
        goto LABEL_47;
      case 9u:
        goto LABEL_46;
      case 10u:
        goto LABEL_45;
      case 11u:
        v57 += v40[10] << 24;
LABEL_45:
        v57 += v40[9] << 16;
LABEL_46:
        v57 += v40[8] << 8;
LABEL_47:
        v38 += v40[7] << 24;
LABEL_48:
        v38 += v40[6] << 16;
LABEL_49:
        v38 += v40[5] << 8;
LABEL_50:
        v38 += v40[4];
LABEL_51:
        v39 += v40[3] << 24;
LABEL_52:
        v39 += v40[2] << 16;
LABEL_53:
        v39 += v40[1] << 8;
LABEL_54:
        v39 += *v40;
        break;
      default:
        break;
    }
    v64 = (v39 - v38 - v57) ^ (v57 >> 13);
    *((_DWORD *)s2a + 7) = s2a;
    v65 = (v38 - v57 - v64) ^ (v64 << 8);
    v66 = (v57 - v64 - v65) ^ (v65 >> 13);
    v67 = (v64 - v65 - v66) ^ (v66 >> 12);
    v68 = (v65 - v66 - v67) ^ (v67 << 16);
    v69 = (v66 - v67 - v68) ^ (v68 >> 5);
    v70 = (v67 - v68 - v69) ^ (v69 >> 3);
    v71 = (v69 - v70 - ((v68 - v69 - v70) ^ (v70 << 10))) ^ (((v68 - v69 - v70) ^ (v70 << 10)) >> 15);
    *((_DWORD *)s2a + 9) = v71;
    v72 = devids_15749;
    *((_DWORD *)s2a + 8) = strlen((const char *)s2a);
    if ( v72 )
    {
      *((_DWORD *)s2a + 2) = *(_DWORD *)(v72 + 8);
      v73 = (char *)(s2a + 8);
      v74 = *(int **)(v72 + 8);
      *((_DWORD *)s2a + 4) = 0;
      v75 = v74[4];
      *((_DWORD *)s2a + 3) = v75 - v74[5];
      *(_DWORD *)(v75 + 8) = s2a;
      v74[4] = (int)(s2a + 8);
    }
    else
    {
      *((_DWORD *)s2a + 4) = 0;
      *((_DWORD *)s2a + 3) = 0;
      devids_15749 = (int)s2a;
      v107 = malloc(44u);
      *((_DWORD *)s2a + 2) = v107;
      if ( !v107 )
        goto LABEL_90;
      memset(v107, 0, 44u);
      v73 = (char *)(s2a + 8);
      v108 = (_DWORD *)*((_DWORD *)s2a + 2);
      v108[4] = s2a + 8;
      v108[1] = 32;
      v108[2] = 5;
      v108[5] = 8;
      v109 = malloc(384u);
      *v108 = v109;
      if ( !v109 )
        goto LABEL_90;
      memset(v109, 0, 384u);
      v74 = (int *)*((_DWORD *)s2a + 2);
      v74[10] = -1609490463;
    }
    v76 = *v74;
    v77 = 3 * ((v74[1] - 1) & v71);
    ++v74[3];
    v78 = 4 * v77;
    v79 = *(_DWORD *)(v76 + v78);
    v80 = *(_DWORD *)(v76 + v78 + 4) + 1;
    *(_DWORD *)(v76 + v78 + 4) = v80;
    *((_DWORD *)s2a + 6) = v79;
    *((_DWORD *)s2a + 5) = 0;
    if ( v79 )
      *(_DWORD *)(v79 + 12) = v73;
    v81 = *(_DWORD *)(v76 + v78 + 8);
    *(_DWORD *)(v76 + v78) = v73;
    if ( v80 < 10 * (v81 + 1) )
      goto LABEL_34;
    v82 = *((_DWORD *)s2a + 2);
    if ( *(_DWORD *)(v82 + 36) == 1 )
      goto LABEL_34;
    v83 = calloc(24 * *(_DWORD *)(v82 + 4), 1u);
    if ( v83 )
    {
      v84 = (void **)*((_DWORD *)s2a + 2);
      v85 = (char *)v84[1];
      v86 = (unsigned int)v84[3];
      v87 = (char *)v84[2];
      v84[7] = 0;
      v88 = v86 >> ((_BYTE)v87 + 1);
      v89 = 2 * (_DWORD)v85 - 1;
      if ( (v86 & v89) != 0 )
        ++v88;
      v84[6] = (void *)v88;
      if ( v85 )
      {
        v113 = 0;
        ptr = (char *)*v84;
        v115 = 12 * (_DWORD)v85;
        do
        {
          v90 = *(_DWORD **)&ptr[v113];
          if ( v90 )
          {
            do
            {
              v91 = (_DWORD *)v90[4];
              v92 = 3 * (v89 & v90[7]);
              v93 = (char *)&v83[3 * (v89 & v90[7])];
              v94 = *((_DWORD *)v93 + 1) + 1;
              *((_DWORD *)v93 + 1) = v94;
              if ( v88 < v94 )
              {
                v84[7] = (char *)v84[7] + 1;
                *((_DWORD *)v93 + 2) = v94 / v88;
              }
              v95 = v83[v92];
              v90[3] = 0;
              v90[4] = v95;
              if ( v95 )
                *(_DWORD *)(v95 + 12) = v90;
              v83[v92] = v90;
              v90 = v91;
            }
            while ( v91 );
          }
          v96 = v115 == v113 + 12;
          v113 += 12;
        }
        while ( !v96 );
        free(ptr);
      }
      else
      {
        free(*v84);
      }
      v97 = (_DWORD *)*((_DWORD *)s2a + 2);
      v98 = v97[3];
      v99 = v97[7];
      v100 = v97[1];
      v101 = v97[2];
      *v97 = v83;
      v102 = v101 + 1;
      v103 = 2 * v100;
      v97[2] = v102;
      if ( v99 <= v98 >> 1 )
        v102 = 0;
      v97[1] = v103;
      if ( v99 > v98 >> 1 )
      {
        v104 = v97[8] + 1;
        v97[8] = v104;
        if ( v104 > 1 )
          v97[9] = 1;
      }
      else
      {
        v97[8] = v102;
      }
      goto LABEL_34;
    }
LABEL_90:
    exit(-1);
  }
  while ( v29 != *(_DWORD *)(v33 + 36) || v6 != *(_DWORD *)(v33 + 32) || memcmp(*(const void **)(v33 + 28), s2, v6) )
  {
    v34 = *(_DWORD *)(v33 + 24);
    if ( v34 )
    {
      v33 = v34 + v32;
      if ( v33 )
        continue;
    }
    goto LABEL_23;
  }
  v58 = *(_DWORD *)(v33 + 4) + 1;
  *(_DWORD *)(v33 + 4) = v58;
  a1[2] = v58;
LABEL_34:
  if ( pthread_rwlock_wrlock(&devices_lock) )
    wr_lock_part_54_constprop_73("add_cgpu", 11178);
  devices = (int)cgrealloc((void *)devices, 4 * (new_devices + total_devices + 2), "cgminer.c", "add_cgpu", 11179);
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock_part_40_constprop_79("add_cgpu", 11180);
  selective_yield(0);
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock_part_47_constprop_75("add_cgpu", 11182);
  a1[58] = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield_part_48_constprop_77("add_cgpu", 11184);
  selective_yield(0);
  if ( hotplug_mode )
  {
    v60 = total_devices;
    v63 = new_devices + total_devices;
    ++new_devices;
    *(_DWORD *)(devices + 4 * v63) = a1;
  }
  else
  {
    v59 = total_devices;
    v60 = ++total_devices;
    *(_DWORD *)(devices + 4 * v59) = a1;
  }
  result = 1;
  v62 = v60 - zombie_devs;
  if ( v62 > most_devices )
    most_devices = v62;
  return result;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 826B4: using guessed type int devids_15749;
// 826B8: using guessed type int new_devices;
// 826BC: using guessed type int most_devices;
// 80BB8C: using guessed type int devices;
// 80BB98: using guessed type char hotplug_mode;
// 80CBB4: using guessed type int zombie_devs;
// 80DCD8: using guessed type int total_devices;
// 80EDD8: using guessed type pthread_mutex_t stats_lock;
// 80EF1C: using guessed type pthread_rwlock_t devices_lock;

//----- (0002A008) --------------------------------------------------------
_BYTE *__fastcall copy_drv(const void *a1)
{
  _BYTE *v2; // r5
  _BYTE *result; // r0

  v2 = cgmalloc(120u, "cgminer.c", "copy_drv", 11208);
  cg_memcpy(v2, a1, 120u, (int)"cgminer.c", (int)"copy_drv", 11209);
  result = v2;
  v2[100] = 1;
  return result;
}

//----- (0002A04C) --------------------------------------------------------
int setStartTimePoint()
{
  int result; // r0
  int v1; // r4
  char *v2; // r0
  struct sysinfo v3; // [sp+0h] [bp-150h] BYREF
  char s[272]; // [sp+40h] [bp-110h] BYREF

  if ( sysinfo(&v3) )
  {
    v1 = *_errno_location();
    v2 = strerror(v1);
    sprintf(s, "Failed to get sysinfo, errno:%u, reason:%s\n", v1, v2);
    writeInitLogFile(s);
    result = time(0);
    total_tv_start_sys = result;
    total_tv_end_sys = result + 1;
  }
  else
  {
    total_tv_start_sys = v3.uptime;
    total_tv_end_sys = v3.uptime + 1;
    sprintf(s, "setStartTimePoint total_tv_start_sys=%d total_tv_end_sys=%d\n", v3.uptime, v3.uptime + 1);
    return writeInitLogFile(s);
  }
  return result;
}
// 80BA40: using guessed type int total_tv_start_sys;
// 80CBA0: using guessed type int total_tv_end_sys;

//----- (0002A0D0) --------------------------------------------------------
char *read_config()
{
  FILE *v0; // r4
  char *result; // r0
  char *v2; // r0
  char *v3; // r1
  int v4; // r2
  char *v5; // r0
  int v6; // r3
  char v7; // t1
  int v8; // t1
  bool v9; // zf
  char *v10; // r0
  char *v11; // r0
  char *v12; // r0
  char *v13; // r0
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r0
  char *v18; // r0
  char *v19; // r0
  char *v20; // r0
  char *v21; // r0
  char *v22; // r0
  char *v23; // r0
  char *v24; // r0
  char *v25; // r0
  char *v26; // r0
  char *v27; // r0
  char *v28; // r0
  char *v29; // r0
  char *v30; // r0
  char *v31; // r0
  char *v32; // r0
  char *v33; // r0
  char *v34; // r0
  char *v35; // r0
  char *v36; // r0
  char *v37; // r0
  char *v38; // r0
  char *v39; // r0
  char *v40; // r0
  char *v41; // r0
  char *v42; // r0
  char *v43; // r0
  char *v44; // r0
  char *v45; // r0
  char *v46; // r0
  char *v47; // r0
  char *v48; // r0
  char *v49; // r0
  char *v50; // r0
  int v51; // r3
  char *v52; // r0
  char *v53; // r0
  char *v54; // r0
  char *v55; // r0
  char *v56; // r0
  char *v57; // r0
  char *v58; // r0
  char *v59; // r0
  const char *v60; // r9
  int v61; // r3
  int v62; // [sp+0h] [bp-428h] BYREF
  int v63; // [sp+4h] [bp-424h] BYREF
  char s[1056]; // [sp+8h] [bp-420h] BYREF

  memset(s, 0, 1024u);
  v62 = 0;
  v63 = 0;
  v0 = fopen("/etc/config/Config.ini", "r");
LABEL_2:
  while ( 1 )
  {
    result = fgets(s, 1023, v0);
    if ( !result )
      break;
    while ( s[0] != 35 && s[1] != 35 )
    {
      v2 = strstr(s, "TestDir=");
      if ( !v2 )
      {
        v10 = strstr(s, "DataCount=");
        if ( v10 )
        {
          sscanf(v10 + 10, "%d", &dword_2F458C);
        }
        else
        {
          v11 = strstr(s, "PassCount1=");
          if ( v11 )
          {
            sscanf(v11 + 11, "%d", &dword_2F4590);
          }
          else
          {
            v12 = strstr(s, "PassCount2=");
            if ( v12 )
            {
              sscanf(v12 + 11, "%d", &dword_2F4594);
            }
            else
            {
              v13 = strstr(s, "PassCount3=");
              if ( v13 )
              {
                sscanf(v13 + 11, "%d", &dword_2F4598);
              }
              else
              {
                v14 = strstr(s, "Freq=");
                if ( v14 )
                {
                  sscanf(v14 + 5, "%d", &dword_2F459C);
                  dword_2F4648 = 0;
                }
                else
                {
                  v15 = strstr(s, "freq_e=");
                  if ( v15 )
                  {
                    sscanf(v15 + 7, "%d", &dword_2F4638);
                  }
                  else
                  {
                    v16 = strstr(s, "UseConfigVol=");
                    if ( v16 )
                    {
                      sscanf(v16 + 13, "%d", &dword_2F464C);
                    }
                    else
                    {
                      v17 = strstr(s, "freq_m=");
                      if ( v17 )
                      {
                        sscanf(v17 + 7, "%d", &dword_2F463C);
                      }
                      else
                      {
                        v18 = strstr(s, "freq_a=");
                        if ( v18 )
                        {
                          sscanf(v18 + 7, "%d", &dword_2F4640);
                        }
                        else
                        {
                          v19 = strstr(s, "freq_t=");
                          if ( v19 )
                          {
                            sscanf(v19 + 7, "%d", &dword_2F4644);
                          }
                          else if ( !strstr(s, "force_freq=") )
                          {
                            v20 = strstr(s, "Timeout=");
                            if ( v20 )
                            {
                              sscanf(v20 + 8, "%d", &dword_2F45A0);
                            }
                            else
                            {
                              v21 = strstr(s, "UseFreqPIC=");
                              if ( v21 )
                              {
                                sscanf(v21 + 11, "%d", &unk_2F45BC);
                              }
                              else
                              {
                                v22 = strstr(s, "TestMode=");
                                if ( v22 )
                                {
                                  sscanf(v22 + 9, "%d", &dword_2F45C0);
                                }
                                else
                                {
                                  v23 = strstr(s, "CheckChain=");
                                  if ( v23 )
                                  {
                                    sscanf(v23 + 11, "%d", &dword_2F45C4);
                                  }
                                  else
                                  {
                                    v24 = strstr(s, "CommandMode=");
                                    if ( v24 )
                                    {
                                      sscanf(v24 + 12, "%d", &dword_2F45C8);
                                    }
                                    else
                                    {
                                      v25 = strstr(s, "ValidNonce1=");
                                      if ( v25 )
                                      {
                                        sscanf(v25 + 12, "%d", &dword_2F45D0);
                                      }
                                      else
                                      {
                                        v26 = strstr(s, "ValidNonce2=");
                                        if ( v26 )
                                        {
                                          sscanf(v26 + 12, "%d", &dword_2F45D4);
                                        }
                                        else
                                        {
                                          v27 = strstr(s, "ValidNonce3=");
                                          if ( v27 )
                                          {
                                            sscanf(v27 + 12, "%d", &dword_2F45D8);
                                          }
                                          else
                                          {
                                            v28 = strstr(s, "Pic_VOLTAGE=");
                                            if ( v28 )
                                            {
                                              sscanf(v28 + 12, "%d", &dword_2F45DC);
                                            }
                                            else
                                            {
                                              v29 = strstr(s, "Voltage1=");
                                              if ( v29 )
                                              {
                                                sscanf(v29 + 9, "%d", &dword_2F45E0);
                                              }
                                              else
                                              {
                                                v30 = strstr(s, "Voltage2=");
                                                if ( v30 )
                                                {
                                                  sscanf(v30 + 9, "%d", &dword_2F45E4);
                                                }
                                                else
                                                {
                                                  v31 = strstr(s, "Voltage3=");
                                                  if ( v31 )
                                                  {
                                                    sscanf(v31 + 9, "%d", &dword_2F45E8);
                                                  }
                                                  else
                                                  {
                                                    v32 = strstr(s, "final_voltage1=");
                                                    if ( v32 )
                                                    {
                                                      sscanf(v32 + 15, "%ud", &unk_2F45EC);
                                                    }
                                                    else
                                                    {
                                                      v33 = strstr(s, "final_voltage2=");
                                                      if ( v33 )
                                                      {
                                                        sscanf(v33 + 15, "%ud", &unk_2F45F0);
                                                      }
                                                      else
                                                      {
                                                        v34 = strstr(s, "final_voltage3=");
                                                        if ( v34 )
                                                        {
                                                          sscanf(v34 + 15, "%ud", &unk_2F45F4);
                                                        }
                                                        else
                                                        {
                                                          v35 = strstr(s, "freq_gap=");
                                                          if ( v35 )
                                                          {
                                                            sscanf(v35 + 9, "%ud", &unk_2F45F8);
                                                          }
                                                          else
                                                          {
                                                            v36 = strstr(s, "OpenCoreGap=");
                                                            if ( v36 )
                                                            {
                                                              sscanf(v36 + 12, "%d", &dword_2F45FC);
                                                            }
                                                            else
                                                            {
                                                              v37 = strstr(s, "CheckTemp=");
                                                              if ( v37 )
                                                              {
                                                                sscanf(v37 + 10, "%d", &dword_2F4600);
                                                              }
                                                              else
                                                              {
                                                                v38 = strstr(s, "IICPic=");
                                                                if ( v38 )
                                                                {
                                                                  sscanf(v38 + 7, "%d", &dword_2F4604);
                                                                }
                                                                else
                                                                {
                                                                  v39 = strstr(s, "Open_Core_Num1=");
                                                                  if ( v39 )
                                                                  {
                                                                    sscanf(v39 + 15, "%ud", &dword_2F4608);
                                                                  }
                                                                  else
                                                                  {
                                                                    v40 = strstr(s, "Open_Core_Num2=");
                                                                    if ( v40 )
                                                                    {
                                                                      sscanf(v40 + 15, "%ud", &dword_2F460C);
                                                                    }
                                                                    else
                                                                    {
                                                                      v41 = strstr(s, "Open_Core_Num3=");
                                                                      if ( v41 )
                                                                      {
                                                                        sscanf(v41 + 15, "%ud", &dword_2F4610);
                                                                      }
                                                                      else
                                                                      {
                                                                        v42 = strstr(s, "Open_Core_Num4=");
                                                                        if ( v42 )
                                                                        {
                                                                          sscanf(v42 + 15, "%ud", &dword_2F4614);
                                                                        }
                                                                        else
                                                                        {
                                                                          v43 = strstr(s, "DAC=");
                                                                          if ( v43 )
                                                                          {
                                                                            sscanf(v43 + 4, "%ud", &dword_2F4618);
                                                                          }
                                                                          else
                                                                          {
                                                                            v44 = strstr(s, "GetTempFrom=");
                                                                            if ( v44 )
                                                                            {
                                                                              sscanf(v44 + 12, "%ud", &dword_2F461C);
                                                                            }
                                                                            else
                                                                            {
                                                                              v45 = strstr(s, "TempSel=");
                                                                              if ( v45 )
                                                                              {
                                                                                sscanf(v45 + 8, "%ud", &dword_2F4620);
                                                                              }
                                                                              else
                                                                              {
                                                                                v46 = strstr(s, "TempSensor1=");
                                                                                if ( v46 )
                                                                                {
                                                                                  sscanf(v46 + 12, "%ud", &dword_2F4624);
                                                                                }
                                                                                else
                                                                                {
                                                                                  v47 = strstr(s, "TempSensor2=");
                                                                                  if ( v47 )
                                                                                  {
                                                                                    sscanf(
                                                                                      v47 + 12,
                                                                                      "%ud",
                                                                                      &dword_2F4628);
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v48 = strstr(s, "TempSensor3=");
                                                                                    if ( v48 )
                                                                                    {
                                                                                      sscanf(
                                                                                        v48 + 12,
                                                                                        "%ud",
                                                                                        &dword_2F462C);
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v49 = strstr(s, "TempSensor4=");
                                                                                      if ( v49 )
                                                                                      {
                                                                                        sscanf(
                                                                                          v49 + 12,
                                                                                          "%ud",
                                                                                          &dword_2F4630);
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v50 = strstr(
                                                                                                s,
                                                                                                "DefaultTempOffset=");
                                                                                        if ( v50 )
                                                                                        {
                                                                                          sscanf(v50 + 18, "%d", &v62);
                                                                                          v51 = v62;
                                                                                          if ( v62 >= 0 )
                                                                                            byte_2F4634 = v62;
                                                                                          else
                                                                                            v51 = -v62;
                                                                                          if ( v62 < 0 )
                                                                                          {
                                                                                            v62 = v51;
                                                                                            byte_2F4634 = -(char)v51;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          v52 = strstr(s, "year=");
                                                                                          if ( v52 )
                                                                                          {
                                                                                            sscanf(
                                                                                              v52 + 5,
                                                                                              "%d",
                                                                                              &dword_2F4658);
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            v53 = strstr(s, "month=");
                                                                                            if ( v53 )
                                                                                            {
                                                                                              sscanf(
                                                                                                v53 + 6,
                                                                                                "%d",
                                                                                                &dword_2F465C);
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              v54 = strstr(s, "date=");
                                                                                              if ( v54 )
                                                                                              {
                                                                                                sscanf(
                                                                                                  v54 + 5,
                                                                                                  "%d",
                                                                                                  &dword_2F4660);
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                v55 = strstr(s, "hour=");
                                                                                                if ( v55 )
                                                                                                {
                                                                                                  sscanf(
                                                                                                    v55 + 5,
                                                                                                    "%d",
                                                                                                    &dword_2F4664);
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  v56 = strstr(s, "minute=");
                                                                                                  if ( v56 )
                                                                                                  {
                                                                                                    sscanf(v56 + 7, "%d", &dword_2F4668);
                                                                                                  }
                                                                                                  else
                                                                                                  {
                                                                                                    v57 = strstr(s, "second=");
                                                                                                    if ( v57 )
                                                                                                    {
                                                                                                      sscanf(v57 + 7, "%d", &dword_2F466C);
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      v58 = strstr(s, "StartSensor=");
                                                                                                      if ( v58 )
                                                                                                      {
                                                                                                        sscanf(v58 + 12, "%d", &dword_2F4650);
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        v59 = strstr(s, "StartTemp=");
                                                                                                        if ( v59 )
                                                                                                        {
                                                                                                          v60 = v59 + 10;
                                                                                                          sscanf(v59 + 10, "%d", &dword_2F4654);
                                                                                                          sscanf(v60, "%d", &v63);
                                                                                                          v61 = v63;
                                                                                                          if ( v63 < 0 )
                                                                                                          {
                                                                                                            v63 = -v63;
                                                                                                            v61 = -(char)v63;
                                                                                                          }
                                                                                                          dword_2F4654 = v61;
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        goto LABEL_2;
      }
      v3 = (char *)&unk_82E6B;
      v4 = 0;
      v7 = v2[8];
      v5 = v2 + 8;
      LOBYTE(v6) = v7;
      while ( 1 )
      {
        *++v3 = v6;
        ++v4;
        v8 = (unsigned __int8)*++v5;
        v6 = v8;
        v9 = v8 == 13;
        if ( v8 != 13 )
          v9 = v6 == 10;
        if ( v9 )
          break;
        if ( v4 == 64 )
        {
          v4 = 65;
          break;
        }
      }
      *((_BYTE *)&cgpu + v4 + 604) = 0;
      printf("workdataPathPrefix:%s\n", &byte_82E6C);
      result = fgets(s, 1023, v0);
      if ( !result )
        goto LABEL_13;
    }
  }
LABEL_13:
  dword_2F45B8 = 84;
  dword_2F45CC = 1387;
  dword_2F45B4 = 114;
  return result;
}
// 82C10: using guessed type int cgpu;
// 82E6C: using guessed type char byte_82E6C;
// 2F458C: using guessed type int dword_2F458C;
// 2F4590: using guessed type int dword_2F4590;
// 2F4594: using guessed type int dword_2F4594;
// 2F4598: using guessed type int dword_2F4598;
// 2F459C: using guessed type int dword_2F459C;
// 2F45A0: using guessed type int dword_2F45A0;
// 2F45B4: using guessed type int dword_2F45B4;
// 2F45B8: using guessed type int dword_2F45B8;
// 2F45C0: using guessed type int dword_2F45C0;
// 2F45C4: using guessed type int dword_2F45C4;
// 2F45C8: using guessed type int dword_2F45C8;
// 2F45CC: using guessed type int dword_2F45CC;
// 2F45D0: using guessed type int dword_2F45D0;
// 2F45D4: using guessed type int dword_2F45D4;
// 2F45D8: using guessed type int dword_2F45D8;
// 2F45DC: using guessed type int dword_2F45DC;
// 2F45E0: using guessed type int dword_2F45E0;
// 2F45E4: using guessed type int dword_2F45E4;
// 2F45E8: using guessed type int dword_2F45E8;
// 2F45FC: using guessed type int dword_2F45FC;
// 2F4600: using guessed type int dword_2F4600;
// 2F4604: using guessed type int dword_2F4604;
// 2F4608: using guessed type int dword_2F4608;
// 2F460C: using guessed type int dword_2F460C;
// 2F4610: using guessed type int dword_2F4610;
// 2F4614: using guessed type int dword_2F4614;
// 2F4618: using guessed type int dword_2F4618;
// 2F461C: using guessed type int dword_2F461C;
// 2F4620: using guessed type int dword_2F4620;
// 2F4624: using guessed type int dword_2F4624;
// 2F4628: using guessed type int dword_2F4628;
// 2F462C: using guessed type int dword_2F462C;
// 2F4630: using guessed type int dword_2F4630;
// 2F4634: using guessed type char byte_2F4634;
// 2F4638: using guessed type int dword_2F4638;
// 2F463C: using guessed type int dword_2F463C;
// 2F4640: using guessed type int dword_2F4640;
// 2F4644: using guessed type int dword_2F4644;
// 2F4648: using guessed type int dword_2F4648;
// 2F464C: using guessed type int dword_2F464C;
// 2F4650: using guessed type int dword_2F4650;
// 2F4654: using guessed type int dword_2F4654;
// 2F4658: using guessed type int dword_2F4658;
// 2F465C: using guessed type int dword_2F465C;
// 2F4660: using guessed type int dword_2F4660;
// 2F4664: using guessed type int dword_2F4664;
// 2F4668: using guessed type int dword_2F4668;
// 2F466C: using guessed type int dword_2F466C;

//----- (0002A94C) --------------------------------------------------------
int receive_func()
{
  int v0; // r10
  int v1; // r4
  int v3; // r5
  int v4; // r9
  unsigned int v5; // r1
  int v6; // r7
  char *v7; // r8
  int v8; // r0
  unsigned int v9; // r3
  int v10; // r2
  _DWORD *v11; // lr
  unsigned int v12; // r3
  int v13; // r2
  unsigned int v14; // lr
  unsigned int v15; // r8
  int v16; // r12
  unsigned int v17; // r3
  unsigned int v18; // r0
  unsigned int v19; // r1
  int v20; // r9
  int v21; // lr
  char *v22; // r7
  int v23; // r0
  int v24; // r3
  int v25; // r2
  char *v26; // r8
  unsigned int v27; // [sp+0h] [bp-40h]
  int v28; // [sp+8h] [bp-38h]
  unsigned int v29; // [sp+8h] [bp-38h]
  int v30; // [sp+Ch] [bp-34h]
  unsigned int v31; // [sp+10h] [bp-30h] BYREF
  unsigned int v32; // [sp+14h] [bp-2Ch]

  v31 = 0;
  v32 = 0;
  v0 = 0;
  memset(&repeated_nonce_id, 255, 16384u);
  memset(&last_nonce, 0, 64u);
  memset(&llast_nonce, 0, 64u);
  memset(&work_id, 0, 64u);
  v27 = 0;
  memset(&m_nonce, 0, 64u);
LABEL_2:
  while ( 1 )
  {
    v1 = (unsigned __int8)ExitFlag;
    if ( ExitFlag )
      return 0;
    while ( !start_receive )
    {
      v0 = (unsigned __int8)start_receive;
      v31 = (unsigned __int8)start_receive;
      v27 = (unsigned __int8)start_receive;
      v32 = (unsigned __int8)start_receive;
      memset(&repeated_nonce_id, 255, 16384u);
      memset(&last_nonce, (unsigned __int8)start_receive, 64u);
      memset(&llast_nonce, (unsigned __int8)start_receive, 64u);
      memset(&work_id, (unsigned __int8)start_receive, 64u);
      memset(&m_nonce, (unsigned __int8)start_receive, 64u);
      usleep(100000u);
      v1 = (unsigned __int8)ExitFlag;
      if ( ExitFlag )
        return 0;
    }
    v3 = get_nonce_number_in_fifo() & 0x1FF;
    if ( v3 )
    {
      while ( 1 )
      {
        get_return_nonce(&v31);
        if ( (v31 & 2147483648) == 0 )
        {
          insert_reg_data((int)&v31);
        }
        else if ( gBegin_get_nonce && (v31 & 0x80) != 0 )
        {
          v4 = v31 & 0xF;
          v5 = v32;
          v6 = 4 * v4;
          v7 = (char *)&unk_2F7A88 + v6;
          v8 = *((_DWORD *)&unk_2F7A88 + v4 + 762);
          *(_DWORD *)((char *)&unk_2F7A88 + v6 + 3176) = HIWORD(v31) & 0x7FFF;
          if ( v5 == v8 || v5 == *((_DWORD *)v7 + 778) )
          {
            ++*(_DWORD *)((char *)&unk_2F7A88 + v6 + 3308);
          }
          else
          {
            if ( dword_2F44D0 == 1 )
            {
              if ( dword_2F87C4 <= 64 )
              {
                v0 = v5 & 0x3F;
                v27 = v0;
                goto LABEL_25;
              }
              if ( (unsigned int)(dword_2F87C4 - 65) > 63 )
              {
                printf("%s: conf.core = %d, but it is error\n", "receive_func", dword_2F87C4);
                v8 = *((_DWORD *)v7 + 762);
                v5 = v32;
                goto LABEL_25;
              }
              v27 = v5 & 0x7F;
              if ( v27 <= 56 )
              {
                v0 = v5 & 0x7F;
                goto LABEL_25;
              }
              if ( (v5 & 0x7F) - 64 > 63 )
              {
LABEL_25:
                v14 = dword_2F8820;
                v15 = dword_2F8824;
                v16 = dword_2F8828;
                v28 = dword_2F882C;
                if ( !v0 )
                {
                  v10 = 0;
                  goto LABEL_19;
                }
              }
              else
              {
                v14 = dword_2F8820;
                v0 = (unsigned __int8)((v5 & 0x7F) - 7);
                v15 = dword_2F8824;
                v16 = dword_2F8828;
                v28 = dword_2F882C;
              }
              v10 = 0;
              v30 = v8;
              v17 = 0;
              v18 = v28;
              v29 = v5;
              v19 = v16;
              while ( 2 )
              {
                while ( v17 > 31 )
                {
                  if ( v17 - 32 > 31 )
                  {
                    if ( v17 - 64 > 31 )
                    {
                      if ( (v18 & 1) != 0 )
                      {
                        v18 >>= 1;
                        v10 = (unsigned __int8)(v10 + 1);
                      }
                      else
                      {
                        v18 >>= 1;
                      }
                    }
                    else if ( (v19 & 1) != 0 )
                    {
                      v19 >>= 1;
                      v10 = (unsigned __int8)(v10 + 1);
                    }
                    else
                    {
                      v19 >>= 1;
                    }
                    goto LABEL_30;
                  }
                  ++v17;
                  if ( (v15 & 1) != 0 )
                  {
                    v15 >>= 1;
                    v10 = (unsigned __int8)(v10 + 1);
                  }
                  else
                  {
                    v15 >>= 1;
                  }
                  if ( v17 == v0 )
                  {
LABEL_37:
                    v8 = v30;
                    v5 = v29;
                    goto LABEL_19;
                  }
                }
                if ( (v14 & 1) != 0 )
                {
                  v14 >>= 1;
                  v10 = (unsigned __int8)(v10 + 1);
                }
                else
                {
                  v14 >>= 1;
                }
LABEL_30:
                if ( ++v17 == v0 )
                  goto LABEL_37;
                continue;
              }
            }
            v9 = (unsigned int)((2863311531u * (unsigned __int64)HIBYTE(v5)) >> 32) >> 1;
            if ( v9 <= 83 )
            {
              v0 = (unsigned __int8)v9;
              v10 = (unsigned __int8)v9;
LABEL_19:
              v11 = (_DWORD *)((char *)&unk_2F7A88 + v6);
              v12 = *(_DWORD *)((char *)&unk_2F7A88 + v6 + 3176);
              v11[778] = v8;
              v11[762] = v5;
              if ( v12 <= 4999 )
              {
                v13 = *(_DWORD *)(cgpu[v10 + 167] + 52 * v12 + 4);
                v11[810] = v13;
                if ( v13 == v5 )
                {
                  v20 = v4 << 8;
                  v21 = 4 * (v20 + v0);
                  if ( v12 == *(_DWORD *)((char *)&unk_2F36A8 + v21 + 4040) )
                  {
                    ++*(_DWORD *)((char *)&unk_6FC638 + v6 + 644);
                  }
                  else
                  {
                    *(_DWORD *)((char *)&unk_2F36A8 + v21 + 4040) = v12;
                    v22 = (char *)&unk_2FBE68 + v6;
                    v23 = dword_2F44D0;
                    v24 = *((_DWORD *)v22 + 644);
                    ++*(_DWORD *)((char *)&unk_2F7A88 + v21 + 3568);
                    v25 = total_valid_nonce_num;
                    *((_DWORD *)v22 + 644) = v24 + 1;
                    total_valid_nonce_num = v25 + 1;
                    if ( v23 != 1 )
                    {
                      if ( dword_2F87C4 > 64 )
                      {
                        if ( (unsigned int)(dword_2F87C4 - 65) > 63 )
                        {
                          printf("%s: conf.core = %d, but it is error\n", "receive_func", dword_2F87C4);
                        }
                        else
                        {
                          v27 = v5 & 0x7F;
                          if ( v27 - 64 <= 63 )
                            v27 = (unsigned __int8)((v5 & 0x7F) - 7);
                        }
                      }
                      else
                      {
                        v27 = v5 & 0x3F;
                      }
                      v26 = (char *)&unk_2FBE68 + 1024 * (v20 + v0) + 4 * v27;
                      ++*((_DWORD *)v26 + 661);
                    }
                  }
                }
                else
                {
                  ++*(_DWORD *)((char *)&unk_6FC638 + v6 + 708);
                }
              }
            }
          }
        }
        if ( v3 == ++v1 )
          goto LABEL_2;
      }
    }
    usleep(1000u);
  }
}
// 82C10: using guessed type int cgpu[150];
// 2F44D0: using guessed type int dword_2F44D0;
// 2F8770: using guessed type char start_receive;
// 2F8771: using guessed type char gBegin_get_nonce;
// 2F87C4: using guessed type int dword_2F87C4;
// 2F8820: using guessed type int dword_2F8820;
// 2F8824: using guessed type int dword_2F8824;
// 2F8828: using guessed type int dword_2F8828;
// 2F882C: using guessed type int dword_2F882C;
// 2FC8B8: using guessed type int total_valid_nonce_num;
// 6FC93C: using guessed type char ExitFlag;

//----- (0002ACD0) --------------------------------------------------------
int doTestBoard_isra_0()
{
  int *v0; // r6
  int v1; // r5
  int v2; // r0
  int v3; // r6
  int *v4; // r4
  int v5; // r7
  char *v6; // r0
  char *v7; // r3
  int v8; // r4
  char *v9; // r9
  int *v10; // r7
  int v11; // t1
  char ChainAsicNum; // r0
  int v13; // r3
  int *v14; // r5
  int v15; // r4
  int v16; // t1
  char *v17; // r4
  char *v18; // r3
  int *v19; // r0
  char *v20; // r1
  char v21; // t1
  int v22; // r10
  char *v23; // r7
  int *v24; // r8
  int *v25; // r6
  int v26; // r3
  int v27; // r4
  int v28; // r5
  int v29; // r4
  int *v30; // r5
  int v31; // r10
  int v32; // r3
  int v33; // r11
  char *v34; // r3
  int v35; // r2
  char v36; // t1
  int v37; // r3
  char *v38; // r2
  char v39; // t1
  unsigned int *v40; // lr
  int *v41; // r11
  int i; // r12
  int v43; // r2
  int v44; // r3
  int v45; // r2
  int *v46; // r3
  int v47; // r0
  int v48; // r2
  int v49; // t1
  int v50; // r4
  char *v51; // r5
  int *v52; // r6
  int v53; // t1
  int v54; // r6
  int v55; // r3
  int v56; // r5
  int v57; // r1
  int v58; // r4
  int v59; // r3
  int v60; // r11
  int v61; // r2
  int v62; // r3
  char *v63; // r1
  char v64; // t1
  _DWORD *v65; // r2
  char v66; // t1
  _DWORD *v67; // r3
  int *v68; // r12
  _DWORD *v69; // lr
  int v70; // r1
  int *v71; // r12
  int v72; // r1
  int v73; // r3
  int v74; // r2
  int v75; // r3
  _DWORD *v76; // r6
  _DWORD *v77; // r5
  int v78; // r4
  int v79; // r3
  bool v80; // nf
  int v81; // r3
  int v82; // r2
  const char *v83; // r1
  int v84; // r7
  int v85; // r9
  int v86; // r2
  int v87; // r10
  int *v88; // r5
  int j; // r4
  int v90; // t1
  int spins; // r1
  int v92; // r2
  bool v93; // cc
  int v94; // r2
  int v95; // r3
  bool v96; // cc
  int v97; // r2
  int v98; // r4
  int v99; // r3
  int v100; // r2
  int ChainAsicFreqIndex; // r0
  int freqvalue_by_index; // r0
  int v103; // r4
  int *v104; // r10
  int v105; // t1
  int v106; // r2
  int v107; // r3
  char *v108; // r7
  char *v109; // r8
  int v110; // r10
  int v111; // r4
  int v112; // r3
  char *v113; // r3
  int v114; // t1
  char *v115; // r3
  int v116; // t1
  int nonce_fifo_interrupt; // r0
  int *v119; // [sp+4h] [bp-9E4h]
  int *v120; // [sp+4h] [bp-9E4h]
  int *v121; // [sp+4h] [bp-9E4h]
  int v122; // [sp+8h] [bp-9E0h]
  int *v123; // [sp+8h] [bp-9E0h]
  int *v124; // [sp+Ch] [bp-9DCh]
  int v125; // [sp+10h] [bp-9D8h]
  int *v126; // [sp+14h] [bp-9D4h]
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *v127; // [sp+14h] [bp-9D4h]
  char *v128; // [sp+18h] [bp-9D0h]
  int v129; // [sp+1Ch] [bp-9CCh]
  int v130; // [sp+20h] [bp-9C8h]
  int *v131; // [sp+28h] [bp-9C0h]
  _DWORD *v132; // [sp+3Ch] [bp-9ACh]
  int *v133; // [sp+40h] [bp-9A8h]
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *p_spins; // [sp+44h] [bp-9A4h]
  int *v135; // [sp+48h] [bp-9A0h]
  int *v136; // [sp+4Ch] [bp-99Ch]
  int *v137; // [sp+50h] [bp-998h]
  int v138; // [sp+54h] [bp-994h]
  const char *v139[5]; // [sp+5Ch] [bp-98Ch] BYREF
  char v140[52]; // [sp+70h] [bp-978h] BYREF
  _DWORD v141[13]; // [sp+A4h] [bp-944h] BYREF
  int v142[13]; // [sp+D8h] [bp-910h] BYREF
  int v143[13]; // [sp+10Ch] [bp-8DCh] BYREF
  char v144; // [sp+140h] [bp-8A8h] BYREF
  char v145; // [sp+17Ch] [bp-86Ch] BYREF
  _DWORD v146[15]; // [sp+180h] [bp-868h] BYREF
  char v147; // [sp+1BCh] [bp-82Ch] BYREF
  char s[1024]; // [sp+1C0h] [bp-828h] BYREF
  char v149[1064]; // [sp+5C0h] [bp-428h] BYREF

  v0 = &dword_2F44F8;
  v131 = &dword_2F44F8;
  memset(&asic_nonce_num, 0, 16384u);
  memset(&asic_core_nonce_num, 0, 4194304u);
  memset(&repeated_nonce_id, 255, 16384u);
  memset(err_nonce_num, 0, sizeof(err_nonce_num));
  memset(last_nonce_num, 0, sizeof(last_nonce_num));
  memset(repeated_nonce_num, 0, sizeof(repeated_nonce_num));
  memset(valid_nonce_num, 0, sizeof(valid_nonce_num));
  memset(send_work_num, 0, 64u);
  v1 = 0;
  start_receive = 1;
  total_valid_nonce_num = 0;
  do
  {
    v2 = v1++;
    v0[1] = getChainExistFlag(v2);
    ++v0;
  }
  while ( v1 != 16 );
  v3 = dword_2F87E0;
  if ( dword_2F87E0 > 0 )
  {
    v4 = (int *)&unk_2F40A8;
    v5 = conf;
    v6 = (char *)&unk_830A8;
    do
    {
      if ( v5 > 0 )
      {
        v7 = v6;
        do
        {
          *((_DWORD *)v7 + 1) = 0;
          v7 += 4;
        }
        while ( v7 != &v6[4 * v5] );
      }
      v4[1] = 0;
      ++v4;
      v6 += 20000;
    }
    while ( v4 != &cgpu[v3 + 640294] );
  }
  v8 = 0;
  dword_2F44B0 = 0;
  unk_2F44B4 = 0;
  unk_2F44B8 = 0;
  unk_2F44BC = 0;
  dword_2F44F8 = 0;
  v9 = &byte_2F4540;
  dword_2F44D0 = 84;
  unk_2F44EC = 1387;
  unk_2F44D4 = v3;
  unk_2F44D8 = dword_2F87C4;
  v10 = &dword_2F44F8;
  pthread_mutex_lock(&opencore_readtemp_mutex);
  do
  {
    while ( 1 )
    {
      v11 = v10[1];
      ++v10;
      if ( v11 )
      {
        ChainAsicNum = getChainAsicNum(v8);
        v13 = (unsigned __int8)chain_need_opencore[v8];
        *v9 = ChainAsicNum;
        if ( v13 )
        {
          sprintf(s, "do open core on Chain[%d]...\n", v8);
          if ( showLogToKernelLog )
            writeInitLogFile(s);
          open_core_one_chain(v8, 1);
          sprintf(s, "Done open core on Chain[%d]!\n", v8);
          if ( showLogToKernelLog )
            break;
        }
      }
      ++v8;
      ++v9;
      if ( v10 == (int *)&unk_2F4538 )
        goto LABEL_18;
    }
    ++v8;
    writeInitLogFile(s);
    ++v9;
  }
  while ( v10 != (int *)&unk_2F4538 );
LABEL_18:
  pthread_mutex_unlock(&opencore_readtemp_mutex);
  if ( !gBegin_get_nonce )
  {
    puts("clement2 set_nonce_fifo_interrupt");
    nonce_fifo_interrupt = get_nonce_fifo_interrupt();
    set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
    gBegin_get_nonce = 1;
  }
  v14 = &dword_2F44F8;
  v15 = 0;
  do
  {
    while ( 1 )
    {
      v16 = v14[1];
      ++v14;
      if ( v16 )
        break;
      ++v15;
      if ( v14 == (int *)&unk_2F4538 )
        goto LABEL_26;
    }
    sprintf(s, "start send works on chain[%d]\n", v15);
    if ( showLogToKernelLog )
      writeInitLogFile(s);
    StartSendFlag[v15++] = 1;
  }
  while ( v14 != (int *)&unk_2F4538 );
LABEL_26:
  ClearWorkFIFOAndResetRegisters();
  v17 = (char *)&unk_6FC98F;
  memset(v140, 0, sizeof(v140));
  v140[0] = -1;
  memset(v142, 0, sizeof(v142));
  memset(v143, 0, sizeof(v143));
  v18 = &v145;
  v19 = &v143[12];
  v20 = (char *)v139 + 3;
  do
  {
    v21 = *++v17;
    *((_DWORD *)v18 + 1) = 0;
    v18 += 4;
    v19[1] = 0;
    ++v19;
    *++v20 = v21;
  }
  while ( v18 != &v147 );
  v22 = 0;
  do
  {
    v23 = &v144;
    v24 = v146;
    v25 = send_work_num;
    v126 = chain_DataCount;
    v119 = &dword_2F44F8;
    v122 = 0;
    while ( 1 )
    {
      v26 = v119[1];
      ++v119;
      if ( !v26 || !*((_BYTE *)&v139[1] + v122) )
        goto LABEL_50;
      v27 = *(_DWORD *)v23;
      if ( *(int *)v23 <= 83 )
        break;
      v73 = *v24;
      *(_DWORD *)v23 = 0;
      v74 = *v126;
      *v24 = ++v73;
      if ( v73 >= v74 )
LABEL_48:
        *((_BYTE *)&v139[1] + v122) = 0;
      if ( v22 > 2000 )
        goto LABEL_83;
LABEL_50:
      v23 += 4;
      ++v24;
      ++v25;
      ++v122;
      ++v126;
      if ( v119 == (int *)&unk_2F4538 )
        goto LABEL_51;
    }
    v28 = v27 + 167;
    v29 = v27 + 1;
    v30 = &cgpu[v28];
    while ( (get_buffer_space() & (1 << v122)) != 0 )
    {
      v31 = *v24;
      if ( dword_2F44F8 )
      {
        v32 = *v30;
        memset(v142, 0, 13);
        v33 = v32 + 52 * v31;
        memset(v140, 0, sizeof(v140));
        v34 = &v140[3];
        v35 = v33 + 19;
        v140[1] = v122 | 0x80;
        v140[0] = 1;
        do
        {
          v36 = *(_BYTE *)++v35;
          *++v34 = v36;
        }
        while ( v34 != &v140[35] );
        v37 = v33 + 7;
        v38 = &v140[39];
        do
        {
          v39 = *(_BYTE *)++v37;
          *++v38 = v39;
        }
        while ( v37 != v33 + 19 );
        v40 = (unsigned int *)v140;
        v41 = v142;
        for ( i = 1; ; ++i )
        {
          *v41++ = _byteswap_ulong(*v40);
          if ( i == 10 )
          {
            v142[9] = v31;
          }
          else if ( i == 13 )
          {
            pthread_mutex_lock(&opencore_readtemp_mutex);
            set_TW_write_command((int)v142);
            pthread_mutex_unlock(&opencore_readtemp_mutex);
            v43 = v29;
            *(_DWORD *)v23 = v29;
            goto LABEL_46;
          }
          ++v40;
        }
      }
      v59 = *v30;
      v143[0] = dword_2F44F8;
      v143[1] = dword_2F44F8;
      v60 = v59 + 52 * v31;
      v143[2] = dword_2F44F8;
      LOBYTE(v143[3]) = dword_2F44F8;
      memset(v141, dword_2F44F8, sizeof(v141));
      v61 = v60 + 7;
      v62 = v60 + 19;
      v63 = (char *)&v141[1] + 3;
      v141[1] = v31;
      BYTE1(v141[0]) = v122 | 0x80;
      LOBYTE(v141[0]) = 1;
      do
      {
        v64 = *(_BYTE *)++v61;
        *++v63 = v64;
      }
      while ( v61 != v62 );
      v65 = (_DWORD *)((char *)&v141[4] + 3);
      do
      {
        v66 = *(_BYTE *)++v62;
        *((_BYTE *)v65 + 1) = v66;
        v65 = (_DWORD *)((char *)v65 + 1);
      }
      while ( v65 != (_DWORD *)((char *)&v141[12] + 3) );
      v67 = v141;
      v68 = &v143[1];
      v69 = v141;
      v143[1] = v31;
      v143[0] = (((unsigned __int8)v122 | 0x80) << 16) | 0x1000000;
      do
      {
        v70 = *((unsigned __int8 *)v69++ + 9);
        v68[1] = *((unsigned __int8 *)v69 + 7) | (v70 << 16) | (*((unsigned __int8 *)v69 + 4) << 24) | (*((unsigned __int8 *)v69 + 6) << 8);
        ++v68;
      }
      while ( v69 != &v141[3] );
      v71 = &v143[4];
      do
      {
        v72 = *((unsigned __int8 *)v67++ + 21);
        v71[1] = *((unsigned __int8 *)v67 + 19) | (v72 << 16) | (*((unsigned __int8 *)v67 + 16) << 24) | (*((unsigned __int8 *)v67 + 18) << 8);
        ++v71;
      }
      while ( v67 != &v141[8] );
      pthread_mutex_lock(&opencore_readtemp_mutex);
      set_TW_write_command_vil(v143);
      pthread_mutex_unlock(&opencore_readtemp_mutex);
      v43 = v29;
      *(_DWORD *)v23 = v29;
LABEL_46:
      ++v29;
      ++v30;
      v22 = 0;
      ++*v25;
      if ( v43 == 84 )
      {
        v44 = *v24;
        *(_DWORD *)v23 = 0;
        v45 = *v126;
        *v24 = ++v44;
        if ( v44 < v45 )
          goto LABEL_50;
        goto LABEL_48;
      }
    }
    if ( ++v22 <= 2000 )
      goto LABEL_50;
LABEL_83:
    strcpy(v149, "Fatal Error: send work timeout\n");
    if ( showLogToKernelLog )
      writeInitLogFile(v149);
LABEL_51:
    usleep(5000u);
    v46 = &dword_2F44F8;
    v47 = 1;
    v48 = 0;
    do
    {
      v49 = v46[1];
      ++v46;
      if ( v49 && StartSendFlag[v48] && v146[v48] < chain_DataCount[v48] )
        v47 = 0;
      ++v48;
    }
    while ( v46 != (int *)&unk_2F4538 );
  }
  while ( !v47 );
  v50 = 0;
  v51 = StartSendFlag;
  v52 = &dword_2F44F8;
  do
  {
    while ( 1 )
    {
      v53 = v52[1];
      ++v52;
      if ( v53 )
      {
        if ( *v51 )
        {
          *v51 = 0;
          sprintf(v149, "get send work num :%d on Chain[%d]\n", send_work_num[v50], v50);
          if ( showLogToKernelLog )
            break;
        }
      }
      ++v50;
      ++v51;
      if ( v52 == (int *)&unk_2F4538 )
        goto LABEL_64;
    }
    ++v50;
    writeInitLogFile(v149);
    ++v51;
  }
  while ( v52 != (int *)&unk_2F4538 );
LABEL_64:
  v54 = 0;
  v120 = &dword_2F44F8;
  do
  {
    v55 = v120[1];
    ++v120;
    if ( v55 )
    {
      sprintf(s, "wait recv nonce on chain[%d]\n", v54);
      if ( showLogToKernelLog )
        writeInitLogFile(s);
      v56 = 0;
      v57 = 0;
      while ( 1 )
      {
        v58 = valid_nonce_num[v54];
        if ( v58 >= chain_ValidNonce[v54] )
          break;
        if ( v58 == v57 )
        {
          ++v56;
          usleep((__useconds_t)&loc_1869E + 2);
          if ( v56 == 20 )
            break;
          v57 = v58;
        }
        else
        {
          usleep((__useconds_t)&loc_1869E + 2);
          v56 = 0;
          v57 = v58;
        }
      }
    }
    ++v54;
  }
  while ( v120 != (int *)&unk_2F4538 );
  v136 = &last_result;
  v137 = &total_valid_nonce_num;
  v132 = &asic_nonce_num;
  v135 = &last_result_opencore;
  v139[0] = "get nonces on chain[%d]\n";
  p_spins = (union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *)&iic_mutex.__spins;
  v130 = 0;
  v133 = &dword_2F44F8;
  gBegin_get_nonce = 0;
  start_receive = 0;
  while ( 2 )
  {
    v75 = v133[1];
    ++v133;
    if ( v75 )
    {
      sprintf(s, v139[0], v130);
      if ( showLogToKernelLog )
        writeInitLogFile(s);
      v125 = chain_PassCount[v130];
      v138 = chain_ValidNonce[v130];
      puts("\n------------------------------------------------------------------------------------------------------");
      if ( dword_2F87E8 )
        puts("Command mode is FIL");
      else
        puts("Command mode is VIL");
      LOWORD(v76) = (unsigned __int16)&unk_2F36A8;
      if ( dword_2F44D0 == 1 )
      {
        HIWORD(v76) = (unsigned int)&unk_2F36A8 >> 16;
        printf("Open core number : Conf.OpenCoreNum1 = %ud = 0x%x\n", v76[984], v76[984]);
        printf("Open core number : Conf.OpenCoreNum2 = %ud = 0x%x\n", v76[985], v76[985]);
        printf("Open core number : Conf.OpenCoreNum3 = %ud = 0x%x\n", v76[986], v76[986]);
        printf("Open core number : Conf.OpenCoreNum4 = %ud = 0x%x\n", v76[987], v76[987]);
        v129 = v76[963];
      }
      else
      {
        v129 = dword_2F44D0;
        HIWORD(v76) = 47;
      }
      sprintf(v149, "require nonce number:%d\n", v125);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      sprintf(v149, "require validnonce number:%d\n", v138);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      if ( v129 > 0 )
      {
        v77 = v132;
        v78 = 0;
        v79 = dword_2F44D0;
        do
        {
          while ( 1 )
          {
            v83 = "asic[%02d]=%02d\t";
            if ( v79 == 1 )
              v83 = "core[%02d]=%02d\t";
            sprintf(v149, v83, v78, *v77);
            if ( showLogToKernelLog )
              writeInitLogFile(v149);
            v80 = -v78 < 0;
            v81 = v78 & 7;
            v82 = -v78++ & 7;
            if ( !v80 )
              v81 = -v82;
            ++v77;
            if ( v81 == 7 )
            {
              strcpy(v149, "\n");
              if ( showLogToKernelLog )
                break;
            }
            v79 = dword_2F44D0;
            if ( v78 == v129 )
              goto LABEL_115;
          }
          writeInitLogFile(v149);
          v79 = dword_2F44D0;
        }
        while ( v78 != v129 );
      }
LABEL_115:
      if ( (int)v76[1002] <= 0 || dword_2F44D0 == 1 )
      {
        strcpy(v149, "\n\n");
        if ( showLogToKernelLog )
          goto LABEL_181;
        goto LABEL_179;
      }
      v84 = v125 / v76[963];
      sprintf(v149, "\n\n\nBelow ASIC's core didn't receive all the nonce, they should receive %d nonce each!\n\n", v84);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      if ( v129 <= 0 )
      {
        strcpy(v149, "\n\n");
        if ( showLogToKernelLog )
          goto LABEL_181;
        strcpy(v149, "\n\n");
      }
      else
      {
        v85 = 0;
        v128 = (char *)(v132 - 1);
        v127 = p_spins;
        v123 = v135;
        v124 = v136;
        v121 = v137;
        do
        {
          v86 = v76[963];
          v87 = 0;
          if ( v86 > 0 )
          {
            v88 = v121;
            for ( j = 0; j < v86; ++j )
            {
              while ( 1 )
              {
                v90 = v88[1];
                ++v88;
                if ( v90 <= 0 && !isDisabledCore(v130, v85, j) )
                  break;
                v86 = v76[963];
                ++j;
                ++v87;
                if ( j >= v86 )
                  goto LABEL_127;
              }
              v86 = v76[963];
            }
          }
LABEL_127:
          spins = v127[1].__spins;
          ++v127;
          v92 = v86 - spins;
          v93 = spins < 14;
          if ( spins <= 14 )
            v93 = v87 < v92;
          v94 = !v93;
          if ( v93 )
            *v123 = v94;
          else
            *v123 = 1;
          v95 = *((_DWORD *)v128 + 1);
          v128 += 4;
          v96 = spins < 14;
          if ( spins <= 14 )
            v96 = v95 < v125 - spins * v84;
          if ( v96 )
          {
            v97 = 0;
            spins = (int)v124;
          }
          else
          {
            v97 = (int)v124;
          }
          if ( !v96 )
          {
            spins = v97;
            v97 = 1;
          }
          *(_DWORD *)spins = v97;
          if ( v125 > v95 )
          {
            sprintf(v149, "asic[%02d]=%02d\n", v85);
            if ( showLogToKernelLog )
              writeInitLogFile(v149);
            if ( (int)v76[963] > 0 )
            {
              v103 = 0;
              v104 = v121;
              do
              {
                while ( 1 )
                {
                  v105 = v104[1];
                  ++v104;
                  v106 = v103++;
                  v107 = v105;
                  if ( v84 != v105 )
                  {
                    sprintf(v149, "core[%03d]=%d\t", v106, v107);
                    if ( showLogToKernelLog )
                      break;
                  }
                  if ( v103 >= v76[963] )
                    goto LABEL_160;
                }
                writeInitLogFile(v149);
              }
              while ( v103 < v76[963] );
            }
LABEL_160:
            strcpy(v149, "\n\n");
            if ( showLogToKernelLog )
              writeInitLogFile(v149);
          }
          ++v85;
          v121 += 256;
          ++v124;
          ++v123;
        }
        while ( v129 != v85 );
        strcpy(v149, "\n\n");
        if ( !showLogToKernelLog )
        {
LABEL_145:
          v98 = 0;
          do
          {
            while ( 1 )
            {
              ChainAsicFreqIndex = getChainAsicFreqIndex(v130, v98);
              freqvalue_by_index = get_freqvalue_by_index(ChainAsicFreqIndex);
              sprintf(v149, "freq[%02d]=%d\t", v98, freqvalue_by_index);
              if ( showLogToKernelLog )
                writeInitLogFile(v149);
              v80 = -v98 < 0;
              v99 = v98 & 7;
              v100 = -v98++ & 7;
              if ( !v80 )
                v99 = -v100;
              if ( v99 == 7 )
              {
                strcpy(v149, "\n");
                if ( showLogToKernelLog )
                  break;
              }
              if ( v129 <= v98 )
                goto LABEL_164;
            }
            writeInitLogFile(v149);
          }
          while ( v129 > v98 );
          goto LABEL_164;
        }
LABEL_181:
        writeInitLogFile(v149);
LABEL_179:
        if ( v129 > 0 )
          goto LABEL_145;
LABEL_164:
        strcpy(v149, "\n\n");
        if ( showLogToKernelLog )
          writeInitLogFile(v149);
      }
      sprintf(v149, "total valid nonce number:%d\n", valid_nonce_num[v130]);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      sprintf(v149, "total send work number:%d\n", send_work_num[v130]);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      sprintf(v149, "require valid nonce number:%d\n", v138);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      sprintf(v149, "repeated_nonce_num:%d\n", repeated_nonce_num[v130]);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      sprintf(v149, "err_nonce_num:%d\n", err_nonce_num[v130]);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
      sprintf(v149, "last_nonce_num:%d\n", last_nonce_num[v130]);
      if ( showLogToKernelLog )
        writeInitLogFile(v149);
    }
    ++v130;
    v132 += 256;
    v137 += 65536;
    v136 += 256;
    v135 += 256;
    p_spins += 256;
    if ( v133 != (int *)&unk_2F4538 )
      continue;
    break;
  }
  v108 = (char *)&unk_6FCA1C;
  v109 = (char *)&unk_700A1C;
  v110 = 1;
  v111 = 0;
  do
  {
    v112 = v131[1];
    ++v131;
    if ( v112 )
    {
      v113 = v109;
      do
      {
        v114 = *((_DWORD *)v113 + 1);
        v113 += 4;
        if ( !v114 )
        {
          sprintf(s, "chain[%d]: some chip cores are not opened FAILED!\n", v111);
          if ( showLogToKernelLog )
            writeInitLogFile(s);
          isChainAllCoresOpened[v111] = 0;
          chain_need_opencore[v111] = 1;
          goto LABEL_191;
        }
      }
      while ( v109 + 336 != v113 );
      sprintf(s, "chain[%d]: All chip cores are opened OK!\n", v111);
      if ( showLogToKernelLog )
        writeInitLogFile(s);
      isChainAllCoresOpened[v111] = 1;
      chain_need_opencore[v111] = 0;
LABEL_191:
      v115 = v108;
      do
      {
        v116 = *((_DWORD *)v115 + 1);
        v115 += 4;
        if ( !v116 )
        {
          sprintf(s, "Test Patten on chain[%d]: FAILED!\n", v111);
          if ( showLogToKernelLog )
            writeInitLogFile(s);
          saveChainTestPattenResult(v111, 0);
          v110 = 0;
          search_freq_result[v111] = 0;
          goto LABEL_197;
        }
      }
      while ( v108 + 336 != v115 );
      sprintf(s, "Test Patten on chain[%d]: OK!\n", v111);
      if ( showLogToKernelLog )
        writeInitLogFile(s);
      saveChainTestPattenResult(v111, 1);
    }
LABEL_197:
    ++v111;
    v108 += 1024;
    v109 += 1024;
  }
  while ( v131 != (int *)&unk_2F4538 );
  return v110;
}
// 7DFD8: using guessed type char showLogToKernelLog;
// 82C10: using guessed type int cgpu[150];
// 2F44B0: using guessed type int dword_2F44B0;
// 2F44D0: using guessed type int dword_2F44D0;
// 2F44F8: using guessed type int dword_2F44F8;
// 2F4540: using guessed type char byte_2F4540;
// 2F8770: using guessed type char start_receive;
// 2F8771: using guessed type char gBegin_get_nonce;
// 2F8774: using guessed type _DWORD last_nonce_num[16];
// 2F87B4: using guessed type int conf;
// 2F87C4: using guessed type int dword_2F87C4;
// 2F87E0: using guessed type int dword_2F87E0;
// 2F87E8: using guessed type int dword_2F87E8;
// 2FC878: using guessed type _DWORD valid_nonce_num[16];
// 2FC8B8: using guessed type int total_valid_nonce_num;
// 6FC8BC: using guessed type _DWORD repeated_nonce_num[16];
// 6FC8FC: using guessed type _DWORD err_nonce_num[16];
// 6FC940: using guessed type int send_work_num[];
// 6FC9A0: using guessed type int chain_DataCount[15];
// 6FC9E0: using guessed type int chain_ValidNonce[15];
// 6FCA20: using guessed type int last_result;
// 700A20: using guessed type int last_result_opencore;
// 704A20: using guessed type int chain_PassCount[16];
// 2ACD0: using guessed type _DWORD var_868[15];

//----- (0002BB38) --------------------------------------------------------
int process_config()
{
  bool v0; // zf
  int v1; // r0
  int v2; // r3
  int v3; // r1
  int v4; // r1
  int v5; // r1
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  dword_2F87E8 = dword_2F45C8;
  dword_2F8838 = dword_2F4620;
  dword_2F8834 = dword_2F461C;
  if ( dword_2F45C8 == 1 )
  {
    if ( dword_2F461C != 1 )
      goto LABEL_5;
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(s, "Can't get temperature from ASIC in FIL mode!\n");
      applog(3, s, 0);
    }
    return -1;
  }
  v0 = dword_2F461C == 1;
  if ( dword_2F461C == 1 )
    v0 = dword_2F45C8 == 0;
  if ( v0 )
  {
    algn_2F4541[59] = dword_2F4620;
    algn_2F4541[60] = 1;
    algn_2F4541[61] = 3;
    if ( dword_2F4624 + dword_2F4628 + dword_2F462C + dword_2F4630 )
    {
      byte_2F883F = dword_2F4630;
      byte_2F883C = dword_2F4624;
      byte_2F883D = dword_2F4628;
      byte_2F883E = dword_2F462C;
      algn_2F4541[62] = byte_2F4634;
      byte_2F8840 = byte_2F4634;
      byte_2F4580 = byte_2F4634;
      algn_2F4581[0] = byte_2F4634;
      algn_2F4581[1] = byte_2F4634;
      byte_2F885C = dword_2F4650;
      byte_2F885D = dword_2F4654;
      goto LABEL_5;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(s, "Must set temperature sensor address!\n");
      applog(3, s, 0);
      return -1;
    }
    return -1;
  }
LABEL_5:
  dword_2F8844 = dword_2F4638;
  dword_2F8848 = dword_2F463C;
  dword_2F884C = dword_2F4640;
  dword_2F8850 = dword_2F4644;
  dword_2F8854 = dword_2F4648;
  dword_2F8858 = dword_2F464C;
  dword_2F8820 = dword_2F4608;
  dword_2F8824 = dword_2F460C;
  dword_2F8828 = dword_2F4610;
  dword_2F882C = dword_2F4614;
  dword_2F87EC = 1387;
  dword_2F45B0 = 3;
  dword_2F87DC = 3;
  dword_2F87C4 = dword_2F45B4;
  dword_2F87E0 = 128;
  v1 = calculate_core_number(dword_2F45B4);
  dword_2F87FC = dword_2F45DC;
  dword_2F87E4 = dword_2F45C0;
  dword_2F87F0 = dword_2F45D0;
  dword_2F87F4 = dword_2F45D4;
  dword_2F8804 = dword_2F45E4;
  dword_2F87F8 = dword_2F45D8;
  dword_2F8814 = dword_2F4604;
  dword_2F8830 = dword_2F4618;
  dword_2F8800 = dword_2F45E0;
  dword_2F880C = dword_2F45FC;
  dword_2F8808 = dword_2F45E8;
  dword_2F8810 = dword_2F4600;
  dword_2F8860 = dword_2F4658;
  dword_2F87C8 = dword_2F459C;
  dword_2F8864 = dword_2F465C;
  dword_2F8868 = dword_2F4660;
  dword_2F886C = dword_2F4664;
  dword_2F8870 = dword_2F4668;
  dword_2F8874 = dword_2F466C;
  if ( dword_2F45A0 <= 0 )
    dword_2F87CC = 95 * (dword_2F87DC * (16777216 / v1) / dword_2F459C) / 100;
  else
    dword_2F87CC = dword_2F45A0;
  v2 = dword_2F458C;
  dword_2F87D0 = 26;
  if ( (unsigned int)(dword_2F458C - 1) > 4999 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
    {
      v3 = dword_2F4590;
      v2 = conf;
      if ( !((v3 > conf) | ((unsigned int)v3 >> 31)) )
        goto LABEL_11;
LABEL_42:
      if ( opt_log_level <= 2 )
      {
        v4 = dword_2F4594;
        v2 = conf;
        if ( !((dword_2F4594 > conf) | ((unsigned int)dword_2F4594 >> 31)) )
          goto LABEL_13;
LABEL_44:
        if ( opt_log_level <= 2 )
        {
          v5 = dword_2F4598;
          if ( !((dword_2F4598 > conf) | ((unsigned int)dword_2F4598 >> 31)) )
            goto LABEL_15;
LABEL_32:
          if ( opt_log_level <= 2 )
            return 0;
LABEL_33:
          snprintf(s, 2048u, "$$$$Config argument DataCount:%d err\n", dword_2F458C);
          applog(3, s, 0);
          return 0;
        }
        goto LABEL_29;
      }
      goto LABEL_26;
    }
    snprintf(s, 2048u, "$$$$Config argument DataCount:%d err\n", dword_2F458C);
    applog(3, s, 0);
    v2 = conf;
  }
  else
  {
    conf = dword_2F458C;
  }
  v3 = dword_2F4590;
  if ( !((dword_2F4590 > v2) | ((unsigned int)dword_2F4590 >> 31)) )
  {
LABEL_11:
    dword_2F87B8 = v3;
    goto LABEL_12;
  }
  if ( !use_syslog && !opt_log_output )
    goto LABEL_42;
LABEL_26:
  snprintf(s, 2048u, "$$$$Config argument DataCount:%d err\n", dword_2F458C);
  applog(3, s, 0);
  v2 = conf;
LABEL_12:
  v4 = dword_2F4594;
  if ( !((dword_2F4594 > v2) | ((unsigned int)dword_2F4594 >> 31)) )
  {
LABEL_13:
    dword_2F87BC = v4;
    goto LABEL_14;
  }
  if ( !use_syslog && !opt_log_output )
    goto LABEL_44;
LABEL_29:
  snprintf(s, 2048u, "$$$$Config argument DataCount:%d err\n", dword_2F458C);
  applog(3, s, 0);
  v2 = conf;
LABEL_14:
  v5 = dword_2F4598;
  if ( (dword_2F4598 > v2) | ((unsigned int)dword_2F4598 >> 31) )
  {
    if ( use_syslog || opt_log_output )
      goto LABEL_33;
    goto LABEL_32;
  }
LABEL_15:
  dword_2F87C0 = v5;
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 2F4580: using guessed type char byte_2F4580;
// 2F458C: using guessed type int dword_2F458C;
// 2F4590: using guessed type int dword_2F4590;
// 2F4594: using guessed type int dword_2F4594;
// 2F4598: using guessed type int dword_2F4598;
// 2F459C: using guessed type int dword_2F459C;
// 2F45A0: using guessed type int dword_2F45A0;
// 2F45B0: using guessed type int dword_2F45B0;
// 2F45B4: using guessed type int dword_2F45B4;
// 2F45C0: using guessed type int dword_2F45C0;
// 2F45C8: using guessed type int dword_2F45C8;
// 2F45D0: using guessed type int dword_2F45D0;
// 2F45D4: using guessed type int dword_2F45D4;
// 2F45D8: using guessed type int dword_2F45D8;
// 2F45DC: using guessed type int dword_2F45DC;
// 2F45E0: using guessed type int dword_2F45E0;
// 2F45E4: using guessed type int dword_2F45E4;
// 2F45E8: using guessed type int dword_2F45E8;
// 2F45FC: using guessed type int dword_2F45FC;
// 2F4600: using guessed type int dword_2F4600;
// 2F4604: using guessed type int dword_2F4604;
// 2F4608: using guessed type int dword_2F4608;
// 2F460C: using guessed type int dword_2F460C;
// 2F4610: using guessed type int dword_2F4610;
// 2F4614: using guessed type int dword_2F4614;
// 2F4618: using guessed type int dword_2F4618;
// 2F461C: using guessed type int dword_2F461C;
// 2F4620: using guessed type int dword_2F4620;
// 2F4624: using guessed type int dword_2F4624;
// 2F4628: using guessed type int dword_2F4628;
// 2F462C: using guessed type int dword_2F462C;
// 2F4630: using guessed type int dword_2F4630;
// 2F4634: using guessed type char byte_2F4634;
// 2F4638: using guessed type int dword_2F4638;
// 2F463C: using guessed type int dword_2F463C;
// 2F4640: using guessed type int dword_2F4640;
// 2F4644: using guessed type int dword_2F4644;
// 2F4648: using guessed type int dword_2F4648;
// 2F464C: using guessed type int dword_2F464C;
// 2F4650: using guessed type int dword_2F4650;
// 2F4654: using guessed type int dword_2F4654;
// 2F4658: using guessed type int dword_2F4658;
// 2F465C: using guessed type int dword_2F465C;
// 2F4660: using guessed type int dword_2F4660;
// 2F4664: using guessed type int dword_2F4664;
// 2F4668: using guessed type int dword_2F4668;
// 2F466C: using guessed type int dword_2F466C;
// 2F87B4: using guessed type int conf;
// 2F87B8: using guessed type int dword_2F87B8;
// 2F87BC: using guessed type int dword_2F87BC;
// 2F87C0: using guessed type int dword_2F87C0;
// 2F87C4: using guessed type int dword_2F87C4;
// 2F87C8: using guessed type int dword_2F87C8;
// 2F87CC: using guessed type int dword_2F87CC;
// 2F87D0: using guessed type int dword_2F87D0;
// 2F87DC: using guessed type int dword_2F87DC;
// 2F87E0: using guessed type int dword_2F87E0;
// 2F87E4: using guessed type int dword_2F87E4;
// 2F87E8: using guessed type int dword_2F87E8;
// 2F87EC: using guessed type int dword_2F87EC;
// 2F87F0: using guessed type int dword_2F87F0;
// 2F87F4: using guessed type int dword_2F87F4;
// 2F87F8: using guessed type int dword_2F87F8;
// 2F87FC: using guessed type int dword_2F87FC;
// 2F8800: using guessed type int dword_2F8800;
// 2F8804: using guessed type int dword_2F8804;
// 2F8808: using guessed type int dword_2F8808;
// 2F880C: using guessed type int dword_2F880C;
// 2F8810: using guessed type int dword_2F8810;
// 2F8814: using guessed type int dword_2F8814;
// 2F8820: using guessed type int dword_2F8820;
// 2F8824: using guessed type int dword_2F8824;
// 2F8828: using guessed type int dword_2F8828;
// 2F882C: using guessed type int dword_2F882C;
// 2F8830: using guessed type int dword_2F8830;
// 2F8834: using guessed type int dword_2F8834;
// 2F8838: using guessed type int dword_2F8838;
// 2F883C: using guessed type char byte_2F883C;
// 2F883D: using guessed type char byte_2F883D;
// 2F883E: using guessed type char byte_2F883E;
// 2F883F: using guessed type char byte_2F883F;
// 2F8840: using guessed type char byte_2F8840;
// 2F8844: using guessed type int dword_2F8844;
// 2F8848: using guessed type int dword_2F8848;
// 2F884C: using guessed type int dword_2F884C;
// 2F8850: using guessed type int dword_2F8850;
// 2F8854: using guessed type int dword_2F8854;
// 2F8858: using guessed type int dword_2F8858;
// 2F885C: using guessed type char byte_2F885C;
// 2F885D: using guessed type char byte_2F885D;
// 2F8860: using guessed type int dword_2F8860;
// 2F8864: using guessed type int dword_2F8864;
// 2F8868: using guessed type int dword_2F8868;
// 2F886C: using guessed type int dword_2F886C;
// 2F8870: using guessed type int dword_2F8870;
// 2F8874: using guessed type int dword_2F8874;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0002C00C) --------------------------------------------------------
int get_works()
{
  int *v0; // r10
  FILE **v1; // r6
  FILE *v2; // r4
  _DWORD *v3; // r7
  int v4; // r5
  FILE *v5; // t1
  void *v6; // r4
  int v7; // r0
  char *v8; // r0
  int v9; // lr
  char *v10; // r9
  int v11; // r6
  _DWORD *v12; // r4
  char *v13; // r2
  int v14; // r12
  int v15; // r7
  int v16; // r5
  int v17; // r5
  int v18; // r8
  int v19; // r12
  int v20; // r5
  int v21; // r1
  char *v22; // r3
  FILE *v23; // r0
  int v24; // r6
  int v25; // r4
  int v26; // r2
  int v27; // r3
  _DWORD *v28; // r0
  int v29; // r5
  int v30; // r1
  int v31; // t1
  int v32; // r3
  unsigned int v34; // [sp+8h] [bp-890h]
  int v35; // [sp+Ch] [bp-88Ch]
  int v36; // [sp+10h] [bp-888h]
  _DWORD *v37; // [sp+14h] [bp-884h]
  void *ptr; // [sp+18h] [bp-880h]
  unsigned int v39; // [sp+2Ch] [bp-86Ch] BYREF
  char s[64]; // [sp+30h] [bp-868h] BYREF
  char v41[2088]; // [sp+70h] [bp-828h] BYREF

  v0 = cgpu;
  v37 = &unk_2F42A8;
  memset(s, 0, sizeof(s));
  v36 = 0;
  do
  {
    v1 = (FILE **)v0;
    ++v36;
    sprintf(s, "%s%02i.bin", &byte_82E6C);
    v2 = fopen(s, "rb");
    *v0 = (int)v2;
    if ( !v2 )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        return -1;
      snprintf(v41, 2048u, "Open test file %s error\n", s);
      goto LABEL_35;
    }
    v39 = 240000;
    v3 = malloc(240000u);
    ptr = v3;
    fseek(v2, 0, 2);
    v4 = ftell((FILE *)*v0);
    v5 = (FILE *)*v0++;
    fseek(v5, 0, 0);
    v6 = malloc(v4);
    v7 = fread(v6, 1u, v4, *v1);
    uncompress((int)v3, (int *)&v39, (unsigned int)v6, v7);
    free(v6);
    v8 = (char *)malloc(260000u);
    v0[166] = (int)v8;
    if ( v8 )
    {
      v34 = v39;
      if ( v39 )
      {
        v9 = 0;
        v10 = v8;
        v11 = 0;
        v12 = v3 + 11;
        v35 = 4 - (_DWORD)v3;
        while ( 1 )
        {
          v13 = &v10[v9];
          *((_DWORD *)v13 + 1) = *v12;
          *((_DWORD *)v13 + 1) = bswap32(*(_DWORD *)&v10[v9 + 4]);
          v14 = *(v12 - 10);
          v15 = *(v12 - 9);
          v16 = *(v12 - 8);
          *((_DWORD *)v13 + 5) = *(v12 - 11);
          *((_DWORD *)v13 + 6) = v14;
          *((_DWORD *)v13 + 7) = v15;
          *((_DWORD *)v13 + 8) = v16;
          v17 = *(v12 - 4);
          v18 = *(v12 - 7);
          v19 = *(v12 - 6);
          *((_DWORD *)v13 + 11) = *(v12 - 5);
          *((_DWORD *)v13 + 9) = v18;
          *((_DWORD *)v13 + 10) = v19;
          *((_DWORD *)v13 + 12) = v17;
          v20 = *(v12 - 2);
          v21 = *(v12 - 1);
          v22 = (char *)v12 + v35;
          *((_DWORD *)v13 + 2) = *(v12 - 3);
          v12 += 12;
          *((_DWORD *)v13 + 3) = v20;
          *((_DWORD *)v13 + 4) = v21;
          *(_DWORD *)&v10[v9] = v11++;
          v9 += 52;
          if ( v34 <= (unsigned int)v22 || v11 == 5000 )
            break;
          v10 = (char *)v0[166];
        }
      }
      else
      {
        v11 = 0;
      }
      free(ptr);
    }
    else if ( use_syslog || (v11 = (unsigned __int8)opt_log_output, opt_log_output) || opt_log_level > 2 )
    {
      v11 = 0;
      strcpy(v41, "malloc struct testpatten_work err\n");
      applog(3, v41, 0);
    }
    v23 = (FILE *)*(v0 - 1);
    v37[1] = v11;
    ++v37;
    fclose(v23);
  }
  while ( v36 != 84 );
  v24 = 0;
  v25 = dword_2F42AC;
  v26 = 0;
  v27 = 0;
  v28 = &dword_2F42AC;
  unk_2F44AC = dword_2F42AC;
  v29 = dword_2F42AC;
  while ( ++v26 != 84 )
  {
    v31 = v28[1];
    ++v28;
    v30 = v31;
    if ( v31 < v25 )
    {
      v29 = v30;
      v27 = v26;
      v25 = v30;
      v24 = 1;
    }
  }
  if ( v24 )
    unk_2F44AC = v29;
  if ( !opt_debug )
  {
LABEL_22:
    v32 = conf;
    if ( conf <= v25 )
      return 0;
    if ( use_syslog || opt_log_output )
    {
LABEL_26:
      snprintf(v41, 2048u, "$$$$dataCount=%d, but min work subid=%d\n", v32, v25);
LABEL_35:
      applog(3, v41, 0);
      return -1;
    }
LABEL_25:
    if ( opt_log_level <= 2 )
      return -1;
    goto LABEL_26;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 6 )
  {
    snprintf(v41, 2048u, "min work minertest[%d]:%d\n\n\n", v27, v25);
    applog(7, v41, 0);
    v25 = unk_2F44AC;
    goto LABEL_22;
  }
  v32 = conf;
  if ( conf > v25 )
    goto LABEL_25;
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 82C10: using guessed type int cgpu[150];
// 82E6C: using guessed type char byte_82E6C;
// 2F42AC: using guessed type _DWORD dword_2F42AC;
// 2F87B4: using guessed type int conf;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (0002C348) --------------------------------------------------------
int configMiner()
{
  read_config();
  puts("\n\nRead Config.ini");
  printf("DataCount:%d\n", dword_2F458C);
  printf("PassCount1:%d\n", dword_2F4590);
  printf("PassCount2:%d\n", dword_2F4594);
  printf("PassCount3:%d\n", dword_2F4598);
  printf("Freq:%d\n", dword_2F459C);
  printf("Timeout:%d\n", dword_2F45A0);
  printf("OpenCoreGap:%d\n", dword_2F45FC);
  printf("CheckTemp:%d\n", dword_2F4600);
  printf("CoreNum:%d\n", dword_2F45B4);
  printf("freq_e:%d\n", dword_2F4638);
  printf("AsicNum:%d\n", dword_2F45B8);
  printf("TestMode:%d\n", dword_2F45C0);
  printf("CheckChain:%d\n", dword_2F45C4);
  printf("CommandMode:%d\n", dword_2F45C8);
  printf("AsicType:%d\n", dword_2F45CC);
  printf("ValidNonce1:%d\n", dword_2F45D0);
  printf("ValidNonce2:%d\n", dword_2F45D4);
  printf("ValidNonce3:%d\n", dword_2F45D8);
  printf("Pic:%ud\n", dword_2F45DC);
  printf("IICPic:%ud\n", dword_2F4604);
  printf("dac = %ud\n", dword_2F4618);
  printf("Voltage1:%ud\n", dword_2F45E0);
  printf("Voltage2:%ud\n", dword_2F45E4);
  printf("Voltage3:%ud\n", dword_2F45E8);
  printf("OpenCoreNum1 = %ud = 0x%x\n", dword_2F4608, dword_2F4608);
  printf("OpenCoreNum2 = %ud = 0x%x\n", dword_2F460C, dword_2F460C);
  printf("OpenCoreNum3 = %ud = 0x%x\n", dword_2F4610, dword_2F4610);
  printf("OpenCoreNum4 = %ud = 0x%x\n", dword_2F4614, dword_2F4614);
  printf("GetTempFrom:%d\n", dword_2F461C);
  printf("TempSel:%d\n", dword_2F4620);
  printf("TempSensor1:%d\n", dword_2F4624);
  printf("TempSensor2:%d\n", dword_2F4628);
  printf("TempSensor3:%d\n", dword_2F462C);
  printf("TempSensor4:%d\n", dword_2F4630);
  printf("DefaultTempOffset:%d\n", byte_2F4634);
  printf("StartSensor:%d\n", dword_2F4650);
  printf("StartTemp:%d\n", dword_2F4654);
  printf("year:%04d\n", dword_2F4658);
  printf("month:%02d\n", dword_2F465C);
  printf("date:%02d\n", dword_2F4660);
  printf("hour:%02d\n", dword_2F4664);
  printf("minute:%02d\n", dword_2F4668);
  printf("second:%02d\n", dword_2F466C);
  puts("\n");
  if ( process_config() < 0 )
    return -14;
  puts("\n\nparameter processed after Reading Config.ini");
  printf("DataCount:%d\n", conf);
  printf("PassCount1:%d\n", dword_2F87B8);
  printf("PassCount2:%d\n", dword_2F87BC);
  printf("PassCount3:%d\n", dword_2F87C0);
  printf("Freq:%d\n", dword_2F87C8);
  printf("Timeout:%d\n", dword_2F87CC);
  printf("OpenCoreGap:%d\n", dword_2F880C);
  printf("CheckTemp:%d\n", dword_2F8810);
  printf("CoreNum:%d\n", dword_2F87C4);
  printf("AsicNum:%d\n", dword_2F87E0);
  printf("TestMode:%d\n", dword_2F87E4);
  printf("CommandMode:%d\n", dword_2F87E8);
  printf("AsicType:%d\n", dword_2F87EC);
  printf("ValidNonce1:%d\n", dword_2F87F0);
  printf("ValidNonce2:%d\n", dword_2F87F4);
  printf("ValidNonce3:%d\n", dword_2F87F8);
  printf("Pic:%ud\n", dword_2F87FC);
  printf("IICPic:%ud\n", dword_2F8814);
  printf("dac:%ud\n", dword_2F8830);
  printf("Voltage1:%ud\n", dword_2F8800);
  printf("Voltage2:%ud\n", dword_2F8804);
  printf("Voltage3:%ud\n", dword_2F8808);
  printf("OpenCoreNum1 = %ud = 0x%x\n", dword_2F8820, dword_2F8820);
  printf("OpenCoreNum2 = %ud = 0x%x\n", dword_2F8824, dword_2F8824);
  printf("OpenCoreNum3 = %ud = 0x%x\n", dword_2F8828, dword_2F8828);
  printf("OpenCoreNum4 = %ud = 0x%x\n", dword_2F882C, dword_2F882C);
  printf("GetTempFrom:%d\n", dword_2F8834);
  printf("TempSel:%d\n", dword_2F8838);
  printf("TempSensor1:%d\n", (unsigned __int8)byte_2F883C);
  printf("TempSensor2:%d\n", (unsigned __int8)byte_2F883D);
  printf("TempSensor3:%d\n", (unsigned __int8)byte_2F883E);
  printf("TempSensor4:%d\n", (unsigned __int8)byte_2F883F);
  printf("DefaultTempOffset:%d\n", byte_2F8840);
  printf("StartSensor:%d\n", (unsigned __int8)byte_2F885C);
  printf("StartTemp:%d\n", byte_2F885D);
  printf("year:%04d\n", dword_2F8860);
  printf("month:%02d\n", dword_2F8864);
  printf("date:%02d\n", dword_2F8868);
  printf("hour:%02d\n", dword_2F886C);
  printf("minute:%02d\n", dword_2F8870);
  printf("second:%02d\n", dword_2F8874);
  puts("\n");
  if ( get_works() < 0 )
    return -14;
  else
    return 0;
}
// 2F458C: using guessed type int dword_2F458C;
// 2F4590: using guessed type int dword_2F4590;
// 2F4594: using guessed type int dword_2F4594;
// 2F4598: using guessed type int dword_2F4598;
// 2F459C: using guessed type int dword_2F459C;
// 2F45A0: using guessed type int dword_2F45A0;
// 2F45B4: using guessed type int dword_2F45B4;
// 2F45B8: using guessed type int dword_2F45B8;
// 2F45C0: using guessed type int dword_2F45C0;
// 2F45C4: using guessed type int dword_2F45C4;
// 2F45C8: using guessed type int dword_2F45C8;
// 2F45CC: using guessed type int dword_2F45CC;
// 2F45D0: using guessed type int dword_2F45D0;
// 2F45D4: using guessed type int dword_2F45D4;
// 2F45D8: using guessed type int dword_2F45D8;
// 2F45DC: using guessed type int dword_2F45DC;
// 2F45E0: using guessed type int dword_2F45E0;
// 2F45E4: using guessed type int dword_2F45E4;
// 2F45E8: using guessed type int dword_2F45E8;
// 2F45FC: using guessed type int dword_2F45FC;
// 2F4600: using guessed type int dword_2F4600;
// 2F4604: using guessed type int dword_2F4604;
// 2F4608: using guessed type int dword_2F4608;
// 2F460C: using guessed type int dword_2F460C;
// 2F4610: using guessed type int dword_2F4610;
// 2F4614: using guessed type int dword_2F4614;
// 2F4618: using guessed type int dword_2F4618;
// 2F461C: using guessed type int dword_2F461C;
// 2F4620: using guessed type int dword_2F4620;
// 2F4624: using guessed type int dword_2F4624;
// 2F4628: using guessed type int dword_2F4628;
// 2F462C: using guessed type int dword_2F462C;
// 2F4630: using guessed type int dword_2F4630;
// 2F4634: using guessed type char byte_2F4634;
// 2F4638: using guessed type int dword_2F4638;
// 2F4650: using guessed type int dword_2F4650;
// 2F4654: using guessed type int dword_2F4654;
// 2F4658: using guessed type int dword_2F4658;
// 2F465C: using guessed type int dword_2F465C;
// 2F4660: using guessed type int dword_2F4660;
// 2F4664: using guessed type int dword_2F4664;
// 2F4668: using guessed type int dword_2F4668;
// 2F466C: using guessed type int dword_2F466C;
// 2F87B4: using guessed type int conf;
// 2F87B8: using guessed type int dword_2F87B8;
// 2F87BC: using guessed type int dword_2F87BC;
// 2F87C0: using guessed type int dword_2F87C0;
// 2F87C4: using guessed type int dword_2F87C4;
// 2F87C8: using guessed type int dword_2F87C8;
// 2F87CC: using guessed type int dword_2F87CC;
// 2F87E0: using guessed type int dword_2F87E0;
// 2F87E4: using guessed type int dword_2F87E4;
// 2F87E8: using guessed type int dword_2F87E8;
// 2F87EC: using guessed type int dword_2F87EC;
// 2F87F0: using guessed type int dword_2F87F0;
// 2F87F4: using guessed type int dword_2F87F4;
// 2F87F8: using guessed type int dword_2F87F8;
// 2F87FC: using guessed type int dword_2F87FC;
// 2F8800: using guessed type int dword_2F8800;
// 2F8804: using guessed type int dword_2F8804;
// 2F8808: using guessed type int dword_2F8808;
// 2F880C: using guessed type int dword_2F880C;
// 2F8810: using guessed type int dword_2F8810;
// 2F8814: using guessed type int dword_2F8814;
// 2F8820: using guessed type int dword_2F8820;
// 2F8824: using guessed type int dword_2F8824;
// 2F8828: using guessed type int dword_2F8828;
// 2F882C: using guessed type int dword_2F882C;
// 2F8830: using guessed type int dword_2F8830;
// 2F8834: using guessed type int dword_2F8834;
// 2F8838: using guessed type int dword_2F8838;
// 2F883C: using guessed type char byte_2F883C;
// 2F883D: using guessed type char byte_2F883D;
// 2F883E: using guessed type char byte_2F883E;
// 2F883F: using guessed type char byte_2F883F;
// 2F8840: using guessed type char byte_2F8840;
// 2F885C: using guessed type char byte_2F885C;
// 2F885D: using guessed type char byte_2F885D;
// 2F8860: using guessed type int dword_2F8860;
// 2F8864: using guessed type int dword_2F8864;
// 2F8868: using guessed type int dword_2F8868;
// 2F886C: using guessed type int dword_2F886C;
// 2F8870: using guessed type int dword_2F8870;
// 2F8874: using guessed type int dword_2F8874;

//----- (0002C8FC) --------------------------------------------------------
int __fastcall clement_doTestBoard(char a1)
{
  char *v1; // r3
  _DWORD *v2; // r8
  _DWORD *v3; // r4
  char *v4; // r5
  _DWORD *v5; // r0
  char *v6; // r10
  _DWORD *v7; // r9
  char *v8; // r12
  char *v9; // r6
  _DWORD *v10; // lr
  char *v11; // r1
  _DWORD *v12; // r3
  char *v13; // r0
  _DWORD *v14; // r10
  char *v15; // r5
  _DWORD *v16; // r9
  _DWORD *v17; // r12
  char *v18; // r4
  char *v19; // r3
  char *v20; // r2
  unsigned int v21; // r0
  int *v22; // r5
  char *v23; // r2
  int *v24; // r3
  int *v25; // r1
  int v26; // t1
  char *v27; // r1
  int v28; // t1
  char *v29; // r3
  int v30; // t1
  int v31; // r4
  int v33; // [sp+4h] [bp-434h]
  char s[1064]; // [sp+10h] [bp-428h] BYREF

  showLogToKernelLog = a1;
  if ( init_once > 0 )
  {
    memset(cgpu, 0, (size_t)&unk_271974);
    if ( configMiner() < 0 )
    {
      puts("configMiner Error!");
      return 0;
    }
    init_once = 0;
    puts("single board test start");
    conf = 912;
    dword_2F87B8 = 912;
    dword_2F87BC = 912;
    dword_2F87C0 = 912;
    dword_2F87F0 = (int)&loc_12B3E + 2;
    dword_2F87F4 = (int)&loc_12B3E + 2;
    dword_2F87F8 = (int)&loc_12B3E + 2;
    ExitFlag = 0;
    dword_2F45D0 = (int)&loc_12B3E + 2;
    dword_2F458C = 912;
    dword_2F4590 = 912;
    dword_2F4594 = 912;
    dword_2F4598 = 912;
    dword_2F45D4 = (int)&loc_12B3E + 2;
    dword_2F45D8 = (int)&loc_12B3E + 2;
    pthread_create(dword_82E10, 0, (void *(*)(void *))receive_func, cgpu);
    v1 = (char *)&unk_6FC98F;
    do
      *++v1 = 0;
    while ( v1 != (char *)&unk_6FC99F );
  }
  v2 = &unk_6FC9DC;
  v3 = &unk_704A6C;
  v4 = (char *)&unk_700A1C;
  v5 = &unk_6FCE1C;
  v6 = (char *)&unk_704A5F;
  v7 = &unk_704A1C;
  v8 = &algn_6FC944[59];
  v9 = (char *)&unk_6FCA1C;
  v10 = &unk_6FC99C;
  do
  {
    v11 = v4;
    v12 = v9;
    v3[1] = 0;
    ++v3;
    do
    {
      v12[1] = 0;
      ++v12;
      *((_DWORD *)v11 + 1) = 0;
      v11 += 4;
    }
    while ( v12 != v5 );
    v5 = v12 + 256;
    v9 += 1024;
    *++v6 = 1;
    v4 += 1024;
    v10[1] = 912;
    ++v10;
    v2[1] = (char *)&loc_12B3E + 2;
    ++v2;
    v7[1] = 912;
    ++v7;
    *++v8 = 0;
  }
  while ( v3 != (_DWORD *)&unk_704AAC );
  v33 = 0;
  do
  {
    sprintf(s, "do heat board 8xPatten for %d times\n", ++v33);
    if ( showLogToKernelLog )
      writeInitLogFile(s);
    v13 = (char *)&unk_6FCE1C;
    v14 = &unk_704A1C;
    v15 = (char *)&unk_700A1C;
    v16 = &unk_6FC9DC;
    v17 = &unk_6FC99C;
    v18 = (char *)&unk_704A5F;
    do
    {
      v19 = v13 - 1024;
      v20 = v15;
      do
      {
        *((_DWORD *)v19 + 1) = 0;
        v19 += 4;
        *((_DWORD *)v20 + 1) = 0;
        v20 += 4;
      }
      while ( v19 != v13 );
      *++v18 = 1;
      v15 += 1024;
      v17[1] = 912;
      ++v17;
      v13 = v19 + 1024;
      v16[1] = (char *)&loc_12B3E + 2;
      ++v16;
      v14[1] = 912;
      ++v14;
    }
    while ( v18 != (char *)&unk_704A6F );
    v21 = doTestBoard_isra_0();
    v22 = &dword_2F44F8;
    v23 = search_freq_result;
    v24 = &dword_2F44F8;
    v25 = &testModeOKCounter;
    do
    {
      v26 = v24[1];
      ++v24;
      if ( v26 )
      {
        if ( *v23 )
          ++*v25;
      }
      ++v23;
      ++v25;
    }
    while ( &unk_2F4538 != (_UNKNOWN *)v24 );
  }
  while ( (v33 == 1) > v21 );
  v27 = (char *)&unk_700B6C;
  while ( 1 )
  {
    v28 = v22[1];
    ++v22;
    if ( v28 )
      break;
LABEL_29:
    v27 += 1024;
    if ( &unk_2F4538 == (_UNKNOWN *)v22 )
    {
      v31 = 1;
      someBoardUpVoltage = 0;
      goto LABEL_28;
    }
  }
  v29 = v27 - 336;
  while ( 1 )
  {
    v30 = *((_DWORD *)v29 + 1);
    v29 += 4;
    if ( !v30 )
      break;
    if ( v27 == v29 )
      goto LABEL_29;
  }
  v31 = 0;
  someBoardUpVoltage = 1;
LABEL_28:
  set_PWM(100);
  return v31;
}
// 7DFD8: using guessed type char showLogToKernelLog;
// 7DFDC: using guessed type int init_once;
// 82C10: using guessed type int cgpu[150];
// 82E10: using guessed type pthread_t[22];
// 2F44F8: using guessed type int dword_2F44F8;
// 2F458C: using guessed type int dword_2F458C;
// 2F4590: using guessed type int dword_2F4590;
// 2F4594: using guessed type int dword_2F4594;
// 2F4598: using guessed type int dword_2F4598;
// 2F45D0: using guessed type int dword_2F45D0;
// 2F45D4: using guessed type int dword_2F45D4;
// 2F45D8: using guessed type int dword_2F45D8;
// 2F87B4: using guessed type int conf;
// 2F87B8: using guessed type int dword_2F87B8;
// 2F87BC: using guessed type int dword_2F87BC;
// 2F87C0: using guessed type int dword_2F87C0;
// 2F87F0: using guessed type int dword_2F87F0;
// 2F87F4: using guessed type int dword_2F87F4;
// 2F87F8: using guessed type int dword_2F87F8;
// 6FC93C: using guessed type char ExitFlag;
// 704A70: using guessed type int testModeOKCounter;
// 80B581: using guessed type char someBoardUpVoltage;

//----- (0002CB90) --------------------------------------------------------
int __fastcall clement_doTestBoardOnce(char a1)
{
  char *v1; // r3
  _DWORD *v2; // r7
  _DWORD *v3; // r4
  char *v4; // r6
  _DWORD *v5; // r8
  char *v6; // r12
  char *v7; // r10
  _DWORD *v8; // r9
  char *v9; // r5
  _DWORD *v10; // r0
  char *v11; // r1
  _DWORD *v12; // r3
  int *v13; // r3
  char *v14; // r2
  int *v15; // r1
  int v16; // t1

  showLogToKernelLog = a1;
  if ( init_once > 0 )
  {
    memset(cgpu, 0, (size_t)&unk_271974);
    if ( configMiner() < 0 )
    {
      puts("configMiner Error!");
      return 0;
    }
    init_once = 0;
    puts("single board test start");
    ExitFlag = 0;
    conf = 912;
    dword_2F87B8 = 912;
    dword_2F87BC = 912;
    dword_2F87C0 = 912;
    dword_2F87F0 = (int)&loc_12B3E + 2;
    dword_2F87F4 = (int)&loc_12B3E + 2;
    dword_2F87F8 = (int)&loc_12B3E + 2;
    dword_2F45D0 = (int)&loc_12B3E + 2;
    dword_2F458C = 912;
    dword_2F4590 = 912;
    dword_2F4594 = 912;
    dword_2F4598 = 912;
    dword_2F45D4 = (int)&loc_12B3E + 2;
    dword_2F45D8 = (int)&loc_12B3E + 2;
    pthread_create(dword_82E10, 0, (void *(*)(void *))receive_func, cgpu);
    v1 = (char *)&unk_6FC98F;
    do
      *++v1 = 0;
    while ( &unk_6FC99F != (_UNKNOWN *)v1 );
  }
  v2 = &unk_6FC99C;
  v3 = &unk_704A6C;
  v4 = (char *)&unk_700A1C;
  v5 = &unk_6FC9DC;
  v6 = &algn_6FC944[59];
  v7 = (char *)&unk_704A5F;
  v8 = &unk_704A1C;
  v9 = (char *)&unk_6FCA1C;
  v10 = &unk_6FCE1C;
  do
  {
    v11 = v4;
    v12 = v9;
    v3[1] = 0;
    ++v3;
    do
    {
      v12[1] = 0;
      ++v12;
      *((_DWORD *)v11 + 1) = 0;
      v11 += 4;
    }
    while ( v12 != v10 );
    v10 = v12 + 256;
    v9 += 1024;
    *++v7 = 1;
    v4 += 1024;
    v2[1] = 912;
    ++v2;
    v5[1] = (char *)&loc_12B3E + 2;
    ++v5;
    v8[1] = 912;
    ++v8;
    *++v6 = 0;
  }
  while ( v3 != (_DWORD *)&unk_704AAC );
  doTestBoard_isra_0();
  v13 = &dword_2F44F8;
  v14 = search_freq_result;
  v15 = &testModeOKCounter;
  do
  {
    v16 = v13[1];
    ++v13;
    if ( v16 )
    {
      if ( *v14 )
        ++*v15;
    }
    ++v14;
    ++v15;
  }
  while ( v13 != (int *)&unk_2F4538 );
  set_PWM(100);
  return 1;
}
// 7DFD8: using guessed type char showLogToKernelLog;
// 7DFDC: using guessed type int init_once;
// 82C10: using guessed type int cgpu[150];
// 82E10: using guessed type pthread_t dword_82E10[22];
// 2F44F8: using guessed type int dword_2F44F8;
// 2F458C: using guessed type int dword_2F458C;
// 2F4590: using guessed type int dword_2F4590;
// 2F4594: using guessed type int dword_2F4594;
// 2F4598: using guessed type int dword_2F4598;
// 2F45D0: using guessed type int dword_2F45D0;
// 2F45D4: using guessed type int dword_2F45D4;
// 2F45D8: using guessed type int dword_2F45D8;
// 2F87B4: using guessed type int conf;
// 2F87B8: using guessed type int dword_2F87B8;
// 2F87BC: using guessed type int dword_2F87BC;
// 2F87C0: using guessed type int dword_2F87C0;
// 2F87F0: using guessed type int dword_2F87F0;
// 2F87F4: using guessed type int dword_2F87F4;
// 2F87F8: using guessed type int dword_2F87F8;
// 6FC93C: using guessed type char ExitFlag;
// 704A70: using guessed type int testModeOKCounter;

//----- (0002CD2C) --------------------------------------------------------
unsigned int __fastcall crc16(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // r1
  unsigned int v3; // r3
  int v4; // t1

  if ( a2 <= 0 )
    return 0;
  v2 = &a1[a2];
  v3 = 0;
  do
  {
    v4 = *a1++;
    v3 = crc16_table[2 * (v4 ^ (v3 >> 8))] ^ (unsigned __int16)((_WORD)v3 << 8);
  }
  while ( a1 != v2 );
  return v3;
}
// 7DFE0: using guessed type unsigned __int16 crc16_table[512];

//----- (0002CD6C) --------------------------------------------------------
int bitmain_c5_shutdown()
{
  int v0; // r0
  int dhash_acc_control; // r0

  thr_info_cancel(check_system_work_id);
  thr_info_cancel(read_nonce_reg_id);
  thr_info_cancel(read_temp_id);
  thr_info_cancel(pic_heart_beat);
  v0 = get_BC_write_command();
  set_BC_write_command(v0 & 0xFFBFFFFF);
  dhash_acc_control = get_dhash_acc_control();
  return set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
}
// 81774C: using guessed type int pic_heart_beat;
// 817C18: using guessed type int read_nonce_reg_id;
// 817C1C: using guessed type int check_system_work_id;
// 817CFC: using guessed type int read_temp_id;

//----- (0002CDC4) --------------------------------------------------------
__int64 __fastcall bitmain_c5_scanhash(void *arg)
{
  pthread_t newthread; // [sp+4h] [bp-14h] BYREF

  h = 0LL;
  pthread_create(&newthread, 0, (void *(*)(void *))bitmain_scanhash, arg);
  pthread_join(newthread, 0);
  return h;
}
// 2D3E8: using guessed type int bitmain_scanhash();

//----- (0002CDFC) --------------------------------------------------------
int bitmain_c5_reinit_device()
{
  int result; // r0

  result = (unsigned __int8)status_error;
  if ( !status_error )
    exit((unsigned __int8)status_error);
  return result;
}
// 704AB8: using guessed type char status_error;

//----- (0002CE10) --------------------------------------------------------
int bitmain_c5_detect()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  int result; // r0
  char v4[2072]; // [sp+0h] [bp-818h] BYREF

  v0 = calloc(1u, 392u);
  if ( !v0 )
    _assert_fail("cgpu", "driver-btm-c5.c", 16676u, "bitmain_c5_detect");
  v1 = v0;
  v0[1] = &bitmain_c5_drv;
  v0[8] = 0;
  v0[37] = 1;
  v2 = calloc(6296u, 1u);
  v1[5] = v2;
  if ( !v2 )
  {
    strcpy(v4, "Failed to calloc cgpu_info data");
    applog(3, v4, 1);
    quit(1);
  }
  v2[1570] = 0;
  v2[1571] = 1;
  v2[1572] = 2;
  result = add_cgpu(v1);
  if ( !result )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-c5.c", 16688u, "bitmain_c5_detect");
  return result;
}

//----- (0002CEE0) --------------------------------------------------------
void __noreturn pic_heart_beat_func()
{
  char *v0; // r5
  int v1; // r4
  bool v2; // cc
  int v3; // r6
  FILE *v4; // r0
  FILE *v5; // r11
  FILE *v6; // r0
  FILE *v7; // r6
  char s[104]; // [sp+18h] [bp-68h] BYREF

  memset(s, 0, 64u);
LABEL_2:
  v0 = s;
  v1 = 0;
  while ( 1 )
  {
    while ( !*(_DWORD *)(dev + 4 * (v1 + 2)) )
    {
LABEL_3:
      ++v1;
      v0 += 4;
      if ( v1 == 16 )
        goto LABEL_17;
    }
    pthread_mutex_lock(&iic_mutex);
    cgsleep_ms();
    if ( dsPIC33EP16GS202_pic_heart_beat(v1) == 1 )
    {
      *(_DWORD *)v0 = 0;
      pthread_mutex_unlock(&iic_mutex);
      goto LABEL_3;
    }
    v2 = (unsigned int)log_level > 1;
    v3 = *(_DWORD *)v0 + 1;
    *(_DWORD *)v0 = v3;
    if ( v2 )
    {
      v4 = fopen(log_file, "a+");
      v5 = v4;
      if ( v4 )
        fprintf(
          v4,
          "%s:%d:%s: chain[%d] heart beat fail %d times.\n",
          "driver-btm-c5.c",
          9793,
          "pic_heart_beat_func",
          v1,
          v3);
      fclose(v5);
    }
    pthread_mutex_unlock(&iic_mutex);
    if ( v3 <= 6 )
      goto LABEL_3;
    if ( (unsigned int)log_level > 1 )
    {
      v6 = fopen(log_file, "a+");
      v7 = v6;
      if ( v6 )
        fprintf(v6, "%s:%d:%s: chain[%d] is dead, rebooting...\n", "driver-btm-c5.c", 9799, "pic_heart_beat_func", v1);
      fclose(v7);
    }
    ++v1;
    system("sync");
    v0 += 4;
    sleep(5u);
    system("reboot");
    if ( v1 == 16 )
    {
LABEL_17:
      sleep(10u);
      goto LABEL_2;
    }
  }
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 817C28: using guessed type int dev;

//----- (0002D01C) --------------------------------------------------------
int __fastcall chainHasDisabledCore_part_5(int a1)
{
  int v1; // r0
  char *v2; // r2
  char *v3; // r0

  v1 = 16 * a1;
  v2 = &disabledcore_pos_buf[v1 + 14];
  v3 = &disabledcore_pos_buf[v1];
  while ( (unsigned __int8)v3[2] > 83u || (unsigned __int8)v3[3] > 113u )
  {
    v3 += 2;
    if ( v3 == v2 )
      return 0;
  }
  return 1;
}

//----- (0002D048) --------------------------------------------------------
void __fastcall check_chain_part_9(int a1, int a2, int a3, const char *a4)
{
  char v4[2056]; // [sp+0h] [bp-808h] BYREF

  snprintf(v4, 2048u, "%s: get_hash_on_plug functions error\n", a4);
  applog(7, v4, 0);
}

//----- (0002D074) --------------------------------------------------------
int GetTotalRate_part_12()
{
  int v0; // r11
  int v1; // r8
  int *v2; // r6
  char *v3; // r9
  int *v4; // r4
  char *v5; // r5

  v0 = 0;
  v1 = 0;
  v2 = (int *)&unk_704C24;
  v3 = &byte_708AD6;
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v1 + 2)) == 1 )
    {
      v4 = v2 - 84;
      v5 = v3;
      do
      {
        if ( *v4 <= 14 )
          v0 += strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * (unsigned __int8)*v5 + 40], 0, 10) * (114 - *v4);
        ++v4;
        ++v5;
      }
      while ( v4 != v2 );
    }
    ++v1;
    v2 += 256;
    v3 += 128;
  }
  while ( v1 != 16 );
  return v0 / 1000;
}
// 708AD6: using guessed type char byte_708AD6;
// 817C28: using guessed type int dev;

//----- (0002D10C) --------------------------------------------------------
int __fastcall suffix_string_c5_constprop_16(unsigned __int64 a1, char *s, size_t maxlen, int a4)
{
  double v6; // d8
  double v7; // d0
  double v8; // r0
  __int16 v10[26]; // [sp+14h] [bp-34h] BYREF

  v10[0] = 0;
  if ( a1 > 999999999 )
  {
    *(double *)&a1 = (double)(a1 / (unsigned int)&unk_F4240);
    v10[0] = 71;
    v6 = *(double *)&a1 / 1000.0;
    goto LABEL_3;
  }
  if ( (unsigned int)&unk_F423F < a1 )
  {
    a1 /= 1000uLL;
    v10[0] = 77;
    v6 = (double)(int)a1 / 1000.0;
    if ( a4 )
      goto LABEL_4;
    return snprintf(s, maxlen, "%.3g%s", v6, (const char *)v10);
  }
  if ( a1 >= 1000 )
  {
    v10[0] = 75;
    v6 = (double)(int)a1 / 1000.0;
LABEL_3:
    if ( a4 )
      goto LABEL_4;
    return snprintf(s, maxlen, "%.3g%s", v6, (const char *)v10);
  }
  if ( !a4 )
    return snprintf(s, maxlen, "%d%s", (_DWORD)a1, (const char *)v10);
  v6 = (double)(int)a1;
LABEL_4:
  if ( v6 <= 0.0 )
  {
    v7 = 0.0;
  }
  else
  {
    v7 = v6;
    v8 = log10(*(double *)&a1);
    floor(v8);
  }
  return snprintf(s, maxlen, "%*.*f", a4 + 1, (int)((double)(a4 - 1) - v7), v6);
}

//----- (0002D270) --------------------------------------------------------
int __fastcall get_plldata_constprop_17(int a1, _DWORD *a2, __int16 *a3, _DWORD *a4)
{
  char **v7; // r4
  int v8; // r5
  const char *i; // r0
  char *v10; // r5
  int v11; // r10
  void *v12; // r6
  void *v13; // r4
  __int16 v14; // r5
  int result; // r0
  char s[12]; // [sp+4h] [bp-8Ch] BYREF
  char v17[32]; // [sp+10h] [bp-80h] BYREF
  char v18[32]; // [sp+30h] [bp-60h] BYREF
  char v19[64]; // [sp+50h] [bp-40h] BYREF

  v7 = &off_60FF8;
  sprintf(s, "%d", a1);
  v8 = 0;
  memset(v17, 0, sizeof(v17));
  memset(v18, 0, sizeof(v18));
  memset(v19, 0, 32u);
  for ( i = "100"; ; i = *(v7 - 4) )
  {
    v7 += 4;
    if ( !memcmp(i, s, 4u) )
    {
      v10 = &_PRETTY_FUNCTION___14958[16 * v8];
      v11 = *((_DWORD *)v10 + 12);
      v12 = (void *)*((_DWORD *)v10 + 11);
      v13 = (void *)*((_DWORD *)v10 + 13);
      v14 = v11;
      goto LABEL_6;
    }
    if ( ++v8 == 114 )
      break;
  }
  v14 = 1056;
  v13 = &unk_400241;
  v12 = &loc_40040;
  v11 = 1056;
LABEL_6:
  sprintf(v17, "%08x", v12);
  sprintf(v18, "%04x", v11);
  result = sprintf(v19, "%04x", v13);
  *a2 = v12;
  *a3 = v14;
  *a4 = v13;
  return result;
}
// 60FF8: using guessed type char *off_60FF8;

//----- (0002D344) --------------------------------------------------------
int __fastcall rwlock_init_constprop_22(pthread_rwlock_t *a1, int a2)
{
  int result; // r0
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v4 = _errno_location();
    snprintf(
      s,
      2048u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      "driver-btm-c5.c",
      "bitmain_c5_prepare",
      a2);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (0002D39C) --------------------------------------------------------
void __fastcall __noreturn mutex_init_part_3_constprop_28(int a1)
{
  int *v2; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v2 = _errno_location();
  snprintf(
    s,
    2048u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v2,
    "driver-btm-c5.c",
    "bitmain_c5_prepare",
    a1);
  applog(3, s, 1);
  quit(1);
}

//----- (0002D3E8) --------------------------------------------------------
int __fastcall bitmain_scanhash(int *a1)
{
  pthread_mutex_t *v1; // r3
  pthread_mutex_t *v2; // r4
  int v3; // r2
  unsigned int v4; // r8
  unsigned int v5; // r4
  int *v6; // r3
  int v7; // r6
  unsigned int v8; // r9
  int v9; // r3
  unsigned int *p_nusers; // r7
  int v11; // r3
  bool v12; // cc
  __int64 v13; // r0
  _BOOL4 v15; // r3
  unsigned int v16; // r4
  void **v17; // r9
  unsigned __int64 v18; // r2
  __int64 i; // r0
  bool v20; // cf
  __int64 v21; // r0
  unsigned __int64 v22; // r0
  unsigned __int64 v23; // r2
  __int64 j; // r4
  __int64 v25; // r2
  int v26; // r1
  int v27; // r2
  int v28; // r3
  int v29; // r0
  int v30; // r1
  int v31; // r2
  int v32; // r3
  unsigned int v33; // r0
  unsigned int v34; // r1
  unsigned int v35; // r2
  void ***v36; // r1
  int *v37; // r2
  unsigned int v38; // t1
  unsigned __int64 v39; // r2
  __int64 v40; // r4
  _BOOL4 v41; // r2
  unsigned int v42; // r4
  unsigned int v43; // r4
  int *v44; // r3
  char v46; // r1
  unsigned int v47; // r6
  int *v48; // r0
  int *v49; // r0
  int *v50; // r0
  int *v51; // r0
  int v52; // [sp+1Ch] [bp-984h]
  int v53; // [sp+20h] [bp-980h]
  double v54; // [sp+20h] [bp-980h]
  int v55; // [sp+2Ch] [bp-974h]
  unsigned __int64 v56; // [sp+30h] [bp-970h]
  pthread_mutex_t *mutex; // [sp+38h] [bp-968h]
  void **v59; // [sp+4Ch] [bp-954h] BYREF
  int src[6]; // [sp+50h] [bp-950h] BYREF
  unsigned int v61; // [sp+68h] [bp-938h]
  int v62; // [sp+6Ch] [bp-934h] BYREF
  char v63[28]; // [sp+70h] [bp-930h] BYREF
  char v64; // [sp+8Ch] [bp-914h] BYREF
  int v65[58]; // [sp+90h] [bp-910h] BYREF
  char s[2048]; // [sp+178h] [bp-828h] BYREF

  v1 = *(pthread_mutex_t **)(a1[9] + 20);
  *(_QWORD *)&h = 0LL;
  v2 = v1;
  mutex = v1;
  pthread_mutex_lock(&nonce_mutex);
  if ( pthread_mutex_lock(v2) )
  {
    v51 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v51,
      "driver-btm-c5.c",
      "bitmain_scanhash",
      16836);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)&mutex[1]) )
  {
    v48 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v48,
      "driver-btm-c5.c",
      "bitmain_scanhash",
      16836);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(mutex) )
  {
    v49 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v49,
      "driver-btm-c5.c",
      "bitmain_scanhash",
      16836);
    applog(3, s, 1);
    quit(1);
  }
LABEL_4:
  while ( dword_80EF7C )
  {
    while ( 1 )
    {
      v3 = 0;
      v4 = nonce_read_out[15 * dword_80EF78 + 8];
      v5 = nonce_read_out[15 * dword_80EF78 + 3];
      v6 = &nonce_read_out[15 * dword_80EF78];
      v53 = v6[6];
      v55 = v6[7];
      v52 = v6[9];
      v7 = v6[4];
      v8 = (v6[5] << 24) | HIBYTE(v6[5]) | ((v6[5] & 0xFF0000u) >> 8) | ((v6[5] & 0xFF00) << 8);
      do
        ++v3;
      while ( v3 != 32 );
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          s,
          2048u,
          "%s: job_id:0x%x   work_id:0x%x   nonce2:0x%llx   nonce3:0x%x   version:0x%x\n",
          "bitmain_scanhash",
          v5,
          v7,
          __PAIR64__(v55, v53),
          v4,
          v8);
        applog(7, s, 0);
      }
      if ( (unsigned int)dword_80EF78 >= 510 )
        v9 = 0;
      else
        v9 = dword_80EF78;
      p_nusers = &mutex[30].__nusers;
      if ( (unsigned int)dword_80EF78 < 510 )
        ++v9;
      dword_80EF78 = v9;
      --dword_80EF7C;
      if ( v4 == last_nonce3_15022 && v7 == last_workid_15023 )
        goto LABEL_29;
      last_nonce3_15022 = v4;
      last_workid_15023 = v7;
      if ( !opt_debug )
      {
        v15 = v5 < given_id - 2;
        if ( v5 <= given_id )
          v15 = 0;
        if ( v15 )
          goto LABEL_29;
LABEL_41:
        v16 = given_id - v5;
        switch ( v16 )
        {
          case 1u:
            goto LABEL_96;
          case 0u:
            goto LABEL_45;
          case 2u:
            goto LABEL_44;
        }
        goto LABEL_29;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        snprintf(s, 2048u, "%s: Chain ID J%d ...\n", "bitmain_scanhash", v52 + 1);
        applog(7, s, 0);
        v11 = given_id;
        v41 = v5 < given_id - 2;
        if ( v5 <= given_id )
          v41 = 0;
        if ( v41 )
        {
          if ( !opt_debug )
            goto LABEL_29;
          if ( !use_syslog && !opt_log_output )
          {
LABEL_85:
            if ( opt_log_level <= 6 )
              goto LABEL_29;
          }
LABEL_27:
          snprintf(s, 2048u, "%s: job_id error ...\n", "bitmain_scanhash");
          goto LABEL_28;
        }
        if ( !opt_debug )
          goto LABEL_41;
      }
      else
      {
        v11 = given_id;
        v12 = given_id - 2 > v5;
        if ( given_id - 2 > v5 )
          v12 = v5 > given_id;
        if ( v12 )
        {
          if ( !opt_log_output )
            goto LABEL_85;
          goto LABEL_27;
        }
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
      {
        v42 = given_id - v5;
        switch ( v42 )
        {
          case 1u:
            goto LABEL_96;
          case 0u:
            goto LABEL_45;
          case 2u:
LABEL_44:
            p_nusers = &mutex[184].__nusers;
            goto LABEL_45;
        }
        if ( !opt_log_output )
          goto LABEL_103;
        goto LABEL_95;
      }
      snprintf(s, 2048u, "%s: given_id:%d job_id:%d switch:%d  ...\n", "bitmain_scanhash", v11, v5, v11 - v5);
      applog(7, s, 0);
      v43 = given_id - v5;
      if ( v43 == 1 )
        break;
      if ( !v43 )
        goto LABEL_45;
      if ( v43 == 2 )
        goto LABEL_44;
      if ( opt_debug )
      {
        if ( !use_syslog && !opt_log_output )
        {
LABEL_103:
          if ( opt_log_level <= 6 )
            goto LABEL_29;
        }
LABEL_95:
        snprintf(s, 2048u, "%s: job_id non't found ...\n", "bitmain_scanhash");
LABEL_28:
        applog(7, s, 0);
      }
LABEL_29:
      if ( *(_DWORD *)(dev + 4 * (v52 + 2)) != 1 )
        goto LABEL_4;
      inc_hw_errors((int)a1);
      ++*(_DWORD *)(dev + 4 * v52 + 2748);
      if ( !dword_80EF7C )
        goto LABEL_31;
    }
LABEL_96:
    p_nusers = &mutex[107].__nusers;
LABEL_45:
    get_work_by_nonce2(a1, (int *)&v59, (int)p_nusers, *(_DWORD *)(pools + 4 * *p_nusers), v53, v55, v8);
    v17 = v59;
    v54 = *((double *)v59 + 39);
    if ( (unsigned __int64)v54 != pool_diff_14987 )
    {
      pool_diff_bit_14989 = 0LL;
      pool_diff_14987 = (unsigned __int64)v54;
      if ( (unsigned __int64)v54 )
      {
        v18 = (unsigned __int64)v54;
        for ( i = 1LL; ; ++i )
        {
          v18 >>= 1;
          if ( !v18 )
            break;
        }
        v20 = (_DWORD)i != 0;
        LODWORD(i) = i - 1;
        HIDWORD(v21) = v20 + HIDWORD(i) - 1;
      }
      else
      {
        v21 = -1LL;
      }
      pool_diff_bit_14989 = v21;
      if ( opt_debug )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 6 )
        {
          snprintf(
            s,
            2048u,
            "%s: pool_diff:%d work_diff:%d pool_diff_bit:%d ...\n",
            "hashtest_submit",
            (unsigned int)(unsigned __int64)v54,
            (_DWORD)((unsigned __int64)v54 >> 32),
            LODWORD(v54));
          applog(7, s, 0);
        }
      }
    }
    v22 = (unsigned __int64)current_diff;
    if ( (unsigned __int64)current_diff != net_diff_14988 )
    {
      net_diff_14988 = (unsigned __int64)current_diff;
      if ( v22 )
      {
        v23 = (unsigned __int64)current_diff;
        for ( j = 1LL; ; ++j )
        {
          v23 >>= 1;
          if ( !v23 )
            break;
        }
        v25 = j - 1;
      }
      else
      {
        v25 = -1LL;
      }
      net_diff_bit_14990 = v25;
      if ( opt_debug )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 6 )
        {
          snprintf(
            s,
            2048u,
            "%s:net_diff:%d current_diff:%d net_diff_bit %d ...\n",
            "hashtest_submit",
            (_DWORD)v22,
            HIDWORD(v22),
            LODWORD(current_diff));
          applog(7, s, 0);
        }
      }
    }
    v26 = (int)v17[33];
    v27 = (int)v17[34];
    v28 = (int)v17[35];
    v65[2] = (int)v17[32];
    v65[3] = v26;
    v65[4] = v27;
    v65[5] = v28;
    v29 = (int)v17[36];
    v30 = (int)v17[37];
    v31 = (int)v17[38];
    v32 = (int)v17[39];
    v65[1] = 0;
    v65[6] = v29;
    v65[7] = v30;
    v65[8] = v31;
    v65[9] = v32;
    v33 = (unsigned int)v17[16];
    v65[0] = 80;
    v34 = (unsigned int)v17[17];
    v35 = (unsigned int)v17[18];
    v65[13] = bswap32(v4);
    v65[10] = bswap32(v33);
    src[1] = v34;
    src[2] = v35;
    src[0] = v4;
    v65[11] = bswap32(v34);
    v65[12] = bswap32(v35);
    sha2_finish((int)v65, src);
    memset(v65, 0, sizeof(v65));
    sha2(src, 32, v63);
    v36 = &v59;
    v37 = &v62;
    do
    {
      v38 = v37[1];
      ++v37;
      v36[1] = (void **)bswap32(v38);
      ++v36;
    }
    while ( v37 != (int *)&v64 );
    LODWORD(v39) = v62;
    if ( v62 )
    {
      if ( *(_DWORD *)(dev + 4 * (v52 + 2)) == 1 )
      {
        inc_hw_errors((int)a1);
        ++*(_DWORD *)(dev + 4 * v52 + 2748);
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(s, 2048u, "%s: HASH2_32[7] != 0", "hashtest_submit");
        applog(7, s, 0);
      }
      goto LABEL_74;
    }
    v44 = &v62;
    while ( !*--v44 )
    {
      LODWORD(v39) = v39 + 1;
      if ( (_DWORD)v39 == 7 )
      {
        v39 = 7LL;
        goto LABEL_111;
      }
    }
    v39 = (int)v39;
LABEL_111:
    v46 = pool_diff_bit_14989;
    v56 = (unsigned __int64)pool_diff_bit_14989 >> 5;
    if ( v39 < (unsigned __int64)pool_diff_bit_14989 >> 5 )
    {
LABEL_74:
      v40 = 0LL;
    }
    else
    {
      v47 = (unsigned int)((2863311531u * (unsigned __int64)HIBYTE(v4)) >> 32) >> 1;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          s,
          2048u,
          "%s: chain %d which_asic_nonce %d which_core_nonce %d",
          "hashtest_submit",
          v52,
          v47,
          v4 & 0x7F);
        applog(7, s, 0);
        v46 = pool_diff_bit_14989;
        v56 = (unsigned __int64)pool_diff_bit_14989 >> 5;
      }
      ++*(_QWORD *)(dev + 8 * (v47 + (v52 << 7)) + 2812);
      if ( bswap32(*(&v61 - v56)) < 4294967295u >> (v46 & 0x1F) )
      {
        v40 = 256LL;
        submit_nonce((int)a1, (int)v17, v4);
      }
      else
      {
        if ( bswap32(v61) > 16777214 )
          goto LABEL_74;
        v40 = 256LL;
      }
    }
    *(_QWORD *)&h += v40;
    free_work(&v59, "driver-btm-c5.c", "bitmain_scanhash", 16922);
  }
LABEL_31:
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)&mutex[1]) )
  {
    v50 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v50,
      "driver-btm-c5.c",
      "bitmain_scanhash",
      16924);
    applog(3, s, 1);
    quit(1);
  }
  selective_yield(0);
  pthread_mutex_unlock(&nonce_mutex);
  cgsleep_ms();
  v13 = *(_QWORD *)&h;
  if ( *(_QWORD *)&h && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "%s: hashes %u ...\n", "bitmain_scanhash", -h);
    applog(7, s, 0);
    v13 = *(_QWORD *)&h;
  }
  *(_QWORD *)&h = -4294967297LL * v13;
  return 0;
}
// 7DEF0: using guessed type double current_diff;
// 7E558: using guessed type int given_id;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 704AB0: using guessed type int h;
// 7092EC: using guessed type int last_nonce3_15022;
// 7092F0: using guessed type int last_workid_15023;
// 7092F8: using guessed type __int64 pool_diff_14987;
// 709300: using guessed type __int64 pool_diff_bit_14989;
// 709308: using guessed type __int64 net_diff_14988;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CBE4: using guessed type int pools;
// 80CC18: using guessed type char use_syslog;
// 80EF74: using guessed type int nonce_read_out[];
// 80EF78: using guessed type int dword_80EF78;
// 80EF7C: using guessed type int dword_80EF7C;
// 817C28: using guessed type int dev;
// 2D3E8: using guessed type char var_930[28];

//----- (0002DE00) --------------------------------------------------------
int __fastcall copy_pool_stratum(int result, int a2)
{
  pthread_mutex_t *v2; // r8
  int v3; // r4
  int v5; // r7
  size_t v6; // r5
  void *v7; // r0
  int v8; // r5
  void *v9; // r0
  __int64 v10; // r10
  int v11; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r2
  int v16; // r3
  _DWORD *v17; // r0
  _DWORD *v18; // r11
  int v19; // r5
  _DWORD *v20; // r2
  int v21; // lr
  int v22; // r0
  int v23; // r1
  int v24; // lr
  int v25; // r0
  int v26; // r1
  int v27; // r10
  _DWORD *v28; // r3
  int *v29; // r0
  int *v30; // r0
  int *v31; // r0
  int *v32; // r0
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( *(_DWORD *)(a2 + 672) )
  {
    v2 = (pthread_mutex_t *)(result + 212);
    v3 = result;
    v5 = *(_DWORD *)(a2 + 1708);
    v6 = *(_DWORD *)(a2 + 1572);
    if ( pthread_mutex_lock((pthread_mutex_t *)(result + 212)) )
    {
      v29 = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v29,
        "driver-btm-c5.c",
        "copy_pool_stratum",
        16564);
      applog(3, s, 1);
      quit(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v32 = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v32,
        "driver-btm-c5.c",
        "copy_pool_stratum",
        16564);
      applog(3, s, 1);
      quit(1);
    }
    free(*(void **)(v3 + 672));
    free(*(void **)(v3 + 612));
    free(*(void **)(v3 + 1568));
    if ( v6 << 30 )
      v6 = (v6 & 0xFFFFFFFC) + 4;
    v7 = calloc(v6, 1u);
    *(_DWORD *)(v3 + 1568) = v7;
    if ( !v7 )
    {
      strcpy(s, "Failed to calloc pool_stratum coinbase in c5");
      applog(3, s, 1);
      quit(1);
    }
    memcpy(v7, *(const void **)(a2 + 1568), v6);
    if ( *(int *)(v3 + 1708) > 0 )
    {
      v8 = 0;
      do
      {
        v9 = *(void **)(*(_DWORD *)(v3 + 676) + 4 * v8++);
        free(v9);
      }
      while ( *(_DWORD *)(v3 + 1708) > v8 );
    }
    if ( v5 )
    {
      v17 = realloc(*(void **)(v3 + 676), 4 * v5 + 1);
      *(_DWORD *)(v3 + 676) = v17;
      if ( v5 > 0 )
      {
        v18 = v17;
        v19 = 0;
        while ( 1 )
        {
          v27 = 4 * v19;
          v18[v19] = malloc(32u);
          v28 = *(_DWORD **)(*(_DWORD *)(v3 + 676) + 4 * v19);
          if ( !v28 )
          {
            strcpy(s, "Failed to malloc pool_stratum swork merkle_bin");
            applog(3, s, 1);
            quit(1);
          }
          ++v19;
          v20 = *(_DWORD **)(*(_DWORD *)(a2 + 676) + v27);
          v21 = v20[1];
          v22 = v20[2];
          v23 = v20[3];
          *v28 = *v20;
          v28[1] = v21;
          v28[2] = v22;
          v28[3] = v23;
          v24 = v20[5];
          v25 = v20[6];
          v26 = v20[7];
          v28[4] = v20[4];
          v28[5] = v24;
          v28[6] = v25;
          v28[7] = v26;
          if ( v5 == v19 )
            break;
          v18 = *(_DWORD **)(v3 + 676);
        }
      }
    }
    v10 = *(_QWORD *)(a2 + 1824);
    v11 = *(_DWORD *)(a2 + 1572);
    v12 = *(_DWORD *)(a2 + 1576);
    *(_DWORD *)v3 = *(_DWORD *)a2;
    v13 = *(_DWORD *)(a2 + 632);
    *(_QWORD *)(v3 + 1824) = v10;
    v14 = *(_DWORD *)(a2 + 1708);
    *(_DWORD *)(v3 + 1576) = v12;
    *(_DWORD *)(v3 + 632) = v13;
    *(_DWORD *)(v3 + 1708) = v14;
    *(_DWORD *)(v3 + 1572) = v11;
    *(_DWORD *)(v3 + 672) = _strdup(*(const char **)(a2 + 672));
    *(_DWORD *)(v3 + 612) = _strdup(*(const char **)(a2 + 612));
    v15 = *(_DWORD *)(a2 + 1808);
    v16 = *(_DWORD *)(a2 + 1812);
    *(_DWORD *)(v3 + 1804) = *(_DWORD *)(a2 + 1804);
    *(_DWORD *)(v3 + 1808) = v15;
    *(_DWORD *)(v3 + 1812) = v16;
    memcpy((void *)(v3 + 1580), (const void *)(a2 + 1580), 128u);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v30 = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v30,
        "driver-btm-c5.c",
        "copy_pool_stratum",
        16602);
      applog(3, s, 1);
      quit(1);
    }
    if ( pthread_mutex_unlock(v2) )
    {
      v31 = _errno_location();
      snprintf(
        s,
        2048u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v31,
        "driver-btm-c5.c",
        "copy_pool_stratum",
        16602);
      applog(3, s, 1);
      quit(1);
    }
    return selective_yield(0);
  }
  return result;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0002E148) --------------------------------------------------------
int __fastcall isDisabledCore(int a1, int a2, int a3)
{
  int v3; // r0
  int v5; // r4
  char *v6; // r0

  v3 = 16 * a1;
  if ( *((_BYTE *)&bitmain_c5_drv + v3 + 120) != 44 || *((_BYTE *)&bitmain_c5_drv + v3 + 121) != 101 )
    return 0;
  v5 = v3 + 14;
  v6 = &disabledcore_pos_buf[v3];
  while ( (unsigned __int8)v6[2] != a2 || (unsigned __int8)v6[3] != a3 )
  {
    v6 += 2;
    if ( v6 == &disabledcore_pos_buf[v5] )
      return 0;
  }
  return 1;
}

//----- (0002E190) --------------------------------------------------------
int hasDisabledCore()
{
  char *v0; // r3
  char *v1; // r2

  v0 = (char *)&unk_7E466;
  while ( *(v0 - 14) != 44 || *(v0 - 13) != 101 )
  {
LABEL_2:
    v0 += 16;
    if ( v0 == &algn_7E565[1] )
      return 0;
  }
  v1 = v0 - 14;
  while ( (unsigned __int8)v1[2] > 83u || (unsigned __int8)v1[3] > 113u )
  {
    v1 += 2;
    if ( v0 == v1 )
      goto LABEL_2;
  }
  return 1;
}

//----- (0002E1D4) --------------------------------------------------------
int __fastcall chainHasDisabledCore(int a1)
{
  char *v1; // r3

  v1 = (char *)&bitmain_c5_drv + 16 * a1;
  if ( v1[120] == 44 && v1[121] == 101 )
    return chainHasDisabledCore_part_5(a1);
  else
    return 0;
}

//----- (0002E1F8) --------------------------------------------------------
int __fastcall getMeddleOffsetForTestPatten(int a1)
{
  return *((char *)&unk_708E90 + 8 * a1 + 1160);
}

//----- (0002E20C) --------------------------------------------------------
int isFixedFreqMode()
{
  return (unsigned __int8)opt_fixed_freq;
}
// 709398: using guessed type char opt_fixed_freq;

//----- (0002E21C) --------------------------------------------------------
int isC5_Board()
{
  FILE *v0; // r0
  FILE *v1; // r4
  char *v2; // r0
  int v3; // r2
  int result; // r0
  char *v5; // r0
  char v6[40]; // [sp+0h] [bp-28h] BYREF

  memset(v6, 0, 32u);
  v0 = fopen("/usr/bin/ctrl_bd", "rb");
  if ( v0
    && ((v1 = v0, fread(v6, 1u, 32u, v0), fclose(v1), v2 = strstr(v6, "XILINX"), v3 = 0, v2)
     || (v5 = strstr(v6, "7007"), v3 = 1, v5)) )
  {
    result = 0;
    is7007_ctrl_board = v3;
  }
  else
  {
    result = 1;
    is7007_ctrl_board = 0;
  }
  return result;
}
// 7E55C: using guessed type int is7007_ctrl_board;

//----- (0002E2A0) --------------------------------------------------------
bool is7007_Board()
{
  if ( is7007_ctrl_board == -1 )
    isC5_Board();
  return is7007_ctrl_board == 1;
}
// 7E55C: using guessed type int is7007_ctrl_board;

//----- (0002E2D4) --------------------------------------------------------
int __fastcall CRC16(int a1, int a2)
{
  int v2; // r2
  int v3; // r4
  int v4; // r1
  int v5; // r0
  int v6; // t1
  char *v7; // r3

  if ( !a2 )
    return 65535;
  v2 = 255;
  v3 = (unsigned __int16)(a2 - 1) + a1;
  v4 = 255;
  v5 = a1 - 1;
  do
  {
    v6 = *(unsigned __int8 *)++v5;
    v7 = &_PRETTY_FUNCTION___14958[v6 ^ v2];
    v2 = (unsigned __int8)v7[1960] ^ v4;
    v4 = (unsigned __int8)v7[2216];
  }
  while ( v5 != v3 );
  return v2 | (v4 << 8);
}

//----- (0002E314) --------------------------------------------------------
int __fastcall CRC5(_BYTE *a1, unsigned int a2)
{
  int v2; // r7
  unsigned __int8 v3; // r6
  int v4; // r2
  char v5; // lr
  int v6; // r12
  int v7; // r8
  char v8; // r9
  unsigned int v9; // r5
  int v10; // r11
  unsigned int v11; // r3
  int v12; // r3
  int v13; // r4
  int result; // r0

  if ( !a2 )
  {
    v12 = 1;
    result = 16;
    v13 = 1;
    v2 = 1;
LABEL_22:
    result |= 8u;
    goto LABEL_14;
  }
  v2 = 1;
  v3 = 0;
  LOBYTE(v4) = 0;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  v8 = 1;
  v9 = 128;
  while ( 1 )
  {
    v4 = (unsigned __int8)(v4 + 1);
    ++v3;
    v10 = v6;
    v11 = *a1 & v9;
    v9 >>= 1;
    if ( v11 )
      LOBYTE(v12) = v8 ^ 1;
    else
      LOBYTE(v12) = v8;
    v12 = (unsigned __int8)v12;
    if ( v4 == 8 )
    {
      ++a1;
      LOBYTE(v4) = 0;
      v9 = 128;
    }
    v13 = (unsigned __int8)(v12 ^ v5);
    v8 = v7;
    v5 = v2;
    if ( a2 <= v3 )
      break;
    v2 = (unsigned __int8)v12;
    v6 = v13;
    v7 = v10;
  }
  if ( v7 )
    result = 16;
  else
    result = 0;
  if ( v6 )
    goto LABEL_22;
LABEL_14:
  if ( v13 )
    result |= 4u;
  if ( v2 )
    result |= 2u;
  if ( v12 )
    return result | 1;
  return result;
}

//----- (0002E3A0) --------------------------------------------------------
int __fastcall getPICvoltageFromValue(int a1)
{
  return (unsigned __int8)(unsigned int)(364.0704 / ((double)a1 * 4.75 / 100.0 - 32.79) - 30.72);
}

//----- (0002E408) --------------------------------------------------------
int __fastcall getVolValueFromPICvoltage(int a1)
{
  return 10 * ((int)((364.0704 / ((double)a1 + 30.72) + 32.79) * 100.0 / 4.75) / 10);
}

//----- (0002E480) --------------------------------------------------------
int getVoltageLimitedFromHashrate()
{
  return 930;
}

//----- (0002E488) --------------------------------------------------------
int getBoardVoltageLimitedFromHashrate()
{
  return 930;
}

//----- (0002E490) --------------------------------------------------------
int getFixedFreqVoltageValue()
{
  return 860;
}

//----- (0002E498) --------------------------------------------------------
unsigned int __fastcall getPICChainIndexOffset(int a1, unsigned int *a2, int *a3)
{
  unsigned int result; // r0
  bool v4; // cc
  int v5; // r3
  unsigned int v6; // r3

  result = a1 - 1;
  v4 = result > 12;
  if ( result > 12 )
    v5 = 0;
  else
    v5 = 4032;
  if ( result > 12 )
    result = v5;
  else
    HIWORD(v5) = 6;
  if ( !v4 )
  {
    v6 = v5 + 4 * result;
    result = *(_DWORD *)(v6 + 2472);
    v5 = *(_DWORD *)(v6 + 2524);
  }
  *a2 = result;
  *a3 = v5;
  return result;
}

//----- (0002E4C0) --------------------------------------------------------
int __fastcall getChainAsicFreqIndex(int a1, int a2)
{
  return *((unsigned __int8 *)&unk_707D98 + 128 * a1 + a2 + 3390);
}

//----- (0002E4D4) --------------------------------------------------------
int get_pic_iic()
{
  int v0; // r4
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  v0 = *(_DWORD *)(axi_fpga_addr + 48);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "%s: IIC_COMMAND is 0x%x\n", "get_pic_iic", *(_DWORD *)(axi_fpga_addr + 48));
    applog(7, s, 0);
  }
  return v0;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80B7FC: using guessed type int axi_fpga_addr;
// 80CC18: using guessed type char use_syslog;

//----- (0002E544) --------------------------------------------------------
int __fastcall set_pic_iic(int a1)
{
  int v1; // r4
  bool v2; // cc
  int result; // r0
  FILE *v4; // r0
  FILE *v5; // r5
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  v1 = a1 & 0x7FFFFFFF;
  v2 = (unsigned int)log_level > 7;
  *(_DWORD *)(axi_fpga_addr + 48) = a1 & 0x7FFFFFFF;
  if ( v2 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(
        v4,
        "%s:%d:%s: fpga write, addr:value ==> 0x%08x:0x%08x\n",
        "driver-btm-c5.c",
        1251,
        "set_pic_iic",
        12,
        v1);
    fclose(v5);
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "%s: set IIC_COMMAND is 0x%x\n", "set_pic_iic", v1);
    applog(7, s, 0);
  }
  while ( 1 )
  {
    result = get_pic_iic();
    if ( result < 0 )
      break;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: waiting write pic iic\n", "set_pic_iic");
      applog(7, s, 0);
    }
    cgsleep_us();
  }
  return (unsigned __int8)result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80B7FC: using guessed type int axi_fpga_addr;
// 80CC18: using guessed type char use_syslog;

//----- (0002E678) --------------------------------------------------------
int __fastcall write_pic_iic(int a1, int a2, int a3, char a4, unsigned __int8 a5)
{
  int v5; // r0

  if ( a1 )
    v5 = 33554432;
  else
    v5 = 0;
  if ( a2 )
    v5 |= (a3 << 8) | 0x1000000;
  return set_pic_iic(v5 | a5 | 0x400000 | ((a4 & 0xF) << 16));
}

//----- (0002E6A8) --------------------------------------------------------
int __fastcall send_pic_command(char a1)
{
  int v1; // r4

  v1 = (a1 & 0xF) << 16;
  set_pic_iic(v1 | 0x400055);
  return set_pic_iic(v1 | 0x4000AA);
}

//----- (0002E6CC) --------------------------------------------------------
int __fastcall send_data_to_pic_iic(char a1, int a2, unsigned __int8 *a3, int a4)
{
  int v6; // r5
  int result; // r0
  unsigned __int8 *v8; // r6
  int v9; // t1

  v6 = ((a1 & 0xF) << 16) | 0x400000;
  result = set_pic_iic(a2 | v6);
  if ( a4 )
  {
    v8 = &a3[a4];
    do
    {
      v9 = *a3++;
      result = set_pic_iic(v9 | v6);
    }
    while ( a3 != v8 );
  }
  return result;
}

//----- (0002E6F8) --------------------------------------------------------
int __fastcall get_data_from_pic_iic(char a1, int a2, _BYTE *a3, int a4)
{
  int v4; // r5
  int result; // r0
  int v8; // r5
  _BYTE *v9; // r6

  v4 = (a1 & 0xF) << 16;
  result = set_pic_iic(a2 | 0x400000 | v4);
  if ( a4 )
  {
    v8 = v4 | 0x2400000;
    v9 = &a3[a4];
    do
    {
      result = set_pic_iic(v8);
      *a3++ = result;
    }
    while ( a3 != v9 );
  }
  return result;
}

//----- (0002E728) --------------------------------------------------------
int __fastcall send_data_to_pic_flash(char a1, unsigned __int8 *a2)
{
  send_pic_command(a1);
  return send_data_to_pic_iic(a1, 2, a2, 16);
}

//----- (0002E744) --------------------------------------------------------
int __fastcall get_data_from_pic_flash(char a1, _BYTE *a2)
{
  send_pic_command(a1);
  return get_data_from_pic_iic(a1, 3, a2, 16);
}

//----- (0002E760) --------------------------------------------------------
int __fastcall erase_pic_flash(char a1)
{
  send_pic_command(a1);
  set_pic_iic((unsigned int)&unk_400004 | ((a1 & 0xF) << 16));
  usleep(100000u);
  return 0;
}

//----- (0002E78C) --------------------------------------------------------
int __fastcall set_temperature_offset_value(char a1, unsigned __int8 *a2)
{
  send_pic_command(a1);
  send_data_to_pic_iic(a1, 34, a2, 8);
  return cgsleep_ms();
}

//----- (0002E7B4) --------------------------------------------------------
int __fastcall write_data_into_pic_flash(char a1)
{
  send_pic_command(a1);
  set_pic_iic((unsigned int)&unk_400005 | ((a1 & 0xF) << 16));
  usleep(100000u);
  return 0;
}

//----- (0002E7E4) --------------------------------------------------------
int __fastcall jump_to_app_CheckAndRestorePIC_T9_18(int a1)
{
  FILE *v2; // r0
  FILE *v3; // r7
  FILE *v4; // r0
  FILE *v5; // r5
  int result; // r0
  FILE *v7; // r0
  FILE *v8; // r4
  unsigned __int8 v9; // [sp+17h] [bp-19h] BYREF

  if ( (unsigned int)log_level > 1 )
  {
    v2 = fopen(log_file, "a+");
    v3 = v2;
    if ( v2 )
      fprintf(
        v2,
        "%s:%d:%s: chain[%d] PIC jump to app\n",
        "driver-btm-c5.c",
        1767,
        "jump_to_app_CheckAndRestorePIC_T9_18",
        a1);
    fclose(v3);
    if ( (unsigned int)log_level > 3 )
    {
      v4 = fopen(log_file, "a+");
      v5 = v4;
      if ( v4 )
        fprintf(
          v4,
          "%s:%d:%s: chain[%d] PIC jump to app\n",
          "driver-btm-c5.c",
          1768,
          "jump_to_app_CheckAndRestorePIC_T9_18",
          a1);
      fclose(v5);
    }
  }
  dsPIC33EP16GS202_jump_to_app_from_loader((unsigned __int8)a1);
  result = dsPIC33EP16GS202_get_pic_sw_version((unsigned __int8)a1, &v9);
  if ( (unsigned int)log_level > 3 )
  {
    v7 = fopen(log_file, "a+");
    v8 = v7;
    if ( v7 )
      fprintf(
        v7,
        "%s:%d:%s: Check chain[%d] PIC fw version=0x%02x\n",
        "driver-btm-c5.c",
        1773,
        "jump_to_app_CheckAndRestorePIC_T9_18",
        a1,
        v9);
    return fclose(v8);
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0002E8DC) --------------------------------------------------------
int reset_iic_pic()
{
  return (unsigned __int8)dsPIC33EP16GS202_reset_pic();
}
// 3F8E8: using guessed type int dsPIC33EP16GS202_reset_pic(void);

//----- (0002E8E8) --------------------------------------------------------
int __fastcall get_pic_iic_flash_addr_pointer(char a1, _BYTE *a2, _BYTE *a3)
{
  int v4; // r4
  int v6; // r0
  int result; // r0

  v4 = (a1 & 0xF) << 16;
  send_pic_command(a1);
  v6 = v4 | 0x400000;
  v4 |= 37748736u;
  set_pic_iic(v6 | 8);
  *a2 = set_pic_iic(v4);
  result = set_pic_iic(v4);
  *a3 = result;
  return result;
}

//----- (0002E91C) --------------------------------------------------------
int __fastcall set_pic_iic_flash_addr_pointer(int a1, int a2, int a3)
{
  int v3; // r7
  int v4; // r6
  int v5; // r10
  int v8; // r7
  int v9; // r5
  int result; // r0
  FILE *v11; // r0
  FILE *v12; // r11
  unsigned __int8 v14; // [sp+2Eh] [bp-2Ah] BYREF
  unsigned __int8 v15; // [sp+2Fh] [bp-29h] BYREF

  v3 = ((a1 & 0xF) << 16) | 0x400000;
  v4 = ((a1 & 0xF) << 16) | 0x400001;
  v5 = a3 | v3;
  v8 = v3 | a2;
  v9 = 4;
  while ( 1 )
  {
    send_pic_command(a1);
    set_pic_iic(v4);
    set_pic_iic(v8);
    set_pic_iic(v5);
    result = get_pic_iic_flash_addr_pointer(a1, &v14, &v15);
    if ( v14 == a2 && v15 == a3 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v11 = fopen(log_file, "a+");
      v12 = v11;
      if ( v11 )
        fprintf(
          v11,
          "%s:%d:%s: Error of set PIC FLASH addr: addr_H=%x(%x) addr_L=%x(%x) on Chain[%d]\n",
          "driver-btm-c5.c",
          1326,
          "set_pic_iic_flash_addr_pointer",
          a2,
          v14,
          a3,
          v15,
          a1);
      fclose(v12);
      --v9;
      result = a1;
      if ( !v9 )
        return result;
    }
    else
    {
      --v9;
      result = a1;
      if ( !v9 )
        return result;
    }
    dsPIC33EP16GS202_reset_pic(result);
    sleep(5u);
  }
  return result;
}
// 3F8E8: using guessed type int __fastcall dsPIC33EP16GS202_reset_pic(_DWORD);
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0002EA0C) --------------------------------------------------------
int __fastcall erase_pic_flash_all(int a1)
{
  int v1; // r4
  char v2; // r5
  int result; // r0

  v1 = 100;
  v2 = a1;
  set_pic_iic_flash_addr_pointer(a1, 3, 0);
  do
  {
    result = erase_pic_flash(v2);
    --v1;
  }
  while ( v1 );
  return result;
}

//----- (0002EA28) --------------------------------------------------------
int __fastcall write_EEPROM_iic(int a1, int a2, int a3, char a4, unsigned __int8 a5)
{
  int v5; // r4
  int v10; // r0

  v5 = 4;
  get_iic();
  do
  {
    usleep(1000u);
    get_iic();
    --v5;
  }
  while ( v5 );
  if ( a1 )
    v10 = 33554432;
  else
    v10 = 0;
  if ( a2 )
    v10 |= (a3 << 8) | 0x1000000;
  return set_iic(v10 | a5 | 0xA00000 | ((a4 & 0xF) << 16));
}

//----- (0002EA7C) --------------------------------------------------------
int __fastcall AT24C02_read_bytes_part_7(int result, _BYTE *a2, char a3, int a4)
{
  int v4; // r7
  int v6; // r4
  int v8; // r2

  if ( a4 )
  {
    v4 = (unsigned __int8)(result + a4);
    v6 = result;
    do
    {
      v8 = v6;
      v6 = (unsigned __int8)(v6 + 1);
      result = write_EEPROM_iic(1, 1, v8, a3, 0);
      *a2++ = result;
    }
    while ( v6 != v4 );
  }
  return result;
}

//----- (0002EAB8) --------------------------------------------------------
int __fastcall get_temperature_offset_value(char a1, _BYTE *a2)
{
  return AT24C02_read_bytes_part_7(152, a2, a1, 8);
}

//----- (0002EAC0) --------------------------------------------------------
int __fastcall AT24C02_write_one_byte(int a1, unsigned __int8 a2, char a3)
{
  return write_EEPROM_iic(0, 1, a1, a3, a2);
}

//----- (0002EAD8) --------------------------------------------------------
int __fastcall AT24C02_read_one_byte(int a1, char a2)
{
  return write_EEPROM_iic(1, 1, a1, a2, 0);
}

//----- (0002EAF0) --------------------------------------------------------
int __fastcall AT24C02_write_bytes(int result, int a2, char a3, int a4)
{
  unsigned __int8 v4; // r8
  int v6; // r5
  int v7; // r4
  unsigned __int8 v8; // t1
  int v9; // r2

  v4 = result + a4;
  if ( result + a4 <= 256 && a4 )
  {
    v6 = a2 - 1;
    v7 = result;
    do
    {
      v8 = *(_BYTE *)++v6;
      v9 = v7;
      v7 = (unsigned __int8)(v7 + 1);
      result = write_EEPROM_iic(0, 1, v9, a3, v8);
    }
    while ( v7 != v4 );
  }
  return result;
}

//----- (0002EB2C) --------------------------------------------------------
int __fastcall AT24C02_read_bytes(int result, _BYTE *a2, char a3, int a4)
{
  if ( result + a4 <= 256 )
    return AT24C02_read_bytes_part_7(result, a2, a3, a4);
  return result;
}

//----- (0002EB44) --------------------------------------------------------
int __fastcall read_disabled_cores(char a1, _BYTE *a2)
{
  AT24C02_read_bytes_part_7(160, a2, a1, 16);
  return 16;
}

//----- (0002EB54) --------------------------------------------------------
int __fastcall get_chain_data_file_path(int result, char *s)
{
  if ( s )
    return j_sprintf(s, "/config/hashBoardData_chain%d", result);
  return result;
}

//----- (0002EB6C) --------------------------------------------------------
FILE *__fastcall save_chain_data_to_file(FILE *result, const void *a2, size_t a3)
{
  FILE *v3; // r5
  FILE *v6; // r5
  char v7[216]; // [sp+0h] [bp-D8h] BYREF

  if ( a2 )
  {
    v3 = result;
    memset(v7, 0, 200u);
    sprintf(v7, "/config/hashBoardData_chain%d", v3);
    result = fopen(v7, "wb+");
    v6 = result;
    if ( result )
    {
      fwrite(a2, a3, 1u, result);
      return (FILE *)fclose(v6);
    }
  }
  return result;
}

//----- (0002EBBC) --------------------------------------------------------
FILE *__fastcall read_chain_data_from_file(FILE *result, void *a2, size_t a3)
{
  FILE *v3; // r5
  FILE *v6; // r5
  char v7[216]; // [sp+0h] [bp-D8h] BYREF

  if ( a2 )
  {
    v3 = result;
    memset(v7, 0, 200u);
    sprintf(v7, "/config/hashBoardData_chain%d", v3);
    result = fopen(v7, "rb");
    v6 = result;
    if ( result )
    {
      fread(a2, a3, 1u, result);
      return (FILE *)fclose(v6);
    }
  }
  return result;
}

//----- (0002EC0C) --------------------------------------------------------
int __fastcall read_freq_badcores(char a1, _BYTE *a2)
{
  AT24C02_read_bytes_part_7(0, a2, a1, 128);
  return 128;
}

//----- (0002EC1C) --------------------------------------------------------
int __fastcall save_freq_badcores(char a1, int a2)
{
  int v3; // r5
  int v4; // r4
  unsigned __int8 v5; // t1
  int v6; // r2

  v3 = a2 - 1;
  v4 = 0;
  do
  {
    v5 = *(_BYTE *)++v3;
    v6 = v4;
    v4 = (unsigned __int8)(v4 + 1);
    write_EEPROM_iic(0, 1, v6, a1, v5);
  }
  while ( v4 != 128 );
  return 128;
}

//----- (0002EC48) --------------------------------------------------------
int __fastcall AT24C02_save_voltage(char a1, unsigned __int8 a2)
{
  return write_EEPROM_iic(0, 1, 144, a1, a2);
}

//----- (0002EC60) --------------------------------------------------------
int __fastcall set_Voltage_S9_plus_plus_BM1387_54(int a1, unsigned __int8 a2)
{
  unsigned __int8 v2; // r9
  int v5; // r7
  int v6; // r6
  int v7; // r0
  bool v8; // zf
  int v9; // r0
  FILE *v11; // r0
  FILE *v12; // r11

  if ( (a2 & 0x80) != 0 )
    return 0;
  v2 = a2 + 23;
  v5 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 7u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 16u);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, v2);
    usleep((__useconds_t)&loc_1869E + 2);
    v6 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v7 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v8 = v6 == 16;
    if ( v6 == 16 )
      v8 = v7 == 1;
    v9 = !v8;
    if ( v8 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v11 = fopen(log_file, "a+");
      v12 = v11;
      if ( v11 )
        fprintf(
          v11,
          "%s:%d:%s: %s failed on Chain[%d]!\n\n",
          "driver-btm-c5.c",
          2542,
          "set_Voltage_S9_plus_plus_BM1387_54",
          "set_Voltage_S9_plus_plus_BM1387_54",
          a1);
      fclose(v12);
    }
    sleep(1u);
    if ( !--v5 )
      return 0;
  }
  write_EEPROM_iic(v9, 1, 144, a1, a2);
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0002EDC0) --------------------------------------------------------
int __fastcall get_pic_voltage(char a1)
{
  return write_EEPROM_iic(1, 1, 144, a1, 0);
}

//----- (0002EDE0) --------------------------------------------------------
int __fastcall get_pll_index_for_lowpower_mode(int a1)
{
  int result; // r0
  FILE *v2; // r0
  FILE *v3; // r4

  switch ( a1 )
  {
    case 0:
      result = 67;
      break;
    case 1:
      result = 66;
      break;
    case 2:
      result = 64;
      break;
    case 3:
      result = 63;
      break;
    default:
      if ( (unsigned int)log_level > 3 )
      {
        v2 = fopen(log_file, "a+");
        v3 = v2;
        if ( v2 )
          fprintf(
            v2,
            "%s:%d:%s: get wrong freq index for low power mode of S11\n",
            "driver-btm-c5.c",
            2587,
            "get_pll_index_for_lowpower_mode");
        fclose(v3);
        result = 52;
      }
      else
      {
        result = 52;
      }
      break;
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0002EE58) --------------------------------------------------------
int __fastcall set_voltage_setting_time(char a1, unsigned __int8 *a2)
{
  send_pic_command(a1);
  send_data_to_pic_iic(a1, 17, a2, 6);
  return cgsleep_us();
}

//----- (0002EE80) --------------------------------------------------------
int __fastcall set_hash_board_id_number(char a1, unsigned __int8 *a2)
{
  send_pic_command(a1);
  send_data_to_pic_iic(a1, 18, a2, 12);
  return cgsleep_us();
}

//----- (0002EEA8) --------------------------------------------------------
int __fastcall get_hash_board_id_number(char a1, _BYTE *a2)
{
  return AT24C02_read_bytes_part_7(128, a2, a1, 12);
}

//----- (0002EEB0) --------------------------------------------------------
int __fastcall write_host_MAC_and_time(char a1, unsigned __int8 *a2)
{
  send_pic_command(a1);
  send_data_to_pic_iic(a1, 20, a2, 12);
  return cgsleep_us();
}

//----- (0002EED8) --------------------------------------------------------
int __fastcall enable_pic_dc_dc(char a1)
{
  int v1; // r4

  v1 = (a1 & 0xF) << 16;
  send_pic_command(a1);
  set_pic_iic(v1 | 0x400015);
  return set_pic_iic(v1 | 0x400001);
}

//----- (0002EF04) --------------------------------------------------------
int enable_pic_dc_dc_all()
{
  int i; // r4
  char v1; // r0
  int result; // r0

  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dev + 4 * (i + 2)) != 1 )
    {
      if ( ++i == 16 )
        return result;
    }
    v1 = i;
    enable_pic_dc_dc(v1);
    result = cgsleep_ms();
  }
  return result;
}
// 817C28: using guessed type int dev;

//----- (0002EF38) --------------------------------------------------------
int __fastcall getChainPICMagicNumber(int a1)
{
  return *((unsigned __int8 *)&unk_707D98 + 128 * a1 + 3388);
}

//----- (0002EF4C) --------------------------------------------------------
int __fastcall enable_pic_dac(int a1)
{
  int v2; // r3
  FILE *v4; // r0
  FILE *v5; // r6
  FILE *v6; // r0
  char s[116]; // [sp+Ch] [bp-74h] BYREF

  v2 = is7007_ctrl_board;
  if ( is7007_ctrl_board == -1 )
  {
    isC5_Board();
    v2 = is7007_ctrl_board;
  }
  if ( v2 == 1 )
  {
    sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio907/value");
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_5;
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: %s\n", "driver-btm-c5.c", 2809, "enable_pic_dac", s);
LABEL_9:
    fclose(v5);
    goto LABEL_5;
  }
  sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio36/value");
  if ( (unsigned int)log_level > 3 )
  {
    v6 = fopen(log_file, "a+");
    v5 = v6;
    if ( v6 )
      fprintf(v6, "%s:%d:%s: %s\n", "driver-btm-c5.c", 2816, "enable_pic_dac", s);
    goto LABEL_9;
  }
LABEL_5:
  system(s);
  return dsPIC33EP16GS202_enable_pic_dc_dc(a1, 1);
}
// 7E55C: using guessed type int is7007_ctrl_board;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0002F054) --------------------------------------------------------
int __fastcall disable_pic_dac(int a1)
{
  int v2; // r2
  FILE *v4; // r0
  FILE *v5; // r6
  FILE *v6; // r0
  char s[116]; // [sp+Ch] [bp-74h] BYREF

  v2 = is7007_ctrl_board;
  if ( is7007_ctrl_board == -1 )
  {
    isC5_Board();
    v2 = is7007_ctrl_board;
  }
  if ( v2 == 1 )
  {
    sprintf(s, "echo %d > %s", 1, "/sys/class/gpio/gpio907/value");
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_5;
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: %s\n", "driver-btm-c5.c", 2832, "disable_pic_dac", s);
LABEL_9:
    fclose(v5);
    goto LABEL_5;
  }
  sprintf(s, "echo %d > %s", 1, "/sys/class/gpio/gpio36/value");
  if ( (unsigned int)log_level > 3 )
  {
    v6 = fopen(log_file, "a+");
    v5 = v6;
    if ( v6 )
      fprintf(v6, "%s:%d:%s: %s\n", "driver-btm-c5.c", 2839, "disable_pic_dac", s);
    goto LABEL_9;
  }
LABEL_5:
  system(s);
  return dsPIC33EP16GS202_enable_pic_dc_dc(a1, 0);
}
// 7E55C: using guessed type int is7007_ctrl_board;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0002F158) --------------------------------------------------------
bool __fastcall pic_heart_beat_each_chain(char a1)
{
  return dsPIC33EP16GS202_pic_heart_beat(a1) == 1;
}

//----- (0002F16C) --------------------------------------------------------
void check_chain()
{
  int hash_on_plug; // r0
  int v1; // r1
  int v2; // r2
  int v3; // r2
  int v4; // r1
  _BYTE *v5; // r5
  int v6; // r4
  int v7; // r3
  bool v8; // zf
  int v9; // r3
  const char *v10; // r3

  *(_BYTE *)(dev + 21501) = 0;
  hash_on_plug = get_hash_on_plug();
  if ( hash_on_plug < 0 )
  {
    if ( opt_debug )
    {
      v10 = (const char *)(unsigned __int8)use_syslog;
      if ( use_syslog
        || (v10 = (const char *)(unsigned __int8)opt_log_output, opt_log_output)
        || (v10 = (const char *)opt_log_level, opt_log_level > 6) )
      {
        check_chain_part_9(hash_on_plug, v1, v2, v10);
      }
    }
  }
  else
  {
    v3 = 0;
    v4 = dev + 8;
    v5 = (_BYTE *)(dev + 21501);
    v6 = dev + 8;
    do
    {
      v7 = hash_on_plug >> v3++;
      v4 += 4;
      v9 = v7 & 1;
      v8 = v9 == 0;
      v6 += 4;
      if ( v9 )
      {
        *(_DWORD *)(v4 - 4) = 1;
        LOBYTE(v9) = *v5;
      }
      else
      {
        *(_DWORD *)(v6 - 4) = 0;
      }
      if ( !v8 )
        *v5 = v9 + 1;
    }
    while ( v3 != 16 );
  }
}
// 2F1F6: variable 'v1' is possibly undefined
// 2F1F6: variable 'v2' is possibly undefined
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (0002F1FC) --------------------------------------------------------
unsigned int *check_fan()
{
  int v0; // r9
  int v1; // r1
  int v2; // r4
  unsigned int *result; // r0
  unsigned int v4; // r1
  bool v5; // cf
  int v6; // r1
  int v7; // lr
  int v8; // r2
  unsigned int v9; // r3
  int v10; // r1
  char v11; // lr
  int v12; // r1
  unsigned __int8 v13; // [sp+3h] [bp-25h] BYREF
  int v14; // [sp+4h] [bp-24h] BYREF

  v0 = 2;
  v1 = dev;
  v13 = 0;
  *(_DWORD *)(dev + 21504) = 0;
  *(_DWORD *)(v1 + 21508) = 0;
  do
  {
    v2 = 8;
    do
    {
      while ( 1 )
      {
        result = (unsigned int *)(get_fan_speed(&v13, &v14) + 1);
        if ( !result )
          goto LABEL_10;
        v6 = v14;
        v7 = v13;
        v8 = dev;
        v9 = 120 * v14;
        *(_DWORD *)(dev + 4 * (v13 + 5346) + 4) = 120 * v14;
        if ( v6 )
        {
          if ( !*(_BYTE *)(v8 + v7 + 21380) )
          {
            *(_BYTE *)(v8 + v7 + 21380) = 1;
            v10 = 1 << v7;
            v11 = *(_BYTE *)(v8 + 21502);
            *(_DWORD *)(v8 + 76) |= v10;
            *(_BYTE *)(v8 + 21502) = v11 + 1;
          }
        }
        else if ( *(_BYTE *)(v8 + v7 + 21380) == 1 )
        {
          *(_BYTE *)(v8 + v7 + 21380) = 0;
          v12 = *(_DWORD *)(v8 + 76) & 1;
          if ( 1 << v7 )
            v12 = 0;
          --*(_BYTE *)(v8 + 21502);
          *(_DWORD *)(v8 + 76) = v12;
        }
        result = (unsigned int *)(v8 + 21504);
        v4 = *(_DWORD *)(v8 + 21508);
        if ( v9 > *(_DWORD *)(v8 + 21504) )
          *result = v9;
        v5 = 1;
        if ( v9 )
          v5 = v9 >= v4;
        if ( v5 && v4 )
          break;
        *(_DWORD *)(v8 + 21508) = v9;
LABEL_10:
        if ( !--v2 )
          goto LABEL_17;
      }
      --v2;
    }
    while ( v2 );
LABEL_17:
    --v0;
  }
  while ( v0 );
  return result;
}
// 817C28: using guessed type int dev;

//----- (0002F2E8) --------------------------------------------------------
unsigned int check_fan_beforeInit()
{
  int v0; // r4
  int v1; // r7
  unsigned int v2; // lr
  unsigned int *v3; // r2
  bool v4; // cc
  int v5; // r7
  int v6; // r2
  int v7; // r1
  int v8; // r10
  int v9; // lr
  unsigned int v10; // r3
  char v11; // r12
  unsigned int result; // r0
  int v13; // r3
  FILE *v14; // r0
  FILE *v15; // r7
  FILE *v16; // r0
  FILE *v17; // r7
  FILE *v18; // r0
  FILE *v19; // r10
  FILE *v20; // r0
  FILE *v21; // r7
  int v22; // [sp+10h] [bp-38h]
  unsigned __int8 v23; // [sp+1Bh] [bp-2Dh] BYREF
  int v24; // [sp+1Ch] [bp-2Ch] BYREF

  v23 = 0;
  v22 = 2;
  do
  {
    v0 = 8;
    do
    {
      while ( 1 )
      {
        if ( get_fan_speed(&v23, &v24) == -1 )
          goto LABEL_12;
        v5 = v24;
        v6 = dev;
        v7 = v23;
        v8 = dev + v23;
        v9 = dev + 4 * v23;
        v10 = 120 * v24;
        *(_DWORD *)(v9 + 21388) = 120 * v24;
        if ( !v5 )
        {
          if ( *(_BYTE *)(v8 + 21380) == 1 )
          {
            *(_BYTE *)(v8 + 21380) = 0;
            v13 = *(_DWORD *)(v6 + 76) & 1;
            if ( 1 << v7 )
              v13 = 0;
            --*(_BYTE *)(v6 + 21502);
            *(_DWORD *)(v6 + 76) = v13;
            v10 = *(_DWORD *)(v9 + 21388);
          }
LABEL_4:
          v1 = print_num_13028;
          goto LABEL_5;
        }
        if ( *(_BYTE *)(v8 + 21380) )
        {
          if ( *(_BYTE *)(v8 + 21380) != 1 )
            goto LABEL_4;
        }
        else
        {
          *(_BYTE *)(v8 + 21380) = 1;
          v11 = *(_BYTE *)(v6 + 21502);
          *(_DWORD *)(v6 + 76) |= 1 << v7;
          *(_BYTE *)(v6 + 21502) = v11 + 1;
        }
        v1 = print_num_13028;
        if ( print_num_13028 <= 99 && (v1 = print_num_13028 + 1, ++print_num_13028, (unsigned int)log_level > 3) )
        {
          v18 = fopen(log_file, "a+");
          v19 = v18;
          if ( v18 )
            fprintf(
              v18,
              "%s:%d:%s: get fan[%d] speed=%d\n",
              "driver-btm-c5.c",
              3006,
              "check_fan_beforeInit",
              v23,
              *(_DWORD *)(dev + 4 * (v23 + 5346) + 4));
          fclose(v19);
          v1 = print_num_13028;
          if ( print_num_13028 <= 99 || (unsigned int)log_level <= 3 )
          {
            v7 = v23;
            v6 = dev;
            v10 = *(_DWORD *)(dev + 4 * (v23 + 5346) + 4);
          }
          else
          {
            v20 = fopen(log_file, "a+");
            v21 = v20;
            if ( v20 )
              fprintf(
                v20,
                "%s:%d:%s: Fatal Error: some Fan lost or Fan speed low!\n",
                "driver-btm-c5.c",
                3010,
                "check_fan_beforeInit");
            fclose(v21);
            v7 = v23;
            v6 = dev;
            v1 = print_num_13028;
            v10 = *(_DWORD *)(dev + 4 * (v23 + 5346) + 4);
          }
        }
        else
        {
          v10 = *(_DWORD *)(v9 + 21388);
        }
LABEL_5:
        if ( *(_DWORD *)(v6 + 21504) < v10 )
          *(_DWORD *)(v6 + 21504) = v10;
        v2 = *(_DWORD *)(v6 + 21508);
        v3 = (unsigned int *)(v6 + 21508);
        v4 = v10 != 0;
        if ( v10 )
          v4 = v2 > v10;
        if ( !v4 && v2 )
          break;
        *v3 = v10;
        if ( v1 == 30 )
          goto LABEL_22;
LABEL_12:
        if ( !--v0 )
          goto LABEL_24;
      }
      if ( v1 != 30 )
        goto LABEL_12;
LABEL_22:
      if ( (unsigned int)log_level > 3 )
      {
        v14 = fopen(log_file, "a+");
        v15 = v14;
        if ( v14 )
          fprintf(v14, "%s:%d:%s: waiting fans become stable...\n", "driver-btm-c5.c", 3023, "check_fan_beforeInit");
        fclose(v15);
        if ( (unsigned int)log_level > 5 )
        {
          v16 = fopen(log_file, "a+");
          v17 = v16;
          if ( v16 )
            fprintf(v16, "%s:%d:%s: reset dev->fan_speed_low1\n", "driver-btm-c5.c", 3024, "check_fan_beforeInit");
          fclose(v17);
        }
        v7 = v23;
      }
      --v0;
      *(_DWORD *)(dev + 21508) = *(_DWORD *)(dev + 4 * (v7 + 5346) + 4);
    }
    while ( v0 );
LABEL_24:
    result = sleep(1u);
    --v22;
  }
  while ( v22 );
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 70939C: using guessed type int print_num_13028;
// 817C28: using guessed type int dev;

//----- (0002F57C) --------------------------------------------------------
int __fastcall set_PWM(int a1)
{
  char v1; // r3
  void *v2; // r1
  int v3; // r2

  if ( a1 <= 19 )
  {
    v2 = &unk_A0028;
    v1 = 20;
  }
  else if ( a1 <= 100 )
  {
    v1 = a1;
    v2 = (void *)((a1 >> 1 << 16) | ((100 - a1) >> 1));
  }
  else
  {
    v1 = 100;
    v2 = &unk_320000;
  }
  v3 = dev;
  *(_DWORD *)(dev + 4) = v2;
  *(_BYTE *)(v3 + 21500) = v1;
  return set_fan_control((int)v2);
}
// 817C28: using guessed type int dev;

//----- (0002F5C4) --------------------------------------------------------
int isTempTooLow()
{
  int v0; // r3
  int v1; // r4
  int v2; // r1
  int v3; // t1
  int v4; // r5
  int v5; // r0
  int v6; // r12
  FILE *v8; // r0
  FILE *v9; // r8
  FILE *v10; // r0
  FILE *v11; // r6

  v0 = dev;
  v1 = 0;
  v2 = dev + 4;
  while ( 1 )
  {
    v3 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    if ( v3 != 1 )
      goto LABEL_2;
    v4 = v1;
    if ( chain_temp_toolow[v1] )
      goto LABEL_2;
    v5 = *(__int16 *)(v0 + 1392);
    if ( v5 <= 0 )
      goto LABEL_2;
    v6 = lowest_testOK_temp[v4];
    if ( v6 <= 0 )
      break;
    if ( v6 > v5 )
    {
      if ( (unsigned int)log_level <= 3 )
        return 1;
      v8 = fopen(log_file, "a+");
      v9 = v8;
      if ( v8 )
        fprintf(
          v8,
          "%s:%d:%s: Detect temp too low: Chain[%d] lowest_testOK_temp=%d curtemp=%d\n",
          "driver-btm-c5.c",
          3082,
          "isTempTooLow",
          v1,
          *(_DWORD *)((char *)&unk_708E90 + v4 * 4 + 1360),
          *(__int16 *)(dev + (v1 << 6) + 1392));
      fclose(v9);
      return 1;
    }
LABEL_2:
    ++v1;
    v0 += 64;
    if ( v1 == 16 )
      return 0;
  }
  if ( v5 > 79 )
    goto LABEL_2;
  if ( (unsigned int)log_level > 3 )
  {
    v10 = fopen(log_file, "a+");
    v11 = v10;
    if ( v10 )
      fprintf(
        v10,
        "%s:%d:%s: Detect temp too low: Chain[%d] curtemp=%d\n",
        "driver-btm-c5.c",
        3075,
        "isTempTooLow",
        v1,
        *(__int16 *)(dev + (v1 << 6) + 1392));
    fclose(v11);
  }
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 7093A0: using guessed type int chain_temp_toolow[16];
// 7093E0: using guessed type int lowest_testOK_temp[];
// 817C28: using guessed type int dev;

//----- (0002F6F0) --------------------------------------------------------
int CheckChainTempTooLowFlag()
{
  int *v0; // r2
  int v1; // r6
  int *v2; // r3
  int v3; // r5
  int v4; // r1
  int result; // r0
  int v6; // t1
  int v7; // t1

  v0 = chain_temp_toolow;
  v1 = 0;
  v2 = chain_temp_toolow;
  v3 = dev + 4;
  v4 = dev + 4;
  do
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v4 + 4);
      v4 += 4;
      result = v6;
      if ( v6 == 1 )
        break;
      if ( ++v2 == lowest_testOK_temp )
        goto LABEL_7;
    }
    result = *v2++;
    if ( !result )
      v1 = 1;
  }
  while ( v2 != lowest_testOK_temp );
LABEL_7:
  if ( !v1 )
  {
    do
    {
      v7 = *(_DWORD *)(v3 + 4);
      v3 += 4;
      ++v0;
      if ( v7 == 1 )
        *(v0 - 1) = v1;
    }
    while ( v0 != lowest_testOK_temp );
  }
  return result;
}
// 7093A0: using guessed type int chain_temp_toolow[16];
// 7093E0: using guessed type int lowest_testOK_temp[];
// 817C28: using guessed type int dev;

//----- (0002F744) --------------------------------------------------------
int setChainTempTooLowFlag()
{
  int *v0; // r5
  int *v1; // r6
  int v2; // r4
  int v3; // r2
  int v4; // r11
  int v5; // r3
  FILE *v7; // r0
  FILE *v8; // r0
  FILE *stream; // [sp+14h] [bp-2Ch]

  v0 = chain_temp_toolow;
  v1 = lowest_testOK_temp;
  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = dev;
      *v0 = 0;
      if ( *(_DWORD *)(v3 + 4 * (v2 + 2)) != 1 )
        goto LABEL_2;
      v4 = v2 + 301;
      v5 = *(__int16 *)(v3 + 8 * (v2 + 301));
      if ( v5 <= 0 )
        goto LABEL_2;
      if ( *v1 <= 0 )
        break;
      if ( *v1 > v5 )
      {
        if ( (unsigned int)log_level <= 3 )
          goto LABEL_8;
        v8 = fopen(log_file, "a+");
        stream = v8;
        if ( v8 )
          fprintf(
            v8,
            "%s:%d:%s: Detect Chain[%d] temp too low, will ignore: temp=%d < %d\n",
            "driver-btm-c5.c",
            3139,
            "setChainTempTooLowFlag",
            v2,
            *(__int16 *)(dev + 8 * v4),
            *v1);
        goto LABEL_16;
      }
LABEL_2:
      ++v2;
      ++v0;
      ++v1;
      if ( v2 == 16 )
        return CheckChainTempTooLowFlag();
    }
    if ( v5 > 79 )
      goto LABEL_2;
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_8;
    v7 = fopen(log_file, "a+");
    stream = v7;
    if ( v7 )
      fprintf(
        v7,
        "%s:%d:%s: Detect Chain[%d] temp too low, will ignore: temp=%d\n",
        "driver-btm-c5.c",
        3131,
        "setChainTempTooLowFlag",
        v2,
        *(__int16 *)(dev + 8 * v4));
LABEL_16:
    fclose(stream);
LABEL_8:
    ++v2;
    *v0 = 1;
    ++v1;
    ++v0;
  }
  while ( v2 != 16 );
  return CheckChainTempTooLowFlag();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 7093A0: using guessed type int chain_temp_toolow[16];
// 7093E0: using guessed type int lowest_testOK_temp[];
// 817C28: using guessed type int dev;

//----- (0002F85C) --------------------------------------------------------
int set_PWM_according_to_temperature()
{
  double v0; // d5
  int v1; // r4
  int v2; // r3
  double v3; // d4
  int v4; // s15
  double v5; // d7
  double v6; // d8
  unsigned int v7; // r3
  int result; // r0
  _BOOL4 v9; // r3
  double v10; // d7
  int v11; // r3
  const char *i; // r2
  int v13; // r6
  int v14; // r2
  int v15; // r3
  int v16; // r3
  int v17; // r4
  int v18; // r2
  int v19; // r3
  bool v20; // nf
  int v21; // r2
  int v22; // r3
  double v23; // d6
  double v24; // d5
  int v25; // r3
  FILE *v26; // r0
  FILE *v27; // r7
  FILE *v28; // r0
  FILE *v29; // r4
  FILE *v30; // r0
  FILE *v31; // r8
  FILE *v32; // r0
  FILE *v33; // r9
  int v34; // r3
  FILE *v35; // r0
  FILE *v36; // r0
  FILE *v37; // r8

  v0 = 0.0;
  v1 = 0;
  v2 = dev;
  v3 = 0.0;
  do
  {
    if ( *(_WORD *)(v2 + 1386) && *(_WORD *)(v2 + 1394) )
    {
      ++v1;
      v0 = v0 + (double)*(__int16 *)(v2 + 1386);
      v3 = v3 + (double)*(__int16 *)(v2 + 1394);
    }
    v2 += 64;
  }
  while ( dev + 1024 != v2 );
  v4 = v1;
  LOWORD(v1) = (unsigned __int16)&unk_708E90;
  v5 = (double)v4;
  v6 = v0 / v5;
  if ( v3 / v5 <= 85.0 )
  {
    HIWORD(v1) = (unsigned int)&unk_708E90 >> 16;
    *(_DWORD *)(v1 + 1424) = 0;
    cgtime((struct timeval *)(v1 + 1436));
    v18 = *(_DWORD *)(v1 + 1436);
    result = *(_DWORD *)(v1 + 1428);
    v19 = *(_DWORD *)(v1 + 1440) - *(_DWORD *)(v1 + 1432);
    v20 = v19 < 0;
    *(_DWORD *)(v1 + 1448) = v19;
    v21 = v18 - result;
    v22 = v19 + (v19 < 0 ? 999424 : 0);
    *(_DWORD *)(v1 + 1444) = v21;
    if ( v20 )
    {
      --v21;
      *(_DWORD *)(v1 + 1448) = v22 + 576;
      *(_DWORD *)(v1 + 1444) = v21;
    }
    if ( v21 > 60 )
    {
      if ( fan_mode_13087 )
      {
        if ( (unsigned int)log_level > 3 )
        {
          v36 = fopen(log_file, "a+");
          v37 = v36;
          if ( v36 )
            fprintf(
              v36,
              "%s:%d:%s: %s: fan set normal mode\n",
              "driver-btm-c5.c",
              3307,
              "set_PWM_according_to_temperature",
              "set_PWM_according_to_temperature");
          result = fclose(v37);
        }
        fan_mode_13087 = 0;
      }
      goto LABEL_10;
    }
  }
  else
  {
    HIWORD(v1) = (unsigned int)&unk_708E90 >> 16;
    v7 = *(_DWORD *)(v1 + 1424) + 1;
    *(_DWORD *)(v1 + 1424) = v7;
    if ( v7 > 4 && fan_mode_13087 != 1 )
    {
      if ( (unsigned int)log_level > 3 )
      {
        v30 = fopen(log_file, "a+");
        v31 = v30;
        if ( v30 )
          fprintf(
            v30,
            "%s:%d:%s: %s: fan set force mode\n",
            "driver-btm-c5.c",
            3295,
            "set_PWM_according_to_temperature",
            "set_PWM_according_to_temperature");
        fclose(v31);
      }
      fan_mode_13087 = 1;
    }
    result = cgtime((struct timeval *)&force_mode_timepoint_13088);
  }
  if ( fan_mode_13087 == 1 )
  {
LABEL_18:
    v13 = 100;
    goto LABEL_19;
  }
LABEL_10:
  v9 = v6 == 0.0;
  if ( v3 / v5 != 0.0 )
    v9 = 0;
  if ( v9 )
    goto LABEL_18;
  v10 = 65.0;
  if ( v6 >= 65.0 )
  {
    v23 = 100.0;
    v24 = 0.0;
  }
  else
  {
    result = 62;
    v11 = 1;
    for ( i = "d"; ; result = *((_DWORD *)i + 5) )
    {
      i += 16;
      v10 = (double)result;
      if ( v6 >= (double)result )
        break;
      if ( ++v11 == 6 )
      {
        v23 = 0.0;
        v24 = 0.0;
        v10 = 0.0;
        goto LABEL_47;
      }
    }
    v34 = 16 * v11;
    v24 = *(double *)&fan_spend_temp_arg[v34 + 8];
    v23 = (double)*(int *)&_PRETTY_FUNCTION___14958[v34 + 2872];
  }
LABEL_47:
  v13 = (int)(v23 + (v6 - v10) * v24);
LABEL_19:
  if ( !*(_BYTE *)(v1 + 1452) || v6 >= 50.0 )
  {
    if ( v13 - (unsigned int)*(unsigned __int8 *)(dev + 21570) + 1 <= 2 )
      return result;
    if ( (unsigned int)log_level > 5 )
    {
      v32 = fopen(log_file, "a+");
      v33 = v32;
      if ( v32 )
        fprintf(
          v32,
          "%s:%d:%s: %s: Set PWM percent : %d\n",
          "driver-btm-c5.c",
          3340,
          "set_PWM_according_to_temperature",
          "set_PWM_according_to_temperature",
          v13);
      fclose(v33);
    }
    v15 = is7007_ctrl_board;
    if ( is7007_ctrl_board == -1 )
    {
      isC5_Board();
      v15 = is7007_ctrl_board;
    }
    if ( v15 != 1 )
      goto LABEL_29;
    if ( *(_BYTE *)(v1 + 1454) )
    {
      v25 = (3 * v13) & ~((3 * v13) >> 31);
      if ( 3 * v13 < 0 )
        v25 = 3 * v13 + 3;
      v17 = v25 >> 2;
      if ( (unsigned int)log_level <= 3 )
        goto LABEL_39;
      v26 = fopen(log_file, "a+");
      v27 = v26;
      if ( v26 )
        fprintf(
          v26,
          "%s:%d:%s: %s: Set PWM percent : %d\n",
          "driver-btm-c5.c",
          3345,
          "set_PWM_according_to_temperature",
          "set_PWM_according_to_temperature",
          v17);
    }
    else
    {
      if ( !*(_BYTE *)(v1 + 1453) )
      {
LABEL_29:
        result = set_PWM((unsigned __int8)v13);
LABEL_30:
        *(_BYTE *)(dev + 21570) = v13;
        return result;
      }
      v16 = (3 * v13) & ~((3 * v13) >> 31);
      if ( 3 * v13 < 0 )
        v16 = 3 * v13 + 3;
      v17 = v16 >> 2;
      if ( (unsigned int)log_level <= 3 )
      {
LABEL_39:
        result = set_PWM((unsigned __int8)v17);
        goto LABEL_30;
      }
      v35 = fopen(log_file, "a+");
      v27 = v35;
      if ( v35 )
        fprintf(
          v35,
          "%s:%d:%s: %s: Set PWM percent : %d\n",
          "driver-btm-c5.c",
          3351,
          "set_PWM_according_to_temperature",
          "set_PWM_according_to_temperature",
          v17);
    }
    fclose(v27);
    goto LABEL_39;
  }
  if ( (unsigned int)log_level > 3 )
  {
    v28 = fopen(log_file, "a+");
    v29 = v28;
    if ( v28 )
      fprintf(
        v28,
        "%s:%d:%s: doing pre-heating, set fan pwm to 0...\n",
        "driver-btm-c5.c",
        3331,
        "set_PWM_according_to_temperature");
    fclose(v29);
  }
  v14 = dev;
  *(_DWORD *)(dev + 4) = 655400;
  *(_BYTE *)(v14 + 21500) = 20;
  result = set_fan_control(655400);
  *(_BYTE *)(dev + 21570) = 0;
  return result;
}
// 7E55C: using guessed type int is7007_ctrl_board;
// 7E560: using guessed type int fan_mode_13087;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 709424: using guessed type int force_mode_timepoint_13088;
// 817C28: using guessed type int dev;

//----- (0002FD04) --------------------------------------------------------
int __fastcall set_frequency_with_addr_plldatai(int a1, int a2, int a3, int a4)
{
  int v4; // r4
  int v6; // r5
  int v8; // r4
  int v9; // r0
  int v10; // r4
  int v12; // r0
  int v13; // r0
  unsigned int v14; // r6
  int v15; // r0
  int v16; // r0
  int v17; // [sp+0h] [bp-30h] BYREF
  int v18; // [sp+4h] [bp-2Ch]
  char v19; // [sp+8h] [bp-28h]
  int v20; // [sp+Ch] [bp-24h] BYREF
  int v21; // [sp+10h] [bp-20h]
  int v22; // [sp+14h] [bp-1Ch]

  v4 = opt_multi_version;
  v6 = *(_DWORD *)&_PRETTY_FUNCTION___14958[16 * a1 + 52];
  if ( opt_multi_version )
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    if ( a2 )
    {
      v8 = 1476984844;
      LOBYTE(v17) = 88;
    }
    else
    {
      v8 = 1208549388;
      LOBYTE(v17) = 72;
    }
    BYTE2(v17) = a3;
    LOBYTE(v18) = HIBYTE(v6);
    BYTE1(v18) = BYTE2(v6);
    BYTE2(v18) = BYTE1(v6);
    HIBYTE(v17) = 12;
    HIBYTE(v18) = v6;
    BYTE1(v17) = 9;
    v9 = CRC5(&v17, 64u);
    v19 = v9;
    v20 = v8 | (a3 << 8);
    v22 = v9 << 24;
    v21 = v6;
    while ( 1 )
    {
      v10 = get_BC_write_command();
      if ( v10 >= 0 )
        break;
      cgsleep_us();
    }
    set_BC_command_buffer(&v20);
    set_BC_write_command((a4 << 16) | 0x80800000 | v10 & 0xFFF0FFFF);
    return cgsleep_us();
  }
  else
  {
    v17 = opt_multi_version;
    v18 = opt_multi_version;
    LOBYTE(v17) = 7;
    v19 = opt_multi_version;
    v20 = opt_multi_version;
    v21 = opt_multi_version;
    v22 = opt_multi_version;
    v12 = CRC5(&v17, 27u);
    HIBYTE(v17) = v12;
    v20 = v12 | 0x7000000;
    set_BC_command_buffer(&v20);
    v13 = get_BC_write_command();
    v14 = (a4 << 16) | 0x80800000;
    set_BC_write_command(v13 & 0xFFF0FFFF | v14);
    cgsleep_us();
    v17 = v4;
    v21 = v4;
    LOBYTE(v17) = -126;
    v22 = v4;
    v18 = v4;
    v19 = v4;
    v20 = v4;
    v15 = CRC5(&v17, 27u);
    HIBYTE(v17) = v15;
    v20 = v15 | 0x82000000;
    set_BC_command_buffer(&v20);
    v16 = get_BC_write_command();
    set_BC_write_command(v16 & 0xFFF0FFFF | v14);
    return cgsleep_us();
  }
}
// 7DF98: using guessed type int opt_multi_version;

//----- (0002FE68) --------------------------------------------------------
int __fastcall get_pll_index(int a1)
{
  const char *v1; // r0
  char **v2; // r4
  int v3; // r5
  char s[28]; // [sp+4h] [bp-1Ch] BYREF

  sprintf(s, "%d", a1);
  v1 = "100";
  v2 = &off_60FF8;
  v3 = 0;
  while ( 1 )
  {
    v2 += 4;
    if ( !memcmp(v1, s, 4u) )
      return v3;
    if ( ++v3 == 114 )
      break;
    v1 = *(v2 - 4);
  }
  return -1;
}
// 60FF8: using guessed type char *off_60FF8;

//----- (0002FEB8) --------------------------------------------------------
int __fastcall get_freqvalue_by_index(int a1)
{
  return j_strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * a1 + 40], 0, 10);
}

//----- (0002FED0) --------------------------------------------------------
int get_total_rate_from_eeprom()
{
  pthread_mutex_t *v0; // r3
  int v1; // r4
  int v2; // r2
  int v3; // t1
  FILE *v5; // r0
  FILE *v6; // r5

  v0 = (pthread_mutex_t *)chain_pic_buf;
  v1 = 0;
  v2 = dev + 4;
  do
  {
    v3 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    v0 = (pthread_mutex_t *)((char *)v0 + 128);
    if ( v3 == 1 )
      v1 += *(int *)((char *)&v0[-2].__align + 6);
  }
  while ( v0 != &nonce_mutex );
  if ( (unsigned int)log_level <= 3 )
    return v1;
  v5 = fopen(log_file, "a+");
  v6 = v5;
  if ( v5 )
    fprintf(v5, "%s:%d:%s: totalrate = %d\n", "driver-btm-c5.c", 3769, "get_total_rate_from_eeprom", v1);
  fclose(v6);
  return v1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 817C28: using guessed type int dev;

//----- (0002FF5C) --------------------------------------------------------
int GetTotalRate()
{
  if ( opt_economic_mode )
    return GetTotalRate_part_12();
  else
    return ideal_total_hash_rate;
}
// 70943E: using guessed type char opt_economic_mode;
// 709440: using guessed type int ideal_total_hash_rate;

//----- (0002FF74) --------------------------------------------------------
int __fastcall GetRealBoardRate(int a1)
{
  int v2; // r8
  int *v3; // r6
  int *v4; // r4
  unsigned __int8 *v5; // r5
  int v6; // r3

  if ( *(_DWORD *)(dev + 4 * (a1 + 2)) != 1 )
    return 0;
  v2 = 0;
  v3 = &chain_badcore_num[256 * a1 + 84];
  v4 = &chain_badcore_num[256 * a1];
  v5 = (unsigned __int8 *)&chip_last_freq + 256 * a1 + 2;
  do
  {
    while ( *v4 > 14 )
    {
      ++v4;
      ++v5;
      if ( v4 == v3 )
        return v2 / 1000;
    }
    v6 = *v5;
    ++v4;
    ++v5;
    v2 += strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * v6 + 40], 0, 10) * (114 - *(v4 - 1));
  }
  while ( v4 != v3 );
  return v2 / 1000;
}
// 704AD4: using guessed type int chain_badcore_num[];
// 817C28: using guessed type int dev;

//----- (00030008) --------------------------------------------------------
int __fastcall GetBoardRate(int a1)
{
  int v2; // r8
  int *v3; // r6
  int *v4; // r4
  char *v5; // r5
  int v6; // r3

  if ( *(_DWORD *)(dev + 4 * (a1 + 2)) != 1 )
    return 0;
  v2 = 0;
  v3 = &chain_badcore_num[256 * a1 + 84];
  v4 = &chain_badcore_num[256 * a1];
  v5 = &chain_pic_buf[128 * a1 + 2];
  do
  {
    while ( *v4 > 14 )
    {
      ++v4;
      ++v5;
      if ( v4 == v3 )
        return v2 / 1000;
    }
    v6 = (unsigned __int8)*v5;
    ++v4;
    ++v5;
    v2 += strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * v6 + 40], 0, 10) * (114 - *(v4 - 1));
  }
  while ( v4 != v3 );
  return v2 / 1000;
}
// 704AD4: using guessed type int chain_badcore_num[];
// 817C28: using guessed type int dev;

//----- (0003009C) --------------------------------------------------------
bool isChainEnough()
{
  int v0; // r0
  int v1; // r3
  int v2; // t1

  v0 = 0;
  v1 = dev + 4;
  do
  {
    v2 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    if ( v2 == 1 )
      ++v0;
  }
  while ( v1 != dev + 68 );
  return v0 > 3;
}
// 817C28: using guessed type int dev;

//----- (000300C4) --------------------------------------------------------
int __fastcall writeInitLogFile(const char *a1)
{
  FILE *v2; // r0
  FILE *v3; // r4
  size_t v4; // r0

  pthread_mutex_lock(&init_log_mutex);
  v2 = fopen("/tmp/freq", "a+");
  if ( v2 )
  {
    v3 = v2;
    v4 = strlen(a1);
    fwrite(a1, 1u, v4, v3);
    fclose(v3);
  }
  return j_pthread_mutex_unlock(&init_log_mutex);
}

//----- (0003010C) --------------------------------------------------------
int clearInitLogFile()
{
  FILE *v0; // r0
  FILE *v1; // r0
  FILE *v2; // r0
  FILE *v3; // r0

  pthread_mutex_lock(&init_log_mutex);
  v0 = fopen("/tmp/freq", "w");
  if ( v0 )
    fclose(v0);
  if ( !opt_fixed_freq )
    return j_pthread_mutex_unlock(&init_log_mutex);
  v1 = fopen("/tmp/search", "w");
  if ( v1 )
    fclose(v1);
  v2 = fopen("/tmp/freq", "w");
  if ( v2 )
    fclose(v2);
  v3 = fopen("/tmp/lasttemp", "w");
  if ( !v3 )
    return j_pthread_mutex_unlock(&init_log_mutex);
  fclose(v3);
  return j_pthread_mutex_unlock(&init_log_mutex);
}
// 709398: using guessed type char opt_fixed_freq;

//----- (000301A4) --------------------------------------------------------
int __fastcall set_frequency(int a1)
{
  char *v1; // r6
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *p_spins; // r7
  int v3; // r4
  int v4; // r5
  char *v5; // r3
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *v6; // r3
  int total_rate_from_eeprom; // r5
  int v8; // r2
  int v9; // r11
  int v10; // r0
  unsigned int v11; // r1
  int v12; // s24
  char *v13; // r4
  int v14; // r5
  int v15; // r6
  signed int v16; // r7
  int v17; // r0
  unsigned int v18; // r3
  FILE *v19; // r0
  FILE *v20; // r8
  FILE *v21; // r0
  FILE *v22; // r8
  FILE *v23; // r0
  FILE *v24; // r9
  FILE *v25; // r0
  FILE *v26; // r9
  int v27; // r4
  pthread_mutex_t *v28; // r3
  char *v29; // r5
  int v30; // r6
  int v31; // t1
  char *v32; // r1
  int v33; // r11
  bool v34; // zf
  int v35; // s24
  unsigned int v36; // r3
  FILE *v37; // r0
  FILE *v38; // r4
  char *v39; // r9
  int v40; // r5
  char *v41; // r4
  int v42; // r7
  int v43; // r8
  int v44; // r3
  int v45; // r1
  bool v46; // cc
  FILE *v47; // r0
  FILE *v48; // r0
  FILE *v49; // r6
  FILE *v50; // r0
  FILE *v51; // r4
  FILE *v52; // r0
  FILE *v53; // r4
  FILE *v54; // r0
  FILE *v55; // r4
  FILE *v56; // r0
  FILE *v57; // r4
  int result; // r0
  unsigned int v59; // r3
  int v60; // r7
  int *v61; // r3
  int v62; // r4
  char *v63; // r6
  int v64; // t1
  char *v65; // r1
  FILE *v66; // r0
  FILE *v67; // r4
  FILE *v68; // r0
  FILE *v69; // r5
  FILE *v70; // r0
  FILE *v71; // r4
  FILE *v72; // r0
  FILE *v73; // r4
  FILE *v74; // r0
  FILE *v75; // r4
  FILE *v76; // r0
  FILE *v77; // r4
  FILE *v78; // r0
  FILE *v79; // r4
  FILE *v80; // r0
  FILE *v81; // r6
  FILE *v82; // r0
  FILE *v83; // r4
  FILE *v84; // r0
  FILE *v85; // r4
  int v86; // r5
  int v87; // r3
  int v88; // r9
  int v89; // r7
  char *v90; // r8
  int v91; // lr
  pthread_mutex_t *v92; // r4
  char *v93; // r6
  int v94; // t1
  char *v95; // r2
  pthread_mutex_t *v96; // r3
  int v97; // t1
  int v98; // r9
  int v99; // r4
  int v100; // r11
  int v101; // r0
  int v102; // r6
  int v103; // r3
  int v104; // r12
  int *v105; // r1
  char *v106; // r2
  int v107; // t1
  int v108; // r4
  char *v109; // r6
  int v110; // t1
  char *v111; // r2
  char *v112; // r3
  int v113; // t1
  int v114; // r1
  FILE *v115; // r0
  FILE *v116; // r4
  FILE *v117; // r0
  FILE *v118; // r4
  FILE *v119; // r0
  FILE *v120; // r5
  FILE *v121; // r0
  FILE *v122; // r5
  FILE *v123; // r0
  FILE *v124; // r0
  FILE *v125; // r6
  FILE *v126; // r0
  FILE *v127; // r4
  FILE *v128; // r0
  FILE *v129; // r4
  FILE *v130; // r0
  FILE *v131; // r4
  FILE *v132; // r0
  FILE *v133; // r4
  int v134; // [sp+8h] [bp-8A0h]
  int v136; // [sp+10h] [bp-898h]
  int v137; // [sp+10h] [bp-898h]
  FILE *stream; // [sp+1Ch] [bp-88Ch]
  FILE *streama; // [sp+1Ch] [bp-88Ch]
  int v140; // [sp+20h] [bp-888h]
  char *v141; // [sp+28h] [bp-880h]
  char *v142; // [sp+28h] [bp-880h]
  int v143; // [sp+2Ch] [bp-87Ch]
  char *v144; // [sp+30h] [bp-878h]
  unsigned __int8 pll_index; // [sp+3Ch] [bp-86Ch]
  __int16 v146; // [sp+4Eh] [bp-85Ah] BYREF
  int v147; // [sp+50h] [bp-858h] BYREF
  int v148; // [sp+54h] [bp-854h] BYREF
  char s[2128]; // [sp+58h] [bp-850h] BYREF

  v147 = 0;
  v146 = 0;
  v148 = 0;
  pll_index = get_pll_index(a1);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "\n--- %s\n", "set_frequency");
    applog(7, s, 0);
  }
  get_plldata_constprop_17(a1, &v147, &v146, &v148);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "%s: frequency = %d\n", "set_frequency", a1);
    applog(7, s, 0);
  }
  v1 = &byte_708AD5;
  p_spins = (union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *)&iic_mutex.__spins;
  v3 = 1;
  do
  {
    while ( 1 )
    {
      v4 = v3 + 1;
      if ( *(_DWORD *)(dev + 4 * (v3 + 1)) == 1 )
      {
        if ( *(_BYTE *)(dev + v3 - 1 + 21484) )
          break;
      }
      p_spins += 256;
      v1 += 128;
      ++v3;
      if ( v4 == 17 )
        goto LABEL_21;
    }
    if ( opt_fixed_freq || *(v1 - 1) != 125 )
    {
      v5 = v1;
      *(v1 - 1) = 125;
      isUseDefaultFreq = 1;
      do
        *++v5 = pll_index;
      while ( v5 != v1 + 84 );
      if ( (unsigned int)log_level <= 3 )
        goto LABEL_18;
      v23 = fopen(log_file, "a+");
      v24 = v23;
      if ( v23 )
        fprintf(
          v23,
          "%s:%d:%s: Chain[J%d] has no freq in PIC, set default freq=%dM\n",
          "driver-btm-c5.c",
          4484,
          "set_frequency",
          v3,
          a1);
      fclose(v24);
    }
    if ( (unsigned int)log_level > 3 )
    {
      v25 = fopen(log_file, "a+");
      v26 = v25;
      if ( v25 )
        fprintf(v25, "%s:%d:%s: Chain[J%d] has no core num in PIC\n", "driver-btm-c5.c", 4545, "set_frequency", v3);
      fclose(v26);
    }
LABEL_18:
    v6 = p_spins;
    do
    {
      v6[1].__spins = 0;
      ++v6;
    }
    while ( v6 != &p_spins[84] );
    p_spins += 256;
    v1 += 128;
    ++v3;
  }
  while ( v4 != 17 );
LABEL_21:
  if ( !opt_economic_mode || (total_rate_from_eeprom = GetTotalRate_part_12(), !opt_economic_mode) )
    total_rate_from_eeprom = get_total_rate_from_eeprom();
  if ( total_rate_from_eeprom % 1000 >= 500 )
    v8 = 500;
  else
    v8 = 0;
  ideal_total_hash_rate = 1000 * (total_rate_from_eeprom / 1000) + v8;
  if ( (unsigned int)log_level > 3 )
  {
    v84 = fopen(log_file, "a+");
    v85 = v84;
    if ( v84 )
      fprintf(
        v84,
        "%s:%d:%s: miner total rate=%dGH/s ideal_total_hash_rate = %dGH/s\n",
        "driver-btm-c5.c",
        4592,
        "set_frequency",
        total_rate_from_eeprom,
        ideal_total_hash_rate);
    fclose(v85);
    if ( opt_fixed_freq )
      goto LABEL_62;
  }
  else if ( opt_fixed_freq )
  {
    goto LABEL_63;
  }
  v9 = 0;
  v141 = &byte_708AD6;
  stream = (FILE *)base_freq_index;
  v140 = 1;
  while ( 2 )
  {
    if ( *(_DWORD *)(dev + 4 * (v9 + 2)) != 1 || !*(_BYTE *)(dev + v9 + 21484) )
      goto LABEL_29;
    v10 = write_EEPROM_iic(*(_DWORD *)(dev + 4 * (v9 + 2)), 1, 144, v9, 0);
    v11 = log_level;
    v12 = v10;
    if ( (unsigned int)log_level > 3 )
    {
      v124 = fopen(log_file, "a+");
      v125 = v124;
      if ( v124 )
        fprintf(
          v124,
          "%s:%d:%s: read PIC voltage=%d on chain[%d]\n",
          "driver-btm-c5.c",
          4617,
          "set_frequency",
          10 * ((int)((364.0704 / ((double)v12 + 30.72) + 32.79) * 100.0 / 4.75) / 10),
          v9);
      fclose(v125);
      v11 = log_level;
      if ( (unsigned int)log_level > 3 )
      {
        v126 = fopen(log_file, "a+");
        v127 = v126;
        if ( v126 )
          fprintf(
            v126,
            "%s:%d:%s: Chain:%d chipnum=%d\n",
            "driver-btm-c5.c",
            4619,
            "set_frequency",
            v9,
            *(unsigned __int8 *)(dev + v9 + 21484));
        fclose(v127);
        v11 = log_level;
        if ( (unsigned int)log_level > 3 )
        {
          v128 = fopen(log_file, "a+");
          v129 = v128;
          if ( v128 )
            fprintf(
              v128,
              "%s:%d:%s: S9+ can not record Chain[J%d] voltage added value\n",
              "driver-btm-c5.c",
              4637,
              "set_frequency",
              v140);
          fclose(v129);
          v11 = log_level;
        }
      }
    }
    if ( isUseDefaultFreq )
    {
      LOBYTE(stream->_flags) = pll_index;
      if ( v11 > 3 )
        goto LABEL_127;
    }
    else
    {
      LOBYTE(stream->_flags) = 12;
      if ( v11 <= 3 )
        goto LABEL_35;
LABEL_127:
      v66 = fopen(log_file, "a+");
      v67 = v66;
      if ( v66 )
        fprintf(
          v66,
          "%s:%d:%s: Chain:%d base freq=%s\n",
          "driver-btm-c5.c",
          4761,
          "set_frequency",
          v9,
          *(const char **)&_PRETTY_FUNCTION___14958[16 * LOBYTE(stream->_flags) + 40]);
      fclose(v67);
      v11 = log_level;
    }
LABEL_35:
    v13 = v141;
    v14 = 1;
    v15 = 100;
    v16 = 0;
    v17 = *(unsigned __int8 *)(dev + v9 + 21484);
    while ( 2 )
    {
      if ( v17 > v14 - 1 )
      {
        v18 = (unsigned __int8)*v13;
        if ( v18 > 3 )
        {
          if ( v18 > 106 )
          {
            v18 = 106;
            *v13 = 106;
          }
        }
        else
        {
          v18 = 4;
          *v13 = 4;
        }
        if ( v16 < (int)v18 )
          v16 = v18;
        if ( v15 >= (int)v18 )
          v15 = v18;
        if ( v11 > 3 )
        {
          v19 = fopen(log_file, "a+");
          v20 = v19;
          if ( v19 )
            fprintf(
              v19,
              "Asic[%2d]:%s ",
              v14 - 1,
              *(const char **)&_PRETTY_FUNCTION___14958[16 * (unsigned __int8)*v13 + 40]);
          fclose(v20);
          if ( v14 << 29 )
          {
LABEL_54:
            v11 = log_level;
            v17 = *(unsigned __int8 *)(dev + v9 + 21484);
          }
          else
          {
            v11 = log_level;
            if ( (unsigned int)log_level > 3 )
            {
              v21 = fopen(log_file, "a+");
              v22 = v21;
              if ( v21 )
                fputc(10, v21);
              fclose(v22);
              goto LABEL_54;
            }
            v17 = *(unsigned __int8 *)(dev + v9 + 21484);
          }
        }
        ++v14;
        ++v13;
        continue;
      }
      break;
    }
    if ( v11 > 3 )
    {
      v72 = fopen(log_file, "a+");
      v73 = v72;
      if ( v72 )
        fputc(10, v72);
      fclose(v73);
      if ( (unsigned int)log_level > 3 )
      {
        v74 = fopen(log_file, "a+");
        v75 = v74;
        if ( v74 )
          fprintf(
            v74,
            "%s:%d:%s: Chain:%d max freq=%s\n",
            "driver-btm-c5.c",
            4830,
            "set_frequency",
            v9,
            *(const char **)&_PRETTY_FUNCTION___14958[16 * v16 + 40]);
        fclose(v75);
        if ( (unsigned int)log_level > 3 )
        {
          v76 = fopen(log_file, "a+");
          v77 = v76;
          if ( v76 )
            fprintf(
              v76,
              "%s:%d:%s: Chain:%d min freq=%s\n",
              "driver-btm-c5.c",
              4831,
              "set_frequency",
              v9,
              *(const char **)&_PRETTY_FUNCTION___14958[16 * v15 + 40]);
          fclose(v77);
          if ( (unsigned int)log_level > 3 )
          {
            v78 = fopen(log_file, "a+");
            v79 = v78;
            if ( v78 )
              fputc(10, v78);
            fclose(v79);
          }
        }
      }
    }
LABEL_29:
    ++v9;
    ++v140;
    v141 += 128;
    stream = (FILE *)((char *)stream + 1);
    if ( v9 != 16 )
      continue;
    break;
  }
LABEL_62:
  if ( (unsigned int)log_level > 3 )
  {
    v68 = fopen(log_file, "a+");
    v69 = v68;
    if ( v68 )
      fputc(10, v68);
    fclose(v69);
    if ( (unsigned int)log_level > 3 )
    {
      v70 = fopen(log_file, "a+");
      v71 = v70;
      if ( v70 )
        fprintf(v70, "%s:%d:%s: Miner fix freq ...\n", "driver-btm-c5.c", 4840, "set_frequency");
      fclose(v71);
    }
  }
LABEL_63:
  v27 = dev;
  v28 = (pthread_mutex_t *)&chip_last_freq;
  v29 = chain_pic_buf;
  v30 = dev + 4;
  do
  {
    while ( 1 )
    {
      v31 = *(_DWORD *)(v30 + 4);
      v30 += 4;
      if ( v31 == 1 )
        break;
      v28 = (pthread_mutex_t *)((char *)v28 + 256);
      v29 += 128;
      if ( v28 == &init_log_mutex )
        goto LABEL_67;
    }
    v32 = v29;
    v29 += 128;
    v28 = (pthread_mutex_t *)((char *)memcpy(v28, v32, 128u) + 256);
  }
  while ( v28 != &init_log_mutex );
LABEL_67:
  v144 = &byte_708AD6;
  v142 = (char *)&unk_70A46C;
  v136 = 0;
  v33 = 0;
  v143 = 1;
  while ( 2 )
  {
    if ( *(_DWORD *)(v27 + 4 * (v136 + 2)) == 1 && *(_BYTE *)(v27 + v136 + 21484) )
    {
      v35 = write_EEPROM_iic(1, 1, 144, v136, 0);
      if ( (unsigned int)log_level > 3 )
      {
        v80 = fopen(log_file, "a+");
        v81 = v80;
        if ( v80 )
          fprintf(
            v80,
            "%s:%d:%s: read PIC voltage=%d on chain[%d]\n",
            "driver-btm-c5.c",
            4875,
            "set_frequency",
            10 * ((int)((364.0704 / ((double)v35 + 30.72) + 32.79) * 100.0 / 4.75) / 10),
            v136);
        fclose(v81);
        if ( (unsigned int)log_level > 3 )
        {
          v82 = fopen(log_file, "a+");
          v83 = v82;
          if ( v82 )
            fprintf(
              v82,
              "%s:%d:%s: Chain:%d chipnum=%d\n",
              "driver-btm-c5.c",
              4876,
              "set_frequency",
              v136,
              *(unsigned __int8 *)(dev + v136 + 21484));
          fclose(v83);
        }
      }
      if ( !opt_fixed_freq )
      {
        v36 = log_level;
        if ( (unsigned int)log_level > 3 )
        {
          v130 = fopen(log_file, "a+");
          v131 = v130;
          if ( v130 )
            fprintf(
              v130,
              "%s:%d:%s: S9+ can not record Chain[J%d] voltage added value\n",
              "driver-btm-c5.c",
              4893,
              "set_frequency",
              v143);
          fclose(v131);
          if ( !opt_fixed_freq )
          {
            v36 = log_level;
            goto LABEL_75;
          }
        }
        else
        {
LABEL_75:
          if ( isUseDefaultFreq )
            base_freq_index[v136] = pll_index;
          else
            base_freq_index[v136] = 12;
          if ( v36 > 3 )
          {
            v37 = fopen(log_file, "a+");
            v38 = v37;
            if ( v37 )
              fprintf(
                v37,
                "%s:%d:%s: Chain:%d base freq=%s\n",
                "driver-btm-c5.c",
                5041,
                "set_frequency",
                v136,
                *(const char **)&_PRETTY_FUNCTION___14958[16 * base_freq_index[v136] + 40]);
            fclose(v38);
          }
        }
      }
      v39 = v142;
      v40 = 1;
      v41 = v144;
      v42 = 100;
      v43 = 0;
      while ( 1 )
      {
        v44 = dev;
        if ( *(unsigned __int8 *)(dev + v136 + 21484) <= v40 - 1 )
          break;
        v45 = (unsigned __int8)*v41;
        if ( (unsigned int)v45 > 3 )
        {
          if ( (unsigned int)v45 > 106 )
          {
            v45 = 106;
            *v41 = 106;
          }
        }
        else
        {
          v45 = 4;
          *v41 = 4;
        }
        if ( v33 < v45 )
          v33 = v45;
        if ( v43 < v45 )
          v43 = v45;
        if ( v42 >= v45 )
          v42 = v45;
        set_frequency_with_addr_plldatai(
          v45,
          0,
          (unsigned __int8)((v40 - 1) * *(_BYTE *)(v44 + 21549)),
          (unsigned __int8)v136);
        v46 = (unsigned int)log_level > 3;
        *((_DWORD *)v39 + 1) = (unsigned __int8)*v41;
        v39 += 4;
        if ( v46 )
        {
          v47 = fopen(log_file, "a+");
          streama = v47;
          if ( v47 )
            fprintf(
              v47,
              "Asic[%2d]:%s ",
              v40 - 1,
              *(const char **)&_PRETTY_FUNCTION___14958[16 * (unsigned __int8)*v41 + 40]);
          fclose(streama);
          if ( !(v40 << 29) && (unsigned int)log_level > 3 )
          {
            v48 = fopen(log_file, "a+");
            v49 = v48;
            if ( v48 )
              fputc(10, v48);
            fclose(v49);
          }
        }
        ++v40;
        ++v41;
      }
      if ( (unsigned int)log_level > 3 )
      {
        v50 = fopen(log_file, "a+");
        v51 = v50;
        if ( v50 )
          fputc(10, v50);
        fclose(v51);
        if ( (unsigned int)log_level > 3 )
        {
          v52 = fopen(log_file, "a+");
          v53 = v52;
          if ( v52 )
            fprintf(
              v52,
              "%s:%d:%s: Chain:%d max freq=%s\n",
              "driver-btm-c5.c",
              5131,
              "set_frequency",
              v136,
              *(const char **)&_PRETTY_FUNCTION___14958[16 * v43 + 40]);
          fclose(v53);
          if ( (unsigned int)log_level > 3 )
          {
            v54 = fopen(log_file, "a+");
            v55 = v54;
            if ( v54 )
              fprintf(
                v54,
                "%s:%d:%s: Chain:%d min freq=%s\n",
                "driver-btm-c5.c",
                5132,
                "set_frequency",
                v136,
                *(const char **)&_PRETTY_FUNCTION___14958[16 * v42 + 40]);
            fclose(v55);
            if ( (unsigned int)log_level > 3 )
            {
              v56 = fopen(log_file, "a+");
              v57 = v56;
              if ( v56 )
                fputc(10, v56);
              fclose(v57);
            }
          }
        }
      }
    }
    ++v143;
    v34 = v136++ == 15;
    v144 += 128;
    v142 += 1024;
    if ( !v34 )
    {
      v27 = dev;
      continue;
    }
    break;
  }
  result = strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * v33 + 40], 0, 10);
  v59 = log_level;
  *(_WORD *)(dev + 21571) = result;
  if ( v59 > 3 )
  {
    v119 = fopen(log_file, "a+");
    v120 = v119;
    if ( v119 )
      fprintf(
        v119,
        "%s:%d:%s: max freq = %d\n",
        "driver-btm-c5.c",
        5140,
        "set_frequency",
        *(unsigned __int16 *)(dev + 21571));
    result = fclose(v120);
  }
  if ( isUseDefaultFreq )
    goto LABEL_118;
  v86 = ideal_total_hash_rate;
  if ( ideal_total_hash_rate % 1000 >= 500 )
    v87 = 500;
  else
    v87 = 0;
  v88 = 1000 * (ideal_total_hash_rate / 1000) + v87;
  if ( (unsigned int)log_level > 3 )
  {
    v132 = fopen(log_file, "a+");
    v133 = v132;
    if ( v132 )
      fprintf(
        v132,
        "%s:%d:%s: totalRate = %d, fixed_totalRate = %d\n",
        "driver-btm-c5.c",
        4183,
        "ProcessFixFreq",
        v86,
        v88);
    fclose(v133);
    if ( opt_economic_mode )
      goto LABEL_243;
LABEL_168:
    result = ideal_total_hash_rate;
  }
  else
  {
    if ( !opt_economic_mode )
      goto LABEL_168;
LABEL_243:
    result = GetTotalRate_part_12();
  }
  if ( v88 >= result )
  {
LABEL_118:
    v60 = dev + 4;
    goto LABEL_119;
  }
  v89 = dev;
  v137 = v88;
  while ( 2 )
  {
    v90 = (char *)&unk_70F46C;
    v91 = v89 + 4;
    v92 = (pthread_mutex_t *)&byte_708AD5;
    v93 = (char *)&unk_70F46C;
    do
    {
      while ( 1 )
      {
        v94 = *(_DWORD *)(v91 + 4);
        v91 += 4;
        if ( v94 == 1 )
          break;
        v92 = (pthread_mutex_t *)((char *)v92 + 128);
        v93 += 1024;
        if ( v92 == (pthread_mutex_t *)((char *)&nonce_mutex.__lock + 1) )
          goto LABEL_177;
      }
      result = (int)&v92[3].__kind;
      v95 = v93;
      v96 = v92;
      do
      {
        v97 = (unsigned __int8)v96->__size[1];
        v96 = (pthread_mutex_t *)((char *)v96 + 1);
        *((_DWORD *)v95 + 1) = v97;
        v95 += 4;
      }
      while ( (pthread_mutex_t *)result != v96 );
      v92 = (pthread_mutex_t *)((char *)v92 + 128);
      v93 += 1024;
    }
    while ( v92 != (pthread_mutex_t *)((char *)&nonce_mutex.__lock + 1) );
LABEL_177:
    if ( (unsigned int)log_level > 5 )
    {
      v115 = fopen(log_file, "a+");
      v116 = v115;
      if ( v115 )
        fprintf(v115, "%s:%d:%s: DownOneChipFreqOneStep enter\n", "driver-btm-c5.c", 4057, "DownOneChipFreqOneStep");
      result = fclose(v116);
      v89 = dev;
    }
    v98 = 0;
    v99 = -1;
    v100 = 0;
    while ( 2 )
    {
      if ( *(_DWORD *)(v89 + 4 * (v100 + 2)) != 1 )
        goto LABEL_179;
      result = v100;
      if ( *(_BYTE *)(v89 + v100 + 21484) != 84 )
        goto LABEL_197;
      if ( v98 )
      {
        result = GetBoardRate(v100);
        if ( result <= v98 )
        {
LABEL_179:
          if ( ++v100 == 16 )
            break;
          goto LABEL_180;
        }
      }
      v101 = v100;
      v99 = v100++;
      result = GetBoardRate(v101);
      v98 = result;
      if ( v100 != 16 )
      {
LABEL_180:
        v89 = dev;
        continue;
      }
      break;
    }
    if ( v99 == -1 )
    {
      if ( (unsigned int)log_level > 3 )
      {
        v123 = fopen(log_file, "a+");
        v122 = v123;
        if ( v123 )
          fprintf(
            v123,
            "%s:%d:%s: Fatal Error: DownOneChipFreqOneStep has Wrong chain index=%d\n",
            "driver-btm-c5.c",
            4079,
            "DownOneChipFreqOneStep",
            -1);
        goto LABEL_224;
      }
LABEL_214:
      v89 = dev;
      goto LABEL_197;
    }
    v89 = dev;
    if ( !*(_BYTE *)(dev + v99 + 21484) )
      break;
    v102 = 0;
    v103 = 0;
    v104 = -1;
    v105 = &iic_mutex.__spins + 256 * v99;
    v106 = &chain_pic_buf[128 * v99 + 2];
    while ( 2 )
    {
      v107 = v105[1];
      ++v105;
      result = v107;
      if ( v107 <= 14 )
      {
        if ( !v102 )
        {
          v102 = (unsigned __int8)*v106;
          goto LABEL_192;
        }
        result = (unsigned __int8)*v106;
        if ( v102 < result )
        {
          v102 = (unsigned __int8)*v106;
LABEL_192:
          v104 = v103;
        }
      }
      ++v103;
      ++v106;
      if ( v103 != *(unsigned __int8 *)(dev + v99 + 21484) )
        continue;
      break;
    }
    if ( v104 != -1 )
    {
      if ( v102 <= 4 )
      {
        if ( (unsigned int)log_level <= 3 )
          goto LABEL_197;
        v121 = fopen(log_file, "a+");
        v122 = v121;
        if ( v121 )
          fprintf(
            v121,
            "%s:%d:%s: Fatal Error: DownOneChipFreqOneStep Chain[%d] has no chip can down freq!!!\n",
            "driver-btm-c5.c",
            4137,
            "DownOneChipFreqOneStep",
            v99);
LABEL_224:
        result = fclose(v122);
        goto LABEL_214;
      }
      v114 = (unsigned __int8)opt_economic_mode;
      --*((_BYTE *)&unk_707D98 + 128 * v99 + v104 + 3390);
      if ( v114 )
      {
        result = GetTotalRate_part_12();
        v89 = dev;
      }
      else
      {
        result = ideal_total_hash_rate;
      }
      if ( v137 >= result )
        goto LABEL_197;
      continue;
    }
    break;
  }
  if ( (unsigned int)log_level > 3 )
  {
    v117 = fopen(log_file, "a+");
    v118 = v117;
    if ( v117 )
      fprintf(
        v117,
        "%s:%d:%s: Fatal Error: DownOneChipFreqOneStep Chain[%d] has Wrong chip index=%d\n",
        "driver-btm-c5.c",
        4130,
        "DownOneChipFreqOneStep",
        -1,
        v134);
    result = fclose(v118);
    v89 = dev;
  }
LABEL_197:
  v60 = v89 + 4;
  v108 = v60;
  v109 = &byte_708AD5;
  do
  {
    v110 = *(_DWORD *)(v108 + 4);
    v108 += 4;
    if ( v110 == 1 )
    {
      result = (int)(v90 + 336);
      v111 = v109;
      v112 = v90;
      do
      {
        v113 = *((_DWORD *)v112 + 1);
        v112 += 4;
        *++v111 = v113;
      }
      while ( (char *)result != v112 );
    }
    v90 += 1024;
    v109 += 128;
  }
  while ( &unk_71346C != (_UNKNOWN *)v90 );
LABEL_119:
  v61 = (int *)&show_last_freq;
  v62 = v60;
  v63 = chain_pic_buf;
  do
  {
    while ( 1 )
    {
      v64 = *(_DWORD *)(v62 + 4);
      v62 += 4;
      if ( v64 == 1 )
        break;
      v61 += 64;
      v63 += 128;
      if ( &last_record_freq == v61 )
        return result;
    }
    v65 = v63;
    v63 += 128;
    result = (int)memcpy(v61, v65, 128u);
    v61 = (int *)(result + 256);
  }
  while ( &last_record_freq != (int *)(result + 256) );
  return result;
}
// 30F30: variable 'v134' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 708AD5: using guessed type char byte_708AD5;
// 708AD6: using guessed type char byte_708AD6;
// 709398: using guessed type char opt_fixed_freq;
// 70943E: using guessed type char opt_economic_mode;
// 709440: using guessed type int ideal_total_hash_rate;
// 70A460: using guessed type unsigned __int8 base_freq_index[12];
// 70F470: using guessed type int last_record_freq;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (000311EC) --------------------------------------------------------
int __fastcall set_frequency_with_addr(int a1, int a2, int a3, int a4)
{
  int v8; // r4
  int v9; // r6
  int v10; // r4
  int v11; // r0
  int v12; // r0
  char v14; // r6
  int v15; // r9
  int v16; // r8
  unsigned __int8 v17; // r0
  int v18; // r6
  unsigned int v19; // r9
  int v20; // r0
  int v21; // r8
  int v22; // r0
  unsigned __int16 v23; // [sp+Eh] [bp-842h] BYREF
  int v24; // [sp+10h] [bp-840h] BYREF
  int v25; // [sp+14h] [bp-83Ch] BYREF
  int v26; // [sp+18h] [bp-838h] BYREF
  int v27; // [sp+1Ch] [bp-834h]
  char v28; // [sp+20h] [bp-830h]
  int v29; // [sp+24h] [bp-82Ch] BYREF
  int v30; // [sp+28h] [bp-828h]
  int v31; // [sp+2Ch] [bp-824h]
  char s[2080]; // [sp+30h] [bp-820h] BYREF

  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v24 = 0;
  v23 = 0;
  v25 = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "\n--- %s\n", "set_frequency_with_addr");
    applog(7, s, 0);
  }
  get_plldata_constprop_17(a1, &v24, (__int16 *)&v23, &v25);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "%s: frequency = %d\n", "set_frequency_with_addr", a1);
    applog(7, s, 0);
  }
  v8 = opt_multi_version;
  if ( opt_multi_version )
  {
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    if ( a2 )
    {
      v9 = 1476984844;
      LOBYTE(v26) = 88;
    }
    else
    {
      v9 = 1208549388;
      LOBYTE(v26) = 72;
    }
    v10 = v25;
    BYTE1(v26) = 9;
    HIBYTE(v26) = 12;
    BYTE2(v26) = a3;
    HIBYTE(v27) = v25;
    LOBYTE(v27) = HIBYTE(v25);
    BYTE1(v27) = BYTE2(v25);
    BYTE2(v27) = BYTE1(v25);
    v11 = CRC5(&v26, 64u);
    v28 = v11;
    v30 = v10;
    v31 = v11 << 24;
    v29 = v9 | (a3 << 8);
    set_BC_command_buffer(&v29);
    v12 = get_BC_write_command();
    set_BC_write_command(v12 & 0xFFF0FFFF | (a4 << 16) | 0x80800000);
    *(_WORD *)(dev + 2 * (a4 + 10788) + 7) = a1;
    return cgsleep_us();
  }
  else
  {
    LOBYTE(v26) = 7;
    v27 = opt_multi_version;
    v14 = v24;
    v28 = opt_multi_version;
    BYTE1(v26) = BYTE2(v24);
    BYTE2(v26) = BYTE1(v24);
    v15 = BYTE2(v24);
    v16 = BYTE1(v24) << 8;
    HIBYTE(v26) = v24;
    v29 = opt_multi_version;
    v30 = opt_multi_version;
    v31 = opt_multi_version;
    v17 = CRC5(&v26, 27u) | v14;
    v18 = v16 | (v15 << 16);
    v19 = (a4 << 16) | 0x80800000;
    HIBYTE(v26) = v17;
    v29 = v17 | v18 | 0x7000000;
    set_BC_command_buffer(&v29);
    v20 = get_BC_write_command();
    set_BC_write_command(v20 & 0xFFF0FFFF | v19);
    cgsleep_us();
    BYTE1(v26) = BYTE1(v8);
    v27 = v8;
    v21 = HIBYTE(v23);
    LOBYTE(v18) = v23;
    LOBYTE(v26) = -126;
    BYTE2(v26) = HIBYTE(v23);
    HIBYTE(v26) = v23;
    v28 = v8;
    v29 = v8;
    v30 = v8;
    v31 = v8;
    HIBYTE(v26) = v18 | CRC5(&v26, 27u);
    v29 = HIBYTE(v26) | (v21 << 8) | 0x82000000;
    set_BC_command_buffer(&v29);
    v22 = get_BC_write_command();
    set_BC_write_command(v22 & 0xFFF0FFFF | v19);
    *(_WORD *)(dev + 2 * (a4 + 10788) + 7) = a1;
    return cgsleep_us();
  }
}
// 7DF98: using guessed type int opt_multi_version;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (00031498) --------------------------------------------------------
int clear_nonce_fifo()
{
  pthread_mutex_lock(&nonce_mutex);
  nonce_read_out[0] = 0;
  dword_80EF78 = 0;
  dword_80EF7C = 0;
  return j_pthread_mutex_unlock(&nonce_mutex);
}
// 80EF74: using guessed type int nonce_read_out[];
// 80EF78: using guessed type int dword_80EF78;
// 80EF7C: using guessed type int dword_80EF7C;

//----- (000314C0) --------------------------------------------------------
int clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  reg_value_buf = 0;
  dword_816748 = 0;
  dword_81674C = 0;
  return j_pthread_mutex_unlock(&reg_mutex);
}
// 816744: using guessed type int reg_value_buf;
// 816748: using guessed type int dword_816748;
// 81674C: using guessed type int dword_81674C;

//----- (000314E8) --------------------------------------------------------
void __noreturn get_nonce_and_register()
{
  __int16 nonce_number_in_fifo; // r0
  int v1; // r7
  int v2; // r5
  int v3; // r3
  int v4; // r7
  int v5; // lr
  unsigned int v6; // r1
  int v7; // r12
  int v8; // r2
  int v9; // lr
  int v10; // r0
  int *v11; // r1
  char v12; // t1
  char *v13; // r1
  int v14; // r3
  int v15; // r3
  char v16; // r2
  unsigned int v17; // r1
  int v18; // r3
  int v19; // r3
  FILE *v20; // r0
  FILE *v21; // r11
  int v22; // [sp+14h] [bp-854h]
  unsigned int v23; // [sp+38h] [bp-830h] BYREF
  int v24; // [sp+3Ch] [bp-82Ch]
  char s[2088]; // [sp+40h] [bp-828h] BYREF

  v23 = 0;
  v24 = 0;
  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        cgsleep_ms();
        if ( !doTestPatten )
          break;
        cgsleep_ms();
      }
      nonce_number_in_fifo = get_nonce_number_in_fifo();
      v1 = nonce_number_in_fifo & 0x1FF;
    }
    while ( (nonce_number_in_fifo & 0x1FF) == 0 );
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: read_loop = %d\n", "get_nonce_and_register", nonce_number_in_fifo & 0x1FF);
      applog(7, s, 0);
    }
    v2 = 0;
    v22 = v1;
    do
    {
      get_return_nonce(&v23);
      if ( (v23 & 2147483648) == 0 )
      {
        if ( test_show_register && (unsigned int)log_level > 3 )
        {
          v20 = fopen(log_file, "a+");
          v21 = v20;
          if ( v20 )
            fprintf(
              v20,
              "%s:%d:%s: FPGA recv : buf[0]=0x%08x buf[1]=0x%08x\n",
              "driver-btm-c5.c",
              11734,
              "get_nonce_and_register",
              v23,
              v24);
          fclose(v21);
        }
        if ( (unsigned int)dword_81674C <= 510 && reg_value_buf[0] <= 510u )
        {
          pthread_mutex_lock(&reg_mutex);
          v16 = v23;
          v17 = HIBYTE(v23) & 0x1F;
          reg_value_buf[2 * reg_value_buf[0] + 3] = v24;
          LOBYTE(reg_value_buf[2 * reg_value_buf[0] + 4]) = v17;
          BYTE1(reg_value_buf[2 * reg_value_buf[0] + 4]) = v16 & 0xF;
          if ( reg_value_buf[0] >= 510u )
            v18 = 0;
          else
            v18 = reg_value_buf[0];
          if ( reg_value_buf[0] < 510u )
            ++v18;
          reg_value_buf[0] = v18;
          if ( (unsigned int)dword_81674C > 510 )
            v19 = 511;
          else
            v19 = dword_81674C;
          if ( (unsigned int)dword_81674C <= 510 )
            ++v19;
          dword_81674C = v19;
          pthread_mutex_unlock(&reg_mutex);
        }
        else
        {
          clear_register_value_buf();
        }
      }
      else if ( gBegin_get_nonce_0 && (v23 & 0x80) != 0 )
      {
        pthread_mutex_lock(&nonce_mutex);
        v3 = 0;
        v4 = v24;
        v5 = v23 & 0xF;
        v6 = HIWORD(v23) & 0x7FFF;
        v7 = nonce2_jobid_address;
        nonce_read_out[15 * nonce_read_out[0] + 4] = v6;
        v6 <<= 6;
        v8 = v7 + v6 + 31;
        nonce_read_out[15 * nonce_read_out[0] + 8] = v4;
        nonce_read_out[15 * nonce_read_out[0] + 9] = v5;
        nonce_read_out[15 * nonce_read_out[0] + 3] = *(_DWORD *)(v7 + v6);
        nonce_read_out[15 * nonce_read_out[0] + 5] = *(_DWORD *)(v7 + v6 + 4);
        v9 = *(_DWORD *)(v7 + v6 + 8);
        v10 = *(_DWORD *)(v7 + v6 + 12);
        v11 = &nonce_read_out[15 * nonce_read_out[0]];
        v11[6] = v9;
        v11[7] = v10;
        do
        {
          v12 = *(_BYTE *)++v8;
          v13 = (char *)&nonce_read_out[15 * nonce_read_out[0]] + v3++;
          v13[40] = v12;
        }
        while ( v3 != 32 );
        if ( nonce_read_out[0] >= 510u )
          v14 = 0;
        else
          v14 = nonce_read_out[0];
        if ( nonce_read_out[0] < 510u )
          ++v14;
        nonce_read_out[0] = v14;
        if ( (unsigned int)dword_80EF7C > 510 )
          v15 = 511;
        else
          v15 = dword_80EF7C;
        if ( (unsigned int)dword_80EF7C <= 510 )
          ++v15;
        dword_80EF7C = v15;
        pthread_mutex_unlock(&nonce_mutex);
      }
      ++v2;
    }
    while ( v22 != v2 );
  }
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 713488: using guessed type char doTestPatten;
// 713489: using guessed type char gBegin_get_nonce_0;
// 71348A: using guessed type char test_show_register;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80B804: using guessed type int nonce2_jobid_address;
// 80CC18: using guessed type char use_syslog;
// 80EF74: using guessed type int nonce_read_out[];
// 80EF7C: using guessed type int dword_80EF7C;
// 816744: using guessed type int reg_value_buf[];
// 81674C: using guessed type int dword_81674C;

//----- (0003177C) --------------------------------------------------------
int __fastcall read_asic_register(int a1, int a2, int a3, int a4)
{
  int v7; // r4
  int v8; // r0
  int v9; // r0
  int v11; // r4
  int v12; // r0
  int v13; // r4
  FILE *v14; // r4
  int hash_on_plug; // r0
  unsigned int v16; // [sp+1Ch] [bp-82Ch] BYREF
  unsigned __int8 v17; // [sp+20h] [bp-828h]
  unsigned int v18; // [sp+24h] [bp-824h] BYREF
  int v19; // [sp+28h] [bp-820h]
  int v20; // [sp+2Ch] [bp-81Ch]
  char s[2072]; // [sp+30h] [bp-818h] BYREF

  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  if ( opt_multi_version )
  {
    if ( a2 )
    {
      v11 = 84;
      LOBYTE(v16) = 84;
    }
    else
    {
      v11 = 68;
      LOBYTE(v16) = 68;
    }
    BYTE1(v16) = 5;
    BYTE2(v16) = a3;
    HIBYTE(v16) = a4;
    v12 = CRC5(&v16, 32u);
    v17 = v12;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        s,
        2048u,
        "%s:VIL buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x",
        "read_asic_register",
        v11,
        5,
        a3,
        a4,
        v12);
      applog(7, s, 0);
      v12 = v17;
    }
    v13 = 3001;
    v19 = v12 << 24;
    v18 = bswap32(v16);
    while ( get_BC_write_command() < 0 )
    {
      cgsleep_ms();
      if ( !--v13 )
      {
        if ( (unsigned int)log_level > 3 )
        {
          v14 = fopen(log_file, "a+");
          if ( v14 )
          {
            hash_on_plug = get_hash_on_plug();
            fprintf(
              v14,
              "%s:%d:%s: Error: clement debug: wait BC ready timeout, PLUG ON=0x%08x..\n",
              "driver-btm-c5.c",
              5329,
              "read_asic_register",
              hash_on_plug);
          }
          fclose(v14);
        }
        break;
      }
    }
  }
  else
  {
    BYTE1(v16) = a3;
    BYTE2(v16) = a4;
    v7 = 4;
    LOBYTE(v16) = 4;
    if ( a2 )
    {
      v7 = 132;
      LOBYTE(v16) = -124;
    }
    v8 = CRC5(&v16, 27u);
    HIBYTE(v16) = v8;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        s,
        2048u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        "read_asic_register",
        v7,
        a3,
        a4,
        v8);
      applog(7, s, 0);
    }
    v18 = bswap32(v16);
  }
  set_BC_command_buffer(&v18);
  v9 = get_BC_write_command();
  return set_BC_write_command(v9 & 0xFFF0FFFF | (a1 << 16) | 0x80800000);
}
// 7DF98: using guessed type int opt_multi_version;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00031968) --------------------------------------------------------
int __fastcall read_temp(int result, unsigned __int8 a2, int a3, int a4, unsigned __int8 a5, int a6)
{
  int v6; // r4
  int v7; // r0
  int v8; // r4
  char v9[8]; // [sp+0h] [bp-30h] BYREF
  char v10; // [sp+8h] [bp-28h]
  int v11; // [sp+Ch] [bp-24h] BYREF
  int v12; // [sp+10h] [bp-20h]
  int v13; // [sp+14h] [bp-1Ch]

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  if ( opt_multi_version )
  {
    v9[6] = a2;
    v9[7] = a3;
    qmemcpy(v9, "H\t", 2);
    v9[3] = 32;
    v9[4] = 1;
    v9[5] = result | a4;
    v6 = a3 | 0x1000000 | (a2 << 8) | ((result | a4) << 16);
    v9[2] = a5;
    v7 = CRC5(v9, 64u);
    v10 = v7;
    v13 = v7 << 24;
    v12 = v6;
    v11 = (a5 << 8) | 0x48090020;
    while ( 1 )
    {
      v8 = get_BC_write_command();
      if ( v8 >= 0 )
        break;
      cgsleep_ms();
    }
    set_BC_command_buffer(&v11);
    return set_BC_write_command((a6 << 16) | 0x80800000 | v8 & 0xFFF0FFFF);
  }
  return result;
}
// 7DF98: using guessed type int opt_multi_version;

//----- (00031A1C) --------------------------------------------------------
unsigned int __fastcall reset_one_hashboard(int a1)
{
  set_QN_write_data_command((a1 << 16) | 0x8000000F);
  while ( get_QN_write_data_command() < 0 )
    usleep(10000u);
  return j_sleep(1u);
}

//----- (00031A48) --------------------------------------------------------
int __fastcall check_asic_reg_oneChain(int a1, int a2)
{
  int v3; // r5
  int *v5; // r4
  unsigned int v6; // r6
  int v7; // r5
  int v8; // r3
  int v9; // r2
  int v10; // r3
  int v11; // r2
  int *v12; // r3
  int v13; // r2
  int *v14; // r3
  unsigned int v15; // r2
  int v16; // r3
  int *v17; // r4
  char *v18; // r7
  unsigned int v19; // r4
  char *v20; // r3
  int v21; // r2
  bool v22; // nf
  int v24; // r2
  int v25; // [sp+14h] [bp-864h]
  unsigned __int64 v26; // [sp+18h] [bp-860h]
  int v27; // [sp+20h] [bp-858h]
  int *v28; // [sp+28h] [bp-850h]
  int v29; // [sp+34h] [bp-844h]
  int v30; // [sp+3Ch] [bp-83Ch] BYREF
  char v31; // [sp+40h] [bp-838h]
  char nptr[12]; // [sp+44h] [bp-834h] BYREF
  char s[2088]; // [sp+50h] [bp-828h] BYREF

  v3 = 0;
  v29 = a1 + 2;
  v30 = 0;
  v31 = 0;
  while ( 1 )
  {
    clear_register_value_buf();
    if ( *(_DWORD *)(dev + 4 * v29) != 1 )
      return 1;
    read_asic_register((unsigned __int8)a1, 1, 0, (unsigned __int8)a2);
    if ( !a2 )
      *(_BYTE *)(dev + a1 + 21484) = 0;
    if ( v3 > 2 )
    {
      v27 = 0;
      v26 = 0LL;
LABEL_41:
      if ( !a2 )
        goto LABEL_55;
      v19 = *(unsigned __int8 *)(dev + a1 + 21484);
LABEL_43:
      if ( v19 == v27 )
      {
        rate[a1] = v26;
        suffix_string_c5_constprop_16(v26, &displayed_rate[32 * a1], 32u, 6);
        v24 = (unsigned __int8)opt_debug;
        *((_DWORD *)&unk_712748 + a1 + 882) = 0;
        if ( !v24 || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        {
          if ( !v19 )
          {
            *((_DWORD *)&unk_712748 + a1 + 882) = 1;
LABEL_47:
            if ( !status_error )
            {
LABEL_49:
              clear_register_value_buf();
              return 1;
            }
LABEL_48:
            rate[a1] = 0LL;
            suffix_string_c5_constprop_16(0LL, &displayed_rate[32 * a1], 32u, 6);
            goto LABEL_49;
          }
LABEL_52:
          if ( !status_error )
            goto LABEL_49;
          ++*((_DWORD *)&unk_712748 + a1 + 882);
          goto LABEL_48;
        }
        snprintf(s, 2048u, "%s: chain %d hashrate is %s\n", "check_asic_reg_oneChain", a1, &displayed_rate[32 * a1]);
        applog(7, s, 0);
      }
      if ( !v27 )
      {
        v20 = (char *)&unk_712748 + 4 * a1;
        v21 = *((_DWORD *)v20 + 882) + 1;
        v22 = *((_DWORD *)v20 + 882) - 2 < 0;
        *((_DWORD *)v20 + 882) = v21;
        if ( !(v22 ^ __OFSUB__(v21, 3) | (v21 == 3)) )
          goto LABEL_48;
        goto LABEL_47;
      }
      goto LABEL_52;
    }
    v5 = reg_value_buf;
    v25 = 0;
    v27 = 0;
    v26 = 0LL;
LABEL_7:
    cgsleep_ms();
    pthread_mutex_lock(&reg_mutex);
    v6 = v5[2];
    if ( v6 <= 510 && (unsigned int)v5[1] <= 510 )
      break;
    ++v3;
    pthread_mutex_unlock(&reg_mutex);
  }
  if ( !v6 )
  {
    ++v3;
    cgsleep_ms();
    pthread_mutex_unlock(&reg_mutex);
    if ( v3 != 3 )
      goto LABEL_7;
    goto LABEL_41;
  }
  v25 += v6;
  if ( v25 <= 600 )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = v5[1] + 1;
      if ( a1 != BYTE1(v5[2 * v8 + 2]) )
        break;
      v9 = v5[2 * v8 + 1];
      v10 = v5[1];
      HIBYTE(v30) = v9;
      v11 = v5[2 * v10 + 3];
      v12 = &v5[2 * v5[1] + 2];
      BYTE2(v30) = BYTE1(v11);
      v13 = v12[1];
      v14 = &v5[2 * v5[1] + 2];
      BYTE1(v30) = BYTE2(v13);
      v15 = HIBYTE(v14[1]);
      ++v5[1];
      v16 = v5[2];
      LOBYTE(v30) = v15;
      v5[2] = v16 - 1;
      if ( (unsigned int)v5[1] > 510 )
        v5[1] = 0;
      if ( a2 )
      {
        if ( a2 == 12 )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(s, 2048u, "%s: the asic freq is 0x%x\n", "check_asic_reg_oneChain", v5[2 * v5[1] + 3]);
            applog(7, s, 0);
          }
        }
        else if ( a2 == 8 )
        {
          v28 = v5;
          v17 = &v30;
          v18 = nptr;
          while ( 1 )
          {
            sprintf(v18, "%02x");
            v18 += 2;
            if ( v17 == (int *)((char *)&v30 + 3) )
              break;
            v17 = (int *)((char *)v17 + 1);
          }
          v5 = v28;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(s, 2048u, "%s: hashrate is %s\n", "check_asic_reg_oneChain", nptr);
            applog(7, s, 0);
          }
          ++v27;
          v26 += (__int64)strtol(nptr, 0, 16) << 24;
        }
LABEL_15:
        if ( ++v7 == v6 )
          goto LABEL_21;
      }
      else
      {
        ++v7;
        ++*(_BYTE *)(dev + a1 + 21484);
        if ( v7 == v6 )
        {
LABEL_21:
          if ( a2 || *(_BYTE *)(dev + a1 + 21484) != 84 )
          {
            v3 = 0;
            pthread_mutex_unlock(&reg_mutex);
            goto LABEL_7;
          }
          pthread_mutex_unlock(&reg_mutex);
LABEL_55:
          v19 = *(unsigned __int8 *)(dev + a1 + 21484);
          if ( *(unsigned __int8 *)(dev + 21550) < v19 )
            *(_BYTE *)(dev + 21550) = v19;
          goto LABEL_43;
        }
      }
    }
    v5[1] = v8;
    --v5[2];
    if ( (unsigned int)v5[1] > 510 )
      v5[1] = 0;
    goto LABEL_15;
  }
  pthread_mutex_unlock(&reg_mutex);
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 704AB8: using guessed type char status_error;
// 713490: using guessed type _QWORD rate[16];
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 816744: using guessed type int reg_value_buf[];
// 817C28: using guessed type int dev;

//----- (00031E90) --------------------------------------------------------
int __fastcall check_asic_reg_oneChain_test(int a1, int a2)
{
  int v3; // r5
  int *v5; // r4
  unsigned int v6; // r6
  int v7; // r5
  int v8; // r3
  int v9; // r2
  int *v10; // r3
  int v11; // r2
  int *v12; // r3
  unsigned int v13; // r2
  int v14; // r3
  FILE *v15; // r0
  FILE *v16; // r9
  int *v17; // r4
  char *v18; // r9
  int v19; // r9
  int v20; // r11
  unsigned int v21; // r3
  char *v22; // r3
  int v23; // r2
  bool v24; // nf
  FILE *v26; // r0
  FILE *v27; // r5
  FILE *v28; // r0
  FILE *v29; // r5
  FILE *v30; // r0
  FILE *v31; // r6
  FILE *v32; // r0
  FILE *v33; // r4
  FILE *v34; // r0
  FILE *v35; // r4
  int v36; // r2
  FILE *v37; // r0
  FILE *v38; // r4
  FILE *v39; // r0
  FILE *v40; // r8
  int v41; // [sp+24h] [bp-864h]
  unsigned __int64 v42; // [sp+28h] [bp-860h]
  int v43; // [sp+30h] [bp-858h]
  int *v44; // [sp+3Ch] [bp-84Ch]
  int v45; // [sp+44h] [bp-844h]
  int v46; // [sp+4Ch] [bp-83Ch] BYREF
  char v47; // [sp+50h] [bp-838h]
  char nptr[12]; // [sp+54h] [bp-834h] BYREF
  char s[2088]; // [sp+60h] [bp-828h] BYREF

  v3 = 0;
  v45 = a1 + 2;
  v46 = 0;
  v47 = 0;
  while ( 1 )
  {
    clear_register_value_buf();
    if ( *(_DWORD *)(dev + 4 * v45) != 1 )
      return 1;
    if ( (unsigned int)log_level > 3 )
    {
      v34 = fopen(log_file, "a+");
      v35 = v34;
      if ( v34 )
        fprintf(
          v34,
          "%s:%d:%s: do read_asic_register on Chain[%d]...\n",
          "driver-btm-c5.c",
          5978,
          "check_asic_reg_oneChain_test",
          a1);
      fclose(v35);
    }
    read_asic_register((unsigned __int8)a1, 1, 0, (unsigned __int8)a2);
    if ( (unsigned int)log_level > 3 )
    {
      v32 = fopen(log_file, "a+");
      v33 = v32;
      if ( v32 )
        fprintf(
          v32,
          "%s:%d:%s: Done read_asic_register on Chain[%d]\n",
          "driver-btm-c5.c",
          5982,
          "check_asic_reg_oneChain_test",
          a1);
      fclose(v33);
    }
    if ( !a2 )
      *(_BYTE *)(dev + a1 + 21484) = 0;
    if ( v3 > 2 )
    {
      v19 = a2;
      v42 = 0LL;
      v20 = a1;
      v43 = 0;
LABEL_52:
      if ( v19 )
      {
        v21 = *(unsigned __int8 *)(dev + v20 + 21484);
      }
      else
      {
LABEL_81:
        v21 = *(unsigned __int8 *)(dev + v20 + 21484);
        if ( *(unsigned __int8 *)(dev + 21550) < v21 )
          *(_BYTE *)(dev + 21550) = v21;
      }
      if ( v43 == v21 )
      {
        rate[v20] = v42;
        suffix_string_c5_constprop_16(v42, &displayed_rate[32 * v20], 32u, 6);
        v36 = (unsigned __int8)opt_debug;
        *((_DWORD *)&unk_712748 + v20 + 882) = 0;
        if ( v36 && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            s,
            2048u,
            "%s: chain %d hashrate is %s\n",
            "check_asic_reg_oneChain_test",
            v20,
            &displayed_rate[32 * v20]);
          applog(7, s, 0);
          goto LABEL_55;
        }
        if ( !v43 )
        {
          *((_DWORD *)&unk_712748 + v20 + 882) = 1;
          goto LABEL_58;
        }
      }
      else
      {
LABEL_55:
        if ( !v43 )
        {
          v22 = (char *)&unk_712748 + 4 * v20;
          v23 = *((_DWORD *)v22 + 882) + 1;
          v24 = *((_DWORD *)v22 + 882) - 2 < 0;
          *((_DWORD *)v22 + 882) = v23;
          if ( !(v24 ^ __OFSUB__(v23, 3) | (v23 == 3)) )
          {
LABEL_59:
            rate[v20] = 0LL;
            suffix_string_c5_constprop_16(0LL, &displayed_rate[32 * v20], 32u, 6);
            goto LABEL_60;
          }
LABEL_58:
          if ( status_error )
            goto LABEL_59;
LABEL_60:
          clear_register_value_buf();
          return 1;
        }
      }
      if ( status_error )
      {
        ++*((_DWORD *)&unk_712748 + v20 + 882);
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    v5 = reg_value_buf;
    v41 = 0;
    v43 = 0;
    v42 = 0LL;
LABEL_9:
    while ( 2 )
    {
      cgsleep_ms();
      pthread_mutex_lock(&reg_mutex);
      v6 = v5[2];
      if ( v6 <= 510 && (unsigned int)v5[1] <= 510 )
      {
        if ( !v6 )
        {
          ++v3;
          cgsleep_ms();
          if ( (unsigned int)log_level > 3 )
          {
            v30 = fopen(log_file, "a+");
            v31 = v30;
            if ( v30 )
              fprintf(
                v30,
                "%s:%d:%s: not_reg_data_time=%d on Chain[%d]\n",
                "driver-btm-c5.c",
                6115,
                "check_asic_reg_oneChain_test",
                v3,
                a1);
            fclose(v31);
          }
          pthread_mutex_unlock(&reg_mutex);
          if ( v3 == 3 )
          {
            v19 = a2;
            v20 = a1;
            goto LABEL_52;
          }
          continue;
        }
        v41 += v6;
        if ( v41 > 600 )
        {
          if ( (unsigned int)log_level > 3 )
          {
            v37 = fopen(log_file, "a+");
            v38 = v37;
            if ( v37 )
              fprintf(
                v37,
                "%s:%d:%s: Fatal Error: read asic reg Error on Chain[%d] reg_processed_counter=%d\n",
                "driver-btm-c5.c",
                6018,
                "check_asic_reg_oneChain_test",
                a1,
                v41);
            fclose(v38);
          }
          pthread_mutex_unlock(&reg_mutex);
          return 0;
        }
        if ( (unsigned int)log_level > 3 )
        {
          v26 = fopen(log_file, "a+");
          v27 = v26;
          if ( v26 )
            fprintf(
              v26,
              "%s:%d:%s: process reg_value_num=%d on Chain[%d]\n",
              "driver-btm-c5.c",
              6024,
              "check_asic_reg_oneChain_test",
              v6,
              a1);
          fclose(v27);
        }
        v7 = 0;
        while ( 2 )
        {
          while ( a1 == BYTE1(v5[2 * v5[1] + 4]) )
          {
            v8 = v5[1];
            HIBYTE(v46) = v5[2 * v8 + 3];
            v9 = v5[2 * v8 + 3];
            v10 = &v5[2 * v5[1] + 2];
            BYTE2(v46) = BYTE1(v9);
            v11 = v10[1];
            v12 = &v5[2 * v5[1] + 2];
            BYTE1(v46) = BYTE2(v11);
            v13 = HIBYTE(v12[1]);
            ++v5[1];
            v14 = v5[2];
            LOBYTE(v46) = v13;
            v5[2] = v14 - 1;
            if ( (unsigned int)v5[1] > 510 )
              v5[1] = 0;
            if ( a2 )
            {
              if ( a2 == 12 )
              {
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf(s, 2048u, "%s: the asic freq is 0x%x\n", "check_asic_reg_oneChain_test", v5[2 * v5[1] + 3]);
                  applog(7, s, 0);
                }
              }
              else if ( a2 == 8 )
              {
                v44 = v5;
                v17 = &v46;
                v18 = nptr;
                while ( 1 )
                {
                  sprintf(v18, "%02x");
                  v18 += 2;
                  if ( v17 == (int *)((char *)&v46 + 3) )
                    break;
                  v17 = (int *)((char *)v17 + 1);
                }
                v5 = v44;
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf(s, 2048u, "%s: hashrate is %s\n", "check_asic_reg_oneChain_test", nptr);
                  applog(7, s, 0);
                }
                ++v43;
                v42 += (__int64)strtol(nptr, 0, 16) << 24;
              }
              goto LABEL_20;
            }
            ++v7;
            ++*(_BYTE *)(dev + a1 + 21484);
            if ( v7 == v6 )
            {
LABEL_26:
              if ( !a2 && *(_BYTE *)(dev + a1 + 21484) == 84 )
              {
                v20 = a1;
                pthread_mutex_unlock(&reg_mutex);
                goto LABEL_81;
              }
              if ( (unsigned int)log_level > 3 )
              {
                v28 = fopen(log_file, "a+");
                v29 = v28;
                if ( v28 )
                  fprintf(
                    v28,
                    "%s:%d:%s: Done reg_value_num=%d on Chain[%d]\n",
                    "driver-btm-c5.c",
                    6108,
                    "check_asic_reg_oneChain_test",
                    v6,
                    a1);
                fclose(v29);
              }
              v3 = 0;
              pthread_mutex_unlock(&reg_mutex);
              goto LABEL_9;
            }
          }
          if ( (unsigned int)log_level > 3 )
          {
            v15 = fopen(log_file, "a+");
            v16 = v15;
            if ( v15 )
              fprintf(
                v15,
                "%s:%d:%s: Fatal Error: read asic reg chain_number=%d on Chain[%d]\n",
                "driver-btm-c5.c",
                6032,
                "check_asic_reg_oneChain_test",
                BYTE1(v5[2 * v5[1] + 4]),
                a1);
            fclose(v16);
          }
          ++v5[1];
          --v5[2];
          if ( (unsigned int)v5[1] > 510 )
            v5[1] = 0;
LABEL_20:
          if ( ++v7 == v6 )
            goto LABEL_26;
          continue;
        }
      }
      break;
    }
    ++v3;
    if ( (unsigned int)log_level > 3 )
    {
      v39 = fopen(log_file, "a+");
      v40 = v39;
      if ( v39 )
        fprintf(
          v39,
          "%s:%d:%s: Need Retry: read asic reg reg_value_num=%d reg_value_buf.p_rd=%d on Chain[%d]\n",
          "driver-btm-c5.c",
          5998,
          "check_asic_reg_oneChain_test",
          v6,
          v5[1],
          a1);
      fclose(v40);
    }
    pthread_mutex_unlock(&reg_mutex);
  }
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 704AB8: using guessed type char status_error;
// 713490: using guessed type _QWORD rate[16];
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 816744: using guessed type int reg_value_buf[];
// 817C28: using guessed type int dev;

//----- (00032578) --------------------------------------------------------
int __fastcall check_asic_reg_with_addr(int a1, int a2, unsigned __int8 a3)
{
  int v3; // r5
  int v6; // r6
  unsigned int v7; // r8
  int v9; // r5
  int v10; // [sp+14h] [bp-844h]
  unsigned __int8 v12; // [sp+20h] [bp-838h]
  int v13; // [sp+24h] [bp-834h]
  int v14; // [sp+28h] [bp-830h]
  int v15; // [sp+2Ch] [bp-82Ch]
  char s[2088]; // [sp+30h] [bp-828h] BYREF

  v3 = (unsigned __int8)a2;
  v14 = (unsigned __int8)a2;
  v6 = (unsigned __int8)a1;
  v15 = (unsigned __int8)a1;
  v12 = a3;
  clear_register_value_buf();
  read_asic_register(a3, 0, v3, v6);
  v13 = 5;
  cgsleep_ms();
  while ( 1 )
  {
LABEL_2:
    pthread_mutex_lock(&reg_mutex);
    v7 = dword_81674C;
    pthread_mutex_unlock(&reg_mutex);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: reg_value_num %d", "check_asic_reg_with_addr", v7);
      applog(7, s, 0);
    }
    if ( v7 <= 510 )
    {
      v9 = v7 == 0;
      if ( (unsigned int)dword_816748 > 510 )
        v9 = 1;
      if ( !v9 )
        break;
    }
    clear_register_value_buf();
    read_asic_register(v12, 0, v14, v15);
    cgsleep_ms();
    if ( !--v13 )
    {
      clear_register_value_buf();
      return 0;
    }
  }
  v12 = v7;
  pthread_mutex_lock(&reg_mutex);
  while ( 1 )
  {
    ++v9;
    v10 = reg_value_buf[2 * dword_816748 + 3];
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: chip %x reg %x reg_buff %x", "check_asic_reg_with_addr", a2, a1, v10);
      applog(7, s, 0);
    }
    ++dword_816748;
    --dword_81674C;
    if ( (unsigned int)dword_816748 > 510 )
      dword_816748 = 0;
    if ( a1 == 32 )
      break;
    if ( v9 == v7 )
    {
      pthread_mutex_unlock(&reg_mutex);
      goto LABEL_2;
    }
  }
  pthread_mutex_unlock(&reg_mutex);
  clear_register_value_buf();
  if ( (v10 & 0xC0000000) != 0 )
    return 0;
  else
    return v10;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 816744: using guessed type int reg_value_buf[];
// 816748: using guessed type int dword_816748;
// 81674C: using guessed type int dword_81674C;

//----- (0003274C) --------------------------------------------------------
int __fastcall wait_iic_ok(int a1, unsigned __int8 a2)
{
  int v4; // r4

  v4 = check_asic_reg_with_addr(32, a1, a2);
  if ( !v4 )
  {
    cgsleep_ms();
    v4 = check_asic_reg_with_addr(32, a1, a2);
    if ( !v4 )
      cgsleep_ms();
  }
  return v4;
}

//----- (00032784) --------------------------------------------------------
int __fastcall check_reg_temp(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6)
{
  int v10; // r7
  int v11; // r6

  pthread_mutex_lock(&temp_mutex);
  if ( a4 )
  {
    v10 = 0;
    while ( 1 )
    {
      ++v10;
      wait_iic_ok(a5, a6);
      read_temp(a1, a2, a3, a4, a5, a6);
      wait_iic_ok(a5, a6);
      cgsleep_ms();
      wait_iic_ok(a5, a6);
      read_temp(a1, a2, 0, 0, a5, a6);
      v11 = wait_iic_ok(a5, a6);
      cgsleep_ms();
      if ( a2 == BYTE1(v11) || (unsigned __int8)v11 == a3 )
        break;
      if ( v10 != 1 )
      {
LABEL_5:
        pthread_mutex_unlock(&temp_mutex);
        return 0;
      }
    }
  }
  else
  {
    v10 = 0;
    while ( 1 )
    {
      ++v10;
      wait_iic_ok(a5, a6);
      read_temp(a1, a2, a3, 0, a5, a6);
      cgsleep_ms();
      v11 = wait_iic_ok(a5, a6);
      cgsleep_ms();
      if ( a2 == BYTE1(v11) && (v11 & 0x7F) != 127 )
        break;
      if ( v10 != 1 )
        goto LABEL_5;
    }
  }
  pthread_mutex_unlock(&temp_mutex);
  if ( v10 == 2 )
    return 0;
  else
    return v11;
}

//----- (00032880) --------------------------------------------------------
int __fastcall calc_offset(int a1, int a2)
{
  float v2; // s14

  v2 = (double)a1 - ((double)a2 + 273.15) * 0.101190476 - (double)a2;
  return (char)(int)(float)(0.0 - v2);
}

//----- (000328DC) --------------------------------------------------------
int __fastcall get_remote(__int16 a1)
{
  int v1; // r3
  float v2; // s16
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v1 = (__int16)(a1 - 64);
  v2 = ((double)v1 * 1.008 - 27.8613) / 1.11;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "remote : %d temp : %f", v1, v2);
    applog(7, s, 0);
  }
  return (__int16)(int)v2;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00032990) --------------------------------------------------------
int __fastcall get_local(__int16 a1)
{
  return (__int16)(a1 - 64);
}

//----- (00032998) --------------------------------------------------------
int __fastcall do_calibration_sensor_offset(int a1, int a2, int a3, int a4)
{
  int v4; // r10
  int v9; // r2
  int v10; // r0
  bool v11; // zf
  char v12; // r3
  int v13; // r3
  bool v14; // cc
  bool v15; // zf
  bool v16; // zf
  int v17; // r9
  int v18; // r10
  float v19; // s14
  float v20; // s14
  int v21; // r6
  int v22; // r2
  FILE *v24; // r0
  FILE *v25; // r7
  FILE *v26; // r0
  FILE *v27; // r11
  FILE *v28; // r0
  FILE *v29; // r11
  FILE *v30; // r0
  FILE *v31; // r11
  FILE *v32; // r0
  FILE *v33; // r7

  v4 = 8 * a3;
  v9 = dev + 8 * a3 + a4;
  v10 = *(unsigned __int8 *)(v9 + 1128);
  v11 = v10 == 26;
  if ( v10 != 26 )
    v11 = v10 == 85;
  v12 = !v11;
  if ( v10 == 65 )
    v13 = 0;
  else
    v13 = v12 & 1;
  if ( v13 )
  {
    DEVICEADDR[a3] = -104;
    v10 = (unsigned __int8)check_reg_temp(152, 254, 0, 0, a2, a3);
    LOBYTE(v9) = log_level;
    v14 = (unsigned int)log_level > 3;
    *(_BYTE *)(dev + v4 + a4 + 1128) = v10;
    if ( v14 )
    {
      v28 = fopen(log_file, "a+");
      v29 = v28;
      if ( v28 )
        fprintf(
          v28,
          "%s:%d:%s: Chain[J%d] try read temp chip[%d] ID=%02x (I2C addr=0x98)\n",
          "driver-btm-c5.c",
          6340,
          "do_calibration_sensor_offset",
          a3 + 1,
          a2,
          *(unsigned __int8 *)(dev + v4 + a4 + 1128));
      fclose(v29);
      v10 = *(unsigned __int8 *)(dev + v4 + a4 + 1128);
    }
    v15 = v10 == 85;
    if ( v10 != 85 )
      v15 = v10 == 26;
    v13 = v15;
    if ( v10 == 65 )
      v13 |= 1u;
    if ( v13 )
    {
      a1 = 152;
    }
    else
    {
      DEVICEADDR[a3] = -102;
      v10 = (unsigned __int8)check_reg_temp(154, 254, 0, 0, a2, a3);
      LOBYTE(v9) = log_level;
      v14 = (unsigned int)log_level > 3;
      *(_BYTE *)(dev + v4 + a4 + 1128) = v10;
      if ( v14 )
      {
        v30 = fopen(log_file, "a+");
        v31 = v30;
        if ( v30 )
          fprintf(
            v30,
            "%s:%d:%s: Chain[J%d] try read temp chip[%d] ID=%02x (I2C addr=0x9A)\n",
            "driver-btm-c5.c",
            6352,
            "do_calibration_sensor_offset",
            a3 + 1,
            a2,
            *(unsigned __int8 *)(dev + v4 + a4 + 1128));
        fclose(v31);
        v10 = *(unsigned __int8 *)(dev + v4 + a4 + 1128);
      }
      v16 = v10 == 85;
      if ( v10 != 85 )
        v16 = v10 == 26;
      v13 = v16;
      if ( v10 == 65 )
        v13 |= 1u;
      if ( v13 )
      {
        a1 = 154;
      }
      else
      {
        DEVICEADDR[a3] = -100;
        v10 = (unsigned __int8)check_reg_temp(156, 254, 0, 0, a2, a3);
        LOBYTE(v9) = log_level;
        v14 = (unsigned int)log_level > 3;
        v13 = dev + v4 + a4;
        *(_BYTE *)(v13 + 1128) = v10;
        if ( v14 )
        {
          v32 = fopen(log_file, "a+");
          v33 = v32;
          if ( v32 )
            fprintf(
              v32,
              "%s:%d:%s: Chain[J%d] try read temp chip[%d] ID=%02x (I2C addr=0x9C)\n",
              "driver-btm-c5.c",
              6364,
              "do_calibration_sensor_offset",
              a3 + 1,
              a2,
              *(unsigned __int8 *)(dev + v4 + a4 + 1128));
          fclose(v33);
          v13 = dev;
          v10 = *(unsigned __int8 *)(a4 + v4 + dev + 1128);
        }
        a1 = 156;
      }
    }
  }
  if ( v10 != 85 )
  {
    v13 = (int)&unk_712748;
    LOBYTE(v9) = 1;
  }
  if ( v10 != 85 )
    *(_BYTE *)(v13 + 3616) = v9;
  check_reg_temp(a1, 9, 4, 1, a2, a3);
  check_reg_temp(a1, 17, 0, 1, a2, a3);
  v17 = (char)(check_reg_temp(a1, 0, 0, 0, a2, a3) - 64);
  v18 = (char)(check_reg_temp(a1, 1, 0, 0, a2, a3) - 64);
  v19 = (double)v18 - ((double)v17 + 273.15) * 0.101190476 - (double)v17;
  v20 = 0.0 - v19;
  v21 = (char)(int)v20;
  if ( v21 <= 0 )
  {
    if ( (unsigned int)log_level > 3 )
    {
      v26 = fopen(log_file, "a+");
      v27 = v26;
      if ( v26 )
        fprintf(
          v26,
          "%s:%d:%s: Warning: Chain[%d] chip[%d] local:%hhd remote:%hhd offset:%hhd, will fixed offset=27\n",
          "driver-btm-c5.c",
          6398,
          "do_calibration_sensor_offset",
          a3,
          a2,
          v17,
          v18,
          (char)(int)v20);
      fclose(v27);
      v22 = 27;
      v21 = 27;
    }
    else
    {
      v22 = 27;
      v21 = 27;
    }
  }
  else
  {
    v22 = (unsigned __int8)v21;
  }
  check_reg_temp(a1, 17, v22, 1, a2, a3);
  if ( (unsigned int)log_level <= 3 )
    return v21;
  v24 = fopen(log_file, "a+");
  v25 = v24;
  if ( v24 )
    fprintf(
      v24,
      "%s:%d:%s: New offset Chain[%d] chip[%d] local:%hhd remote:%hhd offset:%hhd \n",
      "driver-btm-c5.c",
      6405,
      "do_calibration_sensor_offset",
      a3 + 1,
      a2,
      v17,
      v18,
      v21);
  fclose(v25);
  return v21;
}
// 32ABC: variable 'v9' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 817C28: using guessed type int dev;
// 817CEC: using guessed type unsigned __int8 DEVICEADDR[16];

//----- (00032D70) --------------------------------------------------------
int __fastcall set_baud_with_addr(char a1, int a2, char a3, int a4, int a5, int a6, int a7)
{
  int v8; // r4
  int v9; // r0
  int v10; // r0
  char v12; // r0
  int v13; // r0
  int v14; // r4
  unsigned int v15; // [sp+10h] [bp-828h] BYREF
  unsigned int v16; // [sp+14h] [bp-824h]
  char v17; // [sp+18h] [bp-820h]
  unsigned int v18; // [sp+1Ch] [bp-81Ch] BYREF
  unsigned int v19; // [sp+20h] [bp-818h]
  int v20; // [sp+24h] [bp-814h]
  char s[2064]; // [sp+28h] [bp-810h] BYREF

  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  if ( opt_multi_version )
  {
    if ( a2 )
      LOBYTE(v15) = 88;
    else
      LOBYTE(v15) = 72;
    LOBYTE(v16) = 64;
    BYTE2(v15) = a3;
    BYTE1(v15) = 9;
    HIBYTE(v15) = 28;
    if ( a7 )
      BYTE1(v16) = 32;
    else
      BYTE1(v16) = 33;
    v12 = a1 & 0x1F;
    if ( a5 )
    {
      v12 |= 64u;
      HIBYTE(v16) = -32;
      BYTE2(v16) = v12;
    }
    else
    {
      BYTE2(v16) = v12;
      HIBYTE(v16) = -128;
    }
    if ( a6 )
      BYTE2(v16) = v12 | 0x80;
    v17 = 0;
    v13 = CRC5(&v15, 64u);
    v17 = v13;
    v20 = v13 << 24;
    v18 = bswap32(v15);
    v19 = bswap32(v16);
    while ( 1 )
    {
      v14 = get_BC_write_command();
      if ( v14 >= 0 )
        break;
      cgsleep_ms();
    }
    set_BC_command_buffer(&v18);
    return set_BC_write_command((a4 << 16) | 0x80800000 | v14 & 0xFFF0FFFF);
  }
  else
  {
    v8 = a1 & 0x1F;
    LOWORD(v15) = 4230;
    BYTE2(v15) = a1 & 0x1F;
    v9 = CRC5(&v15, 27u);
    HIBYTE(v15) = v9;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        s,
        2048u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
        "set_baud_with_addr",
        134,
        16,
        v8,
        v9);
      applog(7, s, 0);
    }
    v18 = bswap32(v15);
    set_BC_command_buffer(&v18);
    v10 = get_BC_write_command();
    return set_BC_write_command(v10 & 0xFFF0FFFF | (a4 << 16) | 0x80800000);
  }
}
// 7DF98: using guessed type int opt_multi_version;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00032F10) --------------------------------------------------------
int __fastcall calibration_sensor_offset(int a1, int a2)
{
  unsigned int v3; // r3
  const char **v4; // r6
  char *v5; // r4
  FILE *v6; // r0
  FILE *v7; // r7
  int v8; // r4
  int v9; // r3
  int v10; // r1
  int v11; // r2
  char *v12; // r4
  int v13; // r6
  int v14; // r3
  char *v15; // r4
  unsigned __int8 v16; // r2
  char v17; // r2
  char v18; // r0
  char v19; // r0
  int v20; // r2
  int v21; // lr
  bool v22; // cc
  int v23; // r9
  int v24; // r3
  int v25; // lr
  _BOOL4 v26; // r1
  bool v27; // r0
  unsigned __int8 v29; // r2
  int v30; // r9
  char v31; // r0
  int v32; // r3
  bool v33; // zf
  int v34; // lr
  int v35; // r1
  unsigned __int8 v36; // lr
  char v37; // r0
  int v38; // r3
  bool v39; // zf
  int v40; // r1
  unsigned __int8 v41; // lr
  char v42; // r0
  int v43; // r0
  bool v44; // r3
  char v46; // r0
  FILE *v47; // r0
  FILE *v48; // r6
  FILE *v49; // r0
  FILE *v50; // r9
  FILE *v51; // r0
  FILE *v52; // r9
  FILE *v54; // r0
  FILE *v55; // r4
  FILE *v56; // r0
  FILE *v57; // r4
  int v58; // r3
  int v59; // r4
  char *v60; // r6
  char v61; // r0
  unsigned int v62; // r3
  FILE *v63; // r0
  FILE *v64; // r10
  FILE *v65; // r0
  FILE *v66; // r10
  FILE *v67; // r0
  FILE *v68; // r4
  FILE *v69; // r0
  FILE *v70; // r4
  int *v71; // [sp+18h] [bp-1Ch]
  char *modes; // [sp+1Ch] [bp-18h]
  char *v73; // [sp+20h] [bp-14h]
  int v74; // [sp+24h] [bp-10h]
  int v75; // [sp+28h] [bp-Ch]
  int v76; // [sp+34h] [bp+0h] BYREF
  int v77; // [sp+38h] [bp+4h]
  int v78; // [sp+3Ch] [bp+8h]
  int v79; // [sp+40h] [bp+Ch]
  __int16 v80; // [sp+44h] [bp+10h]
  char v81[6]; // [sp+46h] [bp+12h] BYREF

  v77 = 0;
  v76 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  pthread_mutex_lock(&iic_mutex);
  AT24C02_read_bytes_part_7(152, &v76, a2, 8);
  pthread_mutex_unlock(&iic_mutex);
  v3 = log_level;
  if ( (unsigned int)log_level > 3 )
  {
    v56 = fopen(log_file, "a+");
    v57 = v56;
    if ( v56 )
      fprintf(
        v56,
        "%s:%d:%s: Chain[J%d] PIC temp offset: ",
        "driver-btm-c5.c",
        6614,
        "calibration_sensor_offset",
        a2 + 1);
    fclose(v57);
    v3 = log_level;
  }
  v4 = (const char **)v81;
  v5 = (char *)&v76;
  v71 = &v76;
  do
  {
    while ( v3 <= 3 )
    {
      if ( ++v5 == v81 )
        goto LABEL_8;
    }
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(v6, "%d,", *v5);
    ++v5;
    fclose(v7);
    v3 = log_level;
  }
  while ( v5 != v81 );
LABEL_8:
  if ( v3 > 3 )
  {
    v4 = (const char **)&log_file;
    v54 = fopen(log_file, "a+");
    v55 = v54;
    if ( v54 )
      fputc(10, v54);
    fclose(v55);
    v3 = log_level;
    v8 = BYTE2(v77) & 0x1F;
    if ( v8 != 7 )
    {
LABEL_10:
      if ( v8 == 9 || v8 == 6 )
      {
        if ( v3 > 3 )
          v4 = (const char **)(unsigned __int16)&log_file;
        v74 = 154;
        if ( v3 > 3 )
          HIWORD(v4) = (unsigned int)&log_file >> 16;
        DEVICEADDR[a2] = -102;
        if ( v3 <= 3 )
          goto LABEL_17;
      }
      else
      {
        if ( v3 > 3 )
          v4 = (const char **)(unsigned __int16)&log_file;
        v74 = 152;
        if ( v3 > 3 )
          HIWORD(v4) = (unsigned int)&log_file >> 16;
        DEVICEADDR[a2] = -104;
        if ( v3 <= 3 )
          goto LABEL_17;
      }
LABEL_75:
      v47 = fopen(*v4, "a+");
      v48 = v47;
      if ( v47 )
        fprintf(
          v47,
          "%s:%d:%s: chain[%d] temp chip I2C addr=0x%02x\n",
          "driver-btm-c5.c",
          6648,
          "calibration_sensor_offset",
          a2 + 1,
          v74);
      fclose(v48);
LABEL_17:
      if ( (unsigned int)(v8 - 1) > 1 )
      {
        chip_hasNoMiddle = 1;
        if ( (unsigned int)log_level > 3 )
        {
          v67 = fopen(log_file, "a+");
          v68 = v67;
          if ( v67 )
            fprintf(
              v67,
              "%s:%d:%s: chain[%d] has no middle temp, use special fix mode.\n",
              "driver-btm-c5.c",
              6656,
              "calibration_sensor_offset",
              a2 + 1);
          fclose(v68);
        }
      }
      goto LABEL_19;
    }
    DEVICEADDR[a2] = -100;
    if ( v3 > 3 )
    {
      v74 = 156;
      goto LABEL_75;
    }
  }
  else
  {
    v8 = BYTE2(v77) & 0x1F;
    if ( v8 != 7 )
      goto LABEL_10;
    DEVICEADDR[a2] = -100;
  }
  v74 = 156;
  chip_hasNoMiddle = 1;
LABEL_19:
  v9 = 0;
  v10 = dev;
  v11 = 1;
  *(_BYTE *)(dev + a2 + 1112) = 0;
  v12 = 0;
  while ( 1 )
  {
    if ( v9 != 3 )
    {
      if ( *((_BYTE *)&v76 + 2 * v9) )
        v12 = (char *)(unsigned __int8)((_BYTE)v12 + 1);
      if ( v11 == 9 )
        break;
    }
    ++v9;
    ++v11;
  }
  modes = v12;
  if ( !v12 )
  {
LABEL_95:
    v75 = 8 * a2;
    if ( (unsigned int)log_level > 3 )
      goto LABEL_110;
    goto LABEL_96;
  }
  v13 = 8 * a2;
  v14 = 0;
  v73 = (char *)&unk_708E90 + 8 * a2;
  v15 = 0;
  while ( 1 )
  {
    v16 = *((_BYTE *)&v76 + 2 * (_DWORD)v15) - 1;
    if ( v16 <= 82u )
      break;
LABEL_27:
    ++v15;
    v71 = (int *)((char *)v71 + 2);
    if ( v15 == modes )
    {
      if ( v14 <= 0 )
        goto LABEL_95;
      return 0;
    }
  }
  v75 = 8 * a2;
  v17 = 3 * v16;
  *(_BYTE *)(v10 + v13 + v14 + 1256) = v17;
  v18 = *(_BYTE *)(v10 + 21551);
  v73[v14 + 1160] = *((_BYTE *)v71 + 1);
  set_baud_with_addr(v18, 0, v17, a2, 1, 0, 1);
  check_asic_reg_with_addr(28, *(unsigned __int8 *)(dev + v13 + *(char *)(dev + a2 + 1112) + 1256), a2);
  v19 = check_reg_temp(v74, 254, 0, 0, *(_BYTE *)(dev + v13 + *(char *)(dev + a2 + 1112) + 1256), a2);
  v20 = dev;
  v21 = dev + a2;
  v22 = (unsigned int)log_level > 3;
  *(_BYTE *)(*(char *)(dev + a2 + 1112) + dev + v13 + 1128) = v19;
  if ( v22 )
  {
    v49 = fopen(log_file, "a+");
    v50 = v49;
    if ( v49 )
      fprintf(
        v49,
        "%s:%d:%s: Chain[J%d] chip[%d] use PIC middle temp offset=%d typeID=%02x\n",
        "driver-btm-c5.c",
        6681,
        "calibration_sensor_offset",
        a2 + 1,
        *(unsigned __int8 *)(dev + v13 + *(char *)(dev + a2 + 1112) + 1256),
        v73[*(char *)(dev + a2 + 1112) + 1160],
        *(unsigned __int8 *)(dev + v13 + *(char *)(dev + a2 + 1112) + 1128));
    fclose(v50);
    v20 = dev;
    v21 = dev + a2;
  }
  v23 = *(char *)(v21 + 1112);
  v24 = v20 + v13 + v23;
  v25 = *(unsigned __int8 *)(v24 + 1128);
  v26 = v25 != 85;
  v27 = v25 != 26 && v25 != 85;
  if ( v25 == 65 || !v27 )
    goto LABEL_66;
  v29 = *(_BYTE *)(v24 + 1256);
  v30 = 152;
  chip_hasNoMiddle = 1;
  DEVICEADDR[a2] = -104;
  v31 = check_reg_temp(152, 254, 0, 0, v29, a2);
  v20 = dev;
  v33 = v31 == 85;
  if ( v31 != 85 )
    v33 = v31 == 26;
  v34 = dev + a2;
  if ( v33 )
    v32 = 1;
  if ( !v33 )
    v32 = 0;
  if ( v31 == 65 )
    v32 |= 1u;
  v35 = *(char *)(v34 + 1112) + dev + v13;
  *(_BYTE *)(v35 + 1128) = v31;
  if ( v32 )
    goto LABEL_58;
  v30 = 154;
  v36 = *(_BYTE *)(v35 + 1256);
  DEVICEADDR[a2] = -102;
  v37 = check_reg_temp(154, 254, 0, 0, v36, a2);
  v20 = dev;
  v39 = v37 == 85;
  if ( v37 != 85 )
    v39 = v37 == 26;
  v34 = dev + a2;
  if ( v39 )
    v38 = 1;
  if ( !v39 )
    v38 = 0;
  if ( v37 == 65 )
    v38 |= 1u;
  v40 = *(char *)(v34 + 1112) + dev + v13;
  *(_BYTE *)(v40 + 1128) = v37;
  if ( v38 )
  {
LABEL_58:
    v74 = v30;
  }
  else
  {
    v41 = *(_BYTE *)(v40 + 1256);
    v74 = 156;
    DEVICEADDR[a2] = -100;
    v42 = check_reg_temp(156, 254, 0, 0, v41, a2);
    v20 = dev;
    v34 = dev + a2;
    *(_BYTE *)(*(char *)(dev + a2 + 1112) + dev + v13 + 1128) = v42;
  }
  v23 = *(char *)(v34 + 1112);
  v43 = *(unsigned __int8 *)(v20 + v13 + v23 + 1128);
  v26 = v43 != 85;
  v44 = v43 != 26 && v43 != 85;
  if ( v43 == 65 || !v44 )
  {
LABEL_66:
    if ( v26 )
      is218_Temp = 1;
    v46 = do_calibration_sensor_offset(v74, *(unsigned __int8 *)(v20 + v13 + v23 + 1256), a2, v23);
    v22 = (unsigned int)log_level > 3;
    v73[v23 + 1160] = v46;
    if ( v22 )
    {
      v51 = fopen(log_file, "a+");
      v52 = v51;
      if ( v51 )
        fprintf(
          v51,
          "%s:%d:%s: Chain[J%d] chip[%d] get middle temp offset=%d typeID=%02x\n",
          "driver-btm-c5.c",
          6774,
          "calibration_sensor_offset",
          a2 + 1,
          (unsigned __int8)v15[dev + 1256 + v13],
          v73[*(char *)(dev + a2 + 1112) + 1160],
          *(unsigned __int8 *)(dev + v13 + *(char *)(dev + a2 + 1112) + 1128));
      fclose(v52);
    }
    v10 = dev;
    v14 = (char)(*(_BYTE *)(dev + a2 + 1112) + 1);
    *(_BYTE *)(dev + a2 + 1112) = v14;
    goto LABEL_27;
  }
  *(_BYTE *)(v34 + 1112) = 0;
  if ( (unsigned int)log_level <= 3 )
    goto LABEL_96;
LABEL_110:
  v69 = fopen(log_file, "a+");
  v70 = v69;
  if ( v69 )
    fprintf(
      v69,
      "%s:%d:%s: Warning: Chain[J%d] has no temp offset in PIC! will fix it\n",
      "driver-btm-c5.c",
      6786,
      "calibration_sensor_offset",
      a2 + 1);
  fclose(v70);
LABEL_96:
  v58 = dev;
  *(_BYTE *)(dev + a2 + 1112) = 2;
  *(_BYTE *)(v58 + 8 * (a2 + 157)) = 69;
  v59 = 0;
  *(_BYTE *)(v58 + v75 + 1257) = -124;
  v60 = (char *)&middle_Offset + v75;
  do
  {
    set_baud_with_addr(*(_BYTE *)(v58 + 21551), 0, *(_BYTE *)(v58 + v75 + v59 + 1256), a2, 1, 0, 1);
    check_asic_reg_with_addr(28, *(unsigned __int8 *)(dev + v75 + v59 + 1256), a2);
    if ( (unsigned int)log_level > 3 )
    {
      v63 = fopen(log_file, "a+");
      v64 = v63;
      if ( v63 )
        fprintf(
          v63,
          "%s:%d:%s: Chain[J%d] use default temp chip[%d] \n",
          "driver-btm-c5.c",
          6910,
          "calibration_sensor_offset",
          a2 + 1,
          *(unsigned __int8 *)(dev + v75 + v59 + 1256));
      fclose(v64);
    }
    v61 = do_calibration_sensor_offset(v74, *(unsigned __int8 *)(dev + v75 + v59 + 1256), a2, v59);
    v62 = log_level;
    *v60 = v61;
    if ( v62 > 3 )
    {
      v65 = fopen(log_file, "a+");
      v66 = v65;
      if ( v65 )
        fprintf(
          v65,
          "%s:%d:%s: Chain[J%d] chip[%d] get middle temp offset=%d typeID=%02x\n",
          "driver-btm-c5.c",
          6915,
          "calibration_sensor_offset",
          a2 + 1,
          *(unsigned __int8 *)(dev + v75 + v59 + 1256),
          *v60,
          *(unsigned __int8 *)(dev + v75 + v59 + 1128));
      fclose(v66);
    }
    v58 = dev;
    ++v59;
    ++v60;
  }
  while ( *(char *)(dev + a2 + 1112) > v59 );
  return 0;
}
// 331AC: variable 'v32' is possibly undefined
// 331FC: variable 'v38' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 713568: using guessed type char is218_Temp;
// 713569: using guessed type char chip_hasNoMiddle;
// 817C28: using guessed type int dev;
// 817CEC: using guessed type unsigned __int8 DEVICEADDR[16];

//----- (000336E4) --------------------------------------------------------
FILE *clearTempLogFile()
{
  FILE *result; // r0

  result = fopen("/tmp/temp", "w");
  if ( result )
    return (FILE *)j_fclose(result);
  return result;
}

//----- (00033708) --------------------------------------------------------
FILE *__fastcall writeLogFile(const char *a1)
{
  FILE *result; // r0
  FILE *v3; // r4
  size_t v4; // r0

  result = fopen("/tmp/temp", "a+");
  if ( result )
  {
    v3 = result;
    v4 = strlen(a1);
    fwrite(a1, 1u, v4, v3);
    return (FILE *)j_fclose(v3);
  }
  return result;
}

//----- (00033744) --------------------------------------------------------
FILE *showAllBadRTInfo()
{
  double *v0; // r8
  int v1; // r2
  int v2; // r7
  int v3; // r4
  double *v4; // r5
  FILE *result; // r0
  double v6; // d7
  char s[1064]; // [sp+8h] [bp-428h] BYREF

  v0 = (double *)chain_asic_RT;
  v1 = 1;
  do
  {
    v2 = v1 + 1;
    v3 = *(_DWORD *)(dev + 4 * (v1 + 1));
    if ( v3 == 1 )
    {
      v4 = v0;
      sprintf(s, "Check Chain[J%d] ASIC RT error: (asic index start from 1-%d)\n", v1, 84);
      result = writeLogFile(s);
      do
      {
        v6 = *v4++;
        if ( v6 > 100.0 )
        {
          sprintf(s, "Asic[%02d]=%f\n", v3, v6);
          result = writeLogFile(s);
        }
        ++v3;
      }
      while ( v3 != 85 );
    }
    v0 += 84;
    v1 = v2;
  }
  while ( v2 != 17 );
  return result;
}
// 713570: using guessed type _QWORD chain_asic_RT[1176];
// 817C28: using guessed type int dev;

//----- (000337E4) --------------------------------------------------------
int __fastcall check_asic_reg(int a1)
{
  __int64 v1; // d0
  int v2; // r5
  int *v3; // r10
  int v5; // r9
  int *v6; // r4
  int *v7; // r3
  int v8; // r10
  int v9; // r11
  int *v10; // r8
  unsigned int v11; // r6
  int v12; // r7
  int v13; // r5
  int *v14; // r10
  int v15; // r3
  int v16; // r2
  int v17; // r3
  int v18; // r2
  int *v19; // r3
  int v20; // r2
  int *v21; // r3
  unsigned int v22; // r2
  int v23; // r3
  int *v24; // r3
  int v25; // r8
  int v26; // r3
  char *v27; // r4
  char *v28; // r8
  int v29; // t1
  char *v30; // r0
  bool v31; // zf
  int v32; // r3
  bool v33; // nf
  int *v35; // r3
  unsigned int v36; // r1
  unsigned __int64 v37; // [sp+8h] [bp-490h]
  int v38; // [sp+10h] [bp-488h]
  int v39; // [sp+14h] [bp-484h]
  int *v40; // [sp+18h] [bp-480h]
  unsigned __int64 *v41; // [sp+1Ch] [bp-47Ch]
  char *v42; // [sp+20h] [bp-478h]
  unsigned __int64 v43; // [sp+28h] [bp-470h]
  int *v44; // [sp+30h] [bp-468h]
  int v45; // [sp+3Ch] [bp-45Ch] BYREF
  char v46; // [sp+40h] [bp-458h] BYREF
  char nptr[12]; // [sp+44h] [bp-454h] BYREF
  char v48[32]; // [sp+50h] [bp-448h] BYREF
  char s[2]; // [sp+70h] [bp-428h] BYREF

  v2 = 0;
  v45 = 0;
  v46 = 0;
  v3 = &dev;
  while ( 1 )
  {
    v5 = 0;
    v41 = rate;
    v42 = displayed_rate;
    clear_register_value_buf();
    v40 = (int *)&rate_error;
LABEL_4:
    if ( *(_DWORD *)(*v3 + 4 * (v5 + 2)) != 1 )
      goto LABEL_3;
    read_asic_register((unsigned __int8)v5, 1, 0, (unsigned __int8)a1);
    if ( a1 )
    {
      if ( a1 == 8 )
      {
        sprintf(s, "\nget RT hashrate from Chain[%d]: (asic index start from 1-%d)\n", v5, 84);
        writeLogFile(s);
        if ( v2 > 2 )
          goto LABEL_55;
      }
      else if ( v2 > 2 )
      {
        goto LABEL_55;
      }
    }
    else
    {
      *(_BYTE *)(*v3 + v5 + 21484) = 0;
      if ( v2 > 2 )
        goto LABEL_55;
    }
    v6 = reg_value_buf;
    v38 = 0;
    v43 = 0LL;
    v7 = v3;
    v8 = a1;
    v9 = 0;
    v10 = v7;
LABEL_8:
    cgsleep_ms();
    pthread_mutex_lock(&reg_mutex);
    v11 = v6[2];
    if ( v11 <= 510 && (unsigned int)v6[1] <= 510 )
      break;
    a1 = v8;
    ++v2;
    v3 = v10;
    pthread_mutex_unlock(&reg_mutex);
  }
  if ( !v11 )
  {
    ++v2;
    cgsleep_ms();
    pthread_mutex_unlock(&reg_mutex);
    if ( v2 != 3 )
      goto LABEL_8;
    v24 = v10;
    v25 = v9;
    a1 = v8;
    v3 = v24;
    if ( !a1 )
      goto LABEL_64;
    goto LABEL_32;
  }
  v38 += v11;
  if ( v38 > 600 )
  {
    pthread_mutex_unlock(&reg_mutex);
    return 0;
  }
  v12 = v8;
  v13 = 0;
  v14 = v10;
  do
  {
    while ( 1 )
    {
      v15 = v6[1] + 1;
      if ( BYTE1(v6[2 * v15 + 2]) != v5 )
      {
        v6[1] = v15;
        --v6[2];
        if ( (unsigned int)v6[1] > 510 )
          v6[1] = 0;
        goto LABEL_16;
      }
      v16 = v6[2 * v15 + 1];
      v17 = v6[1];
      HIBYTE(v45) = v16;
      v18 = v6[2 * v17 + 3];
      v19 = &v6[2 * v6[1] + 2];
      BYTE2(v45) = BYTE1(v18);
      v20 = v19[1];
      v21 = &v6[2 * v6[1] + 2];
      BYTE1(v45) = BYTE2(v20);
      v22 = HIBYTE(v21[1]);
      ++v6[1];
      v23 = v6[2];
      LOBYTE(v45) = v22;
      v6[2] = v23 - 1;
      if ( (unsigned int)v6[1] > 510 )
        v6[1] = 0;
      if ( !v12 )
        break;
      if ( v12 == 12 )
      {
        sprintf(s, "chain[%d]: the asic freq is 0x%x\n", v5, v6[2 * v6[1] + 3]);
        writeInitLogFile(s);
      }
      else
      {
        if ( v12 == 24 )
        {
          sprintf(s, "chain[%02d] chip[%02d]: the asic TICKET_MASK is 0x%08x\n", v5, ++v9, v6[2 * v6[1] + 3]);
        }
        else if ( v12 == 20 )
        {
          sprintf(s, "chain[%02d] chip[%02d]: the asic HASH_COUNTING_NUMBER is 0x%08x\n", v5, ++v9, v6[2 * v6[1] + 3]);
        }
        else
        {
          if ( v12 != 16 )
          {
            if ( v12 == 8 )
            {
              v39 = v9 + 1;
              if ( v9 + 1 <= 84 )
              {
                v44 = v6;
                v27 = (char *)&v45;
                v28 = nptr;
                do
                {
                  v29 = (unsigned __int8)*v27++;
                  v30 = v28;
                  v28 += 2;
                  sprintf(v30, "%02x", v29);
                }
                while ( v27 != &v46 );
                v6 = v44;
                v37 = (__int64)strtol(nptr, 0, 16) << 24;
                if ( v37 <= 99999999999LL )
                  v43 += v37;
                suffix_string_c5_constprop_16(v37, v48, 32u, 6);
                sprintf(s, "Asic[%02d]=%s ", v39, v48);
                writeLogFile(s);
                strtod(v48, 0);
                v31 = (v39 & 7) == 0;
                if ( (v39 & 7) != 0 )
                  v31 = v39 == 84;
                chain_asic_RT[84 * v5 + v9] = v1;
                if ( v31 )
                {
                  strcpy(s, "\n");
                  writeLogFile(s);
                }
              }
              ++v9;
            }
            goto LABEL_16;
          }
          sprintf(s, "chain[%02d] chip[%02d]: the asic START_NONCE_OFFSET is 0x%08x\n", v5, ++v9, v6[2 * v6[1] + 3]);
        }
        writeInitLogFile(s);
      }
LABEL_16:
      if ( ++v13 == v11 )
        goto LABEL_22;
    }
    ++v13;
    ++*(_BYTE *)(*v14 + v5 + 21484);
  }
  while ( v13 != v11 );
LABEL_22:
  v10 = v14;
  v8 = v12;
  if ( v12 || *(_BYTE *)(*v10 + v5 + 21484) != 84 )
  {
    v2 = 0;
    pthread_mutex_unlock(&reg_mutex);
    goto LABEL_8;
  }
  v35 = v10;
  v25 = v9;
  v3 = v35;
  a1 = 0;
  pthread_mutex_unlock(&reg_mutex);
LABEL_64:
  v36 = *(unsigned __int8 *)(*v3 + v5 + 21484);
  if ( *(unsigned __int8 *)(*v3 + 21550) < v36 )
    *(_BYTE *)(*v3 + 21550) = v36;
LABEL_32:
  if ( v25 )
  {
    *v41 = v43;
    suffix_string_c5_constprop_16(v43, v42, 32u, 6);
    v26 = (unsigned __int8)status_error;
    *v40 = 0;
    if ( v26 )
    {
      *v40 = 1;
      goto LABEL_35;
    }
    goto LABEL_58;
  }
LABEL_55:
  v32 = *v40 + 1;
  v33 = *v40 - 2 < 0;
  *v40 = v32;
  if ( !(v33 ^ __OFSUB__(v32, 3) | (v32 == 3)) || status_error )
  {
LABEL_35:
    *v41 = 0LL;
    suffix_string_c5_constprop_16(0LL, v42, 32u, 6);
  }
LABEL_58:
  v2 = 0;
  clear_register_value_buf();
LABEL_3:
  ++v5;
  ++v41;
  v42 += 32;
  ++v40;
  if ( v5 != 16 )
    goto LABEL_4;
  return 1;
}
// 33B88: variable 'v1' is possibly undefined
// 704AB8: using guessed type char status_error;
// 713490: using guessed type _QWORD rate[16];
// 713570: using guessed type _QWORD chain_asic_RT[1176];
// 816744: using guessed type int reg_value_buf[];
// 817C28: using guessed type int dev;

//----- (00033C48) --------------------------------------------------------
int updateLogFile()
{
  return j_system("cp /tmp/temp /tmp/lasttemp");
}

//----- (00033C54) --------------------------------------------------------
FILE *__fastcall saveTestID(int a1)
{
  FILE *result; // r0
  FILE *v3; // r4
  char v4[48]; // [sp+0h] [bp-30h] BYREF

  result = fopen("/etc/config/testID", "wb");
  if ( result )
  {
    v3 = result;
    memset(v4, 0, 32u);
    sprintf(v4, "%d", a1);
    fwrite(v4, 1u, 32u, v3);
    return (FILE *)fclose(v3);
  }
  return result;
}

//----- (00033CA4) --------------------------------------------------------
FILE *readTestID()
{
  FILE *result; // r0
  FILE *v1; // r4
  char v2[40]; // [sp+0h] [bp-28h] BYREF

  result = fopen("/etc/config/testID", "rb");
  v1 = result;
  if ( result )
  {
    memset(v2, 0, 32u);
    fread(v2, 1u, 32u, v1);
    fclose(v1);
    return (FILE *)strtol(v2, 0, 10);
  }
  return result;
}

//----- (00033CF0) --------------------------------------------------------
int __fastcall fakeMiddleTempFromPCB(int a1)
{
  return a1 + 15;
}

//----- (00033CF4) --------------------------------------------------------
void __noreturn check_temp_func()
{
  int v0; // r9
  int i; // r4
  int v2; // r3
  int v3; // r5
  unsigned __int8 v4; // r1
  int v5; // r0
  int v6; // r0
  int j; // r4
  int v8; // r0
  int dhash_acc_control; // r0
  bool v10; // zf
  FILE *v11; // r0
  FILE *v12; // r4

  v0 = -100;
  while ( 1 )
  {
    for ( i = 0; i != 16; ++i )
    {
      while ( 1 )
      {
        v2 = dev;
        if ( *(_DWORD *)(dev + 4 * (i + 2)) != 1 )
          goto LABEL_3;
        if ( fpga_version > 13 || fpga_major_version > 197 )
          break;
        if ( i % 3 == 1 )
          goto LABEL_8;
LABEL_3:
        if ( ++i == 16 )
          goto LABEL_15;
      }
      if ( (i & 0xFFFFFFFD) != 8 )
      {
        v10 = i == 12;
        if ( i != 12 )
          v10 = i == 6;
        if ( !v10 )
          goto LABEL_3;
      }
LABEL_8:
      if ( *(char *)(dev + i + 1112) <= 0 )
        goto LABEL_3;
      v3 = 0;
      do
      {
        v4 = *(_BYTE *)(v2 + 8 * i + v3++ + 1256);
        v5 = check_reg_temp(DEVICEADDR[i], 0, 0, 0, v4, i);
        if ( v5 )
        {
          v6 = (unsigned __int8)v5 - 64;
          if ( v0 < v6 )
            v0 = v6;
        }
        v2 = dev;
      }
      while ( *(char *)(dev + i + 1112) > v3 );
    }
LABEL_15:
    if ( v0 > 89 )
    {
      global_stop = 1;
      status_error = 1;
      once_error = 1;
      if ( (unsigned int)log_level > 3 )
      {
        v11 = fopen(log_file, "a+");
        v12 = v11;
        if ( v11 )
          fprintf(v11, "%s:%d:%s: disable pic dac because of temp\n", "driver-btm-c5.c", 8362, "check_temp_func");
        fclose(v12);
      }
      for ( j = 0; j != 16; ++j )
      {
        while ( *(_DWORD *)(dev + 4 * (j + 2)) != 1 )
        {
          if ( ++j == 16 )
            goto LABEL_21;
        }
        pthread_mutex_lock(&iic_mutex);
        v8 = (unsigned __int8)j;
        disable_pic_dac(v8);
        pthread_mutex_unlock(&iic_mutex);
      }
LABEL_21:
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
    }
    sleep(3u);
  }
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 704AB8: using guessed type char status_error;
// 817C24: using guessed type int fpga_major_version;
// 817C28: using guessed type int dev;
// 817CEC: using guessed type unsigned __int8 DEVICEADDR[16];
// 817D00: using guessed type int fpga_version;

//----- (00033E8C) --------------------------------------------------------
int __fastcall chain_inactive(int a1)
{
  int v2; // r0
  int v3; // r0
  int v5; // r0
  int v6; // r4
  unsigned int v7; // [sp+1Ch] [bp-824h] BYREF
  unsigned __int8 v8; // [sp+20h] [bp-820h]
  unsigned int v9; // [sp+24h] [bp-81Ch] BYREF
  int v10; // [sp+28h] [bp-818h]
  int v11; // [sp+2Ch] [bp-814h]
  char s[2064]; // [sp+30h] [bp-810h] BYREF

  *(_WORD *)((char *)&v7 + 1) = 0;
  HIBYTE(v7) = 0;
  v8 = 5;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( opt_multi_version )
  {
    LOWORD(v7) = 1365;
    v5 = CRC5(&v7, 32u);
    v8 = v5;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        s,
        2048u,
        "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x\n",
        "chain_inactive",
        85,
        5,
        0,
        0,
        v5);
      applog(7, s, 0);
      v5 = v8;
    }
    v10 = v5 << 24;
    v9 = bswap32(v7);
    while ( 1 )
    {
      v6 = get_BC_write_command();
      if ( v6 >= 0 )
        break;
      cgsleep_ms();
    }
    set_BC_command_buffer(&v9);
    return set_BC_write_command((a1 << 16) | 0x80800000 | v6 & 0xFFF0FFFF);
  }
  else
  {
    LOBYTE(v7) = -123;
    v2 = CRC5(&v7, 27u);
    HIBYTE(v7) = v2;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n", "chain_inactive", 133, 0, 0, v2);
      applog(7, s, 0);
    }
    v9 = bswap32(v7);
    set_BC_command_buffer(&v9);
    v3 = get_BC_write_command();
    return set_BC_write_command((a1 << 16) | 0x80800000 | v3 & 0xFFF0FFFF);
  }
}
// 7DF98: using guessed type int opt_multi_version;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00034018) --------------------------------------------------------
int __fastcall set_address(int a1, int a2, int a3)
{
  int v5; // r6
  int v6; // r0
  int v7; // r0
  int v9; // r0
  int v10; // r4
  unsigned int v11; // [sp+10h] [bp-830h] BYREF
  int v12; // [sp+14h] [bp-82Ch]
  char v13; // [sp+18h] [bp-828h]
  int v14; // [sp+1Ch] [bp-824h] BYREF
  int v15; // [sp+20h] [bp-820h]
  int v16; // [sp+24h] [bp-81Ch]
  char s[2072]; // [sp+28h] [bp-818h] BYREF

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( opt_multi_version )
  {
    BYTE2(v11) = a3;
    LOWORD(v11) = 1345;
    v9 = CRC5(&v11, 32u);
    LOBYTE(v12) = v9;
    v15 = v9 << 24;
    v14 = (a3 << 8) | 0x41050000;
    while ( 1 )
    {
      v10 = get_BC_write_command();
      if ( v10 >= 0 )
        break;
      cgsleep_ms();
    }
    set_BC_command_buffer(&v14);
    return set_BC_write_command((a1 << 16) | 0x80800000 | v10 & 0xFFF0FFFF);
  }
  else
  {
    BYTE1(v11) = a3;
    LOBYTE(v11) = 1;
    v5 = 1;
    if ( a2 )
    {
      v5 = 129;
      LOBYTE(v11) = -127;
    }
    v6 = CRC5(&v11, 27u);
    HIBYTE(v11) = v6;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n", "set_address", v5, a3, 0, v6);
      applog(7, s, 0);
    }
    v14 = bswap32(v11);
    set_BC_command_buffer(&v14);
    v7 = get_BC_write_command();
    return set_BC_write_command((a1 << 16) | 0x80800000 | v7 & 0xFFF0FFFF);
  }
}
// 7DF98: using guessed type int opt_multi_version;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (0003414C) --------------------------------------------------------
int __fastcall calculate_asic_number(int result)
{
  char v1[2056]; // [sp+0h] [bp-808h] BYREF

  if ( result != 1 && result != 2 )
  {
    if ( (unsigned int)(result - 3) > 1 )
    {
      if ( (unsigned int)(result - 5) > 3 )
      {
        if ( (unsigned int)(result - 9) > 7 )
        {
          if ( (unsigned int)(result - 17) > 15 )
          {
            if ( (unsigned int)(result - 33) > 31 )
            {
              if ( (unsigned int)(result - 65) > 63 )
              {
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf(v1, 2048u, "actual_asic_number = %d, but it is error\n", result);
                  applog(7, v1, 0);
                  return -1;
                }
                else
                {
                  return -1;
                }
              }
              else
              {
                return 128;
              }
            }
            else
            {
              return 64;
            }
          }
          else
          {
            return 32;
          }
        }
        else
        {
          return 16;
        }
      }
      else
      {
        return 8;
      }
    }
    else
    {
      return 4;
    }
  }
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00034204) --------------------------------------------------------
int __fastcall calculate_core_number(int result)
{
  if ( result != 1 && result != 2 )
  {
    if ( (unsigned int)(result - 3) <= 1 )
    {
      return 4;
    }
    else if ( (unsigned int)(result - 5) > 3 )
    {
      if ( (unsigned int)(result - 9) > 7 )
      {
        if ( (unsigned int)(result - 17) > 15 )
        {
          if ( (unsigned int)(result - 33) > 31 )
          {
            if ( (unsigned int)(result - 65) > 63 )
            {
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                return calculate_core_number_part_11(result);
              else
                return -1;
            }
            else
            {
              return 128;
            }
          }
          else
          {
            return 64;
          }
        }
        else
        {
          return 32;
        }
      }
      else
      {
        return 16;
      }
    }
    else
    {
      return 8;
    }
  }
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (00034290) --------------------------------------------------------
unsigned int __fastcall software_set_address_onChain(unsigned __int8 a1)
{
  int v2; // r4
  unsigned int v3; // r5
  unsigned int result; // r0
  char v5[2072]; // [sp+0h] [bp-818h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(v5, 2048u, "--- %s\n", "software_set_address_onChain");
    applog(7, v5, 0);
  }
  v2 = 0;
  *(_BYTE *)(dev + 21549) = 3;
  v3 = 0;
  chain_inactive(a1);
  cgsleep_ms();
  chain_inactive(a1);
  cgsleep_ms();
  chain_inactive(a1);
  cgsleep_ms();
  do
  {
    ++v3;
    set_address(a1, 0, v2);
    v2 = (unsigned __int8)(*(_BYTE *)(dev + 21549) + v2);
    cgsleep_ms();
    result = 256 / *(unsigned __int8 *)(dev + 21549);
  }
  while ( result > v3 );
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (00034364) --------------------------------------------------------
unsigned int software_set_address()
{
  unsigned int result; // r0
  int v1; // r3
  int v2; // r4
  int v3; // r6
  unsigned int v4; // r10
  char v5[2080]; // [sp+0h] [bp-820h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(v5, 2048u, "--- %s\n", "software_set_address");
    applog(7, v5, 0);
  }
  v1 = dev;
  v2 = 0;
  *(_BYTE *)(dev + 21549) = 3;
  while ( *(_DWORD *)(v1 + 4 * (v2 + 2)) != 1 || !*(_BYTE *)(v1 + v2 + 21484) )
  {
    if ( ++v2 == 16 )
      return result;
LABEL_7:
    v1 = dev;
  }
  v3 = 0;
  v4 = 0;
  chain_inactive((unsigned __int8)v2);
  cgsleep_ms();
  chain_inactive((unsigned __int8)v2);
  cgsleep_ms();
  chain_inactive((unsigned __int8)v2);
  cgsleep_ms();
  do
  {
    ++v4;
    set_address((unsigned __int8)v2, 0, v3);
    v3 = (unsigned __int8)(*(_BYTE *)(dev + 21549) + v3);
    cgsleep_ms();
    result = 256 / *(unsigned __int8 *)(dev + 21549);
  }
  while ( result > v4 );
  if ( ++v2 != 16 )
    goto LABEL_7;
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (00034468) --------------------------------------------------------
int __fastcall set_asic_ticket_mask(unsigned int a1)
{
  unsigned int v1; // r2
  int result; // r0
  int v3; // r4
  int v4; // lr
  int v5; // r0
  unsigned int v6; // r3
  int v7; // r11
  int v8; // r10
  int v9; // r7
  int v10; // r7
  int v11; // r0
  char v12; // [sp+10h] [bp-858h]
  unsigned __int8 v13; // [sp+14h] [bp-854h]
  int v14; // [sp+18h] [bp-850h]
  int v15; // [sp+1Ch] [bp-84Ch]
  unsigned int v16; // [sp+20h] [bp-848h]
  unsigned int v17; // [sp+28h] [bp-840h] BYREF
  int v18; // [sp+2Ch] [bp-83Ch]
  char v19; // [sp+30h] [bp-838h]
  unsigned int v20; // [sp+34h] [bp-834h] BYREF
  int v21; // [sp+38h] [bp-830h]
  int v22; // [sp+3Ch] [bp-82Ch]
  char s[2088]; // [sp+40h] [bp-828h] BYREF

  v1 = bswap32(a1);
  v16 = HIBYTE(v1);
  v12 = a1;
  result = 24;
  v13 = v1;
  v14 = BYTE1(v1);
  v15 = BYTE2(v1);
  v3 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  do
  {
    while ( *(_DWORD *)(dev + 4 * (v3 + 2)) != 1 )
    {
      if ( ++v3 == 16 )
        return result;
    }
    if ( opt_multi_version )
    {
      v17 = 402655576;
      v7 = bit_swap_table[v13];
      v8 = bit_swap_table[v14];
      HIBYTE(v18) = bit_swap_table[v16];
      v9 = bit_swap_table[v15];
      BYTE1(v18) = v8;
      BYTE2(v18) = v9;
      v10 = HIBYTE(v18) | (v7 << 24) | (v8 << 16) | (v9 << 8);
      LOBYTE(v18) = v7;
      v11 = CRC5(&v17, 64u);
      v21 = v10;
      v19 = v11;
      v22 = v11 << 24;
      v20 = 1476984856;
    }
    else
    {
      LOWORD(v17) = 4230;
      BYTE2(v17) = v12 & 0x1F;
      v4 = CRC5(&v17, 27u);
      HIBYTE(v17) = v4;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          s,
          2048u,
          "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n",
          "set_asic_ticket_mask",
          134,
          16,
          v12 & 0x1F,
          v4);
        applog(7, s, 0);
      }
      v20 = bswap32(v17);
    }
    set_BC_command_buffer(&v20);
    v5 = get_BC_write_command();
    v6 = (v3++ << 16) | 0x80800000;
    result = set_BC_write_command(v5 & 0xFFF0FFFF | v6);
  }
  while ( v3 != 16 );
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 805A8: using guessed type int opt_log_level;
// 806D8: using guessed type unsigned __int8 bit_swap_table[256];
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (0003460C) --------------------------------------------------------
int __fastcall set_sno(unsigned int a1)
{
  int v1; // r2
  int v2; // r3
  char v3; // r9
  char v4; // r8
  int v5; // r6
  int v6; // r4
  int result; // r0
  int v8; // r0
  int v9; // r0
  unsigned int v10; // r1
  int v11; // [sp+0h] [bp-48h]
  int v12; // [sp+4h] [bp-44h]
  int v13; // [sp+8h] [bp-40h] BYREF
  int v14; // [sp+Ch] [bp-3Ch]
  char v15; // [sp+10h] [bp-38h]
  int v16; // [sp+14h] [bp-34h] BYREF
  int v17; // [sp+18h] [bp-30h]
  int v18; // [sp+1Ch] [bp-2Ch]

  v1 = BYTE2(a1);
  v2 = BYTE1(a1);
  v13 = 0;
  v3 = HIBYTE(a1);
  v16 = 0;
  v4 = a1;
  v5 = (unsigned __int8)a1 | (HIBYTE(a1) << 24) | (BYTE2(a1) << 16) | (BYTE1(a1) << 8);
  v17 = 0;
  v6 = 0;
  v18 = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    while ( 1 )
    {
      result = v6 + 2;
      if ( *(_DWORD *)(dev + 4 * (v6 + 2)) == 1 )
      {
        if ( opt_multi_version )
          break;
      }
      if ( ++v6 == 16 )
        return result;
    }
    v13 = 268437848;
    BYTE1(v14) = v1;
    v12 = v1;
    BYTE2(v14) = v2;
    v11 = v2;
    LOBYTE(v14) = v3;
    HIBYTE(v14) = v4;
    v8 = CRC5(&v13, 64u);
    v15 = v8;
    v16 = 1476984848;
    v18 = v8 << 24;
    v17 = v5;
    set_BC_command_buffer(&v16);
    v9 = get_BC_write_command();
    v10 = (v6++ << 16) | 0x80800000;
    result = set_BC_write_command(v9 & 0xFFF0FFFF | v10);
    v1 = v12;
    v2 = v11;
  }
  while ( v6 != 16 );
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 817C28: using guessed type int dev;

//----- (000346F0) --------------------------------------------------------
int __fastcall set_hcnt(unsigned int a1)
{
  int v1; // r2
  int v2; // r3
  char v3; // r9
  char v4; // r8
  int v5; // r6
  int v6; // r4
  int result; // r0
  int v8; // r0
  int v9; // r0
  unsigned int v10; // r1
  int v11; // [sp+0h] [bp-48h]
  int v12; // [sp+4h] [bp-44h]
  int v13; // [sp+8h] [bp-40h] BYREF
  int v14; // [sp+Ch] [bp-3Ch]
  char v15; // [sp+10h] [bp-38h]
  int v16; // [sp+14h] [bp-34h] BYREF
  int v17; // [sp+18h] [bp-30h]
  int v18; // [sp+1Ch] [bp-2Ch]

  v1 = BYTE2(a1);
  v2 = BYTE1(a1);
  v13 = 0;
  v3 = HIBYTE(a1);
  v16 = 0;
  v4 = a1;
  v5 = (unsigned __int8)a1 | (HIBYTE(a1) << 24) | (BYTE2(a1) << 16) | (BYTE1(a1) << 8);
  v17 = 0;
  v6 = 0;
  v18 = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    while ( 1 )
    {
      result = v6 + 2;
      if ( *(_DWORD *)(dev + 4 * (v6 + 2)) == 1 )
      {
        if ( opt_multi_version )
          break;
      }
      if ( ++v6 == 16 )
        return result;
    }
    v13 = 335546712;
    BYTE1(v14) = v1;
    v12 = v1;
    BYTE2(v14) = v2;
    v11 = v2;
    LOBYTE(v14) = v3;
    HIBYTE(v14) = v4;
    v8 = CRC5(&v13, 64u);
    v15 = v8;
    v16 = 1476984852;
    v18 = v8 << 24;
    v17 = v5;
    set_BC_command_buffer(&v16);
    v9 = get_BC_write_command();
    v10 = (v6++ << 16) | 0x80800000;
    result = set_BC_write_command(v9 & 0xFFF0FFFF | v10);
    v1 = v12;
    v2 = v11;
  }
  while ( v6 != 16 );
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 817C28: using guessed type int dev;

//----- (000347D4) --------------------------------------------------------
int __fastcall set_baud(char a1)
{
  int v1; // r6
  int v3; // r4
  int v4; // r0
  int v5; // r0
  unsigned int v6; // r3
  int v7; // r0
  int result; // r0
  int v9; // r0
  unsigned int v10; // [sp+10h] [bp-840h] BYREF
  int v11; // [sp+14h] [bp-83Ch]
  char v12; // [sp+18h] [bp-838h]
  unsigned int v13; // [sp+1Ch] [bp-834h] BYREF
  unsigned int v14; // [sp+20h] [bp-830h]
  int v15; // [sp+24h] [bp-82Ch]
  char s[2088]; // [sp+28h] [bp-828h] BYREF

  v1 = a1 & 0x1F;
  v3 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    while ( *(_DWORD *)(dev + 4 * (v3 + 2)) != 1 )
    {
      if ( ++v3 == 16 )
        goto LABEL_11;
    }
    if ( opt_multi_version )
    {
      v10 = 469764440;
      LOWORD(v11) = 8192;
      HIBYTE(v11) = -128;
      BYTE2(v11) = v1;
      v9 = CRC5(&v10, 64u);
      v12 = v9;
      v15 = v9 << 24;
      v13 = 1476984860;
      v14 = (unsigned int)&unk_200080 | (v1 << 8);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          s,
          2048u,
          "%s: cmd_buf[0]=0x%x, cmd_buf[1]=0x%x, cmd_buf[2]=0x%x\n",
          "set_baud",
          1476984860,
          (unsigned int)&unk_200080 | (v1 << 8),
          v9 << 24);
        applog(7, s, 0);
      }
    }
    else
    {
      LOWORD(v10) = 4230;
      BYTE2(v10) = v1;
      v4 = CRC5(&v10, 27u);
      HIBYTE(v10) = v4;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(s, 2048u, "%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x\n", "set_baud", 134, 16, v1, v4);
        applog(7, s, 0);
      }
      v13 = bswap32(v10);
    }
    set_BC_command_buffer(&v13);
    v5 = get_BC_write_command();
    v6 = (v3++ << 16) | 0x80800000;
    set_BC_write_command(v5 & 0xFFF0FFFF | v6);
  }
  while ( v3 != 16 );
LABEL_11:
  cgsleep_us();
  v7 = get_BC_write_command();
  result = set_BC_write_command(v7 & 0xFFFFFFE0 | v1 & 0x1F);
  *(_BYTE *)(dev + 21551) = a1;
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (000349AC) --------------------------------------------------------
int init_uart_baud()
{
  FILE *v0; // r0
  FILE *v1; // r4

  if ( (unsigned int)log_level <= 3 )
    return set_baud(1);
  v0 = fopen(log_file, "a+");
  v1 = v0;
  if ( v0 )
    fprintf(v0, "%s:%d:%s: set baud=%d\n", "driver-btm-c5.c", 9624, "init_uart_baud", 1);
  fclose(v1);
  return set_baud(1);
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00034A18) --------------------------------------------------------
int __fastcall set_led(int a1)
{
  int v2; // r5
  const char *v3; // r3
  const char *v4; // r1
  int v6; // r3
  int v7; // r2
  int v8; // r3
  const char *v9; // r1
  char s[116]; // [sp+4h] [bp-74h] BYREF

  blink_14032 ^= 1u;
  if ( !are_pools_active() )
  {
    if ( isC5_CtrlBoard )
    {
      sprintf(s, "echo %d > %s", 0, "/sys/class/leds/hps_led0/brightness");
      system(s);
      v3 = "/sys/class/leds/hps_led2/brightness";
      LOWORD(v4) = 9284;
      goto LABEL_7;
    }
    v2 = is7007_ctrl_board;
    if ( is7007_ctrl_board == -1 )
    {
      isC5_Board();
      v2 = is7007_ctrl_board;
    }
    if ( v2 != 1 )
    {
      sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio38/value");
      system(s);
      v3 = "/sys/class/gpio/gpio37/value";
      LOWORD(v4) = (unsigned __int16)"echo %d > %s";
LABEL_7:
      HIWORD(v4) = (unsigned int)"echo %d > %s" >> 16;
      sprintf(s, v4, 1, v3);
      return system(s);
    }
    sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
    system(s);
    LOWORD(v8) = 13408;
    LOWORD(v9) = 9284;
    v7 = 1;
    goto LABEL_21;
  }
  if ( isC5_CtrlBoard )
  {
    if ( a1 )
    {
      sprintf(s, "echo %d > %s", 0, "/sys/class/leds/hps_led0/brightness");
      system(s);
      sprintf(s, "echo %d > %s", (unsigned __int8)blink_14032, "/sys/class/leds/hps_led2/brightness");
    }
    else
    {
      sprintf(s, "echo %d > %s", 0, "/sys/class/leds/hps_led2/brightness");
      system(s);
      sprintf(s, "echo %d > %s", (unsigned __int8)blink_14032, "/sys/class/leds/hps_led0/brightness");
    }
    return system(s);
  }
  v6 = is7007_ctrl_board;
  if ( is7007_ctrl_board == -1 )
  {
    isC5_Board();
    v6 = is7007_ctrl_board;
  }
  if ( v6 != 1 )
  {
    if ( a1 )
    {
      sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio38/value");
      system(s);
      sprintf(s, "echo %d > %s", (unsigned __int8)blink_14032, "/sys/class/gpio/gpio37/value");
    }
    else
    {
      sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio37/value");
      system(s);
      sprintf(s, "echo %d > %s", (unsigned __int8)blink_14032, "/sys/class/gpio/gpio38/value");
    }
    return system(s);
  }
  if ( a1 )
  {
    sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
    system(s);
    v7 = (unsigned __int8)blink_14032;
    LOWORD(v8) = (unsigned __int16)"/sys/class/gpio/gpio941/value";
    LOWORD(v9) = (unsigned __int16)"echo %d > %s";
LABEL_21:
    HIWORD(v8) = (unsigned int)"/sys/class/gpio/gpio941/value" >> 16;
    HIWORD(v9) = (unsigned int)"echo %d > %s" >> 16;
    sprintf(s, v9, v7, v8);
    return system(s);
  }
  sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
  system(s);
  sprintf(s, "echo %d > %s", (unsigned __int8)blink_14032, "/sys/class/gpio/gpio942/value");
  return system(s);
}
// 7E55C: using guessed type int is7007_ctrl_board;
// 7E564: using guessed type char blink_14032;
// 715F72: using guessed type char isC5_CtrlBoard;

//----- (00034CA8) --------------------------------------------------------
int change_pic_voltage_old()
{
  char *v0; // r6
  int v1; // r9
  int result; // r0
  unsigned int v3; // r4
  unsigned int v4; // r3

  v0 = &chain_voltage_pic;
  v1 = 0;
  result = sleep(300u);
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v1 + 2)) )
    {
      LOBYTE(v3) = de_voltage;
      v4 = (unsigned __int8)*v0;
      if ( v4 >= (unsigned __int8)de_voltage )
      {
        do
        {
          v3 = (unsigned __int8)(v3 + 5);
          if ( v3 >= v4 )
            v3 = v4;
          pthread_mutex_lock(&iic_mutex);
          pthread_mutex_unlock(&iic_mutex);
          pthread_mutex_lock(&iic_mutex);
          write_EEPROM_iic(1, 1, 144, v1, 0);
          pthread_mutex_unlock(&iic_mutex);
          result = 100;
          if ( (unsigned __int8)*v0 == v3 )
            break;
          result = cgsleep_ms();
          v4 = (unsigned __int8)*v0;
        }
        while ( v4 >= v3 );
      }
    }
    ++v1;
    ++v0;
  }
  while ( v1 != 16 );
  return result;
}
// 7E568: using guessed type char chain_voltage_pic;
// 7E578: using guessed type char de_voltage;
// 817C28: using guessed type int dev;

//----- (00034D48) --------------------------------------------------------
int __fastcall get_asic_nonce_num(int a1, int a2, int a3)
{
  int v3; // r4
  int result; // r0
  int v5; // r4
  int v6; // r3
  int v7; // r2
  int v8; // r1

  if ( a3 <= 0 )
    return 0;
  v3 = 7680 * a1;
  result = 0;
  v5 = v3 + 60 * a2;
  v6 = nonce_times % 60 - 1;
  v7 = v6 - a3;
  do
  {
    v8 = v6 + (v6 < 0 ? 60 : 0);
    --v6;
    result += nonce_num[2 * v8 + 2 * v5];
  }
  while ( v6 != v7 );
  return result;
}
// 715F74: using guessed type int nonce_times;
// 715F78: using guessed type _DWORD nonce_num[245098];

//----- (00034DB0) --------------------------------------------------------
size_t __fastcall get_lastn_nonce_num(char *a1, int a2)
{
  int v3; // r3
  int v4; // r6
  int v5; // r3
  int v6; // r2
  int v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r3
  int v11; // r2
  int v12; // r0
  int v13; // r1
  size_t result; // r0
  int v15; // [sp+0h] [bp-850h]
  char *desta; // [sp+4h] [bp-84Ch]
  char *dest; // [sp+4h] [bp-84Ch]
  char src[4]; // [sp+14h] [bp-83Ch] BYREF
  int v20; // [sp+18h] [bp-838h]
  int v21; // [sp+1Ch] [bp-834h]
  int v22; // [sp+20h] [bp-830h]
  int v23; // [sp+24h] [bp-82Ch]
  _DWORD v24[522]; // [sp+28h] [bp-828h] BYREF

  v3 = 1;
  do
  {
    while ( 1 )
    {
      v15 = v3 + 1;
      v4 = v3 - 1;
      if ( *(_DWORD *)(dev + 4 * (v3 + 1)) )
        break;
      ++v3;
      if ( v15 == 17 )
        goto LABEL_15;
    }
    desta = (char *)v3;
    v24[0] = 123;
    memset(&v24[1], 0, 2044u);
    *(_DWORD *)src = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    sprintf(src, "Chain%d:{", desta);
    dest = (char *)stpcpy((char *)v24 + 1, src);
    if ( a2 <= 0 )
    {
      v5 = 0;
    }
    else
    {
      v5 = 0;
      v6 = nonce_times % 60 - 1;
      v7 = v6 - a2;
      do
      {
        v8 = v6 + (v6 < 0 ? 60 : 0);
        --v6;
        v5 += nonce_num[15360 * v4 + 2 * v8];
      }
      while ( v6 != v7 );
    }
    sprintf(src, "N%d=%d", 0, v5);
    strcpy(dest, src);
    if ( *(unsigned __int8 *)(dev + 21550) > 1u )
    {
      v9 = 1;
      do
      {
        if ( a2 <= 0 )
        {
          v10 = 0;
        }
        else
        {
          v10 = 0;
          v11 = nonce_times % 60 - 1;
          v12 = v11 - a2;
          do
          {
            v13 = v11 + (v11 < 0 ? 60 : 0);
            --v11;
            v10 += nonce_num[15360 * v4 + 120 * v9 + 2 * v13];
          }
          while ( v12 != v11 );
        }
        sprintf(src, ",N%d=%d", v9, v10);
        strcat((char *)v24, src);
        ++v9;
      }
      while ( *(unsigned __int8 *)(dev + 21550) > v9 );
    }
    strcat((char *)v24, "},");
    strcat(a1, (const char *)v24);
    v3 = v15;
  }
  while ( v15 != 17 );
LABEL_15:
  result = strlen(a1);
  a1[result - 1] = 0;
  return result;
}
// 12138: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 715F74: using guessed type int nonce_times;
// 715F78: using guessed type _DWORD nonce_num[245098];
// 817C28: using guessed type int dev;

//----- (00034F6C) --------------------------------------------------------
bool if_hashrate_ok()
{
  double v0; // d8
  int TotalRate_part_12; // s14

  v0 = *(double *)total_mhashes_done / 1000.0 / total_secs;
  if ( opt_economic_mode )
    TotalRate_part_12 = GetTotalRate_part_12();
  else
    TotalRate_part_12 = ideal_total_hash_rate;
  return v0 > (double)TotalRate_part_12 * 0.98;
}
// 7DEC8: using guessed type double total_secs;
// 70943E: using guessed type char opt_economic_mode;
// 709440: using guessed type int ideal_total_hash_rate;

//----- (00034FE8) --------------------------------------------------------
bool if_avg_hash_ok()
{
  double v0; // d0
  FILE *v2; // r0
  FILE *v3; // r5

  getAVGhashrate();
  if ( (unsigned int)log_level > 3 )
  {
    v2 = fopen(log_file, "a+");
    v3 = v2;
    if ( v2 )
      fprintf(
        v2,
        "%s:%d:%s: avg hash rate = %f, ideal hash rate = %d\n",
        "driver-btm-c5.c",
        9905,
        "if_avg_hash_ok",
        v0,
        ideal_total_hash_rate);
    fclose(v3);
  }
  return v0 > (double)ideal_total_hash_rate * 0.99;
}
// 3502A: variable 'v0' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 709440: using guessed type int ideal_total_hash_rate;

//----- (0003509C) --------------------------------------------------------
int get_runtime_hash_rate()
{
  __int64 *v0; // r3
  unsigned __int64 v1; // r6
  int v2; // r2
  int v3; // t1
  __int64 v4; // r4
  unsigned __int64 v5; // r0
  unsigned __int64 v6; // r4
  FILE *v7; // r0
  FILE *v8; // r6

  v0 = (__int64 *)&rate;
  v1 = 0LL;
  v2 = dev + 4;
  do
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(v2 + 4);
      v2 += 4;
      if ( v3 == 1 )
        break;
      if ( ++v0 == (__int64 *)&rate_error )
        goto LABEL_5;
    }
    v4 = *v0++;
    v1 += v4;
  }
  while ( v0 != (__int64 *)&rate_error );
LABEL_5:
  v5 = (unsigned __int64)((double)(v1 / (unsigned int)&unk_F4240) / 1000.0);
  v6 = v5;
  if ( (unsigned int)log_level > 4 )
  {
    v7 = fopen(log_file, "a+");
    v8 = v7;
    if ( v7 )
      fprintf(v7, "%s:%d:%s: RT hash = %llu\n", "driver-btm-c5.c", 9936, "get_runtime_hash_rate", v6);
    fclose(v8);
    LODWORD(v5) = v6;
  }
  return v5;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 817C28: using guessed type int dev;

//----- (00035170) --------------------------------------------------------
bool check_hashrate_maybe_ok()
{
  double v0; // d0
  double v1; // d8
  int TotalRate_part_12; // s14

  v1 = *(double *)total_mhashes_done / 1000.0 / total_secs;
  if ( opt_economic_mode )
    TotalRate_part_12 = GetTotalRate_part_12();
  else
    TotalRate_part_12 = ideal_total_hash_rate;
  return v1 > (double)TotalRate_part_12 * v0;
}
// 351B8: variable 'v0' is possibly undefined
// 7DEC8: using guessed type double total_secs;
// 70943E: using guessed type char opt_economic_mode;
// 709440: using guessed type int ideal_total_hash_rate;

//----- (000351E8) --------------------------------------------------------
int __fastcall saveRebootTestNum(int a1)
{
  FILE *v2; // r0
  FILE *v3; // r4
  char v5[48]; // [sp+0h] [bp-30h] BYREF

  v2 = fopen("/etc/config/rebootTest", "wb");
  if ( v2 )
  {
    v3 = v2;
    memset(v5, 0, 32u);
    sprintf(v5, "%d", a1);
    fwrite(v5, 1u, 32u, v3);
    fclose(v3);
  }
  return system("sync");
}

//----- (00035244) --------------------------------------------------------
int readRebootTestNum()
{
  return 0;
}

//----- (00035248) --------------------------------------------------------
int __fastcall saveRestartNum(int a1)
{
  FILE *v2; // r0
  FILE *v3; // r4
  char v5[48]; // [sp+0h] [bp-30h] BYREF

  v2 = fopen("/etc/config/restartTest", "wb");
  if ( v2 )
  {
    v3 = v2;
    memset(v5, 0, 32u);
    sprintf(v5, "%d", a1);
    fwrite(v5, 1u, 32u, v3);
    fclose(v3);
  }
  return system("sync");
}

//----- (000352A4) --------------------------------------------------------
FILE *readRestartNum()
{
  FILE *result; // r0
  FILE *v1; // r4
  char v2[40]; // [sp+0h] [bp-28h] BYREF

  result = fopen("/etc/config/restartTest", "rb");
  v1 = result;
  if ( result )
  {
    memset(v2, 0, 32u);
    fread(v2, 1u, 32u, v1);
    fclose(v1);
    return (FILE *)strtol(v2, 0, 10);
  }
  return result;
}

//----- (000352F0) --------------------------------------------------------
int __fastcall saveRetryFlag(int a1)
{
  FILE *v2; // r0
  FILE *v3; // r4
  char v5[48]; // [sp+0h] [bp-30h] BYREF

  v2 = fopen("/etc/config/retryFlag", "wb");
  if ( v2 )
  {
    v3 = v2;
    memset(v5, 0, 32u);
    sprintf(v5, "%d", a1);
    fwrite(v5, 1u, 32u, v3);
    fclose(v3);
  }
  return system("sync");
}

//----- (0003534C) --------------------------------------------------------
FILE *readRetryFlag()
{
  FILE *result; // r0
  FILE *v1; // r4
  char v2[40]; // [sp+0h] [bp-28h] BYREF

  result = fopen("/etc/config/retryFlag", "rb");
  v1 = result;
  if ( result )
  {
    memset(v2, 0, 32u);
    fread(v2, 1u, 32u, v1);
    fclose(v1);
    return (FILE *)strtol(v2, 0, 10);
  }
  return result;
}

//----- (00035398) --------------------------------------------------------
int __fastcall saveTestPattenHighestTemp(int a1)
{
  FILE *v2; // r0
  FILE *v3; // r4
  char v5[48]; // [sp+0h] [bp-30h] BYREF

  v2 = fopen("/etc/config/pcbtemp", "wb");
  if ( v2 )
  {
    v3 = v2;
    memset(v5, 0, 32u);
    sprintf(v5, "%d", a1);
    fwrite(v5, 1u, 32u, v3);
    fclose(v3);
  }
  return system("sync");
}

//----- (000353F4) --------------------------------------------------------
FILE *readTestPattenHighestTemp()
{
  FILE *result; // r0
  FILE *v1; // r4
  char v2[40]; // [sp+0h] [bp-28h] BYREF

  result = fopen("/etc/config/pcbtemp", "rb");
  v1 = result;
  if ( result )
  {
    memset(v2, 0, 32u);
    fread(v2, 1u, 32u, v1);
    fclose(v1);
    return (FILE *)strtol(v2, 0, 10);
  }
  return result;
}

//----- (00035440) --------------------------------------------------------
int __fastcall saveChainTestPattenResult(int a1, int a2)
{
  FILE *v3; // r0
  FILE *v4; // r4
  char v6[32]; // [sp+0h] [bp-130h] BYREF
  char s[272]; // [sp+20h] [bp-110h] BYREF

  sprintf(s, "/etc/config/%d.test", a1);
  v3 = fopen(s, "wb");
  if ( v3 )
  {
    v4 = v3;
    memset(v6, 0, sizeof(v6));
    sprintf(v6, "%d", a2);
    fwrite(v6, 1u, 32u, v4);
    fclose(v4);
  }
  return system("sync");
}

//----- (000354A4) --------------------------------------------------------
FILE *__fastcall readChainTestPattenResult(int a1)
{
  FILE *result; // r0
  FILE *v2; // r4
  char v3[32]; // [sp+0h] [bp-128h] BYREF
  char s[264]; // [sp+20h] [bp-108h] BYREF

  sprintf(s, "/etc/config/%d.test", a1);
  result = fopen(s, "rb");
  v2 = result;
  if ( result )
  {
    memset(v3, 0, sizeof(v3));
    fread(v3, 1u, 32u, v2);
    fclose(v2);
    return (FILE *)strtol(v3, 0, 10);
  }
  return result;
}

//----- (000354F8) --------------------------------------------------------
int __fastcall down_freq_n_steps(int a1, int *a2, int a3)
{
  int v5; // r6
  int v6; // r4
  int *v7; // r5
  int v8; // lr
  int v9; // r0
  FILE *v10; // r0
  FILE *v11; // r11
  FILE *v12; // r0
  FILE *v13; // r11
  __int16 v14; // r0
  bool v15; // cc
  int v16; // r4
  unsigned int v17; // r3
  int v18; // r0
  FILE *v20; // r0
  FILE *v21; // r6
  FILE *v22; // r0
  FILE *v23; // r4
  FILE *v24; // r0
  FILE *v25; // r4
  FILE *v26; // r0
  FILE *v27; // r4
  FILE *v28; // r0
  FILE *v29; // r4
  int v30; // r0

  if ( (unsigned int)log_level > 3 )
  {
    v28 = fopen(log_file, "a+");
    v29 = v28;
    if ( v28 )
      fprintf(
        v28,
        "%s:%d:%s: down_freq_n_steps chain[%d] steps = %d\n",
        "driver-btm-c5.c",
        10120,
        "down_freq_n_steps",
        a1,
        a3);
    fclose(v29);
  }
  v5 = 1;
  v6 = 0;
  v7 = a2;
  do
  {
    while ( 1 )
    {
      v8 = dev;
      v9 = *v7 - a3;
      *v7 = v9;
      set_frequency_with_addr_plldatai(v9, 0, (unsigned __int8)(*(_BYTE *)(v8 + 21549) * v6), a1);
      if ( (unsigned int)log_level > 3 )
      {
        v10 = fopen(log_file, "a+");
        v11 = v10;
        if ( v10 )
          fprintf(v10, "Asic[%2d]:%s ", v6, *(_DWORD *)&_PRETTY_FUNCTION___14958[16 * *v7 + 40]);
        fclose(v11);
        if ( (v5 & 7) == 0 && (unsigned int)log_level > 3 )
          break;
      }
      ++v6;
      ++v7;
      ++v5;
      if ( v6 == 84 )
        goto LABEL_12;
    }
    v12 = fopen(log_file, "a+");
    v13 = v12;
    if ( v12 )
      fputc(10, v12);
    ++v6;
    fclose(v13);
    ++v7;
    ++v5;
  }
  while ( v6 != 84 );
LABEL_12:
  if ( (unsigned int)log_level > 3 )
  {
    v26 = fopen(log_file, "a+");
    v27 = v26;
    if ( v26 )
      fputc(10, v26);
    fclose(v27);
  }
  v14 = strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * *a2 + 40], 0, 10);
  v15 = (unsigned int)log_level > 3;
  *(_WORD *)(dev + 21571) = v14;
  if ( v15 )
  {
    v20 = fopen(log_file, "a+");
    v21 = v20;
    if ( v20 )
      fprintf(
        v20,
        "%s:%d:%s: max freq = %d\n",
        "driver-btm-c5.c",
        10157,
        "down_freq_n_steps",
        *(unsigned __int16 *)(dev + 21571));
    fclose(v21);
    if ( (unsigned int)log_level <= 3 )
    {
      if ( (byte_805F7C & 4) == 0 )
        goto LABEL_20;
      goto LABEL_15;
    }
    v22 = fopen(log_file, "a+");
    v23 = v22;
    if ( v22 )
      fprintf(
        v22,
        "%s:%d:%s: dev->timeout = %d\n",
        "driver-btm-c5.c",
        10159,
        "down_freq_n_steps",
        *(_DWORD *)(dev + 72));
    fclose(v23);
  }
  if ( (byte_805F7C & 4) != 0 )
  {
LABEL_15:
    if ( word_805F8A )
    {
      v16 = dev;
      v17 = HIBYTE(word_805F8A) + 1000 * (unsigned __int8)word_805F8A;
    }
    else
    {
      v30 = calculate_core_number(*(unsigned __int8 *)(dev + 21548));
      v16 = dev;
      v17 = 90 * (*(unsigned __int8 *)(v16 + 21549) * (16777216 / v30) / *(unsigned __int16 *)(v16 + 21571)) / 100;
    }
    *(_DWORD *)(dev + 72) = v17;
    if ( v17 > 131071 )
      *(_DWORD *)(v16 + 72) = 131071;
  }
  if ( (unsigned int)log_level > 3 )
  {
    v24 = fopen(log_file, "a+");
    v25 = v24;
    if ( v24 )
      fprintf(
        v24,
        "%s:%d:%s: dev->timeout = %d\n",
        "driver-btm-c5.c",
        10177,
        "down_freq_n_steps",
        *(_DWORD *)(dev + 72));
    fclose(v25);
  }
LABEL_20:
  set_asic_ticket_mask(ticket_mask);
  set_hcnt(0);
  set_sno(0);
  cgsleep_ms();
  if ( opt_multi_version )
    v18 = (*(_DWORD *)(dev + 72) * opt_multi_version) & 0x1FFFF | 0x80000000;
  else
    v18 = *(_DWORD *)(dev + 72) & 0x1FFFF | 0x80000000;
  return set_time_out_control(v18);
}
// 7DF98: using guessed type int opt_multi_version;
// 7E57C: using guessed type int ticket_mask;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805F7C: using guessed type char byte_805F7C;
// 805F8A: using guessed type __int16 word_805F8A;
// 817C28: using guessed type int dev;

//----- (0003585C) --------------------------------------------------------
void print_freq_table()
{
  bool v0; // zf
  unsigned int v1; // r3
  _DWORD *v2; // r5
  int v3; // r4
  FILE *v4; // r0
  FILE *v5; // r7
  FILE *v6; // r0
  FILE *v7; // r7
  FILE *v8; // r4
  FILE *v9; // r0
  FILE *v10; // r4
  int v11; // [sp+Ch] [bp-34h]
  _DWORD *v12; // [sp+10h] [bp-30h]

  v12 = &freq_table;
  v11 = 0;
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v11 + 2)) == 1 )
    {
      v1 = log_level;
      if ( (unsigned int)log_level > 3 )
      {
        v9 = fopen(log_file, "a+");
        v10 = v9;
        if ( v9 )
          fprintf(v9, "%s:%d:%s: chain[%d] freq table:\n", "driver-btm-c5.c", 10200, "print_freq_table", v11);
        fclose(v10);
        v1 = log_level;
      }
      v2 = v12;
      v3 = 1;
      do
      {
        while ( 1 )
        {
          if ( v1 > 3 )
          {
            v4 = fopen(log_file, "a+");
            v5 = v4;
            if ( v4 )
              fprintf(v4, "Asic[%2d]:%s ", v3 - 1, *(const char **)&_PRETTY_FUNCTION___14958[16 * *v2 + 40]);
            fclose(v5);
            v1 = log_level;
            if ( (v3 & 7) == 0 && (unsigned int)log_level > 3 )
              break;
          }
          ++v3;
          ++v2;
          if ( v3 == 85 )
            goto LABEL_15;
        }
        v6 = fopen(log_file, "a+");
        v7 = v6;
        if ( v6 )
          fputc(10, v6);
        ++v3;
        fclose(v7);
        v1 = log_level;
        ++v2;
      }
      while ( v3 != 85 );
LABEL_15:
      if ( v1 > 3 )
      {
        v8 = fopen(log_file, "a+");
        if ( v8 )
          fwrite("\n\n", 1u, 2u, v8);
        fclose(v8);
      }
    }
    v0 = v11++ == 15;
    v12 += 256;
  }
  while ( !v0 );
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 817C28: using guessed type int dev;

//----- (000359AC) --------------------------------------------------------
int check_avg_rate()
{
  double v0; // d0
  unsigned int v1; // r6
  double v2; // d7
  int result; // r0
  int v4; // r1
  int v5; // r8
  int *v6; // r5
  int i; // r4
  int *v8; // r1
  int v9; // r0
  double v10; // d8
  FILE *v11; // r0
  FILE *v12; // r4
  FILE *v13; // r0
  FILE *v14; // r6
  FILE *v15; // r0
  FILE *v16; // r4
  FILE *v17; // r0
  FILE *v18; // r4
  FILE *v19; // r0

  getAVGhashrate();
  v1 = log_level;
  if ( (unsigned int)log_level > 3 )
  {
    v13 = fopen(log_file, "a+");
    v14 = v13;
    if ( v13 )
      fprintf(
        v13,
        "%s:%d:%s: avg_rate = %d, ideal_total_hash_rate = %d\n",
        "driver-btm-c5.c",
        10218,
        "check_avg_rate",
        (int)v0,
        ideal_total_hash_rate);
    fclose(v14);
    v1 = log_level;
  }
  v2 = (double)ideal_total_hash_rate;
  if ( v0 < (double)ideal_total_hash_rate + 450.0 && v0 > v2 )
  {
    if ( v1 <= 3 )
      return 1;
    v17 = fopen(log_file, "a+");
    v18 = v17;
    if ( v17 )
      fprintf(v17, "%s:%d:%s: avg hash rate is OK\n", "driver-btm-c5.c", 10223, "check_avg_rate");
    goto LABEL_32;
  }
  v4 = 57456 * total_exist_chain_num / 1000;
  if ( !adjust_num_14198 )
  {
    v10 = v0 - v2 - 450.0;
    if ( v10 < 0.0 )
    {
      if ( v1 <= 5 )
        return 1;
      v19 = fopen(log_file, "a+");
      v18 = v19;
      if ( v19 )
        fprintf(v19, "%s:%d:%s: avg hash is not high\n", "driver-btm-c5.c", 10240, "check_avg_rate");
LABEL_32:
      fclose(v18);
      return 1;
    }
    v5 = (int)(v10 / (double)v4);
    if ( v1 <= 3 )
      goto LABEL_12;
    goto LABEL_19;
  }
  if ( v0 >= v2 )
    v5 = 1;
  else
    v5 = -1;
  offset_14197 += v5;
  if ( (offset_14197 > 500 / v4) | ((unsigned int)offset_14197 >> 31) )
  {
    if ( v1 <= 3 )
      return 0;
    v15 = fopen(log_file, "a+");
    v16 = v15;
    if ( v15 )
      fprintf(v15, "%s:%d:%s: offset overflow, offset = %d\n", "driver-btm-c5.c", 10260, "check_avg_rate", offset_14197);
    fclose(v16);
    return 0;
  }
  if ( v1 > 3 )
  {
LABEL_19:
    v11 = fopen(log_file, "a+");
    v12 = v11;
    if ( v11 )
      fprintf(v11, "%s:%d:%s: adjust steps = %d\n", "driver-btm-c5.c", 10265, "check_avg_rate", v5);
    fclose(v12);
  }
LABEL_12:
  v6 = (int *)&freq_table;
  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dev + 4 * (i + 2)) != 1 )
    {
      ++i;
      v6 += 256;
      if ( i == 16 )
        goto LABEL_16;
    }
    v8 = v6;
    v9 = (unsigned __int8)i;
    v6 += 256;
    down_freq_n_steps(v9, v8, v5);
  }
LABEL_16:
  result = 0;
  ++adjust_num_14198;
  return result;
}
// 359F2: variable 'v0' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 709440: using guessed type int ideal_total_hash_rate;
// 805F98: using guessed type int total_exist_chain_num;
// 805F9C: using guessed type int adjust_num_14198;
// 805FA0: using guessed type int offset_14197;
// 817C28: using guessed type int dev;

//----- (00035C80) --------------------------------------------------------
void xadc_check()
{
  int v0; // r0
  int v1; // r4
  int v2; // r5
  int v3; // r5
  struct dirent *v4; // r0
  struct dirent **v5; // r5
  struct dirent **v6; // r5
  struct dirent **v7; // r5
  struct dirent **v8; // r5
  struct dirent **namelist; // [sp+4h] [bp-14h] BYREF

  v0 = scandir("/sys/bus/iio/devices/iio:device0", &namelist, 0, alphasort);
  v1 = v0;
  if ( v0 >= 0 )
  {
    if ( v0 <= 5 )
      goto LABEL_3;
    v5 = namelist;
    get_iio_node((int)namelist, 5);
    process_true_data((int)v5, 5);
    if ( v1 <= 15
      || (v6 = namelist, get_iio_node((int)namelist, 15), process_true_data((int)v6, 15), v1 <= 17)
      || (v7 = namelist, get_iio_node((int)namelist, 17), process_true_data((int)v7, 17), v1 <= 19) )
    {
LABEL_3:
      v2 = v1 - 1;
      if ( !v1 )
      {
LABEL_6:
        free(namelist);
        return;
      }
    }
    else
    {
      v8 = namelist;
      get_iio_node((int)namelist, 19);
      process_true_data((int)v8, 19);
      v2 = v1 - 1;
    }
    v3 = v2;
    do
    {
      v4 = namelist[v3--];
      free(v4);
      --v1;
    }
    while ( v1 );
    goto LABEL_6;
  }
}

//----- (00035D1C) --------------------------------------------------------
void *__fastcall close_bad_core(int a1, char a2)
{
  int v4; // r7
  void *result; // r0
  int v6; // r11
  unsigned __int8 *v7; // r10
  int dhash_acc_control; // r0
  int v9; // r0
  char *v10; // r3
  char *v11; // r11
  unsigned int v12; // r3
  int v13; // r0
  int v14; // r0
  int v15; // r5
  int v16; // r4
  int v17; // r0
  int v18; // r0
  int v19; // r4
  int v20; // r1
  int *v21; // r4
  int *v22; // lr
  int v23; // r2
  int *v24; // r3
  int v25; // r3
  FILE *v26; // r0
  FILE *v27; // r4
  FILE *v28; // r0
  FILE *v29; // r4
  int v30; // r0
  int v31; // [sp+14h] [bp-8CCh]
  int v32; // [sp+14h] [bp-8CCh]
  char *v33; // [sp+2Ch] [bp-8B4h]
  int v34; // [sp+38h] [bp-8A8h] BYREF
  unsigned int v35; // [sp+3Ch] [bp-8A4h]
  char v36; // [sp+40h] [bp-8A0h]
  int v37; // [sp+44h] [bp-89Ch] BYREF
  unsigned int v38; // [sp+48h] [bp-898h]
  int v39; // [sp+4Ch] [bp-894h]
  int s[13]; // [sp+50h] [bp-890h] BYREF
  int v41[13]; // [sp+84h] [bp-85Ch] BYREF
  char v42[2088]; // [sp+B8h] [bp-828h] BYREF

  v37 = 0;
  v4 = a1 + 2;
  v38 = 0;
  v39 = 0;
  result = memset(s, 0, sizeof(s));
  v34 = 0;
  v35 = 0;
  v36 = 0;
  if ( *(_DWORD *)(dev + 4 * v4) == 1 )
  {
    v6 = 16 * a1;
    v7 = (unsigned __int8 *)&bitmain_c5_drv + 16 * a1;
    if ( v7[120] == 44 && v7[121] == 101 && v7[122] <= 83u )
    {
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control(dhash_acc_control & 0xFFFF7FDF | ((opt_multi_version & 0xF) << 8) | 0x8000);
      set_hash_counting_number(0);
      v34 = 469764424;
      BYTE2(v35) = *(_BYTE *)(dev + 21551) & 0x1F | 0x80;
      v31 = dev;
      LOWORD(v35) = 8256;
      HIBYTE(v35) = -128;
      v36 = CRC5(&v34, 64u);
      memset(s, 0, 13);
      memset(v41, 255, sizeof(v41));
      if ( *(_DWORD *)(v31 + 4 * v4) == 1 )
      {
        if ( v7[120] == 44 && v7[121] == 101 )
        {
          if ( v7[122] <= 83u )
          {
            v32 = (unsigned __int8)a1 | 0x80;
            v10 = &disabledcore_pos_buf[v6 + 14];
            v11 = &disabledcore_pos_buf[v6];
            v33 = v10;
            do
            {
              v12 = (unsigned __int8)v11[2];
              if ( v12 <= 83 && (unsigned __int8)v11[3] <= 113u )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 4 )
                {
                  snprintf(v42, 2048u, "Close asic %d bad core %d", v12, (unsigned __int8)v11[3]);
                  applog(5, v42, 0);
                }
                v13 = get_BC_write_command();
                set_BC_write_command(v13 & 0xFF30FFFF | (a1 << 16) & 0xFF3FFFFF | 0x800000);
                v14 = get_dhash_acc_control();
                set_dhash_acc_control(v14 | 0x80);
                cgsleep_us();
                v15 = 0;
                BYTE2(v34) = *(_BYTE *)(dev + 21549) * v11[2];
                v16 = BYTE2(v34);
                v17 = CRC5(&v34, 64u);
                v36 = v17;
                *(_WORD *)((char *)v41 + 1) = (unsigned __int8)v32;
                v39 = v17 << 24;
                HIBYTE(v41[0]) = 0;
                v41[1] = 0;
                LOBYTE(v41[0]) = 1;
                LOBYTE(v41[2]) = -1;
                HIBYTE(v41[4]) = -1;
                v38 = bswap32(v35);
                v37 = HIBYTE(v34) | (BYTE1(v34) << 16) | ((unsigned __int8)v34 << 24) | (v16 << 8);
                set_BC_command_buffer(&v37);
                v18 = get_BC_write_command();
                set_BC_write_command(v18 & 0xFFF0FFFF | (a1 << 16) | 0x80800000);
                cgsleep_us();
                while ( 2 )
                {
                  if ( (unsigned __int8)v11[3] == v15 )
                  {
                    if ( (unsigned int)log_level > 3 )
                    {
                      v28 = fopen(log_file, "a+");
                      v29 = v28;
                      if ( v28 )
                        fprintf(
                          v28,
                          "%s:%d:%s: Disable Chain[%d] Chip[%d] Core[%d]!\n",
                          "driver-btm-c5.c",
                          10773,
                          "close_bad_core",
                          a1,
                          (unsigned __int8)v11[2],
                          (unsigned __int8)v11[3]);
                      fclose(v29);
                    }
                    LOBYTE(v41[2]) = 0;
                    HIBYTE(v41[4]) = 0;
                  }
                  else
                  {
                    LOBYTE(v41[2]) = -1;
                    HIBYTE(v41[4]) = -1;
                  }
                  v19 = 3001;
                  while ( (get_buffer_space() & (1 << a1)) == 0 )
                  {
                    cgsleep_us();
                    if ( !--v19 )
                    {
                      if ( (unsigned int)log_level > 3 )
                      {
                        v26 = fopen(log_file, "a+");
                        v27 = v26;
                        if ( v26 )
                          fprintf(
                            v26,
                            "%s:%d:%s: Error: send open core work Failed on Chain[%d]!\n",
                            "driver-btm-c5.c",
                            10800,
                            "close_bad_core",
                            a1);
                        fclose(v27);
                      }
                      goto LABEL_41;
                    }
                  }
                  if ( v15 )
                  {
                    v20 = 16777216;
                    LOBYTE(v41[0]) = 1;
                  }
                  else
                  {
                    v20 = 285212672;
                    LOBYTE(v41[0]) = 17;
                  }
                  v21 = v41;
                  v22 = &s[1];
                  BYTE1(v41[0]) = a1 | 0x80;
                  s[1] = v41[1];
                  s[0] = HIBYTE(v41[0]) | (BYTE2(v41[0]) << 8) | (v32 << 16) | v20;
                  do
                  {
                    v23 = *((unsigned __int8 *)v21++ + 9);
                    v22[1] = *((unsigned __int8 *)v21 + 7) | (v23 << 16) | (*((unsigned __int8 *)v21 + 4) << 24) | (*((unsigned __int8 *)v21 + 6) << 8);
                    ++v22;
                  }
                  while ( v21 != &v41[3] );
                  v24 = &s[4];
                  do
                  {
                    v24[1] = 0;
                    ++v24;
                  }
                  while ( v24 != &s[12] );
                  set_TW_write_command_vil(s);
                  if ( v15 == 113 )
                    v25 = a2 & 1;
                  else
                    v25 = 0;
                  if ( v25 )
                  {
                    v30 = get_BC_write_command();
                    set_BC_write_command(v30 | 0x400000);
                  }
                  if ( ++v15 != 114 )
                    continue;
                  break;
                }
              }
LABEL_41:
              v11 += 2;
            }
            while ( v11 != v33 );
          }
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            v42,
            2048u,
            "Chain %d disabled core magic num error [0x%x%x] except 0x2C65!!",
            a1,
            v7[120],
            *((unsigned __int8 *)&bitmain_c5_drv + v6 + 121));
          applog(5, v42, 0);
        }
      }
      v9 = get_dhash_acc_control();
      return (void *)set_dhash_acc_control(v9 | ((opt_multi_version & 0xF) << 8) | 0x8000);
    }
  }
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (0003617C) --------------------------------------------------------
int __fastcall open_core(char a1)
{
  int dhash_acc_control; // r0
  int v3; // r4
  int v4; // r5
  int v5; // r5
  int v6; // r0
  int v7; // r9
  int v8; // r0
  int v9; // r5
  int v10; // r2
  int v11; // r3
  int v12; // r11
  int v13; // r12
  unsigned __int8 *v14; // r1
  int *v15; // lr
  int v16; // r0
  int v17; // r11
  int v18; // r0
  int v20; // r0
  int v21; // r5
  int v22; // r8
  int v23; // r0
  int v24; // r3
  int v25; // r8
  int v26; // r6
  int v27; // r0
  int v28; // r0
  int v29; // r4
  int v30; // r1
  char *v31; // r0
  int *v32; // r4
  int v33; // r2
  int *v34; // r3
  int v35; // r3
  int v36; // r0
  FILE *v37; // r0
  FILE *v38; // r4
  int v39; // r0
  int v40; // r0
  int v41; // r0
  int v42; // [sp+14h] [bp-8F4h]
  char *v43; // [sp+14h] [bp-8F4h]
  unsigned int v44; // [sp+28h] [bp-8E0h] BYREF
  int v45; // [sp+2Ch] [bp-8DCh] BYREF
  int v46; // [sp+30h] [bp-8D8h]
  char v47; // [sp+34h] [bp-8D4h]
  unsigned int v48; // [sp+38h] [bp-8D0h] BYREF
  int v49; // [sp+3Ch] [bp-8CCh]
  int v50; // [sp+40h] [bp-8C8h]
  int s[13]; // [sp+44h] [bp-8C4h] BYREF
  int v52[13]; // [sp+78h] [bp-890h] BYREF
  char v53[52]; // [sp+ACh] [bp-85Ch] BYREF
  char v54[2088]; // [sp+E0h] [bp-828h] BYREF

  v44 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  memset(s, 0, sizeof(s));
  memset(v52, 0, sizeof(v52));
  memset(v53, 0, sizeof(v53));
  v53[0] = -1;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  if ( !opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFFFFDF);
    set_hash_counting_number(0);
    v3 = dev;
    v4 = *(unsigned __int8 *)(dev + 21551);
    LOWORD(v44) = 134;
    HIBYTE(v44) = -128;
    v5 = v4 | 0x80;
    BYTE2(v44) = v5;
    v6 = CRC5(&v44, 27u) & 0x1F;
    HIBYTE(v44) = v6 | 0x80;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        v54,
        2048u,
        "%s: gateblk[0]=0x%x, gateblk[1]=0x%x, gateblk[2]=0x%x, gateblk[3]=0x%x\n",
        "open_core",
        134,
        0,
        v5,
        v6 | 0x80);
      applog(7, v54, 0);
      v3 = dev;
    }
    v42 = 0;
    v48 = bswap32(v44);
    memset(v53, 0, sizeof(v53));
    v7 = 0;
    v53[51] = -1;
    v53[40] = -1;
    while ( 1 )
    {
      if ( *(_DWORD *)(v3 + 4 * (v7 + 2)) != 1 )
      {
        if ( ++v7 == 16 )
          goto LABEL_26;
        goto LABEL_9;
      }
      set_BC_command_buffer(&v48);
      v8 = get_BC_write_command();
      v9 = 0;
      set_BC_write_command(v8 & 0xFFF0FFFF | (v7 << 16) | 0x80800000);
      cgsleep_us();
      do
      {
        while ( (get_buffer_space() & (1 << v7)) == 0 )
          cgsleep_us();
        if ( v9 )
        {
          if ( v9 == 113 )
            v10 = a1 & 1;
          else
            v10 = 0;
          v53[0] = 1;
          v53[1] = v7 | 0x80;
          v11 = (unsigned __int8)v7 | 0x80;
          v12 = 1;
          if ( v10 )
          {
            v41 = get_BC_write_command();
            set_BC_write_command(v41 & ((v7 << 16) | 0xC00000));
            v12 = (unsigned __int8)v53[0];
            v11 = (unsigned __int8)v53[1];
          }
        }
        else
        {
          v53[0] = 17;
          v53[1] = v7 | 0x80;
          v40 = get_BC_write_command();
          set_BC_write_command(v40 & 0xFFBFFFFF);
          v12 = (unsigned __int8)v53[0];
          v11 = (unsigned __int8)v53[1];
        }
        v13 = v12;
        v14 = (unsigned __int8 *)v53;
        memset(s, 0, 13);
        v15 = s;
        v16 = 1;
        v17 = v11;
        while ( 1 )
        {
          *v15++ = (v17 << 16) | (v13 << 24) | v14[3] | (v14[2] << 8);
          if ( v16 != 10 )
            break;
          s[9] = v42++;
LABEL_21:
          v13 = v14[4];
          ++v16;
          v17 = v14[5];
          v14 += 4;
        }
        if ( v16 != 13 )
          goto LABEL_21;
        ++v9;
        set_TW_write_command((int)s);
      }
      while ( v9 != 114 );
      if ( ++v7 == 16 )
      {
LABEL_26:
        v18 = get_dhash_acc_control();
        return set_dhash_acc_control(v18 | 0x20);
      }
LABEL_9:
      v3 = dev;
    }
  }
  v20 = get_dhash_acc_control();
  v43 = disabledcore_pos_buf;
  set_dhash_acc_control(v20 & 0xFFFF7FDF | ((opt_multi_version & 0xF) << 8) | 0x8000);
  set_hash_counting_number(0);
  v21 = dev;
  v45 = 469764440;
  v22 = *(_BYTE *)(dev + 21551) & 0x1F | 0x80;
  LOWORD(v46) = 8256;
  BYTE2(v46) = v22;
  HIBYTE(v46) = -128;
  v23 = CRC5(&v45, 64u);
  v47 = v23;
  v24 = (v22 << 8) | 0x40200080;
  v50 = v23 << 24;
  v48 = 1476984860;
  memset(v52, 0, 13);
  v25 = 0;
  v49 = v24;
  memset(v54, 255, 52u);
  while ( 2 )
  {
    if ( *(_DWORD *)(v21 + 4 * (v25 + 2)) != 1 )
      goto LABEL_28;
    v26 = 0;
    v27 = get_BC_write_command();
    set_BC_write_command(v27 & 0xFF30FFFF | (v25 << 16) & 0xFF3FFFFF | 0x800000);
    cgsleep_us();
    v54[0] = 1;
    v54[2] = 0;
    v54[3] = 0;
    *(_DWORD *)&v54[4] = 0;
    v54[8] = -1;
    v54[19] = -1;
    v54[1] = v25 | 0x80;
    set_BC_command_buffer(&v48);
    v28 = get_BC_write_command();
    set_BC_write_command(v28 & 0xFFF0FFFF | (v25 << 16) | 0x80800000);
    cgsleep_us();
LABEL_32:
    v29 = 3001;
    do
    {
      if ( (get_buffer_space() & (1 << v25)) != 0 )
      {
        if ( v26 )
        {
          v30 = 16777216;
          v54[0] = 1;
        }
        else
        {
          v30 = 285212672;
          v54[0] = 17;
        }
        v31 = v54;
        v32 = &v52[1];
        v54[1] = v25 | 0x80;
        v52[1] = *(_DWORD *)&v54[4];
        v52[0] = (unsigned __int8)v54[3] | ((unsigned __int8)v54[2] << 8) | (((unsigned __int8)v25 | 0x80) << 16) | v30;
        do
        {
          v33 = (unsigned __int8)v31[9];
          v31 += 4;
          v32[1] = (unsigned __int8)v31[7] | (v33 << 16) | ((unsigned __int8)v31[4] << 24) | ((unsigned __int8)v31[6] << 8);
          ++v32;
        }
        while ( v31 != &v54[12] );
        v34 = &v52[4];
        do
        {
          v34[1] = 0;
          ++v34;
        }
        while ( &v52[12] != v34 );
        set_TW_write_command_vil(v52);
        if ( v26 == 113 )
          v35 = a1 & 1;
        else
          v35 = 0;
        if ( !v35 )
          goto LABEL_48;
        if ( *v43 != 44 || v43[1] != 101 || !chainHasDisabledCore_part_5(v25) )
        {
          v36 = get_BC_write_command();
          set_BC_write_command(v36 | 0x400000);
LABEL_48:
          if ( ++v26 != 114 )
            goto LABEL_32;
LABEL_49:
          close_bad_core(v25, a1);
          goto LABEL_28;
        }
        if ( ++v26 == 114 )
          goto LABEL_49;
        goto LABEL_32;
      }
      cgsleep_us();
      --v29;
    }
    while ( v29 );
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_49;
    v37 = fopen(log_file, "a+");
    v38 = v37;
    if ( v37 )
      fprintf(
        v37,
        "%s:%d:%s: Error: send open core work Failed on Chain[%d]!\n",
        "driver-btm-c5.c",
        11024,
        "open_core",
        v25);
    fclose(v38);
    close_bad_core(v25, a1);
LABEL_28:
    ++v25;
    v43 += 16;
    if ( v25 != 16 )
    {
      v21 = dev;
      continue;
    }
    break;
  }
  v39 = get_dhash_acc_control();
  return set_dhash_acc_control(v39 | ((opt_multi_version & 0xF) << 8) | 0x8000);
}
// 7DF98: using guessed type int opt_multi_version;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (000366B4) --------------------------------------------------------
int __fastcall open_core_one_chain(int a1, char a2)
{
  int dhash_acc_control; // r0
  int v5; // r7
  int v6; // r5
  int v7; // r5
  int v8; // r0
  int v9; // r0
  int v11; // r0
  int v12; // r7
  int v13; // r5
  int v14; // r0
  int v15; // r0
  unsigned __int8 v16; // r10
  int v17; // r0
  int v18; // r8
  int v19; // r4
  int v20; // r11
  int v21; // r2
  int v22; // r3
  int v23; // r9
  int v24; // r12
  unsigned __int8 *v25; // r1
  int *v26; // lr
  int v27; // r0
  int v28; // r9
  int v29; // r0
  int v30; // r7
  int v31; // r0
  int v32; // r4
  int v33; // r1
  char *v34; // r4
  int *v35; // lr
  int v36; // r2
  int *v37; // r3
  int v38; // r3
  int v39; // r0
  FILE *v40; // r0
  FILE *v41; // r4
  int v42; // r0
  int v43; // r0
  int v44; // [sp+14h] [bp-8E4h]
  char *v45; // [sp+14h] [bp-8E4h]
  unsigned int v46; // [sp+18h] [bp-8E0h] BYREF
  int v47; // [sp+1Ch] [bp-8DCh] BYREF
  int v48; // [sp+20h] [bp-8D8h]
  char v49; // [sp+24h] [bp-8D4h]
  unsigned int v50; // [sp+28h] [bp-8D0h] BYREF
  int v51; // [sp+2Ch] [bp-8CCh]
  int v52; // [sp+30h] [bp-8C8h]
  int s[13]; // [sp+34h] [bp-8C4h] BYREF
  int v54[13]; // [sp+68h] [bp-890h] BYREF
  char v55[52]; // [sp+9Ch] [bp-85Ch] BYREF
  char v56[2088]; // [sp+D0h] [bp-828h] BYREF

  v46 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  memset(s, 0, sizeof(s));
  memset(v54, 0, sizeof(v54));
  memset(v55, 0, sizeof(v55));
  v55[0] = -1;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  if ( !opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFFFFDF);
    set_hash_counting_number(0);
    v5 = dev;
    v6 = *(unsigned __int8 *)(dev + 21551);
    LOWORD(v46) = 134;
    HIBYTE(v46) = -128;
    v7 = v6 | 0x80;
    BYTE2(v46) = v7;
    v8 = CRC5(&v46, 27u) & 0x1F;
    HIBYTE(v46) = v8 | 0x80;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        v56,
        2048u,
        "%s: gateblk[0]=0x%x, gateblk[1]=0x%x, gateblk[2]=0x%x, gateblk[3]=0x%x\n",
        "open_core_one_chain",
        134,
        0,
        v7,
        v8 | 0x80);
      applog(7, v56, 0);
      v5 = dev;
    }
    v50 = bswap32(v46);
    memset(v55, 0, sizeof(v55));
    v55[51] = -1;
    v55[40] = -1;
    if ( *(_DWORD *)(v5 + 4 * (a1 + 2)) != 1 )
    {
LABEL_8:
      v9 = get_dhash_acc_control();
      return set_dhash_acc_control(v9 | 0x20);
    }
    v16 = a1 | 0x80;
    set_BC_command_buffer(&v50);
    v17 = get_BC_write_command();
    v18 = 0;
    v19 = 1 << a1;
    set_BC_write_command(v17 & 0xFFF0FFFF | (a1 << 16) | 0x80800000);
    cgsleep_us();
    v20 = 0;
    v44 = ((a1 & 0xF) << 16) | 0xC00000;
LABEL_13:
    while ( (get_buffer_space() & v19) == 0 )
      cgsleep_us();
    if ( v20 )
    {
      if ( v20 == 113 )
        v21 = a2 & 1;
      else
        v21 = 0;
      v55[0] = 1;
      v55[1] = v16;
      v22 = v16;
      v23 = 1;
      if ( v21 )
      {
        v43 = get_BC_write_command();
        set_BC_write_command(v43 & v44);
        v23 = (unsigned __int8)v55[0];
        v22 = (unsigned __int8)v55[1];
      }
    }
    else
    {
      v55[1] = v16;
      v55[0] = 17;
      v42 = get_BC_write_command();
      set_BC_write_command(v42 & 0xFFBFFFFF);
      v23 = (unsigned __int8)v55[0];
      v22 = (unsigned __int8)v55[1];
    }
    v24 = v23;
    v25 = (unsigned __int8 *)v55;
    memset(s, 0, 13);
    v26 = s;
    v27 = 1;
    v28 = v22;
    while ( 1 )
    {
      *v26++ = (v28 << 16) | (v24 << 24) | v25[3] | (v25[2] << 8);
      if ( v27 == 10 )
      {
        s[9] = v18++;
      }
      else if ( v27 == 13 )
      {
        ++v20;
        set_TW_write_command((int)s);
        if ( v20 == 114 )
          goto LABEL_8;
        goto LABEL_13;
      }
      v24 = v25[4];
      ++v27;
      v28 = v25[5];
      v25 += 4;
    }
  }
  v11 = get_dhash_acc_control();
  set_dhash_acc_control(v11 & 0xFFFF7FDF | ((opt_multi_version & 0xF) << 8) | 0x8000);
  set_hash_counting_number(0);
  v12 = dev;
  LOWORD(v48) = 8256;
  v47 = 469764440;
  v13 = *(_BYTE *)(dev + 21551) & 0x1F | 0x80;
  BYTE2(v48) = *(_BYTE *)(dev + 21551) & 0x1F | 0x80;
  HIBYTE(v48) = -128;
  v14 = CRC5(&v47, 64u);
  v49 = v14;
  memset(v54, 0, 13);
  v52 = v14 << 24;
  v51 = (v13 << 8) | 0x40200080;
  v50 = 1476984860;
  memset(v56, 255, 52u);
  if ( *(_DWORD *)(v12 + 4 * (a1 + 2)) == 1 )
  {
    v29 = get_BC_write_command() & 0xFF30FFFF | (a1 << 16) & 0xFF3FFFFF | 0x800000;
    set_BC_write_command(v29);
    cgsleep_us();
    v56[8] = -1;
    v56[19] = -1;
    v56[0] = 1;
    v30 = 0;
    v56[2] = 0;
    v56[3] = 0;
    *(_DWORD *)&v56[4] = 0;
    v56[1] = a1 | 0x80;
    set_BC_command_buffer(&v50);
    v31 = get_BC_write_command();
    set_BC_write_command(v31 & 0xFFF0FFFF | (a1 << 16) | 0x80800000);
    cgsleep_us();
    v45 = (char *)&bitmain_c5_drv + 16 * a1;
    while ( 2 )
    {
      v32 = 3001;
      while ( (get_buffer_space() & (1 << a1)) == 0 )
      {
        cgsleep_us();
        if ( !--v32 )
        {
          if ( (unsigned int)log_level > 3 )
          {
            v40 = fopen(log_file, "a+");
            v41 = v40;
            if ( v40 )
              fprintf(
                v40,
                "%s:%d:%s: Error: send open core work Failed on Chain[%d]!\n",
                "driver-btm-c5.c",
                11251,
                "open_core_one_chain",
                a1);
            fclose(v41);
          }
          goto LABEL_44;
        }
      }
      if ( v30 )
      {
        v33 = 16777216;
        v56[0] = 1;
      }
      else
      {
        v33 = 285212672;
        v56[0] = 17;
      }
      v34 = v56;
      v35 = &v54[1];
      v56[1] = a1 | 0x80;
      v54[1] = *(_DWORD *)&v56[4];
      v54[0] = (unsigned __int8)v56[3] | ((unsigned __int8)v56[2] << 8) | (((unsigned __int8)a1 | 0x80) << 16) | v33;
      do
      {
        v36 = (unsigned __int8)v34[9];
        v34 += 4;
        v35[1] = (unsigned __int8)v34[7] | (v36 << 16) | ((unsigned __int8)v34[4] << 24) | ((unsigned __int8)v34[6] << 8);
        ++v35;
      }
      while ( v34 != &v56[12] );
      v37 = &v54[4];
      do
      {
        v37[1] = 0;
        ++v37;
      }
      while ( &v54[12] != v37 );
      set_TW_write_command_vil(v54);
      if ( v30 == 113 )
        v38 = a2 & 1;
      else
        v38 = 0;
      if ( v38 && (v45[120] != 44 || v45[121] != 101 || !chainHasDisabledCore_part_5(a1)) )
      {
        v39 = get_BC_write_command();
        set_BC_write_command(v39 | 0x400000);
      }
      if ( ++v30 != 114 )
        continue;
      break;
    }
LABEL_44:
    close_bad_core(a1, a2);
  }
  v15 = get_dhash_acc_control();
  return set_dhash_acc_control(v15 | ((opt_multi_version & 0xF) << 8) | 0x8000);
}
// 7DF98: using guessed type int opt_multi_version;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (00036BA4) --------------------------------------------------------
int bitmain_reinit_test()
{
  int v0; // r5
  int v1; // r3
  int v2; // r0
  int *v3; // r7
  unsigned __int8 *v4; // r6
  int v5; // r8
  int v6; // r5
  int v7; // r9
  unsigned int v8; // s15
  FILE *v9; // r0
  unsigned int v10; // r3
  FILE *v11; // r0
  FILE *v12; // r9
  FILE *v13; // r0
  int v14; // r5
  int v15; // r0
  int v16; // r11
  FILE *v17; // r0
  FILE *v18; // r6
  FILE *v19; // r0
  FILE *v20; // r6
  int v21; // r0
  int v22; // r2
  int v23; // r1
  int v24; // r3
  int v25; // r6
  unsigned int v26; // r3
  int v27; // r5
  int v28; // r2
  int v29; // r3
  int v30; // r5
  int v31; // r0
  char *v32; // r7
  int v33; // r3
  int v34; // r6
  int v35; // t1
  int v36; // r6
  int v37; // r6
  int v38; // r2
  char *v39; // r5
  int result; // r0
  FILE *v41; // r0
  FILE *v42; // r10
  FILE *v43; // r11
  int RealBoardRate; // r0
  int TotalRate_part_12; // lr
  FILE *v46; // r0
  FILE *v47; // r10
  int dhash_acc_control; // r0
  int v49; // r0
  FILE *v50; // r0
  FILE *v51; // r6
  FILE *v52; // r0
  FILE *v53; // r6
  int v54; // r0
  int v55; // r1
  FILE *stream; // [sp+14h] [bp-864h]
  FILE *streama; // [sp+14h] [bp-864h]
  int streamb; // [sp+14h] [bp-864h]
  char s[2128]; // [sp+28h] [bp-850h] BYREF

  v0 = 0;
  pthread_mutex_lock(&iic_mutex);
  memset((void *)dev, 0, 21616u);
  *(_DWORD *)dev = job_start_address_1;
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  set_reset_allhashboard(1);
  set_QN_write_data_command(-2139062257);
  sleep(2u);
  v1 = dev;
  *(_BYTE *)(dev + 21500) = 100;
  *(_DWORD *)(v1 + 4) = 3276800;
  set_fan_control(3276800);
  set_reset_allhashboard(1);
  v2 = PHY_MEM_NONCE2_JOBID_ADDRESS;
  *(_BYTE *)(dev + 21551) = 26;
  set_nonce2_and_job_id_store_address(v2);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  check_chain();
  do
  {
    while ( *(_DWORD *)(dev + 4 * (v0 + 2)) != 1 )
    {
      if ( ++v0 == 16 )
        goto LABEL_5;
    }
    chain_voltage_pic[v0] = write_EEPROM_iic(1, 1, 144, v0, 0);
    ++v0;
  }
  while ( v0 != 16 );
LABEL_5:
  v3 = &chain_voltage_value;
  v4 = (unsigned __int8 *)chain_voltage_pic;
  v5 = 1;
  v6 = 0;
  cgsleep_ms();
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v6 + 2)) == 1 )
    {
      v7 = 10 * ((int)((364.0704 / ((double)*v4 + 30.72) + 32.79) * 100.0 / 4.75) / 10);
      if ( (unsigned int)log_level > 3 )
      {
        v13 = fopen(log_file, "a+");
        streama = v13;
        if ( v13 )
          fprintf(
            v13,
            "%s:%d:%s: Chain[J%d] working voltage=%d value=%d\n",
            "driver-btm-c5.c",
            7200,
            "bitmain_reinit_test",
            v5,
            *v4,
            v7);
        fclose(streama);
      }
      if ( chain_pic_buf[128 * v6] == 125 && *v3 > v7 )
      {
        v8 = (unsigned int)(364.0704 / ((double)*v3 * 4.75 / 100.0 - 32.79) - 30.72);
        if ( (unsigned int)log_level > 3 )
        {
          v9 = fopen(log_file, "a+");
          stream = v9;
          if ( v9 )
            fprintf(
              v9,
              "%s:%d:%s: Chain[J%d] will use backup chain_voltage_pic=%d [%d]\n",
              "driver-btm-c5.c",
              7216,
              "bitmain_reinit_test",
              v5,
              *v3,
              (unsigned __int8)v8);
          fclose(stream);
          v10 = log_level;
          *v4 = v8;
          if ( v10 > 3 )
          {
            v11 = fopen(log_file, "a+");
            v12 = v11;
            if ( v11 )
              fprintf(
                v11,
                "%s:%d:%s: Chain[J%d] get working voltage=%d\n",
                "driver-btm-c5.c",
                7224,
                "bitmain_reinit_test",
                v5,
                *v4);
            fclose(v12);
          }
        }
        else
        {
          *v4 = v8;
        }
      }
    }
    ++v6;
    ++v5;
    ++v3;
    ++v4;
  }
  while ( v6 != 16 );
  pthread_mutex_unlock(&iic_mutex);
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
  }
  cgsleep_ms();
  *(_BYTE *)(dev + 21548) = 114;
  v14 = 0;
  streamb = 1;
  check_asic_reg(0);
  cgsleep_ms();
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v14 + 2)) != 1 )
      goto LABEL_25;
    if ( (unsigned int)log_level <= 3 )
    {
      v15 = dev + v14;
      if ( *(_BYTE *)(dev + v14 + 21484) == 84 )
        goto LABEL_25;
LABEL_29:
      v16 = 6;
      while ( 1 )
      {
        *(_BYTE *)(v15 + 21484) = 0;
        set_reset_hashboard(v14, 1);
        pthread_mutex_lock(&iic_mutex);
        disable_pic_dac((unsigned __int8)v14);
        pthread_mutex_unlock(&iic_mutex);
        sleep(1u);
        pthread_mutex_lock(&iic_mutex);
        enable_pic_dac((unsigned __int8)v14);
        pthread_mutex_unlock(&iic_mutex);
        sleep(2u);
        set_reset_hashboard(v14, 0);
        sleep(1u);
        check_asic_reg_oneChain(v14, 0);
        v15 = dev + v14;
        if ( *(_BYTE *)(dev + v14 + 21484) == 84 )
          goto LABEL_34;
        if ( !--v16 )
        {
          if ( !*(_BYTE *)(v15 + 21484) )
            *(_DWORD *)(dev + 4 * (v14 + 2)) = 0;
          goto LABEL_34;
        }
      }
    }
    v19 = fopen(log_file, "a+");
    v20 = v19;
    if ( v19 )
      fprintf(
        v19,
        "%s:%d:%s: Chain[J%d] has %d asic\n",
        "driver-btm-c5.c",
        7291,
        "bitmain_reinit_test",
        streamb,
        *(unsigned __int8 *)(dev + v14 + 21484));
    fclose(v20);
    v15 = dev + v14;
    if ( *(_BYTE *)(dev + v14 + 21484) != 84 )
      goto LABEL_29;
LABEL_34:
    if ( (unsigned int)log_level > 3 )
    {
      v17 = fopen(log_file, "a+");
      v18 = v17;
      if ( v17 )
        fprintf(
          v17,
          "%s:%d:%s: retry Chain[J%d] has %d asic\n",
          "driver-btm-c5.c",
          7324,
          "bitmain_reinit_test",
          streamb,
          *(unsigned __int8 *)(dev + v14 + 21484));
      fclose(v18);
    }
LABEL_25:
    ++v14;
    ++streamb;
  }
  while ( v14 != 16 );
  software_set_address();
  cgsleep_ms();
  if ( (byte_805F7C & 8) != 0 )
  {
    v49 = (unsigned __int16)word_805F84;
    *(_WORD *)(dev + 21571) = word_805F84;
    set_frequency(v49);
    sprintf((char *)(dev + 21573), "%u", *(unsigned __int16 *)(dev + 21571));
  }
  cgsleep_ms();
  v21 = (unsigned __int8)opt_debug;
  v22 = dev;
  v23 = (unsigned __int8)byte_805F82;
  v24 = ((unsigned __int8)byte_805F7C >> 1) & 1;
  *(_BYTE *)(dev + 21569) = (byte_805F7C & 2) != 0;
  *(_BYTE *)(v22 + 21570) = v23;
  if ( v21 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "%s: fan_eft : %d  fan_pwm : %d\n", "bitmain_reinit_test", (unsigned __int8)v24, v23);
    applog(7, s, 0);
  }
  if ( (byte_805F7C & 2) != 0 && (unsigned __int8)byte_805F82 <= 100u )
    set_PWM((unsigned __int8)byte_805F82);
  else
    set_PWM_according_to_temperature();
  if ( (byte_805F7C & 4) != 0 )
  {
    if ( word_805F8A )
    {
      v25 = dev;
      v26 = HIBYTE(word_805F8A) + 1000 * (unsigned __int8)word_805F8A;
      *(_DWORD *)(dev + 72) = v26;
    }
    else
    {
      v54 = calculate_core_number(*(unsigned __int8 *)(dev + 21548));
      v25 = dev;
      v55 = (unsigned __int8)opt_debug;
      v26 = 90 * (*(unsigned __int8 *)(dev + 21549) * (16777216 / v54) / *(unsigned __int16 *)(dev + 21571)) / 100;
      *(_DWORD *)(dev + 72) = v26;
      if ( v55 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(s, 2048u, "dev->timeout = %d\n", v26);
        applog(7, s, 0);
        v25 = dev;
        v26 = *(_DWORD *)(dev + 72);
      }
    }
    if ( v26 > 131071 )
      *(_DWORD *)(v25 + 72) = 131071;
  }
  init_uart_baud();
  v27 = 0;
  cgsleep_ms();
  v28 = dev;
  do
  {
    while ( *(_DWORD *)(v28 + 4 * (v27 + 2)) != 1 || *(_BYTE *)(v28 + v27 + 21484) != 84 )
    {
      if ( ++v27 == 16 )
        goto LABEL_61;
    }
    calibration_sensor_offset(152, v27++);
    cgsleep_ms();
    v28 = dev;
  }
  while ( v27 != 16 );
LABEL_61:
  set_time_out_control((*(_DWORD *)(v28 + 72) / 10u) & 0x1FFFF | 0x80000000);
  v29 = dev;
  *(_BYTE *)(dev + 21500) = 100;
  *(_DWORD *)(v29 + 4) = 3276800;
  set_fan_control(3276800);
  v30 = (unsigned __int8)opt_fixed_freq;
  v31 = dev;
  if ( !opt_fixed_freq )
  {
    v32 = chain_voltage_pic;
    while ( 2 )
    {
      if ( !*(_DWORD *)(v31 + 4 * (v30 + 2)) )
        goto LABEL_75;
      v33 = v31 + 4;
      v34 = 0;
      do
      {
        v35 = *(_DWORD *)(v33 + 4);
        v33 += 4;
        if ( v35 == 1 )
          ++v34;
      }
      while ( v31 + 68 != v33 );
      if ( v34 <= 3 )
        goto LABEL_75;
      v36 = 10 * ((int)((364.0704 / ((double)(unsigned __int8)*v32 + 30.72) + 32.79) * 100.0 / 4.75) / 10);
      if ( ENABLE_LIMIT_ON_SINGLE_BOARD )
      {
        GetRealBoardRate(v30);
        if ( (unsigned int)log_level <= 3 )
          goto LABEL_73;
        v43 = fopen(log_file, "a+");
        if ( v43 )
        {
          RealBoardRate = GetRealBoardRate(v30);
          fprintf(
            v43,
            "%s:%d:%s: single board rate=%d voltage limit=%d on chain[%d]\n",
            "driver-btm-c5.c",
            7482,
            "bitmain_reinit_test",
            RealBoardRate,
            930,
            v30);
        }
      }
      else
      {
        if ( opt_economic_mode )
          GetTotalRate_part_12();
        if ( (unsigned int)log_level <= 3 )
        {
LABEL_73:
          if ( v36 > 930 )
          {
            if ( (unsigned int)log_level > 3 )
            {
              v50 = fopen(log_file, "a+");
              v51 = v50;
              if ( v50 )
                fprintf(
                  v50,
                  "%s:%d:%s: will set the voltage limited on chain[%d], change voltage=%d\n",
                  "driver-btm-c5.c",
                  7541,
                  "bitmain_reinit_test",
                  v30,
                  930);
              fclose(v51);
              if ( (unsigned int)log_level > 3 )
              {
                v52 = fopen(log_file, "a+");
                v53 = v52;
                if ( v52 )
                  fprintf(
                    v52,
                    "%s:%d:%s: now set pic voltage=%d on chain[%d]\n",
                    "driver-btm-c5.c",
                    7544,
                    "bitmain_reinit_test",
                    1,
                    v30);
                fclose(v53);
              }
            }
            v31 = dev;
            *v32 = 1;
          }
          else
          {
            v31 = dev;
          }
LABEL_75:
          ++v30;
          ++v32;
          if ( v30 == 16 )
            goto LABEL_76;
          continue;
        }
        v43 = fopen(log_file, "a+");
        if ( v43 )
        {
          if ( opt_economic_mode )
            TotalRate_part_12 = GetTotalRate_part_12();
          else
            TotalRate_part_12 = ideal_total_hash_rate;
          fprintf(
            v43,
            "%s:%d:%s: miner rate=%d voltage limit=%d on chain[%d]\n",
            "driver-btm-c5.c",
            7488,
            "bitmain_reinit_test",
            TotalRate_part_12,
            930,
            v30);
        }
      }
      break;
    }
    fclose(v43);
    if ( (unsigned int)log_level > 3 )
    {
      v46 = fopen(log_file, "a+");
      v47 = v46;
      if ( v46 )
        fprintf(
          v46,
          "%s:%d:%s: get PIC voltage=%d on chain[%d], check: must be < %d\n",
          "driver-btm-c5.c",
          7518,
          "bitmain_reinit_test",
          v36,
          v30,
          930);
      fclose(v47);
    }
    goto LABEL_73;
  }
LABEL_76:
  v37 = 1;
  v38 = v31;
  v39 = chain_voltage_pic;
  while ( 2 )
  {
    result = v39 - chain_voltage_pic;
    if ( *(_DWORD *)(v38 + 4 * (v39 - chain_voltage_pic + 2)) != 1
      || (open_core_one_chain(result, 1),
          sleep(1u),
          pthread_mutex_lock(&iic_mutex),
          result = pthread_mutex_unlock(&iic_mutex),
          (unsigned int)log_level <= 3) )
    {
      ++v39;
      ++v37;
      if ( &de_voltage == v39 )
        return result;
      goto LABEL_78;
    }
    v41 = fopen(log_file, "a+");
    v42 = v41;
    if ( v41 )
      fprintf(
        v41,
        "%s:%d:%s: Chain[J%d] set working voltage=%d [%d]\n",
        "driver-btm-c5.c",
        7661,
        "bitmain_reinit_test",
        v37,
        10 * ((int)((364.0704 / ((double)(unsigned __int8)*v39 + 30.72) + 32.79) * 100.0 / 4.75) / 10),
        (unsigned __int8)*v39);
    ++v39;
    result = fclose(v42);
    ++v37;
    if ( &de_voltage != v39 )
    {
LABEL_78:
      v38 = dev;
      continue;
    }
    return result;
  }
}
// 7DF98: using guessed type int opt_multi_version;
// 7E578: using guessed type char de_voltage;
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 709398: using guessed type char opt_fixed_freq;
// 70943E: using guessed type char opt_economic_mode;
// 709440: using guessed type int ideal_total_hash_rate;
// 805F7C: using guessed type char byte_805F7C;
// 805F82: using guessed type char byte_805F82;
// 805F84: using guessed type __int16 word_805F84;
// 805F8A: using guessed type __int16 word_805F8A;
// 805FA4: using guessed type int chain_voltage_value;
// 805FE4: using guessed type char ENABLE_LIMIT_ON_SINGLE_BOARD;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80B808: using guessed type int job_start_address_1;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (00037664) --------------------------------------------------------
int __fastcall open_core_onChain(int a1, int a2, unsigned int a3, char a4)
{
  unsigned int v4; // r5
  int v9; // r0
  int v10; // r7
  int v11; // r5
  int v12; // r5
  int v13; // r0
  int v14; // r0
  int dhash_acc_control; // r0
  int v17; // r6
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r4
  int v22; // r5
  char v23; // r8
  int v24; // r3
  unsigned int *v25; // r0
  int *v26; // r12
  int i; // lr
  int v28; // r0
  int v29; // r4
  int v30; // r0
  int v31; // r6
  char *v32; // r3
  int v33; // r8
  char v34; // r7
  int v35; // r4
  char v36; // r3
  int v37; // r1
  char *v38; // r4
  int *v39; // lr
  int v40; // r2
  int *v41; // r3
  int v42; // r3
  int v43; // r0
  FILE *v44; // r0
  FILE *v45; // r4
  int v46; // r0
  int v47; // r0
  int v48; // [sp+14h] [bp-8ECh]
  int v49; // [sp+14h] [bp-8ECh]
  int v50; // [sp+14h] [bp-8ECh]
  int v51; // [sp+18h] [bp-8E8h]
  char *v52; // [sp+1Ch] [bp-8E4h]
  unsigned int v53; // [sp+20h] [bp-8E0h] BYREF
  int v54; // [sp+24h] [bp-8DCh] BYREF
  int v55; // [sp+28h] [bp-8D8h]
  char v56; // [sp+2Ch] [bp-8D4h]
  unsigned int v57; // [sp+30h] [bp-8D0h] BYREF
  int v58; // [sp+34h] [bp-8CCh]
  int v59; // [sp+38h] [bp-8C8h]
  int s[13]; // [sp+3Ch] [bp-8C4h] BYREF
  int v61[13]; // [sp+70h] [bp-890h] BYREF
  char v62[52]; // [sp+A4h] [bp-85Ch] BYREF
  char v63[2088]; // [sp+D8h] [bp-828h] BYREF

  v4 = 0;
  v53 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  memset(s, 0, sizeof(s));
  memset(v61, 0, sizeof(v61));
  memset(v62, 0, sizeof(v62));
  v62[0] = -1;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF7FDF | ((opt_multi_version & 0xF) << 8) | 0x8000);
    set_hash_counting_number(0);
    LOWORD(v55) = 8256;
    v54 = 469764440;
    v17 = *(_BYTE *)(dev + 21551) & 0x1F | 0x80;
    v48 = dev;
    BYTE2(v55) = *(_BYTE *)(dev + 21551) & 0x1F | 0x80;
    HIBYTE(v55) = -128;
    v18 = CRC5(&v54, 64u);
    v56 = v18;
    memset(v61, 0, 13);
    v59 = v18 << 24;
    v58 = (v17 << 8) | 0x40200080;
    v57 = 1476984860;
    memset(v63, 255, 52u);
    if ( *(_DWORD *)(v48 + 4 * (a1 + 2)) == 1 )
    {
      v28 = get_BC_write_command();
      set_BC_write_command(v28 & 0xFF30FFFF | (a1 << 16) & 0xFF3FFFFF | 0x800000);
      cgsleep_us();
      v63[8] = -1;
      v63[19] = -1;
      v63[1] = a1 | 0x80;
      v29 = (unsigned __int8)a1 | 0x80;
      v63[0] = 1;
      v63[2] = 0;
      v63[3] = 0;
      *(_DWORD *)&v63[4] = 0;
      set_BC_command_buffer(&v57);
      v30 = get_BC_write_command();
      set_BC_write_command(v30 & 0xFFF0FFFF | (a1 << 16) | 0x80800000);
      cgsleep_us();
      if ( a2 )
      {
        v31 = 1 << a1;
        v32 = (char *)&bitmain_c5_drv + 16 * a1;
        v50 = a1;
        v33 = v29 << 16;
        v34 = v29;
        v52 = v32;
LABEL_30:
        v35 = 3001;
        if ( v4 < a3 )
          v36 = -1;
        else
          v36 = 0;
        v63[8] = v36;
        v63[19] = v36;
        do
        {
          if ( (get_buffer_space() & v31) != 0 )
          {
            if ( v4 )
            {
              v37 = 16777216;
              v63[0] = 1;
            }
            else
            {
              v37 = 285212672;
              v63[0] = 17;
            }
            v38 = v63;
            v39 = &v61[1];
            v63[1] = v34;
            v61[1] = *(_DWORD *)&v63[4];
            v61[0] = (unsigned __int8)v63[3] | ((unsigned __int8)v63[2] << 8) | v33 | v37;
            do
            {
              v40 = (unsigned __int8)v38[9];
              v38 += 4;
              v39[1] = (unsigned __int8)v38[7] | (v40 << 16) | ((unsigned __int8)v38[4] << 24) | ((unsigned __int8)v38[6] << 8);
              ++v39;
            }
            while ( &v63[12] != v38 );
            v41 = &v61[4];
            do
            {
              v41[1] = 0;
              ++v41;
            }
            while ( v41 != &v61[12] );
            set_TW_write_command_vil(v61);
            if ( a2 - 1 == v4 )
              v42 = a4 & 1;
            else
              v42 = 0;
            if ( v42 && (v52[120] != 44 || v52[121] != 101 || !chainHasDisabledCore_part_5(v50)) )
            {
              v43 = get_BC_write_command();
              set_BC_write_command(v43 | 0x400000);
            }
            if ( a2 == ++v4 )
            {
              a1 = v50;
              goto LABEL_50;
            }
            goto LABEL_30;
          }
          cgsleep_us();
          --v35;
        }
        while ( v35 );
        a1 = v50;
        if ( (unsigned int)log_level > 3 )
        {
          v44 = fopen(log_file, "a+");
          v45 = v44;
          if ( v44 )
            fprintf(
              v44,
              "%s:%d:%s: Error: send open core work Failed on Chain[%d]!\n",
              "driver-btm-c5.c",
              11484,
              "open_core_onChain",
              v50);
          fclose(v45);
        }
      }
LABEL_50:
      close_bad_core(a1, a4);
    }
    v19 = get_dhash_acc_control();
    return set_dhash_acc_control(v19 | ((opt_multi_version & 0xF) << 8) | 0x8000);
  }
  else
  {
    v9 = get_dhash_acc_control();
    set_dhash_acc_control(v9 & 0xFFFFFFDF);
    set_hash_counting_number(0);
    v10 = dev;
    LOWORD(v53) = 134;
    v11 = *(unsigned __int8 *)(dev + 21551);
    HIBYTE(v53) = -128;
    v12 = v11 | 0x80;
    BYTE2(v53) = v12;
    v13 = CRC5(&v53, 27u) & 0x1F | 0x80;
    HIBYTE(v53) = v13;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        v63,
        2048u,
        "%s: gateblk[0]=0x%x, gateblk[1]=0x%x, gateblk[2]=0x%x, gateblk[3]=0x%x\n",
        "open_core_onChain",
        134,
        0,
        v12,
        v13);
      applog(7, v63, 0);
      v10 = dev;
    }
    v57 = bswap32(v53);
    memset(v62, 0, sizeof(v62));
    v62[51] = -1;
    v62[40] = -1;
    if ( *(_DWORD *)(v10 + 4 * (a1 + 2)) == 1 )
    {
      set_BC_command_buffer(&v57);
      v20 = get_BC_write_command();
      set_BC_write_command(v20 & 0xFFF0FFFF | (a1 << 16) | 0x80800000);
      cgsleep_us();
      if ( a2 )
      {
        v21 = 1 << a1;
        v49 = 0;
        v22 = 0;
        v51 = ((a1 & 0xF) << 16) | 0xC00000;
        v23 = a1 | 0x80;
        do
        {
          while ( (get_buffer_space() & v21) == 0 )
            cgsleep_us();
          if ( v22 )
          {
            v62[0] = 1;
            v62[1] = v23;
          }
          else
          {
            v62[1] = v23;
            v62[0] = 17;
            v46 = get_BC_write_command();
            set_BC_write_command(v46 & 0xFFBFFFFF);
          }
          if ( v22 == a2 - 1 )
            v24 = a4 & 1;
          else
            v24 = 0;
          if ( v24 )
          {
            v47 = get_BC_write_command();
            set_BC_write_command(v47 & v51);
          }
          v25 = (unsigned int *)v62;
          memset(s, 0, 13);
          v26 = s;
          for ( i = 1; ; ++i )
          {
            *v26++ = _byteswap_ulong(*v25);
            if ( i != 10 )
              break;
            s[9] = v49++;
LABEL_23:
            ++v25;
          }
          if ( i != 13 )
            goto LABEL_23;
          ++v22;
          set_TW_write_command((int)s);
        }
        while ( a2 != v22 );
      }
    }
    v14 = get_dhash_acc_control();
    return set_dhash_acc_control(v14 | 0x20);
  }
}
// 7DF98: using guessed type int opt_multi_version;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (00037B68) --------------------------------------------------------
int __fastcall opencore_onebyone_onChain(int a1)
{
  int v2; // r4
  int result; // r0

  v2 = 0;
  do
  {
    open_core_onChain(a1, 114, ++v2, 1);
    result = usleep((__useconds_t)&loc_1869E + 2);
  }
  while ( v2 != 114 );
  return result;
}

//----- (00037B90) --------------------------------------------------------
int __fastcall insert_reg_data(int a1)
{
  int v3; // r3
  int v4; // r3

  if ( (unsigned int)dword_81674C > 510 || reg_value_buf[0] > 510u )
    return clear_register_value_buf();
  pthread_mutex_lock(&reg_mutex);
  reg_value_buf[2 * reg_value_buf[0] + 3] = *(_DWORD *)(a1 + 4);
  LOBYTE(reg_value_buf[2 * reg_value_buf[0] + 4]) = *(_BYTE *)(a1 + 3) & 0x1F;
  BYTE1(reg_value_buf[2 * reg_value_buf[0] + 4]) = *(_BYTE *)a1 & 0xF;
  if ( reg_value_buf[0] >= 510u )
    v3 = 0;
  else
    v3 = reg_value_buf[0];
  if ( reg_value_buf[0] < 510u )
    ++v3;
  reg_value_buf[0] = v3;
  if ( (unsigned int)dword_81674C > 510 )
    v4 = 511;
  else
    v4 = dword_81674C;
  if ( (unsigned int)dword_81674C <= 510 )
    ++v4;
  dword_81674C = v4;
  return j_pthread_mutex_unlock(&reg_mutex);
}
// 816744: using guessed type int reg_value_buf[];
// 81674C: using guessed type int dword_81674C;

//----- (00037C18) --------------------------------------------------------
int __fastcall getChainAsicNum(int a1)
{
  return *(unsigned __int8 *)(a1 + dev + 21484);
}
// 817C28: using guessed type int dev;

//----- (00037C2C) --------------------------------------------------------
int __fastcall getChainExistFlag(int a1)
{
  return *(_DWORD *)(dev + 4 * (a1 + 2));
}
// 817C28: using guessed type int dev;

//----- (00037C40) --------------------------------------------------------
int __fastcall saveSearchFailedFlagInfo(const char *a1)
{
  FILE *v2; // r0
  FILE *v3; // r4
  size_t v4; // r0

  v2 = fopen("/tmp/searcherror", "wb");
  if ( v2 )
  {
    v3 = v2;
    v4 = strlen(a1);
    fwrite(a1, 1u, v4 + 1, v3);
    fclose(v3);
  }
  system("cp /tmp/search /tmp/err1.log -f");
  system("cp /tmp/freq /tmp/err2.log -f");
  system("cp /tmp/lasttemp /tmp/err3.log -f");
  return j_system("sync");
}

//----- (00037CA8) --------------------------------------------------------
int ClearWorkFIFOAndResetRegisters()
{
  int dhash_acc_control; // r0

  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control | 0x80);
  cgsleep_ms();
  set_asic_ticket_mask(0);
  set_hcnt(0);
  return set_sno(0);
}

//----- (00037CD4) --------------------------------------------------------
int is_S9()
{
  return 0;
}

//----- (00037CD8) --------------------------------------------------------
int is_S9_plus()
{
  return 1;
}

//----- (00037CDC) --------------------------------------------------------
int is_T9_plus()
{
  return 0;
}

//----- (00037CE0) --------------------------------------------------------
int is_T9()
{
  return 0;
}

//----- (00037CE4) --------------------------------------------------------
int is_S9i()
{
  return 0;
}

//----- (00037CE8) --------------------------------------------------------
int is_R4()
{
  return 0;
}

//----- (00037CEC) --------------------------------------------------------
int is_S9_Hydro()
{
  return 0;
}

//----- (00037CF0) --------------------------------------------------------
int is_S11()
{
  return 1;
}

//----- (00037CF4) --------------------------------------------------------
int bitmain_axi_init()
{
  int v0; // r0
  int v1; // r4
  FILE *v2; // r0
  FILE *v3; // r5
  _DWORD *v5; // r0
  _BYTE *v6; // r3
  int v7; // [sp+Ch] [bp-814h] BYREF
  char v8[2064]; // [sp+10h] [bp-810h] BYREF

  v0 = znyq7010_axi_init(&v7);
  if ( v0 )
  {
    v1 = v0;
    if ( (unsigned int)log_level > 1 )
    {
      v2 = fopen(log_file, "a+");
      v3 = v2;
      if ( v2 )
        fprintf(v2, "%s:%d:%s: znyq7010_axi_init failed.\n", "driver-btm-c5.c", 11980, "bitmain_axi_init");
      fclose(v3);
      return v1;
    }
    return v1;
  }
  v5 = calloc(21616u, 1u);
  dev = (int)v5;
  LOWORD(v6) = (unsigned __int16)&opt_debug;
  if ( v5 )
  {
    HIWORD(v6) = (unsigned int)&opt_debug >> 16;
    v1 = (unsigned __int8)*v6;
    *v5 = v7;
    if ( v1 )
    {
      if ( use_syslog || (v1 = (unsigned __int8)opt_log_output, opt_log_output) || opt_log_level > 6 )
      {
        strcpy(v8, "kmalloc for dev success.\n");
        applog(7, v8, 0);
        return 0;
      }
    }
    return v1;
  }
  HIWORD(v6) = (unsigned int)&opt_debug >> 16;
  if ( !*v6 || !use_syslog && !opt_log_output && opt_log_level <= 6 )
    return -1;
  strcpy(v8, "kmalloc for dev failed.\n");
  applog(7, v8, 0);
  return -1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (00037E30) --------------------------------------------------------
int check_config_file()
{
  int result; // r0
  FILE *v1; // r0
  FILE *v2; // r4
  time_t timer; // [sp+Ch] [bp-6Ch] BYREF
  struct stat stat_buf; // [sp+10h] [bp-68h] BYREF

  time(&timer);
  result = _xstat(3, "/etc/config/pcbtemp", &stat_buf);
  if ( timer - stat_buf.st_mtim.tv_sec > 600 )
  {
    result = system("rm -rf /etc/config/pcbtemp");
    if ( (unsigned int)log_level > 3 )
    {
      v1 = fopen(log_file, "a+");
      v2 = v1;
      if ( v1 )
        fprintf(
          v1,
          "%s:%d:%s: /etc/config/pcbtemp is too old, deleted\n",
          "driver-btm-c5.c",
          12010,
          "check_config_file");
      return fclose(v2);
    }
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00037EB8) --------------------------------------------------------
int __fastcall slowly_downgrade_voltage(int a1, int a2)
{
  int v4; // r4
  int result; // r0
  int v6; // r4
  int i; // r4
  FILE *v8; // r0
  FILE *v9; // r11
  FILE *v10; // r0
  FILE *v11; // r4
  FILE *v12; // r0
  FILE *v13; // r0
  FILE *v14; // r9
  FILE *v15; // r0
  FILE *v16; // r8

  v4 = (int)((364.0704 / ((double)write_EEPROM_iic(1, 1, 144, a1, 0) + 30.72) + 32.79) * 100.0 / 4.75);
  result = 1717986919 * v4;
  v6 = 10 * (v4 / 10);
  if ( (unsigned int)log_level > 3 )
  {
    v13 = fopen(log_file, "a+");
    v14 = v13;
    if ( v13 )
      fprintf(
        v13,
        "%s:%d:%s: chain[%d] current_voltage_value = %d\n",
        "driver-btm-c5.c",
        12021,
        "slowly_downgrade_voltage",
        a1,
        v6);
    result = fclose(v14);
    if ( (unsigned int)log_level > 3 )
    {
      v15 = fopen(log_file, "a+");
      v16 = v15;
      if ( v15 )
        fprintf(
          v15,
          "%s:%d:%s: chain[%d] target_voltage_value = %d\n",
          "driver-btm-c5.c",
          12022,
          "slowly_downgrade_voltage",
          a1,
          a2);
      result = fclose(v16);
    }
  }
  if ( (unsigned int)(a2 - 500) > 700 )
  {
    if ( (unsigned int)log_level > 1 )
    {
      v12 = fopen(log_file, "a+");
      v11 = v12;
      if ( v12 )
        fprintf(v12, "%s:%d:%s: target voltage invalid\n", "driver-btm-c5.c", 12026, "slowly_downgrade_voltage");
      return j_fclose(v11);
    }
  }
  else
  {
    for ( i = v6 - 10; a2 <= i; result = sleep(3u) )
    {
      while ( 1 )
      {
        pthread_mutex_lock(&iic_mutex);
        pthread_mutex_unlock(&iic_mutex);
        if ( (unsigned int)log_level > 3 )
          break;
        i -= 10;
        result = sleep(3u);
        if ( a2 > i )
          goto LABEL_10;
      }
      v8 = fopen(log_file, "a+");
      v9 = v8;
      if ( v8 )
        fprintf(
          v8,
          "%s:%d:%s: chain[%d] set voltage to %d\n",
          "driver-btm-c5.c",
          12039,
          "slowly_downgrade_voltage",
          a1,
          i);
      i -= 10;
      fclose(v9);
    }
LABEL_10:
    if ( (unsigned int)log_level > 1 )
    {
      v10 = fopen(log_file, "a+");
      v11 = v10;
      if ( v10 )
      {
        fprintf(
          v10,
          "%s:%d:%s: chain[%d] set working voltage to %d\n",
          "driver-btm-c5.c",
          12049,
          "slowly_downgrade_voltage",
          a1,
          a2);
        return j_fclose(v11);
      }
      return j_fclose(v11);
    }
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00038108) --------------------------------------------------------
int __fastcall slowly_downgrade_voltage_all_chain(int result)
{
  int v1; // r11
  int v2; // r4
  unsigned __int8 *v3; // r5
  int v4; // s13
  int v5; // r0
  __int64 v6; // r2
  int v7; // r8
  int v8; // r9
  int v9; // r8
  FILE *v10; // r0
  FILE *v11; // r9
  FILE *v12; // r0
  FILE *v13; // r0
  FILE *v14; // r10
  FILE *v15; // r0
  FILE *v16; // r4
  FILE *v17; // r0
  FILE *v18; // r8
  FILE *stream; // [sp+10h] [bp-58h]
  unsigned __int8 *v20; // [sp+14h] [bp-54h]

  v20 = (unsigned __int8 *)result;
LABEL_2:
  v1 = 0;
  v2 = 0;
  v3 = v20;
  while ( 1 )
  {
    while ( *(_DWORD *)(dev + 4 * (v2 + 2)) != 1 )
    {
LABEL_3:
      ++v2;
      ++v3;
      if ( v2 == 16 )
        goto LABEL_14;
    }
    if ( (unsigned int)log_level > 5 )
    {
      v17 = fopen(log_file, "a+");
      v18 = v17;
      if ( v17 )
        fprintf(
          v17,
          "%s:%d:%s: vol_list[%d] = %d\n",
          "driver-btm-c5.c",
          12072,
          "slowly_downgrade_voltage_all_chain",
          v2,
          *v3);
      fclose(v18);
    }
    v4 = (int)((364.0704 / ((double)write_EEPROM_iic(1, 1, 144, v2, 0) + 30.72) + 32.79) * 100.0 / 4.75);
    v5 = (int)((364.0704 / ((double)*v3 + 30.72) + 32.79) * 100.0 / 4.75);
    v6 = 1717986919LL * v5;
    result = v5 >> 31;
    v7 = 10 * (v4 / 10);
    v8 = 10 * ((SHIDWORD(v6) >> 2) - result);
    if ( (unsigned int)log_level > 5 )
    {
      v12 = fopen(log_file, "a+");
      stream = v12;
      if ( v12 )
        fprintf(
          v12,
          "%s:%d:%s: chain[%d] current_voltage_value = %d\n",
          "driver-btm-c5.c",
          12077,
          "slowly_downgrade_voltage_all_chain",
          v2,
          v7);
      result = fclose(stream);
      if ( (unsigned int)log_level > 5 )
        break;
    }
    if ( (unsigned int)(v8 - 500) > 700 )
      goto LABEL_22;
LABEL_8:
    v9 = v7 - 10;
    if ( v9 < v8 )
      goto LABEL_3;
    pthread_mutex_lock(&iic_mutex);
    result = pthread_mutex_unlock(&iic_mutex);
    if ( (unsigned int)log_level <= 3 )
    {
      v1 = 1;
      goto LABEL_3;
    }
    v10 = fopen(log_file, "a+");
    v11 = v10;
    if ( v10 )
      fprintf(
        v10,
        "%s:%d:%s: chain[%d] set voltage to %d\n",
        "driver-btm-c5.c",
        12093,
        "slowly_downgrade_voltage_all_chain",
        v2,
        v9);
    ++v2;
    result = fclose(v11);
    v1 = 1;
    ++v3;
    if ( v2 == 16 )
    {
LABEL_14:
      if ( !v1 )
        return result;
      result = sleep(3u);
      goto LABEL_2;
    }
  }
  v13 = fopen(log_file, "a+");
  v14 = v13;
  if ( v13 )
    fprintf(
      v13,
      "%s:%d:%s: chain[%d] target_voltage_value = %d\n",
      "driver-btm-c5.c",
      12078,
      "slowly_downgrade_voltage_all_chain",
      v2,
      v8);
  result = fclose(v14);
  if ( (unsigned int)(v8 - 500) <= 700 )
    goto LABEL_8;
LABEL_22:
  if ( (unsigned int)log_level > 1 )
  {
    v15 = fopen(log_file, "a+");
    v16 = v15;
    if ( v15 )
      fprintf(v15, "%s:%d:%s: target voltage invalid\n", "driver-btm-c5.c", 12082, "slowly_downgrade_voltage_all_chain");
    return j_fclose(v16);
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 817C28: using guessed type int dev;

//----- (000383D8) --------------------------------------------------------
int set_working_voltage()
{
  FILE *v1; // r0
  FILE *v2; // r4

  if ( (unsigned int)log_level > 3 )
  {
    v1 = fopen(log_file, "a+");
    v2 = v1;
    if ( v1 )
      fprintf(v1, "%s:%d:%s: setting to working voltage...\n", "driver-btm-c5.c", 12113, "set_working_voltage");
    fclose(v2);
  }
  return set_iic_power_to_working_voltage();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00038438) --------------------------------------------------------
int set_higher_voltage()
{
  int result; // r0

  if ( !opt_fixed_freq )
    return set_iic_power_to_higher_voltage();
  return result;
}
// 709398: using guessed type char opt_fixed_freq;

//----- (0003844C) --------------------------------------------------------
int init_exist_chain_table()
{
  int v0; // r2
  int v1; // r5
  int result; // r0
  int v3; // r4
  int v4; // t1
  char *v5; // r2
  int v6; // r3
  int v7; // t1
  FILE *v8; // r0
  FILE *v9; // r4

  v0 = 0;
  v1 = total_exist_chain_num;
  result = 0;
  v3 = dev + 4;
  do
  {
    v4 = *(_DWORD *)(v3 + 4);
    v3 += 4;
    if ( v4 )
    {
      v5 = &ENABLE_LIMIT_ON_SINGLE_BOARD;
      v6 = 0;
      while ( 1 )
      {
        v7 = *((_DWORD *)v5 + 1);
        v5 += 4;
        if ( !v7 )
          break;
        if ( ++v6 == 16 )
          goto LABEL_6;
      }
      *((_DWORD *)&unk_805520 + v6 + 690) = result;
LABEL_6:
      ++v1;
      v0 = 1;
    }
    ++result;
  }
  while ( result != 16 );
  if ( v0 )
    total_exist_chain_num = v1;
  if ( (unsigned int)log_level > 3 )
  {
    v8 = fopen(log_file, "a+");
    v9 = v8;
    if ( v8 )
      fprintf(
        v8,
        "%s:%d:%s: total_exist_chain_num = %d\n",
        "driver-btm-c5.c",
        12205,
        "init_exist_chain_table",
        total_exist_chain_num);
    return j_fclose(v9);
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805F98: using guessed type int total_exist_chain_num;
// 805FE4: using guessed type char ENABLE_LIMIT_ON_SINGLE_BOARD;
// 817C28: using guessed type int dev;

//----- (00038500) --------------------------------------------------------
int __fastcall bitmain_c5_init(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int *v8; // r4
  FILE *RestartNum; // r9
  int v10; // r0
  int v11; // r8
  FILE *v13; // r0
  FILE *v14; // r8
  FILE *v15; // r0
  FILE *v16; // r8
  FILE *v17; // r0
  FILE *v18; // r5
  char *v19; // r1
  int v20; // r2
  int v21; // r0
  int i; // r3
  int v23; // t1
  char *v24; // r3
  int v25; // r3
  FILE *v26; // r0
  FILE *v27; // r5
  FILE *v28; // r0
  FILE *v29; // r0
  FILE *v30; // r0
  FILE *v31; // r5
  FILE *v32; // r0
  unsigned int hardware_version; // r0
  unsigned __int8 v34; // lr^1
  int v35; // r2
  int v36; // r0
  int v37; // lr
  int v38; // r0
  int v39; // r2
  int v40; // r4
  int v41; // lr
  int v42; // r2
  int v43; // r3
  int v44; // lr
  int v45; // r2
  int v46; // r10
  _BOOL4 v47; // r3
  FILE *v48; // r0
  FILE *v49; // r8
  int v50; // r2
  int v51; // r10
  int v52; // lr
  int v53; // r1
  int v54; // r2
  int v55; // r0
  int v56; // r6
  int v57; // r3
  int v58; // r9
  int v59; // r3
  FILE *v60; // r0
  int v61; // r5
  int *v62; // r7
  char *v63; // r8
  unsigned __int8 *v64; // r9
  unsigned int v65; // r3
  unsigned __int8 *v66; // r10
  FILE *v67; // r0
  FILE *v68; // r3
  bool v69; // cc
  int v70; // r8
  int v71; // r9
  unsigned __int8 *v72; // r10
  int v73; // r6
  int *v74; // r5
  int v75; // s15
  FILE *v76; // r0
  FILE *v77; // r9
  FILE *v78; // r0
  FILE *v79; // r10
  FILE *v80; // r0
  FILE *v81; // r8
  FILE *v82; // r0
  FILE *v83; // r8
  int v84; // r3
  int dhash_acc_control; // r0
  int v86; // r9
  int v87; // r3
  int v88; // r2
  int v89; // r5
  FILE *v90; // r0
  FILE *v91; // r8
  FILE *v92; // r0
  FILE *v93; // r5
  int v94; // r0
  int v95; // r2
  int v96; // r1
  int v97; // r0
  int v98; // r3
  int v99; // r8
  int v100; // r3
  int v101; // r3
  int k; // r8
  FILE *v103; // r0
  int v104; // r3
  int *v105; // r9
  int v106; // r4
  int v107; // r1
  int v108; // r2
  int v109; // t1
  int v110; // r6
  FILE *v111; // r10
  int RealBoardRate; // r0
  FILE *v113; // r0
  FILE *v114; // r8
  int v115; // r10
  int v116; // r3
  int v117; // r8
  int v118; // r5
  int v119; // r4
  unsigned __int8 v120; // r9
  int v121; // r1
  int v122; // r7
  int v123; // r1
  int v124; // r10
  int v125; // t1
  int v126; // r4
  int v127; // r3
  int v128; // r11
  int v129; // r0
  int v130; // r6
  int v131; // lr
  int v132; // r2
  int v133; // lr
  int v134; // r2
  int TotalRate_part_12; // r0
  FILE *v136; // r0
  FILE *v137; // r10
  FILE *v138; // r0
  FILE *v139; // r8
  FILE *v140; // r0
  FILE *v141; // r4
  int v142; // r3
  unsigned __int8 *v143; // r10
  int v144; // r9
  int *v145; // r8
  FILE *v146; // r0
  int v147; // r8
  unsigned int v148; // r3
  FILE *v149; // r0
  FILE *v150; // r8
  FILE *v151; // r0
  FILE *v152; // r0
  FILE *v153; // r0
  FILE *v154; // r10
  FILE *v155; // r0
  FILE *v156; // r10
  int v157; // r1
  int v158; // r10
  char *v159; // r4
  char *v160; // r1
  char v161; // r3
  FILE *v162; // r0
  FILE *v163; // r8
  int j; // [sp+1Ch] [bp-8CCh]
  int v165; // [sp+1Ch] [bp-8CCh]
  FILE *stream; // [sp+20h] [bp-8C8h]
  FILE *streama; // [sp+20h] [bp-8C8h]
  int format; // [sp+24h] [bp-8C4h]
  char *formata; // [sp+24h] [bp-8C4h]
  char *formatb; // [sp+24h] [bp-8C4h]
  char *formatc; // [sp+24h] [bp-8C4h]
  char *formatd; // [sp+24h] [bp-8C4h]
  FILE *v173; // [sp+28h] [bp-8C0h]
  FILE *v174; // [sp+28h] [bp-8C0h]
  FILE *v175; // [sp+28h] [bp-8C0h]
  int v176; // [sp+2Ch] [bp-8BCh]
  int v177; // [sp+2Ch] [bp-8BCh]
  int v178; // [sp+30h] [bp-8B8h]
  FILE *v179; // [sp+44h] [bp-8A4h]
  int *v180; // [sp+44h] [bp-8A4h]
  struct sysinfo v181; // [sp+48h] [bp-8A0h] BYREF
  char s[2128]; // [sp+88h] [bp-860h] BYREF
  int v183; // [sp+8D8h] [bp-10h]
  int v184; // [sp+8DCh] [bp-Ch]
  int v185; // [sp+8E0h] [bp-8h]
  int v186; // [sp+8E4h] [bp-4h]

  opt_multi_version = 1;
  v183 = a1;
  v184 = a2;
  v185 = a3;
  v186 = a4;
  v8 = &log_level;
  check_config_file();
  RestartNum = readRestartNum();
  saveRebootTestNum(0);
  clearInitLogFile();
  if ( (int)RestartNum <= 0 )
  {
    if ( (unsigned int)log_level > 3 )
    {
      v30 = fopen(log_file, "a+");
      v31 = v30;
      if ( v30 )
        fprintf(
          v30,
          "%s:%d:%s: This is the first time running after searching freq!\n",
          "driver-btm-c5.c",
          12248,
          "bitmain_c5_init");
      fclose(v31);
    }
    saveRestartNum(2);
  }
  else if ( (unsigned int)log_level > 3 )
  {
    v26 = fopen(log_file, "a+");
    v27 = v26;
    if ( v26 )
      fprintf(v26, "%s:%d:%s: This is user mode for mining\n", "driver-btm-c5.c", 12253, "bitmain_c5_init");
    fclose(v27);
  }
  v10 = isC5_Board();
  isC5_CtrlBoard = v10;
  if ( !v10 )
  {
    sysinfo(&v181);
    if ( v181.totalram > 1000000000 )
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
      if ( (unsigned int)log_level <= 3 )
        goto LABEL_5;
      v29 = fopen(log_file, "a+");
      v14 = v29;
      if ( v29 )
        fprintf(v29, "%s:%d:%s: Detect 1GB control board of XILINX\n", "driver-btm-c5.c", 12296, "bitmain_c5_init");
    }
    else if ( v181.totalram <= 500000000 )
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 251658240;
      if ( (unsigned int)log_level <= 3 )
        goto LABEL_5;
      v32 = fopen(log_file, "a+");
      v14 = v32;
      if ( v32 )
        fprintf(v32, "%s:%d:%s: Detect 256MB control board of XILINX\n", "driver-btm-c5.c", 12308, "bitmain_c5_init");
    }
    else
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 520093696;
      if ( (unsigned int)log_level <= 3 )
        goto LABEL_5;
      v13 = fopen(log_file, "a+");
      v14 = v13;
      if ( v13 )
        fprintf(v13, "%s:%d:%s: Detect 512MB control board of XILINX\n", "driver-btm-c5.c", 12302, "bitmain_c5_init");
    }
LABEL_18:
    fclose(v14);
    if ( (unsigned int)log_level > 3 )
    {
      v15 = fopen(log_file, "a+");
      v16 = v15;
      if ( v15 )
        fprintf(v15, "%s:%d:%s: Miner Type = S9+\n", "driver-btm-c5.c", 12327, "bitmain_c5_init");
      fclose(v16);
      if ( (unsigned int)log_level > 3 )
      {
        v17 = fopen(log_file, "a+");
        v18 = v17;
        if ( v17 )
          fprintf(
            v17,
            "%s:%d:%s: Miner compile time: %s type: %s\n",
            "driver-btm-c5.c",
            12334,
            "bitmain_c5_init",
            g_miner_compiletime,
            g_miner_type);
        fclose(v18);
      }
    }
    goto LABEL_5;
  }
  PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
  if ( (unsigned int)log_level > 3 )
  {
    v28 = fopen(log_file, "a+");
    v14 = v28;
    if ( v28 )
      fprintf(v28, "%s:%d:%s: This is C5 board.\n", "driver-btm-c5.c", 12274, "bitmain_c5_init");
    goto LABEL_18;
  }
LABEL_5:
  *(_DWORD *)&config_parameter = v183;
  *(_DWORD *)&byte_805F7C = v184;
  unk_805F80 = v185;
  *(_DWORD *)&word_805F84 = v186;
  unk_805F88 = a5;
  unk_805F8C = a6;
  unk_805F90 = a7;
  unk_805F94 = a8;
  if ( (unsigned __int8)v183 != 81 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -1;
    snprintf(
      s,
      2048u,
      "%s: config_parameter.token_type != 0x%x, it is 0x%x\n",
      "bitmain_c5_init",
      81,
      (unsigned __int8)v183);
    v11 = -1;
    applog(7, s, 0);
    return v11;
  }
  v19 = &config_parameter;
  v20 = 255;
  v21 = 255;
  for ( i = 81; ; i = v23 )
  {
    v24 = &_PRETTY_FUNCTION___14958[v20 ^ i];
    v20 = (unsigned __int8)v24[1960] ^ v21;
    v21 = (unsigned __int8)v24[2216];
    if ( &unk_805F95 == (_UNKNOWN *)v19 )
      break;
    v23 = (unsigned __int8)*++v19;
  }
  v25 = v20 | (v21 << 8);
  if ( (unsigned __int16)word_805F96 != v25 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -2;
    v11 = -2;
    snprintf(
      s,
      2048u,
      "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
      "bitmain_c5_init",
      (unsigned __int16)word_805F96,
      v25);
    applog(7, s, 0);
    return v11;
  }
  v11 = check_pool_worker();
  if ( v11 )
    return v11;
  v11 = check_pool_for_validation();
  if ( v11 )
    return v11;
  bitmain_axi_init();
  read_nonce_reg_id = (int)calloc(1u, 64u);
  v11 = thr_info_create(read_nonce_reg_id, 0, (void *(*)(void *))get_nonce_and_register, (void *)read_nonce_reg_id);
  if ( v11 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -5;
    v11 = -5;
    snprintf(s, 2048u, "%s: create thread for get nonce and register from FPGA failed\n", "bitmain_c5_init");
    applog(7, s, 0);
    return v11;
  }
  pthread_detach(*(_DWORD *)(read_nonce_reg_id + 12));
  if ( opt_fixed_freq )
  {
    if ( (unsigned int)log_level > 3 )
    {
      v78 = fopen(log_file, "a+");
      v79 = v78;
      if ( v78 )
        fprintf(
          v78,
          "%s:%d:%s: config voltage = %d, freq = %d\n",
          "driver-btm-c5.c",
          12376,
          "bitmain_c5_init",
          opt_bitmain_c5_voltage,
          (unsigned __int16)word_805F84);
      fclose(v79);
    }
    if ( opt_bitmain_c5_voltage >= 1000 )
      set_fixed_voltage();
  }
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  set_reset_allhashboard(1);
  if ( (byte_805F7C & 1) != 0 )
  {
    set_QN_write_data_command(-2139062257);
    sleep(2u);
    if ( is_certification )
    {
      v50 = dev;
      *(_BYTE *)(dev + 21500) = 20;
      *(_DWORD *)(v50 + 4) = 655400;
      set_fan_control(655400);
    }
    else
    {
      v84 = dev;
      *(_BYTE *)(dev + 21500) = 100;
      *(_DWORD *)(v84 + 4) = 3276800;
      set_fan_control(3276800);
    }
  }
  read_fpga_id(FPGA_ID_str);
  if ( (unsigned int)log_level > 3 )
  {
    v60 = fopen(log_file, "a+");
    streama = v60;
    if ( v60 )
      fprintf(v60, "%s:%d:%s: miner ID : %s\n", "driver-btm-c5.c", 12424, "bitmain_c5_init", FPGA_ID_str);
    fclose(streama);
  }
  hardware_version = get_hardware_version();
  v34 = BYTE1(hardware_version);
  v35 = (unsigned __int8)hardware_version;
  stream = (FILE *)(HIWORD(hardware_version) & 0x7FFF);
  v36 = is7007_ctrl_board;
  v37 = v34;
  fpga_version = v35;
  fpga_major_version = v37;
  pcb_version = (int)stream;
  if ( is7007_ctrl_board == -1 )
  {
    isC5_Board();
    v36 = is7007_ctrl_board;
    v35 = fpga_version;
    v37 = fpga_major_version;
    stream = (FILE *)pcb_version;
  }
  if ( v36 == 1 )
    sprintf(g_miner_version, "%d.%d.%d.%d", v35 + ((v37 - 176) << 8), stream, 1, 3);
  else
    sprintf(g_miner_version, "%d.%d.%d.%d", v35 + ((v37 - 197) << 8), stream, 1, 3);
  set_reset_allhashboard(1);
  v38 = PHY_MEM_NONCE2_JOBID_ADDRESS;
  *(_BYTE *)(dev + 21551) = 26;
  set_nonce2_and_job_id_store_address(v38);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  check_chain();
  if ( is_certification )
  {
    sleep(1u);
    v39 = dev;
    *(_DWORD *)(dev + 4) = 655400;
    v40 = 0;
    *(_BYTE *)(v39 + 21500) = 20;
    set_fan_control(655400);
    v41 = dev;
    *(_BYTE *)(dev + 21570) = 20;
    v42 = v41;
    do
    {
      if ( *(_DWORD *)(v42 + 4 * (v40 + 2)) == 1 )
      {
        pthread_mutex_lock(&iic_mutex);
        disable_pic_dac((unsigned __int8)v40);
        pthread_mutex_unlock(&iic_mutex);
        v42 = dev;
      }
      ++v40;
    }
    while ( v40 != 16 );
    v51 = 0;
    v52 = v42;
    for ( j = dev; ; v52 = j )
    {
      if ( *(_DWORD *)(v52 + 4 * (v51 + 2)) )
      {
        v53 = 0;
        v54 = 0;
        v55 = v52 + 136 * v51;
        *(_BYTE *)(v52 + v51 + 21484) = 84;
        do
        {
          v56 = v55 + v53 + v54;
          if ( (v54 & 7) == 0 )
          {
            ++v53;
            *(_BYTE *)(v56 + 19196) = 32;
          }
          v57 = (v51 << 7) + v54 + 351;
          v58 = v55 + v53 + v54++;
          v59 = v52 + 8 * v57;
          *(_BYTE *)(v58 + 19196) = 111;
          *(_DWORD *)(v59 + 4) = 0;
          *(_DWORD *)(v59 + 8) = 0;
        }
        while ( v54 != 84 );
        *(_BYTE *)(v55 + v53 + 19280) = 0;
      }
      else
      {
        *(_BYTE *)(v52 + v51 + 21484) = 0;
      }
      if ( ++v51 == 16 )
        break;
    }
    sleep(2u);
    return v11;
  }
  v43 = dev;
  v44 = (unsigned __int8)is_certification;
  v178 = (unsigned __int8)is_certification;
  *(_BYTE *)(dev + 21500) = 100;
  *(_DWORD *)(v43 + 4) = 3276800;
  v176 = v44;
  set_fan_control(3276800);
  while ( 1 )
  {
    check_fan_beforeInit();
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(s, 2048u, "Max fan speed: %d, Min fan speed: %d", *(_DWORD *)(dev + 21504), *(_DWORD *)(dev + 21508));
      applog(5, s, 0);
    }
    v45 = dev;
    if ( *(unsigned __int8 *)(dev + 21502) > 1u && *(_DWORD *)(dev + 21508) >= 2000u )
      break;
    v46 = 0;
    while ( 1 )
    {
      if ( *(_DWORD *)(v45 + 4 * (v46 + 2)) == 1 )
      {
        pthread_mutex_lock(&iic_mutex);
        dsPIC33EP16GS202_reset_pic((unsigned __int8)v46);
        pthread_mutex_unlock(&iic_mutex);
      }
      if ( ++v46 == 16 )
        break;
      v45 = dev;
    }
    if ( !v176 && (unsigned int)log_level > 3 )
    {
      v48 = fopen(log_file, "a+");
      v49 = v48;
      if ( v48 )
        fprintf(v48, "%s:%d:%s: Checking fans...\n", "driver-btm-c5.c", 12581, "bitmain_c5_init");
      fclose(v49);
    }
    v47 = ++v178 > 100;
    if ( (int)RestartNum > 0 )
      v47 = 0;
    if ( v47 )
    {
      *(_DWORD *)s = &unk_313A46;
      saveSearchFailedFlagInfo(s);
      system("reboot");
    }
    v176 = 1;
    cgsleep_ms();
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(s, "Fan ok!");
    applog(5, s, 0);
  }
  v173 = (FILE *)lowest_testOK_temp;
  v177 = 1;
  v61 = 0;
  v62 = &chain_voltage_value;
  v63 = chain_pic_buf;
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v61 + 2)) != 1 )
    {
      v64 = (unsigned __int8 *)(v63 + 128);
      goto LABEL_118;
    }
    pthread_mutex_lock(&iic_mutex);
    dsPIC33EP16GS202_reset_pic((unsigned __int8)v61);
    jump_to_app_CheckAndRestorePIC_T9_18(v61);
    if ( !opt_fixed_freq )
    {
      AT24C02_read_bytes_part_7((unsigned __int8)opt_fixed_freq, v63, v61, 128);
      v65 = *v8;
      if ( (unsigned int)*v8 > 3 )
      {
        v76 = fopen(log_file, "a+");
        v77 = v76;
        if ( v76 )
          fprintf(v76, "%s:%d:%s: Chain[%d] read_freq_badcores : ", "driver-btm-c5.c", 13034, "bitmain_c5_init", v61);
        fclose(v77);
        v65 = *v8;
      }
      v64 = (unsigned __int8 *)(v63 + 128);
      v66 = (unsigned __int8 *)v63;
      do
      {
        if ( v65 > 3 )
        {
          v67 = fopen(log_file, "a+");
          v68 = v67;
          if ( v67 )
          {
            v179 = v67;
            fprintf(v67, "0x%02x ", *v66, v67);
            v68 = v179;
          }
          fclose(v68);
          v65 = *v8;
        }
        ++v66;
      }
      while ( v66 != v64 );
      if ( v65 > 3 )
      {
        v153 = fopen(log_file, "a+");
        v154 = v153;
        if ( v153 )
          fputc(10, v153);
        fclose(v154);
        if ( !opt_economic_mode )
          goto LABEL_141;
        if ( (unsigned int)*v8 > 3 )
        {
          v155 = fopen(log_file, "a+");
          v156 = v155;
          if ( v155 )
            fprintf(v155, "%s:%d:%s: S11 USE LOW POWER MODE!\n", "driver-btm-c5.c", 13043, "bitmain_c5_init");
          fclose(v156);
        }
      }
      else if ( !opt_economic_mode )
      {
        goto LABEL_141;
      }
      v157 = *((_DWORD *)v63 + 28);
      v180 = v8;
      v158 = 0;
      v63[1] = v63[90];
      v159 = v63 + 1;
      *(_DWORD *)(v63 + 86) = v157;
      do
      {
        v160 = (char *)&unk_707D98 + 128 * v61 + (v158 >> 2);
        v161 = 2 * (v158++ & 3);
        *++v159 = get_pll_index_for_lowpower_mode(((int)(unsigned __int8)v160[3479] >> v161) & 3);
      }
      while ( v158 != 84 );
      v8 = v180;
LABEL_141:
      if ( !opt_fixed_freq )
      {
        if ( *v63 == 125 )
        {
          v69 = (unsigned int)*v8 > 3;
          *v62 = 5 * (unsigned __int8)v63[1];
          if ( v69 )
          {
            v162 = fopen(log_file, "a+");
            v163 = v162;
            if ( v162 )
              fprintf(
                v162,
                "%s:%d:%s: Chain[J%d] has backup chain_voltage=%d\n",
                "driver-btm-c5.c",
                13073,
                "bitmain_c5_init",
                v177,
                *v62);
            fclose(v163);
          }
          if ( opt_economic_mode && is7007_ctrl_board == -1 )
            isC5_Board();
          set_fixed_voltage();
        }
        v69 = (unsigned int)*v8 > 3;
        ENABLE_LIMIT_ON_SINGLE_BOARD = 1;
        if ( v69 )
        {
          v80 = fopen(log_file, "a+");
          v81 = v80;
          if ( v80 )
            fprintf(
              v80,
              "%s:%d:%s: S9+: use voltage limit rules on single board!\n",
              "driver-btm-c5.c",
              13084,
              "bitmain_c5_init");
          fclose(v81);
          v69 = (unsigned int)*v8 > 3;
          v173->_flags = 60;
          if ( v69 )
          {
            v82 = fopen(log_file, "a+");
            v83 = v82;
            if ( v82 )
              fprintf(
                v82,
                "%s:%d:%s: S9+ fix Chain[J%d] test patten OK temp=%d\n",
                "driver-btm-c5.c",
                13088,
                "bitmain_c5_init",
                v177,
                v173->_flags);
            fclose(v83);
          }
        }
        else
        {
          v173->_flags = 60;
        }
      }
      goto LABEL_123;
    }
    v64 = (unsigned __int8 *)(v63 + 128);
LABEL_123:
    pthread_mutex_unlock(&iic_mutex);
LABEL_118:
    ++v61;
    v63 = (char *)v64;
    ++v62;
    ++v177;
    v173 = (FILE *)((char *)v173 + 4);
  }
  while ( v61 != 16 );
  pic_heart_beat = (int)calloc(1u, 64u);
  if ( thr_info_create(pic_heart_beat, 0, (void *(*)(void *))pic_heart_beat_func, (void *)pic_heart_beat) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: create thread error for pic_heart_beat_func\n", "bitmain_c5_init");
      goto LABEL_130;
    }
    return -6;
  }
  v70 = 0;
  pthread_detach(*(_DWORD *)(pic_heart_beat + 12));
  init_exist_chain_table();
  power_init();
  power_tuning();
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v70 + 2)) == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      chain_voltage_pic[v70] = write_EEPROM_iic(1, 1, 144, v70, 0);
      enable_pic_dac((unsigned __int8)v70);
      pthread_mutex_unlock(&iic_mutex);
    }
    ++v70;
  }
  while ( v70 != 16 );
  if ( !opt_fixed_freq )
    goto LABEL_151;
  v143 = (unsigned __int8 *)chain_voltage_pic;
  v144 = 0;
  v145 = &chain_voltage_value;
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v144 + 2)) == 1 )
    {
      *v145 = is_using_voltage_from_config ? opt_bitmain_c5_voltage : 860;
      v69 = (unsigned int)*v8 > 3;
      *v143 = (unsigned int)(364.0704 / ((double)*v145 * 4.75 / 100.0 - 32.79) - 30.72);
      if ( v69 )
      {
        v146 = fopen(log_file, "a+");
        formatd = (char *)v146;
        if ( v146 )
          fprintf(
            v146,
            "%s:%d:%s: Fix freq=%d Chain[%d] voltage_pic=%d value=%d\n",
            "driver-btm-c5.c",
            13295,
            "bitmain_c5_init",
            (unsigned __int16)word_805F84,
            v144,
            *v143,
            *v145);
        fclose((FILE *)formatd);
      }
    }
    ++v144;
    ++v143;
    ++v145;
  }
  while ( v144 != 16 );
  if ( !opt_fixed_freq )
  {
LABEL_151:
    v71 = 0;
    cgsleep_ms();
    v72 = (unsigned __int8 *)chain_voltage_pic;
    v73 = 1;
    v74 = &chain_voltage_value;
    do
    {
      if ( *(_DWORD *)(dev + 4 * (v71 + 2)) == 1 )
      {
        pthread_mutex_lock(&iic_mutex);
        v75 = (int)((364.0704 / ((double)*v72 + 30.72) + 32.79) * 100.0 / 4.75);
        if ( (unsigned int)*v8 > 3 )
        {
          v152 = fopen(log_file, "a+");
          v175 = v152;
          if ( v152 )
            fprintf(
              v152,
              "%s:%d:%s: Chain[J%d] orignal chain_voltage_pic=%d value=%d\n",
              "driver-btm-c5.c",
              13315,
              "bitmain_c5_init",
              v73,
              *v72,
              10 * (v75 / 10));
          fclose(v175);
        }
        if ( chain_pic_buf[128 * v71] == 125 && *v74 != 10 * (v75 / 10) )
        {
          v147 = (unsigned __int8)(unsigned int)(364.0704 / ((double)*v74 * 4.75 / 100.0 - 32.79) - 30.72);
          if ( (unsigned int)*v8 > 3 )
          {
            v151 = fopen(log_file, "a+");
            v174 = v151;
            if ( v151 )
              fprintf(
                v151,
                "%s:%d:%s: Chain[J%d] will use backup chain_voltage_pic=%d [%d]\n",
                "driver-btm-c5.c",
                13332,
                "bitmain_c5_init",
                v73,
                *v74,
                v147);
            fclose(v174);
          }
          v148 = *v8;
          *v72 = v147;
          if ( v148 > 3 )
          {
            v149 = fopen(log_file, "a+");
            v150 = v149;
            if ( v149 )
              fprintf(
                v149,
                "%s:%d:%s: Chain[J%d] get working chain_voltage_pic=%d\n",
                "driver-btm-c5.c",
                13342,
                "bitmain_c5_init",
                v73,
                *v72);
            fclose(v150);
          }
        }
        pthread_mutex_unlock(&iic_mutex);
      }
      ++v71;
      ++v73;
      ++v72;
      ++v74;
    }
    while ( v71 != 16 );
    cgsleep_ms();
  }
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF70DF | 0x8100);
  }
  cgsleep_ms();
  v86 = 0;
  *(_BYTE *)(dev + 21548) = 114;
  format = 1;
  check_asic_reg(0);
  cgsleep_ms();
  do
  {
    v87 = dev;
    if ( *(_DWORD *)(dev + 4 * (v86 + 2)) == 1 )
    {
      if ( (unsigned int)*v8 > 3 )
      {
        v92 = fopen(log_file, "a+");
        v93 = v92;
        if ( v92 )
          fprintf(
            v92,
            "%s:%d:%s: Chain[J%d] has %d asic\n",
            "driver-btm-c5.c",
            13433,
            "bitmain_c5_init",
            format,
            *(unsigned __int8 *)(dev + v86 + 21484));
        fclose(v93);
        v87 = dev;
      }
      v88 = v87 + v86;
      if ( *(_BYTE *)(v87 + v86 + 21484) != 84 )
      {
        v89 = 6;
        while ( 1 )
        {
          *(_BYTE *)(v88 + 21484) = 0;
          set_reset_hashboard(v86, 1);
          pthread_mutex_lock(&iic_mutex);
          disable_pic_dac((unsigned __int8)v86);
          pthread_mutex_unlock(&iic_mutex);
          sleep(1u);
          pthread_mutex_lock(&iic_mutex);
          enable_pic_dac((unsigned __int8)v86);
          pthread_mutex_unlock(&iic_mutex);
          sleep(2u);
          set_reset_hashboard(v86, 0);
          sleep(1u);
          check_asic_reg_oneChain(v86, 0);
          if ( (unsigned int)*v8 > 3 )
          {
            v90 = fopen(log_file, "a+");
            v91 = v90;
            if ( v90 )
              fprintf(
                v90,
                "%s:%d:%s: retry Chain[J%d] has %d asic\n",
                "driver-btm-c5.c",
                13461,
                "bitmain_c5_init",
                format,
                *(unsigned __int8 *)(dev + v86 + 21484));
            fclose(v91);
          }
          v88 = dev + v86;
          if ( *(_BYTE *)(dev + v86 + 21484) == 84 )
            break;
          if ( !--v89 )
          {
            if ( !*(_BYTE *)(v88 + 21484) )
              *(_DWORD *)(dev + 4 * (v86 + 2)) = 0;
            break;
          }
        }
      }
    }
    ++v86;
    ++format;
  }
  while ( v86 != 16 );
  software_set_address();
  cgsleep_ms();
  if ( (byte_805F7C & 8) != 0 )
  {
    v94 = (unsigned __int16)word_805F84;
    *(_WORD *)(dev + 21571) = word_805F84;
    set_frequency(v94);
    sprintf((char *)(dev + 21573), "%u", *(unsigned __int16 *)(dev + 21571));
  }
  cgsleep_ms();
  v95 = dev;
  v96 = (unsigned __int8)byte_805F82;
  v97 = (unsigned __int8)opt_debug;
  v98 = ((unsigned __int8)byte_805F7C >> 1) & 1;
  *(_BYTE *)(dev + 21569) = (byte_805F7C & 2) != 0;
  *(_BYTE *)(v95 + 21570) = v96;
  if ( v97 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(s, 2048u, "%s: fan_eft : %d  fan_pwm : %d\n", "bitmain_c5_init", (unsigned __int8)v98, v96);
    applog(7, s, 0);
  }
  if ( (byte_805F7C & 2) != 0 && (unsigned __int8)byte_805F82 <= 100u )
    set_PWM((unsigned __int8)byte_805F82);
  else
    set_PWM_according_to_temperature();
  if ( (byte_805F7C & 4) != 0 )
  {
    if ( word_805F8A )
    {
      *(_DWORD *)(dev + 72) = HIBYTE(word_805F8A) + 1000 * (unsigned __int8)word_805F8A;
    }
    else
    {
      v142 = 90
           * (*(unsigned __int8 *)(dev + 21549)
            * (16777216
             / calculate_core_number(*(unsigned __int8 *)(dev + 21548)))
            / *(unsigned __int16 *)(dev + 21571))
           / 100;
      *(_DWORD *)(dev + 72) = v142;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(s, 2048u, "dev->timeout = %d\n", v142);
        applog(7, s, 0);
      }
    }
    if ( *(_DWORD *)(dev + 72) > 131071u )
      *(_DWORD *)(dev + 72) = 131071;
  }
  init_uart_baud();
  v99 = 0;
  cgsleep_ms();
  v100 = dev;
  do
  {
    if ( *(_DWORD *)(v100 + 4 * (v99 + 2)) == 1 && *(_BYTE *)(v100 + v99 + 21484) == 84 )
    {
      calibration_sensor_offset(152, v99);
      cgsleep_ms();
      v100 = dev;
    }
    ++v99;
  }
  while ( v99 != 16 );
  set_time_out_control((*(_DWORD *)(v100 + 72) / 10u) & 0x1FFFF | 0x80000000);
  v101 = dev;
  *(_BYTE *)(dev + 21500) = 100;
  *(_DWORD *)(v101 + 4) = 3276800;
  set_fan_control(3276800);
  if ( !opt_fixed_freq && !is_scan_based_on_domain )
  {
    v104 = dev;
    v105 = v8;
    v106 = is_scan_based_on_domain;
    formatb = chain_voltage_pic;
    while ( 2 )
    {
      if ( !*(_DWORD *)(v104 + 4 * (v106 + 2)) )
        goto LABEL_241;
      v107 = v104 + 4;
      v108 = 0;
      do
      {
        v109 = *(_DWORD *)(v107 + 4);
        v107 += 4;
        if ( v109 == 1 )
          ++v108;
      }
      while ( v104 + 68 != v107 );
      if ( v108 <= 3 )
        goto LABEL_241;
      v110 = 10 * ((int)((364.0704 / ((double)(unsigned __int8)*formatb + 30.72) + 32.79) * 100.0 / 4.75) / 10);
      if ( ENABLE_LIMIT_ON_SINGLE_BOARD )
      {
        GetRealBoardRate(v106);
        if ( (unsigned int)*v105 <= 3 )
          goto LABEL_239;
        v111 = fopen(log_file, "a+");
        if ( v111 )
        {
          RealBoardRate = GetRealBoardRate(v106);
          fprintf(
            v111,
            "%s:%d:%s: single board rate=%d voltage limit=%d on chain[%d]\n",
            "driver-btm-c5.c",
            13663,
            "bitmain_c5_init",
            RealBoardRate,
            930,
            v106);
        }
      }
      else
      {
        if ( opt_economic_mode )
          GetTotalRate_part_12();
        if ( (unsigned int)*v105 <= 3 )
        {
LABEL_239:
          if ( v110 > 930 )
          {
            if ( (unsigned int)*v105 > 3 )
            {
              v136 = fopen(log_file, "a+");
              v137 = v136;
              if ( v136 )
                fprintf(
                  v136,
                  "%s:%d:%s: will set the voltage limited on chain[%d], change voltage=%d\n",
                  "driver-btm-c5.c",
                  13723,
                  "bitmain_c5_init",
                  v106,
                  930);
              fclose(v137);
              if ( (unsigned int)*v105 > 3 )
              {
                v138 = fopen(log_file, "a+");
                v139 = v138;
                if ( v138 )
                  fprintf(
                    v138,
                    "%s:%d:%s: now set pic voltage=%d on chain[%d]\n",
                    "driver-btm-c5.c",
                    13726,
                    "bitmain_c5_init",
                    1,
                    v106);
                fclose(v139);
              }
            }
            v104 = dev;
            *formatb = 1;
          }
          else
          {
            v104 = dev;
          }
LABEL_241:
          ++v106;
          ++formatb;
          if ( v106 == 16 )
          {
            v8 = v105;
            goto LABEL_217;
          }
          continue;
        }
        v111 = fopen(log_file, "a+");
        if ( v111 )
        {
          if ( opt_economic_mode )
            TotalRate_part_12 = GetTotalRate_part_12();
          else
            TotalRate_part_12 = ideal_total_hash_rate;
          fprintf(
            v111,
            "%s:%d:%s: miner rate=%d voltage limit=%d on chain[%d]\n",
            "driver-btm-c5.c",
            13669,
            "bitmain_c5_init",
            TotalRate_part_12,
            930,
            v106);
        }
      }
      break;
    }
    fclose(v111);
    if ( (unsigned int)*v105 > 3 )
    {
      v113 = fopen(log_file, "a+");
      v114 = v113;
      if ( v113 )
        fprintf(
          v113,
          "%s:%d:%s: get PIC voltage=%d on chain[%d], check: must be < %d\n",
          "driver-btm-c5.c",
          13700,
          "bitmain_c5_init",
          v110,
          v106,
          930);
      fclose(v114);
    }
    goto LABEL_239;
  }
LABEL_217:
  for ( k = 0; k != 16; ++k )
  {
    if ( *(_DWORD *)(dev + 4 * (k + 2)) == 1 )
    {
      if ( is_scan_based_on_domain )
      {
        if ( (unsigned int)*v8 > 3 )
        {
          v103 = fopen(log_file, "a+");
          formata = (char *)v103;
          if ( v103 )
            fprintf(v103, "%s:%d:%s: open core three times\n", "driver-btm-c5.c", 13763, "bitmain_c5_init");
          fclose((FILE *)formata);
        }
        open_core_one_chain(k, 1);
        sleep(2u);
        open_core_one_chain(k, 1);
        sleep(2u);
      }
      open_core_one_chain(k, 1);
      sleep(1u);
    }
  }
  set_working_voltage();
  v115 = 0;
  set_time_out_control((*(_DWORD *)(dev + 72) / 10u) & 0x1FFFF | 0x80000000);
  formatc = (char *)v8;
  do
  {
    v116 = dev;
    if ( *(_DWORD *)(dev + 4 * (v115 + 2)) == 1 && *(char *)(dev + v115 + 1112) > 0 )
    {
      v117 = 0;
      v118 = 8 * v115;
      v119 = *(_DWORD *)(dev + 4 * (v115 + 2));
      v120 = 0;
      do
      {
        set_baud_with_addr(*(_BYTE *)(v116 + 21551), 0, *(_BYTE *)(v116 + v118 + v117 + 1256), v115, v119, 0, v119);
        ++v120;
        v121 = *(unsigned __int8 *)(v117 + dev + v118 + 1256);
        v117 = v120;
        check_asic_reg_with_addr(28, v121, v115);
        v116 = dev;
      }
      while ( v120 < *(char *)(dev + v115 + 1112) );
    }
    ++v115;
  }
  while ( v115 != 16 );
  if ( *(_DWORD *)formatc > 3u )
  {
    v140 = fopen(log_file, "a+");
    v141 = v140;
    if ( v140 )
      fprintf(v140, "%s:%d:%s: start thread for read temp\n", "driver-btm-c5.c", 13966, "bitmain_c5_init");
    fclose(v141);
  }
  read_temp_id = (int)calloc(1u, 64u);
  if ( thr_info_create(read_temp_id, 0, (void *(*)(void *))read_temp_func, (void *)read_temp_id) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      v11 = -7;
      snprintf(s, 2048u, "%s: create thread for read temp\n", "bitmain_c5_init");
      applog(7, s, 0);
    }
    else
    {
      return -7;
    }
  }
  else
  {
    pthread_detach(*(_DWORD *)(read_temp_id + 12));
    if ( !opt_fixed_freq )
      opt_pre_heat = 0;
    set_asic_ticket_mask(ticket_mask);
    set_hcnt(0);
    set_sno(0);
    cgsleep_ms();
    if ( opt_multi_version )
      set_time_out_control((*(_DWORD *)(dev + 72) * opt_multi_version) & 0x1FFFF | 0x80000000);
    else
      set_time_out_control(*(_DWORD *)(dev + 72) & 0x1FFFF | 0x80000000);
    check_system_work_id = (int)calloc(1u, 64u);
    v11 = thr_info_create(check_system_work_id, 0, (void *(*)(void *))check_system_work, (void *)check_system_work_id);
    if ( v11 )
    {
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return -6;
      snprintf(s, 2048u, "%s: create thread for check system\n", "bitmain_c5_init");
LABEL_130:
      v11 = -6;
      applog(7, s, 0);
    }
    else
    {
      pthread_detach(*(_DWORD *)(check_system_work_id + 12));
      v122 = dev;
      v123 = 0;
      v124 = dev + 4;
      do
      {
        v125 = *(_DWORD *)(v124 + 4);
        v124 += 4;
        if ( v125 )
        {
          v126 = *(unsigned __int8 *)(v122 + v123 + 21484);
          if ( *(_BYTE *)(v122 + v123 + 21484) )
          {
            v127 = 0;
            v128 = v123 << 7;
            v129 = 0;
            v130 = v122 + 136 * v123;
            v165 = v123;
            do
            {
              if ( (v129 & 7) == 0 )
                LOBYTE(v123) = 32;
              v131 = v130 + v127 + v129;
              if ( (v129 & 7) == 0 )
              {
                ++v127;
                *(_BYTE *)(v131 + 19196) = v123;
              }
              v132 = v128 + v129 + 351;
              v133 = v130 + v127 + v129++;
              v134 = v122 + 8 * v132;
              LOBYTE(v123) = 111;
              *(_BYTE *)(v133 + 19196) = 111;
              *(_DWORD *)(v134 + 4) = 0;
              *(_DWORD *)(v134 + 8) = 0;
            }
            while ( v129 != v126 );
            v123 = v165;
          }
          else
          {
            v127 = *(unsigned __int8 *)(v122 + v123 + 21484);
          }
          *(_BYTE *)(v127 + v126 + v122 + 136 * v123 + 19196) = 0;
        }
        ++v123;
      }
      while ( v123 != 16 );
      cgtime(&tv_send_job);
      cgtime(&tv_send);
      startCheckNetworkJob = 1;
      setStartTimePoint();
    }
  }
  return v11;
}
// 3BCFC: using guessed type void __noreturn check_system_work();
// 3D294: using guessed type void __noreturn read_temp_func();
// 3F8E8: using guessed type int __fastcall dsPIC33EP16GS202_reset_pic(_DWORD);
// 7DF98: using guessed type int opt_multi_version;
// 7E55C: using guessed type int is7007_ctrl_board;
// 7E57C: using guessed type int ticket_mask;
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 7E584: using guessed type int opt_bitmain_c5_voltage;
// 7E588: using guessed type char is_using_voltage_from_config;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 709398: using guessed type char opt_fixed_freq;
// 7093E0: using guessed type int lowest_testOK_temp[];
// 70943E: using guessed type char opt_economic_mode;
// 709440: using guessed type int ideal_total_hash_rate;
// 715F72: using guessed type char isC5_CtrlBoard;
// 805F78: using guessed type char config_parameter;
// 805F7C: using guessed type char byte_805F7C;
// 805F82: using guessed type char byte_805F82;
// 805F84: using guessed type __int16 word_805F84;
// 805F8A: using guessed type __int16 word_805F8A;
// 805F96: using guessed type __int16 word_805F96;
// 805FA4: using guessed type int chain_voltage_value;
// 805FE4: using guessed type char ENABLE_LIMIT_ON_SINGLE_BOARD;
// 806028: using guessed type char is_certification;
// 80602C: using guessed type struct timeval tv_send_job;
// 806034: using guessed type struct timeval tv_send;
// 80603C: using guessed type char startCheckNetworkJob;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817748: using guessed type int pcb_version;
// 81774C: using guessed type int pic_heart_beat;
// 817C18: using guessed type int read_nonce_reg_id;
// 817C1C: using guessed type int check_system_work_id;
// 817C24: using guessed type int fpga_major_version;
// 817C28: using guessed type int dev;
// 817CFC: using guessed type int read_temp_id;
// 817D00: using guessed type int fpga_version;

//----- (0003A0E8) --------------------------------------------------------
int __fastcall bitmain_c5_prepare(int a1)
{
  int v1; // r4
  int *v2; // r1
  __int16 v3; // r3
  char v4; // r2
  char v5; // r0
  int v6; // t1
  char *v7; // r3
  int v8; // r2
  int v10[8]; // [sp+10h] [bp-38h] BYREF

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20);
  *(_DWORD *)(v1 + 668) = a1;
  if ( pthread_mutex_init((pthread_mutex_t *)(v1 + 676), 0) )
    mutex_init_part_3_constprop_28(16611);
  if ( pthread_mutex_init((pthread_mutex_t *)v1, 0) )
    mutex_init_part_3_constprop_28(16612);
  rwlock_init_constprop_22((pthread_rwlock_t *)(v1 + 24), 16612);
  if ( pthread_mutex_init((pthread_mutex_t *)(v1 + 948), 0) )
    mutex_init_part_3_constprop_28(16613);
  rwlock_init_constprop_22((pthread_rwlock_t *)(v1 + 972), 16613);
  if ( pthread_mutex_init((pthread_mutex_t *)(v1 + 2796), 0) )
    mutex_init_part_3_constprop_28(16614);
  rwlock_init_constprop_22((pthread_rwlock_t *)(v1 + 2820), 16614);
  if ( pthread_mutex_init((pthread_mutex_t *)(v1 + 4644), 0) )
    mutex_init_part_3_constprop_28(16615);
  rwlock_init_constprop_22((pthread_rwlock_t *)(v1 + 4668), 16615);
  memset(v10, 0, sizeof(v10));
  v2 = v10;
  LOWORD(v10[3]) = opt_bitmain_c5_freq;
  BYTE2(v10[2]) = opt_bitmain_fan_pwm;
  LOBYTE(v10[0]) = 81;
  HIWORD(v10[0]) = 26;
  BYTE1(v10[1]) = 7;
  LOWORD(v10[2]) = 13833;
  HIBYTE(v10[2]) = 80;
  HIWORD(v10[3]) = 9479;
  LOWORD(v10[4]) = 2570;
  LOBYTE(v10[1]) = (2 * (opt_bitmain_fan_ctrl & 1)) | 0xFD;
  v3 = 188;
  v4 = -127;
  v5 = -1;
  LOBYTE(v10[6]) = 4;
  HIWORD(v10[6]) = 400;
  LOWORD(v10[7]) = 600;
  while ( 1 )
  {
    v8 = (unsigned __int8)(v4 ^ v5);
    v5 = v3;
    if ( v2 == (int *)((char *)&v10[7] + 1) )
      break;
    v6 = *((unsigned __int8 *)v2 + 1);
    v2 = (int *)((char *)v2 + 1);
    v7 = &_PRETTY_FUNCTION___14958[v6 ^ v8];
    v4 = v7[1960];
    v3 = (unsigned __int8)v7[2216];
  }
  HIWORD(v10[7]) = v8 | (v3 << 8);
  bitmain_c5_init(v10[0], v10[1], v10[2], v10[3], v10[4], v10[5], v10[6], v10[7]);
  return 1;
}
// 7E58C: using guessed type int opt_bitmain_c5_freq;
// 80603D: using guessed type char opt_bitmain_fan_ctrl;
// 806040: using guessed type int opt_bitmain_fan_pwm;

//----- (0003A2A0) --------------------------------------------------------
size_t __fastcall parse_job_to_c5(_DWORD *a1, int a2, int a3)
{
  char v4; // r7
  char v5; // r3
  int v6; // r4
  int v8; // r0
  char *v9; // r9
  size_t v10; // r4
  size_t v11; // r2
  int v12; // r1
  __int64 v13; // r6
  int v14; // r11
  size_t v15; // r10
  size_t v16; // r7
  unsigned __int8 *v17; // r0
  unsigned __int8 *v18; // r6
  unsigned __int8 *v19; // r3
  int v20; // lr
  int v21; // r12
  _DWORD *v22; // t1
  int v23; // r4
  int v24; // r0
  int v25; // r1
  int v26; // r4
  int v27; // r0
  int v28; // r1
  __int16 v29; // r3
  int v30; // r0
  int v31; // r2
  unsigned __int8 *v32; // r1
  int v33; // t1
  char *v34; // r3
  __int16 v35; // r4
  __int64 v36; // r2
  void *v37; // r0
  __int64 src; // [sp+8h] [bp-888h] BYREF
  int v40[22]; // [sp+10h] [bp-880h] BYREF
  char v41[2088]; // [sp+68h] [bp-828h] BYREF

  v4 = *(_BYTE *)(a2 + 644);
  v5 = BYTE1(v40[2]) & 0xFE | *(_BYTE *)(a2 + 680) & 1;
  v6 = *(_DWORD *)(a2 + 648);
  v40[3] = a3;
  LOWORD(v40[0]) = 82;
  LOBYTE(v40[2]) = pool_send_nu_14834;
  BYTE2(v40[2]) = 15;
  BYTE1(v40[2]) = v5 | 2;
  LOBYTE(v40[20]) = v4;
  v40[21] = v6;
  hex2bin(&v40[4], (unsigned __int8 *)(a2 + 1780), 4);
  hex2bin(&v40[5], (unsigned __int8 *)(a2 + 1712), 32);
  hex2bin(&v40[14], (unsigned __int8 *)(a2 + 1792), 4);
  hex2bin(&v40[13], (unsigned __int8 *)(a2 + 1804), 4);
  v8 = *(_DWORD *)(a2 + 1576);
  v9 = *(char **)(a2 + 1568);
  v10 = *(_DWORD *)(a2 + 1572);
  v11 = *(_DWORD *)(a2 + 632);
  HIWORD(v40[15]) = v8;
  LOWORD(v40[15]) = v10;
  LOWORD(v40[16]) = v11;
  v12 = *(_DWORD *)&v9[v8 + 4];
  v13 = *(_QWORD *)(a2 + 624);
  v40[18] = *(_DWORD *)&v9[v8];
  v40[19] = v12;
  src = v13;
  memcpy(&v40[18], &src, v11);
  v14 = *(_DWORD *)(a2 + 1708);
  HIWORD(v40[16]) = v14;
  v15 = v10 + 32 * v14;
  v16 = v15 + 90;
  v17 = (unsigned __int8 *)calloc(v15 + 90, 1u);
  v18 = v17;
  if ( !v17 )
  {
    strcpy(v41, "Failed to malloc tmp_buf");
    applog(3, v41, 1);
    quit(1);
  }
  v40[1] = v15 + 82;
  memcpy(v17, v40, 88u);
  memcpy(v18 + 88, v9, v10);
  if ( v14 > 0 )
  {
    v19 = &v18[v10 + 88];
    v20 = 0;
    v21 = *(_DWORD *)(a2 + 676) - 4;
    do
    {
      v22 = *(_DWORD **)(v21 + 4);
      v21 += 4;
      ++v20;
      v19 += 32;
      v23 = v22[1];
      v24 = v22[2];
      v25 = v22[3];
      *((_DWORD *)v19 - 8) = *v22;
      *((_DWORD *)v19 - 7) = v23;
      *((_DWORD *)v19 - 6) = v24;
      *((_DWORD *)v19 - 5) = v25;
      v26 = v22[5];
      v27 = v22[6];
      v28 = v22[7];
      *((_DWORD *)v19 - 4) = v22[4];
      *((_DWORD *)v19 - 3) = v26;
      *((_DWORD *)v19 - 2) = v27;
      *((_DWORD *)v19 - 1) = v28;
    }
    while ( v20 != v14 );
  }
  if ( (unsigned __int16)v16 == 2 )
  {
    v29 = -1;
  }
  else
  {
    v30 = 255;
    v31 = 255;
    v32 = v18;
    do
    {
      v33 = *v32++;
      v34 = &_PRETTY_FUNCTION___14958[v33 ^ v31];
      v31 = (unsigned __int8)v34[1960] ^ v30;
      v30 = (unsigned __int8)v34[2216];
    }
    while ( v32 != &v18[(unsigned __int16)(v15 + 87) + 1] );
    v29 = v31 | ((_WORD)v30 << 8);
  }
  v35 = v29;
  v36 = *(_QWORD *)&pool_send_nu_14834;
  *(_WORD *)&v18[v15 + 88] = v35;
  *(_QWORD *)&pool_send_nu_14834 = v36 + 1;
  v37 = malloc(v16);
  *a1 = v37;
  memcpy(v37, v18, v16);
  memcpy(last_job_buffer, v18, v16);
  free(v18);
  return v15 + 90;
}
// 806048: using guessed type int pool_send_nu_14834;

//----- (0003A4C4) --------------------------------------------------------
int __fastcall send_job(unsigned __int8 *a1)
{
  int result; // r0
  int v3; // r4
  size_t v4; // r4
  int *v5; // r0
  int v6; // r3
  int v7; // r3
  size_t v8; // r1
  unsigned int v9; // r3
  size_t v10; // r9
  int v11; // r3
  char *v12; // r8
  int v13; // r1
  int v14; // r3
  char *v15; // r2
  char v16; // t1
  int v17; // r4
  int v18; // r7
  int v19; // t1
  int v20; // r5
  int v21; // r3
  char *v22; // r8
  char *v23; // r1
  unsigned int v24; // r3
  char v25; // t1
  unsigned int v26; // r4
  int v27; // r7
  int v28; // t1
  int v29; // r5
  int dhash_acc_control; // r0
  int v31; // r6
  void **v32; // r7
  unsigned __int8 *v33; // r6
  int v34; // r2
  int v35; // r3
  int v36; // r0
  int v37; // r0
  int nonce_fifo_interrupt; // r0
  unsigned __int8 v39; // r7
  int *v40; // [sp+14h] [bp-8E4h]
  char *ptr; // [sp+1Ch] [bp-8DCh]
  size_t n; // [sp+20h] [bp-8D8h]
  int v43; // [sp+28h] [bp-8D0h]
  unsigned int v44; // [sp+34h] [bp-8C4h]
  _BOOL4 v45; // [sp+40h] [bp-8B8h]
  void *v46; // [sp+4Ch] [bp-8ACh] BYREF
  int s[32]; // [sp+50h] [bp-8A8h] BYREF
  char v48[2088]; // [sp+D0h] [bp-828h] BYREF

  memset(s, 0, sizeof(s));
  result = 0;
  if ( doTestPatten )
    return result;
  if ( *a1 != 82 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -1;
    snprintf(v48, 2048u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", "send_job", *a1);
    applog(7, v48, 0);
    return -1;
  }
  v3 = *((_DWORD *)a1 + 1);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(v48, 2048u, "%s: len = 0x%x\n", "send_job", *((_DWORD *)a1 + 1));
    applog(7, v48, 0);
  }
  v4 = v3 + 8;
  v5 = (int *)calloc(v4, 1u);
  v40 = v5;
  if ( !v5 )
  {
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return -2;
    snprintf(v48, 2048u, "%s: malloc buffer failed.\n", "send_job");
    applog(7, v48, 0);
    return -2;
  }
  memcpy(v5, a1, v4);
  v6 = *(_DWORD *)dev;
  if ( *(_DWORD *)dev == job_start_address_1 )
  {
    *(_DWORD *)dev = job_start_address_2;
  }
  else
  {
    if ( v6 != job_start_address_2 )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          v48,
          2048u,
          "%s: dev->current_job_start_address = 0x%x, but job_start_address_1 = 0x%x, job_start_address_2 = 0x%x\n",
          "send_job",
          v6,
          job_start_address_1,
          job_start_address_2);
        applog(7, v48, 0);
      }
      free(v40);
      return -3;
    }
    *(_DWORD *)dev = job_start_address_1;
  }
  if ( *((_BYTE *)v40 + 80) || v40[21] == 4 )
  {
    v7 = 4;
    opt_multi_version = 4;
  }
  else
  {
    v7 = 1;
    opt_multi_version = 1;
  }
  v45 = last_version_num_14890 != v7;
  if ( last_version_num_14890 != v7 )
    last_version_num_14890 = v7;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(v48, 2048u, "Verion num %d", v7);
    applog(5, v48, 0);
  }
  v8 = *((unsigned __int16 *)v40 + 30);
  n = v8;
  if ( (v8 & 0x3F) > 55 )
    v9 = (v8 >> 6) + 2;
  else
    v9 = *((unsigned __int16 *)v40 + 30);
  if ( (v8 & 0x3F) <= 55 )
    v9 = (v9 >> 6) + 1;
  v10 = v9 << 6;
  ptr = (char *)malloc(v9 << 6);
  if ( ptr )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(v48, 2048u, "%s: coinbase_padding = 0x%x", "send_job", ptr);
      applog(7, v48, 0);
    }
    v11 = *((unsigned __int16 *)v40 + 33);
    v43 = v11;
    if ( !*((_WORD *)v40 + 33) )
    {
      v46 = 0;
      v44 = 0;
LABEL_52:
      v12 = ptr - 1;
      memset(ptr, 0, v10);
      memcpy(ptr, a1 + 88, n);
      v13 = c_coinbase_padding;
      ptr[n] = -128;
      *(_DWORD *)&ptr[v10 - 4] = (((8 * n) & 0xFF00) << 8) | (((8 * n) & 0xFF0000) >> 8) | (n << 27);
      v14 = 0;
      v15 = ptr - 1;
      *(_DWORD *)&ptr[4 * ((v10 - 8) >> 2)] = 0;
      c_coinbase_padding = v10;
      l_coinbase_padding = v13;
      do
      {
        v16 = *++v15;
        *(_BYTE *)(*(_DWORD *)dev + v14++) = v16;
      }
      while ( v10 != v14 );
      v17 = 0;
      do
      {
        v19 = (unsigned __int8)*++v12;
        v18 = v19;
        v20 = *(unsigned __int8 *)(*(_DWORD *)dev + v17);
        if ( v20 != v19 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            v48,
            2048u,
            "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
            "send_job",
            v17,
            v20,
            v17,
            v18);
          applog(7, v48, 0);
        }
        ++v17;
      }
      while ( v10 != v17 );
      v21 = c_merkles_num;
      c_merkles_num = v43;
      l_merkles_num = v21;
      if ( v43 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(v48, 2048u, "%s: copy merkle bin into memory ...\n", "send_job");
          applog(7, v48, 0);
        }
        v22 = (char *)v46 - 1;
        memset(v46, 0, v44);
        memcpy(v46, &a1[n + 88], v44);
        v23 = (char *)v46 - 1;
        v24 = 0;
        do
        {
          v25 = *++v23;
          *(_BYTE *)(*(_DWORD *)dev + v10 + v24++) = v25;
        }
        while ( v44 > v24 );
        v26 = 0;
        do
        {
          v28 = (unsigned __int8)*++v22;
          v27 = v28;
          v29 = *(unsigned __int8 *)(*(_DWORD *)dev + v10 + v26);
          if ( v29 != v28 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              v48,
              2048u,
              "%s: merkles_in_ddr[%d] = 0x%x, but *(merkles_bin + %d) =0x%x",
              "send_job",
              v26,
              v29,
              v26,
              v27);
            applog(7, v48, 0);
          }
          ++v26;
        }
        while ( v44 > v26 );
      }
      dhash_acc_control = get_dhash_acc_control();
      if ( v45 )
        set_dhash_acc_control(dhash_acc_control & 0xFFFEFFBF | 0x10000);
      else
        set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
      cgsleep_ms();
      if ( *(_DWORD *)dev == job_start_address_1 )
      {
        set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
      }
      else if ( *(_DWORD *)dev == job_start_address_2 )
      {
        set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2162688);
      }
      if ( (*((_BYTE *)v40 + 9) & 2) != 0 )
      {
        v39 = *((_BYTE *)v40 + 10);
        set_ticket_mask(v39);
        *(_BYTE *)(dev + 21568) = v39;
      }
      set_job_id(v40[3]);
      v31 = v40[4];
      set_block_header_version(v31);
      if ( opt_multi_version == 4 )
      {
        set_block_header_version1_ab(v31 | 0x4000);
        set_block_header_version2_ab(v31 | 0x8000);
        set_block_header_version3_ab(v31 | 0xC000);
      }
      v32 = &v46;
      memset(s, 0, sizeof(s));
      v33 = (unsigned __int8 *)v40;
      do
      {
        v34 = v33[22];
        v33 += 4;
        v32[1] = (void *)(v33[16] | (v34 << 16) | (v33[19] << 24) | (v33[17] << 8));
        ++v32;
      }
      while ( v33 != (unsigned __int8 *)(v40 + 8) );
      set_pre_header_hash(s);
      set_time_stamp(v40[13]);
      set_target_bits(v40[14]);
      set_coinbase_length_and_nonce2_length((unsigned __int8)(v10 >> 6) | (*((unsigned __int8 *)v40 + 64) << 8) | (*((unsigned __int16 *)v40 + 31) << 16));
      v35 = v40[19];
      s[0] = v40[18];
      s[1] = v35;
      set_work_nonce2(s);
      set_merkle_bin_number(v43);
      set_job_length((v44 + v10) & 0xFFE0);
      cgsleep_ms();
      if ( !gBegin_get_nonce_0 )
      {
        nonce_fifo_interrupt = get_nonce_fifo_interrupt();
        set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
        gBegin_get_nonce_0 = 1;
        reCalculateAVG();
      }
      if ( opt_multi_version )
      {
        v36 = get_dhash_acc_control();
        set_dhash_acc_control(v36 & 0xFFFEF0FF | ((opt_multi_version & 0xF) << 8) | 0x8060);
      }
      else
      {
        v37 = get_dhash_acc_control();
        set_dhash_acc_control(v37 & 0xFFFEF0FF | ((opt_multi_version & 0xF) << 8) | 0x60);
      }
      free(ptr);
      if ( v43 )
        free(v46);
      free(v40);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(v48, 2048u, "--- %s end\n", "send_job");
        applog(7, v48, 0);
      }
      cgtime(&tv_send_job);
      cgsleep_ms();
      set_asic_ticket_mask(ticket_mask);
      set_sno(0);
      set_hcnt(0);
      return 0;
    }
    v44 = 32 * v11;
    v46 = malloc(32 * v11);
    if ( v46 )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(v48, 2048u, "%s: merkles_bin = 0x%x", "send_job", v46);
        applog(7, v48, 0);
      }
      goto LABEL_52;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(v48, 2048u, "%s: malloc merkles_bin failed.\n", "send_job");
      applog(7, v48, 0);
    }
    free(v40);
    free(ptr);
    return -5;
  }
  else
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(v48, 2048u, "%s: malloc coinbase_padding failed.\n", "send_job");
      applog(7, v48, 0);
    }
    free(v40);
    return -4;
  }
}
// 7DF98: using guessed type int opt_multi_version;
// 7E57C: using guessed type int ticket_mask;
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 805A8: using guessed type int opt_log_level;
// 713488: using guessed type char doTestPatten;
// 713489: using guessed type char gBegin_get_nonce_0;
// 80602C: using guessed type struct timeval tv_send_job;
// 806050: using guessed type int last_version_num_14890;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80B808: using guessed type int job_start_address_1;
// 80B80C: using guessed type int job_start_address_2;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (0003AD7C) --------------------------------------------------------
int __fastcall bitmain_c5_update(int a1)
{
  int v1; // r4
  int v2; // r5
  void *v3; // r1
  int v4; // r5
  int v5; // r3
  int *v7; // r0
  int *v8; // r0
  int *v9; // r0
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  int *v13; // r0
  int *v14; // r0
  int *v15; // r0
  int *v16; // r0
  void **work; // [sp+10h] [bp-830h] BYREF
  void *ptr; // [sp+14h] [bp-82Ch] BYREF
  char s[2088]; // [sp+18h] [bp-828h] BYREF

  v1 = *(_DWORD *)(a1 + 20);
  v2 = **(_DWORD **)(a1 + 152);
  if ( pthread_mutex_lock((pthread_mutex_t *)(v1 + 676)) )
  {
    v16 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v16,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16950);
    applog(3, s, 1);
    quit(1);
  }
  v3 = *(void **)v2;
  *(_BYTE *)(v2 + 63) = 0;
  *(_BYTE *)(v2 + 62) = 0;
  ptr = 0;
  work = get_work(v2, v3);
  discard_work(&work, "driver-btm-c5.c", "bitmain_c5_update", 16958);
  v4 = current_pool();
  if ( !*(_BYTE *)(v4 + 640) )
  {
    strcpy(s, "Bitmain S9 has to use stratum pools");
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)v1) )
  {
    v7 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v7,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16965);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v1 + 24)) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v8,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16965);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(v4 + 212)) )
  {
    v9 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v9,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16966);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 236)) )
  {
    v10 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v10,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16966);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(v4 + 212)) )
  {
    v11 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v11,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16966);
    applog(3, s, 1);
    quit(1);
  }
  *(_DWORD *)(v1 + 732) = *(_DWORD *)v4;
  copy_pool_stratum(v1 + 4432, v1 + 2584);
  *(_DWORD *)(v1 + 6288) = *(_DWORD *)(v1 + 6284);
  copy_pool_stratum(v1 + 2584, v1 + 736);
  *(_DWORD *)(v1 + 6284) = *(_DWORD *)(v1 + 6280);
  copy_pool_stratum(v1 + 736, v4);
  v5 = given_id + 1;
  *(_DWORD *)(v1 + 6280) = given_id + 1;
  given_id = v5;
  parse_job_to_c5(&ptr, v4, v5);
  if ( !status_error )
  {
    pthread_mutex_lock(&reinit_mutex);
    send_job((unsigned __int8 *)ptr);
    pthread_mutex_unlock(&reinit_mutex);
  }
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 236)) )
  {
    v12 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v12,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16984);
    applog(3, s, 1);
    quit(1);
  }
  selective_yield(0);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v1 + 24)) )
  {
    v13 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v13,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16985);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v1) )
  {
    v14 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v14,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16985);
    applog(3, s, 1);
    quit(1);
  }
  selective_yield(0);
  free(ptr);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(v1 + 676)) )
  {
    v15 = _errno_location();
    snprintf(
      s,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v15,
      "driver-btm-c5.c",
      "bitmain_c5_update",
      16987);
    applog(3, s, 1);
    quit(1);
  }
  return selective_yield(0);
}
// 7E558: using guessed type int given_id;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 704AB8: using guessed type char status_error;

//----- (0003B200) --------------------------------------------------------
int re_send_last_job_part_15()
{
  pthread_mutex_lock(&reinit_mutex);
  send_job((unsigned __int8 *)last_job_buffer);
  return j_pthread_mutex_unlock(&reinit_mutex);
}

//----- (0003B224) --------------------------------------------------------
int re_send_last_job()
{
  int result; // r0

  if ( last_job_buffer[0] != 23 )
    return re_send_last_job_part_15();
  return result;
}

//----- (0003B238) --------------------------------------------------------
int do8xPattenTest()
{
  int dhash_acc_control; // r0
  pthread_mutex_t *v1; // r4
  char *v2; // r5
  int v3; // r0
  pthread_mutex_t *v4; // r3
  int v5; // r6
  int v6; // t1
  const void *v7; // r1
  char *v8; // r5
  int v9; // r6
  int v10; // t1
  pthread_mutex_t *v11; // r0
  int nonce_fifo_interrupt; // r0
  int result; // r0

  doTestPatten = 1;
  startCheckNetworkJob = 0;
  pthread_mutex_lock(&reinit_mutex);
  dhash_acc_control = get_dhash_acc_control();
  v1 = (pthread_mutex_t *)chain_pic_buf;
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  v2 = (char *)&chip_last_freq;
  sleep(3u);
  v3 = get_dhash_acc_control();
  set_dhash_acc_control(v3 & 0xFFFFFFBF);
  sleep(2u);
  v4 = (pthread_mutex_t *)chain_pic_buf;
  v5 = dev + 4;
  do
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v5 + 4);
      v5 += 4;
      if ( v6 == 1 )
        break;
      v4 = (pthread_mutex_t *)((char *)v4 + 128);
      v2 += 256;
      if ( v4 == &nonce_mutex )
        goto LABEL_5;
    }
    v7 = v2;
    v2 += 256;
    v4 = (pthread_mutex_t *)((char *)memcpy(v4, v7, 128u) + 128);
  }
  while ( v4 != &nonce_mutex );
LABEL_5:
  v8 = (char *)&show_last_freq;
  set_asic_ticket_mask(0);
  clement_doTestBoardOnce(1);
  v9 = dev + 4;
  do
  {
    while ( 1 )
    {
      v10 = *(_DWORD *)(v9 + 4);
      v9 += 4;
      if ( v10 == 1 )
        break;
      v1 = (pthread_mutex_t *)((char *)v1 + 128);
      v8 += 256;
      if ( v1 == &nonce_mutex )
        goto LABEL_9;
    }
    v11 = v1;
    v1 = (pthread_mutex_t *)((char *)v1 + 128);
    memcpy(v11, v8, 128u);
    v8 += 256;
  }
  while ( v1 != &nonce_mutex );
LABEL_9:
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms();
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  clear_nonce_fifo();
  if ( opt_multi_version )
    set_time_out_control((*(_DWORD *)(dev + 72) * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(*(_DWORD *)(dev + 72) & 0x1FFFF | 0x80000000);
  doTestPatten = 0;
  pthread_mutex_unlock(&reinit_mutex);
  if ( last_job_buffer[0] != 23 )
    re_send_last_job_part_15();
  cgtime(&tv_send_job);
  result = cgtime(&tv_send);
  startCheckNetworkJob = 1;
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 7E57C: using guessed type int ticket_mask;
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 713488: using guessed type char doTestPatten;
// 80602C: using guessed type struct timeval tv_send_job;
// 806034: using guessed type struct timeval tv_send;
// 80603C: using guessed type char startCheckNetworkJob;
// 817C28: using guessed type int dev;

//----- (0003B3B8) --------------------------------------------------------
int doReInitTest()
{
  int dhash_acc_control; // r0
  pthread_mutex_t *v1; // r4
  char *v2; // r5
  int v3; // r0
  int v4; // r6
  int v5; // t1
  pthread_mutex_t *v6; // r0
  int nonce_fifo_interrupt; // r0
  int result; // r0

  startCheckNetworkJob = 0;
  doTestPatten = 1;
  pthread_mutex_lock(&reinit_mutex);
  dhash_acc_control = get_dhash_acc_control();
  v1 = (pthread_mutex_t *)chain_pic_buf;
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  v2 = (char *)&show_last_freq;
  sleep(3u);
  v3 = get_dhash_acc_control();
  set_dhash_acc_control(v3 & 0xFFFFFFBF);
  sleep(2u);
  v4 = dev + 4;
  do
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(v4 + 4);
      v4 += 4;
      if ( v5 == 1 )
        break;
      v1 = (pthread_mutex_t *)((char *)v1 + 128);
      v2 += 256;
      if ( v1 == &nonce_mutex )
        goto LABEL_5;
    }
    v6 = v1;
    v1 = (pthread_mutex_t *)((char *)v1 + 128);
    memcpy(v6, v2, 128u);
    v2 += 256;
  }
  while ( v1 != &nonce_mutex );
LABEL_5:
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  doTestPatten = 0;
  bitmain_reinit_test();
  doTestPatten = 1;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms();
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  clear_nonce_fifo();
  if ( opt_multi_version )
    set_time_out_control((*(_DWORD *)(dev + 72) * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(*(_DWORD *)(dev + 72) & 0x1FFFF | 0x80000000);
  doTestPatten = 0;
  pthread_mutex_unlock(&reinit_mutex);
  if ( last_job_buffer[0] != 23 )
    re_send_last_job_part_15();
  cgtime(&tv_send_job);
  result = cgtime(&tv_send);
  startCheckNetworkJob = 1;
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 7E57C: using guessed type int ticket_mask;
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 713488: using guessed type char doTestPatten;
// 80602C: using guessed type struct timeval tv_send_job;
// 806034: using guessed type struct timeval tv_send;
// 80603C: using guessed type char startCheckNetworkJob;
// 817C28: using guessed type int dev;

//----- (0003B518) --------------------------------------------------------
int __fastcall re_open_core(int a1)
{
  int v1; // r2
  pthread_mutex_t *v2; // r4
  int dhash_acc_control; // r0
  char *v4; // r5
  int v5; // r0
  int v6; // r7
  int v7; // t1
  pthread_mutex_t *v8; // r0
  int v9; // r4
  int v10; // r3
  int v11; // r4
  int v12; // r3
  int v13; // r7
  int v14; // r2
  FILE *v15; // r0
  FILE *v16; // r9
  FILE *v17; // r0
  FILE *v18; // r10
  FILE *v19; // r0
  FILE *v20; // r8
  int v21; // r4
  char v22; // r3
  char v23; // r1
  unsigned int v24; // r3
  int v25; // r4
  int v26; // r2
  int v27; // r4
  int v28; // r3
  int nonce_fifo_interrupt; // r0
  int i; // r7
  int v31; // r3
  int v32; // r4
  int v33; // r9
  unsigned __int8 v34; // r5
  int v35; // r1
  int v36; // r2
  int result; // r0
  FILE *v38; // r0
  FILE *v39; // r4
  FILE *v40; // r0
  FILE *v41; // r4
  int v42; // r3
  int v43; // r0
  int v44; // r0
  int v45; // r1
  int v46; // [sp+18h] [bp-850h]
  char s[2088]; // [sp+40h] [bp-828h] BYREF

  if ( (unsigned int)log_level > 3 )
  {
    v40 = fopen(log_file, "a+");
    v41 = v40;
    if ( v40 )
      fprintf(v40, "%s:%d:%s: re_open_core enter\n", "driver-btm-c5.c", 15642, "re_open_core");
    fclose(v41);
  }
  startCheckNetworkJob = 0;
  enable_read_temp = 0;
  doTestPatten = 1;
  pthread_mutex_lock(&reinit_mutex);
  v1 = dev;
  v2 = (pthread_mutex_t *)chain_pic_buf;
  *(_BYTE *)(dev + 21500) = 20;
  *(_DWORD *)(v1 + 4) = 655400;
  set_fan_control(655400);
  dhash_acc_control = get_dhash_acc_control();
  v4 = (char *)&show_last_freq;
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  sleep(3u);
  v5 = get_dhash_acc_control();
  set_dhash_acc_control(v5 & 0xFFFFFFBF);
  sleep(2u);
  v6 = dev + 4;
  do
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(v6 + 4);
      v6 += 4;
      if ( v7 == 1 )
        break;
      v2 = (pthread_mutex_t *)((char *)v2 + 128);
      v4 += 256;
      if ( &nonce_mutex == v2 )
        goto LABEL_6;
    }
    v8 = v2;
    v2 = (pthread_mutex_t *)((char *)v2 + 128);
    memcpy(v8, v4, 128u);
    v4 += 256;
  }
  while ( &nonce_mutex != v2 );
LABEL_6:
  v9 = 0;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  doTestPatten = 0;
  pthread_mutex_lock(&iic_mutex);
  memset((void *)dev, 0, 21616u);
  *(_DWORD *)dev = job_start_address_1;
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  set_reset_allhashboard(1);
  set_QN_write_data_command(-2139062257);
  sleep(2u);
  v10 = dev;
  *(_BYTE *)(dev + 21500) = 100;
  *(_DWORD *)(v10 + 4) = 3276800;
  set_fan_control(3276800);
  set_reset_allhashboard(1);
  *(_BYTE *)(dev + 21551) = 26;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  check_chain();
  do
  {
    while ( *(_DWORD *)(dev + 4 * (v9 + 2)) != 1 )
    {
      if ( ++v9 == 16 )
        goto LABEL_10;
    }
    chain_voltage_pic[v9] = write_EEPROM_iic(1, 1, 144, v9, 0);
    ++v9;
  }
  while ( v9 != 16 );
LABEL_10:
  pthread_mutex_unlock(&iic_mutex);
  quickly_set_to_highest_voltage();
  sleep(1u);
  set_reset_allhashboard(1);
  sleep(3u);
  set_reset_allhashboard(0);
  sleep(1u);
  if ( opt_multi_version )
  {
    v43 = get_dhash_acc_control();
    set_dhash_acc_control(v43 & 0xFFFF70DF | 0x8100);
  }
  cgsleep_ms();
  *(_BYTE *)(dev + 21548) = 114;
  v46 = 1;
  v11 = 0;
  check_asic_reg(0);
  cgsleep_ms();
  do
  {
    v12 = dev;
    if ( *(_DWORD *)(dev + 4 * (v11 + 2)) == 1 )
    {
      if ( (unsigned int)log_level > 3 )
      {
        v19 = fopen(log_file, "a+");
        v20 = v19;
        if ( v19 )
          fprintf(
            v19,
            "%s:%d:%s: Chain[J%d] has %d asic\n",
            "driver-btm-c5.c",
            15803,
            "re_open_core",
            v46,
            *(unsigned __int8 *)(dev + v11 + 21484));
        fclose(v20);
        v12 = dev;
      }
      v13 = 0;
      while ( 1 )
      {
        v14 = v12 + v11;
        if ( *(_BYTE *)(v12 + v11 + 21484) == 84 )
          break;
        if ( v13 == 20 )
        {
          if ( !*(_BYTE *)(v12 + v11 + 21484) )
            *(_DWORD *)(v12 + 4 * (v11 + 2)) = 0;
          break;
        }
        if ( (unsigned int)log_level > 3 )
        {
          v15 = fopen(log_file, "a+");
          v16 = v15;
          if ( v15 )
            fprintf(
              v15,
              "%s:%d:%s: i = %d, retry_count = %d, dev->chain_asic_num[i] = %d\n",
              "driver-btm-c5.c",
              15807,
              "re_open_core",
              v11,
              v13,
              *(unsigned __int8 *)(dev + v11 + 21484));
          fclose(v16);
          v14 = dev + v11;
        }
        *(_BYTE *)(v14 + 21484) = 0;
        ++v13;
        set_reset_hashboard(v11, 1);
        sleep(1u);
        pthread_mutex_lock(&iic_mutex);
        disable_pic_dac((unsigned __int8)v11);
        pthread_mutex_unlock(&iic_mutex);
        sleep(1u);
        pthread_mutex_lock(&iic_mutex);
        enable_pic_dac((unsigned __int8)v11);
        pthread_mutex_unlock(&iic_mutex);
        sleep(2u);
        set_reset_hashboard(v11, 0);
        sleep(2u);
        check_asic_reg_oneChain(v11, 0);
        if ( (unsigned int)log_level > 3 )
        {
          v17 = fopen(log_file, "a+");
          v18 = v17;
          if ( v17 )
            fprintf(
              v17,
              "%s:%d:%s: retry Chain[J%d] has %d asic\n",
              "driver-btm-c5.c",
              15830,
              "re_open_core",
              v46,
              *(unsigned __int8 *)(dev + v11 + 21484));
          fclose(v18);
        }
        v12 = dev;
      }
    }
    ++v11;
    ++v46;
  }
  while ( v11 != 16 );
  software_set_address();
  cgsleep_ms();
  if ( (byte_805F7C & 8) != 0 )
  {
    v42 = (unsigned __int16)word_805F84;
    *(_WORD *)(dev + 21571) = word_805F84;
    set_frequency(v42);
    sprintf((char *)(dev + 21573), "%u", *(unsigned __int16 *)(dev + 21571));
  }
  cgsleep_ms();
  v21 = dev;
  v22 = byte_805F7C;
  v23 = byte_805F82;
  *(_BYTE *)(dev + 21569) = (byte_805F7C & 2) != 0;
  *(_BYTE *)(v21 + 21570) = v23;
  if ( (v22 & 4) != 0 )
  {
    if ( word_805F8A )
    {
      v24 = HIBYTE(word_805F8A) + 1000 * (unsigned __int8)word_805F8A;
      *(_DWORD *)(v21 + 72) = v24;
    }
    else
    {
      v44 = calculate_core_number(*(unsigned __int8 *)(v21 + 21548));
      v21 = dev;
      v45 = (unsigned __int8)opt_debug;
      v24 = 90 * (*(unsigned __int8 *)(v21 + 21549) * (16777216 / v44) / *(unsigned __int16 *)(v21 + 21571)) / 100;
      *(_DWORD *)(dev + 72) = v24;
      if ( v45 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(s, 2048u, "dev->timeout = %d\n", v24);
        applog(7, s, 0);
        v21 = dev;
        v24 = *(_DWORD *)(dev + 72);
      }
    }
    if ( v24 > 131071 )
      *(_DWORD *)(v21 + 72) = 131071;
  }
  init_uart_baud();
  v25 = 0;
  cgsleep_ms();
  v26 = dev;
  do
  {
    while ( *(_DWORD *)(v26 + 4 * (v25 + 2)) != 1 || *(_BYTE *)(v26 + v25 + 21484) != 84 )
    {
      if ( ++v25 == 16 )
        goto LABEL_46;
    }
    calibration_sensor_offset(152, v25++);
    cgsleep_ms();
    v26 = dev;
  }
  while ( v25 != 16 );
LABEL_46:
  v27 = 0;
  set_time_out_control((*(_DWORD *)(v26 + 72) / 10u) & 0x1FFFF | 0x80000000);
  v28 = dev;
  *(_BYTE *)(dev + 21500) = 100;
  *(_DWORD *)(v28 + 4) = 3276800;
  set_fan_control(3276800);
  do
  {
    while ( *(_DWORD *)(dev + 4 * (v27 + 2)) != 1 )
    {
      if ( ++v27 == 16 )
        goto LABEL_50;
    }
    open_core_one_chain(v27++, 1);
    sleep(1u);
  }
  while ( v27 != 16 );
LABEL_50:
  doTestPatten = 1;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms();
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  if ( opt_multi_version )
    set_time_out_control((*(_DWORD *)(dev + 72) * opt_multi_version) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(*(_DWORD *)(dev + 72) & 0x1FFFF | 0x80000000);
  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      v31 = dev;
      if ( *(_DWORD *)(dev + 4 * (i + 2)) == 1 && *(char *)(dev + i + 1112) > 0 )
        break;
      if ( ++i == 16 )
        goto LABEL_59;
    }
    v32 = 0;
    v33 = 8 * i;
    v34 = 0;
    do
    {
      ++v34;
      set_baud_with_addr(*(_BYTE *)(v31 + 21551), 0, *(_BYTE *)(v31 + v33 + v32 + 1256), i, 1, 0, 1);
      v35 = *(unsigned __int8 *)(v32 + dev + v33 + 1256);
      v32 = v34;
      check_asic_reg_with_addr(28, v35, i);
      v31 = dev;
    }
    while ( v34 < *(char *)(dev + i + 1112) );
  }
LABEL_59:
  doTestPatten = 0;
  pthread_mutex_unlock(&reinit_mutex);
  clear_nonce_fifo();
  if ( last_job_buffer[0] != 23 )
    re_send_last_job_part_15();
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  v36 = dev;
  *(_BYTE *)(dev + 21500) = 20;
  *(_DWORD *)(v36 + 4) = 655400;
  startCheckNetworkJob = 1;
  enable_read_temp = 1;
  set_fan_control(655400);
  if ( a1 )
  {
    if ( !opt_fixed_freq )
      set_iic_power_to_higher_voltage();
  }
  else
  {
    set_working_voltage();
  }
  result = reCalculateAVG();
  if ( (unsigned int)log_level > 3 )
  {
    v38 = fopen(log_file, "a+");
    v39 = v38;
    if ( v38 )
      fprintf(v38, "%s:%d:%s: reopen core end\n", "driver-btm-c5.c", 16094, "re_open_core");
    return fclose(v39);
  }
  return result;
}
// 7DF98: using guessed type int opt_multi_version;
// 7E57C: using guessed type int ticket_mask;
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 80590: using guessed type char enable_read_temp;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 709398: using guessed type char opt_fixed_freq;
// 713488: using guessed type char doTestPatten;
// 805F7C: using guessed type char byte_805F7C;
// 805F82: using guessed type char byte_805F82;
// 805F84: using guessed type __int16 word_805F84;
// 805F8A: using guessed type __int16 word_805F8A;
// 80602C: using guessed type struct timeval tv_send_job;
// 806034: using guessed type struct timeval tv_send;
// 80603C: using guessed type char startCheckNetworkJob;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80B808: using guessed type int job_start_address_1;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (0003BCFC) --------------------------------------------------------
void __noreturn check_system_work()
{
  double v0; // d0
  FILE *RestartNum; // r5
  unsigned int *v2; // r3
  bool v3; // cc
  const char **v4; // r3
  int v5; // r5
  char *v6; // r4
  double v7; // d8
  int v8; // r3
  unsigned int v9; // r5
  int v10; // r3
  int v11; // r9
  int v12; // r8
  int v13; // lr
  int v14; // r7
  int v15; // r5
  int v16; // r5
  int v17; // r12
  int v18; // r11
  int v19; // r5
  int v20; // lr
  int v21; // r9
  int v22; // r3
  int v23; // r7
  int v24; // r1
  char v25; // r12
  int v26; // r3
  int v27; // r0
  _DWORD *v28; // r4
  int v29; // r2
  int v30; // r2
  int v31; // r11
  FILE *v32; // r0
  FILE *v33; // r4
  _BOOL4 v35; // r0
  unsigned int v36; // r3
  int runtime_hash_rate; // r5
  FILE *v38; // r0
  FILE *v39; // r4
  FILE *v40; // r0
  FILE *v41; // r4
  FILE *v42; // r0
  FILE *v43; // r4
  FILE *v44; // r0
  FILE *v45; // r4
  FILE *v46; // r0
  FILE *v47; // r4
  FILE *v48; // r0
  FILE *v49; // r4
  FILE *v50; // r0
  FILE *v51; // r4
  FILE *v52; // r0
  FILE *v53; // r0
  FILE *v54; // r4
  FILE *v55; // r0
  FILE *v56; // r4
  double v57; // [sp+10h] [bp-900h]
  _DWORD *v58; // [sp+1Ch] [bp-8F4h]
  int v59; // [sp+1Ch] [bp-8F4h]
  int v60; // [sp+2Ch] [bp-8E4h]
  char *format; // [sp+34h] [bp-8DCh]
  int v62; // [sp+48h] [bp-8C8h]
  int v63; // [sp+48h] [bp-8C8h]
  _DWORD *v64; // [sp+4Ch] [bp-8C4h]
  _BYTE *v65; // [sp+50h] [bp-8C0h]
  unsigned int i; // [sp+54h] [bp-8BCh]
  const char **v67; // [sp+5Ch] [bp-8B4h]
  unsigned int *v68; // [sp+60h] [bp-8B0h]
  int v69; // [sp+64h] [bp-8ACh]
  int v70; // [sp+68h] [bp-8A8h]
  unsigned int v71; // [sp+6Ch] [bp-8A4h]
  int v72; // [sp+74h] [bp-89Ch]
  unsigned int v73; // [sp+7Ch] [bp-894h]
  unsigned int v74; // [sp+80h] [bp-890h]
  unsigned int v75; // [sp+84h] [bp-88Ch]
  int v76; // [sp+88h] [bp-888h]
  _BOOL4 v77; // [sp+98h] [bp-878h]
  _BOOL4 v78; // [sp+9Ch] [bp-874h]
  int v79; // [sp+A0h] [bp-870h]
  timeval v80; // [sp+A8h] [bp-868h] BYREF
  struct timeval v81; // [sp+B0h] [bp-860h] BYREF
  struct timeval v82; // [sp+B8h] [bp-858h] BYREF
  timeval v83; // [sp+C0h] [bp-850h] BYREF
  char s[2120]; // [sp+C8h] [bp-848h] BYREF

  cgtime(&v81);
  cgtime(&v82);
  copy_time(&v80, &v81);
  copy_time(&v83, &v82);
  RestartNum = readRestartNum();
  LOWORD(v2) = (unsigned __int16)&log_level;
  if ( (int)RestartNum <= 0 )
  {
    HIWORD(v2) = (unsigned int)&log_level >> 16;
    v68 = v2;
    v67 = (const char **)&log_file;
  }
  else
  {
    HIWORD(v2) = (unsigned int)&log_level >> 16;
    v68 = v2;
    v3 = *v2 > 3;
    LOWORD(v4) = (unsigned __int16)&log_file;
    if ( v3 )
    {
      HIWORD(v4) = (unsigned int)&log_file >> 16;
      v67 = v4;
      v46 = fopen(*v4, "a+");
      v47 = v46;
      if ( v46 )
        fprintf(
          v46,
          "%s:%d:%s: restartNum = %d , auto-reinit enabled...\n",
          "driver-btm-c5.c",
          10338,
          "check_system_work",
          RestartNum);
      fclose(v47);
    }
    else
    {
      HIWORD(v4) = (unsigned int)&log_file >> 16;
      v67 = v4;
    }
  }
  v75 = 0;
  v74 = 0;
  v79 = 0;
  v73 = 0;
  v76 = 0;
  v78 = 0;
  v77 = 0;
  v72 = 0;
  v71 = 0;
  for ( i = 1; ; ++i )
  {
    while ( 1 )
    {
      set_led(global_stop);
      if ( !doTestPatten )
        break;
      cgsleep_ms();
    }
    if ( i == 30 * (i / 30) )
    {
      v5 = v78;
      if ( !v78 && !global_stop )
      {
        if ( v74 <= 9 )
        {
          v74 = (unsigned __int8)(v74 + 1);
        }
        else
        {
          v6 = displayed_rate;
          v7 = 0.0;
          do
          {
            while ( 1 )
            {
              v8 = v5 + 2;
              ++v5;
              if ( *(_DWORD *)(dev + 4 * v8) == 1 )
              {
                if ( *v6 )
                  break;
              }
              v6 += 32;
              if ( v5 == 16 )
                goto LABEL_15;
            }
            strtod(v6, 0);
            v7 = v7 + v0;
            v6 += 32;
          }
          while ( v5 != 16 );
LABEL_15:
          if ( v7 < (double)ideal_total_hash_rate * 0.92 )
          {
            ++v73;
            if ( v73 == 3 * (v73 / 3) )
            {
              ++v76;
              if ( *v68 > 3 )
              {
                v40 = fopen(*v67, "a+");
                v41 = v40;
                if ( v40 )
                  fprintf(
                    v40,
                    "%s:%d:%s: re_open_core_times: %d, total_rate:%f, ideal_total_hash_rate:%d\n",
                    "driver-btm-c5.c",
                    10380,
                    "check_system_work",
                    v76,
                    v7,
                    ideal_total_hash_rate);
                fclose(v41);
              }
              v74 = 0;
              re_open_core(v79);
            }
            v78 = v73 > 60;
          }
          else
          {
            v73 = 0;
          }
        }
      }
    }
    if ( i == 120 )
    {
      if ( opt_fixed_freq )
        goto LABEL_29;
      v35 = if_avg_hash_ok();
      v36 = *v68;
      if ( v35 )
      {
        if ( v36 > 3 )
        {
          v52 = fopen(*v67, "a+");
          v33 = v52;
          if ( v52 )
            fprintf(v52, "%s:%d:%s: hash rate is ok now\n", "driver-btm-c5.c", 10399, "check_system_work");
          goto LABEL_89;
        }
      }
      else
      {
        if ( v36 > 1 )
        {
          v53 = fopen(*v67, "a+");
          v54 = v53;
          if ( v53 )
            fprintf(v53, "%s:%d:%s: hash rate is low...\n", "driver-btm-c5.c", 10404, "check_system_work");
          fclose(v54);
        }
        if ( bring_up_pcb_temp <= 34 )
        {
          ++v75;
          re_open_core(1);
          if ( *v68 > 3 )
          {
            v55 = fopen(*v67, "a+");
            v56 = v55;
            if ( v55 )
              fprintf(v55, "%s:%d:%s: re-open core %d times\n", "driver-btm-c5.c", 10417, "check_system_work", v75);
            fclose(v56);
          }
          v72 = 0;
          v79 = 1;
          is_working_in_low_temperature = 1;
          goto LABEL_29;
        }
      }
      v71 = 1;
    }
    else
    {
      if ( i - 180 <= 1619 && !(i % 180) )
      {
        runtime_hash_rate = get_runtime_hash_rate();
        getAVGhashrate();
        if ( *v68 > 4 )
        {
          v42 = fopen(*v67, "a+");
          v43 = v42;
          if ( v42 )
            fprintf(
              v42,
              "%s:%d:%s: run time hash = %f, avg hash = %f\n",
              "driver-btm-c5.c",
              10435,
              "check_system_work",
              v0,
              v57);
          fclose(v43);
        }
        if ( runtime_hash_rate
          && v0 < (double)ideal_total_hash_rate * 0.9
          && v0 / (double)(unsigned int)runtime_hash_rate < 0.95 )
        {
          reCalculateAVG();
        }
      }
      if ( (i == 360) <= v71 )
        goto LABEL_29;
      if ( *v68 > 3 )
      {
        v38 = fopen(*v67, "a+");
        v39 = v38;
        if ( v38 )
          fprintf(v38, "%s:%d:%s: checking hash again\n", "driver-btm-c5.c", 10445, "check_system_work");
        fclose(v39);
      }
      if ( if_avg_hash_ok() )
      {
        if ( *v68 > 3 )
        {
          v32 = fopen(*v67, "a+");
          v33 = v32;
          if ( v32 )
            fprintf(v32, "%s:%d:%s: hash rate is ok now\n", "driver-btm-c5.c", 10448, "check_system_work");
LABEL_89:
          v71 = 1;
          fclose(v33);
          goto LABEL_29;
        }
        v71 = 1;
      }
      else
      {
        if ( v75 <= 1 )
        {
          v9 = 0;
          i = 100;
          v71 = 0;
          goto LABEL_30;
        }
        v71 = 0;
      }
    }
LABEL_29:
    v9 = i % 10;
LABEL_30:
    if ( v77 || opt_fixed_freq )
      goto LABEL_36;
    if ( !(i % 900) )
    {
      if ( *v68 > 4 )
      {
        v44 = fopen(*v67, "a+");
        v45 = v44;
        if ( v44 )
          fprintf(
            v44,
            "%s:%d:%s: check if the hash rate is too high...\n",
            "driver-btm-c5.c",
            10463,
            "check_system_work");
        fclose(v45);
      }
      if ( check_avg_rate() )
        v77 = ok_num_14263++ > 5;
      else
        ok_num_14263 = 0;
LABEL_36:
      if ( v72 || opt_fixed_freq )
        goto LABEL_38;
      goto LABEL_77;
    }
    if ( v72 )
      goto LABEL_38;
LABEL_77:
    if ( i != 60 * (i / 60) )
      goto LABEL_80;
    if ( *v68 > 4 )
    {
      v48 = fopen(*v67, "a+");
      v49 = v48;
      if ( v48 )
        fprintf(
          v48,
          "%s:%d:%s: voltage check, last_testpatten_highest_pcb_temp = %d, critical_value = %d\n",
          "driver-btm-c5.c",
          10499,
          "check_system_work",
          last_testpatten_highest_pcb_temp,
          47);
      fclose(v49);
    }
    if ( last_testpatten_highest_pcb_temp <= 47 )
    {
LABEL_80:
      v72 = 0;
      if ( v9 )
        goto LABEL_39;
      goto LABEL_81;
    }
    set_working_voltage();
    if ( *v68 > 3 )
    {
      v50 = fopen(*v67, "a+");
      v51 = v50;
      if ( v50 )
        fprintf(v50, "%s:%d:%s: voltage_check_done\n", "driver-btm-c5.c", 10505, "check_system_work");
      fclose(v51);
    }
    v72 = 1;
    is_working_in_low_temperature = 0;
LABEL_38:
    if ( v9 )
      goto LABEL_39;
LABEL_81:
    xadc_check();
LABEL_39:
    cgtime(&v81);
    cgtime(&v82);
    v10 = v81.tv_sec - v80.tv_sec;
    if ( v81.tv_usec - v80.tv_usec < 0 )
      --v10;
    if ( v10 <= 300 )
    {
      if ( v10 <= 60 && (v10 <= 30 || !(global_stop & 1)) )
        goto LABEL_86;
    }
    else
    {
      check_temp_offside = 1;
    }
    v11 = 0;
    v12 = 0;
    v62 = 0;
    v13 = nonce_times;
    do
    {
      if ( *(_DWORD *)(dev + 4 * (v12 + 2)) )
      {
        v62 += *(unsigned __int8 *)(dev + v12 + 21484);
        if ( *(_BYTE *)(dev + v12 + 21484) )
        {
          v14 = 0;
          v15 = dev;
          do
          {
            v16 = v15 + 8 * ((v12 << 7) + v14);
            v17 = *(_DWORD *)(v16 + 2816);
            v18 = v16 + 2812;
            v58 = &nonce_num[15360 * v12 + 120 * v14 + 2 * (v13 % 60)];
            *v58 = *(_DWORD *)(v16 + 2812);
            v58[1] = v17;
            v19 = *(_DWORD *)(v16 + 2812);
            v11 += v19;
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                s,
                2048u,
                "%s: chain %d asic %d asic_nonce_num %d",
                "check_system_work",
                v12,
                v14,
                v19,
                *(_DWORD *)(v18 + 4));
              applog(7, s, 0);
              v13 = nonce_times;
            }
            ++v14;
            v15 = dev;
          }
          while ( *(unsigned __int8 *)(dev + v12 + 21484) > v14 );
        }
      }
      ++v12;
    }
    while ( v12 != 16 );
    nonce_times = v13 + 1;
    memset(nonce_num10_string, 0, 4096u);
    memset(nonce_num30_string, 0, sizeof(nonce_num30_string));
    memset(nonce_num60_string, 0, sizeof(nonce_num60_string));
    get_lastn_nonce_num(nonce_num10_string, 10);
    get_lastn_nonce_num(nonce_num30_string, 30);
    get_lastn_nonce_num(nonce_num60_string, 60);
    if ( v62 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "%s: avg_num %d asic_num %d", "check_system_work", v11, v62);
      applog(7, s, 0);
    }
    format = 0;
    v20 = dev;
    v60 = (unsigned __int8)status_error;
    v64 = &x_time;
    v65 = (_BYTE *)(dev + 21484);
    v63 = dev + 4;
    v69 = dev + 68;
    v21 = nonce_times % 60 + 59;
    if ( nonce_times % 60 - 1 >= 0 )
      v21 = nonce_times % 60 - 1;
    do
    {
      v22 = *(_DWORD *)(v63 + 4);
      v63 += 4;
      if ( v22 )
      {
        v23 = (unsigned __int8)*v65;
        if ( *v65 )
        {
          v24 = 0;
          v59 = (unsigned __int8)*v65;
          v70 = 16 * (_DWORD)format;
          v25 = 0;
          v26 = 0;
          v27 = v20 + 136 * (_DWORD)format;
          v28 = v64;
          do
          {
            if ( (v26 & 7) == 0 )
              v25 = 32;
            v31 = v27 + v24 + v26;
            if ( (v26 & 7) == 0 )
              ++v24;
            if ( (v26 & 7) == 0 )
              *(_BYTE *)(v31 + 19196) = v25;
            if ( (int)nonce_num[15360 * (_DWORD)format + 120 * v26 + 2 * v21] > 1 )
            {
              *(_BYTE *)(v27 + v24 + v26 + 19196) = 111;
            }
            else
            {
              v25 = 111;
              *(_BYTE *)(v27 + v24 + v26 + 19196) = 111;
              if ( !v60 )
                ++*v28;
            }
            v29 = ((_DWORD)format << 7) + v26++;
            ++v28;
            v30 = v20 + 8 * (v29 + 351);
            *(_DWORD *)(v30 + 4) = 0;
            *(_DWORD *)(v30 + 8) = 0;
          }
          while ( v26 != v59 );
          v23 = v59 + v24;
        }
        else
        {
          v70 = 16 * (_DWORD)format;
        }
        *(_BYTE *)(v23 + v20 + 8 * (_DWORD)&format[v70] + 19196) = 0;
      }
      ++format;
      ++v65;
      v64 += 256;
    }
    while ( v69 != v63 );
    copy_time(&v80, &v81);
LABEL_86:
    cgsleep_ms();
  }
}
// 3BEA2: variable 'v0' is possibly undefined
// 3C552: variable 'v57' is possibly undefined
// 3BCFC: using guessed type void __noreturn check_system_work();
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805A8: using guessed type int opt_log_level;
// 704AB8: using guessed type char status_error;
// 709398: using guessed type char opt_fixed_freq;
// 70943D: using guessed type char is_working_in_low_temperature;
// 709440: using guessed type int ideal_total_hash_rate;
// 713488: using guessed type char doTestPatten;
// 715F74: using guessed type int nonce_times;
// 715F78: using guessed type _DWORD nonce_num[245098];
// 806084: using guessed type int last_testpatten_highest_pcb_temp;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 817C28: using guessed type int dev;

//----- (0003C754) --------------------------------------------------------
int bitmain_core_reInit()
{
  int dhash_acc_control; // r0
  int v1; // r0
  int nonce_fifo_interrupt; // r0
  int result; // r0
  FILE *v4; // r0
  FILE *v5; // r4

  doTestPatten = 1;
  pthread_mutex_lock(&reinit_mutex);
  startCheckNetworkJob = 0;
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
  sleep(3u);
  v1 = get_dhash_acc_control();
  set_dhash_acc_control(v1 & 0xFFFFFFBF);
  sleep(2u);
  open_core(1);
  if ( (unsigned int)log_level > 3 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: bitmain_core_reInit open_core over\n", "driver-btm-c5.c", 16112, "bitmain_core_reInit");
    fclose(v5);
  }
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  set_asic_ticket_mask(ticket_mask);
  set_hcnt(0);
  set_sno(0);
  cgsleep_ms();
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  doTestPatten = 0;
  pthread_mutex_unlock(&reinit_mutex);
  if ( last_job_buffer[0] != 23 )
    re_send_last_job_part_15();
  cgtime(&tv_send_job);
  result = cgtime(&tv_send);
  startCheckNetworkJob = 1;
  return result;
}
// 7E57C: using guessed type int ticket_mask;
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 713488: using guessed type char doTestPatten;
// 80602C: using guessed type struct timeval tv_send_job;
// 806034: using guessed type struct timeval tv_send;
// 80603C: using guessed type char startCheckNetworkJob;

//----- (0003C874) --------------------------------------------------------
void processTEST()
{
  FILE *TestID; // r0
  FILE *v1; // r4
  int v2; // r5
  int v3; // r0
  int v4; // r4
  FILE *v5; // r0
  FILE *v6; // r9
  unsigned int v7; // s15
  FILE *v8; // r0
  FILE *v9; // r4
  FILE *v10; // r0
  FILE *v11; // r0
  int v12; // r5
  int v13; // r0
  int v14; // r4
  FILE *v15; // r0
  FILE *v16; // r9
  unsigned int v17; // s15
  FILE *v18; // r0
  FILE *v19; // r0
  int v20; // r4
  int v21; // r5
  int v22; // r11
  FILE *v23; // r0
  FILE *v24; // r0
  FILE *v25; // r4
  FILE *v26; // r0
  FILE *v27; // r0
  FILE *v28; // r5
  FILE *v29; // r0
  FILE *v30; // r5
  FILE *v31; // r0
  FILE *v32; // r9
  FILE *v33; // r0
  FILE *v34; // r0
  FILE *v35; // r9
  FILE *v36; // r0
  FILE *v37; // r4
  FILE *v38; // r0
  FILE *v39; // r0
  FILE *v40; // r5
  FILE *v41; // r0
  FILE *v42; // r5
  FILE *v43; // r0
  FILE *v44; // r5
  FILE *v45; // r4
  int crc_count; // r0
  FILE *v47; // r0
  FILE *v48; // r5
  FILE *stream; // [sp+14h] [bp-4Ch]
  char s[72]; // [sp+18h] [bp-48h] BYREF

  TestID = readTestID();
  v1 = TestID;
  if ( TestID == (FILE *)11 )
  {
    saveTestID(0);
    if ( (unsigned int)log_level > 3 )
    {
      v27 = fopen(log_file, "a+");
      v28 = v27;
      if ( v27 )
        fprintf(v27, "%s:%d:%s: get TEST ID=%d do 8xPatten test\n", "driver-btm-c5.c", 7746, "processTEST", 11);
      fclose(v28);
    }
    do8xPattenTest();
    return;
  }
  if ( TestID == (FILE *)12 )
  {
    saveTestID(0);
    if ( (unsigned int)log_level > 3 )
    {
      v39 = fopen(log_file, "a+");
      v40 = v39;
      if ( v39 )
        fprintf(
          v39,
          "%s:%d:%s: get TEST ID=%d do bitmain_core_reInit test\n",
          "driver-btm-c5.c",
          7755,
          "processTEST",
          v1);
      fclose(v40);
    }
    bitmain_core_reInit();
    reCalculateAVG();
    if ( (unsigned int)log_level > 3 )
    {
      v10 = fopen(log_file, "a+");
      v9 = v10;
      if ( v10 )
        fprintf(v10, "%s:%d:%s: Done bitmain_core_reInit test\n", "driver-btm-c5.c", 7760, "processTEST");
      goto LABEL_25;
    }
    return;
  }
  if ( TestID == (FILE *)13 )
  {
    saveTestID(0);
    if ( (unsigned int)log_level > 3 )
    {
      v41 = fopen(log_file, "a+");
      v42 = v41;
      if ( v41 )
        fprintf(v41, "%s:%d:%s: get TEST ID=%d do doReInitTest test\n", "driver-btm-c5.c", 7767, "processTEST", v1);
      fclose(v42);
    }
    doReInitTest();
    reCalculateAVG();
    if ( (unsigned int)log_level > 3 )
    {
      v19 = fopen(log_file, "a+");
      v9 = v19;
      if ( v19 )
        fprintf(v19, "%s:%d:%s: Done doReInitTest test\n", "driver-btm-c5.c", 7772, "processTEST");
      goto LABEL_25;
    }
    return;
  }
  if ( TestID == (FILE *)14 )
  {
    saveTestID(0);
    if ( (unsigned int)log_level > 3 )
    {
      v43 = fopen(log_file, "a+");
      v44 = v43;
      if ( v43 )
        fprintf(v43, "%s:%d:%s: get TEST ID=%d do do get asicnum\n", "driver-btm-c5.c", 7779, "processTEST", v1);
      fclose(v44);
    }
    v20 = 1;
    test_show_register = 1;
    reset_crc_count(1);
    do
    {
      v21 = v20 + 1;
      v22 = v20 - 1;
      if ( *(_DWORD *)(dev + 4 * (v20 + 1)) == 1 )
      {
        *(_BYTE *)(dev + v22 + 21484) = 0;
        check_asic_reg_oneChain_test(v20 - 1, 0);
        if ( (unsigned int)log_level > 3 )
        {
          v23 = fopen(log_file, "a+");
          stream = v23;
          if ( v23 )
            fprintf(
              v23,
              "%s:%d:%s: Chain[J%d] has %d asic\n",
              "driver-btm-c5.c",
              7791,
              "processTEST",
              v20,
              *(unsigned __int8 *)(dev + v22 + 21484));
          fclose(stream);
        }
      }
      ++v20;
    }
    while ( v21 != 17 );
    if ( (unsigned int)log_level > 3 )
    {
      v45 = fopen(log_file, "a+");
      if ( v45 )
      {
        crc_count = get_crc_count();
        fprintf(v45, "%s:%d:%s: test asicnum CRC error counter=%d\n", "driver-btm-c5.c", 7795, "processTEST", crc_count);
      }
      fclose(v45);
    }
    reset_crc_count(0);
    test_show_register = 0;
    if ( (unsigned int)log_level > 3 )
    {
      v24 = fopen(log_file, "a+");
      v9 = v24;
      if ( v24 )
        fprintf(v24, "%s:%d:%s: Done do get asicnum\n", "driver-btm-c5.c", 7800, "processTEST");
      goto LABEL_25;
    }
    return;
  }
  if ( TestID == (FILE *)15 )
  {
    saveTestID(0);
    if ( (unsigned int)log_level > 3 )
    {
      v47 = fopen(log_file, "a+");
      v48 = v47;
      if ( v47 )
        fprintf(v47, "%s:%d:%s: get TEST ID=%d do reCalculateAVG test\n", "driver-btm-c5.c", 7807, "processTEST", v1);
      fclose(v48);
    }
    reCalculateAVG();
    if ( (unsigned int)log_level > 3 )
    {
      v11 = fopen(log_file, "a+");
      v9 = v11;
      if ( v11 )
        fprintf(v11, "%s:%d:%s: Done reCalculateAVG test\n", "driver-btm-c5.c", 7811, "processTEST");
      goto LABEL_25;
    }
    return;
  }
  if ( TestID == (FILE *)16 )
  {
    saveTestID(0);
    if ( (unsigned int)log_level > 3 )
    {
      v29 = fopen(log_file, "a+");
      v30 = v29;
      if ( v29 )
        fprintf(
          v29,
          "%s:%d:%s: get TEST ID=%d DUMP MODE : to show TM and HCN.\n",
          "driver-btm-c5.c",
          7817,
          "processTEST",
          v1);
      fclose(v30);
    }
    check_asic_reg(24);
    check_asic_reg(20);
    check_asic_reg(16);
    return;
  }
  if ( TestID == (FILE *)17 )
  {
    saveTestID(0);
    v25 = fopen("/etc/config/log_level", "rb");
    if ( v25 )
    {
      memset(s, 0, 32u);
      fread(s, 1u, 32u, v25);
      fclose(v25);
      log_level = strtol(s, 0, 10);
      if ( (unsigned int)log_level > 1 )
      {
        v26 = fopen(log_file, "a+");
        v9 = v26;
        if ( v26 )
          fprintf(v26, "%s:%d:%s: log level set to %d\n", "driver-btm-c5.c", 7837, "processTEST", log_level);
        goto LABEL_25;
      }
    }
    return;
  }
  if ( TestID == (FILE *)18 )
  {
    saveTestID(0);
    v37 = fopen("/etc/config/ideal_hash", "rb");
    if ( v37 )
    {
      memset(s, 0, 32u);
      fread(s, 1u, 32u, v37);
      fclose(v37);
      ideal_total_hash_rate = strtol(s, 0, 10);
      if ( (unsigned int)log_level > 1 )
      {
        v38 = fopen(log_file, "a+");
        v9 = v38;
        if ( v38 )
          fprintf(
            v38,
            "%s:%d:%s: ideal_hash set to %d\n",
            "driver-btm-c5.c",
            7854,
            "processTEST",
            ideal_total_hash_rate);
        goto LABEL_25;
      }
    }
    return;
  }
  if ( TestID == (FILE *)19 )
  {
    get_avg_voltage();
    return;
  }
  if ( TestID == (FILE *)20 )
    return;
  if ( (unsigned int)&TestID[-1]._markers + 3 <= 15 )
  {
    saveTestID(0);
    v12 = (int)v1 % 100;
    if ( (unsigned int)log_level > 3 )
    {
      v31 = fopen(log_file, "a+");
      v32 = v31;
      if ( v31 )
        fprintf(
          v31,
          "%s:%d:%s: get TEST ID=%d up voltage 0.1V on Chain[J%d]\n",
          "driver-btm-c5.c",
          7883,
          "processTEST",
          v1,
          v12);
      fclose(v32);
      if ( *(_DWORD *)(dev + 4 * (v12 + 1)) != 1 )
      {
        if ( (unsigned int)log_level > 3 )
        {
          v33 = fopen(log_file, "a+");
          v9 = v33;
          if ( v33 )
            fprintf(v33, "%s:%d:%s: There is hashboard on Chain[J%d]\n", "driver-btm-c5.c", 7903, "processTEST", v12);
          goto LABEL_25;
        }
        return;
      }
    }
    else if ( *(_DWORD *)(dev + 4 * (v12 + 1)) != 1 )
    {
      return;
    }
    v13 = write_EEPROM_iic(1, 1, 144, v12 - 1, 0);
    if ( (unsigned int)log_level > 3 )
    {
      v14 = 10 * ((int)((364.0704 / ((double)v13 + 30.72) + 32.79) * 100.0 / 4.75) / 10);
      v15 = fopen(log_file, "a+");
      v16 = v15;
      if ( v15 )
        fprintf(
          v15,
          "%s:%d:%s: Try to up 0.1V on chain[J%d] from vol=%d to %d...\n",
          "driver-btm-c5.c",
          7894,
          "processTEST",
          v12,
          v14,
          v14 + 10);
      fclose(v16);
      v17 = (unsigned int)(364.0704 / ((double)(v14 + 10) * 4.75 / 100.0 - 32.79) - 30.72);
      if ( (unsigned int)log_level > 3 )
      {
        v18 = fopen(log_file, "a+");
        v9 = v18;
        if ( v18 )
          fprintf(
            v18,
            "%s:%d:%s: now set pic voltage=%d on chain[J%d]\n",
            "driver-btm-c5.c",
            7897,
            "processTEST",
            (unsigned __int8)v17,
            v12);
        goto LABEL_25;
      }
    }
  }
  else
  {
    if ( (unsigned int)&TestID[-2].__pad4 + 3 > 15 )
      return;
    saveTestID(0);
    v2 = (int)v1 % 100;
    if ( (unsigned int)log_level <= 3 )
    {
      if ( *(_DWORD *)(dev + 4 * (v2 + 1)) != 1 )
        return;
LABEL_15:
      v3 = write_EEPROM_iic(1, 1, 144, v2 - 1, 0);
      if ( (unsigned int)log_level > 3 )
      {
        v4 = 10 * ((int)((364.0704 / ((double)v3 + 30.72) + 32.79) * 100.0 / 4.75) / 10);
        v5 = fopen(log_file, "a+");
        v6 = v5;
        if ( v5 )
          fprintf(
            v5,
            "%s:%d:%s: Try to down 0.1V on chain[J%d] from vol=%d to %d...\n",
            "driver-btm-c5.c",
            7925,
            "processTEST",
            v2,
            v4,
            v4 - 10);
        fclose(v6);
        v7 = (unsigned int)(364.0704 / ((double)(v4 - 10) * 4.75 / 100.0 - 32.79) - 30.72);
        if ( (unsigned int)log_level > 3 )
        {
          v8 = fopen(log_file, "a+");
          v9 = v8;
          if ( v8 )
            fprintf(
              v8,
              "%s:%d:%s: now set pic voltage=%d on chain[J%d]\n",
              "driver-btm-c5.c",
              7928,
              "processTEST",
              (unsigned __int8)v7,
              v2);
LABEL_25:
          fclose(v9);
          return;
        }
      }
      return;
    }
    v34 = fopen(log_file, "a+");
    v35 = v34;
    if ( v34 )
      fprintf(
        v34,
        "%s:%d:%s: get TEST ID=%d down voltage 0.1V on Chain[J%d]\n",
        "driver-btm-c5.c",
        7914,
        "processTEST",
        v1,
        v2);
    fclose(v35);
    if ( *(_DWORD *)(dev + 4 * (v2 + 1)) == 1 )
      goto LABEL_15;
    if ( (unsigned int)log_level > 3 )
    {
      v36 = fopen(log_file, "a+");
      v9 = v36;
      if ( v36 )
        fprintf(v36, "%s:%d:%s: There is no hashboard on Chain[J%d]\n", "driver-btm-c5.c", 7934, "processTEST", v2);
      goto LABEL_25;
    }
  }
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 709440: using guessed type int ideal_total_hash_rate;
// 71348A: using guessed type char test_show_register;
// 817C28: using guessed type int dev;

//----- (0003D294) --------------------------------------------------------
void __noreturn read_temp_func()
{
  _DWORD *v0; // r3
  int v1; // r6
  int v2; // r10
  int v3; // r5
  int v4; // r4
  int v5; // r2
  int v6; // r8
  int v7; // r0
  bool v8; // cc
  int v9; // r0
  int v10; // r7
  __int16 remote; // r0
  int v12; // lr
  int v13; // r2
  int v14; // r3
  int v15; // r2
  int v16; // r0
  int v17; // r8
  int v18; // r2
  int v19; // r7
  _DWORD *v20; // r1
  int v21; // r1
  int v22; // r7
  int v23; // r2
  int v24; // r2
  int v25; // r2
  int v26; // r0
  FILE *v27; // r0
  FILE *v28; // r8
  FILE *v29; // r0
  FILE *v30; // r8
  FILE *v31; // r0
  int v32; // r1
  __int16 v33; // r4
  int v34; // r0
  __int16 v35; // lr
  __int16 v36; // r2
  bool v37; // r8
  int v38; // r12
  _WORD *v39; // r7
  int v40; // lr
  int v41; // r2
  int v42; // r4
  int v43; // r12
  int v44; // r7
  int v45; // r4
  _BOOL4 v46; // r0
  int v47; // r3
  _BOOL4 v48; // r0
  int v49; // r3
  int v50; // r2
  int v51; // r3
  int v52; // r3
  int v53; // r2
  int v54; // r5
  int v55; // r2
  int crc_count; // r0
  FILE *v57; // r0
  FILE *v58; // r4
  int v59; // r3
  int v60; // r2
  const char *v61; // r5
  int v62; // r3
  int v63; // r3
  int v64; // r4
  int v65; // r0
  int v66; // r1
  int v67; // r2
  int v68; // r3
  int *v69; // r5
  int v70; // r0
  int v71; // r1
  int v72; // r2
  int v73; // r3
  int v74; // r1
  FILE *v75; // r0
  FILE *v76; // r4
  FILE *v77; // r0
  FILE *v78; // r4
  int v79; // [sp+1Ch] [bp-494h]
  int v80; // [sp+20h] [bp-490h]
  int v81; // [sp+24h] [bp-48Ch]
  int v82; // [sp+28h] [bp-488h]
  int v83; // [sp+2Ch] [bp-484h]
  int v84; // [sp+40h] [bp-470h]
  int v85; // [sp+48h] [bp-468h]
  int v86; // [sp+50h] [bp-460h]
  int v87; // [sp+54h] [bp-45Ch]
  FILE *stream; // [sp+58h] [bp-458h]
  int v89; // [sp+64h] [bp-44Ch]
  char v90; // [sp+68h] [bp-448h]
  int v91; // [sp+70h] [bp-440h]
  int v92; // [sp+74h] [bp-43Ch]
  int v93; // [sp+80h] [bp-430h]
  __int16 v94; // [sp+84h] [bp-42Ch]
  char s[1064]; // [sp+88h] [bp-428h] BYREF

  v92 = 0;
  v91 = 0;
  v89 = 0;
  clearTempLogFile();
  while ( 1 )
  {
    while ( 1 )
    {
      v90 = enable_read_temp;
      if ( enable_read_temp )
        break;
      sleep(1u);
    }
    clearTempLogFile();
    strcpy(s, "do read_temp_func once...\n");
    writeLogFile(s);
    pthread_mutex_lock(&opencore_readtemp_mutex);
    if ( doTestPatten )
    {
      usleep(100000u);
    }
    else if ( check_asic_reg(8) )
    {
      showAllBadRTInfo();
    }
    else
    {
      strcpy(s, "Error: check_asic_reg 0x08 timeout\n");
      writeInitLogFile(s);
    }
    v85 = -100;
    v87 = -100;
    v86 = -100;
    strcpy(s, "Done check_asic_reg\n");
    writeLogFile(s);
    v0 = (_DWORD *)dev;
    v84 = 0;
    v1 = 0;
    v93 = 0;
    v94 = 0;
    do
    {
      while ( v0[v1 + 2] != 1 )
      {
        if ( ++v1 == 16 )
          goto LABEL_77;
      }
      if ( (unsigned int)log_level > 5 )
      {
        v57 = fopen(log_file, "a+");
        v58 = v57;
        if ( v57 )
          fprintf(v57, "%s:%d:%s: do read temp on Chain[%d]\n", "driver-btm-c5.c", 8477, "read_temp_func", v1);
        fclose(v58);
        v0 = (_DWORD *)dev;
        if ( *(char *)(dev + v1 + 1112) <= 0 )
          goto LABEL_102;
LABEL_11:
        v2 = -100;
        v80 = 1000;
        v3 = 8 * v1;
        v81 = -100;
        v4 = 0;
        v79 = -100;
        v82 = 1000;
        v83 = 1000;
        while ( 2 )
        {
          if ( (unsigned int)log_level > 5 )
          {
            v29 = fopen(log_file, "a+");
            v30 = v29;
            if ( v29 )
              fprintf(
                v29,
                "%s:%d:%s: Chain[%d] Chip[%d] TempTypeID=%02x middle offset=%d\n",
                "driver-btm-c5.c",
                8492,
                "read_temp_func",
                v1,
                (*(unsigned __int8 *)(dev + 8 * v1 + v4 + 1256) >> 2) + 1,
                *(unsigned __int8 *)(dev + 8 * v1 + v4 + 1128),
                middle_Offset[8 * v1 + v4]);
            fclose(v30);
          }
          v26 = check_reg_temp(DEVICEADDR[v1], 0, 0, 0, *(_BYTE *)(dev + v3 + v4 + 1256), v1);
          if ( v26 )
          {
            v5 = dev;
            v6 = v3 + v4 + 173;
            v7 = (__int16)((unsigned __int8)v26 - 64);
            v8 = (unsigned int)log_level > 5;
            *(_WORD *)(dev + 8 * v6) = v7;
            if ( v8 )
            {
              v31 = fopen(log_file, "a+");
              stream = v31;
              if ( v31 )
                fprintf(
                  v31,
                  "%s:%d:%s: Chain[%d] Chip[%d] local Temp=%d\n",
                  "driver-btm-c5.c",
                  8499,
                  "read_temp_func",
                  v1,
                  *(unsigned __int8 *)(dev + v3 + v4 + 1256),
                  *(__int16 *)(dev + 8 * v6));
              fclose(stream);
              v5 = dev;
              v7 = *(__int16 *)(dev + 8 * (v3 + v4 + 173));
            }
            sprintf(s, "Chain[%d] Chip[%d] pcb temperature=%d\n", v1, *(unsigned __int8 *)(v5 + v3 + v4 + 1256), v7);
            writeLogFile(s);
          }
          else if ( (unsigned int)log_level > 5 )
          {
            v27 = fopen(log_file, "a+");
            v28 = v27;
            if ( v27 )
              fprintf(
                v27,
                "%s:%d:%s: read failed, old value: Chain[%d] Chip[%d] local Temp=%d\n",
                "driver-btm-c5.c",
                8510,
                "read_temp_func",
                v1,
                *(unsigned __int8 *)(dev + v3 + v4 + 1256),
                *(__int16 *)(dev + 8 * (v3 + v4 + 173)));
            v84 = 1;
            fclose(v28);
          }
          else
          {
            v84 = 1;
          }
          v9 = check_reg_temp(DEVICEADDR[v1], 1, 0, 0, *(_BYTE *)(dev + v3 + v4 + 1256), v1);
          if ( v9 )
          {
            v10 = dev;
            remote = get_remote((unsigned __int8)v9);
            v12 = dev;
            v13 = 8 * (v3 + v4);
            v14 = dev + v3 + v4;
            *(_WORD *)(v10 + v13 + 1386) = remote;
            sprintf(
              s,
              "Chain[%d] Chip[%d] junction temperature=%d\n",
              v1,
              (*(unsigned __int8 *)(v14 + 1256) >> 2) + 1,
              *(__int16 *)(v13 + v12 + 1386));
          }
          else
          {
            sprintf(
              s,
              "read failed on Chain[%d] Chip[%d] middle Temp old value:%d\n",
              v1,
              (*(unsigned __int8 *)(dev + v3 + v4 + 1256) >> 2) + 1,
              *(__int16 *)(dev + 8 * (v3 + v4) + 1386));
          }
          writeLogFile(s);
          if ( is218_Temp || chip_hasNoMiddle )
          {
            v0 = (_DWORD *)dev;
            LOWORD(v15) = *(_WORD *)(dev + 8 * (v3 + v4 + 173));
LABEL_19:
            v17 = 2 * (v3 + v4);
            v18 = (__int16)(v15 + 15);
            HIWORD(v0[v17 + 346]) = v18;
            sprintf(
              s,
              "Special fix Chain[%d] Chip[%d] middle Temp = %d\n",
              v1,
              (*((unsigned __int8 *)&v0[v3 / 4u + 314] + v4) >> 2) + 1,
              v18);
            writeLogFile(s);
            v0 = (_DWORD *)dev;
            v15 = *(__int16 *)(dev + 8 * (v3 + v4 + 173));
            v16 = *(__int16 *)(v17 * 4 + dev + 1386);
          }
          else
          {
            v0 = (_DWORD *)dev;
            v15 = *(__int16 *)(dev + 8 * (v3 + v4 + 173));
            v16 = *(__int16 *)(dev + 8 * (v3 + v4) + 1386);
            if ( v15 > v16 )
              goto LABEL_19;
          }
          if ( v2 < v15 )
            v2 = v15;
          v19 = v81;
          v20 = &v0[2 * v3 + 2 * v4++];
          v21 = *((__int16 *)v20 + 694);
          if ( v81 < v16 )
            v19 = v16;
          v81 = v19;
          v22 = v80;
          if ( v80 >= v15 )
            v22 = v15;
          v23 = v82;
          v80 = v22;
          if ( v82 >= v16 )
            v23 = v16;
          v82 = v23;
          v24 = v79;
          if ( v79 < v21 )
            v24 = v21;
          v79 = v24;
          v25 = v83;
          if ( v83 >= v21 )
            v25 = v21;
          v83 = v25;
          if ( *((char *)v0 + v1 + 1112) <= v4 )
          {
            v32 = (__int16)v25;
            v33 = v81;
            v34 = (__int16)v79;
            v35 = v22;
            v36 = v82;
            v37 = (__int16)v83 > 0;
            goto LABEL_49;
          }
          continue;
        }
      }
      if ( *((char *)v0 + v1 + 1112) > 0 )
        goto LABEL_11;
LABEL_102:
      v32 = 1000;
      v34 = -100;
      v3 = 8 * v1;
      v36 = 1000;
      v35 = 1000;
      v37 = v90;
      v33 = -100;
      LOWORD(v2) = -100;
LABEL_49:
      v38 = check_temp_offside;
      v39 = &v0[v3 / 4u];
      v39[1268] = v35;
      v40 = v33;
      v39[1204] = v2;
      v39[1205] = v33;
      v39[1206] = v34;
      v39[1269] = v36;
      v39[1270] = v32;
      if ( v38 )
      {
        v40 = (__int16)v39[1205];
        if ( (unsigned __int16)(v40 - 75) > 50u )
        {
          if ( !v89 )
          {
            v89 = 1;
            ++temp_offside[v1];
          }
        }
        else
        {
          v89 = 0;
        }
      }
      v41 = v87;
      v42 = v86;
      v43 = (__int16)v39[1268];
      v44 = (__int16)v39[1204];
      if ( v87 < v40 )
        v41 = v40;
      if ( v86 < v34 )
        v42 = v34;
      v87 = v41;
      v86 = v42;
      v45 = v85;
      v46 = v43 > 0;
      if ( v43 >= (__int16)v93 )
        v46 = 0;
      if ( v85 < v44 )
        v45 = v44;
      v85 = v45;
      if ( v46 )
      {
        if ( chain_temp_toolow[v1] )
          goto LABEL_65;
LABEL_64:
        LOWORD(v93) = v43;
        goto LABEL_65;
      }
      if ( !(_WORD)v93 )
        goto LABEL_64;
LABEL_65:
      v47 = SHIWORD(v0[v3 / 4u + 634]);
      v48 = v47 > 0;
      if ( v47 >= SHIWORD(v93) )
        v48 = 0;
      if ( v48 )
      {
        if ( chain_temp_toolow[v1] )
          goto LABEL_70;
LABEL_69:
        HIWORD(v93) = v47;
        goto LABEL_70;
      }
      if ( !HIWORD(v93) )
        goto LABEL_69;
LABEL_70:
      v49 = v94 > v32 && v37;
      if ( v49 && !chain_temp_toolow[v1] || !v94 )
        v94 = v32;
      v50 = v1++;
      sprintf(s, "Done read temp on Chain[%d]\n", v50);
      writeLogFile(s);
      v0 = (_DWORD *)dev;
    }
    while ( v1 != 16 );
LABEL_77:
    v0[5382] = (__int16)v93;
    v0[5383] = SHIWORD(v93);
    v0[5378] = v85;
    v0[5384] = v94;
    last_testpatten_highest_pcb_temp = v85;
    v0[5379] = v87;
    v0[5380] = v86;
    if ( v92 )
      goto LABEL_117;
    if ( !v85 )
      goto LABEL_79;
    saveTestPattenHighestTemp(v85);
    bring_up_pcb_temp = last_testpatten_highest_pcb_temp;
    if ( (unsigned int)log_level <= 3 )
    {
LABEL_117:
      v92 = 1;
    }
    else
    {
      v77 = fopen(log_file, "a+");
      v78 = v77;
      if ( v77 )
        fprintf(v77, "%s:%d:%s: bring_up_pcb_temp = %d\n", "driver-btm-c5.c", 8747, "read_temp_func", bring_up_pcb_temp);
      v92 = 1;
      fclose(v78);
    }
LABEL_79:
    check_fan();
    sprintf(s, "Max pcb temp : %d\n", *(_DWORD *)(dev + 21512));
    writeLogFile(s);
    if ( (byte_805F7C & 2) != 0 )
    {
      if ( (unsigned __int8)byte_805F82 <= 100u )
      {
        sprintf(s, "Set fixed fan speed=%d\n", (unsigned __int8)byte_805F82);
        writeLogFile(s);
        set_PWM((unsigned __int8)byte_805F82);
      }
      else if ( v84 )
      {
        v51 = dev;
        *(_BYTE *)(dev + 21500) = 100;
        *(_DWORD *)(v51 + 4) = 3276800;
        set_fan_control(3276800);
        qmemcpy(s, "Set fixed full f", 16);
        *(_BYTE *)(dev + 21570) = 100;
        strcpy(&s[16], "an speed\n");
        writeLogFile(s);
      }
      else
      {
LABEL_126:
        set_PWM_according_to_temperature();
      }
      v52 = (unsigned __int8)startCheckNetworkJob;
      if ( !startCheckNetworkJob )
        goto LABEL_84;
      goto LABEL_120;
    }
    if ( !v84 )
      goto LABEL_126;
    v62 = dev;
    *(_BYTE *)(dev + 21500) = 100;
    *(_DWORD *)(v62 + 4) = 3276800;
    set_fan_control(3276800);
    qmemcpy(s, "Read temp failed", 16);
    *(_BYTE *)(dev + 21570) = 100;
    last_temperature = 75;
    strcpy(&s[16], ", set fixed full fan speed\n");
    writeLogFile(s);
    v52 = (unsigned __int8)startCheckNetworkJob;
    if ( !startCheckNetworkJob )
    {
LABEL_84:
      v53 = dev;
      v54 = 2;
      goto LABEL_85;
    }
LABEL_120:
    cgtime(&tv_send);
    v53 = dev;
    v63 = tv_send.tv_sec - tv_send_job.tv_sec;
    if ( tv_send.tv_usec - tv_send_job.tv_usec < 0 )
      --v63;
    v54 = *(unsigned __int8 *)(dev + 21502);
    if ( v63 > 120 )
    {
      strcpy(s, "Fatal Error: network connection lost!\n");
      writeInitLogFile(s);
      v55 = *(_DWORD *)(dev + 21512);
LABEL_104:
      sprintf(s, "max pcb temperature:%d, fan num:%d, error counter:%d\n", v55, v54, ++v91);
      writeInitLogFile(s);
      if ( v91 == 1 )
      {
        global_stop = 0;
        if ( once_error )
          goto LABEL_109;
        status_error = 0;
        goto LABEL_92;
      }
      v59 = 1;
      v60 = *(_DWORD *)(dev + 21512);
      global_stop = 1;
      if ( v60 <= 90 )
      {
        if ( v54 > 1 )
        {
          FatalErrorValue = 3;
LABEL_108:
          if ( (unsigned int)log_level > 3 )
          {
            v75 = fopen(log_file, "a+");
            v76 = v75;
            if ( v75 )
              fprintf(v75, "%s:%d:%s: Do not clear run bit\n", "driver-btm-c5.c", 9057, "read_temp_func");
            fclose(v76);
          }
          goto LABEL_109;
        }
        v59 = 2;
      }
      FatalErrorValue = v59;
      strcpy(s, "Fatal error, turning off hash boards power...\n");
      status_error = 1;
      once_error = 1;
      v64 = 0;
      writeInitLogFile(s);
      sprintf(s, "max pcb temperature : %d, fan num : %d\n", *(_DWORD *)(dev + 21512), v54);
      writeInitLogFile(s);
      do
      {
        if ( *(_DWORD *)(dev + 4 * (v64 + 2)) == 1 )
        {
          pthread_mutex_lock(&iic_mutex);
          disable_pic_dac((unsigned __int8)v64);
          pthread_mutex_unlock(&iic_mutex);
        }
        ++v64;
      }
      while ( v64 != 16 );
      goto LABEL_108;
    }
    v52 = *(unsigned __int8 *)(dev + 21502) <= 1u;
LABEL_85:
    v55 = *(_DWORD *)(v53 + 21512);
    if ( v55 > 90 )
      v52 |= 1u;
    if ( v52 )
      goto LABEL_104;
    global_stop = 0;
    if ( once_error )
    {
      if ( FatalErrorValue == 3 )
      {
LABEL_147:
        FatalErrorValue = 0;
        v91 = 0;
        strcpy(s, "Network connection restore.\n");
        writeInitLogFile(s);
      }
      else
      {
        v91 = (unsigned __int8)v52;
      }
LABEL_109:
      if ( !status_error )
        goto LABEL_92;
      switch ( FatalErrorValue )
      {
        case 2:
          strcpy(s, "Fatal Error: Fan lost!\n");
          break;
        case 3:
          v61 = "Fatal Error: network connection lost!\n";
LABEL_134:
          v65 = *(_DWORD *)v61;
          v66 = *((_DWORD *)v61 + 1);
          v67 = *((_DWORD *)v61 + 2);
          v68 = *((_DWORD *)v61 + 3);
          v69 = (int *)(v61 + 16);
          *(_DWORD *)s = v65;
          *(_DWORD *)&s[4] = v66;
          *(_DWORD *)&s[8] = v67;
          *(_DWORD *)&s[12] = v68;
          v70 = *v69;
          v71 = v69[1];
          v72 = v69[2];
          v73 = v69[3];
          v69 += 4;
          *(_DWORD *)&s[16] = v70;
          *(_DWORD *)&s[20] = v71;
          *(_DWORD *)&s[24] = v72;
          *(_DWORD *)&s[28] = v73;
          v74 = v69[1];
          *(_DWORD *)&s[32] = *v69;
          *(_WORD *)&s[36] = v74;
          s[38] = BYTE2(v74);
          break;
        case 1:
          v61 = "Fatal Error: Temperature is too high!\n";
          goto LABEL_134;
        default:
          strcpy(s, "Fatal Error: unkown status.\n");
          break;
      }
      writeInitLogFile(s);
      goto LABEL_92;
    }
    if ( FatalErrorValue != 3 )
      v91 = 0;
    status_error = 0;
    if ( FatalErrorValue == 3 )
      goto LABEL_147;
LABEL_92:
    processTEST();
    sprintf(s, "FAN PWM: %d\n", *(unsigned __int8 *)(dev + 21570));
    writeLogFile(s);
    pthread_mutex_unlock(&opencore_readtemp_mutex);
    strcpy(s, "read_temp_func Done!\n");
    writeLogFile(s);
    crc_count = get_crc_count();
    sprintf(s, "CRC error counter=%d\n", crc_count);
    writeLogFile(s);
    system("cp /tmp/temp /tmp/lasttemp");
    sleep(10u);
  }
}
// 3D294: using guessed type void __noreturn read_temp_func();
// 80590: using guessed type char enable_read_temp;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 704AB8: using guessed type char status_error;
// 7093A0: using guessed type int chain_temp_toolow[16];
// 713488: using guessed type char doTestPatten;
// 713568: using guessed type char is218_Temp;
// 713569: using guessed type char chip_hasNoMiddle;
// 805F7C: using guessed type char byte_805F7C;
// 805F82: using guessed type char byte_805F82;
// 80602C: using guessed type struct timeval tv_send_job;
// 806034: using guessed type struct timeval tv_send;
// 80603C: using guessed type char startCheckNetworkJob;
// 806084: using guessed type int last_testpatten_highest_pcb_temp;
// 80A0A4: using guessed type _DWORD temp_offside[16];
// 80A0E4: using guessed type int last_temperature;
// 80A0E8: using guessed type int FatalErrorValue;
// 817C28: using guessed type int dev;
// 817CEC: using guessed type unsigned __int8 DEVICEADDR[16];

//----- (0003DDF4) --------------------------------------------------------
void __fastcall __noreturn stop_mining(const char *a1)
{
  FILE *v2; // r0
  FILE *v3; // r4

  if ( (unsigned int)log_level > 1 )
  {
    v2 = fopen(log_file, "a+");
    v3 = v2;
    if ( v2 )
      fprintf(v2, "%s:%d:%s: %s\n", "driver-btm-c5.c", 12210, "stop_mining", a1);
    fclose(v3);
  }
  while ( 1 )
  {
    processTEST();
    sleep(1u);
  }
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0003DE58) --------------------------------------------------------
char *__fastcall remove_dot_char(char *a1)
{
  size_t v2; // r0
  int v3; // r2
  size_t i; // r3
  int v5; // r1
  char *v6; // r4
  char v8[80]; // [sp+0h] [bp-50h] BYREF

  v2 = strlen(a1);
  v3 = 0;
  for ( i = 0; ; ++i )
  {
    v6 = &v8[v3 + 64];
    if ( i >= v2 )
      break;
    v5 = (unsigned __int8)a1[i];
    if ( v5 != 44 )
    {
      ++v3;
      *(v6 - 64) = v5;
    }
  }
  *(v6 - 64) = 0;
  return strcpy(a1, v8);
}

//----- (0003DE94) --------------------------------------------------------
char *__fastcall add_dot_number(char *a1)
{
  char *v2; // r0
  int v3; // r4
  char v5[48]; // [sp+0h] [bp-30h] BYREF

  remove_dot_char(a1);
  strcpy(v5, a1);
  v2 = strchr(a1, 46);
  if ( v2 )
  {
    v3 = v2 - a1;
    if ( (unsigned int)(v2 - a1) > 3 )
    {
      memcpy(v5, a1, v3 - 3);
      v5[v3 - 3] = 44;
      strcpy(&v5[v3 - 2], &a1[v3 - 3]);
    }
  }
  return strcpy(a1, v5);
}

//----- (0003DEE4) --------------------------------------------------------
_DWORD *__fastcall get_api_stats_stub(int *a1)
{
  int v2; // r3
  int v3; // r2
  _DWORD *v4; // r0
  int v5; // r7
  _DWORD *v6; // r0
  int v7; // r3
  int v8; // lr
  _DWORD *v9; // r0
  int v10; // r7
  int v11; // r2
  int v12; // lr
  _DWORD *v13; // r0
  int v14; // r7
  int v15; // r1
  _DWORD *v16; // r0
  int v17; // lr
  const char *v18; // r2
  int v19; // r7
  int v20; // r1
  _DWORD *v21; // r0
  int v22; // lr
  const char *v23; // r2
  int v24; // r7
  _DWORD *v25; // r0
  int v26; // r8
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r8
  __int16 v31; // r3
  int v32; // r7
  __int16 v33; // t1
  _DWORD *v34; // r0
  int v35; // r7
  _DWORD *v36; // r0
  int v37; // lr
  int v38; // r7
  _DWORD *v39; // r0
  _DWORD *v40; // r0
  int v41; // r2
  FILE *v42; // r0
  FILE *v43; // r11
  int i; // r7
  int v45; // r2
  int v46; // r7
  int v47; // lr
  _DWORD *v48; // r0
  int v49; // r2
  char *v50; // r7
  int j; // r5
  const char *v52; // r2
  FILE *v53; // r0
  int v54; // r2
  int v55; // r3
  int v56; // r9
  int v57; // r8
  int v58; // lr
  char *v59; // r7
  int v60; // r6
  int v61; // r12
  int v62; // t1
  int v63; // r3
  const char *v64; // r1
  size_t v65; // r0
  unsigned int v66; // r2
  int v67; // r8
  int v68; // r7
  int v69; // r2
  int v70; // r8
  int v71; // r7
  __int64 *v72; // r3
  int v73; // r2
  unsigned __int64 v74; // r0
  int v75; // t1
  __int64 v76; // r8
  _DWORD *v77; // r0
  _DWORD *result; // r0
  FILE *v79; // r0
  FILE *v80; // r6
  FILE *v81; // r0
  FILE *v82; // r7
  FILE *v83; // r0
  FILE *v84; // r4
  char *modes; // [sp+14h] [bp-874h]
  char *modesa; // [sp+14h] [bp-874h]
  int v87; // [sp+1Ch] [bp-86Ch]
  int *v88; // [sp+20h] [bp-868h]
  _DWORD v89[2]; // [sp+28h] [bp-860h] BYREF
  char v90[16]; // [sp+30h] [bp-858h] BYREF
  char src[8]; // [sp+40h] [bp-848h] BYREF
  int v92; // [sp+48h] [bp-840h]
  int v93; // [sp+4Ch] [bp-83Ch]
  int v94; // [sp+50h] [bp-838h]
  _DWORD v95[524]; // [sp+58h] [bp-830h] BYREF

  if ( (unsigned int)log_level > 6 )
  {
    v83 = fopen(log_file, "a+");
    v84 = v83;
    if ( v83 )
      fprintf(v83, "%s:%d:%s: get_api_stats_stub enter\n", "driver-btm-c5.c", 17035, "get_api_stats_stub");
    fclose(v84);
  }
  v2 = dev;
  v3 = dev + 21376;
  *(_BYTE *)(dev + 21502) = 2;
  *(_DWORD *)(v2 + 21573) = 3158070;
  v4 = api_add_uint8((_DWORD *)*a1, "miner_count", (const char *)(v3 + 125), 1);
  *a1 = (int)v4;
  v5 = 0;
  v6 = api_add_string(v4, "frequency", (const char *)(dev + 21573), 1);
  *a1 = (int)v6;
  *a1 = (int)api_add_uint8(v6, "fan_num", (const char *)(dev + 21502), 1);
  v7 = dev;
  *(_DWORD *)(dev + 21396) = 2020;
  *(_DWORD *)(v7 + 21408) = 2040;
  do
  {
    sprintf((char *)v95, "fan%d", v5 + 1);
    v8 = v5 + 5346;
    ++v5;
    v9 = api_add_uint((_DWORD *)*a1, (const char *)v95, (const char *)(dev + 4 * v8 + 4), 1);
    *a1 = (int)v9;
  }
  while ( v5 != 8 );
  v10 = 0;
  *a1 = (int)api_add_uint8(v9, "temp_num", (const char *)(dev + 21501), 1);
  do
  {
    sprintf((char *)v95, "temp%d", v10 + 1);
    v11 = dev;
    v12 = v10 + 301;
    v13 = (_DWORD *)*a1;
    ++v10;
    *(_WORD *)(dev + 8 * v12) = 0;
    *a1 = (int)api_add_int16(v13, (const char *)v95, (const char *)(v11 + 8 * v12), 1);
  }
  while ( v10 != 16 );
  v14 = 0;
  do
  {
    sprintf((char *)v95, "temp2_%d", v14 + 1);
    v15 = v14 << 6;
    v16 = (_DWORD *)*a1;
    v17 = (v14++ << 6) + 1386;
    v18 = (const char *)(dev + v17);
    *(_WORD *)(v15 + dev + 1386) = 83;
    *a1 = (int)api_add_int16(v16, (const char *)v95, v18, 1);
  }
  while ( v14 != 16 );
  v19 = 0;
  do
  {
    sprintf((char *)v95, "temp3_%d", v19 + 1);
    v20 = v19 << 6;
    v21 = (_DWORD *)*a1;
    v22 = (v19++ << 6) + 1394;
    v23 = (const char *)(dev + v22);
    *(_WORD *)(v20 + dev + 1394) = 52;
    *a1 = (int)api_add_int16(v21, (const char *)v95, v23, 1);
  }
  while ( v19 != 16 );
  v24 = 0;
  do
  {
    while ( 1 )
    {
      v26 = v24 + 1;
      memset(src, 0, sizeof(src));
      sprintf((char *)v95, "freq_avg%d", v24 + 1);
      if ( *(_DWORD *)(dev + 4 * (v24 + 2)) == 1 )
        break;
      v25 = (_DWORD *)*a1;
      ++v24;
      memset(src, 0, sizeof(src));
      *a1 = (int)api_add_mhs(v25, (const char *)v95, src, 1);
      if ( v26 == 16 )
        goto LABEL_14;
    }
    ++v24;
    v27 = (_DWORD *)*a1;
    *(_QWORD *)src = 4649008896651779113LL;
    *a1 = (int)api_add_mhs(v27, (const char *)v95, src, 1);
  }
  while ( v26 != 16 );
LABEL_14:
  *(_QWORD *)src = loc_3E3B0;
  strcpy((char *)v95, "total_rateideal");
  v28 = api_add_mhs((_DWORD *)*a1, (const char *)v95, src, 1);
  *a1 = (int)v28;
  *(_QWORD *)src = 4649008896651779113LL;
  strcpy((char *)v95, "total_freqavg");
  v29 = api_add_mhs(v28, (const char *)v95, src, 1);
  *a1 = (int)v29;
  v30 = v29;
  v31 = 0;
  *(_WORD *)src = 0;
  v32 = dev + 21483;
  strcpy((char *)v95, "total_acn");
  do
  {
    v33 = *(unsigned __int8 *)++v32;
    v31 += v33;
  }
  while ( v32 != dev + 21499 );
  *(_WORD *)src = v31;
  if ( (unsigned int)log_level > 3 )
  {
    v81 = fopen(log_file, "a+");
    v82 = v81;
    if ( v81 )
      fprintf(v81, "%s:%d:%s: asic_num_total = %d\n", "driver-btm-c5.c", 17119, "get_api_stats_stub", *(__int16 *)src);
    fclose(v82);
    v30 = (_DWORD *)*a1;
  }
  v34 = api_add_int16(v30, (const char *)v95, src, 1);
  *a1 = (int)v34;
  v35 = 0;
  strcpy((char *)v95, "total_rate");
  *(_QWORD *)src = 4669026215020441108LL;
  *a1 = (int)api_add_mhs(v34, (const char *)v95, src, 1);
  do
  {
    ++v35;
    *(_QWORD *)src = loc_3E3B8;
    sprintf((char *)v95, "chain_rateideal%d", v35);
    v36 = api_add_mhs((_DWORD *)*a1, (const char *)v95, src, 1);
    *a1 = (int)v36;
  }
  while ( v35 != 16 );
  v37 = dev;
  v38 = 0;
  *(_DWORD *)(dev + 21512) = 0;
  v39 = api_add_int(v36, "temp_max", (const char *)(v37 + 21512), 1);
  v89[0] = 0;
  v89[1] = 0;
  *a1 = (int)v39;
  hw_errors = 0;
  v40 = api_add_percent(v39, "Device Hardware%", (const char *)v89, 1);
  *a1 = (int)v40;
  *a1 = (int)api_add_int(v40, "no_matching_work", (const char *)&hw_errors, 1);
  do
  {
    sprintf((char *)v95, "chain_acn%d", v38 + 1);
    if ( (unsigned int)log_level > 5 )
    {
      v42 = fopen(log_file, "a+");
      v43 = v42;
      if ( v42 )
        fprintf(
          v42,
          "%s:%d:%s: chain_asic_num[%d]=%d\n",
          "driver-btm-c5.c",
          17154,
          "get_api_stats_stub",
          v38,
          *(unsigned __int8 *)(dev + v38 + 21484));
      fclose(v43);
    }
    v41 = dev + v38++;
    *a1 = (int)api_add_uint8((_DWORD *)*a1, (const char *)v95, (const char *)(v41 + 21484), 1);
  }
  while ( v38 != 16 );
  for ( i = 0; i != 16; ++i )
  {
    sprintf((char *)v95, "chain_acs%d", i + 1);
    v45 = 17 * i;
    *a1 = (int)api_add_string((_DWORD *)*a1, (const char *)v95, (const char *)(dev + 8 * v45 + 19192 + 4), 1);
  }
  v46 = 0;
  do
  {
    sprintf((char *)v95, "chain_hw%d", v46 + 1);
    v47 = v46 + 686;
    v48 = (_DWORD *)*a1;
    ++v46;
    v49 = dev + 4 * v47;
    *(_DWORD *)(v49 + 4) = 0;
    *a1 = (int)api_add_uint32(v48, (const char *)v95, (const char *)(v49 + 4), 1);
  }
  while ( v46 != 16 );
  v50 = displayed_rate;
  for ( j = 0; j != 16; ++j )
  {
    sprintf((char *)v95, "chain_rate%d", j + 1);
    snprintf(v50, 32u, "%.2f", 4729.74);
    if ( (unsigned int)log_level > 5 )
    {
      v53 = fopen(log_file, "a+");
      modes = (char *)v53;
      if ( v53 )
        fprintf(v53, "%s:%d:%s: %d  %s\n", "driver-btm-c5.c", 17181, "get_api_stats_stub", j, v50);
      fclose((FILE *)modes);
    }
    v52 = v50;
    v50 += 32;
    *a1 = (int)api_add_string((_DWORD *)*a1, (const char *)v95, v52, 1);
  }
  v54 = dev;
  modesa = (char *)&x_time;
  v55 = 1;
  v88 = a1;
  do
  {
    v56 = v55 + 1;
    v57 = v55 - 1;
    if ( *(_DWORD *)(v54 + 4 * (v55 + 1)) == 1 )
    {
      v87 = v55;
      v95[0] = 123;
      memset(&v95[1], 0, 2044u);
      memset(src, 0, sizeof(src));
      v92 = 0;
      v93 = 0;
      v94 = 0;
      sprintf(v90, "chain_xtime%d", v87);
      v58 = 1;
      if ( *(_DWORD *)modesa )
      {
        sprintf(src, "X%d=%d", 0, *(_DWORD *)modesa);
        strcat((char *)v95, src);
        v58 = 0;
      }
      if ( *(unsigned __int8 *)(dev + v57 + 21484) > 1u )
      {
        v59 = modesa;
        v60 = 1;
        do
        {
          v62 = *((_DWORD *)v59 + 1);
          v59 += 4;
          v61 = v62;
          if ( v62 )
          {
            v63 = v61;
            v64 = "X%d=%d";
            if ( !v58 )
            {
              v64 = ",X%d=%d";
              v63 = v61;
            }
            sprintf(src, v64, v60, v63);
            strcat((char *)v95, src);
            v58 = 0;
          }
          ++v60;
        }
        while ( *(unsigned __int8 *)(dev + v57 + 21484) > v60 );
      }
      v65 = strlen((const char *)v95);
      v66 = log_level;
      *(_WORD *)((char *)v95 + v65) = 125;
      if ( v66 > 5 )
      {
        v79 = fopen(log_file, "a+");
        v80 = v79;
        if ( v79 )
          fprintf(v79, "%s:%d:%s: %s\n", "driver-btm-c5.c", 17221, "get_api_stats_stub", (const char *)v95);
        fclose(v80);
      }
      *v88 = (int)api_add_string((_DWORD *)*v88, v90, (const char *)v95, 1);
      v54 = dev;
    }
    modesa += 1024;
    v55 = v56;
  }
  while ( v56 != 17 );
  v67 = 1;
  v68 = 0;
  do
  {
    while ( *(_DWORD *)(v54 + 4 * (v68 + 2)) != 1 )
    {
      ++v68;
      ++v67;
      if ( v68 == 16 )
        goto LABEL_54;
    }
    sprintf(src, "chain_offside_%d", v67);
    v69 = temp_offside[v68++];
    sprintf((char *)v95, "%d", v69);
    *v88 = (int)api_add_string((_DWORD *)*v88, src, (const char *)v95, 1);
    ++v67;
    v54 = dev;
  }
  while ( v68 != 16 );
LABEL_54:
  v70 = 1;
  v71 = 0;
  do
  {
    while ( *(_DWORD *)(v54 + 4 * (v71 + 2)) != 1 )
    {
      ++v71;
      ++v70;
      if ( v71 == 16 )
        goto LABEL_60;
    }
    sprintf(src, "chain_opencore_%d", v70);
    if ( isChainAllCoresOpened[v71] )
      strcpy((char *)v95, "1");
    else
      strcpy((char *)v95, "0");
    ++v71;
    ++v70;
    *v88 = (int)api_add_string((_DWORD *)*v88, src, (const char *)v95, 1);
    v54 = dev;
  }
  while ( v71 != 16 );
LABEL_60:
  v72 = rate;
  v73 = v54 + 4;
  v74 = 0LL;
  do
  {
    while ( 1 )
    {
      v75 = *(_DWORD *)(v73 + 4);
      v73 += 4;
      if ( v75 == 1 )
        break;
      if ( ++v72 == (__int64 *)&rate_error )
        goto LABEL_64;
    }
    v76 = *v72++;
    v74 += v76;
  }
  while ( v72 != (__int64 *)&rate_error );
LABEL_64:
  suffix_string_c5_constprop_16(v74, displayed_hash_rate, 16u, 7);
  strcpy((char *)v95, "miner_version");
  v77 = api_add_string((_DWORD *)*v88, (const char *)v95, g_miner_version, 1);
  *v88 = (int)v77;
  strcpy((char *)v95, "miner_id");
  result = api_add_string(v77, (const char *)v95, FPGA_ID_str, 1);
  *v88 = (int)result;
  return result;
}
// 67AC8: using guessed type __int16 word_67AC8;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 713490: using guessed type _QWORD rate[16];
// 80A0A4: using guessed type _DWORD temp_offside[16];
// 80BA88: using guessed type int hw_errors;
// 817C28: using guessed type int dev;

//----- (0003E794) --------------------------------------------------------
_DWORD *bitmain_api_stats()
{
  double v0; // d0
  int v1; // r5
  _DWORD *v2; // r0
  _DWORD *v3; // r0
  int v4; // lr
  _DWORD *v5; // r0
  int v6; // r5
  int v7; // r7
  int i; // r5
  int v9; // r2
  int j; // r5
  int v11; // r2
  int v12; // r6
  int v13; // lr
  int v14; // r10
  int v15; // r5
  int v16; // r2
  int v17; // r0
  int v18; // r3
  int v19; // r3
  char *v20; // r2
  int v21; // r6
  int v22; // r1
  int v23; // r10
  int v24; // r5
  int v25; // r2
  int v26; // r0
  int v27; // r3
  int v28; // r3
  char *v29; // r2
  int v30; // r7
  int v31; // r3
  char *v32; // r6
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *v33; // r11
  int v34; // r5
  int v35; // r3
  int spins; // t1
  const char *v37; // r0
  bool v38; // cc
  int v39; // r0
  int v40; // r2
  double v41; // d6
  double v42; // d7
  _DWORD *v43; // r0
  int *v44; // r10
  int v45; // r11
  char *v46; // r8
  char *v47; // r7
  int *v48; // r5
  int v49; // r6
  int v50; // r0
  double v51; // d7
  int v52; // r8
  int v53; // r7
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *v54; // r11
  char *v55; // r6
  int v56; // r5
  const char *v57; // r3
  int v58; // t1
  const char *v59; // r0
  bool v60; // cc
  int v61; // r0
  __int16 v62; // r6
  _DWORD *v63; // r7
  int v64; // r3
  int v65; // r5
  int v66; // lr
  int v67; // t1
  int v68; // r5
  char *v69; // r6
  int v70; // r3
  int v71; // r7
  int v72; // r11
  int v73; // r3
  char *v74; // r10
  int v75; // r6
  int *v76; // r5
  int v77; // r0
  double v78; // d6
  const char *v79; // r10
  _DWORD *v80; // r5
  __int64 v81; // r0
  double v82; // d7
  _DWORD *v83; // r0
  int v84; // r5
  int v85; // lr
  int k; // r5
  int v87; // lr
  int m; // r6
  int v89; // lr
  int v90; // r5
  _DWORD *v91; // r0
  int v92; // r2
  int v93; // r6
  int v94; // r10
  int v95; // r7
  int v96; // lr
  char *v97; // r6
  int v98; // r5
  int v99; // r12
  int v100; // t1
  int v101; // r3
  const char *v102; // r1
  _DWORD *v103; // r0
  int v104; // r6
  int v105; // r5
  int v106; // r2
  int v107; // r2
  _DWORD *v108; // r0
  int v109; // r6
  char *v110; // r5
  _DWORD *v111; // r0
  __int64 *v112; // r3
  int v113; // r2
  unsigned __int64 v114; // r0
  int v115; // t1
  __int64 v116; // r4
  char *v118; // [sp+Ch] [bp-894h]
  char *v119; // [sp+Ch] [bp-894h]
  char *v120; // [sp+10h] [bp-890h]
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *v121; // [sp+14h] [bp-88Ch]
  char *v122; // [sp+14h] [bp-88Ch]
  int v123; // [sp+18h] [bp-888h]
  int *v124; // [sp+18h] [bp-888h]
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *p_spins; // [sp+1Ch] [bp-884h]
  int v126; // [sp+24h] [bp-87Ch]
  _DWORD *v127; // [sp+2Ch] [bp-874h] BYREF
  double v128; // [sp+30h] [bp-870h] BYREF
  char v129; // [sp+38h] [bp-868h] BYREF
  char v130; // [sp+39h] [bp-867h]
  char s[8]; // [sp+48h] [bp-858h] BYREF
  int v132; // [sp+50h] [bp-850h]
  int v133; // [sp+54h] [bp-84Ch]
  int v134; // [sp+58h] [bp-848h]
  _DWORD v135[528]; // [sp+60h] [bp-840h] BYREF

  v127 = 0;
  v126 = (unsigned __int8)is_certification;
  if ( is_certification )
  {
    get_api_stats_stub((int *)&v127);
    return v127;
  }
  v1 = (unsigned __int8)is_certification;
  v2 = api_add_uint8((_DWORD *)(unsigned __int8)is_certification, "miner_count", (const char *)(dev + 21501), 1);
  v3 = api_add_string(v2, "frequency", (const char *)(dev + 21573), 1);
  v127 = api_add_uint8(v3, "fan_num", (const char *)(dev + 21502), 1);
  do
  {
    sprintf((char *)v135, "fan%d", v1 + 1);
    v4 = v1 + 5346;
    ++v1;
    v5 = api_add_uint(v127, (const char *)v135, (const char *)(dev + 4 * v4 + 4), 1);
    v127 = v5;
  }
  while ( v1 != 8 );
  v6 = 0;
  v127 = api_add_uint8(v5, "temp_num", (const char *)(dev + 21501), 1);
  do
  {
    sprintf((char *)v135, "temp%d", v6 + 1);
    v7 = v6 + 301;
    ++v6;
    v127 = api_add_int16(v127, (const char *)v135, (const char *)(dev + 8 * v7), 1);
  }
  while ( v6 != 16 );
  for ( i = 0; i != 16; ++i )
  {
    sprintf((char *)v135, "temp2_%d", i + 1);
    v9 = (i << 6) + 1386;
    v127 = api_add_int16(v127, (const char *)v135, (const char *)(v9 + dev), 1);
  }
  for ( j = 0; j != 16; ++j )
  {
    sprintf((char *)v135, "temp3_%d", j + 1);
    v11 = (j << 6) + 1394;
    v127 = api_add_int16(v127, (const char *)v135, (const char *)(v11 + dev), 1);
  }
  v12 = 0;
  do
  {
    v13 = dev;
    v130 = 0;
    v14 = 0;
    v15 = 0;
    v129 = 45;
    v16 = *(char *)(dev + v12 + 1112);
    while ( 1 )
    {
      v38 = v15 < v16;
      v19 = 8 * v12 + v15++ + 173;
      if ( !v38 )
        break;
      v17 = sprintf((char *)v135 + v14, "%d", *(__int16 *)(v13 + 8 * v19));
      v13 = dev;
      v14 += v17;
      v18 = dev + v12;
      v16 = *(char *)(dev + v12 + 1112);
      if ( v15 < v16 )
      {
        strcpy((char *)v135 + v14++, "-");
        v16 = *(char *)(v18 + 1112);
      }
    }
    sprintf(s, "temp_pcb_%d", ++v12);
    if ( v14 <= 0 )
      v20 = &v129;
    else
      v20 = (char *)v135;
    v127 = api_add_string(v127, s, v20, 1);
  }
  while ( v12 != 16 );
  v21 = 0;
  do
  {
    v22 = dev;
    v130 = 0;
    v23 = 0;
    v24 = 0;
    v129 = 45;
    v25 = *(char *)(dev + v21 + 1112);
    while ( 1 )
    {
      v38 = v24 < v25;
      v28 = v22 + 8 * (8 * v21 + v24++);
      if ( !v38 )
        break;
      v26 = sprintf((char *)v135 + v23, "%d", *(__int16 *)(v28 + 1386));
      v22 = dev;
      v23 += v26;
      v27 = dev + v21;
      v25 = *(char *)(dev + v21 + 1112);
      if ( v24 < v25 )
      {
        strcpy((char *)v135 + v23++, "-");
        v25 = *(char *)(v27 + 1112);
      }
    }
    sprintf(s, "temp_chip_%d", ++v21);
    if ( v23 <= 0 )
      v29 = &v129;
    else
      v29 = (char *)v135;
    v127 = api_add_string(v127, s, v29, 1);
  }
  while ( v21 != 16 );
  v120 = &byte_708AD6;
  v118 = &byte_708AD6;
  v30 = 0;
  p_spins = (union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *)&iic_mutex.__spins;
  v121 = (union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *)&iic_mutex.__spins;
  do
  {
    v123 = v30 + 1;
    *(double *)s = 0.0;
    sprintf((char *)v135, "freq_avg%d", v30 + 1);
    v31 = *(_DWORD *)(dev + 4 * (v30 + 2));
    if ( v31 != 1 )
    {
      v51 = *(double *)s;
      LOBYTE(v31) = 1;
LABEL_53:
      v43 = v127;
      v42 = v51 * 100.0;
      goto LABEL_41;
    }
    v32 = v118;
    if ( *(v118 - 2) != 125 )
    {
      v51 = *(double *)s;
      goto LABEL_53;
    }
    if ( !*(_BYTE *)(dev + v30 + 21484) )
      goto LABEL_39;
    v33 = v121;
    v34 = 0;
    do
    {
      spins = v33[1].__spins;
      ++v33;
      v35 = spins;
      v37 = "200";
      ++v34;
      ++v32;
      v38 = spins <= 14;
      if ( spins <= 14 )
        v35 = (unsigned __int8)*(v32 - 1);
      if ( v38 )
        v37 = *(const char **)&_PRETTY_FUNCTION___14958[16 * v35 + 40];
      v39 = strtol(v37, 0, 10);
      *(double *)s = *(double *)s + (double)v39;
      v40 = *(unsigned __int8 *)(dev + v30 + 21484);
    }
    while ( v40 > v34 );
    if ( *(_BYTE *)(dev + v30 + 21484) )
      v41 = *(double *)s / (double)v40;
    else
LABEL_39:
      v41 = *(double *)s;
    v42 = v41 * 100.0;
    LOBYTE(v31) = 1;
    v43 = v127;
LABEL_41:
    *(double *)s = (double)(int)v42 / 100.0;
    ++v30;
    v127 = api_add_mhs(v43, (const char *)v135, s, v31);
    v121 += 256;
    v118 += 128;
  }
  while ( v123 != 16 );
  v124 = chain_badcore_num;
  v44 = chain_badcore_num;
  v45 = 0;
  memset(s, 0, sizeof(s));
  strcpy((char *)v135, "total_rateideal");
  v46 = &byte_708AD6;
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v45 + 2)) == 1 )
    {
      if ( opt_fixed_freq )
      {
        if ( *(v46 - 2) == 125 && *(_BYTE *)(dev + v45 + 21484) )
        {
          v47 = v46;
          v48 = v44;
          v49 = 0;
          do
          {
            ++v49;
            if ( *v48 <= 14 )
            {
              v50 = strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * (unsigned __int8)*v47 + 40], 0, 10);
              *(double *)s = (double)(v50 * (114 - *v48)) + *(double *)s;
            }
            ++v48;
            ++v47;
          }
          while ( *(unsigned __int8 *)(dev + v45 + 21484) > v49 );
        }
      }
      else
      {
        *(double *)s = (double)(1000 * ideal_total_hash_rate);
      }
    }
    ++v45;
    v44 += 256;
    v46 += 128;
  }
  while ( v45 != 16 );
  v52 = 0;
  v122 = &byte_708AD6;
  v53 = 0;
  *(double *)s = (double)(int)(*(double *)s / 1000.0 * 100.0) / 100.0;
  v127 = api_add_mhs(v127, (const char *)v135, s, 1);
  strcpy((char *)v135, "total_freqavg");
  memset(s, 0, sizeof(s));
  do
  {
    if ( *(_DWORD *)(dev + 4 * (v53 + 2)) == 1 && *(v122 - 2) == 125 && *(_BYTE *)(dev + v53 + 21484) )
    {
      v54 = p_spins;
      v55 = v122;
      v56 = v52;
      do
      {
        v58 = v54[1].__spins;
        ++v54;
        v57 = (const char *)v58;
        v59 = "200";
        ++v56;
        ++v55;
        v60 = v58 <= 14;
        if ( v58 <= 14 )
          v59 = (const char *)(unsigned __int8)*(v55 - 1);
        if ( v60 )
          v57 = "bitmain_c5_detect";
        if ( v60 )
          v59 = *(const char **)&v57[16 * (_DWORD)v59 + 40];
        v61 = strtol(v59, 0, 10);
        *(double *)s = *(double *)s + (double)v61;
      }
      while ( v56 - v52 < *(unsigned __int8 *)(dev + v53 + 21484) );
      v52 = v56;
    }
    ++v53;
    p_spins += 256;
    v122 += 128;
  }
  while ( v53 != 16 );
  v62 = 0;
  *(double *)s = (double)(int)(*(double *)s / (double)v52 * 100.0) / 100.0;
  v63 = api_add_mhs(v127, (const char *)v135, s, 1);
  v64 = dev + 4;
  v65 = dev + 21484;
  v127 = v63;
  strcpy((char *)v135, "total_acn");
  v66 = v126;
  *(_WORD *)s = 0;
  do
  {
    v67 = *(_DWORD *)(v64 + 4);
    v64 += 4;
    ++v65;
    if ( v67 == 1 )
    {
      v66 = 1;
      v62 += *(unsigned __int8 *)(v65 - 1);
    }
  }
  while ( dev + 68 != v64 );
  if ( v66 )
    *(_WORD *)s = v62;
  v127 = api_add_int16(v63, (const char *)v135, s, 1);
  v68 = 0;
  memset(s, 0, sizeof(s));
  v69 = displayed_rate;
  strcpy((char *)v135, "total_rate");
  do
  {
    while ( 1 )
    {
      v70 = v68 + 2;
      ++v68;
      if ( *(_DWORD *)(dev + 4 * v70) == 1 )
      {
        if ( *v69 )
          break;
      }
      v69 += 32;
      if ( v68 == 16 )
        goto LABEL_82;
    }
    strtod(v69, 0);
    v69 += 32;
    v0 = *(double *)s + v0;
    *(double *)s = v0;
  }
  while ( v68 != 16 );
LABEL_82:
  v71 = 0;
  *(double *)s = (double)(int)(*(double *)s * 100.0) / 100.0;
  v127 = api_add_mhs(v127, (const char *)v135, s, 1);
  while ( 2 )
  {
    v72 = v71 + 1;
    *(double *)s = 0.0;
    sprintf((char *)v135, "chain_rateideal%d", v71 + 1);
    v73 = *(_DWORD *)(dev + 4 * (v71 + 2));
    if ( v73 != 1 )
    {
      v78 = *(double *)s;
      LOBYTE(v73) = 1;
LABEL_92:
      *(double *)s = (double)(int)(v78 / 1000.0 * 100.0) / 100.0;
      v127 = api_add_mhs(v127, (const char *)v135, s, v73);
      goto LABEL_93;
    }
    if ( *(v120 - 2) != 125 )
    {
      v78 = *(double *)s;
      goto LABEL_92;
    }
    if ( opt_economic_mode )
    {
      if ( *(_BYTE *)(dev + v71 + 21484) )
      {
        v74 = v120;
        v75 = 0;
        v76 = v124;
        do
        {
          ++v75;
          if ( *v76 <= 14 )
          {
            v77 = strtol(*(const char **)&_PRETTY_FUNCTION___14958[16 * (unsigned __int8)*v74 + 40], 0, 10);
            *(double *)s = (double)(v77 * (114 - *v76)) + *(double *)s;
          }
          ++v76;
          ++v74;
        }
        while ( *(unsigned __int8 *)(dev + v71 + 21484) > v75 );
      }
      *(double *)s = (double)(int)(*(double *)s / 1000.0 * 100.0) / 100.0;
    }
    else
    {
      *(double *)s = (double)*((int *)v120 + 21);
    }
    v127 = api_add_mhs(v127, (const char *)v135, s, 1);
LABEL_93:
    ++v71;
    v124 += 256;
    v120 += 128;
    if ( v72 != 16 )
      continue;
    break;
  }
  v79 = displayed_rate;
  v80 = api_add_int(v127, "temp_max", (const char *)(dev + 21512), 1);
  v127 = v80;
  *(_QWORD *)&total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + *(double *)total_diff_stale);
  v81 = (__int64)(total_diff_accepted + total_diff_rejected + *(double *)total_diff_stale) + hw_errors;
  if ( v81 )
    v82 = (double)hw_errors / (double)v81;
  else
    v82 = 0.0;
  v128 = v82;
  v83 = api_add_percent(v80, "Device Hardware%", (const char *)&v128, 1);
  v84 = 0;
  v127 = api_add_int(v83, "no_matching_work", (const char *)&hw_errors, 1);
  do
  {
    sprintf((char *)v135, "chain_acn%d", v84 + 1);
    v85 = v84 + 21480;
    ++v84;
    v127 = api_add_uint8(v127, (const char *)v135, (const char *)(dev + v85 + 4), 1);
  }
  while ( v84 != 16 );
  for ( k = 0; k != 16; ++k )
  {
    sprintf((char *)v135, "chain_acs%d", k + 1);
    v87 = 17 * k;
    v127 = api_add_string(v127, (const char *)v135, (const char *)(dev + 8 * v87 + 19192 + 4), 1);
  }
  for ( m = 0; m != 16; ++m )
  {
    sprintf((char *)v135, "chain_hw%d", m + 1);
    v89 = m + 686;
    v127 = api_add_uint32(v127, (const char *)v135, (const char *)(dev + 4 * v89 + 4), 1);
  }
  v90 = 0;
  do
  {
    sprintf((char *)v135, "chain_rate%d", ++v90);
    v91 = api_add_string(v127, (const char *)v135, v79, 1);
    v79 += 32;
    v127 = v91;
  }
  while ( v90 != 16 );
  v92 = dev;
  v119 = (char *)&x_time;
  v93 = 1;
  do
  {
    v94 = v93 + 1;
    v95 = v93 - 1;
    if ( *(_DWORD *)(v92 + 4 * (v93 + 1)) == 1 )
    {
      v135[0] = 123;
      memset(&v135[1], 0, 2044u);
      memset(s, 0, sizeof(s));
      v132 = 0;
      v133 = 0;
      v134 = 0;
      sprintf(&v129, "chain_xtime%d", v93);
      v96 = 1;
      if ( *(_DWORD *)v119 )
      {
        sprintf(s, "X%d=%d", 0, *(_DWORD *)v119);
        strcat((char *)v135, s);
        v96 = 0;
      }
      if ( *(unsigned __int8 *)(dev + v95 + 21484) > 1u )
      {
        v97 = v119;
        v98 = 1;
        do
        {
          v100 = *((_DWORD *)v97 + 1);
          v97 += 4;
          v99 = v100;
          if ( v100 )
          {
            v101 = v99;
            v102 = "X%d=%d";
            if ( !v96 )
            {
              v102 = ",X%d=%d";
              v101 = v99;
            }
            sprintf(s, v102, v98, v101);
            strcat((char *)v135, s);
            v96 = 0;
          }
          ++v98;
        }
        while ( *(unsigned __int8 *)(dev + v95 + 21484) > v98 );
      }
      *(_WORD *)((char *)v135 + strlen((const char *)v135)) = 125;
      v103 = api_add_string(v127, &v129, (const char *)v135, 1);
      v92 = dev;
      v127 = v103;
    }
    v93 = v94;
    v119 += 1024;
  }
  while ( v94 != 17 );
  v104 = 1;
  v105 = 0;
  do
  {
    while ( *(_DWORD *)(v92 + 4 * (v105 + 2)) != 1 )
    {
      ++v105;
      ++v104;
      if ( v105 == 16 )
        goto LABEL_127;
    }
    v106 = v104++;
    sprintf(s, "chain_offside_%d", v106);
    v107 = temp_offside[v105++];
    sprintf((char *)v135, "%d", v107);
    v108 = api_add_string(v127, s, (const char *)v135, 1);
    v92 = dev;
    v127 = v108;
  }
  while ( v105 != 16 );
LABEL_127:
  v109 = 1;
  v110 = isChainAllCoresOpened;
  do
  {
    while ( *(_DWORD *)(v92 + 4 * (v110 - isChainAllCoresOpened + 2)) != 1 )
    {
      ++v110;
      ++v109;
      if ( &is_first_job == (_UNKNOWN *)v110 )
        goto LABEL_133;
    }
    sprintf(s, "chain_opencore_%d", v109);
    if ( *v110 )
      strcpy((char *)v135, "1");
    else
      strcpy((char *)v135, "0");
    ++v110;
    ++v109;
    v111 = api_add_string(v127, s, (const char *)v135, 1);
    v92 = dev;
    v127 = v111;
  }
  while ( &is_first_job != (_UNKNOWN *)v110 );
LABEL_133:
  v112 = rate;
  v113 = v92 + 4;
  v114 = 0LL;
  do
  {
    while ( 1 )
    {
      v115 = *(_DWORD *)(v113 + 4);
      v113 += 4;
      if ( v115 == 1 )
        break;
      if ( &rate_error == (_UNKNOWN *)++v112 )
        goto LABEL_137;
    }
    v116 = *v112++;
    v114 += v116;
  }
  while ( &rate_error != (_UNKNOWN *)v112 );
LABEL_137:
  suffix_string_c5_constprop_16(v114, displayed_hash_rate, 16u, 7);
  strcpy((char *)v135, "miner_version");
  v127 = api_add_string(v127, (const char *)v135, g_miner_version, 1);
  strcpy((char *)v135, "miner_id");
  return api_add_string(v127, (const char *)v135, FPGA_ID_str, 1);
}
// 3EE5E: variable 'v0' is possibly undefined
// 67AC8: using guessed type __int16 word_67AC8;
// 704AD4: using guessed type int chain_badcore_num[];
// 708AD6: using guessed type char byte_708AD6;
// 709398: using guessed type char opt_fixed_freq;
// 70943E: using guessed type char opt_economic_mode;
// 709440: using guessed type int ideal_total_hash_rate;
// 713490: using guessed type _QWORD rate[16];
// 806028: using guessed type char is_certification;
// 80A0A4: using guessed type _DWORD temp_offside[16];
// 80BA88: using guessed type int hw_errors;
// 80BA90: using guessed type double total_diff_accepted;
// 80BAB0: using guessed type double total_diff_rejected;
// 80EF60: using guessed type int total_diff1;
// 817C28: using guessed type int dev;

//----- (0003F420) --------------------------------------------------------
bool is_network_error()
{
  return FatalErrorValue == 3;
}
// 80A0E8: using guessed type int FatalErrorValue;

//----- (0003F438) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_reset_pic_part_0(int a1)
{
  int v2; // r5
  int v3; // r7
  int v4; // r8
  bool v5; // zf
  FILE *v7; // r0
  FILE *v8; // r7

  v2 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 7u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, 11u);
    usleep((__useconds_t)"ac");
    v3 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v4 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    usleep(100000u);
    v5 = v3 == 7;
    if ( v3 == 7 )
      v5 = v4 == 1;
    if ( v5 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v7 = fopen(log_file, "a+");
      v8 = v7;
      if ( v7 )
        fprintf(
          v7,
          "%s:%d:%s: %s failed on Chain[%d]!\n",
          "dsPIC33EP16GS202.c",
          166,
          "dsPIC33EP16GS202_reset_pic",
          "dsPIC33EP16GS202_reset_pic",
          a1);
      fclose(v8);
    }
    sleep(1u);
    if ( !--v2 )
      return 0;
  }
  sleep(1u);
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0003F558) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_erase_pic_app_program_part_1(int a1)
{
  int v2; // r5
  int v3; // r7
  int v4; // r8
  bool v5; // zf
  FILE *v7; // r0
  FILE *v8; // r8

  v2 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 9u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, 13u);
    usleep((__useconds_t)&loc_1869E + 2);
    v3 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v4 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    usleep(200000u);
    v5 = v3 == 9;
    if ( v3 == 9 )
      v5 = v4 == 1;
    if ( v5 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v7 = fopen(log_file, "a+");
      v8 = v7;
      if ( v7 )
        fprintf(
          v7,
          "%s:%d:%s: %s failed on Chain[%d]!\n",
          "dsPIC33EP16GS202.c",
          257,
          "dsPIC33EP16GS202_erase_pic_app_program",
          "dsPIC33EP16GS202_erase_pic_app_program",
          a1);
      fclose(v8);
    }
    sleep(1u);
    if ( !--v2 )
      return 0;
  }
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0003F674) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_get_pic_sw_version(int a1, _BYTE *a2)
{
  int v3; // r6
  int v4; // r9
  int v5; // r8
  __int16 v6; // r11
  int v7; // r10
  bool v8; // zf
  int result; // r0
  FILE *v10; // r0
  FILE *v11; // r8
  int v12; // [sp+10h] [bp-30h]

  v3 = 3;
  *a2 = -1;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 23u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, 27u);
    usleep((__useconds_t)&loc_1869E + 2);
    v4 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v5 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v6 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v7 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v12 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    usleep((__useconds_t)&loc_1869E + 2);
    v8 = v5 == 23;
    if ( v5 == 23 )
      v8 = v4 == 5;
    if ( !v8 )
    {
      if ( (unsigned int)log_level > 3 )
      {
        v10 = fopen(log_file, "a+");
        v11 = v10;
        if ( v10 )
          fprintf(
            v10,
            "%s:%d:%s: %s failed on Chain[%d]!\n",
            "dsPIC33EP16GS202.c",
            61,
            "dsPIC33EP16GS202_get_pic_sw_version",
            "dsPIC33EP16GS202_get_pic_sw_version",
            a1);
        fclose(v11);
      }
      goto LABEL_6;
    }
    if ( v7 == (unsigned __int16)(v6 + 28) >> 8 && v12 == (unsigned __int8)(v6 + 28) )
      break;
LABEL_6:
    sleep(1u);
    if ( !--v3 )
      return 0;
  }
  result = 1;
  *a2 = v6;
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0003F7DC) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_jump_to_app_from_loader(int a1)
{
  int v2; // r5
  int v3; // r7
  int v4; // r0
  bool v5; // zf
  FILE *v7; // r0
  FILE *v8; // r9

  v2 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 6u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, 10u);
    usleep((__useconds_t)&loc_1869E + 2);
    v3 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v4 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v5 = v3 == 6;
    if ( v3 == 6 )
      v5 = v4 == 1;
    if ( v5 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v7 = fopen(log_file, "a+");
      v8 = v7;
      if ( v7 )
        fprintf(
          v7,
          "%s:%d:%s: %s failed on Chain[%d]!\n",
          "dsPIC33EP16GS202.c",
          118,
          "dsPIC33EP16GS202_jump_to_app_from_loader",
          "dsPIC33EP16GS202_jump_to_app_from_loader",
          a1);
      fclose(v8);
    }
    sleep(1u);
    if ( !--v2 )
      return 0;
  }
  sleep(1u);
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0003F8EC) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_enable_pic_dc_dc(int a1, __int16 a2)
{
  unsigned __int8 v2; // r11
  unsigned __int8 v3; // r10
  unsigned __int8 v5; // r6
  int v6; // r5
  int v7; // r9
  int v8; // r0
  bool v9; // zf
  FILE *v11; // r0
  FILE *v12; // r9

  v2 = a2 + 26;
  v3 = a2;
  v5 = (unsigned __int16)(a2 + 26) >> 8;
  v6 = 3;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 5u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 21u);
    T9_plus_write_pic_iic(0, 0, 0, a1, v3);
    T9_plus_write_pic_iic(0, 0, 0, a1, v5);
    T9_plus_write_pic_iic(0, 0, 0, a1, v2);
    usleep(10000u);
    v7 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v8 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v9 = v7 == 21;
    if ( v7 == 21 )
      v9 = v8 == 1;
    if ( v9 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v11 = fopen(log_file, "a+");
      v12 = v11;
      if ( v11 )
        fprintf(
          v11,
          "%s:%d:%s: %s failed on Chain[%d]!\n",
          "dsPIC33EP16GS202.c",
          214,
          "dsPIC33EP16GS202_enable_pic_dc_dc",
          "dsPIC33EP16GS202_enable_pic_dc_dc",
          a1);
      fclose(v12);
    }
    sleep(1u);
    if ( !--v6 )
      return 0;
  }
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0003FA1C) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_send_data_to_pic(int a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // r2
  unsigned int v5; // r3
  __int16 v6; // t1
  unsigned __int8 v7; // r5
  int v8; // r7
  int v9; // r11
  int v10; // r9
  bool v11; // zf
  FILE *v13; // r0
  FILE *v14; // r11
  unsigned int v15; // [sp+14h] [bp-2Ch]

  v2 = a2 - 1;
  LOWORD(v5) = 22;
  do
  {
    v6 = *++v2;
    v5 = (unsigned __int16)(v5 + v6);
  }
  while ( a2 + 15 != v2 );
  v7 = v5;
  v8 = 3;
  v15 = v5 >> 8;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 20u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 2u);
    T9_plus_write_pic_iic(0, 0, 0, a1, *a2);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[1]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[2]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[3]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[4]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[5]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[6]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[7]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[8]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[9]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[10]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[11]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[12]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[13]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[14]);
    T9_plus_write_pic_iic(0, 0, 0, a1, a2[15]);
    T9_plus_write_pic_iic(0, 0, 0, a1, v15);
    T9_plus_write_pic_iic(0, 0, 0, a1, v7);
    usleep((__useconds_t)&loc_30D40);
    v9 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v10 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    usleep(100000u);
    v11 = v9 == 2;
    if ( v9 == 2 )
      v11 = v10 == 1;
    if ( v11 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v13 = fopen(log_file, "a+");
      v14 = v13;
      if ( v13 )
        fprintf(
          v13,
          "%s:%d:%s: %s failed on Chain[%d]!\n",
          "dsPIC33EP16GS202.c",
          320,
          "dsPIC33EP16GS202_send_data_to_pic",
          "dsPIC33EP16GS202_send_data_to_pic",
          a1);
      fclose(v14);
    }
    sleep(1u);
    if ( !--v8 )
      return 0;
  }
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0003FCA4) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_pic_heart_beat(char a1)
{
  int v2; // r6
  int v3; // r7
  bool v4; // zf
  int result; // r0

  T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
  T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
  T9_plus_write_pic_iic(0, 0, 0, a1, 4u);
  T9_plus_write_pic_iic(0, 0, 0, a1, 22u);
  T9_plus_write_pic_iic(0, 0, 0, a1, 0);
  T9_plus_write_pic_iic(0, 0, 0, a1, 26u);
  usleep(500000u);
  T9_plus_write_pic_iic(1, 0, 0, a1, 0);
  v2 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
  v3 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
  T9_plus_write_pic_iic(1, 0, 0, a1, 0);
  T9_plus_write_pic_iic(1, 0, 0, a1, 0);
  T9_plus_write_pic_iic(1, 0, 0, a1, 0);
  v4 = v2 == 22;
  if ( v2 == 22 )
    v4 = v3 == 1;
  result = 1;
  if ( !v4 )
  {
    sleep(1u);
    return 0;
  }
  return result;
}

//----- (0003FD84) --------------------------------------------------------
int __fastcall dsPIC33EP16GS202_update_pic_app_program(int a1)
{
  FILE *v2; // r0
  FILE *v3; // r5
  char *v4; // r4
  unsigned int v5; // r0
  int v7; // r4
  char *v8; // r3
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  char v13[8]; // [sp+0h] [bp-3738h] BYREF
  int v14; // [sp+8h] [bp-3730h] BYREF
  int v15; // [sp+Ch] [bp-372Ch]
  int v16; // [sp+10h] [bp-3728h]
  int v17; // [sp+14h] [bp-3724h]
  char s[14080]; // [sp+18h] [bp-3720h] BYREF
  int v19; // [sp+3718h] [bp-20h] BYREF

  memset(s, 0, sizeof(s));
  memset(v13, 0, 7);
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v2 = fopen("/etc/config/dsPIC33EP16GS202_app.txt", "r");
  if ( !v2 )
    return -1;
  v3 = v2;
  fseek(v2, 0, 0);
  v4 = s;
  memset(s, 0, sizeof(s));
  do
  {
    v4 += 4;
    fgets(v13, 7, v3);
    v5 = strtoul(v13, 0, 16);
    *(v4 - 1) = v5;
    *(v4 - 4) = HIBYTE(v5);
    *(v4 - 3) = BYTE2(v5);
    *(v4 - 2) = BYTE1(v5);
  }
  while ( v4 != (char *)&v19 );
  fclose(v3);
  if ( dsPIC33EP16GS202_reset_pic_part_0(a1) && dsPIC33EP16GS202_erase_pic_app_program_part_1(a1) )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = &s[v7];
      v7 += 16;
      v9 = *(_DWORD *)v8;
      v10 = *((_DWORD *)v8 + 1);
      v11 = *((_DWORD *)v8 + 2);
      v12 = *((_DWORD *)v8 + 3);
      v14 = v9;
      v15 = v10;
      v16 = v11;
      v17 = v12;
      if ( !dsPIC33EP16GS202_send_data_to_pic(a1, (unsigned __int8 *)&v14) )
        break;
      if ( v7 == 14080 )
        return dsPIC33EP16GS202_reset_pic_part_0(a1) != 0;
    }
  }
  return 0;
}
// 3FD84: using guessed type char var_3738[8];

//----- (0003FE78) --------------------------------------------------------
void *__fastcall k_alloc_items(const char **a1, const char *a2, const char *a3, int a4)
{
  void *result; // r0
  int v6; // r3
  const char *v7; // r2
  signed int v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  char *v12; // r0
  char *v13; // r5
  const char *v14; // r1
  char *v15; // r2
  const char *v16; // r0
  const char *v17; // r3
  const char *v18; // r1
  const char *v19; // r3
  int v20; // r0
  int v21; // r6
  const char *v22; // r2
  const char *v23; // r1
  const char *v24; // r1
  char *v25; // r0
  const char *v26; // r0
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = (void *)*((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      2048u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    applog(3, s, 1);
    quit(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (signed int)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (signed int)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      2048u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    applog(3, s, 1);
    quit(1);
  }
  v12 = (char *)calloc(v8, 16u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(
      s,
      2048u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    applog(3, s, 1);
    quit(1);
  }
  v14 = a1[6];
  v15 = v12 + 16;
  v16 = a1[13];
  *(_DWORD *)&v16[4 * (_DWORD)(a1[12] + 1073741823)] = v13;
  v17 = &v14[v8];
  v18 = *a1;
  if ( v8 > 2 )
    v16 = &v13[16 * v8];
  a1[6] = v17;
  v19 = v13 + 16;
  a1[7] = (const char *)v8;
  if ( v8 > 2 )
    v19 = v13 + 32;
  a1[8] = (const char *)v8;
  *(_DWORD *)v13 = v18;
  *((_DWORD *)v13 + 1) = 0;
  *((_DWORD *)v13 + 2) = v15;
  if ( v8 > 2 )
  {
    do
    {
      *((_DWORD *)v19 - 4) = v18;
      *((_DWORD *)v19 - 3) = v19 - 32;
      *((_DWORD *)v19 - 2) = v19;
      v19 += 16;
    }
    while ( v16 != v19 );
  }
  v20 = *((unsigned __int8 *)a1 + 44);
  v21 = 16 * (v8 + 268435455);
  a1[3] = v13;
  v22 = &v13[v21];
  *(_DWORD *)&v13[v21] = v18;
  *((_DWORD *)v22 + 1) = &v13[v21 - 16];
  *((_DWORD *)v22 + 2) = 0;
  if ( v20 )
    a1[4] = v22;
  v23 = a1[14];
  do
  {
    v24 = v23 + 1;
    v25 = (char *)a1[15];
    a1[14] = v24;
    v26 = (const char *)realloc(v25, 4 * (_DWORD)v24);
    a1[15] = v26;
    if ( !v26 )
    {
      snprintf(
        s,
        2048u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      applog(3, s, 1);
      quit(1);
    }
    result = calloc(1u, (size_t)a1[5]);
    *((_DWORD *)v13 + 3) = result;
    if ( !result )
    {
      snprintf(s, 2048u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      applog(3, s, 1);
      quit(1);
    }
    v23 = a1[14];
    *(_DWORD *)&a1[15][4 * (_DWORD)(v23 + 1073741823)] = result;
    v13 = (char *)*((_DWORD *)v13 + 2);
  }
  while ( v13 );
  return result;
}

//----- (000400CC) --------------------------------------------------------
_DWORD *__fastcall k_new_store(const char **a1)
{
  _DWORD *result; // r0
  const char *v3; // r1
  char v4; // r2
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = calloc(1u, 64u);
  if ( !result )
  {
    snprintf(s, 2048u, "Failed to calloc store for %s in %s %s():%d", *a1, "klist.c", "k_new_store", 85);
    applog(3, s, 1);
    quit(1);
  }
  v3 = *a1;
  v4 = *((_BYTE *)a1 + 44);
  result[2] = a1[2];
  *result = v3;
  *((_BYTE *)result + 44) = v4;
  *((_BYTE *)result + 4) = 1;
  return result;
}

//----- (00040138) --------------------------------------------------------
_BYTE *__fastcall k_new_list(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r0
  _BYTE *v13; // r4
  pthread_mutex_t *v14; // r0
  pthread_mutex_t *v15; // r5
  int *v17; // r0
  int *v18; // r0
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      2048u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    applog(3, s, 1);
    quit(1);
  }
  if ( a4 < 0 )
  {
    snprintf(
      s,
      2048u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      a1,
      a4,
      "klist.c",
      "_k_new_list",
      103);
    applog(3, s, 1);
    quit(1);
  }
  v12 = calloc(1u, 64u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(s, 2048u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    applog(3, s, 1);
    quit(1);
  }
  v12[4] = 0;
  v14 = (pthread_mutex_t *)calloc(1u, 56u);
  *((_DWORD *)v13 + 2) = v14;
  v15 = v14;
  if ( !v14 )
  {
    snprintf(s, 2048u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_init(v14, 0) )
  {
    v17 = _errno_location();
    snprintf(s, 2048u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v15[1], 0) )
  {
    v18 = _errno_location();
    snprintf(s, 2048u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v18, "klist.c", "_k_new_list", 115);
    applog(3, s, 1);
    quit(1);
  }
  *(_DWORD *)v13 = a1;
  *((_DWORD *)v13 + 5) = a2;
  *((_DWORD *)v13 + 9) = a3;
  *((_DWORD *)v13 + 10) = a4;
  v13[44] = a5;
  k_alloc_items((const char **)v13, a6, a7, a8);
  return v13;
}

//----- (00040348) --------------------------------------------------------
int __fastcall k_unlink_head(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r4
  int v6; // r3
  int v7; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return v5;
    k_alloc_items((const char **)a1, a2, a3, a4);
    if ( !*(_DWORD *)(a1 + 12) )
      return v5;
    v5 = *(_DWORD *)(a1 + 12);
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  v7 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(a1 + 28) = v7 - 1;
  return v5;
}

//----- (0004038C) --------------------------------------------------------
int __fastcall k_unlink_head_zero(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = k_unlink_head(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (000403A8) --------------------------------------------------------
int __fastcall k_unlink_tail(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  int v7; // r3
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    applog(3, s, 1);
    quit(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    v7 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    *(_DWORD *)(a1 + 28) = v7 - 1;
  }
  return result;
}

//----- (00040420) --------------------------------------------------------
const char *__fastcall k_add_head(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  int v7; // r3
  int v8; // r3
  int v9; // r3
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *(const char **)a1;
  if ( *(const char **)a2 != result )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_add_head",
      *(const char **)a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    applog(3, s, 1);
    quit(1);
  }
  v7 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = v7;
  if ( v7 )
    *(_DWORD *)(v7 + 4) = a2;
  v8 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v8 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v9 = *(_DWORD *)(a1 + 32) + 1;
  ++*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 32) = v9;
  return result;
}

//----- (000404B4) --------------------------------------------------------
int __fastcall k_add_tail(const char **a1, const char *a2, const char *a3, const char *a4, int a5)
{
  int result; // r0
  const char *v7; // r3
  const char *v8; // r3
  int v9; // r3
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *(_DWORD *)a2;
  if ( *(const char **)a2 != *a1 )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_add_tail",
      *(const char **)a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    applog(3, s, 1);
    quit(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    applog(3, s, 1);
    quit(1);
  }
  v7 = a1[4];
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 1) = v7;
  if ( v7 )
    *((_DWORD *)v7 + 2) = a2;
  v8 = a1[3];
  a1[4] = a2;
  if ( !v8 )
    a1[3] = a2;
  v9 = (int)(a1[8] + 1);
  ++a1[7];
  a1[8] = (const char *)v9;
  return result;
}

//----- (00040590) --------------------------------------------------------
int __fastcall k_insert_before(const char **a1, const char *a2, int a3, const char *a4, const char *a5, int a6)
{
  int result; // r0
  int v9; // r3
  int v10; // r3
  const char *v11; // r2
  const char *v12; // r3
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *(_DWORD *)a2;
  if ( *(const char **)a2 != *a1 )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_insert_before",
      *(const char **)a2,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    applog(3, s, 1);
    quit(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      2048u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *a1,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    applog(3, s, 1);
    quit(1);
  }
  v9 = *(_DWORD *)(a3 + 4);
  *((_DWORD *)a2 + 2) = a3;
  *((_DWORD *)a2 + 1) = v9;
  v10 = *(_DWORD *)(a3 + 4);
  if ( v10 )
    *(_DWORD *)(v10 + 8) = a2;
  else
    a1[3] = a2;
  v11 = a1[7];
  v12 = a1[8];
  *(_DWORD *)(a3 + 4) = a2;
  a1[7] = v11 + 1;
  a1[8] = v12 + 1;
  return result;
}

//----- (00040670) --------------------------------------------------------
int __fastcall k_insert_after(const char **a1, const char *a2, int a3, const char *a4, const char *a5, int a6)
{
  int result; // r0
  int v9; // r3
  int v10; // r3
  const char *v11; // r2
  const char *v12; // r3
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *(_DWORD *)a2;
  if ( *(const char **)a2 != *a1 )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_insert_after",
      *(const char **)a2,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    applog(3, s, 1);
    quit(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      2048u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *a1,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    applog(3, s, 1);
    quit(1);
  }
  v9 = *(_DWORD *)(a3 + 8);
  *((_DWORD *)a2 + 1) = a3;
  *((_DWORD *)a2 + 2) = v9;
  v10 = *(_DWORD *)(a3 + 8);
  if ( v10 )
  {
    *(_DWORD *)(v10 + 4) = a2;
  }
  else if ( *((_BYTE *)a1 + 44) )
  {
    a1[4] = a2;
  }
  v11 = a1[7];
  v12 = a1[8];
  *(_DWORD *)(a3 + 8) = a2;
  a1[7] = v11 + 1;
  a1[8] = v12 + 1;
  return result;
}

//----- (00040758) --------------------------------------------------------
const char *__fastcall k_unlink_item(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  int v7; // r3
  int v8; // r2
  int v9; // r3
  int v10; // r3
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  result = *(const char **)a1;
  if ( *(const char **)a2 != result )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_unlink_item",
      *(const char **)a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    applog(3, s, 1);
    quit(1);
  }
  v7 = *(_DWORD *)(a2 + 4);
  if ( v7 )
    *(_DWORD *)(v7 + 8) = *(_DWORD *)(a2 + 8);
  v8 = *(_DWORD *)(a2 + 8);
  if ( v8 )
    *(_DWORD *)(v8 + 4) = v7;
  v9 = *(unsigned __int8 *)(a1 + 44);
  if ( a2 == *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 12) = v8;
  if ( v9 && a2 == *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  v10 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a1 + 28) = v10 - 1;
  return result;
}

//----- (000407F4) --------------------------------------------------------
const char *__fastcall k_list_transfer_to_head(
        const char **a1,
        const char **a2,
        const char *a3,
        const char *a4,
        int a5)
{
  const char *v6; // r6
  const char *result; // r0
  const char *v9; // r6
  const char *v10; // r7
  const char *v11; // r12
  const char *v12; // lr
  const char *v13; // r1
  const char *v14; // r2
  char s[2080]; // [sp+20h] [bp-820h] BYREF

  v6 = *a1;
  result = *a2;
  if ( v6 != *a2 )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v6,
      "_k_list_transfer_to_head",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    applog(3, s, 1);
    quit(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    applog(3, s, 1);
    quit(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    result = a2[3];
    if ( result )
    {
      v10 = a1[4];
      *((_DWORD *)result + 1) = v10;
    }
    else
    {
      a2[4] = a1[4];
      v10 = a1[4];
    }
    v11 = a2[7];
    v12 = a2[8];
    v13 = a1[7];
    v14 = a1[8];
    *((_DWORD *)v10 + 2) = result;
    a2[3] = v9;
    a1[4] = 0;
    a1[3] = 0;
    a2[7] = &v11[(_DWORD)v13];
    a1[7] = 0;
    a2[8] = &v12[(_DWORD)v14];
    a1[8] = 0;
  }
  return result;
}

//----- (000408EC) --------------------------------------------------------
const char *__fastcall k_list_transfer_to_tail(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *v6; // r6
  const char *result; // r0
  const char *v9; // r2
  int v10; // r6
  int v11; // lr
  const char *v12; // r1
  const char *v13; // r7
  char s[2080]; // [sp+20h] [bp-820h] BYREF

  v6 = *a1;
  result = *(const char **)a2;
  if ( v6 != *(const char **)a2 )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v6,
      "_k_list_transfer_to_tail",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    applog(3, s, 1);
    quit(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    applog(3, s, 1);
    quit(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    v10 = *(_DWORD *)(a2 + 16);
    if ( v10 )
    {
      *(_DWORD *)(v10 + 8) = v9;
    }
    else
    {
      *(_DWORD *)(a2 + 12) = v9;
      v9 = a1[3];
    }
    v11 = *(_DWORD *)(a2 + 32);
    v12 = a1[8];
    result = &a1[7][*(_DWORD *)(a2 + 28)];
    v13 = a1[4];
    *((_DWORD *)v9 + 1) = v10;
    *(_DWORD *)(a2 + 16) = v13;
    a1[4] = 0;
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) = result;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) = &v12[v11];
    a1[8] = 0;
  }
  return result;
}

//----- (000409E0) --------------------------------------------------------
int __fastcall k_free_list(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      2048u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    applog(3, s, 1);
    quit(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}

//----- (00040AA0) --------------------------------------------------------
int __fastcall k_free_store(void *ptr, const char *a2, const char *a3, int a4)
{
  char s[2072]; // [sp+20h] [bp-818h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      2048u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *(const char **)ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    applog(3, s, 1);
    quit(1);
  }
  free(ptr);
  return 0;
}

//----- (00040B00) --------------------------------------------------------
int __fastcall dump_mem(int result, unsigned __int8 *a2, int a3)
{
  int v4; // r6
  unsigned int v5; // r3
  int v6; // r4
  int v7; // r2
  bool v8; // nf
  int v9; // r3
  int v10; // r3
  int v11; // r5
  char *v12; // r3
  FILE *v13; // r0
  FILE *v14; // r10
  FILE *v15; // r0
  FILE *v16; // r10
  FILE *v17; // r0
  FILE *v18; // r10
  const char *v19; // r4
  FILE *v20; // r0
  FILE *v21; // r5
  FILE *v22; // r0
  FILE *v23; // r4
  FILE *v24; // r0
  FILE *v25; // r4
  char v26[60]; // [sp+Ch] [bp-3Ch] BYREF

  v4 = a3;
  v5 = log_level;
  if ( result )
  {
    if ( (unsigned int)log_level <= 3 )
    {
      if ( a3 <= 0 )
        return result;
      goto LABEL_4;
    }
    v19 = (const char *)result;
    v20 = fopen(log_file, "a+");
    v21 = v20;
    if ( v20 )
      fprintf(v20, "%s:\n", v19);
    result = fclose(v21);
    v5 = log_level;
  }
  if ( v4 <= 0 )
    goto LABEL_29;
LABEL_4:
  v6 = 0;
  do
  {
    v11 = v6 & 0xF;
    if ( (v6 & 0xF) == 0 )
    {
      if ( v6 )
      {
        if ( v5 <= 3 )
          goto LABEL_7;
        v15 = fopen(log_file, "a+");
        v16 = v15;
        if ( v15 )
          fprintf(v15, "  %s\n", v26);
        result = fclose(v16);
        v5 = log_level;
      }
      if ( v5 <= 3 )
      {
LABEL_7:
        v7 = *a2;
        if ( (unsigned int)(v7 - 32) > 94 )
          goto LABEL_8;
        goto LABEL_17;
      }
      v17 = fopen(log_file, "a+");
      v18 = v17;
      if ( v17 )
        fprintf(v17, "  %04x ", v6);
      result = fclose(v18);
      v5 = log_level;
    }
    if ( v5 <= 3 )
      goto LABEL_7;
    v13 = fopen(log_file, "a+");
    v14 = v13;
    if ( v13 )
      fprintf(v13, " %02x", *a2);
    result = fclose(v14);
    v7 = *a2;
    if ( (unsigned int)(v7 - 32) > 94 )
    {
LABEL_8:
      v9 = -v6;
      v8 = -v6 < 0;
      LOBYTE(v7) = 46;
      goto LABEL_9;
    }
LABEL_17:
    v9 = -v6;
    v8 = -v6 < 0;
LABEL_9:
    v10 = v9 & 0xF;
    ++v6;
    if ( !v8 )
      v11 = -v10;
    v12 = &v26[v11 + 20];
    *(v12 - 20) = v7;
    *(v12 - 19) = 0;
    ++a2;
    v5 = log_level;
  }
  while ( v4 != v6 );
  while ( v4 << 28 )
  {
    ++v4;
    if ( v5 > 3 )
    {
      v24 = fopen(log_file, "a+");
      v25 = v24;
      if ( v24 )
        fwrite("   ", 1u, 3u, v24);
      result = fclose(v25);
      v5 = log_level;
    }
  }
LABEL_29:
  if ( v5 > 3 )
  {
    v22 = fopen(log_file, "a+");
    v23 = v22;
    if ( v22 )
      fprintf(v22, "  %s\n", v26);
    return fclose(v23);
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00040CA0) --------------------------------------------------------
void __fastcall applog(int a1, const char *a2, int a3)
{
  int v6; // r7
  struct tm *v7; // r0
  int v8; // r0
  FILE *v9; // r5
  size_t v10; // r0
  size_t v11; // r0
  int v12; // r3
  time_t timer; // [sp+1Ch] [bp-6Ch] BYREF
  struct timeval v14; // [sp+20h] [bp-68h] BYREF
  char s[96]; // [sp+28h] [bp-60h] BYREF

  if ( use_syslog )
  {
    syslog(a1 | 0x80, "%s", a2);
    return;
  }
  v14.tv_sec = (unsigned __int8)use_syslog;
  v14.tv_usec = (unsigned __int8)use_syslog;
  cgtime(&v14);
  timer = v14.tv_sec;
  v6 = v14.tv_usec / 1000;
  v7 = localtime(&timer);
  snprintf(
    s,
    64u,
    " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
    v7->tm_year + 1900,
    v7->tm_mon + 1,
    v7->tm_mday,
    v7->tm_hour,
    v7->tm_min,
    v7->tm_sec,
    v6);
  v8 = fileno((FILE *)_bss_start);
  if ( isatty(v8) )
  {
    if ( g_logfile_enable )
    {
LABEL_4:
      v9 = (FILE *)g_log_file;
      if ( g_log_file
        || (v9 = fopen((const char *)&g_logfile_path, (const char *)&g_logfile_openflag), (g_log_file = (int)v9) != 0) )
      {
        v10 = strlen(s);
        fwrite(s, v10, 1u, v9);
        v11 = strlen(a2);
        fwrite(a2, v11, 1u, (FILE *)g_log_file);
        fwrite("\n", 1u, 1u, (FILE *)g_log_file);
        fflush((FILE *)g_log_file);
      }
    }
  }
  else
  {
    fprintf((FILE *)_bss_start, "%s%s\n", s, a2);
    fflush((FILE *)_bss_start);
    if ( g_logfile_enable )
      goto LABEL_4;
  }
  if ( a1 == 3 )
    v12 = 0;
  else
    v12 = opt_quiet & 1;
  if ( !v12 )
    my_log_curses_part_2(s, a2, a3);
}
// 80B08: using guessed type int _bss_start;
// 80B5A0: using guessed type char g_logfile_enable;
// 80B5A4: using guessed type int g_log_file;
// 80B5A8: using guessed type __int16 g_logfile_openflag;
// 80B5C8: using guessed type int g_logfile_path;
// 80BA98: using guessed type char opt_quiet;
// 80CC18: using guessed type char use_syslog;

//----- (00040DFC) --------------------------------------------------------
int __fastcall mutex_unlock_noyield_constprop_3(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_mutex_unlock(&console_lock);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}
// 40CA0: using guessed type int __fastcall applog(_DWORD, _DWORD, _DWORD);
// 80EDF8: using guessed type pthread_mutex_t console_lock;

//----- (00040E5C) --------------------------------------------------------
int mutex_lock_constprop_4()
{
  int result; // r0
  int *v1; // r0
  char s[2056]; // [sp+10h] [bp-808h] BYREF

  result = pthread_mutex_lock(&console_lock);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 52);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}
// 40CA0: using guessed type int __fastcall applog(_DWORD, _DWORD, _DWORD);
// 80EDF8: using guessed type pthread_mutex_t console_lock;

//----- (00040EBC) --------------------------------------------------------
int __fastcall my_log_curses_part_2(const char *a1, const char *a2, int a3)
{
  int v6; // r0

  if ( a3 )
  {
    pthread_mutex_trylock(&console_lock);
    v6 = mutex_unlock_noyield_constprop_3(41);
    selective_yield(v6);
  }
  mutex_lock_constprop_4();
  printf("%s%s%s", a1, a2, "                    \n");
  mutex_unlock_noyield_constprop_3(54);
  return ((int (__fastcall *)())selective_yield)();
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80EDF8: using guessed type pthread_mutex_t console_lock;

//----- (00040F18) --------------------------------------------------------
void __fastcall simplelog(int a1, const char *a2, int a3)
{
  int v6; // r0
  int v7; // r0

  if ( use_syslog )
  {
    j_syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)_bss_start);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)_bss_start, "%s\n", a2);
      fflush((FILE *)_bss_start);
    }
    if ( a1 == 3 )
      v7 = 0;
    else
      v7 = opt_quiet & 1;
    if ( !v7 )
      my_log_curses_part_2("", a2, a3);
  }
}
// 80B08: using guessed type int _bss_start;
// 80BA98: using guessed type char opt_quiet;
// 80CC18: using guessed type char use_syslog;

//----- (00040F9C) --------------------------------------------------------
int check_pool_for_validation()
{
  return 0;
}

//----- (00040FA0) --------------------------------------------------------
int check_pool_worker()
{
  int v0; // r7
  int v1; // r4
  int v2; // r3
  FILE *v3; // r0
  FILE *v4; // r11
  int result; // r0
  FILE *v6; // r0
  FILE *v7; // r4

  if ( total_pools <= 0 )
  {
LABEL_12:
    if ( (unsigned int)log_level > 3 )
    {
      v6 = fopen(log_file, "a+");
      v7 = v6;
      if ( v6 )
        fprintf(v6, "%s:%d:%s: No valid pools, please configure them first!\n", "mp_test_fw.c", 64, "check_pool_worker");
      fclose(v7);
    }
    return 255;
  }
  v0 = 0;
  v1 = 0;
  do
  {
    while ( 1 )
    {
      v2 = *(_DWORD *)(pools + 4 * v1);
      if ( !**(_BYTE **)(v2 + 164) )
        goto LABEL_4;
      if ( !**(_BYTE **)(v2 + 172) )
        break;
      ++v0;
LABEL_4:
      if ( total_pools <= ++v1 )
        goto LABEL_11;
    }
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_4;
    v3 = fopen(log_file, "a+");
    v4 = v3;
    if ( v3 )
      fprintf(v3, "%s:%d:%s: Blank worker exists.\n", "mp_test_fw.c", 57, "check_pool_worker");
    ++v1;
    fclose(v4);
  }
  while ( total_pools > v1 );
LABEL_11:
  result = 0;
  if ( !v0 )
    goto LABEL_12;
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80BAEC: using guessed type int total_pools;
// 80CBE4: using guessed type int pools;

//----- (000410A0) --------------------------------------------------------
_DWORD *__fastcall dupalloc(int a1, int a2)
{
  _DWORD *v4; // r4
  const char **v5; // r0
  _DWORD *result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v4 = calloc(1u, 32u);
  if ( !v4 )
  {
    snprintf(s, 2048u, "Failed to calloc dupdata in %s %s():%d", "noncedup.c", "dupalloc", 36);
    applog(3, s, 1);
    quit(1);
  }
  *v4 = a2;
  v5 = (const char **)k_new_list("Nonces", 16, 1024, 0, 1, "noncedup.c", "dupalloc", 39);
  v4[1] = v5;
  result = k_new_store(v5);
  *(_DWORD *)(a1 + 24) = v4;
  v4[2] = result;
  return result;
}

//----- (0004112C) --------------------------------------------------------
int __fastcall dupcounters(__int64 a1, _QWORD *a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    *(_QWORD *)HIDWORD(a1) = *(_QWORD *)(v2 + 16);
    a1 = *(_QWORD *)(v2 + 24);
    *a2 = a1;
  }
  else
  {
    *(_QWORD *)HIDWORD(a1) = 0LL;
    *a2 = 0LL;
  }
  return a1;
}

//----- (00041158) --------------------------------------------------------
int __fastcall isdupnonce(_DWORD *a1, int a2, int a3)
{
  double v3; // d0
  int v4; // r4
  int v7; // r5
  int v8; // r5
  int v9; // r6
  _DWORD *v11; // r3
  int v12; // r0
  int v13; // r5
  int v15; // r0
  _DWORD *v16; // r5
  int v17; // lr
  __time_t tv_sec; // r0
  int *v19; // r0
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  struct timeval v24; // [sp+18h] [bp-830h] BYREF
  char s[2088]; // [sp+20h] [bp-828h] BYREF

  v4 = a1[6];
  if ( !v4 )
    return 0;
  cgtime(&v24);
  v7 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 8);
  ++*(_QWORD *)(v4 + 16);
  if ( pthread_mutex_lock((pthread_mutex_t *)v7) )
  {
    v22 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v22, "noncedup.c", "isdupnonce", 70);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 24)) )
  {
    v21 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v21, "noncedup.c", "isdupnonce", 70);
    applog(3, s, 1);
    quit(1);
  }
  v8 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + 16);
  v9 = 1;
  while ( v8 && v9 & 1 )
  {
    v11 = *(_DWORD **)(v8 + 12);
    v9 = 1;
    if ( *v11 == *(_DWORD *)(a2 + 340) && v11[1] == a3 )
    {
      v9 = 0;
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(s, 2048u, "%s%d: Duplicate nonce %08x", *(_DWORD *)(a1[1] + 8), a1[2], a3);
        applog(4, s, 0);
        break;
      }
      v9 = (unsigned __int8)opt_log_output;
    }
    else
    {
      v8 = *(_DWORD *)(v8 + 4);
    }
  }
  if ( v9 )
  {
    v15 = k_unlink_head(*(_DWORD *)(v4 + 4), "noncedup.c", "isdupnonce", 81);
    v16 = *(_DWORD **)(v15 + 12);
    v17 = v15;
    *v16 = *(_DWORD *)(a2 + 340);
    v16[1] = a3;
    tv_sec = v24.tv_sec;
    v16[3] = v24.tv_usec;
    v16[2] = tv_sec;
    k_add_head(*(_DWORD *)(v4 + 8), v17, "noncedup.c", "isdupnonce", 85);
  }
  while ( *(_DWORD *)(*(_DWORD *)(v4 + 8) + 16) )
  {
    tdiff();
    if ( v3 <= (double)*(int *)v4 )
      break;
    v12 = k_unlink_tail(*(_DWORD *)(v4 + 8), "noncedup.c", "isdupnonce", 89);
    k_add_head(*(_DWORD *)(v4 + 4), v12, "noncedup.c", "isdupnonce", 90);
  }
  v13 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v13 + 24)) )
  {
    v19 = _errno_location();
    snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v19, "noncedup.c", "isdupnonce", 93);
    applog(3, s, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v13) )
  {
    v20 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v20, "noncedup.c", "isdupnonce", 93);
    applog(3, s, 1);
    quit(1);
  }
  selective_yield(0);
  if ( !v9 )
    ++*(_QWORD *)(v4 + 24);
  return v9 ^ 1;
}
// 4123E: conditional instruction was optimized away because r3.4==0
// 41298: variable 'v3' is possibly undefined
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00041420) --------------------------------------------------------
int __fastcall znyq_set_iic(unsigned int a1, char a2, int a3, int a4, unsigned __int8 a5, unsigned __int8 a6)
{
  int v6; // r4

  if ( a3 )
    v6 = 33554432;
  else
    v6 = 0;
  if ( a4 )
    v6 |= (a5 << 8) | 0x1000000;
  return set_iic(a6 | ((a1 & 7) << 16) | ((a2 & 3) << 26) | (((a1 >> 3) & 0xF) << 20) | v6);
}

//----- (00041460) --------------------------------------------------------
int power_check_protocal_type()
{
  int v0; // r4
  int v1; // r7
  FILE *v3; // r0
  FILE *v4; // r4
  FILE *v5; // r0
  FILE *v6; // r4

  v0 = 10;
  pthread_mutex_lock(&iic_mutex);
  while ( 1 )
  {
    v1 = set_iic(((power_iic_addr & 7) << 16) | ((power_iic_no & 3) << 26) | 0x3000000 | ((((unsigned __int8)power_iic_addr >> 3) & 0xF) << 20));
    usleep((__useconds_t)&loc_30D40);
    if ( v1 == 245 )
      break;
    if ( !--v0 )
    {
      if ( (unsigned int)log_level > 3 )
      {
        v3 = fopen(log_file, "a+");
        v4 = v3;
        if ( v3 )
          fprintf(
            v3,
            "%s:%d:%s: power protocal %02x, using simple cmd\n",
            "power.c",
            153,
            "power_check_protocal_type",
            v1);
        fclose(v4);
      }
      power_protocal_type = 1;
      return j_pthread_mutex_unlock(&iic_mutex);
    }
  }
  if ( (unsigned int)log_level > 3 )
  {
    v5 = fopen(log_file, "a+");
    v6 = v5;
    if ( v5 )
      fprintf(
        v5,
        "%s:%d:%s: power protocal %02x, using package cmd\n",
        "power.c",
        148,
        "power_check_protocal_type",
        245);
    fclose(v6);
    power_protocal_type = 2;
  }
  else
  {
    power_protocal_type = 2;
  }
  return j_pthread_mutex_unlock(&iic_mutex);
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805AC: using guessed type char power_iic_addr;
// 805AD: using guessed type char power_iic_no;
// 805AE: using guessed type __int16 power_protocal_type;

//----- (00041578) --------------------------------------------------------
__int64 power_init()
{
  int v0; // r7
  FILE *v1; // r6
  __int64 result; // r0
  FILE *v3; // r0
  FILE *v4; // r5
  const char *v5; // r3
  FILE *v6; // r0
  FILE *v7; // r6
  FILE *v8; // r0
  FILE *v9; // r6
  FILE *v10; // r0
  FILE *v11; // r6
  char s[56]; // [sp+8h] [bp-38h] BYREF

  power_check_protocal_type();
  power_info = 2;
  if ( (unsigned int)log_level > 3 )
  {
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(v6, "%s:%d:%s: start detect power type\n", "power.c", 173, "power_type_detect");
    fclose(v7);
  }
  if ( is7007_Board() )
  {
    if ( access("/sys/class/gpio/gpio907", 0) == -1 )
    {
      system("echo 907 > /sys/class/gpio/export");
      system("echo out > /sys/class/gpio/gpio907/direction");
      if ( (unsigned int)log_level > 3 )
      {
        v10 = fopen(log_file, "a+");
        v11 = v10;
        if ( v10 )
          fprintf(v10, "%s:%d:%s: init gpio907\n", "power.c", 181, "power_type_detect");
        fclose(v11);
      }
    }
    system("echo 0 > /sys/class/gpio/gpio907/value");
  }
  else
  {
    if ( access("/sys/class/gpio/gpio36", 0) == -1 )
    {
      system("echo 36 > /sys/class/gpio/export");
      system("echo out > /sys/class/gpio/gpio36/direction");
      if ( (unsigned int)log_level > 3 )
      {
        v8 = fopen(log_file, "a+");
        v9 = v8;
        if ( v8 )
          fprintf(v8, "%s:%d:%s: init gpio36\n", "power.c", 193, "power_type_detect");
        fclose(v9);
      }
    }
    system("echo 0 > /sys/class/gpio/gpio36/value");
  }
  sleep(1u);
  v0 = power_info;
  v1 = fopen("/etc/config/S11_power_type", "wb");
  if ( v1 )
  {
    memset(s, 0, 32u);
    sprintf(s, "%d", v0);
    fwrite(s, 1u, 32u, v1);
    fclose(v1);
  }
  system("sync");
  if ( is7007_Board() )
  {
    system("echo 1 > /sys/class/gpio/gpio907/value");
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_9;
  }
  else
  {
    system("echo 1 > /sys/class/gpio/gpio36/value");
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_9;
  }
  v3 = fopen(log_file, "a+");
  v4 = v3;
  if ( v3 )
  {
    v5 = "APW8 new type";
    if ( power_info != 2 )
      v5 = "APW8 old type";
    fprintf(v3, "%s:%d:%s: power type is %s\n", "power.c", 211, "power_type_detect", v5);
  }
  fclose(v4);
LABEL_9:
  dword_80B6E8 = 0;
  byte_80B6D4 = 0;
  if ( dbl_80B6D8 < 9.7 )
    dbl_80B6D8 = 10.45;
  result = *(_QWORD *)sub_417FC;
  dword_80B6EC = 0;
  dword_80B6F0 = 0;
  unk_80B6E0 = *(_QWORD *)sub_417FC;
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B6D0: using guessed type int power_info;
// 80B6D4: using guessed type char byte_80B6D4;
// 80B6D8: using guessed type double dbl_80B6D8;
// 80B6E8: using guessed type int dword_80B6E8;
// 80B6EC: using guessed type int dword_80B6EC;
// 80B6F0: using guessed type int dword_80B6F0;

//----- (000417FC) --------------------------------------------------------
int __fastcall sub_417FC(int a1, int a2)
{
  _DWORD *v2; // r4

  return set_fixed_voltage(*v2, a2, v2[9], v2[10]);
}
// 417FC: variable 'v2' is possibly undefined
// 41804: using guessed type int __fastcall set_fixed_voltage(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00041804) --------------------------------------------------------
void set_fixed_voltage()
{
  double v0; // d0
  FILE *v1; // r0
  FILE *v2; // r5

  dbl_80B6D8 = v0;
  if ( (unsigned int)log_level > 3 )
  {
    v1 = fopen(log_file, "a+");
    v2 = v1;
    if ( v1 )
      fprintf(v1, "%s:%d:%s: s9_84_fixed_voltage = %f\n", "power.c", 238, "set_fixed_voltage", dbl_80B6D8);
    j_fclose(v2);
  }
}
// 4181A: variable 'v0' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B6D8: using guessed type double dbl_80B6D8;

//----- (00041874) --------------------------------------------------------
void get_fixed_voltage()
{
  ;
}

//----- (00041884) --------------------------------------------------------
FILE *__fastcall save_power_working_iic_date(char a1)
{
  FILE *result; // r0
  FILE *v3; // r4
  char v4[4]; // [sp+4h] [bp-14h] BYREF

  result = fopen("/config/vol_iic_data", "wb+");
  if ( result )
  {
    v3 = result;
    fseek(result, 0, 0);
    v4[0] = a1;
    fwrite(v4, 1u, 1u, v3);
    return (FILE *)fclose(v3);
  }
  return result;
}
// 41884: using guessed type char anonymous_0[4];

//----- (000418C4) --------------------------------------------------------
FILE *__fastcall save_power_max_iic_date(char a1)
{
  FILE *result; // r0
  FILE *v3; // r4
  char v4[4]; // [sp+4h] [bp-14h] BYREF

  result = fopen("/config/vol_iic_data", "wb+");
  if ( result )
  {
    v3 = result;
    fseek(result, 1, 0);
    v4[0] = a1;
    fwrite(v4, 1u, 1u, v3);
    return (FILE *)fclose(v3);
  }
  return result;
}
// 418C4: using guessed type char anonymous_0[4];

//----- (00041904) --------------------------------------------------------
unsigned __int8 *__fastcall check_pic_crc(unsigned __int8 *result)
{
  unsigned int v1; // r3
  unsigned __int8 *v2; // r1
  unsigned int v3; // r5
  unsigned __int8 *v4; // r2
  int v5; // r4
  __int16 v6; // t1
  int v7; // r5
  FILE *v8; // r0
  FILE *v9; // r6

  if ( result )
  {
    v1 = *result;
    if ( v1 <= 3 )
    {
      return 0;
    }
    else
    {
      v2 = &result[v1 - 3];
      v3 = v1 - 2;
      v4 = result;
      LOWORD(v5) = 0;
      while ( 1 )
      {
        v5 = (unsigned __int16)(v1 + v5);
        if ( v4 == v2 )
          break;
        v6 = *++v4;
        LOWORD(v1) = v6;
      }
      v7 = result[v3 + 1] | (v4[1] << 8);
      if ( (unsigned int)log_level > 5 )
      {
        v8 = fopen(log_file, "a+");
        v9 = v8;
        if ( v8 )
          fprintf(v8, "%s:%d:%s: sum1,sum2 = %d,%d\n", "power.c", 311, "check_pic_crc", v5, v7);
        fclose(v9);
      }
      return (unsigned __int8 *)(v5 == v7);
    }
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00041998) --------------------------------------------------------
int __fastcall get_power_iic_value_from_voltage(_DWORD *a1)
{
  int v1; // r4
  double v2; // d0
  double v3; // d8
  FILE *v5; // r0
  FILE *v6; // r5
  double v7; // d7
  bool v8; // nf

  v3 = v2;
  if ( *a1 == 2 )
  {
    v7 = 1925.735 - v2 * 171.875;
    if ( v7 <= 255.0 )
    {
      v8 = v7 < 0.0;
      if ( v7 < 0.0 )
        v1 = 0;
      else
        HIDWORD(v7) = (unsigned int)v7;
      if ( !v8 )
        v1 = BYTE4(v7);
    }
    else
    {
      v1 = 255;
    }
  }
  else
  {
    v3 = v2 * 100.0;
    v1 = (unsigned __int8)(unsigned int)((v2 * 100.0 * 11128.32 - 6233779.2) / (243507.0 - v2 * 100.0 * 180.9));
    if ( (v1 & 0x80) != 0 )
      v1 = 127;
  }
  if ( (unsigned int)log_level <= 3 )
    return v1;
  v5 = fopen(log_file, "a+");
  v6 = v5;
  if ( v5 )
    fprintf(
      v5,
      "%s:%d:%s: iic_index for voltage[%d] = %d\n",
      "power.c",
      349,
      "get_power_iic_value_from_voltage",
      v1,
      (int)v3);
  fclose(v6);
  return v1;
}
// 419A4: variable 'v2' is possibly undefined
// 419F0: variable 'v1' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00041ACC) --------------------------------------------------------
unsigned __int8 *__fastcall decode_an_voltage_buf(unsigned __int8 *result)
{
  unsigned __int8 *v1; // r5
  int v2; // r4
  FILE *v3; // r0
  FILE *v4; // r4
  FILE *v5; // r0
  FILE *v6; // r7
  double v7; // d8
  FILE *v8; // r0
  FILE *v9; // r4
  double v10; // d8
  FILE *v11; // r0

  if ( result )
  {
    v1 = result;
    result = check_pic_crc(result);
    if ( result )
    {
      v2 = v1[4] | (v1[3] << 8);
      if ( (unsigned int)log_level > 5 )
      {
        v5 = fopen(log_file, "a+");
        v6 = v5;
        if ( v5 )
          fprintf(v5, "%s:%d:%s: voltage = %d\n", "power.c", 490, "decode_an_voltage_buf", v2);
        result = (unsigned __int8 *)fclose(v6);
        v7 = (double)v2 * 3.3 * 0.000244140625;
        if ( (unsigned int)log_level > 5 )
        {
          v8 = fopen(log_file, "a+");
          v9 = v8;
          if ( v8 )
            fprintf(v8, "%s:%d:%s: v_an2 = %f\n", "power.c", 495, "decode_an_voltage_buf", v7);
          result = (unsigned __int8 *)fclose(v9);
          v10 = v7 * 4.0;
          if ( (unsigned int)log_level > 5 )
          {
            v11 = fopen(log_file, "a+");
            v4 = v11;
            if ( v11 )
              fprintf(v11, "%s:%d:%s: v_10 = %f\n", "power.c", 498, "decode_an_voltage_buf", v10);
            return (unsigned __int8 *)fclose(v4);
          }
        }
      }
    }
    else if ( (unsigned int)log_level > 3 )
    {
      v3 = fopen(log_file, "a+");
      v4 = v3;
      if ( v3 )
        fprintf(v3, "%s:%d:%s: crc error!\n", "power.c", 482, "decode_an_voltage_buf");
      return (unsigned __int8 *)fclose(v4);
    }
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00041C8C) --------------------------------------------------------
unsigned __int8 *__fastcall dsPIC33EP16GS202_pic_get_an_voltage2(int a1)
{
  int v2; // r6
  unsigned __int8 *result; // r0
  FILE *v4; // r0
  FILE *v5; // r9
  FILE *v6; // r0
  FILE *v7; // r5
  int v8; // [sp+Ch] [bp-2Ch] BYREF
  int v9; // [sp+10h] [bp-28h]
  char v10; // [sp+14h] [bp-24h]

  v2 = 2;
  v8 = 255;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    T9_plus_write_pic_iic(0, 0, 0, a1, 85u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 170u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 4u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 41u);
    T9_plus_write_pic_iic(0, 0, 0, a1, 0);
    T9_plus_write_pic_iic(0, 0, 0, a1, 45u);
    usleep(500000u);
    LOBYTE(v8) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    BYTE1(v8) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    BYTE2(v8) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    HIBYTE(v8) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    LOBYTE(v9) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    BYTE1(v9) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    BYTE2(v9) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    HIBYTE(v9) = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    v10 = T9_plus_write_pic_iic(1, 0, 0, a1, 0);
    if ( BYTE1(v8) == 41 && BYTE2(v8) == 1 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v4 = fopen(log_file, "a+");
      v5 = v4;
      if ( v4 )
        fprintf(
          v4,
          "%s:%d:%s: Couldn't hear AN voltage response from IIC[%d]\n",
          "power.c",
          538,
          "dsPIC33EP16GS202_pic_get_an_voltage2",
          a1);
      fclose(v5);
    }
    dump_mem((int)"read_back_data:", (unsigned __int8 *)&v8, 9);
    result = (unsigned __int8 *)sleep(1u);
    if ( !--v2 )
      return result;
  }
  if ( (unsigned int)log_level > 5 )
  {
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(
        v6,
        "%s:%d:%s: Receive AN voltage response from IIC[%d]\n",
        "power.c",
        544,
        "dsPIC33EP16GS202_pic_get_an_voltage2",
        a1);
    fclose(v7);
  }
  return decode_an_voltage_buf((unsigned __int8 *)&v8);
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00041E94) --------------------------------------------------------
void get_avg_voltage()
{
  double v0; // d0
  int v1; // r3
  double v2; // d9
  int *v3; // r4
  int v4; // r5
  FILE *v5; // r0
  FILE *v6; // r11
  int v7; // s15
  FILE *v8; // r0
  FILE *v9; // r4

  v1 = total_exist_chain_num;
  v2 = 0.0;
  if ( total_exist_chain_num > 0 )
  {
    v3 = &exist_chain;
    v4 = 0;
    do
    {
      while ( 1 )
      {
        ++v4;
        pthread_mutex_lock(&iic_mutex);
        dsPIC33EP16GS202_pic_get_an_voltage2(*(unsigned __int8 *)v3);
        pthread_mutex_unlock(&iic_mutex);
        if ( (unsigned int)log_level > 3 )
          break;
        v1 = total_exist_chain_num;
        ++v3;
        v2 = v2 + v0;
        if ( total_exist_chain_num <= v4 )
          goto LABEL_8;
      }
      v5 = fopen(log_file, "a+");
      v6 = v5;
      if ( v5 )
        fprintf(v5, "%s:%d:%s: board[%d] voltage: %f\n", "power.c", 565, "get_avg_voltage", *v3, v0);
      ++v3;
      fclose(v6);
      v1 = total_exist_chain_num;
      v2 = v2 + v0;
    }
    while ( total_exist_chain_num > v4 );
  }
LABEL_8:
  v7 = v1;
  if ( (unsigned int)log_level > 3 )
  {
    v8 = fopen(log_file, "a+");
    v9 = v8;
    if ( v8 )
      fprintf(v8, "%s:%d:%s: avg voltage: %f\n", "power.c", 571, "get_avg_voltage", v2 / (double)v7);
    fclose(v9);
  }
}
// 41EE2: variable 'v0' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805F98: using guessed type int total_exist_chain_num;
// 805FE8: using guessed type int exist_chain;

//----- (00041FDC) --------------------------------------------------------
void set_iic_power_to_working_voltage_part_2()
{
  double v0; // d0

  get_avg_voltage();
  if ( v0 < 9.7 )
    stop_mining("power voltage too low\n");
}
// 41FEE: variable 'v0' is possibly undefined

//----- (00042008) --------------------------------------------------------
void get_min_voltage()
{
  double v0; // d0
  int *v1; // r4
  int v2; // r5
  double v3; // d8
  FILE *v4; // r0
  FILE *v5; // r11
  FILE *v6; // r0
  FILE *v7; // r4

  if ( total_exist_chain_num <= 0 )
  {
    v3 = 20.0;
  }
  else
  {
    v1 = &exist_chain;
    v2 = 0;
    v3 = 20.0;
    do
    {
      ++v2;
      pthread_mutex_lock(&iic_mutex);
      dsPIC33EP16GS202_pic_get_an_voltage2(*(unsigned __int8 *)v1);
      pthread_mutex_unlock(&iic_mutex);
      if ( (unsigned int)log_level > 3 )
      {
        v4 = fopen(log_file, "a+");
        v5 = v4;
        if ( v4 )
          fprintf(v4, "%s:%d:%s: board[%d] voltage: %f\n", "power.c", 587, "get_min_voltage", *v1, v0);
        fclose(v5);
      }
      ++v1;
      if ( v0 < v3 )
        v3 = v0;
    }
    while ( total_exist_chain_num > v2 );
  }
  if ( (unsigned int)log_level > 3 )
  {
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(v6, "%s:%d:%s: min voltage: %f\n", "power.c", 593, "get_min_voltage", v3);
    fclose(v7);
  }
}
// 4205C: variable 'v0' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805F98: using guessed type int total_exist_chain_num;
// 805FE8: using guessed type int exist_chain;

//----- (00042138) --------------------------------------------------------
int power_off_all_chain()
{
  int *v0; // r5
  int v1; // r4
  int v2; // t1
  int result; // r0

  if ( total_exist_chain_num > 0 )
  {
    v0 = &exist_chain;
    v1 = 0;
    do
    {
      v2 = *v0++;
      ++v1;
      result = disable_pic_dac((unsigned __int8)v2);
    }
    while ( total_exist_chain_num > v1 );
  }
  return result;
}
// 805F98: using guessed type int total_exist_chain_num;
// 805FE8: using guessed type int exist_chain;

//----- (00042168) --------------------------------------------------------
int power_on_all_chain()
{
  int *v0; // r5
  int v1; // r4
  int v2; // t1
  int result; // r0

  if ( total_exist_chain_num > 0 )
  {
    v0 = &exist_chain;
    v1 = 0;
    do
    {
      v2 = *v0++;
      ++v1;
      result = enable_pic_dac((unsigned __int8)v2);
    }
    while ( total_exist_chain_num > v1 );
  }
  return result;
}
// 805F98: using guessed type int total_exist_chain_num;
// 805FE8: using guessed type int exist_chain;

//----- (00042198) --------------------------------------------------------
int __fastcall power_set_da_value_simple(unsigned __int8 a1)
{
  int v2; // r5

  pthread_mutex_lock(&iic_mutex);
  usleep((__useconds_t)&loc_1869E + 2);
  v2 = znyq_set_iic((unsigned __int8)power_iic_addr, power_iic_no, 0, 1, 2u, a1);
  pthread_mutex_unlock(&iic_mutex);
  return v2;
}
// 805AC: using guessed type char power_iic_addr;
// 805AD: using guessed type char power_iic_no;

//----- (000421E0) --------------------------------------------------------
bool power_is_support_cmd_package()
{
  return power_protocal_type == 2;
}
// 805AE: using guessed type __int16 power_protocal_type;

//----- (000421F8) --------------------------------------------------------
int __fastcall power_check_reply(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v4; // r4
  unsigned int v5; // r2
  unsigned __int8 *v6; // r10
  FILE *v7; // r0
  FILE *v8; // r11
  FILE *v10; // r0
  FILE *v11; // r4
  FILE *v12; // r0
  FILE *v13; // r7
  int v14; // r1
  int v15; // r7
  int v16; // r3
  __int16 v17; // r2
  int v18; // r8
  unsigned __int8 *v19; // r7
  FILE *v20; // r0
  FILE *v21; // r11
  FILE *v22; // r0
  FILE *v23; // r9

  v4 = a3;
  if ( *a1 != *a2 || a1[1] != a2[1] || a1[3] != a2[3] || (v14 = a2[2], v14 + 2 != a3) )
  {
    v5 = log_level;
    if ( (unsigned int)log_level > 3 )
    {
      v12 = fopen(log_file, "a+");
      v13 = v12;
      if ( v12 )
        fprintf(v12, "%s:%d:%s: power reply data error:\n", "power.c", 876, "power_check_reply");
      v4 = (unsigned __int16)v4;
      fclose(v13);
      v5 = log_level;
      if ( !(_WORD)v4 )
        goto LABEL_10;
    }
    else
    {
      v4 = (unsigned __int16)v4;
      if ( !(_WORD)v4 )
        return 0;
    }
    v6 = a2;
    do
    {
      while ( v5 <= 3 )
      {
        if ( (unsigned __int16)((_WORD)++v6 - (_WORD)a2) >= v4 )
          goto LABEL_10;
      }
      v7 = fopen(log_file, "a+");
      v8 = v7;
      if ( v7 )
        fprintf(v7, "%02x ", *v6);
      ++v6;
      fclose(v8);
      v5 = log_level;
    }
    while ( (unsigned __int16)((_WORD)v6 - (_WORD)a2) < v4 );
    goto LABEL_10;
  }
  if ( a2[2] > 2u )
  {
    v16 = 2;
    LOWORD(v15) = 0;
    do
    {
      v17 = a2[v16];
      v16 = (unsigned __int16)(v16 + 1);
      v15 = (unsigned __int16)(v17 + v15);
    }
    while ( v14 > v16 );
  }
  else
  {
    v15 = 0;
  }
  v18 = (unsigned __int16)(a2[v4 - 2] + (a2[v4 - 1] << 8));
  if ( v18 != v15 )
  {
    v5 = log_level;
    if ( (unsigned int)log_level > 3 )
    {
      v22 = fopen(log_file, "a+");
      v23 = v22;
      if ( v22 )
        fprintf(
          v22,
          "%s:%d:%s: power reply crc error, crc %04x != crc_reply %04x:\n",
          "power.c",
          892,
          "power_check_reply",
          v15,
          v18);
      v4 = (unsigned __int16)v4;
      fclose(v23);
      v5 = log_level;
      if ( !(_WORD)v4 )
        goto LABEL_10;
      goto LABEL_30;
    }
    v4 = (unsigned __int16)v4;
    if ( (_WORD)v4 )
    {
LABEL_30:
      v19 = a2;
      do
      {
        if ( v5 > 3 )
        {
          v20 = fopen(log_file, "a+");
          v21 = v20;
          if ( v20 )
            fprintf(v20, "%02x ", *v19);
          fclose(v21);
          v5 = log_level;
        }
        ++v19;
      }
      while ( (unsigned __int16)((_WORD)v19 - (_WORD)a2) < v4 );
LABEL_10:
      if ( v5 > 3 )
      {
        v10 = fopen(log_file, "a+");
        v11 = v10;
        if ( v10 )
          fputc(10, v10);
        fclose(v11);
      }
    }
    return 0;
  }
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (000423F8) --------------------------------------------------------
int __fastcall power_send_cmd(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v6; // r6
  unsigned __int8 *v7; // r5
  unsigned __int8 *v10; // r4
  int v11; // t1
  unsigned __int8 *v12; // r4
  int v13; // r4
  FILE *v15; // r0
  FILE *v16; // r11

  v6 = 1;
  v7 = &a1[(unsigned __int8)(a2 - 1)];
  pthread_mutex_lock(&iic_mutex);
  do
  {
    if ( a2 )
    {
      v10 = a1 - 1;
      do
      {
        v11 = *++v10;
        set_iic(v11 | 0x5201100);
      }
      while ( v10 != v7 );
    }
    v12 = a3 - 1;
    usleep(500000u);
    if ( a4 )
    {
      do
        *++v12 = set_iic(102760448);
      while ( v12 != &a3[(unsigned __int8)(a4 - 1)] );
    }
    v13 = power_check_reply(a1, a3, a4);
    if ( v13 )
      break;
    if ( (unsigned int)log_level > 3 )
    {
      v15 = fopen(log_file, "a+");
      v16 = v15;
      if ( v15 )
        fprintf(
          v15,
          "%s:%d:%s: power send cmd 0x%02x failed, retry for %d times\n",
          "power.c",
          928,
          "power_send_cmd",
          a1[2],
          v6);
      fclose(v16);
    }
    ++v6;
  }
  while ( v6 != 4 );
  pthread_mutex_unlock(&iic_mutex);
  return v13;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (000424EC) --------------------------------------------------------
int __fastcall power_set_da_value(__int16 a1)
{
  int v3; // [sp+0h] [bp-38h] BYREF
  char v4; // [sp+4h] [bp-34h]
  char v5; // [sp+5h] [bp-33h]
  __int16 v6; // [sp+6h] [bp-32h]
  unsigned __int8 v7[48]; // [sp+8h] [bp-30h] BYREF

  v3 = -2096715179;
  v5 = 0;
  memset(v7, 0, 32u);
  v4 = a1;
  v6 = a1 + 137;
  return power_send_cmd((unsigned __int8 *)&v3, 8, v7, 8u);
}

//----- (00042544) --------------------------------------------------------
int __fastcall power_set_voltage(__int16 a1)
{
  if ( power_protocal_type == 2 )
    power_set_da_value(a1);
  else
    power_set_da_value_simple(a1);
  return 0;
}
// 805AE: using guessed type __int16 power_protocal_type;

//----- (00042564) --------------------------------------------------------
int __fastcall write_iic_of_S9_plus_power(int a1, int a2)
{
  *(_DWORD *)(a2 + 24) = a1;
  if ( power_protocal_type == 2 )
    power_set_da_value(a1);
  else
    power_set_da_value_simple(a1);
  return 0;
}
// 805AE: using guessed type __int16 power_protocal_type;

//----- (00042588) --------------------------------------------------------
int __fastcall voltage_tunning(int a1, int a2)
{
  double v2; // d0
  double v3; // d1
  int v5; // r4
  _BOOL4 v6; // r3
  double v8; // d8
  int v9; // r2
  int v10; // r3
  int result; // r0
  unsigned int v12; // r3
  FILE *v13; // r0
  FILE *v14; // r8
  int power_iic_value_from_voltage; // r4
  FILE *v16; // r0
  FILE *v17; // r6
  FILE *v18; // r0
  FILE *v19; // r6

  v5 = *(_DWORD *)(a2 + 24);
  v6 = v2 == 0.0;
  if ( !v5 )
    v6 = 1;
  if ( v6 )
  {
    power_iic_value_from_voltage = get_power_iic_value_from_voltage((_DWORD *)a2);
    write_iic_of_S9_plus_power(power_iic_value_from_voltage, a2);
    is7007_Board();
    return power_iic_value_from_voltage;
  }
  else
  {
    v8 = fabs(v3 - v2);
    if ( (unsigned int)log_level > 3 )
    {
      v13 = fopen(log_file, "a+");
      v14 = v13;
      if ( v13 )
        fprintf(v13, "%s:%d:%s: last_iic_data = %d\n", "power.c", 370, "voltage_tunning", v5);
      fclose(v14);
    }
    if ( v8 >= 0.02 )
    {
      if ( a1 )
      {
        v9 = *(_DWORD *)a2;
        v10 = 1;
        goto LABEL_8;
      }
      if ( v8 <= 0.25 )
      {
        v9 = *(_DWORD *)a2;
        if ( v8 > 0.13 )
        {
          if ( v9 == 2 )
          {
            v10 = 8;
            goto LABEL_36;
          }
          goto LABEL_17;
        }
      }
      else
      {
        v9 = *(_DWORD *)a2;
        if ( *(_DWORD *)a2 == 2 )
        {
          v10 = 16;
          goto LABEL_36;
        }
        if ( v8 > 0.13 )
        {
LABEL_17:
          if ( v8 > 0.07 )
          {
            v10 = 4;
          }
          else if ( v8 <= 0.05 )
          {
            v10 = 1;
          }
          else
          {
            v10 = 2;
          }
          goto LABEL_9;
        }
      }
      if ( v8 <= 0.07 )
      {
        if ( v8 <= 0.05 )
          v10 = 1;
        else
          v10 = 2;
      }
      else
      {
        v10 = 4;
      }
LABEL_8:
      if ( v9 != 2 )
      {
LABEL_9:
        if ( v3 > v2 )
        {
          if ( v9 == 1 )
          {
            v5 += v10;
            if ( v5 >= 127 )
              v5 = 127;
            goto LABEL_12;
          }
LABEL_11:
          v5 = (v5 - v10) & ~((v5 - v10) >> 31);
LABEL_12:
          write_iic_of_S9_plus_power((unsigned __int8)v5, a2);
          return v5;
        }
        if ( v9 == 1 )
          goto LABEL_11;
LABEL_30:
        v5 += v10;
        if ( v5 >= 255 )
          v5 = 255;
        goto LABEL_12;
      }
LABEL_36:
      if ( v8 < 0.03 )
        v10 = 1;
      else
        v10 *= 2;
      if ( v3 > v2 )
        goto LABEL_11;
      goto LABEL_30;
    }
    if ( is7007_Board() )
    {
      v12 = *(_DWORD *)(a2 + 36) + 1;
      *(_DWORD *)(a2 + 36) = v12;
      if ( v12 > 1 )
      {
        if ( (unsigned int)log_level > 3 )
        {
          v18 = fopen(log_file, "a+");
          v19 = v18;
          if ( v18 )
            fprintf(
              v18,
              "%s:%d:%s: It's very close to target voltage, stop tunning\n",
              "power.c",
              376,
              "voltage_tunning");
          fclose(v19);
        }
        *(_BYTE *)(a2 + 4) = 1;
        *(_DWORD *)(a2 + 36) = 0;
      }
      return v5;
    }
    if ( (unsigned int)log_level > 3 )
    {
      v16 = fopen(log_file, "a+");
      v17 = v16;
      if ( v16 )
        fprintf(v16, "%s:%d:%s: It's very close to target voltage, stop tunning\n", "power.c", 382, "voltage_tunning");
      fclose(v17);
    }
    result = v5;
    *(_BYTE *)(a2 + 4) = 1;
  }
  return result;
}
// 42598: variable 'v2' is possibly undefined
// 425B0: variable 'v3' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00042824) --------------------------------------------------------
int __fastcall set_iic_power_voltage(int a1, int a2)
{
  double v2; // d0
  int v3; // r9
  int v5; // r4
  double v6; // d8
  unsigned int v8; // r5
  int v9; // r8
  unsigned int v10; // r3
  bool v11; // cc
  FILE *v12; // r0
  FILE *v13; // r8
  FILE *v14; // r0
  FILE *v15; // r8
  FILE *v16; // r0
  FILE *v17; // r0
  FILE *v18; // r4
  FILE *v19; // r0
  FILE *v20; // r5
  int result; // r0

  v3 = 0;
  v5 = 0;
  v6 = v2;
  *(_BYTE *)(a1 + 4) = 0;
  while ( 1 )
  {
    sleep(1u);
    if ( is7007_Board() )
    {
      get_min_voltage();
      if ( a2 )
        v2 = v2 * 324.0 / 330.0;
    }
    else
    {
      get_avg_voltage();
    }
    v8 = voltage_tunning(v3, a1);
    if ( (unsigned int)log_level > 3 )
    {
      v14 = fopen(log_file, "a+");
      v15 = v14;
      if ( v14 )
        fprintf(v14, "%s:%d:%s: voltage_tunning, set to %f, N=%d\n", "power.c", 626, "set_iic_power_voltage", v6, v8);
      v16 = v15;
      v9 = v5 + 1;
      fclose(v16);
      if ( v5 > 50 )
      {
        if ( (unsigned int)log_level > 3 )
        {
          v17 = fopen(log_file, "a+");
          v18 = v17;
          if ( v17 )
            fprintf(v17, "%s:%d:%s: power voltage abnormal\n", "power.c", 629, "set_iic_power_voltage");
          fclose(v18);
        }
LABEL_6:
        stop_mining("power abnormal");
      }
    }
    else
    {
      v9 = v5 + 1;
      if ( v5 > 50 )
        goto LABEL_6;
    }
    v5 += 2;
    if ( v9 > 20 )
    {
      if ( (unsigned int)log_level > 5 )
      {
        v12 = fopen(log_file, "a+");
        v13 = v12;
        if ( v12 )
          fprintf(v12, "%s:%d:%s: tuning up 20 times\n", "power.c", 634, "set_iic_power_voltage");
        v3 = 1;
        fclose(v13);
      }
      else
      {
        v3 = 1;
      }
    }
    if ( *(_DWORD *)a1 == 1 )
      v10 = 127;
    else
      v10 = 255;
    v11 = v8 != 0;
    if ( v8 )
      v11 = v10 > v8;
    if ( !v11 )
      return *(unsigned __int8 *)(a1 + 4);
    if ( (unsigned int)log_level > 5 )
    {
      v19 = fopen(log_file, "a+");
      v20 = v19;
      if ( v19 )
        fprintf(v19, "%s:%d:%s: tunning %d times\n", "power.c", 643, "set_iic_power_voltage", v5);
      fclose(v20);
      result = *(unsigned __int8 *)(a1 + 4);
      if ( *(_BYTE *)(a1 + 4) )
        return result;
    }
    else
    {
      result = *(unsigned __int8 *)(a1 + 4);
      if ( *(_BYTE *)(a1 + 4) )
        return result;
    }
  }
}
// 4284A: variable 'v2' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (00042A14) --------------------------------------------------------
int set_iic_power_to_working_voltage()
{
  FILE *v1; // r0
  FILE *v2; // r4

  if ( (unsigned int)log_level > 3 )
  {
    v1 = fopen(log_file, "a+");
    v2 = v1;
    if ( v1 )
      fprintf(v1, "%s:%d:%s: setting to working voltage...\n", "power.c", 654, "set_iic_power_to_working_voltage");
    fclose(v2);
  }
  if ( !set_iic_power_voltage((int)&power_info, 1) )
    set_iic_power_to_working_voltage_part_2();
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B6D0: using guessed type int power_info;

//----- (00042A88) --------------------------------------------------------
int set_iic_power_to_highest_voltage()
{
  FILE *v1; // r0
  FILE *v2; // r4

  if ( (unsigned int)log_level > 3 )
  {
    v1 = fopen(log_file, "a+");
    v2 = v1;
    if ( v1 )
      fprintf(v1, "%s:%d:%s: setting to highest voltage...\n", "power.c", 672, "set_iic_power_to_highest_voltage");
    fclose(v2);
  }
  if ( !set_iic_power_voltage((int)&power_info, 0) )
    set_iic_power_to_working_voltage_part_2();
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B6D0: using guessed type int power_info;

//----- (00042AFC) --------------------------------------------------------
int set_iic_power_to_higher_voltage()
{
  double v0; // d8
  double v1; // d9
  double v2; // d8
  int v3; // r4
  FILE *v5; // r0
  FILE *v6; // r5
  FILE *v7; // r0
  FILE *v8; // r5

  v0 = unk_80B6D8;
  if ( is7007_Board() )
  {
    v1 = unk_80B6E0;
    v2 = unk_80B6D8 + 0.35;
    if ( unk_80B6D8 + 0.35 <= unk_80B6E0 )
    {
LABEL_3:
      v3 = 1;
      if ( (unsigned int)log_level <= 3 )
      {
LABEL_4:
        if ( !set_iic_power_voltage((int)&power_info, v3) )
        {
          get_avg_voltage();
          if ( v2 < 9.7 )
            stop_mining("power voltage too low\n");
        }
        return 1;
      }
LABEL_13:
      v7 = fopen(log_file, "a+");
      v8 = v7;
      if ( v7 )
        fprintf(v7, "%s:%d:%s: setting to voltage %f...\n", "power.c", 702, "set_iic_power_to_higher_voltage", v2);
      fclose(v8);
      goto LABEL_4;
    }
  }
  else
  {
    v1 = unk_80B6E0;
    v2 = v0 + 0.3;
    if ( v2 <= unk_80B6E0 )
      goto LABEL_3;
  }
  if ( !is7007_Board() )
  {
    v2 = v1;
    v3 = 0;
    if ( (unsigned int)log_level <= 3 )
      goto LABEL_4;
    goto LABEL_13;
  }
  if ( (unsigned int)log_level > 3 )
  {
    v5 = fopen(log_file, "a+");
    v6 = v5;
    if ( v5 )
      fprintf(
        v5,
        "%s:%d:%s: setting to higer voltage %f...do nothing, current iic data:%d\n",
        "power.c",
        714,
        "set_iic_power_to_higher_voltage",
        v1,
        dword_80B6E8);
    fclose(v6);
  }
  return 1;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B6D0: using guessed type int power_info;
// 80B6E8: using guessed type int dword_80B6E8;

//----- (00042C64) --------------------------------------------------------
int power_tuning()
{
  double v0; // d0
  int result; // r0
  FILE *v2; // r0
  FILE *v3; // r5

  if ( is7007_Board() )
    system("echo 0 > /sys/class/gpio/gpio907/value");
  else
    system("echo 0 > /sys/class/gpio/gpio36/value");
  sleep(1u);
  v0 = dbl_80B6D8;
  if ( !set_iic_power_voltage((int)&power_info, 1) )
  {
    get_avg_voltage();
    if ( v0 < 9.7 )
      stop_mining("power voltage too low\n");
  }
  dword_80B6EC = dword_80B6E8;
  result = set_iic_power_voltage((int)&power_info, 0);
  if ( !result && (unsigned int)log_level > 1 )
  {
    v2 = fopen(log_file, "a+");
    v3 = v2;
    if ( v2 )
      fprintf(v2, "%s:%d:%s: Warning! power voltage couldn't up to %f\n", "power.c", 794, "power_tuning", unk_80B6E0);
    result = fclose(v3);
  }
  dword_80B6F0 = dword_80B6E8;
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B6D0: using guessed type int power_info;
// 80B6D8: using guessed type double dbl_80B6D8;
// 80B6E8: using guessed type int dword_80B6E8;
// 80B6EC: using guessed type int dword_80B6EC;
// 80B6F0: using guessed type int dword_80B6F0;

//----- (00042D4C) --------------------------------------------------------
int quickly_set_to_working_voltage()
{
  unsigned __int8 v0; // r0
  FILE *v2; // r0
  FILE *v3; // r7
  FILE *v4; // r0
  FILE *v5; // r4

  if ( (unsigned int)log_level > 3 )
  {
    v2 = fopen(log_file, "a+");
    v3 = v2;
    if ( v2 )
      fprintf(v2, "%s:%d:%s: setting to working voltage...\n", "power.c", 725, "quickly_set_to_working_voltage");
    fclose(v3);
    v0 = dword_80B6EC;
    if ( dword_80B6EC )
    {
      if ( (unsigned int)log_level > 3 )
      {
        v4 = fopen(log_file, "a+");
        v5 = v4;
        if ( v4 )
          fprintf(v4, "%s:%d:%s: iic data set to %d\n", "power.c", 731, "quickly_set_to_working_voltage", dword_80B6EC);
        fclose(v5);
        v0 = dword_80B6EC;
      }
      goto LABEL_3;
    }
  }
  else
  {
    v0 = dword_80B6EC;
    if ( dword_80B6EC )
    {
LABEL_3:
      write_iic_of_S9_plus_power(v0, (int)&power_info);
      return 1;
    }
  }
  return set_iic_power_to_working_voltage();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B6D0: using guessed type int power_info;
// 80B6EC: using guessed type int dword_80B6EC;

//----- (00042E18) --------------------------------------------------------
int quickly_set_to_highest_voltage()
{
  unsigned __int8 v0; // r0
  int result; // r0
  int v2; // r1
  unsigned __int8 v3; // r3
  int v4; // r4
  _BOOL4 v5; // r3
  FILE *v6; // r0
  FILE *v7; // r5
  FILE *v8; // r0
  FILE *v9; // r7
  FILE *v10; // r0
  FILE *v11; // r5
  FILE *v12; // r0
  FILE *v13; // r6

  if ( dword_80B6F0 < (unsigned int)dword_80B6E8 || !is7007_Board() )
  {
    if ( (unsigned int)log_level > 3 )
    {
      v8 = fopen(log_file, "a+");
      v9 = v8;
      if ( v8 )
        fprintf(v8, "%s:%d:%s: setting to highest voltage...\n", "power.c", 754, "quickly_set_to_highest_voltage");
      fclose(v9);
      v0 = dword_80B6F0;
      if ( dword_80B6F0 )
      {
        if ( (unsigned int)log_level > 3 )
        {
          v10 = fopen(log_file, "a+");
          v11 = v10;
          if ( v10 )
            fprintf(
              v10,
              "%s:%d:%s: iic data set to %d\n",
              "power.c",
              760,
              "quickly_set_to_highest_voltage",
              dword_80B6F0);
          fclose(v11);
          v0 = dword_80B6F0;
        }
        goto LABEL_4;
      }
    }
    else
    {
      v0 = dword_80B6F0;
      if ( dword_80B6F0 )
      {
LABEL_4:
        write_iic_of_S9_plus_power(v0, (int)&power_info);
        return 1;
      }
    }
    return set_iic_power_to_highest_voltage();
  }
  if ( (unsigned int)log_level > 3 )
  {
    v12 = fopen(log_file, "a+");
    v13 = v12;
    if ( v12 )
      fprintf(
        v12,
        "%s:%d:%s: setting to highest voltage... current iic data:%d\n",
        "power.c",
        741,
        "quickly_set_to_highest_voltage",
        dword_80B6E8);
    fclose(v13);
  }
  v2 = minus_n_number;
  if ( minus_n_number )
  {
    v3 = dword_80B6E8;
    v2 = --minus_n_number;
    dword_80B6F0 = dword_80B6E8;
  }
  else
  {
    v3 = dword_80B6F0;
  }
  v4 = v3;
  v5 = v3 > 1u;
  if ( v2 > 1 )
    v5 = 0;
  if ( v5 )
    v4 = (unsigned __int8)(v4 - 1);
  result = write_iic_of_S9_plus_power(v4, (int)&power_info);
  if ( (unsigned int)log_level > 3 )
  {
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(v6, "%s:%d:%s: iic data set to %d\n", "power.c", 751, "quickly_set_to_highest_voltage", v4);
    return fclose(v7);
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 805B0: using guessed type int minus_n_number;
// 80B6D0: using guessed type int power_info;
// 80B6E8: using guessed type int dword_80B6E8;
// 80B6F0: using guessed type int dword_80B6F0;

//----- (00042FC0) --------------------------------------------------------
int __fastcall sha256_transf(int result, int a2, int a3)
{
  int *v3; // r5
  int i; // r4
  unsigned int *v5; // r2
  char *v6; // r6
  unsigned int v7; // r4
  char *v8; // r1
  unsigned int v9; // t1
  int v10; // r3
  int *v11; // r2
  int v12; // t1
  int v13; // r3
  int v14; // lr
  int v15; // r6
  int v16; // r10
  int v17; // r9
  int v18; // r7
  int v19; // r8
  int v20; // r12
  int v21; // r11
  int v22; // r2
  int v23; // r4
  int v24; // r3
  int v25; // r5
  int v26; // r4
  int *v27; // r9
  _DWORD *v28; // lr
  int v29; // t1
  int v30; // [sp+4h] [bp-164h]
  int v33; // [sp+10h] [bp-158h]
  _DWORD *v34; // [sp+14h] [bp-154h]
  int v35; // [sp+18h] [bp-150h]
  _DWORD *v36; // [sp+1Ch] [bp-14Ch] BYREF
  int v37; // [sp+20h] [bp-148h] BYREF
  int v38; // [sp+24h] [bp-144h]
  int v39; // [sp+28h] [bp-140h]
  int v40; // [sp+2Ch] [bp-13Ch]
  int v41; // [sp+30h] [bp-138h]
  int v42; // [sp+34h] [bp-134h]
  int v43; // [sp+38h] [bp-130h]
  int v44; // [sp+3Ch] [bp-12Ch] BYREF
  _DWORD v45[48]; // [sp+40h] [bp-128h] BYREF
  char v46; // [sp+100h] [bp-68h] BYREF

  if ( a3 > 0 )
  {
    v30 = 0;
    v35 = result + 132;
    v33 = result + 164;
    v36 = (_DWORD *)(result + 136);
    v34 = (_DWORD *)(result + 168);
    do
    {
      v3 = &v44;
      for ( i = 0; i != 16; ++i )
      {
        v5 = (unsigned int *)(a2 + (v30 << 6) + 4 * i);
        v3[1] = _byteswap_ulong(*v5);
        ++v3;
      }
      v6 = (char *)v45;
      do
      {
        v7 = *((_DWORD *)v6 + 14);
        v8 = v6;
        v9 = *((_DWORD *)v6 + 1);
        v6 += 4;
        *((_DWORD *)v6 + 15) = (__ROR4__(v9, 18) ^ __ROR4__(v9, 7) ^ (v9 >> 3))
                             + *(_DWORD *)v8
                             + *((_DWORD *)v8 + 9)
                             + (__ROR4__(v7, 19) ^ __ROR4__(v7, 17) ^ (v7 >> 10));
      }
      while ( &v46 != v6 );
      v10 = v35;
      v11 = (int *)&v36;
      do
      {
        v12 = *(_DWORD *)(v10 + 4);
        v10 += 4;
        v11[1] = v12;
        ++v11;
      }
      while ( v33 != v10 );
      v13 = v44;
      v14 = 0;
      v15 = v41;
      v16 = v42;
      v17 = v43;
      v18 = v37;
      v19 = v38;
      v20 = v39;
      v21 = v40;
      while ( 1 )
      {
        v22 = (v17 & ~v15 ^ v15 & v16) + (__ROR4__(v15, 11) ^ __ROR4__(v15, 6) ^ __ROR4__(v15, 25)) + v45[v14];
        v23 = sha256_k[v14++];
        result = (v20 ^ v19) & v18 ^ v19 & v20;
        v24 = v13 + v22 + v23;
        v25 = v24 + v21;
        v26 = (__ROR4__(v18, 13) ^ __ROR4__(v18, 2) ^ __ROR4__(v18, 22)) + result + v24;
        v21 = v20;
        v13 = v17;
        if ( v14 == 64 )
          break;
        v20 = v19;
        v17 = v16;
        v19 = v18;
        v16 = v15;
        v18 = v26;
        v15 = v25;
      }
      v44 = v17;
      v27 = &v37;
      v28 = v36;
      v43 = v16;
      v42 = v15;
      v41 = v25;
      v40 = v20;
      v39 = v19;
      v38 = v18;
      v37 = v26;
      while ( 1 )
      {
        *v28++ += v26;
        if ( v28 == v34 )
          break;
        v29 = v27[1];
        ++v27;
        v26 = v29;
      }
      ++v30;
    }
    while ( v30 != a3 );
  }
  return result;
}
// 805B4: using guessed type _DWORD sha256_k[7];
// 42FC0: using guessed type _DWORD var_128[48];

//----- (0004313C) --------------------------------------------------------
_DWORD *__fastcall sha256_init(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r3
  int v3; // t1

  v1 = &unk_806B0;
  v2 = result + 33;
  do
  {
    v3 = v1[1];
    ++v1;
    v2[1] = v3;
    ++v2;
  }
  while ( v2 != result + 41 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00043164) --------------------------------------------------------
void *__fastcall sha256_update(int *a1, const void *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r5
  char *v8; // r0
  void *result; // r0
  size_t v10; // r3
  size_t v11; // r6
  int v12; // r5
  int v13; // r7
  int v14; // r6
  int v15; // r3

  v4 = a1[1];
  v7 = 64 - v4;
  v8 = (char *)a1 + v4 + 8;
  if ( v7 >= n )
    v7 = n;
  result = memcpy(v8, a2, v7);
  v10 = a1[1] + n;
  if ( v10 > 63 )
  {
    v11 = n - v7;
    v12 = (int)a2 + v7;
    v13 = v11 >> 6;
    sha256_transf((int)a1, (int)(a1 + 2), 1);
    v14 = v11 & 0x3F;
    sha256_transf((int)a1, v12, v13);
    result = memcpy(a1 + 2, (const void *)(v12 + (v13 << 6)), v14);
    v15 = *a1;
    a1[1] = v14;
    *a1 = v15 + ((v13 + 1) << 6);
  }
  else
  {
    a1[1] = v10;
  }
  return result;
}

//----- (000431D0) --------------------------------------------------------
int *__fastcall sha256_final(_DWORD *a1, int a2)
{
  int v2; // r3
  int v3; // r6
  bool v5; // cf
  int v7; // r2
  int v8; // r7
  size_t v9; // r2
  void *v10; // r0
  int v11; // r3
  int v12; // r8
  int v13; // r9
  int v14; // r10
  int v15; // r11
  int v16; // r7
  int v17; // r0
  int *v18; // r4
  int i; // r3
  _BYTE *v20; // r2
  int *result; // r0
  int v22; // t1
  int v23; // [sp+4h] [bp-2Ch]

  v2 = a1[1];
  v3 = (int)(a1 + 2);
  v5 = (v2 & 0x3Fu) >= 56;
  if ( (v2 & 0x3Fu) >= 56 )
    v7 = 128;
  else
    v7 = 64;
  v8 = *a1 + v2;
  v9 = v7 - v2;
  v10 = (void *)(v3 + v2);
  if ( (v2 & 0x3Fu) >= 56 )
    v11 = 124;
  else
    v11 = 60;
  if ( v5 )
    v12 = 125;
  else
    v12 = 61;
  if ( v5 )
    v13 = 126;
  else
    v13 = 62;
  if ( v5 )
    v14 = 127;
  else
    v14 = 63;
  if ( v5 )
    v15 = 2;
  else
    v15 = 1;
  v23 = v11;
  v16 = 8 * v8;
  memset(v10, 0, v9);
  *((_BYTE *)a1 + a1[1] + 8) = -128;
  *(_BYTE *)(v3 + v14) = v16;
  v17 = (int)a1;
  *(_BYTE *)(v3 + v13) = BYTE1(v16);
  v18 = a1 + 34;
  *(_BYTE *)(v3 + v12) = BYTE2(v16);
  *(_BYTE *)(v3 + v23) = HIBYTE(v16);
  sha256_transf(v17, v3, v15);
  for ( i = 0; i != 8; ++i )
  {
    v20 = (_BYTE *)(a2 + 4 * i);
    result = v18;
    v20[3] = *v18;
    v20[2] = BYTE1(*v18);
    v22 = *v18++;
    v20[1] = BYTE2(v22);
    *v20 = *((_BYTE *)result + 3);
  }
  return result;
}

//----- (00043288) --------------------------------------------------------
int *__fastcall sha256(const void *a1, size_t n, int a3)
{
  _DWORD *v3; // r3
  char *v5; // r2
  int v6; // t1
  int v8[33]; // [sp+0h] [bp-B8h] BYREF
  char v9; // [sp+84h] [bp-34h] BYREF

  v3 = &unk_806B0;
  v5 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *((_DWORD *)v5 + 1) = v6;
    v5 += 4;
  }
  while ( v3 != (_DWORD *)&unk_806D0 );
  v8[0] = 0;
  v8[1] = 0;
  sha256_update(v8, a1, n);
  return sha256_final(v8, a3);
}

//----- (000432C8) --------------------------------------------------------
_DWORD *__fastcall sha2_starts(_DWORD *result)
{
  result[2] = 1779033703;
  result[3] = -1150833019;
  result[4] = 1013904242;
  result[5] = -1521486534;
  result[6] = 1359893119;
  result[7] = -1694144372;
  result[8] = 528734635;
  result[9] = 1541459225;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (00043324) --------------------------------------------------------
int __fastcall sha2_process(_DWORD *a1, int a2)
{
  unsigned int v2; // r12
  unsigned int v3; // r8
  int v4; // r2
  int v5; // r12
  int v6; // r11
  unsigned int v7; // r3
  unsigned int v8; // r1
  int v9; // r0
  int v10; // r4
  int v11; // r0
  int v12; // lr
  int v13; // lr
  int v14; // r9
  int v15; // r12
  int v16; // r11
  unsigned int v17; // r1
  int v18; // r11
  int v19; // r6
  int v20; // r4
  int v21; // r6
  int v22; // r5
  int v23; // r7
  int v24; // r5
  int v25; // r8
  int v26; // r12
  int v27; // r8
  int v28; // r9
  int v29; // r11
  int v30; // r9
  int v31; // r1
  int v32; // r4
  int v33; // r7
  int v34; // r6
  int v35; // r0
  int v36; // r7
  int v37; // r12
  int v38; // r8
  int v39; // r12
  int v40; // lr
  int v41; // r9
  int v42; // lr
  int v43; // r3
  int v44; // r4
  int v45; // r3
  int v46; // r2
  int v47; // r5
  int v48; // r11
  int v49; // r2
  int v50; // r11
  int v51; // r12
  int v52; // r6
  int v53; // r5
  unsigned int v54; // r0
  int v55; // lr
  int v56; // r9
  int v57; // r4
  int v58; // r8
  int v59; // r9
  int v60; // r3
  int v61; // r10
  int v62; // r3
  int v63; // r8
  int v64; // r11
  int v65; // r8
  int v66; // r0
  int v67; // r5
  int v68; // r0
  int v69; // r2
  int v70; // r9
  int v71; // r2
  int v72; // lr
  int v73; // r3
  int v74; // lr
  int v75; // r10
  int v76; // r8
  int v77; // r10
  unsigned int v78; // r11
  int v79; // r7
  int v80; // r0
  int v81; // r7
  int v82; // r0
  int v83; // r2
  int v84; // r12
  int v85; // r5
  int v86; // lr
  int v87; // r4
  int v88; // r10
  int v89; // r4
  int v90; // r6
  int v91; // r7
  int v92; // r6
  int v93; // r3
  int v94; // r0
  int v95; // r8
  int v96; // r9
  int v97; // r9
  int v98; // r2
  int v99; // r4
  int v100; // r12
  int v101; // lr
  int v102; // r3
  int v103; // r8
  int v104; // r0
  int v105; // r10
  int v106; // r9
  int v107; // r10
  int v108; // r7
  int v109; // r2
  int v110; // r6
  int v111; // lr
  int v112; // r6
  int v113; // r4
  int v114; // r8
  int v115; // r4
  int v116; // r10
  int v117; // r9
  unsigned int v118; // r0
  int v119; // r1
  int v120; // r7
  int v121; // r1
  int v122; // r2
  int v123; // r6
  int v124; // r5
  int v125; // r8
  int v126; // r5
  int v127; // r0
  int v128; // r9
  int v129; // r0
  int v130; // r11
  int v131; // r1
  int v132; // r11
  int v133; // r12
  int v134; // r2
  int v135; // r12
  int v136; // r10
  int v137; // r5
  int v138; // r10
  int v139; // r7
  int v140; // r0
  int v141; // lr
  int v142; // r11
  int v143; // lr
  int v144; // r8
  int v145; // r12
  int v146; // r8
  unsigned int v147; // r2
  int v148; // r1
  int v149; // r10
  int v150; // r1
  int v151; // r7
  int v152; // r4
  int v153; // r9
  int v154; // r7
  int v155; // r0
  int v156; // lr
  int v157; // r0
  int v158; // r9
  int v159; // r8
  int v160; // r9
  int v161; // r11
  int v162; // r5
  int v163; // r10
  int v164; // r4
  int v165; // r3
  int v166; // r4
  int v167; // r11
  int v168; // r4
  int v169; // r11
  int v170; // r0
  int v171; // r2
  unsigned int v172; // r3
  int v173; // r1
  unsigned int v174; // r12
  int v175; // r2
  int v176; // r9
  int v177; // r1
  int v178; // r4
  int v179; // r10
  unsigned int v180; // r11
  int v181; // r8
  int v182; // r0
  int v183; // r3
  unsigned int v184; // r6
  unsigned int v185; // r5
  int v186; // r9
  int v187; // r0
  unsigned int v188; // r11
  int v189; // r2
  int v190; // r9
  int v191; // r4
  int v192; // r5
  int v193; // r6
  int v194; // r5
  unsigned int v195; // lr
  int v196; // r8
  int result; // r0
  int v198; // [sp+4h] [bp-A4h]
  int v199; // [sp+4h] [bp-A4h]
  int v200; // [sp+4h] [bp-A4h]
  int v201; // [sp+4h] [bp-A4h]
  int v202; // [sp+4h] [bp-A4h]
  int v203; // [sp+4h] [bp-A4h]
  unsigned int v204; // [sp+4h] [bp-A4h]
  int v205; // [sp+8h] [bp-A0h]
  unsigned int v206; // [sp+8h] [bp-A0h]
  int v207; // [sp+8h] [bp-A0h]
  int v208; // [sp+8h] [bp-A0h]
  unsigned int v209; // [sp+8h] [bp-A0h]
  int v210; // [sp+8h] [bp-A0h]
  int v211; // [sp+Ch] [bp-9Ch]
  unsigned int v212; // [sp+Ch] [bp-9Ch]
  int v213; // [sp+Ch] [bp-9Ch]
  int v214; // [sp+Ch] [bp-9Ch]
  unsigned int v215; // [sp+Ch] [bp-9Ch]
  unsigned int v216; // [sp+10h] [bp-98h]
  unsigned int v217; // [sp+10h] [bp-98h]
  int v218; // [sp+10h] [bp-98h]
  int v219; // [sp+10h] [bp-98h]
  int v220; // [sp+10h] [bp-98h]
  int v221; // [sp+10h] [bp-98h]
  unsigned int v222; // [sp+14h] [bp-94h]
  unsigned int v223; // [sp+14h] [bp-94h]
  unsigned int v224; // [sp+14h] [bp-94h]
  int v225; // [sp+14h] [bp-94h]
  unsigned int v226; // [sp+18h] [bp-90h]
  unsigned int v227; // [sp+18h] [bp-90h]
  unsigned int v228; // [sp+18h] [bp-90h]
  unsigned int v229; // [sp+1Ch] [bp-8Ch]
  unsigned int v230; // [sp+1Ch] [bp-8Ch]
  unsigned int v231; // [sp+1Ch] [bp-8Ch]
  int v232; // [sp+1Ch] [bp-8Ch]
  unsigned int v233; // [sp+20h] [bp-88h]
  unsigned int v234; // [sp+20h] [bp-88h]
  unsigned int v235; // [sp+20h] [bp-88h]
  unsigned int v236; // [sp+20h] [bp-88h]
  unsigned int v237; // [sp+24h] [bp-84h]
  unsigned int v238; // [sp+24h] [bp-84h]
  unsigned int v239; // [sp+24h] [bp-84h]
  unsigned int v240; // [sp+24h] [bp-84h]
  unsigned int v241; // [sp+28h] [bp-80h]
  int v242; // [sp+28h] [bp-80h]
  unsigned int v243; // [sp+28h] [bp-80h]
  unsigned int v244; // [sp+28h] [bp-80h]
  unsigned int v245; // [sp+28h] [bp-80h]
  int v246; // [sp+2Ch] [bp-7Ch]
  unsigned int v247; // [sp+30h] [bp-78h]
  int v248; // [sp+30h] [bp-78h]
  unsigned int v249; // [sp+30h] [bp-78h]
  unsigned int v250; // [sp+30h] [bp-78h]
  unsigned int v251; // [sp+34h] [bp-74h]
  unsigned int v252; // [sp+34h] [bp-74h]
  unsigned int v253; // [sp+34h] [bp-74h]
  int v254; // [sp+34h] [bp-74h]
  unsigned int v255; // [sp+38h] [bp-70h]
  unsigned int v256; // [sp+38h] [bp-70h]
  unsigned int v257; // [sp+38h] [bp-70h]
  unsigned int v258; // [sp+3Ch] [bp-6Ch]
  unsigned int v259; // [sp+3Ch] [bp-6Ch]
  int v260; // [sp+3Ch] [bp-6Ch]
  unsigned int v261; // [sp+40h] [bp-68h]
  unsigned int v262; // [sp+40h] [bp-68h]
  unsigned int v263; // [sp+40h] [bp-68h]
  int v264; // [sp+40h] [bp-68h]
  unsigned int v265; // [sp+44h] [bp-64h]
  unsigned int v266; // [sp+44h] [bp-64h]
  unsigned int v267; // [sp+44h] [bp-64h]
  unsigned int v268; // [sp+48h] [bp-60h]
  unsigned int v269; // [sp+48h] [bp-60h]
  unsigned int v270; // [sp+48h] [bp-60h]
  unsigned int v271; // [sp+4Ch] [bp-5Ch]
  unsigned int v272; // [sp+4Ch] [bp-5Ch]
  int v273; // [sp+50h] [bp-58h]
  unsigned int v274; // [sp+50h] [bp-58h]
  unsigned int v275; // [sp+50h] [bp-58h]
  int v276; // [sp+54h] [bp-54h]
  unsigned int v277; // [sp+54h] [bp-54h]
  int v278; // [sp+58h] [bp-50h]
  int v279; // [sp+5Ch] [bp-4Ch]
  int v280; // [sp+60h] [bp-48h]
  unsigned int v282; // [sp+68h] [bp-40h]
  unsigned int v283; // [sp+6Ch] [bp-3Ch]
  int v284; // [sp+70h] [bp-38h]
  int v285; // [sp+74h] [bp-34h]
  int v286; // [sp+78h] [bp-30h]
  int v287; // [sp+7Ch] [bp-2Ch]

  v216 = _byteswap_ulong(*(_DWORD *)a2);
  v226 = _byteswap_ulong(*(_DWORD *)(a2 + 8));
  v222 = _byteswap_ulong(*(_DWORD *)(a2 + 4));
  v229 = _byteswap_ulong(*(_DWORD *)(a2 + 12));
  v2 = _byteswap_ulong(*(_DWORD *)(a2 + 16));
  v3 = v2 + 961987163;
  v233 = v2;
  v241 = _byteswap_ulong(*(_DWORD *)(a2 + 24));
  v237 = _byteswap_ulong(*(_DWORD *)(a2 + 20));
  v247 = _byteswap_ulong(*(_DWORD *)(a2 + 32));
  v268 = _byteswap_ulong(*(_DWORD *)(a2 + 28));
  v273 = *(unsigned __int8 *)(a2 + 58);
  v205 = *(unsigned __int8 *)(a2 + 59);
  v251 = _byteswap_ulong(*(_DWORD *)(a2 + 36));
  v255 = _byteswap_ulong(*(_DWORD *)(a2 + 40));
  v211 = *(unsigned __int8 *)(a2 + 60);
  v258 = _byteswap_ulong(*(_DWORD *)(a2 + 44));
  v4 = *(unsigned __int8 *)(a2 + 61);
  v5 = (*(unsigned __int8 *)(a2 + 57) << 16) | (*(unsigned __int8 *)(a2 + 56) << 24);
  v276 = *(unsigned __int8 *)(a2 + 63);
  v261 = _byteswap_ulong(*(_DWORD *)(a2 + 48));
  v6 = *(unsigned __int8 *)(a2 + 62);
  v285 = a1[8];
  v246 = a1[6];
  v279 = a1[3];
  v280 = a1[7];
  v287 = a1[9];
  v284 = a1[4];
  v286 = a1[5];
  v265 = _byteswap_ulong(*(_DWORD *)(a2 + 52));
  v278 = a1[2];
  v7 = (__ROR4__(v246, 11) ^ __ROR4__(v246, 6) ^ __ROR4__(v246, 25))
     + v287
     + 1116352408
     + ((v280 ^ v285) & v246 ^ v285)
     + v216;
  v8 = (__ROR4__(v278, 13) ^ __ROR4__(v278, 2) ^ __ROR4__(v278, 22)) + (v278 & v279 | (v278 | v279) & v284) + v7;
  v9 = (__ROR4__(v7 + v286, 11) ^ __ROR4__(v7 + v286, 6) ^ __ROR4__(v7 + v286, 25))
     + ((v246 ^ v280) & (v7 + v286) ^ v280)
     + v285
     + 1899447441
     + v222;
  v10 = (__ROR4__(v8, 13) ^ __ROR4__(v8, 2) ^ __ROR4__(v8, 22)) + ((v278 | v8) & v279 | v278 & v8) + v9;
  v206 = v5 | v205 | (v273 << 8);
  v11 = v9 + v284;
  v212 = (v4 << 16) | (v211 << 24) | v276 | (v6 << 8);
  v12 = v280
      - 1245643825
      + v226
      + ((v246 ^ (v7 + v286)) & v11 ^ v246)
      + (__ROR4__(v11, 11) ^ __ROR4__(v11, 6) ^ __ROR4__(v11, 25));
  v198 = (__ROR4__(v10, 13) ^ __ROR4__(v10, 2) ^ __ROR4__(v10, 22)) + ((v8 | v10) & v278 | v8 & v10) + v12;
  v217 = (__ROR4__(v222, 18) ^ __ROR4__(v222, 7) ^ (v222 >> 3))
       + v216
       + v251
       + (__ROR4__(v206, 19) ^ __ROR4__(v206, 17) ^ (v206 >> 10));
  v13 = v12 + v279;
  v14 = (__ROR4__(v13, 11) ^ __ROR4__(v13, 6) ^ __ROR4__(v13, 25))
      + ((v7 + v286) ^ ((v7 + v286) ^ v11) & v13)
      + v246
      - 373957723
      + v229;
  v15 = (__ROR4__(v198, 13) ^ __ROR4__(v198, 2) ^ __ROR4__(v198, 22)) + ((v10 | v198) & v8 | v198 & v10) + v14;
  v223 = (__ROR4__(v212, 19) ^ __ROR4__(v212, 17) ^ (v212 >> 10))
       + v222
       + v255
       + (__ROR4__(v226, 18) ^ __ROR4__(v226, 7) ^ (v226 >> 3));
  v16 = (__ROR4__(v278 + v14, 11) ^ __ROR4__(v278 + v14, 6) ^ __ROR4__(v278 + v14, 25))
      + ((v11 ^ v13) & (v278 + v14) ^ v11)
      + v3
      + v7
      + v286;
  v17 = v8 + v16;
  v18 = v16 + (v198 & v15 | (v198 | v15) & v10) + (__ROR4__(v15, 13) ^ __ROR4__(v15, 2) ^ __ROR4__(v15, 22));
  v19 = (__ROR4__(v17, 11) ^ __ROR4__(v17, 6) ^ __ROR4__(v17, 25))
      + ((v13 ^ (v278 + v14)) & v17 ^ v13)
      + v11
      + v237
      + 1508970993;
  v20 = v10 + v19;
  v21 = v19 + ((v15 | v18) & v198 | v15 & v18) + (__ROR4__(v18, 13) ^ __ROR4__(v18, 2) ^ __ROR4__(v18, 22));
  v227 = v226
       + v258
       + (__ROR4__(v229, 18) ^ __ROR4__(v229, 7) ^ (v229 >> 3))
       + (__ROR4__(v217, 19) ^ __ROR4__(v217, 17) ^ (v217 >> 10));
  v22 = (__ROR4__(v20, 11) ^ __ROR4__(v20, 6) ^ __ROR4__(v20, 25))
      + v13
      + v241
      - 1841331548
      + (((v278 + v14) ^ v17) & v20 ^ (v278 + v14));
  v23 = v198 + v22;
  v24 = v22 + (__ROR4__(v21, 13) ^ __ROR4__(v21, 2) ^ __ROR4__(v21, 22)) + ((v18 | v21) & v15 | v18 & v21);
  v25 = (__ROR4__(v23, 11) ^ __ROR4__(v23, 6) ^ __ROR4__(v23, 25))
      + ((v17 ^ v20) & v23 ^ v17)
      + v278
      + v14
      + v268
      - 1424204075;
  v26 = v15 + v25;
  v27 = v25 + (__ROR4__(v24, 13) ^ __ROR4__(v24, 2) ^ __ROR4__(v24, 22)) + ((v21 | v24) & v18 | v21 & v24);
  v28 = (__ROR4__(v26, 11) ^ __ROR4__(v26, 6) ^ __ROR4__(v26, 25)) + v17 + v247 - 670586216 + ((v20 ^ v23) & v26 ^ v20);
  v29 = v18 + v28;
  v30 = v28 + (__ROR4__(v27, 13) ^ __ROR4__(v27, 2) ^ __ROR4__(v27, 22)) + ((v24 | v27) & v21 | v24 & v27);
  v230 = (__ROR4__(v223, 19) ^ __ROR4__(v223, 17) ^ (v223 >> 10))
       + (__ROR4__(v233, 18) ^ __ROR4__(v233, 7) ^ (v233 >> 3))
       + v229
       + v261;
  v31 = (__ROR4__(v29, 11) ^ __ROR4__(v29, 6) ^ __ROR4__(v29, 25)) + v20 + v251 + 310598401 + ((v23 ^ v26) & v29 ^ v23);
  v32 = (v27 & v30 | (v27 | v30) & v24) + (__ROR4__(v30, 13) ^ __ROR4__(v30, 2) ^ __ROR4__(v30, 22)) + v31;
  v199 = v21 + v31;
  v33 = v23
      + v255
      + 607225278
      + ((v26 ^ v29) & v199 ^ v26)
      + (__ROR4__(v21 + v31, 11) ^ __ROR4__(v21 + v31, 6) ^ __ROR4__(v199, 25));
  v34 = v24 + v33;
  v35 = __ROR4__(v24 + v33, 11);
  v36 = v33 + ((v30 | v32) & v27 | v30 & v32) + (__ROR4__(v32, 13) ^ __ROR4__(v32, 2) ^ __ROR4__(v32, 22));
  v37 = v26 + v258 + 1426881987 + ((v29 ^ v199) & v34 ^ v29) + (v35 ^ __ROR4__(v34, 6) ^ __ROR4__(v34, 25));
  v38 = v27 + v37;
  v39 = v37 + (__ROR4__(v36, 13) ^ __ROR4__(v36, 2) ^ __ROR4__(v36, 22)) + ((v32 | v36) & v30 | v32 & v36);
  v40 = (__ROR4__(v38, 11) ^ __ROR4__(v38, 6) ^ __ROR4__(v38, 25))
      + ((v199 ^ v34) & v38 ^ v199)
      + v29
      + v261
      + 1925078388;
  v41 = v30 + v40;
  v42 = v40 + (__ROR4__(v39, 13) ^ __ROR4__(v39, 2) ^ __ROR4__(v39, 22)) + ((v36 | v39) & v32 | v36 & v39);
  v234 = v233
       + v265
       + (__ROR4__(v237, 18) ^ __ROR4__(v237, 7) ^ (v237 >> 3))
       + (__ROR4__(v227, 19) ^ __ROR4__(v227, 17) ^ (v227 >> 10));
  v43 = v199
      + v265
      - 2132889090
      + ((v34 ^ v38) & v41 ^ v34)
      + (__ROR4__(v41, 11) ^ __ROR4__(v41, 6) ^ __ROR4__(v41, 25));
  v44 = v32 + v43;
  v45 = v43 + (__ROR4__(v42, 13) ^ __ROR4__(v42, 2) ^ __ROR4__(v42, 22)) + (v39 & v42 | (v39 | v42) & v36);
  v46 = v34 + v206 - 1680079193 + ((v38 ^ v41) & v44 ^ v38) + (__ROR4__(v44, 11) ^ __ROR4__(v44, 6) ^ __ROR4__(v44, 25));
  v47 = v36 + v46;
  v48 = __ROR4__(v36 + v46, 11);
  v49 = v46 + ((v42 | v45) & v39 | v42 & v45) + (__ROR4__(v45, 13) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22));
  v200 = v47;
  v50 = (v48 ^ __ROR4__(v47, 6) ^ __ROR4__(v200, 25)) + v38 + v212 - 1046744716 + ((v41 ^ v44) & v200 ^ v41);
  v51 = v39 + v50;
  v52 = (v45 & v49 | (v45 | v49) & v42) + (__ROR4__(v49, 13) ^ __ROR4__(v49, 2) ^ __ROR4__(v49, 22)) + v50;
  v238 = v237
       + v206
       + (__ROR4__(v241, 18) ^ __ROR4__(v241, 7) ^ (v241 >> 3))
       + (__ROR4__(v230, 19) ^ __ROR4__(v230, 17) ^ (v230 >> 10));
  v53 = v41 + v217 - 459576895 + ((v44 ^ v47) & v51 ^ v44) + (__ROR4__(v51, 11) ^ __ROR4__(v51, 6) ^ __ROR4__(v51, 25));
  v54 = v241 + v212;
  v55 = v42 + v53;
  v242 = v53 + (__ROR4__(v52, 13) ^ __ROR4__(v52, 2) ^ __ROR4__(v52, 22)) + ((v49 | v52) & v45 | v49 & v52);
  v56 = ((v200 ^ v51) & v55 ^ v200)
      + v44
      + v223
      - 272742522
      + (__ROR4__(v55, 11) ^ __ROR4__(v55, 6) ^ __ROR4__(v55, 25));
  v57 = v45 + v56;
  v58 = __ROR4__(v45 + v56, 11);
  v59 = v56 + ((v52 | v242) & v49 | v52 & v242) + (__ROR4__(v242, 13) ^ __ROR4__(v242, 2) ^ __ROR4__(v242, 22));
  v60 = ((v51 ^ v55) & v57 ^ v51) + v200 + v227 + 264347078 + (v58 ^ __ROR4__(v57, 6) ^ __ROR4__(v57, 25));
  v61 = v49 + v60;
  v62 = v60 + (__ROR4__(v59, 13) ^ __ROR4__(v59, 2) ^ __ROR4__(v59, 22)) + ((v242 | v59) & v52 | v242 & v59);
  v63 = ((v55 ^ v57) & v61 ^ v55) + v51 + v230 + 604807628 + (__ROR4__(v61, 11) ^ __ROR4__(v61, 6) ^ __ROR4__(v61, 25));
  v64 = v52 + v63;
  v65 = v63 + ((v59 | v62) & v242 | v59 & v62) + (__ROR4__(v62, 13) ^ __ROR4__(v62, 2) ^ __ROR4__(v62, 22));
  v271 = v54
       + (__ROR4__(v268, 18) ^ __ROR4__(v268, 7) ^ (v268 >> 3))
       + (__ROR4__(v234, 19) ^ __ROR4__(v234, 17) ^ (v234 >> 10));
  v66 = v55 + v234 + 770255983 + ((v57 ^ v61) & v64 ^ v57) + (__ROR4__(v64, 11) ^ __ROR4__(v64, 6) ^ __ROR4__(v64, 25));
  v67 = v242 + v66;
  v68 = v66 + (v62 & v65 | (v62 | v65) & v59) + (__ROR4__(v65, 13) ^ __ROR4__(v65, 2) ^ __ROR4__(v65, 22));
  v69 = ((v61 ^ v64) & v67 ^ v61) + v57 + v238 + 1249150122 + (__ROR4__(v67, 11) ^ __ROR4__(v67, 6) ^ __ROR4__(v67, 25));
  v70 = v59 + v69;
  v71 = v69 + ((v65 | v68) & v62 | v65 & v68) + (__ROR4__(v68, 13) ^ __ROR4__(v68, 2) ^ __ROR4__(v68, 22));
  v72 = (__ROR4__(v70, 11) ^ __ROR4__(v70, 6) ^ __ROR4__(v70, 25)) + ((v64 ^ v67) & v70 ^ v64) + v271 + 1555081692 + v61;
  v73 = v62 + v72;
  v74 = v72 + ((v68 | v71) & v65 | v68 & v71) + (__ROR4__(v71, 13) ^ __ROR4__(v71, 2) ^ __ROR4__(v71, 22));
  v243 = (__ROR4__(v247, 18) ^ __ROR4__(v247, 7) ^ (v247 >> 3))
       + v268
       + v217
       + (__ROR4__(v238, 19) ^ __ROR4__(v238, 17) ^ (v238 >> 10));
  v75 = ((v67 ^ v70) & v73 ^ v67) + v243 + 1996064986 + v64 + (__ROR4__(v73, 11) ^ __ROR4__(v73, 6) ^ __ROR4__(v73, 25));
  v76 = v65 + v75;
  v77 = v75 + (__ROR4__(v74, 13) ^ __ROR4__(v74, 2) ^ __ROR4__(v74, 22)) + ((v71 | v74) & v68 | v71 & v74);
  v78 = (__ROR4__(v271, 19) ^ __ROR4__(v271, 17) ^ (v271 >> 10))
      + (__ROR4__(v251, 18) ^ __ROR4__(v251, 7) ^ (v251 >> 3))
      + v247
      + v223;
  v79 = ((v70 ^ v73) & v76 ^ v70) + v67 + v78 - 1740746414 + (__ROR4__(v76, 11) ^ __ROR4__(v76, 6) ^ __ROR4__(v76, 25));
  v248 = v68 + v79;
  v80 = __ROR4__(v68 + v79, 11);
  v81 = v79 + ((v74 | v77) & v71 | v74 & v77) + (__ROR4__(v77, 13) ^ __ROR4__(v77, 2) ^ __ROR4__(v77, 22));
  v252 = (__ROR4__(v243, 19) ^ __ROR4__(v243, 17) ^ (v243 >> 10))
       + (__ROR4__(v255, 18) ^ __ROR4__(v255, 7) ^ (v255 >> 3))
       + v251
       + v227;
  v82 = (v80 ^ __ROR4__(v248, 6) ^ __ROR4__(v248, 25)) + ((v73 ^ v76) & v248 ^ v73) + v70 + v252 - 1473132947;
  v83 = v71 + v82;
  v84 = ((v77 | v81) & v74 | v77 & v81) + (__ROR4__(v81, 13) ^ __ROR4__(v81, 2) ^ __ROR4__(v81, 22)) + v82;
  v256 = (__ROR4__(v258, 18) ^ __ROR4__(v258, 7) ^ (v258 >> 3))
       + v255
       + v230
       + (__ROR4__(v78, 19) ^ __ROR4__(v78, 17) ^ (v78 >> 10));
  v85 = ((v76 ^ v248) & v83 ^ v76)
      + v73
      + v256
      - 1341970488
      + (__ROR4__(v83, 11) ^ __ROR4__(v83, 6) ^ __ROR4__(v83, 25));
  v201 = v85 + (__ROR4__(v84, 13) ^ __ROR4__(v84, 2) ^ __ROR4__(v84, 22)) + ((v81 | v84) & v77 | v81 & v84);
  v86 = v74 + v85;
  v282 = (__ROR4__(v252, 19) ^ __ROR4__(v252, 17) ^ (v252 >> 10))
       + (__ROR4__(v261, 18) ^ __ROR4__(v261, 7) ^ (v261 >> 3))
       + v258
       + v234;
  v87 = ((v248 ^ v83) & v86 ^ v248)
      + v76
      + v282
      - 1084653625
      + (__ROR4__(v86, 11) ^ __ROR4__(v86, 6) ^ __ROR4__(v86, 25));
  v88 = v77 + v87;
  v89 = v87 + ((v84 | v201) & v81 | v84 & v201) + (__ROR4__(v201, 13) ^ __ROR4__(v201, 2) ^ __ROR4__(v201, 22));
  v259 = (__ROR4__(v265, 18) ^ __ROR4__(v265, 7) ^ (v265 >> 3))
       + v261
       + v238
       + (__ROR4__(v256, 19) ^ __ROR4__(v256, 17) ^ (v256 >> 10));
  v90 = ((v83 ^ v86) & v88 ^ v83) + v259 - 958395405 + v248 + (__ROR4__(v88, 11) ^ __ROR4__(v88, 6) ^ __ROR4__(v88, 25));
  v91 = v81 + v90;
  v92 = v90 + (v201 & v89 | (v201 | v89) & v84) + (__ROR4__(v89, 13) ^ __ROR4__(v89, 2) ^ __ROR4__(v89, 22));
  v249 = (__ROR4__(v282, 19) ^ __ROR4__(v282, 17) ^ (v282 >> 10))
       + (__ROR4__(v206, 18) ^ __ROR4__(v206, 7) ^ (v206 >> 3))
       + v265
       + v271;
  v93 = (__ROR4__(v91, 11) ^ __ROR4__(v91, 6) ^ __ROR4__(v91, 25)) + ((v86 ^ v88) & v91 ^ v86) + v83 + v249 - 710438585;
  v94 = v84 + v93;
  v95 = ((v89 | v92) & v201 | v89 & v92) + (__ROR4__(v92, 13) ^ __ROR4__(v92, 2) ^ __ROR4__(v92, 22)) + v93;
  v262 = (__ROR4__(v212, 18) ^ __ROR4__(v212, 7) ^ (v212 >> 3))
       + v206
       + v243
       + (__ROR4__(v259, 19) ^ __ROR4__(v259, 17) ^ (v259 >> 10));
  v96 = ((v88 ^ v91) & v94 ^ v88)
      + v86
      + v262
      + 113926993
      + (__ROR4__(v84 + v93, 11) ^ __ROR4__(v94, 6) ^ __ROR4__(v94, 25));
  v207 = v201 + v96;
  v97 = v96 + (__ROR4__(v95, 13) ^ __ROR4__(v95, 2) ^ __ROR4__(v95, 22)) + ((v92 | v95) & v89 | v92 & v95);
  v266 = (__ROR4__(v217, 18) ^ __ROR4__(v217, 7) ^ (v217 >> 3))
       + v212
       + v78
       + (__ROR4__(v249, 19) ^ __ROR4__(v249, 17) ^ (v249 >> 10));
  v98 = ((v91 ^ (v84 + v93)) & v207 ^ v91)
      + v88
      + v266
      + 338241895
      + (__ROR4__(v207, 11) ^ __ROR4__(v207, 6) ^ __ROR4__(v207, 25));
  v99 = v89 + v98;
  v202 = v98 + (__ROR4__(v97, 13) ^ __ROR4__(v97, 2) ^ __ROR4__(v97, 22)) + ((v95 | v97) & v92 | v95 & v97);
  v269 = (__ROR4__(v223, 18) ^ __ROR4__(v223, 7) ^ (v223 >> 3))
       + v217
       + v252
       + (__ROR4__(v262, 19) ^ __ROR4__(v262, 17) ^ (v262 >> 10));
  v100 = (__ROR4__(v99, 11) ^ __ROR4__(v99, 6) ^ __ROR4__(v99, 25))
       + ((v94 ^ v207) & v99 ^ v94)
       + v91
       + v269
       + 666307205;
  v101 = ((v97 | v202) & v95 | v97 & v202) + (__ROR4__(v202, 13) ^ __ROR4__(v202, 2) ^ __ROR4__(v202, 22)) + v100;
  v213 = v92 + v100;
  v283 = (__ROR4__(v227, 18) ^ __ROR4__(v227, 7) ^ (v227 >> 3))
       + v223
       + v256
       + (__ROR4__(v266, 19) ^ __ROR4__(v266, 17) ^ (v266 >> 10));
  v102 = (__ROR4__(v92 + v100, 11) ^ __ROR4__(v92 + v100, 6) ^ __ROR4__(v213, 25))
       + ((v207 ^ v99) & v213 ^ v207)
       + v283
       + 773529912
       + v94;
  v103 = v95 + v102;
  v104 = ((v202 | v101) & v97 | v202 & v101) + (__ROR4__(v101, 13) ^ __ROR4__(v101, 2) ^ __ROR4__(v101, 22)) + v102;
  v224 = (__ROR4__(v269, 19) ^ __ROR4__(v269, 17) ^ (v269 >> 10))
       + (__ROR4__(v230, 18) ^ __ROR4__(v230, 7) ^ (v230 >> 3))
       + v227
       + v282;
  v105 = ((v99 ^ (v92 + v100)) & v103 ^ v99)
       + v207
       + v224
       + 1294757372
       + (__ROR4__(v103, 11) ^ __ROR4__(v103, 6) ^ __ROR4__(v103, 25));
  v106 = v97 + v105;
  v107 = v105 + (__ROR4__(v104, 13) ^ __ROR4__(v104, 2) ^ __ROR4__(v104, 22)) + ((v101 | v104) & v202 | v101 & v104);
  v231 = v230
       + (__ROR4__(v234, 18) ^ __ROR4__(v234, 7) ^ (v234 >> 3))
       + v259
       + (__ROR4__(v283, 19) ^ __ROR4__(v283, 17) ^ (v283 >> 10));
  v108 = ((v213 ^ v103) & v106 ^ v213)
       + v99
       + v231
       + 1396182291
       + (__ROR4__(v106, 11) ^ __ROR4__(v106, 6) ^ __ROR4__(v106, 25));
  v109 = v202 + v108;
  v203 = v108 + (__ROR4__(v107, 13) ^ __ROR4__(v107, 2) ^ __ROR4__(v107, 22)) + ((v104 | v107) & v101 | v104 & v107);
  v235 = (__ROR4__(v238, 18) ^ __ROR4__(v238, 7) ^ (v238 >> 3))
       + v234
       + v249
       + (__ROR4__(v224, 19) ^ __ROR4__(v224, 17) ^ (v224 >> 10));
  v110 = ((v103 ^ v106) & v109 ^ v103)
       + v235
       + 1695183700
       + v92
       + v100
       + (__ROR4__(v109, 11) ^ __ROR4__(v109, 6) ^ __ROR4__(v109, 25));
  v111 = v101 + v110;
  v112 = v110 + (__ROR4__(v203, 13) ^ __ROR4__(v203, 2) ^ __ROR4__(v203, 22)) + ((v107 | v203) & v104 | v107 & v203);
  v274 = (__ROR4__(v271, 18) ^ __ROR4__(v271, 7) ^ (v271 >> 3))
       + v238
       + v262
       + (__ROR4__(v231, 19) ^ __ROR4__(v231, 17) ^ (v231 >> 10));
  v113 = (__ROR4__(v111, 11) ^ __ROR4__(v111, 6) ^ __ROR4__(v111, 25))
       + ((v106 ^ v109) & v111 ^ v106)
       + v274
       + 1986661051
       + v103;
  v208 = v104 + v113;
  v114 = ((v203 | v112) & v107 | v203 & v112) + (__ROR4__(v112, 13) ^ __ROR4__(v112, 2) ^ __ROR4__(v112, 22)) + v113;
  v239 = (__ROR4__(v243, 18) ^ __ROR4__(v243, 7) ^ (v243 >> 3))
       + v271
       + v266
       + (__ROR4__(v235, 19) ^ __ROR4__(v235, 17) ^ (v235 >> 10));
  v115 = (__ROR4__(v104 + v113, 11) ^ __ROR4__(v104 + v113, 6) ^ __ROR4__(v104 + v113, 25))
       + ((v109 ^ v111) & (v104 + v113) ^ v109)
       + v239
       - 2117940946
       + v106;
  v116 = v107 + v115;
  v117 = ((v112 | v114) & v203 | v112 & v114) + (__ROR4__(v114, 13) ^ __ROR4__(v114, 2) ^ __ROR4__(v114, 22)) + v115;
  v118 = v243
       + (__ROR4__(v78, 18) ^ __ROR4__(v78, 7) ^ (v78 >> 3))
       + v269
       + (__ROR4__(v274, 19) ^ __ROR4__(v274, 17) ^ (v274 >> 10));
  v119 = ((v111 ^ v208) & v116 ^ v111)
       + v109
       + v118
       - 1838011259
       + (__ROR4__(v116, 11) ^ __ROR4__(v116, 6) ^ __ROR4__(v116, 25));
  v120 = v203 + v119;
  v121 = v119 + (__ROR4__(v117, 13) ^ __ROR4__(v117, 2) ^ __ROR4__(v117, 22)) + ((v114 | v117) & v112 | v114 & v117);
  v272 = v78
       + (__ROR4__(v252, 18) ^ __ROR4__(v252, 7) ^ (v252 >> 3))
       + v283
       + (__ROR4__(v239, 19) ^ __ROR4__(v239, 17) ^ (v239 >> 10));
  v244 = v118;
  v122 = ((v208 ^ v116) & v120 ^ v208)
       + v111
       + v272
       - 1564481375
       + (__ROR4__(v120, 11) ^ __ROR4__(v120, 6) ^ __ROR4__(v120, 25));
  v123 = v112 + v122;
  v214 = v122 + (__ROR4__(v121, 13) ^ __ROR4__(v121, 2) ^ __ROR4__(v121, 22)) + ((v117 | v121) & v114 | v117 & v121);
  v253 = (__ROR4__(v118, 19) ^ __ROR4__(v118, 17) ^ (v118 >> 10))
       + (__ROR4__(v256, 18) ^ __ROR4__(v256, 7) ^ (v256 >> 3))
       + v252
       + v224;
  v124 = ((v116 ^ v120) & v123 ^ v116)
       + v208
       + v253
       - 1474664885
       + (__ROR4__(v123, 11) ^ __ROR4__(v123, 6) ^ __ROR4__(v123, 25));
  v125 = v114 + v124;
  v126 = v124 + (__ROR4__(v214, 13) ^ __ROR4__(v214, 2) ^ __ROR4__(v214, 22)) + ((v121 | v214) & v117 | v121 & v214);
  v277 = (__ROR4__(v272, 19) ^ __ROR4__(v272, 17) ^ (v272 >> 10))
       + (__ROR4__(v282, 18) ^ __ROR4__(v282, 7) ^ (v282 >> 3))
       + v256
       + v231;
  v127 = ((v120 ^ v123) & v125 ^ v120)
       + v116
       + v277
       - 1035236496
       + (__ROR4__(v125, 11) ^ __ROR4__(v125, 6) ^ __ROR4__(v125, 25));
  v128 = v117 + v127;
  v129 = v127 + (__ROR4__(v126, 13) ^ __ROR4__(v126, 2) ^ __ROR4__(v126, 22)) + ((v214 | v126) & v121 | v214 & v126);
  v204 = (__ROR4__(v253, 19) ^ __ROR4__(v253, 17) ^ (v253 >> 10))
       + (__ROR4__(v259, 18) ^ __ROR4__(v259, 7) ^ (v259 >> 3))
       + v282
       + v235;
  v130 = ((v123 ^ v125) & v128 ^ v123)
       + v120
       + v204
       - 949202525
       + (__ROR4__(v128, 11) ^ __ROR4__(v128, 6) ^ __ROR4__(v128, 25));
  v131 = v121 + v130;
  v132 = v130 + (__ROR4__(v129, 13) ^ __ROR4__(v129, 2) ^ __ROR4__(v129, 22)) + ((v126 | v129) & v214 | v126 & v129);
  v209 = (__ROR4__(v277, 19) ^ __ROR4__(v277, 17) ^ (v277 >> 10))
       + (__ROR4__(v249, 18) ^ __ROR4__(v249, 7) ^ (v249 >> 3))
       + v259
       + v274;
  v133 = ((v125 ^ v128) & v131 ^ v125)
       + v123
       + v209
       - 778901479
       + (__ROR4__(v131, 11) ^ __ROR4__(v131, 6) ^ __ROR4__(v131, 25));
  v134 = v214 + v133;
  v135 = v133 + (__ROR4__(v132, 13) ^ __ROR4__(v132, 2) ^ __ROR4__(v132, 22)) + ((v129 | v132) & v126 | v129 & v132);
  v215 = (__ROR4__(v262, 18) ^ __ROR4__(v262, 7) ^ (v262 >> 3))
       + v249
       + v239
       + (__ROR4__(v204, 19) ^ __ROR4__(v204, 17) ^ (v204 >> 10));
  v136 = ((v128 ^ v131) & v134 ^ v128)
       + v215
       - 694614492
       + v125
       + (__ROR4__(v134, 11) ^ __ROR4__(v134, 6) ^ __ROR4__(v134, 25));
  v137 = v126 + v136;
  v138 = v136 + (__ROR4__(v135, 13) ^ __ROR4__(v135, 2) ^ __ROR4__(v135, 22)) + ((v132 | v135) & v129 | v132 & v135);
  v228 = (__ROR4__(v266, 18) ^ __ROR4__(v266, 7) ^ (v266 >> 3))
       + v262
       + v244
       + (__ROR4__(v209, 19) ^ __ROR4__(v209, 17) ^ (v209 >> 10));
  v139 = ((v131 ^ v134) & v137 ^ v131)
       + v228
       - 200395387
       + v128
       + (__ROR4__(v137, 11) ^ __ROR4__(v137, 6) ^ __ROR4__(v137, 25));
  v140 = v129 + v139;
  v218 = v139 + (__ROR4__(v138, 13) ^ __ROR4__(v138, 2) ^ __ROR4__(v138, 22)) + ((v135 | v138) & v132 | v135 & v138);
  v250 = (__ROR4__(v269, 18) ^ __ROR4__(v269, 7) ^ (v269 >> 3))
       + v266
       + v272
       + (__ROR4__(v215, 19) ^ __ROR4__(v215, 17) ^ (v215 >> 10));
  v141 = ((v134 ^ v137) & v140 ^ v134)
       + v131
       + v250
       + 275423344
       + (__ROR4__(v140, 11) ^ __ROR4__(v140, 6) ^ __ROR4__(v140, 25));
  v142 = v132 + v141;
  v257 = (__ROR4__(v283, 18) ^ __ROR4__(v283, 7) ^ (v283 >> 3))
       + v269
       + v253
       + (__ROR4__(v228, 19) ^ __ROR4__(v228, 17) ^ (v228 >> 10));
  v143 = v141 + (__ROR4__(v218, 13) ^ __ROR4__(v218, 2) ^ __ROR4__(v218, 22)) + ((v138 | v218) & v135 | v138 & v218);
  v144 = ((v137 ^ v140) & v142 ^ v137)
       + v257
       + 430227734
       + v134
       + (__ROR4__(v142, 11) ^ __ROR4__(v142, 6) ^ __ROR4__(v142, 25));
  v145 = v135 + v144;
  v146 = v144 + (__ROR4__(v143, 13) ^ __ROR4__(v143, 2) ^ __ROR4__(v143, 22)) + ((v218 | v143) & v138 | v218 & v143);
  v147 = (__ROR4__(v250, 19) ^ __ROR4__(v250, 17) ^ (v250 >> 10))
       + (__ROR4__(v224, 18) ^ __ROR4__(v224, 7) ^ (v224 >> 3))
       + v283
       + v277;
  v148 = ((v140 ^ v142) & v145 ^ v140)
       + v147
       + 506948616
       + v137
       + (__ROR4__(v145, 11) ^ __ROR4__(v145, 6) ^ __ROR4__(v145, 25));
  v149 = v138 + v148;
  v150 = v148 + ((v143 | v146) & v218 | v143 & v146) + (__ROR4__(v146, 13) ^ __ROR4__(v146, 2) ^ __ROR4__(v146, 22));
  v151 = (__ROR4__(v257, 19) ^ __ROR4__(v257, 17) ^ (v257 >> 10))
       + (__ROR4__(v231, 18) ^ __ROR4__(v231, 7) ^ (v231 >> 3))
       + v224
       + v204;
  v152 = ((v142 ^ v145) & v149 ^ v142)
       + v140
       + v151
       + 659060556
       + (__ROR4__(v149, 11) ^ __ROR4__(v149, 6) ^ __ROR4__(v149, 25));
  v263 = v151;
  v153 = v218 + v152;
  v219 = v152 + (__ROR4__(v150, 13) ^ __ROR4__(v150, 2) ^ __ROR4__(v150, 22)) + ((v146 | v150) & v143 | v146 & v150);
  v154 = v153;
  v267 = (__ROR4__(v235, 18) ^ __ROR4__(v235, 7) ^ (v235 >> 3))
       + v231
       + v209
       + (__ROR4__(v147, 19) ^ __ROR4__(v147, 17) ^ (v147 >> 10));
  v155 = ((v145 ^ v149) & v154 ^ v145)
       + v142
       + v267
       + 883997877
       + (__ROR4__(v154, 11) ^ __ROR4__(v154, 6) ^ __ROR4__(v154, 25));
  v156 = v143 + v155;
  v157 = v155 + ((v150 | v219) & v146 | v150 & v219) + (__ROR4__(v219, 13) ^ __ROR4__(v219, 2) ^ __ROR4__(v219, 22));
  v270 = (__ROR4__(v263, 19) ^ __ROR4__(v263, 17) ^ (v263 >> 10))
       + (__ROR4__(v274, 18) ^ __ROR4__(v274, 7) ^ (v274 >> 3))
       + v235
       + v215;
  v158 = ((v149 ^ v153) & v156 ^ v149)
       + v145
       + v270
       + 958139571
       + (__ROR4__(v156, 11) ^ __ROR4__(v156, 6) ^ __ROR4__(v156, 25));
  v159 = v146 + v158;
  v160 = v158 + (__ROR4__(v157, 13) ^ __ROR4__(v157, 2) ^ __ROR4__(v157, 22)) + ((v219 | v157) & v150 | v219 & v157);
  v275 = (__ROR4__(v267, 19) ^ __ROR4__(v267, 17) ^ (v267 >> 10))
       + (__ROR4__(v239, 18) ^ __ROR4__(v239, 7) ^ (v239 >> 3))
       + v274
       + v228;
  v161 = (__ROR4__(v159, 11) ^ __ROR4__(v159, 6) ^ __ROR4__(v159, 25))
       + ((v154 ^ v156) & v159 ^ v154)
       + v275
       + 1322822218
       + v149;
  v162 = v150 + v161;
  v163 = ((v157 | v160) & v219 | v157 & v160) + (__ROR4__(v160, 13) ^ __ROR4__(v160, 2) ^ __ROR4__(v160, 22)) + v161;
  v164 = (__ROR4__(v244, 18) ^ __ROR4__(v244, 7) ^ (v244 >> 3))
       + v239
       + v250
       + (__ROR4__(v270, 19) ^ __ROR4__(v270, 17) ^ (v270 >> 10));
  v165 = v164 + 1537002063;
  v240 = v164;
  v166 = v219;
  v167 = (__ROR4__(v150 + v161, 11) ^ __ROR4__(v162, 6) ^ __ROR4__(v162, 25))
       + ((v156 ^ v159) & v162 ^ v156)
       + v165
       + v154;
  v220 = (v160 & v163 | (v160 | v163) & v157) + (__ROR4__(v163, 13) ^ __ROR4__(v163, 2) ^ __ROR4__(v163, 22)) + v167;
  v168 = v166 + v167;
  v245 = (__ROR4__(v272, 18) ^ __ROR4__(v272, 7) ^ (v272 >> 3))
       + v244
       + v257
       + (__ROR4__(v275, 19) ^ __ROR4__(v275, 17) ^ (v275 >> 10));
  v169 = (__ROR4__(v168, 11) ^ __ROR4__(v168, 6) ^ __ROR4__(v168, 25))
       + v245
       + 1747873779
       + v156
       + ((v159 ^ v162) & v168 ^ v159);
  v170 = v157 + v169;
  v236 = (__ROR4__(v253, 18) ^ __ROR4__(v253, 7) ^ (v253 >> 3))
       + v272
       + v147
       + (__ROR4__(v240, 19) ^ __ROR4__(v240, 17) ^ (v240 >> 10));
  v171 = (__ROR4__(v170, 11) ^ __ROR4__(v170, 6) ^ __ROR4__(v170, 25))
       + ((v162 ^ v168) & v170 ^ v162)
       + v159
       + v236
       + 1955562222;
  v260 = (__ROR4__(v220, 13) ^ __ROR4__(v220, 2) ^ __ROR4__(v220, 22)) + ((v163 | v220) & v160 | v163 & v220) + v169;
  v225 = v160 + v171;
  v232 = v171 + ((v220 | v260) & v163 | v220 & v260) + (__ROR4__(v260, 13) ^ __ROR4__(v260, 2) ^ __ROR4__(v260, 22));
  v172 = (__ROR4__(v245, 19) ^ __ROR4__(v245, 17) ^ (v245 >> 10))
       + v263
       + (__ROR4__(v277, 18) ^ __ROR4__(v277, 7) ^ (v277 >> 3))
       + v253;
  v173 = ((v168 ^ v170) & (v160 + v171) ^ v168)
       + v172
       + 2024104815
       + v162
       + (__ROR4__(v160 + v171, 11) ^ __ROR4__(v160 + v171, 6) ^ __ROR4__(v160 + v171, 25));
  v174 = (__ROR4__(v204, 18) ^ __ROR4__(v204, 7) ^ (v204 >> 3))
       + v277
       + v267
       + (__ROR4__(v236, 19) ^ __ROR4__(v236, 17) ^ (v236 >> 10));
  v175 = v163 + v173;
  v176 = __ROR4__(v163 + v173, 11);
  v177 = v173 + ((v260 | v232) & v220 | v232 & v260) + (__ROR4__(v232, 13) ^ __ROR4__(v232, 2) ^ __ROR4__(v232, 22));
  v254 = v175;
  v178 = v168 + v174 - 2067236844 + ((v170 ^ v225) & v175 ^ v170) + (v176 ^ __ROR4__(v175, 6) ^ __ROR4__(v175, 25));
  v179 = (__ROR4__(v177, 13) ^ __ROR4__(v177, 2) ^ __ROR4__(v177, 22)) + (v232 & v177 | (v232 | v177) & v260) + v178;
  v180 = (__ROR4__(v172, 19) ^ __ROR4__(v172, 17) ^ (v172 >> 10))
       + v204
       + (__ROR4__(v209, 18) ^ __ROR4__(v209, 7) ^ (v209 >> 3))
       + v270;
  v181 = __ROR4__(v220 + v178, 11) ^ __ROR4__(v220 + v178, 6);
  v221 = v220 + v178;
  v264 = __ROR4__(v180, 19) ^ __ROR4__(v180, 17) ^ (v180 >> 10);
  v182 = v170 + v180 - 1933114872 + ((v225 ^ v175) & v221 ^ v225) + (v181 ^ __ROR4__(v221, 25));
  v183 = (__ROR4__(v179, 13) ^ __ROR4__(v179, 2) ^ __ROR4__(v179, 22)) + ((v177 | v179) & v232 | v177 & v179) + v182;
  v184 = (__ROR4__(v215, 18) ^ __ROR4__(v215, 7) ^ (v215 >> 3)) + v209;
  v210 = v260 + v182;
  v185 = (__ROR4__(v174, 19) ^ __ROR4__(v174, 17) ^ (v174 >> 10)) + v184 + v275;
  v186 = v185
       - 1866530822
       + v225
       + ((v175 ^ v221) & (v260 + v182) ^ v175)
       + (__ROR4__(v260 + v182, 11) ^ __ROR4__(v260 + v182, 6) ^ __ROR4__(v260 + v182, 25));
  v187 = ((v179 | v183) & v177 | v179 & v183) + (__ROR4__(v183, 13) ^ __ROR4__(v183, 2) ^ __ROR4__(v183, 22)) + v186;
  v188 = (__ROR4__(v228, 18) ^ __ROR4__(v228, 7) ^ (v228 >> 3)) + v215 + v240;
  v189 = v232 + v186;
  v190 = v188
       + v264
       - 1538233109
       + v254
       + ((v210 ^ v221) & v189 ^ v221)
       + (__ROR4__(v232 + v186, 11) ^ __ROR4__(v189, 6) ^ __ROR4__(v189, 25));
  v191 = ((v183 | v187) & v179 | v183 & v187) + (__ROR4__(v187, 13) ^ __ROR4__(v187, 2) ^ __ROR4__(v187, 22)) + v190;
  v192 = (__ROR4__(v177 + v190, 11) ^ __ROR4__(v177 + v190, 6) ^ __ROR4__(v177 + v190, 25))
       + ((v210 ^ v189) & (v177 + v190) ^ v210)
       + v228
       - 1090935817
       + (__ROR4__(v250, 18) ^ __ROR4__(v250, 7) ^ (v250 >> 3))
       + v245
       + (__ROR4__(v185, 19) ^ __ROR4__(v185, 17) ^ (v185 >> 10))
       + v221;
  v193 = ((v187 | v191) & v183 | v187 & v191) + (__ROR4__(v191, 13) ^ __ROR4__(v191, 2) ^ __ROR4__(v191, 22)) + v192;
  v194 = v192 + v179;
  v195 = v250
       - 965641998
       + (__ROR4__(v257, 18) ^ __ROR4__(v257, 7) ^ (v257 >> 3))
       + v236
       + (__ROR4__(v188 + v264, 19) ^ __ROR4__(v188 + v264, 17) ^ ((v188 + v264) >> 10))
       + v210
       + ((v189 ^ (v177 + v190)) & v194 ^ v189)
       + (__ROR4__(v194, 11) ^ __ROR4__(v194, 6) ^ __ROR4__(v194, 25));
  v196 = ((v191 | v193) & v187 | v191 & v193) + (__ROR4__(v193, 13) ^ __ROR4__(v193, 2) ^ __ROR4__(v193, 22)) + v278;
  result = v187 + v286;
  a1[9] = v287 + v189;
  a1[5] = result;
  a1[8] = v177 + v190 + v285;
  a1[4] = v191 + v284;
  a1[3] = v193 + v279;
  a1[7] = v194 + v280;
  a1[2] = v196 + v195;
  a1[6] = v183 + v246 + v195;
  return result;
}

//----- (000451BC) --------------------------------------------------------
unsigned int *__fastcall sha2_update(unsigned int *result, void *src, int a3)
{
  signed int v3; // r4
  unsigned int *v4; // r6
  char *v5; // r5
  int v6; // r7
  unsigned int v7; // r3
  bool v8; // cc
  int v9; // lr
  int v10; // r3
  int v11; // r1
  int v12; // r8
  size_t v13; // r2
  char *v14; // r0

  v3 = a3;
  if ( a3 <= 0 )
    return result;
  v4 = result;
  v5 = (char *)src;
  v6 = *result & 0x3F;
  v7 = *result + a3;
  v8 = a3 > v7;
  *result = v7;
  if ( a3 > v7 )
    v7 = result[1];
  v9 = 64 - v6;
  if ( v8 )
    result[1] = v7 + 1;
  v10 = v6;
  if ( v6 )
    v10 = 1;
  if ( a3 < v9 )
    v10 = 0;
  if ( v10 )
  {
    v12 = (int)(result + 10);
    v13 = 64 - v6;
    v14 = (char *)result + v6 + 40;
    v3 -= v9;
    v5 = (char *)src + v9;
    v6 = 0;
    memcpy(v14, src, v13);
    result = (unsigned int *)sha2_process(v4, v12);
    if ( v3 <= 63 )
      goto LABEL_13;
  }
  else if ( a3 <= 63 )
  {
    return (unsigned int *)j_memcpy((char *)v4 + v6 + 40, v5, v3);
  }
  do
  {
    v11 = (int)v5;
    v3 -= 64;
    v5 += 64;
    result = (unsigned int *)sha2_process(v4, v11);
  }
  while ( v3 > 63 );
LABEL_13:
  if ( v3 > 0 )
    return (unsigned int *)j_memcpy((char *)v4 + v6 + 40, v5, v3);
  return result;
}

//----- (00045240) --------------------------------------------------------
unsigned int *__fastcall sha2_finish(int a1, _BYTE *a2)
{
  unsigned int v4; // r2
  int v5; // r1
  unsigned int v6; // r3
  unsigned int v7; // r0
  unsigned int v8; // r6
  unsigned int v9; // r3
  int v10; // r2
  unsigned int *result; // r0
  char v12[32]; // [sp+0h] [bp-20h] BYREF

  v4 = *(_DWORD *)a1 & 0x3F;
  v5 = *(_QWORD *)a1 >> 29;
  v6 = 8 * *(_DWORD *)a1;
  v7 = HIWORD(v6);
  v8 = HIBYTE(v6);
  v12[7] = v6;
  v12[3] = v5;
  v9 = v6 >> 8;
  v12[5] = v7;
  v12[2] = BYTE1(v5);
  if ( v4 > 55 )
    v10 = 120 - v4;
  else
    v10 = 56 - v4;
  v12[6] = v9;
  v12[0] = HIBYTE(v5);
  v12[1] = BYTE2(v5);
  v12[4] = v8;
  sha2_update((unsigned int *)a1, &sha2_padding, v10);
  result = sha2_update((unsigned int *)a1, v12, 8);
  *a2 = *(_BYTE *)(a1 + 11);
  a2[1] = *(_WORD *)(a1 + 10);
  a2[2] = BYTE1(*(_DWORD *)(a1 + 8));
  a2[3] = *(_DWORD *)(a1 + 8);
  a2[4] = *(_BYTE *)(a1 + 15);
  a2[5] = *(_WORD *)(a1 + 14);
  a2[6] = BYTE1(*(_DWORD *)(a1 + 12));
  a2[7] = *(_DWORD *)(a1 + 12);
  a2[8] = *(_BYTE *)(a1 + 19);
  a2[9] = *(_WORD *)(a1 + 18);
  a2[10] = BYTE1(*(_DWORD *)(a1 + 16));
  a2[11] = *(_DWORD *)(a1 + 16);
  a2[12] = *(_BYTE *)(a1 + 23);
  a2[13] = *(_WORD *)(a1 + 22);
  a2[14] = BYTE1(*(_DWORD *)(a1 + 20));
  a2[15] = *(_DWORD *)(a1 + 20);
  a2[16] = *(_BYTE *)(a1 + 27);
  a2[17] = *(_WORD *)(a1 + 26);
  a2[18] = BYTE1(*(_DWORD *)(a1 + 24));
  a2[19] = *(_DWORD *)(a1 + 24);
  a2[20] = *(_BYTE *)(a1 + 31);
  a2[21] = *(_WORD *)(a1 + 30);
  a2[22] = BYTE1(*(_DWORD *)(a1 + 28));
  a2[23] = *(_DWORD *)(a1 + 28);
  a2[24] = *(_BYTE *)(a1 + 35);
  a2[25] = *(_WORD *)(a1 + 34);
  a2[26] = BYTE1(*(_DWORD *)(a1 + 32));
  a2[27] = *(_DWORD *)(a1 + 32);
  a2[28] = *(_BYTE *)(a1 + 39);
  a2[29] = *(_WORD *)(a1 + 38);
  a2[30] = BYTE1(*(_DWORD *)(a1 + 36));
  a2[31] = *(_DWORD *)(a1 + 36);
  return result;
}

//----- (00045344) --------------------------------------------------------
unsigned int *__fastcall sha2(void *src, int a2, _BYTE *a3)
{
  unsigned int v5[64]; // [sp+0h] [bp-100h] BYREF

  v5[2] = 1779033703;
  v5[3] = -1150833019;
  v5[4] = 1013904242;
  v5[7] = -1694144372;
  v5[0] = 0;
  v5[1] = 0;
  v5[5] = -1521486534;
  v5[6] = 1359893119;
  v5[8] = 528734635;
  v5[9] = 1541459225;
  sha2_update(v5, src, a2);
  return sha2_finish((int)v5, a3);
}

//----- (000453C0) --------------------------------------------------------
int no_yield()
{
  return 0;
}

//----- (000453C4) --------------------------------------------------------
int __fastcall _stratum_send(int a1, char *a2, int a3)
{
  int v4; // r4
  int v5; // r11
  int v6; // r8
  int v7; // r8
  int v8; // r11
  fd_set *p_tv_usec; // r3
  int result; // r0
  ssize_t v11; // r0
  bool v12; // cc
  int v13; // r2
  __int64 v14; // r4
  __int64 v15; // r8
  __int64 v16; // r10
  int v17; // [sp+Ch] [bp-844h]
  size_t n; // [sp+10h] [bp-840h]
  struct timeval timeout; // [sp+20h] [bp-830h] BYREF
  fd_set writefds; // [sp+28h] [bp-828h] BYREF

  v4 = *(_DWORD *)(a1 + 588);
  if ( opt_protocol && (use_syslog || opt_log_output || opt_log_level > 4) )
  {
    snprintf((char *)&writefds, 2048u, "SEND: %s", a2);
    applog(5, (const char *)&writefds, 0);
  }
  n = a3 + 1;
  strcat(a2, "\n");
  if ( a3 + 1 <= 0 )
  {
    v14 = 0LL;
LABEL_26:
    result = 0;
    v15 = *(_QWORD *)(a1 + 512);
    v16 = *(_QWORD *)(a1 + 504) + v14;
    ++*(_QWORD *)(a1 + 496);
    *(_QWORD *)(a1 + 504) = v16;
    *(_QWORD *)(a1 + 512) = v14 + v15;
  }
  else
  {
    LOBYTE(v5) = v4 & 0x1F;
    v6 = (v4 + 31) & (v4 >> 31);
    if ( v4 >= 0 )
      v6 = v4;
    if ( v4 <= 0 )
      v5 = -(-v4 & 0x1F);
    v7 = v6 >> 5;
    v8 = 1 << v5;
    v17 = 0;
    do
    {
      while ( 1 )
      {
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        while ( 1 )
        {
          p_tv_usec = (fd_set *)&timeout.tv_usec;
          do
          {
            p_tv_usec->__fds_bits[1] = 0;
            p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
          }
          while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
          writefds.__fds_bits[v7] |= v8;
          if ( select(v4 + 1, 0, &writefds, 0, &timeout) > 0 )
            break;
          if ( *_errno_location() != 4 )
            return 1;
        }
        v11 = send(*(_DWORD *)(a1 + 588), &a2[v17], n, 16384);
        if ( v11 < 0 )
          break;
        v12 = (int)(n - v11) <= 0;
        v13 = v17 + v11;
        n -= v11;
        v17 += v11;
        if ( v12 )
        {
          v14 = v13;
          goto LABEL_26;
        }
      }
    }
    while ( *_errno_location() == 11 );
    return 2;
  }
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80BAB8: using guessed type char opt_protocol;
// 80CC18: using guessed type char use_syslog;

//----- (0004554C) --------------------------------------------------------
int __fastcall http_negotiate(const char **a1, int a2, int a3)
{
  const char *v5; // r3
  const char *v6; // r5
  size_t v7; // r0
  ssize_t v8; // r0
  int v9; // r3
  char *p_s; // r10
  int v11; // r7
  int v12; // r3
  int v13; // r4
  char s; // [sp+10h] [bp-C20h] BYREF
  char v16; // [sp+11h] [bp-C1Fh]
  char v17; // [sp+12h] [bp-C1Eh]
  char v18; // [sp+13h] [bp-C1Dh]
  char buf[2080]; // [sp+410h] [bp-820h] BYREF

  v5 = a1[150];
  v6 = a1[146];
  if ( a3 )
    snprintf(&s, 1024u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v5, v6);
  else
    snprintf(&s, 1024u, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v5, v6, v5, v6);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(buf, 2048u, "Sending proxy %s:%s - %s", a1[151], a1[152], &s);
    applog(7, buf, 0);
  }
  v7 = strlen(&s);
  send(a2, &s, v7, 0);
  v8 = recv(a2, &s, 12u, 0);
  if ( v8 > 0 )
  {
    v9 = (unsigned __int8)opt_debug;
    *(&s + v8) = 0;
    if ( v9 && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(buf, 2048u, "Received from proxy %s:%s - %s", a1[151], a1[152], &s);
      applog(7, buf, 0);
    }
    if ( !strcmp(&s, "HTTP/1.1 200") || !strcmp(&s, "HTTP/1.0 200") )
    {
      p_s = &s;
      v11 = 0;
      do
      {
        if ( recv(a2, buf, 1u, 0) == -1 )
        {
          *(&s + v11) = -1;
          goto LABEL_27;
        }
        v12 = (unsigned __int8)buf[0];
        ++v11;
        *p_s++ = buf[0];
        if ( v12 == 255 )
          goto LABEL_27;
      }
      while ( v11 != 4 );
      if ( !strncmp(&s, "\r\n\r\n", 4u) )
      {
LABEL_21:
        v13 = (unsigned __int8)opt_debug;
        if ( opt_debug )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 6 )
          {
            snprintf(buf, 2048u, "Success negotiating with %s:%s HTTP proxy", a1[151], a1[152]);
            applog(7, buf, 0);
            return v13;
          }
        }
        else
        {
          return 1;
        }
      }
      else
      {
        while ( 1 )
        {
          s = v16;
          v16 = v17;
          v17 = v18;
          if ( recv(a2, buf, 1u, 0) == -1 )
            break;
          v18 = buf[0];
          if ( (unsigned __int8)buf[0] == 255 )
            goto LABEL_27;
          if ( !strncmp(&s, "\r\n\r\n", 4u) )
            goto LABEL_21;
        }
        v18 = -1;
LABEL_27:
        if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
          return 0;
        v13 = 0;
        snprintf(buf, 2048u, "Couldn't read HTTP byte from proxy %s:%s", a1[151], a1[152]);
        applog(4, buf, 0);
      }
      return v13;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(buf, 2048u, "HTTP Error from proxy %s:%s - %s", a1[151], a1[152], &s);
      applog(4, buf, 0);
      return 0;
    }
    return 0;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
    return 0;
  snprintf(buf, 2048u, "Couldn't read from proxy %s:%s after sending CONNECT", a1[151], a1[152]);
  applog(4, buf, 0);
  return 0;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (000458B8) --------------------------------------------------------
int __fastcall _suspend_stratum(int a1)
{
  _BYTE *v1; // r3
  int result; // r0

  v1 = *(_BYTE **)(a1 + 592);
  if ( v1 )
    *v1 = 0;
  result = *(_DWORD *)(a1 + 588);
  *(_BYTE *)(a1 + 643) = 0;
  *(_BYTE *)(a1 + 641) = 0;
  if ( result )
    result = close(result);
  *(_DWORD *)(a1 + 588) = 0;
  return result;
}

//----- (000458E4) --------------------------------------------------------
int __fastcall block_socket(int a1)
{
  unsigned int v2; // r2

  v2 = fcntl(a1, 3, 0) & 0xFFFFF7FF;
  return j_fcntl(a1, 4, v2);
}

//----- (00045900) --------------------------------------------------------
bool __fastcall socket_full_isra_2(int a1, int a2)
{
  fd_set *p_tv_usec; // r3
  int v3; // r7
  int v4; // r4
  int v5; // r4
  struct timeval timeout; // [sp+8h] [bp-A0h] BYREF
  fd_set readfds; // [sp+10h] [bp-98h] BYREF

  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->__fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( p_tv_usec != (fd_set *)&readfds.__fds_bits[31] );
  LOBYTE(v3) = a1 & 0x1F;
  v4 = (a1 + 31) & (a1 >> 31);
  if ( a1 >= 0 )
    v4 = a1;
  v5 = v4 >> 5;
  if ( a1 <= 0 )
    v3 = -(-a1 & 0x1F);
  timeout.tv_usec = 0;
  timeout.tv_sec = a2 & ~(a2 >> 31);
  readfds.__fds_bits[v5] |= 1 << v3;
  return select(a1 + 1, &readfds, 0, 0, &timeout) > 0;
}

//----- (0004596C) --------------------------------------------------------
_DWORD *__fastcall _json_array_string(_DWORD *a1, unsigned int a2)
{
  _DWORD *v4; // r0

  if ( !a1 )
    return 0;
  if ( *a1 == 1 && (unsigned int)json_array_size(a1) >= a2 )
  {
    v4 = json_array_get(a1, a2);
    if ( v4 )
    {
      if ( *v4 == 2 )
        return json_string_value(v4);
    }
  }
  return 0;
}

//----- (000459A4) --------------------------------------------------------
char *__fastcall json_array_string(_DWORD *a1, unsigned int a2)
{
  char *result; // r0

  result = (char *)_json_array_string(a1, a2);
  if ( result )
    return j___strdup(result);
  return result;
}

//----- (000459B8) --------------------------------------------------------
void __fastcall process_version_mask_part_6(int a1)
{
  char v2[2056]; // [sp+0h] [bp-808h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(v2, 2048u, "Pool %d rolling mask do not match!", *(_DWORD *)a1);
    applog(5, v2, 0);
  }
  *(_BYTE *)(a1 + 644) = 0;
  *(_DWORD *)(a1 + 648) = 1;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00045A18) --------------------------------------------------------
void __fastcall process_version_mask(int a1, char *nptr)
{
  int v3; // r6
  unsigned int v4; // r4
  int v5; // r5
  int v6; // r3
  int v7; // r1

  if ( nptr )
  {
    v3 = 0;
    v4 = bswap32(strtol(nptr, 0, 16)) & 0xC000;
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = 1 << v6;
      if ( ((v4 >> v6++) & 1) != 0 )
      {
        v5 |= v7;
        if ( v3 )
          break;
        v3 = 1;
      }
    }
    while ( v6 != 32 );
    *(_DWORD *)(a1 + 652) = v5;
    if ( (v5 & 0xC000) != 0 )
    {
      *(_BYTE *)(a1 + 644) = 1;
      *(_DWORD *)(a1 + 648) = 4;
    }
    else
    {
      process_version_mask_part_6(a1);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 644) = 0;
    *(_DWORD *)(a1 + 648) = 1;
  }
}

//----- (00045A80) --------------------------------------------------------
void __fastcall __noreturn cgsem_post_part_7(const void *a1, const char *a2, const char *a3, int a4)
{
  int *v8; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v8 = _errno_location();
  snprintf(s, 2048u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v8, a1, a2, a3, a4);
  applog(3, s, 1);
  quit(1);
}

//----- (00045AC4) --------------------------------------------------------
int __fastcall valid_hex_constprop_10(const char *a1, int a2, int a3)
{
  signed int v4; // r0
  unsigned __int8 *v5; // r7
  unsigned __int8 *v6; // r0
  int v7; // t1
  int result; // r0
  char s[2080]; // [sp+10h] [bp-820h] BYREF

  if ( a1 )
  {
    v4 = strlen(a1);
    if ( v4 <= 0 )
      return 1;
    if ( (int)hex2bin_tbl[*(unsigned __int8 *)a1] >= 0 )
    {
      v5 = (unsigned __int8 *)&a1[v4];
      v6 = (unsigned __int8 *)(a1 + 1);
      while ( v6 != v5 )
      {
        v7 = *v6++;
        if ( (int)hex2bin_tbl[v7] < 0 )
          goto LABEL_8;
      }
      return 1;
    }
LABEL_8:
    if ( use_syslog || (result = (unsigned __int8)opt_log_output, opt_log_output) || opt_log_level > 2 )
    {
      snprintf(s, 2048u, "Invalid char 0x%x passed to valid_hex from", " in %s %s():%d");
LABEL_12:
      applog(3, s, 0);
      return 0;
    }
  }
  else if ( use_syslog || (result = (unsigned __int8)opt_log_output, opt_log_output) || opt_log_level > 2 )
  {
    snprintf(s, 2048u, "Null string passed to valid_hex from", " in %s %s():%d", "util.c", a2, a3);
    goto LABEL_12;
  }
  return result;
}
// 66484: using guessed type _DWORD hex2bin_tbl[256];
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00045BD0) --------------------------------------------------------
int __fastcall wr_lock_constprop_12(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_rwlock_wrlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (00045C20) --------------------------------------------------------
int __fastcall rw_unlock_constprop_14(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_rwlock_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (00045C70) --------------------------------------------------------
int __fastcall mutex_unlock_noyield_constprop_15(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (00045CC0) --------------------------------------------------------
void __fastcall __noreturn mutex_lock_part_1_constprop_16(const char *a1, int a2)
{
  int *v4; // r0
  char s[2064]; // [sp+10h] [bp-810h] BYREF

  v4 = _errno_location();
  snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  applog(3, s, 1);
  quit(1);
}

//----- (00045D04) --------------------------------------------------------
int __fastcall clear_sock(int a1)
{
  pthread_mutex_t *v1; // r5
  int v3; // r0
  int v4; // r0
  int result; // r0
  _BYTE *v6; // r3

  v1 = (pthread_mutex_t *)(a1 + 704);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
    mutex_lock_part_1_constprop_16("clear_sock", 1765);
  do
    v3 = *(_DWORD *)(a1 + 588);
  while ( v3 && recv(v3, *(void **)(a1 + 592), 8188u, 0) > 0 );
  v4 = mutex_unlock_noyield_constprop_15(v1, "clear_sock", 1774);
  result = selective_yield(v4);
  v6 = *(_BYTE **)(a1 + 592);
  if ( v6 )
    *v6 = 0;
  return result;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (00045D68) --------------------------------------------------------
int __fastcall tq_freezethaw(int a1, char a2)
{
  pthread_mutex_t *v2; // r5
  int v5; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    mutex_lock_part_1_constprop_16("tq_freezethaw", 1108);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  v5 = mutex_unlock_noyield_constprop_15(v2, "tq_freezethaw", 1111);
  return selective_yield(v5);
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (00045DB0) --------------------------------------------------------
void *__fastcall cgmalloc(unsigned int a1, const char *a2, const char *a3, int a4)
{
  unsigned int v5; // r4
  void *result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v5 = a1;
  if ( a1 << 30 )
    v5 = a1 & 0xFFFFFFFC;
  if ( a1 << 30 )
    v5 += 4;
  result = malloc(v5);
  if ( !result )
  {
    snprintf(s, 2048u, "Failed to malloc size %d from %s %s:%d", v5, a2, a3, a4);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (00045E18) --------------------------------------------------------
void *__fastcall cgcalloc(size_t a1, unsigned int a2, const char *a3, const char *a4, int a5)
{
  unsigned int v6; // r4
  void *result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v6 = a2;
  if ( a2 << 30 )
    v6 = a2 & 0xFFFFFFFC;
  if ( a2 << 30 )
    v6 += 4;
  result = calloc(a1, v6);
  if ( !result )
  {
    snprintf(s, 2048u, "Failed to calloc memb %d size %d from %s %s:%d", a1, v6, a3, a4, a5);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (00045E84) --------------------------------------------------------
void *__fastcall cgrealloc(void *a1, unsigned int a2, const char *a3, const char *a4, int a5)
{
  unsigned int v6; // r4
  void *result; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  v6 = a2;
  if ( a2 << 30 )
    v6 = a2 & 0xFFFFFFFC;
  if ( a2 << 30 )
    v6 += 4;
  result = realloc(a1, v6);
  if ( !result )
  {
    snprintf(s, 2048u, "Failed to realloc size %d from %s %s:%d", v6, a3, a4, a5);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (00045EE4) --------------------------------------------------------
char *__fastcall proxytype(char *a1)
{
  char **v1; // r3
  const char *v2; // r2

  if ( !a1 )
    return "http:";
  v1 = &proxynames;
  v2 = "http0:";
  while ( 1 )
  {
    v1 += 2;
    if ( v1[1] == a1 )
      break;
    v2 = v1[2];
    if ( !v2 )
      return "invalid";
  }
  return (char *)v2;
}
// 668A0: using guessed type char *proxynames;

//----- (00045F18) --------------------------------------------------------
_BYTE *__fastcall _bin2hex(_BYTE *result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r7
  _BYTE *v4; // r4
  unsigned __int8 *v5; // r6
  unsigned int v6; // t1

  if ( a3 <= 0 )
  {
    *result = 0;
  }
  else
  {
    v3 = &a2[a3];
    v4 = result + 2;
    do
    {
      v5 = a2;
      v6 = *a2++;
      v4 += 2;
      *(v4 - 4) = *((_BYTE *)&hex2bin_tbl + (v6 >> 4) + 1108);
      *(v4 - 3) = *((_BYTE *)&hex2bin_tbl + (*v5 & 0xF) + 1108);
    }
    while ( a2 != v3 );
    result += 2 * a3;
    *result = 0;
  }
  return result;
}

//----- (00045F64) --------------------------------------------------------
_BYTE *__fastcall bin2hex(unsigned __int8 *a1, int a2)
{
  int v2; // r5
  int v4; // r0
  int v6; // r6
  _BYTE *result; // r0
  unsigned __int8 *v8; // r1
  unsigned __int8 *v9; // r2
  char *v10; // r4
  unsigned __int8 *v11; // r7
  unsigned int v12; // t1
  _BYTE *v13; // r5

  v2 = 2 * a2;
  v4 = 2 * a2 + 1;
  v6 = v4 & 3;
  if ( v4 <= 0 )
    v6 = -(-v4 & 3);
  result = cgcalloc(v4 + 4 - v6, 1u, "util.c", "bin2hex", 789);
  if ( a2 <= 0 )
  {
    v13 = result;
  }
  else
  {
    v8 = &a1[a2];
    v9 = a1;
    v10 = result + 2;
    do
    {
      v11 = v9;
      v12 = *v9++;
      v10 += 2;
      *(v10 - 4) = *((_BYTE *)&hex2bin_tbl + (v12 >> 4) + 1108);
      *(v10 - 3) = *((_BYTE *)&hex2bin_tbl + (*v11 & 0xF) + 1108);
    }
    while ( v9 != v8 );
    v13 = &result[v2];
  }
  *v13 = 0;
  return result;
}

//----- (00045FE8) --------------------------------------------------------
bool __fastcall hex2bin(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int v3; // r3
  int v4; // r4
  unsigned __int8 *v5; // r1
  int v6; // r3
  int v7; // r4
  char v9[2064]; // [sp-810h] [bp-810h] BYREF

  if ( !*a2 )
    return a3 == 0;
  if ( !a3 )
    return 0;
  if ( !a2[1] )
  {
LABEL_17:
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(v9, "hex2bin str truncated");
      applog(3, v9, 0);
    }
    return 0;
  }
  v3 = hex2bin_tbl[*a2];
  v4 = hex2bin_tbl[a2[1]];
  if ( (v3 | v4) < 0 )
  {
LABEL_11:
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(v9, "hex2bin scan failed");
      applog(3, v9, 0);
      return 0;
    }
    return 0;
  }
  v5 = a2 + 4;
  while ( 1 )
  {
    --a3;
    *a1++ = v4 | (16 * v3);
    v6 = *(v5 - 2);
    if ( !*(v5 - 2) )
      return a3 == 0;
    if ( !a3 )
      return 0;
    v7 = *(v5 - 1);
    v5 += 2;
    if ( !v7 )
      goto LABEL_17;
    v3 = hex2bin_tbl[v6];
    v4 = hex2bin_tbl[v7];
    if ( (v3 | v4) < 0 )
      goto LABEL_11;
  }
}
// 66484: using guessed type _DWORD hex2bin_tbl[256];
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (000460F4) --------------------------------------------------------
int __fastcall b58tobin(_BYTE *a1, char *s)
{
  int v2; // r6
  signed int v5; // r0
  char *v6; // r1
  char *v7; // r0
  int v8; // t1
  int *v9; // r4
  int v10; // r2
  int v11; // t1
  __int64 v12; // r2
  int result; // r0
  unsigned int v14; // r3
  unsigned int *v15; // r2
  int *v16; // r1
  unsigned int *v17; // r8
  unsigned int v18; // t1
  int v19; // [sp+4h] [bp-34h] BYREF
  int v20[5]; // [sp+8h] [bp-30h] BYREF
  int v21; // [sp+1Ch] [bp-1Ch] BYREF

  v2 = 0;
  memset(v20, 0, sizeof(v20));
  v19 = 0;
  v21 = 0;
  v5 = strlen(s);
  if ( v5 <= 0 )
  {
    v14 = 0;
    result = 0;
  }
  else
  {
    v6 = s;
    v7 = &s[v5];
    while ( 1 )
    {
      v8 = (unsigned __int8)*v6++;
      v9 = &v21;
      v10 = *((_DWORD *)&hex2bin_tbl + v8 + 283);
      while ( 1 )
      {
        v12 = 58LL * (unsigned int)v2 + (unsigned int)v10;
        *v9 = v12;
        v10 = BYTE4(v12) & 0x3F;
        if ( &v19 == v9 )
          break;
        v11 = *--v9;
        v2 = v11;
      }
      if ( v7 == v6 )
        break;
      v2 = v21;
    }
    result = (unsigned __int8)v19;
    v14 = bswap32(v20[0]);
  }
  v15 = (unsigned int *)(a1 + 1);
  v16 = v20;
  *a1 = result;
  v17 = (unsigned int *)(a1 + 25);
  while ( 1 )
  {
    *v15++ = v14;
    if ( v15 == v17 )
      break;
    v18 = v16[1];
    ++v16;
    v14 = bswap32(v18);
  }
  return result;
}

//----- (00046188) --------------------------------------------------------
int __fastcall ser_number(int a1, int a2)
{
  char v3; // r2
  int result; // r0

  if ( a2 > 127 )
  {
    if ( a2 >= 16512 )
    {
      if ( a2 <= 2113663 )
        v3 = 3;
      else
        v3 = 4;
      if ( a2 <= 2113663 )
        result = 4;
      else
        result = 5;
    }
    else
    {
      v3 = 2;
      result = 3;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (000461BC) --------------------------------------------------------
int __fastcall fulltest(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r3
  unsigned int *v3; // r2
  unsigned int v4; // r5
  unsigned int v5; // t1
  unsigned int v6; // t1
  bool v7; // cf
  int v8; // r4
  unsigned int v10; // r5
  unsigned int v11; // r2
  unsigned int v12; // r7
  unsigned int v13; // r6
  unsigned int v14; // r2
  unsigned int v15; // r5
  unsigned int v16; // r12
  unsigned int v17; // r6
  unsigned int v18; // r7
  unsigned int v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r5
  unsigned int v22; // r3
  unsigned int v23; // r2
  unsigned int v24; // r6
  unsigned int v25; // r7
  unsigned int v26; // lr
  unsigned int v27; // r5
  unsigned int v28; // r6
  unsigned int v29; // r2
  unsigned int v30; // r3
  char *v31; // r6
  const char *v32; // r0
  char *v33; // r5
  const char *v34; // r3
  int v35[8]; // [sp+8h] [bp-858h] BYREF
  int v36[8]; // [sp+28h] [bp-838h] BYREF
  char s[2072]; // [sp+48h] [bp-818h] BYREF

  v2 = a1 + 8;
  v3 = a2 + 8;
  while ( 1 )
  {
    v5 = *--v2;
    v4 = v5;
    v6 = *--v3;
    v7 = v4 >= v6;
    if ( v4 > v6 )
      break;
    if ( !v7 || v2 == a1 )
    {
      v8 = 1;
      goto LABEL_7;
    }
  }
  v8 = 0;
LABEL_7:
  if ( !opt_debug )
    return v8;
  v10 = a1[5];
  v11 = bswap32(a1[6]);
  v35[0] = bswap32(a1[7]);
  v12 = a1[3];
  v13 = bswap32(v10);
  v35[1] = v11;
  v14 = a1[2];
  v15 = a1[4];
  v16 = bswap32(v12);
  v35[2] = v13;
  v17 = *a1;
  v18 = a1[1];
  v19 = bswap32(v14);
  v20 = a2[6];
  v35[3] = bswap32(v15);
  v21 = a2[7];
  v35[5] = v19;
  v22 = bswap32(v20);
  v35[7] = bswap32(v17);
  v23 = a2[4];
  v24 = a2[5];
  v35[6] = bswap32(v18);
  v36[0] = bswap32(v21);
  v25 = bswap32(v23);
  v26 = bswap32(v24);
  v27 = a2[2];
  v28 = a2[3];
  v29 = a2[1];
  v36[1] = v22;
  v30 = *a2;
  v35[4] = v16;
  v36[2] = v26;
  v36[7] = bswap32(v30);
  v36[4] = bswap32(v28);
  v36[5] = bswap32(v27);
  v36[6] = bswap32(v29);
  v36[3] = v25;
  v31 = bin2hex((unsigned __int8 *)v35, 32);
  v32 = bin2hex((unsigned __int8 *)v36, 32);
  v33 = (char *)v32;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v34 = "YES (hash <= target)";
    if ( !v8 )
      v34 = "no (false positive; hash > target)";
    snprintf(s, 2048u, " Proof: %s\nTarget: %s\nTrgVal? %s", v31, v32, v34);
    applog(7, s, 0);
  }
  free(v31);
  free(v33);
  return v8;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;

//----- (000462F8) --------------------------------------------------------
thread_q *tq_new()
{
  char *v0; // r4

  v0 = (char *)cgcalloc(1u, 88u, "util.c", "tq_new", 1077);
  *(_DWORD *)v0 = v0;
  *((_DWORD *)v0 + 1) = v0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v0 + 40), 0);
  return (thread_q *)v0;
}

//----- (00046338) --------------------------------------------------------
void __fastcall tq_free(char *a1)
{
  int v2; // r2
  bool v3; // zf
  _DWORD *v4; // r0
  _DWORD *i; // r4
  _DWORD *v6; // r3

  if ( a1 )
  {
    v2 = **(_DWORD **)a1;
    v3 = a1 == *(char **)a1;
    v4 = (_DWORD *)(*(_DWORD *)a1 - 4);
    for ( i = (_DWORD *)(v2 - 4); !v3; i = (_DWORD *)(v2 - 4) )
    {
      v6 = (_DWORD *)v4[2];
      *(_DWORD *)(v2 + 4) = v6;
      *v6 = v2;
      free(v4);
      v4 = i;
      v2 = i[1];
      v3 = i + 1 == (_DWORD *)a1;
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    j_free(a1);
  }
}

//----- (00046384) --------------------------------------------------------
int __fastcall tq_freeze(int a1)
{
  return tq_freezethaw(a1, 1);
}

//----- (00046388) --------------------------------------------------------
int __fastcall tq_thaw(int a1)
{
  return tq_freezethaw(a1, 0);
}

//----- (0004638C) --------------------------------------------------------
int __fastcall tq_push(int a1, int a2)
{
  _DWORD *v4; // r6
  _DWORD *v5; // r4
  _DWORD *v6; // r3
  int v7; // r8
  int v8; // r0

  v4 = cgcalloc(1u, 12u, "util.c", "tq_push", 1129);
  *v4 = a2;
  v5 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    mutex_lock_part_1_constprop_16("tq_push", 1133);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v7 = 0;
    free(v4);
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 4);
    v7 = 1;
    *(_DWORD *)(a1 + 4) = v5;
    v4[1] = a1;
    v4[2] = v6;
    *v6 = v5;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  v8 = mutex_unlock_noyield_constprop_15((pthread_mutex_t *)(a1 + 12), "tq_push", 1146);
  selective_yield(v8);
  return v7;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (0004641C) --------------------------------------------------------
int __fastcall tq_pop(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r5
  int *v5; // r3
  _DWORD *v6; // r1
  int v7; // r4
  int v8; // r6
  int v9; // r0
  int v11; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    mutex_lock_part_1_constprop_16("tq_pop", 1158);
  v5 = *(int **)a1;
  if ( a1 != *(_DWORD *)a1 )
    goto LABEL_3;
  if ( a2 )
    v11 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), v2, a2);
  else
    v11 = pthread_cond_wait((pthread_cond_t *)(a1 + 40), v2);
  if ( v11 )
  {
    v8 = 0;
    goto LABEL_4;
  }
  v5 = *(int **)a1;
  if ( *(_DWORD *)a1 == a1 )
  {
    v8 = 0;
  }
  else
  {
LABEL_3:
    v6 = (_DWORD *)v5[1];
    v7 = *v5;
    v8 = *(v5 - 1);
    *(_DWORD *)(v7 + 4) = v6;
    *v6 = v7;
    *v5 = 0;
    v5[1] = 0;
    free(v5 - 1);
  }
LABEL_4:
  v9 = mutex_unlock_noyield_constprop_15(v2, "tq_pop", 1184);
  selective_yield(v9);
  return v8;
}
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);

//----- (000464A4) --------------------------------------------------------
int __fastcall thr_info_cancel(int result)
{
  int v1; // r4
  pthread_t v2; // r0
  sem_t *v3; // r0

  if ( result )
  {
    v1 = result;
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      v3 = (sem_t *)(v1 + 16);
      *(_DWORD *)(v1 + 12) = 0;
    }
    else
    {
      v3 = (sem_t *)(v1 + 16);
    }
    return j_sem_destroy(v3);
  }
  return result;
}

//----- (000464D0) --------------------------------------------------------
int __fastcall subtime(int *a1, _DWORD *a2)
{
  int v2; // r2
  int v3; // r3
  int result; // r0
  int v5; // r3
  int v6; // r2

  v2 = *a1;
  v3 = a1[1];
  result = a2[1];
  v5 = v3 - result;
  v6 = v2 - *a2;
  *a2 = v6;
  a2[1] = v5;
  if ( v5 < 0 )
  {
    *a2 = v6 - 1;
    a2[1] = v5 + 1000000;
  }
  return result;
}

//----- (00046500) --------------------------------------------------------
int __fastcall addtime(int *a1, _DWORD *a2)
{
  int v2; // r5
  int result; // r0
  int v4; // r2
  int v5; // r3
  bool v6; // cc

  v2 = *a1;
  result = a1[1];
  v4 = *a2 + v2;
  v5 = a2[1] + result;
  v6 = v5 <= (int)&unk_F423F;
  *a2 = v4;
  a2[1] = v5;
  if ( v5 > (int)&unk_F423F )
  {
    ++v4;
    v5 -= 1000000;
  }
  if ( !v6 )
  {
    *a2 = v4;
    a2[1] = v5;
  }
  return result;
}

//----- (00046534) --------------------------------------------------------
bool __fastcall time_more(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (00046554) --------------------------------------------------------
bool __fastcall time_less(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (00046574) --------------------------------------------------------
_DWORD *__fastcall timespec_to_val(_DWORD *result, _DWORD *a2)
{
  int v2; // r3

  v2 = a2[1];
  *result = *a2;
  result[1] = v2 / 1000;
  return result;
}

//----- (00046594) --------------------------------------------------------
_DWORD *__fastcall timeval_to_spec(_DWORD *result, _DWORD *a2)
{
  int v2; // r3

  v2 = 1000 * a2[1];
  *result = *a2;
  result[1] = v2;
  return result;
}

//----- (000465AC) --------------------------------------------------------
int __fastcall us_to_timeval(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  int v4[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v4);
  v3 = v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// 125D8: using guessed type int __fastcall lldiv(_DWORD);

//----- (000465D4) --------------------------------------------------------
int __fastcall us_to_timespec(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  int v4[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// 125D8: using guessed type int __fastcall lldiv(_DWORD);

//----- (00046604) --------------------------------------------------------
int __fastcall ms_to_timespec(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  int v4[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v4);
  v3 = (_DWORD)&unk_F4240 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// 125D8: using guessed type int __fastcall lldiv(_DWORD);

//----- (00046634) --------------------------------------------------------
int __fastcall ms_to_timeval(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  int v4[8]; // [sp+8h] [bp-20h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// 125D8: using guessed type int __fastcall lldiv(_DWORD);

//----- (00046660) --------------------------------------------------------
int *__fastcall timeraddspec(int *result, int *a2)
{
  int v2; // r2
  int v3; // r5
  int v4; // r3
  int v5; // r2
  int v6; // r5
  int v7; // r1
  int v8; // r2
  int v9; // r4

  v2 = *a2;
  v3 = *result;
  v4 = a2[1] + result[1];
  result[1] = v4;
  v5 = v2 + v3;
  *result = v5;
  if ( v4 <= 999999999 )
  {
    if ( v4 < 0 )
    {
      v8 = v5 - 1;
      do
      {
        v4 += 1000000000;
        v9 = v8--;
      }
      while ( v4 < 0 );
      *result = v9;
      result[1] = v4;
    }
  }
  else
  {
    v6 = v5 + 1;
    v7 = v4 - 1000000000;
    if ( v4 - 1000000000 > 999999999 )
    {
      v7 = -2000000000;
      v6 = v5 + 2;
    }
    *result = v6;
    if ( v4 - 1000000000 > 999999999 )
      v7 += v4;
    result[1] = v7;
  }
  return result;
}

//----- (000466C4) --------------------------------------------------------
const char *__fastcall Strcasestr(const char *a1, const char *a2)
{
  bool v2; // zf
  signed int v5; // r10
  size_t v6; // r0
  bool v7; // zf
  int v8; // r9
  const __int32_t **v9; // r0
  const char *v10; // r3
  const __int32_t *v11; // lr
  char *v12; // r2
  int v13; // t1
  const __int32_t **v14; // r0
  const char *v15; // r1
  const __int32_t *v16; // lr
  char *v17; // r3
  int v18; // t1
  char *v19; // r0
  char v21[32]; // [sp+0h] [bp-20h] BYREF

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  if ( v2 )
    return 0;
  v5 = strlen(a1);
  v6 = strlen(a2);
  v7 = v6 == 0;
  if ( v6 )
    v7 = v5 == 0;
  v8 = v6;
  if ( v7 )
    return 0;
  if ( v5 > 0 )
  {
    v9 = _ctype_tolower_loc();
    v10 = a1;
    v11 = *v9;
    v12 = &v21[-1];
    do
    {
      v13 = *(unsigned __int8 *)v10++;
      *++v12 = v11[v13];
    }
    while ( v10 != &a1[v5] );
  }
  if ( v8 > 0 )
  {
    v14 = _ctype_tolower_loc();
    v15 = a2;
    v16 = *v14;
    v17 = &v21[-1];
    do
    {
      v18 = *(unsigned __int8 *)v15++;
      *++v17 = v16[v18];
    }
    while ( v15 != &a2[v8] );
  }
  v19 = strstr(v21, v21);
  if ( !v19 )
    return 0;
  else
    return &a1[v19 - v21];
}

//----- (00046778) --------------------------------------------------------
const char *__fastcall Strsep(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0
  const char *result; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    result = v3;
    *a1 = 0;
  }
  return result;
}

//----- (0004679C) --------------------------------------------------------
int __fastcall cgtime(struct timeval *a1)
{
  return j_gettimeofday(a1, 0);
}

//----- (000467A4) --------------------------------------------------------
int __fastcall cgtimer_to_ms(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (000467C8) --------------------------------------------------------
int __fastcall cgtimer_sub(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v3; // r4
  int v4; // r1
  int v5; // r3
  int result; // r0

  v3 = *a2;
  v4 = a2[1];
  v5 = *a1 - v3;
  result = a1[1] - v4;
  *a3 = v5;
  if ( result >= 0 )
  {
    a3[1] = result;
  }
  else
  {
    v4 = 1000000000;
    --v5;
  }
  if ( result < 0 )
  {
    *a3 = v5;
    a3[1] = v4 + result;
  }
  return result;
}

//----- (000467F8) --------------------------------------------------------
int __fastcall cgtimer_time(struct timespec *tp)
{
  return j_clock_gettime(1, tp);
}

//----- (00046800) --------------------------------------------------------
int __fastcall cgsleep_ms_r(_DWORD *a1)
{
  int v2; // r3
  __time_t v3; // r2
  __time_t v4; // r4
  int v5; // r1
  int result; // r0
  int v7; // r2
  __time_t v8; // r0
  struct timespec v9[2]; // [sp+0h] [bp-10h] BYREF

  ms_to_timespec(v9);
  v2 = a1[1] + v9[0].tv_nsec;
  v3 = *a1 + v9[0].tv_sec;
  v9[0].tv_sec = v3;
  v9[0].tv_nsec = v2;
  if ( v2 <= 999999999 )
  {
    if ( v2 < 0 )
    {
      v7 = v3 - 1;
      do
      {
        v2 += 1000000000;
        v8 = v7--;
      }
      while ( v2 < 0 );
      v9[0].tv_sec = v8;
      v9[0].tv_nsec = v2;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = v2 - 1000000000;
    if ( v2 - 1000000000 > 999999999 )
    {
      v5 = -2000000000;
      v4 = v3 + 2;
    }
    v9[0].tv_sec = v4;
    if ( v2 - 1000000000 > 999999999 )
      v5 += v2;
    v9[0].tv_nsec = v5;
  }
  do
    result = clock_nanosleep(1, 1, v9, 0);
  while ( result == 4 );
  return result;
}

//----- (00046880) --------------------------------------------------------
int __fastcall cgsleep_us_r(_DWORD *a1)
{
  int v2; // r3
  __time_t v3; // r2
  __time_t v4; // r4
  int v5; // r1
  int result; // r0
  int v7; // r2
  __time_t v8; // r0
  struct timespec v9[2]; // [sp+0h] [bp-10h] BYREF

  us_to_timespec(v9);
  v2 = a1[1] + v9[0].tv_nsec;
  v3 = *a1 + v9[0].tv_sec;
  v9[0].tv_sec = v3;
  v9[0].tv_nsec = v2;
  if ( v2 <= 999999999 )
  {
    if ( v2 < 0 )
    {
      v7 = v3 - 1;
      do
      {
        v2 += 1000000000;
        v8 = v7--;
      }
      while ( v2 < 0 );
      v9[0].tv_sec = v8;
      v9[0].tv_nsec = v2;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = v2 - 1000000000;
    if ( v2 - 1000000000 > 999999999 )
    {
      v5 = -2000000000;
      v4 = v3 + 2;
    }
    v9[0].tv_sec = v4;
    if ( v2 - 1000000000 > 999999999 )
      v5 += v2;
    v9[0].tv_nsec = v5;
  }
  do
    result = clock_nanosleep(1, 1, v9, 0);
  while ( result == 4 );
  return result;
}

//----- (000468FC) --------------------------------------------------------
int cgsleep_ms()
{
  struct timespec v1; // [sp+0h] [bp-10h] BYREF

  clock_gettime(1, &v1);
  return cgsleep_ms_r(&v1);
}

//----- (00046918) --------------------------------------------------------
int cgsleep_us()
{
  struct timespec v1; // [sp+0h] [bp-18h] BYREF

  clock_gettime(1, &v1);
  return cgsleep_us_r(&v1);
}

//----- (00046938) --------------------------------------------------------
_DWORD *__fastcall us_tdiff(_DWORD *result, _DWORD *a2)
{
  if ( *result - *a2 <= 60 )
    return &unk_F4240;
  return result;
}

//----- (00046970) --------------------------------------------------------
void *__fastcall ms_tdiff(_DWORD *a1, _DWORD *a2)
{
  int v2; // r2

  v2 = *a1 - *a2;
  if ( v2 > 3600 )
    return &unk_36EE80;
  else
    return (void *)((a1[1] - a2[1]) / 1000 + 1000 * v2);
}

//----- (000469AC) --------------------------------------------------------
void tdiff()
{
  ;
}

//----- (000469E8) --------------------------------------------------------
int __fastcall extract_sockaddr(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r5
  char *v8; // r0
  bool v9; // zf
  char v10; // r9
  int v11; // r9
  char *v12; // r0
  const char *v13; // r5
  signed int v14; // r10
  signed int v15; // r8
  int v16; // r3
  char *v17; // r2
  int v18; // t1
  bool v19; // zf
  char v21[8]; // [sp+8h] [bp-128h] BYREF
  char s[288]; // [sp+10h] [bp-120h] BYREF

  v4 = a1;
  *a2 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = v7 == 0;
  if ( v7 )
    v9 = v8 == 0;
  v10 = !v9;
  if ( v7 < v8 )
    v11 = v10 & 1;
  else
    v11 = 0;
  if ( !v11 )
    v8 = (char *)v4;
  v12 = strchr(v8, 58);
  v13 = v12;
  if ( v12 )
  {
    v14 = v12 - v4;
    v15 = ~(v12 - v4) + strlen(v4);
    if ( v15 <= 0 )
      return 0;
    ++v13;
  }
  else
  {
    v15 = 0;
    v14 = strlen(v4);
  }
  if ( v14 <= 0 )
    return 0;
  if ( v11 )
  {
    v14 -= 2;
    ++v4;
  }
  snprintf(s, 254u, "%.*s", v14, v4);
  if ( v15 )
  {
    snprintf(v21, 6u, "%.*s", v15, v13);
    v16 = (unsigned __int8)v21[0];
    if ( v21[0] )
    {
      v17 = v21;
      while ( 1 )
      {
        v19 = v16 == 47;
        if ( v16 != 47 )
          v19 = v16 == 35;
        if ( v19 )
          break;
        v18 = (unsigned __int8)*++v17;
        v16 = v18;
        if ( !v18 )
          goto LABEL_30;
      }
      *v17 = 0;
    }
  }
  else
  {
    strcpy(v21, "80");
  }
LABEL_30:
  *a3 = _strdup(v21);
  *a2 = _strdup(s);
  return 1;
}

//----- (00046B08) --------------------------------------------------------
char *__fastcall get_proxy(char *s1, int a2)
{
  const char *v2; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r10
  char *v9; // r0
  const char *v10; // r1

  v2 = "http:";
  v4 = 0;
  v5 = 5;
  *(_DWORD *)(a2 + 184) = 0;
  while ( strncmp(s1, v2, v5) )
  {
    ++v4;
    v2 = (&proxynames)[2 * v4];
    if ( !v2 )
      return s1;
    v5 = strlen(v2);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)cgmalloc(1 - v5 + v7 - s1, "util.c", "get_proxy", 750);
    v10 = &s1[v5];
    *(_DWORD *)(a2 + 184) = v9;
    s1 = v8 + 1;
    strcpy(v9, v10);
    extract_sockaddr(*(const char **)(a2 + 184), (_DWORD *)(a2 + 604), (char **)(a2 + 608));
    *(_DWORD *)(a2 + 180) = hex2bin_tbl[2 * v4 + 264];
  }
  return s1;
}
// 66484: using guessed type _DWORD hex2bin_tbl[256];
// 668A0: using guessed type char *proxynames;

//----- (00046BB4) --------------------------------------------------------
bool __fastcall sock_full(int a1)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(a1 + 592);
  return *v1 || socket_full_isra_2(*(_DWORD *)(a1 + 588), (unsigned __int8)*v1);
}

//----- (00046BC8) --------------------------------------------------------
void **__fastcall recalloc(void **result, unsigned int a2, unsigned int a3, const char *a4, const char *a5, int a6)
{
  _DWORD *v7; // r7

  if ( a3 != a2 )
  {
    v7 = result;
    result = (void **)cgrealloc(*result, a3, a4, a5, a6);
    *v7 = result;
    if ( a3 > a2 )
      return (void **)j_memset((char *)result + a2, 0, a3 - a2);
  }
  return result;
}

//----- (00046C0C) --------------------------------------------------------
int __fastcall real_mask(unsigned int a1, int a2)
{
  int v2; // r4
  int v4; // r3
  int result; // r0
  int v6; // r5

  v2 = 0;
  v4 = 0;
  result = 0;
  do
  {
    v6 = 1 << v4;
    if ( ((a1 >> v4++) & 1) != 0 )
    {
      ++v2;
      result |= v6;
      if ( v2 == a2 )
        break;
    }
  }
  while ( v4 != 32 );
  return result;
}

//----- (00046C3C) --------------------------------------------------------
int __fastcall parse_version_rolling_mask(int a1, int a2)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r9
  int v4; // r6
  _DWORD *v5; // r0
  int v6; // r3
  int v7; // r3
  int v9; // r0
  const char *i; // r4
  int v11; // r0
  int v12; // r0
  int v13; // r0
  _DWORD *v14; // r5
  char *v15; // r0
  int v17[23]; // [sp+14h] [bp-924h] BYREF
  char v18[160]; // [sp+70h] [bp-8C8h] BYREF
  char s[2088]; // [sp+110h] [bp-828h] BYREF

  v2 = (_DWORD *)json_loads(a2, 0, (int)v17);
  if ( v2 )
  {
    v3 = v2;
    v4 = json_object_get(v2, "result");
    v5 = (_DWORD *)json_object_get(v3, "error");
    if ( v4 )
    {
      if ( *(_DWORD *)v4 == 7 || v5 && *v5 != 7 )
      {
        v4 = 0;
      }
      else
      {
        v9 = json_object_iter((_DWORD *)v4);
        for ( i = (const char *)json_object_iter_key(v9); i; i = (const char *)json_object_iter_key(v12) )
        {
          v13 = json_object_key_to_iter((int)i);
          v14 = (_DWORD *)json_object_iter_value(v13);
          if ( !v14 )
            break;
          if ( !strcasecmp(i, "version-rolling") && strlen(i) == 15 )
          {
            if ( *v14 != 5 )
            {
              v4 = 0;
              *(_BYTE *)(a1 + 644) = 0;
              *(_DWORD *)(a1 + 648) = 1;
              goto LABEL_7;
            }
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(s, 2048u, "POOL %d support ab mode!", *(_DWORD *)a1);
              applog(5, s, 0);
            }
          }
          else if ( !strcasecmp(i, "version-rolling.mask") )
          {
            v15 = (char *)json_string_value(v14);
            process_version_mask(a1, v15);
          }
          else if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf(s, 2048u, "JSON-RPC unexpected mining.configure value: %s", i);
            applog(3, s, 0);
          }
          v11 = json_object_key_to_iter((int)i);
          v12 = json_object_iter_next((_DWORD *)v4, v11);
        }
        v4 = 1;
      }
    }
LABEL_7:
    v6 = v3[1];
    if ( v6 == -1 )
      return v4;
    v7 = v6 - 1;
    v3[1] = v7;
    if ( v7 )
    {
      return v4;
    }
    else
    {
      json_delete(v3);
      return v4;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(s, 2048u, "JSON decode failed(%d): %s", v17[0], v18);
      applog(6, s, 0);
    }
    return 0;
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;
// 46C3C: using guessed type int var_924[23];
// 46C3C: using guessed type char var_8C8[160];

//----- (00046E28) --------------------------------------------------------
int __fastcall suspend_stratum(int a1)
{
  pthread_mutex_t *v2; // r5
  int *v4; // r0
  int *v5; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    v2 = (pthread_mutex_t *)(a1 + 704);
    snprintf(s, 2048u, "Closing socket for stratum pool %d", *(_DWORD *)a1);
    applog(6, s, 0);
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
      goto LABEL_8;
  }
  else
  {
    v2 = (pthread_mutex_t *)(a1 + 704);
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
    {
LABEL_8:
      v4 = _errno_location();
      snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", "suspend_stratum", 3087);
      applog(3, s, 1);
      quit(1);
    }
  }
  _suspend_stratum(a1);
  if ( pthread_mutex_unlock(v2) )
  {
    v5 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v5, "util.c", "suspend_stratum", 3089);
    applog(3, s, 1);
    quit(1);
  }
  return selective_yield(0);
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00046F40) --------------------------------------------------------
int __fastcall stratum_send(int a1, char *a2, int a3)
{
  int *v6; // r0
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  if ( opt_protocol && (use_syslog || opt_log_output || opt_log_level > 4) )
  {
    snprintf(s, 2048u, "SEND: %s", a2);
    applog(5, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
  {
    v9 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "util.c", "stratum_send", 1688);
    applog(3, s, 1);
    quit(1);
  }
  if ( !*(_BYTE *)(a1 + 641) )
  {
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
      goto LABEL_8;
    selective_yield(0);
    goto LABEL_10;
  }
  v8 = _stratum_send(a1, a2, a3);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
  {
LABEL_8:
    v6 = _errno_location();
    snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", "stratum_send", 1694);
    applog(3, s, 1);
    quit(1);
  }
  selective_yield(0);
  if ( v8 == 2 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(s, "Failed to send in stratum_send");
      applog(7, s, 0);
      suspend_stratum(a1);
      return 0;
    }
    goto LABEL_26;
  }
  if ( v8 != 3 )
  {
    if ( v8 != 1 )
      return v8 == 0;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(s, 2048u, "Write select failed on pool %d sock", *(_DWORD *)a1);
      applog(7, s, 0);
    }
LABEL_26:
    suspend_stratum(a1);
    return 0;
  }
LABEL_10:
  result = (unsigned __int8)opt_debug;
  if ( opt_debug )
  {
    if ( use_syslog || (result = (unsigned __int8)opt_log_output, opt_log_output) || opt_log_level > 6 )
    {
      strcpy(s, "Stratum send failed due to no pool stratum_active");
      applog(7, s, 0);
      return 0;
    }
  }
  return result;
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BAB8: using guessed type char opt_protocol;
// 80CC18: using guessed type char use_syslog;

//----- (000471AC) --------------------------------------------------------
char *__fastcall recv_line(int a1)
{
  char *v1; // r5
  signed int v3; // r6
  char *v4; // r0
  char *v5; // r8
  size_t v6; // r0
  signed int v7; // r5
  __int64 *v8; // r12
  int v9; // r1
  int v10; // r0
  __int64 v11; // r2
  __int64 v12; // r6
  __int64 v13; // r4
  _QWORD *v14; // lr
  __int64 v15; // t1
  char *v17; // r9
  size_t v18; // r7
  size_t v19; // r8
  unsigned int v20; // r0
  unsigned int v21; // r7
  char *v22; // r0
  bool v23; // cc
  ssize_t v24; // r7
  int v25; // r5
  struct timeval tv; // [sp+8h] [bp-2838h] BYREF
  struct timeval v27; // [sp+10h] [bp-2830h] BYREF
  char v28[2048]; // [sp+18h] [bp-2828h] BYREF
  char s[8232]; // [sp+818h] [bp-2028h] BYREF

  v1 = *(char **)(a1 + 592);
  if ( !strchr(v1, 10) )
  {
    gettimeofday(&tv, 0);
    if ( !socket_full_isra_2(*(_DWORD *)(a1 + 588), 60) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(s, "Timed out waiting for data on socket_full");
        applog(7, s, 0);
      }
      goto LABEL_17;
    }
    while ( 1 )
    {
      memset(s, 0, 8192u);
      v24 = recv(*(_DWORD *)(a1 + 588), s, 8188u, 0);
      if ( !v24 )
        break;
      gettimeofday(&v27, 0);
      v25 = (int)((double)(v27.tv_usec - tv.tv_usec) / 1000000.0 + (double)(v27.tv_sec - tv.tv_sec));
      if ( v24 >= 0 )
      {
        v17 = *(char **)(a1 + 592);
        v18 = strlen(s);
        v19 = strlen(v17);
        v20 = v18 + v19 + 1;
        if ( v20 >= *(_DWORD *)(a1 + 596) )
        {
          v21 = (v20 & 0xFFFFE000) + 8192;
          v22 = (char *)cgrealloc(v17, v21, "util.c", "recalloc_sock", 1803);
          *(_DWORD *)(a1 + 592) = v22;
          memset(&v22[v19], 0, v21 - v19);
          v17 = *(char **)(a1 + 592);
          *(_DWORD *)(a1 + 596) = v21;
        }
        strcat(v17, s);
      }
      else if ( *_errno_location() != 11 || !socket_full_isra_2(*(_DWORD *)(a1 + 588), 60 - v25) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy(v28, "Failed to recv sock in recv_line");
          applog(7, v28, 0);
        }
        goto LABEL_35;
      }
      v23 = v25 <= 59;
      v1 = *(char **)(a1 + 592);
      if ( !v23 || strchr(*(const char **)(a1 + 592), 10) )
        goto LABEL_2;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(v28, "Socket closed waiting in recv_line");
      applog(7, v28, 0);
    }
LABEL_35:
    suspend_stratum(a1);
    v1 = *(char **)(a1 + 592);
  }
LABEL_2:
  v3 = strlen(v1);
  v4 = strtok(v1, "\n");
  if ( !v4 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(s, "Failed to parse a \\n terminated string in recv_line");
      applog(7, s, 0);
    }
LABEL_17:
    v5 = 0;
    clear_sock(a1);
    return v5;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( v3 > (int)(v6 + 1) )
    memmove(*(void **)(a1 + 592), (const void *)(v6 + 1 + *(_DWORD *)(a1 + 592)), v3 - v6 + 1);
  else
    **(_BYTE **)(a1 + 592) = 0;
  v8 = (__int64 *)(a1 + 520);
  v9 = a1;
  v10 = (unsigned __int8)opt_protocol;
  v11 = v7;
  v12 = *(_QWORD *)(a1 + 520) + 1LL;
  v14 = (_QWORD *)(a1 + 528);
  v13 = *(_QWORD *)(a1 + 528);
  *v8 = v12;
  v15 = *(_QWORD *)(v9 + 536);
  *v14 = v13 + v11;
  *(_QWORD *)(v9 + 536) = v11 + v15;
  if ( v10 && (use_syslog || opt_log_output || opt_log_level > 4) )
  {
    snprintf(s, 2048u, "RECVD: %s", v5);
    applog(5, s, 0);
  }
  return v5;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BAB8: using guessed type char opt_protocol;
// 80CC18: using guessed type char use_syslog;

//----- (00047554) --------------------------------------------------------
time_t __fastcall dev_error(_DWORD *a1, int a2)
{
  time_t result; // r0

  result = time(0);
  a1[62] = a2;
  a1[61] = result;
  switch ( a2 )
  {
    case 0:
      ++a1[63];
      break;
    case 1:
      ++a1[64];
      break;
    case 2:
      ++a1[65];
      break;
    case 3:
      ++a1[66];
      break;
    case 4:
      ++a1[67];
      break;
    case 5:
      ++a1[68];
      break;
    case 6:
      ++a1[69];
      break;
    case 7:
      ++a1[70];
      break;
    case 8:
      ++a1[71];
      break;
    case 9:
      ++a1[72];
      break;
    default:
      return result;
  }
  return result;
}

//----- (000475F4) --------------------------------------------------------
char *__fastcall realloc_strcat(char *a1, char *s)
{
  size_t v4; // r0
  unsigned int v5; // r0
  const char *v6; // r1
  char *v7; // r4
  unsigned int v9; // r0
  char *v10; // r0

  v4 = strlen(s);
  if ( !v4 )
    return a1;
  if ( a1 )
  {
    v5 = strlen(a1) + v4 + 1;
    if ( v5 << 30 )
    {
      LOWORD(v6) = (unsigned __int16)"util.c";
      v5 = (v5 & 0xFFFFFFFC) + 4;
    }
    else
    {
      LOWORD(v6) = 28712;
    }
    HIWORD(v6) = (unsigned int)"util.c" >> 16;
    v7 = (char *)cgmalloc(v5, v6, "realloc_strcat", 3413);
    sprintf(v7, "%s%s", a1, s);
    free(a1);
    return v7;
  }
  else
  {
    v9 = v4 + 1;
    if ( v9 << 30 )
      v9 = (v9 & 0xFFFFFFFC) + 4;
    v10 = (char *)cgmalloc(v9, "util.c", "realloc_strcat", 3413);
    return strcpy(v10, s);
  }
}

//----- (00047680) --------------------------------------------------------
char *__fastcall str_text(char *s)
{
  char *v1; // r4
  size_t v2; // r0
  char *v3; // r7
  char *v4; // r5
  char v5; // r3
  int v6; // t1
  int v7; // r2
  int v8; // t1
  char *result; // r0
  char *v10; // r3
  char sa[2072]; // [sp+8h] [bp-818h] BYREF

  v1 = s;
  if ( !s )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(sa, 2048u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3438);
      applog(3, sa, 1);
      quit(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(v1);
  v3 = (char *)cgmalloc(4 * v2 + 5, "util.c", "str_text", 3443);
  v4 = v3;
  do
  {
    while ( 1 )
    {
      v7 = (unsigned __int8)*v1;
      if ( (unsigned int)(v7 - 32) <= 94 )
        break;
      sprintf(v4, "0x%02x");
      v8 = (unsigned __int8)*v1++;
      v5 = v8;
      v4 += 4;
      if ( !v8 )
        goto LABEL_7;
    }
    *v4++ = v7;
    v6 = (unsigned __int8)*v1++;
    v5 = v6;
  }
  while ( v6 );
LABEL_7:
  result = v3;
  *v4 = v5;
  return result;
}

//----- (00047740) --------------------------------------------------------
int __fastcall RenameThread(const char *a1)
{
  char s[24]; // [sp+8h] [bp-18h] BYREF

  snprintf(s, 16u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (0004776C) --------------------------------------------------------
int __fastcall cgsem_init(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  result = sem_init(a1, 0, 0);
  if ( result )
  {
    v8 = result;
    v9 = _errno_location();
    snprintf(s, 2048u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    applog(3, s, 1);
    quit(1);
  }
  return result;
}

//----- (000477BC) --------------------------------------------------------
int __fastcall thr_info_create(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  cgsem_init((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1191);
  return j_pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (000477F4) --------------------------------------------------------
int __fastcall cgsem_post(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0

  result = sem_post(a1);
  if ( result )
    cgsem_post_part_7(a1, a2, a3, a4);
  return result;
}

//----- (0004781C) --------------------------------------------------------
int __fastcall completion_thread(int a1)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(a1 + 16))(*(_DWORD *)(a1 + 20));
  cgsem_post((sem_t *)a1, "util.c", "completion_thread", 3669);
  return 0;
}

//----- (0004784C) --------------------------------------------------------
int __fastcall cgsem_wait(sem_t *sem, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v9; // r3
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  while ( 1 )
  {
    result = sem_wait(sem);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 != 4 )
    {
      snprintf(s, 2048u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v9, sem, a2, a3, a4);
      applog(3, s, 1);
      quit(1);
    }
  }
  return result;
}

//----- (000478A0) --------------------------------------------------------
int __fastcall cgsem_mswait(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  __time_t tv_sec; // r10
  int v8; // r5
  int v9; // r3
  bool v10; // cc
  int v11; // r2
  int v12; // r1
  __time_t v13; // r0
  int result; // r0
  __time_t v15; // r2
  __time_t v16; // r1
  struct timespec abstime; // [sp+18h] [bp-838h] BYREF
  struct timeval tv; // [sp+20h] [bp-830h] BYREF
  char s[2088]; // [sp+28h] [bp-828h] BYREF

  gettimeofday(&tv, 0);
  tv_sec = tv.tv_sec;
  v8 = 1000 * tv.tv_usec;
  ms_to_timespec(&abstime);
  while ( 1 )
  {
    v9 = abstime.tv_nsec + v8;
    v10 = abstime.tv_nsec + v8 <= 999999999;
    v11 = abstime.tv_sec + tv_sec;
    abstime.tv_sec += tv_sec;
    abstime.tv_nsec += v8;
    if ( v10 )
    {
      if ( v9 < 0 )
      {
        v15 = v11 - 1;
        do
        {
          v9 += 1000000000;
          v16 = v15--;
        }
        while ( v9 < 0 );
        abstime.tv_nsec = v9;
        abstime.tv_sec = v16;
      }
    }
    else
    {
      v12 = v9 - 1000000000;
      v13 = v11 + 1;
      if ( v9 - 1000000000 > 999999999 )
      {
        v12 = v9 - 2000000000;
        v13 = v11 + 2;
      }
      abstime.tv_nsec = v12;
      abstime.tv_sec = v13;
    }
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    result = *_errno_location();
    if ( result == 110 )
      break;
    if ( result != 4 )
    {
      snprintf(s, 2048u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", result, a1, a3, a4, a5);
      applog(3, s, 1);
      quit(1);
    }
  }
  return result;
}

//----- (00047988) --------------------------------------------------------
int *__fastcall cgsem_reset(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (000479AC) --------------------------------------------------------
bool __fastcall cg_completion_timeout(int a1, int a2, int a3)
{
  sem_t *v6; // r4
  int v7; // r5
  pthread_t newthread; // [sp+Ch] [bp-1Ch] BYREF

  v6 = (sem_t *)cgmalloc(24u, "util.c", "cg_completion_timeout", 3680);
  cgsem_init(v6, "util.c", "cg_completion_timeout", 3681);
  v6[1].__align = a1;
  *(&v6[1].__align + 1) = a2;
  pthread_create(&newthread, 0, (void *(*)(void *))completion_thread, v6);
  v7 = cgsem_mswait(v6, a3, "util.c", "cg_completion_timeout", 3687);
  if ( v7 )
  {
    pthread_cancel(newthread);
    return v7 == 0;
  }
  else
  {
    pthread_join(newthread, 0);
    free(v6);
    return 1;
  }
}
// 4781C: using guessed type int completion_thread();

//----- (00047A3C) --------------------------------------------------------
void __fastcall cg_memcpy(void *a1, const void *a2, size_t a3, int a4, int a5, int a6)
{
  char s[2072]; // [sp+10h] [bp-818h] BYREF

  if ( (int)(a3 - 1) < 0 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return;
    snprintf(s, 2048u, "ERR: Asked to memcpy %u bytes from %s %s():%d", a3, a4, a5, a6);
LABEL_9:
    applog(3, s, 0);
    return;
  }
  if ( !a1 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return;
    snprintf(s, 2048u, "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
  if ( a2 )
  {
    j_memcpy(a1, a2, a3);
    return;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(s, 2048u, "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (00047B30) --------------------------------------------------------
void __fastcall address_to_pubkeyhash(_BYTE *a1, char *a2)
{
  int v3[6]; // [sp+Ch] [bp-2Ch] BYREF
  char v4; // [sp+24h] [bp-14h]

  memset(v3, 0, sizeof(v3));
  v4 = 0;
  b58tobin(v3, a2);
  *a1 = 118;
  a1[1] = -87;
  a1[2] = 20;
  cg_memcpy(a1 + 3, (char *)v3 + 1, 20u, (int)"util.c", (int)"address_to_pubkeyhash", 966);
  a1[23] = -120;
  a1[24] = -84;
}

//----- (00047B88) --------------------------------------------------------
_BYTE *__fastcall ser_string(const char *a1, _DWORD *a2)
{
  size_t v4; // r4
  _BYTE *v5; // r0
  _BYTE *v6; // r5
  _BYTE *result; // r0

  v4 = strlen(a1);
  v5 = cgmalloc(v4 + 9, "util.c", "ser_string", 996);
  v6 = v5;
  if ( v4 <= 252 )
  {
    *v5 = v4;
    cg_memcpy(v5 + 1, a1, v4, (int)"util.c", (int)"ser_string", 1000);
    result = v6;
    *a2 = v4 + 1;
  }
  else if ( v4 < 65536 )
  {
    *v5 = -3;
    *(_WORD *)(v5 + 1) = __rev16(v4);
    cg_memcpy(v5 + 3, a1, v4, (int)"util.c", (int)"ser_string", 1009);
    result = v6;
    *a2 = v4 + 3;
  }
  else
  {
    *v5 = -2;
    *(_DWORD *)(v5 + 1) = bswap32(v4);
    cg_memcpy(v5 + 5, a1, v4, (int)"util.c", (int)"ser_string", 1019);
    result = v6;
    *a2 = v4 + 5;
  }
  return result;
}

//----- (00047C48) --------------------------------------------------------
void __fastcall copy_time(timeval *dest, const timeval *src)
{
  cg_memcpy(dest, src, 8u, (int)"util.c", (int)"copy_time", 1236);
}

//----- (00047C6C) --------------------------------------------------------
_DWORD *__fastcall parse_notify(int a1, _DWORD *a2)
{
  _DWORD *result; // r0
  _DWORD *v4; // r4
  _BOOL4 v5; // r10
  char *v6; // r5
  char *v7; // r8
  char *v8; // r11
  bool v9; // r9
  signed int v10; // r0
  unsigned __int8 *v11; // r0
  unsigned __int8 *v12; // r3
  int v13; // t1
  void *v14; // r0
  char *v15; // r6
  const char *v16; // r3
  int v17; // r1
  double v18; // d7
  int v19; // r6
  int v20; // r2
  int v21; // r1
  size_t v22; // r3
  size_t v23; // r0
  int v24; // r9
  void *v25; // r0
  int v26; // r6
  void *v27; // r0
  size_t v28; // lr
  int v29; // r4
  int v30; // r0
  const char *v31; // r3
  int v32; // r5
  __int64 v33; // r2
  const char *v34; // r0
  char *v35; // r6
  signed int v36; // r9
  void *v37; // r0
  int v38; // r1
  int v39; // r6
  unsigned __int8 *v40; // r5
  int v41; // r10
  void *v42; // r0
  int v43; // r3
  const char *v44; // lr
  int v45; // r0
  int v46; // r1
  int v47; // r2
  int v48; // r3
  int *v49; // lr
  int v50; // r0
  int v51; // r1
  int v52; // r2
  int v53; // r3
  int v54; // r0
  int v55; // r1
  int v56; // r2
  int v57; // r3
  int v58; // r1
  int v59; // r3
  const char *v60; // r4
  int v61; // r0
  int v62; // r1
  int v63; // r2
  int v64; // r3
  int *v65; // r4
  int v66; // r0
  int v67; // r1
  int v68; // r2
  int v69; // r3
  int v70; // r0
  int v71; // r1
  int v72; // r2
  int v73; // r3
  int v74; // r4
  char *v75; // [sp+18h] [bp+0h] BYREF
  const char *v76; // [sp+1Ch] [bp+4h]
  int v77; // [sp+20h] [bp+8h]
  pthread_rwlock_t *v78; // [sp+24h] [bp+Ch]
  size_t v79; // [sp+28h] [bp+10h]
  const char *v80; // [sp+2Ch] [bp+14h]
  const char *v81; // [sp+30h] [bp+18h]
  const char *v82; // [sp+34h] [bp+1Ch]
  const char *v83; // [sp+38h] [bp+20h]
  pthread_mutex_t *v84; // [sp+3Ch] [bp+24h]
  size_t v85; // [sp+40h] [bp+28h]
  int v86; // [sp+44h] [bp+2Ch]
  size_t v87; // [sp+48h] [bp+30h]
  _BOOL4 v88; // [sp+4Ch] [bp+34h]
  const char *v89; // [sp+50h] [bp+38h]
  const char *v90; // [sp+54h] [bp+3Ch]
  int v91; // [sp+58h] [bp+40h]
  const char *v92; // [sp+5Ch] [bp+44h]
  const char *v93; // [sp+60h] [bp+48h]
  char *v94; // [sp+64h] [bp+4Ch]
  unsigned __int8 v95[228]; // [sp+6Ch] [bp+54h] BYREF
  int v96; // [sp+150h] [bp+138h] BYREF
  int v97; // [sp+154h] [bp+13Ch]
  int v98; // [sp+158h] [bp+140h]
  int v99; // [sp+15Ch] [bp+144h]
  int v100; // [sp+160h] [bp+148h]
  int v101; // [sp+164h] [bp+14Ch]
  int v102; // [sp+168h] [bp+150h]
  int v103; // [sp+16Ch] [bp+154h]
  int v104; // [sp+170h] [bp+158h]
  int v105; // [sp+174h] [bp+15Ch]
  int v106; // [sp+178h] [bp+160h]
  int v107; // [sp+17Ch] [bp+164h]
  int v108; // [sp+180h] [bp+168h]
  __int16 v109; // [sp+184h] [bp+16Ch]
  char v110; // [sp+186h] [bp+16Eh]

  v94 = (char *)a1;
  result = json_array_get(a2, 4u);
  v4 = result;
  if ( result )
  {
    if ( *result != 1 )
      return 0;
    v91 = (int)json_array_size(result);
    v6 = json_array_string(a2, 0);
    v93 = (const char *)_json_array_string(a2, 1u);
    v7 = json_array_string(a2, 2u);
    v8 = json_array_string(a2, 3u);
    v92 = (const char *)_json_array_string(a2, 5u);
    v90 = (const char *)_json_array_string(a2, 6u);
    v89 = (const char *)_json_array_string(a2, 7u);
    if ( json_array_get(a2, 8u) )
    {
      v9 = *json_array_get(a2, 8u) == 5;
      v88 = v9;
    }
    else
    {
      v9 = 0;
      v88 = 0;
    }
    if ( v6 )
    {
      v10 = strlen(v6);
      if ( v10 )
      {
        if ( v10 <= 0 )
          goto LABEL_20;
        if ( (unsigned int)(unsigned __int8)*v6 - 32 <= 94 )
        {
          v11 = (unsigned __int8 *)&v6[v10];
          v12 = (unsigned __int8 *)(v6 + 1);
          while ( v12 != v11 )
          {
            v13 = *v12++;
            if ( (unsigned int)(v13 - 32) > 94 )
              goto LABEL_15;
          }
LABEL_20:
          if ( valid_hex_constprop_10(v93, (int)"parse_notify", 1947)
            && valid_hex_constprop_10(v7, (int)"parse_notify", 1947)
            && valid_hex_constprop_10(v8, (int)"parse_notify", 1948)
            && valid_hex_constprop_10(v92, (int)"parse_notify", 1948)
            && valid_hex_constprop_10(v90, (int)"parse_notify", 1948)
            && valid_hex_constprop_10(v89, (int)"parse_notify", 1949) )
          {
            v84 = (pthread_mutex_t *)(v94 + 212);
            if ( pthread_mutex_lock((pthread_mutex_t *)(v94 + 212)) )
              mutex_lock_part_1_constprop_16("parse_notify", 1958);
            v78 = (pthread_rwlock_t *)(v94 + 236);
            wr_lock_constprop_12((pthread_rwlock_t *)(v94 + 236), "parse_notify", 1958);
            v14 = (void *)*((_DWORD *)v94 + 168);
            v15 = v94 + 1712;
            v83 = v94 + 1712;
            free(v14);
            v16 = v93;
            *((_DWORD *)v94 + 168) = v6;
            snprintf(v15, 65u, "%s", v16);
            v87 = strlen(v7) >> 1;
            v82 = v94 + 1780;
            v85 = strlen(v8) >> 1;
            v81 = v94 + 1792;
            snprintf(v94 + 1780, 9u, "%s", v92);
            v80 = v94 + 1804;
            snprintf(v94 + 1792, 9u, "%s", v90);
            snprintf(v94 + 1804, 9u, "%s", v89);
            v17 = (int)v94;
            v94[680] = v9;
            v18 = *(double *)(v17 + 1816);
            if ( v18 > 0.0 )
              *(double *)(v17 + 1824) = v18;
            v19 = (int)v94;
            v20 = *((_DWORD *)v94 + 158);
            v21 = *((_DWORD *)v94 + 427);
            v22 = *((_DWORD *)v94 + 391) + v87;
            v23 = v85;
            *((_DWORD *)v94 + 394) = v22;
            v79 = v22 + v20 + v23;
            *(_DWORD *)(v19 + 1572) = v79;
            if ( v21 > 0 )
            {
              v24 = 0;
              do
              {
                v25 = *(void **)(*((_DWORD *)v94 + 169) + 4 * v24++);
                free(v25);
              }
              while ( *((_DWORD *)v94 + 427) > v24 );
            }
            if ( v91 )
            {
              v86 = 47800;
              v36 = 0;
              v37 = cgrealloc(*((void **)v94 + 169), 4 * v91 + 1, "util.c", "parse_notify", 1979);
              v38 = (int)v94;
              v76 = "util.c";
              v75 = &opt_debug;
              *((_DWORD *)v94 + 169) = v37;
              v39 = v38;
              LOWORD(v37) = v86;
              v94 = v6;
              HIWORD(v37) = 128;
              v86 = (int)v37;
              while ( 1 )
              {
                v77 = 4 * v36;
                if ( v36 >= v91 )
                  break;
                v40 = (unsigned __int8 *)json_array_string(v4, v36);
                v41 = *(_DWORD *)(v39 + 676);
                v42 = cgmalloc(32u, v76, "parse_notify", 1984);
                v43 = *(unsigned __int8 *)v86;
                *(_DWORD *)(v41 + 4 * v36) = v42;
                if ( v43 && *v75 && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf((char *)&v96, 2048u, "merkle %d: %s", v36, v40);
                  applog(7, (const char *)&v96, 0);
                }
                ++v36;
                v5 = hex2bin(*(_BYTE **)(*(_DWORD *)(v39 + 676) + v77), v40, 32);
                free(v40);
                if ( !v5 )
                {
                  v6 = v94;
                  v94 = (char *)v39;
                  if ( use_syslog || opt_log_output || opt_log_level > 2 )
                  {
                    v44 = "Failed to convert merkle to merkle_bin in parse_notify";
                    goto LABEL_117;
                  }
                  goto LABEL_115;
                }
              }
              v59 = v91;
              v6 = v94;
              v94 = (char *)v39;
              *(_DWORD *)(v39 + 1708) = v91;
              if ( v59 > 1 )
                goto LABEL_35;
            }
            else
            {
              v86 = (int)&opt_protocol;
              *((_DWORD *)v94 + 427) = 0;
            }
            ++*((_QWORD *)v94 + 47);
LABEL_35:
            if ( v88 )
              *((_QWORD *)v94 + 78) = 0LL;
            snprintf(
              (char *)v95,
              225u,
              "%s%s%s%s%s%s%s",
              v82,
              v83,
              "0000000000000000000000000000000000000000000000000000000000000000",
              v80,
              v81,
              "00000000",
              workpadding);
            v5 = hex2bin(v94 + 1580, v95, 112);
            if ( v5 )
            {
              v5 = hex2bin(&v75, (unsigned __int8 *)v7, v87);
              if ( v5 )
              {
                v5 = hex2bin(&v75, (unsigned __int8 *)v8, v85);
                if ( v5 )
                {
                  v26 = (int)v94;
                  free(*((void **)v94 + 392));
                  v27 = cgcalloc(v79, 1u, "util.c", "parse_notify", 2041);
                  *(_DWORD *)(v26 + 1568) = v27;
                  cg_memcpy(v27, &v75, v87, (int)"util.c", (int)"parse_notify", 2042);
                  v28 = *(_DWORD *)(v26 + 1564);
                  if ( v28 )
                  {
                    v29 = (int)v94;
                    cg_memcpy(
                      (void *)(*((_DWORD *)v94 + 392) + v87),
                      *((const void **)v94 + 154),
                      v28,
                      (int)"util.c",
                      (int)"parse_notify",
                      2044);
                    v28 = *(_DWORD *)(v29 + 1564);
                  }
                  cg_memcpy(
                    (void *)(*((_DWORD *)v94 + 158) + v28 + v87 + *((_DWORD *)v94 + 392)),
                    &v75,
                    v85,
                    (int)"util.c",
                    (int)"parse_notify",
                    2045);
                  if ( opt_debug )
                  {
                    v34 = bin2hex(*((unsigned __int8 **)v94 + 392), *((_DWORD *)v94 + 393));
                    v35 = (char *)v34;
                    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                    {
                      snprintf((char *)&v96, 2048u, "Pool %d coinbase %s", *(_DWORD *)v94, v34);
                      applog(7, (const char *)&v96, 0);
                    }
                    free(v35);
                  }
                  goto LABEL_43;
                }
                if ( use_syslog || opt_log_output || opt_log_level > 2 )
                {
                  v60 = "Failed to convert cb2 to cb2_bin in parse_notify";
LABEL_129:
                  v61 = *(_DWORD *)v60;
                  v62 = *((_DWORD *)v60 + 1);
                  v63 = *((_DWORD *)v60 + 2);
                  v64 = *((_DWORD *)v60 + 3);
                  v65 = (int *)(v60 + 16);
                  v96 = v61;
                  v97 = v62;
                  v98 = v63;
                  v99 = v64;
                  v66 = *v65;
                  v67 = v65[1];
                  v68 = v65[2];
                  v69 = v65[3];
                  v65 += 4;
                  v100 = v66;
                  v101 = v67;
                  v102 = v68;
                  v103 = v69;
                  v70 = *v65;
                  v71 = v65[1];
                  v72 = v65[2];
                  v73 = v65[3];
                  v74 = v65[4];
                  v104 = v70;
                  v105 = v71;
                  v106 = v72;
                  v107 = v73;
                  LOBYTE(v108) = v74;
                  applog(3, (const char *)&v96, 0);
                  goto LABEL_43;
                }
              }
              else if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                v60 = (const char *)&unk_67614;
                goto LABEL_129;
              }
            }
            else if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              v44 = "Failed to convert header to header_bin in parse_notify";
LABEL_117:
              v45 = *(_DWORD *)v44;
              v46 = *((_DWORD *)v44 + 1);
              v47 = *((_DWORD *)v44 + 2);
              v48 = *((_DWORD *)v44 + 3);
              v49 = (int *)(v44 + 16);
              v96 = v45;
              v97 = v46;
              v98 = v47;
              v99 = v48;
              v50 = *v49;
              v51 = v49[1];
              v52 = v49[2];
              v53 = v49[3];
              v49 += 4;
              v100 = v50;
              v101 = v51;
              v102 = v52;
              v103 = v53;
              v54 = *v49;
              v55 = v49[1];
              v56 = v49[2];
              v57 = v49[3];
              v49 += 4;
              v104 = v54;
              v105 = v55;
              v106 = v56;
              v107 = v57;
              v58 = v49[1];
              v108 = *v49;
              v109 = v58;
              v110 = BYTE2(v58);
              applog(3, (const char *)&v96, 0);
LABEL_43:
              rw_unlock_constprop_14(v78, "parse_notify", 2054);
              v30 = mutex_unlock_noyield_constprop_15(v84, "parse_notify", 2054);
              selective_yield(v30);
              if ( !*(_BYTE *)v86 )
                goto LABEL_80;
              if ( opt_debug )
              {
                if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
                  goto LABEL_51;
                snprintf((char *)&v96, 2048u, "job_id: %s", v6);
                applog(7, (const char *)&v96, 0);
                if ( !opt_debug )
                  goto LABEL_66;
                if ( !use_syslog )
                {
LABEL_51:
                  if ( !opt_log_output && opt_log_level <= 6 )
                    goto LABEL_55;
                }
                snprintf((char *)&v96, 2048u, "prev_hash: %s", v93);
                applog(7, (const char *)&v96, 0);
                if ( !opt_debug )
                  goto LABEL_71;
                if ( !use_syslog )
                {
LABEL_55:
                  if ( !opt_log_output && opt_log_level <= 6 )
                    goto LABEL_59;
                }
                snprintf((char *)&v96, 2048u, "coinbase1: %s", v7);
                applog(7, (const char *)&v96, 0);
                if ( !opt_debug )
                {
LABEL_94:
                  if ( !opt_debug )
                    goto LABEL_80;
                  if ( use_syslog )
                  {
LABEL_77:
                    v31 = "yes";
                    if ( !v88 )
                      v31 = "no";
                    snprintf((char *)&v96, 2048u, "clean: %s", v31);
                    applog(7, (const char *)&v96, 0);
                    goto LABEL_80;
                  }
LABEL_75:
                  if ( opt_log_output || opt_log_level > 6 )
                    goto LABEL_77;
LABEL_80:
                  free(v7);
                  free(v8);
                  v32 = (int)v94;
                  v33 = *(_QWORD *)&total_getworks + 1LL;
                  ++*((_DWORD *)v94 + 29);
                  *(_QWORD *)&total_getworks = v33;
                  if ( v32 == current_pool() )
                    opt_work_update = 1;
                  return (_DWORD *)v5;
                }
                if ( !use_syslog )
                {
LABEL_59:
                  if ( !opt_log_output && opt_log_level <= 6 )
                    goto LABEL_63;
                }
                snprintf((char *)&v96, 2048u, "coinbase2: %s", v8);
                applog(7, (const char *)&v96, 0);
              }
              if ( !opt_debug )
                goto LABEL_80;
              if ( use_syslog )
              {
LABEL_65:
                snprintf((char *)&v96, 2048u, "bbversion: %s", v92);
                applog(7, (const char *)&v96, 0);
LABEL_66:
                if ( !opt_debug )
                  goto LABEL_80;
                if ( use_syslog )
                {
LABEL_70:
                  snprintf((char *)&v96, 2048u, "nbit: %s", v90);
                  applog(7, (const char *)&v96, 0);
LABEL_71:
                  if ( !opt_debug )
                    goto LABEL_80;
                  if ( use_syslog )
                  {
LABEL_93:
                    snprintf((char *)&v96, 2048u, "ntime: %s", v89);
                    applog(7, (const char *)&v96, 0);
                    goto LABEL_94;
                  }
LABEL_73:
                  if ( !opt_log_output && opt_log_level <= 6 )
                    goto LABEL_75;
                  goto LABEL_93;
                }
LABEL_68:
                if ( !opt_log_output && opt_log_level <= 6 )
                  goto LABEL_73;
                goto LABEL_70;
              }
LABEL_63:
              if ( !opt_log_output && opt_log_level <= 6 )
                goto LABEL_68;
              goto LABEL_65;
            }
LABEL_115:
            v5 = 0;
            goto LABEL_43;
          }
          goto LABEL_19;
        }
LABEL_15:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)&v96, 2048u, "Invalid char 0x%x passed to valid_ascii from", " in %s %s():%d");
          applog(3, (const char *)&v96, 0);
        }
LABEL_19:
        free(v6);
        free(v7);
        free(v8);
        return 0;
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        goto LABEL_19;
      snprintf(
        (char *)&v96,
        2048u,
        "Zero length string passed to valid_ascii from",
        " in %s %s():%d",
        "util.c",
        "parse_notify",
        1947);
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        goto LABEL_19;
      snprintf(
        (char *)&v96,
        2048u,
        "Null string passed to valid_ascii from",
        " in %s %s():%d",
        "util.c",
        "parse_notify",
        1947);
    }
    applog(3, (const char *)&v96, 0);
    goto LABEL_19;
  }
  return result;
}
// 7DF94: using guessed type char *workpadding;
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BAB8: using guessed type char opt_protocol;
// 80CC18: using guessed type char use_syslog;
// 80DD00: using guessed type int total_getworks;
// 80EF00: using guessed type char opt_work_update;

//----- (00048768) --------------------------------------------------------
int __fastcall socks4_negotiate(const char **a1, int a2, int a3)
{
  const char *v6; // r0
  __int16 v7; // kr00_2
  unsigned int v8; // r6
  int v10; // r5
  const char *v11; // r0
  const char *v12; // r9
  int v13; // r0
  int v14; // r8
  unsigned int v15; // r6
  struct addrinfo *pai; // [sp+8h] [bp-A48h] BYREF
  char v17; // [sp+Ch] [bp-A44h] BYREF
  char buf[4]; // [sp+2Ch] [bp-A24h] BYREF
  char v19; // [sp+30h] [bp-A20h]
  char v20; // [sp+31h] [bp-A1Fh]
  char v21; // [sp+32h] [bp-A1Eh]
  char v22; // [sp+33h] [bp-A1Dh]
  char v23[8]; // [sp+34h] [bp-A1Ch] BYREF
  char v24[500]; // [sp+3Ch] [bp-A14h] BYREF
  struct addrinfo v25; // [sp+230h] [bp-820h] BYREF

  v6 = a1[146];
  buf[0] = 4;
  buf[1] = 1;
  v7 = strtol(v6, 0, 10);
  buf[2] = HIBYTE(v7);
  buf[3] = v7;
  strcpy(v23, "CGMINER");
  v8 = bswap32(inet_addr(a1[150]));
  if ( v8 != -1 )
    goto LABEL_2;
  pai = (struct addrinfo *)&v17;
  memset(&v25, 0, sizeof(v25));
  v11 = a1[150];
  v25.ai_family = 2;
  if ( !getaddrinfo(v11, 0, &v25, &pai) )
  {
    v15 = *(_DWORD *)&pai->ai_addr->sa_data[2];
    freeaddrinfo(pai);
    v8 = bswap32(v15);
    if ( v8 != -1 )
    {
LABEL_2:
      v22 = v8;
      v19 = HIBYTE(v8);
      v20 = BYTE2(v8);
      v21 = BYTE1(v8);
      send(a2, buf, 16u, 0);
      goto LABEL_3;
    }
LABEL_23:
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      return 0;
    snprintf((char *)&v25, 2048u, "Invalid IP address specified for socks4 proxy: %s", a1[150]);
    goto LABEL_9;
  }
  if ( !a3 )
    goto LABEL_23;
  v12 = a1[150];
  v22 = 1;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v13 = strlen(v12);
  if ( v13 >= 255 )
    v13 = 255;
  v14 = v13;
  cg_memcpy(v24, v12, v13, (int)"util.c", (int)"socks4_negotiate", 2855);
  v24[v14] = 0;
  send(a2, buf, v14 + 17, 0);
LABEL_3:
  if ( recv(a2, &v25, 1u, 0) == -1 || LOBYTE(v25.ai_flags) || recv(a2, &v25, 1u, 0) == -1 || LOBYTE(v25.ai_flags) != 90 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
      return 0;
    snprintf((char *)&v25, 2048u, "Bad response from %s:%s SOCKS4 server", a1[151], a1[152]);
LABEL_9:
    applog(4, (const char *)&v25, 0);
    return 0;
  }
  v10 = 6;
  do
  {
    recv(a2, &v25, 1u, 0);
    --v10;
  }
  while ( v10 );
  return 1;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;
// 48768: using guessed type struct addrinfo var_820;
// 48768: using guessed type char var_A14[500];

//----- (00048954) --------------------------------------------------------
int __fastcall setup_stratum_socket(int a1)
{
  pthread_mutex_t *v1; // r5
  int v2; // r0
  int v3; // r0
  int v4; // r5
  struct addrinfo *v6; // r6
  _DWORD *v7; // r4
  int v8; // r0
  int v9; // r1
  int v10; // r2
  __int16 v11; // r3
  int v12; // r0
  int v13; // r7
  int v14; // r0
  int *v15; // r10
  int v16; // r3
  int v17; // r11
  int v18; // r11
  fd_set *p_ai_next; // r3
  int v20; // r0
  int v21; // r0
  const char *v22; // r0
  int v23; // r3
  int *v24; // r0
  int *v25; // r0
  const char *v26; // r10
  int v27; // r0
  int v28; // r9
  __int16 v29; // r0
  char *v30; // lr
  int v31; // r9
  int v32; // r9
  int v33; // r5
  int v34; // r5
  int v36; // [sp+20h] [bp-A78h]
  char *name; // [sp+30h] [bp-A68h]
  char *service; // [sp+34h] [bp-A64h]
  struct addrinfo *pai; // [sp+38h] [bp-A60h] BYREF
  socklen_t optlen; // [sp+3Ch] [bp-A5Ch] BYREF
  int optval; // [sp+40h] [bp-A58h] BYREF
  struct timeval timeout; // [sp+44h] [bp-A54h] BYREF
  struct addrinfo s; // [sp+4Ch] [bp-A4Ch] BYREF
  fd_set writefds; // [sp+6Ch] [bp-A2Ch] BYREF
  _DWORD v45[522]; // [sp+270h] [bp-828h] BYREF

  v1 = (pthread_mutex_t *)(a1 + 704);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
  {
    v24 = _errno_location();
    snprintf(
      (char *)v45,
      2048u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v24,
      "util.c",
      "setup_stratum_socket",
      2902);
    applog(3, (const char *)v45, 1);
    quit(1);
  }
  v2 = *(_DWORD *)(a1 + 588);
  *(_BYTE *)(a1 + 641) = 0;
  if ( v2 )
    close(v2);
  *(_DWORD *)(a1 + 588) = 0;
  if ( pthread_mutex_unlock(v1) )
  {
    v25 = _errno_location();
    snprintf(
      (char *)v45,
      2048u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v25,
      "util.c",
      "setup_stratum_socket",
      2907);
    applog(3, (const char *)v45, 1);
    quit(1);
  }
  selective_yield(0);
  memset(&s, 0, sizeof(s));
  s.ai_socktype = 1;
  if ( *(_DWORD *)(a1 + 184) )
    goto LABEL_6;
  v22 = (const char *)opt_socks_proxy;
  if ( !opt_socks_proxy )
  {
    name = *(char **)(a1 + 600);
    goto LABEL_94;
  }
  *(_DWORD *)(a1 + 184) = opt_socks_proxy;
  extract_sockaddr(v22, (_DWORD *)(a1 + 604), (char **)(a1 + 608));
  v23 = *(_DWORD *)(a1 + 184);
  *(_DWORD *)(a1 + 180) = 3;
  name = *(char **)(a1 + 600);
  if ( !v23 )
  {
LABEL_94:
    service = *(char **)(a1 + 584);
    v3 = getaddrinfo(name, service, &s, &pai);
    goto LABEL_7;
  }
LABEL_6:
  name = *(char **)(a1 + 604);
  service = *(char **)(a1 + 608);
  v3 = getaddrinfo(name, service, &s, &pai);
LABEL_7:
  if ( v3 )
  {
    v4 = *(unsigned __int8 *)(a1 + 99);
    if ( *(_BYTE *)(a1 + 99) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)v45, 2048u, "Failed to getaddrinfo for %s:%s", name, service);
        applog(6, (const char *)v45, 0);
        return 0;
      }
      return 0;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)v45, 2048u, "Failed to resolve (?wrong URL) %s:%s", name, service);
      applog(4, (const char *)v45, 0);
    }
    *(_BYTE *)(a1 + 99) = 1;
    return v4;
  }
  if ( !pai )
  {
LABEL_30:
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)v45, 2048u, "Failed to connect to stratum on %s:%s", name, service);
      applog(6, (const char *)v45, 0);
    }
    freeaddrinfo(pai);
    return 0;
  }
  v6 = pai;
  while ( 1 )
  {
    v12 = socket(v6->ai_family, v6->ai_socktype, v6->ai_protocol);
    v13 = v12;
    if ( v12 == -1 )
    {
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_21;
      v7 = v45;
      v8 = *(_DWORD *)"Failed socket";
      v9 = *(_DWORD *)"ed socket";
      v10 = *(_DWORD *)"ocket";
      v11 = *(_WORD *)"t";
      goto LABEL_20;
    }
    v14 = fcntl(v12, 3, 0, v12 + 1);
    fcntl(v13, 4, v14 | 0x800);
    if ( connect(v13, v6->ai_addr, v6->ai_addrlen) != -1 )
      break;
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    v15 = _errno_location();
    if ( *v15 == 115 )
    {
      LOBYTE(v16) = v13 & 0x1F;
      v17 = (v13 + 31) & (v13 >> 31);
      if ( v13 >= 0 )
        v17 = v13;
      v18 = v17 >> 5;
      if ( v13 <= 0 )
        v16 = -(-v13 & 0x1F);
      v36 = 1 << v16;
      while ( 1 )
      {
        p_ai_next = (fd_set *)&s.ai_next;
        do
        {
          p_ai_next->__fds_bits[1] = 0;
          p_ai_next = (fd_set *)((char *)p_ai_next + 4);
        }
        while ( &writefds.__fds_bits[31] != (__fd_mask *)p_ai_next );
        writefds.__fds_bits[v18] |= v36;
        v20 = select(v13 + 1, 0, &writefds, 0, &timeout);
        if ( v20 > 0 )
          break;
        if ( !v20 || *v15 != 4 )
          goto LABEL_49;
      }
      if ( (v36 & writefds.__fds_bits[v18]) != 0 )
      {
        optlen = 4;
        if ( !getsockopt(v13, 1, 4, &optval, &optlen) && !optval )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)v45, "Succeeded delayed connect");
            applog(7, (const char *)v45, 0);
          }
          goto LABEL_64;
        }
      }
LABEL_49:
      close(v13);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        qmemcpy(v45, "Select timeout/f", 16);
        v7 = &v45[4];
        v8 = *(_DWORD *)"ailed connect";
        v9 = *(_DWORD *)"d connect";
        v10 = *(_DWORD *)"nnect";
        v11 = *(_WORD *)"t";
LABEL_20:
        *v7 = v8;
        v7[1] = v9;
        v7[2] = v10;
        *((_WORD *)v7 + 6) = v11;
        applog(7, (const char *)v45, 0);
      }
LABEL_21:
      v6 = v6->ai_next;
      if ( !v6 )
        goto LABEL_30;
    }
    else
    {
      close(v13);
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_21;
      strcpy((char *)v45, "Failed sock connect");
      applog(7, (const char *)v45, 0);
      v6 = v6->ai_next;
      if ( !v6 )
        goto LABEL_30;
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)v45, "Succeeded immediate connect");
    applog(4, (const char *)v45, 0);
  }
LABEL_64:
  block_socket(v13);
  freeaddrinfo(pai);
  if ( *(_DWORD *)(a1 + 184) )
  {
    switch ( *(_DWORD *)(a1 + 180) )
    {
      case 0:
        if ( !http_negotiate((const char **)a1, v13, 0) )
          return 0;
        break;
      case 1:
        if ( !http_negotiate((const char **)a1, v13, 1) )
          return 0;
        break;
      case 2:
        if ( !socks4_negotiate((const char **)a1, v13, 0) )
          return 0;
        break;
      case 3:
      case 5:
        LOWORD(writefds.__fds_bits[0]) = 261;
        BYTE2(writefds.__fds_bits[0]) = 0;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)v45,
            2048u,
            "Attempting to negotiate with %s:%s SOCKS5 proxy",
            *(const char **)(a1 + 604),
            *(const char **)(a1 + 608));
          applog(7, (const char *)v45, 0);
        }
        send(v13, &writefds, 3u, 0);
        if ( recv(v13, v45, 1u, 0) == -1
          || LOBYTE(v45[0]) != 5
          || recv(v13, v45, 1u, 0) == -1
          || BYTE2(writefds.__fds_bits[0]) != LOBYTE(v45[0]) )
        {
          goto LABEL_71;
        }
        writefds.__fds_bits[0] = 50331909;
        v26 = *(const char **)(a1 + 600);
        v27 = strlen(v26);
        if ( v27 >= 255 )
          v27 = 255;
        v28 = v27;
        LOBYTE(writefds.__fds_bits[1]) = v27;
        cg_memcpy((char *)&writefds.__fds_bits[1] + 1, v26, v27, (int)"util.c", (int)"socks5_negotiate", 2753);
        v29 = strtol(*(const char **)(a1 + 584), 0, 10);
        v30 = (char *)&writefds + v28;
        v30[6] = v29;
        v30[5] = HIBYTE(v29);
        send(v13, &writefds, v28 + 7, 0);
        if ( recv(v13, v45, 1u, 0) == -1 )
          goto LABEL_71;
        if ( LOBYTE(v45[0]) != 5 )
          goto LABEL_71;
        if ( recv(v13, v45, 1u, 0) == -1 )
          goto LABEL_71;
        v31 = LOBYTE(v45[0]);
        if ( LOBYTE(v45[0]) )
          goto LABEL_71;
        recv(v13, v45, 1u, 0);
        if ( recv(v13, v45, 1u, v31) == -1 )
          goto LABEL_71;
        if ( LOBYTE(v45[0]) == 1 )
        {
          v34 = 4;
          do
          {
            recv(v13, v45, 1u, 0);
            --v34;
          }
          while ( v34 );
        }
        else
        {
          if ( LOBYTE(v45[0]) != 3 )
          {
LABEL_71:
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf(
                (char *)v45,
                2048u,
                "Bad response from %s:%s SOCKS5 server",
                *(const char **)(a1 + 604),
                *(const char **)(a1 + 608));
              applog(4, (const char *)v45, 0);
            }
            return 0;
          }
          if ( recv(v13, v45, 1u, 0) != -1 )
          {
            v32 = LOBYTE(v45[0]);
            if ( LOBYTE(v45[0]) )
            {
              v33 = 0;
              do
              {
                ++v33;
                recv(v13, v45, 1u, 0);
              }
              while ( v32 != v33 );
            }
          }
        }
        recv(v13, v45, 1u, 0);
        recv(v13, v45, 1u, 0);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)v45,
            2048u,
            "Success negotiating with %s:%s SOCKS5 proxy",
            *(const char **)(a1 + 604),
            *(const char **)(a1 + 608));
          applog(7, (const char *)v45, 0);
        }
        break;
      case 4:
        if ( socks4_negotiate((const char **)a1, v13, 1) )
          break;
        return 0;
      default:
        if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
          return 0;
        v4 = 0;
        snprintf(
          (char *)v45,
          2048u,
          "Unsupported proxy type for %s:%s",
          *(const char **)(a1 + 604),
          *(const char **)(a1 + 608));
        applog(4, (const char *)v45, 0);
        return v4;
    }
  }
  if ( !*(_DWORD *)(a1 + 592) )
  {
    *(_DWORD *)(a1 + 592) = cgcalloc(8192u, 1u, "util.c", "setup_stratum_socket", 3044);
    *(_DWORD *)(a1 + 596) = 8192;
  }
  *(_DWORD *)(a1 + 588) = v13;
  writefds.__fds_bits[0] = 45;
  v45[0] = 30;
  timeout.tv_sec = 1;
  v21 = fcntl(v13, 3, 0);
  fcntl(v13, 4, v21 | 0x800);
  setsockopt(v13, 1, 9, &timeout, 4u);
  if ( !opt_delaynet )
    fcntl(v13, 2, 1);
  setsockopt(v13, 6, 1, &timeout, 4u);
  setsockopt(v13, 6, 6, &timeout, 4u);
  setsockopt(v13, 6, 4, &writefds, 4u);
  setsockopt(v13, 6, 5, v45, 4u);
  return 1;
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 82AF0: using guessed type int opt_socks_proxy;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80CC19: using guessed type char opt_delaynet;

//----- (0004929C) --------------------------------------------------------
int __fastcall config_asicboost(int a1)
{
  int v2; // r4
  int v4; // r2
  int v5; // r0
  char *v6; // r0
  char *v7; // r7
  _DWORD *v8; // r5
  _DWORD *v9; // r4
  _DWORD *v10; // r0
  const char *v11; // r4
  char *v12; // r0
  int v13; // r3
  int v14; // r3
  char *v15; // r0
  _DWORD *v16; // r0
  const char *v17; // r4
  signed int v18; // r0
  char *v19; // r2
  const char *v20; // r0
  const char *v21; // r3
  char v22; // t1
  int v23; // r4
  int v24; // r0
  int v25; // r3
  int v26; // r1
  int v28[2]; // [sp+8h] [bp-2920h] BYREF
  char v29; // [sp+10h] [bp-2918h]
  int v30[23]; // [sp+14h] [bp-2914h] BYREF
  char v31[160]; // [sp+70h] [bp-28B8h] BYREF
  char v32[2048]; // [sp+110h] [bp-2818h] BYREF
  char s[8216]; // [sp+910h] [bp-2018h] BYREF

  v28[0] = 48;
  v28[1] = 0;
  v29 = 0;
  if ( !setup_stratum_socket(a1) )
    return 0;
  clear_sock(a1);
  v4 = swork_id++;
  sprintf(
    s,
    "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"ffffffff\""
    ",\"version-rolling.min-bit-count\":%d}]}",
    v4,
    2);
  v5 = strlen(s);
  if ( _stratum_send(a1, s, v5) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(v32, "Failed to send s in initiate_stratum");
      applog(7, v32, 0);
    }
    return 0;
  }
  if ( !socket_full_isra_2(*(_DWORD *)(a1 + 588), 60) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(v32, "Timed out waiting for response in initiate_stratum");
      applog(7, v32, 0);
    }
    return 0;
  }
  v6 = recv_line(a1);
  v7 = v6;
  if ( !v6 )
    return 0;
  v8 = (_DWORD *)json_loads((int)v6, 0, (int)v30);
  free(v7);
  if ( !v8 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(v32, 2048u, "JSON decode failed(%d): %s", v30[0], v31);
      applog(6, v32, 0);
    }
    return 0;
  }
  v9 = (_DWORD *)json_object_get(v8, "result");
  v10 = (_DWORD *)json_object_get(v8, "error");
  if ( !v9 || *v9 == 7 )
  {
    if ( !v10 )
    {
      v15 = (char *)malloc(17u);
      v11 = v15;
      if ( v15 )
        strcpy(v15, "(unknown reason)");
      goto LABEL_23;
    }
LABEL_22:
    v11 = (const char *)json_dumps(v10, 3);
LABEL_23:
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(v32, 2048u, "JSON-RPC decode failed: %s", v11);
      applog(5, v32, 0);
    }
    v12 = (char *)v11;
    v2 = 0;
    free(v12);
    opt_multi_version = 1;
    *(_DWORD *)(a1 + 652) = 49152;
    *(_DWORD *)(a1 + 648) = 4;
    goto LABEL_28;
  }
  if ( v10 && *v10 != 7 )
    goto LABEL_22;
  v16 = (_DWORD *)json_object_get(v9, "version-rolling.mask");
  v17 = (const char *)json_string_value(v16);
  v18 = strlen(v17);
  if ( v18 > 0 )
  {
    v19 = (char *)v28 + 7 - v18;
    v20 = &v17[v18 - 1];
    v21 = v17 - 1;
    do
    {
      v22 = *++v21;
      *++v19 = v22;
    }
    while ( v21 != v20 );
  }
  v23 = 0;
  v29 = 0;
  hex2bin((_BYTE *)(a1 + 652), (unsigned __int8 *)v28, 4);
  v24 = 0;
  v25 = 0;
  do
  {
    v26 = 1 << v25;
    if ( ((*(_DWORD *)(a1 + 652) >> v25++) & 1) != 0 )
    {
      v23 |= v26;
      if ( v24 )
        break;
      v24 = 1;
    }
  }
  while ( v25 != 32 );
  *(_DWORD *)(a1 + 652) = v23;
  v2 = 1;
  opt_multi_version = 1;
  *(_DWORD *)(a1 + 648) = 4;
LABEL_28:
  v13 = v8[1];
  if ( v13 == -1 )
    return v2;
  v14 = v13 - 1;
  v8[1] = v14;
  if ( v14 )
    return v2;
  json_delete(v8);
  return v2;
}
// 7DF98: using guessed type int opt_multi_version;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CBA8: using guessed type int swork_id;
// 80CC18: using guessed type char use_syslog;
// 4929C: using guessed type int var_2914[23];
// 4929C: using guessed type char var_28B8[160];

//----- (000495B4) --------------------------------------------------------
int __fastcall initiate_stratum(_DWORD *a1)
{
  _DWORD *v2; // r5
  unsigned int v3; // r6
  unsigned int v4; // r8
  int v5; // r0
  const char *v6; // r3
  int v7; // r2
  int v8; // r0
  int v9; // r9
  int v10; // r3
  int v11; // r3
  int v12; // r4
  int v13; // r3
  int v14; // r3
  int v16; // r2
  int *v17; // r0
  int *v18; // r0
  int *v19; // r0
  int *v20; // r0
  char *v21; // r0
  char *v22; // r10
  _DWORD *v23; // r9
  _DWORD *v24; // r0
  char *v25; // r8
  char *v26; // r0
  _DWORD *v27; // r0
  unsigned int v28; // r8
  _DWORD *v29; // r0
  _DWORD *v30; // r10
  char *v31; // r0
  char *v32; // r10
  const char *v33; // r0
  _DWORD *v34; // r0
  int v35; // r0
  const char *v36; // r1
  size_t v37; // r3
  void *v38; // r0
  _BYTE *v39; // r0
  int v40; // r2
  int v41; // r1
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  _DWORD *v45; // [sp+10h] [bp-14h]
  int v46; // [sp+10h] [bp-14h]
  _DWORD *v47; // [sp+14h] [bp-10h]
  int v48[23]; // [sp+24h] [bp+0h] BYREF
  char v49[160]; // [sp+80h] [bp+5Ch] BYREF
  char v50[2048]; // [sp+120h] [bp+FCh] BYREF
  char s[8196]; // [sp+920h] [bp+8FCh] BYREF

  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = setup_stratum_socket((int)a1);
  if ( !v5 )
    goto LABEL_26;
  while ( 1 )
  {
    if ( v4 )
    {
      clear_sock((int)a1);
      v16 = swork_id++;
      sprintf(s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v16);
    }
    else
    {
      v6 = (const char *)a1[159];
      if ( v6 )
      {
        v7 = swork_id++;
        sprintf(s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"bmminer/2.0.0\", \"%s\"]}", v7, v6);
      }
      else
      {
        ++swork_id;
        sprintf(s, aIdDMethodMinin_6);
      }
    }
    v8 = strlen(s);
    if ( _stratum_send((int)a1, s, v8) )
    {
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_10;
      v9 = 1;
      strcpy(v50, "Failed to send s in initiate_stratum");
      applog(7, v50, 0);
    }
    else if ( socket_full_isra_2(a1[147], 60) )
    {
      v21 = recv_line((int)a1);
      v22 = v21;
      if ( !v21 )
        goto LABEL_10;
      v2 = (_DWORD *)json_loads((int)v21, 0, (int)v48);
      free(v22);
      if ( v2 )
      {
        v23 = (_DWORD *)json_object_get(v2, "result");
        v24 = (_DWORD *)json_object_get(v2, "error");
        if ( !v23 || *v23 == 7 )
        {
          if ( v24 )
          {
LABEL_59:
            v25 = (char *)json_dumps(v24, 3);
          }
          else
          {
            v26 = (char *)malloc(17u);
            v25 = v26;
            if ( v26 )
              strcpy(v26, "(unknown reason)");
          }
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf(v50, 2048u, "JSON-RPC decode failed: %s", v25);
            applog(6, v50, 0);
          }
LABEL_64:
          v9 = 1;
          free(v25);
          v4 = 1;
          goto LABEL_11;
        }
        if ( v24 && *v24 != 7 )
          goto LABEL_59;
        v27 = json_array_get(v23, 0);
        v45 = v27;
        if ( v27 )
        {
          if ( *v27 == 1 )
          {
            v47 = json_array_size(v27);
            if ( (int)v47 > 0 )
            {
              v28 = 0;
              do
              {
                v29 = json_array_get(v45, v28);
                v30 = v29;
                if ( !v29 || *v29 != 1 )
                  break;
                ++v28;
                v33 = (const char *)_json_array_string(v29, 0);
                if ( v33 && !strncasecmp(v33, "mining.notify", 13u) )
                {
                  v25 = json_array_string(v30, 1u);
                  if ( v25 )
                    goto LABEL_85;
                  break;
                }
              }
              while ( v47 != (_DWORD *)v28 );
            }
          }
        }
        v31 = (char *)(unsigned __int8)opt_debug;
        if ( opt_debug
          && (use_syslog || (v31 = (char *)(unsigned __int8)opt_log_output, opt_log_output) || opt_log_level > 6) )
        {
          v25 = 0;
          strcpy(v50, "Failed to get sessionid in initiate_stratum");
          applog(7, v50, 0);
        }
        else
        {
          v25 = v31;
        }
LABEL_85:
        v32 = json_array_string(v23, 1u);
        if ( !valid_hex_constprop_10(v32, (int)"initiate_stratum", 3258) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            strcpy(v50, "Failed to get valid nonce1 in initiate_stratum");
            applog(6, v50, 0);
          }
          goto LABEL_64;
        }
        v34 = json_array_get(v23, 2u);
        v35 = json_integer_value((int)v34);
        if ( (unsigned int)(v35 - 2) <= 14 )
        {
          v46 = v35;
          if ( v25 )
          {
            v36 = (const char *)a1[159];
            if ( v36 )
            {
              if ( !strcmp(v25, v36) && (use_syslog || opt_log_output || opt_log_level > 4) )
              {
                snprintf(v50, 2048u, "Pool %d successfully negotiated resume with the same session ID", *a1);
                applog(5, v50, 0);
              }
            }
          }
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
            mutex_lock_part_1_constprop_16("initiate_stratum", 3279);
          if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v44 = _errno_location();
            snprintf(
              v50,
              2048u,
              "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
              *v44,
              "util.c",
              "initiate_stratum",
              3279);
            applog(3, v50, 1);
            quit(1);
          }
          free((void *)a1[153]);
          free((void *)a1[159]);
          a1[159] = v25;
          a1[153] = v32;
          v37 = strlen(v32) >> 1;
          v38 = (void *)a1[154];
          a1[391] = v37;
          free(v38);
          v39 = cgcalloc(a1[391], 1u, "util.c", "initiate_stratum", 3286);
          v40 = a1[391];
          a1[154] = v39;
          hex2bin(v39, (unsigned __int8 *)a1[153], v40);
          a1[158] = v46;
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v43 = _errno_location();
            snprintf(
              v50,
              2048u,
              "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *v43,
              "util.c",
              "initiate_stratum",
              3289);
            applog(3, v50, 1);
            quit(1);
          }
          if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
          {
            v42 = _errno_location();
            snprintf(
              v50,
              2048u,
              "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *v42,
              "util.c",
              "initiate_stratum",
              3289);
            applog(3, v50, 1);
            quit(1);
          }
          selective_yield(0);
          if ( v25 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(v50, 2048u, "Pool %d stratum session id: %s", *a1, (const char *)a1[159]);
            applog(7, v50, 0);
          }
          if ( !a1[144] )
            a1[144] = a1[150];
          v41 = (unsigned __int8)opt_protocol;
          *((_BYTE *)a1 + 641) = 1;
          *((_QWORD *)a1 + 227) = 0LL;
          *((_QWORD *)a1 + 228) = 4607182418800017408LL;
          if ( v41 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              v50,
              2048u,
              "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
              *a1,
              (const char *)a1[153],
              a1[158]);
            applog(7, v50, 0);
          }
          v12 = 1;
          goto LABEL_35;
        }
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          strcpy(v50, "Failed to get valid n2size in initiate_stratum");
          applog(6, v50, 0);
        }
        v9 = 1;
        free(v25);
        v4 = 1;
        free(v32);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        v9 = 1;
        snprintf(v50, 2048u, "JSON decode failed(%d): %s", v48[0], v49);
        v4 = 1;
        applog(6, v50, 0);
      }
      else
      {
        v4 = 1;
        v9 = 1;
      }
    }
    else
    {
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      {
LABEL_10:
        v9 = 1;
        goto LABEL_11;
      }
      v9 = 1;
      strcpy(v50, "Timed out waiting for response in initiate_stratum");
      applog(7, v50, 0);
    }
LABEL_11:
    if ( v3 >= v4 )
      break;
    while ( 1 )
    {
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v17 = _errno_location();
        snprintf(
          v50,
          2048u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v17,
          "util.c",
          "initiate_stratum",
          3317);
        applog(3, v50, 1);
        quit(1);
      }
      if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v18 = _errno_location();
        snprintf(
          v50,
          2048u,
          "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v18,
          "util.c",
          "initiate_stratum",
          3317);
        applog(3, v50, 1);
        quit(1);
      }
      free((void *)a1[159]);
      free((void *)a1[153]);
      a1[153] = 0;
      a1[159] = 0;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v20 = _errno_location();
        snprintf(
          v50,
          2048u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v20,
          "util.c",
          "initiate_stratum",
          3321);
        applog(3, v50, 1);
        quit(1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v19 = _errno_location();
        snprintf(
          v50,
          2048u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v19,
          "util.c",
          "initiate_stratum",
          3321);
        applog(3, v50, 1);
        quit(1);
      }
      selective_yield(0);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(v50, "Failed to resume stratum, trying afresh");
        applog(7, v50, 0);
      }
      if ( v2 )
      {
        v10 = v2[1];
        if ( v10 != -1 )
        {
          v11 = v10 - 1;
          v2[1] = v11;
          if ( !v11 )
            json_delete(v2);
        }
      }
      v3 = 1;
      v5 = setup_stratum_socket((int)a1);
      if ( v5 )
        break;
LABEL_26:
      v9 = v5;
      if ( v3 >= v4 )
        goto LABEL_27;
    }
  }
LABEL_27:
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(v50, "Initiate stratum failed");
    applog(7, v50, 0);
  }
  if ( v9 )
    suspend_stratum((int)a1);
  v12 = (int)v2;
  if ( v2 )
  {
    v12 = 0;
LABEL_35:
    v13 = v2[1];
    if ( v13 != -1 )
    {
      v14 = v13 - 1;
      v2[1] = v14;
      if ( !v14 )
        json_delete(v2);
    }
  }
  return v12;
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80BAB8: using guessed type char opt_protocol;
// 80CBA8: using guessed type int swork_id;
// 80CC18: using guessed type char use_syslog;
// 495B4: using guessed type char var_28A4[160];
// 495B4: using guessed type int var_2900[23];

//----- (00049FC0) --------------------------------------------------------
int __fastcall restart_stratum(int a1)
{
  if ( *(_BYTE *)(a1 + 641) )
    suspend_stratum(a1);
  if ( initiate_stratum((_DWORD *)a1)
    && (!*(_BYTE *)(a1 + 580) || subscribe_extranonce(a1))
    && auth_stratum((_DWORD *)a1) )
  {
    stratum_resumed(a1);
    return 1;
  }
  else
  {
    pool_died(a1);
    return 0;
  }
}
// 4AB7C: using guessed type int __fastcall subscribe_extranonce(_DWORD);

//----- (0004A004) --------------------------------------------------------
int __fastcall parse_reconnect(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  const char *v5; // r0
  const char *v6; // r9
  const char *v7; // r5
  char *v8; // r8
  char *v9; // r0
  _DWORD *v10; // r0
  int v11; // r0
  const char *v12; // r6
  int v13; // r3
  void *v14; // r0
  void *v15; // r0
  _DWORD *v17; // r0
  int *v18; // r0
  int *v19; // r0
  char s[264]; // [sp+10h] [bp-108h] BYREF
  int v21; // [sp+118h] [bp+0h] BYREF
  char *v22; // [sp+11Ch] [bp+4h] BYREF
  char v23[256]; // [sp+120h] [bp+8h] BYREF
  char v24[2052]; // [sp+220h] [bp+108h] BYREF

  memset(v23, 0, 255u);
  v4 = json_array_get(a2, 0);
  v5 = (const char *)json_string_value(v4);
  if ( v5 )
  {
    v6 = (const char *)a1[150];
    v7 = v5;
    v8 = strchr(v6, 46);
    if ( v8 )
    {
      v9 = strchr(v7, 46);
      if ( v9 )
      {
        if ( !strcmp(v8, v9) )
          goto LABEL_5;
        if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
          return 0;
        snprintf(v24, 2048u, "Denied stratum reconnect request to non-matching domain url '%s'", v6);
      }
      else
      {
        if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
          return 0;
        snprintf(v24, 2048u, "Denied stratum reconnect request to url without domain '%s'", v7);
      }
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        return 0;
      snprintf(v24, 2048u, "Denied stratum reconnect request for pool without domain '%s'", v6);
    }
    applog(3, v24, 0);
    return 0;
  }
  v7 = (const char *)a1[150];
LABEL_5:
  v10 = json_array_get(a2, 1u);
  v11 = json_integer_value((int)v10);
  if ( v11 )
  {
    v12 = s;
    sprintf(s, "%d", v11);
  }
  else
  {
    v17 = json_array_get(a2, 1u);
    v12 = (const char *)json_string_value(v17);
    if ( !v12 )
      v12 = (const char *)a1[146];
  }
  snprintf(v23, 254u, "%s:%s", v7, v12);
  if ( !extract_sockaddr(v23, &v21, &v22) )
    return 0;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(v24, 2048u, "Stratum reconnect requested from pool %d to %s", *a1, v23);
    applog(4, v24, 0);
  }
  clear_pool_work(a1);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 176)) )
  {
    v18 = _errno_location();
    snprintf(v24, 2048u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v18, "util.c", "parse_reconnect", 2334);
    applog(3, v24, 1);
    quit(1);
  }
  _suspend_stratum((int)a1);
  v13 = v21;
  v14 = (void *)a1[150];
  a1[144] = v21;
  a1[150] = v13;
  free(v14);
  v15 = (void *)a1[146];
  a1[146] = v22;
  free(v15);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176)) )
  {
    v19 = _errno_location();
    snprintf(v24, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v19, "util.c", "parse_reconnect", 2343);
    applog(3, v24, 1);
    quit(1);
  }
  selective_yield(0);
  return restart_stratum((int)a1);
}
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80CC18: using guessed type char use_syslog;

//----- (0004A2C8) --------------------------------------------------------
int __fastcall parse_method(_DWORD *a1, int a2)
{
  int valid; // r6
  double v3; // d0
  _DWORD *v5; // r0
  _DWORD *v6; // r5
  _DWORD *v7; // r8
  _DWORD *v8; // r7
  _DWORD *v9; // r10
  char *v10; // r4
  int v11; // r3
  int v12; // r3
  const char *v14; // r0
  const char *v15; // r7
  _DWORD *v16; // r4
  unsigned int v17; // r7
  _DWORD *v18; // r0
  bool v19; // cf
  unsigned int v20; // r1
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r0
  _DWORD *v25; // r0
  char *v26; // r0
  double v27; // r0
  double v28; // d9
  const char *v29; // r2
  int v30; // r3
  char *v31; // r9
  int v32; // r0
  int v33; // r0
  _DWORD *v34; // r0
  _DWORD *v35; // r0
  _DWORD *v36; // r0
  size_t v37; // r3
  void *v38; // r0
  void *v39; // r0
  int v40; // r0
  int *v41; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  int *v45; // r0
  int v46; // [sp+0h] [bp-2150h]
  int v47; // [sp+14h] [bp-213Ch]
  int v48[23]; // [sp+1Ch] [bp-2134h] BYREF
  char v49[160]; // [sp+78h] [bp-20D8h] BYREF
  char s[8248]; // [sp+118h] [bp-2038h] BYREF

  if ( !a2 )
    return 0;
  v5 = (_DWORD *)json_loads(a2, 0, (int)v48);
  v6 = v5;
  if ( !v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      valid = 0;
      snprintf(s, 2048u, "JSON decode failed(%d): %s", v48[0], v49);
      applog(6, s, 0);
      return valid;
    }
    return 0;
  }
  v7 = (_DWORD *)json_object_get(v5, "method");
  if ( !v7 )
    goto LABEL_20;
  v8 = (_DWORD *)json_object_get(v6, "error");
  v9 = (_DWORD *)json_object_get(v6, "params");
  if ( v8 && *v8 != 7 )
  {
    v10 = (char *)json_dumps(v8, 3);
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(s, 2048u, "JSON-RPC method decode failed: %s", v10);
      applog(6, s, 0);
    }
    valid = 0;
    free(v10);
    goto LABEL_11;
  }
  v14 = (const char *)json_string_value(v7);
  v15 = v14;
  if ( !v14 )
  {
    valid = 0;
    goto LABEL_11;
  }
  if ( !strncasecmp(v14, "mining.multi_version", 20u) )
  {
    *((_BYTE *)a1 + 644) = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy(s, "Pool support multi version");
      applog(6, s, 0);
    }
    v16 = a1 + 163;
    v17 = 0;
    while ( 1 )
    {
      v19 = v17 >= (unsigned int)json_array_size(v9);
      v20 = v17++;
      if ( v19 )
        break;
      v18 = json_array_get(v9, v20);
      v16[1] = json_integer_value((int)v18);
      ++v16;
    }
    goto LABEL_11;
  }
  if ( !strncasecmp(v15, "mining.notify", 13u) )
  {
    valid = (int)parse_notify((int)a1, v9);
    if ( valid )
    {
      *((_BYTE *)a1 + 643) = 1;
      goto LABEL_11;
    }
LABEL_51:
    *((_BYTE *)a1 + 643) = valid;
    goto LABEL_11;
  }
  if ( !strncasecmp(v15, "mining.set_version_mask", 23u) )
  {
    v25 = json_array_get(v9, 0);
    valid = 1;
    v26 = (char *)json_string_value(v25);
    process_version_mask((int)a1, v26);
    goto LABEL_51;
  }
  if ( !strncasecmp(v15, "mining.set_difficulty", 21u) )
  {
    LODWORD(v27) = json_array_get(v9, 0);
    json_number_value(v27);
    if ( v3 == 0.0 )
      goto LABEL_20;
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      mutex_lock_part_1_constprop_16("parse_diff", 2197);
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v41 = _errno_location();
      snprintf(s, 2048u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v41, "util.c", "parse_diff", 2197);
      applog(3, s, 1);
      quit(1);
    }
    v28 = *((double *)a1 + 227);
    if ( v28 <= 0.0 )
    {
      v28 = *((double *)a1 + 228);
      *((double *)a1 + 228) = v3;
    }
    *((double *)a1 + 227) = v3;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v43 = _errno_location();
      snprintf(s, 2048u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v43, "util.c", "parse_diff", 2210);
      applog(3, s, 1);
      quit(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
    {
      v42 = _errno_location();
      snprintf(s, 2048u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v42, "util.c", "parse_diff", 2210);
      applog(3, s, 1);
      quit(1);
    }
    selective_yield(0);
    if ( v3 == v28 )
    {
      valid = (unsigned __int8)opt_debug;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(s, 2048u, "Pool %d difficulty set to %f", *a1, v3);
        applog(7, s, 0);
        goto LABEL_11;
      }
    }
    else if ( v3 == (double)(int)v3 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        v46 = (int)v3;
        v29 = "Pool %d difficulty changed to %d";
        v30 = *a1;
LABEL_65:
        valid = 1;
        snprintf(s, 2048u, v29, v30, v46);
        applog(5, s, 0);
        goto LABEL_11;
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(s, 2048u, "Pool %d difficulty changed to %.1f", *a1, v3);
      valid = 1;
      applog(5, s, 0);
      goto LABEL_11;
    }
LABEL_92:
    valid = 1;
    goto LABEL_11;
  }
  if ( !strncasecmp(v15, "mining.set_extranonce", 21u) )
  {
    v31 = json_array_string(v9, 0);
    valid = valid_hex_constprop_10(v31, (int)"parse_extranonce", 2241);
    if ( valid )
    {
      v36 = json_array_get(v9, 1u);
      v47 = json_integer_value((int)v36);
      if ( v47 )
      {
        if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
          mutex_lock_part_1_constprop_16("parse_extranonce", 2253);
        if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
        {
          v45 = _errno_location();
          snprintf(
            s,
            2048u,
            "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            *v45,
            "util.c",
            "parse_extranonce",
            2253);
          applog(3, s, 1);
          quit(1);
        }
        free((void *)a1[153]);
        a1[153] = v31;
        v37 = strlen(v31) >> 1;
        v38 = (void *)a1[154];
        a1[391] = v37;
        free(v38);
        v39 = cgcalloc(a1[391], 1u, "util.c", "parse_extranonce", 2258);
        a1[154] = v39;
        if ( !v39 )
        {
          snprintf(s, 2048u, "Failed to calloc pool->nonce1bin in %s %s():%d", "util.c", "parse_extranonce", 2260);
          applog(3, s, 1);
          quit(1);
        }
        hex2bin((_BYTE *)a1[154], (unsigned __int8 *)a1[153], a1[391]);
        a1[158] = v47;
        if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        {
          v44 = _errno_location();
          snprintf(
            s,
            2048u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v44,
            "util.c",
            "parse_extranonce",
            2263);
          applog(3, s, 1);
          quit(1);
        }
        v40 = mutex_unlock_noyield_constprop_15((pthread_mutex_t *)(a1 + 53), "parse_extranonce", 2263);
        selective_yield(v40);
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(s, 2048u, "Pool %d extranonce change requested", *a1);
          applog(5, s, 0);
        }
        opt_work_update = 1;
      }
      else
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          strcpy(s, "Failed to get valid n2size in parse_extranonce");
          applog(6, s, 0);
        }
        valid = 0;
        free(v31);
      }
      goto LABEL_11;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy(s, "Failed to get valid nonce1 in parse_extranonce");
      applog(6, s, 0);
      goto LABEL_11;
    }
    goto LABEL_20;
  }
  if ( !strncasecmp(v15, "client.reconnect", 16u) )
  {
    valid = parse_reconnect(a1, v9);
    goto LABEL_11;
  }
  if ( strncasecmp(v15, "client.get_version", 18u) )
  {
    if ( strncasecmp(v15, "client.show_message", 19u) )
    {
      if ( !strncasecmp(v15, "mining.ping", 11u) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf(s, 2048u, "Pool %d ping", *a1);
          applog(6, s, 0);
        }
        v21 = json_object_get(v6, "id");
        if ( !v21 )
          goto LABEL_46;
        v22 = json_object_get(v6, "id");
        v23 = json_integer_value(v22);
        sprintf(s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v23);
LABEL_45:
        v24 = strlen(s);
        v21 = stratum_send((int)a1, s, v24);
LABEL_46:
        valid = v21;
        goto LABEL_11;
      }
      goto LABEL_20;
    }
    if ( !v9 )
      goto LABEL_20;
    if ( *v9 != 1 )
      goto LABEL_20;
    v34 = json_array_get(v9, 0);
    v35 = json_string_value(v34);
    if ( !v35 )
      goto LABEL_20;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      v29 = "Pool %d message: %s";
      v46 = (int)v35;
      v30 = *a1;
      goto LABEL_65;
    }
    goto LABEL_92;
  }
  if ( json_object_get(v6, "id") )
  {
    v32 = json_object_get(v6, "id");
    v33 = json_integer_value(v32);
    sprintf(s, "{\"id\": %d, \"result\": \"bmminer/2.0.0\", \"error\": null}", v33);
    goto LABEL_45;
  }
LABEL_20:
  valid = 0;
LABEL_11:
  v11 = v6[1];
  if ( v11 != -1 )
  {
    v12 = v11 - 1;
    v6[1] = v12;
    if ( !v12 )
      json_delete(v6);
  }
  return valid;
}
// 4A390: variable 'valid' is possibly undefined
// 4A606: variable 'v27' is possibly undefined
// 4A616: variable 'v3' is possibly undefined
// 805A8: using guessed type int opt_log_level;
// 806D4: using guessed type int (__fastcall *selective_yield)(_DWORD);
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 80EF00: using guessed type char opt_work_update;
// 4A2C8: using guessed type int var_2134[23];
// 4A2C8: using guessed type char var_20D8[160];

//----- (0004AB7C) --------------------------------------------------------
int __fastcall subscribe_extranonce(_DWORD *a1)
{
  int v1; // r2
  int v3; // r0
  int v4; // r4
  char *v5; // r0
  _DWORD *v7; // r6
  _DWORD *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r4
  const char *v11; // r7
  const char *v12; // r4
  char *v13; // r0
  int v14; // r3
  int v15; // r3
  char *v16; // r0
  char v17[252]; // [sp+Ch] [bp-2914h] BYREF
  char v18[2048]; // [sp+108h] [bp-2818h] BYREF
  char s[8216]; // [sp+908h] [bp-2018h] BYREF

  v1 = swork_id++;
  sprintf(s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v1);
  v3 = strlen(s);
  v4 = stratum_send((int)a1, s, v3);
  if ( !v4 )
    return v4;
  while ( 1 )
  {
    if ( !socket_full_isra_2(a1[147], 2) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(v18, "Timed out waiting for response extranonce.subscribe");
        applog(7, v18, 0);
      }
      return 1;
    }
    v5 = recv_line((int)a1);
    v4 = (int)v5;
    if ( !v5 )
      return v4;
    if ( !parse_method(a1, (int)v5) )
      break;
    free((void *)v4);
  }
  v7 = (_DWORD *)json_loads(v4, 0, (int)v17);
  free((void *)v4);
  v8 = (_DWORD *)json_object_get(v7, "result");
  v9 = (_DWORD *)json_object_get(v7, "error");
  v10 = v9;
  if ( !v8 || *v8 == 6 )
  {
    if ( !v9 )
    {
      v16 = (char *)malloc(17u);
      v12 = v16;
      if ( v16 )
        strcpy(v16, "(unknown reason)");
      goto LABEL_21;
    }
  }
  else if ( !v9 || *v9 == 7 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v4 = 1;
      snprintf(v18, 2048u, "Stratum extranonce subscribe for pool %d", *a1);
      applog(6, v18, 0);
      goto LABEL_26;
    }
LABEL_33:
    v4 = 1;
    goto LABEL_26;
  }
  v11 = (const char *)_json_array_string(v9, 1u);
  if ( (v11 || (v11 = (const char *)json_string_value(v10)) != 0)
    && (!strcmp(v11, "Method 'subscribe' not found for service 'mining.extranonce'")
     || !strcmp(v11, "Unrecognized request provided")) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v4 = 1;
      snprintf(v18, 2048u, "Cannot subscribe to mining.extranonce for pool %d", *a1);
      applog(6, v18, 0);
      goto LABEL_26;
    }
    goto LABEL_33;
  }
  v12 = (const char *)json_dumps(v10, 3);
LABEL_21:
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(v18, 2048u, "Pool %d JSON extranonce subscribe failed: %s", *a1, v12);
    applog(6, v18, 0);
  }
  v13 = (char *)v12;
  v4 = 0;
  free(v13);
LABEL_26:
  if ( v7 )
  {
    v14 = v7[1];
    if ( v14 != -1 )
    {
      v15 = v14 - 1;
      v7[1] = v15;
      if ( !v15 )
      {
        json_delete(v7);
        return v4;
      }
    }
  }
  return v4;
}
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CBA8: using guessed type int swork_id;
// 80CC18: using guessed type char use_syslog;
// 4AB7C: using guessed type char var_2914[252];

//----- (0004AE1C) --------------------------------------------------------
int __fastcall auth_stratum(_DWORD *a1)
{
  const char *v1; // r3
  int v3; // r2
  int v4; // r0
  char *v5; // r0
  char *v6; // r4
  int v7; // r4
  _DWORD *v9; // r7
  _DWORD *v10; // r4
  _DWORD *v11; // r0
  const char *v12; // r4
  char *v13; // r0
  int v14; // r3
  int v15; // r3
  char *v16; // r0
  int v17; // r3
  int v18; // r2
  int v19; // r0
  int v20; // r2
  int v21; // r0
  const char *v22; // [sp+0h] [bp-2920h]
  char v23[252]; // [sp+Ch] [bp-2914h] BYREF
  char v24[2048]; // [sp+108h] [bp-2818h] BYREF
  char s[8216]; // [sp+908h] [bp-2018h] BYREF

  v1 = (const char *)a1[43];
  v3 = swork_id;
  v22 = (const char *)a1[44];
  ++swork_id;
  sprintf(s, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v3, v1, v22);
  v4 = strlen(s);
  if ( stratum_send((int)a1, s, v4) )
  {
    while ( 1 )
    {
      v5 = recv_line((int)a1);
      v6 = v5;
      if ( !v5 )
        return 0;
      if ( !parse_method(a1, v5) )
        break;
      free(v6);
    }
    v9 = (_DWORD *)json_loads((int)v6, 0, (int)v23);
    free(v6);
    v10 = (_DWORD *)json_object_get(v9, "result");
    v11 = (_DWORD *)json_object_get(v9, "error");
    if ( !v10 || *v10 == 6 )
    {
      if ( !v11 )
      {
        v16 = (char *)malloc(17u);
        v12 = v16;
        if ( v16 )
          strcpy(v16, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v11 || *v11 == 7 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(v24, 2048u, "Stratum authorisation success for pool %d", *a1);
        applog(6, v24, 0);
      }
      v17 = opt_suggest_diff;
      successful_connect = 1;
      *((_BYTE *)a1 + 99) = 1;
      if ( v17 )
      {
        v20 = swork_id++;
        sprintf(s, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v20, v17);
        v21 = strlen(s);
        stratum_send((int)a1, s, v21);
      }
      if ( opt_bitmain_ab )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy(v24, "LOW POWER MODE!");
          applog(5, v24, 0);
        }
        v18 = swork_id;
        v7 = 1;
        ++swork_id;
        sprintf(
          s,
          "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%08"
          "x\",\"version-rolling.min-bit-count\":%d}]}",
          v18,
          12582912,
          2);
        v19 = strlen(s);
        stratum_send((int)a1, s, v19);
        a1[162] = 1;
      }
      else
      {
        v7 = 1;
      }
      goto LABEL_18;
    }
    v12 = (const char *)json_dumps(v11, 3);
LABEL_13:
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(v24, 2048u, "pool %d JSON stratum auth failed: %s", *a1, v12);
      applog(6, v24, 0);
    }
    v13 = (char *)v12;
    v7 = 0;
    free(v13);
    suspend_stratum((int)a1);
LABEL_18:
    if ( v9 )
    {
      v14 = v9[1];
      if ( v14 != -1 )
      {
        v15 = v14 - 1;
        v9[1] = v15;
        if ( !v15 )
          json_delete(v9);
      }
    }
    return v7;
  }
  return 0;
}
// 4A2C8: using guessed type int __fastcall parse_method(_DWORD, _DWORD);
// 7DFA0: using guessed type char opt_bitmain_ab;
// 805A8: using guessed type int opt_log_level;
// 80B6C8: using guessed type char opt_log_output;
// 80B6F8: using guessed type char successful_connect;
// 80BB9C: using guessed type int opt_suggest_diff;
// 80CBA8: using guessed type int swork_id;
// 80CC18: using guessed type char use_syslog;
// 4AE1C: using guessed type char var_2914[252];

//----- (0004B08C) --------------------------------------------------------
int __fastcall cg_timeval_subtract(_DWORD *a1, int *a2, int *a3)
{
  int v3; // r5
  bool v4; // zf
  int v5; // r1
  int v6; // r3
  int v7; // r3
  int v8; // r4

  v3 = *a2;
  v4 = *a2 == *a3;
  if ( *a2 > *a3 )
    return -1;
  v5 = a2[1];
  v6 = a3[1];
  if ( v4 && v5 > v6 )
    return -1;
  v7 = v6 - v5;
  v8 = *a3 - v3;
  *a1 = v8;
  a1[1] = v7;
  if ( v7 < 0 )
  {
    *a1 = v8 - 1;
    a1[1] = v7 + 1000000;
  }
  return 0;
}

//----- (0004B0CC) --------------------------------------------------------
char *__fastcall rev(char *result, int a2)
{
  unsigned int v2; // r2
  char *v3; // r1
  char *v4; // r3
  char v5; // r5

  v2 = a2 - 1;
  if ( a2 != 1 )
  {
    v3 = &result[a2];
    v4 = result;
    do
    {
      --v2;
      v5 = *v4;
      *v4++ = *(v3 - 1);
      *--v3 = v5;
    }
    while ( v2 > v4 - result );
  }
  return result;
}

//----- (0004B0F0) --------------------------------------------------------
int __fastcall check_asicnum(int a1, char a2)
{
  unsigned int v2; // r1
  unsigned int v4; // r1
  int v5; // r1
  unsigned int v6; // r1
  unsigned int v7; // r1

  switch ( a1 )
  {
    case 1:
      return 1;
    case 2:
      if ( (a2 & 0x80) == 128 )
        return 2;
      else
        return 1;
    case 4:
      v5 = a2 & 0xC0;
      switch ( v5 )
      {
        case 128:
          return 3;
        case 192:
          return 4;
        case 64:
          return 2;
        default:
          return 1;
      }
    case 8:
      v6 = a2 & 0xE0;
      if ( v6 == 128 )
        return 5;
      if ( v6 <= 128 )
      {
        if ( v6 == 64 )
          return 3;
        if ( v6 == 96 )
          return 4;
        if ( v6 != 32 )
          return 1;
        return 2;
      }
      if ( v6 == 192 )
        return 7;
      if ( v6 == 224 )
        return 8;
      if ( v6 != 160 )
        return 1;
      return 6;
    case 16:
      v2 = a2 & 0xF0;
      if ( v2 == 128 )
        return 9;
      if ( v2 > 128 )
      {
        if ( v2 == 192 )
        {
          return 13;
        }
        else if ( v2 <= 192 )
        {
          switch ( v2 )
          {
            case 160u:
              return 11;
            case 176u:
              return 12;
            case 144u:
              return 10;
            default:
              return 1;
          }
        }
        else
        {
          switch ( v2 )
          {
            case 224u:
              return 15;
            case 240u:
              return 16;
            case 208u:
              return 14;
            default:
              return 1;
          }
        }
      }
      else if ( v2 == 64 )
      {
        return 5;
      }
      else if ( v2 > 64 )
      {
        switch ( v2 )
        {
          case '`':
            return 7;
          case 'p':
            return 8;
          case 'P':
            return 6;
          default:
            return 1;
        }
      }
      else
      {
        switch ( v2 )
        {
          case 32u:
            return 3;
          case 48u:
            return 4;
          case 16u:
            return 2;
          default:
            return 1;
        }
      }
    case 32:
      v7 = (unsigned __int8)((a2 & 0xF8) - 8);
      if ( v7 > 240 )
        return 1;
      return *((char *)&hex2bin_tbl + v7 + 1992);
    case 64:
      v4 = (unsigned __int8)((a2 & 0xFC) - 4);
      if ( v4 > 248 )
        return 1;
      return *((char *)&hex2bin_tbl + v4 + 2236);
    default:
      return 0;
  }
}

//----- (0004B244) --------------------------------------------------------
void __fastcall cg_logwork(int a1, unsigned __int8 *a2, int a3)
{
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _BYTE *v12; // lr
  _DWORD *v13; // r7
  int v14; // r1
  int v15; // r2
  int v16; // r1
  int v17; // r3
  int v18; // r2
  int v19; // r1
  int v20; // r2
  int v21; // r3
  char v22; // r3
  _DWORD *v23; // r3
  _BYTE *v24; // r2
  char v25; // r1
  _DWORD *v26; // r3
  _BYTE *v27; // r2
  char v28; // r1
  char *v29; // r7
  char *v30; // r8
  _BYTE *v31; // r10
  char *v32; // r9
  unsigned __int64 v33; // r0
  char *v34; // r2
  size_t v35; // r0
  unsigned __int64 v36; // r2
  int i; // r4
  size_t v38; // r0
  size_t v39; // r0
  int v40; // r4
  size_t v41; // r0
  size_t v42; // r0
  int v43; // [sp+14h] [bp-CACh]
  _BYTE *ptr; // [sp+24h] [bp-C9Ch]
  char *v45; // [sp+28h] [bp-C98h]
  unsigned __int64 v46; // [sp+2Ch] [bp-C94h]
  _DWORD v47[4]; // [sp+38h] [bp-C88h] BYREF
  _DWORD v48[3]; // [sp+48h] [bp-C78h] BYREF
  int v49; // [sp+54h] [bp-C6Ch] BYREF
  _DWORD v50[8]; // [sp+58h] [bp-C68h] BYREF
  _DWORD v51[4]; // [sp+78h] [bp-C48h] BYREF
  _DWORD v52[3]; // [sp+88h] [bp-C38h] BYREF
  int v53; // [sp+94h] [bp-C2Ch] BYREF
  char s[1024]; // [sp+98h] [bp-C28h] BYREF
  char v55[2088]; // [sp+498h] [bp-828h] BYREF

  if ( opt_logwork_path )
  {
    memset(s, 0, sizeof(s));
    memset(v50, 0, sizeof(v50));
    v6 = *(_DWORD *)(a1 + 132);
    v7 = *(_DWORD *)(a1 + 136);
    v8 = *(_DWORD *)(a1 + 140);
    v47[0] = *(_DWORD *)(a1 + 128);
    v47[1] = v6;
    v47[2] = v7;
    v47[3] = v8;
    v9 = *(_DWORD *)(a1 + 148);
    v10 = *(_DWORD *)(a1 + 152);
    v11 = *(_DWORD *)(a1 + 156);
    v12 = (char *)&v49 + 3;
    v48[0] = *(_DWORD *)(a1 + 144);
    v48[1] = v9;
    v48[2] = v10;
    v49 = v11;
    v13 = v47;
    v14 = *(_DWORD *)(a1 + 68);
    v15 = *(_DWORD *)(a1 + 72);
    v50[0] = *(_DWORD *)(a1 + 64);
    v50[1] = v14;
    v50[2] = v15;
    v16 = *(_DWORD *)(a1 + 196);
    v17 = *(_DWORD *)(a1 + 204);
    v18 = *(_DWORD *)(a1 + 200);
    v51[0] = *(_DWORD *)(a1 + 192);
    v51[1] = v16;
    v51[2] = v18;
    v51[3] = v17;
    v19 = *(_DWORD *)(a1 + 212);
    v20 = *(_DWORD *)(a1 + 216);
    v21 = *(_DWORD *)(a1 + 220);
    v52[0] = *(_DWORD *)(a1 + 208);
    v52[1] = v19;
    v52[2] = v20;
    v53 = v21;
    do
    {
      v22 = *(_BYTE *)v13;
      *(_BYTE *)v13 = *v12;
      v13 = (_DWORD *)((char *)v13 + 1);
      *v12-- = v22;
    }
    while ( v48 != v13 );
    v23 = v50;
    v24 = (char *)&v50[2] + 3;
    do
    {
      v25 = *(_BYTE *)v23;
      *(_BYTE *)v23 = *v24;
      v23 = (_DWORD *)((char *)v23 + 1);
      *v24-- = v25;
    }
    while ( (_DWORD *)((char *)&v50[1] + 2) != v23 );
    v26 = v51;
    v27 = (char *)&v53 + 3;
    do
    {
      v28 = *(_BYTE *)v26;
      *(_BYTE *)v26 = *v27;
      v26 = (_DWORD *)((char *)v26 + 1);
      *v27-- = v28;
    }
    while ( v52 != v26 );
    ptr = bin2hex((unsigned __int8 *)a1, 128);
    v29 = bin2hex((unsigned __int8 *)v47, 32);
    v30 = bin2hex((unsigned __int8 *)v50, 12);
    v45 = bin2hex(a2, 4);
    v31 = bin2hex(a2, 5);
    v32 = bin2hex((unsigned __int8 *)v51, 32);
    v33 = share_ndiff((unsigned __int64 *)a1);
    v46 = v33;
    v34 = "x";
    if ( a3 )
      v34 = "o";
    sprintf(
      s,
      "%s %08x midstate %s data %s nonce %s hash %s diff %I64d",
      v34,
      *(_DWORD *)(a1 + 340),
      v29,
      v30,
      v31,
      v32,
      v33);
    if ( !strcmp((const char *)opt_logwork_path, "screen") )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v55, 2048u, s);
        applog(3, v55, 0);
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(v55, 2048u, s);
        applog(3, v55, 0);
      }
      if ( g_logwork_file )
      {
        if ( a3 )
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %I64d",
            "o",
            *(_DWORD *)(a1 + 340),
            ptr,
            v29,
            v30,
            v31,
            v32,
            v43,
            v46);
          v35 = strlen(s);
          fwrite(s, v35, 1u, (FILE *)g_logwork_file);
          fwrite("\n", 1u, 1u, (FILE *)g_logwork_file);
          fflush((FILE *)g_logwork_file);
          if ( g_logwork_asicnum == 1 )
          {
            sprintf(s, "midstate %s data %s nonce %s hash %s", v29, v30, v45, v32);
            v42 = strlen(s);
            fwrite(s, v42, 1u, (FILE *)g_logwork_files[0]);
            fwrite("\n", 1u, 1u, (FILE *)g_logwork_files[0]);
            fflush((FILE *)g_logwork_files[0]);
          }
          else if ( ((g_logwork_asicnum - 32) & 0xFFFFFFDF) == 0 )
          {
            sprintf(s, "midstate %s data %s nonce %s hash %s", v29, v30, v45, v32);
            v40 = check_asicnum(g_logwork_asicnum, *a2);
            v41 = strlen(s);
            fwrite(s, v41, 1u, (FILE *)g_logwork_files[v40]);
            fwrite("\n", 1u, 1u, (FILE *)g_logwork_files[v40]);
            fflush((FILE *)g_logwork_files[v40]);
          }
          if ( opt_logwork_diff )
          {
            v36 = v46;
            for ( i = 0; i != 64; ++i )
            {
              v36 >>= 1;
              if ( !v36 )
                break;
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(v55, 2048u, "work diff %I64d diffnum %d");
              applog(7, v55, 0);
            }
            sprintf(s, "midstate %s data %s nonce %s hash %s", v29, v30, v45, v32);
            v38 = strlen(s);
            fwrite(s, v38, 1u, (FILE *)g_logwork_diffs[i]);
            fwrite("\n", 1u, 1u, (FILE *)g_logwork_diffs[i]);
            fflush((FILE *)g_logwork_diffs[i]);
          }
        }
        else
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %I64d",
            "x",
            *(_DWORD *)(a1 + 340),
            ptr,
            v29,
            v30,
            v31,
            v32,
            v43,
            v46);
          v39 = strlen(s);
          fwrite(s, v39, 1u, (FILE *)g_logwork_file);
          fwrite("\n", 1u, 1u, (FILE *)g_logwork_file);
          fflush((FILE *)g_logwork_file);
        }
      }
    }
    if ( ptr )
      free(ptr);
    if ( v29 )
      free(v29);
    if ( v30 )
      free(v30);
    if ( v45 )
      free(v45);
    if ( v31 )
      free(v31);
    if ( v32 )
      free(v32);
  }
}
// 4B4C4: variable 'v43' is possibly undefined
// 805A8: using guessed type int opt_log_level;
// 80B58: using guessed type int opt_logwork_path;
// 828C4: using guessed type int g_logwork_asicnum;
// 828C8: using guessed type int g_logwork_file;
// 828CC: using guessed type int g_logwork_files[];
// 829D0: using guessed type char opt_logwork_diff;
// 829D4: using guessed type int g_logwork_diffs[65];
// 80B6C8: using guessed type char opt_log_output;
// 80B6C9: using guessed type char opt_debug;
// 80CC18: using guessed type char use_syslog;
// 4B244: using guessed type _DWORD var_C78[3];
// 4B244: using guessed type _DWORD var_C38[3];

//----- (0004B70C) --------------------------------------------------------
void __fastcall cg_logwork_uint32(int a1, int a2, int a3)
{
  int v3; // [sp+0h] [bp-10h] BYREF
  char v4; // [sp+4h] [bp-Ch]

  if ( opt_logwork_path )
  {
    v3 = a2;
    v4 = 0;
    cg_logwork(a1, (unsigned __int8 *)&v3, a3);
  }
}
// 80B58: using guessed type int opt_logwork_path;

//----- (0004B738) --------------------------------------------------------
int __fastcall conv_voltage(int result)
{
  if ( result != 1 && result && result != 2 )
    return puts("Convertion type incorrect... Doing no conversion");
  return result;
}

//----- (0004B7C0) --------------------------------------------------------
int __fastcall conv_voltage_ext_ch(int result)
{
  if ( result != 1 && result && result != 2 )
    return puts("Convertion type incorrect... Doing no conversion");
  return result;
}

//----- (0004B818) --------------------------------------------------------
int __fastcall conv_temperature(int result)
{
  if ( result != 1 && result && result != 2 )
    return puts("Conversion type incorrect... Doing no conversion");
  return result;
}

//----- (0004B8A0) --------------------------------------------------------
int __fastcall get_iio_node(int a1, int a2)
{
  int v2; // r3
  __off_t v3; // r4
  int v4; // r5
  char *v5; // r6
  __off_t v6; // r1
  __off_t v8; // r4
  char *v9; // r6
  __off_t v10; // r1
  char v11; // [sp+3h] [bp-35h] BYREF
  char v12[52]; // [sp+4h] [bp-34h] BYREF

  v2 = *(_DWORD *)(a1 + 4 * a2);
  v3 = 0;
  v11 = 0;
  sprintf(gNodeName, "%s/%s", "/sys/bus/iio/devices/iio:device0", (const char *)(v2 + 11));
  v4 = open(gNodeName, 2);
  if ( strstr(gNodeName, "temp") )
  {
    if ( !strstr(gNodeName, "raw") )
      return close(v4);
    v5 = v12;
    do
    {
      v6 = v3++;
      lseek(v4, v6, 0);
      read(v4, &v11, 1u);
      *v5++ = v11;
    }
    while ( v3 != 5 );
    goto LABEL_5;
  }
  if ( strstr(gNodeName, "voltage") && strstr(gNodeName, "raw") )
  {
    v8 = 0;
    v9 = v12;
    do
    {
      v10 = v8++;
      lseek(v4, v10, 0);
      read(v4, &v11, 1u);
      *v9++ = v11;
    }
    while ( v8 != 5 );
LABEL_5:
    v12[5] = 0;
    strtol(v12, 0, 10);
  }
  return close(v4);
}

//----- (0004BA4C) --------------------------------------------------------
int __fastcall write_log_file(const char *a1, const char *a2)
{
  FILE *v3; // r4
  char v5[272]; // [sp+0h] [bp-110h] BYREF

  sprintf(v5, "%s/%s", "/config", a1);
  v3 = fopen(v5, "w+");
  fputs(a2, v3);
  return fclose(v3);
}

//----- (0004BA8C) --------------------------------------------------------
int __fastcall check_voltage(int result, int a2)
{
  float v2; // s0
  float v3; // s1
  int v4; // r5
  double v6; // d7
  FILE *v7; // r0
  FILE *v8; // r6
  char s[224]; // [sp+20h] [bp-E0h] BYREF

  v4 = result;
  if ( (unsigned int)log_level > 7 )
  {
    v7 = fopen(log_file, "a+");
    v8 = v7;
    if ( v7 )
      fprintf(v7, "%s:%d:%s: true_data = %f, i = %d, rule = %f\n", "xadc.c", 164, "check_voltage", v2, a2, v3);
    result = fclose(v8);
  }
  if ( v2 > (float)(v3 * 1.05) )
  {
    v6 = (float)(v3 * 1.05);
  }
  else
  {
    if ( v2 >= (float)(v3 * 0.95) )
      return result;
    v6 = (float)(v3 * 0.95);
  }
  sprintf(s, "WARNING : %s is %f mv, rule is %f\n", (const char *)(*(_DWORD *)(v4 + 4 * a2) + 11), v2, v6);
  return write_log_file((const char *)(*(_DWORD *)(v4 + 4 * a2) + 11), s);
}
// 4BABE: variable 'v2' is possibly undefined
// 4BAB2: variable 'v3' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;

//----- (0004BB74) --------------------------------------------------------
int __fastcall process_true_data(int result, int a2)
{
  float v2; // s0
  int v3; // r5
  const char *v5; // r2
  FILE *v6; // r0
  FILE *v7; // r6
  char s[232]; // [sp+18h] [bp-E8h] BYREF

  v3 = result;
  if ( (unsigned int)log_level > 7 )
  {
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(v6, "%s:%d:%s: true_data = %f, i = %d\n", "xadc.c", 183, "process_true_data", v2, a2);
    result = fclose(v7);
  }
  switch ( a2 )
  {
    case 5:
      if ( v2 > 85.0 )
      {
        sprintf(s, "WARNING : %s is %f cent\n", (const char *)(*(_DWORD *)(v3 + 20) + 11), v2);
        result = write_log_file((const char *)(*(_DWORD *)(v3 + 20) + 11), s);
      }
      if ( first_time_6468 )
      {
        v5 = (const char *)(*(_DWORD *)(v3 + 20) + 11);
        first_time_6468 = 0;
        sprintf(s, "XADC checking when system bring up : %s is %f cent\n", v5, v2);
        result = write_log_file("xadc_test", s);
      }
      break;
    default:
      result = check_voltage(v3, a2);
      break;
  }
  return result;
}
// 4BBD0: variable 'v2' is possibly undefined
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 807D8: using guessed type char first_time_6468;

//----- (0004BCA8) --------------------------------------------------------
int __fastcall get_work_nonce2_part_1(_DWORD *a1)
{
  FILE *v2; // r0
  FILE *v3; // r5

  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: WORK_NONCE_2 buf[0]: 0x%x, buf[1]: 0x%x\n", "znyq7010.c", 710, "get_work_nonce2", *a1, a1[1]);
  return j_fclose(v3);
}
// 805A4: using guessed type char *log_file;

//----- (0004BD00) --------------------------------------------------------
int __fastcall read_fpga_id(char *a1)
{
  return j_sprintf(a1, "%08x%08x", *(_DWORD *)(axi_fpga_addr + 244), *(_DWORD *)(axi_fpga_addr + 240));
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BD20) --------------------------------------------------------
int get_iic()
{
  return *(_DWORD *)(axi_fpga_addr + 48);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BD30) --------------------------------------------------------
int __fastcall set_iic(int a1)
{
  int v1; // r4
  int v2; // r5
  FILE *v4; // r0
  FILE *v5; // r4

  v1 = 3000;
  *(_DWORD *)(axi_fpga_addr + 48) = a1 & 0x7FFFFFFF;
  while ( 1 )
  {
    usleep(1000u);
    v2 = *(_DWORD *)(axi_fpga_addr + 48);
    if ( v2 < 0 )
      break;
    if ( !--v1 )
    {
      if ( (unsigned int)log_level > 1 )
      {
        v4 = fopen(log_file, "a+");
        v5 = v4;
        if ( v4 )
          fprintf(v4, "%s:%d:%s: ERROR: set_iic timeout \n", "znyq7010.c", 111, "set_iic");
        fclose(v5);
      }
      return (unsigned __int8)v2;
    }
  }
  return (unsigned __int8)v2;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BDB4) --------------------------------------------------------
int get_nonce2_and_job_id_store_address()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 272);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 272);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(
      v2,
      "%s:%d:%s: nonce2_and_job_id_store_address is 0x%x\n",
      "znyq7010.c",
      126,
      "get_nonce2_and_job_id_store_address",
      v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BE20) --------------------------------------------------------
int __fastcall set_nonce2_and_job_id_store_address(int a1)
{
  bool v2; // cc
  FILE *v3; // r0
  FILE *v4; // r5

  get_nonce2_and_job_id_store_address();
  v2 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 272) = a1;
  if ( v2 )
  {
    v3 = fopen(log_file, "a+");
    v4 = v3;
    if ( v3 )
      fprintf(
        v3,
        "%s:%d:%s: set NONCE2_AND_JOBID_STORE_ADDRESS is 0x%x\n",
        "znyq7010.c",
        134,
        "set_nonce2_and_job_id_store_address",
        a1);
    fclose(v4);
  }
  return get_nonce2_and_job_id_store_address();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BE9C) --------------------------------------------------------
int get_job_start_address()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 280);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 280);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: JOB_START_ADDRESS is 0x%x\n", "znyq7010.c", 142, "get_job_start_address", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BF08) --------------------------------------------------------
int __fastcall set_job_start_address(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 280) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set JOB_START_ADDRESS is 0x%x\n", "znyq7010.c", 149, "set_job_start_address", a1);
    fclose(v5);
  }
  return get_job_start_address();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BF78) --------------------------------------------------------
int __fastcall set_bmc_counter(int result)
{
  *(_DWORD *)(axi_fpga_addr + 56) = result;
  return result;
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BF88) --------------------------------------------------------
int read_bmc_counter()
{
  return *(_DWORD *)(axi_fpga_addr + 56);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004BF98) --------------------------------------------------------
int get_QN_write_data_command()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 128);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 128);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: QN_WRITE_DATA_COMMAND is 0x%x\n", "znyq7010.c", 169, "get_QN_write_data_command", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C004) --------------------------------------------------------
int __fastcall set_QN_write_data_command(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 128) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set QN_WRITE_DATA_COMMAND is 0x%x\n", "znyq7010.c", 176, "set_QN_write_data_command", a1);
    fclose(v5);
  }
  return get_QN_write_data_command();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C074) --------------------------------------------------------
int __fastcall set_reset_hashboard(char a1, int a2)
{
  int result; // r0
  int v3; // r5
  int v4; // r5
  FILE *v5; // r0
  FILE *v6; // r6

  result = 1 << a1;
  v3 = *(_DWORD *)(axi_fpga_addr + 52);
  if ( a2 <= 0 )
    v4 = v3 & ~result;
  else
    v4 = v3 | result;
  if ( (unsigned int)log_level > 5 )
  {
    v5 = fopen(log_file, "a+");
    v6 = v5;
    if ( v5 )
      fprintf(v5, "%s:%d:%s: set_reset_hashboard = 0x%08x\n", "znyq7010.c", 192, "set_reset_hashboard", v4);
    result = fclose(v6);
    *(_DWORD *)(axi_fpga_addr + 52) = v4;
  }
  else
  {
    *(_DWORD *)(axi_fpga_addr + 52) = v4;
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C0F0) --------------------------------------------------------
int __fastcall set_reset_allhashboard(int result)
{
  unsigned int v1; // r4
  unsigned int v2; // r4
  int v3; // r4
  FILE *v4; // r0
  FILE *v5; // r6

  v1 = *(_DWORD *)(axi_fpga_addr + 52);
  if ( result <= 0 )
    v2 = HIWORD(v1);
  else
    v2 = ~HIWORD(v1);
  if ( result <= 0 )
    v3 = v2 << 16;
  else
    v3 = ~(v2 << 16);
  if ( (unsigned int)log_level > 5 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set_reset_allhashboard = 0x%08x\n", "znyq7010.c", 206, "set_reset_allhashboard", v3);
    result = fclose(v5);
    *(_DWORD *)(axi_fpga_addr + 52) = v3;
  }
  else
  {
    *(_DWORD *)(axi_fpga_addr + 52) = v3;
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C16C) --------------------------------------------------------
int __fastcall znyq7010_axi_init(_DWORD *a1)
{
  int v2; // r0
  int v3; // r0
  void *v4; // r0
  int result; // r0
  FILE *v6; // r0
  FILE *v7; // r8
  unsigned int v8; // r3
  int v9; // r8
  FILE *v10; // r0
  FILE *v11; // r10
  FILE *v12; // r0
  FILE *v13; // r6
  FILE *v14; // r0
  FILE *v15; // r8
  FILE *v16; // r0
  FILE *v17; // r8
  FILE *v18; // r0
  FILE *v19; // r5
  FILE *v20; // r0
  FILE *v21; // r5
  FILE *v22; // r0
  FILE *v23; // r0
  FILE *v24; // r5
  FILE *v25; // r0
  FILE *v26; // r4

  v2 = open("/dev/axi_fpga_dev", 2);
  fd = v2;
  if ( v2 < 0 )
  {
    if ( (unsigned int)log_level > 1 )
    {
      v23 = fopen(log_file, "a+");
      v24 = v23;
      if ( v23 )
        fprintf(v23, "%s:%d:%s: /dev/axi_fpga_dev open failed. fd = %d\n", "znyq7010.c", 218, "znyq7010_axi_init", fd);
      fclose(v24);
    }
    goto LABEL_41;
  }
  axi_fpga_addr = (int)mmap(0, 352u, 3, 1, v2, 0);
  if ( !axi_fpga_addr )
  {
    if ( (unsigned int)log_level <= 1 )
      return -1;
    v20 = fopen(log_file, "a+");
    v21 = v20;
    if ( v20 )
      fprintf(
        v20,
        "%s:%d:%s: mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n",
        "znyq7010.c",
        226,
        "znyq7010_axi_init",
        axi_fpga_addr);
LABEL_32:
    fclose(v21);
    return -1;
  }
  if ( (unsigned int)log_level > 5 )
  {
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(v6, "%s:%d:%s: mmap axi_fpga_addr = 0x%x\n", "znyq7010.c", 229, "znyq7010_axi_init", axi_fpga_addr);
    fclose(v7);
    v8 = log_level;
    v9 = *(_DWORD *)axi_fpga_addr;
    if ( (unsigned __int16)*(_DWORD *)axi_fpga_addr != 50433 )
    {
      if ( (unsigned int)log_level <= 5 )
        goto LABEL_4;
      v10 = fopen(log_file, "a+");
      v11 = v10;
      if ( v10 )
        fprintf(
          v10,
          "%s:%d:%s: data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n",
          "znyq7010.c",
          235,
          "znyq7010_axi_init",
          v9,
          50433);
      fclose(v11);
      v8 = log_level;
    }
    if ( v8 > 5 )
    {
      v12 = fopen(log_file, "a+");
      v13 = v12;
      if ( v12 )
        fprintf(v12, "%s:%d:%s: axi_fpga_addr data = 0x%x\n", "znyq7010.c", 238, "znyq7010_axi_init", v9);
      fclose(v13);
    }
  }
LABEL_4:
  v3 = open("/dev/fpga_mem", 2);
  fd_fpga_mem = v3;
  if ( v3 < 0 )
  {
    if ( (unsigned int)log_level > 5 )
    {
      v25 = fopen(log_file, "a+");
      v26 = v25;
      if ( v25 )
        fprintf(
          v25,
          "%s:%d:%s: /dev/fpga_mem open failed. fd_fpga_mem = %d\n",
          "znyq7010.c",
          243,
          "znyq7010_axi_init",
          fd_fpga_mem);
      fclose(v26);
    }
LABEL_41:
    perror("open");
    return -1;
  }
  v4 = mmap(0, 16777216u, 3, 1, v3, 0);
  fpga_mem_addr = (int)v4;
  if ( !v4 )
  {
    if ( (unsigned int)log_level <= 5 )
      return -1;
    v22 = fopen(log_file, "a+");
    v21 = v22;
    if ( v22 )
      fprintf(
        v22,
        "%s:%d:%s: mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n",
        "znyq7010.c",
        251,
        "znyq7010_axi_init",
        fpga_mem_addr);
    goto LABEL_32;
  }
  if ( (unsigned int)log_level > 5 )
  {
    v14 = fopen(log_file, "a+");
    v15 = v14;
    if ( v14 )
      fprintf(v14, "%s:%d:%s: mmap fpga_mem_addr = 0x%x\n", "znyq7010.c", 254, "znyq7010_axi_init", fpga_mem_addr);
    fclose(v15);
    nonce2_jobid_address = fpga_mem_addr;
    job_start_address_1 = fpga_mem_addr + 2097152;
    job_start_address_2 = fpga_mem_addr + 2162688;
    if ( (unsigned int)log_level > 5 )
    {
      v16 = fopen(log_file, "a+");
      v17 = v16;
      if ( v16 )
        fprintf(
          v16,
          "%s:%d:%s: job_start_address_1 = 0x%x\n",
          "znyq7010.c",
          260,
          "znyq7010_axi_init",
          job_start_address_1);
      fclose(v17);
      if ( (unsigned int)log_level > 5 )
      {
        v18 = fopen(log_file, "a+");
        v19 = v18;
        if ( v18 )
          fprintf(
            v18,
            "%s:%d:%s: job_start_address_2 = 0x%x\n",
            "znyq7010.c",
            261,
            "znyq7010_axi_init",
            job_start_address_2);
        fclose(v19);
      }
    }
  }
  else
  {
    nonce2_jobid_address = (int)v4;
    job_start_address_1 = (int)v4 + 2097152;
    job_start_address_2 = (int)v4 + 2162688;
  }
  set_nonce2_and_job_id_store_address(1056964608);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  result = 0;
  *a1 = job_start_address_1;
  return result;
}
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;
// 80B800: using guessed type int fpga_mem_addr;
// 80B804: using guessed type int nonce2_jobid_address;
// 80B808: using guessed type int job_start_address_1;
// 80B80C: using guessed type int job_start_address_2;
// 80EF68: using guessed type int fd;
// 80EF6C: using guessed type int fd_fpga_mem;

//----- (0004C524) --------------------------------------------------------
int znyq7010_axi_Reinit()
{
  int v0; // r6
  FILE *v2; // r0
  FILE *v3; // r8
  FILE *v4; // r0
  FILE *v5; // r5

  v0 = *(_DWORD *)axi_fpga_addr;
  if ( (unsigned __int16)*(_DWORD *)axi_fpga_addr != 50433 )
  {
    if ( (unsigned int)log_level <= 5 )
      goto LABEL_3;
    v2 = fopen(log_file, "a+");
    v3 = v2;
    if ( v2 )
      fprintf(
        v2,
        "%s:%d:%s: data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n",
        "znyq7010.c",
        279,
        "znyq7010_axi_Reinit",
        v0,
        50433);
    fclose(v3);
  }
  if ( (unsigned int)log_level > 5 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: axi_fpga_addr data = 0x%x\n", "znyq7010.c", 282, "znyq7010_axi_Reinit", v0);
    fclose(v5);
  }
LABEL_3:
  nonce2_jobid_address = fpga_mem_addr;
  job_start_address_1 = fpga_mem_addr + 2097152;
  job_start_address_2 = fpga_mem_addr + 2162688;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2097152);
  return 0;
}
// 7E580: using guessed type int PHY_MEM_NONCE2_JOBID_ADDRESS;
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;
// 80B800: using guessed type int fpga_mem_addr;
// 80B804: using guessed type int nonce2_jobid_address;
// 80B808: using guessed type int job_start_address_1;
// 80B80C: using guessed type int job_start_address_2;

//----- (0004C608) --------------------------------------------------------
int znyq7010_axi_close()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5
  FILE *v4; // r0
  FILE *v5; // r5

  if ( munmap((void *)axi_fpga_addr, 352u) < 0 && (unsigned int)log_level > 5 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: munmap failed!\n", "znyq7010.c", 301, "znyq7010_axi_close");
    fclose(v5);
  }
  v0 = munmap((void *)fpga_mem_addr, 16777216u);
  if ( v0 < 0 && (unsigned int)log_level > 5 )
  {
    v2 = fopen(log_file, "a+");
    v3 = v2;
    if ( v2 )
      fprintf(v2, "%s:%d:%s: munmap failed!\n", "znyq7010.c", 307, "znyq7010_axi_close");
    fclose(v3);
  }
  close(fd);
  close(fd_fpga_mem);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;
// 80B800: using guessed type int fpga_mem_addr;
// 80EF68: using guessed type int fd;
// 80EF6C: using guessed type int fd_fpga_mem;

//----- (0004C6F0) --------------------------------------------------------
int get_fan_control()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 132);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 132);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: FAN_CONTROL is 0x%x\n", "znyq7010.c", 324, "get_fan_control", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C760) --------------------------------------------------------
int __fastcall set_fan_control(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 132) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set FAN_CONTROL is 0x%x\n", "znyq7010.c", 331, "set_fan_control", a1);
    fclose(v5);
  }
  return get_fan_control();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C7D4) --------------------------------------------------------
int get_hash_on_plug()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 8);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 8);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: HASH_ON_PLUG is 0x%x\n", "znyq7010.c", 340, "get_hash_on_plug", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C840) --------------------------------------------------------
int get_crc_count()
{
  return *(unsigned __int16 *)(axi_fpga_addr + 248);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C850) --------------------------------------------------------
int __fastcall reset_crc_count(int result)
{
  if ( result )
    *(_DWORD *)(axi_fpga_addr + 248) = -2147483648;
  else
    *(_DWORD *)(axi_fpga_addr + 248) = 0;
  return result;
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C874) --------------------------------------------------------
int get_hardware_version()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)axi_fpga_addr;
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)axi_fpga_addr;
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: HARDWARE_VERSION is 0x%x\n", "znyq7010.c", 363, "get_hardware_version", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C8E0) --------------------------------------------------------
int __fastcall set_Hardware_version(int result)
{
  *(_DWORD *)axi_fpga_addr = result;
  return result;
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C8F0) --------------------------------------------------------
int __fastcall get_fan_speed(unsigned __int8 *a1, _DWORD *a2)
{
  int v2; // r4
  FILE *v6; // r0
  FILE *v7; // r7

  v2 = *(_DWORD *)(axi_fpga_addr + 4);
  *a2 = (unsigned __int8)v2;
  *a1 = BYTE1(v2) & 7;
  if ( !*a2 || (unsigned int)log_level <= 5 )
    return v2;
  v6 = fopen(log_file, "a+");
  v7 = v6;
  if ( v6 )
    fprintf(v6, "%s:%d:%s: fan_id is 0x%x, fan_speed is 0x%x\n", "znyq7010.c", 380, "get_fan_speed", *a1, *a2);
  fclose(v7);
  return v2;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C978) --------------------------------------------------------
int get_temperature_0_3()
{
  return *(_DWORD *)(axi_fpga_addr + 32);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C988) --------------------------------------------------------
int get_temperature_4_7()
{
  return *(_DWORD *)(axi_fpga_addr + 36);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C998) --------------------------------------------------------
int get_temperature_8_11()
{
  return *(_DWORD *)(axi_fpga_addr + 40);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C9A8) --------------------------------------------------------
int get_temperature_12_15()
{
  return *(_DWORD *)(axi_fpga_addr + 44);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004C9B8) --------------------------------------------------------
int get_time_out_control()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 136);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 136);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: TIME_OUT_CONTROL is 0x%x\n", "znyq7010.c", 421, "get_time_out_control", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CA28) --------------------------------------------------------
int __fastcall set_time_out_control(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 136) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set FAN_CONTROL is 0x%x\n", "znyq7010.c", 428, "set_time_out_control", a1);
    fclose(v5);
  }
  return get_time_out_control();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CA9C) --------------------------------------------------------
int __fastcall get_BC_command_buffer(_DWORD *a1)
{
  int v1; // r3
  unsigned int v2; // r2
  int v3; // r5
  FILE *v6; // r0
  FILE *v7; // r6

  v1 = axi_fpga_addr;
  *a1 = *(_DWORD *)(axi_fpga_addr + 196);
  v2 = log_level;
  a1[1] = *(_DWORD *)(v1 + 200);
  v3 = *(_DWORD *)(v1 + 204);
  a1[2] = v3;
  if ( v2 <= 7 )
    return v3;
  v6 = fopen(log_file, "a+");
  v7 = v6;
  if ( v6 )
    fprintf(
      v6,
      "%s:%d:%s: BC_COMMAND_BUFFER buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x\n",
      "znyq7010.c",
      441,
      "get_BC_command_buffer",
      *a1,
      a1[1],
      a1[2]);
  fclose(v7);
  return v3;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CB24) --------------------------------------------------------
int __fastcall set_BC_command_buffer(_DWORD *a1)
{
  int v2; // r2
  unsigned int v3; // r1
  int v4; // r0
  int v5; // r0
  FILE *v7; // r0
  FILE *v8; // r5
  int v9[10]; // [sp+10h] [bp-28h] BYREF

  v2 = axi_fpga_addr;
  v3 = log_level;
  *(_DWORD *)(axi_fpga_addr + 196) = *a1;
  v4 = a1[1];
  v9[1] = 0;
  v9[0] = 0;
  *(_DWORD *)(v2 + 200) = v4;
  v5 = a1[2];
  v9[2] = 0;
  v9[3] = 0;
  *(_DWORD *)(v2 + 204) = v5;
  if ( v3 <= 7 )
    return get_BC_command_buffer(v9);
  v7 = fopen(log_file, "a+");
  v8 = v7;
  if ( v7 )
    fprintf(
      v7,
      "%s:%d:%s: set BC_COMMAND_BUFFER value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x\n",
      "znyq7010.c",
      451,
      "set_BC_command_buffer",
      *a1,
      a1[1],
      a1[2]);
  fclose(v8);
  return get_BC_command_buffer(v9);
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CBC0) --------------------------------------------------------
int get_nonce_number_in_fifo()
{
  return *(_DWORD *)(axi_fpga_addr + 24);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CBD0) --------------------------------------------------------
int __fastcall get_return_nonce(_DWORD *a1)
{
  int v1; // r3
  int v2; // r3

  v1 = axi_fpga_addr;
  *a1 = *(_DWORD *)(axi_fpga_addr + 16);
  v2 = *(_DWORD *)(v1 + 20);
  a1[1] = v2;
  return v2;
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CBE8) --------------------------------------------------------
int get_BC_write_command()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 192);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 192);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: BC_WRITE_COMMAND is 0x%x\n", "znyq7010.c", 478, "get_BC_write_command", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CC58) --------------------------------------------------------
int __fastcall set_BC_write_command(int a1)
{
  int result; // r0
  int v2; // r4
  bool v3; // nf
  FILE *v4; // r0
  FILE *v5; // r4

  *(_DWORD *)(axi_fpga_addr + 192) = a1;
  if ( a1 >= 0 )
    return get_BC_write_command();
  v2 = 3001;
  while ( 1 )
  {
    v3 = get_BC_write_command() < 0;
    result = 1000;
    if ( !v3 )
      break;
    result = usleep(1000u);
    if ( !--v2 )
    {
      if ( (unsigned int)log_level > 5 )
      {
        v4 = fopen(log_file, "a+");
        v5 = v4;
        if ( v4 )
          fprintf(
            v4,
            "%s:%d:%s: Error: set_BC_write_command wait buffer ready timeout!\n",
            "znyq7010.c",
            497,
            "set_BC_write_command");
        return j_fclose(v5);
      }
      return result;
    }
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CCE4) --------------------------------------------------------
int get_ticket_mask()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 140);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 140);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: TICKET_MASK_FPGA is 0x%x\n", "znyq7010.c", 513, "get_ticket_mask", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CD54) --------------------------------------------------------
int __fastcall set_ticket_mask(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 140) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set TICKET_MASK_FPGA is 0x%x\n", "znyq7010.c", 520, "set_ticket_mask", a1);
    fclose(v5);
  }
  return get_ticket_mask();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CDC8) --------------------------------------------------------
int get_job_id()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 292);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 292);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: JOB_ID is 0x%x\n", "znyq7010.c", 528, "get_job_id", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CE38) --------------------------------------------------------
int __fastcall set_job_id(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 292) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set JOB_ID is 0x%x\n", "znyq7010.c", 535, "set_job_id", a1);
    fclose(v5);
  }
  return get_job_id();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CEAC) --------------------------------------------------------
int get_job_length()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 284);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 284);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: JOB_LENGTH is 0x%x\n", "znyq7010.c", 543, "get_job_length", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CF1C) --------------------------------------------------------
int __fastcall set_job_length(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 284) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set JOB_LENGTH is 0x%x\n", "znyq7010.c", 550, "set_job_length", a1);
    fclose(v5);
  }
  return get_job_id();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004CF90) --------------------------------------------------------
int get_block_header_version()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 304);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 304);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: BLOCK_HEADER_VERSION is 0x%x\n", "znyq7010.c", 559, "get_block_header_version", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D000) --------------------------------------------------------
int __fastcall set_block_header_version(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 304) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set BLOCK_HEADER_VERSION is 0x%x\n", "znyq7010.c", 566, "set_block_header_version", a1);
    fclose(v5);
  }
  return get_block_header_version();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D074) --------------------------------------------------------
int get_block_header_version0_ab()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 352);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 352);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: BLOCK_VERSION_0 is 0x%x\n", "znyq7010.c", 574, "get_block_header_version0_ab", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D0E4) --------------------------------------------------------
int __fastcall set_block_header_version0_ab(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 352) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set BLOCK_VERSION_0 is 0x%x\n", "znyq7010.c", 581, "set_block_header_version0_ab", a1);
    fclose(v5);
  }
  return get_block_header_version0_ab();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D158) --------------------------------------------------------
int get_block_header_version1_ab()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 356);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 356);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: BLOCK_VERSION_1 is 0x%x\n", "znyq7010.c", 589, "get_block_header_version1_ab", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D1C8) --------------------------------------------------------
int __fastcall set_block_header_version1_ab(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 356) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set BLOCK_VERSION_1 is 0x%x\n", "znyq7010.c", 596, "set_block_header_version1_ab", a1);
    fclose(v5);
  }
  return get_block_header_version1_ab();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D23C) --------------------------------------------------------
int get_block_header_version2_ab()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 360);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 360);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: BLOCK_VERSION_2 is 0x%x\n", "znyq7010.c", 604, "get_block_header_version2_ab", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D2AC) --------------------------------------------------------
int __fastcall set_block_header_version2_ab(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 360) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set BLOCK_VERSION_2 is 0x%x\n", "znyq7010.c", 611, "set_block_header_version2_ab", a1);
    fclose(v5);
  }
  return get_block_header_version2_ab();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D320) --------------------------------------------------------
int get_block_header_version3_ab()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 364);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 364);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: BLOCK_VERSION_3 is 0x%x\n", "znyq7010.c", 619, "get_block_header_version3_ab", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D390) --------------------------------------------------------
int __fastcall set_block_header_version3_ab(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 364) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set BLOCK_VERSION_3 is 0x%x\n", "znyq7010.c", 626, "set_block_header_version3_ab", a1);
    fclose(v5);
  }
  return get_block_header_version3_ab();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D404) --------------------------------------------------------
int get_time_stamp()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 308);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 308);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: TIME_STAMP is 0x%x\n", "znyq7010.c", 634, "get_time_stamp", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D474) --------------------------------------------------------
int __fastcall set_time_stamp(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 308) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set TIME_STAMP is 0x%x\n", "znyq7010.c", 641, "set_time_stamp", a1);
    fclose(v5);
  }
  return get_time_stamp();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D4E8) --------------------------------------------------------
int get_target_bits()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 312);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 312);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: TARGET_BITS is 0x%x\n", "znyq7010.c", 649, "get_target_bits", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D558) --------------------------------------------------------
int __fastcall set_target_bits(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 312) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set TARGET_BITS is 0x%x\n", "znyq7010.c", 656, "set_target_bits", a1);
    fclose(v5);
  }
  return get_target_bits();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D5CC) --------------------------------------------------------
int __fastcall get_pre_header_hash(_DWORD *a1)
{
  _DWORD *v1; // r3
  unsigned int v2; // r2
  int v3; // r3
  FILE *v6; // r0
  FILE *v7; // r5

  v1 = (_DWORD *)axi_fpga_addr;
  *a1 = *(_DWORD *)(axi_fpga_addr + 320);
  v2 = log_level;
  a1[1] = v1[81];
  a1[2] = v1[82];
  a1[3] = v1[83];
  a1[4] = v1[84];
  a1[5] = v1[85];
  a1[6] = v1[86];
  v3 = v1[87];
  a1[7] = v3;
  if ( v2 <= 5 )
    return v3;
  v6 = fopen(log_file, "a+");
  v7 = v6;
  if ( v6 )
    fprintf(
      v6,
      "%s:%d:%s: PRE_HEADER_HASH buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x, buf[3]: 0x%x, buf[4]: 0x%x, buf[5]: 0x%x, buf["
      "6]: 0x%x, buf[7]: 0x%x\n",
      "znyq7010.c",
      671,
      "get_pre_header_hash",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7]);
  fclose(v7);
  return a1[7];
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D690) --------------------------------------------------------
_DWORD *__fastcall set_pre_header_hash(_DWORD *result)
{
  _DWORD *v1; // r3
  unsigned int v2; // r2
  _DWORD *v3; // r4
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (_DWORD *)axi_fpga_addr;
  v2 = log_level;
  *(_DWORD *)(axi_fpga_addr + 320) = *result;
  v1[81] = result[1];
  v1[82] = result[2];
  v1[83] = result[3];
  v1[84] = result[4];
  v1[85] = result[5];
  v1[86] = result[6];
  v1[87] = result[7];
  if ( v2 > 5 )
  {
    v3 = result;
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(
        v4,
        "%s:%d:%s: set PRE_HEADER_HASH value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x, value[3]: 0x%x, value[4]: 0x%x, va"
        "lue[5]: 0x%x, value[6]: 0x%x, value[7]: 0x%x\n",
        "znyq7010.c",
        686,
        "set_pre_header_hash",
        *v3,
        v3[1],
        v3[2],
        v3[3],
        v3[4],
        v3[5],
        v3[6],
        v3[7]);
    return (_DWORD *)j_fclose(v5);
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D74C) --------------------------------------------------------
int get_coinbase_length_and_nonce2_length()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 260);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 260);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(
      v2,
      "%s:%d:%s: COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
      "znyq7010.c",
      694,
      "get_coinbase_length_and_nonce2_length",
      v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D7BC) --------------------------------------------------------
int __fastcall set_coinbase_length_and_nonce2_length(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 260) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(
        v4,
        "%s:%d:%s: set COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
        "znyq7010.c",
        701,
        "set_coinbase_length_and_nonce2_length",
        a1);
    fclose(v5);
  }
  return get_coinbase_length_and_nonce2_length();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D830) --------------------------------------------------------
int __fastcall get_work_nonce2(_DWORD *a1)
{
  int v1; // r2
  bool v2; // cc

  v1 = axi_fpga_addr;
  *a1 = *(_DWORD *)(axi_fpga_addr + 264);
  v2 = (unsigned int)log_level > 5;
  a1[1] = *(_DWORD *)(v1 + 268);
  if ( v2 )
    get_work_nonce2_part_1(a1);
  return -1;
}
// 805A0: using guessed type int log_level;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D860) --------------------------------------------------------
_DWORD *__fastcall set_work_nonce2(_DWORD *result)
{
  int v1; // r6
  int v2; // r3
  unsigned int v3; // r1
  int v4; // r6
  _DWORD *v5; // r6
  FILE *v6; // r0
  FILE *v7; // r7
  int v8; // r3
  int v9; // [sp+10h] [bp-20h] BYREF
  int v10; // [sp+14h] [bp-1Ch]

  v1 = *result;
  v2 = axi_fpga_addr;
  v3 = log_level;
  v10 = 0;
  *(_DWORD *)(axi_fpga_addr + 264) = v1;
  v4 = result[1];
  v9 = 0;
  *(_DWORD *)(v2 + 268) = v4;
  if ( v3 > 5 )
  {
    v5 = result;
    v6 = fopen(log_file, "a+");
    v7 = v6;
    if ( v6 )
      fprintf(
        v6,
        "%s:%d:%s: set WORK_NONCE_2 value[0]: 0x%x, value[1]: 0x%x\n",
        "znyq7010.c",
        719,
        "set_work_nonce2",
        *v5,
        v5[1]);
    result = (_DWORD *)fclose(v7);
    v8 = *(_DWORD *)(axi_fpga_addr + 264);
    v10 = *(_DWORD *)(axi_fpga_addr + 268);
    v9 = v8;
    if ( (unsigned int)log_level > 5 )
      return (_DWORD *)get_work_nonce2_part_1(&v9);
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D8FC) --------------------------------------------------------
int get_merkle_bin_number()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(unsigned __int16 *)(axi_fpga_addr + 276);
  if ( (unsigned int)log_level <= 5 )
    return *(unsigned __int16 *)(axi_fpga_addr + 276);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: MERKLE_BIN_NUMBER is 0x%x\n", "znyq7010.c", 728, "get_merkle_bin_number", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D96C) --------------------------------------------------------
int __fastcall set_merkle_bin_number(unsigned __int16 a1)
{
  int v1; // r4
  bool v2; // cc
  FILE *v3; // r0
  FILE *v4; // r5

  v1 = a1;
  v2 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 276) = a1;
  if ( v2 )
  {
    v3 = fopen(log_file, "a+");
    v4 = v3;
    if ( v3 )
      fprintf(v3, "%s:%d:%s: set MERKLE_BIN_NUMBER is 0x%x\n", "znyq7010.c", 735, "set_merkle_bin_number", v1);
    fclose(v4);
  }
  return get_merkle_bin_number();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004D9E4) --------------------------------------------------------
int get_nonce_fifo_interrupt()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 28);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 28);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: NONCE_FIFO_INTERRUPT is 0x%x\n", "znyq7010.c", 743, "get_nonce_fifo_interrupt", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DA50) --------------------------------------------------------
int __fastcall set_nonce_fifo_interrupt(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 28) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set NONCE_FIFO_INTERRUPT is 0x%x\n", "znyq7010.c", 750, "set_nonce_fifo_interrupt", a1);
    fclose(v5);
  }
  return get_nonce_fifo_interrupt();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DAC0) --------------------------------------------------------
int get_dhash_acc_control()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 256);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 256);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: DHASH_ACC_CONTROL is 0x%x\n", "znyq7010.c", 758, "get_dhash_acc_control", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DB30) --------------------------------------------------------
int __fastcall set_dhash_acc_control(int a1)
{
  bool v2; // cc
  int v3; // r4
  int v4; // r3
  int result; // r0
  FILE *v6; // r0
  FILE *v7; // r4
  FILE *v8; // r0
  FILE *v9; // r4

  v2 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 256) = a1;
  if ( v2 )
  {
    v8 = fopen(log_file, "a+");
    v9 = v8;
    if ( v8 )
      fprintf(v8, "%s:%d:%s: set DHASH_ACC_CONTROL is 0x%x\n", "znyq7010.c", 766, "set_dhash_acc_control", a1);
    fclose(v9);
  }
  v3 = 10;
  while ( 1 )
  {
    v4 = get_dhash_acc_control() | 0x80;
    result = 2000;
    if ( (a1 | 0x80) == v4 )
      break;
    *(_DWORD *)(axi_fpga_addr + 256) = a1;
    result = usleep(2000u);
    if ( !--v3 )
    {
      if ( (unsigned int)log_level > 5 )
      {
        v6 = fopen(log_file, "a+");
        v7 = v6;
        if ( v6 )
          fprintf(v6, "%s:%d:%s: set DHASH_ACC_CONTROL failed!", "znyq7010.c", 776, "set_dhash_acc_control");
        return j_fclose(v7);
      }
      return result;
    }
  }
  return result;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DC10) --------------------------------------------------------
int __fastcall set_TW_write_command(int a1)
{
  int v1; // r3
  int result; // r0
  int v3; // r2
  int v4; // t1

  v1 = a1 - 4;
  result = a1 + 48;
  v3 = axi_fpga_addr + 60;
  do
  {
    v4 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    *(_DWORD *)(v3 + 4) = v4;
    v3 += 4;
  }
  while ( v1 != result );
  return result;
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DC30) --------------------------------------------------------
int __fastcall set_TW_write_command_vil(_DWORD *a1)
{
  int v2; // r0
  int v3; // r2
  int i; // r3

  pthread_mutex_lock(&fpga_mutex);
  v2 = axi_fpga_addr;
  v3 = 1;
  for ( i = 0; !i; ++i )
  {
    *(_DWORD *)(v2 + 64) = *a1;
LABEL_4:
    ++v3;
  }
  *(_DWORD *)(v2 + 68) = a1[i];
  if ( v3 != 13 )
    goto LABEL_4;
  return j_pthread_mutex_unlock(&fpga_mutex);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DC70) --------------------------------------------------------
int get_buffer_space()
{
  return *(_DWORD *)(axi_fpga_addr + 12);
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DC80) --------------------------------------------------------
int get_hash_counting_number()
{
  int v0; // r4
  FILE *v2; // r0
  FILE *v3; // r5

  v0 = *(_DWORD *)(axi_fpga_addr + 144);
  if ( (unsigned int)log_level <= 5 )
    return *(_DWORD *)(axi_fpga_addr + 144);
  v2 = fopen(log_file, "a+");
  v3 = v2;
  if ( v2 )
    fprintf(v2, "%s:%d:%s: DHASH_ACC_CONTROL is 0x%x\n", "znyq7010.c", 816, "get_hash_counting_number", v0);
  fclose(v3);
  return v0;
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DCF0) --------------------------------------------------------
int __fastcall set_hash_counting_number(int a1)
{
  bool v1; // cc
  FILE *v4; // r0
  FILE *v5; // r5

  v1 = (unsigned int)log_level > 5;
  *(_DWORD *)(axi_fpga_addr + 144) = a1;
  if ( v1 )
  {
    v4 = fopen(log_file, "a+");
    v5 = v4;
    if ( v4 )
      fprintf(v4, "%s:%d:%s: set DHASH_ACC_CONTROL is 0x%x\n", "znyq7010.c", 823, "set_hash_counting_number", a1);
    fclose(v5);
  }
  return get_hash_counting_number();
}
// 805A0: using guessed type int log_level;
// 805A4: using guessed type char *log_file;
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DD64) --------------------------------------------------------
int __fastcall T9_plus_write_pic_iic(int a1, int a2, int a3, char a4, unsigned __int8 a5)
{
  int v9; // r0

  while ( *(int *)(axi_fpga_addr + 48) >= 0 )
    usleep(1000u);
  if ( a1 )
    v9 = 33554432;
  else
    v9 = 0;
  if ( a2 )
    v9 |= (a3 << 8) | 0x1000000;
  return set_iic(v9 | a5 | 0x400000 | ((a4 & 0xF) << 16));
}
// 80B7FC: using guessed type int axi_fpga_addr;

//----- (0004DDC0) --------------------------------------------------------
char *__fastcall arg_bad(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v5 + v4);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (0004DDE8) --------------------------------------------------------
int __fastcall opt_set_bool(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0004DDF0) --------------------------------------------------------
int __fastcall opt_set_false(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0004DDF8) --------------------------------------------------------
int __fastcall opt_set_invbool(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0004DE00) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_bool_arg(const unsigned __int8 *a1, _BYTE *a2)
{
  unsigned __int8 *result; // r0

  if ( !strcasecmp((const char *)a1, "yes") || !strcasecmp((const char *)a1, "true") )
  {
    result = 0;
    *a2 = 1;
  }
  else if ( !strcasecmp((const char *)a1, "no") || !strcasecmp((const char *)a1, "false") )
  {
    result = 0;
    *a2 = 0;
  }
  else
  {
    return opt_invalid_argument(a1);
  }
  return result;
}

//----- (0004DE60) --------------------------------------------------------
unsigned __int8 *__fastcall opt_set_invbool_arg(const unsigned __int8 *a1, _BYTE *a2)
{
  unsigned __int8 *result; // r0

  result = opt_set_bool_arg(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (0004DE78) --------------------------------------------------------
int __fastcall opt_set_charp(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (0004DE80) --------------------------------------------------------
char *__fastcall opt_set_floatval(const char *a1, _DWORD *a2)
{
  int v2; // s0
  int *v5; // r5
  _BYTE *v6; // r3
  char *result; // r0
  _BYTE *v8; // [sp+4h] [bp-14h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(a1, &v8);
  v6 = v8;
  *a2 = v2;
  if ( *v6 || !*a1 )
    return arg_bad("'%s' is not a number", a1);
  result = (char *)*v5;
  if ( *v5 )
    return arg_bad("'%s' is out of range", a1);
  return result;
}
// 4DE9C: variable 'v2' is possibly undefined
// 12294: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (0004DED0) --------------------------------------------------------
char *__fastcall opt_set_longval(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-14h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return arg_bad("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return arg_bad("'%s' is out of range", a1);
  return result;
}

//----- (0004DF20) --------------------------------------------------------
char *__fastcall opt_set_intval(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-Ch] BYREF

  result = opt_set_longval(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (0004DF3C) --------------------------------------------------------
char *__fastcall opt_set_uintval(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v5; // [sp+4h] [bp-14h] BYREF

  result = opt_set_longval(a1, &v5);
  if ( !result )
  {
    if ( v5 < 0 )
      return arg_bad("'%s' is negative", a1);
    else
      *a2 = v5;
  }
  return result;
}

//----- (0004DF6C) --------------------------------------------------------
char *__fastcall opt_set_ulongval(const char *a1, _DWORD *a2)
{
  char *result; // r0
  bool v5; // nf
  int v6; // [sp+4h] [bp-14h] BYREF

  result = opt_set_longval(a1, &v6);
  if ( !result )
  {
    v5 = v6 < 0;
    *a2 = v6;
    if ( v5 )
      return arg_bad("'%s' is negative", a1);
  }
  return result;
}

//----- (0004DF9C) --------------------------------------------------------
int __fastcall opt_inc_intval(_DWORD *a1)
{
  int result; // r0

  result = 0;
  ++*a1;
  return result;
}

//----- (0004DFA8) --------------------------------------------------------
void __fastcall __noreturn opt_version_and_exit(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 80B14: using guessed type int stdout;

//----- (0004DFC4) --------------------------------------------------------
unsigned __int8 *__fastcall __noreturn opt_usage_and_exit(const unsigned __int8 *extra)
{
  char *v1; // r0

  v1 = opt_usage((const char *)opt_argv0, (char *)extra);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 80B14: using guessed type int stdout;
// 817D14: using guessed type int opt_argv0;

//----- (0004DFF8) --------------------------------------------------------
char *__fastcall opt_show_bool(char *a1, unsigned __int8 *a2)
{
  int v2; // r4
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( !v2 )
    v3 = "false";
  return j_strncpy(a1, v3, 80u);
}

//----- (0004E01C) --------------------------------------------------------
char *__fastcall opt_show_invbool(char *a1, unsigned __int8 *a2)
{
  int v2; // r4
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( !v2 )
    v3 = "true";
  return j_strncpy(a1, v3, 80u);
}

//----- (0004E040) --------------------------------------------------------
char *__fastcall opt_show_charp(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  size_t v5; // r5
  char *result; // r0
  _BYTE *v7; // r4

  v4 = strlen(*a2);
  *a1 = 34;
  if ( v4 > 78 )
  {
    result = strncpy(a1 + 1, *a2, 78u);
    a1[79] = 34;
  }
  else
  {
    v5 = v4;
    result = strncpy(a1 + 1, *a2, v4);
    v7 = &a1[v5];
    v7[1] = 34;
    if ( v5 != 78 )
      v7[2] = 0;
  }
  return result;
}

//----- (0004E080) --------------------------------------------------------
int __fastcall opt_show_intval(char *a1, _DWORD *a2)
{
  return j_snprintf(a1, 80u, "%i", *a2);
}

//----- (0004E090) --------------------------------------------------------
int __fastcall opt_show_floatval(char *a1, float *a2)
{
  return snprintf(a1, 80u, "%.1f", *a2);
}

//----- (0004E0B4) --------------------------------------------------------
int __fastcall opt_show_uintval(char *a1, _DWORD *a2)
{
  return j_snprintf(a1, 80u, "%u", *a2);
}

//----- (0004E0C4) --------------------------------------------------------
int __fastcall opt_show_longval(char *a1, _DWORD *a2)
{
  return j_snprintf(a1, 80u, "%li", *a2);
}

//----- (0004E0D4) --------------------------------------------------------
int __fastcall opt_show_ulongval(char *a1, _DWORD *a2)
{
  return j_snprintf(a1, 80u, "%lu", *a2);
}

//----- (0004E0E4) --------------------------------------------------------
int __fastcall next_name(int a1, int *a2)
{
  int v2; // r2
  int v3; // r0
  bool v4; // zf
  int v5; // r2
  int v6; // r4
  bool v7; // zf
  int v8; // r3
  int v9; // t1
  int result; // r0

  v2 = *(unsigned __int8 *)(a1 + *a2);
  v3 = a1 + *a2;
  v4 = (v2 & 0xDF) == 0;
  if ( (v2 & 0xDF) != 0 )
    v4 = v2 == 61;
  v5 = v4;
  if ( v4 )
    return 0;
  v6 = v3 + 1;
  while ( 1 )
  {
    v9 = *(unsigned __int8 *)++v6;
    v8 = v9;
    if ( (v9 & 0xDF) == 0 )
      break;
    v7 = v8 == 61;
    if ( v8 != 61 )
      v7 = v8 == 124;
    if ( v7 )
      break;
    ++v5;
  }
  result = v3 + 2;
  *a2 = v5;
  return result;
}

//----- (0004E124) --------------------------------------------------------
int __fastcall first_opt(unsigned int *a1, _DWORD *a2)
{
  int *v2; // r2
  int v3; // r5
  unsigned int v4; // r4
  int v5; // r0
  int v6; // r2
  int v7; // r4
  bool v8; // zf
  int v9; // r3
  int v10; // t1
  int result; // r0

  *a1 = 0;
  if ( !opt_count )
    return 0;
  v2 = (int *)opt_table;
  if ( *(_DWORD *)(opt_table + 4) == 8 )
  {
    v3 = opt_table + 28;
    v4 = 1;
    while ( 1 )
    {
      *a1 = v4;
      v2 = (int *)v3;
      v3 += 28;
      if ( opt_count <= v4++ )
        return 0;
      if ( v2[1] != 8 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    v5 = *v2;
    v6 = 0;
    v7 = v5;
    while ( 1 )
    {
      v10 = *(unsigned __int8 *)++v7;
      v9 = v10;
      if ( (v10 & 0xDF) == 0 )
        break;
      v8 = v9 == 61;
      if ( v9 != 61 )
        v8 = v9 == 124;
      if ( v8 )
        break;
      ++v6;
    }
    result = v5 + 1;
    *a2 = v6;
  }
  return result;
}
// 817D10: using guessed type int opt_table;
// 817D18: using guessed type int opt_count;

//----- (0004E194) --------------------------------------------------------
int __fastcall next_opt(int a1, unsigned int *a2, int *a3)
{
  unsigned int v3; // r3
  int v7; // r0
  int *v8; // r2
  int result; // r0
  int v10; // r5
  int v11; // r2
  bool v12; // zf
  int v13; // r3
  int v14; // t1

  v3 = *a2;
  if ( opt_count <= *a2 )
    return 0;
  while ( 1 )
  {
    v7 = a1;
    v8 = (int *)(opt_table + 28 * v3);
    if ( v8[1] != 8 )
      break;
LABEL_8:
    *a2 = ++v3;
    if ( opt_count <= v3 )
      return 0;
  }
  if ( a1 )
  {
    result = next_name(a1, a3);
    a1 = result;
    if ( result )
      return result;
    v3 = *a2;
    goto LABEL_8;
  }
  v10 = *v8;
  v11 = *v8;
  while ( 1 )
  {
    v14 = *(unsigned __int8 *)++v11;
    v13 = v14;
    if ( (v14 & 0xDF) == 0 )
      break;
    v12 = v13 == 61;
    if ( v13 != 61 )
      v12 = v13 == 124;
    if ( v12 )
      break;
    ++v7;
  }
  *a3 = v7;
  return v10 + 1;
}
// 817D10: using guessed type int opt_table;
// 817D18: using guessed type int opt_count;

//----- (0004E214) --------------------------------------------------------
_BYTE *__fastcall check_opt(const char **a1)
{
  unsigned int v2; // r0
  bool v3; // cc
  int v4; // r3
  const char *v5; // r2
  const char *v6; // r4
  bool v7; // zf
  int v8; // r1
  int v9; // t1
  _BYTE *result; // r0
  const char *v11; // r1
  unsigned int v12; // r2
  const char *v13; // r4
  int v14; // r2
  bool v15; // zf
  int v16; // [sp+Ch] [bp-1Ch] BYREF

  v2 = (unsigned int)a1[1];
  v3 = v2 > 4;
  if ( v2 != 4 )
    v3 = v2 - 1 > 1;
  v4 = v3;
  if ( v3 )
    errx(1, "Option %s: unknown entry type %u", *a1, v2);
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", *a1);
  v5 = *a1;
  if ( **a1 != 45 )
    errx(1, "Option %s: does not begin with '-'", v5);
  v6 = *a1;
  while ( 1 )
  {
    v9 = *(unsigned __int8 *)++v6;
    v8 = v9;
    if ( (v9 & 0xDF) == 0 )
      break;
    v7 = v8 == 61;
    if ( v8 != 61 )
      v7 = v8 == 124;
    if ( v7 )
      break;
    ++v4;
  }
  result = v5 + 1;
  v16 = v4;
  if ( v5 != (const char *)-1 )
  {
    while ( 1 )
    {
      if ( *result == 45 )
      {
        if ( v4 == 1 )
          errx(1, "Option %s: invalid long option '--'", *a1);
        v13 = a1[1];
        ++opt_num_long;
      }
      else
      {
        if ( v4 != 1 )
          errx(1, "Option %s: invalid short option '%.*s'", *a1, v4 + 1, result - 1);
        v11 = a1[1];
        ++opt_num_short;
        v12 = (unsigned int)(v11 - 2) & 0xFFFFFFFD;
        if ( !v12 )
          v12 = opt_num_short_arg;
        v13 = v11;
        if ( ((unsigned int)(v11 - 2) & 0xFFFFFFFD) == 0 )
          opt_num_short_arg = v12 + 1;
      }
      if ( v13 == (const char *)1 )
      {
        v14 = (unsigned __int8)result[v4];
        v15 = v14 == 61;
        if ( v14 != 61 )
          v15 = v14 == 32;
        if ( v15 )
          errx(1, "Option %s: does not take arguments '%s'", *a1, &result[v4 + 1]);
      }
      result = (_BYTE *)next_name((int)result, &v16);
      if ( !result )
        break;
      v4 = v16;
    }
  }
  return result;
}
// 817D04: using guessed type int opt_num_short_arg;
// 817D08: using guessed type int opt_num_long;
// 817D0C: using guessed type int opt_num_short;

//----- (0004E338) --------------------------------------------------------
int __fastcall add_opt(int *a1)
{
  char *v2; // r4
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // lr
  char *v8; // r4
  int result; // r0
  int v10; // r1
  int v11; // r2

  v2 = (char *)realloc((void *)opt_table, 28 * (opt_count + 1));
  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  v6 = a1[3];
  a1 += 4;
  opt_table = (int)v2;
  v7 = 7 * opt_count++;
  v8 = &v2[4 * v7];
  *(_DWORD *)v8 = v3;
  *((_DWORD *)v8 + 1) = v4;
  *((_DWORD *)v8 + 2) = v5;
  *((_DWORD *)v8 + 3) = v6;
  v8 += 16;
  result = *a1;
  v10 = a1[1];
  v11 = a1[2];
  *(_DWORD *)v8 = *a1;
  *((_DWORD *)v8 + 1) = v10;
  *((_DWORD *)v8 + 2) = v11;
  return result;
}
// 817D10: using guessed type int opt_table;
// 817D18: using guessed type int opt_count;

//----- (0004E380) --------------------------------------------------------
_BYTE *__fastcall first_lopt(unsigned int *a1, _DWORD *a2)
{
  _BYTE *opt; // r0
  int *v4; // r1
  int *v5; // r4
  _BYTE *result; // r0

  opt = (_BYTE *)first_opt(a1, a2);
  if ( !opt )
    return 0;
  v5 = v4;
  while ( *opt != 45 )
  {
    opt = (_BYTE *)next_opt((int)opt, a1, v5);
    if ( !opt )
      return 0;
  }
  result = opt + 1;
  --*v5;
  return result;
}
// 4E38A: variable 'v4' is possibly undefined

//----- (0004E3B4) --------------------------------------------------------
_BYTE *__fastcall next_lopt(int a1, unsigned int *a2, int *a3)
{
  _BYTE *opt; // r0
  _BYTE *result; // r0

  opt = (_BYTE *)next_opt(a1, a2, a3);
  if ( !opt )
    return 0;
  while ( *opt != 45 )
  {
    opt = (_BYTE *)next_opt((int)opt, a2, a3);
    if ( !opt )
      return 0;
  }
  result = opt + 1;
  --*a3;
  return result;
}

//----- (0004E3E0) --------------------------------------------------------
_BYTE *__fastcall first_sopt(unsigned int *a1)
{
  _BYTE *result; // r0
  int v3; // [sp+4h] [bp-14h] BYREF

  v3 = 0;
  result = (_BYTE *)first_opt(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (_BYTE *)next_opt((int)result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0004E414) --------------------------------------------------------
_BYTE *__fastcall next_sopt(int a1, unsigned int *a2)
{
  _BYTE *result; // r0
  int v4; // [sp+4h] [bp-14h] BYREF

  v4 = 1;
  result = (_BYTE *)next_opt(a1, a2, &v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (_BYTE *)next_opt((int)result, a2, &v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0004E448) --------------------------------------------------------
int __fastcall opt_register(
        const char *a1,
        const char *a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7)
{
  const char *v8[11]; // [sp+4h] [bp-2Ch] BYREF

  v8[0] = a1;
  v8[1] = a2;
  v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  v8[6] = a7;
  check_opt(v8);
  return add_opt((int *)v8);
}

//----- (0004E470) --------------------------------------------------------
int __fastcall opt_register_table(int result, int a2)
{
  int v2; // r4
  int v4; // r6
  int v5; // r3
  int *v6; // r0
  int v7; // r1
  int v8[13]; // [sp+4h] [bp-34h] BYREF

  v2 = result;
  v4 = opt_count;
  if ( a2 )
  {
    v8[0] = 0;
    memset(&v8[2], 0, 16);
    v8[6] = a2;
    v8[1] = 8;
    add_opt(v8);
    v5 = *(_DWORD *)(v2 + 4);
    if ( v5 != 16 )
      goto LABEL_5;
LABEL_8:
    result = 7 * v4;
    *(_DWORD *)(opt_table + 28 * v4 + 20) = opt_count - v4;
    return result;
  }
  v5 = *(_DWORD *)(result + 4);
  if ( v5 == 16 )
    return result;
  do
  {
LABEL_5:
    while ( v5 != 8 )
    {
      check_opt((const char **)v2);
      v6 = (int *)v2;
      v2 += 28;
      result = add_opt(v6);
      v5 = *(_DWORD *)(v2 + 4);
      if ( v5 == 16 )
        goto LABEL_7;
    }
    v7 = *(_DWORD *)(v2 + 24);
    v2 += 28;
    result = opt_register_table(*(_DWORD *)(v2 - 28), v7);
    v5 = *(_DWORD *)(v2 + 4);
  }
  while ( v5 != 16 );
LABEL_7:
  if ( a2 )
    goto LABEL_8;
  return result;
}
// 817D10: using guessed type int opt_table;
// 817D18: using guessed type int opt_count;

//----- (0004E4F8) --------------------------------------------------------
bool __fastcall opt_parse(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  int v6; // r0
  int v8; // [sp+4h] [bp-1Ch] BYREF

  opt_argv0 = (int)*a2;
  v8 = 0;
  do
    v6 = parse_one(a1, a2, &v8, a3);
  while ( v6 == 1 );
  return v6 == 0;
}
// 817D14: using guessed type int opt_argv0;

//----- (0004E530) --------------------------------------------------------
void opt_free_table()
{
  free((void *)opt_table);
  opt_table = 0;
}
// 817D10: using guessed type int opt_table;

//----- (0004E548) --------------------------------------------------------
void opt_log_stderr(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, fmt);
  vfprintf((FILE *)_bss_start, (const char *)fmt, varg_r1);
  fputc(10, (FILE *)_bss_start);
}
// 80B08: using guessed type int _bss_start;

//----- (0004E578) --------------------------------------------------------
void __noreturn opt_log_stderr_exit(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)_bss_start, a1, varg_r1);
  fputc(10, (FILE *)_bss_start);
  exit(1);
}
// 80B08: using guessed type int _bss_start;

//----- (0004E5A4) --------------------------------------------------------
unsigned __int8 *__fastcall opt_invalid_argument(const unsigned __int8 *arg)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen((const char *)arg);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", (const char *)arg);
  return (unsigned __int8 *)v3;
}

//----- (0004E5C8) --------------------------------------------------------
void *__fastcall consume_option(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(4 * a3 + a2), (const void *)(a2 + 4 * a3 + 4), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (0004E5E8) --------------------------------------------------------
int __fastcall parse_one(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  int result; // r0
  const char **v9; // r5
  int v10; // r4
  int v11; // r7
  const char *v12; // r8
  const char *v13; // r7
  size_t v14; // r4
  size_t v15; // r1
  unsigned int v16; // lr
  const char *v17; // r3
  unsigned int v18; // r0
  int v19; // r12
  int v20; // r1
  char *v21; // r7
  char *v22; // r8
  _BYTE *v23; // r0
  int v24; // r7
  unsigned int v25; // r0
  const char *v26; // r5
  size_t v27; // r0
  int *v28; // r3
  int v29; // t1
  size_t v30; // r7
  const char *v31; // [sp+8h] [bp-38h]
  int v32; // [sp+Ch] [bp-34h]
  unsigned int v33; // [sp+10h] [bp-30h] BYREF
  size_t n[11]; // [sp+14h] [bp-2Ch] BYREF

  if ( getenv("POSIXLY_CORRECT") )
  {
    result = (int)a2[1];
    v9 = a2 + 1;
    if ( result )
    {
      if ( *(_BYTE *)result != 45 )
        return 0;
      v10 = 1;
LABEL_7:
      if ( *(_BYTE *)(result + 1) == 45 )
      {
        v11 = *(unsigned __int8 *)(result + 2);
        if ( !*(_BYTE *)(result + 2) )
        {
          consume_option(a1, (int)a2, v10);
          return v11;
        }
        if ( *a3 )
          _assert_fail("*offset == 0", "ccan/opt/parse.c", 59u, "parse_one");
        v12 = first_lopt(&v33, n);
        if ( v12 )
        {
          v32 = v10;
          do
          {
            v13 = *v9;
            v14 = n[0];
            if ( !strncmp(*v9 + 2, v12, n[0]) )
            {
              v15 = v14 + 2;
              if ( v13[v14 + 2] == 61 )
              {
                v16 = v33;
                v17 = v13;
                v30 = v14;
                v10 = v32;
                v21 = (char *)&v17[v30 + 3];
                v31 = v12 - 2;
                n[0] = v15;
                v18 = opt_table + 28 * v33;
                v19 = *(_DWORD *)(v18 + 4);
                if ( v19 == 1 )
                {
                  if ( v21 )
                  {
                    a4("%s: %.*s: %s", *a2, v15, v31, "doesn't allow an argument");
                    return -1;
                  }
LABEL_36:
                  v21 = 0;
                  v22 = (char *)(*(int (__fastcall **)(_DWORD))(v18 + 8))(*(_DWORD *)(v18 + 20));
LABEL_23:
                  if ( v22 )
                  {
                    a4("%s: %.*s: %s", *a2, n[0], v31, v22);
                    free(v22);
                    return -1;
                  }
                  if ( *a3 )
                  {
                    if ( !(*v9)[*a3 + 1] )
                    {
                      *a3 = 0;
                      goto LABEL_27;
                    }
                  }
                  else
                  {
LABEL_27:
                    consume_option(a1, (int)a2, v10);
                    if ( v21 )
                    {
                      if ( v21 == *v9 )
                        consume_option(a1, (int)a2, v10);
                    }
                  }
                  return 1;
                }
                if ( !v21 )
                {
LABEL_16:
                  v20 = *a3;
                  goto LABEL_17;
                }
LABEL_20:
                if ( v19 == 4 )
                {
                  opt_set_charp((int)v21, *(_DWORD **)(v18 + 20));
                  v16 = v33;
                }
                v22 = (char *)(*(int (__fastcall **)(char *, _DWORD))(opt_table + 28 * v16 + 12))(
                                v21,
                                *(_DWORD *)(opt_table + 28 * v16 + 20));
                goto LABEL_23;
              }
              if ( !v13[v14 + 2] )
              {
                v16 = v33;
                v31 = v12 - 2;
                v17 = v13;
                n[0] = v14 + 2;
                v10 = v32;
                v18 = opt_table + 28 * v33;
                v19 = *(_DWORD *)(v18 + 4);
                if ( v19 == 1 )
                  goto LABEL_36;
                goto LABEL_16;
              }
            }
            v12 = next_lopt((int)v12, &v33, (int *)n);
          }
          while ( v12 );
        }
      }
      else
      {
        v23 = first_sopt(&v33);
        if ( v23 )
        {
          v17 = *v9;
          v20 = *a3 + 1;
          if ( (*v9)[v20] == *v23 )
          {
LABEL_35:
            v16 = v33;
            v24 = opt_table;
            v31 = v23 - 1;
            v25 = 7 * v33;
            n[0] = 2;
            *a3 = v20;
            v18 = v24 + 4 * v25;
            v19 = *(_DWORD *)(v18 + 4);
            if ( v19 == 1 )
              goto LABEL_36;
LABEL_17:
            if ( v20 && (v21 = (char *)&v17[v20 + 1], *v21) )
            {
              *a3 = 0;
            }
            else
            {
              v21 = (char *)a2[v10 + 1];
              if ( !v21 )
              {
                a4("%s: %.*s: %s", *a2, n[0], v31, "requires an argument");
                return -1;
              }
            }
            goto LABEL_20;
          }
          while ( 1 )
          {
            v23 = next_sopt((int)v23, &v33);
            if ( !v23 )
              break;
            v17 = *v9;
            v20 = *a3 + 1;
            if ( (*v9)[v20] == *v23 )
              goto LABEL_35;
          }
        }
      }
      v26 = *v9;
      v27 = strlen(v26);
      a4("%s: %.*s: %s", *a2, v27, v26, "unrecognized option");
      return -1;
    }
  }
  else
  {
    result = (int)a2[1];
    if ( result )
    {
      if ( *(_BYTE *)result == 45 )
      {
        v9 = a2 + 1;
        v10 = 1;
        goto LABEL_7;
      }
      v28 = (int *)(a2 + 2);
      v10 = 1;
      while ( 1 )
      {
        v9 = (const char **)v28;
        v29 = *v28++;
        result = v29;
        ++v10;
        if ( !v29 )
          break;
        if ( *(_BYTE *)result == 45 )
          goto LABEL_7;
      }
    }
  }
  return result;
}
// 817D10: using guessed type int opt_table;

//----- (0004E8F0) --------------------------------------------------------
char *__fastcall opt_usage(const char *a1, char *a2)
{
  size_t v2; // r11
  unsigned int v3; // r8
  size_t v4; // r11
  int v5; // r4
  unsigned int v6; // r9
  const char *v7; // r6
  size_t v8; // r11
  size_t v9; // r0
  size_t v10; // r11
  size_t v11; // r5
  char *v12; // r0
  char *v13; // r4
  int v14; // r0
  char *v15; // r1
  char *v16; // r4
  char *v17; // r5
  char *sopt; // lr
  int v19; // r8
  int v20; // r0
  char *v21; // r5
  int v22; // r3
  int v23; // r6
  unsigned int v24; // r8
  unsigned int v25; // r4
  int v26; // r2
  unsigned int v27; // r4
  unsigned int v28; // r4
  int v29; // r3
  const char *v30; // r2
  char *v32; // r2
  int v33; // r2
  int v34; // r3
  size_t v35; // r5
  char *s; // [sp+4h] [bp-94h]
  char *v38; // [sp+10h] [bp-88h]
  char *v39; // [sp+14h] [bp-84h]
  unsigned int v40[31]; // [sp+1Ch] [bp-7Ch] BYREF

  s = a2;
  if ( a2 )
  {
    v2 = strlen(a1);
    v3 = opt_count;
    v4 = v2 + opt_num_short + 20 + strlen(s);
    if ( !opt_count )
      goto LABEL_12;
    v5 = opt_table;
  }
  else
  {
    v3 = opt_count;
    if ( !opt_count )
    {
      s = "";
      v4 = opt_num_short + 20 + strlen(a1);
      goto LABEL_12;
    }
    v33 = 0;
    v5 = opt_table;
    v34 = opt_table;
    do
    {
      ++v33;
      if ( *(unsigned __int8 *(__fastcall **)(const unsigned __int8 *))(v34 + 8) == opt_usage_and_exit
        && *(_DWORD *)(v34 + 20) )
      {
        s = *(char **)(v34 + 20);
        v35 = strlen(s);
        goto LABEL_45;
      }
      v34 += 28;
    }
    while ( v33 != opt_count );
    v35 = 0;
    s = "";
LABEL_45:
    v4 = v35 + opt_num_short + 20 + strlen(a1);
  }
  v6 = 0;
  do
  {
    while ( 1 )
    {
      v11 = v4 + 6;
      if ( *(_DWORD *)(v5 + 4) != 8 )
        break;
      ++v6;
      v4 += 3 + strlen(*(const char **)(v5 + 24));
      v5 += 28;
      if ( v6 >= v3 )
        goto LABEL_12;
    }
    v7 = *(const char **)(v5 + 24);
    if ( v7 != (const char *)&opt_hidden )
    {
      v8 = strlen(*(const char **)v5);
      v9 = strlen(v7) + v11 + v8;
      v10 = v9 + 118;
      if ( !*(_DWORD *)(v5 + 16) )
        v10 = v9 + 21;
      v4 = v10 + 1;
    }
    ++v6;
    v5 += 28;
  }
  while ( v6 < v3 );
LABEL_12:
  v12 = (char *)malloc(v4);
  v13 = v12;
  v39 = v12;
  if ( v12 )
  {
    v14 = sprintf(v12, "Usage: %s", a1);
    v15 = v13;
    v16 = &v13[v14];
    v17 = v16 + 3;
    *(_DWORD *)&v15[v14] = &unk_2D5B20;
    sopt = first_sopt(v40);
    if ( sopt )
    {
      v19 = 0;
      do
      {
        if ( *(_UNKNOWN **)(opt_table + 28 * v40[0] + 24) != &opt_hidden )
          v17[v19++] = *sopt;
        sopt = next_sopt((int)sopt, v40);
      }
      while ( sopt );
      if ( v19 )
      {
        v16 = &v17[v19 + 1];
        *(_WORD *)&v17[v19] = 93;
      }
    }
    v20 = sprintf(v16, " %s", s);
    v21 = &v16[v20 + 1];
    v22 = opt_count;
    strcpy(&v16[v20], "\n");
    if ( v22 )
    {
      v23 = 0;
      v24 = 0;
      do
      {
        while ( 1 )
        {
          v29 = opt_table + v23;
          v30 = *(const char **)(opt_table + v23 + 24);
          if ( v30 != (const char *)&opt_hidden )
            break;
LABEL_29:
          ++v24;
          v23 += 28;
          if ( opt_count <= v24 )
            goto LABEL_33;
        }
        if ( *(_DWORD *)(v29 + 4) != 8 )
        {
          v25 = sprintf(v21, "%s", *(const char **)v29);
          if ( *(_DWORD *)(opt_table + v23 + 4) == 2 )
          {
            v38 = *(char **)(opt_table + v23);
            if ( !strchr(v38, 32) && !strchr(v38, 61) )
            {
              v32 = &v21[v25];
              *(_DWORD *)&v21[v25] = *(_DWORD *)" <arg>";
              v25 += 6;
              strcpy(v32 + 4, "g>");
            }
          }
          if ( v25 > 19 )
            v26 = 1;
          else
            v26 = 20 - v25;
          v27 = v25 + sprintf(&v21[v25], "%.*s", v26, "                    ");
          v28 = v27 + sprintf(&v21[v27], "%s", *(const char **)(opt_table + v23 + 24));
          if ( *(_DWORD *)(opt_table + v23 + 16) )
          {
            v40[20] = (unsigned int)&unk_2E2E2E;
            (*(void (__fastcall **)(unsigned int *, _DWORD))(opt_table + v23 + 16))(
              v40,
              *(_DWORD *)(opt_table + v23 + 20));
            v28 += sprintf(&v21[v28], " (default: %s)", (const char *)v40);
          }
          strcpy(&v21[v28], "\n");
          v21 += v28 + 1;
          goto LABEL_29;
        }
        ++v24;
        v21 += sprintf(v21, "%s:\n", v30);
        v23 += 28;
      }
      while ( opt_count > v24 );
    }
LABEL_33:
    *v21 = 0;
  }
  return v39;
}
// 5E060: using guessed type __int16 word_5E060;
// 817D0C: using guessed type int opt_num_short;
// 817D10: using guessed type int opt_table;
// 817D18: using guessed type int opt_count;

//----- (0004EC28) --------------------------------------------------------
int __fastcall dump_to_strbuffer(void *src, size_t n, const void **a3)
{
  return strbuffer_append_bytes(a3, src, n);
}

//----- (0004EC34) --------------------------------------------------------
size_t __fastcall dump_to_file(const void *a1, size_t a2, FILE *s)
{
  size_t result; // r0

  result = fwrite(a1, a2, 1u, s) - 1;
  if ( result )
    return -1;
  return result;
}

//----- (0004EC4C) --------------------------------------------------------
int __fastcall compare_keys(const char **a1, const char **a2)
{
  return j_strcmp(*a1, *a2);
}

//----- (0004EC54) --------------------------------------------------------
int __fastcall dump_string(char *a1, int a2, int (__fastcall *a3)(char *, int, int), int a4, unsigned int a5)
{
  unsigned int v9; // r8
  char *i; // r11
  char *v12; // r5
  bool v13; // zf
  int v14; // r1
  char *v15; // r0
  int v16; // r1
  unsigned int v17; // r3
  int v18; // [sp+0h] [bp-48h]
  int v19; // [sp+Ch] [bp-3Ch] BYREF
  char s[56]; // [sp+10h] [bp-38h] BYREF

  if ( a3("\"", 1, a4) )
    return -1;
  v9 = (unsigned int)&a1[a2];
  for ( i = a1; (unsigned int)i < v9; i = v12 )
  {
    v12 = utf8_iterate(i, v9 - (_DWORD)i, &v19);
    if ( !v12 )
      return -1;
    v13 = v19 == 34;
    if ( v19 != 34 )
      v13 = v19 == 92;
    v14 = v13;
    if ( v19 <= 31 )
      v14 |= 1u;
    if ( !v14 && ((v19 == 47) & (a5 >> 10)) == 0 && ((v19 > 127) & (a5 >> 6)) == 0 )
      continue;
    if ( a1 != i && a3(a1, i - a1, a4) )
      return -1;
    if ( i == v12 )
      return a3("\"", 1, a4);
    if ( v19 == 12 )
    {
      v16 = 2;
      v15 = "\\f";
      goto LABEL_27;
    }
    if ( v19 <= 12 )
    {
      switch ( v19 )
      {
        case 9:
          v15 = "\\t";
          v16 = 2;
          goto LABEL_27;
        case 10:
          v15 = "\\n";
          v16 = 2;
          goto LABEL_27;
        case 8:
          v15 = "\\b";
          v16 = 2;
          goto LABEL_27;
      }
LABEL_33:
      if ( v19 >= 65536 )
      {
        v17 = ((unsigned int)(v19 - 65536) >> 10) & 0x3FF | 0xD800;
        v18 = (v19 - 65536) & 0x3FF | 0xDC00;
        v19 -= 65536;
        snprintf(s, 13u, "\\u%04X\\u%04X", v17, v18);
        v15 = s;
        v16 = 12;
        goto LABEL_27;
      }
LABEL_34:
      snprintf(s, 13u, "\\u%04X", v19);
      v15 = s;
      v16 = 6;
      goto LABEL_27;
    }
    if ( v19 == 34 )
    {
      v15 = "\\\"";
      v16 = 2;
      goto LABEL_27;
    }
    if ( v19 <= 34 )
    {
      if ( v19 == 13 )
      {
        v15 = "\\r";
        v16 = 2;
        goto LABEL_27;
      }
      goto LABEL_34;
    }
    if ( v19 == 47 )
    {
      v15 = "\\/";
      v16 = 2;
      goto LABEL_27;
    }
    if ( v19 != 92 )
      goto LABEL_33;
    v15 = "\\\\";
    v16 = 2;
LABEL_27:
    if ( a3(v15, v16, a4) )
      return -1;
    a1 = v12;
  }
  if ( a1 == i || !a3(a1, i - a1, a4) )
    return a3("\"", 1, a4);
  return -1;
}
// 4ED68: conditional instruction was optimized away because %var_3C.4 is in (E..21)

//----- (0004EDF8) --------------------------------------------------------
int __fastcall dump_indent(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  unsigned int v7; // r4
  int v8; // r5

  if ( (a1 & 0x1F) != 0 )
  {
    v7 = (a1 & 0x1F) * a2;
    if ( !a4("\n", 1, a5) )
    {
      if ( !v7 )
        return 0;
      while ( 1 )
      {
        v8 = v7;
        if ( v7 >= 32 )
          v8 = 32;
        if ( a4("                                ", v8, a5) )
          break;
        v7 -= v8;
        if ( !v7 )
          return 0;
      }
    }
    return -1;
  }
  else
  {
    if ( !a3 || (a1 & 0x20) != 0 )
      return 0;
    return a4(" ", 1, a5);
  }
}

//----- (0004EE68) --------------------------------------------------------
int __fastcall do_dump(_DWORD *a1, unsigned int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  _DWORD *v6; // r5
  int result; // r0
  int v9; // r0
  int v10; // r1
  bool v11; // zf
  char *v12; // r3
  int v13; // r1
  int v14; // r7
  int v15; // r10
  _DWORD *v16; // r9
  int v17; // r5
  char *v18; // r8
  int v19; // r0
  int v20; // r0
  _DWORD *v21; // r9
  int v22; // r8
  unsigned int v23; // r7
  _DWORD *v24; // r0
  char *v25; // r7
  _DWORD *v26; // r0
  __int64 v27; // r0
  unsigned int v28; // r0
  int v29; // r1
  int v30; // r0
  int v31; // r8
  int v32; // r9
  unsigned int v33; // r7
  int v34; // r9
  char *v35; // r5
  char *v36; // t1
  int v37; // r8
  int v38; // r0
  char *v40; // [sp+10h] [bp-B0h]
  int v41; // [sp+14h] [bp-ACh]
  size_t nmemb; // [sp+18h] [bp-A8h]
  _DWORD *v43; // [sp+1Ch] [bp-A4h]
  void *base; // [sp+28h] [bp-98h]
  int v45; // [sp+2Ch] [bp-94h]
  char s[140]; // [sp+34h] [bp-8Ch] BYREF

  if ( !a1 )
    return -1;
  v6 = a1;
  switch ( *a1 )
  {
    case 0:
      v9 = a1[9];
      v10 = a2 & 0x20;
      v11 = v10 == 0;
      v12 = ":";
      if ( v10 )
        v13 = 1;
      else
        v13 = 2;
      if ( v11 )
        v12 = ": ";
      v41 = v13;
      v40 = v12;
      if ( v9 )
        goto LABEL_21;
      v6[9] = 1;
      v14 = json_object_iter(v6);
      if ( a4("{", 1, a5) )
        goto LABEL_21;
      if ( !v14 )
        goto LABEL_42;
      v15 = a3 + 1;
      if ( dump_indent(a2, a3 + 1, 0, a4, a5) )
        goto LABEL_21;
      if ( (a2 & 0x80) == 0 )
      {
        v16 = v6;
        while ( 1 )
        {
          v17 = json_object_iter_next(v16, v14);
          v18 = (char *)json_object_iter_key(v14);
          v19 = strlen(v18);
          dump_string(v18, v19, (int (__fastcall *)(char *, int, int))a4, a5, a2);
          if ( a4(v40, v41, a5) )
            break;
          v20 = json_object_iter_value(v14);
          if ( do_dump(v20, a2, v15, a4, a5) )
            break;
          if ( !v17 )
          {
            v6 = v16;
            if ( !dump_indent(a2, a3, 0, a4, a5) )
              goto LABEL_42;
LABEL_21:
            result = -1;
            v6[9] = 0;
            return result;
          }
          if ( !a4(",", 1, a5) )
          {
            v14 = v17;
            if ( !dump_indent(a2, v15, 1, a4, a5) )
              continue;
          }
          break;
        }
        v6 = v16;
        goto LABEL_21;
      }
      nmemb = (size_t)json_object_size(v6);
      v30 = jsonp_malloc(4 * nmemb);
      base = (void *)v30;
      if ( !v30 )
        goto LABEL_21;
      v45 = v30 - 4;
      v31 = v30 - 4;
      v32 = 0;
      do
      {
        ++v32;
        *(_DWORD *)(v31 + 4) = json_object_iter_key(v14);
        v31 += 4;
        v14 = json_object_iter_next(v6, v14);
      }
      while ( v14 );
      if ( nmemb != v32 )
        _assert_fail("i == size", "compat/jansson-2.9/src/dump.c", 338u, "do_dump");
      qsort(base, nmemb, 4u, (__compar_fn_t)compare_keys);
      v33 = 0;
      v34 = v45;
      v43 = v6;
      do
      {
        v36 = *(char **)(v34 + 4);
        v34 += 4;
        v35 = v36;
        v37 = json_object_get(v43, v36);
        if ( !v37 )
          _assert_fail("value", "compat/jansson-2.9/src/dump.c", 349u, "do_dump");
        v38 = strlen(v35);
        dump_string(v35, v38, (int (__fastcall *)(char *, int, int))a4, a5, a2);
        if ( a4(v40, v41, a5) || do_dump(v37, a2, v15, a4, a5) )
        {
LABEL_58:
          v6 = v43;
          jsonp_free((int)base);
          goto LABEL_21;
        }
        if ( v33 < nmemb - 1 )
        {
          if ( a4(",", 1, a5) || dump_indent(a2, v15, 1, a4, a5) )
            goto LABEL_58;
        }
        else if ( dump_indent(a2, a3, 0, a4, a5) )
        {
          goto LABEL_58;
        }
        ++v33;
      }
      while ( nmemb != v33 );
      v6 = v43;
      jsonp_free((int)base);
LABEL_42:
      v6[9] = 0;
      return a4((const char *)&word_67AC8, 1, a5);
    case 1:
      if ( a1[5] )
        goto LABEL_33;
      a1[5] = 1;
      v21 = json_array_size(a1);
      if ( a4("[", 1, a5) )
        goto LABEL_33;
      if ( !v21 )
        goto LABEL_44;
      v22 = a3 + 1;
      if ( dump_indent(a2, a3 + 1, 0, a4, a5) )
        goto LABEL_33;
      v23 = 0;
      break;
    case 2:
      v25 = (char *)json_string_value(a1);
      v26 = json_string_length(v6);
      return dump_string(v25, (int)v26, (int (__fastcall *)(char *, int, int))a4, a5, a2);
    case 3:
      v27 = json_integer_value((int)a1);
      v28 = snprintf(s, 100u, "%lld", v27);
      if ( v28 > 99 )
        return -1;
      return a4(s, v28, a5);
    case 4:
      json_real_value();
      v29 = jsonp_dtostr(s, 100u, (unsigned __int16)a2 >> 11);
      if ( v29 < 0 )
        return -1;
      return a4(s, v29, a5);
    case 5:
      return a4("true", 4, a5);
    case 6:
      return a4("false", 5, a5);
    case 7:
      return a4("null", 4, a5);
    default:
      return -1;
  }
  do
  {
    v24 = json_array_get(v6, v23);
    if ( do_dump(v24, a2, v22, a4, a5) )
    {
LABEL_33:
      result = -1;
      v6[5] = 0;
      return result;
    }
    if ( (unsigned int)v21 - 1 > v23 )
    {
      if ( a4(",", 1, a5) || dump_indent(a2, v22, 1, a4, a5) )
        goto LABEL_33;
    }
    else if ( dump_indent(a2, a3, 0, a4, a5) )
    {
      goto LABEL_33;
    }
    ++v23;
  }
  while ( v21 != (_DWORD *)v23 );
LABEL_44:
  v6[5] = 0;
  return a4((const char *)&word_5E060, 1, a5);
}
// 4EC4C: using guessed type int compare_keys();
// 5E060: using guessed type __int16 word_5E060;
// 67AC8: using guessed type __int16 word_67AC8;

//----- (0004F290) --------------------------------------------------------
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, __int16 a4)
{
  if ( (a4 & 0x200) != 0 || a1 && *a1 <= 1u )
    return do_dump(a1, a4, 0, a2, a3);
  else
    return -1;
}

//----- (0004F2B8) --------------------------------------------------------
void *__fastcall json_dumps(_DWORD *a1, __int16 a2)
{
  void *v4; // r4
  const char *v6; // r0
  int v7[7]; // [sp+4h] [bp-1Ch] BYREF

  if ( strbuffer_init(v7) )
    return 0;
  v4 = 0;
  if ( !json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))dump_to_strbuffer, (int)v7, a2) )
  {
    v6 = (const char *)strbuffer_value((int)v7);
    v4 = jsonp_strdup(v6);
  }
  strbuffer_close(v7);
  return v4;
}
// 4F2B8: using guessed type int var_1C[7];

//----- (0004F300) --------------------------------------------------------
int __fastcall json_dumpf(_DWORD *a1, int a2, __int16 a3)
{
  return json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))dump_to_file, a2, a3);
}

//----- (0004F310) --------------------------------------------------------
int __fastcall json_dump_file(_DWORD *a1, char *filename, __int16 a3)
{
  FILE *v5; // r0
  FILE *v6; // r4
  int v7; // r5

  v5 = fopen(filename, "w");
  if ( !v5 )
    return -1;
  v6 = v5;
  v7 = json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))dump_to_file, (int)v5, a3);
  fclose(v6);
  return v7;
}

//----- (0004F350) --------------------------------------------------------
char *__fastcall jsonp_error_set_source_part_0(int a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  if ( v4 <= 79 )
    return j_strncpy((char *)(a1 + 12), s, v4 + 1);
  qmemcpy((void *)(a1 + 12), "...", 3);
  return j_strncpy((char *)(a1 + 15), &s[v4 - 76], 77u);
}

//----- (0004F394) --------------------------------------------------------
int __fastcall jsonp_error_init(int a1, char *s)
{
  if ( a1 )
  {
    *(_BYTE *)(a1 + 92) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)a1 = -1;
    *(_DWORD *)(a1 + 4) = -1;
    if ( s )
      return (int)jsonp_error_set_source_part_0(a1, s);
    else
      *(_BYTE *)(a1 + 12) = 0;
  }
  return a1;
}

//----- (0004F3B8) --------------------------------------------------------
int __fastcall jsonp_error_set_source(int a1, char *s)
{
  bool v2; // zf

  v2 = s == 0;
  if ( s )
    v2 = a1 == 0;
  if ( !v2 )
    return (int)jsonp_error_set_source_part_0(a1, s);
  return a1;
}

//----- (0004F3C4) --------------------------------------------------------
int jsonp_error_set(int result, int a2, int a3, int a4, const char *arg, ...)
{
  int v5; // r4
  va_list va; // [sp+24h] [bp+4h] BYREF

  va_start(va, arg);
  if ( result )
  {
    v5 = result;
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 160u, arg, va);
      *(_BYTE *)(v5 + 251) = 0;
    }
  }
  return result;
}

//----- (0004F3F8) --------------------------------------------------------
int __fastcall jsonp_error_vset(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg)
{
  int v6; // r4

  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      v6 = result;
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 160u, format, arg);
      *(_BYTE *)(v6 + 251) = 0;
    }
  }
  return result;
}

//----- (0004F424) --------------------------------------------------------
int __fastcall hashlittle(unsigned __int8 *a1, unsigned int a2, int a3)
{
  int v3; // r4
  int v4; // r7
  unsigned __int8 *v5; // r6
  int v6; // r3
  int v7; // r12
  int v8; // r5
  int v9; // r4
  int v10; // r3
  int v11; // r4
  int v12; // r5
  int v13; // r3
  int v14; // r2
  int v15; // r4
  int v16; // r2
  int v17; // r3
  int v18; // lr
  unsigned __int8 *v19; // r6
  int v20; // r2
  int v21; // r4
  int v22; // r5
  int v23; // r8
  int v24; // lr
  int v25; // r3
  int v26; // r2
  int v27; // r4
  int v28; // r3
  int v29; // r5
  int v30; // r4
  int v31; // r2
  int v32; // r4
  int v33; // r3
  int v34; // r5
  int v35; // r3
  int v36; // r4
  int v37; // r4
  int v38; // r6
  unsigned __int8 *v39; // r5
  int v40; // r9
  int v41; // r12
  int v42; // r4
  int v43; // r2
  int v44; // r3
  int v45; // r4
  int v46; // r7
  int v47; // r3
  int v48; // r2
  int v49; // r4
  int v50; // r6
  int v51; // r2
  int v52; // r4
  int v53; // r7
  int v54; // t2
  int v55; // r3
  int v56; // r2
  int v57; // r3
  int v58; // r1
  int v59; // r3
  int v60; // r1
  int v61; // r4
  int v62; // r2
  int v63; // r1
  int v64; // r1

  v3 = a3 - 559038737;
  v4 = a3 - 559038737 + a2;
  if ( (_DWORD)a1 << 30 )
  {
    if ( ((unsigned __int8)a1 & 1) != 0 )
    {
      if ( a2 > 12 )
      {
        v39 = a1 + 12;
        v6 = v3 + a2;
        v38 = v3 + a2;
        do
        {
          v40 = *(v39 - 2);
          a2 -= 12;
          v41 = *(v39 - 3);
          v42 = *(v39 - 10);
          a1 = v39;
          v43 = *(v39 - 11);
          v39 += 12;
          v44 = v6 + *(v39 - 16) + (v40 << 16) + (v41 << 8) + (*(v39 - 13) << 24);
          v45 = (*(v39 - 24) + (v42 << 16) + (v43 << 8) + (*(v39 - 21) << 24) - v44 + v38) ^ __ROR4__(v44, 28);
          v46 = v4 + *(v39 - 20) + (*(v39 - 18) << 16) + (*(v39 - 19) << 8) + (*(v39 - 17) << 24);
          v47 = v44 + v46;
          v48 = (v46 - v45) ^ __ROR4__(v45, 26);
          v49 = v45 + v47;
          v50 = v48 + v49;
          v51 = (v47 - v48) ^ __ROR4__(v48, 24);
          v52 = v49 - v51;
          v53 = v51 + v50;
          v54 = __ROR4__(v51, 16);
          v55 = v50 - (v52 ^ v54);
          v38 = (v52 ^ v54) + v51 + v50;
          v56 = v55 ^ __ROR4__(v52 ^ v54, 13);
          v57 = v53 - v56;
          v4 = v56 + v38;
          v6 = v57 ^ __ROR4__(v56, 28);
        }
        while ( a2 > 12 );
      }
      else
      {
        v6 = v3 + a2;
        v38 = v3 + a2;
      }
      switch ( a2 )
      {
        case 1u:
          goto LABEL_27;
        case 2u:
          goto LABEL_26;
        case 3u:
          goto LABEL_25;
        case 4u:
          goto LABEL_24;
        case 5u:
          goto LABEL_23;
        case 6u:
          goto LABEL_22;
        case 7u:
          goto LABEL_21;
        case 8u:
          goto LABEL_20;
        case 9u:
          goto LABEL_19;
        case 10u:
          goto LABEL_18;
        case 11u:
          goto LABEL_17;
        case 12u:
          v6 += a1[11] << 24;
LABEL_17:
          v6 += a1[10] << 16;
LABEL_18:
          v6 += a1[9] << 8;
LABEL_19:
          v6 += a1[8];
LABEL_20:
          v4 += a1[7] << 24;
LABEL_21:
          v4 += a1[6] << 16;
LABEL_22:
          v4 += a1[5] << 8;
LABEL_23:
          v4 += a1[4];
LABEL_24:
          v38 += a1[3] << 24;
LABEL_25:
          v38 += a1[2] << 16;
LABEL_26:
          v38 += a1[1] << 8;
LABEL_27:
          v58 = *a1 + v38;
          goto LABEL_28;
        default:
          return v6;
      }
    }
    if ( a2 <= 12 )
    {
      v6 = v3 + a2;
      v20 = v3 + a2;
    }
    else
    {
      v19 = a1 + 12;
      v6 = v3 + a2;
      v20 = v3 + a2;
      do
      {
        v21 = *((unsigned __int16 *)v19 - 1);
        a2 -= 12;
        v22 = *((unsigned __int16 *)v19 - 2);
        v23 = *((unsigned __int16 *)v19 - 5);
        a1 = v19;
        v24 = *((unsigned __int16 *)v19 - 6);
        v19 += 12;
        v25 = v6 + v22 + (v21 << 16);
        v26 = (v20 + v24 + (v23 << 16) - v25) ^ __ROR4__(v25, 28);
        v27 = *((unsigned __int16 *)v19 - 10) + (*((unsigned __int16 *)v19 - 9) << 16) + v4;
        v28 = v25 + v27;
        v29 = v26 + v28;
        v30 = (v27 - v26) ^ __ROR4__(v26, 26);
        v31 = v30 + v26 + v28;
        v32 = (v28 - v30) ^ __ROR4__(v30, 24);
        v33 = v29 - v32;
        v34 = v32 + v31;
        v35 = v33 ^ __ROR4__(v32, 16);
        v36 = v31 - v35;
        v20 = v35 + v34;
        v37 = v36 ^ __ROR4__(v35, 13);
        v4 = v37 + v35 + v34;
        v6 = (v34 - v37) ^ __ROR4__(v37, 28);
      }
      while ( a2 > 12 );
    }
    switch ( a2 )
    {
      case 1u:
        v58 = *a1 + v20;
        break;
      case 2u:
        goto LABEL_51;
      case 3u:
        v20 += a1[2] << 16;
LABEL_51:
        v58 = *(unsigned __int16 *)a1 + v20;
        break;
      case 4u:
        goto LABEL_45;
      case 5u:
        v4 += a1[4];
LABEL_45:
        v58 = *(unsigned __int16 *)a1 + v20 + (*((unsigned __int16 *)a1 + 1) << 16);
        break;
      case 6u:
        goto LABEL_47;
      case 7u:
        v4 += a1[6] << 16;
LABEL_47:
        v58 = *(unsigned __int16 *)a1 + v20 + (*((unsigned __int16 *)a1 + 1) << 16);
        v4 += *((unsigned __int16 *)a1 + 2);
        break;
      case 8u:
        goto LABEL_49;
      case 9u:
        v6 += a1[8];
LABEL_49:
        v4 += *((unsigned __int16 *)a1 + 2) + (*((unsigned __int16 *)a1 + 3) << 16);
        v58 = *(unsigned __int16 *)a1 + v20 + (*((unsigned __int16 *)a1 + 1) << 16);
        break;
      case 10u:
        goto LABEL_43;
      case 11u:
        v6 += a1[10] << 16;
LABEL_43:
        v4 += *((unsigned __int16 *)a1 + 2) + (*((unsigned __int16 *)a1 + 3) << 16);
        v58 = *(unsigned __int16 *)a1 + v20 + (*((unsigned __int16 *)a1 + 1) << 16);
        v6 += *((unsigned __int16 *)a1 + 4);
        break;
      case 12u:
        v6 += *((unsigned __int16 *)a1 + 4) + (*((unsigned __int16 *)a1 + 5) << 16);
        v4 += *((unsigned __int16 *)a1 + 2) + (*((unsigned __int16 *)a1 + 3) << 16);
        v58 = *(unsigned __int16 *)a1 + v20 + (*((unsigned __int16 *)a1 + 1) << 16);
        break;
      default:
        return v6;
    }
  }
  else
  {
    if ( a2 <= 12 )
    {
      v6 = v3 + a2;
      v7 = v3 + a2;
    }
    else
    {
      v5 = a1 + 12;
      v6 = v3 + a2;
      v7 = v3 + a2;
      do
      {
        a2 -= 12;
        v8 = *((_DWORD *)v5 - 3);
        v9 = *((_DWORD *)v5 - 2);
        a1 = v5;
        v10 = v6 + *((_DWORD *)v5 - 1);
        v5 += 12;
        v11 = v9 + v4;
        v12 = (v8 - v10 + v7) ^ __ROR4__(v10, 28);
        v13 = v10 + v11;
        v14 = (v11 - v12) ^ __ROR4__(v12, 26);
        v15 = v14 + v12 + v13;
        v16 = (v13 - v14) ^ __ROR4__(v14, 24);
        v17 = (v12 + v13 - v16) ^ __ROR4__(v16, 16);
        v7 = v17 + v16 + v15;
        v18 = (v15 - v17) ^ __ROR4__(v17, 13);
        v4 = v18 + v7;
        v6 = (v16 + v15 - v18) ^ __ROR4__(v18, 28);
      }
      while ( a2 > 12 );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_39;
      case 2u:
        goto LABEL_38;
      case 3u:
        v7 += a1[2] << 16;
LABEL_38:
        v7 += a1[1] << 8;
LABEL_39:
        v58 = *a1 + v7;
        break;
      case 4u:
        goto LABEL_36;
      case 5u:
        goto LABEL_35;
      case 6u:
        goto LABEL_34;
      case 7u:
        v4 += a1[6] << 16;
LABEL_34:
        v4 += a1[5] << 8;
LABEL_35:
        v4 += a1[4];
LABEL_36:
        v58 = *(_DWORD *)a1 + v7;
        break;
      case 8u:
        goto LABEL_32;
      case 9u:
        goto LABEL_31;
      case 10u:
        goto LABEL_30;
      case 11u:
        v6 += a1[10] << 16;
LABEL_30:
        v6 += a1[9] << 8;
LABEL_31:
        v6 += a1[8];
LABEL_32:
        v4 += *((_DWORD *)a1 + 1);
        v58 = *(_DWORD *)a1 + v7;
        break;
      case 12u:
        v6 += *((_DWORD *)a1 + 2);
        v4 += *((_DWORD *)a1 + 1);
        v58 = *(_DWORD *)a1 + v7;
        break;
      default:
        return v6;
    }
  }
LABEL_28:
  v59 = (v6 ^ v4) - __ROR4__(v4, 18);
  v60 = (v58 ^ v59) - __ROR4__(v59, 21);
  v61 = (v4 ^ v60) - __ROR4__(v60, 7);
  v62 = (v59 ^ v61) - __ROR4__(v61, 16);
  v63 = (v60 ^ v62) - __ROR4__(v62, 28);
  v64 = (v61 ^ v63) - __ROR4__(v63, 18);
  return (v62 ^ v64) - __ROR4__(v64, 8);
}

//----- (0004F7C4) --------------------------------------------------------
int __fastcall hashtable_find_pair(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 + 16) != a4 || strcmp((const char *)(v4 + 24), s2) )
  {
    if ( v4 == a2[1] )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4;
}

//----- (0004F800) --------------------------------------------------------
int __fastcall hashtable_do_clear(int result)
{
  int v1; // r6
  int v2; // r4
  int v3; // r0
  int v4; // r5
  int v5; // r3
  bool v6; // zf
  int v7; // r3
  int v8; // r0

  v1 = result + 12;
  v2 = *(_DWORD *)(result + 16);
  if ( v2 != result + 12 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 20);
      v4 = *(_DWORD *)(v2 + 4);
      if ( v3 )
      {
        v5 = *(_DWORD *)(v3 + 4);
        v6 = v5 == -1;
        v7 = v5 - 1;
        if ( !v6 )
        {
          *(_DWORD *)(v3 + 4) = v7;
          if ( !v7 )
            json_delete();
        }
      }
      v8 = v2;
      v2 = v4;
      result = jsonp_free(v8);
    }
    while ( v4 != v1 );
  }
  return result;
}
// 5287C: using guessed type int json_delete(void);

//----- (0004F834) --------------------------------------------------------
int __fastcall hashtable_init(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r1
  _DWORD *v4; // r3
  _DWORD *v5; // r2

  *a1 = 0;
  a1[2] = 3;
  v2 = (_DWORD *)jsonp_malloc(64);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1[2];
  v4 = a1 + 3;
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  if ( 1 << v3 )
  {
    v5 = &v2[2 * (1 << v3)];
    do
    {
      v2[1] = v4;
      *v2 = v4;
      v2 += 2;
    }
    while ( v2 != v5 );
  }
  return 0;
}

//----- (0004F87C) --------------------------------------------------------
int __fastcall hashtable_close(int a1)
{
  hashtable_do_clear(a1);
  return jsonp_free(*(_DWORD *)(a1 + 4));
}

//----- (0004F890) --------------------------------------------------------
int __fastcall hashtable_set(int *a1, char *s, int a3)
{
  int v4; // r3
  int v7; // r4
  unsigned int v8; // r7
  unsigned int v9; // r8
  int v10; // r5
  int *v11; // r11
  int pair; // r0
  int v13; // r4
  _DWORD *v14; // r0
  int v15; // r3
  int v16; // r3
  int result; // r0
  int v18; // r5
  int v19; // r11
  _DWORD *v20; // r5
  _DWORD *v21; // r3
  _DWORD *v22; // r4
  int v23; // r8
  int v24; // r3
  int v25; // r1
  _DWORD *v26; // r0
  _DWORD *v27; // r1
  _DWORD *v28; // r2
  int v29; // r0
  _DWORD *v30; // r4
  int v31; // r3
  _DWORD *v32; // r2
  int v33; // r1
  int v34; // r3

  v4 = a1[2];
  if ( (unsigned int)*a1 >> v4 )
  {
    v18 = v4 + 1;
    v8 = 1 << (v4 + 1);
    v19 = jsonp_malloc(8 * v8);
    if ( !v19 )
      return -1;
    jsonp_free(a1[1]);
    a1[2] = v18;
    a1[1] = v19;
    v20 = a1 + 3;
    v21 = (_DWORD *)v19;
    if ( v8 )
    {
      do
      {
        v21[1] = v20;
        *v21 = v20;
        v21 += 2;
      }
      while ( (_DWORD *)(v19 + 8 * v8) != v21 );
    }
    else
    {
      v20 = a1 + 3;
    }
    v22 = (_DWORD *)a1[4];
    a1[3] = (int)v20;
    a1[4] = (int)v20;
    if ( v22 == v20 )
    {
      v7 = v19;
    }
    else
    {
      v23 = a1[1];
      do
      {
        while ( 1 )
        {
          v25 = v22[4] % v8;
          v26 = *(_DWORD **)(v19 + 8 * v25);
          v27 = (_DWORD *)(v19 + 8 * v25);
          v28 = (_DWORD *)v22[1];
          if ( v26 == v20 && (_DWORD *)v27[1] == v20 )
            break;
          v24 = *v26;
          v22[1] = v26;
          v19 = v23;
          *v22 = v24;
          *(_DWORD *)(*v26 + 4) = v22;
          *v26 = v22;
          *v27 = v22;
          v22 = v28;
          if ( v28 == v20 )
            goto LABEL_17;
        }
        v19 = v23;
        *v22 = a1[3];
        v22[1] = v20;
        *(_DWORD *)(a1[3] + 4) = v22;
        a1[3] = (int)v22;
        v27[1] = v22;
        *v27 = v22;
        v22 = v28;
      }
      while ( v28 != v20 );
LABEL_17:
      v7 = v23;
      v8 = 1 << a1[2];
    }
  }
  else
  {
    v7 = a1[1];
    v8 = 1 << v4;
  }
  v9 = strlen(s);
  v10 = hashlittle((unsigned __int8 *)s, v9, hashtable_seed);
  v11 = (int *)(v7 + 8 * ((v8 - 1) & v10));
  pair = hashtable_find_pair((int)a1, v11, s, v10);
  v13 = pair;
  if ( pair )
  {
    v14 = *(_DWORD **)(pair + 20);
    if ( !v14 || (v15 = v14[1], v15 == -1) || (v16 = v15 - 1, (v14[1] = v16) != 0) )
    {
      *(_DWORD *)(v13 + 20) = a3;
      return 0;
    }
    else
    {
      json_delete(v14);
      *(_DWORD *)(v13 + 20) = a3;
      return 0;
    }
  }
  if ( v9 > 4294967270 )
    return -1;
  v29 = jsonp_malloc(v9 + 25);
  v30 = (_DWORD *)v29;
  if ( !v29 )
    return -1;
  *(_DWORD *)(v29 + 16) = v10;
  strncpy((char *)(v29 + 24), s, v9 + 1);
  v31 = *v11;
  v32 = v30 + 2;
  v30[5] = a3;
  v30[1] = v30;
  *v30 = v30;
  v30[3] = v30 + 2;
  v30[2] = v30 + 2;
  if ( (int *)v31 == a1 + 3 && v31 == v11[1] )
  {
    *v30 = a1[3];
    v30[1] = v31;
    *(_DWORD *)(a1[3] + 4) = v30;
    a1[3] = (int)v30;
    v11[1] = (int)v30;
    *v11 = (int)v30;
  }
  else
  {
    *v30 = *(_DWORD *)v31;
    v30[1] = v31;
    *(_DWORD *)(*(_DWORD *)v31 + 4) = v30;
    *(_DWORD *)v31 = v30;
    *v11 = (int)v30;
  }
  v33 = a1[5];
  v34 = *a1;
  result = 0;
  v30[3] = a1 + 5;
  v30[2] = v33;
  *(_DWORD *)(a1[5] + 4) = v32;
  a1[5] = (int)v32;
  *a1 = v34 + 1;
  return result;
}
// 80B828: using guessed type int hashtable_seed;

//----- (0004FA48) --------------------------------------------------------
int __fastcall hashtable_get(int a1, char *s)
{
  unsigned int v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = hashlittle((unsigned __int8 *)s, v4, hashtable_seed);
  result = hashtable_find_pair(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (((1 << *(_DWORD *)(a1 + 8)) - 1) & v5)), s, v5);
  if ( result )
    return *(_DWORD *)(result + 20);
  return result;
}
// 80B828: using guessed type int hashtable_seed;

//----- (0004FA8C) --------------------------------------------------------
int __fastcall hashtable_del(_DWORD *a1, char *s)
{
  unsigned int v4; // r0
  int v5; // r0
  int v6; // r7
  int v7; // r5
  int *v8; // r8
  _DWORD *pair; // r0
  _DWORD *v10; // r1
  int v11; // r4
  _DWORD *v12; // r3
  int v13; // r2
  _DWORD *v14; // r1
  int v15; // r2
  _DWORD *v16; // r0
  int v17; // r3
  int v18; // r3
  int v19; // r3
  int result; // r0
  bool v21; // zf

  v4 = strlen(s);
  v5 = hashlittle((unsigned __int8 *)s, v4, hashtable_seed);
  v6 = a1[1];
  v7 = v5 & ((1 << a1[2]) - 1);
  v8 = (int *)(v6 + 8 * v7);
  pair = (_DWORD *)hashtable_find_pair((int)a1, v8, s, v5);
  if ( !pair )
    return -1;
  v11 = (int)pair;
  v12 = (_DWORD *)v8[1];
  if ( pair == *(_DWORD **)(v6 + 8 * v7) )
  {
    v21 = pair == v12;
    if ( pair == v12 )
    {
      v10 = a1 + 3;
      v13 = pair[1];
      v12 = (_DWORD *)*pair;
      v8[1] = (int)(a1 + 3);
    }
    else
    {
      v13 = pair[1];
    }
    if ( v21 )
      *(_DWORD *)(v6 + 8 * v7) = v10;
    else
      v12 = (_DWORD *)*pair;
    if ( !v21 )
      *(_DWORD *)(v6 + 8 * v7) = v13;
  }
  else
  {
    v21 = pair == v12;
    v12 = (_DWORD *)*pair;
    v13 = pair[1];
    if ( v21 )
      v8[1] = (int)v12;
  }
  v12[1] = v13;
  v14 = (_DWORD *)pair[1];
  v15 = pair[3];
  v16 = (_DWORD *)pair[5];
  *v14 = v12;
  v17 = *(_DWORD *)(v11 + 8);
  *(_DWORD *)(v17 + 4) = v15;
  **(_DWORD **)(v11 + 12) = v17;
  if ( v16 )
  {
    v18 = v16[1];
    if ( v18 != -1 )
    {
      v19 = v18 - 1;
      v16[1] = v19;
      if ( !v19 )
        json_delete(v16);
    }
  }
  jsonp_free(v11);
  result = 0;
  --*a1;
  return result;
}
// 4FB36: variable 'v10' is possibly undefined
// 80B828: using guessed type int hashtable_seed;

//----- (0004FB48) --------------------------------------------------------
int __fastcall hashtable_clear(_DWORD *a1)
{
  int result; // r0
  int v3; // r1
  _DWORD *v4; // r3
  _DWORD *v5; // r2
  _DWORD *v6; // r1

  result = hashtable_do_clear((int)a1);
  v3 = 1 << a1[2];
  if ( v3 )
  {
    v4 = (_DWORD *)a1[1];
    v5 = a1 + 3;
    v6 = &v4[2 * v3];
    do
    {
      v4[1] = v5;
      *v4 = v5;
      v4 += 2;
    }
    while ( v6 != v4 );
  }
  else
  {
    v5 = a1 + 3;
  }
  a1[4] = v5;
  a1[3] = v5;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  *a1 = 0;
  return result;
}

//----- (0004FB84) --------------------------------------------------------
int __fastcall hashtable_iter(int a1)
{
  if ( *(_DWORD *)(a1 + 24) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a1 + 24);
}

//----- (0004FB94) --------------------------------------------------------
int __fastcall hashtable_iter_at(int a1, char *s)
{
  unsigned int v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = hashlittle((unsigned __int8 *)s, v4, hashtable_seed);
  result = hashtable_find_pair(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (((1 << *(_DWORD *)(a1 + 8)) - 1) & v5)), s, v5);
  if ( result )
    result += 8;
  return result;
}
// 80B828: using guessed type int hashtable_seed;

//----- (0004FBD8) --------------------------------------------------------
int __fastcall hashtable_iter_next(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (0004FBE8) --------------------------------------------------------
int __fastcall hashtable_iter_key(int a1)
{
  return a1 + 16;
}

//----- (0004FBEC) --------------------------------------------------------
int __fastcall hashtable_iter_value(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0004FBF0) --------------------------------------------------------
_DWORD *__fastcall hashtable_iter_set(int a1, int a2)
{
  _DWORD *result; // r0
  int v5; // r3
  int v6; // r3

  result = *(_DWORD **)(a1 + 12);
  if ( !result || (v5 = result[1], v5 == -1) || (v6 = v5 - 1, (result[1] = v6) != 0) )
  {
    *(_DWORD *)(a1 + 12) = a2;
  }
  else
  {
    result = json_delete(result);
    *(_DWORD *)(a1 + 12) = a2;
  }
  return result;
}

//----- (0004FC14) --------------------------------------------------------
time_t __fastcall json_object_seed(time_t result)
{
  int v1; // r3

  if ( !hashtable_seed )
  {
    v1 = result;
    if ( !result )
    {
      result = time(0);
      if ( result )
        v1 = result;
      else
        v1 = 1;
    }
    hashtable_seed = v1;
  }
  return result;
}
// 80B828: using guessed type int hashtable_seed;

//----- (0004FC38) --------------------------------------------------------
int __fastcall string_get(_DWORD *a1)
{
  int v1; // r2
  int v2; // r3

  v1 = a1[1];
  v2 = *(unsigned __int8 *)(*a1 + v1);
  if ( !*(_BYTE *)(*a1 + v1) )
    return -1;
  a1[1] = v1 + 1;
  return v2;
}

//----- (0004FC50) --------------------------------------------------------
int __fastcall buffer_get(_DWORD *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r2
  int v3; // r3

  v1 = a1[2];
  if ( v1 >= a1[1] )
    return -1;
  v2 = v1 + 1;
  v3 = *(unsigned __int8 *)(*a1 + v1);
  a1[2] = v2;
  return v3;
}

//----- (0004FC6C) --------------------------------------------------------
int __fastcall callback_get(_DWORD *a1)
{
  unsigned int v1; // r3
  int result; // r0
  int (__fastcall *v4)(_DWORD *, int, _DWORD); // r3
  int v5; // r0
  int v6; // r3

  v1 = a1[257];
  if ( v1 >= a1[256] )
  {
    v4 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
    a1[257] = 0;
    v5 = v4(a1, 1024, a1[259]);
    a1[256] = v5;
    if ( (unsigned int)(v5 - 1) > 4294967293 )
    {
      return -1;
    }
    else
    {
      v6 = a1[257];
      result = *((unsigned __int8 *)a1 + v6);
      a1[257] = v6 + 1;
    }
  }
  else
  {
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
  }
  return result;
}

//----- (0004FCB8) --------------------------------------------------------
int error_set(int result, _DWORD *a2, const char *a3, ...)
{
  int v4; // r5
  const char *v5; // r0
  int v6; // r7
  int v7; // r6
  int v8; // r8
  char *v9; // r3
  char s[160]; // [sp+10h] [bp-168h] BYREF
  char v11[159]; // [sp+B0h] [bp-C8h] BYREF
  char v12; // [sp+14Fh] [bp-29h]
  va_list arg; // [sp+174h] [bp-4h] BYREF

  va_start(arg, a3);
  if ( result )
  {
    v4 = result;
    vsnprintf(s, 160u, a3, arg);
    s[159] = 0;
    if ( !a2 )
    {
      v7 = -1;
      v9 = s;
      v8 = 0;
      v6 = -1;
      return jsonp_error_set(v4, v6, v7, v8, "%s", v9);
    }
    v5 = (const char *)strbuffer_value((int)(a2 + 10));
    v6 = a2[6];
    v7 = a2[7];
    v8 = a2[9];
    if ( v5 && *v5 )
    {
      if ( a2[11] <= 20u )
      {
        snprintf(v11, 160u, "%s near '%s'", s, v5);
        v9 = v11;
        v12 = 0;
        return jsonp_error_set(v4, v6, v7, v8, "%s", v9);
      }
    }
    else if ( a2[5] != -2 )
    {
      snprintf(v11, 160u, "%s near end of file", s);
      v9 = v11;
      v12 = 0;
      return jsonp_error_set(v4, v6, v7, v8, "%s", v9);
    }
    v9 = s;
    return jsonp_error_set(v4, v6, v7, v8, "%s", v9);
  }
  return result;
}

//----- (0004FD70) --------------------------------------------------------
int __fastcall lex_close(int *a1)
{
  if ( a1[15] != 256 )
    return strbuffer_close(a1 + 10);
  jsonp_free(a1[16]);
  a1[16] = 0;
  a1[17] = 0;
  return strbuffer_close(a1 + 10);
}

//----- (0004FDA0) --------------------------------------------------------
int __fastcall decode_unicode_escape(_BYTE *a1)
{
  _BYTE *v1; // r3
  int result; // r0
  _BYTE *v3; // r5
  int v4; // r2
  int v5; // t1
  int v6; // r0
  int v7; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "compat/jansson-2.9/src/load.c", 312u, "decode_unicode_escape");
  v1 = a1;
  result = 0;
  v3 = v1 + 4;
  while ( 1 )
  {
    v5 = (unsigned __int8)*++v1;
    v4 = v5;
    v6 = 16 * result;
    v7 = v5 - 48;
    if ( (unsigned __int8)(v5 - 48) > 9u )
      break;
    result = v6 + v7;
LABEL_10:
    if ( v1 == v3 )
      return result;
  }
  if ( (unsigned int)(v4 - 97) <= 25 )
  {
    result = v6 + v4 - 87;
    goto LABEL_10;
  }
  if ( (unsigned int)(v4 - 65) <= 25 )
  {
    result = v6 + v4 - 55;
    goto LABEL_10;
  }
  return -1;
}

//----- (0004FE0C) --------------------------------------------------------
_DWORD *__fastcall stream_unget(_DWORD *result, int a2)
{
  _DWORD *v2; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r2

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    --result[9];
    if ( a2 == 10 )
    {
      v6 = result[8];
      --result[6];
      result[7] = v6;
    }
    else
    {
      result = (_DWORD *)utf8_check_first((unsigned __int8)a2);
      if ( result )
        --v2[7];
    }
    v4 = v2[4];
    if ( !v4 )
      _assert_fail("stream->buffer_pos > 0", "compat/jansson-2.9/src/load.c", 240u, "stream_unget");
    v5 = v4 - 1;
    v2[4] = v5;
    if ( a2 != *((unsigned __int8 *)v2 + v5 + 8) )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "compat/jansson-2.9/src/load.c", 242u, "stream_unget");
  }
  return result;
}

//----- (0004FE84) --------------------------------------------------------
int __fastcall stream_get_part_3(int a1, int a2)
{
  int v2; // r3
  int v4; // r2
  int v5; // r3
  int v6; // r5
  int v7; // r2
  int result; // r0
  int v9; // r3
  int v10; // r2
  int v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r9
  int v15; // r5
  int v16; // r8
  int v17; // r3
  int v18; // r2

  v2 = *(_DWORD *)(a1 + 16);
  v4 = a1 + v2;
  v5 = v2 + 1;
  v6 = *(unsigned __int8 *)(v4 + 8);
  if ( !*(_BYTE *)(v4 + 8) )
  {
    result = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    v12 = result;
    if ( result == -1 )
    {
      *(_DWORD *)(a1 + 20) = -1;
      return result;
    }
    v6 = (unsigned __int8)result;
    *(_BYTE *)(a1 + 8) = result;
    *(_DWORD *)(a1 + 16) = 0;
    if ( (unsigned int)(result - 128) <= 127 )
    {
      v13 = utf8_check_first((unsigned __int8)result);
      v14 = v13;
      if ( !v13 )
        goto LABEL_17;
      if ( v13 <= 1 )
        _assert_fail("count >= 2", "compat/jansson-2.9/src/load.c", 188u, "stream_get");
      v15 = a1 + 8;
      v16 = v13 + 7 + a1;
      do
        *(_BYTE *)++v15 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
      while ( v16 != v15 );
      if ( !utf8_check_full((char *)(a1 + 8), v14, 0) )
      {
LABEL_17:
        *(_DWORD *)(a1 + 20) = -2;
        error_set(a2, (_DWORD *)a1, "unable to decode byte 0x%x", v12);
        return -2;
      }
      *(_BYTE *)(v14 + a1 + 8) = 0;
      v17 = *(_DWORD *)(a1 + 16);
      v18 = a1 + v17;
      v5 = v17 + 1;
      v6 = *(unsigned __int8 *)(v18 + 8);
    }
    else
    {
      v5 = 1;
      *(_BYTE *)(a1 + 9) = 0;
    }
  }
  v7 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 36) = v7 + 1;
  if ( v6 == 10 )
  {
    v9 = *(_DWORD *)(a1 + 24);
    v10 = *(_DWORD *)(a1 + 28);
    result = 10;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 24) = v9 + 1;
    *(_DWORD *)(a1 + 32) = v10;
  }
  else if ( utf8_check_first(v6) )
  {
    result = v6;
    ++*(_DWORD *)(a1 + 28);
  }
  else
  {
    return v6;
  }
  return result;
}

//----- (0004FF80) --------------------------------------------------------
int __fastcall lex_get_save(int a1, int a2)
{
  int part_3; // r4

  part_3 = *(_DWORD *)(a1 + 20);
  if ( !part_3 )
    part_3 = stream_get_part_3(a1, a2);
  if ( (unsigned int)(part_3 + 2) > 1 )
    strbuffer_append_byte((const void **)(a1 + 40), part_3);
  return part_3;
}

//----- (0004FFA4) --------------------------------------------------------
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2)
{
  _DWORD *v2; // r5

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    stream_unget(result, a2);
    result = (_DWORD *)strbuffer_pop(v2 + 10);
    if ( (_DWORD *)a2 != result )
      _assert_fail("c == d", "compat/jansson-2.9/src/load.c", 285u, "lex_unget_unsave");
  }
  return result;
}

//----- (0004FFE0) --------------------------------------------------------
int __fastcall lex_scan(_DWORD *a1, int a2)
{
  const void **v2; // r7
  unsigned int part_3; // r4
  bool v6; // cc
  int result; // r0
  bool v8; // zf
  _BOOL4 v9; // r2
  bool v10; // cc
  int v11; // r0
  const char *v12; // r4
  char i; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r0
  bool v17; // zf
  const char *v18; // r7
  int *v19; // r8
  __int64 v20; // r0
  double v21; // r2
  int v22; // r1
  int v23; // r0
  unsigned int save; // r4
  int v25; // r0
  bool v26; // zf
  unsigned int v27; // r3
  int v28; // r8
  unsigned int v29; // r3
  unsigned int v30; // r4
  bool v31; // cc
  int v32; // r1
  int v33; // r0
  _BYTE *v34; // r4
  const char *v35; // r7
  int v36; // r3
  unsigned int v37; // r3
  const char *v38; // r2
  int v39; // r0
  int v40; // r11
  unsigned __int8 *v41; // r8
  int v42; // r0
  int v43; // r2
  const char *v44; // r2
  int v45; // [sp+Ch] [bp-34h]
  double endptr[6]; // [sp+10h] [bp-30h] BYREF

  v2 = (const void **)(a1 + 10);
  strbuffer_clear((int)(a1 + 10));
  if ( a1[15] == 256 )
  {
    jsonp_free(a1[16]);
    a1[16] = 0;
    a1[17] = 0;
  }
  do
  {
    part_3 = a1[5];
    if ( !part_3 )
      part_3 = stream_get_part_3((int)a1, a2);
    v6 = part_3 > 32;
    if ( part_3 != 32 )
      v6 = part_3 - 9 > 1;
    result = !v6;
  }
  while ( !v6 || part_3 == 13 );
  if ( part_3 == -1 )
    goto LABEL_36;
  if ( part_3 == -2 )
  {
LABEL_35:
    result = -1;
LABEL_36:
    a1[15] = result;
    return result;
  }
  strbuffer_append_byte(v2, part_3);
  if ( (((part_3 & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_50;
  v8 = part_3 == 44;
  if ( part_3 != 44 )
    v8 = part_3 == 58;
  v9 = v8;
  if ( v8 )
    goto LABEL_50;
  if ( part_3 == 34 )
  {
    a1[16] = v9;
    a1[15] = -1;
    while ( 1 )
    {
      v22 = a2;
      v23 = (int)a1;
      do
      {
        save = lex_get_save(v23, v22);
LABEL_60:
        switch ( save )
        {
          case 34u:
            v33 = jsonp_malloc(a1[11] + 1);
            v34 = (_BYTE *)v33;
            if ( !v33 )
              goto LABEL_73;
            a1[16] = v33;
            v35 = (const char *)(strbuffer_value((int)v2) + 1);
            while ( 1 )
            {
              while ( 1 )
              {
LABEL_95:
                v36 = *(unsigned __int8 *)v35;
                if ( v36 == 34 )
                {
                  *v34 = 0;
                  result = 256;
                  v43 = a1[16];
                  a1[15] = 256;
                  a1[17] = &v34[-v43];
                  return result;
                }
                if ( v36 == 92 )
                  break;
                *v34 = v36;
                ++v35;
                ++v34;
              }
              v37 = *((unsigned __int8 *)v35 + 1);
              if ( v37 != 117 )
                break;
              v39 = decode_unicode_escape((_BYTE *)v35 + 1);
              v40 = v39;
              if ( v39 < 0 )
              {
                error_set(a2, a1, "invalid Unicode escape '%.6s'", v35);
                goto LABEL_73;
              }
              v41 = (unsigned __int8 *)(v35 + 6);
              v45 = v39 - 55296;
              if ( (unsigned int)(v39 - 55296) >= 1024 )
              {
                if ( (unsigned int)(v39 - 56320) < 1024 )
                  goto LABEL_134;
              }
              else
              {
                if ( v35[6] != 92 || v35[7] != 117 )
                {
LABEL_134:
                  error_set(a2, a1, "invalid Unicode '\\u%04X'", v39);
                  goto LABEL_73;
                }
                v42 = decode_unicode_escape((_BYTE *)v35 + 7);
                if ( v42 < 0 )
                {
                  error_set(a2, a1, "invalid Unicode escape '%.6s'", v35 + 6);
                  goto LABEL_73;
                }
                v41 = (unsigned __int8 *)(v35 + 12);
                if ( (unsigned int)(v42 - 56320) >= 1024 )
                {
                  error_set(a2, a1, "invalid Unicode '\\u%04X\\u%04X'", v40, v42);
                  goto LABEL_73;
                }
                v40 = v42 - 56320 + (v45 << 10) + 65536;
              }
              if ( utf8_encode(v40, v34, endptr) )
                _assert_fail((const char *)&word_603C4, "compat/jansson-2.9/src/load.c", 475u, "lex_scan_string");
              v35 = (const char *)v41;
              v34 += LODWORD(endptr[0]);
            }
            if ( v37 == 98 )
            {
              *v34 = 8;
            }
            else
            {
              if ( v37 <= 98 )
              {
                if ( v37 != 47 && v37 != 92 && v37 != 34 )
LABEL_117:
                  _assert_fail((const char *)&word_603C4, "compat/jansson-2.9/src/load.c", 503u, "lex_scan_string");
                goto LABEL_128;
              }
              if ( v37 == 110 )
              {
                *v34 = 10;
              }
              else
              {
                if ( v37 <= 110 )
                {
                  if ( v37 != 102 )
                    goto LABEL_117;
                  *v34 = 12;
                  goto LABEL_106;
                }
                if ( v37 != 114 )
                {
                  if ( v37 != 116 )
                    goto LABEL_117;
                  *v34 = 9;
                  goto LABEL_106;
                }
                LOBYTE(v37) = 13;
LABEL_128:
                *v34 = v37;
              }
            }
LABEL_106:
            ++v34;
            v35 += 2;
            goto LABEL_95;
          case 4294967294u:
            goto LABEL_73;
          case 4294967295u:
            error_set(a2, a1, "premature end of input", 0);
            goto LABEL_73;
        }
        if ( save <= 31 )
        {
          lex_unget_unsave(a1, save);
          if ( save == 10 )
            LOWORD(v38) = -26088;
          else
            LOWORD(v38) = -26068;
          HIWORD(v38) = 6;
          error_set(a2, a1, v38, save);
          goto LABEL_73;
        }
        v22 = a2;
        v23 = (int)a1;
      }
      while ( save != 92 );
      v25 = lex_get_save((int)a1, a2);
      if ( v25 == 117 )
      {
        v28 = 4;
        save = lex_get_save((int)a1, a2);
        while ( 1 )
        {
          v29 = save & 0xFFFFFFDF;
          v30 = save - 48;
          v27 = v29 - 65;
          v31 = v27 > 5;
          if ( v27 > 5 )
            v31 = v30 > 9;
          if ( v31 )
            break;
          --v28;
          save = lex_get_save((int)a1, a2);
          if ( !v28 )
            goto LABEL_60;
        }
LABEL_72:
        error_set(a2, a1, "invalid escape", v27);
LABEL_73:
        jsonp_free(a1[16]);
        result = a1[15];
        a1[16] = 0;
        a1[17] = 0;
        return result;
      }
      v26 = v25 == 92;
      if ( v25 != 92 )
        v26 = (v25 & 0xFFFFFFBF) == 34;
      if ( !v26 && v25 != 47 && (v25 & 0xFFFFFFF7) != 102 )
      {
        v27 = (v25 - 114) & 0xFFFFFFFD;
        if ( v27 )
          goto LABEL_72;
      }
    }
  }
  v10 = part_3 > 45;
  if ( part_3 != 45 )
    v10 = part_3 - 48 > 9;
  if ( v10 )
  {
    if ( (part_3 & 0xFFFFFFDF) - 65 > 25 )
    {
      for ( i = *((_BYTE *)a1 + a1[4] + 8); i; i = *((_BYTE *)a1 + v14 + 8) )
      {
        strbuffer_append_byte(v2, i);
        v14 = a1[4] + 1;
        v15 = a1[9] + 1;
        a1[4] = v14;
        a1[9] = v15;
      }
    }
    else
    {
      do
        v11 = lex_get_save((int)a1, a2);
      while ( (v11 & 0xFFFFFFDF) - 65 <= 25 );
      lex_unget_unsave(a1, v11);
      v12 = (const char *)strbuffer_value((int)v2);
      if ( !strcmp(v12, "true") )
      {
        result = 259;
        a1[15] = 259;
        return result;
      }
      if ( !strcmp(v12, "false") )
      {
        result = 260;
        a1[15] = 260;
        return result;
      }
      if ( !strcmp(v12, "null") )
      {
        result = 261;
        a1[15] = 261;
        return result;
      }
    }
    goto LABEL_35;
  }
  a1[15] = -1;
  if ( part_3 == 45 )
    part_3 = lex_get_save((int)a1, a2);
  if ( part_3 == 48 )
  {
    v16 = lex_get_save((int)a1, a2);
    if ( (unsigned int)(v16 - 48) <= 9 )
      goto LABEL_92;
  }
  else
  {
    if ( part_3 - 48 > 9 )
    {
      lex_unget_unsave(a1, part_3);
      return a1[15];
    }
    do
      v16 = lex_get_save((int)a1, a2);
    while ( (unsigned int)(v16 - 48) <= 9 );
  }
  if ( (a1[13] & 8) != 0 )
    goto LABEL_52;
  v17 = v16 == 46;
  if ( v16 != 46 )
    v17 = v16 == 69;
  if ( v17 )
  {
LABEL_52:
    if ( v16 == 46 )
    {
      v32 = a1[5];
      if ( !v32 )
        v32 = stream_get_part_3((int)a1, a2);
      if ( (unsigned int)(v32 - 48) > 9 )
      {
        stream_unget(a1, v32);
        return a1[15];
      }
      strbuffer_append_byte(v2, v32);
      do
        v16 = lex_get_save((int)a1, a2);
      while ( (unsigned int)(v16 - 48) <= 9 );
    }
    if ( (v16 & 0xFFFFFFDF) != 69 )
      goto LABEL_54;
LABEL_74:
    v16 = lex_get_save((int)a1, a2);
    if ( ((v16 - 43) & 0xFFFFFFFD) == 0 )
      v16 = lex_get_save((int)a1, a2);
    if ( (unsigned int)(v16 - 48) <= 9 )
    {
      do
        v16 = lex_get_save((int)a1, a2);
      while ( (unsigned int)(v16 - 48) <= 9 );
LABEL_54:
      lex_unget_unsave(a1, v16);
      if ( jsonp_strtod((int)v2, endptr) )
      {
        error_set(a2, a1, "real number overflow");
        return a1[15];
      }
      else
      {
        v21 = endptr[0];
        result = 258;
        a1[15] = 258;
        *((double *)a1 + 8) = v21;
      }
      return result;
    }
LABEL_92:
    lex_unget_unsave(a1, v16);
    return a1[15];
  }
  if ( v16 == 101 )
    goto LABEL_74;
  lex_unget_unsave(a1, v16);
  v18 = (const char *)strbuffer_value((int)v2);
  v19 = _errno_location();
  *v19 = 0;
  v20 = strtoll(v18, (char **)endptr, 10);
  if ( *v19 != 34 )
  {
    if ( (const char *)LODWORD(endptr[0]) != &v18[a1[11]] )
      _assert_fail(
        "end == saved_text + lex->saved_text.length",
        "compat/jansson-2.9/src/load.c",
        585u,
        "lex_scan_number");
    part_3 = 257;
    *((_QWORD *)a1 + 8) = v20;
LABEL_50:
    result = part_3;
    a1[15] = part_3;
    return result;
  }
  if ( v20 >= 0 )
    LOWORD(v44) = -25908;
  else
    LOWORD(v44) = -25936;
  HIWORD(v44) = 6;
  error_set(a2, a1, v44, HIDWORD(v20));
  return a1[15];
}
// 603C4: using guessed type __int16 word_603C4;

//----- (00050554) --------------------------------------------------------
_DWORD *__fastcall parse_value(double a1, int a2)
{
  _DWORD *v2; // r4
  unsigned int v4; // r3
  int v5; // r3
  _DWORD *v6; // r6
  _DWORD *result; // r0
  int v8; // r8
  void *v9; // r7
  size_t v10; // r9
  int v11; // r3
  char *v12; // r9
  unsigned int v13; // r2
  _DWORD *v14; // r0
  _DWORD *v15; // r7
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int v19; // r3
  int v20; // r3
  int appended; // r0
  int v22; // r3
  bool v23; // zf
  int v24; // r3
  int v25; // r3
  _DWORD *v26; // r0
  int v27; // r3
  int v28; // r3
  int v29; // r3

  v2 = (_DWORD *)LODWORD(a1);
  v4 = *(_DWORD *)(LODWORD(a1) + 56) + 1;
  *(_DWORD *)(LODWORD(a1) + 56) = v4;
  if ( v4 > 2048 )
  {
    error_set(a2, (_DWORD *)LODWORD(a1), "maximum parsing depth reached");
    return 0;
  }
  v5 = *(_DWORD *)(LODWORD(a1) + 60);
  if ( v5 == 257 )
  {
    v6 = (_DWORD *)json_integer(*(_QWORD *)(LODWORD(a1) + 64));
    if ( !v6 )
      return 0;
    goto LABEL_18;
  }
  if ( v5 >= 258 )
  {
    if ( v5 == 259 )
    {
      v6 = json_true();
      if ( !v6 )
        return 0;
    }
    else if ( v5 <= 258 )
    {
      v6 = (_DWORD *)json_real(a1);
      if ( !v6 )
        return 0;
    }
    else
    {
      if ( v5 != 260 )
      {
        if ( v5 == 261 )
        {
          v6 = json_null();
          if ( !v6 )
            return 0;
          goto LABEL_18;
        }
        goto LABEL_60;
      }
      v6 = json_false();
      if ( !v6 )
        return 0;
    }
LABEL_18:
    result = v6;
    --v2[14];
    return result;
  }
  v8 = HIDWORD(a1);
  if ( v5 == 91 )
  {
    v6 = json_array();
    if ( !v6 )
      return 0;
    lex_scan(v2, a2);
    v20 = v2[15];
    if ( v20 == 93 )
      goto LABEL_18;
    if ( v20 )
    {
      while ( 1 )
      {
        v26 = (_DWORD *)parse_value(v2, v8, a2);
        v15 = v26;
        if ( !v26 )
          break;
        if ( v26[1] != -1 )
          ++v26[1];
        appended = json_array_append_new(v6, v26);
        v22 = v15[1];
        if ( appended )
        {
          if ( v22 != -1 )
          {
LABEL_69:
            v29 = v22 - 1;
            v15[1] = v29;
            if ( !v29 )
              json_delete(v15);
          }
          break;
        }
        v23 = v22 == -1;
        v24 = v22 - 1;
        if ( !v23 )
        {
          v15[1] = v24;
          if ( !v24 )
            json_delete(v15);
        }
        lex_scan(v2, a2);
        v25 = v2[15];
        if ( v25 != 44 )
        {
          if ( v25 == 93 )
            goto LABEL_18;
          goto LABEL_67;
        }
        lex_scan(v2, a2);
        if ( !v2[15] )
          goto LABEL_67;
      }
    }
    else
    {
LABEL_67:
      error_set(a2, v2, "']' expected");
    }
LABEL_57:
    v27 = v6[1];
    if ( v27 != -1 )
    {
      v28 = v27 - 1;
      v6[1] = v28;
      if ( !v28 )
        json_delete(v6);
    }
    return 0;
  }
  if ( v5 <= 91 )
  {
    if ( v5 == -1 )
    {
      error_set(a2, (_DWORD *)LODWORD(a1), "invalid token");
      return 0;
    }
    goto LABEL_60;
  }
  if ( v5 == 123 )
  {
    v6 = (_DWORD *)json_object();
    if ( !v6 )
      return 0;
    lex_scan(v2, a2);
    v11 = v2[15];
    if ( v11 == 125 )
      goto LABEL_18;
    if ( v11 == 256 )
    {
      v12 = (char *)v2[16];
      v13 = v2[17];
      v2[16] = 0;
      v2[17] = 0;
      if ( !v12 )
        return 0;
      while ( 1 )
      {
        if ( rpl_memchr((unsigned int)v12, 0, v13) )
        {
          jsonp_free((int)v12);
          error_set(a2, v2, "NUL byte in object key not supported");
          goto LABEL_57;
        }
        if ( (v8 & 1) != 0 && json_object_get(v6, v12) )
        {
          jsonp_free((int)v12);
          error_set(a2, v2, "duplicate object key");
          goto LABEL_57;
        }
        lex_scan(v2, a2);
        if ( v2[15] != 58 )
        {
          jsonp_free((int)v12);
          error_set(a2, v2, "':' expected");
          goto LABEL_57;
        }
        lex_scan(v2, a2);
        v14 = (_DWORD *)parse_value(v2, v8, a2);
        v15 = v14;
        if ( !v14 )
        {
          jsonp_free((int)v12);
          goto LABEL_57;
        }
        v16 = v14[1];
        if ( v16 != -1 )
          v14[1] = v16 + 1;
        if ( json_object_set_new_nocheck(v6, v12, v14) )
        {
          jsonp_free((int)v12);
          v22 = v15[1];
          if ( v22 != -1 )
            goto LABEL_69;
          goto LABEL_57;
        }
        v17 = v15[1];
        if ( v17 != -1 )
        {
          v18 = v17 - 1;
          v15[1] = v18;
          if ( !v18 )
            json_delete(v15);
        }
        jsonp_free((int)v12);
        lex_scan(v2, a2);
        v19 = v2[15];
        if ( v19 != 44 )
          break;
        lex_scan(v2, a2);
        if ( v2[15] != 256 )
          goto LABEL_72;
        v12 = (char *)v2[16];
        v13 = v2[17];
        v2[16] = 0;
        v2[17] = 0;
        if ( !v12 )
          return 0;
      }
      if ( v19 == 125 )
        goto LABEL_18;
      error_set(a2, v2, "'}' expected");
    }
    else
    {
LABEL_72:
      error_set(a2, v2, "string or '}' expected");
    }
    goto LABEL_57;
  }
  if ( v5 != 256 )
  {
LABEL_60:
    error_set(a2, (_DWORD *)LODWORD(a1), "unexpected token");
    return 0;
  }
  v9 = *(void **)(LODWORD(a1) + 64);
  v10 = *(_DWORD *)(LODWORD(a1) + 68);
  if ( (BYTE4(a1) & 0x10) != 0 || !rpl_memchr(*(_DWORD *)(LODWORD(a1) + 64), 0, *(_DWORD *)(LODWORD(a1) + 68)) )
  {
    v6 = jsonp_stringn_nocheck_own(v9, v10);
    if ( !v6 )
      return 0;
    v2[16] = 0;
    v2[17] = 0;
    goto LABEL_18;
  }
  error_set(a2, v2, "\\u0000 is not allowed without JSON_ALLOW_NUL");
  return 0;
}

//----- (000508D0) --------------------------------------------------------
int __fastcall parse_json(_DWORD *a1, unsigned int a2, int a3)
{
  _DWORD *v6; // r4
  int result; // r0
  int v8; // r3
  int v9; // r5

  a1[14] = 0;
  lex_scan(a1, a3);
  if ( (a2 & 4) != 0 || (a1[15] & 0xFFFFFFDF) == 91 )
  {
    v6 = parse_value(COERCE_DOUBLE(__PAIR64__(a2, (unsigned int)a1)), a3);
    if ( !v6 )
      return 0;
    if ( (a2 & 2) != 0 || (lex_scan(a1, a3), !a1[15]) )
    {
      result = (int)v6;
      if ( a3 )
        *(_DWORD *)(a3 + 8) = a1[9];
    }
    else
    {
      error_set(a3, a1, "end of file expected");
      v8 = v6[1];
      if ( v8 == -1 )
        return 0;
      v9 = v8 - 1;
      v6[1] = v8 - 1;
      if ( v8 != 1 )
        return 0;
      json_delete(v6);
      return v9;
    }
  }
  else
  {
    error_set(a3, a1, "'[' or '{' expected");
    return a2 & 4;
  }
  return result;
}

//----- (00050960) --------------------------------------------------------
int __fastcall json_loads(int a1, unsigned int a2, int a3)
{
  int v6; // r4
  int v8[2]; // [sp+0h] [bp-68h] BYREF
  int v9[2]; // [sp+8h] [bp-60h] BYREF
  char v10; // [sp+10h] [bp-58h]
  int v11; // [sp+18h] [bp-50h]
  int v12; // [sp+1Ch] [bp-4Ch]
  int v13; // [sp+20h] [bp-48h]
  int v14; // [sp+24h] [bp-44h]
  int v15; // [sp+2Ch] [bp-3Ch]
  _DWORD v16[14]; // [sp+30h] [bp-38h] BYREF

  jsonp_error_init(a3, "<string>");
  if ( a1 )
  {
    v8[0] = a1;
    v9[0] = (int)string_get;
    v8[1] = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v9[1] = (int)v8;
    v13 = 1;
    if ( strbuffer_init(v16) )
    {
      return 0;
    }
    else
    {
      v16[5] = -1;
      v16[3] = a2;
      v6 = parse_json(v9, a2, a3);
      lex_close(v9);
      return v6;
    }
  }
  else
  {
    error_set(a3, 0, "wrong arguments");
    return 0;
  }
}

//----- (000509E0) --------------------------------------------------------
int __fastcall json_loadb(int a1, int a2, unsigned int a3, int a4)
{
  int v8; // r4
  int v10[3]; // [sp+4h] [bp-6Ch] BYREF
  int v11[2]; // [sp+10h] [bp-60h] BYREF
  char v12; // [sp+18h] [bp-58h]
  int v13; // [sp+20h] [bp-50h]
  int v14; // [sp+24h] [bp-4Ch]
  int v15; // [sp+28h] [bp-48h]
  int v16; // [sp+2Ch] [bp-44h]
  int v17; // [sp+34h] [bp-3Ch]
  _DWORD v18[14]; // [sp+38h] [bp-38h] BYREF

  jsonp_error_init(a4, "<buffer>");
  if ( a1 )
  {
    v10[0] = a1;
    v10[1] = a2;
    v11[0] = (int)buffer_get;
    v10[2] = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v16 = 0;
    v17 = 0;
    v11[1] = (int)v10;
    v15 = 1;
    if ( strbuffer_init(v18) )
    {
      return 0;
    }
    else
    {
      v18[5] = -1;
      v18[3] = a3;
      v8 = parse_json(v11, a3, a4);
      lex_close(v11);
      return v8;
    }
  }
  else
  {
    error_set(a4, 0, "wrong arguments");
    return 0;
  }
}

//----- (00050A6C) --------------------------------------------------------
int __fastcall json_loadf(int a1, unsigned int a2, int a3)
{
  char *v5; // r1
  int v7; // r4
  int v9[2]; // [sp+0h] [bp-60h] BYREF
  char v10; // [sp+8h] [bp-58h]
  int v11; // [sp+10h] [bp-50h]
  int v12; // [sp+14h] [bp-4Ch]
  int v13; // [sp+18h] [bp-48h]
  int v14; // [sp+1Ch] [bp-44h]
  int v15; // [sp+24h] [bp-3Ch]
  _DWORD v16[14]; // [sp+28h] [bp-38h] BYREF

  if ( stdin == a1 )
    v5 = "<stdin>";
  else
    v5 = "<stream>";
  jsonp_error_init(a3, v5);
  if ( a1 )
  {
    v9[0] = (int)fgetc;
    v9[1] = a1;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( strbuffer_init(v16) )
    {
      return 0;
    }
    else
    {
      v16[5] = -1;
      v16[3] = a2;
      v7 = parse_json(v9, a2, a3);
      lex_close(v9);
      return v7;
    }
  }
  else
  {
    error_set(a3, 0, "wrong arguments");
    return 0;
  }
}
// 80B10: using guessed type int stdin;

//----- (00050B04) --------------------------------------------------------
int __fastcall json_load_file(char *a1, unsigned int a2, int a3)
{
  FILE *v6; // r0
  FILE *v7; // r6
  int v8; // r4
  int *v10; // r0
  char *v11; // r0

  jsonp_error_init(a3, a1);
  if ( a1 )
  {
    v6 = fopen(a1, "rb");
    v7 = v6;
    if ( v6 )
    {
      v8 = json_loadf((int)v6, a2, a3);
      fclose(v7);
      return v8;
    }
    else
    {
      v10 = _errno_location();
      v11 = strerror(*v10);
      error_set(a3, 0, "unable to open %s: %s", a1, v11);
      return 0;
    }
  }
  else
  {
    error_set(a3, 0, "wrong arguments");
    return 0;
  }
}

//----- (00050B78) --------------------------------------------------------
int __fastcall json_load_callback(int a1, int a2, unsigned int a3, int a4)
{
  int v8; // r4
  int v10[2]; // [sp+0h] [bp-470h] BYREF
  char v11; // [sp+8h] [bp-468h]
  int v12; // [sp+10h] [bp-460h]
  int v13; // [sp+14h] [bp-45Ch]
  int v14; // [sp+18h] [bp-458h]
  int v15; // [sp+1Ch] [bp-454h]
  int v16; // [sp+24h] [bp-44Ch]
  _DWORD v17[8]; // [sp+28h] [bp-448h] BYREF
  int s[266]; // [sp+48h] [bp-428h] BYREF

  memset(s, 0, 1040u);
  s[259] = a2;
  s[258] = a1;
  jsonp_error_init(a4, "<callback>");
  if ( a1 )
  {
    v10[0] = (int)callback_get;
    v14 = 1;
    v10[1] = (int)s;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v15 = 0;
    v16 = 0;
    if ( strbuffer_init(v17) )
    {
      return 0;
    }
    else
    {
      v17[5] = -1;
      v17[3] = a3;
      v8 = parse_json(v10, a3, a4);
      lex_close(v10);
      return v8;
    }
  }
  else
  {
    error_set(a4, 0, "wrong arguments");
    return 0;
  }
}

//----- (00050C10) --------------------------------------------------------
int __fastcall jsonp_malloc(int result)
{
  if ( result )
    return do_malloc();
  return result;
}
// 80AE8: using guessed type int (*do_malloc)(void);

//----- (00050C20) --------------------------------------------------------
int __fastcall jsonp_free(int result)
{
  if ( result )
    return do_free();
  return result;
}
// 80AEC: using guessed type int (*do_free)(void);

//----- (00050C30) --------------------------------------------------------
void *__fastcall jsonp_strndup(const void *a1, size_t a2)
{
  void *result; // r0
  void *v5; // r6

  if ( a2 == -1 )
    return 0;
  result = (void *)do_malloc(a2 + 1);
  v5 = result;
  if ( result )
  {
    memcpy(result, a1, a2);
    result = v5;
    *((_BYTE *)v5 + a2) = 0;
  }
  return result;
}
// 80AE8: using guessed type int (__fastcall *do_malloc)(_DWORD);

//----- (00050C64) --------------------------------------------------------
void *__fastcall jsonp_strdup(const char *a1)
{
  size_t v2; // r1

  v2 = strlen(a1);
  return jsonp_strndup(a1, v2);
}

//----- (00050C78) --------------------------------------------------------
int (__fastcall *__fastcall json_set_alloc_funcs(int (__fastcall *result)(_DWORD), int (*a2)(void)))(_DWORD)
{
  do_malloc = result;
  do_free = a2;
  return result;
}
// 80AE8: using guessed type int (__fastcall *do_malloc)(_DWORD);
// 80AEC: using guessed type int (*do_free)(void);

//----- (00050C88) --------------------------------------------------------
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = do_malloc;
  if ( a2 )
    *a2 = do_free;
  return result;
}
// 80AE8: using guessed type int (__fastcall *do_malloc)(_DWORD);
// 80AEC: using guessed type int (*do_free)(void);

//----- (00050CA8) --------------------------------------------------------
int set_error(int *a1, char *a2, char *format, ...)
{
  va_list varg_r3; // [sp+2Ch] [bp-4h] BYREF

  va_start(varg_r3, format);
  jsonp_error_vset(a1[14], a1[6], a1[7], a1[8], format, varg_r3);
  return jsonp_error_set_source(a1[14], a2);
}

//----- (00050CDC) --------------------------------------------------------
unsigned __int8 *__fastcall next_token(_DWORD *a1)
{
  unsigned __int8 **v1; // r5
  int v3; // r7
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  unsigned __int8 *v8; // r0
  int v9; // r2
  int v10; // r1
  int v11; // r3
  bool v12; // zf
  int v13; // r5
  int v14; // r6
  bool v15; // zf
  int v16; // t1
  bool v17; // zf
  int v18; // r2
  unsigned __int8 *result; // r0
  unsigned __int8 *v20; // r1
  unsigned __int8 *v21; // r2
  unsigned __int8 *v22; // r3

  v1 = (unsigned __int8 **)(a1 + 6);
  v3 = a1[10];
  v4 = a1[7];
  v5 = a1[8];
  v6 = a1[9];
  a1[2] = a1[6];
  a1[3] = v4;
  a1[4] = v5;
  a1[5] = v6;
  if ( v3 )
  {
    result = (unsigned __int8 *)a1[10];
    v20 = (unsigned __int8 *)a1[11];
    v21 = (unsigned __int8 *)a1[12];
    v22 = (unsigned __int8 *)a1[13];
    *v1 = result;
    v1[1] = v20;
    v1[2] = v21;
    v1[3] = v22;
    a1[10] = 0;
  }
  else
  {
    v7 = a1[18];
    v8 = (unsigned __int8 *)a1[1];
    v9 = a1[17] + 1;
    a1[17] = v9;
    v10 = v7 + 1;
    a1[18] = v10;
    v11 = *v8;
    v12 = v11 == 32;
    if ( v11 != 32 )
      v12 = v11 == 44;
    v13 = v12;
    if ( v11 == 58 )
      v13 |= 1u;
    if ( (unsigned int)(v11 - 9) <= 1 )
      v13 |= 1u;
    v14 = a1[16];
    if ( v13 )
    {
      do
      {
        v15 = v11 == 10;
        ++v10;
        if ( v11 == 10 )
        {
          ++v14;
          a1[17] = 1;
          a1[16] = v14;
        }
        else
        {
          v11 = a1[17];
        }
        if ( !v15 )
          ++v11;
        a1[18] = v10;
        if ( !v15 )
          a1[17] = v11;
        v16 = *++v8;
        v11 = v16;
        v17 = v16 == 44;
        if ( v16 != 44 )
          v17 = v11 == 32;
        v18 = v17;
        if ( v11 == 58 )
          v18 |= 1u;
        if ( (unsigned int)(v11 - 9) <= 1 )
          v18 |= 1u;
      }
      while ( v18 );
      v9 = a1[17];
    }
    result = v8 + 1;
    *((_BYTE *)a1 + 36) = v11;
    a1[1] = result;
    a1[6] = v14;
    a1[7] = v9;
    a1[8] = v10;
  }
  return result;
}

//----- (00050D94) --------------------------------------------------------
int __fastcall read_string(int a1, size_t **a2, const char *a3, unsigned int *a4, _DWORD *a5)
{
  _DWORD *v5; // r4
  _DWORD *v10; // r11
  int v11; // r1
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r10
  int v15; // r6
  bool v16; // zf
  int v17; // r1
  int v18; // r2
  int v19; // r3
  const char **v20; // r3
  const char *v21; // r6
  unsigned int v22; // r4
  int result; // r0
  int v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r1
  int v28; // r2
  int v29; // r3
  size_t v30; // r2
  size_t *v31; // r3
  char *v32; // r6
  int v33; // r3
  int v34; // r1
  int v35; // r2
  int v36; // r3
  int v37; // r1
  int v38; // r2
  int v39; // r3
  int v40; // [sp+4h] [bp-34h] BYREF
  unsigned int v41; // [sp+8h] [bp-30h]

  v5 = (_DWORD *)(a1 + 24);
  v10 = (_DWORD *)(a1 + 40);
  next_token((_DWORD *)a1);
  v11 = v5[1];
  v12 = v5[2];
  v13 = v5[3];
  v14 = (_DWORD *)(a1 + 8);
  v15 = *(unsigned __int8 *)(a1 + 36);
  *v10 = *v5;
  v10[1] = v11;
  v10[2] = v12;
  v10[3] = v13;
  v16 = (v15 & 0xF7) == 35;
  if ( (v15 & 0xF7) != 35 )
    v16 = v15 == 37;
  v17 = *(_DWORD *)(a1 + 12);
  v18 = *(_DWORD *)(a1 + 16);
  v19 = *(_DWORD *)(a1 + 20);
  *v5 = *v14;
  v5[1] = v17;
  v5[2] = v18;
  v5[3] = v19;
  if ( v16 )
  {
    strbuffer_init(&v40);
    do
    {
      v31 = (*a2)++;
      v32 = (char *)*v31;
      if ( !*v31 )
      {
        set_error((int *)a1, "<args>", "NULL string argument");
        strbuffer_close(&v40);
        return 0;
      }
      next_token((_DWORD *)a1);
      v33 = *(unsigned __int8 *)(a1 + 36);
      if ( v33 == 35 || v33 == 37 )
      {
        v30 = *(*a2)++;
      }
      else
      {
        v24 = v5[1];
        v25 = v5[2];
        v26 = v5[3];
        *v10 = *v5;
        v10[1] = v24;
        v10[2] = v25;
        v10[3] = v26;
        v27 = *(_DWORD *)(a1 + 12);
        v28 = *(_DWORD *)(a1 + 16);
        v29 = *(_DWORD *)(a1 + 20);
        *v5 = *v14;
        v5[1] = v27;
        v5[2] = v28;
        v5[3] = v29;
        v30 = strlen(v32);
      }
      if ( strbuffer_append_bytes((const void **)&v40, v32, v30) == -1 )
      {
        set_error((int *)a1, "<internal>", "Out of memory");
        strbuffer_close(&v40);
        return 0;
      }
      next_token((_DWORD *)a1);
    }
    while ( *(_BYTE *)(a1 + 36) == 43 );
    v34 = v5[1];
    v35 = v5[2];
    v36 = v5[3];
    *v10 = *v5;
    v10[1] = v34;
    v10[2] = v35;
    v10[3] = v36;
    v37 = *(_DWORD *)(a1 + 12);
    v38 = *(_DWORD *)(a1 + 16);
    v39 = *(_DWORD *)(a1 + 20);
    *v5 = *v14;
    v5[1] = v37;
    v5[2] = v38;
    v5[3] = v39;
    if ( utf8_check_string(v40, v41) )
    {
      *a4 = v41;
      *a5 = 1;
      return strbuffer_steal_value(&v40);
    }
    else
    {
      set_error((int *)a1, "<args>", "Invalid UTF-8 %s", a3);
      strbuffer_close(&v40);
      return 0;
    }
  }
  else
  {
    v20 = (const char **)(*a2)++;
    v21 = *v20;
    if ( *v20 )
    {
      v22 = strlen(*v20);
      if ( utf8_check_string((int)v21, v22) )
      {
        result = (int)v21;
        *a4 = v22;
        *a5 = 0;
      }
      else
      {
        set_error((int *)a1, "<args>", "Invalid UTF-8 %s", a3);
        return 0;
      }
    }
    else
    {
      set_error((int *)a1, "<args>", "NULL string argument");
      return 0;
    }
  }
  return result;
}

//----- (00050F3C) --------------------------------------------------------
int __fastcall unpack(double a1, _QWORD ***a2)
{
  __int64 v2; // d0
  double v4; // kr00_8
  _DWORD **v5; // r3
  _DWORD *v6; // r3
  int v7; // r3
  _DWORD **v9; // r3
  _DWORD *v10; // r9
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r1
  int v15; // r2
  int v16; // r3
  _DWORD *v17; // r0
  int v18; // r8
  int v19; // r5
  int v20; // r3
  bool v21; // zf
  bool v22; // r5
  int v23; // r0
  int v24; // r6
  char *v25; // r9
  char *v26; // r5
  int v27; // r0
  int v28; // r0
  int v29; // r0
  size_t v30; // r0
  _QWORD **v31; // r3
  _QWORD *v32; // r5
  int v33; // r5
  _DWORD **v34; // r2
  int v35; // r3
  _DWORD **v36; // r3
  int v37; // r8
  _DWORD *v38; // r9
  int v39; // r5
  bool v40; // zf
  bool v41; // r3
  int v42; // r3
  char *v43; // r0
  int v44; // r3
  __int64 **v45; // r3
  __int64 *v46; // r5
  __int64 v47; // r0
  _DWORD **v48; // r3
  _DWORD *v49; // r5
  int v50; // r0
  _QWORD **v51; // r3
  _QWORD *v52; // r5
  char *v53; // r2
  char *v54; // r1
  char **v55; // r3
  char *v56; // r10
  char v57; // r9
  char v58; // r9
  void *v60; // r0
  int v61; // r3
  _DWORD **v62; // r3
  _DWORD *v63; // r5
  _DWORD *v64; // r0
  int v65; // r3
  _DWORD *v66; // r0
  int v67; // r0
  char *v68; // r6
  int v69; // r5
  int v70; // r0
  int v71; // r0
  int v72; // r0
  size_t v73; // r0
  const char *v74; // r0
  int v75; // [sp+0h] [bp-50h]
  const void *v76[3]; // [sp+8h] [bp-48h] BYREF
  int v77[15]; // [sp+14h] [bp-3Ch] BYREF

  v4 = a1;
  switch ( *(_BYTE *)(LODWORD(a1) + 36) )
  {
    case 'F':
      if ( !HIDWORD(a1) )
        goto LABEL_115;
      if ( (unsigned int)(*(_DWORD *)HIDWORD(a1) - 3) > 1 )
      {
        set_error(
          (int *)LODWORD(a1),
          "<validation>",
          "Expected real or integer, got %s",
          (&type_names)[*(_DWORD *)HIDWORD(a1)]);
        return -1;
      }
      else
      {
        if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) != 0 )
          return 0;
        v31 = *a2;
        LODWORD(a1) = HIDWORD(a1);
        ++*a2;
        v32 = *v31;
        json_number_value(a1);
        v7 = 0;
        *v32 = v2;
      }
      return v7;
    case 'I':
      if ( !HIDWORD(a1) )
        goto LABEL_115;
      v44 = *(_DWORD *)HIDWORD(a1);
      if ( *(_DWORD *)HIDWORD(a1) != 3 )
        goto LABEL_141;
      if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) != 0 )
        return 0;
      v45 = (*a2)++;
      v46 = *v45;
      v47 = json_integer_value(SHIDWORD(a1));
      v7 = 0;
      *v46 = v47;
      return v7;
    case 'O':
      if ( !HIDWORD(a1) )
        goto LABEL_2;
      if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) != 0 )
        return 0;
      v35 = *(_DWORD *)(HIDWORD(a1) + 4);
      if ( v35 != -1 )
        *(_DWORD *)(HIDWORD(a1) + 4) = v35 + 1;
      v36 = (_DWORD **)(*a2)++;
      v6 = *v36;
LABEL_4:
      *v6 = HIDWORD(a1);
      return 0;
    case '[':
      if ( HIDWORD(a1) && *(_DWORD *)HIDWORD(a1) != 1 )
      {
        set_error((int *)LODWORD(a1), "<validation>", "Expected array, got %s", (&type_names)[*(_DWORD *)HIDWORD(a1)]);
        return -1;
      }
      v37 = 0;
      v38 = 0;
      next_token((_DWORD *)LODWORD(a1));
      while ( 2 )
      {
        v39 = *(unsigned __int8 *)(LODWORD(v4) + 36);
        if ( v39 == 93 )
        {
LABEL_71:
          if ( v37 )
          {
            v41 = v37 == 1;
          }
          else
          {
            if ( (*(_DWORD *)(LODWORD(v4) + 60) & 2) == 0 )
              return 0;
            v41 = 1;
          }
          if ( HIDWORD(v4) )
            v42 = v41;
          else
            v42 = 0;
          if ( v42 && v38 != json_array_size((_DWORD *)HIDWORD(v4)) )
          {
            v43 = (char *)json_array_size((_DWORD *)HIDWORD(v4));
            set_error((int *)LODWORD(v4), "<validation>", "%li array item(s) left unpacked", v43 - (char *)v38);
            return -1;
          }
          return 0;
        }
        while ( 1 )
        {
          if ( v37 )
          {
            if ( v37 == 1 )
              v61 = 33;
            else
              v61 = 42;
            set_error((int *)LODWORD(v4), "<format>", "Expected ']' after '%c', got '%c'", v61, v39);
            return -1;
          }
          if ( !v39 )
          {
            set_error((int *)LODWORD(v4), "<format>", "Unexpected end of format string");
            return -1;
          }
          v40 = v39 == 42;
          if ( v39 != 42 )
            v40 = v39 == 33;
          if ( !v40 )
            break;
          if ( v39 == 33 )
            v37 = 1;
          else
            v37 = -1;
          next_token((_DWORD *)LODWORD(v4));
          v39 = *(unsigned __int8 *)(LODWORD(v4) + 36);
          if ( v39 == 93 )
            goto LABEL_71;
        }
        if ( !strchr("{[siIbfFOon", v39) )
        {
          LOWORD(v53) = -25008;
          LOWORD(v54) = -25232;
LABEL_95:
          HIWORD(v53) = (unsigned int)"Unexpected format character '%c'" >> 16;
          HIWORD(v54) = (unsigned int)"<format>" >> 16;
          set_error((int *)LODWORD(v4), v54, v53);
          return -1;
        }
        if ( !HIDWORD(v4) || json_array_get((_DWORD *)HIDWORD(v4), (unsigned int)v38) )
        {
          if ( unpack(LODWORD(v4)) )
            return -1;
          v38 = (_DWORD *)((char *)v38 + 1);
          next_token((_DWORD *)LODWORD(v4));
          continue;
        }
        break;
      }
      set_error((int *)LODWORD(v4), "<validation>", "Array index %lu out of range", v38);
      return -1;
    case 'b':
      if ( !HIDWORD(a1) )
        goto LABEL_115;
      v33 = *(_DWORD *)HIDWORD(a1);
      if ( (unsigned int)(*(_DWORD *)HIDWORD(a1) - 5) > 1 )
      {
        set_error((int *)LODWORD(a1), "<validation>", "Expected true or false, got %s", (&type_names)[v33]);
        return -1;
      }
      else
      {
        v7 = *(_DWORD *)(LODWORD(a1) + 60) & 1;
        if ( v7 )
          return 0;
        v34 = (_DWORD **)(*a2)++;
        **v34 = v33 == 5;
      }
      return v7;
    case 'f':
      if ( !HIDWORD(a1) )
        goto LABEL_115;
      if ( *(_DWORD *)HIDWORD(a1) == 4 )
      {
        if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) != 0 )
          return 0;
        v51 = (*a2)++;
        v52 = *v51;
        json_real_value();
        v7 = 0;
        *v52 = v2;
      }
      else
      {
        set_error((int *)LODWORD(a1), "<validation>", "Expected real, got %s", (&type_names)[*(_DWORD *)HIDWORD(a1)]);
        return -1;
      }
      return v7;
    case 'i':
      if ( !HIDWORD(a1) )
      {
LABEL_115:
        if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) == 0 )
          ++*a2;
        return 0;
      }
      v44 = *(_DWORD *)HIDWORD(a1);
      if ( *(_DWORD *)HIDWORD(a1) == 3 )
      {
        if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) != 0 )
          return 0;
        v48 = (_DWORD **)(*a2)++;
        v49 = *v48;
        v50 = json_integer_value(SHIDWORD(a1));
        v7 = 0;
        *v49 = v50;
      }
      else
      {
LABEL_141:
        set_error((int *)LODWORD(a1), "<validation>", "Expected integer, got %s", (&type_names)[v44]);
        return -1;
      }
      return v7;
    case 'n':
      if ( !HIDWORD(a1) || *(_DWORD *)HIDWORD(a1) == 7 )
        return 0;
      set_error((int *)LODWORD(a1), "<validation>", "Expected null, got %s", (&type_names)[*(_DWORD *)HIDWORD(a1)]);
      return -1;
    case 'o':
LABEL_2:
      if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) == 0 )
      {
        v5 = (_DWORD **)(*a2)++;
        v6 = *v5;
        if ( HIDWORD(a1) )
          goto LABEL_4;
      }
      return 0;
    case 's':
      if ( HIDWORD(a1) && *(_DWORD *)HIDWORD(a1) != 2 )
      {
        set_error((int *)LODWORD(a1), "<validation>", "Expected string, got %s", (&type_names)[*(_DWORD *)HIDWORD(a1)]);
        return -1;
      }
      else
      {
        if ( (*(_DWORD *)(LODWORD(a1) + 60) & 1) != 0 )
          return 0;
        v9 = (_DWORD **)(*a2)++;
        v10 = *v9;
        if ( *v9 )
        {
          next_token((_DWORD *)LODWORD(a1));
          if ( *(_BYTE *)(LODWORD(v4) + 36) == 37 )
          {
            v62 = (_DWORD **)(*a2)++;
            v63 = *v62;
            if ( *v62 )
            {
              if ( !HIDWORD(v4) )
                return 0;
              *v10 = json_string_value((_DWORD *)HIDWORD(v4));
              v64 = json_string_length((_DWORD *)HIDWORD(v4));
              v7 = 0;
              *v63 = v64;
            }
            else
            {
              set_error((int *)LODWORD(v4), "<args>", "NULL string length argument");
              return -1;
            }
          }
          else
          {
            v11 = *(_DWORD *)(LODWORD(v4) + 28);
            v12 = *(_DWORD *)(LODWORD(v4) + 32);
            v13 = *(_DWORD *)(LODWORD(v4) + 36);
            *(_DWORD *)(LODWORD(v4) + 40) = *(_DWORD *)(LODWORD(v4) + 24);
            *(_DWORD *)(LODWORD(v4) + 44) = v11;
            *(_DWORD *)(LODWORD(v4) + 48) = v12;
            *(_DWORD *)(LODWORD(v4) + 52) = v13;
            v14 = *(_DWORD *)(LODWORD(v4) + 12);
            v15 = *(_DWORD *)(LODWORD(v4) + 16);
            v16 = *(_DWORD *)(LODWORD(v4) + 20);
            *(_DWORD *)(LODWORD(v4) + 24) = *(_DWORD *)(LODWORD(v4) + 8);
            *(_DWORD *)(LODWORD(v4) + 28) = v14;
            *(_DWORD *)(LODWORD(v4) + 32) = v15;
            *(_DWORD *)(LODWORD(v4) + 36) = v16;
            if ( !HIDWORD(v4) )
              return 0;
            v17 = json_string_value((_DWORD *)HIDWORD(v4));
            v7 = 0;
            *v10 = v17;
          }
        }
        else
        {
          set_error((int *)LODWORD(a1), "<args>", "NULL string argument");
          return -1;
        }
      }
      return v7;
    case '{':
      if ( hashtable_init(v77) )
      {
        set_error((int *)LODWORD(v4), "<internal>", "Out of memory");
        return -1;
      }
      if ( HIDWORD(v4) && *(_DWORD *)HIDWORD(v4) )
      {
        set_error((int *)LODWORD(v4), "<validation>", "Expected object, got %s", (&type_names)[*(_DWORD *)HIDWORD(v4)]);
        v19 = -1;
        goto LABEL_118;
      }
      v18 = 0;
      v19 = 0;
      next_token((_DWORD *)LODWORD(v4));
      while ( 1 )
      {
        v20 = *(unsigned __int8 *)(LODWORD(v4) + 36);
        if ( v20 == 125 )
          break;
        while ( 1 )
        {
          if ( v19 )
          {
            v75 = v20;
            if ( v19 == 1 )
              v65 = 33;
            else
              v65 = 42;
            v19 = -1;
            set_error((int *)LODWORD(v4), "<format>", "Expected '}' after '%c', got '%c'", v65, v75);
            goto LABEL_118;
          }
          if ( !v20 )
          {
            v19 = -1;
            set_error((int *)LODWORD(v4), "<format>", "Unexpected end of format string");
            goto LABEL_118;
          }
          v21 = v20 == 42;
          if ( v20 != 42 )
            v21 = v20 == 33;
          if ( !v21 )
            break;
          if ( v20 == 33 )
            v19 = 1;
          else
            v19 = -1;
          next_token((_DWORD *)LODWORD(v4));
          v20 = *(unsigned __int8 *)(LODWORD(v4) + 36);
          if ( v20 == 125 )
            goto LABEL_29;
        }
        if ( v20 != 115 )
        {
          v19 = -1;
          set_error((int *)LODWORD(v4), "<format>", "Expected format 's', got '%c'", v20);
          goto LABEL_118;
        }
        v55 = (char **)(*a2)++;
        v56 = *v55;
        if ( !*v55 )
        {
          v19 = -1;
          set_error((int *)LODWORD(v4), "<args>", "NULL object key");
          goto LABEL_118;
        }
        next_token((_DWORD *)LODWORD(v4));
        if ( *(_BYTE *)(LODWORD(v4) + 36) == 63 )
        {
          v18 = 1;
          next_token((_DWORD *)LODWORD(v4));
          v57 = 1;
        }
        else
        {
          v57 = 0;
        }
        if ( HIDWORD(v4) )
        {
          v58 = v57 ^ 1;
          if ( !json_object_get((_DWORD *)HIDWORD(v4), v56) && v58 & 1 )
          {
            set_error((int *)LODWORD(v4), "<validation>", "Object item not found: %s", v56);
            v19 = -1;
            goto LABEL_118;
          }
        }
        if ( unpack(LODWORD(v4)) )
        {
          v19 = -1;
LABEL_118:
          hashtable_close((int)v77);
          return v19;
        }
        v60 = json_null();
        hashtable_set(v77, v56, (int)v60);
        next_token((_DWORD *)LODWORD(v4));
      }
LABEL_29:
      if ( v19 )
      {
        v22 = v19 == 1;
      }
      else
      {
        if ( (*(_DWORD *)(LODWORD(v4) + 60) & 2) == 0 )
          goto LABEL_118;
        v22 = 1;
      }
      if ( HIDWORD(v4) )
        v19 = v22;
      else
        v19 = 0;
      if ( !v19 )
        goto LABEL_118;
      if ( v18 )
      {
        v23 = json_object_iter((_DWORD *)HIDWORD(v4));
        v24 = 0;
        v25 = 0;
        v26 = (char *)json_object_iter_key(v23);
        if ( v26 )
        {
          do
          {
            v29 = json_object_key_to_iter((int)v26);
            if ( !json_object_iter_value(v29) )
              break;
            if ( !hashtable_get((int)v77, v26) )
            {
              ++v25;
              if ( v24 )
                strbuffer_append_bytes(v76, ", ", 2u);
              else
                strbuffer_init(v76);
              v24 = 1;
              v30 = strlen(v26);
              strbuffer_append_bytes(v76, v26, v30);
            }
            v27 = json_object_key_to_iter((int)v26);
            v28 = json_object_iter_next((_DWORD *)HIDWORD(v4), v27);
            v26 = (char *)json_object_iter_key(v28);
          }
          while ( v26 );
          if ( v25 )
          {
LABEL_156:
            v19 = -1;
            v74 = (const char *)strbuffer_value((int)v76);
            set_error((int *)LODWORD(v4), "<validation>", "%li object item(s) left unpacked: %s", v25, v74);
            strbuffer_close((int *)v76);
            goto LABEL_118;
          }
        }
      }
      else
      {
        v66 = json_object_size((_DWORD *)HIDWORD(v4));
        v25 = (char *)v66 - v77[0];
        if ( v66 != (_DWORD *)v77[0] )
        {
          v67 = json_object_iter((_DWORD *)HIDWORD(v4));
          v68 = (char *)json_object_iter_key(v67);
          if ( v68 )
          {
            v69 = 0;
            do
            {
              v72 = json_object_key_to_iter((int)v68);
              if ( !json_object_iter_value(v72) )
                break;
              if ( !hashtable_get((int)v77, v68) )
              {
                if ( v69 )
                  strbuffer_append_bytes(v76, ", ", 2u);
                else
                  strbuffer_init(v76);
                v69 = 1;
                v73 = strlen(v68);
                strbuffer_append_bytes(v76, v68, v73);
              }
              v70 = json_object_key_to_iter((int)v68);
              v71 = json_object_iter_next((_DWORD *)HIDWORD(v4), v70);
              v68 = (char *)json_object_iter_key(v71);
            }
            while ( v68 );
          }
          goto LABEL_156;
        }
      }
      v19 = 0;
      goto LABEL_118;
    default:
      LOWORD(v53) = (unsigned __int16)"Unexpected format character '%c'";
      LOWORD(v54) = (unsigned __int16)"<format>";
      goto LABEL_95;
  }
}
// 51166: variable 'v2' is possibly undefined
// 69CA8: using guessed type char *type_names;

//----- (00051790) --------------------------------------------------------
_DWORD *__fastcall pack(double a1)
{
  double v1; // r4
  _DWORD *result; // r0
  int v3; // r3
  bool v4; // r7
  _DWORD *v5; // r6
  _DWORD *v6; // lr
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // r4
  int v12; // r1
  int v13; // r2
  int v14; // r3
  _DWORD **v15; // r3
  int v16; // r7
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  _DWORD *v23; // r7
  int v24; // r3
  char *v25; // r6
  _DWORD *v26; // r0
  __int64 *v27; // r3
  __int64 v28; // r0
  int v29; // r3
  bool v30; // r7
  _DWORD *v31; // r6
  _DWORD *v32; // lr
  int v33; // r0
  int v34; // r1
  int v35; // r2
  int v36; // r3
  _DWORD *v37; // r4
  int v38; // r1
  int v39; // r2
  int v40; // r3
  _DWORD *v41; // r3
  _DWORD *v42; // r3
  int v43; // r7
  int v44; // r2
  _DWORD *v45; // r6
  _DWORD *v46; // r0
  int v47; // r2
  int v48; // r0
  int v49; // r4
  int v50; // r0
  int v51; // r4
  size_t v52; // [sp+8h] [bp-28h] BYREF
  int v53[9]; // [sp+Ch] [bp-24h] BYREF

  v1 = a1;
  switch ( *(_BYTE *)(LODWORD(a1) + 36) )
  {
    case 'I':
      v27 = (__int64 *)((*(_DWORD *)HIDWORD(a1) + 7) & 0xFFFFFFF8);
      v28 = *v27;
      *(_DWORD *)HIDWORD(v1) = v27 + 1;
      return (_DWORD *)json_integer(v28);
    case 'O':
      next_token((_DWORD *)LODWORD(a1));
      v29 = *(unsigned __int8 *)(LODWORD(v1) + 36);
      v30 = v29 == 63;
      if ( v29 != 63 )
      {
        v31 = (_DWORD *)(LODWORD(v1) + 24);
        v32 = (_DWORD *)(LODWORD(v1) + 40);
        v33 = *(_DWORD *)(LODWORD(v1) + 24);
        v34 = *(_DWORD *)(LODWORD(v1) + 28);
        v35 = *(_DWORD *)(LODWORD(v1) + 32);
        v36 = *(_DWORD *)(LODWORD(v1) + 36);
        v37 = (_DWORD *)(LODWORD(v1) + 8);
        *v32 = v33;
        v32[1] = v34;
        v32[2] = v35;
        v32[3] = v36;
        v38 = v37[1];
        v39 = v37[2];
        v40 = v37[3];
        *v31 = *v37;
        v31[1] = v38;
        v31[2] = v39;
        v31[3] = v40;
      }
      v41 = (_DWORD *)*(_DWORD *)HIDWORD(v1);
      *(_DWORD *)HIDWORD(v1) += 4;
      v42 = (_DWORD *)*v41;
      if ( v42 )
        v43 = 0;
      else
        v43 = v30;
      if ( v43 )
        return json_null();
      if ( !v42 )
        return 0;
      v44 = v42[1];
      result = v42;
      if ( v44 != -1 )
        v42[1] = v44 + 1;
      return result;
    case '[':
      v45 = json_array();
      while ( 1 )
      {
        next_token((_DWORD *)LODWORD(v1));
        if ( *(_BYTE *)(LODWORD(v1) + 36) == 93 )
          return v45;
        if ( !*(_BYTE *)(LODWORD(v1) + 36) )
          break;
        v46 = (_DWORD *)pack(LODWORD(v1), HIDWORD(v1));
        if ( !v46 )
          goto LABEL_58;
        if ( json_array_append_new(v45, v46) )
        {
          set_error((int *)LODWORD(v1), "<internal>", "Unable to append to array");
          goto LABEL_58;
        }
      }
      set_error((int *)LODWORD(v1), "<format>", "Unexpected end of format string");
LABEL_58:
      if ( !v45 )
        return 0;
      v50 = v45[1];
      if ( v50 == -1 )
        return 0;
      v51 = v50 - 1;
      v45[1] = v50 - 1;
      if ( v50 != 1 )
        return 0;
      json_delete(v45);
      return (_DWORD *)v51;
    case 'b':
      v47 = **(_DWORD **)HIDWORD(a1);
      *(_DWORD *)HIDWORD(a1) += 4;
      if ( v47 )
        return json_true();
      else
        return json_false();
    case 'f':
      *(_DWORD *)HIDWORD(a1) = ((*(_DWORD *)HIDWORD(a1) + 7) & 0xFFFFFFF8) + 8;
      return (_DWORD *)json_real(a1);
    case 'i':
      LODWORD(a1) = **(_DWORD **)HIDWORD(a1);
      *(_DWORD *)HIDWORD(a1) += 4;
      return (_DWORD *)json_integer(SLODWORD(a1));
    case 'n':
      return json_null();
    case 'o':
      next_token((_DWORD *)LODWORD(a1));
      v3 = *(unsigned __int8 *)(LODWORD(v1) + 36);
      v4 = v3 == 63;
      if ( v3 != 63 )
      {
        v5 = (_DWORD *)(LODWORD(v1) + 24);
        v6 = (_DWORD *)(LODWORD(v1) + 40);
        v7 = *(_DWORD *)(LODWORD(v1) + 24);
        v8 = *(_DWORD *)(LODWORD(v1) + 28);
        v9 = *(_DWORD *)(LODWORD(v1) + 32);
        v10 = *(_DWORD *)(LODWORD(v1) + 36);
        v11 = (_DWORD *)(LODWORD(v1) + 8);
        *v6 = v7;
        v6[1] = v8;
        v6[2] = v9;
        v6[3] = v10;
        v12 = v11[1];
        v13 = v11[2];
        v14 = v11[3];
        *v5 = *v11;
        v5[1] = v12;
        v5[2] = v13;
        v5[3] = v14;
      }
      v15 = (_DWORD **)*(_DWORD *)HIDWORD(v1);
      *(_DWORD *)HIDWORD(v1) += 4;
      result = *v15;
      if ( *v15 )
        v16 = 0;
      else
        v16 = v4;
      if ( v16 )
        return json_null();
      return result;
    case 's':
      next_token((_DWORD *)LODWORD(a1));
      if ( *(_BYTE *)(LODWORD(v1) + 36) == 63 )
      {
        result = (_DWORD *)read_string(SLODWORD(v1), (size_t **)HIDWORD(v1), "string", &v52, v53);
        if ( !result )
          return json_null();
      }
      else
      {
        v17 = *(_DWORD *)(LODWORD(v1) + 28);
        v18 = *(_DWORD *)(LODWORD(v1) + 32);
        v19 = *(_DWORD *)(LODWORD(v1) + 36);
        *(_DWORD *)(LODWORD(v1) + 40) = *(_DWORD *)(LODWORD(v1) + 24);
        *(_DWORD *)(LODWORD(v1) + 44) = v17;
        *(_DWORD *)(LODWORD(v1) + 48) = v18;
        *(_DWORD *)(LODWORD(v1) + 52) = v19;
        v20 = *(_DWORD *)(LODWORD(v1) + 12);
        v21 = *(_DWORD *)(LODWORD(v1) + 16);
        v22 = *(_DWORD *)(LODWORD(v1) + 20);
        *(_DWORD *)(LODWORD(v1) + 24) = *(_DWORD *)(LODWORD(v1) + 8);
        *(_DWORD *)(LODWORD(v1) + 28) = v20;
        *(_DWORD *)(LODWORD(v1) + 32) = v21;
        *(_DWORD *)(LODWORD(v1) + 36) = v22;
        result = (_DWORD *)read_string(SLODWORD(v1), (size_t **)HIDWORD(v1), "string", &v52, v53);
        if ( !result )
          return result;
      }
      if ( v53[0] )
        return jsonp_stringn_nocheck_own(result, v52);
      else
        return json_stringn_nocheck(result, v52);
    case '{':
      v23 = (_DWORD *)json_object();
      next_token((_DWORD *)LODWORD(v1));
      v24 = *(unsigned __int8 *)(LODWORD(v1) + 36);
      if ( v24 == 125 )
        return v23;
      if ( !*(_BYTE *)(LODWORD(v1) + 36) )
        goto LABEL_66;
      if ( v24 != 115 )
        goto LABEL_67;
      break;
    default:
      set_error(
        (int *)LODWORD(a1),
        "<format>",
        "Unexpected format character '%c'",
        *(unsigned __int8 *)(LODWORD(a1) + 36));
      return 0;
  }
  while ( 1 )
  {
    v25 = (char *)read_string(SLODWORD(v1), (size_t **)HIDWORD(v1), "object key", &v52, v53);
    if ( !v25 )
      break;
    next_token((_DWORD *)LODWORD(v1));
    v26 = (_DWORD *)pack(LODWORD(v1), HIDWORD(v1));
    if ( !v26 )
      goto LABEL_51;
    if ( json_object_set_new_nocheck(v23, v25, v26) )
    {
      set_error((int *)LODWORD(v1), "<internal>", "Unable to add key \"%s\"", v25);
LABEL_51:
      if ( v53[0] )
        jsonp_free((int)v25);
      break;
    }
    if ( v53[0] )
      jsonp_free((int)v25);
    next_token((_DWORD *)LODWORD(v1));
    v24 = *(unsigned __int8 *)(LODWORD(v1) + 36);
    if ( v24 == 125 )
      return v23;
    if ( !*(_BYTE *)(LODWORD(v1) + 36) )
    {
LABEL_66:
      set_error((int *)LODWORD(v1), "<format>", "Unexpected end of format string");
      break;
    }
    if ( v24 != 115 )
    {
LABEL_67:
      set_error((int *)LODWORD(v1), "<format>", "Expected format 's', got '%c'", v24);
      break;
    }
  }
  if ( !v23 )
    return 0;
  v48 = v23[1];
  if ( v48 == -1 )
    return 0;
  v49 = v48 - 1;
  v23[1] = v48 - 1;
  if ( v48 != 1 )
    return 0;
  json_delete(v23);
  return (_DWORD *)v49;
}

//----- (00051B30) --------------------------------------------------------
_DWORD *__fastcall json_vpack_ex(int a1, int a2, _BYTE *a3, int a4)
{
  double v8; // r0
  _DWORD *v9; // r4
  _DWORD *result; // r0
  int v11; // r3
  int v12; // r3
  int v13; // [sp+8h] [bp-68h] BYREF
  int v14[9]; // [sp+Ch] [bp-64h] BYREF
  int v15; // [sp+30h] [bp-40h]
  int v16; // [sp+34h] [bp-3Ch]
  int v17; // [sp+38h] [bp-38h]
  int v18; // [sp+3Ch] [bp-34h]
  int v19; // [sp+40h] [bp-30h]
  int v20; // [sp+44h] [bp-2Ch]
  int v21; // [sp+48h] [bp-28h]
  int v22; // [sp+4Ch] [bp-24h]
  int v23; // [sp+50h] [bp-20h]
  int v24; // [sp+54h] [bp-1Ch]

  if ( !a3 || !*a3 )
  {
    jsonp_error_init(a1, "<format>");
    jsonp_error_set(a1, -1, -1, 0, "NULL or empty format string");
    return 0;
  }
  jsonp_error_init(a1, 0);
  v14[0] = (int)a3;
  v14[1] = (int)a3;
  memset(&v14[2], 0, 28);
  v16 = 0;
  v23 = 0;
  v24 = 0;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v22 = 1;
  v20 = a1;
  v21 = a2;
  next_token(v14);
  LODWORD(v8) = v14;
  v13 = a4;
  HIDWORD(v8) = &v13;
  v9 = pack(v8);
  if ( !v9 )
    return 0;
  next_token(v14);
  result = v9;
  if ( (_BYTE)v15 )
  {
    v11 = v9[1];
    if ( v11 != -1 )
    {
      v12 = v11 - 1;
      v9[1] = v12;
      if ( !v12 )
        json_delete(v9);
    }
    set_error(v14, "<format>", "Garbage after format string");
    return 0;
  }
  return result;
}

//----- (00051BF8) --------------------------------------------------------
_DWORD *json_pack_ex(int a1, int a2, _BYTE *a3, ...)
{
  va_list varg_r3; // [sp+14h] [bp-4h] BYREF

  va_start(varg_r3, a3);
  return json_vpack_ex(a1, a2, a3, (int)varg_r3);
}

//----- (00051C18) --------------------------------------------------------
_DWORD *json_pack(_BYTE *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp-Ch] BYREF

  va_start(varg_r1, a1);
  return json_vpack_ex(0, 0, a1, (int)varg_r1);
}

//----- (00051C3C) --------------------------------------------------------
int __fastcall json_vunpack_ex(int a1, int a2, int a3, _BYTE *a4, _QWORD **a5)
{
  double v9; // r0
  int v10; // r4
  _QWORD **v12; // [sp+8h] [bp-68h] BYREF
  int v13[9]; // [sp+Ch] [bp-64h] BYREF
  int v14; // [sp+30h] [bp-40h]
  int v15; // [sp+34h] [bp-3Ch]
  int v16; // [sp+38h] [bp-38h]
  int v17; // [sp+3Ch] [bp-34h]
  int v18; // [sp+40h] [bp-30h]
  int v19; // [sp+44h] [bp-2Ch]
  int v20; // [sp+48h] [bp-28h]
  int v21; // [sp+4Ch] [bp-24h]
  int v22; // [sp+50h] [bp-20h]
  int v23; // [sp+54h] [bp-1Ch]

  if ( a1 )
  {
    if ( a4 && *a4 )
    {
      jsonp_error_init(a2, 0);
      v13[0] = (int)a4;
      v13[1] = (int)a4;
      memset(&v13[2], 0, 28);
      v15 = 0;
      v22 = 0;
      v23 = 0;
      v14 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v21 = 1;
      v19 = a2;
      v20 = a3;
      next_token(v13);
      HIDWORD(v9) = a1;
      LODWORD(v9) = v13;
      v12 = a5;
      v10 = unpack(v9, &v12);
      if ( v10 )
      {
        return -1;
      }
      else
      {
        next_token(v13);
        if ( (_BYTE)v14 )
        {
          v10 = -1;
          set_error(v13, "<format>", "Garbage after format string");
        }
      }
    }
    else
    {
      v10 = -1;
      jsonp_error_init(a2, "<format>");
      jsonp_error_set(a2, -1, -1, 0, "NULL or empty format string");
    }
  }
  else
  {
    v10 = -1;
    jsonp_error_init(a2, "<root>");
    jsonp_error_set(a2, -1, -1, 0, "NULL root value");
  }
  return v10;
}

//----- (00051D2C) --------------------------------------------------------
int json_unpack_ex(int a1, int a2, int a3, _BYTE *a4, ...)
{
  va_list va; // [sp+20h] [bp+0h] BYREF

  va_start(va, a4);
  return json_vunpack_ex(a1, a2, a3, a4, (_QWORD **)va);
}

//----- (00051D4C) --------------------------------------------------------
int json_unpack(int a1, _BYTE *a2, ...)
{
  va_list varg_r2; // [sp+20h] [bp-8h] BYREF

  va_start(varg_r2, a2);
  return json_vunpack_ex(a1, 0, 0, a2, (_QWORD **)varg_r2);
}

//----- (00051D70) --------------------------------------------------------
int __fastcall strbuffer_init(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = (_BYTE *)jsonp_malloc(16);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (00051D90) --------------------------------------------------------
int __fastcall strbuffer_close(int *a1)
{
  int result; // r0

  result = *a1;
  if ( result )
    result = jsonp_free(result);
  a1[2] = 0;
  a1[1] = 0;
  *a1 = 0;
  return result;
}

//----- (00051DA8) --------------------------------------------------------
int __fastcall strbuffer_clear(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (00051DB4) --------------------------------------------------------
int __fastcall strbuffer_value(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00051DB8) --------------------------------------------------------
int __fastcall strbuffer_steal_value(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (00051DC4) --------------------------------------------------------
int __fastcall strbuffer_append_bytes(const void **a1, void *src, size_t n)
{
  size_t v4; // r3
  unsigned int v7; // r0
  char *v8; // r0
  int v9; // r5
  size_t v10; // r3
  char *v11; // r0
  char *v12; // r8
  char *v13; // r1
  int result; // r0
  size_t v15; // r7

  v4 = (size_t)a1[1];
  v7 = (unsigned int)a1[2];
  if ( v7 - v4 > n )
  {
    v8 = (char *)*a1;
LABEL_9:
    memcpy(&v8[v4], src, n);
    v13 = (char *)*a1;
    result = 0;
    v15 = (size_t)a1[1] + n;
    a1[1] = (const void *)v15;
    v13[v15] = 0;
    return result;
  }
  if ( !((n == -1) | (v7 >> 31)) && -2 - n >= v4 )
  {
    v9 = 2 * v7;
    v10 = v4 + 1 + n;
    if ( 2 * v7 < v10 )
      v9 = v10;
    v11 = (char *)jsonp_malloc(v9);
    v12 = v11;
    if ( v11 )
    {
      memcpy(v11, *a1, (size_t)a1[1]);
      jsonp_free((int)*a1);
      v4 = (size_t)a1[1];
      v8 = v12;
      *a1 = v12;
      a1[2] = (const void *)v9;
      goto LABEL_9;
    }
  }
  return -1;
}

//----- (00051E4C) --------------------------------------------------------
int __fastcall strbuffer_append_byte(const void **a1, char a2)
{
  char v3; // [sp+7h] [bp-9h] BYREF

  v3 = a2;
  return strbuffer_append_bytes(a1, &v3, 1u);
}

//----- (00051E64) --------------------------------------------------------
int __fastcall strbuffer_pop(int *a1)
{
  int v1; // r3
  int v2; // r2
  int v3; // r3
  int result; // r0

  v1 = a1[1];
  if ( !v1 )
    return 0;
  v2 = *a1;
  v3 = v1 - 1;
  a1[1] = v3;
  result = *(unsigned __int8 *)(v2 + v3);
  *(_BYTE *)(v2 + v3) = 0;
  return result;
}

//----- (00051E80) --------------------------------------------------------
int __fastcall jsonp_strtod(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-1Ch] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)a1) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "compat/jansson-2.9/src/strconv.c", 80u, "jsonp_strtod");
  if ( (v2 > 1.79769313e308 || v2 < -1.79769313e308) && *v9 == 34 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 51ECE: variable 'v2' is possibly undefined

//----- (00051F28) --------------------------------------------------------
int __fastcall jsonp_dtostr(char *a1, size_t a2, int a3)
{
  double v3; // d0
  int v4; // r3
  int v7; // r0
  int v8; // r4
  int v9; // r6
  int v10; // r1
  char *v11; // r0
  char *v12; // r0
  unsigned __int8 *v13; // r4
  int v14; // r3
  unsigned __int8 *v15; // r5
  int v16; // t1
  size_t v17; // r2

  if ( a3 )
    v4 = a3;
  else
    v4 = 17;
  v7 = snprintf(a1, a2, "%.*g", v4, v3);
  v8 = v7;
  if ( v7 >= 0 )
  {
    v9 = v7;
    if ( a2 > v7 )
    {
      v10 = *(unsigned __int8 *)localeconv()->decimal_point;
      if ( v10 != 46 )
      {
        v11 = strchr(a1, v10);
        if ( v11 )
          *v11 = 46;
      }
      if ( strchr(a1, 46) )
      {
LABEL_10:
        v12 = strchr(a1, 101);
        if ( !v12 )
          return v9;
        goto LABEL_11;
      }
      v12 = strchr(a1, 101);
      if ( v12 )
      {
LABEL_11:
        v13 = (unsigned __int8 *)(v12 + 2);
        v14 = (unsigned __int8)v12[2];
        if ( v12[1] != 45 )
        {
          v15 = (unsigned __int8 *)(v12 + 1);
          if ( v14 != 48 )
          {
LABEL_14:
            if ( v15 != v13 )
            {
              v17 = v9 - (v13 - (unsigned __int8 *)a1);
              v9 -= v13 - v15;
              memmove(v15, v13, v17);
            }
            return v9;
          }
          do
LABEL_13:
            v16 = *++v13;
          while ( v16 == 48 );
          goto LABEL_14;
        }
        if ( v14 == 48 )
        {
          v15 = (unsigned __int8 *)(v12 + 2);
          v13 = (unsigned __int8 *)(v12 + 3);
          if ( v12[3] != 48 )
            goto LABEL_14;
          goto LABEL_13;
        }
        return v9;
      }
      if ( a2 > v8 + 3 )
      {
        v9 = v8 + 2;
        a1[v8] = 46;
        a1[v8 + 1] = 48;
        a1[v8 + 2] = 0;
        goto LABEL_10;
      }
    }
  }
  return -1;
}
// 51F44: variable 'v3' is possibly undefined

//----- (00051FF0) --------------------------------------------------------
int __fastcall utf8_encode(int a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // r6
  int v4; // r5
  int v5; // r4
  char v6; // r3
  int result; // r0
  char v8; // r3

  if ( a1 >= 0 )
  {
    if ( a1 <= 127 )
    {
      *a2 = a1;
      result = 0;
      *a3 = 1;
      return result;
    }
    if ( a1 < 2048 )
    {
      a2[1] = (a1 & 0x3F) + -128;
      *a2 = (((unsigned int)a1 >> 6) & 0x1F) - 64;
      result = 0;
      *a3 = 2;
      return result;
    }
    if ( a1 < 65536 )
    {
      v8 = (a1 & 0x3F) + -128;
      *a2 = ((unsigned __int16)a1 >> 12) - 32;
      a2[1] = (((unsigned int)a1 >> 6) & 0x3F) + -128;
      result = 0;
      a2[2] = v8;
      *a3 = 3;
      return result;
    }
    if ( a1 < 1114112 )
    {
      v3 = ((unsigned int)a1 >> 18) & 7;
      v4 = ((unsigned int)a1 >> 12) & 0x3F;
      v5 = ((unsigned int)a1 >> 6) & 0x3F;
      v6 = (a1 & 0x3F) + -128;
      result = 0;
      *a2 = v3 - 16;
      a2[1] = v4 + -128;
      a2[2] = v5 + -128;
      a2[3] = v6;
      *a3 = 4;
      return result;
    }
  }
  return -1;
}

//----- (00052088) --------------------------------------------------------
int __fastcall utf8_check_first(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 65 )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 29u )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 15u )
    return 3;
  if ( (unsigned __int8)(a1 + 16) <= 4u )
    return 4;
  return 0;
}

//----- (000520C8) --------------------------------------------------------
int __fastcall utf8_check_full(char *a1, unsigned int a2, int *a3)
{
  char v3; // r5
  int v4; // r5
  int result; // r0
  int v6; // r3
  _BYTE *v7; // r0
  unsigned int v8; // r4
  int v9; // t1
  bool v10; // zf
  _BOOL4 v11; // r3
  _BOOL4 v12; // r1

  v3 = *a1;
  switch ( a2 )
  {
    case 2u:
      v4 = v3 & 0x1F;
      break;
    case 3u:
      v4 = v3 & 0xF;
      break;
    case 4u:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 63 )
    return 0;
  v7 = a1 + 1;
  v8 = 1;
  while ( 1 )
  {
    ++v8;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v8 )
      break;
    v9 = (unsigned __int8)*++v7;
    LOBYTE(v6) = v9;
    if ( (v9 ^ 0x80u) > 63 )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) < 2048 )
    return 0;
  v10 = v4 == 127;
  if ( v4 <= 127 )
    v10 = a2 == 2;
  result = v10;
  if ( v10 )
    return 0;
  v11 = a2 == 3;
  if ( v4 >= 2048 )
    v11 = 0;
  if ( !v11 )
  {
    v12 = a2 == 4;
    if ( v4 >= 65536 )
      v12 = 0;
    if ( !v12 )
    {
      if ( a3 )
        *a3 = v4;
      return 1;
    }
    return 0;
  }
  return result;
}

//----- (00052174) --------------------------------------------------------
char *__fastcall utf8_iterate(char *result, int a2, _DWORD *a3)
{
  char *v4; // r4
  unsigned int v5; // r0
  unsigned int v6; // r1
  int v7; // r2
  unsigned int v8; // r6
  int v9; // [sp+4h] [bp-14h] BYREF

  if ( !a2 )
    return result;
  v4 = result;
  v5 = utf8_check_first((unsigned __int8)*result);
  v8 = v5;
  if ( !v5 )
    return 0;
  if ( v5 == 1 )
  {
    v9 = v7;
    goto LABEL_7;
  }
  if ( v6 < v5 || !utf8_check_full(v4, v5, &v9) )
    return 0;
LABEL_7:
  if ( a3 )
    *a3 = v9;
  return &v4[v8];
}
// 5218E: variable 'v7' is possibly undefined
// 52194: variable 'v6' is possibly undefined

//----- (000521B8) --------------------------------------------------------
int __fastcall utf8_check_string(int a1, unsigned int a2)
{
  unsigned int i; // r4
  unsigned int v5; // r0
  unsigned int v6; // r5

  if ( !a2 )
    return 1;
  for ( i = 0; i < a2; ++i )
  {
    v5 = utf8_check_first(*(unsigned __int8 *)(a1 + i));
    v6 = v5;
    if ( !v5 )
      return 0;
    if ( v5 > 1 )
    {
      if ( v5 > a2 - i || !utf8_check_full((char *)(a1 + i), v5, 0) )
        return 0;
      i = i + v6 - 1;
    }
  }
  return 1;
}

//----- (00052210) --------------------------------------------------------
int __fastcall json_integer_copy(int a1)
{
  __int64 v1; // r4
  int result; // r0

  if ( a1 && *(_DWORD *)a1 == 3 )
    v1 = *(_QWORD *)(a1 + 8);
  else
    v1 = 0LL;
  result = jsonp_malloc(16);
  if ( result )
  {
    *(_QWORD *)(result + 8) = v1;
    *(_DWORD *)result = 3;
    *(_DWORD *)(result + 4) = 1;
  }
  return result;
}

//----- (0005223C) --------------------------------------------------------
void *__fastcall json_array_grow(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // r3
  void *result; // r0
  int v6; // r4
  const void *v7; // r7

  v3 = a1[2];
  if ( a1[3] + a2 <= v3 )
    return (void *)a1[4];
  v6 = a2 + v3;
  v7 = (const void *)a1[4];
  if ( a2 + v3 < 2 * v3 )
    v6 = 2 * v3;
  result = (void *)jsonp_malloc(4 * v6);
  if ( result )
  {
    a1[2] = v6;
    a1[4] = result;
    if ( a3 )
    {
      memcpy(result, v7, 4 * a1[3]);
      jsonp_free((int)v7);
      return (void *)a1[4];
    }
    else
    {
      return (void *)v7;
    }
  }
  return result;
}

//----- (00052284) --------------------------------------------------------
_DWORD *__fastcall string_create(void *a1, size_t a2, int a3)
{
  void *v4; // r5
  _DWORD *v5; // r4
  _DWORD *result; // r0

  if ( !a1 )
    return 0;
  if ( a3 )
  {
    v4 = a1;
    v5 = (_DWORD *)jsonp_malloc(16);
    if ( v5 )
      goto LABEL_5;
    return 0;
  }
  v4 = jsonp_strndup(a1, a2);
  if ( !v4 )
    return 0;
  v5 = (_DWORD *)jsonp_malloc(16);
  if ( v5 )
  {
LABEL_5:
    v5[2] = v4;
    result = v5;
    v5[3] = a2;
    *v5 = 2;
    v5[1] = 1;
    return result;
  }
  jsonp_free((int)v4);
  return 0;
}

//----- (000522D0) --------------------------------------------------------
int json_object()
{
  int result; // r0
  _DWORD *v1; // r4

  result = jsonp_malloc(40);
  v1 = (_DWORD *)result;
  if ( result )
  {
    if ( !hashtable_seed )
      json_object_seed(hashtable_seed);
    *v1 = 0;
    v1[1] = 1;
    if ( hashtable_init(v1 + 2) )
    {
      jsonp_free((int)v1);
      return 0;
    }
    else
    {
      v1[9] = 0;
      return (int)v1;
    }
  }
  return result;
}
// 80B828: using guessed type int hashtable_seed;

//----- (00052314) --------------------------------------------------------
_DWORD *__fastcall json_object_size(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (00052324) --------------------------------------------------------
int __fastcall json_object_get(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return hashtable_get((int)(a1 + 2), a2);
}

//----- (0005233C) --------------------------------------------------------
bool __fastcall json_equal_part_3(int a1, int a2)
{
  int v5; // r9
  int v6; // r0
  int v7; // r0
  char *v8; // r6
  int v9; // r7
  int v10; // r8
  int v11; // r7
  int v12; // r3
  unsigned int v13; // r6
  int v14; // r2
  int v15; // r0
  int v16; // r1
  bool v17; // zf
  size_t v18; // r2

  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return 0;
  if ( a1 != a2 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        if ( *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) )
          return 0;
        v5 = a1 + 8;
        v6 = hashtable_iter(a1 + 8);
        if ( !v6 )
          return 1;
        break;
      case 1:
        v11 = *(_DWORD *)(a1 + 12);
        if ( v11 != *(_DWORD *)(a2 + 12) )
          return 0;
        if ( !v11 )
          return 1;
        v12 = 1;
        v13 = 0;
        v14 = 1;
        while ( 2 )
        {
          if ( v14 == 1 && *(_DWORD *)(a1 + 12) > v13 )
            v15 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * v13);
          else
            v15 = 0;
          if ( v12 != 1 || *(_DWORD *)(a2 + 12) <= v13 )
            return 0;
          v16 = *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4 * v13);
          v17 = v16 == 0;
          if ( v16 )
            v17 = v15 == 0;
          if ( v17 || !json_equal_part_3(v15) )
            return 0;
          if ( v11 != ++v13 )
          {
            v14 = *(_DWORD *)a1;
            v12 = *(_DWORD *)a2;
            continue;
          }
          break;
        }
        return 1;
      case 2:
        v18 = *(_DWORD *)(a1 + 12);
        return v18 == *(_DWORD *)(a2 + 12) && !memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v18);
      case 3:
        return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8);
      case 4:
        return *(double *)(a1 + 8) == *(double *)(a2 + 8);
      default:
        return 0;
    }
    while ( 1 )
    {
      v7 = hashtable_iter_key(v6);
      v8 = (char *)v7;
      v9 = v7 - 16;
      if ( !v7 )
        break;
      v10 = hashtable_iter_value(v7 - 16);
      if ( !v10 )
        break;
      if ( !json_object_get((_DWORD *)a2, v8) || !json_equal_part_3(v10) )
        return 0;
      if ( !*(_DWORD *)a1 )
      {
        v6 = hashtable_iter_next(v5, v9);
        if ( v6 )
          continue;
      }
      return 1;
    }
  }
  return 1;
}

//----- (00052458) --------------------------------------------------------
int __fastcall json_object_del(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return -1;
  else
    return hashtable_del(a1 + 2, a2);
}

//----- (00052470) --------------------------------------------------------
int __fastcall json_object_clear(_DWORD *a1)
{
  if ( !a1 )
    return -1;
  if ( *a1 )
    return -1;
  hashtable_clear(a1 + 2);
  return 0;
}

//----- (00052490) --------------------------------------------------------
int __fastcall json_object_iter(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return hashtable_iter((int)(a1 + 2));
}

//----- (000524A0) --------------------------------------------------------
int __fastcall json_object_iter_at(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return hashtable_iter_at((int)(a1 + 2), a2);
}

//----- (000524B8) --------------------------------------------------------
int __fastcall json_object_iter_next(_DWORD *a1, int a2)
{
  _BOOL4 v2; // r3

  if ( !a1 )
    return 0;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 )
    return 0;
  else
    return hashtable_iter_next((int)(a1 + 2), a2);
}

//----- (000524D8) --------------------------------------------------------
int __fastcall json_object_iter_key(int a1)
{
  if ( a1 )
    return hashtable_iter_key(a1);
  return a1;
}

//----- (000524E0) --------------------------------------------------------
int __fastcall json_object_iter_value(int a1)
{
  if ( a1 )
    return hashtable_iter_value(a1);
  return a1;
}

//----- (000524E8) --------------------------------------------------------
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, int a3)
{
  bool v3; // zf
  int v4; // r4

  if ( !a1 || *a1 )
    return -1;
  v3 = a3 == 0;
  if ( a3 )
    v3 = a2 == 0;
  v4 = v3;
  if ( v3 )
    return -1;
  hashtable_iter_set(a2, a3);
  return v4;
}

//----- (00052518) --------------------------------------------------------
int __fastcall json_object_key_to_iter(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (00052520) --------------------------------------------------------
_DWORD *json_array()
{
  _DWORD *result; // r0
  int v1; // r4
  int v2; // r5

  result = (_DWORD *)jsonp_malloc(24);
  v1 = (int)result;
  if ( result )
  {
    *result = 1;
    result[1] = 1;
    result[3] = 0;
    result[2] = 8;
    v2 = jsonp_malloc(32);
    *(_DWORD *)(v1 + 16) = v2;
    if ( v2 )
    {
      *(_DWORD *)(v1 + 20) = 0;
      return (_DWORD *)v1;
    }
    else
    {
      jsonp_free(v1);
      return 0;
    }
  }
  return result;
}

//----- (00052558) --------------------------------------------------------
_DWORD *__fastcall json_array_size(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (0005256C) --------------------------------------------------------
_DWORD *__fastcall json_array_get(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (00052588) --------------------------------------------------------
int __fastcall json_array_extend(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v2; // r3
  size_t v5; // r2
  char *v6; // r1
  char *v7; // r5
  int v8; // r4
  int v9; // t1
  int result; // r0

  if ( !a1 )
    return -1;
  v2 = a2 == 0;
  if ( *a1 != 1 )
    v2 = 1;
  if ( v2 || *a2 != 1 || !json_array_grow(a1, a2[3], 1) )
    return -1;
  v5 = a2[3];
  v6 = (char *)a2[4];
  if ( v5 )
  {
    v5 *= 4;
    v7 = (char *)a2[4];
    do
    {
      v9 = *(_DWORD *)v7;
      v7 += 4;
      v8 = v9;
      if ( v9 )
      {
        if ( *(_DWORD *)(v8 + 4) != -1 )
          ++*(_DWORD *)(v8 + 4);
      }
    }
    while ( v7 != &v6[v5] );
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), v6, v5);
  result = 0;
  a1[3] += a2[3];
  return result;
}

//----- (00052604) --------------------------------------------------------
const char *__fastcall json_string_nocheck(const char *result)
{
  char *v1; // r4
  size_t v2; // r1

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)string_create(v1, v2, 0);
  }
  return result;
}

//----- (0005261C) --------------------------------------------------------
_DWORD *__fastcall json_stringn_nocheck(void *a1, size_t a2)
{
  return string_create(a1, a2, 0);
}

//----- (00052620) --------------------------------------------------------
_DWORD *__fastcall jsonp_stringn_nocheck_own(void *a1, size_t a2)
{
  return string_create(a1, a2, 1);
}

//----- (00052624) --------------------------------------------------------
_DWORD *__fastcall json_stringn(void *a1, size_t a2)
{
  if ( !a1 )
    return 0;
  if ( utf8_check_string((int)a1, a2) )
    return string_create(a1, a2, 0);
  return 0;
}

//----- (00052648) --------------------------------------------------------
const char *__fastcall json_string(const char *result)
{
  char *v1; // r4
  size_t v2; // r1

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)json_stringn(v1, v2);
  }
  return result;
}

//----- (00052660) --------------------------------------------------------
_DWORD *__fastcall json_string_value(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (00052670) --------------------------------------------------------
_DWORD *__fastcall json_string_length(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00052684) --------------------------------------------------------
int __fastcall json_string_setn_nocheck(_DWORD *a1, const void *a2, size_t a3)
{
  void *v6; // r7
  int result; // r0

  if ( !a1 )
    return -1;
  if ( *a1 != 2 || a2 == 0 )
    return -1;
  v6 = jsonp_strndup(a2, a3);
  if ( !v6 )
    return -1;
  jsonp_free(a1[2]);
  result = 0;
  a1[2] = v6;
  a1[3] = a3;
  return result;
}

//----- (000526C8) --------------------------------------------------------
int __fastcall json_string_set_nocheck(_DWORD *a1, char *s)
{
  size_t v4; // r0

  if ( !s )
    return -1;
  v4 = strlen(s);
  return json_string_setn_nocheck(a1, s, v4);
}

//----- (000526EC) --------------------------------------------------------
int __fastcall json_string_setn(_DWORD *a1, const void *a2, size_t a3)
{
  if ( !a2 )
    return -1;
  if ( utf8_check_string((int)a2, a3) )
    return json_string_setn_nocheck(a1, a2, a3);
  return -1;
}

//----- (0005271C) --------------------------------------------------------
int __fastcall json_string_set(_DWORD *a1, char *s)
{
  size_t v4; // r0

  if ( !s )
    return -1;
  v4 = strlen(s);
  return json_string_setn(a1, s, v4);
}

//----- (00052740) --------------------------------------------------------
int __fastcall json_integer(__int64 a1)
{
  int result; // r0

  result = jsonp_malloc(16);
  if ( result )
  {
    *(_QWORD *)(result + 8) = a1;
    *(_DWORD *)result = 3;
    *(_DWORD *)(result + 4) = 1;
  }
  return result;
}

//----- (0005275C) --------------------------------------------------------
__int64 __fastcall json_integer_value(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0LL;
}

//----- (00052770) --------------------------------------------------------
int __fastcall json_integer_set(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (00052788) --------------------------------------------------------
int __fastcall json_real(double a1)
{
  __int64 v1; // d0
  double v2; // r0
  int result; // r0

  LODWORD(v2) = _isnan(a1);
  if ( LODWORD(v2) )
    return 0;
  if ( _isinf(v2) )
    return 0;
  result = jsonp_malloc(16);
  if ( result )
  {
    *(_QWORD *)(result + 8) = v1;
    *(_DWORD *)result = 4;
    *(_DWORD *)(result + 4) = 1;
  }
  return result;
}
// 5279E: variable 'v2' is possibly undefined
// 527B0: variable 'v1' is possibly undefined

//----- (000527D0) --------------------------------------------------------
void json_real_value()
{
  ;
}

//----- (000527F0) --------------------------------------------------------
int __fastcall json_real_set(double a1)
{
  __int64 v1; // d0
  int v2; // r4
  double v3; // r0
  int result; // r0

  if ( !LODWORD(a1) || *(_DWORD *)LODWORD(a1) != 4 )
    return -1;
  v2 = LODWORD(a1);
  LODWORD(v3) = _isnan(a1);
  if ( LODWORD(v3) )
    return -1;
  result = _isinf(v3);
  if ( result )
    return -1;
  *(_QWORD *)(v2 + 8) = v1;
  return result;
}
// 5280A: variable 'v3' is possibly undefined
// 52810: variable 'v1' is possibly undefined

//----- (00052824) --------------------------------------------------------
int __fastcall json_number_value(double a1)
{
  if ( LODWORD(a1) && *(_DWORD *)LODWORD(a1) == 3 )
    a1 = (double)*(__int64 *)(LODWORD(a1) + 8);
  return LODWORD(a1);
}

//----- (00052860) --------------------------------------------------------
void *json_true()
{
  return &the_true_7785;
}

//----- (0005286C) --------------------------------------------------------
void *json_false()
{
  return &the_false_7789;
}

//----- (00052874) --------------------------------------------------------
void *json_null()
{
  return &the_null_7793;
}

//----- (0005287C) --------------------------------------------------------
_DWORD *__fastcall json_delete(_DWORD *result)
{
  int v1; // r4
  unsigned int v2; // r2
  unsigned int v3; // r5
  int v4; // r1
  int v5; // r0
  int v6; // r3
  bool v7; // zf
  int v8; // r3

  if ( result )
  {
    v1 = (int)result;
    switch ( *result )
    {
      case 0:
        hashtable_close((int)(result + 2));
        result = (_DWORD *)jsonp_free(v1);
        break;
      case 1:
        v2 = result[3];
        v3 = 0;
        v4 = result[4];
        while ( v3 < v2 )
        {
          v5 = *(_DWORD *)(v4 + 4 * v3++);
          if ( v5 )
          {
            v6 = *(_DWORD *)(v5 + 4);
            v7 = v6 == -1;
            v8 = v6 - 1;
            if ( !v7 )
            {
              *(_DWORD *)(v5 + 4) = v8;
              if ( !v8 )
              {
                json_delete();
                v4 = *(_DWORD *)(v1 + 16);
                v2 = *(_DWORD *)(v1 + 12);
              }
            }
          }
        }
        jsonp_free(v4);
        result = (_DWORD *)jsonp_free(v1);
        break;
      case 2:
        jsonp_free(result[2]);
        result = (_DWORD *)jsonp_free(v1);
        break;
      case 3:
      case 4:
        result = (_DWORD *)jsonp_free((int)result);
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (000528FC) --------------------------------------------------------
int __fastcall json_array_clear(_DWORD *a1)
{
  unsigned int v1; // r2
  unsigned int i; // r4
  _DWORD *v4; // r0
  int v5; // r3
  bool v6; // zf
  int v7; // r3
  int result; // r0

  if ( !a1 )
    return -1;
  if ( *a1 != 1 )
    return -1;
  v1 = a1[3];
  for ( i = 0; v1 > i; ++i )
  {
    v4 = *(_DWORD **)(a1[4] + 4 * i);
    if ( v4 )
    {
      v5 = v4[1];
      v6 = v5 == -1;
      v7 = v5 - 1;
      if ( !v6 )
      {
        v4[1] = v7;
        if ( !v7 )
        {
          json_delete(v4);
          v1 = a1[3];
        }
      }
    }
  }
  result = 0;
  a1[3] = 0;
  return result;
}

//----- (00052944) --------------------------------------------------------
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // r2
  int v5; // r6
  _DWORD *v6; // r0
  int v7; // r3
  int v8; // r3
  unsigned int v9; // r2
  int result; // r0

  if ( !a1 )
    return -1;
  if ( *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 <= a2 )
    return -1;
  v5 = 4 * a2;
  v6 = *(_DWORD **)(a1[4] + 4 * a2);
  if ( !v6 || (v7 = v6[1], v7 == -1) || (v8 = v7 - 1, (v6[1] = v8) != 0) )
  {
    v9 = v2 - 1;
    if ( a2 >= v9 )
    {
LABEL_8:
      a1[3] = v9;
      return 0;
    }
  }
  else
  {
    json_delete(v6);
    v9 = a1[3] - 1;
    if ( a2 >= v9 )
      goto LABEL_8;
  }
  memmove((void *)(a1[4] + v5), (const void *)(v5 + 4 + a1[4]), 4 * (v9 - a2));
  result = 0;
  --a1[3];
  return result;
}

//----- (000529A8) --------------------------------------------------------
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  _BOOL4 v5; // r3
  int v6; // r3
  int v7; // r6
  _DWORD *v8; // r0
  _DWORD *v9; // r3
  int v10; // r2
  int v11; // r2
  int result; // r0
  int v13; // r3
  int v14; // r3

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_12;
  v5 = a3 == a1;
  if ( *a1 != 1 )
    v5 = 1;
  if ( v5 || a1[3] <= a2 )
  {
LABEL_12:
    v13 = a3[1];
    if ( v13 != -1 )
    {
      v14 = v13 - 1;
      a3[1] = v14;
      if ( !v14 )
        json_delete(a3);
    }
    return -1;
  }
  else
  {
    v6 = a1[4];
    v7 = 4 * a2;
    v8 = *(_DWORD **)(v6 + 4 * a2);
    v9 = (_DWORD *)(v6 + 4 * a2);
    if ( !v8 || (v10 = v8[1], v10 == -1) || (v11 = v10 - 1, (v8[1] = v11) != 0) )
    {
      result = 0;
      *v9 = a3;
    }
    else
    {
      json_delete(v8);
      result = 0;
      *(_DWORD *)(a1[4] + v7) = a3;
    }
  }
  return result;
}

//----- (00052A18) --------------------------------------------------------
int __fastcall json_array_insert_new(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  int v6; // r2
  char *v7; // r7
  char *v8; // r0
  int v9; // r8
  int result; // r0
  int v11; // r3
  int v12; // r3
  int v13; // r3
  int v14; // r0

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_11;
  v6 = a3 == a1;
  if ( *a1 != 1 )
    v6 |= 1u;
  if ( !v6 && a1[3] >= a2 && (v7 = (char *)json_array_grow(a1, 1, 0)) != 0 )
  {
    v8 = (char *)a1[4];
    if ( v7 == v8 )
    {
      v14 = 4 * (a2 + 1);
      v9 = v14 - 4;
      memmove(&v7[v14], &v7[v14 - 4], 4 * (a1[3] - a2));
    }
    else
    {
      v9 = 4 * a2;
      memcpy(v8, v7, 4 * a2);
      memcpy((void *)(v9 + 4 + a1[4]), &v7[v9], 4 * (a1[3] - a2));
      jsonp_free((int)v7);
    }
    result = 0;
    v11 = a1[3] + 1;
    *(_DWORD *)(a1[4] + v9) = a3;
    a1[3] = v11;
  }
  else
  {
LABEL_11:
    v12 = a3[1];
    if ( v12 != -1 )
    {
      v13 = v12 - 1;
      a3[1] = v13;
      if ( !v13 )
        json_delete(a3);
    }
    return -1;
  }
  return result;
}

//----- (00052AC8) --------------------------------------------------------
int __fastcall json_object_set_new_nocheck(_DWORD *a1, char *a2, _DWORD *a3)
{
  bool v3; // zf
  _BOOL4 v5; // r3
  int result; // r0
  int v7; // r3
  int v8; // r3

  if ( !a3 )
    return -1;
  v3 = a1 == 0;
  if ( a1 )
    v3 = a2 == 0;
  if ( v3 )
    goto LABEL_9;
  v5 = a3 == a1;
  if ( *a1 )
    v5 = 1;
  if ( v5 || (result = hashtable_set(a1 + 2, a2, (int)a3)) != 0 )
  {
LABEL_9:
    v7 = a3[1];
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      a3[1] = v8;
      if ( !v8 )
        json_delete(a3);
    }
    return -1;
  }
  return result;
}

//----- (00052B14) --------------------------------------------------------
int __fastcall json_object_update(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v2; // r3
  int v3; // r8
  int v6; // r0
  int v7; // r0
  char *v8; // r4
  int v9; // r5
  _DWORD *v10; // r0

  if ( !a1 )
    return -1;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 || *a2 )
    return -1;
  v3 = (int)(a2 + 2);
  v6 = hashtable_iter((int)(a2 + 2));
  if ( v6 )
  {
    while ( 1 )
    {
      v7 = hashtable_iter_key(v6);
      v8 = (char *)v7;
      v9 = v7 - 16;
      if ( !v7 )
        break;
      v10 = (_DWORD *)hashtable_iter_value(v7 - 16);
      if ( !v10 )
        break;
      if ( v10[1] != -1 )
        ++v10[1];
      if ( json_object_set_new_nocheck(a1, v8, v10) )
        return -1;
      if ( !*a2 )
      {
        v6 = hashtable_iter_next(v3, v9);
        if ( v6 )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (00052B94) --------------------------------------------------------
int __fastcall json_object_update_existing(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v2; // r3
  int v3; // r9
  int i; // r0
  int v7; // r0
  char *v8; // r4
  int v9; // r6
  _DWORD *v10; // r5

  if ( !a1 )
    return -1;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 || *a2 )
    return -1;
  v3 = (int)(a2 + 2);
  for ( i = hashtable_iter((int)(a2 + 2)); i; i = hashtable_iter_next(v3, v9) )
  {
    v7 = hashtable_iter_key(i);
    v8 = (char *)v7;
    v9 = v7 - 16;
    if ( !v7 )
      break;
    v10 = (_DWORD *)hashtable_iter_value(v7 - 16);
    if ( !v10 )
      break;
    if ( json_object_get(a1, v8) )
    {
      if ( v10[1] != -1 )
        ++v10[1];
      json_object_set_new_nocheck(a1, v8, v10);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00052C20) --------------------------------------------------------
int __fastcall json_object_update_missing(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v2; // r3
  int v3; // r9
  int i; // r0
  int v7; // r0
  char *v8; // r4
  int v9; // r5
  _DWORD *v10; // r6

  if ( !a1 )
    return -1;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 || *a2 )
    return -1;
  v3 = (int)(a2 + 2);
  for ( i = hashtable_iter((int)(a2 + 2)); i; i = hashtable_iter_next(v3, v9) )
  {
    v7 = hashtable_iter_key(i);
    v8 = (char *)v7;
    v9 = v7 - 16;
    if ( !v7 )
      break;
    v10 = (_DWORD *)hashtable_iter_value(v7 - 16);
    if ( !v10 )
      break;
    if ( !json_object_get(a1, v8) )
    {
      if ( v10[1] != -1 )
        ++v10[1];
      json_object_set_new_nocheck(a1, v8, v10);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00052CAC) --------------------------------------------------------
int __fastcall json_object_set_new(_DWORD *a1, char *s, _DWORD *a3)
{
  unsigned int v6; // r0
  int v8; // r3
  int v9; // r3

  if ( s )
  {
    v6 = strlen(s);
    if ( utf8_check_string((int)s, v6) )
      return json_object_set_new_nocheck(a1, s, a3);
  }
  if ( a3 )
  {
    v8 = a3[1];
    if ( v8 != -1 )
    {
      v9 = v8 - 1;
      a3[1] = v9;
      if ( !v9 )
        json_delete(a3);
    }
  }
  return -1;
}

//----- (00052CF0) --------------------------------------------------------
int __fastcall json_array_append_new(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v4; // r5
  int v5; // r3
  int result; // r0
  int v7; // r3
  int v8; // r3

  if ( !a2 )
    return -1;
  if ( !a1 )
    goto LABEL_8;
  v4 = a2 == a1;
  if ( *a1 != 1 )
    v4 = 1;
  if ( !v4 && json_array_grow(a1, 1, 1) )
  {
    v5 = a1[3];
    result = 0;
    *(_DWORD *)(a1[4] + 4 * v5) = a2;
    a1[3] = v5 + 1;
  }
  else
  {
LABEL_8:
    v7 = a2[1];
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      a2[1] = v8;
      if ( !v8 )
        json_delete(a2);
    }
    return -1;
  }
  return result;
}

//----- (00052D48) --------------------------------------------------------
bool __fastcall json_equal(int a1, int a2)
{
  bool v2; // zf

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  return !v2 && json_equal_part_3(a1, a2);
}

//----- (00052D58) --------------------------------------------------------
int __fastcall json_copy(double a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r5
  unsigned int v3; // r3
  unsigned int j; // r6
  _DWORD *v5; // r1
  int i; // r0
  int v7; // r0
  char *v8; // r6
  int v9; // r7
  _DWORD *v10; // r0

  if ( !LODWORD(a1) )
    return 0;
  v1 = (_DWORD *)LODWORD(a1);
  switch ( *(_DWORD *)LODWORD(a1) )
  {
    case 0:
      v2 = (_DWORD *)json_object();
      if ( !v2 )
        goto LABEL_19;
      if ( !*v1 )
      {
        for ( i = hashtable_iter((int)(v1 + 2)); i; i = hashtable_iter_next((int)(v1 + 2), v9) )
        {
          v7 = hashtable_iter_key(i);
          v8 = (char *)v7;
          v9 = v7 - 16;
          if ( !v7 )
            break;
          v10 = (_DWORD *)hashtable_iter_value(v7 - 16);
          if ( !v10 )
            break;
          if ( v10[1] != -1 )
            ++v10[1];
          json_object_set_new_nocheck(v2, v8, v10);
          if ( *v1 )
            break;
        }
      }
      goto LABEL_5;
    case 1:
      v2 = json_array();
      if ( !v2 )
        goto LABEL_19;
      if ( *v1 == 1 )
      {
        v3 = v1[3];
        if ( v3 )
        {
          for ( j = 0; j < v3; ++j )
          {
            v5 = 0;
            if ( v3 > j )
            {
              v5 = *(_DWORD **)(v1[4] + 4 * j);
              if ( v5 )
              {
                if ( v5[1] != -1 )
                  ++v5[1];
              }
            }
            json_array_append_new(v2, v5);
            if ( *v1 != 1 )
              break;
            v3 = v1[3];
          }
        }
      }
LABEL_5:
      LODWORD(a1) = v2;
      break;
    case 2:
      LODWORD(a1) = string_create(*(void **)(LODWORD(a1) + 8), *(_DWORD *)(LODWORD(a1) + 12), 0);
      return LODWORD(a1);
    case 3:
      LODWORD(a1) = json_integer_copy(SLODWORD(a1));
      return LODWORD(a1);
    case 4:
      LODWORD(a1) = json_real(a1);
      return LODWORD(a1);
    case 5:
    case 6:
    case 7:
      return LODWORD(a1);
    default:
LABEL_19:
      LODWORD(a1) = 0;
      break;
  }
  return LODWORD(a1);
}

//----- (00052E54) --------------------------------------------------------
int __fastcall json_deep_copy(double a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r5
  unsigned int v3; // r3
  unsigned int j; // r6
  int v5; // r0
  _DWORD *v6; // r0
  int i; // r6
  char *v8; // r7
  int v9; // r0
  _DWORD *v10; // r0

  if ( !LODWORD(a1) )
    return 0;
  v1 = (_DWORD *)LODWORD(a1);
  switch ( *(_DWORD *)LODWORD(a1) )
  {
    case 0:
      v2 = (_DWORD *)json_object();
      if ( !v2 )
        goto LABEL_17;
      if ( !*v1 )
      {
        for ( i = hashtable_iter((int)(v1 + 2)); i; i = hashtable_iter_next((int)(v1 + 2), i) )
        {
          v8 = (char *)hashtable_iter_key(i);
          v9 = hashtable_iter_value(i);
          v10 = (_DWORD *)json_deep_copy(v9);
          json_object_set_new_nocheck(v2, v8, v10);
          if ( *v1 )
            break;
        }
      }
      goto LABEL_5;
    case 1:
      v2 = json_array();
      if ( !v2 )
        goto LABEL_17;
      if ( *v1 == 1 )
      {
        v3 = v1[3];
        if ( v3 )
        {
          for ( j = 0; j < v3; ++j )
          {
            v5 = 0;
            if ( j < v3 )
              v5 = *(_DWORD *)(v1[4] + 4 * j);
            v6 = (_DWORD *)json_deep_copy(v5);
            json_array_append_new(v2, v6);
            if ( *v1 != 1 )
              break;
            v3 = v1[3];
          }
        }
      }
LABEL_5:
      LODWORD(a1) = v2;
      break;
    case 2:
      LODWORD(a1) = string_create(*(void **)(LODWORD(a1) + 8), *(_DWORD *)(LODWORD(a1) + 12), 0);
      return LODWORD(a1);
    case 3:
      LODWORD(a1) = json_integer_copy(SLODWORD(a1));
      return LODWORD(a1);
    case 4:
      LODWORD(a1) = json_real(a1);
      return LODWORD(a1);
    case 5:
    case 6:
    case 7:
      return LODWORD(a1);
    default:
LABEL_17:
      LODWORD(a1) = 0;
      break;
  }
  return LODWORD(a1);
}

//----- (00052F38) --------------------------------------------------------
unsigned int __fastcall rpl_memchr(unsigned int result, unsigned __int8 a2, unsigned int a3)
{
  _DWORD *v3; // r3
  bool v4; // zf
  int v5; // r6
  _DWORD *v6; // r5
  char *v7; // r4
  char *v8; // r2

  if ( !a3 )
    return a3;
  if ( result << 30 )
  {
    if ( *(unsigned __int8 *)result == a2 )
      return result;
    v3 = (_DWORD *)(result + 1);
    while ( 1 )
    {
      --a3;
      result = (unsigned int)v3;
      if ( !a3 )
        return 0;
      v4 = ((unsigned __int8)v3 & 3) == 0;
      v3 = (_DWORD *)((char *)v3 + 1);
      if ( v4 )
        break;
      if ( *(unsigned __int8 *)result == a2 )
        return result;
    }
  }
  v5 = a2 | (a2 << 8) | ((a2 | (a2 << 8)) << 16);
  if ( a3 > 3 && (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 )
  {
    v6 = (_DWORD *)(result + 4);
    do
    {
      a3 -= 4;
      result = (unsigned int)v6++;
      if ( a3 <= 3 )
        break;
    }
    while ( (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 );
    if ( !a3 )
      return a3;
  }
  if ( *(unsigned __int8 *)result != a2 )
  {
    v7 = (char *)(result + a3);
    v8 = (char *)(result + 1);
    while ( 1 )
    {
      v4 = v8 == v7;
      result = (unsigned int)v8++;
      if ( v4 )
        break;
      if ( *(unsigned __int8 *)result == a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (00052FD0) --------------------------------------------------------
unsigned int __fastcall critical_factorization_part_0(int a1, unsigned int a2, int *a3)
{
  int v3; // lr
  int v4; // r4
  unsigned int v5; // r5
  int v6; // r6
  unsigned int v7; // r3
  int v8; // r7
  unsigned int v9; // r7
  unsigned int v10; // r12
  int v11; // r8
  unsigned int v12; // r5
  int v13; // r4
  int v14; // r7
  unsigned int v15; // r3
  int v16; // lr
  unsigned int v17; // lr
  unsigned int v18; // r12
  unsigned int v19; // r7
  unsigned int result; // r0
  bool v21; // zf
  bool v22; // zf

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v4 + v5;
    v8 = a1 + v6;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v4);
      v10 = *(unsigned __int8 *)(a1 + v7);
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = a1 + v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      v21 = v4 == v3;
      if ( v4 == v3 )
        v3 = v4;
      else
        ++v4;
      if ( v21 )
      {
        v5 = v7;
        v4 = 1;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *a3 = v3;
  while ( 1 )
  {
    v15 = v13 + v12;
    v16 = a1 + v14;
    if ( a2 <= v13 + v12 )
      break;
    while ( 1 )
    {
      v17 = *(unsigned __int8 *)(v16 + v13);
      v18 = *(unsigned __int8 *)(a1 + v15);
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = a1 + v14;
      if ( a2 <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      v22 = v13 == v11;
      if ( v13 == v11 )
        v11 = v13;
      else
        ++v13;
      if ( v22 )
      {
        v12 = v15;
        v13 = 1;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  v19 = v14 + 1;
  result = v6 + 1;
  if ( v19 >= v6 + 1 )
  {
    result = v19;
    *a3 = v11;
  }
  return result;
}

//----- (00053088) --------------------------------------------------------
int __fastcall two_way_long_needle(int a1, int a2, void *s1, unsigned int a4)
{
  unsigned int v7; // r9
  unsigned int v8; // r4
  int *v9; // r2
  char *v10; // r1
  int v11; // r2
  int v12; // t1
  unsigned int v13; // r0
  unsigned int v14; // r3
  unsigned int v15; // r5
  bool v16; // cf
  unsigned int v17; // r3
  unsigned int v18; // r3
  char *v19; // r1
  unsigned __int8 *v20; // r2
  int v21; // r12
  int v22; // t1
  int v23; // t1
  unsigned int v24; // r1
  unsigned __int8 *v25; // r2
  char *v26; // lr
  int v27; // r10
  int v28; // t1
  int v29; // t1
  unsigned int v31; // r2
  unsigned int v32; // r12
  unsigned int v33; // lr
  int v34; // r3
  unsigned __int8 *v35; // r2
  unsigned int v36; // r3
  char *v37; // r1
  int v38; // r5
  int v39; // t1
  int v40; // t1
  unsigned __int8 *v41; // r2
  char *v42; // r3
  int v43; // r0
  int v44; // t1
  int v45; // t1
  unsigned int v46; // [sp+4h] [bp-44Ch]
  unsigned int v47; // [sp+4h] [bp-44Ch]
  unsigned int v48; // [sp+4h] [bp-44Ch]
  unsigned int v49; // [sp+Ch] [bp-444h]
  int v50; // [sp+Ch] [bp-444h]
  unsigned int v51; // [sp+18h] [bp-438h]
  int v52[256]; // [sp+24h] [bp-42Ch] BYREF
  char v53; // [sp+424h] [bp-2Ch] BYREF

  if ( a4 > 2 )
  {
    v48 = a4;
    v7 = critical_factorization_part_0((int)s1, a4, v52);
    v49 = v52[0];
    a4 = v48;
    v8 = v48 - 1;
  }
  else
  {
    v7 = a4 - 1;
    v8 = a4 - 1;
    v49 = 1;
    v52[0] = 1;
  }
  v9 = v52;
  do
  {
    v9[1] = a4;
    ++v9;
  }
  while ( v9 != (int *)&v53 );
  v10 = (char *)s1 - 1;
  v11 = v8;
  if ( a4 )
  {
    do
    {
      v12 = (unsigned __int8)*++v10;
      v52[v12 + 1] = v11--;
    }
    while ( v11 != v8 - a4 );
  }
  v46 = a4;
  v13 = memcmp(s1, (char *)s1 + v49, v7);
  v14 = v46;
  if ( v13 )
  {
    v31 = v46 - v7;
    v32 = a2 - v46;
    if ( v46 - v7 < v7 )
      v31 = v7;
    v33 = 0;
    v50 = v31 + 1;
    while ( 1 )
    {
      v34 = v52[*(unsigned __int8 *)(a1 + v8 + v33) + 1];
      if ( v34 )
        goto LABEL_51;
      if ( v7 >= v8 )
        goto LABEL_44;
      v35 = (unsigned __int8 *)(v7 + v33 + a1);
      if ( *((unsigned __int8 *)s1 + v7) == *v35 )
        break;
      v36 = v7;
LABEL_54:
      v33 += 1 - v7 + v36;
LABEL_52:
      if ( v33 > v32 )
        return 0;
    }
    v37 = (char *)s1 + v7;
    v36 = v7;
    while ( ++v36 != v8 )
    {
      v39 = (unsigned __int8)*++v37;
      v38 = v39;
      v40 = *++v35;
      if ( v38 != v40 )
        goto LABEL_54;
    }
LABEL_44:
    if ( !v7 )
      return a1 + v33;
    v41 = (unsigned __int8 *)(v7 - 1 + v33 + a1);
    if ( *v41 == *((unsigned __int8 *)s1 + v7 - 1) )
    {
      v42 = (char *)s1 + v7 - 1;
      while ( v42 != s1 )
      {
        v44 = (unsigned __int8)*--v42;
        v43 = v44;
        v45 = *--v41;
        if ( v43 != v45 )
          goto LABEL_50;
      }
      return a1 + v33;
    }
LABEL_50:
    v34 = v50;
LABEL_51:
    v33 += v34;
    goto LABEL_52;
  }
  v47 = a2 - v46;
  v15 = 0;
  v51 = v14 - v49;
  while ( 1 )
  {
    while ( 1 )
    {
      v17 = v52[*(unsigned __int8 *)(a1 + v8 + v15) + 1];
      if ( v17 )
      {
        v16 = 1;
        if ( v13 )
          v16 = v17 >= v49;
        v13 = 0;
        if ( !v16 )
          v17 = v51;
        v15 += v17;
        goto LABEL_14;
      }
      v18 = v7;
      if ( v7 < v13 )
        v18 = v13;
      if ( v18 >= v8 )
        break;
      v19 = (char *)s1 + v18;
      v20 = (unsigned __int8 *)(v18 + v15 + a1);
      if ( *((unsigned __int8 *)s1 + v18) == *v20 )
      {
        while ( ++v18 != v8 )
        {
          v22 = (unsigned __int8)*++v19;
          v21 = v22;
          v23 = *++v20;
          if ( v21 != v23 )
            goto LABEL_33;
        }
        break;
      }
LABEL_33:
      v13 = 0;
      v15 += 1 - v7 + v18;
LABEL_14:
      if ( v47 < v15 )
        return 0;
    }
    v24 = v7 - 1;
    if ( v7 > v13 )
    {
      v25 = (unsigned __int8 *)(v7 - 1 + v15 + a1);
      if ( *v25 == *((unsigned __int8 *)s1 + v7 - 1) )
      {
        v26 = (char *)s1 + v7 - 1;
        while ( v13 - 1 != v24 - 1 )
        {
          v28 = (unsigned __int8)*--v26;
          v27 = v28;
          v29 = *--v25;
          if ( v27 != v29 )
            break;
          --v24;
        }
      }
      else
      {
        v24 = v7;
      }
    }
    else
    {
      v24 = v7;
    }
    if ( v13 + 1 > v24 )
      return a1 + v15;
    v13 = v51;
    v15 += v49;
    if ( v47 < v15 )
      return 0;
  }
}

//----- (000532B0) --------------------------------------------------------
int __fastcall memmem(unsigned int a1, unsigned int a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // r9
  unsigned int v9; // r0
  bool v10; // zf
  int result; // r0
  unsigned int v12; // r4
  unsigned int v13; // r11
  unsigned int v14; // r0
  unsigned int v15; // r12
  unsigned int v16; // r3
  _BYTE *v17; // r1
  unsigned __int8 *v18; // r2
  int v19; // r6
  int v20; // t1
  int v21; // t1
  unsigned int v22; // r1
  unsigned __int8 *v23; // r2
  _BYTE *v24; // r4
  int v25; // r7
  int v26; // t1
  int v27; // t1
  unsigned int v28; // r0
  unsigned int v29; // r10
  unsigned int v30; // r2
  unsigned int v31; // lr
  unsigned __int8 *v32; // r1
  unsigned int v33; // r3
  _BYTE *v34; // r4
  int v35; // r7
  int v36; // t1
  int v37; // t1
  unsigned __int8 *v38; // r1
  _BYTE *v39; // r3
  int v40; // r6
  int v41; // t1
  int v42; // t1
  unsigned int v43; // [sp+4h] [bp-44h]
  int v44; // [sp+8h] [bp-40h]
  int v45; // [sp+1Ch] [bp-2Ch] BYREF

  v4 = a1;
  if ( !a4 )
    return v4;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 31 )
    return two_way_long_needle(a1, a2, a3, a4);
  v9 = rpl_memchr(a1, *a3, a2);
  v10 = a4 == 1;
  if ( a4 != 1 )
    v10 = v9 == 0;
  v4 = v9;
  result = v10;
  if ( v10 )
    return v4;
  v12 = a2 - (v4 - a1);
  if ( a4 <= v12 )
  {
    if ( a4 > 2 )
    {
      v13 = critical_factorization_part_0((int)a3, a4, &v45);
      v44 = v45;
    }
    else
    {
      v13 = a4 - 1;
      v44 = 1;
      v45 = 1;
    }
    v14 = memcmp(a3, &a3[v44], v13);
    if ( !v14 )
    {
      v43 = v12 - a4;
      v15 = 0;
      while ( 1 )
      {
        v16 = v13;
        if ( v13 < v15 )
          v16 = v15;
        if ( a4 > v16 )
        {
          v17 = &a3[v16];
          v18 = (unsigned __int8 *)(v16 + v14 + v4);
          if ( (unsigned __int8)a3[v16] != *v18 )
          {
LABEL_35:
            v15 = 0;
            v14 += 1 - v13 + v16;
            goto LABEL_30;
          }
          while ( a4 != ++v16 )
          {
            v20 = (unsigned __int8)*++v17;
            v19 = v20;
            v21 = *++v18;
            if ( v19 != v21 )
              goto LABEL_35;
          }
        }
        v22 = v13 - 1;
        if ( v13 > v15 && (v23 = (unsigned __int8 *)(v13 - 1 + v14 + v4), *v23 == (unsigned __int8)a3[v13 - 1]) )
        {
          v24 = &a3[v13 - 1];
          while ( v22 - 1 != v15 - 1 )
          {
            v26 = (unsigned __int8)*--v24;
            v25 = v26;
            v27 = *--v23;
            if ( v25 != v27 )
              break;
            --v22;
          }
        }
        else
        {
          v22 = v13;
        }
        if ( v15 + 1 > v22 )
          return v14 + v4;
        v15 = a4 - v44;
        v14 += v44;
LABEL_30:
        if ( v43 < v14 )
          return 0;
      }
    }
    v28 = a4 - v13;
    v29 = v13 - 1;
    v30 = v12 - a4;
    if ( a4 - v13 < v13 )
      v28 = v13;
    v31 = 0;
    v45 = v28 + 1;
    while ( 1 )
    {
      if ( a4 <= v13 )
        goto LABEL_45;
      v32 = (unsigned __int8 *)(v13 + v31 + v4);
      if ( *v32 == (unsigned __int8)a3[v13] )
        break;
      v33 = v13;
LABEL_51:
      v31 += 1 - v13 + v33;
LABEL_52:
      if ( v30 < v31 )
        return 0;
    }
    v34 = &a3[v13];
    v33 = v13;
    while ( a4 != ++v33 )
    {
      v36 = (unsigned __int8)*++v34;
      v35 = v36;
      v37 = *++v32;
      if ( v35 != v37 )
        goto LABEL_51;
    }
LABEL_45:
    if ( !v13 )
      return v4 + v31;
    v38 = (unsigned __int8 *)(v29 + v31 + v4);
    if ( *v38 == (unsigned __int8)a3[v29] )
    {
      v39 = &a3[v29];
      while ( v39 != a3 )
      {
        v41 = (unsigned __int8)*--v39;
        v40 = v41;
        v42 = *--v38;
        if ( v40 != v42 )
          goto LABEL_54;
      }
      return v4 + v31;
    }
LABEL_54:
    v31 += v28 + 1;
    goto LABEL_52;
  }
  return result;
}

//----- (00053490) --------------------------------------------------------
int __fastcall uncompress(int a1, int *a2, unsigned int a3, int a4)
{
  int v4; // r6
  int v6; // r4
  unsigned int v8; // [sp+0h] [bp-48h] BYREF
  int v9; // [sp+4h] [bp-44h]
  int v10; // [sp+Ch] [bp-3Ch]
  int v11; // [sp+10h] [bp-38h]
  int v12; // [sp+14h] [bp-34h]
  int v13; // [sp+20h] [bp-28h]
  int v14; // [sp+24h] [bp-24h]

  v4 = *a2;
  v8 = a3;
  v10 = a1;
  v13 = 0;
  v14 = 0;
  v9 = a4;
  v11 = v4;
  v6 = inflateInit_(&v8, "1.2.8", 56);
  if ( !v6 )
  {
    v6 = inflate(&v8, 4);
    if ( v6 == 1 )
    {
      *a2 = v12;
      return inflateEnd(&v8);
    }
    else
    {
      inflateEnd(&v8);
      if ( v6 == 2 )
      {
        return -3;
      }
      else if ( v6 == -5 && !v9 )
      {
        return -3;
      }
    }
  }
  return v6;
}

//----- (000534FC) --------------------------------------------------------
int __fastcall updatewindow(int a1, int a2, size_t n)
{
  int v4; // r4
  char *v6; // r2
  unsigned int v7; // r3
  int v8; // r0
  size_t v9; // r3
  char *v10; // r0
  size_t v11; // r6
  size_t v12; // r5
  unsigned int v13; // r1
  size_t v14; // r3
  bool v15; // zf
  unsigned int v16; // r3
  int result; // r0
  int v18; // r3
  int v19; // r3
  int v20; // r3
  int v21; // r0

  v4 = *(_DWORD *)(a1 + 28);
  v6 = *(char **)(v4 + 52);
  if ( !v6 )
  {
    v21 = (*(int (__fastcall **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1 << *(_DWORD *)(v4 + 36), 1);
    *(_DWORD *)(v4 + 52) = v21;
    if ( !v21 )
      return 1;
    v6 = (char *)v21;
  }
  v7 = *(_DWORD *)(v4 + 40);
  if ( v7 )
  {
    if ( v7 > n )
      goto LABEL_4;
LABEL_13:
    memcpy(v6, (const void *)(a2 - v7), v7);
    v19 = *(_DWORD *)(v4 + 40);
    result = 0;
    *(_DWORD *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 44) = v19;
    return result;
  }
  v18 = *(_DWORD *)(v4 + 36);
  *(_DWORD *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  v7 = 1 << v18;
  *(_DWORD *)(v4 + 40) = v7;
  if ( v7 <= n )
    goto LABEL_13;
LABEL_4:
  v8 = *(_DWORD *)(v4 + 48);
  v9 = v7 - v8;
  v10 = &v6[v8];
  if ( v9 >= n )
    v11 = n;
  else
    v11 = v9;
  memcpy(v10, (const void *)(a2 - n), v11);
  v12 = n - v11;
  if ( v12 )
  {
    memcpy(*(void **)(v4 + 52), (const void *)(a2 - v12), v12);
    v20 = *(_DWORD *)(v4 + 40);
    result = 0;
    *(_DWORD *)(v4 + 48) = v12;
    *(_DWORD *)(v4 + 44) = v20;
  }
  else
  {
    v13 = *(_DWORD *)(v4 + 40);
    v14 = v11 + *(_DWORD *)(v4 + 48);
    v15 = v14 == v13;
    *(_DWORD *)(v4 + 48) = v14;
    v16 = *(_DWORD *)(v4 + 44);
    if ( v15 )
      *(_DWORD *)(v4 + 48) = 0;
    result = 0;
    if ( v13 > v16 )
      *(_DWORD *)(v4 + 44) = v11 + v16;
  }
  return result;
}

//----- (000535A4) --------------------------------------------------------
int __fastcall inflateResetKeep(_DWORD *a1)
{
  _DWORD *v1; // r3
  int v2; // r1
  int result; // r0

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  v2 = v1[2];
  v1[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( v2 )
    a1[12] = v2 & 1;
  result = 0;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[8] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[5] = 32768;
  v1[27] = v1 + 332;
  v1[20] = v1 + 332;
  v1[19] = v1 + 332;
  v1[1776] = 1;
  v1[1777] = -1;
  return result;
}

//----- (00053600) --------------------------------------------------------
int __fastcall inflateReset(_DWORD *a1)
{
  _DWORD *v1; // r3
  int v2; // r1
  int result; // r0

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  v2 = v1[2];
  v1[10] = 0;
  v1[11] = 0;
  v1[12] = 0;
  v1[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( v2 )
    a1[12] = v2 & 1;
  result = 0;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[8] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[5] = 32768;
  v1[27] = v1 + 332;
  v1[20] = v1 + 332;
  v1[19] = v1 + 332;
  v1[1776] = 1;
  v1[1777] = -1;
  return result;
}

//----- (00053660) --------------------------------------------------------
int __fastcall inflateReset2(int a1, int a2)
{
  int v3; // r4
  _DWORD *v4; // r6
  int v5; // r7
  bool v6; // cc
  _DWORD *v7; // r3
  int result; // r0
  int v9; // r1

  v3 = a2;
  if ( !a1 )
    return -2;
  v4 = *(_DWORD **)(a1 + 28);
  if ( !v4 )
    return -2;
  if ( a2 >= 0 )
  {
    if ( a2 <= 47 )
      v3 = a2 & 0xF;
    v5 = (a2 >> 4) + 1;
  }
  else
  {
    v3 = -a2;
    v5 = 0;
  }
  v6 = v3 != 0;
  if ( v3 )
    v6 = (unsigned int)(v3 - 8) > 7;
  if ( v6 )
    return -2;
  if ( !v4[13] || v3 == v4[9] )
  {
    v7 = *(_DWORD **)(a1 + 28);
    v4[2] = v5;
    v4[9] = v3;
  }
  else
  {
    (*(void (__fastcall **)(_DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40));
    v7 = *(_DWORD **)(a1 + 28);
    v4[13] = 0;
    v4[2] = v5;
    v4[9] = v3;
    if ( !v7 )
      return -2;
  }
  v9 = v7[2];
  v7[10] = 0;
  v7[11] = 0;
  v7[12] = 0;
  v7[7] = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if ( v9 )
    *(_DWORD *)(a1 + 48) = v9 & 1;
  *v7 = 0;
  result = 0;
  v7[1] = 0;
  v7[3] = 0;
  v7[8] = 0;
  v7[14] = 0;
  v7[15] = 0;
  v7[5] = 32768;
  v7[27] = v7 + 332;
  v7[20] = v7 + 332;
  v7[19] = v7 + 332;
  v7[1776] = 1;
  v7[1777] = -1;
  return result;
}

//----- (00053710) --------------------------------------------------------
int __fastcall inflateInit2_(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  void *(__fastcall *v6)(int, int, int); // r3
  _DWORD *v7; // r0
  _DWORD *v8; // r5
  int v9; // r6

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v6 = (void *(__fastcall *)(int, int, int))a1[8];
  a1[6] = 0;
  if ( !v6 )
  {
    a1[10] = 0;
    a1[8] = zcalloc;
    v6 = zcalloc;
    if ( a1[9] )
      goto LABEL_7;
LABEL_13:
    a1[9] = zcfree;
    goto LABEL_7;
  }
  if ( !a1[9] )
    goto LABEL_13;
LABEL_7:
  v7 = v6(a1[10], 1, 7116);
  v8 = v7;
  if ( !v7 )
    return -4;
  a1[7] = v7;
  v7[13] = 0;
  v9 = inflateReset2((int)a1, a2);
  if ( !v9 )
    return v9;
  ((void (__fastcall *)(_DWORD, _DWORD *))a1[9])(a1[10], v8);
  a1[7] = 0;
  return v9;
}

//----- (0005379C) --------------------------------------------------------
int __fastcall inflateInit_(_DWORD *a1, _BYTE *a2, int a3)
{
  void *(__fastcall *v4)(int, int, int); // r3
  _DWORD *v5; // r0
  _DWORD *v6; // r5
  int v7; // r6

  if ( !a2 || *a2 != 49 || a3 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v4 = (void *(__fastcall *)(int, int, int))a1[8];
  a1[6] = 0;
  if ( !v4 )
  {
    a1[10] = 0;
    a1[8] = zcalloc;
    v4 = zcalloc;
    if ( a1[9] )
      goto LABEL_7;
LABEL_13:
    a1[9] = zcfree;
    goto LABEL_7;
  }
  if ( !a1[9] )
    goto LABEL_13;
LABEL_7:
  v5 = v4(a1[10], 1, 7116);
  v6 = v5;
  if ( !v5 )
    return -4;
  a1[7] = v5;
  v5[13] = 0;
  v7 = inflateReset2((int)a1, 15);
  if ( !v7 )
    return v7;
  ((void (__fastcall *)(_DWORD, _DWORD *))a1[9])(a1[10], v6);
  a1[7] = 0;
  return v7;
}

//----- (00053828) --------------------------------------------------------
int __fastcall inflatePrime(int a1, int a2, int a3)
{
  int v3; // r3
  int v4; // r4
  int v5; // r5
  int result; // r0

  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 28);
    if ( v3 )
    {
      if ( a2 < 0 )
      {
        *(_DWORD *)(v3 + 56) = 0;
        result = 0;
        *(_DWORD *)(v3 + 60) = 0;
        return result;
      }
      if ( a2 <= 16 )
      {
        v4 = *(_DWORD *)(v3 + 60);
        if ( (unsigned int)(a2 + v4) <= 32 )
        {
          v5 = *(_DWORD *)(v3 + 56);
          *(_DWORD *)(v3 + 60) = a2 + v4;
          result = 0;
          *(_DWORD *)(v3 + 56) = v5 + ((a3 & ((1 << a2) - 1)) << v4);
          return result;
        }
      }
    }
  }
  return -2;
}

//----- (0005386C) --------------------------------------------------------
int __fastcall inflate(unsigned int *a1, int a2)
{
  unsigned int v2; // r9
  int v3; // r2
  unsigned int v4; // r8
  size_t v5; // r4
  unsigned __int8 *v6; // r11
  unsigned int *v7; // r12
  unsigned int v8; // r10
  unsigned int v9; // r7
  unsigned __int8 *v10; // r3
  int v11; // t1
  int v12; // r2
  int v13; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r3
  int v17; // r0
  int v18; // t1
  int v19; // r3
  int v20; // r3
  unsigned int v21; // r1
  unsigned __int8 *v22; // r3
  int v23; // t1
  int v24; // r2
  int v25; // r0
  unsigned int v26; // r3
  unsigned int v27; // r2
  unsigned int v28; // r3
  bool v29; // cc
  int v30; // r3
  int v31; // r2
  int v32; // r5
  unsigned __int8 *v33; // r0
  int v34; // r1
  unsigned int v35; // r3
  int v36; // r0
  unsigned __int8 *v37; // r4
  int v38; // t1
  int v39; // r3
  unsigned __int8 *v40; // r0
  unsigned int v41; // r1
  int v42; // r2
  unsigned int v43; // r5
  int v44; // r2
  int v45; // r6
  char *v46; // r0
  char v47; // r1
  unsigned int v48; // r3
  int v49; // r0
  unsigned int v50; // r4
  unsigned __int8 *v51; // r5
  int v52; // t1
  int v53; // r3
  char *v54; // r0
  unsigned int v55; // r6
  char *v56; // r0
  unsigned __int8 *v57; // r5
  int v58; // r9
  int v59; // t1
  int v60; // r3
  char *v61; // r0
  _DWORD *v62; // r4
  unsigned int v63; // r2
  int v64; // r11
  unsigned __int8 *v66; // r3
  int v67; // t1
  int v68; // r2
  int v69; // r3
  unsigned __int8 *v70; // r3
  int v71; // t1
  int v72; // r2
  int v73; // r3
  unsigned int v74; // r4
  unsigned int v75; // r1
  unsigned __int8 *v76; // r3
  int v77; // t1
  int v78; // r2
  int v79; // r3
  int v80; // r3
  unsigned int v81; // r3
  unsigned int v82; // r4
  _DWORD *v83; // r2
  int v84; // r0
  int v85; // r1
  unsigned int v86; // r2
  int v87; // r3
  void *v88; // r0
  size_t v89; // r2
  int v90; // r2
  int v91; // r3
  int v92; // r3
  unsigned int v93; // r4
  int v94; // r3
  int v95; // r5
  int v96; // r2
  unsigned int v97; // r1
  unsigned int v98; // r3
  bool v99; // cf
  unsigned __int8 *v100; // r3
  int v101; // t1
  int v102; // r2
  int v103; // r1
  unsigned __int8 *v104; // r3
  int v105; // t1
  int v106; // r2
  int v107; // r3
  unsigned int v108; // r2
  unsigned int v109; // r3
  int v110; // r0
  unsigned __int8 *v111; // r3
  int v112; // t1
  int v113; // r2
  unsigned int v114; // r6
  unsigned int v115; // r7
  unsigned int *v116; // r10
  unsigned __int8 *v117; // r12
  int v118; // r3
  unsigned int v119; // r4
  unsigned int v120; // r0
  unsigned int v121; // r6
  int v122; // r1
  unsigned int v123; // r5
  unsigned int v124; // r0
  char *v125; // r1
  int v126; // r0
  int v127; // r3
  int v128; // r2
  int v129; // r2
  bool v130; // zf
  int v131; // r3
  char v132; // r3
  unsigned __int8 *v133; // r3
  int v134; // t1
  int v135; // r2
  size_t v136; // r4
  unsigned __int8 *v137; // r3
  int v138; // t1
  int v139; // r2
  unsigned int v140; // r3
  unsigned int v141; // r1
  unsigned int v142; // r2
  unsigned int v143; // r3
  __int16 *v144; // r0
  int v145; // t1
  int v146; // r1
  int v147; // t1
  __int16 v148; // r4
  __int16 *v149; // r3
  int v150; // t1
  int v151; // r0
  unsigned int v152; // r6
  unsigned int v153; // r1
  int v154; // r4
  int v155; // r3
  int v156; // r2
  unsigned int v157; // r0
  unsigned int v158; // r1
  unsigned __int8 *v159; // r2
  int v160; // t1
  int v161; // r1
  int v162; // r1
  unsigned __int8 *v163; // r3
  int v164; // t1
  int v165; // r2
  unsigned int v166; // r10
  int v167; // r5
  unsigned int v168; // r5
  unsigned __int16 v169; // r3
  unsigned int v170; // r12
  unsigned int v171; // r4
  unsigned int v172; // r0
  unsigned int v173; // r2
  int v174; // r1
  unsigned int v175; // r2
  int *v176; // r5
  int *v177; // r2
  int v178; // r6
  unsigned int v179; // r4
  unsigned int v180; // r1
  unsigned __int16 *v181; // r2
  unsigned int v182; // r2
  int v183; // r3
  unsigned __int8 *v184; // r3
  int v185; // t1
  int v186; // r2
  unsigned int v187; // r2
  int v188; // r3
  unsigned int v189; // r0
  int v190; // r0
  int v191; // r2
  unsigned __int8 *v192; // r3
  int v193; // t1
  int v194; // r2
  unsigned int v195; // r4
  int v196; // r3
  int v197; // r5
  int v198; // r2
  unsigned int v199; // r1
  unsigned int v200; // r3
  bool v201; // cf
  int v202; // r2
  int v203; // r2
  int v204; // r3
  int v205; // r0
  _BYTE *v206; // r5
  unsigned int v207; // r2
  unsigned int v208; // r1
  unsigned int v209; // r5
  bool v210; // cf
  char v211; // r4
  unsigned int v212; // r5
  int v213; // r4
  int v214; // r4
  unsigned int v215; // r7
  _DWORD *v216; // r2
  unsigned int v217; // r3
  int v218; // r0
  unsigned int v219; // r1
  unsigned int v220; // r11
  _DWORD *v221; // r0
  int v222; // r5
  unsigned int v223; // r2
  unsigned int v224; // r2
  int v225; // t1
  _BYTE *v226; // r3
  unsigned int v227; // r1
  _BYTE *v228; // r1
  unsigned int v229; // r0
  char v230; // t1
  unsigned __int8 *v231; // r3
  int v232; // t1
  int v233; // r2
  int v234; // r0
  unsigned int v235; // r3
  unsigned int v236; // r2
  bool v237; // cc
  int v238; // r1
  unsigned int v239; // r2
  unsigned int v240; // r1
  unsigned int v241; // r3
  int v242; // r0
  int v243; // r3
  unsigned int v244; // r5
  int v245; // r0
  int v246; // r0
  int v247; // r0
  unsigned __int8 *v248; // r4
  int v249; // r5
  int v250; // r4
  unsigned int v251; // r6
  unsigned __int8 *v252; // r4
  int v253; // t1
  int v254; // r1
  unsigned __int8 *v255; // r6
  int v256; // r9
  int v257; // r0
  int v258; // r0
  int v259; // r0
  int v260; // r0
  int v261; // r0
  unsigned __int8 *v262; // r3
  int v263; // t1
  int v264; // r2
  unsigned __int8 *v265; // r3
  int v266; // t1
  int v267; // r2
  unsigned int v268; // r10
  int *v269; // r3
  unsigned int v270; // r6
  unsigned int v271; // r7
  unsigned int *v272; // r10
  unsigned __int8 *v273; // r12
  int v274; // r0
  int v275; // r0
  int v276; // r0
  int v277; // r0
  int v278; // r0
  int v279; // r1
  int v280; // r2
  int v281; // r0
  unsigned int *v282; // [sp+8h] [bp-78h]
  unsigned int *v283; // [sp+8h] [bp-78h]
  unsigned int *v284; // [sp+8h] [bp-78h]
  unsigned int *v285; // [sp+8h] [bp-78h]
  unsigned int *v286; // [sp+8h] [bp-78h]
  unsigned int *v287; // [sp+8h] [bp-78h]
  unsigned int *v288; // [sp+8h] [bp-78h]
  unsigned int *v289; // [sp+8h] [bp-78h]
  unsigned int *v290; // [sp+8h] [bp-78h]
  unsigned int *v291; // [sp+8h] [bp-78h]
  unsigned int *v292; // [sp+8h] [bp-78h]
  unsigned int *v293; // [sp+8h] [bp-78h]
  unsigned int *v294; // [sp+8h] [bp-78h]
  unsigned int *v295; // [sp+8h] [bp-78h]
  unsigned int *v296; // [sp+8h] [bp-78h]
  unsigned int *v297; // [sp+8h] [bp-78h]
  unsigned int *v298; // [sp+Ch] [bp-74h]
  int v299; // [sp+Ch] [bp-74h]
  unsigned int v300; // [sp+Ch] [bp-74h]
  size_t n; // [sp+10h] [bp-70h]
  _BYTE *dest; // [sp+14h] [bp-6Ch]
  int v303; // [sp+18h] [bp-68h]
  unsigned int v304; // [sp+1Ch] [bp-64h]
  int v306; // [sp+24h] [bp-5Ch]
  int v307; // [sp+28h] [bp-58h]
  unsigned int *v308; // [sp+28h] [bp-58h]
  unsigned int *v309; // [sp+28h] [bp-58h]
  unsigned int v310; // [sp+28h] [bp-58h]
  int v311; // [sp+28h] [bp-58h]
  unsigned int v312; // [sp+2Ch] [bp-54h]
  unsigned int v313; // [sp+30h] [bp-50h]
  int v314; // [sp+34h] [bp-4Ch]
  unsigned int *v315; // [sp+34h] [bp-4Ch]
  unsigned int v316; // [sp+38h] [bp-48h]
  unsigned __int8 *v317; // [sp+38h] [bp-48h]
  unsigned int v318; // [sp+3Ch] [bp-44h]
  unsigned int v319; // [sp+3Ch] [bp-44h]
  int v320; // [sp+44h] [bp-3Ch]
  unsigned int v321; // [sp+48h] [bp-38h]
  _DWORD v322[11]; // [sp+54h] [bp-2Ch] BYREF

  if ( !a1 )
    return -2;
  v2 = a1[7];
  if ( !v2 )
    return -2;
  dest = (_BYTE *)a1[3];
  if ( !dest )
    return -2;
  if ( !*a1 )
  {
    if ( !a1[1] )
    {
      v304 = *a1;
      goto LABEL_6;
    }
    return -2;
  }
  v304 = a1[1];
LABEL_6:
  v3 = *(_DWORD *)v2;
  v4 = *(_DWORD *)(v2 + 60);
  if ( *(_DWORD *)v2 == 11 )
    v3 = 12;
  v5 = a1[4];
  v306 = 0;
  v6 = (unsigned __int8 *)*a1;
  v7 = a1;
  v8 = *(_DWORD *)(v2 + 56);
  v9 = v304;
  if ( *(_DWORD *)v2 == 11 )
    *(_DWORD *)v2 = v3;
  n = v5;
  v312 = a2 - 5;
  v303 = v5;
LABEL_11:
  while ( 2 )
  {
    switch ( v3 )
    {
      case 0:
        v103 = *(_DWORD *)(v2 + 8);
        if ( !v103 )
        {
          v3 = 12;
          *(_DWORD *)v2 = 12;
          continue;
        }
        if ( v4 > 15 )
          goto LABEL_158;
        if ( !v9 )
          goto LABEL_336;
        v104 = v6;
        while ( 1 )
        {
          v105 = *v104++;
          --v9;
          v6 = v104;
          v106 = v105 << v4;
          v4 += 8;
          v8 += v106;
          if ( v4 > 15 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_158:
        if ( (v103 & 2) != 0 && v8 == 35615 )
        {
          v297 = v7;
          v4 = 0;
          v276 = crc32(0, 0, 0);
          LOBYTE(v322[0]) = 31;
          *(_DWORD *)(v2 + 24) = v276;
          BYTE1(v322[0]) = -117;
          v8 = 0;
          v277 = crc32(v276, (char *)v322, 2u);
          v3 = 1;
          *(_DWORD *)(v2 + 24) = v277;
          *(_DWORD *)v2 = 1;
          v7 = v297;
          continue;
        }
        v107 = *(_DWORD *)(v2 + 32);
        *(_DWORD *)(v2 + 16) = 0;
        if ( v107 )
          *(_DWORD *)(v107 + 48) = -1;
        if ( (v103 & 1) == 0
          || (unsigned __int16)((_WORD)v8 << 8) + (v8 >> 8) != 31
                                                             * (((unsigned __int16)((_WORD)v8 << 8) + (v8 >> 8))
                                                              / 31) )
        {
          v3 = 29;
          v7[6] = (unsigned int)"incorrect header check";
          *(_DWORD *)v2 = 29;
          continue;
        }
        if ( (v8 & 0xF) != 8 )
        {
LABEL_177:
          v3 = 29;
          v7[6] = (unsigned int)&unk_6A950;
          *(_DWORD *)v2 = 29;
          continue;
        }
        v8 >>= 4;
        v108 = *(_DWORD *)(v2 + 36);
        v109 = (v8 & 0xF) + 8;
        if ( v108 )
        {
          if ( v109 > v108 )
          {
            v4 -= 4;
            v3 = 29;
            v7[6] = (unsigned int)"invalid window size";
            *(_DWORD *)v2 = 29;
            continue;
          }
        }
        else
        {
          *(_DWORD *)(v2 + 36) = v109;
        }
        *(_DWORD *)(v2 + 20) = 1 << v109;
        v284 = v7;
        v110 = adler32(0, 0, 0);
        v7 = v284;
        if ( (v8 & 0x200) != 0 )
          v3 = 9;
        else
          v3 = 11;
        v8 = 0;
        *(_DWORD *)(v2 + 24) = v110;
        v4 = 0;
        v284[12] = v110;
        *(_DWORD *)v2 = v3;
        continue;
      case 1:
        if ( v4 > 15 )
          goto LABEL_176;
        if ( !v9 )
          goto LABEL_336;
        v111 = v6;
        while ( 1 )
        {
          v112 = *v111++;
          --v9;
          v6 = v111;
          v113 = v112 << v4;
          v4 += 8;
          v8 += v113;
          if ( v4 > 15 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_176:
        *(_DWORD *)(v2 + 16) = v8;
        if ( (unsigned __int8)v8 != 8 )
          goto LABEL_177;
        if ( (v8 & 0xE000) != 0 )
        {
          v3 = 29;
          v7[6] = (unsigned int)"unknown header flags set";
          *(_DWORD *)v2 = 29;
          continue;
        }
        v269 = *(int **)(v2 + 32);
        if ( v269 )
          *v269 = (v8 >> 8) & 1;
        if ( (v8 & 0x200) != 0 )
        {
          v274 = *(_DWORD *)(v2 + 24);
          v296 = v7;
          LOWORD(v322[0]) = v8;
          v275 = crc32(v274, (char *)v322, 2u);
          v7 = v296;
          *(_DWORD *)(v2 + 24) = v275;
        }
        v4 = 0;
        *(_DWORD *)v2 = 2;
        v8 = 0;
LABEL_78:
        if ( !v9 )
          goto LABEL_336;
        v66 = v6;
        while ( 1 )
        {
          v67 = *v66++;
          --v9;
          v6 = v66;
          v68 = v67 << v4;
          v4 += 8;
          v8 += v68;
          if ( v4 > 31 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_82:
        v69 = *(_DWORD *)(v2 + 32);
        if ( v69 )
          *(_DWORD *)(v69 + 4) = v8;
        if ( (*(_DWORD *)(v2 + 16) & 0x200) != 0 )
        {
          v258 = *(_DWORD *)(v2 + 24);
          v294 = v7;
          v322[0] = v8;
          v259 = crc32(v258, (char *)v322, 4u);
          v7 = v294;
          *(_DWORD *)(v2 + 24) = v259;
        }
        v8 = 0;
        v4 = 0;
        *(_DWORD *)v2 = 3;
LABEL_87:
        if ( !v9 )
          goto LABEL_336;
        v70 = v6;
        while ( 1 )
        {
          v71 = *v70++;
          --v9;
          v6 = v70;
          v72 = v71 << v4;
          v4 += 8;
          v8 += v72;
          if ( v4 > 15 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_91:
        v73 = *(_DWORD *)(v2 + 32);
        if ( v73 )
        {
          *(_DWORD *)(v73 + 8) = (unsigned __int8)v8;
          *(_DWORD *)(v73 + 12) = v8 >> 8;
        }
        v74 = *(_DWORD *)(v2 + 16);
        v75 = v74;
        if ( (v74 & 0x200) != 0 )
        {
          v246 = *(_DWORD *)(v2 + 24);
          v292 = v7;
          LOWORD(v322[0]) = v8;
          v247 = crc32(v246, (char *)v322, 2u);
          v74 = *(_DWORD *)(v2 + 16);
          *(_DWORD *)(v2 + 24) = v247;
          v7 = v292;
          v75 = v74;
        }
        *(_DWORD *)v2 = 4;
        if ( (v74 & 0x400) != 0 )
        {
          v4 = 0;
          v8 = 0;
LABEL_98:
          if ( !v9 )
            goto LABEL_336;
          v76 = v6;
          while ( 1 )
          {
            v77 = *v76++;
            --v9;
            v6 = v76;
            v78 = v77 << v4;
            v4 += 8;
            v8 += v78;
            if ( v4 > 15 )
              break;
            if ( !v9 )
              goto LABEL_336;
          }
LABEL_102:
          v79 = *(_DWORD *)(v2 + 32);
          *(_DWORD *)(v2 + 64) = v8;
          if ( v79 )
            *(_DWORD *)(v79 + 20) = v8;
          if ( (v74 & 0x200) != 0 )
          {
            v260 = *(_DWORD *)(v2 + 24);
            LOWORD(v322[0]) = v8;
            v295 = v7;
            v8 = 0;
            v261 = crc32(v260, (char *)v322, 2u);
            v75 = *(_DWORD *)(v2 + 16);
            v4 = 0;
            *(_DWORD *)(v2 + 24) = v261;
            v7 = v295;
            v80 = v75 & 0x400;
          }
          else
          {
            v8 = 0;
            v75 = v74;
            v80 = v74 & 0x400;
            v4 = 0;
          }
        }
        else
        {
          v4 = 0;
          v8 = 0;
LABEL_334:
          v203 = *(_DWORD *)(v2 + 32);
          v80 = v203;
          if ( v203 )
          {
            v80 = 0;
            *(_DWORD *)(v203 + 16) = 0;
          }
        }
        *(_DWORD *)v2 = 5;
LABEL_107:
        if ( v80 )
        {
          v81 = *(_DWORD *)(v2 + 64);
          if ( v9 >= v81 )
            v82 = *(_DWORD *)(v2 + 64);
          else
            v82 = v9;
          if ( v82 )
          {
            v83 = *(_DWORD **)(v2 + 32);
            if ( v83 )
            {
              v84 = v83[4];
              if ( v84 )
              {
                v85 = v83[5];
                v86 = v83[6];
                v283 = v7;
                v87 = v85 - v81;
                v88 = (void *)(v84 + v87);
                if ( v82 + v87 <= v86 )
                  v89 = v82;
                else
                  v89 = v86 - v87;
                memcpy(v88, v6, v89);
                v75 = *(_DWORD *)(v2 + 16);
                v7 = v283;
              }
            }
            if ( (v75 & 0x200) != 0 )
            {
              v293 = v7;
              v257 = crc32(*(_DWORD *)(v2 + 24), (char *)v6, v82);
              v7 = v293;
              *(_DWORD *)(v2 + 24) = v257;
            }
            v9 -= v82;
            v6 += v82;
            v81 = *(_DWORD *)(v2 + 64) - v82;
            *(_DWORD *)(v2 + 64) = v81;
          }
          if ( v81 )
            goto LABEL_336;
          v75 = *(_DWORD *)(v2 + 16);
        }
        *(_DWORD *)(v2 + 64) = 0;
        v90 = v75 & 0x800;
        *(_DWORD *)v2 = 6;
        if ( (v75 & 0x800) != 0 )
        {
LABEL_317:
          if ( !v9 )
            goto LABEL_336;
          v195 = 0;
          do
          {
            v196 = *(_DWORD *)(v2 + 32);
            v197 = v6[v195++];
            if ( v196 )
            {
              v198 = *(_DWORD *)(v196 + 28);
              if ( v198 )
              {
                v199 = *(_DWORD *)(v196 + 32);
                v200 = *(_DWORD *)(v2 + 64);
                if ( v200 < v199 )
                {
                  *(_BYTE *)(v198 + v200) = v197;
                  *(_DWORD *)(v2 + 64) = v200 + 1;
                }
              }
            }
            v201 = 1;
            if ( v197 )
              v201 = v195 >= v9;
          }
          while ( !v201 );
          if ( (*(_DWORD *)(v2 + 16) & 0x200) != 0 )
          {
            v291 = v7;
            v245 = crc32(*(_DWORD *)(v2 + 24), (char *)v6, v195);
            v7 = v291;
            *(_DWORD *)(v2 + 24) = v245;
          }
          v9 -= v195;
          v6 += v195;
          if ( v197 )
            goto LABEL_336;
          v75 = *(_DWORD *)(v2 + 16);
        }
        else
        {
LABEL_124:
          v91 = *(_DWORD *)(v2 + 32);
          if ( v91 )
            *(_DWORD *)(v91 + 28) = v90;
        }
        *(_DWORD *)v2 = 7;
        v92 = v75 & 0x1000;
        *(_DWORD *)(v2 + 64) = 0;
        if ( (v75 & 0x1000) != 0 )
        {
LABEL_129:
          if ( !v9 )
            goto LABEL_336;
          v93 = 0;
          do
          {
            v94 = *(_DWORD *)(v2 + 32);
            v95 = v6[v93++];
            if ( v94 )
            {
              v96 = *(_DWORD *)(v94 + 36);
              if ( v96 )
              {
                v97 = *(_DWORD *)(v94 + 40);
                v98 = *(_DWORD *)(v2 + 64);
                if ( v98 < v97 )
                {
                  *(_BYTE *)(v96 + v98) = v95;
                  *(_DWORD *)(v2 + 64) = v98 + 1;
                }
              }
            }
            v99 = 1;
            if ( v95 )
              v99 = v93 >= v9;
          }
          while ( !v99 );
          if ( (*(_DWORD *)(v2 + 16) & 0x200) != 0 )
          {
            v289 = v7;
            v242 = crc32(*(_DWORD *)(v2 + 24), (char *)v6, v93);
            v7 = v289;
            *(_DWORD *)(v2 + 24) = v242;
          }
          v9 -= v93;
          v6 += v93;
          if ( v95 )
            goto LABEL_336;
          v75 = *(_DWORD *)(v2 + 16);
        }
        else
        {
LABEL_332:
          v202 = *(_DWORD *)(v2 + 32);
          if ( v202 )
            *(_DWORD *)(v202 + 36) = v92;
        }
        *(_DWORD *)v2 = 8;
LABEL_144:
        if ( (v75 & 0x200) != 0 )
        {
          if ( v4 <= 15 )
          {
            if ( !v9 )
              goto LABEL_336;
            v100 = v6;
            while ( 1 )
            {
              v101 = *v100++;
              --v9;
              v6 = v100;
              v102 = v101 << v4;
              v4 += 8;
              v8 += v102;
              if ( v4 > 15 )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( *(unsigned __int16 *)(v2 + 24) != v8 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"header crc mismatch";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v4 = 0;
          v8 = 0;
        }
        v204 = *(_DWORD *)(v2 + 32);
        if ( v204 )
        {
          *(_DWORD *)(v204 + 44) = (v75 >> 9) & 1;
          *(_DWORD *)(v204 + 48) = 1;
        }
        v288 = v7;
        v205 = crc32(0, 0, 0);
        v7 = v288;
        *(_DWORD *)(v2 + 24) = v205;
        v3 = 11;
        v288[12] = v205;
        *(_DWORD *)v2 = 11;
        continue;
      case 2:
        if ( v4 <= 31 )
          goto LABEL_78;
        goto LABEL_82;
      case 3:
        if ( v4 > 15 )
          goto LABEL_91;
        goto LABEL_87;
      case 4:
        v74 = *(_DWORD *)(v2 + 16);
        v75 = v74;
        if ( (v74 & 0x400) == 0 )
          goto LABEL_334;
        if ( v4 > 15 )
          goto LABEL_102;
        goto LABEL_98;
      case 5:
        v75 = *(_DWORD *)(v2 + 16);
        v80 = v75 & 0x400;
        goto LABEL_107;
      case 6:
        v75 = *(_DWORD *)(v2 + 16);
        v90 = v75 & 0x800;
        if ( (v75 & 0x800) != 0 )
          goto LABEL_317;
        goto LABEL_124;
      case 7:
        v75 = *(_DWORD *)(v2 + 16);
        v92 = v75 & 0x1000;
        if ( (v75 & 0x1000) != 0 )
          goto LABEL_129;
        goto LABEL_332;
      case 8:
        v75 = *(_DWORD *)(v2 + 16);
        goto LABEL_144;
      case 9:
        if ( v4 > 31 )
          goto LABEL_17;
        if ( !v9 )
          goto LABEL_336;
        v10 = v6;
        while ( 1 )
        {
          v11 = *v10++;
          --v9;
          v6 = v10;
          v12 = v11 << v4;
          v4 += 8;
          v8 += v12;
          if ( v4 > 31 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_17:
        v13 = HIBYTE(v8) + (v8 << 24);
        v14 = (v8 >> 8) & 0xFF00;
        v15 = v8 & 0xFF00;
        v8 = 0;
        v16 = v13 + v14 + (v15 << 8);
        v4 = 0;
        *(_DWORD *)(v2 + 24) = v16;
        v7[12] = v16;
        *(_DWORD *)v2 = 10;
LABEL_18:
        if ( !*(_DWORD *)(v2 + 12) )
        {
          v270 = v9;
          v271 = v8;
          v272 = v7;
          v273 = v6;
          v272[3] = (unsigned int)dest;
          v64 = 2;
          v272[4] = n;
          *v272 = (unsigned int)v273;
          v272[1] = v270;
          *(_DWORD *)(v2 + 56) = v271;
          *(_DWORD *)(v2 + 60) = v4;
          return v64;
        }
        v282 = v7;
        v17 = adler32(0, 0, 0);
        v7 = v282;
        *(_DWORD *)(v2 + 24) = v17;
        v282[12] = v17;
        *(_DWORD *)v2 = 11;
LABEL_20:
        if ( v312 <= 1 )
          goto LABEL_336;
LABEL_21:
        if ( *(_DWORD *)(v2 + 4) )
        {
          v3 = 26;
          v8 >>= v4 & 7;
          v4 &= 4294967288u;
          *(_DWORD *)v2 = 26;
          continue;
        }
        if ( v4 <= 2 )
        {
          if ( !v9 )
            goto LABEL_336;
          v18 = *v6++;
          --v9;
          v19 = v18 << v4;
          v4 += 8;
          v8 += v19;
        }
        *(_DWORD *)(v2 + 4) = v8 & 1;
        v20 = (v8 >> 1) & 3;
        switch ( v20 )
        {
          case 2:
            v3 = 16;
            *(_DWORD *)v2 = 16;
            break;
          case 3:
            v3 = 29;
            v7[6] = (unsigned int)"invalid block type";
            *(_DWORD *)v2 = 29;
            break;
          case 1:
            *(_DWORD *)(v2 + 76) = "`\a";
            v3 = 19;
            *(_DWORD *)(v2 + 80) = &distfix_6142;
            *(_DWORD *)(v2 + 84) = 9;
            *(_DWORD *)(v2 + 88) = 5;
            *(_DWORD *)v2 = 19;
            if ( a2 == 6 )
            {
              v114 = v9;
              v115 = v8 >> 3;
              v116 = v7;
              v4 -= 3;
              v117 = v6;
              v64 = v306;
              goto LABEL_184;
            }
            break;
          default:
            v3 = 13;
            *(_DWORD *)v2 = 13;
            break;
        }
        v8 >>= 3;
        v4 -= 3;
        continue;
      case 10:
        goto LABEL_18;
      case 11:
        goto LABEL_20;
      case 12:
        goto LABEL_21;
      case 13:
        v132 = v4 & 7;
        v4 &= 4294967288u;
        v8 >>= v132;
        if ( v4 > 31 )
          goto LABEL_214;
        if ( !v9 )
          goto LABEL_336;
        v133 = v6;
        while ( 1 )
        {
          v134 = *v133++;
          --v9;
          v6 = v133;
          v135 = v134 << v4;
          v4 += 8;
          v8 += v135;
          if ( v4 > 31 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_214:
        v136 = (unsigned __int16)v8;
        if ( (unsigned __int16)v8 != (HIWORD(v8) ^ 0xFFFF) )
        {
          v3 = 29;
          v7[6] = (unsigned int)"invalid stored block lengths";
          *(_DWORD *)v2 = 29;
          continue;
        }
        *(_DWORD *)(v2 + 64) = (unsigned __int16)v8;
        *(_DWORD *)v2 = 14;
        if ( a2 != 6 )
        {
          v4 = 0;
          v8 = 0;
LABEL_217:
          *(_DWORD *)v2 = 15;
LABEL_218:
          if ( !v136 )
          {
            v3 = 11;
            *(_DWORD *)v2 = 11;
            continue;
          }
          if ( v9 < v136 )
            v136 = v9;
          if ( v136 >= n )
            v136 = n;
          if ( v136 )
          {
            v285 = v7;
            v9 -= v136;
            memcpy(dest, v6, v136);
            v6 += v136;
            n -= v136;
            v3 = *(_DWORD *)v2;
            *(_DWORD *)(v2 + 64) -= v136;
            v7 = v285;
            dest += v136;
            continue;
          }
LABEL_336:
          v114 = v9;
          v115 = v8;
          v116 = v7;
          v117 = v6;
          v64 = v306;
          goto LABEL_184;
        }
        v4 = 0;
        v114 = v9;
        v116 = v7;
        v115 = 0;
        v117 = v6;
        v64 = v306;
        break;
      case 14:
        v136 = *(_DWORD *)(v2 + 64);
        goto LABEL_217;
      case 15:
        v136 = *(_DWORD *)(v2 + 64);
        goto LABEL_218;
      case 16:
        if ( v4 > 13 )
          goto LABEL_231;
        if ( !v9 )
          goto LABEL_336;
        v137 = v6;
        while ( 1 )
        {
          v138 = *v137++;
          --v9;
          v6 = v137;
          v139 = v138 << v4;
          v4 += 8;
          v8 += v139;
          if ( v4 > 13 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_231:
        v140 = (v8 & 0x1F) + 257;
        v141 = ((v8 >> 5) & 0x1F) + 1;
        v142 = ((v8 >> 10) & 0xF) + 4;
        v4 -= 14;
        *(_DWORD *)(v2 + 96) = v140;
        v8 >>= 14;
        *(_DWORD *)(v2 + 100) = v141;
        *(_DWORD *)(v2 + 92) = v142;
        if ( v140 > 286 || v141 > 30 )
        {
          v3 = 29;
          v7[6] = (unsigned int)"too many length or distance symbols";
          *(_DWORD *)v2 = 29;
          continue;
        }
        v143 = 0;
        *(_DWORD *)(v2 + 104) = 0;
        *(_DWORD *)v2 = 17;
LABEL_235:
        v144 = &order_6170[v143 - 1];
        do
        {
          ++v143;
          if ( v4 <= 2 )
          {
            if ( !v9 )
              goto LABEL_336;
            v145 = *v6++;
            --v9;
            v146 = v145 << v4;
            v4 += 8;
            v8 += v146;
          }
          v147 = (unsigned __int16)v144[1];
          ++v144;
          v148 = v8 & 7;
          v4 -= 3;
          *(_DWORD *)(v2 + 104) = v143;
          v8 >>= 3;
          *(_WORD *)(v2 + 2 * (v147 + 56)) = v148;
        }
        while ( v143 < v142 );
LABEL_240:
        if ( v143 <= 18 )
        {
          v149 = &order_6170[v143 - 1];
          do
          {
            v150 = (unsigned __int16)v149[1];
            ++v149;
            *(_WORD *)(v2 + 2 * (v150 + 56)) = 0;
          }
          while ( v149 != (__int16 *)&unk_6A934 );
          *(_DWORD *)(v2 + 104) = 19;
        }
        *(_DWORD *)(v2 + 108) = v2 + 1328;
        *(_DWORD *)(v2 + 76) = v2 + 1328;
        *(_DWORD *)(v2 + 84) = 7;
        v286 = v7;
        v151 = inflate_table(0, v2 + 112, 19u, (int *)(v2 + 108), (unsigned int *)(v2 + 84), (void **)(v2 + 752));
        v7 = v286;
        v306 = v151;
        if ( v151 )
        {
          v3 = 29;
          v286[6] = (unsigned int)"invalid code lengths set";
          *(_DWORD *)v2 = 29;
          continue;
        }
        v152 = 0;
        *(_DWORD *)(v2 + 104) = 0;
        *(_DWORD *)v2 = 18;
LABEL_247:
        v313 = *(_DWORD *)(v2 + 96);
        v309 = v7;
        v153 = *(_DWORD *)(v2 + 100) + v313;
        v300 = v153;
        while ( v152 < v153 )
        {
          v154 = *(_DWORD *)(v2 + 76);
          v155 = (1 << *(_DWORD *)(v2 + 84)) - 1;
          v156 = v154 + 4 * (v8 & v155);
          v157 = *(unsigned __int8 *)(v156 + 1);
          v158 = *(unsigned __int16 *)(v156 + 2);
          if ( v4 < v157 )
          {
            if ( !v9 )
              goto LABEL_347;
            v159 = v6;
            while ( 1 )
            {
              v160 = *v159++;
              --v9;
              v6 = v159;
              v161 = v160 << v4;
              v4 += 8;
              v8 += v161;
              v162 = v154 + 4 * (v8 & v155);
              v157 = *(unsigned __int8 *)(v162 + 1);
              v158 = *(unsigned __int16 *)(v162 + 2);
              if ( v157 <= v4 )
                break;
              if ( !v9 )
                goto LABEL_347;
            }
          }
          if ( v158 <= 15 )
          {
            v241 = v152 + 56;
            ++v152;
            *(_WORD *)(v2 + 2 * v241) = v158;
            v8 >>= v157;
            v4 -= v157;
            *(_DWORD *)(v2 + 104) = v152;
            v153 = v300;
          }
          else
          {
            if ( v158 == 16 )
            {
              if ( v4 < v157 + 2 )
              {
                if ( !v9 )
                  goto LABEL_347;
                v262 = v6;
                while ( 1 )
                {
                  v263 = *v262++;
                  --v9;
                  v6 = v262;
                  v264 = v263 << v4;
                  v4 += 8;
                  v8 += v264;
                  if ( v4 >= v157 + 2 )
                    break;
                  if ( !v9 )
                    goto LABEL_347;
                }
              }
              v8 >>= v157;
              v4 -= v157;
              if ( !v152 )
              {
LABEL_471:
                v7 = v309;
                v309[6] = (unsigned int)"invalid bit length repeat";
                v3 = 29;
                *(_DWORD *)v2 = 29;
                goto LABEL_11;
              }
              v4 -= 2;
              v169 = *(_WORD *)(v2 + 2 * (v152 + 55));
              v168 = (v8 & 3) + 3;
              v8 >>= 2;
            }
            else if ( v158 == 17 )
            {
              if ( v4 < v157 + 3 )
              {
                if ( !v9 )
                {
LABEL_347:
                  v117 = v6;
                  v114 = v9;
                  v64 = v306;
                  v115 = v8;
                  v116 = v309;
                  goto LABEL_184;
                }
                v265 = v6;
                while ( 1 )
                {
                  v266 = *v265++;
                  --v9;
                  v6 = v265;
                  v267 = v266 << v4;
                  v4 += 8;
                  v8 += v267;
                  if ( v4 >= v157 + 3 )
                    break;
                  if ( !v9 )
                    goto LABEL_347;
                }
              }
              v268 = v8 >> v157;
              v4 += -3 - v157;
              v168 = (v268 & 7) + 3;
              v8 = v268 >> 3;
              v169 = 0;
            }
            else
            {
              if ( v4 < v157 + 7 )
              {
                if ( !v9 )
                  goto LABEL_347;
                v163 = v6;
                while ( 1 )
                {
                  v164 = *v163++;
                  --v9;
                  v6 = v163;
                  v165 = v164 << v4;
                  v4 += 8;
                  v8 += v165;
                  if ( v4 >= v157 + 7 )
                    break;
                  if ( !v9 )
                    goto LABEL_347;
                }
              }
              v166 = v8 >> v157;
              v167 = v166 & 0x7F;
              v8 = v166 >> 7;
              v4 += -7 - v157;
              v168 = v167 + 11;
              v169 = 0;
            }
            v318 = v168 + v152;
            if ( v168 + v152 > v300 )
              goto LABEL_471;
            v170 = v168 - 1;
            v171 = ((v2 + 2 * (v152 + 56)) >> 1) & 1;
            if ( v168 < v171 )
              v171 = v168;
            if ( (v171 & 1) != 0 )
            {
              v172 = v152;
              v173 = v2 + 2 * (v152 + 55);
              do
              {
                ++v172;
                *(_WORD *)(v173 + 2) = v169;
                v173 += 2;
                --v170;
              }
              while ( v171 > v172 - v152 );
            }
            else
            {
              v172 = v152;
            }
            v321 = v168 - v171;
            v316 = (v168 - v171) >> 1;
            v320 = 2 * v316;
            if ( !v316 )
              goto LABEL_278;
            v174 = v169 | (v169 << 16);
            v175 = (v168 - v171) >> 1;
            v176 = (int *)(v2 + 2 * (v152 + 56 + v171));
            if ( v316 <= 8 )
            {
              v179 = 0;
            }
            else
            {
              v177 = v176 + 8;
              v178 = 0;
              do
              {
                v179 = v178 + 8;
                v99 = v178 + 9 >= v316 - 7;
                __pld(v177 + 32);
                *(v177 - 8) = v174;
                v176 = v177;
                *(v177 - 7) = v174;
                v178 += 8;
                *(v177 - 6) = v174;
                *(v177 - 5) = v174;
                *(v177 - 4) = v174;
                *(v177 - 3) = v174;
                *(v177 - 2) = v174;
                *(v177 - 1) = v174;
                v177 += 8;
              }
              while ( !v99 );
              v175 = v316;
            }
            do
            {
              ++v179;
              *v176++ = v174;
            }
            while ( v175 > v179 );
            v170 -= v320;
            v172 += v320;
            if ( v321 != v320 )
            {
LABEL_278:
              if ( v170 > 15 )
              {
                v180 = v172 + 56;
                v181 = (unsigned __int16 *)(v2 + 2 * (v172 + 56));
                do
                {
                  v170 -= 16;
                  *v181 = v169;
                  v172 += 16;
                  __pld((void *)(v2 + 2 * v180 + 80));
                  v181[1] = v169;
                  v180 = v172 + 56;
                  v181[2] = v169;
                  v181[3] = v169;
                  v181[4] = v169;
                  v181[5] = v169;
                  v181[6] = v169;
                  v181[7] = v169;
                  v181[8] = v169;
                  v181[9] = v169;
                  v181[10] = v169;
                  v181[11] = v169;
                  v181[12] = v169;
                  v181[13] = v169;
                  v181[14] = v169;
                  v181[15] = v169;
                  v181 += 16;
                }
                while ( v170 > 15 );
              }
              v182 = v2 + 2 * (v172 + 55);
              do
              {
                *(_WORD *)(v182 + 2) = v169;
                v182 += 2;
              }
              while ( v182 != v2 + 112 + 2 * (v172 + v170) );
            }
            v152 = v318;
            v153 = v300;
            *(_DWORD *)(v2 + 104) = v318;
          }
        }
        v7 = v309;
        if ( !*(_WORD *)(v2 + 624) )
        {
          v3 = 29;
          v309[6] = (unsigned int)"invalid code -- missing end-of-block";
          *(_DWORD *)v2 = 29;
          continue;
        }
        *(_DWORD *)(v2 + 108) = v2 + 1328;
        *(_DWORD *)(v2 + 76) = v2 + 1328;
        *(_DWORD *)(v2 + 84) = 9;
        v278 = inflate_table(1, v2 + 112, v313, (int *)(v2 + 108), (unsigned int *)(v2 + 84), (void **)(v2 + 752));
        v7 = v309;
        v306 = v278;
        if ( v278 )
        {
          v3 = 29;
          v309[6] = (unsigned int)"invalid literal/lengths set";
          *(_DWORD *)v2 = 29;
          continue;
        }
        v279 = *(_DWORD *)(v2 + 96);
        v280 = *(_DWORD *)(v2 + 108);
        *(_DWORD *)(v2 + 88) = 6;
        *(_DWORD *)(v2 + 80) = v280;
        v281 = inflate_table(
                 2,
                 v2 + 2 * (v279 + 56),
                 *(_DWORD *)(v2 + 100),
                 (int *)(v2 + 108),
                 (unsigned int *)(v2 + 88),
                 (void **)(v2 + 752));
        v7 = v309;
        v306 = v281;
        if ( v281 )
        {
          v3 = 29;
          v309[6] = (unsigned int)"invalid distances set";
          *(_DWORD *)v2 = 29;
          continue;
        }
        *(_DWORD *)v2 = 19;
        if ( a2 == 6 )
          goto LABEL_336;
LABEL_45:
        *(_DWORD *)v2 = 20;
LABEL_46:
        v29 = n > 258;
        if ( n >= 258 )
          v29 = v9 > 5;
        if ( !v29 )
        {
          v30 = *(_DWORD *)(v2 + 84);
          v31 = *(_DWORD *)(v2 + 76);
          *(_DWORD *)(v2 + 7108) = 0;
          v298 = (unsigned int *)(v2 + 7108);
          v32 = (1 << v30) - 1;
          v33 = (unsigned __int8 *)(v31 + 4 * (v8 & v32));
          v34 = *v33;
          v35 = v33[1];
          v36 = *((unsigned __int16 *)v33 + 1);
          if ( v4 < v35 )
          {
            if ( !v9 )
              goto LABEL_336;
            v37 = v6;
            while ( 1 )
            {
              v38 = *v37++;
              --v9;
              v6 = v37;
              v39 = v38 << v4;
              v4 += 8;
              v8 += v39;
              v40 = (unsigned __int8 *)(v31 + 4 * (v8 & v32));
              v34 = *v40;
              v35 = v40[1];
              v36 = *((unsigned __int16 *)v40 + 1);
              if ( v35 <= v4 )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( !v34 )
          {
            v8 >>= v35;
            v4 -= v35;
            *(_DWORD *)(v2 + 64) = v36;
            *v298 = v35;
LABEL_58:
            v3 = 25;
            *(_DWORD *)v2 = 25;
            continue;
          }
          if ( (v34 & 0xF0) != 0 )
          {
            v8 >>= v35;
            v4 -= v35;
            *(_DWORD *)(v2 + 64) = v36;
            *v298 = v35;
          }
          else
          {
            v311 = (1 << (v35 + v34)) - 1;
            v248 = (unsigned __int8 *)(v31 + 4 * (((v311 & v8) >> v35) + v36));
            v34 = *v248;
            v249 = v248[1];
            v250 = *((unsigned __int16 *)v248 + 1);
            v251 = v35 + v249;
            if ( v4 < v35 + v249 )
            {
              if ( !v9 )
                goto LABEL_336;
              v315 = v7;
              v252 = v6;
              v313 = v2;
              while ( 1 )
              {
                v253 = *v252++;
                --v9;
                v6 = v252;
                v254 = v253 << v4;
                v4 += 8;
                v8 += v254;
                v255 = (unsigned __int8 *)(v31 + 4 * (((v8 & v311) >> v35) + v36));
                v34 = *v255;
                v249 = v255[1];
                v256 = *((unsigned __int16 *)v255 + 1);
                v251 = v249 + v35;
                if ( v249 + v35 <= v4 )
                  break;
                if ( !v9 )
                {
                  v117 = v252;
                  v114 = 0;
                  v64 = v306;
                  v115 = v8;
                  v2 = v313;
                  v116 = v315;
                  goto LABEL_184;
                }
              }
              v250 = v256;
              v2 = v313;
            }
            v4 = v4 - v35 - v249;
            v8 = v8 >> v35 >> v249;
            *(_DWORD *)(v2 + 64) = v250;
            *v298 = v251;
            if ( !v34 )
              goto LABEL_58;
          }
          if ( (v34 & 0x20) != 0 )
          {
            *(_DWORD *)v2 = 11;
            *v298 = -1;
            v3 = 11;
            continue;
          }
          if ( (v34 & 0x40) != 0 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"invalid literal/length code";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v41 = v34 & 0xF;
          *(_DWORD *)(v2 + 72) = v41;
          *(_DWORD *)v2 = 21;
          if ( v41 )
          {
LABEL_376:
            if ( v4 < v41 )
            {
              if ( !v9 )
                goto LABEL_336;
              v231 = v6;
              while ( 1 )
              {
                v232 = *v231++;
                --v9;
                v6 = v231;
                v233 = v232 << v4;
                v4 += 8;
                v8 += v233;
                if ( v4 >= v41 )
                  break;
                if ( !v9 )
                  goto LABEL_336;
              }
            }
            v43 = v2 + 7104;
            v4 -= v41;
            v234 = v8 & ((1 << v41) - 1);
            v8 >>= v41;
            v42 = v234 + *(_DWORD *)(v2 + 64);
            v235 = v41 + *(_DWORD *)(v2 + 7108);
            *(_DWORD *)(v2 + 64) = v42;
            *(_DWORD *)(v2 + 7108) = v235;
          }
          else
          {
LABEL_60:
            v42 = *(_DWORD *)(v2 + 64);
            v43 = v2 + 7104;
          }
          *(_DWORD *)(v43 + 8) = v42;
          *(_DWORD *)v2 = 22;
LABEL_62:
          v44 = *(_DWORD *)(v2 + 80);
          v45 = (1 << *(_DWORD *)(v2 + 88)) - 1;
          v46 = (char *)(v44 + 4 * (v8 & v45));
          v47 = *v46;
          v48 = (unsigned __int8)v46[1];
          v49 = *((unsigned __int16 *)v46 + 1);
          v50 = v48;
          if ( v4 < v48 )
          {
            if ( !v9 )
              goto LABEL_336;
            v51 = v6;
            while ( 1 )
            {
              v52 = *v51++;
              --v9;
              v6 = v51;
              v53 = v52 << v4;
              v4 += 8;
              v8 += v53;
              v54 = (char *)(v44 + 4 * (v8 & v45));
              v47 = *v54;
              v48 = (unsigned __int8)v54[1];
              v49 = *((unsigned __int16 *)v54 + 1);
              v50 = v48;
              if ( v48 <= v4 )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( (v47 & 0xF0) != 0 )
          {
            v62 = (_DWORD *)(v2 + 7108);
            v63 = *(_DWORD *)(v2 + 7108);
          }
          else
          {
            v55 = v48;
            v307 = v49;
            v299 = (1 << (v48 + v47)) - 1;
            v56 = (char *)(v44 + 4 * (((v299 & v8) >> v48) + v49));
            v47 = *v56;
            v48 = (unsigned __int8)v56[1];
            v49 = *((unsigned __int16 *)v56 + 1);
            if ( v4 < v55 + v48 )
            {
              if ( !v9 )
                goto LABEL_336;
              v313 = v2;
              v57 = v6;
              v58 = v307;
              v308 = v7;
              while ( 1 )
              {
                v59 = *v57++;
                --v9;
                v6 = v57;
                v60 = v59 << v4;
                v4 += 8;
                v8 += v60;
                v61 = (char *)(v44 + 4 * (((v8 & v299) >> v55) + v58));
                v47 = *v61;
                v48 = (unsigned __int8)v61[1];
                v49 = *((unsigned __int16 *)v61 + 1);
                if ( v48 + v55 <= v4 )
                  break;
                if ( !v9 )
                {
                  v117 = v57;
                  v114 = 0;
                  v64 = v306;
                  v115 = v8;
                  v2 = v313;
                  v116 = v308;
                  goto LABEL_184;
                }
              }
              v2 = v313;
            }
            v4 -= v50;
            v8 >>= v55;
            v62 = (_DWORD *)(v2 + 7108);
            v63 = v55 + *(_DWORD *)(v2 + 7108);
          }
          v8 >>= v48;
          v4 -= v48;
          *v62 = v63 + v48;
          if ( (v47 & 0x40) != 0 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"invalid distance code";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v21 = v47 & 0xF;
          *(_DWORD *)(v2 + 72) = v21;
          *(_DWORD *)(v2 + 68) = v49;
          *(_DWORD *)v2 = 23;
          if ( v21 )
          {
LABEL_32:
            if ( v4 < v21 )
            {
              if ( !v9 )
                goto LABEL_336;
              v22 = v6;
              while ( 1 )
              {
                v23 = *v22++;
                --v9;
                v6 = v22;
                v24 = v23 << v4;
                v4 += 8;
                v8 += v24;
                if ( v4 >= v21 )
                  break;
                if ( !v9 )
                  goto LABEL_336;
              }
            }
            v4 -= v21;
            v25 = v8 & ((1 << v21) - 1);
            v8 >>= v21;
            v26 = v21 + *(_DWORD *)(v2 + 7108);
            *(_DWORD *)(v2 + 68) += v25;
            *(_DWORD *)(v2 + 7108) = v26;
          }
LABEL_38:
          *(_DWORD *)v2 = 24;
LABEL_39:
          if ( !n )
            goto LABEL_336;
          v27 = *(_DWORD *)(v2 + 68);
          if ( v303 - n >= v27 )
          {
            v206 = dest;
            v28 = *(_DWORD *)(v2 + 64);
            v313 = (unsigned int)&dest[-v27];
            v207 = v28;
          }
          else
          {
            v28 = v27 - (v303 - n);
            if ( v28 > *(_DWORD *)(v2 + 44) && *(_DWORD *)(v2 + 7104) )
            {
              v3 = 29;
              v7[6] = (unsigned int)"invalid distance too far back";
              *(_DWORD *)v2 = 29;
              continue;
            }
            v236 = *(_DWORD *)(v2 + 48);
            v206 = dest;
            v237 = v28 > v236;
            if ( v28 <= v236 )
            {
              v239 = v236 - v28;
              v238 = *(_DWORD *)(v2 + 52);
            }
            else
            {
              v238 = *(_DWORD *)(v2 + 40);
              v28 -= v236;
              v239 = *(_DWORD *)(v2 + 52);
            }
            if ( v237 )
            {
              v240 = v238 - v28;
              v239 += v240;
            }
            else
            {
              v240 = v238 + v239;
            }
            if ( v237 )
              v313 = v239;
            v207 = *(_DWORD *)(v2 + 64);
            if ( !v237 )
              v313 = v240;
            if ( v28 >= v207 )
              v28 = *(_DWORD *)(v2 + 64);
          }
          v208 = (unsigned int)(v206 + 4);
          v209 = n;
          if ( v28 < n )
            v209 = v28;
          v310 = v209;
          v210 = v313 >= v208;
          if ( v313 < v208 )
            v210 = (unsigned int)dest >= v313 + 4;
          v211 = v210;
          if ( v209 <= 3 )
            v211 = 0;
          v212 = v209 >> 2;
          if ( (((unsigned __int8)v313 | (unsigned __int8)dest) & 3) != 0 )
            v213 = 0;
          else
            v213 = v211 & 1;
          v214 = v213 ^ 1;
          *(_DWORD *)(v2 + 64) = v207 - v310;
          if ( !v212 )
            v214 |= 1u;
          n -= v310;
          v314 = 4 * v212;
          if ( !v214 )
          {
            if ( v212 <= 8 )
            {
              v219 = 0;
              v221 = dest;
              v223 = v313;
            }
            else
            {
              v319 = v9;
              v215 = v212 - 7;
              v216 = dest + 32;
              v317 = v6;
              v217 = v313 + 32;
              do
              {
                v218 = *(_DWORD *)(v217 - 32);
                v29 = v215 > v214 + 9;
                v219 = v214 + 8;
                __pld((void *)(v217 + 84));
                v220 = v217;
                *(v216 - 8) = v218;
                v214 += 8;
                v221 = v216;
                *(v216 - 7) = *(_DWORD *)(v217 - 28);
                *(v216 - 6) = *(_DWORD *)(v217 - 24);
                *(v216 - 5) = *(_DWORD *)(v217 - 20);
                *(v216 - 4) = *(_DWORD *)(v217 - 16);
                *(v216 - 3) = *(_DWORD *)(v217 - 12);
                *(v216 - 2) = *(_DWORD *)(v217 - 8);
                v222 = *(_DWORD *)(v217 - 4);
                v217 += 32;
                *(v216 - 1) = v222;
                v216 += 8;
              }
              while ( v29 );
              v223 = v220;
              v9 = v319;
              v212 = v310 >> 2;
              v6 = v317;
            }
            v224 = v223 - 4;
            do
            {
              v225 = *(_DWORD *)(v224 + 4);
              v224 += 4;
              ++v219;
              *v221++ = v225;
            }
            while ( v212 > v219 );
            v313 += v314;
            v226 = &dest[v314];
            v227 = v310 - v314;
            if ( v314 != v310 )
            {
LABEL_371:
              v228 = &v226[v227];
              v229 = v313 - 1;
              do
              {
                v230 = *(_BYTE *)++v229;
                *v226++ = v230;
              }
              while ( v226 != v228 );
            }
            dest += v310;
            if ( *(_DWORD *)(v2 + 64) )
            {
              v3 = *(_DWORD *)v2;
            }
            else
            {
              v3 = 20;
              *(_DWORD *)v2 = 20;
            }
            continue;
          }
          v227 = v310;
          v226 = dest;
          goto LABEL_371;
        }
        v7[4] = n;
        *v7 = (unsigned int)v6;
        v7[3] = (unsigned int)dest;
        v7[1] = v9;
        *(_DWORD *)(v2 + 56) = v8;
        *(_DWORD *)(v2 + 60) = v4;
        v290 = v7;
        inflate_fast(v7, v303);
        v7 = v290;
        v3 = *(_DWORD *)v2;
        v8 = *(_DWORD *)(v2 + 56);
        v244 = v290[3];
        if ( *(_DWORD *)v2 == 11 )
          v243 = -1;
        v6 = (unsigned __int8 *)*v290;
        dest = (_BYTE *)v290[3];
        if ( *(_DWORD *)v2 == 11 )
          v244 = v2 + 7104;
        v9 = v290[1];
        n = v290[4];
        v4 = *(_DWORD *)(v2 + 60);
        if ( *(_DWORD *)v2 == 11 )
          *(_DWORD *)(v244 + 4) = v243;
        continue;
      case 17:
        v142 = *(_DWORD *)(v2 + 92);
        v143 = *(_DWORD *)(v2 + 104);
        if ( v142 > v143 )
          goto LABEL_235;
        goto LABEL_240;
      case 18:
        v152 = *(_DWORD *)(v2 + 104);
        goto LABEL_247;
      case 19:
        goto LABEL_45;
      case 20:
        goto LABEL_46;
      case 21:
        v41 = *(_DWORD *)(v2 + 72);
        if ( !v41 )
          goto LABEL_60;
        goto LABEL_376;
      case 22:
        goto LABEL_62;
      case 23:
        v21 = *(_DWORD *)(v2 + 72);
        if ( v21 )
          goto LABEL_32;
        goto LABEL_38;
      case 24:
        goto LABEL_39;
      case 25:
        if ( !n )
          goto LABEL_336;
        --n;
        v3 = 20;
        *dest = *(_DWORD *)(v2 + 64);
        *(_DWORD *)v2 = 20;
        ++dest;
        continue;
      case 26:
        v183 = *(_DWORD *)(v2 + 8);
        if ( !v183 )
          goto LABEL_383;
        if ( v4 > 31 )
          goto LABEL_293;
        if ( !v9 )
          goto LABEL_336;
        v184 = v6;
        while ( 1 )
        {
          v185 = *v184++;
          --v9;
          v6 = v184;
          v186 = v185 << v4;
          v4 += 8;
          v8 += v186;
          if ( v4 > 31 )
            break;
          if ( !v9 )
            goto LABEL_336;
        }
LABEL_293:
        v187 = v303 - n;
        v188 = *(_DWORD *)(v2 + 28) + v303 - n;
        v7[5] += v303 - n;
        *(_DWORD *)(v2 + 28) = v188;
        if ( v303 != n )
        {
          v189 = *(_DWORD *)(v2 + 24);
          v287 = v7;
          if ( *(_DWORD *)(v2 + 16) )
            v190 = crc32(v189, &dest[-v187], v187);
          else
            v190 = adler32(v189, &dest[-v187], v187);
          v7 = v287;
          *(_DWORD *)(v2 + 24) = v190;
          v287[12] = v190;
        }
        v191 = v8;
        if ( !*(_DWORD *)(v2 + 16) )
          v191 = HIBYTE(v8) + (v8 << 24) + ((v8 >> 8) & 0xFF00) + ((v8 & 0xFF00) << 8);
        if ( v191 != *(_DWORD *)(v2 + 24) )
        {
          v3 = 29;
          v7[6] = (unsigned int)"incorrect data check";
          v303 = n;
          *(_DWORD *)v2 = 29;
          continue;
        }
        v183 = *(_DWORD *)(v2 + 8);
        v4 = 0;
        v8 = 0;
        v303 = n;
LABEL_383:
        *(_DWORD *)v2 = 27;
LABEL_302:
        if ( v183 && *(_DWORD *)(v2 + 16) )
        {
          if ( v4 <= 31 )
          {
            if ( !v9 )
              goto LABEL_336;
            v192 = v6;
            while ( 1 )
            {
              v193 = *v192++;
              --v9;
              v6 = v192;
              v194 = v193 << v4;
              v4 += 8;
              v8 += v194;
              if ( v4 > 31 )
                break;
              if ( !v9 )
                goto LABEL_336;
            }
          }
          if ( *(_DWORD *)(v2 + 28) != v8 )
          {
            v3 = 29;
            v7[6] = (unsigned int)"incorrect length check";
            *(_DWORD *)v2 = 29;
            continue;
          }
          v4 = 0;
          v114 = v9;
          v116 = v7;
          v115 = 0;
          v117 = v6;
        }
        else
        {
          v114 = v9;
          v115 = v8;
          v116 = v7;
          v117 = v6;
        }
        v64 = 1;
        *(_DWORD *)v2 = 28;
        break;
      case 27:
        v183 = *(_DWORD *)(v2 + 8);
        goto LABEL_302;
      case 28:
        v114 = v9;
        v115 = v8;
        v116 = v7;
        v117 = v6;
        v64 = 1;
        goto LABEL_184;
      case 29:
        v114 = v9;
        v115 = v8;
        v116 = v7;
        v117 = v6;
        v64 = -3;
        goto LABEL_184;
      case 30:
        return -4;
      default:
        return -2;
    }
    break;
  }
LABEL_184:
  v118 = *(_DWORD *)(v2 + 40);
  *v116 = (unsigned int)v117;
  v116[3] = (unsigned int)dest;
  v116[4] = n;
  v116[1] = v114;
  *(_DWORD *)(v2 + 56) = v115;
  *(_DWORD *)(v2 + 60) = v4;
  if ( (v118 || n != v303 && *(_DWORD *)v2 <= 28u && (*(_DWORD *)v2 <= 25u || a2 != 4))
    && updatewindow((int)v116, (int)dest, v303 - n) )
  {
    v64 = -4;
    *(_DWORD *)v2 = 30;
    return v64;
  }
  v119 = v304 - v116[1];
  v120 = v116[5];
  v121 = v303 - v116[4];
  v122 = *(_DWORD *)(v2 + 8);
  v123 = *(_DWORD *)(v2 + 28) + v121;
  v116[2] += v119;
  v116[5] = v120 + v121;
  *(_DWORD *)(v2 + 28) = v123;
  if ( v122 && v121 )
  {
    v124 = *(_DWORD *)(v2 + 24);
    v125 = (char *)(v116[3] - v121);
    if ( *(_DWORD *)(v2 + 16) )
      v126 = crc32(v124, v125, v121);
    else
      v126 = adler32(v124, (unsigned __int8 *)v125, v121);
    *(_DWORD *)(v2 + 24) = v126;
    v116[12] = v126;
  }
  v127 = *(_DWORD *)v2;
  if ( *(_DWORD *)(v2 + 4) )
    v128 = 64;
  else
    v128 = 0;
  v129 = v128 + *(_DWORD *)(v2 + 60);
  if ( v127 == 11 )
  {
    v129 += 128;
  }
  else
  {
    v130 = v127 == 19;
    if ( v127 != 19 )
      v130 = v127 == 14;
    if ( v130 )
    {
      v131 = 256;
      goto LABEL_204;
    }
  }
  v131 = 0;
LABEL_204:
  v116[11] = v129 + v131;
  if ( (!(v121 | v119) || a2 == 4) && !v64 )
    return -5;
  return v64;
}
// 547FE: masking with 0x1 was optimized away because r4.1 <= 0x1
// 547E4: variable 'v313' is possibly undefined
// 54A96: variable 'v243' is possibly undefined
// 6A890: using guessed type void *distfix_6142;
// 6A910: using guessed type __int16 order_6170[7];

//----- (0005501C) --------------------------------------------------------
int __fastcall inflateEnd(_DWORD *a1)
{
  int v2; // r1
  void (__fastcall *v3)(_DWORD, int); // r3
  int result; // r0

  if ( !a1 )
    return -2;
  v2 = a1[7];
  if ( !v2 )
    return -2;
  v3 = (void (__fastcall *)(_DWORD, int))a1[9];
  if ( !v3 )
    return -2;
  if ( *(_DWORD *)(v2 + 52) )
  {
    v3(a1[10], *(_DWORD *)(v2 + 52));
    v3 = (void (__fastcall *)(_DWORD, int))a1[9];
    v2 = a1[7];
  }
  v3(a1[10], v2);
  result = 0;
  a1[7] = 0;
  return result;
}

//----- (00055048) --------------------------------------------------------
int __fastcall inflateGetDictionary(int a1, void *dest, _DWORD *a3)
{
  int v5; // r4
  int v6; // r2
  int result; // r0

  if ( !a1 )
    return -2;
  v5 = *(_DWORD *)(a1 + 28);
  if ( !v5 )
    return -2;
  v6 = *(_DWORD *)(v5 + 44);
  if ( v6 && dest )
  {
    memcpy(dest, (const void *)(*(_DWORD *)(v5 + 52) + *(_DWORD *)(v5 + 48)), v6 - *(_DWORD *)(v5 + 48));
    memcpy((char *)dest + *(_DWORD *)(v5 + 44) - *(_DWORD *)(v5 + 48), *(const void **)(v5 + 52), *(_DWORD *)(v5 + 48));
  }
  result = 0;
  if ( a3 )
    *a3 = *(_DWORD *)(v5 + 44);
  return result;
}

//----- (0005508C) --------------------------------------------------------
int __fastcall inflateSetDictionary(int a1, unsigned __int8 *a2, size_t n)
{
  _DWORD *v6; // r4
  int result; // r0
  int v8; // r0

  if ( !a1 )
    return -2;
  v6 = *(_DWORD **)(a1 + 28);
  if ( !v6 )
    return -2;
  if ( v6[2] )
  {
    if ( *v6 == 10 )
    {
LABEL_8:
      v8 = adler32(0, 0, 0);
      if ( v6[6] != adler32(v8, a2, n) )
        return -3;
      goto LABEL_5;
    }
    return -2;
  }
  if ( *v6 == 10 )
    goto LABEL_8;
LABEL_5:
  result = updatewindow(a1, (int)&a2[n], n);
  if ( result )
  {
    result = -4;
    *v6 = 30;
  }
  else
  {
    v6[3] = 1;
  }
  return result;
}

//----- (000550EC) --------------------------------------------------------
int __fastcall inflateGetHeader(int a1, int a2)
{
  int v2; // r3
  int result; // r0

  if ( !a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 28);
  if ( !v2 || (*(_DWORD *)(v2 + 8) & 2) == 0 )
    return -2;
  *(_DWORD *)(v2 + 32) = a2;
  result = 0;
  *(_DWORD *)(a2 + 48) = 0;
  return result;
}

//----- (00055108) --------------------------------------------------------
int __fastcall inflateSync(int *a1)
{
  _DWORD *v2; // r4
  unsigned int v3; // r0
  int v4; // r3
  int v5; // r2
  char v6; // r1
  unsigned int v7; // r3
  int v8; // r1
  unsigned int v9; // r7
  unsigned int v10; // r2
  char *v11; // r3
  unsigned int v12; // r7
  unsigned int v13; // r3
  int v14; // r1
  bool v15; // r2
  int v17; // r0
  int v18; // r2
  int v19; // r7
  bool v20; // r1
  int v22; // r5
  int v23; // r0
  int v24; // r1
  int v25; // r0
  int v26; // r2
  int result; // r0
  int v28; // r1
  int v29; // r7
  char v30[37]; // [sp+3h] [bp-25h] BYREF

  if ( !a1 )
    return -2;
  v2 = (_DWORD *)a1[7];
  if ( !v2 )
    return -2;
  v3 = a1[1];
  if ( !v3 && v2[15] <= 7u )
    return -5;
  if ( *v2 == 31 )
  {
    v13 = v2[26];
    v15 = v13 <= 3;
  }
  else
  {
    v4 = v2[15];
    v5 = v2[14];
    *v2 = 31;
    v6 = v4 & 7;
    v7 = v4 & 0xFFFFFFF8;
    v2[15] = v7;
    v8 = v5 << v6;
    v2[14] = v8;
    if ( v7 <= 7 )
    {
      v15 = 1;
      v13 = 0;
      v2[26] = 0;
    }
    else
    {
      v9 = (v7 - 8) >> 3;
      v10 = v8;
      v11 = v30;
      do
      {
        *++v11 = v8;
        v10 >>= 8;
        LOBYTE(v8) = v10;
      }
      while ( v11 != &v30[v9 + 1] );
      v12 = v9 + 1;
      v13 = 0;
      v2[14] = v10;
      v14 = 0;
      v2[15] = 0;
      v2[26] = 0;
      do
      {
        if ( v13 <= 1 )
          v17 = 0;
        else
          v17 = 255;
        if ( (unsigned __int8)v30[v14 + 1] == v17 )
        {
          v15 = ++v13 <= 3;
        }
        else
        {
          v13 = 4 - v13;
          if ( v30[v14 + 1] )
          {
            v15 = 1;
            v13 = 0;
          }
          else
          {
            v15 = v13 <= 3;
          }
        }
      }
      while ( ++v14 < v12 && v15 );
    }
    v2[26] = v13;
    v3 = a1[1];
  }
  if ( v3 )
    v18 = v15;
  else
    v18 = 0;
  v19 = *a1;
  if ( v18 )
  {
    v18 = 0;
    do
    {
      if ( v13 <= 1 )
        v22 = 0;
      else
        v22 = 255;
      if ( *(unsigned __int8 *)(v19 + v18) == v22 )
      {
        v20 = ++v13 <= 3;
      }
      else
      {
        v13 = 4 - v13;
        if ( *(_BYTE *)(v19 + v18) )
        {
          v20 = 1;
          v13 = 0;
        }
        else
        {
          v20 = v13 <= 3;
        }
      }
    }
    while ( v3 > ++v18 && v20 );
  }
  v2[26] = v13;
  v23 = a1[1];
  v24 = a1[2];
  *a1 = v19 + v18;
  v25 = v23 - v18;
  v26 = v18 + v24;
  a1[1] = v25;
  a1[2] = v26;
  if ( v13 != 4 )
    return -3;
  v28 = v2[2];
  v29 = a1[5];
  v2[10] = 0;
  v2[11] = 0;
  v2[12] = 0;
  v2[7] = 0;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( v28 )
    a1[12] = v28 & 1;
  result = 0;
  v2[1] = 0;
  v2[3] = 0;
  v2[8] = 0;
  v2[14] = 0;
  v2[15] = 0;
  v2[5] = 32768;
  v2[27] = v2 + 332;
  v2[20] = v2 + 332;
  v2[19] = v2 + 332;
  v2[1776] = 1;
  v2[1777] = -1;
  a1[2] = v26;
  a1[5] = v29;
  *v2 = 11;
  return result;
}

//----- (000552B4) --------------------------------------------------------
int __fastcall inflateSyncPoint(int a1)
{
  _DWORD *v1; // r3

  if ( !a1 )
    return -2;
  v1 = *(_DWORD **)(a1 + 28);
  if ( !v1 )
    return -2;
  if ( *v1 == 13 )
    return v1[15] == 0;
  return 0;
}

//----- (000552D8) --------------------------------------------------------
int __fastcall inflateCopy(_DWORD *a1, int *a2)
{
  bool v2; // zf
  int v5; // r5
  int (__fastcall *v6)(int, int, int); // r3
  _DWORD *v7; // r6
  void *v8; // r7
  int *v9; // r3
  _DWORD *v10; // r4
  int *v11; // r2
  int v12; // r12
  int v13; // lr
  int v14; // r0
  int v15; // r1
  int v16; // lr
  int v17; // r3
  unsigned int v18; // r1
  int v19; // r3
  int result; // r0
  unsigned int v21; // r2

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 )
    return -2;
  v5 = a2[7];
  if ( !v5 )
    return -2;
  v6 = (int (__fastcall *)(int, int, int))a2[8];
  if ( !v6 || !a2[9] )
    return -2;
  v7 = (_DWORD *)v6(a2[10], 1, 7116);
  if ( !v7 )
    return -4;
  v8 = *(void **)(v5 + 52);
  if ( v8 && (v8 = (void *)((int (__fastcall *)(int, int, int))a2[8])(a2[10], 1 << *(_DWORD *)(v5 + 36), 1)) == 0 )
  {
    ((void (__fastcall *)(int, _DWORD *))a2[9])(a2[10], v7);
    return -4;
  }
  else
  {
    v9 = a2;
    v10 = a1;
    v11 = v9 + 12;
    do
    {
      v12 = *v9;
      v13 = v9[1];
      v14 = v9[2];
      v15 = v9[3];
      v9 += 4;
      *v10 = v12;
      v10[1] = v13;
      v10[2] = v14;
      v10[3] = v15;
      v10 += 4;
    }
    while ( v9 != v11 );
    v16 = *v9;
    v17 = v9[1];
    *v10 = v16;
    v10[1] = v17;
    memcpy(v7, (const void *)v5, 7116u);
    v18 = *(_DWORD *)(v5 + 76);
    v19 = v5 + 1328;
    if ( v18 >= v5 + 1328 && v18 <= v5 + 7100 )
    {
      v21 = (*(_DWORD *)(v5 + 80) - v19) & 0xFFFFFFFC;
      v7[19] = (char *)v7 + ((v18 - v19) & 0xFFFFFFFC) + 1328;
      v7[20] = (char *)v7 + v21 + 1328;
    }
    v7[27] = (char *)v7 + ((*(_DWORD *)(v5 + 108) - v19) & 0xFFFFFFFC) + 1328;
    if ( v8 )
      memcpy(v8, *(const void **)(v5 + 52), 1 << *(_DWORD *)(v5 + 36));
    v7[13] = v8;
    result = 0;
    a1[7] = v7;
  }
  return result;
}

//----- (000553E8) --------------------------------------------------------
int __fastcall inflateUndermine(int a1)
{
  int v1; // r3

  if ( !a1 )
    return -2;
  v1 = *(_DWORD *)(a1 + 28);
  if ( !v1 )
    return -2;
  *(_DWORD *)(v1 + 7104) = 1;
  return -3;
}

//----- (00055404) --------------------------------------------------------
int __fastcall inflateMark(int a1)
{
  int *v1; // r3
  _DWORD *v2; // r1
  int v3; // r2
  int v4; // r0
  bool v5; // zf
  int v6; // r0
  bool v7; // zf

  if ( !a1 )
    return -65536;
  v1 = *(int **)(a1 + 28);
  if ( !v1 )
    return -65536;
  v2 = v1 + 1776;
  v3 = *v1;
  v4 = v1[1777];
  v5 = *v1 == 15;
  if ( *v1 == 15 )
    v1 = (int *)v1[16];
  v6 = v4 << 16;
  if ( !v5 )
  {
    v7 = v3 == 24;
    if ( v3 == 24 )
      v3 = v2[2];
    else
      v1 = 0;
    if ( v7 )
      v1 = (int *)(v3 - v1[16]);
  }
  return (int)v1 + v6;
}

//----- (00055438) --------------------------------------------------------
int __fastcall inflate_table(int a1, int a2, unsigned int a3, int *a4, unsigned int *a5, void **a6)
{
  int v6; // r5
  unsigned __int16 *v7; // r3
  int v8; // r6
  unsigned int v9; // r4
  _WORD *v10; // r6
  _WORD *v11; // r6
  _WORD *v12; // r6
  _WORD *v13; // r6
  _WORD *v14; // r6
  _WORD *v15; // r6
  _WORD *v16; // r6
  _WORD *v17; // r6
  _WORD *v18; // r6
  _WORD *v19; // r6
  _WORD *v20; // r6
  _WORD *v21; // r6
  _WORD *v22; // r6
  _WORD *v23; // r6
  int v24; // r6
  int v25; // r5
  int v26; // t1
  unsigned int v27; // r5
  int v28; // r6
  int result; // r0
  int v30; // r3
  int v31; // r4
  unsigned int v32; // r9
  int v33; // r3
  unsigned int v34; // r10
  int v35; // r3
  int v36; // r3
  int v37; // r3
  int v38; // r3
  int v39; // r3
  int v40; // r3
  int v41; // r3
  int v42; // r3
  int v43; // r3
  int v44; // r4
  int v45; // r3
  int v46; // r3
  int v47; // r3
  _BOOL4 v48; // r3
  int v49; // r3
  int v50; // r4
  int v51; // r6
  int v52; // t1
  _WORD *v53; // r6
  int v54; // r7
  int v55; // r3
  unsigned int v56; // r2
  bool v58; // r0
  unsigned int v59; // r0
  unsigned int v60; // r4
  unsigned int v61; // r8
  char v62; // r1
  char v63; // r6
  int v64; // r5
  bool v65; // cc
  char v66; // r12
  int v67; // r2
  int v68; // r1
  unsigned int v69; // r3
  int v70; // r2
  unsigned int i; // r3
  _WORD *v72; // r2
  int v73; // r2
  int v74; // r3
  char *v75; // r6
  int v76; // t1
  int v77; // r3
  unsigned int v78; // r5
  unsigned int v81; // r2
  char *v82; // r3
  int v83; // t1
  char *v84; // [sp+Ch] [bp-94h]
  int v85; // [sp+10h] [bp-90h]
  unsigned int v86; // [sp+14h] [bp-8Ch]
  int v88; // [sp+1Ch] [bp-84h]
  int v90; // [sp+24h] [bp-7Ch]
  int v91; // [sp+28h] [bp-78h]
  bool v92; // [sp+2Ch] [bp-74h]
  unsigned int v93; // [sp+30h] [bp-70h]
  bool v94; // [sp+34h] [bp-6Ch]
  void **v95; // [sp+38h] [bp-68h]
  void **v96; // [sp+3Ch] [bp-64h]
  int v97; // [sp+40h] [bp-60h] BYREF
  int v98; // [sp+44h] [bp-5Ch]
  int v99; // [sp+48h] [bp-58h]
  int v100; // [sp+4Ch] [bp-54h]
  int v101; // [sp+50h] [bp-50h]
  int v102; // [sp+54h] [bp-4Ch]
  int v103; // [sp+58h] [bp-48h]
  int v104; // [sp+5Ch] [bp-44h]
  __int16 v105; // [sp+62h] [bp-3Eh]
  __int16 v106; // [sp+64h] [bp-3Ch]
  __int16 v107; // [sp+66h] [bp-3Ah]
  __int16 v108; // [sp+68h] [bp-38h]
  __int16 v109; // [sp+6Ah] [bp-36h]
  __int16 v110; // [sp+6Ch] [bp-34h]
  __int16 v111; // [sp+6Eh] [bp-32h]
  __int16 v112; // [sp+70h] [bp-30h]
  __int16 v113; // [sp+72h] [bp-2Eh]
  __int16 v114; // [sp+74h] [bp-2Ch]
  __int16 v115; // [sp+76h] [bp-2Ah]
  __int16 v116; // [sp+78h] [bp-28h]
  __int16 v117; // [sp+7Ah] [bp-26h]
  __int16 v118; // [sp+7Ch] [bp-24h]
  __int16 v119; // [sp+7Eh] [bp-22h]
  _WORD v120[16]; // [sp+80h] [bp-20h] BYREF

  v6 = 0;
  v97 = 0;
  v98 = 0;
  v99 = 0;
  v100 = 0;
  v101 = 0;
  v102 = 0;
  v103 = 0;
  v104 = 0;
  if ( a3 )
  {
    if ( a3 <= 16 )
    {
      v9 = 0;
    }
    else
    {
      v7 = (unsigned __int16 *)(a2 + 46);
      do
      {
        v8 = *(v7 - 23);
        v9 = v6 + 16;
        v65 = a3 - 15 > v6 + 17;
        __pld(v7);
        v6 += 16;
        ++*((_WORD *)&v97 + v8);
        v10 = &v120[*(v7 - 22)];
        ++*(v10 - 32);
        v11 = &v120[*(v7 - 21)];
        ++*(v11 - 32);
        v12 = &v120[*(v7 - 20)];
        ++*(v12 - 32);
        v13 = &v120[*(v7 - 19)];
        ++*(v13 - 32);
        v14 = &v120[*(v7 - 18)];
        ++*(v14 - 32);
        v15 = &v120[*(v7 - 17)];
        ++*(v15 - 32);
        v16 = &v120[*(v7 - 16)];
        ++*(v16 - 32);
        v17 = &v120[*(v7 - 15)];
        ++*(v17 - 32);
        v18 = &v120[*(v7 - 14)];
        ++*(v18 - 32);
        v19 = &v120[*(v7 - 13)];
        ++*(v19 - 32);
        v20 = &v120[*(v7 - 12)];
        ++*(v20 - 32);
        v21 = &v120[*(v7 - 11)];
        ++*(v21 - 32);
        v22 = &v120[*(v7 - 10)];
        ++*(v22 - 32);
        v23 = &v120[*(v7 - 9)];
        ++*(v23 - 32);
        v24 = *(v7 - 8);
        v7 += 16;
        ++*((_WORD *)&v97 + v24);
      }
      while ( v65 );
    }
    v25 = a2 + 2 * (v9 - 1);
    do
    {
      v26 = *(unsigned __int16 *)(v25 + 2);
      v25 += 2;
      ++v9;
      ++*((_WORD *)&v97 + v26);
    }
    while ( a3 > v9 );
  }
  v27 = *a5;
  if ( HIWORD(v104) )
  {
    v32 = 15;
  }
  else if ( (_WORD)v104 )
  {
    v32 = 14;
  }
  else if ( HIWORD(v103) )
  {
    v32 = 13;
  }
  else if ( (_WORD)v103 )
  {
    v32 = 12;
  }
  else if ( HIWORD(v102) )
  {
    v32 = 11;
  }
  else if ( (_WORD)v102 )
  {
    v32 = 10;
  }
  else if ( HIWORD(v101) )
  {
    v32 = 9;
  }
  else if ( (_WORD)v101 )
  {
    v32 = 8;
  }
  else if ( HIWORD(v100) )
  {
    v32 = 7;
  }
  else if ( (_WORD)v100 )
  {
    v32 = 6;
  }
  else if ( HIWORD(v99) )
  {
    v32 = 5;
  }
  else if ( (_WORD)v99 )
  {
    v32 = 4;
  }
  else if ( HIWORD(v98) )
  {
    v32 = 3;
  }
  else
  {
    if ( !(_WORD)v98 )
    {
      v28 = HIWORD(v97);
      if ( !HIWORD(v97) )
      {
        result = HIWORD(v97);
        v30 = *a4;
        v31 = *a4 + 8;
        *(_WORD *)(v30 + 2) = HIWORD(v97);
        *(_WORD *)(v30 + 6) = v28;
        *(_BYTE *)v30 = 64;
        *(_BYTE *)(v30 + 4) = 64;
        *(_BYTE *)(v30 + 1) = 1;
        *(_BYTE *)(v30 + 5) = 1;
        *a4 = v31;
        *a5 = 1;
        return result;
      }
      v27 = v27 != 0;
      v32 = 1;
      goto LABEL_25;
    }
    v32 = 2;
  }
  v28 = HIWORD(v97);
  if ( v32 < v27 )
    v27 = v32;
  if ( !HIWORD(v97) )
  {
    v82 = (char *)&v97 + 2;
    v34 = 1;
    do
    {
      if ( ++v34 == v32 )
        break;
      v83 = *((unsigned __int16 *)v82 + 1);
      v82 += 2;
    }
    while ( !v83 );
    v33 = 2;
    goto LABEL_27;
  }
LABEL_25:
  v33 = 2 - v28;
  if ( 2 - v28 < 0 )
    return -1;
  v34 = 1;
LABEL_27:
  v35 = 2 * v33 - (unsigned __int16)v98;
  if ( v35 < 0 )
    return -1;
  v36 = 2 * v35 - HIWORD(v98);
  if ( v36 < 0 )
    return -1;
  v37 = 2 * v36 - (unsigned __int16)v99;
  if ( v37 < 0 )
    return -1;
  v38 = 2 * v37 - HIWORD(v99);
  if ( v38 < 0 )
    return -1;
  v39 = 2 * v38 - (unsigned __int16)v100;
  if ( v39 < 0 )
    return -1;
  v40 = 2 * v39 - HIWORD(v100);
  if ( v40 < 0 )
    return -1;
  v41 = 2 * v40 - (unsigned __int16)v101;
  if ( v41 < 0 )
    return -1;
  v42 = 2 * v41 - HIWORD(v101);
  if ( v42 < 0 )
    return -1;
  v43 = 2 * v42 - (unsigned __int16)v102;
  if ( v43 < 0 )
    return -1;
  v44 = 2 * v43 - HIWORD(v102);
  if ( v44 < 0 )
    return -1;
  if ( 2 * v44 - (unsigned __int16)v103 < 0 )
    return -1;
  v45 = 2 * (2 * v44 - (unsigned __int16)v103) - HIWORD(v103);
  if ( v45 < 0 )
    return -1;
  v46 = 2 * v45 - (unsigned __int16)v104;
  if ( v46 < 0 )
    return -1;
  v47 = 2 * v46 - HIWORD(v104);
  if ( v47 < 0 )
    return -1;
  if ( v47 )
  {
    v48 = a1 == 0;
    if ( v32 != 1 )
      v48 = 1;
    if ( v48 )
      return -1;
  }
  v49 = 0;
  v106 = v28;
  v105 = 0;
  v107 = v28 + v98;
  v108 = v28 + v98 + HIWORD(v98);
  v109 = v108 + v99;
  v110 = v108 + v99 + HIWORD(v99);
  v111 = v110 + v100;
  v112 = v110 + v100 + HIWORD(v100);
  v113 = v112 + v101;
  v114 = v113 + HIWORD(v101);
  v115 = v113 + HIWORD(v101) + v102;
  v116 = v115 + HIWORD(v102);
  v117 = v115 + HIWORD(v102) + v103;
  v118 = v117 + HIWORD(v103);
  v119 = v118 + v104;
  if ( a3 )
  {
    v50 = a2 - 2;
    do
    {
      v52 = *(unsigned __int16 *)(v50 + 2);
      v50 += 2;
      v51 = v52;
      if ( v52 )
      {
        v53 = &v120[v51];
        v54 = (unsigned __int16)*(v53 - 16);
        *((_WORD *)a6 + v54) = v49;
        *(v53 - 16) = v54 + 1;
      }
      ++v49;
    }
    while ( v49 != a3 );
  }
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v90 = 256;
      v95 = (void **)&unk_6A91E;
      v96 = (void **)&unk_6A95E;
    }
    else
    {
      v90 = -1;
      v95 = &dext_6056;
      v96 = (void **)&dbase_6055;
    }
  }
  else
  {
    v95 = a6;
    v96 = a6;
    v90 = 19;
  }
  v55 = 1;
  if ( v34 >= v27 )
    v27 = v34;
  v56 = 1 << v27;
  v86 = v27;
  v92 = a1 == 1;
  v85 = *a4;
  if ( (unsigned int)(1 << v27) > 852 && a1 == 1 )
    return 1;
  v58 = a1 == 2;
  v94 = v58;
  v59 = v56 > 592 && v58;
  if ( v59 )
    return 1;
  LOBYTE(v60) = v27;
  v84 = (char *)a6 - 2;
  v61 = 0;
  v62 = v34;
  v88 = 1 << v27;
  v93 = v56 - 1;
  v91 = -1;
  while ( 1 )
  {
    v63 = v62;
    v64 = *((unsigned __int16 *)v84 + 1);
    v65 = v90 < v64;
    v84 += 2;
    if ( v90 <= v64 )
    {
      if ( v90 >= v64 )
        v67 = 96;
      else
        v67 = (int)v95;
      if ( v90 >= v64 )
        v64 = 0;
      else
        v55 = (int)v96;
      if ( v65 )
      {
        LOBYTE(v67) = *(_BYTE *)(v67 + 2 * v64);
        LOWORD(v64) = *(_WORD *)(v55 + 2 * v64);
      }
      v66 = v67;
    }
    else
    {
      v66 = 0;
    }
    v68 = 1 << v62;
    v69 = v85 + 4 * ((v59 >> v61) + (1 << v60) - v68);
    v70 = 1 << v60;
    do
    {
      v70 -= v68;
      *(_BYTE *)v69 = v66;
      *(_BYTE *)(v69 + 1) = v63;
      *(_WORD *)(v69 + 2) = v64;
      v69 -= 4 * v68;
    }
    while ( v70 );
    for ( i = 1 << (v34 - 1); (v59 & i) != 0; i >>= 1 )
      ;
    if ( i )
      v59 = (v59 & (i - 1)) + i;
    else
      v59 = 0;
    v72 = &v120[v34];
    v55 = (unsigned __int16)(*(v72 - 32) - 1);
    *(v72 - 32) = v55;
    if ( (_WORD)v55 )
      goto LABEL_83;
    if ( v34 == v32 )
      break;
    v55 = *((unsigned __int16 *)v84 + 1);
    v34 = *(unsigned __int16 *)(a2 + 2 * v55);
LABEL_83:
    if ( v86 >= v34 || (v73 = v59 & v93, (v59 & v93) == v91) )
    {
      v62 = v34 - v61;
    }
    else
    {
      if ( !v61 )
        v61 = v86;
      v85 += 4 * (1 << v60);
      v60 = v34 - v61;
      v62 = v34 - v61;
      if ( v34 < v32 )
      {
        v74 = (1 << (v34 - v61)) - *((unsigned __int16 *)&v97 + v34);
        if ( v74 > 0 )
        {
          v75 = (char *)&v97 + 2 * v34;
          do
          {
            ++v60;
            v77 = 2 * v74;
            if ( v32 <= v61 + v60 )
              break;
            v76 = *((unsigned __int16 *)v75 + 1);
            v75 += 2;
            v74 = v77 - v76;
          }
          while ( v74 > 0 );
        }
      }
      v78 = v88 + (1 << v60);
      v88 = v78;
      if ( v78 > 852 && v92 )
        return 1;
      if ( v78 > 592 && v94 )
        return 1;
      v91 = v59 & v93;
      *(_BYTE *)(*a4 + 4 * v73) = v60;
      *(_BYTE *)(*a4 + 4 * v73 + 1) = v86;
      v55 = *a4 + 4 * v73;
      *(_WORD *)(v55 + 2) = (v85 - *a4) >> 2;
    }
  }
  if ( v59 )
  {
    *(_BYTE *)(v85 + 4 * v59) = 64;
    v81 = v85 + 4 * v59;
    *(_BYTE *)(v81 + 1) = v63;
    *(_WORD *)(v81 + 2) = 0;
  }
  result = 0;
  *a4 += 4 * v88;
  *a5 = v86;
  return result;
}
// 6ABA0: using guessed type void *dext_6056;

//----- (00055B58) --------------------------------------------------------
const char *zlibVersion()
{
  return "1.2.8";
}

//----- (00055B64) --------------------------------------------------------
int zlibCompileFlags()
{
  return 85;
}

//----- (00055B68) --------------------------------------------------------
char *__fastcall zError(int a1)
{
  return z_errmsg[2 - a1];
}
// 6AC50: using guessed type char *z_errmsg[2];

//----- (00055B7C) --------------------------------------------------------
void *__fastcall zcalloc(int a1, int a2, int a3)
{
  return j_malloc(a2 * a3);
}

//----- (00055B84) --------------------------------------------------------
void __fastcall zcfree(int a1, void *ptr)
{
  j_free(ptr);
}

//----- (00055B8C) --------------------------------------------------------
int __fastcall adler32(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // r3
  unsigned int v4; // r6
  unsigned __int8 *v5; // r2
  int v6; // t1
  bool v7; // cc
  unsigned __int8 *v9; // r7
  unsigned int v10; // r0
  unsigned int v11; // r5
  unsigned int v12; // r4
  unsigned int v13; // r10
  unsigned int v14; // r4
  unsigned int v15; // r1
  unsigned int v16; // r10
  unsigned int v17; // r1
  unsigned int v18; // r0
  unsigned int v19; // r10
  unsigned int v20; // r0
  unsigned int v21; // r5
  int v22; // r10
  int v23; // r5
  int v24; // r4
  int v25; // r5
  int v26; // r4
  int v27; // r1
  int v28; // r5
  int v29; // r4
  int v30; // r5
  int v31; // r1
  int v32; // r0
  int v33; // r1
  unsigned int v34; // r0
  unsigned int v35; // r6
  unsigned int v36; // r1
  unsigned __int8 *v37; // r4
  unsigned int v38; // r0
  unsigned int v39; // r7
  unsigned int v40; // r5
  unsigned int v41; // r12
  unsigned int v42; // r5
  unsigned int v43; // r0
  unsigned int v44; // r12
  unsigned int v45; // r0
  unsigned int v46; // r7
  unsigned int v47; // r5
  unsigned int v48; // r12
  unsigned int v49; // r5
  int v50; // r0
  int v51; // r12
  int v52; // r0
  int v53; // r7
  int v54; // r5
  int v55; // r12
  int v56; // r5
  int v57; // r0
  int v58; // r5
  int v59; // r1
  unsigned int v60; // r4
  int v61; // r2
  unsigned __int8 *v62; // r1
  int v63; // t1

  v3 = a2;
  v4 = HIWORD(a1);
  a1 = (unsigned __int16)a1;
  if ( a3 != 1 )
  {
    if ( !a2 )
      return 1;
    if ( a3 <= 15 )
    {
      if ( a3 )
      {
        v5 = &a2[a3];
        do
        {
          v6 = *v3++;
          a1 += v6;
          v4 += a1;
        }
        while ( v3 != v5 );
      }
      v7 = a1 > 65520;
      if ( a1 > 65520 )
        a1 -= 65280;
      if ( v7 )
        a1 -= 241;
      return a1 | ((v4 % 65521) << 16);
    }
    if ( a3 <= 5551 )
      goto LABEL_24;
    do
    {
      a3 -= 5552;
      v9 = v3 + 5552;
      do
      {
        v10 = a1 + *v3;
        v11 = v10 + v3[1];
        v12 = v11 + v3[2];
        v13 = v11 + v10 + v12;
        v14 = v12 + v3[3];
        v15 = v14 + v3[4];
        v16 = v13 + v14 + v15;
        v17 = v15 + v3[5];
        v18 = v17 + v3[6];
        v19 = v16 + v17 + v18;
        v20 = v18 + v3[7];
        v21 = v20 + v3[8];
        v22 = v19 + v20 + v21;
        v23 = v21 + v3[9];
        v24 = v23 + v3[10];
        v25 = v22 + v23 + v24;
        v26 = v24 + v3[11];
        v27 = v26 + v3[12];
        v28 = v25 + v26;
        v29 = v3[15];
        v30 = v28 + v27;
        v31 = v27 + v3[13];
        v32 = v31 + v3[14];
        v3 += 16;
        v33 = v30 + v31 + v32;
        a1 = v32 + v29;
        v4 += v33 + a1;
      }
      while ( v3 != v9 );
      a1 %= 65521u;
      v4 %= 65521u;
    }
    while ( a3 > 5551 );
    if ( !a3 )
      return a1 | (v4 << 16);
    if ( a3 <= 15 )
    {
      v61 = a3 - 1;
    }
    else
    {
LABEL_24:
      v36 = a3;
      v37 = v3;
      do
      {
        v36 -= 16;
        v38 = a1 + *v37;
        v39 = v37[1] + v38;
        v40 = v37[2] + v39;
        v41 = v38 + v39 + v40;
        v42 = v40 + v37[3];
        v43 = v42 + v37[4];
        v44 = v41 + v42 + v43;
        v45 = v43 + v37[5];
        v46 = v37[6] + v45;
        v47 = v37[7] + v46;
        v48 = v44 + v45 + v46 + v47;
        v49 = v47 + v37[8];
        v50 = v37[9] + v49;
        v51 = v48 + v49 + v50;
        v52 = v50 + v37[10];
        v53 = v37[11] + v52;
        v54 = v37[12] + v53;
        v55 = v51 + v52 + v53 + v54;
        v56 = v54 + v37[13];
        v57 = v37[14] + v56;
        v58 = v55 + v56 + v57;
        a1 = v57 + v37[15];
        v37 += 16;
        v4 += v58 + a1;
      }
      while ( v36 > 15 );
      v59 = a3 & 0xF;
      v60 = (a3 - 16) & 0xFFFFFFF0;
      v61 = v59 - 1;
      v3 += v60 + 16;
      if ( !v59 )
        return (a1 % 65521) | ((v4 % 65521) << 16);
    }
    v62 = &v3[v61 + 1];
    do
    {
      v63 = *v3++;
      a1 += v63;
      v4 += a1;
    }
    while ( v3 != v62 );
    return (a1 % 65521) | ((v4 % 65521) << 16);
  }
  v34 = *a2 + (unsigned __int16)a1;
  if ( v34 > 65520 )
    v34 -= 65521;
  v35 = v34 + v4;
  if ( v35 > 65520 )
    v35 -= 65521;
  return v34 | (v35 << 16);
}
// 55B8C: too many cbuild loops

//----- (00055DB4) --------------------------------------------------------
int __fastcall adler32_combine(unsigned int a1, unsigned int a2, int a3)
{
  int v4; // r2
  unsigned int v5; // r4
  int v6; // r0
  int v7; // r5
  unsigned int v8; // r4
  unsigned int v9; // r3

  if ( a3 >> 31 == -1 )
    return -1;
  v4 = a3 % 65521;
  v5 = (unsigned __int16)a1 * v4;
  v6 = (unsigned __int16)a1 + (unsigned __int16)a2;
  v7 = 65520;
  v8 = HIWORD(a1) + HIWORD(a2) - v4 + v5 % 65521;
  v9 = v8 + 65521;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( (unsigned int)(v6 - 1) > 65520 )
      v7 = v6 - 65522;
  }
  if ( v9 > 131041 )
    v9 = v8 - 65521;
  if ( v9 > 65520 )
    v9 -= 65521;
  return v7 | (v9 << 16);
}

//----- (00055E4C) --------------------------------------------------------
int __fastcall adler32_combine64(unsigned int a1, unsigned int a2, __int64 a3)
{
  __int64 v4; // r2
  unsigned int v5; // r6
  int v6; // r0
  int v7; // r7
  int v8; // r6
  unsigned int v9; // r3

  if ( a3 < 0 )
    return -1;
  v4 = a3 % 65521;
  v5 = (unsigned __int16)a1 * (_DWORD)v4;
  v6 = (unsigned __int16)a1 + (unsigned __int16)a2;
  v7 = 65520;
  v8 = HIWORD(a1) + HIWORD(a2) - v4 + v5 % 65521;
  v9 = v8 + 65521;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( (unsigned int)(v6 - 1) > 65520 )
      v7 = v6 - 65522;
  }
  if ( v9 > 131041 )
    v9 = v8 - 65521;
  if ( v9 > 65520 )
    v9 -= 65521;
  return v7 | (v9 << 16);
}

//----- (00055EE0) --------------------------------------------------------
int __fastcall crc32_combine_(int result, int a2, __int64 a3)
{
  unsigned int v4; // r6
  int v5; // r5
  int *v6; // r4
  int i; // r8
  unsigned int v8; // r4
  char *v9; // r5
  int v10; // r7
  int j; // r8
  unsigned int v12; // r4
  char *v13; // r5
  int v14; // r7
  int v15; // r6
  int k; // r10
  unsigned int v17; // r7
  char *v18; // r8
  int v19; // r6
  int v20; // r1
  int v21; // r6
  unsigned int v22; // r7
  char *v23; // r8
  __int64 v24; // r2
  int m; // r10
  unsigned int v26; // r7
  char *v27; // r8
  int v28; // r6
  int v29; // r1
  int v30; // r6
  unsigned int v31; // r7
  char *v32; // r8
  _BYTE v33[4]; // [sp+0h] [bp-120h]
  char v34[124]; // [sp+4h] [bp-11Ch] BYREF
  int v35; // [sp+80h] [bp-A0h] BYREF
  char v36[120]; // [sp+84h] [bp-9Ch] BYREF
  char v37; // [sp+FCh] [bp-24h] BYREF

  if ( a3 >= 1 )
  {
    v4 = (unsigned int)&v37;
    v35 = -306674912;
    v5 = 1;
    v6 = &v35;
    do
    {
      v6[1] = v5;
      ++v6;
      v5 *= 2;
    }
    while ( v6 != (int *)&v37 );
    for ( i = 0; i != 128; i += 4 )
    {
      while ( 1 )
      {
        v8 = *(_DWORD *)&v36[i - 4];
        if ( v8 )
          break;
        *(_DWORD *)&v33[i] = 0;
        i += 4;
        if ( i == 128 )
          goto LABEL_13;
      }
      v9 = v36;
      v10 = 0;
      do
      {
        if ( (v8 & 1) != 0 )
          v4 = *((_DWORD *)v9 - 1);
        v9 += 4;
        if ( (v8 & 1) != 0 )
          v10 ^= v4;
        v8 >>= 1;
      }
      while ( v8 );
      *(_DWORD *)&v33[i] = v10;
    }
LABEL_13:
    for ( j = 0; j != 128; j += 4 )
    {
      while ( 1 )
      {
        v12 = *(_DWORD *)&v33[j];
        if ( v12 )
          break;
        *(_DWORD *)&v36[j - 4] = 0;
        j += 4;
        if ( j == 128 )
          goto LABEL_22;
      }
      v13 = v34;
      v14 = 0;
      do
      {
        v15 = v12 << 31;
        if ( (v12 & 1) != 0 )
          v15 = *((_DWORD *)v13 - 1);
        v13 += 4;
        if ( (v12 & 1) != 0 )
          v14 ^= v15;
        v12 >>= 1;
      }
      while ( v12 );
      *(_DWORD *)&v36[j - 4] = v14;
    }
    do
    {
LABEL_22:
      for ( k = 0; k != 128; k += 4 )
      {
        while ( 1 )
        {
          v17 = *(_DWORD *)&v36[k - 4];
          if ( v17 )
            break;
          *(_DWORD *)&v33[k] = 0;
          k += 4;
          if ( k == 128 )
            goto LABEL_31;
        }
        v18 = v36;
        v19 = 0;
        do
        {
          v20 = v17 << 31;
          if ( (v17 & 1) != 0 )
            v20 = *((_DWORD *)v18 - 1);
          v18 += 4;
          if ( (v17 & 1) != 0 )
            v19 ^= v20;
          v17 >>= 1;
        }
        while ( v17 );
        *(_DWORD *)&v33[k] = v19;
      }
LABEL_31:
      v21 = a3 & 1;
      if ( (a3 & 1) != 0 && result )
      {
        v22 = result;
        v23 = v34;
        result = 0;
        do
        {
          if ( (v22 & 1) != 0 )
            v21 = *((_DWORD *)v23 - 1);
          v23 += 4;
          if ( (v22 & 1) != 0 )
            result ^= v21;
          v22 >>= 1;
        }
        while ( v22 );
      }
      v24 = a3 >> 1;
      if ( !v24 )
        break;
      for ( m = 0; m != 128; m += 4 )
      {
        while ( 1 )
        {
          v26 = *(_DWORD *)&v33[m];
          if ( v26 )
            break;
          *(_DWORD *)&v36[m - 4] = 0;
          m += 4;
          if ( m == 128 )
            goto LABEL_49;
        }
        v27 = v34;
        v28 = 0;
        do
        {
          v29 = v26 << 31;
          if ( (v26 & 1) != 0 )
            v29 = *((_DWORD *)v27 - 1);
          v27 += 4;
          if ( (v26 & 1) != 0 )
            v28 ^= v29;
          v26 >>= 1;
        }
        while ( v26 );
        *(_DWORD *)&v36[m - 4] = v28;
      }
LABEL_49:
      v30 = v24 & 1;
      if ( (v24 & 1) != 0 && result )
      {
        v31 = result;
        v32 = v36;
        result = 0;
        do
        {
          if ( (v31 & 1) != 0 )
            v30 = *((_DWORD *)v32 - 1);
          v32 += 4;
          if ( (v31 & 1) != 0 )
            result ^= v30;
          v31 >>= 1;
        }
        while ( v31 );
      }
      a3 = v24 >> 1;
    }
    while ( a3 );
    return result ^ a2;
  }
  return result;
}

//----- (000560B0) --------------------------------------------------------
void *get_crc_table()
{
  return &crc_table;
}

//----- (000560BC) --------------------------------------------------------
int __fastcall crc32(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // r6
  char *v4; // r0
  char v5; // t1
  _DWORD *v7; // r7
  unsigned int v8; // r5
  char *v9; // r4
  unsigned int v10; // r9
  int v11; // r1
  int v12; // r12
  unsigned int v13; // r8
  int v14; // r2
  unsigned int v15; // r0
  int v16; // r10
  int v17; // r8
  int v18; // r1
  int v19; // r0
  unsigned int v20; // r1
  unsigned int v21; // r11
  unsigned int v22; // r2
  unsigned int v23; // r6
  unsigned int v24; // r0
  unsigned int v25; // r8
  char *v26; // r0
  int v27; // r4
  char *v28; // r2
  char v29; // t1
  int v30; // [sp+0h] [bp-30h]
  int v31; // [sp+4h] [bp-2Ch]
  int v32; // [sp+8h] [bp-28h]
  char *v33; // [sp+Ch] [bp-24h]

  if ( !a2 )
    return 0;
  v3 = ~a1;
  if ( a3 )
  {
    if ( (_DWORD)a2 << 30 )
    {
      v4 = a2;
      while ( 1 )
      {
        v5 = *v4++;
        --a3;
        a2 = v4;
        v3 = crc_table[(unsigned __int8)(v5 ^ v3)] ^ (v3 >> 8);
        if ( !a3 )
          break;
        if ( ((unsigned __int8)v4 & 3) == 0 )
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      if ( a3 > 31 )
      {
        v7 = a2 + 64;
        v8 = a3;
        v9 = a2;
        v10 = a3;
        v33 = a2;
        do
        {
          v11 = *(v7 - 16);
          v8 -= 32;
          v12 = *((_DWORD *)v9 + 4);
          __pld(v7);
          __pld(v9 + 68);
          v7 += 8;
          v13 = crc_table[(unsigned __int8)(v3 ^ v11) + 768] ^ crc_table[(v3 ^ v11) >> 24] ^ *((_DWORD *)v9 + 1) ^ crc_table[(unsigned __int8)((unsigned __int16)(v3 ^ v11) >> 8) + 512] ^ crc_table[(unsigned __int8)((v3 ^ v11) >> 16) + 256];
          v32 = *((_DWORD *)v9 + 5);
          v14 = *((_DWORD *)v9 + 7);
          v15 = crc_table[(unsigned __int8)v13 + 768] ^ crc_table[HIBYTE(v13)] ^ *((_DWORD *)v9 + 2) ^ crc_table[BYTE1(v13) + 512] ^ crc_table[BYTE2(v13) + 256];
          v31 = *((_DWORD *)v9 + 6);
          v16 = crc_table[BYTE1(v15) + 512];
          v17 = crc_table[(unsigned __int8)v15 + 768] ^ crc_table[HIBYTE(v15)];
          v18 = crc_table[BYTE2(v15) + 256];
          v19 = *((_DWORD *)v9 + 3);
          v9 += 32;
          v30 = v14;
          v20 = v17 ^ v19 ^ v16 ^ v18;
          v21 = crc_table[(unsigned __int8)v20 + 768] ^ crc_table[HIBYTE(v20)] ^ v12 ^ crc_table[BYTE1(v20) + 512] ^ crc_table[BYTE2(v20) + 256];
          v22 = crc_table[(unsigned __int8)v21 + 768] ^ crc_table[HIBYTE(v21)] ^ v32 ^ crc_table[BYTE1(v21) + 512] ^ crc_table[BYTE2(v21) + 256];
          v23 = crc_table[(unsigned __int8)v22 + 768] ^ crc_table[HIBYTE(v22)] ^ v31 ^ crc_table[BYTE1(v22) + 512] ^ crc_table[BYTE2(v22) + 256];
          v24 = crc_table[(unsigned __int8)v23 + 768] ^ crc_table[HIBYTE(v23)] ^ v30 ^ crc_table[BYTE1(v23) + 512] ^ crc_table[BYTE2(v23) + 256];
          v3 = crc_table[HIBYTE(v24)] ^ crc_table[(unsigned __int8)v24 + 768] ^ crc_table[BYTE1(v24) + 512] ^ crc_table[BYTE2(v24) + 256];
        }
        while ( v8 > 31 );
        a3 = v10 & 0x1F;
        a2 = &v33[((v10 - 32) & 0xFFFFFFE0) + 32];
      }
      if ( a3 > 3 )
      {
        v25 = (a3 - 4) >> 2;
        v26 = a2 + 4;
        do
        {
          v27 = *((_DWORD *)v26 - 1);
          v26 += 4;
          v3 = crc_table[(v3 ^ v27) >> 24] ^ crc_table[(unsigned __int8)(v3 ^ v27) + 768] ^ crc_table[(unsigned __int8)((unsigned __int16)(v3 ^ v27) >> 8) + 512] ^ crc_table[(unsigned __int8)((v3 ^ v27) >> 16) + 256];
        }
        while ( v26 != &a2[4 * v25 + 8] );
        a3 &= 3u;
        a2 += 4 * v25 + 4;
      }
      if ( a3 )
      {
        v28 = &a2[a3];
        do
        {
          v29 = *a2++;
          v3 = crc_table[(unsigned __int8)(v29 ^ v3)] ^ (v3 >> 8);
        }
        while ( a2 != v28 );
      }
    }
  }
  return ~v3;
}
// 6ACF8: using guessed type _DWORD crc_table[2048];

//----- (000563C4) --------------------------------------------------------
int __fastcall crc32_combine(int a1, int a2, int a3)
{
  return crc32_combine_(a1, a2, a3);
}

//----- (000563D0) --------------------------------------------------------
int __fastcall inflate_fast(unsigned int *a1, int a2)
{
  _DWORD *v2; // r11
  unsigned int v3; // r2
  _BYTE *v4; // r12
  int v5; // r1
  _BYTE *v6; // r2
  int v7; // r4
  unsigned int v8; // r10
  unsigned int v9; // r6
  int v10; // r4
  int v11; // r5
  int v12; // r9
  int *v13; // r8
  unsigned int v14; // r11
  int v15; // r2
  char v16; // r1
  int v17; // r3
  int v18; // r2
  unsigned __int8 *v19; // r1
  int v20; // r3
  int v21; // r2
  unsigned int v22; // r1
  const char *v23; // r2
  unsigned __int8 *v24; // r0
  int v25; // r2
  unsigned int v26; // r3
  unsigned int v27; // r2
  bool v28; // cc
  int v29; // r2
  int v30; // r2
  char *v31; // r1
  char v32; // r3
  int v33; // r0
  int v34; // r1
  char *v35; // r4
  int v36; // r0
  unsigned int v37; // r3
  int v38; // r4
  char v39; // r0
  bool v40; // cc
  int v41; // r4
  int v42; // r4
  int v43; // r1
  _BYTE *v44; // r0
  unsigned int v45; // r1
  unsigned int v46; // r4
  unsigned int v47; // r1
  unsigned int v48; // r0
  unsigned int v49; // r1
  bool v50; // cf
  char v51; // r3
  char v52; // r0
  char v53; // r1
  int v54; // r1
  int v55; // r1
  _BYTE *v56; // r0
  unsigned int v57; // r1
  int v58; // r2
  int v59; // r3
  unsigned int v60; // r4
  unsigned int v61; // r11
  _DWORD *v62; // r8
  int v63; // r3
  _DWORD *v64; // r0
  unsigned int v65; // r1
  int v66; // t1
  _BYTE *v67; // r1
  _BYTE *v68; // r3
  char v69; // t1
  _BYTE *v70; // r3
  char v71; // t1
  bool v72; // cf
  int *v73; // r11
  unsigned int *v74; // r8
  int v75; // r3
  int v76; // r3
  unsigned int v77; // r1
  unsigned int v78; // r3
  _BYTE *v79; // r4
  unsigned int v80; // r2
  unsigned int v81; // r3
  int result; // r0
  int v83; // r3
  char v84; // r1
  int v85; // r0
  int v86; // r3
  _BYTE *v87; // r3
  _BYTE *v88; // r4
  char v89; // t1
  unsigned int v90; // r0
  bool v91; // cf
  char v92; // r3
  char v93; // r0
  int v94; // r0
  int v95; // r4
  _BYTE *v96; // r4
  int v97; // r2
  unsigned int v98; // r0
  int v99; // r1
  int v100; // r3
  unsigned int v101; // r11
  unsigned int v102; // r12
  int v103; // r3
  unsigned int v104; // r0
  _DWORD *v105; // r4
  unsigned int v106; // r2
  int v107; // t1
  unsigned int v108; // r1
  _BYTE *v109; // r4
  _BYTE *v110; // r3
  _BYTE *v111; // r0
  char v112; // t1
  _DWORD *v113; // r12
  _DWORD *v114; // r0
  bool v115; // cf
  unsigned int v116; // r4
  char v117; // r3
  int v118; // r3
  int v119; // r1
  _DWORD *v120; // r2
  unsigned int v121; // r0
  int v122; // r5
  unsigned int v123; // r3
  unsigned int v124; // r11
  unsigned int v125; // r4
  int v126; // r5
  unsigned int v127; // r3
  int v128; // t1
  _BYTE *v129; // r1
  int v130; // r3
  unsigned int v131; // r4
  char v132; // t1
  unsigned int v133; // r1
  unsigned int v134; // r0
  unsigned int v135; // r1
  bool v136; // cf
  char v137; // r3
  char v138; // r0
  char v139; // r1
  int v140; // r1
  unsigned int v141; // r4
  _BYTE *v142; // r0
  int v143; // r12
  unsigned int v144; // r1
  int v145; // r3
  unsigned int v146; // r11
  int v147; // r3
  unsigned int v148; // r1
  _DWORD *v149; // r0
  int v150; // t1
  _BYTE *v151; // r1
  _BYTE *v152; // r3
  char v153; // t1
  int v154; // [sp+0h] [bp-B0h]
  _BYTE *v155; // [sp+4h] [bp-ACh]
  unsigned int v156; // [sp+8h] [bp-A8h]
  unsigned int v157; // [sp+8h] [bp-A8h]
  int v158; // [sp+Ch] [bp-A4h]
  unsigned int v159; // [sp+Ch] [bp-A4h]
  unsigned int v160; // [sp+Ch] [bp-A4h]
  unsigned int v161; // [sp+Ch] [bp-A4h]
  unsigned int v162; // [sp+Ch] [bp-A4h]
  unsigned int v163; // [sp+10h] [bp-A0h]
  unsigned int v164; // [sp+14h] [bp-9Ch]
  unsigned int v165; // [sp+18h] [bp-98h]
  unsigned int v166; // [sp+1Ch] [bp-94h]
  int v167; // [sp+20h] [bp-90h]
  unsigned int v168; // [sp+24h] [bp-8Ch]
  int v169; // [sp+28h] [bp-88h]
  unsigned int v170; // [sp+2Ch] [bp-84h]
  unsigned int v171; // [sp+2Ch] [bp-84h]
  int v172; // [sp+2Ch] [bp-84h]
  unsigned int v173; // [sp+30h] [bp-80h]
  int v174; // [sp+34h] [bp-7Ch]
  int v176; // [sp+3Ch] [bp-74h]
  int v177; // [sp+40h] [bp-70h]
  unsigned int v178; // [sp+40h] [bp-70h]
  unsigned int v179; // [sp+40h] [bp-70h]
  unsigned int v180; // [sp+40h] [bp-70h]
  _BYTE *v181; // [sp+44h] [bp-6Ch]
  unsigned int v182; // [sp+48h] [bp-68h]
  int v183; // [sp+50h] [bp-60h]
  _DWORD *v184; // [sp+54h] [bp-5Ch]
  int v185; // [sp+58h] [bp-58h]
  int v186; // [sp+5Ch] [bp-54h]
  unsigned int v187; // [sp+60h] [bp-50h]
  int v188; // [sp+64h] [bp-4Ch]
  unsigned int v189; // [sp+68h] [bp-48h]
  unsigned int v190; // [sp+6Ch] [bp-44h]
  _DWORD *v191; // [sp+6Ch] [bp-44h]
  _BYTE *v192; // [sp+6Ch] [bp-44h]
  unsigned int v193; // [sp+6Ch] [bp-44h]
  _DWORD *v194; // [sp+70h] [bp-40h]
  unsigned int v195; // [sp+70h] [bp-40h]
  unsigned int v196; // [sp+70h] [bp-40h]
  _DWORD *v197; // [sp+70h] [bp-40h]
  unsigned int v198; // [sp+74h] [bp-3Ch]
  int v199; // [sp+74h] [bp-3Ch]
  unsigned int v200; // [sp+78h] [bp-38h]
  unsigned int v201; // [sp+78h] [bp-38h]
  int v202; // [sp+78h] [bp-38h]
  unsigned int v203; // [sp+7Ch] [bp-34h]
  unsigned int v204; // [sp+7Ch] [bp-34h]
  unsigned int v205; // [sp+7Ch] [bp-34h]
  int *v206; // [sp+80h] [bp-30h]
  int v207; // [sp+80h] [bp-30h]
  _BYTE *v208; // [sp+80h] [bp-30h]
  unsigned int v209; // [sp+84h] [bp-2Ch]
  unsigned int v210; // [sp+84h] [bp-2Ch]
  _BYTE *v211; // [sp+88h] [bp-28h]
  unsigned int v212; // [sp+8Ch] [bp-24h]

  v2 = (_DWORD *)a1[7];
  v184 = v2 + 1776;
  v163 = v2[12];
  v168 = *a1 - 1 + a1[1] - 5;
  v174 = v2[10];
  v164 = v163 >> 2;
  v3 = a1[4];
  v4 = (_BYTE *)(a1[3] - 1);
  v5 = v3 - a2;
  v6 = &v4[v3 - 257];
  v7 = 4 * (v163 >> 2);
  v166 = v2[13];
  v173 = v166 - 1;
  v187 = v163 - v7;
  v167 = v7;
  v8 = v2[14];
  v188 = v166 - 1 + v7;
  v182 = v2[11];
  v9 = v2[15];
  v10 = 1 - (v163 >> 2);
  v11 = v2[19];
  if ( v163 >> 2 > 1 )
    v10 = 0;
  v12 = v2[20];
  v185 = v10;
  v176 = (1 << v2[22]) - 1;
  v169 = (1 << v2[21]) - 1;
  v13 = (int *)a1[7];
  v14 = *a1 - 1;
  v186 = v163 + v174;
  v189 = v166 + 4;
  v183 = a1[3] + v5;
  v181 = &v4[v5];
  v165 = (unsigned int)v6;
  while ( 1 )
  {
    if ( v9 <= 14 )
    {
      v15 = *(unsigned __int8 *)(v14 + 1);
      v16 = v9 + 8;
      v17 = *(unsigned __int8 *)(v14 + 2);
      v14 += 2;
      v18 = v15 << v9;
      v9 += 16;
      v8 += v18 + (v17 << v16);
    }
    v19 = (unsigned __int8 *)(v11 + 4 * (v8 & v169));
    v20 = *v19;
    v21 = v19[1];
    v22 = *((unsigned __int16 *)v19 + 1);
    v9 -= v21;
    v8 >>= v21;
    if ( v20 )
      break;
LABEL_72:
    *++v4 = v22;
LABEL_73:
    v72 = (unsigned int)v4 >= v165;
    if ( (unsigned int)v4 < v165 )
      v72 = v14 >= v168;
    if ( v72 )
    {
      v157 = v14;
      v73 = v13;
      v74 = a1;
      goto LABEL_84;
    }
  }
  while ( 1 )
  {
    if ( (v20 & 0x10) != 0 )
    {
      v26 = v20 & 0xF;
      v27 = v22;
      if ( v26 )
      {
        v28 = v26 > v9;
        if ( v26 > v9 )
        {
          v29 = *(unsigned __int8 *)++v14;
          v27 = v29 << v9;
          v9 += 8;
        }
        v9 -= v26;
        if ( v28 )
          v8 += v27;
        v30 = v8 & ((1 << v26) - 1);
        v8 >>= v26;
        v27 = v22 + v30;
      }
      if ( v9 <= 14 )
      {
        v83 = *(unsigned __int8 *)(v14 + 1);
        v84 = v9 + 8;
        v85 = *(unsigned __int8 *)(v14 + 2);
        v14 += 2;
        v86 = v83 << v9;
        v9 += 16;
        v8 += v86 + (v85 << v84);
      }
      v31 = (char *)(v12 + 4 * (v8 & v176));
      v32 = *v31;
      v33 = (unsigned __int8)v31[1];
      v9 -= v33;
      v8 >>= v33;
      v154 = *((unsigned __int16 *)v31 + 1);
      if ( (*v31 & 0x10) == 0 )
      {
        if ( (*v31 & 0x40) != 0 )
        {
LABEL_90:
          v157 = v14;
          v73 = v13;
          v74 = a1;
          a1[6] = (unsigned int)"invalid distance code";
          *v73 = 29;
          goto LABEL_84;
        }
        v34 = *((unsigned __int16 *)v31 + 1);
        while ( 1 )
        {
          v35 = (char *)(v12 + 4 * ((v8 & ((1 << v32) - 1)) + v34));
          v32 = *v35;
          v36 = (unsigned __int8)v35[1];
          v34 = *((unsigned __int16 *)v35 + 1);
          v9 -= v36;
          v8 >>= v36;
          if ( (*v35 & 0x10) != 0 )
            break;
          if ( (*v35 & 0x40) != 0 )
            goto LABEL_90;
        }
        v154 = *((unsigned __int16 *)v35 + 1);
      }
      v37 = v32 & 0xF;
      if ( v37 > v9 )
      {
        v38 = *(unsigned __int8 *)(v14 + 1);
        v39 = v9 + 8;
        v40 = v37 > v9 + 8;
        if ( v37 <= v9 + 8 )
          ++v14;
        v41 = v38 << v9;
        if ( v37 > v9 + 8 )
          v9 += 16;
        else
          v9 += 8;
        v8 += v41;
        if ( v40 )
        {
          v42 = *(unsigned __int8 *)(v14 + 2);
          v14 += 2;
          v8 += v42 << v39;
        }
      }
      v9 -= v37;
      v43 = v8 & ((1 << v37) - 1);
      v8 >>= v37;
      v44 = (_BYTE *)(v4 - v181);
      v158 = v43;
      v45 = v43 + v154;
      v156 = v45;
      if ( v45 <= v4 - v181 )
      {
        v87 = &v4[-v45];
        while ( 1 )
        {
          v88 = v87;
          v27 -= 3;
          v4[1] = v87[1];
          v4[2] = v87[2];
          v89 = v87[3];
          v87 += 3;
          v4[3] = v89;
          if ( v27 <= 2 )
            break;
          v4 += 3;
        }
        if ( v27 )
        {
          v4[4] = v88[4];
          if ( v27 == 2 )
          {
            v4[5] = v88[5];
            v4 += 5;
          }
          else
          {
            v4 += 4;
          }
        }
        else
        {
          v4 += 3;
        }
        goto LABEL_73;
      }
      v170 = v45 - (_DWORD)v44;
      if ( v182 < v45 - (unsigned int)v44 && *v184 )
      {
        v157 = v14;
        v73 = v13;
        v74 = a1;
        a1[6] = (unsigned int)"invalid distance too far back";
        *v73 = 29;
        goto LABEL_84;
      }
      if ( !v163 )
      {
        v46 = v166 - 1;
        v155 = (_BYTE *)(v174 - v170 + v173);
        if ( v27 <= v170 )
        {
LABEL_61:
          if ( v27 > 2 )
          {
            v70 = v155;
            do
            {
              v27 -= 3;
              v4[1] = v70[1];
              v4[2] = v70[2];
              v71 = v70[3];
              v70 += 3;
              v4[3] = v71;
              v4 += 3;
            }
            while ( v27 > 2 );
            v155 = v70;
          }
          if ( v27 )
          {
            if ( v27 == 2 )
              v46 = (unsigned int)v155;
            v4[1] = v155[1];
            if ( v27 == 2 )
            {
              v4[2] = *(_BYTE *)(v46 + 2);
              v4 += 2;
            }
            else
            {
              ++v4;
            }
          }
          goto LABEL_73;
        }
        v194 = v4 + 1;
        v190 = v170 >> 2;
        v47 = v166 + v174 - (v183 - (_DWORD)v4) - v154 - v158;
        v48 = v47 + 1;
        v200 = v47;
        v49 = v47 + 5;
        v27 -= v170;
        v159 = v48;
        v50 = v48 >= (unsigned int)(v4 + 5);
        if ( v48 < (unsigned int)(v4 + 5) )
          v50 = (unsigned int)(v4 + 1) >= v49;
        v51 = v50;
        v52 = v48 | (unsigned __int8)v194;
        v53 = v51;
        if ( v170 <= 3 )
          v53 = 0;
        if ( (v52 & 3) != 0 )
          v54 = 0;
        else
          v54 = v53 & 1;
        v55 = v54 ^ 1;
        v177 = 4 * v190;
        if ( !v190 )
          v55 |= 1u;
        if ( v55 )
        {
          v160 = v170;
          v67 = v4;
        }
        else
        {
          if ( v190 <= 8 )
          {
            v60 = 0;
          }
          else
          {
            v56 = v4 + 33;
            v57 = v200 + 33;
            v203 = v27;
            v58 = 0;
            v201 = v14;
            v206 = v13;
            do
            {
              v59 = *(_DWORD *)(v57 - 32);
              v28 = v190 - 7 > v58 + 9;
              v60 = v58 + 8;
              __pld((void *)(v57 + 84));
              v61 = v57;
              *((_DWORD *)v56 - 8) = v59;
              v62 = v56;
              v58 += 8;
              *((_DWORD *)v56 - 7) = *(_DWORD *)(v57 - 28);
              *((_DWORD *)v56 - 6) = *(_DWORD *)(v57 - 24);
              *((_DWORD *)v56 - 5) = *(_DWORD *)(v57 - 20);
              *((_DWORD *)v56 - 4) = *(_DWORD *)(v57 - 16);
              *((_DWORD *)v56 - 3) = *(_DWORD *)(v57 - 12);
              *((_DWORD *)v56 - 2) = *(_DWORD *)(v57 - 8);
              v63 = *(_DWORD *)(v57 - 4);
              v57 += 32;
              *((_DWORD *)v56 - 1) = v63;
              v56 += 32;
            }
            while ( v28 );
            v159 = v61;
            v194 = v62;
            v27 = v203;
            v13 = v206;
            v14 = v201;
          }
          v64 = v194;
          v65 = v159 - 4;
          do
          {
            v66 = *(_DWORD *)(v65 + 4);
            v65 += 4;
            ++v60;
            *v64++ = v66;
          }
          while ( v190 > v60 );
          v155 += v177;
          v160 = v170 - v177;
          v67 = &v4[v177];
          if ( v170 == v177 )
            goto LABEL_60;
        }
        v68 = v155;
        do
        {
          v69 = *++v68;
          *++v67 = v69;
        }
        while ( v68 != &v155[v160] );
LABEL_60:
        v46 = v170;
        v4 += v170;
        v155 = &v4[-v156];
        goto LABEL_61;
      }
      v90 = v45 - (_DWORD)v44;
      if ( v163 >= v170 )
      {
        v46 = v166 - 1;
        v155 = (_BYTE *)(v163 - v170 + v173);
        if ( v27 <= v170 )
          goto LABEL_61;
        v197 = v4 + 1;
        v180 = v170 >> 2;
        v133 = v166 + v163 - (v183 - (_DWORD)v4) - v154 - v158;
        v134 = v133 + 1;
        v204 = v133;
        v135 = v133 + 5;
        v27 -= v170;
        v193 = v134;
        v136 = v134 >= (unsigned int)(v4 + 5);
        if ( v134 < (unsigned int)(v4 + 5) )
          v136 = (unsigned int)(v4 + 1) >= v135;
        v137 = v136;
        v138 = v134 | (unsigned __int8)v197;
        v139 = v137;
        if ( v170 <= 3 )
          v139 = 0;
        if ( (v138 & 3) != 0 )
          v140 = 0;
        else
          v140 = v139 & 1;
        v199 = 4 * v180;
        v141 = v140 ^ 1;
        if ( !v180 )
          v141 |= 1u;
        if ( v141 )
        {
          v162 = v170;
          v151 = v4;
        }
        else
        {
          if ( v180 > 8 )
          {
            v142 = v4 + 33;
            v208 = v4;
            v143 = 0;
            v144 = v204 + 33;
            v205 = v14;
            do
            {
              v145 = *(_DWORD *)(v144 - 32);
              v146 = v143 + 9;
              v141 = v143 + 8;
              __pld((void *)(v144 + 84));
              v193 = v144;
              v143 += 8;
              *((_DWORD *)v142 - 8) = v145;
              v197 = v142;
              *((_DWORD *)v142 - 7) = *(_DWORD *)(v144 - 28);
              *((_DWORD *)v142 - 6) = *(_DWORD *)(v144 - 24);
              *((_DWORD *)v142 - 5) = *(_DWORD *)(v144 - 20);
              *((_DWORD *)v142 - 4) = *(_DWORD *)(v144 - 16);
              *((_DWORD *)v142 - 3) = *(_DWORD *)(v144 - 12);
              *((_DWORD *)v142 - 2) = *(_DWORD *)(v144 - 8);
              v147 = *(_DWORD *)(v144 - 4);
              v144 += 32;
              *((_DWORD *)v142 - 1) = v147;
              v142 += 32;
            }
            while ( v146 < v180 - 7 );
            v14 = v205;
            v4 = v208;
          }
          v148 = v193 - 4;
          v149 = v197;
          do
          {
            v150 = *(_DWORD *)(v148 + 4);
            v148 += 4;
            ++v141;
            *v149++ = v150;
          }
          while ( v180 > v141 );
          v155 += v199;
          v162 = v170 - v199;
          v151 = &v4[v199];
          if ( v170 == v199 )
            goto LABEL_60;
        }
        v152 = v155;
        do
        {
          v153 = *++v152;
          *++v151 = v153;
        }
        while ( v152 != &v155[v162] );
        goto LABEL_60;
      }
      v46 = v170 - v163;
      v171 = v46;
      v155 = (_BYTE *)(v186 - v90 + v173);
      if ( v27 <= v46 )
        goto LABEL_61;
      v191 = v4 + 1;
      v207 = v183 - (_DWORD)v4;
      v198 = v46 >> 2;
      v178 = v166 + v186 - (v183 - (_DWORD)v4) - v154 - v158;
      v27 -= v46;
      v195 = v178 + 1;
      v91 = v178 + 1 >= (unsigned int)(v4 + 5);
      if ( v178 + 1 < (unsigned int)(v4 + 5) )
        v91 = (unsigned int)(v4 + 1) >= v166 + v186 - (v183 - (_DWORD)v4) - v154 - v158 + 5;
      v92 = v91;
      v93 = v92;
      if ( v46 <= 3 )
        v93 = 0;
      if ( (((unsigned __int8)(v178 + 1) | (unsigned __int8)v191) & 3) != 0 )
        v94 = 0;
      else
        v94 = v93 & 1;
      v95 = v94 ^ 1;
      v202 = 4 * v198;
      if ( !v198 )
        v95 |= 1u;
      if ( v95 )
      {
        v109 = v4;
        v108 = v171;
      }
      else
      {
        if ( v198 <= 8 )
        {
          v179 = 0;
          v99 = v154;
        }
        else
        {
          v212 = v27;
          v96 = v4 + 33;
          v97 = 0;
          v209 = v14;
          v211 = v4;
          v98 = v178 + 33;
          v99 = v154;
          do
          {
            v100 = *(_DWORD *)(v98 - 32);
            v101 = v97 + 9;
            v102 = v97 + 8;
            __pld((void *)(v98 + 84));
            v195 = v98;
            v97 += 8;
            *((_DWORD *)v96 - 8) = v100;
            v191 = v96;
            *((_DWORD *)v96 - 7) = *(_DWORD *)(v98 - 28);
            *((_DWORD *)v96 - 6) = *(_DWORD *)(v98 - 24);
            *((_DWORD *)v96 - 5) = *(_DWORD *)(v98 - 20);
            *((_DWORD *)v96 - 4) = *(_DWORD *)(v98 - 16);
            *((_DWORD *)v96 - 3) = *(_DWORD *)(v98 - 12);
            *((_DWORD *)v96 - 2) = *(_DWORD *)(v98 - 8);
            v103 = *(_DWORD *)(v98 - 4);
            v98 += 32;
            *((_DWORD *)v96 - 1) = v103;
            v96 += 32;
          }
          while ( v198 - 7 > v101 );
          v179 = v102;
          v14 = v209;
          v27 = v212;
          v4 = v211;
        }
        v210 = v27;
        v104 = v195 - 4;
        v105 = v191;
        v106 = v179;
        do
        {
          v107 = *(_DWORD *)(v104 + 4);
          v104 += 4;
          ++v106;
          *v105++ = v107;
        }
        while ( v198 > v106 );
        v154 = v99;
        v108 = v171 - v202;
        v27 = v210;
        v155 += v202;
        v109 = &v4[v202];
        if ( v171 == v202 )
        {
LABEL_123:
          v46 = (unsigned int)&v4[v171];
          v192 = &v4[v171];
          if ( v163 >= v27 )
          {
            v4 += v171;
            v155 = (_BYTE *)(v166 - 1);
            goto LABEL_61;
          }
          v27 -= v163;
          v113 = &v4[v207 - v163 + v154 + v158];
          v114 = v113 + 1;
          v115 = (unsigned int)v113 >= v189;
          if ( (unsigned int)v113 < v189 )
            v115 = v166 >= (unsigned int)v114;
          v116 = v163;
          v117 = v115;
          if ( v163 <= 3 )
            v117 = 0;
          if ( (((unsigned __int8)v113 | (unsigned __int8)v166) & 3) != 0 )
            v118 = 0;
          else
            v118 = v117 & 1;
          v119 = v118 ^ 1 | v185;
          if ( v119 )
          {
            v130 = v166 - 1;
            v129 = v192;
          }
          else
          {
            if ( v164 <= 8 )
            {
              v125 = 0;
              v123 = v166;
            }
            else
            {
              v196 = v27;
              v120 = v113 + 8;
              v161 = v14;
              v121 = v166 + 32;
              v172 = v11;
              do
              {
                v122 = *(_DWORD *)(v121 - 32);
                v113 = v120;
                v123 = v121;
                v124 = v119 + 9;
                v125 = v119 + 8;
                __pld((void *)(v121 + 84));
                *(v120 - 8) = v122;
                v120 += 8;
                v126 = *(_DWORD *)(v121 - 28);
                v121 += 32;
                v119 += 8;
                *(v113 - 7) = v126;
                *(v113 - 6) = *(_DWORD *)(v123 - 24);
                *(v113 - 5) = *(_DWORD *)(v123 - 20);
                *(v113 - 4) = *(_DWORD *)(v123 - 16);
                *(v113 - 3) = *(_DWORD *)(v123 - 12);
                *(v113 - 2) = *(_DWORD *)(v123 - 8);
                *(v113 - 1) = *(_DWORD *)(v123 - 4);
              }
              while ( v164 - 7 > v124 );
              v14 = v161;
              v114 = v113 + 1;
              v27 = v196;
              v11 = v172;
            }
            v127 = v123 - 4;
            do
            {
              v128 = *(_DWORD *)(v127 + 4);
              v127 += 4;
              ++v125;
              *v113 = v128;
              v113 = v114++;
            }
            while ( v164 > v125 );
            v129 = &v192[v167];
            if ( v163 == v167 )
              goto LABEL_145;
            v130 = v188;
            v116 = v187;
          }
          v131 = v130 + v116;
          do
          {
            v132 = *(_BYTE *)++v130;
            *++v129 = v132;
          }
          while ( v130 != v131 );
LABEL_145:
          v46 = (unsigned int)v192;
          v4 = &v192[v163];
          v155 = &v192[v163 - v156];
          goto LABEL_61;
        }
      }
      v110 = v155;
      v111 = v109;
      do
      {
        v112 = *++v110;
        *++v111 = v112;
      }
      while ( v110 != &v155[v108] );
      goto LABEL_123;
    }
    v23 = (const char *)(v20 << 25);
    if ( (v20 & 0x40) != 0 )
      break;
    v24 = (unsigned __int8 *)(v11 + 4 * ((v8 & ((1 << v20) - 1)) + v22));
    v20 = *v24;
    v25 = v24[1];
    v22 = *((unsigned __int16 *)v24 + 1);
    v9 -= v25;
    v8 >>= v25;
    if ( !*v24 )
      goto LABEL_72;
  }
  v75 = v20 << 26;
  v157 = v14;
  if ( v75 >= 0 )
    v23 = "invalid literal/length code";
  v73 = v13;
  v74 = a1;
  if ( v75 >= 0 )
  {
    v76 = 29;
    a1[6] = (unsigned int)v23;
  }
  else
  {
    v76 = 11;
  }
  *v73 = v76;
LABEL_84:
  v77 = v9 - 8 * (v9 >> 3);
  v78 = v157 - (v9 >> 3);
  v79 = v4 + 1;
  v80 = v168 - v78;
  v74[3] = (unsigned int)(v4 + 1);
  v81 = v78 + 1;
  v74[1] = v80 + 5;
  result = ((1 << v77) - 1) & v8;
  *v74 = v81;
  if ( (unsigned int)v4 < v165 )
    v81 = v165 - (_DWORD)v4;
  else
    v79 = (_BYTE *)v165;
  if ( (unsigned int)v4 >= v165 )
    v81 = v79 - v4;
  v74[4] = v81 + 257;
  v73[14] = result;
  v73[15] = v77;
  return result;
}
// 5666E: masking with 0x1 was optimized away because r1.1 <= 0x1
// 56986: masking with 0x1 was optimized away because r0.1 <= 0x1
// 56AF4: masking with 0x1 was optimized away because r3.1 <= 0x1
// 56C46: masking with 0x1 was optimized away because r1.1 <= 0x1

//----- (00057026) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_57068 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 5702A: variable 'v2' is possibly undefined

//----- (00057710) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00057788) --------------------------------------------------------
UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)
{
  bool v3; // cf
  UDItype v4; // r4
  unsigned int v5; // r6
  unsigned int v6; // r1
  unsigned int v7; // r6
  char v8; // lr
  char v9; // r7
  UDItype v10; // r8
  UDItype v11; // r2
  unsigned int v12; // r12
  UDItype v13; // r4
  int v14; // off
  int v15; // off
  unsigned int v16; // kr00_4
  unsigned __int64 v17; // r2
  UDItype v18; // r0

  v3 = n >= d;
  v4 = n;
  if ( n < d )
    LODWORD(n) = 0;
  if ( !v3 )
  {
    HIDWORD(n) = 0;
    goto LABEL_16;
  }
  v5 = __clz(HIDWORD(d));
  if ( HIDWORD(d) )
  {
    v6 = __clz(HIDWORD(n));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(n));
  v5 = __clz(d) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = d << v7;
  if ( v4 >= d << v7 )
  {
    LODWORD(n) = 1 << v7;
    HIDWORD(n) = (1 << v8) | (1u >> v9);
    v4 -= v10;
  }
  else
  {
    n = 0LL;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v13 = v4 - v11;
        v14 = (v13 + (unsigned int)v13) >> 32;
        LODWORD(v13) = 2 * v13;
        HIDWORD(v13) += v14;
        v4 = v13 + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v15 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v15;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v16 = v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    v17 = __PAIR64__(HIDWORD(v4) >> v7, v4) << v7;
    v18 = n + __PAIR64__(HIDWORD(v4), v16);
    HIDWORD(v4) >>= v7;
    n = v18 - __PAIR64__(HIDWORD(v17), (_DWORD)v4 << v7);
  }
LABEL_16:
  if ( rp )
    *rp = v4;
  return n;
}

//----- (0005789C) --------------------------------------------------------
void __fastcall init(int argc, unsigned __int8 **argv, unsigned __int8 **envp)
{
  int i; // r4
  void (__fastcall *v4)(); // r3

  init_proc();
  for ( i = 0; i != 1; ++i )
  {
    v4 = (void (__fastcall *)())*(&_frame_dummy_init_array_entry + i);
    v4();
  }
}
// 7CD04: using guessed type void *_frame_dummy_init_array_entry;

//----- (000578E0) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1377 queued=1014 decompiled=1014 lumina nreq=0 worse=0 better=0
// ALL OK, 1014 function(s) have been successfully decompiled
